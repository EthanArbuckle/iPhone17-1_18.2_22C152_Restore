uint64_t _CFLocaleGetNoteCount()
{
  return __noteCount;
}

uint64_t _CFTimeZoneGetNoteCount()
{
  return __noteCount_0;
}

void *_CFPredicatePolicyData()
{
  return &_CFPredicatePolicyData__cfpredicateelements;
}

uint64_t _CFPredicatePolicyData_getFlags()
{
  return _cfprediacateelements_flags;
}

__objc2_class **_CFPredicatePolicyRestrictedClasses()
{
  return &off_1ECF55548;
}

uint64_t _CFCalendarGetMidnightNoteCount()
{
  return __CFMidnightNoteCount;
}

__objc2_class **_CFPredicatePolicyRestrictedSelectors()
{
  return &off_1ECF55570;
}

char *__CFgetenv(char *__s1)
{
  for (uint64_t i = 0; i != 22; i += 2)
  {
    v3 = (&__CFEnv)[i];
    if (v3 && !strcmp(__s1, v3)) {
      return (&__CFEnv)[i + 1];
    }
  }

  return getenv(__s1);
}

uint64_t __CFStringCheckAndReplace(__CFString *theString, unint64_t a2, uint64_t a3, __CFString *a4)
{
  v34[2] = *(void *)off_1ECE0A5B0;
  char v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) == 0) {
    return 1;
  }
  v6 = a4;
  if (!a4) {
    return 2;
  }
  unint64_t v10 = a2 + a3;
  char v11 = atomic_load((unint64_t *)&theString->info);
  uint64_t v12 = v11 & 5;
  char v13 = atomic_load((unint64_t *)&theString->info);
  uint64_t v14 = v13 & 0x60;
  if (v12 == 4)
  {
    p_data = &theString->data;
    if (v14)
    {
      v16 = *p_data;
    }
    else
    {
      uint64_t v18 = atomic_load((unint64_t *)&theString->info);
      v16 = (char *)&p_data[(v18 & 5) != 4];
    }
    unint64_t length = *v16;
  }
  else if ((v13 & 0x60) != 0)
  {
    unint64_t length = theString->length;
  }
  else
  {
    unint64_t length = (unint64_t)theString->data;
  }
  uint64_t result = 3;
  if (v10 >= a2 && v10 <= length)
  {
    if (a4 == theString)
    {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
      v6 = (__CFString *)Copy;
    }
    else
    {
      CFStringRef Copy = 0;
    }
    CFIndex v20 = CFStringGetLength(v6);
    if (v20 < 1)
    {
      BOOL v22 = 0;
    }
    else
    {
      if (CF_IS_OBJC(7uLL, (unint64_t)v6))
      {
        int v21 = [(__CFString *)v6 _encodingCantBeStoredInEightBitCFString];
      }
      else
      {
        unsigned int v23 = atomic_load((unint64_t *)&v6->info);
        int v21 = (v23 >> 4) & 1;
      }
      BOOL v22 = v21 != 0;
    }
    v34[0] = a2;
    v34[1] = a3;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v34, 1, v20, v22);
    char v24 = atomic_load((unint64_t *)&theString->info);
    char v25 = atomic_load((unint64_t *)&theString->info);
    uint64_t v26 = v25 & 0x60;
    v27 = &theString->data;
    if ((v24 & 0x10) == 0)
    {
      if (v26)
      {
        v28 = *v27;
      }
      else
      {
        uint64_t v30 = atomic_load((unint64_t *)&theString->info);
        v28 = (char *)&v27[(v30 & 5) != 4];
      }
      CFStringEncoding v31 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        CFStringEncoding v31 = __CFDefaultEightBitStringEncoding;
      }
      unint64_t v32 = atomic_load((unint64_t *)&theString->info);
      v35.location = 0;
      v35.unint64_t length = v20;
      CFStringGetBytes(v6, v35, v31, 0, 0, (UInt8 *)&v28[a2 + ((v32 >> 2) & 1)], v20, 0);
      goto LABEL_36;
    }
    if (v26)
    {
      v29 = *v27;
      if (!v29) {
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v33 = atomic_load((unint64_t *)&theString->info);
      v29 = (char *)&v27[(v33 & 5) != 4];
      if (!v29)
      {
LABEL_36:
        if (Copy) {
          CFRelease(Copy);
        }
        return 0;
      }
    }
    v36.location = 0;
    v36.unint64_t length = v20;
    CFStringGetCharacters(v6, v36, (UniChar *)&v29[2 * a2]);
    goto LABEL_36;
  }
  return result;
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  v38[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString appendString:appendedString];
    return;
  }
  p_info = &theString->info;
  char v5 = atomic_load((unint64_t *)&theString->info);
  if ((v5 & 1) == 0)
  {
    v6 = _CFOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      CFStringAppend_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    return;
  }
  char v14 = atomic_load((unint64_t *)p_info);
  uint64_t v15 = v14 & 5;
  char v16 = atomic_load((unint64_t *)p_info);
  uint64_t v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_data = &theString->data;
    if (v17)
    {
      v19 = *p_data;
    }
    else
    {
      uint64_t v21 = atomic_load((unint64_t *)&theString->info);
      v19 = (char *)&p_data[(v21 & 5) != 4];
    }
    uint64_t length = *v19;
  }
  else if ((v16 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }
  else
  {
    uint64_t length = (uint64_t)theString->data;
  }
  if (appendedString == theString)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    appendedString = Copy;
  }
  else
  {
    CFStringRef Copy = 0;
  }
  CFIndex v23 = CFStringGetLength(appendedString);
  if (v23 < 1)
  {
    BOOL v25 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (unint64_t)appendedString))
    {
      int v24 = [(__CFString *)(id)appendedString _encodingCantBeStoredInEightBitCFString];
    }
    else
    {
      unsigned int v26 = atomic_load((unint64_t *)&appendedString->info);
      int v24 = (v26 >> 4) & 1;
    }
    BOOL v25 = v24 != 0;
  }
  v38[0] = length;
  v38[1] = 0;
  __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v38, 1, v23, v25);
  char v28 = atomic_load((unint64_t *)&theString->info);
  char v29 = atomic_load((unint64_t *)&theString->info);
  uint64_t v30 = v29 & 0x60;
  CFStringEncoding v31 = &theString->data;
  if ((v28 & 0x10) == 0)
  {
    if (v30)
    {
      unint64_t v32 = *v31;
    }
    else
    {
      uint64_t v34 = atomic_load((unint64_t *)&theString->info);
      unint64_t v32 = (char *)&v31[(v34 & 5) != 4];
    }
    CFStringEncoding v35 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v27);
      CFStringEncoding v35 = __CFDefaultEightBitStringEncoding;
    }
    unint64_t v36 = atomic_load((unint64_t *)&theString->info);
    v40.location = 0;
    v40.uint64_t length = v23;
    CFStringGetBytes(appendedString, v40, v35, 0, 0, (UInt8 *)&v32[length + ((v36 >> 2) & 1)], v23, 0);
    goto LABEL_37;
  }
  if (!v30)
  {
    uint64_t v37 = atomic_load((unint64_t *)&theString->info);
    uint64_t v33 = (char *)&v31[(v37 & 5) != 4];
    if (!v33) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  uint64_t v33 = *v31;
  if (v33)
  {
LABEL_36:
    v41.location = 0;
    v41.uint64_t length = v23;
    CFStringGetCharacters(appendedString, v41, (UniChar *)&v33[2 * length]);
  }
LABEL_37:
  if (Copy)
  {
    CFRelease(Copy);
  }
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  int v10 = isExternalRepresentation;
  unsigned int v11 = lossByte;
  uint64_t v12 = *(void *)&encoding;
  CFIndex length = range.length;
  CFIndex location = range.location;
  v35[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    if (!v11)
    {
      unint64_t v16 = CFStringConvertEncodingToNSStringEncoding(v12);
      unint64_t v17 = v16;
      v34[0] = location;
      v34[1] = length;
      if (((unint64_t)theString & 0x8000000000000000) == 0) {
        goto LABEL_35;
      }
      uint64_t v18 = 0;
      int v19 = *(_DWORD *)off_1ECE0A6F0;
      if ((~(unint64_t)theString & 0xC000000000000007) == 0) {
        LOBYTE(v19) = 0;
      }
      uint64_t v20 = (v19 ^ theString) & 7;
      while (v20 != *((unsigned __int8 *)off_1ECE0A6E0 + v18))
      {
        if (++v18 == 7) {
          goto LABEL_35;
        }
      }
      if (v10
        || !buffer
        || v18 != 2
        || v16 > 5
        || ((1 << v16) & 0x32) == 0
        || (int64_t Bytes = _NSTaggedPointerStringGetBytes((uint64_t)theString, v35), Bytes < length)
        || location > Bytes - length)
      {
LABEL_35:
        if (-[__CFString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]((id)theString, "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:", buffer, maxBufLen, usedBufLen, v17, 2 * (v10 != 0), location, length, v34))return v34[0] - location; {
        else
        }
          return 0;
      }
      if (length >= maxBufLen) {
        CFIndex length = maxBufLen;
      }
      uint64_t v27 = (char *)v35 + location;
      goto LABEL_42;
    }
  }
  else
  {
    char v21 = atomic_load((unint64_t *)&theString->info);
    if ((v21 & 0x10) == 0)
    {
      int v22 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v22 = __CFDefaultEightBitStringEncoding;
      }
      if (v22 == v12) {
        goto LABEL_14;
      }
      if (v22 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v22 = __CFDefaultEightBitStringEncoding;
      }
      if (v22 == 1536)
      {
        switch(BYTE1(v12))
        {
          case 0:
            if (v12 <= 0x22 && ((1 << v12) & 0x600000032) != 0 || v12 == 152) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 1:
            if (v12 != 134217984) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 2:
            if (v12 == 518) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 6:
            if (v12 != 1536) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 8:
          case 0xC:
            goto LABEL_59;
          case 0xA:
            if ((v12 - 2561) > 0xF) {
              goto LABEL_14;
            }
            int v31 = 1 << (v12 - 1);
            int v32 = 32785;
            break;
          case 0xB:
            if ((v12 - 3059) > 0xC) {
              goto LABEL_14;
            }
            int v31 = 1 << (v12 + 13);
            int v32 = 4099;
            break;
          default:
            if (((unsigned __int16)v12 & 0xFF00u) > 0xC00) {
              goto LABEL_59;
            }
            goto LABEL_14;
        }
        if ((v31 & v32) == 0)
        {
LABEL_14:
          char v23 = atomic_load((unint64_t *)&theString->info);
          p_data = &theString->data;
          if ((v23 & 0x60) != 0)
          {
            BOOL v25 = *p_data;
            if (!buffer)
            {
LABEL_43:
              if (usedBufLen) {
                *usedBufLen = length;
              }
              return length;
            }
          }
          else
          {
            char v28 = atomic_load((unint64_t *)&theString->info);
            BOOL v25 = (char *)&p_data[(v28 & 5) != 4];
            if (!buffer) {
              goto LABEL_43;
            }
          }
          if (length >= maxBufLen) {
            CFIndex length = maxBufLen;
          }
          unint64_t v29 = atomic_load((unint64_t *)&theString->info);
          uint64_t v27 = &v25[location + ((v29 >> 2) & 1)];
LABEL_42:
          memmove(buffer, v27, length);
          goto LABEL_43;
        }
      }
    }
  }
LABEL_59:
  v33.CFIndex location = location;
  v33.CFIndex length = length;

  return __CFStringEncodeByteStream(theString, v33, v10, v12, v11, (UniChar *)buffer, maxBufLen, usedBufLen);
}

void __CFStringAppendBytes(unint64_t *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v84 = *(void *)off_1ECE0A5B0;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  if (a4 == 1536) {
    goto LABEL_5;
  }
  int v8 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(a1);
    int v8 = __CFDefaultEightBitStringEncoding;
  }
  if (v8 == a4)
  {
LABEL_5:
    int v9 = 0;
    BOOL v10 = 0;
    int v11 = 0;
    goto LABEL_6;
  }
  if (a4 == 256)
  {
    if (a3 >= 2)
    {
      unint64_t v40 = 0;
      do
      {
        unsigned int v41 = *(unsigned __int16 *)&a2[2 * v40];
        BOOL v10 = v41 < 0x80;
        ++v40;
      }
      while (v41 <= 0x7F && v40 < a3 >> 1);
    }
    else
    {
      BOOL v10 = 1;
    }
    int v9 = 0;
    int v11 = !v10;
    a3 >>= 1;
LABEL_6:
    if (CF_IS_OBJC(7uLL, (unint64_t)a1))
    {
      if (v10 | v11) {
        [a1 appendCharacters:a2 length:a3];
      }
      else {
        [a1 _cfAppendCString:a2 length:a3];
      }
      return;
    }
    char v12 = atomic_load(a1 + 1);
    uint64_t v13 = v12 & 5;
    char v14 = atomic_load(a1 + 1);
    uint64_t v15 = v14 & 0x60;
    if (v13 == 4)
    {
      unint64_t v16 = (unsigned __int8 ***)(a1 + 2);
      if (v15)
      {
        unint64_t v17 = *v16;
      }
      else
      {
        uint64_t v23 = atomic_load(a1 + 1);
        unint64_t v17 = (unsigned __int8 **)&v16[(v23 & 5) != 4];
      }
      unint64_t v18 = *(unsigned __int8 *)v17;
      if (v11) {
        goto LABEL_30;
      }
LABEL_32:
      unint64_t v25 = atomic_load(a1 + 1);
      uint64_t v24 = (v25 >> 4) & 1;
LABEL_33:
      v51[0] = v18;
      v51[1] = 0;
      __CFStringChangeSizeMultiple((uint64_t)a1, (uint64_t)v51, 1, a3, v24);
      unsigned int v26 = a1 + 1;
      char v27 = atomic_load(a1 + 1);
      if ((v27 & 0x10) != 0)
      {
        char v32 = atomic_load(v26);
        CFRange v33 = a1 + 2;
        if ((v32 & 0x60) != 0)
        {
          uint64_t v34 = (void *)*v33;
        }
        else
        {
          char v36 = atomic_load(a1 + 1);
          uint64_t v34 = &v33[(v36 & 5) != 4];
        }
        if (!v11)
        {
          __CFStrConvertBytesToUnicode(a2, (_WORD *)v34 + v18, a3);
          goto LABEL_60;
        }
        size_t v37 = 2 * a3;
        v38 = (char *)v34 + 2 * v18;
        v39 = a2;
      }
      else
      {
        char v28 = atomic_load(v26);
        uint64_t v29 = v28 & 0x60;
        uint64_t v30 = a1 + 2;
        if (v10)
        {
          if (v29)
          {
            int v31 = (void *)*v30;
          }
          else
          {
            uint64_t v43 = atomic_load(a1 + 1);
            int v31 = &v30[(v43 & 5) != 4];
          }
          unint64_t v44 = atomic_load(a1 + 1);
          if ((uint64_t)a3 >= 1)
          {
            v45 = (unsigned __int8 *)v31 + v18 + ((v44 >> 2) & 1);
            v46 = a2;
            do
            {
              unsigned __int8 v47 = *v46;
              v46 += 2;
              *v45++ = v47;
              --a3;
            }
            while (a3);
          }
          goto LABEL_60;
        }
        if (v29)
        {
          CFStringEncoding v35 = (void *)*v30;
        }
        else
        {
          uint64_t v48 = atomic_load(a1 + 1);
          CFStringEncoding v35 = &v30[(v48 & 5) != 4];
        }
        unint64_t v49 = atomic_load(a1 + 1);
        v38 = (char *)v35 + v18 + ((v49 >> 2) & 1);
        v39 = a2;
        size_t v37 = a3;
      }
      memmove(v38, v39, v37);
LABEL_60:
      if (v9)
      {
        CFAllocatorRef v50 = (const __CFAllocator *)_CFGetTSD(1u);
        if (!v50) {
          CFAllocatorRef v50 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
        }
        CFAllocatorDeallocate(v50, a2);
      }
      return;
    }
    if ((v14 & 0x60) != 0)
    {
      unint64_t v18 = a1[3];
      if ((v11 & 1) == 0) {
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v18 = a1[2];
      if ((v11 & 1) == 0) {
        goto LABEL_32;
      }
    }
LABEL_30:
    LODWORD(v24) = 1;
    goto LABEL_33;
  }
  LOBYTE(v51[0]) = 0;
  uint64_t v19 = _CFGetTSD(1u);
  uint64_t v20 = &__kCFAllocatorSystemDefault;
  if (v19) {
    uint64_t v20 = (__objc2_class **)v19;
  }
  *(void *)&long long v53 = v20;
  *(void *)&long long v52 = 0;
  unsigned int v21 = atomic_load(a1 + 1);
  if (__CFStringDecodeByteStream3((char *)a2, a3, a4, (v21 >> 4) & 1, (uint64_t)&v52, v51, 0))
  {
    BOOL v10 = 0;
    a3 = *((void *)&v53 + 1);
    int v11 = BYTE8(v52) == 0;
    a2 = (unsigned __int8 *)v52;
    if (LOBYTE(v51[0])) {
      BOOL v22 = 1;
    }
    else {
      BOOL v22 = BYTE9(v52) == 0;
    }
    int v9 = !v22;
    goto LABEL_6;
  }
}

void __CFStringChangeSizeMultiple(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = a1;
  uint64_t v143 = *(void *)off_1ECE0A5B0;
  char v6 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v7 = (uint64_t *)(a1 + 16);
  if ((v6 & 0x60) != 0)
  {
    int v8 = (uint64_t *)*v7;
    if (*v7) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  int v8 = &v7[(v11 & 5) != 4];
  if (!v8) {
    goto LABEL_6;
  }
LABEL_3:
  char v9 = atomic_load((unint64_t *)(a1 + 8));
  if ((v9 & 5) == 4)
  {
    uint64_t v10 = *(unsigned __int8 *)v8;
  }
  else
  {
    char v12 = atomic_load((unint64_t *)(a1 + 8));
    if ((v12 & 0x60) != 0) {
      uint64_t v10 = *(void *)(a1 + 24);
    }
    else {
      uint64_t v10 = *v7;
    }
  }
LABEL_10:
  if (a3 == 1)
  {
    int64_t v13 = v10 + a4 - *(void *)(a2 + 8);
  }
  else
  {
    int64_t v13 = v10 + a4 * a3;
    if (a3 >= 1)
    {
      char v14 = (uint64_t *)(a2 + 8);
      uint64_t v15 = a3;
      do
      {
        uint64_t v16 = *v14;
        v14 += 2;
        v13 -= v16;
        --v15;
      }
      while (v15);
    }
  }
  if (v13)
  {
    uint64_t v136 = v10;
    uint64_t v139 = a2;
    uint64_t v17 = 0;
    unint64_t v18 = atomic_load((unint64_t *)(a1 + 8));
    unsigned int v19 = 1;
    uint64_t v141 = 2;
    LODWORD(v20) = 1;
    uint64_t v21 = 0;
    if (!a5 && (v18 & 0x10) == 0)
    {
      unint64_t v22 = *(void *)(a1 + 40);
      uint64_t v20 = (v22 >> 2) & 1;
      if ((v22 & 4) != 0)
      {
        uint64_t v17 = 0;
        uint64_t v21 = 0;
        unsigned int v19 = 1;
        uint64_t v23 = 2;
      }
      else
      {
        unsigned int v19 = 0;
        uint64_t v21 = 2;
        uint64_t v17 = 1;
        uint64_t v23 = 1;
      }
      uint64_t v141 = v23;
    }
    int v132 = v20;
    uint64_t v140 = a3;
    v137 = (char *)v8;
    uint64_t v29 = *(void *)(a1 + 32);
    uint64_t v30 = v29;
    if (v13 > (v21 ^ 0x7FFFFFFFFFFFFFFFuLL) >> v19) {
      __CFStringHandleOutOfMemory();
    }
    uint64_t v135 = v19;
    unint64_t v31 = (v13 << v19) + v21;
    uint64_t v32 = *(void *)(a1 + 32);
    unint64_t v33 = v29 | v31;
    if (v29 | v31)
    {
      if (v29 < v31
        || (v29 >= 0 ? (uint64_t v34 = *(void *)(a1 + 32)) : (uint64_t v34 = v29 + 1),
            (uint64_t v32 = *(void *)(a1 + 32), (*(unsigned char *)(a1 + 40) & 8) == 0) && (uint64_t v32 = *(void *)(a1 + 32), v34 >> 1 > v31)))
      {
        if ((v31 & 0x8000000000000000) != 0) {
          goto LABEL_118;
        }
        unint64_t v35 = *(void *)(a1 + 40);
        unint64_t v36 = (v35 >> 4) * v141;
        if (v36 <= v31) {
          uint64_t v37 = v31;
        }
        else {
          uint64_t v37 = (v35 >> 4) * v141;
        }
        if ((v35 & 2) != 0) {
          unint64_t v38 = v37;
        }
        else {
          unint64_t v38 = (3 * v31 + 1) >> 1;
        }
        if ((3 * v31 + 1) >> 1 >= v36) {
          size_t v39 = v38;
        }
        else {
          size_t v39 = v36;
        }
        char v40 = atomic_load((unint64_t *)(a1 + 8));
        if ((~v40 & 0x60) != 0) {
          uint64_t PreferredSizeForSize = malloc_good_size(v39);
        }
        else {
          uint64_t PreferredSizeForSize = CFAllocatorGetPreferredSizeForSize(*(CFAllocatorRef *)(a1 + 48), v39, 0);
        }
        if (PreferredSizeForSize < 0) {
          uint64_t v32 = -1;
        }
        else {
          uint64_t v32 = PreferredSizeForSize;
        }
        uint64_t v29 = v30;
      }
    }
    if (v32 != -1)
    {
      unint64_t v134 = (v18 & 0x10) >> 4;
      if (v137 && v32 == v29 && (!v135 || v136 < 1 || (v18 & 0x10) != 0))
      {
        int v46 = 0;
        unsigned int v47 = atomic_load((unint64_t *)(v5 + 8));
        unsigned int v48 = (v47 >> 2) & 1;
        unint64_t v49 = v137;
        CFAllocatorRef v50 = (unsigned __int8 *)&v137[v17];
        MutableContents = v137;
        int v52 = (v18 & 0x10) >> 4;
        uint64_t v51 = v135;
        goto LABEL_127;
      }
      MutableContents = (unsigned char *)__CFStrAllocateMutableContents(v5, v32);
      if (MutableContents)
      {
LABEL_126:
        unsigned int v73 = atomic_load((unint64_t *)(v5 + 8));
        unsigned int v48 = (v73 >> 2) & 1;
        CFAllocatorRef v50 = &MutableContents[v17];
        int v46 = 1;
        uint64_t v29 = v32;
        unint64_t v49 = v137;
        int v52 = (v18 & 0x10) >> 4;
        uint64_t v51 = v135;
        if (!v137)
        {
LABEL_138:
          if (v51)
          {
            if (!v52)
            {
              unint64_t v82 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v83 = v82;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v83, v82 | 0x10);
                BOOL v25 = v83 == v82;
                unint64_t v82 = v83;
              }
              while (!v25);
            }
            if (v48)
            {
              unint64_t v84 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v85 = v84;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v85, v84 & 0xFFFFFFFFFFFFFFFBLL);
                BOOL v25 = v85 == v84;
                unint64_t v84 = v85;
              }
              while (!v25);
              unint64_t v86 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v87 = v86;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v87, v86 & 0xFFFFFFFFFFFFFFF7);
                BOOL v25 = v87 == v86;
                unint64_t v86 = v87;
              }
              while (!v25);
            }
          }
          else
          {
            v50[v13] = 0;
            if (v13 <= 255) {
              char v88 = v13;
            }
            else {
              char v88 = 0;
            }
            unsigned char *MutableContents = v88;
            if (!v48)
            {
              unint64_t v89 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v90 = v89;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v90, v89 | 4);
                BOOL v25 = v90 == v89;
                unint64_t v89 = v90;
              }
              while (!v25);
              unint64_t v91 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v92 = v91;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v92, v91 | 8);
                BOOL v25 = v92 == v91;
                unint64_t v91 = v92;
              }
              while (!v25);
            }
            if (v52)
            {
              unint64_t v93 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v94 = v93;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v94, v93 & 0xFFFFFFFFFFFFFFEFLL);
                BOOL v25 = v94 == v93;
                unint64_t v93 = v94;
              }
              while (!v25);
            }
          }
          char v95 = atomic_load((unint64_t *)(v5 + 8));
          BOOL v25 = (v95 & 0x60) == 0;
          uint64_t v96 = 24;
          if (v25) {
            uint64_t v96 = 16;
          }
          *(void *)(v5 + v96) = v13;
          if (v46)
          {
            unint64_t v97 = *(void *)(v5 + 40) & 0xFFFFFFFFFFFFFFF7;
            *(void *)(v5 + 32) = v29;
            *(void *)(v5 + 40) = v97;
            *(void *)(v5 + 16) = MutableContents;
          }
          return;
        }
LABEL_127:
        v130 = MutableContents;
        uint64_t v131 = v29;
        long long v74 = (unsigned __int8 *)&v49[v48];
        if (v132 == v52)
        {
          uint64_t v75 = v140;
          if (v50 == v74)
          {
            if (v140 >= 1)
            {
              unsigned int v127 = v48;
              int v128 = v46;
              uint64_t v98 = 0;
              uint64_t v99 = 0;
              int v129 = 0;
              uint64_t v100 = 0;
              p_char ptr = &ptr;
              uint64_t v102 = 10;
              uint64_t v103 = v141;
              uint64_t v133 = v5;
              do
              {
                v104 = (void *)(v139 + 16 * v99);
                uint64_t v105 = v104[1];
                uint64_t v106 = v105 + *v104;
                if (v75 - v99 == 1)
                {
                  size_t v107 = (v136 - v106) * v103;
                  if (!v107) {
                    break;
                  }
                }
                else
                {
                  size_t v107 = (v104[2] - v106) * v103;
                }
                uint64_t v108 = v106 * v103;
                v98 += (a4 - v105) * v103;
                if (v98 <= 0)
                {
                  if (v98) {
                    BOOL v111 = v107 == 0;
                  }
                  else {
                    BOOL v111 = 1;
                  }
                  if (!v111)
                  {
                    v112 = p_ptr;
                    memmove(&v50[v98 + v108], &v50[v108], v107);
                    p_char ptr = v112;
                    uint64_t v5 = v133;
                  }
                  if (v100 < 1)
                  {
                    uint64_t v75 = v140;
                  }
                  else
                  {
                    unint64_t v113 = v100 + 1;
                    v114 = p_ptr;
                    v115 = &p_ptr[24 * v100 - 8];
                    uint64_t v75 = v140;
                    do
                    {
                      size_t v116 = *((void *)v115 - 1);
                      if (*(void *)v115) {
                        BOOL v117 = v116 == 0;
                      }
                      else {
                        BOOL v117 = 1;
                      }
                      if (!v117) {
                        memmove(&v50[*((void *)v115 - 2) + *(void *)v115], &v50[*((void *)v115 - 2)], v116);
                      }
                      --v113;
                      v115 -= 24;
                    }
                    while (v113 > 1);
                    uint64_t v100 = 0;
                    uint64_t v103 = v141;
                    p_char ptr = v114;
                    uint64_t v5 = v133;
                  }
                }
                else
                {
                  if (v100 == v102)
                  {
                    v109 = p_ptr;
                    uint64_t v110 = 2 * v102 + 8;
                    if (v129)
                    {
                      p_char ptr = (char *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, p_ptr, 24 * v110, 0x1000040504FFAC1, 0, 0);
                    }
                    else
                    {
                      Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 24 * v110, 0x1000040504FFAC1, 0);
                      size_t v119 = 24 * v102;
                      v120 = Typed;
                      memmove(Typed, v109, v119);
                      int v129 = 1;
                      p_char ptr = v120;
                    }
                    uint64_t v5 = v133;
                  }
                  else
                  {
                    uint64_t v110 = v102;
                  }
                  v121 = (uint64_t *)&p_ptr[24 * v100];
                  uint64_t *v121 = v108;
                  v121[1] = v107;
                  v121[2] = v98;
                  ++v100;
                  uint64_t v102 = v110;
                  uint64_t v75 = v140;
                  uint64_t v103 = v141;
                }
                ++v99;
              }
              while (v99 != v75);
              v122 = p_ptr;
              unsigned int v48 = v127;
              if (v100 >= 1)
              {
                unint64_t v123 = v100 + 1;
                v124 = &p_ptr[24 * v100 - 8];
                do
                {
                  size_t v125 = *((void *)v124 - 1);
                  if (*(void *)v124) {
                    BOOL v126 = v125 == 0;
                  }
                  else {
                    BOOL v126 = 1;
                  }
                  if (!v126) {
                    memmove(&v50[*((void *)v124 - 2) + *(void *)v124], &v50[*((void *)v124 - 2)], v125);
                  }
                  --v123;
                  v124 -= 24;
                }
                while (v123 > 1);
              }
              unint64_t v49 = v137;
              int v52 = v134;
              LOBYTE(v51) = v135;
              int v46 = v128;
              if (v129) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v122);
              }
            }
            goto LABEL_133;
          }
          uint64_t v76 = (uint64_t)v50;
          uint64_t v77 = v136;
          uint64_t v78 = (v18 >> 4) & 1;
          uint64_t v79 = v139;
          uint64_t v80 = v140;
        }
        else
        {
          uint64_t v80 = v140;
          if (!v51)
          {
LABEL_133:
            if (v46)
            {
              char v81 = atomic_load((unint64_t *)(v5 + 8));
              if ((v81 & 0x20) != 0) {
                __CFStrDeallocateMutableContents(v5, v49);
              }
              int v46 = 1;
            }
            MutableContents = v130;
            uint64_t v29 = v131;
            goto LABEL_138;
          }
          uint64_t v76 = (uint64_t)v50;
          uint64_t v77 = v136;
          LODWORD(v78) = 1;
          uint64_t v79 = v139;
        }
        copyBlocks(v74, v76, v77, (v18 >> 4) & 1, v78, v79, v80, a4);
        goto LABEL_133;
      }
      if (v33)
      {
        if (v30 < v31
          || (*(unsigned char *)(v5 + 40) & 8) == 0 && (v30 >= 0 ? (uint64_t v72 = v30) : (uint64_t v72 = v30 + 1), v31 < v30 || v72 >> 1 > v31))
        {
          if ((v31 & 0x8000000000000000) != 0) {
            goto LABEL_210;
          }
          if (v31 <= (*(void *)(v5 + 40) >> 4) * v141) {
            size_t v43 = (*(void *)(v5 + 40) >> 4) * v141;
          }
          else {
            size_t v43 = v31;
          }
          char v44 = atomic_load((unint64_t *)(v5 + 8));
          if ((~v44 & 0x60) != 0) {
            uint64_t v45 = malloc_good_size(v43);
          }
          else {
            uint64_t v45 = CFAllocatorGetPreferredSizeForSize(*(CFAllocatorRef *)(v5 + 48), v43, 0);
          }
          if (v45 < 0) {
            uint64_t v30 = -1;
          }
          else {
            uint64_t v30 = v45;
          }
        }
      }
      uint64_t v32 = v30;
      if (v30 != -1)
      {
        MutableContents = (unsigned char *)__CFStrAllocateMutableContents(v5, v30);
        if (!MutableContents) {
          __CFStringHandleOutOfMemory();
        }
        goto LABEL_126;
      }
LABEL_210:
      __CFStringHandleOutOfMemory();
    }
LABEL_118:
    __CFStringHandleOutOfMemory();
  }
  uint64_t v24 = *(void *)(a1 + 32);
  if (v24
    && ((unint64_t)(v24 - 2) <= 0xFFFFFFFFFFFFFFFCLL ? (BOOL v25 = (*(void *)(a1 + 40) & 8) == 0) : (BOOL v25 = 0),
        v25
     && ((size_t v26 = *(void *)(a1 + 40) >> 4, v27 = atomic_load((unint64_t *)(a1 + 8)), (~v27 & 0x60) != 0)
       ? (uint64_t v28 = malloc_good_size(v26))
       : (uint64_t v28 = CFAllocatorGetPreferredSizeForSize(*(CFAllocatorRef *)(a1 + 48), v26, 0)),
         v28 < 0 ? (uint64_t v53 = -1) : (uint64_t v53 = v28),
         v53 != v24)))
  {
    if (v8) {
      __CFStrDeallocateMutableContents(v5, v8);
    }
    *(void *)(v5 + 16) = 0;
    unint64_t v64 = *(void *)(v5 + 40) & 0xFFFFFFFFFFFFFFF7;
    *(void *)(v5 + 32) = 0;
    *(void *)(v5 + 40) = v64;
    unint64_t v65 = atomic_load((unint64_t *)(v5 + 8));
    unint64_t v66 = v65;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v66, v65 & 0xFFFFFFFFFFFFFFFBLL);
      BOOL v25 = v66 == v65;
      unint64_t v65 = v66;
    }
    while (!v25);
    unint64_t v67 = atomic_load((unint64_t *)(v5 + 8));
    unint64_t v68 = v67;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v68, v67 & 0xFFFFFFFFFFFFFFF7);
      BOOL v25 = v68 == v67;
      unint64_t v67 = v68;
    }
    while (!v25);
    if ((*(unsigned char *)(v5 + 40) & 4) == 0)
    {
      unint64_t v69 = atomic_load((unint64_t *)(v5 + 8));
      unint64_t v70 = v69;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v70, v69 & 0xFFFFFFFFFFFFFFEFLL);
        BOOL v25 = v70 == v69;
        unint64_t v69 = v70;
      }
      while (!v25);
    }
  }
  else if ((*(unsigned char *)(v5 + 40) & 4) == 0)
  {
    unint64_t v54 = atomic_load((unint64_t *)(v5 + 8));
    unint64_t v55 = v54;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v55, v54 & 0xFFFFFFFFFFFFFFEFLL);
      BOOL v25 = v55 == v54;
      unint64_t v54 = v55;
    }
    while (!v25);
    if (v24 < 2)
    {
      unint64_t v60 = atomic_load((unint64_t *)(v5 + 8));
      unint64_t v61 = v60;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v61, v60 & 0xFFFFFFFFFFFFFFFBLL);
        BOOL v25 = v61 == v60;
        unint64_t v60 = v61;
      }
      while (!v25);
      unint64_t v62 = atomic_load((unint64_t *)(v5 + 8));
      unint64_t v63 = v62;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v63, v62 & 0xFFFFFFFFFFFFFFF7);
        BOOL v25 = v63 == v62;
        unint64_t v62 = v63;
      }
      while (!v25);
    }
    else
    {
      if (!v8) {
        __CFStringChangeSizeMultiple_cold_1();
      }
      unint64_t v56 = atomic_load((unint64_t *)(v5 + 8));
      unint64_t v57 = v56;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v57, v56 | 4);
        BOOL v25 = v57 == v56;
        unint64_t v56 = v57;
      }
      while (!v25);
      unint64_t v58 = atomic_load((unint64_t *)(v5 + 8));
      unint64_t v59 = v58;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v59, v58 | 8);
        BOOL v25 = v59 == v58;
        unint64_t v58 = v59;
      }
      while (!v25);
      *(_WORD *)int v8 = 0;
    }
  }
  char v71 = atomic_load((unint64_t *)(v5 + 8));
  if ((v71 & 0x60) != 0) {
    *(void *)(v5 + 24) = 0;
  }
  else {
    *uint64_t v7 = 0;
  }
}

unint64_t _NSTaggedPointerStringGetLength(uint64_t a1)
{
  int v1 = *(_DWORD *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    int v1 = 7;
  }
  return ((unint64_t)(v1 ^ a1) >> 3) & 0xF;
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  if (encoding == 134217984)
  {
    *(void *)&encoding = 4;
    goto LABEL_36;
  }
  if (encoding == 1536)
  {
    *(void *)&encoding = 1;
    goto LABEL_36;
  }
  CFStringEncoding v1 = encoding & 0xFFF;
  if (v1 <= 0x4FF)
  {
    if ((encoding & 0xFFF) > 0x200)
    {
      switch(v1)
      {
        case 0x201u:
          *(void *)&encoding = 5;
          goto LABEL_36;
        case 0x202u:
          *(void *)&encoding = 9;
          goto LABEL_36;
        case 0x420u:
          *(void *)&encoding = 8;
          goto LABEL_36;
      }
    }
    else
    {
      if ((encoding & 0xFFF) == 0)
      {
        *(void *)&encoding = 30;
        goto LABEL_36;
      }
      if (v1 == 33)
      {
        *(void *)&encoding = 6;
        goto LABEL_36;
      }
      if (v1 == 256 && encoding == 256)
      {
        *(void *)&encoding = 10;
        goto LABEL_36;
      }
    }
LABEL_26:
    *(void *)&encoding = encoding | 0x80000000;
    goto LABEL_36;
  }
  if ((encoding & 0xFFF) > 0x81F)
  {
    if ((encoding & 0xFFF) > 0xB00)
    {
      if (v1 == 2817)
      {
        *(void *)&encoding = 2;
        goto LABEL_36;
      }
      if (v1 == 3071)
      {
        *(void *)&encoding = 7;
        goto LABEL_36;
      }
    }
    else
    {
      if (v1 == 2080)
      {
        *(void *)&encoding = 21;
        goto LABEL_36;
      }
      if (v1 == 2336)
      {
        *(void *)&encoding = 3;
        goto LABEL_36;
      }
    }
    goto LABEL_26;
  }
  *(void *)&encoding = 12;
  switch(v1)
  {
    case 0x500u:
      break;
    case 0x501u:
      *(void *)&encoding = 15;
      break;
    case 0x502u:
      *(void *)&encoding = 11;
      break;
    case 0x503u:
      *(void *)&encoding = 13;
      break;
    case 0x504u:
      *(void *)&encoding = 14;
      break;
    default:
      goto LABEL_26;
  }
LABEL_36:
  LODWORD(result) = encoding;
  return result;
}

uint64_t __CFStrAllocateMutableContents(uint64_t a1, uint64_t a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v2 & 0x60) != 0)
  {
    if (a1 < 0)
    {
      v3 = &kCFAllocatorSystemDefault;
    }
    else
    {
      char v4 = atomic_load((unint64_t *)(a1 + 8));
      if (v4 < 0) {
        v3 = &kCFAllocatorSystemDefault;
      }
      else {
        v3 = (const CFAllocatorRef *)(a1 - 16);
      }
    }
  }
  else
  {
    v3 = (const CFAllocatorRef *)(a1 + 48);
  }
  uint64_t Typed = CFAllocatorAllocateTyped(*v3, a2, 1802897708, 0);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return Typed;
}

unint64_t _NSTaggedPointerStringGetBytes(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  unint64_t v3 = v2 ^ a1;
  BOOL v4 = (~(v2 ^ a1) & 7) == 0;
  uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  if (v4) {
    uint64_t v5 = 0xFFFFFFFFFFFFFLL;
  }
  unint64_t result = (v3 >> 3) & 0xF;
  unint64_t v7 = (v5 & (v3 >> 3)) >> 4;
  if (result < 8)
  {
    *a2 = v7;
  }
  else
  {
    int v8 = (char *)a2 - 1;
    unint64_t v9 = result;
    if (result >= 0xA)
    {
      do
      {
        v8[v9] = sixBitToCharLookup[v7 & 0x1F];
        v7 >>= 5;
        --v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v8[v9] = sixBitToCharLookup[v7 & 0x3F];
        v7 >>= 6;
        --v9;
      }
      while (v9);
    }
  }
  return result;
}

void cow_cleanup(uint64_t a1, int a2)
{
  uint64_t v2 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  if (a2 == 1) {
    uint64_t v2 = &OBJC_IVAR_____NSDictionaryM_storage;
  }
  uint64_t v3 = a1 + *v2;
  uint64_t v5 = *(void ***)v3;
  unint64_t v4 = *(void *)(v3 + 8);
  uint64_t v6 = LODWORD(__NSDictionarySizes_0[v4 >> 58]);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = v4 & 0x2000000FFFFFFFFLL;
  if (v4 >> 58)
  {
    unint64_t v7 = &v5[v6];
    int v8 = v5;
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v8;
      if ((uint64_t)*v8 >= 1 && v10 != &___NSDictionaryM_DeletedMarker) {

      }
      ++v8;
      --v9;
    }
    while (v9);
    do
    {
      if ((uint64_t)*v7 >= 1) {

      }
      ++v7;
      --v6;
    }
    while (v6);
  }

  free(v5);
}

void _CFRelease(uint64_t cf)
{
  name[32] = *(char **)off_1ECE0A5B0;
  unint64_t v2 = atomic_load((unint64_t *)(cf + 8));
  unint64_t v3 = (v2 >> 8) & 0x3FF;
  if (v3 > 0x47)
  {
    unsigned int v5 = v3 - 72;
    if ((int)v3 - 72 >= dword_1EB1DE0D8 || (uint64_t v6 = __CFRuntimeClassTables[v5 >> 6]) == 0)
    {
      uint64_t v7 = 0;
      if ((v2 & 0x200000) == 0) {
        goto LABEL_7;
      }
LABEL_39:
      _CFRelease_cold_3((char *)name, v7);
    }
    unint64_t v4 = (uint64_t *)(v6 + 8 * (v5 & 0x3F));
  }
  else
  {
    unint64_t v4 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + v3);
  }
  uint64_t v7 = *v4;
  if ((v2 & 0x200000) != 0) {
    goto LABEL_39;
  }
LABEL_7:
  if (!__CFOASafe)
  {
    CFIndex v8 = 0;
    if ((v2 & 0x800000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_91;
  }
  CFIndex v8 = CFGetRetainCount((CFTypeRef)cf);
  if ((v2 & 0x800000) != 0)
  {
LABEL_91:
    __CFCheckCFInfoPACSignature(cf);
    char v44 = *(void (**)(uint64_t, uint64_t))(v7 + 80);
    if (!v44 || (*(unsigned char *)v7 & 8) == 0) {
      _CFRelease_cold_1();
    }
    if (v2 <= 0xFFFEFFFFFFFFFFFFLL) {
      _CFRelease_cold_2();
    }
    v44(-1, cf);
LABEL_95:
    if (__CFOASafe)
    {
      uint64_t v45 = (void (*)(uint64_t, uint64_t, void, CFIndex, void))__CFObjectAllocRecordAllocationFunction;
      if (__CFObjectAllocRecordAllocationFunction)
      {
        v45(29, cf, 0, v8 - 1, 0);
      }
    }
    return;
  }
  while (1)
  {
LABEL_9:
    while (HIWORD(v2) != 1)
    {
      if (!HIWORD(v2)) {
        return;
      }
      unint64_t v9 = v2;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(cf + 8), &v9, v2 - 0x1000000000000);
      BOOL v15 = v9 == v2;
      unint64_t v2 = v9;
      if (v15) {
        goto LABEL_95;
      }
    }
    __CFCheckCFInfoPACSignature(cf);
    if ((*(unsigned char *)v7 & 4) != 0)
    {
      uint64_t v10 = *(void (**)(uint64_t))(v7 + 72);
      if (v10) {
        v10(cf);
      }
    }
    unint64_t v11 = v2;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(cf + 8), &v11, v2 | 0x400000);
    BOOL v15 = v11 == v2;
    unint64_t v2 = v11;
    if (v15)
    {
      char v12 = *(void (**)(uint64_t))(v7 + 32);
      if (v12) {
        v12(cf);
      }
      int64_t v13 = (unint64_t *)(cf + 8);
      unint64_t v14 = atomic_load((unint64_t *)(cf + 8));
      BOOL v15 = v3 == 2 || HIWORD(v14) == 1;
      BOOL v16 = v15;
      if (v15)
      {
        do
        {
          unint64_t v2 = v14;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(cf + 8), &v14, (v14 | 0x200000) - 0x1000000000000);
        }
        while (v14 != v2);
      }
      else
      {
        do
        {
          unint64_t v2 = atomic_load(v13);
          unint64_t v17 = v2;
          atomic_compare_exchange_strong((atomic_ullong *volatile)v13, &v17, v2 & 0xFFFFFFFFFFBFFFFFLL);
        }
        while (v17 != v2);
      }
      if (v16) {
        break;
      }
    }
  }
  if (__CFOASafe && __CFObjectAllocRecordAllocationFunction) {
    __CFObjectAllocRecordAllocationFunction(29, cf, 0, 0, 0);
  }
  if (v3 == 2)
  {
    __CFAllocatorDeallocate((void *)cf);
    return;
  }
  char v18 = atomic_load((unint64_t *)(cf + 8));
  if (v18 < 0)
  {
    CFAllocatorRef v22 = 0;
    BOOL v21 = 1;
    CFAllocatorRef v20 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  else
  {
    unsigned int v19 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
    CFAllocatorRef v20 = (const __CFAllocator *)v19;
    if (&__kCFAllocatorSystemDefault == v19)
    {
      BOOL v21 = 1;
    }
    else if (v19)
    {
      BOOL v21 = 0;
    }
    else
    {
      BOOL v21 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
    }
    if (cf < 0
      || (unint64_t v23 = atomic_load((unint64_t *)(cf + 8)), CF_IS_OBJC((v23 >> 8) & 0x3FF, cf))
      || (unint64_t v24 = atomic_load((unint64_t *)(cf + 8)), (v24 & 0x3FF00) == 0x200))
    {
      CFAllocatorRef v22 = 0;
    }
    else
    {
      char v42 = atomic_load((unint64_t *)(cf + 8));
      if (v42 < 0) {
        size_t v43 = &kCFAllocatorSystemDefault;
      }
      else {
        size_t v43 = (const CFAllocatorRef *)(cf - 16);
      }
      CFAllocatorRef v22 = *v43;
    }
  }
  int v25 = __CFZombieEnabled;
  Class Class = object_getClass((id)cf);
  char v27 = Class;
  if (!v25)
  {
    if (object_getClass(Class)) {
      objc_destructInstance((id)cf);
    }
    goto LABEL_82;
  }
  os_unfair_lock_lock_with_options();
  unint64_t v28 = 0;
  uint64_t v29 = (uint64_t *)&__CFRuntimeBuiltinClassTable;
  uint64_t v30 = __CFRuntimeBuiltinObjCClassTable;
  while (v28 < dword_1EB1DE0D8 + 72)
  {
    int v31 = v28 - 72;
    if (v28 >= 0x48)
    {
      if (v31 >= dword_1EB1DE0D8)
      {
        unint64_t v33 = 0;
      }
      else
      {
        unint64_t v33 = (objc_class *)__CFRuntimeClassTables[(v31 >> 6) + 16];
        if (v33) {
          unint64_t v33 = (objc_class *)*((void *)v33 + (v31 & 0x3F));
        }
      }
      if (v33 != v27 || v31 >= dword_1EB1DE0D8 || (uint64_t v34 = __CFRuntimeClassTables[v31 >> 6]) == 0)
      {
LABEL_67:
        unint64_t v36 = 0;
        goto LABEL_68;
      }
      uint64_t v32 = (uint64_t *)(v34 + 8 * (v31 & 0x3F));
    }
    else
    {
      uint64_t v32 = v29;
      if ((objc_class *)__CFRuntimeBuiltinObjCClassTable[v28] != v27) {
        goto LABEL_67;
      }
    }
    uint64_t v35 = *v32;
    if (!v35) {
      goto LABEL_67;
    }
    unint64_t v36 = *(const char **)(v35 + 8);
LABEL_68:
    ++v28;
    ++v30;
    ++v29;
    if (v36)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
      goto LABEL_75;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
  if (object_getClass(v27)) {
    unint64_t v36 = class_getName(v27);
  }
  else {
    unint64_t v36 = 0;
  }
LABEL_75:
  uint64_t v37 = "$class-unknown$";
  if (v36) {
    uint64_t v37 = v36;
  }
  name[0] = 0;
  asprintf(name, "_NSZombie_%s", v37);
  unint64_t v38 = objc_lookUpClass(name[0]);
  if (!v38)
  {
    size_t v39 = objc_lookUpClass("_NSZombie_");
    unint64_t v38 = objc_duplicateClass(v39, name[0], 0);
  }
  free(name[0]);
  if (object_getClass(v27)) {
    objc_destructInstance((id)cf);
  }
  int v40 = __CFDeallocateZombies;
  object_setClass((id)cf, v38);
  if (v40)
  {
LABEL_82:
    uint64_t v41 = -16;
    if (v21) {
      uint64_t v41 = 0;
    }
    CFAllocatorDeallocate(v20, (void *)(cf + v41));
  }
  if (v22) {
    CFRelease(v22);
  }
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  unint64_t v3 = (malloc_zone_t *)allocator;
  if (!allocator)
  {
    uint64_t v4 = _CFGetTSD(1u);
    if (v4) {
      unint64_t v3 = (malloc_zone_t *)v4;
    }
    else {
      unint64_t v3 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    }
  }
  unint64_t v5 = (unint64_t)v3->reserved1 & ~(unint64_t)off_1ECE0A6D0;
  if (((unint64_t)v3->reserved1 & (unint64_t)off_1ECE0A6D0) != 0) {
    v5 |= (unint64_t)v3->reserved1 & (unint64_t)off_1ECE0A6D0;
  }
  if (v5 != qword_1EB1DDDA0) {
    malloc_zone_free(v3, ptr);
  }
  if (ptr)
  {
    valloc = v3[1].valloc;
    if (valloc)
    {
      try_free_default = v3->try_free_default;
      ((void (*)(void *, void (__cdecl *)(_malloc_zone_t *, void *)))valloc)(ptr, try_free_default);
    }
  }
}

void __CFAllocatorSystemDeallocate(void *ptr, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }

  malloc_zone_free(zone, ptr);
}

uint64_t _CFRuntimeCreateInstance(__objc2_class **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 <= 0x47)
  {
    CFIndex v8 = (uint64_t *)*(&__CFRuntimeBuiltinClassTable + a2);
    if (!v8) {
      return 0;
    }
LABEL_10:
    uint64_t v12 = *v8;
    if ((*v8 & 0x10) != 0) {
      int64_t v13 = &__kCFAllocatorSystemDefault;
    }
    else {
      int64_t v13 = a1;
    }
    if ((v12 & 8) != 0 && !v8[10])
    {
      CFLog(4, @"*** _CFRuntimeCreateInstance() found inconsistent class '%s'.");
      return 0;
    }
    unint64_t v14 = v13;
    if (!v13)
    {
      uint64_t v15 = _CFGetTSD(1u);
      if (v15) {
        unint64_t v14 = (__objc2_class **)v15;
      }
      else {
        unint64_t v14 = &__kCFAllocatorSystemDefault;
      }
    }
    if (&__kCFAllocatorNull == v14) {
      return 0;
    }
    if (&__kCFAllocatorSystemDefault == v14)
    {
      BOOL v17 = 1;
    }
    else if (v14)
    {
      BOOL v17 = 0;
    }
    else
    {
      BOOL v17 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
    }
    if ((*v8 & 0x10) != 0) {
      size_t v18 = v8[11];
    }
    else {
      size_t v18 = 16;
    }
    size_t v19 = (a3 + 16 * !v17 + 31) & 0xFFFFFFFFFFFFFFF0;
    malloc_type_id_t v20 = (403 * (a2 ^ 0xC9DC5)) & 0xFFFFFLL | 0xCF000000;
    if ((*v8 & 0x10) != 0)
    {
      CFAllocatorRef v22 = malloc_default_zone();
      BOOL v21 = (unint64_t *)malloc_type_zone_memalign(v22, v18, v19, v20);
    }
    else
    {
      if (!__CFAllocatorRespectsHintZeroWhenAllocating(v13))
      {
        uint64_t Typed = (unint64_t *)CFAllocatorAllocateTyped(v13, v19, v20, 0);
        BOOL v16 = Typed;
        if (!Typed) {
          return (uint64_t)v16;
        }
        bzero(Typed, v19);
        goto LABEL_36;
      }
      BOOL v21 = (unint64_t *)CFAllocatorAllocateTyped(v13, v19, v20, 1);
    }
    BOOL v16 = v21;
    if (!v21) {
      return (uint64_t)v16;
    }
LABEL_36:
    if (a4 && __CFOASafe)
    {
      unint64_t v23 = __CFObjectAllocSetLastAllocEventNameFunction;
      if (!__CFObjectAllocSetLastAllocEventNameFunction) {
        goto LABEL_44;
      }
      unint64_t v24 = v16;
      uint64_t v25 = a4;
    }
    else
    {
      if (!__CFOASafe) {
        goto LABEL_44;
      }
      unint64_t v23 = __CFObjectAllocSetLastAllocEventNameFunction;
      if (!__CFObjectAllocSetLastAllocEventNameFunction) {
        goto LABEL_44;
      }
      uint64_t v25 = v8[1];
      unint64_t v24 = v16;
    }
    ((void (*)(unint64_t *, uint64_t))v23)(v24, v25);
LABEL_44:
    if (v17)
    {
      uint64_t v26 = 128;
    }
    else
    {
      CFTypeRef v27 = CFRetain(v14);
      uint64_t v26 = 0;
      unint64_t *v16 = (unint64_t)v27;
      v16 += 2;
    }
    uint64_t v28 = v26 | (a2 << 8);
    uint64_t v29 = v16 + 1;
    uint64_t v30 = -8388608;
    if ((v12 & 8) == 0) {
      uint64_t v30 = 0x1000000000000;
    }
    atomic_store(v28 | v30, v29);
    atomic_fetch_and((atomic_ullong *volatile)v29, 0xFFFF000000FFFFFFLL);
    unint64_t v31 = atomic_load(v29);
    atomic_fetch_or((atomic_ullong *volatile)v29, ((v31 & 0x83FF00) >> 16) & 0xFFFFFF000000);
    unint64_t *v16 = 0;
    if (a2 > 0x47)
    {
      int v33 = a2 - 72;
      if ((int)a2 - 72 >= dword_1EB1DE0D8 || (uint64_t v34 = __CFRuntimeClassTables[(v33 >> 6) + 16]) == 0)
      {
        uint64_t v35 = 0;
LABEL_56:
        object_setClass(v16, v35);
        unint64_t v36 = (void (*)(unint64_t *))v8[2];
        if (v36) {
          v36(v16);
        }
        return (uint64_t)v16;
      }
      uint64_t v32 = (objc_class **)(v34 + 8 * (v33 & 0x3F));
    }
    else
    {
      uint64_t v32 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
    }
    uint64_t v35 = *v32;
    goto LABEL_56;
  }
  uint64_t result = os_unfair_lock_lock_with_options();
  if (dword_1EB1DE0D8 + 72 > a2)
  {
    int v10 = a2 - 72;
    if ((int)a2 - 72 < dword_1EB1DE0D8 && (uint64_t v11 = __CFRuntimeClassTables[v10 >> 6]) != 0) {
      CFIndex v8 = *(uint64_t **)(v11 + 8 * (v10 & 0x3F));
    }
    else {
      CFIndex v8 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
    if (!v8) {
      return 0;
    }
    goto LABEL_10;
  }
  __break(1u);
  return result;
}

void *_CFAllocatorAllocateImpl(malloc_zone_t *a1, size_t size, malloc_type_id_t type_id, uint64_t a4)
{
  if (a1)
  {
    if (!size) {
      return 0;
    }
  }
  else
  {
    a1 = (malloc_zone_t *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    }
    if (!size) {
      return 0;
    }
  }
  unint64_t v7 = (unint64_t)a1->reserved1 & ~(unint64_t)off_1ECE0A6D0;
  if (((unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0) != 0) {
    v7 |= (unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0;
  }
  if (v7 == qword_1EB1DDDA0)
  {
    realloc = a1[1].realloc;
    if (realloc)
    {
      try_free_default = a1->try_free_default;
      return (void *)((uint64_t (*)(size_t, malloc_type_id_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))realloc)(size, type_id, a4, try_free_default);
    }
    else
    {
      malloc = a1[1].malloc;
      if (!malloc) {
        return 0;
      }
      uint64_t v12 = a1->try_free_default;
      return (void *)((uint64_t (*)(size_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))malloc)(size, a4, v12);
    }
  }
  else
  {
    return malloc_type_zone_malloc(a1, size, type_id);
  }
}

void *__CFAllocatorSystemAllocateTyped(size_t size, malloc_type_id_t type_id, uint64_t a3, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }
  if (a3 == 1)
  {
    return malloc_type_zone_calloc(zone, 1uLL, size, type_id);
  }
  else
  {
    return malloc_type_zone_malloc(zone, size, type_id);
  }
}

CFTypeRef __CFStringCreateImmutableFunnel3(__objc2_class **Default, int8x16_t *ptr, int64_t a3, uint64_t a4, unsigned int a5, __objc2_class **a6, uint64_t a7)
{
  uint64_t v95 = *(void *)off_1ECE0A5B0;
  uint64_t v7 = (a5 >> 2) & 1;
  BOOL v90 = (a5 & 0x30) != 0;
  uint64_t v8 = a3 - v7;
  if (a3 < v7)
  {
    if (dyld_program_sdk_at_least()) {
      __CFStringCreateImmutableFunnel3_cold_1();
    }
    return 0;
  }
  size_t v13 = a3;
  uint64_t v15 = Default;
  int v86 = a5 & 0x30;
  memset(v94, 0, 480);
  long long v92 = 0u;
  *(_OWORD *)unint64_t v93 = 0u;
  if (!Default)
  {
    Default = (__objc2_class **)_CFGetTSD(1u);
    if (Default) {
      uint64_t v15 = Default;
    }
    else {
      uint64_t v15 = &__kCFAllocatorSystemDefault;
    }
  }
  BOOL v16 = v15;
  if (a6 != (__objc2_class **)-1)
  {
    if (a6)
    {
      BOOL v16 = a6;
    }
    else
    {
      Default = (__objc2_class **)_CFGetTSD(1u);
      BOOL v16 = &__kCFAllocatorSystemDefault;
      if (Default) {
        BOOL v16 = Default;
      }
    }
  }
  CFAllocatorRef allocator = (const __CFAllocator *)v16;
  if (!v13)
  {
    if (&__kCFAllocatorSystemDefault == v15
      || !v15 && (Default = (__objc2_class **)CFAllocatorGetDefault(), &__kCFAllocatorSystemDefault == Default))
    {
      if (v86 && allocator != (const __CFAllocator *)&__kCFAllocatorNull) {
        CFAllocatorDeallocate(allocator, ptr);
      }
      return CFRetain(&stru_1ECE10768);
    }
  }
  int v17 = 0;
  unsigned int v88 = (a5 >> 3) & 1;
  BYTE9(v92) = 0;
  if (a4 != 256)
  {
    int v18 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(Default);
      int v18 = __CFDefaultEightBitStringEncoding;
    }
    if (a4 == 1536 || v18 != a4)
    {
      int v17 = 0;
      switch(BYTE1(a4))
      {
        case 0:
          int v17 = 0;
          if ((a4 > 0x22 || ((1 << a4) & 0x600000032) == 0) && a4 != 152) {
            goto LABEL_46;
          }
          goto LABEL_50;
        case 1:
          if (a4 == 134217984) {
            goto LABEL_46;
          }
          goto LABEL_49;
        case 2:
          if (a4 == 518) {
            goto LABEL_49;
          }
          goto LABEL_46;
        case 6:
          if (a4 != 1536) {
            goto LABEL_49;
          }
          goto LABEL_46;
        case 8:
        case 0xC:
          goto LABEL_50;
        case 0xA:
          if ((a4 - 2561) > 0xF) {
            goto LABEL_46;
          }
          int v20 = 1 << (a4 - 1);
          int v21 = 32785;
          break;
        case 0xB:
          if ((a4 - 3059) > 0xC) {
            goto LABEL_46;
          }
          int v20 = 1 << (a4 + 13);
          int v21 = 4099;
          break;
        default:
          if (((unsigned __int16)a4 & 0xFF00u) > 0xC00) {
            goto LABEL_49;
          }
          goto LABEL_46;
      }
      if ((v20 & v21) != 0)
      {
LABEL_49:
        int v17 = 0;
      }
      else
      {
LABEL_46:
        unint64_t v22 = v13;
        unint64_t v23 = ptr;
        while (v22 > 0x1F)
        {
          int8x16_t v25 = *v23;
          int8x16_t v24 = v23[1];
          v23 += 2;
          int8x16_t v26 = vorrq_s8(v25, v24);
          v22 -= 32;
          if ((*(void *)&vorr_s8(*(int8x8_t *)v26.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)) & 0x8080808080808080) != 0) {
            goto LABEL_49;
          }
        }
        while (v22 > 0xF)
        {
          int v17 = 0;
          uint64_t v34 = v23->i64[0];
          uint64_t v35 = v23->i64[1];
          ++v23;
          v22 -= 16;
          if (((v35 | v34) & 0x8080808080808080) != 0) {
            goto LABEL_50;
          }
        }
        while (v22 > 7)
        {
          int v17 = 0;
          uint64_t v36 = v23->i64[0];
          unint64_t v23 = (int8x16_t *)((char *)v23 + 8);
          v22 -= 8;
          if ((v36 & 0x8080808080808080) != 0) {
            goto LABEL_50;
          }
        }
        while (v22 > 3)
        {
          int v17 = 0;
          __int32 v37 = v23->i32[0];
          unint64_t v23 = (int8x16_t *)((char *)v23 + 4);
          v22 -= 4;
          if ((v37 & 0x80808080) != 0) {
            goto LABEL_50;
          }
        }
        uint64_t v38 = 0;
        do
        {
          int v17 = v22 == v38;
          if (v22 == v38) {
            break;
          }
          int v39 = v23->i8[v38++];
        }
        while ((v39 & 0x80000000) == 0);
      }
    }
    else
    {
      int v17 = 1;
    }
  }
LABEL_50:
  BOOL v27 = (a5 & 1) == 0;
  if (a4 != 256) {
    BOOL v27 = v17;
  }
  if (!v27)
  {
    LOBYTE(v91) = 0;
    v93[0] = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    *(void *)&long long v92 = 0;
    if (!__CFStringDecodeByteStream3(&ptr->i8[v7], v8, a4, 0, (uint64_t)&v92, &v91, a7)) {
      return 0;
    }
    int v17 = BYTE8(v92);
    if (BYTE8(v92)) {
      LODWORD(a4) = 1536;
    }
    else {
      LODWORD(a4) = 256;
    }
    if (!(_BYTE)v91)
    {
      size_t v13 = (uint64_t)v93[1] << (BYTE8(v92) == 0);
      if (v86 && allocator != (const __CFAllocator *)&__kCFAllocatorNull) {
        CFAllocatorDeallocate(allocator, ptr);
      }
      if (BYTE9(v92) && v15 == (__objc2_class **)v93[0] && !v17)
      {
        BYTE9(v92) = 0;
        char ptr = (int8x16_t *)__CFSafelyReallocateWithAllocatorTyped(v15, v92, v13, 1283844863, 0, 0);
        LODWORD(v7) = 0;
        unsigned int v88 = 0;
        BOOL v90 = 1;
      }
      else
      {
        LODWORD(v7) = 0;
        unsigned int v88 = 0;
        BOOL v90 = 0;
        char ptr = (int8x16_t *)v92;
      }
      CFAllocatorRef allocator = (const __CFAllocator *)v15;
    }
    goto LABEL_108;
  }
  if (a4 == 256 && (a5 & 2) != 0)
  {
    unint64_t v28 = v13 >> 1;
    if (v13 >= 2)
    {
      uint64_t v29 = 0;
      if (v28 <= 1) {
        uint64_t v30 = 1;
      }
      else {
        uint64_t v30 = v13 >> 1;
      }
      while (ptr->u16[v29] <= 0x7Fu)
      {
        if (v30 == ++v29) {
          goto LABEL_61;
        }
      }
      LODWORD(a4) = 256;
      goto LABEL_108;
    }
LABEL_61:
    a4 = v13 < 0x200;
    if (v13 >= 0x200) {
      size_t v31 = v13 >> 1;
    }
    else {
      size_t v31 = v28 + 1;
    }
    unint64_t v32 = v31 + 1;
    if (v31 + 1 < 0x3F0)
    {
      uint64_t Typed = (int8x16_t *)v94;
    }
    else
    {
      uint64_t Typed = (int8x16_t *)CFAllocatorAllocateTyped(v15, v31 + 1, 1908973194, 0);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      if (!Typed)
      {
        LODWORD(a4) = 256;
        size_t v13 = v32;
        goto LABEL_108;
      }
    }
    int v40 = Typed;
    if (v13 > 0x1FF || (Typed->i8[0] = v28, int v40 = (int8x16_t *)&Typed->i8[1], v13 >= 2))
    {
      uint64_t v41 = 0;
      if (v28 <= 1) {
        uint64_t v42 = 1;
      }
      else {
        uint64_t v42 = v13 >> 1;
      }
      do
      {
        v40->i8[v41] = ptr->i16[v41];
        ++v41;
      }
      while (v42 != v41);
    }
    v40->i8[v28] = 0;
    if (v86 && allocator != (const __CFAllocator *)&__kCFAllocatorNull) {
      CFAllocatorDeallocate(allocator, ptr);
    }
    BOOL v90 = v32 > 0x3EF;
    size_t v13 = v28 + a4;
    size_t v43 = &Typed->u8[a4];
    LODWORD(v7) = a4;
    LODWORD(a4) = 1536;
    unsigned int v88 = 1;
    CFAllocatorRef allocator = (const __CFAllocator *)v15;
    BOOL v87 = v7;
    goto LABEL_110;
  }
LABEL_108:
  BOOL v87 = v7 != 0;
  unint64_t v28 = v13 - v7;
  if (!v17) {
    goto LABEL_140;
  }
  size_t v43 = &ptr->u8[v7];
  uint64_t Typed = ptr;
LABEL_110:
  if (!__CFTaggedStringClass)
  {
LABEL_132:
    if ((a5 & 0x20) == 0)
    {
      BOOL v54 = v90;
      if (__CFStringCreateImmutableFunnel3_onceToken != -1)
      {
        unint64_t v85 = v43;
        dispatch_once(&__CFStringCreateImmutableFunnel3_onceToken, &__block_literal_global_18);
        size_t v43 = v85;
      }
      unint64_t v55 = (__objc2_class **)allocator;
      if (!__CFStringCreateImmutableFunnel3_sDisableStringROM)
      {
        unint64_t v60 = __CFSearchStringROM(v43, v28);
        if (v60)
        {
          unint64_t v61 = v60;
          if (v90 && allocator != (const __CFAllocator *)&__kCFAllocatorNull) {
            CFAllocatorDeallocate(allocator, Typed);
          }
          unint64_t Instance = (unint64_t)CFRetain(v61);
          goto LABEL_157;
        }
      }
      char ptr = Typed;
      if (!v90) {
        goto LABEL_137;
      }
      goto LABEL_141;
    }
    char ptr = Typed;
LABEL_140:
    unint64_t v55 = (__objc2_class **)allocator;
    BOOL v54 = v90;
    if (!v90)
    {
LABEL_137:
      if (v7)
      {
        LODWORD(v7) = 1;
        size_t v56 = v13;
      }
      else if (a4 == 256 || (uint64_t)v13 > 255)
      {
        LODWORD(v7) = 0;
        size_t v56 = v13 + 8;
      }
      else
      {
        size_t v56 = v13 + 1;
        LODWORD(v7) = 1;
      }
      if (v88) {
        BOOL v62 = 0;
      }
      else {
        BOOL v62 = a4 == 256;
      }
      int v63 = !v62;
      unsigned int v88 = v63;
      if (v62) {
        uint64_t v59 = v56;
      }
      else {
        uint64_t v59 = v56 + 1;
      }
      goto LABEL_168;
    }
LABEL_141:
    BOOL v57 = v55 == &__kCFAllocatorNull || v55 == v15;
    uint64_t v58 = 16;
    if (v57) {
      uint64_t v58 = 8;
    }
    if (v7) {
      uint64_t v59 = v58;
    }
    else {
      uint64_t v59 = v58 + 8;
    }
LABEL_168:
    unint64_t Instance = _CFRuntimeCreateInstance(v15, 7uLL, v59, 0);
    if (!Instance)
    {
      if (v54 && v55 != &__kCFAllocatorNull)
      {
        CFAllocatorDeallocate((CFAllocatorRef)v55, ptr);
        unint64_t Instance = 0;
      }
      goto LABEL_212;
    }
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    uint64_t v64 = 96;
    if (v55 == &__kCFAllocatorNull) {
      uint64_t v64 = 64;
    }
    if (v55 == v15) {
      uint64_t v65 = 32;
    }
    else {
      uint64_t v65 = v64;
    }
    unint64_t v66 = atomic_load((unint64_t *)(Instance + 8));
    if (!v54) {
      uint64_t v65 = 0;
    }
    unint64_t v67 = v66;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v67, v66 & 0xFFFFFFFFFFFFFF9FLL | v65);
      BOOL v57 = v67 == v66;
      unint64_t v66 = v67;
    }
    while (!v57);
    unint64_t v68 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v69 = v68;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v69, v68 & 0xFFFFFFFFFFFFFFEFLL | (16 * (a4 == 256)));
      BOOL v57 = v69 == v68;
      unint64_t v68 = v69;
    }
    while (!v57);
    unint64_t v70 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v71 = v70;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v71, v70 & 0xFFFFFFFFFFFFFFF7 | (8 * v88));
      BOOL v57 = v71 == v70;
      unint64_t v70 = v71;
    }
    while (!v57);
    unint64_t v72 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v73 = v72;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v73, v72 & 0xFFFFFFFFFFFFFFFBLL | (4 * v7));
      BOOL v57 = v73 == v72;
      unint64_t v72 = v73;
    }
    while (!v57);
    if (v7)
    {
      if (v54)
      {
LABEL_192:
        *(void *)(Instance + 16) = ptr;
        char v74 = atomic_load((unint64_t *)(Instance + 8));
        if ((~v74 & 0x60) == 0)
        {
          CFRetain(v55);
          char v75 = atomic_load((unint64_t *)(Instance + 8));
          BOOL v57 = (v75 & 5) == 4;
          uint64_t v76 = 32;
          if (v57) {
            uint64_t v76 = 24;
          }
          *(void *)(Instance + v76) = v55;
        }
        goto LABEL_212;
      }
    }
    else
    {
      char v77 = atomic_load((unint64_t *)(Instance + 8));
      BOOL v57 = (v77 & 0x60) == 0;
      uint64_t v78 = 24;
      if (v57) {
        uint64_t v78 = 16;
      }
      *(void *)(Instance + v78) = v28 >> (a4 == 256);
      if (v54) {
        goto LABEL_192;
      }
    }
    char v79 = atomic_load((unint64_t *)(Instance + 8));
    uint64_t v80 = (unsigned char **)(Instance + 16);
    if ((v79 & 0x60) != 0)
    {
      char v81 = *v80;
    }
    else
    {
      char v82 = atomic_load((unint64_t *)(Instance + 8));
      char v81 = &v80[(v82 & 5) != 4];
    }
    if (v7) {
      char v83 = v87;
    }
    else {
      char v83 = 1;
    }
    if ((v83 & 1) == 0) {
      *v81++ = v13;
    }
    memmove(v81, ptr, v13);
    if (v88) {
      v81[v13] = 0;
    }
    goto LABEL_212;
  }
  if ((uint64_t)v28 > 7)
  {
    if (v28 <= 0xB)
    {
      if (v28 >= 0xA)
      {
        uint64_t v45 = 0;
        unint64_t v50 = v28;
        uint64_t v51 = v43;
        while (1)
        {
          unint64_t v52 = charToSixBitLookup_0[*v51];
          if (v52 > 0x1F) {
            break;
          }
          uint64_t v45 = v52 | (32 * v45);
          ++v51;
          if (!--v50)
          {
LABEL_127:
            unint64_t Instance = (8 * v28) | (v45 << 7) | 0x8000000000000002;
            unint64_t v53 = Instance ^ *(void *)off_1ECE0A6F0;
            if ((~v53 & 0xC000000000000007) != 0)
            {
              unint64_t Instance = v53 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)off_1ECE0A6E0 + (v53 & 7));
              if (!Instance) {
                goto LABEL_132;
              }
            }
            goto LABEL_129;
          }
        }
      }
      else
      {
        uint64_t v45 = 0;
        unint64_t v46 = v28;
        unsigned int v47 = v43;
        while (1)
        {
          unint64_t v48 = charToSixBitLookup_0[*v47];
          if (v48 > 0x3F) {
            break;
          }
          uint64_t v45 = v48 | (v45 << 6);
          ++v47;
          if (!--v46) {
            goto LABEL_127;
          }
        }
      }
    }
    goto LABEL_132;
  }
  uint64_t v91 = 0;
  char v44 = v43;
  __memmove_chk();
  if ((v91 & 0x8080808080808080) != 0)
  {
    size_t v43 = v44;
    goto LABEL_132;
  }
  unint64_t Instance = (8 * v28) | (v91 << 7) | 0x8000000000000002;
  unint64_t v49 = *(void *)off_1ECE0A6F0 ^ Instance;
  if ((~v49 & 0xC000000000000007) != 0) {
    unint64_t Instance = v49 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)off_1ECE0A6E0 + (v49 & 7));
  }
  size_t v43 = v44;
  if (!Instance) {
    goto LABEL_132;
  }
LABEL_129:
  char ptr = 0;
  if (v90 && allocator != (const __CFAllocator *)&__kCFAllocatorNull)
  {
    CFAllocatorDeallocate(allocator, Typed);
LABEL_157:
    char ptr = 0;
  }
LABEL_212:
  if (BYTE9(v92)) {
    CFAllocatorDeallocate(v93[0], ptr);
  }
  return (CFTypeRef)Instance;
}

unint64_t *_CFRetain(unint64_t *cf, int a2)
{
  unint64_t v2 = cf;
  unint64_t v3 = atomic_load(cf + 1);
  if ((v3 & 0x800000) == 0)
  {
    unint64_t v4 = v3;
    while (!a2 || (v4 & 0x600000) == 0)
    {
      if (!HIWORD(v4)) {
        return v2;
      }
      if (HIWORD(v4) == 0xFFFF) {
        v3 &= 0xFFFFFFFFFFFFuLL;
      }
      else {
        unint64_t v3 = v4 + 0x1000000000000;
      }
      unint64_t v5 = v4;
      atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v5, v3);
      BOOL v6 = v5 == v4;
      unint64_t v4 = v5;
      if (v6) {
        goto LABEL_21;
      }
    }
    return 0;
  }
  if (a2) {
    return 0;
  }
  __CFCheckCFInfoPACSignature((uint64_t)cf);
  unint64_t v7 = (v3 >> 8) & 0x3FF;
  if (v7 > 0x47) {
    uint64_t v8 = (_UNKNOWN **)(__CFRuntimeClassTables[(v7 - 72) >> 6] + 8 * ((v7 - 72) & 0x3F));
  }
  else {
    uint64_t v8 = &__CFRuntimeBuiltinClassTable + v7;
  }
  unint64_t v9 = *v8;
  int v10 = (void (*)(uint64_t, unint64_t *))*((void *)*v8 + 10);
  if (!v10 || (*v9 & 8) == 0) {
    _CFRetain_cold_1();
  }
  if (v3 <= 0xFFFEFFFFFFFFFFFFLL) {
    _CFRetain_cold_2();
  }
  v10(1, v2);
LABEL_21:
  if (__CFOASafe)
  {
    CFIndex v12 = CFGetRetainCount(v2);
    if (__CFOASafe)
    {
      if (__CFObjectAllocRecordAllocationFunction) {
        __CFObjectAllocRecordAllocationFunction(28, v2, 0, v12, 0);
      }
    }
  }
  return v2;
}

uint64_t _CFGetTSDCreateIfNeeded(unsigned int a1, int a2)
{
  if (a1 >= 0x46) {
    _CFGetTSDCreateIfNeeded_cold_1(a1);
  }
  unint64_t v4 = __CFTSDGetTable(a2);
  if (v4) {
    return v4[a1 + 1];
  }
  if (a2) {
    _CFLogSimple(4, "Warning: TSD slot %d retrieved but the thread data has already been torn down.", a1);
  }
  return 0;
}

void *__CFTSDGetTable(int a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v2 = *(void **)(StatusReg + 440);
  if (v2 == (void *)4096) {
    return 0;
  }
  if (a1 && !v2)
  {
    unint64_t v2 = malloc_type_calloc(1uLL, 0x468uLL, 0x1080040FF2AA448uLL);
    pthread_key_init_np();
    *(void *)(StatusReg + 440) = v2;
  }
  return v2;
}

uint64_t _CFGetTSD(unsigned int a1)
{
  return _CFGetTSDCreateIfNeeded(a1, 1);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  if (!cf) {
    CFRetain_cold_1();
  }
  CFStringEncoding v1 = (void *)cf;
  if (((unint64_t)cf & 0x8000000000000000) == 0)
  {
    unint64_t v2 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v2 >> 8) & 0x3FF, (unint64_t)cf))
    {
      return v1;
    }
    else
    {
      return _CFRetain((unint64_t *)v1, 0);
    }
  }
  return cf;
}

BOOL __CFAllocatorRespectsHintZeroWhenAllocating(__objc2_class **a1)
{
  return a1 == &__kCFAllocatorSystemDefault || a1 == &__kCFAllocatorMallocZone;
}

uint64_t __CFCheckCFInfoPACSignature(uint64_t result)
{
  unint64_t v1 = atomic_load((unint64_t *)(result + 8));
  unint64_t v2 = atomic_load((unint64_t *)(result + 8));
  if (((v1 ^ ((v2 & 0x83FF00) >> 16)) & 0xFFFFFF000000) != 0) {
    __break(0xC470u);
  }
  return result;
}

__CFString *__CFSearchStringROM(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 > 80) {
    return 0;
  }
  unsigned __int16 v4 = __CFStrHashEightBit2(a1, a2);
  unint64_t v5 = CFStringROMTableHashData[v4];
  if ((v5 & 7) == 0) {
    return 0;
  }
  unint64_t v6 = v5 >> 3;
  unint64_t v7 = (CFStringROMTableHashData[v4] >> 3) + (CFStringROMTableHashData[v4] & 7);
  while (1)
  {
    uint64_t v8 = CFStringROMTable[v6];
    if (v8->length == a2 && !memcmp(a1, v8->data, a2)) {
      break;
    }
    if (++v6 >= v7) {
      return 0;
    }
  }
  return v8;
}

uint64_t __CFStrHashEightBit2(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0;
    uint64_t v3 = a2;
    do
    {
      uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5])
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 2]));
      BOOL v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 3))
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7))
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 1)))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 2)));
      uint64_t v9 = v7 - 16;
      v7 += 4;
    }
    while (v9 < 12);
    int v10 = &a1[a2 - 32];
    do
    {
      uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v10)
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[2]));
      v10 += 4;
    }
    while (v10 < &a1[a2]);
  }
  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      unint64_t v2 = a1;
      unsigned __int16 v4 = a1;
      uint64_t v3 = a2;
    }
    else
    {
      unint64_t v2 = a1;
      uint64_t v3 = a2;
      unsigned __int16 v4 = a1;
      do
      {
        uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[3])
           + 67503105 * v3
           + 257
           * (257
            * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v4)
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[1]))
            + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[2]));
        v4 += 4;
        v2 += 4;
      }
      while (v4 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }
    if (v4 < &a1[a2])
    {
      uint64_t v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        unsigned int v12 = *v4++;
        uint64_t v3 = 257 * v3 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v12);
        --v11;
      }
      while (v11);
    }
  }
  return (v3 << (a2 & 0x1F)) + v3;
}

void __CFStringDeallocate(uint64_t a1)
{
  unint64_t v1 = (unint64_t *)(a1 + 8);
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x60) == 0) {
    return;
  }
  char v4 = atomic_load(v1);
  char v5 = atomic_load(v1);
  if ((v5 & 0x20) == 0) {
    goto LABEL_11;
  }
  char v6 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v7 = (void **)(a1 + 16);
  if ((v6 & 0x60) != 0)
  {
    uint64_t v8 = (void **)*v7;
    if (*v7) {
      goto LABEL_5;
    }
LABEL_11:
    if ((v4 & 1) == 0) {
      return;
    }
    goto LABEL_14;
  }
  char v15 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v8 = &v7[(v15 & 5) != 4];
  if (!v8) {
    goto LABEL_11;
  }
LABEL_5:
  if (v4)
  {
    __CFStrDeallocateMutableContents(a1, v8);
LABEL_14:
    char v16 = atomic_load((unint64_t *)(a1 + 8));
    if ((~v16 & 0x60) != 0) {
      return;
    }
    CFAllocatorRef v14 = *(const __CFAllocator **)(a1 + 48);
    goto LABEL_16;
  }
  char v9 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v9 & 0x60) == 0)
  {
    char v10 = atomic_load((unint64_t *)(a1 + 8));
    BOOL v11 = (v10 & 5) == 4;
    uint64_t v12 = 32;
    if (v11) {
      uint64_t v12 = 24;
    }
    CFAllocatorRef v13 = *(const __CFAllocator **)(a1 + v12);
    CFAllocatorDeallocate(v13, v8);
    CFAllocatorRef v14 = v13;
LABEL_16:
    CFRelease(v14);
    return;
  }
  if (a1 < 0)
  {
    int v17 = &kCFAllocatorSystemDefault;
  }
  else
  {
    char v18 = atomic_load((unint64_t *)(a1 + 8));
    if (v18 < 0) {
      int v17 = &kCFAllocatorSystemDefault;
    }
    else {
      int v17 = (const CFAllocatorRef *)(a1 - 16);
    }
  }
  CFAllocatorRef v19 = *v17;

  CFAllocatorDeallocate(v19, v8);
}

void __CFStrDeallocateMutableContents(uint64_t a1, void *a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v2 & 0x60) != 0)
  {
    if (a1 < 0)
    {
      uint64_t v3 = &kCFAllocatorSystemDefault;
    }
    else
    {
      char v4 = atomic_load((unint64_t *)(a1 + 8));
      if (v4 < 0) {
        uint64_t v3 = &kCFAllocatorSystemDefault;
      }
      else {
        uint64_t v3 = (const CFAllocatorRef *)(a1 - 16);
      }
    }
  }
  else
  {
    uint64_t v3 = (const CFAllocatorRef *)(a1 + 48);
  }
  CFAllocatorRef v5 = *v3;
  char v6 = atomic_load((unint64_t *)(a1 + 8));
  if (v6) {
    atomic_load((unint64_t *)(a1 + 8));
  }
  CFAllocatorDeallocate(v5, a2);
}

void __RELEASE_OBJECTS_IN_THE_ARRAY__(uint64_t a1, int a2)
{
  char v2 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  if (a2 == 1) {
    char v2 = &OBJC_IVAR_____NSArrayM_storage;
  }
  uint64_t v3 = a1 + *v2;
  char v4 = *(id **)v3;
  uint64_t v5 = *(unsigned int *)(v3 + 8);
  unsigned int v6 = *(_DWORD *)(v3 + 12) - v5;
  unsigned int v7 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(v3 + 20) = 0;
  if (v6 >= v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = v6;
  }
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  if (v4)
  {
    if (v8)
    {
      char v9 = &v4[v5];
      uint64_t v10 = v8;
      do
      {
        if (((unint64_t)*v9 & 0x8000000000000000) == 0) {

        }
        ++v9;
        --v10;
      }
      while (v10);
    }
    if (v7 > v6)
    {
      if (v7 - v8 <= 1) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = v7 - v8;
      }
      uint64_t v12 = v4;
      do
      {
        if (((unint64_t)*v12 & 0x8000000000000000) == 0) {

        }
        ++v12;
        --v11;
      }
      while (v11);
    }
    free(v4);
  }
}

void __CFBasicHashDeallocate(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((v1 & 8) != 0)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 24) = *(void *)(a1 + 24);
    *(void *)(a1 + 32) = v1 | 8;
    __CFBasicHashDrain(a1);
  }
}

uint64_t __CFStringDecodeByteStream3(char *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unsigned char *a6, uint64_t a7)
{
  uint64_t v12 = a2;
  v109[1] = *(void *)off_1ECE0A5B0;
  if (a6) {
    *a6 = 0;
  }
  *(void *)(a5 + 24) = 0;
  CFAllocatorRef v14 = (void *)(a5 + 24);
  BOOL v15 = a4 == 0;
  *(unsigned char *)(a5 + 8) = a4 == 0;
  *(unsigned char *)(a5 + 9) = 0;
  if (!a2) {
    return 1;
  }
  char v16 = *(__objc2_class ***)(a5 + 16);
  if (!v16)
  {
    char v16 = (__objc2_class **)_CFGetTSD(1u);
    if (!v16) {
      char v16 = &__kCFAllocatorSystemDefault;
    }
  }
  *(void *)(a5 + 16) = v16;
  if ((int)a3 <= 268435711)
  {
    int v17 = &a1[v12];
    if ((int)a3 <= 134217983)
    {
      if (a3 != 256)
      {
        if (a3 == 3071)
        {
          *(unsigned char *)(a5 + 8) = 0;
          char v18 = *(_WORD **)a5;
          BOOL v20 = (unint64_t)v12 > 0x1F8 || v18 != 0;
          *(unsigned char *)(a5 + 9) = v20;
          if (!v18)
          {
            if ((unint64_t)v12 > 0x1F8)
            {
              uint64_t Typed = CFAllocatorAllocateTyped(v16, 2 * v12, 0x1000040BDFB0063, 0);
              *(void *)a5 = Typed;
              if (!Typed) {
                goto LABEL_204;
              }
              goto LABEL_105;
            }
            char v18 = (_WORD *)(a5 + 32);
          }
          *(void *)a5 = v18;
LABEL_105:
          *CFAllocatorRef v14 = 0;
          if (v12 < 1)
          {
            LOBYTE(v54) = 0;
            goto LABEL_138;
          }
          uint64_t v53 = 0;
          int v54 = 0;
          int v55 = 0;
          while (1)
          {
            unsigned int v57 = *a1++;
            unsigned int v56 = v57;
            if (v54 == 1)
            {
              if ((v56 & 0xFFFFFFDF) == 0x55)
              {
                int v55 = 0;
                int v54 = 2;
              }
              else
              {
                int v55 = v56 - 48;
                if (v56 - 48 > 9)
                {
                  if (v56 != 92) {
                    goto LABEL_137;
                  }
                  int v55 = 92;
LABEL_133:
                  int v54 = 0;
                  uint64_t v59 = *(_WORD **)a5;
                  *(void *)(a5 + 24) = v53 + 1;
                  v59[v53++] = v55;
                  goto LABEL_134;
                }
                int v54 = 7;
              }
            }
            else
            {
              if ((_BYTE)v54)
              {
                unsigned int v58 = v56 - 48;
                if ((char)v54 > 5)
                {
                  if ((v56 - 48) > 9u) {
                    goto LABEL_137;
                  }
                  int v55 = v58 | (8 * v55);
                  if (++v54 == 9) {
                    goto LABEL_133;
                  }
                }
                else
                {
                  if ((v56 - 48) > 9u)
                  {
                    if (v56 > 0x60) {
                      LOBYTE(v56) = v56 - 32;
                    }
                    if ((v56 - 65) > 5u)
                    {
LABEL_137:
                      LOBYTE(v54) = 1;
LABEL_138:
                      BOOL v60 = v54 == 0;
LABEL_139:
                      if (!v60)
                      {
LABEL_204:
                        if (*(unsigned char *)(a5 + 9))
                        {
                          if (*(void *)a5) {
                            CFAllocatorDeallocate(*(CFAllocatorRef *)(a5 + 16), *(void **)a5);
                          }
                        }
                        uint64_t result = 0;
                        *(unsigned char *)(a5 + 8) = v15;
                        *(unsigned char *)(a5 + 9) = 0;
                        *(void *)a5 = 0;
                        *(void *)(a5 + 24) = 0;
                        return result;
                      }
                      return 1;
                    }
                    int v55 = (v56 - 55) | (16 * v55);
                  }
                  else
                  {
                    int v55 = v58 | (16 * v55);
                  }
                  if (++v54 == 6) {
                    goto LABEL_133;
                  }
                }
              }
              else
              {
                if (v56 == 92)
                {
                  int v54 = 1;
                  goto LABEL_134;
                }
                int v55 = v56;
                if ((v56 & 0x80) != 0) {
                  goto LABEL_137;
                }
              }
              if (!(_BYTE)v54) {
                goto LABEL_133;
              }
              if (v54 == 255) {
                goto LABEL_137;
              }
            }
LABEL_134:
            if (a1 >= v17) {
              goto LABEL_138;
            }
          }
        }
        goto LABEL_60;
      }
      goto LABEL_24;
    }
    if (a3 != 134217984)
    {
      int v25 = 201326848;
      goto LABEL_34;
    }
    if (v12 >= 3 && *a1 == 239 && a1[1] == 187 && a1[2] == 191)
    {
      v12 -= 3;
      if (!v12) {
        return 1;
      }
      a1 += 3;
    }
    if (!*(unsigned char *)(a5 + 8))
    {
LABEL_91:
      if (__CFStringDecodeByteStream3_onceToken != -1) {
        dispatch_once(&__CFStringDecodeByteStream3_onceToken, &__block_literal_global_19);
      }
      unint64_t v49 = *(void **)a5;
      BOOL v51 = (unint64_t)v12 > 0x1F8 || v49 != 0;
      *(unsigned char *)(a5 + 9) = v51;
      if (!v49)
      {
        if ((unint64_t)v12 > 0x1F8)
        {
          uint64_t v52 = CFAllocatorAllocateTyped(*(void *)(a5 + 16), 2 * v12, 0x1000040BDFB0063, 0);
          *(void *)a5 = v52;
          if (!v52) {
            goto LABEL_204;
          }
LABEL_186:
          *CFAllocatorRef v14 = 0;
          if (a1 < v17)
          {
            uint64_t v74 = 0;
            while (1)
            {
              v109[0] = 0;
              uint64_t v75 = __CFStringDecodeByteStream3___CFFromUTF8(a7, a1, v17 - a1, *(void *)a5 + 2 * v74, v12 - v74, v109);
              int v76 = v109[0];
              if (!v109[0]) {
                break;
              }
              a1 += v75;
              uint64_t v74 = *v14 + v109[0];
              *CFAllocatorRef v14 = v74;
              if (a1 >= v17) {
                goto LABEL_202;
              }
            }
LABEL_203:
            if (!v76) {
              goto LABEL_204;
            }
            return 1;
          }
LABEL_202:
          int v76 = 1;
          goto LABEL_203;
        }
        unint64_t v49 = (void *)(a5 + 32);
      }
      *(void *)a5 = v49;
      goto LABEL_186;
    }
    if (v12 >= 1)
    {
      unint64_t v28 = a1;
      uint64_t v29 = v12;
      while (1)
      {
        int v30 = *v28++;
        if (v30 < 0) {
          break;
        }
        if (!--v29) {
          goto LABEL_50;
        }
      }
      *(unsigned char *)(a5 + 8) = 0;
      goto LABEL_91;
    }
LABEL_50:
    *(void *)(a5 + 24) = v12;
    size_t v31 = *(void **)a5;
    BOOL v33 = (unint64_t)v12 > 0x3F0 || v31 != 0;
    *(unsigned char *)(a5 + 9) = v33;
    if (!v31)
    {
      if ((unint64_t)v12 > 0x3F0)
      {
        size_t v31 = (void *)CFAllocatorAllocateTyped(v16, v12, 0x100004077774924, 0);
        *(void *)a5 = v31;
        if (!v31) {
          goto LABEL_204;
        }
        goto LABEL_211;
      }
      size_t v31 = (void *)(a5 + 32);
    }
    *(void *)a5 = v31;
LABEL_211:
    unint64_t v71 = v31;
    goto LABEL_284;
  }
  if ((int)a3 <= 402653439)
  {
    if (a3 == 268435712 || a3 == 335544576)
    {
LABEL_24:
      if ((unint64_t)v12 < 2) {
        goto LABEL_204;
      }
      unint64_t v22 = (unsigned __int16 *)&a1[v12 & 0xFFFFFFFFFFFFFFFELL];
      if (a3 == 268435712) {
        goto LABEL_66;
      }
      if (a3 != 256)
      {
        unint64_t v36 = v12 & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v37 = (uint64_t)(v12 & 0xFFFFFFFFFFFFFFFELL) >> 1;
        *CFAllocatorRef v14 = v37;
        if (a6)
        {
          uint64_t result = 1;
          *a6 = 1;
          *(void *)a5 = a1;
          *(unsigned char *)(a5 + 8) = 0;
          return result;
        }
        BOOL v24 = 0;
        goto LABEL_68;
      }
      int v23 = *(unsigned __int16 *)a1;
      if (v23 == 65534 || v23 == 65279)
      {
        a1 += 2;
        BOOL v24 = v23 != 65279;
      }
      else
      {
LABEL_66:
        BOOL v24 = 1;
      }
      unint64_t v36 = (char *)v22 - a1;
      unint64_t v37 = ((char *)v22 - a1) >> 1;
      *CFAllocatorRef v14 = v37;
LABEL_68:
      if (*(unsigned char *)(a5 + 8))
      {
        if (v24) {
          int v38 = 33023;
        }
        else {
          int v38 = 65408;
        }
        int v39 = (unsigned __int16 *)a1;
        do
        {
          if (v39 >= v22)
          {
            unsigned int v47 = *(unsigned char **)a5;
            if (!*(void *)a5)
            {
              if (v37 < 0x3F1)
              {
                unsigned int v47 = (unsigned char *)(a5 + 32);
                *(void *)a5 = a5 + 32;
              }
              else
              {
                uint64_t v48 = CFAllocatorAllocateTyped(v16, v37, 0x100004077774924, 0);
                *(void *)a5 = v48;
                if (!v48) {
                  goto LABEL_204;
                }
                unsigned int v47 = (unsigned char *)v48;
                *(unsigned char *)(a5 + 9) = 1;
              }
            }
            if (v24)
            {
              if (a1 < (char *)v22)
              {
                uint64_t result = 1;
                do
                {
                  *v47++ = a1[1];
                  a1 += 2;
                }
                while (a1 < (char *)v22);
                return result;
              }
            }
            else if (a1 < (char *)v22)
            {
              uint64_t result = 1;
              do
              {
                char v81 = *a1;
                a1 += 2;
                *v47++ = v81;
              }
              while (a1 < (char *)v22);
              return result;
            }
            return 1;
          }
          int v40 = *v39++;
        }
        while ((v38 & v40) == 0);
        *(unsigned char *)(a5 + 8) = 0;
      }
      uint64_t v41 = *(_WORD **)a5;
      if (!*(void *)a5)
      {
        if (v37 < 0x1F9)
        {
          uint64_t v41 = (_WORD *)(a5 + 32);
          *(void *)a5 = a5 + 32;
        }
        else
        {
          uint64_t v42 = CFAllocatorAllocateTyped(v16, v36, 0x1000040BDFB0063, 0);
          *(void *)a5 = v42;
          if (!v42) {
            goto LABEL_204;
          }
          uint64_t v41 = (_WORD *)v42;
          *(unsigned char *)(a5 + 9) = 1;
        }
      }
      if (v24)
      {
        if (a1 < (char *)v22)
        {
          uint64_t result = 1;
          do
          {
            unsigned int v69 = *(unsigned __int16 *)a1;
            a1 += 2;
            *v41++ = bswap32(v69) >> 16;
          }
          while (a1 < (char *)v22);
          return result;
        }
        return 1;
      }
      size_t v70 = 2 * *v14;
      unint64_t v71 = v41;
      unint64_t v72 = a1;
LABEL_285:
      memmove(v71, v72, v70);
      return 1;
    }
    goto LABEL_60;
  }
  if (a3 == 402653440) {
    goto LABEL_35;
  }
  int v25 = 469762304;
LABEL_34:
  if (a3 == v25)
  {
LABEL_35:
    if ((unint64_t)v12 < 4) {
      goto LABEL_204;
    }
    int8x16_t v26 = (unsigned int *)&a1[v12 & 0xFFFFFFFFFFFFFFFCLL];
    if (a3 == 201326848)
    {
      unsigned int v43 = *(_DWORD *)a1;
      if (*(_DWORD *)a1 == -131072 || v43 == 65279)
      {
        a1 += 4;
        uint64_t v27 = (uint64_t)((v12 & 0xFFFFFFFFFFFFFFFCLL) - 4) >> 2;
        *CFAllocatorRef v14 = v27;
        if (v43 == 65279) {
          goto LABEL_85;
        }
LABEL_147:
        int v45 = 0xFFFF;
        int v44 = 1;
        int v46 = -2130706433;
        goto LABEL_148;
      }
      uint64_t v27 = v12 >> 2;
    }
    else
    {
      uint64_t v27 = v12 >> 2;
      if (a3 != 402653440)
      {
        *CFAllocatorRef v14 = v27;
LABEL_85:
        int v44 = 0;
        int v45 = -65536;
        int v46 = -128;
LABEL_148:
        unint64_t v62 = v27;
        if (a1 < (char *)v26)
        {
          unint64_t v62 = v27;
          int v63 = (unsigned int *)a1;
          do
          {
            unsigned int v64 = *v63;
            if ((*v63 & v46) != 0)
            {
              *(unsigned char *)(a5 + 8) = 0;
              if ((v64 & v45) != 0)
              {
                unsigned int v65 = bswap32(v64);
                if (v44) {
                  unsigned int v64 = v65;
                }
                if (HIWORD(v64) > 0x10u) {
                  return 0;
                }
                *CFAllocatorRef v14 = ++v62;
              }
            }
            ++v63;
          }
          while (v63 < v26);
        }
        unint64_t v66 = *(unsigned char **)a5;
        if (*(unsigned char *)(a5 + 8))
        {
          if (!v66)
          {
            if (v62 < 0x3F1)
            {
              unint64_t v66 = (unsigned char *)(a5 + 32);
              *(void *)a5 = a5 + 32;
            }
            else
            {
              uint64_t v67 = CFAllocatorAllocateTyped(v16, v62, 0x100004077774924, 0);
              *(void *)a5 = v67;
              if (!v67) {
                goto LABEL_204;
              }
              unint64_t v66 = (unsigned char *)v67;
              *(unsigned char *)(a5 + 9) = 1;
            }
          }
          if (v44)
          {
            if (a1 < (char *)v26)
            {
              uint64_t result = 1;
              do
              {
                *v66++ = a1[3];
                a1 += 4;
              }
              while (a1 < (char *)v26);
              return result;
            }
          }
          else if (a1 < (char *)v26)
          {
            uint64_t result = 1;
            do
            {
              unsigned int v73 = *(_DWORD *)a1;
              a1 += 4;
              *v66++ = v73;
            }
            while (a1 < (char *)v26);
            return result;
          }
          return 1;
        }
        if (!v66)
        {
          if (v62 < 0x1F9)
          {
            unint64_t v66 = (unsigned char *)(a5 + 32);
            *(void *)a5 = a5 + 32;
          }
          else
          {
            uint64_t v68 = CFAllocatorAllocateTyped(v16, 2 * v62, 0x1000040BDFB0063, 0);
            *(void *)a5 = v68;
            if (!v68) {
              goto LABEL_204;
            }
            unint64_t v66 = (unsigned char *)v68;
            *(unsigned char *)(a5 + 9) = 1;
          }
        }
        if (v27 >= 1)
        {
          char v77 = &a1[4 * v27];
          do
          {
            unsigned int v79 = *(_DWORD *)a1;
            a1 += 4;
            unsigned int v78 = v79;
            unsigned int v80 = bswap32(v79);
            if (v44) {
              unsigned int v78 = v80;
            }
            if (HIWORD(v78))
            {
              if (HIWORD(v78) > 0x10u) {
                goto LABEL_204;
              }
              *(_WORD *)unint64_t v66 = ((v78 + 67043328) >> 10) - 10240;
              v66 += 2;
              LOWORD(v78) = v78 & 0x3FF | 0xDC00;
            }
            else if ((v78 & 0xF800 | 0x400) == 0xDC00)
            {
              goto LABEL_204;
            }
            *(_WORD *)unint64_t v66 = v78;
            v66 += 2;
          }
          while (a1 < v77);
        }
        goto LABEL_202;
      }
    }
    *CFAllocatorRef v14 = v27;
    goto LABEL_147;
  }
LABEL_60:
  uint64_t result = CFStringEncodingGetConverter(a3);
  if (!result) {
    return result;
  }
  uint64_t v35 = result;
  switch(BYTE1(a3))
  {
    case 0:
      if (a3 <= 0x22 && ((1 << a3) & 0x600000032) != 0 || a3 == 152) {
        goto LABEL_230;
      }
      goto LABEL_240;
    case 1:
    case 8:
    case 0xC:
      goto LABEL_230;
    case 2:
      if (a3 != 518) {
        goto LABEL_240;
      }
      goto LABEL_230;
    case 6:
      if (a3 == 1536) {
        goto LABEL_240;
      }
      goto LABEL_230;
    case 0xA:
      if ((a3 - 2561) <= 0xF && ((1 << (a3 - 1)) & 0x8011) != 0) {
        goto LABEL_230;
      }
      goto LABEL_240;
    case 0xB:
      if ((a3 - 3059) >= 2) {
        goto LABEL_240;
      }
      goto LABEL_230;
    default:
      if (((unsigned __int16)a3 & 0xFF00u) >= 0xC01)
      {
LABEL_230:
        int v82 = 0;
        *(unsigned char *)(a5 + 8) = 0;
      }
      else
      {
LABEL_240:
        if (*(unsigned char *)(a5 + 8))
        {
          if (v12 < 1)
          {
LABEL_245:
            char v83 = 0;
            int v82 = 1;
            goto LABEL_249;
          }
          unsigned int v88 = a1;
          uint64_t v89 = v12;
          while (1)
          {
            int v90 = *v88++;
            if (v90 < 0) {
              break;
            }
            if (!--v89) {
              goto LABEL_245;
            }
          }
          int v82 = 1;
          goto LABEL_248;
        }
        int v82 = 1;
      }
      char v83 = 1;
      if (a3 == 1 && !a4)
      {
        *(unsigned char *)(a5 + 8) = 1;
        if (v12 < 1)
        {
LABEL_238:
          char v83 = 0;
          goto LABEL_249;
        }
        unint64_t v84 = a1;
        uint64_t v85 = v12;
        while (1)
        {
          int v87 = *v84++;
          int v86 = v87;
          if (v87 < 0 || v86 == 92) {
            break;
          }
          if (!--v85) {
            goto LABEL_238;
          }
        }
LABEL_248:
        *(unsigned char *)(a5 + 8) = 0;
        char v83 = 1;
      }
LABEL_249:
      if (*(unsigned char *)(result + 20) != 1)
      {
        if ((v83 & 1) == 0) {
          goto LABEL_272;
        }
        unint64_t v95 = CFStringEncodingCharLengthForBytes(a3, 0, (unint64_t)a1, v12);
        unint64_t v96 = v95;
        unint64_t v97 = *(void **)a5;
        if (*(void *)a5) {
          BOOL v98 = 1;
        }
        else {
          BOOL v98 = v95 > 0x1F8;
        }
        char v99 = v98;
        *(unsigned char *)(a5 + 9) = v99;
        if (!v97)
        {
          if (v95 > 0x1F8)
          {
            unint64_t v97 = (void *)CFAllocatorAllocateTyped(*(void *)(a5 + 16), 2 * v95, 0x1000040BDFB0063, 0);
            *(void *)a5 = v97;
            if (!v97) {
              goto LABEL_204;
            }
LABEL_306:
            if ((__CFStringDecodeByteStream3_lossyFlag & 1) == 0) {
              __CFStringDecodeByteStream3_lossyFlag = 1;
            }
            if (v96 <= 0x1F8) {
              uint64_t v108 = 504;
            }
            else {
              uint64_t v108 = v96;
            }
            BOOL v60 = CFStringEncodingBytesToUnicode(a3, __CFWantsToUseASCIICompatibleConversion, (unint64_t)a1, v12, 0, (uint64_t)v97, v108, (uint64_t *)(a5 + 24)) == 0;
            goto LABEL_139;
          }
          unint64_t v97 = (void *)(a5 + 32);
        }
        *(void *)a5 = v97;
        goto LABEL_306;
      }
      if ((v83 & 1) == 0)
      {
LABEL_272:
        *(void *)(a5 + 24) = v12;
        unint64_t v71 = *(void **)a5;
        BOOL v101 = (unint64_t)v12 > 0x3F0 || v71 != 0;
        *(unsigned char *)(a5 + 9) = v101;
        if (!v71)
        {
          if ((unint64_t)v12 > 0x3F0)
          {
            unint64_t v71 = (void *)CFAllocatorAllocateTyped(*(void *)(a5 + 16), v12, 0x100004077774924, 0);
            *(void *)a5 = v71;
            if (!v71) {
              goto LABEL_204;
            }
            goto LABEL_284;
          }
          unint64_t v71 = (void *)(a5 + 32);
        }
        *(void *)a5 = v71;
LABEL_284:
        unint64_t v72 = a1;
        size_t v70 = v12;
        goto LABEL_285;
      }
      uint64_t v91 = *(void **)a5;
      BOOL v93 = (unint64_t)v12 > 0x1F8 || v91 != 0;
      *(unsigned char *)(a5 + 9) = v93;
      if (v91) {
        goto LABEL_289;
      }
      if ((unint64_t)v12 <= 0x1F8)
      {
        uint64_t v91 = (void *)(a5 + 32);
LABEL_289:
        *(void *)a5 = v91;
        goto LABEL_290;
      }
      uint64_t v94 = CFAllocatorAllocateTyped(*(void *)(a5 + 16), 2 * v12, 0x1000040BDFB0063, 0);
      *(void *)a5 = v94;
      if (!v94) {
        goto LABEL_204;
      }
LABEL_290:
      *CFAllocatorRef v14 = v12;
      if (a3 == 513 || a3 == 1536)
      {
        if (v12 >= 1)
        {
          uint64_t v102 = 0;
          uint64_t result = 1;
          do
          {
            *(_WORD *)(*(void *)a5 + 2 * v102) = a1[v102];
            ++v102;
          }
          while (v12 != v102);
          return result;
        }
        return 1;
      }
      if (v12 < 1) {
        return 1;
      }
      uint64_t v103 = 0;
      do
      {
        int v105 = *a1++;
        int v104 = v105;
        uint64_t v106 = v105;
        size_t v107 = (_WORD *)(*(void *)a5 + v103);
        if (!v82 || v104 < 0)
        {
          if (!(*(unsigned int (**)(void, uint64_t, _WORD *))(v35 + 8))(0, v106, v107)) {
            goto LABEL_204;
          }
        }
        else
        {
          *size_t v107 = v106;
        }
        v103 += 2;
        uint64_t result = 1;
        --v12;
      }
      while (v12);
      return result;
  }
}

void __CFDataDeallocate(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 4) == 0)
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 0x10) == 0)
    {
      char v4 = *(const void **)(a1 + 32);
      if (v4)
      {
        uint64_t v5 = (void *)(a1 + 40);
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), *(void **)(a1 + 40));
        CFRelease(v4);
      }
      else
      {
        char v6 = atomic_load((unint64_t *)(a1 + 8));
        if ((v6 & 8) != 0)
        {
          if (a1 < 0)
          {
            uint64_t v8 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
          }
          else
          {
            char v9 = atomic_load((unint64_t *)(a1 + 8));
            if (v9 < 0) {
              uint64_t v8 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
            }
            else {
              uint64_t v8 = (CFAllocatorRef *)(a1 - 16);
            }
          }
          CFAllocatorDeallocate(*v8, *(void **)(a1 + 40));
        }
        else
        {
          unsigned int v7 = *(void **)(a1 + 40);
          if (v7) {
            free(v7);
          }
        }
        uint64_t v5 = (void *)(a1 + 40);
      }
      *uint64_t v5 = 0;
    }
  }
}

unsigned __int8 *copyBlocks(unsigned __int8 *result, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v22 = result;
  char v10 = a4 != 0;
  if (a7 < 1)
  {
    uint64_t v13 = 0;
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v11 = a7;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = a8 << (a5 != 0);
    char v15 = a4 != a5;
    char v16 = (uint64_t *)(a6 + 8);
    do
    {
      uint64_t v17 = *(v16 - 1);
      uint64_t v18 = (v17 << v10) - v13;
      if (v18 >= 1)
      {
        if (a4 == a5) {
          uint64_t result = (unsigned __int8 *)memmove((void *)(a2 + v12), &v22[v13], (v17 << v10) - v13);
        }
        else {
          uint64_t result = __CFStrConvertBytesToUnicode(&v22[v13], (_WORD *)(a2 + v12), v18);
        }
      }
      uint64_t v19 = *v16;
      v16 += 2;
      uint64_t v13 = (v19 + v17) << v10;
      v12 += v14 + (v18 << v15);
      --v11;
    }
    while (v11);
  }
  size_t v20 = (a3 << v10) - v13;
  if (a3 << v10 > v13)
  {
    if (a4 == a5)
    {
      return (unsigned __int8 *)memmove((void *)(a2 + v12), &v22[v13], v20);
    }
    else
    {
      return __CFStrConvertBytesToUnicode(&v22[v13], (_WORD *)(a2 + v12), v20);
    }
  }
  return result;
}

void __CFURLDeallocate(unint64_t *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  uint64_t v3 = a1 + 3;
  if (atomic_load(a1 + 3))
  {
    uint64_t v5 = (const void *)atomic_load(v3);
    CFRelease(v5);
  }
  atomic_store(0xDEADBEEFuLL, v3);
  char v6 = (const void *)a1[4];
  if (v6) {
    CFRelease(v6);
  }
  unsigned int v7 = (void *)a1[5];
  if (v7)
  {
    uint64_t v8 = (const void *)v7[1];
    if (!v8 || (CFRelease(v8), (unsigned int v7 = (void *)a1[5]) != 0)) {
      CFAllocatorDeallocate(v2, v7);
    }
  }
  char v9 = a1 + 6;
  char v10 = (const void *)atomic_load(v9);
  if (v10) {
    CFRelease(v10);
  }
  atomic_store(0xDEADBEEFuLL, v9);
}

void __CFArrayDeallocate(unint64_t a1)
{
}

unsigned __int8 *__CFFromUTF8(__int16 a1, unsigned __int8 *a2, uint64_t a3, _WORD *a4, uint64_t a5, void *a6)
{
  uint64_t v42 = *(void *)off_1ECE0A5B0;
  uint64_t v39 = 0;
  int v40 = a4;
  uint64_t v8 = a2;
  if (a3)
  {
    uint64_t v10 = a3;
    int v12 = a1 & 0xC0;
    uint64_t v8 = a2;
    uint64_t v13 = &offsetsFromUTF8;
    while (1)
    {
      uint64_t v14 = v39;
      if (a5 && v39 >= a5) {
        goto LABEL_73;
      }
      unsigned int v15 = *v8;
      if (v10 <= (unsigned __int16)trailingBytesForUTF8[*v8]) {
        goto LABEL_73;
      }
      --v10;
      if ((~(_BYTE)v15 & 0xF8) == 0) {
        break;
      }
      uint64_t v18 = (unsigned __int16)trailingBytesForUTF8[*v8];
      if ((a1 & 0x800) == 0)
      {
        uint64_t v19 = &v8[v18];
        while (v19 > v8)
        {
          char v20 = *v19--;
          if ((v20 & 0xC0) != 0x80) {
            goto LABEL_7;
          }
        }
        if ((char)v15 < -62 || v15 > 0xF4) {
          break;
        }
        if (*v8 > 0xEFu)
        {
          if (v15 == 240)
          {
            if (v8[1] < 0x90u) {
              break;
            }
          }
          else if (v15 == 244 && v8[1] >= 0x90u)
          {
            break;
          }
        }
        else if (v15 == 224)
        {
          if (v8[1] < 0xA0u) {
            break;
          }
        }
        else if (v15 == 237 && v8[1] > 0x9Fu)
        {
          break;
        }
      }
      int v21 = 0;
      int v22 = (unsigned __int16)trailingBytesForUTF8[*v8];
      switch(*v8)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
        case 0x90u:
        case 0x91u:
        case 0x92u:
        case 0x93u:
        case 0x94u:
        case 0x95u:
        case 0x96u:
        case 0x97u:
        case 0x98u:
        case 0x99u:
        case 0x9Au:
        case 0x9Bu:
        case 0x9Cu:
        case 0x9Du:
        case 0x9Eu:
        case 0x9Fu:
        case 0xA0u:
        case 0xA1u:
        case 0xA2u:
        case 0xA3u:
        case 0xA4u:
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
        case 0xAAu:
        case 0xABu:
        case 0xACu:
        case 0xADu:
        case 0xAEu:
        case 0xAFu:
        case 0xB0u:
        case 0xB1u:
        case 0xB2u:
        case 0xB3u:
        case 0xB4u:
        case 0xB5u:
        case 0xB6u:
        case 0xB7u:
        case 0xB8u:
        case 0xB9u:
        case 0xBAu:
        case 0xBBu:
        case 0xBCu:
        case 0xBDu:
        case 0xBEu:
        case 0xBFu:
          goto LABEL_39;
        case 0xC0u:
        case 0xC1u:
        case 0xC2u:
        case 0xC3u:
        case 0xC4u:
        case 0xC5u:
        case 0xC6u:
        case 0xC7u:
        case 0xC8u:
        case 0xC9u:
        case 0xCAu:
        case 0xCBu:
        case 0xCCu:
        case 0xCDu:
        case 0xCEu:
        case 0xCFu:
        case 0xD0u:
        case 0xD1u:
        case 0xD2u:
        case 0xD3u:
        case 0xD4u:
        case 0xD5u:
        case 0xD6u:
        case 0xD7u:
        case 0xD8u:
        case 0xD9u:
        case 0xDAu:
        case 0xDBu:
        case 0xDCu:
        case 0xDDu:
        case 0xDEu:
        case 0xDFu:
          goto LABEL_38;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
          goto LABEL_37;
        case 0xF0u:
        case 0xF1u:
        case 0xF2u:
        case 0xF3u:
        case 0xF4u:
        case 0xF5u:
        case 0xF6u:
        case 0xF7u:
          int v21 = v15 << 6;
          unsigned int v23 = *++v8;
          unsigned int v15 = v23;
LABEL_37:
          unsigned int v24 = *++v8;
          int v21 = (v21 + v15) << 6;
          unsigned int v15 = v24;
LABEL_38:
          unsigned int v25 = *++v8;
          int v22 = (v21 + v15) << 6;
          unsigned int v15 = v25;
LABEL_39:
          ++v8;
          int v21 = v22 + v15;
          break;
        default:
          break;
      }
      v10 -= v18;
      unsigned int v26 = v21 - v13[v18];
      if (HIWORD(v26))
      {
        if (v26 >= 0x110000)
        {
          if ((a1 & 0x80) == 0) {
            goto LABEL_72;
          }
          if (a5)
          {
            size_t v31 = v40;
            *int v40 = -3;
            int v40 = v31 + 1;
          }
          goto LABEL_12;
        }
        if (!v12) {
          goto LABEL_62;
        }
        uint64_t v27 = v13;
        if ((CFUniCharIsMemberOf(v21 - v13[v18], 0x65u) & 1) == 0)
        {
          uint64_t v14 = v39;
          uint64_t v13 = v27;
LABEL_62:
          uint64_t v17 = v14 + 2;
          if (a5)
          {
            if (v17 > a5) {
              goto LABEL_73;
            }
            uint64_t v35 = v40;
            *int v40 = ((v26 + 67043328) >> 10) - 10240;
            int v40 = v35 + 2;
            v35[1] = v26 & 0x3FF | 0xDC00;
          }
LABEL_13:
          uint64_t v39 = v17;
          goto LABEL_14;
        }
        uint64_t v33 = CFUniCharDecomposeCharacter(v26, v41, 10);
        unint64_t v30 = v33;
        if (!a5)
        {
          if (v33 < 1) {
            goto LABEL_48;
          }
          uint64_t v17 = v39;
          uint64_t v13 = v27;
          do
          {
            if (v41[v30 - 1] < 0x10000) {
              uint64_t v36 = 1;
            }
            else {
              uint64_t v36 = 2;
            }
            v17 += v36;
          }
          while (v30-- > 1);
          goto LABEL_13;
        }
      }
      else
      {
        if ((a1 & 0x80) == 0 && (v26 & 0xFFFFF800) == 0xD800)
        {
LABEL_72:
          v8 -= (v18 + 1);
          goto LABEL_73;
        }
        if (!v12
          || v26 < 0x80
          || (v27 = v13, IsMemberOf = CFUniCharIsMemberOf(v21 - v13[v18], 0x65u), uint64_t v13 = v27, !IsMemberOf))
        {
          if (a5)
          {
            unint64_t v32 = v40;
            *int v40 = v26;
            int v40 = v32 + 1;
          }
          ++v39;
          goto LABEL_14;
        }
        uint64_t v29 = CFUniCharDecomposeCharacter(v26, v41, 10);
        unint64_t v30 = v29;
        if (!a5)
        {
          v39 += v29;
LABEL_48:
          uint64_t v13 = v27;
          goto LABEL_14;
        }
      }
      char v34 = CFUniCharFillDestinationBuffer(v41, v30, (uint64_t *)&v40, a5, &v39, 0);
      uint64_t v13 = v27;
      if ((v34 & 1) == 0) {
        goto LABEL_73;
      }
LABEL_14:
      if (!v10) {
        goto LABEL_73;
      }
    }
LABEL_7:
    if ((a1 & 1) == 0 && v15 != 169) {
      goto LABEL_73;
    }
    if (a5)
    {
      char v16 = v40;
      *int v40 = -3;
      int v40 = v16 + 1;
    }
    ++v8;
LABEL_12:
    uint64_t v17 = v14 + 1;
    goto LABEL_13;
  }
LABEL_73:
  if (a6) {
    *a6 = v39;
  }
  return (unsigned __int8 *)(v8 - a2);
}

void __CFDateComponentsDeallocate(uint64_t a1)
{
  if (!a1) {
    __CFDateComponentsDeallocate_cold_1();
  }
  CFAllocatorRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

void __CFCharacterSetDeallocate(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v3 = (unint64_t *)(a1 + 8);
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x70) != 0
    || (char v5 = atomic_load(v3), (v5 & 1) != 0)
    || (char v6 = atomic_load((unint64_t *)(a1 + 8)), (v6 & 8) != 0)
    || CFCharacterSetGetPredefined(*(CFCharacterSetPredefinedSet *)(a1 + 24)) != (CFCharacterSetRef)a1)
  {
    char v7 = atomic_load(v3);
    if ((v7 & 0x70) == 0x20 && (uint64_t v8 = *(void **)(a1 + 24)) != 0
      || (v9 = atomic_load((unint64_t *)(a1 + 8)), (v9 & 0x70) == 0x30) && (uint64_t v8 = *(void **)(a1 + 24)) != 0
      || (char v10 = atomic_load((unint64_t *)(a1 + 8)), (v10 & 0x70) == 0x40) && (v8 = *(void **)(a1 + 24)) != 0)
    {
      CFAllocatorDeallocate(v2, v8);
    }
    if (*(void *)(a1 + 40))
    {
      for (uint64_t i = 0; i != 16; ++i)
      {
        uint64_t v12 = *(void *)(a1 + 40);
        if (((*(_DWORD *)(v12 + 8) >> i) & 2) != 0) {
          CFRelease(*(CFTypeRef *)(*(void *)v12 + 8 * i));
        }
      }
      CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
      CFAllocatorDeallocate(v13, **(void ***)(a1 + 40));
      CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
      CFAllocatorDeallocate(v14, *(void **)(a1 + 40));
      *(void *)(a1 + 40) = 0;
    }
  }
}

void __CFErrorDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 24));
  CFAllocatorRef v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

void __CFAllocatorDeallocate(void *ptr)
{
  CFAllocatorRef v2 = (const __CFAllocator *)ptr[16];
  uint64_t v3 = (void (*)(uint64_t))ptr[20];
  if (v2 == (const __CFAllocator *)939)
  {
    char v4 = (void (*)(void *, uint64_t))ptr[24];
    uint64_t v5 = ptr[18];
    if (v4)
    {
      char v6 = (void (*)(uint64_t))ptr[20];
      v4(ptr, v5);
      uint64_t v3 = v6;
    }
    if (v3)
    {
      v3(v5);
    }
  }
  else
  {
    if (v3) {
      v3(ptr[18]);
    }
    CFAllocatorDeallocate(v2, ptr);
  }
}

void __CFBitVectorDeallocate(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    CFAllocatorDeallocate(v2, v3);
  }
}

void __CFRunArrayDeallocate(void *a1)
{
  CFAllocatorRef v2 = (const void **)a1[2];
  os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
  if ((uint64_t)*v2 > 1)
  {
    *CFAllocatorRef v2 = (char *)*v2 - 1;
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    if ((uint64_t)v2[2] >= 1)
    {
      uint64_t v3 = 0;
      char v4 = v2 + 7;
      do
      {
        uint64_t v5 = *v4;
        v4 += 2;
        CFRelease(v5);
        ++v3;
      }
      while (v3 < (uint64_t)v2[2]);
    }
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v6, v2);
  }
}

void __CFAttributedStringDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 16));
  CFAllocatorRef v2 = *(const void **)(a1 + 24);

  CFRelease(v2);
}

void __CFNumberFormatterDeallocate(void *a1)
{
  uint64_t v2 = a1[2];
  if (v2) {
    __cficu_unum_close(v2);
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  char v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }
  CFAllocatorRef v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  char v7 = (const void *)a1[8];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[9];
  if (v8)
  {
    CFRelease(v8);
  }
}

void __cficu_unum_close(uint64_t a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    unum_close();
    ___CFICULogWithArguments(1, @"unum_close(%@);", v2);
    CFRelease(v2);
  }
  else
  {
    unum_close();
  }
}

void _cfmp_record_deallocation(unsigned __int8 a1, unsigned int a2, char a3, char a4)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    unsigned int v6 = a2;
    if (_cfmp_records_oGuard != -1) {
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    }
    CFSetRef v8 = (const __CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    v16[0] = v6;
    v16[1] = a1;
    Value = CFSetGetValue(v8, v16);
    if (Value)
    {
      char v10 = Value[5];
      if ((v10 & 4) == 0)
      {
        Value[5] = (16 * (a4 & 1)) | (8 * (a3 & 1)) | v10 & 0xE7 | 2;
        os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
        return;
      }
      unsigned int v6 = *(_DWORD *)Value;
      uint64_t v14 = Value[4];
      unsigned __int8 v13 = (8 * (a3 & 1)) & 0xEF | (16 * (a4 & 1)) | v10 & 0xE7;
      uint64_t v15 = *((unsigned __int16 *)Value + 3);
      CFSetRemoveValue(v8, Value);
      uint64_t v12 = v15 << 48;
      uint64_t v11 = v14 << 32;
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      unsigned __int8 v13 = (8 * (a3 & 1)) & 0xEF | (16 * (a4 & 1));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    _cfmp_cleanup(v11 | v6 | v12 | ((unint64_t)v13 << 40));
  }
}

void __CFMachPortDeallocate(uint64_t a1)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    CFStringRef v2 = (os_unfair_lock_s *)(a1 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (!*(_DWORD *)(a1 + 16))
    {
      *(_DWORD *)(a1 + 16) = 1;
      __dmb(0xBu);
      uint64_t v3 = *(NSObject **)(a1 + 24);
      if (v3)
      {
        dispatch_source_cancel(v3);
        *(void *)(a1 + 24) = 0;
      }
      uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
      char v4 = *(__CFRunLoopSource **)(a1 + 40);
      *(void *)(a1 + 40) = 0;
      uint64_t v6 = *(void *)(a1 + 64);
      char v7 = *(void (**)(uint64_t))(a1 + 112);
      *(void *)(a1 + 64) = 0;
      if (v5)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        v5(a1, v6);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }
      if (v4)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        CFRunLoopSourceInvalidate(v4);
        CFRelease(v4);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }
      if (v7 && v6)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        v7(v6);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }
      *(_DWORD *)(a1 + 16) = 2;
      __dmb(0xBu);
    }
    *(_DWORD *)(a1 + 16) = 3;
    unsigned int v8 = *(_DWORD *)(a1 + 20);
    char v9 = (unint64_t *)(a1 + 8);
    unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
    int v11 = (v10 >> 2) & 1;
    LODWORD(v9) = atomic_load(v9);
    unsigned int v12 = (v9 >> 1) & 1;
    os_unfair_lock_unlock(v2);
    _cfmp_record_deallocation(0, v8, v11, v12);
  }
}

void __CFStorageClearRootNode(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  if (*(unsigned char *)(a1 + 157))
  {
    CFAllocatorDeallocate(v2, *(void **)(a1 + 168));
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3
      && *(_DWORD *)(v3 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode((const void *)a1, v3);
    }
    uint64_t v4 = *(void *)(a1 + 168);
    if (v4
      && *(_DWORD *)(v4 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode((const void *)a1, v4);
    }
    uint64_t v5 = *(void *)(a1 + 176);
    if (v5
      && *(_DWORD *)(v5 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode((const void *)a1, v5);
    }
  }
  *(unsigned char *)(a1 + 157) = 1;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
}

void __CFStringTokenizerDeallocate(uint64_t a1)
{
  if (a1)
  {
    char v1 = *(const void **)(a1 + 16);
    if (v1) {
      CFRelease(v1);
    }
  }
}

void deallocatePurgeable(void *a1, uint64_t a2)
{
  kern_return_t v5;
  int v6;
  NSObject *v7;
  uint64_t vars8;

  if (*(unsigned char *)(a2 + 25))
  {
    free(a1);
  }
  else
  {
    vm_map_t v3 = *(_DWORD *)off_1ECE0A6C8;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a2 + 8));
    uint64_t v5 = mach_vm_deallocate(v3, (mach_vm_address_t)BytePtr, *(void *)(a2 + 16));
    if (v5)
    {
      uint64_t v6 = v5;
      char v7 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        deallocatePurgeable_cold_1(v6, v7);
      }
    }
  }
}

uint64_t CFStringEncodingCharLengthForBytes(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v22[1] = *(void *)off_1ECE0A5B0;
  char v7 = (void *)__CFGetConverter();
  if (!v7) {
    return 0;
  }
  unsigned int v8 = v7;
  uint64_t v9 = *v7;
  int v10 = *(unsigned __int8 *)(*v7 + 20);
  if (v10 != 4)
  {
    if (v10 == 5)
    {
      uint64_t v11 = v7[1];
      return __CFStringEncodingICUCharLength(v11, a2, a3, a4);
    }
    if (*(_WORD *)(v9 + 16) != 1)
    {
      unsigned __int8 v13 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v9 + 32);
      if (v13)
      {
        return v13(a2, a3, a4);
      }
      v22[0] = 0;
      if (a4 < 1) {
        return 0;
      }
      uint64_t v14 = 0;
      while (1)
      {
        uint64_t v15 = (uint64_t (*)(void *, uint64_t, unint64_t, uint64_t, void, void, void *))v8[2];
        if (v15)
        {
          if ((a2 & 0xC0) != 0) {
            uint64_t v15 = (uint64_t (*)(void *, uint64_t, unint64_t, uint64_t, void, void, void *))v8[3];
          }
          uint64_t v16 = v15(v8, a2, a3, a4, 0, 0, v22);
        }
        else
        {
          uint64_t v16 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, void, void, void *))(*v8 + 8))(a2, a3, a4, 0, 0, v22);
        }
        uint64_t v17 = a4 - v16;
        v14 += v22[0];
        if (v17 < 1 || (a2 & 1) == 0) {
          break;
        }
        unint64_t v19 = a3 + v16;
        uint64_t v20 = ((uint64_t (*)(unint64_t, uint64_t, void, void, void *))v8[5])(v19, v17, 0, 0, v22);
        a3 = v19 + v20;
        v14 += v22[0];
        BOOL v21 = v17 <= v20;
        a4 = v17 - v20;
        if (v21) {
          return v14;
        }
      }
      if (v17 >= 1) {
        return 0;
      }
      return v14;
    }
    return a4;
  }

  return __CFStringEncodingPlatformCharLengthForBytes();
}

__n128 __CFRunLoopModeDeallocate(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 96);
  if (v2) {
    CFRelease(v2);
  }
  vm_map_t v3 = *(const void **)(a1 + 104);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 112);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 120);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 128);
  if (v6) {
    CFRelease(v6);
  }
  CFRelease(*(CFTypeRef *)(a1 + 80));
  mach_error_t v7 = mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, *(_DWORD *)(a1 + 136), 3u, -1);
  if (v7)
  {
    __int16 v8 = v7;
    mach_error_string(v7);
    CFLog(3, @"error (%d - %s) while trying to free port set: %d", v9, v10, v11, v12, v13, v14, v8);
  }
  uint64_t v15 = *(NSObject **)(a1 + 152);
  if (v15)
  {
    dispatch_source_cancel(v15);
    dispatch_release(*(dispatch_object_t *)(a1 + 152));
  }
  uint64_t v16 = *(NSObject **)(a1 + 160);
  if (v16) {
    dispatch_release(v16);
  }
  if (*(_DWORD *)(a1 + 172)) {
    mk_timer_destroy();
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  result.n128_u64[0] = 0x7C7C7C7C7C7C7C7CLL;
  result.n128_u64[1] = 0x7C7C7C7C7C7C7C7CLL;
  *(__n128 *)(a1 + 16) = result;
  *(__n128 *)(a1 + 32) = result;
  *(__n128 *)(a1 + 48) = result;
  *(__n128 *)(a1 + 64) = result;
  *(__n128 *)(a1 + 80) = result;
  *(__n128 *)(a1 + 96) = result;
  *(__n128 *)(a1 + 112) = result;
  *(__n128 *)(a1 + 128) = result;
  *(__n128 *)(a1 + 144) = result;
  *(__n128 *)(a1 + 160) = result;
  *(__n128 *)(a1 + 176) = result;
  *(void *)(a1 + 192) = 0x7C7C7C7C7C7C7C7CLL;
  return result;
}

void __CFXNotificationRegistrarDeallocate(uint64_t a1)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  unint64_t v2 = *(unsigned int *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * i);
      if (v4 != -1)
      {
        uint64_t v5 = *(void **)(*(void *)(a1 + 96) + 40 * v4 + 24);
        if (v5)
        {
          free(v5);
          unint64_t v2 = *(unsigned int *)(a1 + 40);
        }
      }
    }
  }
  uint64_t v6 = *(void **)(a1 + 96);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 108);
    if (v7)
    {
      unint64_t v8 = 0;
      uint64_t v9 = 8;
      do
      {
        uint64_t v10 = (const void **)(*(void *)(a1 + 96) + v9);
        if (*v10)
        {
          _CFXNotificationRegistrarRemoveCachedName(v10);
          unint64_t v7 = *(unsigned int *)(a1 + 108);
        }
        ++v8;
        v9 += 40;
      }
      while (v8 < v7);
      uint64_t v6 = *(void **)(a1 + 96);
    }
    free(v6);
  }
  uint64_t v11 = *(void **)(a1 + 120);
  if (v11)
  {
    if ((*(unsigned char *)(a1 + 24) & 2) != 0)
    {
      unint64_t v12 = *(unsigned int *)(a1 + 132);
      if (v12)
      {
        unint64_t v13 = 0;
        uint64_t v14 = 8;
        do
        {
          uint64_t v15 = (const void **)(*(void *)(a1 + 120) + v14);
          if (*v15)
          {
            _CFXNotificationRegistrarRemoveCachedName(v15);
            unint64_t v12 = *(unsigned int *)(a1 + 132);
          }
          ++v13;
          v14 += 32;
        }
        while (v13 < v12);
        uint64_t v11 = *(void **)(a1 + 120);
      }
    }
    free(v11);
  }
  unint64_t v16 = *(unsigned int *)(a1 + 156);
  if (v16)
  {
    unint64_t v17 = 0;
    uint64_t v18 = 44;
    do
    {
      uint64_t v19 = *(void *)(a1 + 144);
      int v20 = *(_DWORD *)(v19 + v18);
      if ((v20 & 0x8000) == 0)
      {
        if ((v20 & 0x400) != 0)
        {
          objc_destroyWeak((id *)(v19 + v18 - 36));
          int v20 = *(_DWORD *)(v19 + v18);
        }
        memset(v25, 0, sizeof(v25));
        _CFXNotificationHandlerRelease((uint64_t *)(v19 + v18 - 28), v20, (unsigned int *)v25);
        _CFXNotificationDisposalListRelease((unsigned int *)v25);
        unint64_t v16 = *(unsigned int *)(a1 + 156);
      }
      ++v17;
      v18 += 56;
    }
    while (v17 < v16);
  }
  free(*(void **)(a1 + 144));
  BOOL v21 = *(void **)(a1 + 32);
  if (v21) {
    free(v21);
  }
  int v22 = *(void **)(a1 + 48);
  if (v22) {
    free(v22);
  }
  unsigned int v23 = *(void **)(a1 + 64);
  if (v23) {
    free(v23);
  }
  unsigned int v24 = *(const void **)(a1 + 88);
  if (v24)
  {
    CFRelease(v24);
  }
}

void __CFNotificationCenterDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = *(_xpc_connection_s **)(a1 + 24);
  if (v2)
  {
    xpc_connection_cancel(v2);
    vm_map_t v3 = *(void **)(a1 + 24);
    xpc_release(v3);
  }
}

void __CFFileDescriptorDeallocate(uint64_t a1)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v11 = 0;
    unint64_t v12 = &v11;
    uint64_t v13 = 0x2000000000;
    uint64_t v14 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000;
    char v10 = 0;
    unint64_t v2 = __fdQueue();
    v6[0] = off_1ECE0A5A0;
    v6[1] = 0x40000000;
    v6[2] = ____CFFileDescriptorDeallocate_block_invoke;
    v6[3] = &unk_1ECDAC050;
    v6[5] = &v11;
    v6[6] = a1;
    v6[4] = &v7;
    dispatch_sync(v2, v6);
    if (*((unsigned char *)v8 + 24))
    {
      vm_map_t v3 = (__CFRunLoopSource *)v12[3];
      if (v3)
      {
        CFRunLoopSourceInvalidate(v3);
        CFRelease((CFTypeRef)v12[3]);
      }
      uint64_t v4 = *(void *)(a1 + 80);
      *(void *)(a1 + 80) = 0;
      uint64_t v5 = *(void (**)(uint64_t))(a1 + 96);
      if (v5) {
        v5(v4);
      }
      *(_DWORD *)(a1 + 16) = 2;
      __dmb(0xBu);
    }
    *(_DWORD *)(a1 + 16) = 3;
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
  }
}

void sub_182B98838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

void CFRetain_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFRetain() called with NULL ***";
  __break(1u);
}

uint64_t _CompareTestEntryToTableEntryKey(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

void __CFBasicHashDrain(uint64_t a1)
{
  uint64_t v2 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  vm_map_t v3 = 0;
  CFAllocatorRef v22 = CFGetAllocator((CFTypeRef)a1);
  unsigned int v23 = *(uint64_t **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = *(unsigned __int16 *)(a1 + 18);
  if ((v4 & 4) != 0)
  {
    uint64_t v5 = a1 + 8 * ((v4 >> 2) & 1);
    vm_map_t v3 = *(uint64_t **)(v5 + 40);
    *(void *)(v5 + 40) = 0;
  }
  if ((v4 & 0x18) != 0)
  {
    uint64_t v6 = a1 + (v4 & 0x18);
    char ptr = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = 0;
  }
  else
  {
    char ptr = 0;
  }
  ++*(_WORD *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  *(_DWORD *)(a1 + 20) = 0;
  *(void *)(a1 + 24) = v7 & 0xFFFFFFFFFF000000;
  if (v2 >= 1)
  {
    uint64_t v8 = v23;
    uint64_t v9 = v3;
    do
    {
      uint64_t v11 = *v8++;
      uint64_t v10 = v11;
      if ((unint64_t)(v11 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v10 == 2814029233) {
          uint64_t v10 = 0;
        }
        if (v10 == 2780474809) {
          uint64_t v12 = -1;
        }
        else {
          uint64_t v12 = v10;
        }
        if ((*(void *)(a1 + 32) & 2) == 0)
        {
          uint64_t v13 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                                  + (HIBYTE(*(void *)(a1 + 24)) & 0xF8))
                                                                     + 8 * ((*(void *)(a1 + 24) >> 54) & 0x1FLL));
          if (v13)
          {
            uint64_t v14 = &kCFAllocatorSystemDefault;
            if ((a1 & 0x8000000000000000) == 0)
            {
              char v15 = atomic_load((unint64_t *)(a1 + 8));
              if (v15 < 0) {
                uint64_t v14 = &kCFAllocatorSystemDefault;
              }
              else {
                uint64_t v14 = (const CFAllocatorRef *)(a1 - 16);
              }
            }
            v13(*v14, v12);
          }
        }
        if (v3)
        {
          uint64_t v16 = *v9;
          if (*v9 == 2814029233) {
            uint64_t v16 = 0;
          }
          if (v16 == 2780474809) {
            uint64_t v17 = -1;
          }
          else {
            uint64_t v17 = v16;
          }
          if ((*(void *)(a1 + 32) & 2) == 0)
          {
            uint64_t v18 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 24) >> 49) & 0x1FLL]
                                                                       + 8 * ((*(void *)(a1 + 24) >> 44) & 0x1FLL));
            if (v18)
            {
              uint64_t v19 = &kCFAllocatorSystemDefault;
              if ((a1 & 0x8000000000000000) == 0)
              {
                char v20 = atomic_load((unint64_t *)(a1 + 8));
                if (v20 < 0) {
                  uint64_t v19 = &kCFAllocatorSystemDefault;
                }
                else {
                  uint64_t v19 = (const CFAllocatorRef *)(a1 - 16);
                }
              }
              v18(*v19, v17);
            }
          }
        }
      }
      ++v9;
      --v2;
    }
    while (v2);
  }
  CFAllocatorDeallocate(v22, v23);
  CFAllocatorDeallocate(v22, v3);
  CFAllocatorDeallocate(v22, ptr);

  CFAllocatorDeallocate(v22, 0);
}

void CFRelease(CFTypeRef cf)
{
  if (!cf) {
    CFRelease_cold_1();
  }
  if (((unint64_t)cf & 0x8000000000000000) == 0)
  {
    unint64_t v2 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v2 >> 8) & 0x3FF, (unint64_t)cf))
    {
    }
    else
    {
      _CFRelease((uint64_t)cf);
    }
  }
}

void __CFTypeCollectionRelease(int a1, CFTypeRef cf)
{
  if (!cf) {
    __CFTypeCollectionRelease_cold_1();
  }
  CFRelease(cf);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  if (!cf
    || ((unint64_t)cf & 0x8000000000000000) != 0
    || (unint64_t v2 = atomic_load((unint64_t *)cf + 1), CF_IS_OBJC((v2 >> 8) & 0x3FF, (unint64_t)cf)))
  {
    vm_map_t v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    return *v3;
  }
  __CFCheckCFInfoPACSignature_Bridged((uint64_t)cf);
  unint64_t v5 = atomic_load((unint64_t *)cf + 1);
  if ((v5 & 0x3FF00) != 0x200)
  {
    char v6 = atomic_load((unint64_t *)cf + 1);
    if (v6 < 0) {
      vm_map_t v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }
    else {
      vm_map_t v3 = (CFAllocatorRef *)((char *)cf - 16);
    }
    return *v3;
  }

  return (CFAllocatorRef)__CFAllocatorGetAllocator((uint64_t)cf);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  if (!cf1) {
    CFEqual_cold_1();
  }
  if (cf1 == cf2) {
    return 1;
  }
  if (!cf2) {
    CFEqual_cold_2();
  }
  if (((unint64_t)cf1 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = *(void *)off_1ECE0A6F0;
    unint64_t v5 = (unint64_t)cf1 & 0xC000000000000007;
    if (((unint64_t)cf2 & 0x8000000000000000) != 0)
    {
      uint64_t v6 = 0;
      if (v5 == 0xC000000000000007) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = *(void *)off_1ECE0A6F0;
      }
      do
      {
        if (((v7 ^ (unint64_t)cf1) & 7) == *((unsigned char *)off_1ECE0A6E0 + v6)) {
          break;
        }
        ++v6;
      }
      while (v6 != 7);
      uint64_t v8 = 0;
      unint64_t v9 = v6 | v7 ^ (unint64_t)cf1;
      uint64_t v10 = v6 & 7;
      int v11 = (v9 >> 55) + 8;
      if (v10 == 7) {
        LODWORD(v10) = v11;
      }
      if ((~(unint64_t)cf2 & 0xC000000000000007) != 0) {
        uint64_t v12 = *(void *)off_1ECE0A6F0;
      }
      else {
        uint64_t v12 = 0;
      }
      unint64_t v13 = v12 ^ (unint64_t)cf2;
      do
      {
        if ((v13 & 7) == *((unsigned char *)off_1ECE0A6E0 + v8)) {
          break;
        }
        ++v8;
      }
      while (v8 != 7);
      unint64_t v14 = v8 | v13;
      uint64_t v15 = v8 & 7;
      int v16 = (v14 >> 55) + 8;
      if (v15 != 7) {
        int v16 = v15;
      }
      if (v10 != v16 || v10 <= 6 && ((1 << v10) & 0x54) != 0) {
        return 0;
      }
    }
    uint64_t v17 = 0;
    if (v5 == 0xC000000000000007) {
      uint64_t v4 = 0;
    }
    unint64_t v18 = v4 ^ (unint64_t)cf1;
    do
    {
      if ((v18 & 7) == *((unsigned char *)off_1ECE0A6E0 + v17)) {
        break;
      }
      ++v17;
    }
    while (v17 != 7);
    int v19 = ((v17 | v18) >> 55) + 8;
    if ((v17 & 7) == 7) {
      int v20 = v19;
    }
    else {
      int v20 = v17 & 7;
    }
    unint64_t v21 = 22;
    switch(v20)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFEqual_cold_7();
        }
        goto LABEL_55;
      case 1:
        goto LABEL_60;
      case 2:
        goto LABEL_54;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_55;
      case 6:
        unint64_t v21 = 42;
        break;
      default:
        if (v20 == 20)
        {
LABEL_55:
          unint64_t v21 = 1;
        }
        else if (v20 == 22)
        {
LABEL_54:
          unint64_t v21 = 7;
        }
        else
        {
LABEL_60:
          unint64_t v21 = [(id)cf1 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v23 = atomic_load((unint64_t *)cf1 + 1);
    unint64_t v21 = (v23 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v21, (unint64_t)cf1))
  {
    unsigned int v24 = (void *)cf1;
    CFTypeRef v25 = cf2;
    return [v24 isEqual:v25];
  }
  if (((unint64_t)cf2 & 0x8000000000000000) != 0)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)cf2 & 0xC000000000000007) == 0) {
      uint64_t v27 = 0;
    }
    unint64_t v28 = v27 ^ (unint64_t)cf2;
    do
    {
      if ((v28 & 7) == *((unsigned char *)off_1ECE0A6E0 + v26)) {
        break;
      }
      ++v26;
    }
    while (v26 != 7);
    unint64_t v29 = v26 | v28;
    uint64_t v30 = v26 & 7;
    int v31 = (v29 >> 55) + 8;
    if (v30 == 7) {
      int v32 = v31;
    }
    else {
      int v32 = v30;
    }
    unint64_t v33 = 22;
    switch(v32)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFEqual_cold_6();
        }
        goto LABEL_59;
      case 1:
        goto LABEL_62;
      case 2:
        goto LABEL_58;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_59;
      case 6:
        unint64_t v33 = 42;
        break;
      default:
        if (v32 == 20)
        {
LABEL_59:
          unint64_t v33 = 1;
        }
        else if (v32 == 22)
        {
LABEL_58:
          unint64_t v33 = 7;
        }
        else
        {
LABEL_62:
          unint64_t v33 = [(id)cf2 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v34 = atomic_load((unint64_t *)cf2 + 1);
    unint64_t v33 = (v34 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v33, (unint64_t)cf2))
  {
    unsigned int v24 = (void *)cf2;
    CFTypeRef v25 = cf1;
    return [v24 isEqual:v25];
  }
  __CFCheckCFInfoPACSignature_Bridged((uint64_t)cf1);
  __CFCheckCFInfoPACSignature_Bridged((uint64_t)cf2);
  if (((unint64_t)cf1 & 0x8000000000000000) != 0)
  {
    uint64_t v35 = 0;
    uint64_t v36 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)cf1 & 0xC000000000000007) == 0) {
      uint64_t v36 = 0;
    }
    unint64_t v37 = v36 ^ (unint64_t)cf1;
    do
    {
      if ((v37 & 7) == *((unsigned char *)off_1ECE0A6E0 + v35)) {
        break;
      }
      ++v35;
    }
    while (v35 != 7);
    unint64_t v38 = v35 | v37;
    uint64_t v39 = v35 & 7;
    int v40 = (v38 >> 55) + 8;
    if (v39 == 7) {
      int v41 = v40;
    }
    else {
      int v41 = v39;
    }
    uint64_t v42 = 22;
    switch(v41)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFEqual_cold_5();
        }
        goto LABEL_83;
      case 1:
        goto LABEL_84;
      case 2:
        goto LABEL_82;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_83;
      case 6:
        uint64_t v42 = 42;
        break;
      default:
        if (v41 == 20)
        {
LABEL_83:
          uint64_t v42 = 1;
        }
        else if (v41 == 22)
        {
LABEL_82:
          uint64_t v42 = 7;
        }
        else
        {
LABEL_84:
          uint64_t v42 = [(id)cf1 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v43 = atomic_load((unint64_t *)cf1 + 1);
    uint64_t v42 = (v43 >> 8) & 0x3FF;
  }
  if (((unint64_t)cf2 & 0x8000000000000000) != 0)
  {
    uint64_t v44 = 0;
    uint64_t v45 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)cf2 & 0xC000000000000007) == 0) {
      uint64_t v45 = 0;
    }
    unint64_t v46 = v45 ^ (unint64_t)cf2;
    do
    {
      if ((v46 & 7) == *((unsigned char *)off_1ECE0A6E0 + v44)) {
        break;
      }
      ++v44;
    }
    while (v44 != 7);
    unint64_t v47 = v44 | v46;
    uint64_t v48 = v44 & 7;
    int v49 = (v47 >> 55) + 8;
    if (v48 == 7) {
      int v50 = v49;
    }
    else {
      int v50 = v48;
    }
    uint64_t v51 = 22;
    switch(v50)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFEqual_cold_4();
        }
        goto LABEL_102;
      case 1:
        goto LABEL_103;
      case 2:
        goto LABEL_101;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_102;
      case 6:
        uint64_t v51 = 42;
        break;
      default:
        if (v50 == 20)
        {
LABEL_102:
          uint64_t v51 = 1;
        }
        else if (v50 == 22)
        {
LABEL_101:
          uint64_t v51 = 7;
        }
        else
        {
LABEL_103:
          uint64_t v51 = [(id)cf2 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v52 = atomic_load((unint64_t *)cf2 + 1);
    uint64_t v51 = (v52 >> 8) & 0x3FF;
  }
  if (v42 != v51) {
    return 0;
  }
  if (((unint64_t)cf1 & 0x8000000000000000) != 0)
  {
    int TaggedPointerTag = _objc_getTaggedPointerTag((uint64_t)cf1);
    unint64_t v54 = 22;
    switch(TaggedPointerTag)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFEqual_cold_3();
        }
        goto LABEL_116;
      case 1:
        goto LABEL_117;
      case 2:
        goto LABEL_115;
      case 3:
        goto LABEL_119;
      case 4:
      case 5:
        goto LABEL_116;
      case 6:
        unint64_t v54 = 42;
        goto LABEL_119;
      default:
        if (TaggedPointerTag == 20)
        {
LABEL_116:
          unint64_t v54 = 1;
          goto LABEL_119;
        }
        if (TaggedPointerTag == 22)
        {
LABEL_115:
          unint64_t v54 = 7;
          goto LABEL_119;
        }
LABEL_117:
        unint64_t v54 = [(id)cf1 _cfTypeID];
        break;
    }
  }
  else
  {
    unint64_t v55 = atomic_load((unint64_t *)cf1 + 1);
    unint64_t v54 = (v55 >> 8) & 0x3FF;
  }
  if (v54 <= 0x47) {
LABEL_119:
  }
    unsigned int v56 = &__CFRuntimeBuiltinClassTable + v54;
  else {
    unsigned int v56 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v54 - 72) >> 6] + 8 * ((v54 - 72) & 0x3F));
  }
  unsigned int v57 = (uint64_t (*)(CFTypeRef, CFTypeRef))*((void *)*v56 + 5);
  if (!v57) {
    return 0;
  }

  return v57(cf1, cf2);
}

uint64_t __CFCheckCFInfoPACSignature_Bridged(uint64_t result)
{
  if ((result & 0x8000000000000000) == 0)
  {
    unint64_t v1 = *(void *)result & ~(unint64_t)off_1ECE0A6D0;
    if ((*(void *)result & (unint64_t)off_1ECE0A6D0) != 0) {
      v1 |= *(void *)result & (unint64_t)off_1ECE0A6D0;
    }
    if (__NSCFType == (__objc2_class *)v1)
    {
      unint64_t v2 = atomic_load((unint64_t *)(result + 8));
      if ((v2 & 0x3FF00) != 0x200) {
        return __CFCheckCFInfoPACSignature(result);
      }
      BOOL v3 = &__kCFAllocatorSystemDefault == (__objc2_class **)result || &__kCFAllocatorMalloc == (__objc2_class **)result;
      BOOL v4 = v3 || &__kCFAllocatorMallocZone == (__objc2_class **)result;
      if (!v4 && &__kCFAllocatorNull != (__objc2_class **)result) {
        return __CFCheckCFInfoPACSignature(result);
      }
    }
  }
  return result;
}

Boolean CFStringFindWithOptionsAndLocale(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFLocaleRef locale, CFRange *result)
{
  CFIndex length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v512 = *(void *)off_1ECE0A5B0;
  CFIndex v12 = CFStringGetLength(stringToFind);
  *(_OWORD *)theSet = 0u;
  long long v471 = 0u;
  uint64_t v13 = __CFStringFillCharacterSetInlineBuffer((uint64_t)theSet, searchOptions);
  LOBYTE(v14) = 0;
  if (v13) {
    uint64_t v15 = theSet;
  }
  else {
    uint64_t v15 = 0;
  }
  v434 = v15;
  if ((searchOptions & 0x91) != 0) {
    int v16 = 1;
  }
  else {
    int v16 = v13;
  }
  if (v12 <= (unint64_t)length) {
    int v17 = 1;
  }
  else {
    int v17 = v16;
  }
  CFIndex v467 = v12;
  if (v12 < 1 || length < 1 || !v17) {
    return v14;
  }
  int v466 = v13;
  uint64_t v509 = 0;
  long long v507 = 0u;
  long long v508 = 0u;
  long long v505 = 0u;
  *(_OWORD *)v506 = 0u;
  long long v503 = 0u;
  long long v504 = 0u;
  long long v501 = 0u;
  long long v502 = 0u;
  long long v499 = 0u;
  long long v500 = 0u;
  *(_OWORD *)buffer = 0u;
  CFIndex v496 = 0;
  CFRange range = (CFRange)0;
  long long v495 = 0u;
  long long v492 = 0u;
  *(_OWORD *)v493 = 0u;
  long long v490 = 0u;
  long long v491 = 0u;
  long long v488 = 0u;
  long long v489 = 0u;
  long long v486 = 0u;
  long long v487 = 0u;
  *(_OWORD *)v485 = 0u;
  uint64_t v18 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(v13);
    uint64_t v18 = __CFDefaultEightBitStringEncoding;
  }
  uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal(theString, v18, 0, 1);
  theStringa = (__CFString *)stringToFind;
  uint64_t v461 = _CFStringGetCStringPtrInternal(stringToFind, v18, 0, 1);
  *(void *)v425 = location;
  uint64_t v19 = location + length;
  if (locale)
  {
    SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 1);
  }
  else if ((searchOptions & 0x20) != 0)
  {
    CFLocaleRef v20 = CFLocaleCopyCurrent();
    SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(v20, 1);
    CFRelease(v20);
  }
  else
  {
    SpecialCaseHandlingLanguageIdentifierForLocale = 0;
  }
  v506[0] = theString;
  *((void *)&v507 + 1) = 0;
  *(void *)&long long v508 = location + length;
  CFStringRef CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(theString);
  uint64_t v22 = 0;
  v506[1] = CharactersPtr;
  if (!CharactersPtr) {
    uint64_t v22 = _CFStringGetCStringPtrInternal(theString, 1536, 0, 1);
  }
  uint64_t v509 = 0;
  *(void *)&long long v507 = v22;
  *((void *)&v508 + 1) = 0;
  v493[0] = theStringa;
  range.CFIndex length = 0;
  *(void *)&long long v495 = v12;
  CFStringRef v23 = (const __CFString *)CFStringGetCharactersPtr(theStringa);
  CFIndex v24 = 0;
  v493[1] = v23;
  if (!v23) {
    CFIndex v24 = _CFStringGetCStringPtrInternal(theStringa, 1536, 0, 1);
  }
  CFStringCompareFlags v456 = searchOptions & 1;
  CFIndex v496 = 0;
  range.CFIndex location = v24;
  *((void *)&v495 + 1) = 0;
  if ((searchOptions & 4) != 0)
  {
    uint64_t v29 = v12;
    if (v16) {
      uint64_t v29 = 1;
    }
    uint64_t v27 = v19 - v29;
    if ((searchOptions & 8) != 0) {
      int v30 = v16;
    }
    else {
      int v30 = 1;
    }
    if (v30) {
      CFIndex v28 = location;
    }
    else {
      CFIndex v28 = v27;
    }
  }
  else
  {
    uint64_t v25 = v12;
    if (v16) {
      uint64_t v25 = 1;
    }
    CFIndex v26 = v19 - v25;
    uint64_t v27 = location;
    if ((searchOptions & 8) != 0) {
      CFIndex v28 = location;
    }
    else {
      CFIndex v28 = v26;
    }
  }
  int v31 = v466;
  int v460 = (searchOptions >> 8) & 1 | v16;
  CFStringCompareFlags v438 = searchOptions & 0xC;
  uint64_t v433 = v28;
  if (v27 > v28) {
    char v32 = -1;
  }
  else {
    char v32 = 1;
  }
  uint64_t v463 = location + length;
  __int16 v441 = searchOptions;
  if (!CStringPtrInternal || !v461)
  {
    if ((v460 & 1) == 0)
    {
      while (1)
      {
        uint64_t v162 = 0;
        CFIndex v163 = v27;
        while (1)
        {
          if (v27 < 0 || (uint64_t v164 = v508, (uint64_t)v508 <= v27))
          {
            UniChar v165 = 0;
          }
          else if (v506[1])
          {
            UniChar v165 = *((_WORD *)&v506[1]->isa + *((void *)&v507 + 1) + v27);
          }
          else if ((void)v507)
          {
            UniChar v165 = *(char *)(v507 + *((void *)&v507 + 1) + v27);
          }
          else
          {
            if (v509 <= v27 || (uint64_t v170 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v27))
            {
              uint64_t v171 = v27 - 4;
              if ((unint64_t)v27 < 4) {
                uint64_t v171 = 0;
              }
              if (v171 + 64 < (uint64_t)v508) {
                uint64_t v164 = v171 + 64;
              }
              *((void *)&v508 + 1) = v171;
              uint64_t v509 = v164;
              v520.CFIndex location = *((void *)&v507 + 1) + v171;
              v520.CFIndex length = v164 - v171;
              CFStringGetCharacters(v506[0], v520, buffer);
              uint64_t v170 = *((void *)&v508 + 1);
            }
            UniChar v165 = buffer[v27 - v170];
          }
          CFIndex v166 = v495;
          if ((uint64_t)v495 <= v162)
          {
            UniChar v167 = 0;
          }
          else if (v493[1])
          {
            UniChar v167 = *((_WORD *)&v493[1]->isa + range.length + v162);
          }
          else if (range.location)
          {
            UniChar v167 = *(char *)(range.location + range.length + v162);
          }
          else
          {
            if (v496 <= v162 || (uint64_t v168 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v162))
            {
              uint64_t v169 = v162 - 4;
              if ((unint64_t)v162 < 4) {
                uint64_t v169 = 0;
              }
              if (v169 + 64 < (uint64_t)v495) {
                CFIndex v166 = v169 + 64;
              }
              *((void *)&v495 + 1) = v169;
              CFIndex v496 = v166;
              v519.CFIndex location = range.length + v169;
              v519.CFIndex length = v166 - v169;
              CFStringGetCharacters(v493[0], v519, v485);
              uint64_t v168 = *((void *)&v495 + 1);
            }
            UniChar v167 = v485[v162 - v168];
          }
          if (v165 != v167) {
            break;
          }
          ++v27;
          if (++v162 == v467) {
            goto LABEL_428;
          }
        }
        if (v162 == v467)
        {
LABEL_428:
          if (result)
          {
            result->CFIndex location = v163;
            result->CFIndex length = v467;
          }
          goto LABEL_436;
        }
        if (v163 == v433) {
          goto LABEL_1116;
        }
        uint64_t v27 = v163 + v32;
      }
    }
    uint64_t v468 = 0;
    uint64_t v469 = 0;
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
    uint64_t UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    uint64_t v443 = v27;
    uint64_t v415 = UnicodePropertyDataForPlane;
    if ((searchOptions & 0x10000) != 0) {
      goto LABEL_533;
    }
    *(_OWORD *)v481 = *(_OWORD *)v493;
    CFRange v482 = range;
    long long v483 = v495;
    CFIndex v484 = v496;
    long long v477 = v489;
    long long v478 = v490;
    long long v479 = v491;
    long long v480 = v492;
    *(_OWORD *)v473 = *(_OWORD *)v485;
    long long v474 = v486;
    long long v475 = v487;
    long long v476 = v488;
    if (CF_IS_OBJC(7uLL, (unint64_t)theString))
    {
      if ([(__CFString *)(id)theString _encodingCantBeStoredInEightBitCFString])goto LABEL_442; {
    }
      }
    else
    {
      unsigned int v172 = atomic_load((unint64_t *)&theString->info);
      if ((v172 >> 4)) {
        goto LABEL_442;
      }
    }
    if (CF_IS_OBJC(7uLL, (unint64_t)theStringa))
    {
      int v173 = [(__CFString *)theStringa _encodingCantBeStoredInEightBitCFString];
    }
    else
    {
      unsigned int v174 = atomic_load((unint64_t *)&theStringa->info);
      int v173 = (v174 >> 4) & 1;
    }
    if (!v173) {
      goto LABEL_533;
    }
LABEL_442:
    uint64_t v175 = 0;
    uint64_t v176 = 0;
    int v472 = 0;
    uint64_t v177 = 64;
    while (1)
    {
      if ((unint64_t)v176 >= 4) {
        uint64_t v178 = 4;
      }
      else {
        uint64_t v178 = v176;
      }
      uint64_t v179 = v483;
      if ((uint64_t)v483 <= v176)
      {
        UniChar v180 = 0;
      }
      else if (v481[1])
      {
        UniChar v180 = *((_WORD *)&v481[1]->isa + v176 + v482.length);
      }
      else if (v482.location)
      {
        UniChar v180 = *(char *)(v482.location + v482.length + v176);
      }
      else
      {
        uint64_t v182 = *((void *)&v483 + 1);
        if (v484 <= v176 || *((void *)&v483 + 1) > v176)
        {
          uint64_t v184 = v178 + v175;
          uint64_t v185 = v177 - v178;
          uint64_t v186 = v176 - v178;
          CFIndex v187 = v186 + 64;
          if (v186 + 64 >= (uint64_t)v483) {
            CFIndex v187 = v483;
          }
          *((void *)&v483 + 1) = v186;
          CFIndex v484 = v187;
          if ((uint64_t)v483 >= v185) {
            uint64_t v179 = v185;
          }
          v521.CFIndex length = v179 + v184;
          v521.CFIndex location = v186 + v482.length;
          CFStringGetCharacters(v481[0], v521, v473);
          uint64_t v182 = *((void *)&v483 + 1);
        }
        UniChar v180 = v473[v176 - v182];
      }
      if (u_isdigit(v180)) {
        goto LABEL_469;
      }
      unsigned int Script = uscript_getScript();
      if (v472 > 0) {
        goto LABEL_474;
      }
      if (Script) {
        break;
      }
      ++v176;
      --v175;
      ++v177;
      if (v467 == v176) {
        goto LABEL_474;
      }
    }
    if (Script > 0xF || ((1 << Script) & 0x8410) == 0)
    {
LABEL_474:
      uint64_t v27 = v443;
LABEL_532:
      uint64_t UnicodePropertyDataForPlane = v415;
LABEL_533:
      uint64_t v420 = 0;
      v422 = result;
      uint64_t v435 = 0;
      uint64_t v436 = 0;
      unsigned __int8 v212 = searchOptions;
      uint64_t v213 = 0;
      uint64_t v214 = 0;
      BOOL v215 = v438 == 8;
      if (v456) {
        BOOL v216 = SpecialCaseHandlingLanguageIdentifierForLocale == 0;
      }
      else {
        BOOL v216 = 1;
      }
      int v217 = !v216;
      uint64_t v218 = (uint64_t)&theSet[1];
      int v219 = v466;
      if (!v466) {
        uint64_t v218 = 8;
      }
      uint64_t v416 = 0;
      v417 = (int *)v218;
      unint64_t v220 = (unint64_t)theSet | 0xC;
      if (!v466) {
        unint64_t v220 = 12;
      }
      v424 = (UTF32Char *)v220;
      uint64_t v221 = (uint64_t)&v471;
      if (!v466) {
        uint64_t v221 = 16;
      }
      v418 = (UTF32Char *)v221;
      uint64_t v222 = (uint64_t)&v471 + 8;
      if (!v466) {
        uint64_t v222 = 24;
      }
      v419 = (uint64_t *)v222;
      uint64_t v423 = v212 & 0x90;
      uint64_t v414 = UnicodePropertyDataForPlane + 256;
      uint64_t v428 = v32;
      uint64_t v223 = v27;
      int v459 = v217;
      while (1)
      {
        uint64_t v224 = 0;
        uint64_t v225 = 0;
        uint64_t v226 = 0;
        uint64_t v429 = 0;
        uint64_t v430 = 0;
        uint64_t v431 = 0;
        uint64_t v437 = 0;
        uint64_t v227 = v223;
        uint64_t v462 = v223;
        while (1)
        {
          uint64_t v451 = v227;
          uint64_t v439 = v225;
          *(void *)v440 = v224;
          uint64_t v228 = v226;
          uint64_t v445 = v226;
LABEL_550:
          uint64_t v229 = v224 - 4;
          if ((unint64_t)v224 < 4) {
            uint64_t v229 = 0;
          }
          uint64_t v450 = v229;
          uint64_t v448 = v229 + 64;
          uint64_t v230 = v224 + 1;
          uint64_t v231 = v224 - 3;
          if ((unint64_t)(v224 + 1) < 4) {
            uint64_t v231 = 0;
          }
          uint64_t v455 = v231;
          uint64_t v453 = v231 + 64;
          if (v228 <= 0) {
            uint64_t v232 = 0;
          }
          else {
            uint64_t v232 = -1;
          }
          uint64_t v465 = v228;
          if (v225)
          {
LABEL_558:
            UTF32Char v233 = __s1[v213++];
            if (!v228) {
              goto LABEL_567;
            }
LABEL_559:
            UTF32Char v234 = __s2[v214++];
            goto LABEL_574;
          }
          while (1)
          {
            if (v227 < 0 || (uint64_t v235 = v508, (uint64_t)v508 <= v227))
            {
              UTF32Char v233 = 0;
              goto LABEL_566;
            }
            v236 = (UniChar *)v506[1];
            if (v506[1])
            {
              uint64_t v237 = *((void *)&v507 + 1) + v227;
            }
            else
            {
              if ((void)v507)
              {
                UniChar v238 = *(char *)(v507 + *((void *)&v507 + 1) + v227);
                goto LABEL_637;
              }
              if (v509 <= v227 || (uint64_t v271 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v227))
              {
                uint64_t v272 = v227 - 4;
                if ((unint64_t)v227 < 4) {
                  uint64_t v272 = 0;
                }
                if (v272 + 64 < (uint64_t)v508) {
                  uint64_t v235 = v272 + 64;
                }
                *((void *)&v508 + 1) = v272;
                uint64_t v509 = v235;
                v524.CFIndex location = *((void *)&v507 + 1) + v272;
                v524.CFIndex length = v235 - v272;
                CFStringGetCharacters(v506[0], v524, buffer);
                uint64_t v228 = v465;
                int v217 = v459;
                BOOL v215 = v438 == 8;
                uint64_t v223 = v462;
                int v219 = v466;
                uint64_t v271 = *((void *)&v508 + 1);
              }
              uint64_t v237 = v227 - v271;
              v236 = buffer;
            }
            UniChar v238 = v236[v237];
LABEL_637:
            UTF32Char v233 = v238;
            if (v456 && v238 >= 0x41u && v238 <= 0x5Au)
            {
              if (v238 != 73 || SpecialCaseHandlingLanguageIdentifierForLocale == 0) {
                UTF32Char v233 = v238 + 32;
              }
              else {
                UTF32Char v233 = 73;
              }
            }
LABEL_566:
            uint64_t v469 = 1;
            if (v228) {
              goto LABEL_559;
            }
LABEL_567:
            if ((v224 & 0x8000000000000000) == 0)
            {
              CFIndex v239 = v495;
              if ((uint64_t)v495 > v224)
              {
                v240 = (UniChar *)v493[1];
                if (v493[1])
                {
                  CFIndex v241 = range.length + v224;
                  goto LABEL_571;
                }
                if (range.location)
                {
                  UniChar v242 = *(char *)(range.location + range.length + v224);
                }
                else
                {
                  if (v496 <= v224 || (uint64_t v273 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v224))
                  {
                    if (v448 < (uint64_t)v495) {
                      CFIndex v239 = v448;
                    }
                    *((void *)&v495 + 1) = v450;
                    CFIndex v496 = v239;
                    v525.CFIndex location = range.length + v450;
                    v525.CFIndex length = v239 - v450;
                    CFStringGetCharacters(v493[0], v525, v485);
                    uint64_t v228 = v465;
                    int v217 = v459;
                    BOOL v215 = v438 == 8;
                    uint64_t v223 = v462;
                    int v219 = v466;
                    uint64_t v273 = *((void *)&v495 + 1);
                  }
                  CFIndex v241 = v224 - v273;
                  v240 = v485;
LABEL_571:
                  UniChar v242 = v240[v241];
                }
                UTF32Char v234 = v242;
                if (v456 && v242 >= 0x41u && v242 <= 0x5Au)
                {
                  if (v242 != 73 || SpecialCaseHandlingLanguageIdentifierForLocale == 0) {
                    UTF32Char v234 = v242 + 32;
                  }
                  else {
                    UTF32Char v234 = 73;
                  }
                }
                goto LABEL_573;
              }
            }
            UTF32Char v234 = 0;
LABEL_573:
            uint64_t v468 = 1;
LABEL_574:
            if (v233 == v234)
            {
              uint64_t v226 = v228;
              goto LABEL_796;
            }
            if ((v234 | v233) > 0x7F) {
              int v243 = 1;
            }
            else {
              int v243 = v219;
            }
            if ((v243 | v217) != 1)
            {
              char v311 = 1;
              goto LABEL_839;
            }
            if ((v233 & 0xFC00) == 0xD800 && v227 >= -1)
            {
              uint64_t v244 = v227 + 1;
              uint64_t v245 = v508;
              if ((uint64_t)v508 <= v227 + 1)
              {
                uint64_t v19 = v463;
                goto LABEL_590;
              }
              v246 = (UniChar *)v506[1];
              if (v506[1])
              {
                uint64_t v247 = *((void *)&v507 + 1) + v244;
                goto LABEL_584;
              }
              if ((void)v507)
              {
                UniChar v248 = *(char *)(v507 + *((void *)&v507 + 1) + v244);
              }
              else
              {
                if (v509 <= v244 || (uint64_t v269 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v244))
                {
                  uint64_t v270 = v227 - 3;
                  if ((unint64_t)v244 < 4) {
                    uint64_t v270 = 0;
                  }
                  if (v270 + 64 < (uint64_t)v508) {
                    uint64_t v245 = v270 + 64;
                  }
                  *((void *)&v508 + 1) = v270;
                  uint64_t v509 = v245;
                  v523.CFIndex location = *((void *)&v507 + 1) + v270;
                  v523.CFIndex length = v245 - v270;
                  CFStringGetCharacters(v506[0], v523, buffer);
                  uint64_t v228 = v465;
                  int v217 = v459;
                  BOOL v215 = v438 == 8;
                  uint64_t v223 = v462;
                  int v219 = v466;
                  uint64_t v269 = *((void *)&v508 + 1);
                }
                uint64_t v247 = v244 - v269;
                v246 = buffer;
LABEL_584:
                UniChar v248 = v246[v247];
              }
              uint64_t v19 = v463;
              if (v248 >> 10 == 55)
              {
                UTF32Char v233 = ((unsigned __int16)v233 << 10) - 56613888 + v248;
                uint64_t v469 = 2;
              }
            }
LABEL_590:
            if ((v234 & 0xFC00) != 0xD800) {
              goto LABEL_600;
            }
            if (v224 < -1) {
              goto LABEL_600;
            }
            CFIndex v249 = v495;
            if ((uint64_t)v495 <= v230) {
              goto LABEL_600;
            }
            v250 = (UniChar *)v493[1];
            if (v493[1])
            {
              CFIndex v251 = range.length + v230;
LABEL_595:
              UniChar v252 = v250[v251];
              goto LABEL_598;
            }
            if (!range.location)
            {
              if (v496 <= v230 || (uint64_t v265 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v230))
              {
                if (v453 < (uint64_t)v495) {
                  CFIndex v249 = v453;
                }
                *((void *)&v495 + 1) = v455;
                CFIndex v496 = v249;
                v522.CFIndex location = range.length + v455;
                v522.CFIndex length = v249 - v455;
                CFStringGetCharacters(v493[0], v522, v485);
                uint64_t v228 = v465;
                int v217 = v459;
                BOOL v215 = v438 == 8;
                uint64_t v223 = v462;
                int v219 = v466;
                uint64_t v265 = *((void *)&v495 + 1);
              }
              CFIndex v251 = v230 - v265;
              v250 = v485;
              goto LABEL_595;
            }
            UniChar v252 = *(char *)(range.location + range.length + v230);
LABEL_598:
            if (v252 >> 10 == 55)
            {
              UTF32Char v234 = ((unsigned __int16)v234 << 10) - 56613888 + v252;
              uint64_t v468 = 2;
            }
LABEL_600:
            if (!v219)
            {
              uint64_t v224 = *(void *)v440;
              uint64_t v226 = v445;
              goto LABEL_736;
            }
            int v253 = v227 != v223 || v215;
            char v254 = (char)theSet[1];
            if (v253 != 1 || v227 >= v19) {
              goto LABEL_697;
            }
            unsigned int v255 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) > v233 || v471 <= v233)
            {
              if (((uint64_t)theSet[1] & 4) == 0) {
                goto LABEL_697;
              }
              goto LABEL_666;
            }
            if (HIWORD(v233) || ((uint64_t)theSet[1] & 2) != 0) {
              break;
            }
            if (*((void *)&v471 + 1))
            {
              if ((uint64_t)theSet[1])
              {
                unsigned int v261 = v255 >> 2;
                uint64_t v262 = *(unsigned __int8 *)(*((void *)&v471 + 1) + ((unint64_t)v233 >> 8));
                if (!*(unsigned char *)(*((void *)&v471 + 1) + ((unint64_t)v233 >> 8))) {
                  goto LABEL_633;
                }
                if (v262 == 255)
                {
                  unsigned int v261 = v255 == 0;
LABEL_633:
                  if (!v261) {
                    goto LABEL_697;
                  }
                  goto LABEL_666;
                }
                BOOL v266 = v255 == 0;
                if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v471 + 1)
                                                            + 32 * v262
                                                            + (v233 >> 3)
                                                            + 224) >> (v233 & 7)) & 1) != 0)
                  unsigned int v261 = v266;
                if (!v261) {
                  goto LABEL_697;
                }
              }
              else
              {
                BOOL v49 = v255 == 0;
                BOOL v256 = v255 != 0;
                char v257 = v49;
                if (((unint64_t)*(unsigned __int8 *)(*((void *)&v471 + 1) + ((unint64_t)v233 >> 3)) >> (v233 & 7))) {
                  BOOL v256 = v257;
                }
                if (!v256) {
                  goto LABEL_697;
                }
              }
            }
            else
            {
              BOOL v49 = v255 == 0;
              BOOL v259 = v255 != 0;
              char v260 = v49;
              if (((uint64_t)theSet[1] & 1) == 0) {
                BOOL v259 = v260;
              }
              if (!v259) {
                goto LABEL_697;
              }
            }
LABEL_666:
            if (v213 == v225 && v225 > 0) {
              uint64_t v225 = 0;
            }
            uint64_t v268 = v469;
            if (v225) {
              uint64_t v268 = 0;
            }
            v227 += v268;
            v214 += v232;
            if (v225) {
              goto LABEL_558;
            }
          }
          int IsLongCharacterMember = CFCharacterSetIsLongCharacterMember(theSet[0], v233);
          uint64_t v228 = v465;
          int v217 = v459;
          BOOL v215 = v438 == 8;
          uint64_t v223 = v462;
          int v219 = v466;
          if (IsLongCharacterMember) {
            goto LABEL_666;
          }
          char v254 = (char)theSet[1];
LABEL_697:
          unsigned int v274 = v254 & 4;
          if (HIDWORD(theSet[1]) > v234 || v471 <= v234)
          {
            if ((v254 & 4) == 0) {
              goto LABEL_812;
            }
            goto LABEL_725;
          }
          if (HIWORD(v234) || (v254 & 2) != 0)
          {
            int v277 = CFCharacterSetIsLongCharacterMember(theSet[0], v234);
            uint64_t v228 = v465;
            int v217 = v459;
            BOOL v215 = v438 == 8;
            uint64_t v223 = v462;
            int v219 = v466;
            if (!v277) {
              goto LABEL_812;
            }
            goto LABEL_725;
          }
          if (!*((void *)&v471 + 1))
          {
            BOOL v49 = v274 == 0;
            BOOL v278 = v274 != 0;
            char v279 = v49;
            if (v254) {
              char v280 = v278;
            }
            else {
              char v280 = v279;
            }
            if ((v280 & 1) == 0) {
              goto LABEL_812;
            }
            goto LABEL_725;
          }
          if ((v254 & 1) == 0) {
            break;
          }
          unsigned int v281 = v274 >> 2;
          uint64_t v282 = *(unsigned __int8 *)(*((void *)&v471 + 1) + ((unint64_t)v234 >> 8));
          if (*(unsigned char *)(*((void *)&v471 + 1) + ((unint64_t)v234 >> 8)))
          {
            if (v282 == 255)
            {
              unsigned int v281 = v274 == 0;
            }
            else
            {
              BOOL v283 = v274 == 0;
              if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v471 + 1)
                                                          + 32 * v282
                                                          + (v234 >> 3)
                                                          + 224) >> (v234 & 7)) & 1) != 0)
                unsigned int v281 = v283;
            }
          }
          if (v281) {
            goto LABEL_725;
          }
LABEL_812:
          uint64_t v226 = v228;
          uint64_t v451 = v227;
          uint64_t v439 = v225;
LABEL_736:
          uint64_t v286 = v435;
          uint64_t v287 = v436;
          if ((v441 & 0x80) != 0 && v451 > v223)
          {
            if (v225)
            {
              uint64_t v288 = v224;
              goto LABEL_740;
            }
            uint64_t v290 = BitmapPtrForPlane;
            if (v233 >= 0x10000)
            {
              uint64_t v290 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v233));
              uint64_t v286 = v435;
              uint64_t v228 = v465;
              int v217 = v459;
              BOOL v215 = v438 == 8;
              uint64_t v223 = v462;
              int v219 = v466;
            }
            uint64_t v288 = v224;
            if (v290)
            {
              int v291 = (1 << (v233 & 7)) & *(unsigned __int8 *)(v290 + ((unsigned __int16)v233 >> 3));
              BOOL v289 = v291 != 0;
              if (v291) {
                UTF32Char v233 = v234;
              }
              if (!v228)
              {
LABEL_748:
                uint64_t v292 = BitmapPtrForPlane;
                if (v234 >= 0x10000)
                {
                  uint64_t v293 = v286;
                  uint64_t v292 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v234));
                  uint64_t v286 = v293;
                  uint64_t v287 = v436;
                  uint64_t v228 = v465;
                  int v217 = v459;
                  BOOL v215 = v438 == 8;
                  uint64_t v223 = v462;
                  int v219 = v466;
                }
                if (v292)
                {
                  int v294 = (1 << (v234 & 7)) & *(unsigned __int8 *)(v292 + ((unsigned __int16)v234 >> 3));
                  if (v294) {
                    UTF32Char v295 = v233;
                  }
                  else {
                    UTF32Char v295 = v234;
                  }
                  if ((v289 ^ (v294 != 0)))
                  {
                    uint64_t v296 = v468;
                    if (!v289) {
                      uint64_t v296 = 0;
                    }
                    uint64_t v224 = v288 - v296;
                    if (v294)
                    {
                      v451 -= v469;
                      UTF32Char v234 = v233;
                    }
                    goto LABEL_763;
                  }
                  UTF32Char v234 = v295;
LABEL_762:
                  uint64_t v224 = v288;
                  goto LABEL_763;
                }
              }
            }
            else
            {
LABEL_740:
              BOOL v289 = 0;
              if (!v228) {
                goto LABEL_748;
              }
            }
            if (v289)
            {
              uint64_t v224 = v288 - v468;
              goto LABEL_763;
            }
            goto LABEL_762;
          }
LABEL_763:
          uint64_t v297 = v437;
          if (v233 == v234)
          {
            uint64_t v225 = v439;
            goto LABEL_769;
          }
          if (v225)
          {
            BOOL v298 = 0;
            uint64_t v225 = v439;
            goto LABEL_767;
          }
          if (v287 && v287 != v451)
          {
            uint64_t v225 = 0;
            goto LABEL_831;
          }
          uint64_t v446 = v226;
          uint64_t v213 = v451 - v286 + 1;
          if (v420 >= 1 && v451 >= v286 && v451 < v416 + v286 && v213 < v420)
          {
            BOOL v298 = 0;
            uint64_t v287 = 0;
            UTF32Char v233 = __s1[v451 - v286];
            uint64_t v225 = v420;
            goto LABEL_767;
          }
          LOBYTE(v473[0]) = 0;
          uint64_t v420 = __CFStringFoldCharacterClusterAtIndex(v233, buffer, v451, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s1, &v469, v473);
          if (v420 > 0)
          {
            uint64_t v213 = 1;
            UTF32Char v233 = __s1[0];
          }
          uint64_t v416 = v469;
          if (LOBYTE(v473[0]))
          {
            uint64_t RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex(theString, v451, 1);
            uint64_t v305 = 2;
            if (RangeOfCharacterClusterAtIndex > 2) {
              uint64_t v305 = RangeOfCharacterClusterAtIndex;
            }
            uint64_t v306 = v305 - 1;
            uint64_t v307 = v451;
            if (v443 <= v433) {
              uint64_t v287 = RangeOfCharacterClusterAtIndex + v304;
            }
            else {
              uint64_t v287 = v306;
            }
          }
          else
          {
            uint64_t v307 = v451;
            uint64_t v287 = 0;
          }
          uint64_t v286 = v307;
          uint64_t v225 = v420;
          int v219 = v466;
          uint64_t v223 = v462;
          BOOL v215 = v438 == 8;
          int v217 = v459;
          uint64_t v226 = v446;
          uint64_t v228 = v465;
LABEL_831:
          BOOL v298 = v225 == 0;
          if (!v225 && v226 > 0)
          {
            uint64_t v435 = v286;
            uint64_t v436 = v287;
            uint64_t v225 = 0;
LABEL_920:
            uint64_t v227 = v451;
            goto LABEL_921;
          }
LABEL_767:
          if (v228)
          {
LABEL_768:
            uint64_t v297 = v437;
            goto LABEL_769;
          }
          if (v233 != v234) {
            BOOL v298 = 1;
          }
          if (!v298)
          {
            uint64_t v435 = v286;
            uint64_t v436 = v287;
            goto LABEL_794;
          }
          if (v430 && v430 != v224)
          {
            uint64_t v435 = v286;
            uint64_t v436 = v287;
            if (v233 != v234) {
              goto LABEL_920;
            }
LABEL_794:
            uint64_t v226 = 0;
LABEL_795:
            uint64_t v227 = v451;
            goto LABEL_796;
          }
          uint64_t v214 = v224 - v437 + 1;
          if (v431 >= 1 && v224 >= v437 && v224 < v429 + v437 && v214 < v431)
          {
            if (v233 == __s2[v224 - v437])
            {
              uint64_t v430 = 0;
              uint64_t v226 = v431;
              goto LABEL_768;
            }
LABEL_919:
            uint64_t v435 = v286;
            uint64_t v436 = v287;
            goto LABEL_920;
          }
          uint64_t v308 = v286;
          LOBYTE(v473[0]) = 0;
          uint64_t v431 = __CFStringFoldCharacterClusterAtIndex(v234, v485, v224, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s2, &v468, v473);
          uint64_t v429 = v468;
          if (LOBYTE(v473[0]))
          {
            uint64_t v309 = CFStringGetRangeOfCharacterClusterAtIndex(theStringa, v224, 1);
            uint64_t v430 = v309 + v310;
          }
          else
          {
            uint64_t v430 = 0;
          }
          int v219 = v466;
          uint64_t v223 = v462;
          BOOL v215 = v438 == 8;
          int v217 = v459;
          uint64_t v286 = v308;
          if (!v431 || v233 != __s2[0]) {
            goto LABEL_919;
          }
          uint64_t v297 = v224;
          uint64_t v226 = v431;
          uint64_t v214 = 1;
LABEL_769:
          uint64_t v436 = v287;
          uint64_t v437 = v297;
          uint64_t v435 = v286;
          if (v225 < 1 || v226 < 1) {
            goto LABEL_795;
          }
          while (v213 < v225 && v214 < v226)
          {
            if (__s1[v213] != __s2[v214]) {
              goto LABEL_920;
            }
            ++v213;
            ++v214;
          }
          if (v213 >= v225) {
            goto LABEL_795;
          }
          uint64_t v227 = v451;
          if (v214 < v226) {
            goto LABEL_921;
          }
LABEL_796:
          if (v213 == v225 && v225 > 0) {
            uint64_t v225 = 0;
          }
          if (v214 == v226 && v226 > 0) {
            uint64_t v226 = 0;
          }
          uint64_t v301 = v469;
          if (v225) {
            uint64_t v301 = 0;
          }
          v227 += v301;
          uint64_t v302 = v468;
          if (v226) {
            uint64_t v302 = 0;
          }
          v224 += v302;
          if (v224 >= v467) {
            goto LABEL_921;
          }
        }
        BOOL v275 = v274 != 0;
        BOOL v276 = v274 == 0;
        if (((unint64_t)*(unsigned __int8 *)(*((void *)&v471 + 1) + ((unint64_t)v234 >> 3)) >> (v234 & 7))) {
          BOOL v275 = v276;
        }
        if (!v275) {
          goto LABEL_812;
        }
LABEL_725:
        if (v214 == v228 && v228 > 0) {
          uint64_t v228 = 0;
        }
        uint64_t v285 = v468;
        if (v228) {
          uint64_t v285 = 0;
        }
        v224 += v285;
        v213 -= v225 > 0;
        if (v224 < v467) {
          goto LABEL_550;
        }
LABEL_921:
        if (v227 == v19) {
          int v338 = v219;
        }
        else {
          int v338 = 0;
        }
        if (v338 != 1 || v224 >= v467)
        {
          char v311 = v466 ^ 1;
          goto LABEL_839;
        }
        while (2)
        {
          if (v224 < 0 || (CFIndex v339 = v495, (uint64_t)v495 <= v224))
          {
            UTF32Char v343 = 0;
          }
          else
          {
            v340 = (UniChar *)v493[1];
            if (v493[1])
            {
              CFIndex v341 = range.length + v224;
              goto LABEL_930;
            }
            if (range.location)
            {
              UniChar v342 = *(char *)(range.location + range.length + v224);
            }
            else
            {
              if (v496 <= v224 || (uint64_t v359 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v224))
              {
                uint64_t v360 = v224 - 4;
                if ((unint64_t)v224 < 4) {
                  uint64_t v360 = 0;
                }
                if (v360 + 64 < (uint64_t)v495) {
                  CFIndex v339 = v360 + 64;
                }
                *((void *)&v495 + 1) = v360;
                CFIndex v496 = v339;
                v529.CFIndex location = range.length + v360;
                v529.CFIndex length = v339 - v360;
                CFStringGetCharacters(v493[0], v529, v485);
                int v217 = v459;
                BOOL v215 = v438 == 8;
                uint64_t v223 = v462;
                int v219 = v466;
                uint64_t v359 = *((void *)&v495 + 1);
              }
              CFIndex v341 = v224 - v359;
              v340 = v485;
LABEL_930:
              UniChar v342 = v340[v341];
            }
            UTF32Char v343 = v342;
            if (v342 >> 10 == 54)
            {
              unint64_t v351 = v224;
              uint64_t v352 = v224 + 1;
              CFIndex v353 = v495;
              if ((uint64_t)v495 <= v352)
              {
                uint64_t v224 = v351;
              }
              else
              {
                v354 = (UniChar *)v493[1];
                if (v493[1])
                {
                  CFIndex v355 = range.length + v352;
                  goto LABEL_959;
                }
                if (range.location)
                {
                  UniChar v356 = *(char *)(range.location + range.length + v352);
                }
                else
                {
                  if (v496 <= v352 || (uint64_t v364 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v352))
                  {
                    unint64_t v365 = v351 - 3;
                    if (v351 < 3) {
                      unint64_t v365 = 0;
                    }
                    if ((uint64_t)(v365 + 64) < (uint64_t)v495) {
                      CFIndex v353 = v365 + 64;
                    }
                    *((void *)&v495 + 1) = v365;
                    CFIndex v496 = v353;
                    v530.CFIndex location = range.length + v365;
                    v530.CFIndex length = v353 - v365;
                    CFStringGetCharacters(v493[0], v530, v485);
                    int v217 = v459;
                    BOOL v215 = v438 == 8;
                    uint64_t v223 = v462;
                    int v219 = v466;
                    uint64_t v364 = *((void *)&v495 + 1);
                  }
                  CFIndex v355 = v352 - v364;
                  v354 = v485;
LABEL_959:
                  UniChar v356 = v354[v355];
                }
                uint64_t v224 = v351;
                if (v356 >> 10 == 55) {
                  UTF32Char v343 = (v343 << 10) - 56613888 + v356;
                }
              }
            }
          }
          int v344 = *v417;
          unsigned int v345 = *v417 & 4;
          if (*v424 > v343 || *v418 <= v343)
          {
            if (!v345) {
              goto LABEL_996;
            }
            goto LABEL_946;
          }
          if (HIWORD(v343) || (v344 & 2) != 0)
          {
            int v350 = CFCharacterSetIsLongCharacterMember(*v434, v343);
            int v217 = v459;
            BOOL v215 = v438 == 8;
            uint64_t v223 = v462;
            int v219 = v466;
            if (!v350) {
              goto LABEL_996;
            }
LABEL_946:
            if (v343 < 0x10000) {
              uint64_t v349 = 1;
            }
            else {
              uint64_t v349 = 2;
            }
            v224 += v349;
            if (v224 >= v467) {
              goto LABEL_996;
            }
            continue;
          }
          break;
        }
        uint64_t v346 = *v419;
        if (*v419)
        {
          if (v344)
          {
            unsigned int v361 = v345 >> 2;
            uint64_t v362 = *(unsigned __int8 *)(v346 + ((unint64_t)v343 >> 8));
            if (*(unsigned char *)(v346 + ((unint64_t)v343 >> 8)))
            {
              if (v362 == 255)
              {
                unsigned int v361 = v345 == 0;
              }
              else
              {
                BOOL v363 = v345 == 0;
                if (((unint64_t)*(unsigned __int8 *)(v346 + 32 * v362 + (v343 >> 3) + 224) >> (v343 & 7))) {
                  unsigned int v361 = v363;
                }
              }
            }
            if (!v361) {
              goto LABEL_996;
            }
          }
          else
          {
            BOOL v49 = v345 == 0;
            BOOL v347 = v345 != 0;
            char v348 = v49;
            if (((unint64_t)*(unsigned __int8 *)(v346 + ((unint64_t)v343 >> 3)) >> (v343 & 7))) {
              BOOL v347 = v348;
            }
            if (!v347) {
              goto LABEL_996;
            }
          }
          goto LABEL_946;
        }
        BOOL v49 = v345 == 0;
        BOOL v357 = v345 != 0;
        char v358 = v49;
        if ((v344 & 1) == 0) {
          BOOL v357 = v358;
        }
        if (v357) {
          goto LABEL_946;
        }
LABEL_996:
        char v311 = v466 ^ 1;
        uint64_t v227 = v19;
LABEL_839:
        if (v224 != v467) {
          goto LABEL_889;
        }
        if (v225 < 1)
        {
LABEL_852:
          if (!v423 || v227 >= v19) {
            goto LABEL_1040;
          }
          if (v227 < 0 || (uint64_t v314 = v508, (uint64_t)v508 <= v227))
          {
            unsigned int v318 = 0;
          }
          else
          {
            v315 = (UniChar *)v506[1];
            if (v506[1])
            {
              uint64_t v316 = *((void *)&v507 + 1) + v227;
              goto LABEL_858;
            }
            if ((void)v507)
            {
              UniChar v317 = *(char *)(v507 + *((void *)&v507 + 1) + v227);
            }
            else
            {
              if (v509 <= v227 || (uint64_t v332 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v227))
              {
                uint64_t v333 = v227 - 4;
                if ((unint64_t)v227 < 4) {
                  uint64_t v333 = 0;
                }
                if (v333 + 64 < (uint64_t)v508) {
                  uint64_t v314 = v333 + 64;
                }
                *((void *)&v508 + 1) = v333;
                uint64_t v509 = v314;
                v526.CFIndex location = *((void *)&v507 + 1) + v333;
                v526.CFIndex length = v314 - v333;
                CFStringGetCharacters(v506[0], v526, buffer);
                int v217 = v459;
                BOOL v215 = v438 == 8;
                uint64_t v223 = v462;
                int v219 = v466;
                uint64_t v332 = *((void *)&v508 + 1);
              }
              uint64_t v316 = v227 - v332;
              v315 = buffer;
LABEL_858:
              UniChar v317 = v315[v316];
            }
            unsigned int v318 = v317;
            if (v317 >> 10 == 54)
            {
              uint64_t v325 = v227 + 1;
              uint64_t v326 = v508;
              if ((uint64_t)v508 > v227 + 1)
              {
                v327 = (UniChar *)v506[1];
                if (v506[1])
                {
                  uint64_t v328 = *((void *)&v507 + 1) + v325;
                  goto LABEL_878;
                }
                if ((void)v507)
                {
                  UniChar v329 = *(char *)(v507 + *((void *)&v507 + 1) + v325);
                }
                else
                {
                  if (v509 <= v325 || (uint64_t v336 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v325))
                  {
                    uint64_t v337 = v227 - 3;
                    if ((unint64_t)v227 < 3) {
                      uint64_t v337 = 0;
                    }
                    if (v337 + 64 < (uint64_t)v508) {
                      uint64_t v326 = v337 + 64;
                    }
                    *((void *)&v508 + 1) = v337;
                    uint64_t v509 = v326;
                    v528.CFIndex location = *((void *)&v507 + 1) + v337;
                    v528.CFIndex length = v326 - v337;
                    CFStringGetCharacters(v506[0], v528, buffer);
                    int v217 = v459;
                    BOOL v215 = v438 == 8;
                    uint64_t v223 = v462;
                    int v219 = v466;
                    uint64_t v336 = *((void *)&v508 + 1);
                  }
                  uint64_t v328 = v325 - v336;
                  v327 = buffer;
LABEL_878:
                  UniChar v329 = v327[v328];
                }
                uint64_t v319 = BitmapPtrForPlane;
                if (v329 >> 10 == 55)
                {
                  unsigned int v318 = (v318 << 10) - 56613888 + v329;
                  uint64_t v319 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v318));
                  int v217 = v459;
                  BOOL v215 = v438 == 8;
                  uint64_t v223 = v462;
                  int v219 = v466;
                }
LABEL_861:
                if (v319 && ((*(unsigned __int8 *)(v319 + ((unsigned __int16)v318 >> 3)) >> (v318 & 7)) & 1) != 0)
                {
                  if ((v441 & 0x80) == 0) {
                    goto LABEL_889;
                  }
                  if (!HIWORD(v318))
                  {
                    uint64_t v366 = -v227;
                    uint64_t v367 = v227 + 64;
                    uint64_t v368 = v227;
                    do
                    {
                      if ((unint64_t)v368 >= 5) {
                        uint64_t v369 = 5;
                      }
                      else {
                        uint64_t v369 = v368;
                      }
                      uint64_t v370 = v368 - 1;
                      if (v368 >= 1 && (uint64_t v371 = v508, (uint64_t)v508 >= v368))
                      {
                        if (v506[1])
                        {
                          UniChar v372 = *((_WORD *)v506[1] + v368 + *((void *)&v507 + 1) - 1);
                        }
                        else if ((void)v507)
                        {
                          UniChar v372 = *(char *)(v507 + *((void *)&v507 + 1) + v368 - 1);
                        }
                        else
                        {
                          if (v509 < v368 || (uint64_t v373 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) >= v368))
                          {
                            uint64_t v374 = -v369;
                            uint64_t v375 = v367 - v369;
                            uint64_t v376 = v369 + v366;
                            uint64_t v377 = v368 + v374;
                            uint64_t v378 = v377 + 64;
                            if (v377 + 64 >= (uint64_t)v508) {
                              uint64_t v378 = v508;
                            }
                            *((void *)&v508 + 1) = v377;
                            uint64_t v509 = v378;
                            if ((uint64_t)v508 >= v375) {
                              uint64_t v371 = v375;
                            }
                            v531.CFIndex length = v371 + v376;
                            v531.CFIndex location = v377 + *((void *)&v507 + 1);
                            CFStringGetCharacters(v506[0], v531, buffer);
                            uint64_t v223 = v462;
                            uint64_t v373 = *((void *)&v508 + 1);
                          }
                          UniChar v372 = buffer[v368 - 1 - v373];
                        }
                      }
                      else
                      {
                        UniChar v372 = 0;
                      }
                      ++v366;
                      --v367;
                      --v368;
                    }
                    while (*(uint64_t *)v425 < v370);
                    if (v372 <= 0x50Fu)
                    {
                      uint64_t v379 = v227 + 1;
                      do
                      {
                        uint64_t v227 = v379;
                        if (v379 >= v19) {
                          break;
                        }
                        if (v379 - 1 >= -1)
                        {
                          uint64_t v382 = v508;
                          uint64_t v381 = BitmapPtrForPlane;
                          if ((uint64_t)v508 <= v227)
                          {
                            UniChar v380 = 0;
                          }
                          else if (v506[1])
                          {
                            UniChar v380 = *((_WORD *)&v506[1]->isa + v227 + *((void *)&v507 + 1));
                          }
                          else if ((void)v507)
                          {
                            UniChar v380 = *(char *)(v507 + *((void *)&v507 + 1) + v227);
                          }
                          else
                          {
                            if (v509 <= v227 || (uint64_t v385 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v227))
                            {
                              uint64_t v386 = v227 - 4;
                              if ((unint64_t)v227 < 4) {
                                uint64_t v386 = 0;
                              }
                              if (v386 + 64 < (uint64_t)v508) {
                                uint64_t v382 = v386 + 64;
                              }
                              *((void *)&v508 + 1) = v386;
                              uint64_t v509 = v382;
                              v532.CFIndex location = *((void *)&v507 + 1) + v386;
                              v532.CFIndex length = v382 - v386;
                              CFStringGetCharacters(v506[0], v532, buffer);
                              uint64_t v223 = v462;
                              uint64_t v385 = *((void *)&v508 + 1);
                            }
                            UniChar v380 = buffer[v227 - v385];
                          }
                        }
                        else
                        {
                          UniChar v380 = 0;
                          uint64_t v381 = BitmapPtrForPlane;
                        }
                        if (!v381) {
                          break;
                        }
                        unsigned int v383 = *(unsigned __int8 *)(v381 + (v380 >> 3));
                        char v384 = v380 & 7;
                        uint64_t v379 = v227 + 1;
                      }
                      while (((v383 >> v384) & 1) != 0);
                    }
                  }
                  goto LABEL_1040;
                }
                if ((v441 & 0x80) != 0) {
                  goto LABEL_1040;
                }
                uint64_t v320 = v227 - 1;
                if (v227 < 1 || (uint64_t v321 = v508, (uint64_t)v508 < v227))
                {
                  UniChar v322 = 0;
                  goto LABEL_881;
                }
                v323 = (UniChar *)v506[1];
                if (v506[1])
                {
                  uint64_t v324 = *((void *)&v507 + 1) + v320;
                  goto LABEL_871;
                }
                if ((void)v507)
                {
                  UniChar v322 = *(char *)(v507 + *((void *)&v507 + 1) + v320);
                }
                else
                {
                  if (v509 < v227 || (uint64_t v334 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) >= v227))
                  {
                    uint64_t v335 = v227 - 5;
                    if ((unint64_t)v227 < 5) {
                      uint64_t v335 = 0;
                    }
                    if (v335 + 64 < (uint64_t)v508) {
                      uint64_t v321 = v335 + 64;
                    }
                    *((void *)&v508 + 1) = v335;
                    uint64_t v509 = v321;
                    v527.CFIndex location = *((void *)&v507 + 1) + v335;
                    v527.CFIndex length = v321 - v335;
                    CFStringGetCharacters(v506[0], v527, buffer);
                    uint64_t v223 = v462;
                    uint64_t v334 = *((void *)&v508 + 1);
                  }
                  uint64_t v324 = v320 - v334;
                  v323 = buffer;
LABEL_871:
                  UniChar v322 = v323[v324];
                }
LABEL_881:
                if (v318 == 847
                  || v322 == 847
                  || v322 == 8205
                  || (unsigned __int16)(v322 - 4352) < 0xFAu
                  || v415
                  && *(unsigned char *)(v415 + HIBYTE(v322))
                  && *(unsigned char *)(v414 + (*(unsigned __int8 *)(v415 + HIBYTE(v322)) << 8) - 256 + v322) == 9)
                {
                  uint64_t v330 = CFStringGetRangeOfCharacterClusterAtIndex(theString, v227 - 1, 1);
                  int v217 = v459;
                  BOOL v215 = v438 == 8;
                  uint64_t v223 = v462;
                  int v219 = v466;
                  if (v227 < v330 + v331) {
                    goto LABEL_889;
                  }
                }
LABEL_1040:
                if (v438 == 12) {
                  char v387 = v311;
                }
                else {
                  char v387 = 1;
                }
                if (v387)
                {
                  v388 = v422;
                }
                else
                {
                  v388 = v422;
                  if (v227 < v19)
                  {
                    v389 = v417;
                    do
                    {
                      if (v227 < 0 || (uint64_t v390 = v508, (uint64_t)v508 <= v227))
                      {
                        UTF32Char v392 = 0;
                      }
                      else
                      {
                        if (v506[1])
                        {
                          UniChar v391 = *((_WORD *)&v506[1]->isa + *((void *)&v507 + 1) + v227);
                        }
                        else if ((void)v507)
                        {
                          UniChar v391 = *(char *)(v507 + *((void *)&v507 + 1) + v227);
                        }
                        else
                        {
                          if (v509 <= v227 || (uint64_t v402 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v227))
                          {
                            uint64_t v403 = v227 - 4;
                            if ((unint64_t)v227 < 4) {
                              uint64_t v403 = 0;
                            }
                            if (v403 + 64 < (uint64_t)v508) {
                              uint64_t v390 = v403 + 64;
                            }
                            *((void *)&v508 + 1) = v403;
                            uint64_t v509 = v390;
                            v533.CFIndex location = *((void *)&v507 + 1) + v403;
                            v533.CFIndex length = v390 - v403;
                            CFStringGetCharacters(v506[0], v533, buffer);
                            uint64_t v223 = v462;
                            uint64_t v402 = *((void *)&v508 + 1);
                          }
                          UniChar v391 = buffer[v227 - v402];
                        }
                        UTF32Char v392 = v391;
                        if (v391 >> 10 == 54)
                        {
                          uint64_t v404 = v227 + 1;
                          uint64_t v405 = v508;
                          if ((uint64_t)v508 <= v227 + 1)
                          {
                            v389 = v417;
                          }
                          else
                          {
                            if (v506[1])
                            {
                              UniChar v406 = *((_WORD *)&v506[1]->isa + *((void *)&v507 + 1) + v404);
                            }
                            else if ((void)v507)
                            {
                              UniChar v406 = *(char *)(v507 + *((void *)&v507 + 1) + v404);
                            }
                            else
                            {
                              if (v509 <= v404 || (uint64_t v410 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v404))
                              {
                                uint64_t v411 = v227 - 3;
                                if ((unint64_t)v227 < 3) {
                                  uint64_t v411 = 0;
                                }
                                if (v411 + 64 < (uint64_t)v508) {
                                  uint64_t v405 = v411 + 64;
                                }
                                *((void *)&v508 + 1) = v411;
                                uint64_t v509 = v405;
                                v534.CFIndex location = *((void *)&v507 + 1) + v411;
                                v534.CFIndex length = v405 - v411;
                                CFStringGetCharacters(v506[0], v534, buffer);
                                uint64_t v223 = v462;
                                uint64_t v410 = *((void *)&v508 + 1);
                              }
                              UniChar v406 = buffer[v404 - v410];
                            }
                            v389 = v417;
                            if (v406 >> 10 == 55) {
                              UTF32Char v392 = (v392 << 10) - 56613888 + v406;
                            }
                          }
                        }
                      }
                      int v393 = *v389;
                      unsigned int v394 = *v389 & 4;
                      if (*v424 > v392 || *v418 <= v392)
                      {
                        if (!v394) {
                          break;
                        }
                      }
                      else if (HIWORD(v392) || (v393 & 2) != 0)
                      {
                        int v399 = CFCharacterSetIsLongCharacterMember(*v434, v392);
                        uint64_t v223 = v462;
                        if (!v399) {
                          break;
                        }
                      }
                      else
                      {
                        uint64_t v395 = *v419;
                        if (*v419)
                        {
                          if (v393)
                          {
                            unsigned int v407 = v394 >> 2;
                            uint64_t v408 = *(unsigned __int8 *)(v395 + ((unint64_t)v392 >> 8));
                            if (*(unsigned char *)(v395 + ((unint64_t)v392 >> 8)))
                            {
                              if (v408 == 255)
                              {
                                unsigned int v407 = v394 == 0;
                              }
                              else
                              {
                                BOOL v409 = v394 == 0;
                                if ((((unint64_t)*(unsigned __int8 *)(v395
                                                                            + 32 * v408
                                                                            + (v392 >> 3)
                                                                            + 224) >> (v392 & 7)) & 1) != 0)
                                  unsigned int v407 = v409;
                              }
                            }
                            if (!v407) {
                              break;
                            }
                          }
                          else
                          {
                            BOOL v49 = v394 == 0;
                            BOOL v396 = v394 != 0;
                            char v397 = v49;
                            if (((unint64_t)*(unsigned __int8 *)(v395 + ((unint64_t)v392 >> 3)) >> (v392 & 7))) {
                              BOOL v396 = v397;
                            }
                            if (!v396) {
                              break;
                            }
                          }
                        }
                        else
                        {
                          BOOL v49 = v394 == 0;
                          BOOL v400 = v394 != 0;
                          char v401 = v49;
                          if ((v393 & 1) == 0) {
                            BOOL v400 = v401;
                          }
                          if (!v400) {
                            break;
                          }
                        }
                      }
                      if (v392 < 0x10000) {
                        uint64_t v398 = 1;
                      }
                      else {
                        uint64_t v398 = 2;
                      }
                      v227 += v398;
                    }
                    while (v227 < v19);
                  }
                }
                if (v438 == 12 && v227 != v19) {
                  goto LABEL_1116;
                }
                if (v388)
                {
                  v388->CFIndex location = v223;
                  v388->CFIndex length = v227 - v223;
                }
LABEL_436:
                LOBYTE(v14) = 1;
                return v14;
              }
            }
          }
          uint64_t v319 = BitmapPtrForPlane;
          goto LABEL_861;
        }
        if ((v441 & 0x80) != 0 && __s1[0] <= 0x50F)
        {
          if (v213 < v225)
          {
            while (1)
            {
              unsigned int v312 = __s1[v213];
              uint64_t v313 = BitmapPtrForPlane;
              if (v312 >= 0x10000)
              {
                uint64_t v313 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v312));
                int v217 = v459;
                BOOL v215 = v438 == 8;
                uint64_t v223 = v462;
                int v219 = v466;
              }
              if (!v313 || ((*(unsigned __int8 *)(v313 + ((unsigned __int16)v312 >> 3)) >> (v312 & 7)) & 1) == 0) {
                break;
              }
              if (v225 == ++v213) {
                goto LABEL_851;
              }
            }
          }
          if (v213 == v225)
          {
LABEL_851:
            v227 += v469;
            uint64_t v213 = v225;
            goto LABEL_852;
          }
        }
LABEL_889:
        if (v223 == v433) {
          goto LABEL_1116;
        }
        v223 += v428;
      }
    }
LABEL_469:
    *(_DWORD *)v473 = 0;
    uint64_t v188 = length << 32;
    if ((searchOptions & 4) != 0)
    {
      if ((v433 & 0x8000000000000000) == 0)
      {
        uint64_t v192 = v433 + (int)length;
        uint64_t v193 = v508;
        if (v192 <= (uint64_t)v508)
        {
          if (v506[1])
          {
            v191 = (UniChar *)v506[1] + *((void *)&v507 + 1) + v433;
            goto LABEL_508;
          }
          if (v188 <= 0x4000000000)
          {
            if (v192 > v509 || v433 < *((uint64_t *)&v508 + 1))
            {
              if (v433 + 64 < (uint64_t)v508) {
                uint64_t v193 = v433 + 64;
              }
              *((void *)&v508 + 1) = v433;
              uint64_t v509 = v193;
              v200.CFIndex location = *((void *)&v507 + 1) + v433;
              v200.CFIndex length = v193 - v433;
              if ((void)v507)
              {
                if (v200.length)
                {
                  v201 = (char *)(v507 + v200.location);
                  uint64_t v202 = v433 - v193;
                  v203 = buffer;
                  do
                  {
                    UniChar v204 = *v201++;
                    *v203++ = v204;
                    BOOL v199 = __CFADD__(v202++, 1);
                  }
                  while (!v199);
                }
              }
              else
              {
                CFStringGetCharacters(v506[0], v200, buffer);
              }
            }
            uint64_t v205 = v433 - *((void *)&v508 + 1);
            goto LABEL_507;
          }
        }
LABEL_477:
        v191 = 0;
        goto LABEL_508;
      }
    }
    else if ((v443 & 0x8000000000000000) == 0)
    {
      uint64_t v189 = v443 + (int)length;
      uint64_t v190 = v508;
      if (v189 <= (uint64_t)v508)
      {
        if (v506[1])
        {
          v191 = (UniChar *)v506[1] + *((void *)&v507 + 1) + v443;
          goto LABEL_508;
        }
        if (v188 <= 0x4000000000)
        {
          if (v189 > v509 || v443 < *((uint64_t *)&v508 + 1))
          {
            if (v443 + 64 < (uint64_t)v508) {
              uint64_t v190 = v443 + 64;
            }
            *((void *)&v508 + 1) = v443;
            uint64_t v509 = v190;
            v194.CFIndex location = *((void *)&v507 + 1) + v443;
            v194.CFIndex length = v190 - v443;
            if ((void)v507)
            {
              if (v194.length)
              {
                v195 = (char *)(v507 + v194.location);
                uint64_t v196 = v443 - v190;
                v197 = buffer;
                do
                {
                  UniChar v198 = *v195++;
                  *v197++ = v198;
                  BOOL v199 = __CFADD__(v196++, 1);
                }
                while (!v199);
              }
            }
            else
            {
              CFStringGetCharacters(v506[0], v194, buffer);
            }
          }
          uint64_t v205 = v443 - *((void *)&v508 + 1);
LABEL_507:
          v191 = &buffer[v205];
LABEL_508:
          if ((int)v467 <= (uint64_t)v495)
          {
            if (v493[1]) {
              goto LABEL_522;
            }
            if (v467 << 32 <= 0x4000000000)
            {
              if ((int)v467 > v496 || *((uint64_t *)&v495 + 1) >= 1)
              {
                if ((uint64_t)v495 >= 64) {
                  v206.CFIndex length = 64;
                }
                else {
                  v206.CFIndex length = v495;
                }
                *((void *)&v495 + 1) = 0;
                CFIndex v496 = v206.length;
                v206.CFIndex location = range.length;
                if (range.location)
                {
                  if (v206.length)
                  {
                    v207 = (char *)(range.location + range.length);
                    v208 = v485;
                    do
                    {
                      UniChar v209 = *v207++;
                      *v208++ = v209;
                      --v206.length;
                    }
                    while (v206.length);
                  }
                }
                else
                {
                  CFStringGetCharacters(v493[0], v206, v485);
                }
              }
LABEL_522:
              if (v191)
              {
                ucol_open();
                if (*(int *)v473 <= 0)
                {
                  ucol_setStrength();
                  usearch_openFromCollator();
                  if (*(int *)v473 <= 0)
                  {
                    if ((searchOptions & 4) != 0) {
                      unsigned int v210 = usearch_last();
                    }
                    else {
                      unsigned int v210 = usearch_first();
                    }
                    unsigned int v211 = v210;
                    if (*(int *)v473 < 1)
                    {
                      if ((v210 & 0x80000000) != 0)
                      {
                        LOBYTE(v14) = 0;
                      }
                      else
                      {
                        int MatchedLength = usearch_getMatchedLength();
                        if ((searchOptions & 8) != 0)
                        {
                          if ((searchOptions & 4) != 0) {
                            BOOL v14 = MatchedLength + v211 == length;
                          }
                          else {
                            BOOL v14 = v211 == 0;
                          }
                        }
                        else
                        {
                          BOOL v14 = 1;
                        }
                        if (result && v14)
                        {
                          result->CFIndex location = *(void *)v425 + v211;
                          result->CFIndex length = MatchedLength;
                          LOBYTE(v14) = 1;
                        }
                      }
                      usearch_close();
                      ucol_close();
                      return v14;
                    }
                    usearch_close();
                  }
                  ucol_close();
                }
              }
            }
          }
          uint64_t v27 = v443;
          goto LABEL_532;
        }
      }
      goto LABEL_477;
    }
    v191 = 0;
    goto LABEL_508;
  }
  v421 = result;
  LODWORD(v33) = 0;
  uint64_t v34 = 0;
  if (v466) {
    uint64_t v35 = (uint64_t)&theSet[1];
  }
  else {
    uint64_t v35 = 8;
  }
  if (v466) {
    unint64_t v36 = (unint64_t)theSet | 0xC;
  }
  else {
    unint64_t v36 = 12;
  }
  uint64_t v37 = (uint64_t)&v471;
  if (!v466) {
    uint64_t v37 = 16;
  }
  v458 = (_DWORD *)v37;
  uint64_t v38 = (uint64_t)&v471 + 8;
  if (!v466) {
    uint64_t v38 = 24;
  }
  v449 = (uint64_t *)v38;
  uint64_t v444 = v32;
  unint64_t v452 = v36;
  uint64_t v454 = v35;
  while (2)
  {
    if (v27 >= v19)
    {
      uint64_t v39 = 0;
      uint64_t v40 = v27;
      goto LABEL_271;
    }
    uint64_t v39 = 0;
    uint64_t v40 = v27;
    uint64_t v442 = v27;
    do
    {
      uint64_t v41 = -v40;
      uint64_t v42 = v40 + 64;
      unsigned int v447 = v34;
      uint64_t v43 = v34;
      uint64_t v44 = v40;
      while (1)
      {
        if ((unint64_t)v44 >= 4) {
          uint64_t v45 = 4;
        }
        else {
          uint64_t v45 = v44;
        }
        int v46 = *(unsigned __int8 *)(CStringPtrInternal + v44);
        int v47 = *(unsigned __int8 *)(v461 + v39);
        if (v46 == v47) {
          goto LABEL_232;
        }
        if (!v460)
        {
          uint64_t v27 = v442;
          uint64_t v34 = v447;
          goto LABEL_271;
        }
        int v48 = (char)v46;
        BOOL v49 = SpecialCaseHandlingLanguageIdentifierForLocale && (char)v46 == 73;
        BOOL v50 = !v49;
        if (v48 < 0 || !v50)
        {
          if (v44 < 0 || (uint64_t)v508 <= v44)
          {
            UniChar v53 = 0;
          }
          else if (v506[1])
          {
            UniChar v53 = *((_WORD *)&v506[1]->isa + v44 + *((void *)&v507 + 1));
          }
          else if ((void)v507)
          {
            UniChar v53 = *(char *)(v507 + *((void *)&v507 + 1) + v44);
          }
          else
          {
            if (v509 <= v44 || (uint64_t v68 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v44))
            {
              uint64_t v69 = -v45;
              uint64_t v70 = v45 + v41;
              uint64_t v71 = v42 - v45;
              uint64_t v72 = v44 + v69;
              uint64_t v73 = v72 + 64;
              if (v72 + 64 >= (uint64_t)v508) {
                uint64_t v73 = v508;
              }
              *((void *)&v508 + 1) = v72;
              uint64_t v509 = v73;
              if ((uint64_t)v508 < v71) {
                uint64_t v71 = v508;
              }
              v513.CFIndex length = v71 + v70;
              v513.CFIndex location = v72 + *((void *)&v507 + 1);
              CFStringGetCharacters(v506[0], v513, buffer);
              uint64_t v68 = *((void *)&v508 + 1);
            }
            UniChar v53 = buffer[v44 - v68];
          }
          uint64_t v43 = v53;
          uint64_t v54 = __CFStringFoldCharacterClusterAtIndex(v53, buffer, v44, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s1, 0, 0);
          if (v54 <= 0)
          {
            __s1[0] = v43;
            unint64_t v52 = 1;
          }
          else
          {
            unint64_t v52 = v54;
          }
          int v31 = v466;
          unint64_t v36 = v452;
          uint64_t v35 = v454;
        }
        else
        {
          if ((v48 - 65) < 0x1Au && v456 != 0) {
            LOBYTE(v48) = v48 + 32;
          }
          __s1[0] = v48;
          unint64_t v52 = 1;
        }
        BOOL v55 = v438 != 8 && v442 == v44;
        char v56 = v466 ^ 1;
        if (v55) {
          char v56 = 1;
        }
        if (v56) {
          break;
        }
        if ((v48 & 0x80u) == 0) {
          unint64_t v57 = v48;
        }
        else {
          unint64_t v57 = v43;
        }
        int v58 = *(_DWORD *)v35;
        unsigned int v59 = *(_DWORD *)v35 & 4;
        if (*(_DWORD *)v36 > v57 || *v458 <= v57)
        {
          if (!v59) {
            break;
          }
          goto LABEL_108;
        }
        if ((v58 & 2) != 0)
        {
          int v63 = CFCharacterSetIsLongCharacterMember(*v434, v57);
          unint64_t v36 = v452;
          uint64_t v35 = v454;
          int v31 = v466;
          if (!v63) {
            break;
          }
          goto LABEL_108;
        }
        uint64_t v60 = *v449;
        if (*v449)
        {
          if (v58)
          {
            unsigned int v66 = v59 >> 2;
            uint64_t v67 = *(unsigned __int8 *)(v60 + (v57 >> 8));
            if (!*(unsigned char *)(v60 + (v57 >> 8))) {
              goto LABEL_124;
            }
            if (v67 == 255)
            {
              unsigned int v66 = v59 == 0;
LABEL_124:
              if (!v66) {
                break;
              }
              goto LABEL_108;
            }
            BOOL v74 = v59 == 0;
            if ((*(unsigned __int8 *)(v60 + 32 * v67 + (v57 >> 3) + 224) >> (v57 & 7))) {
              unsigned int v66 = v74;
            }
            if (!v66) {
              break;
            }
          }
          else
          {
            BOOL v49 = v59 == 0;
            BOOL v61 = v59 != 0;
            char v62 = v49;
            if ((*(unsigned __int8 *)(v60 + (v57 >> 3)) >> (v57 & 7))) {
              BOOL v61 = v62;
            }
            if (!v61) {
              break;
            }
          }
        }
        else
        {
          BOOL v49 = v59 == 0;
          BOOL v64 = v59 != 0;
          char v65 = v49;
          if ((v58 & 1) == 0) {
            BOOL v64 = v65;
          }
          if (!v64) {
            break;
          }
        }
LABEL_108:
        ++v44;
        --v41;
        ++v42;
        if (v44 >= v463) {
          goto LABEL_265;
        }
      }
      unsigned __int8 v75 = v47;
      if (SpecialCaseHandlingLanguageIdentifierForLocale) {
        BOOL v76 = (char)v47 == 73;
      }
      else {
        BOOL v76 = 0;
      }
      int v77 = !v76;
      if ((char)v47 < 0 || !v77)
      {
        __int16 v80 = v441;
        if (v39 < 0 || (CFIndex v81 = v495, (uint64_t)v495 <= v39))
        {
          UniChar v84 = 0;
        }
        else
        {
          int v82 = (UniChar *)v493[1];
          if (v493[1])
          {
            CFIndex v83 = range.length + v39;
LABEL_156:
            UniChar v84 = v82[v83];
            goto LABEL_158;
          }
          if (!range.location)
          {
            if (v496 <= v39 || (uint64_t v111 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v39))
            {
              uint64_t v112 = v39 - 4;
              if ((unint64_t)v39 < 4) {
                uint64_t v112 = 0;
              }
              if (v112 + 64 < (uint64_t)v495) {
                CFIndex v81 = v112 + 64;
              }
              *((void *)&v495 + 1) = v112;
              CFIndex v496 = v81;
              v516.CFIndex location = range.length + v112;
              v516.CFIndex length = v81 - v112;
              CFStringGetCharacters(v493[0], v516, v485);
              uint64_t v111 = *((void *)&v495 + 1);
            }
            CFIndex v83 = v39 - v111;
            int v82 = v485;
            goto LABEL_156;
          }
          UniChar v84 = *(char *)(range.location + range.length + v39);
        }
LABEL_158:
        LODWORD(v33) = v84;
        uint64_t v85 = __CFStringFoldCharacterClusterAtIndex(v84, v485, v39, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s2, 0, 0);
        if (v85 <= 0)
        {
          __s2[0] = v33;
          unint64_t v79 = 1;
        }
        else
        {
          unint64_t v79 = v85;
        }
        int v31 = v466;
        unint64_t v36 = v452;
        uint64_t v35 = v454;
        if (!v466) {
          goto LABEL_178;
        }
LABEL_162:
        if ((v75 & 0x80u) == 0) {
          unint64_t v86 = v75;
        }
        else {
          unint64_t v86 = v33;
        }
        unsigned int v87 = (uint64_t)theSet[1] & 4;
        if (HIDWORD(theSet[1]) > v86 || v471 <= v86)
        {
          if (((uint64_t)theSet[1] & 4) == 0) {
            goto LABEL_178;
          }
        }
        else if (((uint64_t)theSet[1] & 2) != 0)
        {
          int v106 = CFCharacterSetIsLongCharacterMember(theSet[0], v86);
          unint64_t v36 = v452;
          uint64_t v35 = v454;
          int v31 = v466;
          if (!v106) {
            goto LABEL_178;
          }
        }
        else if (*((void *)&v471 + 1))
        {
          if ((uint64_t)theSet[1])
          {
            unsigned int v109 = v87 >> 2;
            uint64_t v110 = *(unsigned __int8 *)(*((void *)&v471 + 1) + (v86 >> 8));
            if (*(unsigned char *)(*((void *)&v471 + 1) + (v86 >> 8)))
            {
              if (v110 == 255)
              {
                unsigned int v109 = v87 == 0;
              }
              else
              {
                BOOL v113 = v87 == 0;
                if ((*(unsigned __int8 *)(*((void *)&v471 + 1) + 32 * v110 + (v86 >> 3) + 224) >> (v86 & 7))) {
                  unsigned int v109 = v113;
                }
              }
            }
            if (!v109) {
              goto LABEL_178;
            }
          }
          else
          {
            BOOL v49 = v87 == 0;
            BOOL v88 = v87 != 0;
            char v89 = v49;
            if ((*(unsigned __int8 *)(*((void *)&v471 + 1) + (v86 >> 3)) >> (v86 & 7))) {
              BOOL v88 = v89;
            }
            if (!v88) {
              goto LABEL_178;
            }
          }
        }
        else
        {
          BOOL v49 = v87 == 0;
          BOOL v107 = v87 != 0;
          char v108 = v49;
          if (((uint64_t)theSet[1] & 1) == 0) {
            BOOL v107 = v108;
          }
          if (!v107) {
            goto LABEL_178;
          }
        }
        uint64_t v40 = v44;
        uint64_t v34 = v43;
        uint64_t v27 = v442;
        goto LABEL_236;
      }
      if ((v47 - 65) < 0x1Au && v456 != 0) {
        unsigned __int8 v75 = v47 + 32;
      }
      __s2[0] = v75;
      unint64_t v79 = 1;
      __int16 v80 = v441;
      if (v31) {
        goto LABEL_162;
      }
LABEL_178:
      if (v52 != 1 || v79 != 1)
      {
        if (v456 || v52 == v79)
        {
          if ((uint64_t)v52 >= (uint64_t)v79) {
            unint64_t v90 = v79;
          }
          else {
            unint64_t v90 = v52;
          }
          if (memcmp(__s1, __s2, 4 * v90))
          {
            uint64_t v40 = v44;
            uint64_t v34 = v43;
            uint64_t v27 = v442;
            int v31 = v466;
            unint64_t v36 = v452;
            uint64_t v35 = v454;
            break;
          }
          if (v52 >= v79)
          {
            int v31 = v466;
            unint64_t v36 = v452;
            uint64_t v35 = v454;
            if (v79 >= v52)
            {
LABEL_232:
              uint64_t v27 = v442;
              goto LABEL_233;
            }
            if ((uint64_t)(v52 + v39) <= v467)
            {
              BOOL v98 = &__s1[v52];
              char v99 = &__s1[v79];
              uint64_t v100 = v44 + 1;
              if ((unint64_t)(v44 + 1) >= 4) {
                uint64_t v101 = v44 - 3;
              }
              else {
                uint64_t v101 = 0;
              }
              while (1)
              {
                if (v44 < -1 || (CFIndex v102 = v495, (uint64_t)v495 <= v100))
                {
                  UniChar v103 = 0;
                }
                else if (v493[1])
                {
                  UniChar v103 = *((_WORD *)&v493[1]->isa + v44 + range.length + 1);
                }
                else if (range.location)
                {
                  UniChar v103 = *(char *)(range.location + range.length + v44 + 1);
                }
                else
                {
                  if (v496 <= v100 || (uint64_t v105 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v100))
                  {
                    if (v101 + 64 < (uint64_t)v495) {
                      CFIndex v102 = v101 + 64;
                    }
                    *((void *)&v495 + 1) = v101;
                    CFIndex v496 = v102;
                    v515.CFIndex location = range.length + v101;
                    v515.CFIndex length = v102 - v101;
                    CFStringGetCharacters(v493[0], v515, v485);
                    uint64_t v105 = *((void *)&v495 + 1);
                  }
                  UniChar v103 = v485[v44 + 1 - v105];
                }
                uint64_t v104 = v39 + 1;
                if (__CFStringFoldCharacterClusterAtIndex(v103, v485, v39 + 1, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s2, 0, 0) > 0)break; {
                int v31 = v466;
                }
                unint64_t v36 = v452;
                uint64_t v35 = v454;
                if (*v99 != __s2[0])
                {
                  uint64_t v40 = v44;
                  uint64_t v34 = v43;
                  uint64_t v27 = v442;
                  goto LABEL_271;
                }
                ++v99;
                ++v39;
                if (v99 >= v98)
                {
                  uint64_t v39 = v104;
                  uint64_t v27 = v442;
                  goto LABEL_233;
                }
              }
              uint64_t v40 = v44;
              uint64_t v34 = v43;
              uint64_t v27 = v442;
LABEL_269:
              int v31 = v466;
              unint64_t v36 = v452;
              uint64_t v35 = v454;
              break;
            }
          }
          else
          {
            int v31 = v466;
            unint64_t v36 = v452;
            uint64_t v35 = v454;
            if ((uint64_t)(v79 + v44) <= v463)
            {
              uint64_t v91 = &__s2[v79];
              long long v92 = &__s2[v52];
              uint64_t v27 = v442;
              while (1)
              {
                uint64_t v93 = v44 + 1;
                if (v44 < -1 || (uint64_t v94 = v508, (uint64_t)v508 <= v93))
                {
                  UniChar v95 = 0;
                }
                else if (v506[1])
                {
                  UniChar v95 = *((_WORD *)&v506[1]->isa + v44 + *((void *)&v507 + 1) + 1);
                }
                else if ((void)v507)
                {
                  UniChar v95 = *(char *)(v507 + *((void *)&v507 + 1) + v44 + 1);
                }
                else
                {
                  if (v509 <= v93 || (uint64_t v96 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v93))
                  {
                    uint64_t v97 = v44 - 3;
                    if ((unint64_t)v93 < 4) {
                      uint64_t v97 = 0;
                    }
                    if (v97 + 64 < (uint64_t)v508) {
                      uint64_t v94 = v97 + 64;
                    }
                    *((void *)&v508 + 1) = v97;
                    uint64_t v509 = v94;
                    v514.CFIndex location = *((void *)&v507 + 1) + v97;
                    v514.CFIndex length = v94 - v97;
                    CFStringGetCharacters(v506[0], v514, buffer);
                    uint64_t v96 = *((void *)&v508 + 1);
                  }
                  UniChar v95 = buffer[v44 + 1 - v96];
                }
                if (__CFStringFoldCharacterClusterAtIndex(v95, buffer, v44 + 1, v80, SpecialCaseHandlingLanguageIdentifierForLocale, __s1, 0, 0) > 0)
                {
                  uint64_t v40 = v44;
                  uint64_t v34 = v43;
                  goto LABEL_269;
                }
                int v31 = v466;
                unint64_t v36 = v452;
                uint64_t v35 = v454;
                if (*v92 != __s1[0]) {
                  break;
                }
                ++v92;
                ++v44;
                if (v92 >= v91)
                {
                  uint64_t v44 = v93;
                  goto LABEL_233;
                }
              }
              uint64_t v40 = v44;
              uint64_t v34 = v43;
              break;
            }
          }
        }
LABEL_265:
        uint64_t v40 = v44;
        uint64_t v34 = v43;
        uint64_t v27 = v442;
        break;
      }
      uint64_t v40 = v44;
      uint64_t v34 = v43;
      uint64_t v27 = v442;
      if (__s1[0] != __s2[0]) {
        break;
      }
LABEL_233:
      uint64_t v40 = v44 + 1;
      uint64_t v34 = v43;
LABEL_236:
      ++v39;
    }
    while (v40 < v463 && v39 < v467);
LABEL_271:
    uint64_t v19 = v463;
    if (v40 == v463) {
      int v114 = v31;
    }
    else {
      int v114 = 0;
    }
    if (v114 == 1 && v39 < v467)
    {
      uint64_t v116 = -v39;
      uint64_t v117 = v39 + 64;
      while (1)
      {
        if ((unint64_t)v39 >= 4) {
          uint64_t v118 = 4;
        }
        else {
          uint64_t v118 = v39;
        }
        if (v39 < 0 || (uint64_t v119 = v495, (uint64_t)v495 <= v39))
        {
          UniChar v120 = 0;
        }
        else if (v493[1])
        {
          UniChar v120 = *((_WORD *)&v493[1]->isa + v39 + range.length);
        }
        else if (range.location)
        {
          UniChar v120 = *(char *)(range.location + range.length + v39);
        }
        else
        {
          if (v496 <= v39 || (uint64_t v129 = *((void *)&v495 + 1), *((uint64_t *)&v495 + 1) > v39))
          {
            uint64_t v130 = -v118;
            uint64_t v131 = v118 + v116;
            uint64_t v132 = v117 - v118;
            uint64_t v133 = v39 + v130;
            CFIndex v134 = v133 + 64;
            if (v133 + 64 >= (uint64_t)v495) {
              CFIndex v134 = v495;
            }
            *((void *)&v495 + 1) = v133;
            CFIndex v496 = v134;
            if ((uint64_t)v495 >= v132) {
              uint64_t v119 = v132;
            }
            v517.CFIndex length = v119 + v131;
            v517.CFIndex location = v133 + range.length;
            CFStringGetCharacters(v493[0], v517, v485);
            unint64_t v36 = v452;
            uint64_t v35 = v454;
            int v31 = v466;
            uint64_t v129 = *((void *)&v495 + 1);
          }
          UniChar v120 = v485[v39 - v129];
        }
        unint64_t v33 = v120;
        int v121 = *(_DWORD *)v35;
        unsigned int v122 = *(_DWORD *)v35 & 4;
        if (*(_DWORD *)v36 > v120 || *v458 <= v120)
        {
          if (!v122) {
            break;
          }
        }
        else if ((v121 & 2) != 0)
        {
          int v126 = CFCharacterSetIsLongCharacterMember(*v434, v120);
          unint64_t v36 = v452;
          uint64_t v35 = v454;
          int v31 = v466;
          if (!v126) {
            break;
          }
        }
        else
        {
          uint64_t v123 = *v449;
          if (*v449)
          {
            if (v121)
            {
              unsigned int v135 = v122 >> 2;
              uint64_t v136 = *(unsigned __int8 *)(v123 + (v33 >> 8));
              if (*(unsigned char *)(v123 + (v33 >> 8)))
              {
                if (v136 == 255)
                {
                  unsigned int v135 = v122 == 0;
                }
                else
                {
                  BOOL v137 = v122 == 0;
                  if ((*(unsigned __int8 *)(v123 + 32 * v136 + (v33 >> 3) + 224) >> (v33 & 7))) {
                    unsigned int v135 = v137;
                  }
                }
              }
              if (!v135) {
                break;
              }
            }
            else
            {
              BOOL v49 = v122 == 0;
              BOOL v124 = v122 != 0;
              char v125 = v49;
              if ((*(unsigned __int8 *)(v123 + (v33 >> 3)) >> (v33 & 7))) {
                BOOL v124 = v125;
              }
              if (!v124) {
                break;
              }
            }
          }
          else
          {
            BOOL v49 = v122 == 0;
            BOOL v127 = v122 != 0;
            char v128 = v49;
            if ((v121 & 1) == 0) {
              BOOL v127 = v128;
            }
            if (!v127) {
              break;
            }
          }
        }
        ++v39;
        --v116;
        ++v117;
        if (v467 == v39) {
          goto LABEL_337;
        }
      }
    }
    if (v39 == v467)
    {
LABEL_337:
      if (v438 == 12) {
        int v139 = v31;
      }
      else {
        int v139 = 0;
      }
      if (v139 == 1)
      {
        uint64_t v140 = v421;
        if (v40 < v463)
        {
          uint64_t v141 = -v40;
          uint64_t v142 = v40 + 64;
          do
          {
            if ((unint64_t)v40 >= 4) {
              uint64_t v143 = 4;
            }
            else {
              uint64_t v143 = v40;
            }
            if (v40 < 0 || (uint64_t v144 = v508, (uint64_t)v508 <= v40))
            {
              UniChar v145 = 0;
            }
            else if (v506[1])
            {
              UniChar v145 = *((_WORD *)&v506[1]->isa + v40 + *((void *)&v507 + 1));
            }
            else if ((void)v507)
            {
              UniChar v145 = *(char *)(v507 + *((void *)&v507 + 1) + v40);
            }
            else
            {
              if (v509 <= v40 || (uint64_t v155 = *((void *)&v508 + 1), *((uint64_t *)&v508 + 1) > v40))
              {
                uint64_t v156 = -v143;
                uint64_t v157 = v143 + v141;
                uint64_t v158 = v142 - v143;
                uint64_t v159 = v40 + v156;
                uint64_t v160 = v159 + 64;
                if (v159 + 64 >= (uint64_t)v508) {
                  uint64_t v160 = v508;
                }
                *((void *)&v508 + 1) = v159;
                uint64_t v509 = v160;
                if ((uint64_t)v508 >= v158) {
                  uint64_t v144 = v158;
                }
                v518.CFIndex length = v144 + v157;
                v518.CFIndex location = v159 + *((void *)&v507 + 1);
                CFStringGetCharacters(v506[0], v518, buffer);
                uint64_t v155 = *((void *)&v508 + 1);
              }
              UniChar v145 = buffer[v40 - v155];
            }
            unsigned int v146 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) <= v145 && v471 > v145)
            {
              if (((uint64_t)theSet[1] & 2) != 0)
              {
                if (!CFCharacterSetIsLongCharacterMember(*v434, v145)) {
                  goto LABEL_432;
                }
              }
              else if (*((void *)&v471 + 1))
              {
                if ((uint64_t)theSet[1])
                {
                  unsigned int v153 = v146 >> 2;
                  uint64_t v154 = *(unsigned __int8 *)(*((void *)&v471 + 1) + ((unint64_t)v145 >> 8));
                  if (*(unsigned char *)(*((void *)&v471 + 1) + ((unint64_t)v145 >> 8)))
                  {
                    if (v154 == 255)
                    {
                      unsigned int v153 = v146 == 0;
                    }
                    else
                    {
                      BOOL v161 = v146 == 0;
                      if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v471 + 1)
                                                                  + 32 * v154
                                                                  + (v145 >> 3)
                                                                  + 224) >> (v145 & 7)) & 1) != 0)
                        unsigned int v153 = v161;
                    }
                  }
                  if (!v153) {
                    goto LABEL_432;
                  }
                }
                else
                {
                  BOOL v148 = v146 != 0;
                  BOOL v149 = v146 == 0;
                  if (((unint64_t)*(unsigned __int8 *)(*((void *)&v471 + 1) + ((unint64_t)v145 >> 3)) >> (v145 & 7))) {
                    BOOL v148 = v149;
                  }
                  if (!v148) {
                    goto LABEL_432;
                  }
                }
              }
              else
              {
                BOOL v49 = v146 == 0;
                BOOL v150 = v146 != 0;
                char v151 = v49;
                if ((uint64_t)theSet[1]) {
                  char v152 = v150;
                }
                else {
                  char v152 = v151;
                }
                if ((v152 & 1) == 0) {
                  goto LABEL_432;
                }
              }
            }
            else if (((uint64_t)theSet[1] & 4) == 0)
            {
              goto LABEL_432;
            }
            ++v40;
            --v141;
            ++v142;
          }
          while (v463 != v40);
          uint64_t v40 = v463;
LABEL_434:
          if (v140)
          {
            v140->CFIndex location = v27;
            v140->CFIndex length = v40 - v27;
          }
          goto LABEL_436;
        }
      }
      else
      {
        uint64_t v140 = v421;
      }
LABEL_432:
      if (v438 == 12 && v40 != v463) {
        break;
      }
      goto LABEL_434;
    }
    if (v27 != v433)
    {
      v27 += v444;
      continue;
    }
    break;
  }
LABEL_1116:
  LOBYTE(v14) = 0;
  return v14;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v2 = 0;
  int v3 = *(_DWORD *)off_1ECE0A6F0;
  if ((~(unint64_t)theString & 0xC000000000000007) == 0) {
    LOBYTE(v3) = 0;
  }
  uint64_t v4 = (v3 ^ theString) & 7;
  while (v4 != *((unsigned __int8 *)off_1ECE0A6E0 + v2))
  {
    if (++v2 == 7) {
      goto LABEL_12;
    }
  }
  if (v2 == 2)
  {
    return _NSTaggedPointerStringGetLength((uint64_t)theString);
  }
  else
  {
LABEL_12:
    if (CF_IS_OBJC(7uLL, (unint64_t)theString))
    {
      return [(__CFString *)(id)theString length];
    }
    else
    {
      char v6 = atomic_load((unint64_t *)&theString->info);
      uint64_t v7 = v6 & 5;
      char v8 = atomic_load((unint64_t *)&theString->info);
      uint64_t v9 = v8 & 0x60;
      if (v7 == 4)
      {
        p_data = &theString->data;
        if (v9)
        {
          int v11 = *p_data;
        }
        else
        {
          uint64_t v12 = atomic_load((unint64_t *)&theString->info);
          int v11 = (char *)&p_data[(v12 & 5) != 4];
        }
        return *v11;
      }
      else if ((v8 & 0x60) != 0)
      {
        return theString->length;
      }
      else
      {
        return (CFIndex)theString->data;
      }
    }
  }
}

uint64_t _CFStringGetCStringPtrInternal(unint64_t *a1, unsigned int a2, int a3, int a4)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0 && a4)
  {
    uint64_t v8 = 0;
    int v9 = *(_DWORD *)off_1ECE0A6F0;
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
      LOBYTE(v9) = 0;
    }
    uint64_t v10 = (v9 ^ a1) & 7;
    while (v10 != *((unsigned __int8 *)off_1ECE0A6E0 + v8))
    {
      if (++v8 == 7) {
        goto LABEL_10;
      }
    }
    if (v8 == 2) {
      return 0;
    }
  }
LABEL_10:
  int v11 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v11 = __CFDefaultEightBitStringEncoding;
  }
  if (v11 != a2)
  {
    if (v11 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v11 = __CFDefaultEightBitStringEncoding;
    }
    if (v11 == 1536)
    {
      uint64_t result = 0;
      switch(BYTE1(a2))
      {
        case 0:
          uint64_t result = 0;
          if ((a2 > 0x22 || ((1 << a2) & 0x600000032) == 0) && a2 != 152)
          {
            BOOL v13 = 1;
            goto LABEL_51;
          }
          return result;
        case 1:
          BOOL v21 = a2 == 134217984;
          goto LABEL_40;
        case 2:
          BOOL v13 = a2 != 518;
          goto LABEL_51;
        case 6:
          BOOL v21 = a2 == 1536;
LABEL_40:
          BOOL v13 = v21;
          goto LABEL_51;
        case 8:
        case 0xC:
          return result;
        case 0xA:
          BOOL v13 = 1;
          if (a2 - 2561 <= 0xF && ((1 << (a2 - 1)) & 0x8011) != 0) {
            return 0;
          }
          goto LABEL_51;
        case 0xB:
          if (a2 == 3071) {
            return 0;
          }
          BOOL v22 = __CFADD__(a2 - 3061, 2);
          goto LABEL_48;
        default:
          BOOL v22 = (a2 & 0xFF00) >= 0xC01;
LABEL_48:
          BOOL v13 = !v22;
LABEL_51:
          uint64_t result = 0;
          if (!a1 || !v13) {
            return result;
          }
          goto LABEL_14;
      }
    }
    return 0;
  }
  if (!a1) {
    return 0;
  }
LABEL_14:
  if (a4 && CF_IS_OBJC(7uLL, (unint64_t)a1))
  {
    return [a1 _fastCStringContents:a3 != 0];
  }
  if (a3 || (char v14 = atomic_load(a1 + 1), (v14 & 0x10) != 0))
  {
    char v15 = atomic_load(a1 + 1);
    if ((v15 & 8) == 0) {
      return 0;
    }
  }
  char v16 = atomic_load(a1 + 1);
  int v17 = a1 + 2;
  if ((v16 & 0x60) != 0)
  {
    uint64_t v18 = (void *)*v17;
  }
  else
  {
    char v19 = atomic_load(a1 + 1);
    uint64_t v18 = &v17[(v19 & 5) != 4];
  }
  unint64_t v20 = atomic_load(a1 + 1);
  return (uint64_t)v18 + ((v20 >> 2) & 1);
}

unint64_t CF_IS_OBJC(unint64_t result, unint64_t a2)
{
  if ((a2 & 0x8000000000000000) != 0) {
    return 1;
  }
  unint64_t v2 = *(void *)a2 & ~(unint64_t)off_1ECE0A6D0;
  if ((*(void *)a2 & (unint64_t)off_1ECE0A6D0) != 0) {
    v2 |= *(void *)a2 & (unint64_t)off_1ECE0A6D0;
  }
  if (!v2)
  {
    if (result) {
      CF_IS_OBJC_cold_1();
    }
    return result;
  }
  if (result == 7 && (__objc2_class *)v2 == __CFConstantStringClassReferencePtr) {
    return 0;
  }
  if (result > 0x47)
  {
    int v4 = result - 72;
    if ((int)result - 72 >= dword_1EB1DE0D8 || (uint64_t v5 = __CFRuntimeClassTables[(v4 >> 6) + 16]) == 0)
    {
      uint64_t v6 = 0;
      goto LABEL_17;
    }
    int v3 = (uint64_t *)(v5 + 8 * (v4 & 0x3F));
  }
  else
  {
    int v3 = &__CFRuntimeBuiltinObjCClassTable[result];
  }
  uint64_t v6 = *v3;
LABEL_17:
  if (v2 == v6) {
    return 0;
  }
  if ((v2 & 1) == 0) {
    return 1;
  }
  return (*(void *)off_1ECE0A6D8 & v2) != v6;
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    uint64_t v2 = 0;
    int v3 = *(_DWORD *)off_1ECE0A6F0;
    if ((~(unint64_t)theString & 0xC000000000000007) == 0) {
      LOBYTE(v3) = 0;
    }
    uint64_t v4 = (v3 ^ theString) & 7;
    while (v4 != *((unsigned __int8 *)off_1ECE0A6E0 + v2))
    {
      if (++v2 == 7) {
        goto LABEL_9;
      }
    }
    if (v2 == 2) {
      return 0;
    }
  }
LABEL_9:
  if (!CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    char v6 = atomic_load((unint64_t *)&theString->info);
    if ((v6 & 0x10) != 0)
    {
      char v7 = atomic_load((unint64_t *)&theString->info);
      p_data = &theString->data;
      if ((v7 & 0x60) != 0) {
        return (const UniChar *)*p_data;
      }
      char v9 = atomic_load((unint64_t *)&theString->info);
      return (const UniChar *)&p_data[(v9 & 5) != 4];
    }
    return 0;
  }

  return (const UniChar *)[(__CFString *)(id)theString _fastCharacterContents];
}

void CFRelease_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFRelease() called with NULL ***";
  __break(1u);
}

uint64_t _NSIsNSTimeZone(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSTimeZone__);
}

void CF_IS_OBJC_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CF objects must have a non-zero isa";
  __break(1u);
}

void _releaseStringsSource(uint64_t a1, _OWORD *a2)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  long long v3 = a2[3];
  v5[2] = a2[2];
  v5[3] = v3;
  uint64_t v6 = *((void *)a2 + 8);
  long long v4 = a2[1];
  v5[0] = *a2;
  v5[1] = v4;
  _CFBundleReleaseStringsSources((uint64_t)v5);

  free(a2);
}

unint64_t ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v4 = __CFBasicHashTableSizes[v3];
  uint64_t v5 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v5) {
    a2 = v5(a2);
  }
  unint64_t v6 = a2 / v4 % v4;
  if (!v6) {
    unint64_t v6 = v4 - 1;
  }
  unint64_t v7 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v8 = (uint64_t *)(a1 + 40 + 8 * ((v7 >> 2) & 1));
  if ((v7 & 4) == 0) {
    uint64_t v8 = (uint64_t *)(a1 + 40);
  }
  uint64_t v9 = *v8;
  unint64_t v10 = v4;
  unint64_t v11 = __CFBasicHashPrimitiveRoots[v3];
  unint64_t result = a2 % v4;
  while (*(void *)(v9 + 8 * result))
  {
    unint64_t result = a2 % v4 + v11 * v6;
    if (v4 <= result) {
      result %= v4;
    }
    v11 *= __CFBasicHashPrimitiveRoots[v3];
    if (v4 <= v11) {
      v11 %= v4;
    }
    if (!--v10) {
      return -1;
    }
  }
  return result;
}

uint64_t __CFStringHash(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v2 = (unsigned __int16 **)(a1 + 16);
  if ((v1 & 0x60) != 0)
  {
    uint64_t v3 = *v2;
  }
  else
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v3 = (unsigned __int16 *)&v2[(v4 & 5) != 4];
  }
  char v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 5) == 4)
  {
    uint64_t v6 = *(unsigned __int8 *)v3;
  }
  else
  {
    char v7 = atomic_load((unint64_t *)(a1 + 8));
    if ((v7 & 0x60) != 0) {
      uint64_t v6 = *(void *)(a1 + 24);
    }
    else {
      uint64_t v6 = (uint64_t)*v2;
    }
  }
  char v8 = atomic_load((unint64_t *)(a1 + 8));
  if ((v8 & 0x10) != 0)
  {
    if (v6 >= 97)
    {
      unint64_t v24 = 0;
      uint64_t v14 = v6;
      do
      {
        uint64_t v14 = v3[v24 + 3] + 67503105 * v14 + 257 * (257 * (257 * v3[v24] + v3[v24 + 1]) + v3[v24 + 2]);
        BOOL v18 = v24 >= 0x1C;
        v24 += 4;
      }
      while (!v18);
      uint64_t v25 = (unsigned __int16 *)((char *)v3 + (v6 & 0xFFFFFFFFFFFFFFFELL) - 32);
      for (uint64_t i = -20; i < 12; i += 4)
      {
        uint64_t v14 = v25[3] + 67503105 * v14 + 257 * (257 * (257 * *v25 + v25[1]) + v25[2]);
        v25 += 4;
      }
      uint64_t v27 = &v3[v6];
      CFIndex v28 = v27 - 32;
      do
      {
        uint64_t v14 = v28[3] + 67503105 * v14 + 257 * (257 * (257 * *v28 + v28[1]) + v28[2]);
        v28 += 4;
      }
      while (v28 < v27);
    }
    else
    {
      char v15 = &v3[v6];
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        uint64_t v14 = v6;
      }
      else
      {
        char v16 = &v3[v6 & 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v14 = v6;
        do
        {
          uint64_t v14 = v3[3] + 67503105 * v14 + 257 * (257 * (257 * *v3 + v3[1]) + v3[2]);
          v3 += 4;
        }
        while (v3 < v16);
      }
      while (v3 < v15)
      {
        unsigned int v30 = *v3++;
        uint64_t v14 = 257 * v14 + v30;
      }
    }
  }
  else
  {
    unint64_t v9 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v10 = (v9 >> 2) & 1;
    unint64_t v11 = (unsigned __int8 *)v3 + v10;
    if (v6 >= 97)
    {
      unint64_t v17 = 0;
      uint64_t v14 = v6;
      do
      {
        uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v3 + v10 + v17 + 3))
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v3 + v10 + v17))
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v3 + v10 + v17 + 1)))
             + *(unsigned __int16 *)(__CFCharToUniCharTable
                                                 + 2 * *((unsigned __int8 *)v3 + v10 + v17 + 2)));
        BOOL v18 = v17 >= 0x1C;
        v17 += 4;
      }
      while (!v18);
      uint64_t v19 = 0;
      uint64_t v20 = (uint64_t)v3 + v10 + ((unint64_t)v6 >> 1) - 16;
      do
      {
        uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19 + 3))
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19))
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19 + 1)))
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19 + 2)));
        uint64_t v21 = v19 - 16;
        v19 += 4;
      }
      while (v21 < 12);
      BOOL v22 = &v11[v6];
      CFStringRef v23 = &v11[v6 - 32];
      do
      {
        uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v23[3])
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v23)
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v23[1]))
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v23[2]));
        v23 += 4;
      }
      while (v23 < v22);
    }
    else
    {
      uint64_t v12 = &v11[v6];
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        uint64_t v14 = v6;
      }
      else
      {
        BOOL v13 = &v11[v6 & 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v14 = v6;
        do
        {
          uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v11[3])
              + 67503105 * v14
              + 257
              * (257
               * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v11)
                + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v11[1]))
               + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v11[2]));
          v11 += 4;
        }
        while (v11 < v13);
      }
      for (; v11 < v12; uint64_t v14 = 257 * v14 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v29))
        unsigned int v29 = *v11++;
    }
  }
  return (v14 << (v6 & 0x1F)) + v14;
}

BOOL __CFStringEqual(CFStringRef theString, CFStringRef a2)
{
  uint64_t v90 = *(void *)off_1ECE0A5B0;
  char v4 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v4 & 0x60) != 0)
  {
    uint64_t v6 = *p_data;
  }
  else
  {
    char v7 = atomic_load((unint64_t *)&theString->info);
    uint64_t v6 = (char *)&p_data[(v7 & 5) != 4];
  }
  char v8 = atomic_load((unint64_t *)&a2->info);
  unint64_t v9 = &a2->data;
  if ((v8 & 0x60) != 0)
  {
    uint64_t v10 = *v9;
  }
  else
  {
    char v11 = atomic_load((unint64_t *)&a2->info);
    uint64_t v10 = (char *)&v9[(v11 & 5) != 4];
  }
  char v12 = atomic_load((unint64_t *)&theString->info);
  if ((v12 & 5) == 4)
  {
    int64_t length = *v6;
  }
  else
  {
    char v14 = atomic_load((unint64_t *)&theString->info);
    if ((v14 & 0x60) != 0) {
      int64_t length = theString->length;
    }
    else {
      int64_t length = (int64_t)*p_data;
    }
  }
  char v15 = atomic_load((unint64_t *)&a2->info);
  if ((v15 & 5) == 4)
  {
    uint64_t v16 = *v10;
  }
  else
  {
    char v17 = atomic_load((unint64_t *)&a2->info);
    if ((v17 & 0x60) != 0) {
      uint64_t v16 = a2->length;
    }
    else {
      uint64_t v16 = (uint64_t)*v9;
    }
  }
  if (length == v16)
  {
    unint64_t v18 = atomic_load((unint64_t *)&theString->info);
    uint64_t v19 = (unsigned __int8 *)&v6[(v18 >> 2) & 1];
    unint64_t v20 = atomic_load((unint64_t *)&a2->info);
    uint64_t v21 = (unsigned __int8 *)&v10[(v20 >> 2) & 1];
    char v22 = atomic_load((unint64_t *)&theString->info);
    if ((v22 & 0x10) == 0)
    {
      char v23 = atomic_load((unint64_t *)&a2->info);
      if ((v23 & 0x10) == 0) {
        return memcmp(v19, v21, length) == 0;
      }
    }
    char v25 = atomic_load((unint64_t *)&theString->info);
    if ((v25 & 0x10) != 0)
    {
      char v32 = atomic_load((unint64_t *)&a2->info);
      if ((v32 & 0x10) != 0)
      {
        if (length >= 1)
        {
          BOOL result = 1;
          while (1)
          {
            int v40 = *(unsigned __int16 *)v19;
            v19 += 2;
            int v39 = v40;
            int v41 = *(unsigned __int16 *)v21;
            v21 += 2;
            if (v39 != v41) {
              break;
            }
            if (!--length) {
              return result;
            }
          }
          return 0;
        }
      }
      else
      {
        long long v87 = 0u;
        long long v85 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        theStringa[0] = a2;
        uint64_t v89 = 0;
        long long v88 = (unint64_t)length;
        CFStringRef CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(a2);
        uint64_t v34 = 0;
        theStringa[1] = CharactersPtr;
        if (!CharactersPtr)
        {
          int v35 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            CFStringRef CharactersPtr = (const __CFString *)__CFStringComputeEightBitStringEncoding(0);
            int v35 = __CFDefaultEightBitStringEncoding;
          }
          if (v35 != 1536)
          {
            if (v35 == -1)
            {
              __CFStringComputeEightBitStringEncoding(CharactersPtr);
              int v35 = __CFDefaultEightBitStringEncoding;
            }
            if (v35 != 1536) {
              goto LABEL_42;
            }
          }
          p_info = &a2->info;
          char v37 = atomic_load((unint64_t *)&a2->info);
          if ((v37 & 0x10) == 0 || (char v38 = atomic_load((unint64_t *)p_info), (v38 & 8) != 0))
          {
            char v44 = atomic_load((unint64_t *)p_info);
            if ((v44 & 0x60) != 0)
            {
              uint64_t v45 = *v9;
            }
            else
            {
              char v62 = atomic_load((unint64_t *)&a2->info);
              uint64_t v45 = (char *)&v9[(v62 & 5) != 4];
            }
            unint64_t v63 = atomic_load((unint64_t *)&a2->info);
            uint64_t v34 = &v45[(v63 >> 2) & 1];
          }
          else
          {
LABEL_42:
            uint64_t v34 = 0;
          }
        }
        *((void *)&v88 + 1) = 0;
        uint64_t v89 = 0;
        *(void *)&long long v87 = v34;
        if (length >= 1)
        {
          uint64_t v64 = 0;
          uint64_t v65 = 0;
          uint64_t v66 = 0;
          for (uint64_t i = 64; ; ++i)
          {
            uint64_t v68 = (unint64_t)v66 >= 4 ? 4 : v66;
            if (theStringa[1])
            {
              unsigned __int16 v69 = *((_WORD *)&theStringa[1]->isa + v66 + *((void *)&v87 + 1));
            }
            else if ((void)v87)
            {
              unsigned __int16 v69 = *(char *)(v87 + *((void *)&v87 + 1) + v66);
            }
            else
            {
              if (v89 <= v66 || v65 > v66)
              {
                uint64_t v71 = -v68;
                uint64_t v72 = v68 + v64;
                uint64_t v73 = i - v68;
                uint64_t v74 = v66 + v71;
                uint64_t v75 = v74 + 64;
                if (v74 + 64 >= (uint64_t)v88) {
                  uint64_t v75 = v88;
                }
                *((void *)&v88 + 1) = v74;
                uint64_t v89 = v75;
                v76.CFIndex location = v74 + *((void *)&v87 + 1);
                if ((uint64_t)v88 >= v73) {
                  uint64_t v77 = v73;
                }
                else {
                  uint64_t v77 = v88;
                }
                v76.int64_t length = v77 + v72;
                CFStringGetCharacters(theStringa[0], v76, (UniChar *)&v78);
                uint64_t v65 = *((void *)&v88 + 1);
              }
              unsigned __int16 v69 = *((_WORD *)&v78 + v66 - v65);
            }
            if (*(unsigned __int16 *)&v19[2 * v66] != v69) {
              break;
            }
            ++v66;
            --v64;
            if (length == v66) {
              return 1;
            }
          }
          return 0;
        }
      }
    }
    else
    {
      long long v87 = 0u;
      long long v85 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v78 = 0u;
      theStringa[0] = theString;
      uint64_t v89 = 0;
      long long v88 = (unint64_t)length;
      CFStringRef v26 = (const __CFString *)CFStringGetCharactersPtr(theString);
      uint64_t v27 = 0;
      theStringa[1] = v26;
      if (!v26)
      {
        int v28 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          CFStringRef v26 = (const __CFString *)__CFStringComputeEightBitStringEncoding(0);
          int v28 = __CFDefaultEightBitStringEncoding;
        }
        if (v28 != 1536)
        {
          if (v28 == -1)
          {
            __CFStringComputeEightBitStringEncoding(v26);
            int v28 = __CFDefaultEightBitStringEncoding;
          }
          if (v28 != 1536) {
            goto LABEL_31;
          }
        }
        unsigned int v29 = &theString->info;
        char v30 = atomic_load((unint64_t *)&theString->info);
        if ((v30 & 0x10) == 0 || (char v31 = atomic_load((unint64_t *)v29), (v31 & 8) != 0))
        {
          char v42 = atomic_load((unint64_t *)v29);
          if ((v42 & 0x60) != 0)
          {
            uint64_t v43 = *p_data;
          }
          else
          {
            char v46 = atomic_load((unint64_t *)&theString->info);
            uint64_t v43 = (char *)&p_data[(v46 & 5) != 4];
          }
          unint64_t v47 = atomic_load((unint64_t *)&theString->info);
          uint64_t v27 = &v43[(v47 >> 2) & 1];
        }
        else
        {
LABEL_31:
          uint64_t v27 = 0;
        }
      }
      *((void *)&v88 + 1) = 0;
      uint64_t v89 = 0;
      *(void *)&long long v87 = v27;
      if (length >= 1)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        uint64_t v50 = 0;
        for (uint64_t j = 64; ; ++j)
        {
          uint64_t v52 = (unint64_t)v50 >= 4 ? 4 : v50;
          if (theStringa[1])
          {
            unsigned __int16 v53 = *((_WORD *)&theStringa[1]->isa + v50 + *((void *)&v87 + 1));
          }
          else if ((void)v87)
          {
            unsigned __int16 v53 = *(char *)(v87 + *((void *)&v87 + 1) + v50);
          }
          else
          {
            if (v89 <= v50 || v49 > v50)
            {
              uint64_t v55 = -v52;
              uint64_t v56 = v52 + v48;
              uint64_t v57 = j - v52;
              uint64_t v58 = v50 + v55;
              uint64_t v59 = v58 + 64;
              if (v58 + 64 >= (uint64_t)v88) {
                uint64_t v59 = v88;
              }
              *((void *)&v88 + 1) = v58;
              uint64_t v89 = v59;
              v60.CFIndex location = v58 + *((void *)&v87 + 1);
              if ((uint64_t)v88 >= v57) {
                uint64_t v61 = v57;
              }
              else {
                uint64_t v61 = v88;
              }
              v60.int64_t length = v61 + v56;
              CFStringGetCharacters(theStringa[0], v60, (UniChar *)&v78);
              uint64_t v49 = *((void *)&v88 + 1);
            }
            unsigned __int16 v53 = *((_WORD *)&v78 + v50 - v49);
          }
          if (*(unsigned __int16 *)&v21[2 * v50] != v53) {
            break;
          }
          ++v50;
          --v48;
          if (length == v50) {
            return 1;
          }
        }
        return 0;
      }
    }
    return 1;
  }
  return 0;
}

unint64_t _CFStringGetLength2(unint64_t *a1)
{
  char v1 = atomic_load(a1 + 1);
  uint64_t v2 = v1 & 5;
  char v3 = atomic_load(a1 + 1);
  uint64_t v4 = v3 & 0x60;
  if (v2 == 4)
  {
    char v5 = (unsigned __int8 ***)(a1 + 2);
    if (v4)
    {
      uint64_t v6 = *v5;
    }
    else
    {
      uint64_t v8 = atomic_load(a1 + 1);
      uint64_t v6 = (unsigned __int8 **)&v5[(v8 & 5) != 4];
    }
    return *(unsigned __int8 *)v6;
  }
  else if ((v3 & 0x60) != 0)
  {
    return a1[3];
  }
  else
  {
    return a1[2];
  }
}

uint64_t comparisonUsingOrderingForStringKeys(id *a1, void *a2)
{
  if (*a1 == (id)*a2) {
    return 0;
  }
  else {
    return objc_msgSend(*a1, "compare:options:range:locale:", *a2, 2, 0, objc_msgSend(*a1, "length"), 0);
  }
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)_CFStringGetCStringPtrInternal((unint64_t *)theString, encoding, 1, 1);
}

CFComparisonResult CFStringCompareWithOptionsAndLocale(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  CFIndex length = rangeToCompare.length;
  CFIndex location = rangeToCompare.location;
  CFStringRef v9 = theString2;
  uint64_t v365 = *(void *)off_1ECE0A5B0;
  CFIndex v11 = CFStringGetLength(theString2);
  CFStringCompareFlags v12 = compareOptions;
  uint64_t v13 = v11;
  unsigned int v306 = (locale == 0) & (compareOptions >> 5);
  CFStringCompareFlags v331 = compareOptions;
  if (v306 == 1)
  {
    CFLocaleRef v14 = CFLocaleCopyCurrent();
    CFStringCompareFlags v12 = compareOptions;
    locale = v14;
  }
  CFStringCompareFlags v15 = v12 & 0x191;
  if (locale)
  {
    uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 1);
    CFStringCompareFlags v12 = v331;
    __s1 = (char *)SpecialCaseHandlingLanguageIdentifierForLocale;
  }
  else
  {
    __s1 = 0;
  }
  int64_t v362 = 0;
  long long v360 = 0u;
  long long v361 = 0u;
  long long v358 = 0u;
  long long v359 = 0u;
  long long v356 = 0u;
  long long v357 = 0u;
  long long v354 = 0u;
  long long v355 = 0u;
  long long v352 = 0u;
  long long v353 = 0u;
  *(_OWORD *)unint64_t v351 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v340 = 0u;
  long long v341 = 0u;
  long long v342 = 0u;
  long long v343 = 0u;
  long long v344 = 0u;
  long long v345 = 0u;
  long long v346 = 0u;
  long long v347 = 0u;
  long long v348 = 0u;
  long long v349 = 0u;
  int64_t v350 = 0;
  uint64_t v337 = 0;
  uint64_t v338 = 0;
  *(_OWORD *)theSet = 0u;
  long long v336 = 0u;
  uint64_t v17 = __CFStringFillCharacterSetInlineBuffer((uint64_t)theSet, v12);
  unint64_t v18 = v331;
  CFComparisonResult v19 = kCFCompareEqualTo;
  if (v15) {
    char v20 = 1;
  }
  else {
    char v20 = v17;
  }
  char v318 = v20;
  int v328 = v17;
  CFStringRef theString = theString1;
  if ((v331 & 0x40) != 0 || locale)
  {
    int64_t v21 = 0;
    goto LABEL_28;
  }
  int64_t v21 = 0;
  if (v17) {
    goto LABEL_28;
  }
  CFStringRef v22 = v9;
  uint64_t v23 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(v17);
    uint64_t v23 = __CFDefaultEightBitStringEncoding;
  }
  uint64_t CStringPtrInternal = (const UniChar *)_CFStringGetCStringPtrInternal(theString, v23, 0, 1);
  uint64_t v25 = _CFStringGetCStringPtrInternal(v22, v23, 0, 1);
  CFStringRef v26 = (unsigned __int16 *)v25;
  if (!CStringPtrInternal || !v25)
  {
    CFComparisonResult v19 = kCFCompareEqualTo;
    uint64_t v32 = 1;
    unint64_t v18 = v331;
    if ((v318 & 1) == 0)
    {
      CFStringRef v9 = v22;
      if (CStringPtrInternal) {
        goto LABEL_611;
      }
      int64_t v21 = 0;
      if (v25) {
        goto LABEL_621;
      }
      uint64_t CStringPtrInternal = CFStringGetCharactersPtr(theString);
      CFStringRef CharactersPtr = CFStringGetCharactersPtr(v22);
      CFStringRef v26 = (unsigned __int16 *)CharactersPtr;
      CFComparisonResult v19 = kCFCompareEqualTo;
      uint64_t v32 = 2;
      if (!CStringPtrInternal)
      {
        int64_t v21 = 0;
        unint64_t v18 = v331;
        goto LABEL_621;
      }
      unint64_t v18 = v331;
      if (!CharactersPtr)
      {
LABEL_611:
        int64_t v21 = 0;
        goto LABEL_621;
      }
      if (length >= v13) {
        uint64_t v34 = v13;
      }
      else {
        uint64_t v34 = length;
      }
      if (v34 < 1) {
        goto LABEL_46;
      }
      int v35 = &CStringPtrInternal[location];
      unint64_t v36 = &v35[v34];
      char v37 = v35 + 1;
      do
      {
        unsigned int v38 = *v26++;
        uint64_t v39 = *(v37 - 1);
        uint64_t v40 = v39 - v38;
      }
      while (v39 == v38 && v37++ < v36);
      if (!v40) {
LABEL_46:
      }
        uint64_t v40 = length - v13;
      CFComparisonResult v42 = (v40 >> 63) | 1;
      BOOL v43 = v40 == 0;
      goto LABEL_636;
    }
    int64_t v21 = 0;
LABEL_620:
    CFStringRef v9 = v22;
    goto LABEL_621;
  }
  unint64_t v18 = v331 & 0xFFFFFFFFFFFFFFEFLL;
  if ((v331 & 0x200) == 0 && v23 == 1536)
  {
    if (v331)
    {
      if (length >= v13) {
        CFIndex v27 = v13;
      }
      else {
        CFIndex v27 = length;
      }
      if (v27)
      {
        int v28 = (unsigned __int8 *)CStringPtrInternal + location;
        while (1)
        {
          int v29 = __ASCII_LOWERCASE_TABLE[*v28] - __ASCII_LOWERCASE_TABLE[*(unsigned __int8 *)v26];
          if (v29) {
            break;
          }
          CFStringRef v26 = (unsigned __int16 *)((char *)v26 + 1);
          ++v28;
          if (!--v27) {
            goto LABEL_632;
          }
        }
      }
      else
      {
LABEL_632:
        int v29 = length - v13;
      }
      BOOL v43 = v29 == 0;
      BOOL v274 = v29 < 0;
LABEL_634:
      CFComparisonResult v42 = kCFCompareLessThan;
      if (!v274) {
        CFComparisonResult v42 = kCFCompareGreaterThan;
      }
LABEL_636:
      if (v43) {
        return 0;
      }
      else {
        return v42;
      }
    }
    goto LABEL_434;
  }
  if ((v331 & 0x81) == 0)
  {
LABEL_434:
    CFComparisonResult v19 = kCFCompareEqualTo;
    int64_t v21 = 0;
    uint64_t v32 = 1;
    goto LABEL_620;
  }
  if (length >= v13) {
    uint64_t v207 = v13;
  }
  else {
    uint64_t v207 = length;
  }
  uint64_t CStringPtrInternal = (const UniChar *)((char *)CStringPtrInternal + location);
  CFStringRef v9 = v22;
  if (v207 < 1)
  {
    CFComparisonResult v19 = kCFCompareEqualTo;
    int64_t v21 = 0;
    goto LABEL_642;
  }
  int64_t v21 = 0;
  CFComparisonResult v19 = kCFCompareEqualTo;
  while (1)
  {
    unsigned int v208 = *((unsigned __int8 *)CStringPtrInternal + v21);
    unsigned int v209 = *(unsigned __int8 *)(v25 + v21);
    if (v208 != v209) {
      break;
    }
LABEL_432:
    if (v207 == ++v21) {
      goto LABEL_643;
    }
  }
  if (((v209 | v208) & 0x80) == 0)
  {
    if (v208 < v209) {
      uint64_t v210 = -1;
    }
    else {
      uint64_t v210 = 1;
    }
    if (((v19 == kCFCompareEqualTo) & (v331 >> 9)) != 0) {
      CFComparisonResult v19 = v210;
    }
    if (v331)
    {
      if (v208 - 65 < 0x1A) {
        v208 += 32;
      }
      if (v209 - 65 < 0x1A) {
        v209 += 32;
      }
    }
    BOOL v211 = v208 >= v209;
    if (v208 != v209) {
      goto LABEL_616;
    }
    goto LABEL_432;
  }
  uint64_t CStringPtrInternal = 0;
LABEL_642:
  if (v21 == v207)
  {
LABEL_643:
    CFComparisonResult v276 = kCFCompareLessThan;
    if ((int)length - (int)v13 >= 0) {
      CFComparisonResult v276 = kCFCompareGreaterThan;
    }
    if (length == v13) {
      return v19;
    }
    else {
      return v276;
    }
  }
  uint64_t v32 = 1;
LABEL_621:
  if (CStringPtrInternal && v26)
  {
    if (length >= v13) {
      CFIndex v271 = v13;
    }
    else {
      CFIndex v271 = length;
    }
    int v272 = memcmp((char *)CStringPtrInternal + v32 * location, v26, v32 * v271);
    int v273 = length - v13;
    if (v272) {
      int v273 = v272;
    }
    BOOL v43 = v273 == 0;
    BOOL v274 = v273 < 0;
    goto LABEL_634;
  }
LABEL_28:
  CFComparisonResult v30 = v19;
  uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
  *(void *)&long long v359 = theString;
  *((void *)&v360 + 1) = location;
  *(void *)&long long v361 = length;
  *((void *)&v359 + 1) = CFStringGetCharactersPtr(theString);
  if (*((void *)&v359 + 1)) {
    uint64_t v31 = 0;
  }
  else {
    uint64_t v31 = _CFStringGetCStringPtrInternal(theString, 1536, 0, 1);
  }
  *(void *)&long long v360 = v31;
  *((void *)&v361 + 1) = 0;
  int64_t v362 = 0;
  *(void *)&long long v347 = v9;
  *((void *)&v348 + 1) = 0;
  *(void *)&long long v349 = v13;
  char v44 = CFStringGetCharactersPtr(v9);
  uint64_t v45 = 0;
  *((void *)&v347 + 1) = v44;
  if (!v44) {
    uint64_t v45 = _CFStringGetCStringPtrInternal(v9, 1536, 0, 1);
  }
  *(void *)&long long v348 = v45;
  *((void *)&v349 + 1) = 0;
  int64_t v350 = 0;
  if (locale)
  {
    unsigned int v46 = v331;
    LODWORD(v319) = ((v331 & 0x200) == 0) & (v331 >> 7);
    if ((v331 & 0x200) != 0) {
      v18 &= ~0x80uLL;
    }
    int64_t v47 = v21;
  }
  else
  {
    int64_t v47 = 0;
    unsigned int v46 = v331;
    uint64_t v319 = (v331 >> 7) & 1;
  }
  uint64_t v48 = v30;
  int v49 = v328;
  char v50 = v318;
  int64_t v51 = 0;
  unint64_t v302 = v18;
  if (v21 >= length || v21 >= v13)
  {
    LOBYTE(v303) = 0;
    int64_t v54 = v21;
    int64_t v66 = 0;
LABEL_411:
    int64_t v58 = v21;
    int64_t v59 = v54;
    if ((v49 | v319) == 1) {
      goto LABEL_439;
    }
    goto LABEL_595;
  }
  CFStringRef v283 = v9;
  int64_t v301 = v13;
  int64_t v327 = length;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  *(void *)v315 = 0;
  CFLocaleRef cf = locale;
  int64_t v51 = 0;
  int v303 = 0;
  uint64_t v289 = 0;
  uint64_t v288 = 0;
  int64_t v54 = v21;
  int64_t v55 = v47;
  while (2)
  {
    uint64_t v56 = 0;
    uint64_t v57 = 0;
LABEL_60:
    int64_t v58 = v21;
    int64_t v59 = v54;
    uint64_t v60 = v56;
    uint64_t v298 = v57;
    uint64_t v61 = v57;
    int64_t v307 = v55;
    int64_t v308 = v47;
    int64_t v310 = v54;
    uint64_t v304 = v56;
LABEL_61:
    int64_t v62 = v59 - 4;
    if ((unint64_t)v59 < 4) {
      int64_t v62 = 0;
    }
    int64_t v297 = v62;
    uint64_t v296 = v62 + 64;
    uint64_t v63 = v59 + 1;
    int64_t v64 = v59 - 3;
    if ((unint64_t)(v59 + 1) < 4) {
      int64_t v64 = 0;
    }
    int64_t v300 = v64;
    uint64_t v299 = v64 + 64;
    if (v61 <= 0) {
      uint64_t v65 = 0;
    }
    else {
      uint64_t v65 = -1;
    }
    uint64_t v320 = v65;
    int64_t v66 = *(void *)v315;
    uint64_t v329 = v61;
LABEL_69:
    if (!v60)
    {
      if (v58 < 0 || (int64_t v69 = v361, (uint64_t)v361 <= v58))
      {
        UTF32Char v67 = 0;
LABEL_78:
        uint64_t v338 = 1;
        if (!v61) {
          goto LABEL_79;
        }
LABEL_71:
        LODWORD(v68) = v363[v53++];
        break;
      }
      uint64_t v70 = (UniChar *)*((void *)&v359 + 1);
      if (*((void *)&v359 + 1))
      {
        int64_t v71 = *((void *)&v360 + 1) + v58;
      }
      else
      {
        if ((void)v360)
        {
          UniChar v72 = *(char *)(v360 + *((void *)&v360 + 1) + v58);
          goto LABEL_115;
        }
        if (v362 <= v58 || (uint64_t v113 = *((void *)&v361 + 1), *((uint64_t *)&v361 + 1) > v58))
        {
          int64_t v114 = v58 - 4;
          if ((unint64_t)v58 < 4) {
            int64_t v114 = 0;
          }
          if (v114 + 64 < (uint64_t)v361) {
            int64_t v69 = v114 + 64;
          }
          *((void *)&v361 + 1) = v114;
          int64_t v362 = v69;
          v367.CFIndex location = *((void *)&v360 + 1) + v114;
          v367.CFIndex length = v69 - v114;
          uint64_t v291 = v52;
          uint64_t v115 = v63;
          uint64_t v116 = v48;
          int64_t v117 = v51;
          CFStringGetCharacters((CFStringRef)v359, v367, v351);
          uint64_t v60 = 0;
          unsigned int v46 = v331;
          uint64_t v61 = v329;
          int64_t v54 = v310;
          uint64_t v52 = v291;
          int64_t v55 = v307;
          int64_t v47 = v308;
          char v50 = v318;
          int64_t v51 = v117;
          int v49 = v328;
          uint64_t v48 = v116;
          uint64_t v63 = v115;
          uint64_t v113 = *((void *)&v361 + 1);
        }
        int64_t v71 = v58 - v113;
        uint64_t v70 = v351;
      }
      UniChar v72 = v70[v71];
LABEL_115:
      UTF32Char v67 = v72;
      if ((v46 & 1) != 0 && v72 >= 0x41u && v72 <= 0x5Au)
      {
        if (__s1 && v72 == 73)
        {
          UTF32Char v67 = 73;
        }
        else
        {
          if (v48) {
            BOOL v109 = 1;
          }
          else {
            BOOL v109 = (v46 & 0x200) == 0;
          }
          if (v109) {
            UTF32Char v67 = v72 + 32;
          }
        }
      }
      goto LABEL_78;
    }
    UTF32Char v67 = v364[v52++];
    if (v61) {
      goto LABEL_71;
    }
LABEL_79:
    if (v59 < 0 || (uint64_t v73 = v349, (uint64_t)v349 <= v59))
    {
      uint64_t v68 = 0;
    }
    else
    {
      uint64_t v74 = (UniChar *)*((void *)&v347 + 1);
      if (*((void *)&v347 + 1))
      {
        int64_t v75 = *((void *)&v348 + 1) + v59;
        goto LABEL_83;
      }
      if ((void)v348)
      {
        UniChar v76 = *(char *)(v348 + *((void *)&v348 + 1) + v59);
      }
      else
      {
        if (v350 <= v59 || (uint64_t v118 = *((void *)&v349 + 1), *((uint64_t *)&v349 + 1) > v59))
        {
          if (v296 < (uint64_t)v349) {
            uint64_t v73 = v296;
          }
          *((void *)&v349 + 1) = v297;
          int64_t v350 = v73;
          uint64_t v333 = v53;
          uint64_t v119 = v60;
          v368.CFIndex location = *((void *)&v348 + 1) + v297;
          v368.CFIndex length = v73 - v297;
          uint64_t v292 = v52;
          *(void *)theCharb = v63;
          uint64_t v120 = v48;
          int64_t v121 = v51;
          CFStringGetCharacters((CFStringRef)v347, v368, buffer);
          uint64_t v60 = v119;
          unsigned int v46 = v331;
          uint64_t v53 = v333;
          uint64_t v61 = v329;
          int64_t v54 = v310;
          uint64_t v52 = v292;
          int64_t v55 = v307;
          int64_t v47 = v308;
          char v50 = v318;
          int64_t v51 = v121;
          int v49 = v328;
          uint64_t v48 = v120;
          uint64_t v63 = *(void *)theCharb;
          uint64_t v118 = *((void *)&v349 + 1);
        }
        int64_t v75 = v59 - v118;
        uint64_t v74 = buffer;
LABEL_83:
        UniChar v76 = v74[v75];
      }
      uint64_t v68 = v76;
      if ((v46 & 1) != 0 && v76 >= 0x41u && v76 <= 0x5Au)
      {
        if (__s1 && v76 == 73)
        {
          uint64_t v68 = 73;
        }
        else
        {
          if (v48) {
            BOOL v110 = 1;
          }
          else {
            BOOL v110 = (v46 & 0x200) == 0;
          }
          if (v110) {
            uint64_t v68 = v76 + 32;
          }
          else {
            uint64_t v68 = v76;
          }
        }
      }
    }
    uint64_t v337 = 1;
    if (!v61
      && (v46 & 0x40) != 0
      && !v60
      && v67 <= 0x39
      && v67 >= 0x30
      && v68 <= 0x39
      && v68 >= 0x30)
    {
      *(void *)v315 = v66;
      uint64_t v183 = 0;
      unint64_t v184 = 0;
      uint64_t v295 = v52;
      do
      {
        uint64_t v185 = v183;
        uint64_t v186 = v58 + v183;
        unint64_t v184 = v67 - 48 + 10 * v184;
        int64_t v21 = v186 + 1;
        if (v186 < -1) {
          break;
        }
        uint64_t v187 = v361;
        if ((uint64_t)v361 <= v21) {
          break;
        }
        if (*((void *)&v359 + 1))
        {
          UniChar v188 = *(_WORD *)(*((void *)&v359 + 1) + 2 * (v58 + v185 + *((void *)&v360 + 1)) + 2);
        }
        else if ((void)v360)
        {
          UniChar v188 = *(char *)(v360 + *((void *)&v360 + 1) + v58 + v185 + 1);
        }
        else
        {
          if (v362 <= v21 || (uint64_t v189 = *((void *)&v361 + 1), *((uint64_t *)&v361 + 1) > v21))
          {
            uint64_t v190 = v58 + v185 - 3;
            if ((unint64_t)v21 < 4) {
              uint64_t v190 = 0;
            }
            if (v190 + 64 < (uint64_t)v361) {
              uint64_t v187 = v190 + 64;
            }
            *((void *)&v361 + 1) = v190;
            int64_t v362 = v187;
            v370.CFIndex location = *((void *)&v360 + 1) + v190;
            v370.CFIndex length = v187 - v190;
            uint64_t v191 = v48;
            int64_t v192 = v51;
            *(void *)theChard = v68;
            CFStringGetCharacters((CFStringRef)v359, v370, v351);
            uint64_t v68 = *(void *)theChard;
            uint64_t v52 = v295;
            int64_t v55 = v307;
            int64_t v47 = v308;
            char v50 = v318;
            unsigned int v46 = v331;
            int64_t v51 = v192;
            int v49 = v328;
            uint64_t v48 = v191;
            uint64_t v189 = *((void *)&v361 + 1);
          }
          UniChar v188 = v351[v58 + 1 - v189 + v185];
        }
        UTF32Char v67 = v188;
        unsigned int v193 = (unsigned __int16)(v188 - 48);
        uint64_t v183 = v185 + 1;
      }
      while (v193 < 0xA);
      uint64_t v194 = 0;
      unint64_t v195 = 0;
      uint64_t v196 = &buffer[v59 + 1];
      do
      {
        uint64_t v197 = v194;
        unint64_t v195 = (v68 - 48) + 10 * v195;
        int64_t v54 = v59 + v194 + 1;
        if (v59 < -1) {
          break;
        }
        uint64_t v198 = v349;
        if ((uint64_t)v349 <= v54) {
          break;
        }
        if (*((void *)&v347 + 1))
        {
          UniChar v199 = *(_WORD *)(*((void *)&v347 + 1) + 2 * (v59 + v197 + *((void *)&v348 + 1)) + 2);
        }
        else if ((void)v348)
        {
          UniChar v199 = *(char *)(v348 + *((void *)&v348 + 1) + v59 + v197 + 1);
        }
        else
        {
          if (v350 <= v54 || (uint64_t v200 = *((void *)&v349 + 1), *((uint64_t *)&v349 + 1) > v54))
          {
            uint64_t v201 = v59 + v197 - 3;
            if ((unint64_t)v54 < 4) {
              uint64_t v201 = 0;
            }
            if (v201 + 64 < (uint64_t)v349) {
              uint64_t v198 = v201 + 64;
            }
            *((void *)&v349 + 1) = v201;
            int64_t v350 = v198;
            v371.CFIndex location = *((void *)&v348 + 1) + v201;
            v371.CFIndex length = v198 - v201;
            uint64_t v202 = v48;
            int64_t v287 = v51;
            int64_t v313 = v54;
            uint64_t v330 = v196;
            CFStringGetCharacters((CFStringRef)v347, v371, buffer);
            uint64_t v196 = v330;
            unsigned int v46 = v331;
            int64_t v54 = v313;
            uint64_t v52 = v295;
            int64_t v55 = v307;
            int64_t v47 = v308;
            char v50 = v318;
            int64_t v51 = v287;
            int v49 = v328;
            uint64_t v48 = v202;
            uint64_t v200 = *((void *)&v349 + 1);
          }
          UniChar v199 = v196[v197 - v200];
        }
        LODWORD(v68) = v199;
        unsigned int v203 = (unsigned __int16)(v199 - 48);
        uint64_t v194 = v197 + 1;
      }
      while (v203 < 0xA);
      if (v184 != v195)
      {
        unsigned int v281 = v306;
        if (!cf) {
          unsigned int v281 = 0;
        }
        if (v184 >= v195)
        {
          if (v281) {
            CFRelease(cf);
          }
          return 1;
        }
        else
        {
          if (v281) {
            CFRelease(cf);
          }
          return -1;
        }
      }
      if ((v46 & 0x200) != 0)
      {
        locale = cf;
        if (!v48)
        {
          if (v185 + 1 < v197 + 1) {
            uint64_t v204 = -1;
          }
          else {
            uint64_t v204 = 1;
          }
          int v205 = v303;
          if (v185 != v197) {
            int v205 = 1;
          }
          int v303 = v205;
          if (v185 == v197) {
            uint64_t v48 = 0;
          }
          else {
            uint64_t v48 = v204;
          }
          if (v185 != v197) {
            int64_t v51 = v59;
          }
          int64_t v206 = *(void *)v315;
          if (v185 != v197) {
            int64_t v206 = v58;
          }
          *(void *)v315 = v206;
        }
      }
      else
      {
        locale = cf;
      }
      if (v21 >= v327 || v54 >= v301)
      {
        int64_t v21 = v58 + v185 + 1;
        int64_t v54 = v59 + v197 + 1;
        CFIndex length = v327;
        goto LABEL_409;
      }
      continue;
    }
    break;
  }
  if (v67 == v68)
  {
    *(void *)v315 = v66;
    uint64_t v57 = v61;
    uint64_t v56 = v60;
    int64_t v54 = v59;
    int64_t v21 = v58;
    locale = cf;
    CFIndex length = v327;
LABEL_329:
    if (v52 == v56 && v56 > 0) {
      uint64_t v56 = 0;
    }
    if (v53 == v57 && v57 > 0) {
      uint64_t v57 = 0;
    }
    uint64_t v173 = v338;
    if (v56) {
      uint64_t v173 = 0;
    }
    v21 += v173;
    uint64_t v174 = v337;
    if (v57) {
      uint64_t v174 = 0;
    }
    v54 += v174;
    if (!(v56 | v57))
    {
      int64_t v55 = v54;
      int64_t v47 = v21;
    }
    if (v21 >= length || v54 >= v301)
    {
LABEL_409:
      uint64_t v13 = v301;
      int64_t v66 = *(void *)v315;
      goto LABEL_411;
    }
    goto LABEL_60;
  }
  if ((v50 & 1) == 0)
  {
    if (!cf)
    {
      BOOL v211 = v67 >= v68;
      goto LABEL_616;
    }
    CFComparisonResult v77 = _CFCompareStringsWithLocale(v351, v21, v327 - v21, buffer, v54, v301 - v54, v302, cf);
    if (!v306) {
      return v77;
    }
    CFLocaleRef v212 = cf;
    goto LABEL_614;
  }
  if (v67 < v68) {
    CFComparisonResult v77 = kCFCompareLessThan;
  }
  else {
    CFComparisonResult v77 = kCFCompareGreaterThan;
  }
  if (((v48 == 0) & (v46 >> 9)) != 0)
  {
    uint64_t v48 = v77;
    int64_t v51 = v55;
    int64_t v66 = v47;
  }
  BOOL v78 = v67 >= 0x80 || v68 >= 0x80;
  int v79 = v328 ^ 1;
  if (v78) {
    int v79 = 0;
  }
  if (v79 == 1)
  {
    if (cf)
    {
      CFComparisonResult v77 = _CFCompareStringsWithLocale(v351, v58, v327 - v58, buffer, v59, v301 - v59, v302, cf);
      if (!v306) {
        return v77;
      }
      CFLocaleRef v212 = cf;
      goto LABEL_614;
    }
    if ((v46 & 1) == 0) {
      return v77;
    }
  }
  uint64_t v332 = v53;
  if ((v67 & 0xFC00) == 0xD800 && v58 >= -1)
  {
    uint64_t v80 = v58 + 1;
    int64_t v81 = v361;
    if ((uint64_t)v361 > v58 + 1)
    {
      long long v82 = (UniChar *)*((void *)&v359 + 1);
      if (*((void *)&v359 + 1))
      {
        uint64_t v83 = *((void *)&v360 + 1) + v80;
        goto LABEL_112;
      }
      if ((void)v360)
      {
        UniChar v84 = *(char *)(v360 + *((void *)&v360 + 1) + v80);
      }
      else
      {
        if (v362 <= v80 || (uint64_t v122 = *((void *)&v361 + 1), *((uint64_t *)&v361 + 1) > v80))
        {
          int64_t v123 = v58 - 3;
          if ((unint64_t)v80 < 4) {
            int64_t v123 = 0;
          }
          if (v123 + 64 < (uint64_t)v361) {
            int64_t v81 = v123 + 64;
          }
          *((void *)&v361 + 1) = v123;
          int64_t v362 = v81;
          *(void *)theCharc = v60;
          v369.CFIndex location = *((void *)&v360 + 1) + v123;
          v369.CFIndex length = v81 - v123;
          uint64_t v293 = v52;
          uint64_t v282 = v48;
          int64_t v285 = v51;
          int v124 = v68;
          CFStringGetCharacters((CFStringRef)v359, v369, v351);
          LODWORD(v68) = v124;
          uint64_t v60 = *(void *)theCharc;
          unsigned int v46 = v331;
          uint64_t v53 = v332;
          uint64_t v61 = v329;
          int64_t v54 = v310;
          uint64_t v52 = v293;
          int64_t v55 = v307;
          int64_t v47 = v308;
          char v50 = v318;
          int64_t v51 = v285;
          int v49 = v328;
          uint64_t v48 = v282;
          uint64_t v122 = *((void *)&v361 + 1);
        }
        uint64_t v83 = v80 - v122;
        long long v82 = v351;
LABEL_112:
        UniChar v84 = v82[v83];
      }
      if (v84 >> 10 == 55)
      {
        UTF32Char v67 = ((unsigned __int16)v67 << 10) - 56613888 + v84;
        uint64_t v338 = 2;
      }
    }
  }
  if ((v68 & 0xFC00) == 0xD800 && v59 >= -1)
  {
    uint64_t v85 = v349;
    if ((uint64_t)v349 > v63)
    {
      unint64_t v86 = (UniChar *)*((void *)&v347 + 1);
      if (*((void *)&v347 + 1))
      {
        uint64_t v87 = *((void *)&v348 + 1) + v63;
        goto LABEL_138;
      }
      if ((void)v348)
      {
        UniChar v88 = *(char *)(v348 + *((void *)&v348 + 1) + v63);
      }
      else
      {
        if (v350 <= v63 || (uint64_t v106 = *((void *)&v349 + 1), *((uint64_t *)&v349 + 1) > v63))
        {
          if (v299 < (uint64_t)v349) {
            uint64_t v85 = v299;
          }
          *((void *)&v349 + 1) = v300;
          int64_t v350 = v85;
          *(void *)theChara = v60;
          v366.CFIndex location = *((void *)&v348 + 1) + v300;
          v366.CFIndex length = v85 - v300;
          uint64_t v290 = v52;
          uint64_t v107 = v48;
          int64_t v284 = v51;
          int v108 = v68;
          CFStringGetCharacters((CFStringRef)v347, v366, buffer);
          LODWORD(v68) = v108;
          uint64_t v60 = *(void *)theChara;
          unsigned int v46 = v331;
          uint64_t v53 = v332;
          uint64_t v61 = v329;
          int64_t v54 = v310;
          uint64_t v52 = v290;
          int64_t v55 = v307;
          int64_t v47 = v308;
          char v50 = v318;
          int64_t v51 = v284;
          int v49 = v328;
          uint64_t v48 = v107;
          uint64_t v106 = *((void *)&v349 + 1);
        }
        uint64_t v87 = v63 - v106;
        unint64_t v86 = buffer;
LABEL_138:
        UniChar v88 = v86[v87];
      }
      if (v88 >> 10 == 55)
      {
        LODWORD(v68) = ((unsigned __int16)v68 << 10) - 56613888 + v88;
        uint64_t v337 = 2;
      }
    }
  }
  UTF32Char theChar = v68;
  if (!v49) {
    goto LABEL_263;
  }
  uint64_t v89 = v60;
  char v90 = (char)theSet[1];
  UTF32Char v91 = HIDWORD(theSet[1]);
  unsigned int v92 = (uint64_t)theSet[1] & 4;
  if (HIDWORD(theSet[1]) > v67 || v336 <= v67)
  {
    if (((uint64_t)theSet[1] & 4) == 0) {
      goto LABEL_220;
    }
    goto LABEL_188;
  }
  if (!HIWORD(v67) && ((uint64_t)theSet[1] & 2) == 0)
  {
    if (*((void *)&v336 + 1))
    {
      if ((uint64_t)theSet[1])
      {
        unsigned int v125 = v92 >> 2;
        uint64_t v104 = *(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)v67 >> 8));
        if (*(unsigned char *)(*((void *)&v336 + 1) + ((unint64_t)v67 >> 8)))
        {
          if (v104 == 255)
          {
            unsigned int v105 = v92 == 0;
          }
          else if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1) {
                                                           + 32 * v104
          }
                                                           + (v67 >> 3)
                                                           + 224) >> (v67 & 7)) & 1) != 0)
          {
            unsigned int v105 = v92 == 0;
          }
          else
          {
            unsigned int v105 = v92 >> 2;
          }
        }
        else
        {
          unsigned int v105 = v92 >> 2;
        }
        int64_t v54 = v310;
        if (!v105) {
          goto LABEL_221;
        }
      }
      else
      {
        BOOL v93 = v92 != 0;
        if (((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)v67 >> 3)) >> (v67 & 7))) {
          BOOL v93 = v92 == 0;
        }
        int64_t v54 = v310;
        if (!v93) {
          goto LABEL_220;
        }
      }
    }
    else
    {
      BOOL v103 = v92 != 0;
      if (((uint64_t)theSet[1] & 1) == 0) {
        BOOL v103 = v92 == 0;
      }
      if (!v103)
      {
LABEL_220:
        unsigned int v125 = v92 >> 2;
        goto LABEL_221;
      }
    }
LABEL_188:
    if (v52 != v89 || v89 <= 0) {
      uint64_t v60 = v89;
    }
    else {
      uint64_t v60 = 0;
    }
    uint64_t v112 = v338;
    if (v60) {
      uint64_t v112 = 0;
    }
    v58 += v112;
    uint64_t v53 = v332 + v320;
    CFIndex length = v327;
    uint64_t v61 = v329;
    if (v58 >= v327)
    {
      locale = cf;
      goto LABEL_438;
    }
    goto LABEL_69;
  }
  uint64_t v94 = v48;
  int64_t v95 = v66;
  int64_t v96 = v51;
  uint64_t v97 = v63;
  int64_t v98 = v58;
  int64_t v99 = v59;
  int64_t v100 = v21;
  uint64_t v101 = v52;
  int IsLongCharacterMember = CFCharacterSetIsLongCharacterMember(theSet[0], v67);
  int64_t v54 = v310;
  uint64_t v52 = v101;
  int64_t v21 = v100;
  int64_t v59 = v99;
  int64_t v58 = v98;
  uint64_t v63 = v97;
  int64_t v55 = v307;
  int64_t v47 = v308;
  char v50 = v318;
  unsigned int v46 = v331;
  int64_t v51 = v96;
  int64_t v66 = v95;
  int v49 = v328;
  uint64_t v48 = v94;
  if (IsLongCharacterMember) {
    goto LABEL_188;
  }
  char v90 = (char)theSet[1];
  UTF32Char v91 = HIDWORD(theSet[1]);
  unsigned int v92 = (uint64_t)theSet[1] & 4;
  unsigned int v125 = (LODWORD(theSet[1]) >> 2) & 1;
LABEL_221:
  uint64_t v61 = v329;
  *(void *)v315 = v66;
  if (v91 > theChar || v336 <= theChar)
  {
    if (!v92) {
      goto LABEL_262;
    }
    goto LABEL_251;
  }
  if (HIWORD(theChar) || (v90 & 2) != 0)
  {
    uint64_t v128 = v48;
    int64_t v129 = v51;
    int64_t v321 = v21;
    uint64_t v130 = v52;
    int v131 = CFCharacterSetIsLongCharacterMember(theSet[0], theChar);
    uint64_t v61 = v329;
    unsigned int v46 = v331;
    int64_t v54 = v310;
    uint64_t v52 = v130;
    int64_t v21 = v321;
    int64_t v55 = v307;
    int64_t v47 = v308;
    char v50 = v318;
    int64_t v51 = v129;
    int v49 = v328;
    uint64_t v48 = v128;
    if (!v131) {
      goto LABEL_262;
    }
    goto LABEL_251;
  }
  if (*((void *)&v336 + 1))
  {
    if (v90)
    {
      uint64_t v134 = *(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)theChar >> 8));
      if (*(unsigned char *)(*((void *)&v336 + 1) + ((unint64_t)theChar >> 8)))
      {
        if (v134 == 255)
        {
          unsigned int v125 = v92 == 0;
        }
        else
        {
          BOOL v135 = v92 == 0;
          if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1)
                                                      + 32 * v134
                                                      + (theChar >> 3)
                                                      + 224) >> (theChar & 7)) & 1) != 0)
            unsigned int v125 = v135;
        }
      }
      if (!v125) {
        goto LABEL_262;
      }
    }
    else
    {
      BOOL v43 = v92 == 0;
      BOOL v126 = v92 != 0;
      char v127 = v43;
      if (((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)theChar >> 3)) >> (theChar & 7))) {
        BOOL v126 = v127;
      }
      if (!v126) {
        goto LABEL_262;
      }
    }
LABEL_251:
    if (v332 == v61 && v61 > 0) {
      uint64_t v61 = 0;
    }
    uint64_t v137 = v337;
    if (v61) {
      uint64_t v137 = 0;
    }
    v59 += v137;
    CFIndex length = v327;
    if (v327 <= v58 || (v60 = v89, v52 -= v89 > 0, uint64_t v53 = v332, v59 >= v301))
    {
      int64_t v66 = *(void *)v315;
      locale = cf;
LABEL_438:
      uint64_t v13 = v301;
LABEL_439:
      uint64_t v213 = v48;
      int64_t v214 = v51;
      *(void *)uint64_t v316 = v66;
      if (v58 < length)
      {
        while (2)
        {
          if (v58 < 0 || (int64_t v215 = v361, (uint64_t)v361 <= v58))
          {
            UniChar v218 = 0;
          }
          else
          {
            BOOL v216 = (UniChar *)*((void *)&v359 + 1);
            if (*((void *)&v359 + 1))
            {
              int64_t v217 = *((void *)&v360 + 1) + v58;
              goto LABEL_444;
            }
            if ((void)v360)
            {
              UniChar v218 = *(char *)(v360 + *((void *)&v360 + 1) + v58);
            }
            else
            {
              if (v362 <= v58 || (uint64_t v235 = *((void *)&v361 + 1), *((uint64_t *)&v361 + 1) > v58))
              {
                int64_t v236 = v58 - 4;
                if ((unint64_t)v58 < 4) {
                  int64_t v236 = 0;
                }
                if (v236 + 64 < (uint64_t)v361) {
                  int64_t v215 = v236 + 64;
                }
                *((void *)&v361 + 1) = v236;
                int64_t v362 = v215;
                v372.CFIndex location = *((void *)&v360 + 1) + v236;
                v372.CFIndex length = v215 - v236;
                CFStringGetCharacters((CFStringRef)v359, v372, v351);
                int64_t v51 = v214;
                int v49 = v328;
                uint64_t v48 = v213;
                uint64_t v235 = *((void *)&v361 + 1);
              }
              int64_t v217 = v58 - v235;
              BOOL v216 = v351;
LABEL_444:
              UniChar v218 = v216[v217];
            }
          }
          UTF32Char v219 = v218;
          if (((v218 < 0x80u) & ~v49) != 0) {
            break;
          }
          if (v218 >> 10 == 54 && v58 >= -1)
          {
            uint64_t v220 = v13;
            uint64_t v221 = v58 + 1;
            int64_t v222 = v361;
            if ((uint64_t)v361 <= v58 + 1)
            {
              uint64_t v13 = v220;
              int64_t v66 = *(void *)v316;
            }
            else
            {
              uint64_t v223 = (UniChar *)*((void *)&v359 + 1);
              if (*((void *)&v359 + 1))
              {
                uint64_t v224 = *((void *)&v360 + 1) + v221;
                goto LABEL_452;
              }
              if ((void)v360)
              {
                UniChar v225 = *(char *)(v360 + *((void *)&v360 + 1) + v221);
              }
              else
              {
                if (v362 <= v221 || (uint64_t v239 = *((void *)&v361 + 1), *((uint64_t *)&v361 + 1) > v221))
                {
                  int64_t v240 = v58 - 3;
                  if ((unint64_t)v221 < 4) {
                    int64_t v240 = 0;
                  }
                  if (v240 + 64 < (uint64_t)v361) {
                    int64_t v222 = v240 + 64;
                  }
                  *((void *)&v361 + 1) = v240;
                  int64_t v362 = v222;
                  v373.CFIndex location = *((void *)&v360 + 1) + v240;
                  v373.CFIndex length = v222 - v240;
                  CFStringGetCharacters((CFStringRef)v359, v373, v351);
                  int64_t v51 = v214;
                  int v49 = v328;
                  uint64_t v48 = v213;
                  uint64_t v239 = *((void *)&v361 + 1);
                }
                uint64_t v224 = v221 - v239;
                uint64_t v223 = v351;
LABEL_452:
                UniChar v225 = v223[v224];
              }
              uint64_t v13 = v220;
              int64_t v66 = *(void *)v316;
              if (v225 >> 10 == 55) {
                UTF32Char v219 = (v219 << 10) + v225 - 56613888;
              }
            }
          }
          if (!v319) {
            goto LABEL_465;
          }
          uint64_t v226 = BitmapPtrForPlane;
          if (v219 >= 0x10000)
          {
            uint64_t v226 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v219));
            int64_t v51 = v214;
            int v49 = v328;
            uint64_t v48 = v213;
          }
          if (!v226 || ((*(unsigned __int8 *)(v226 + ((unsigned __int16)v219 >> 3)) >> (v219 & 7)) & 1) == 0)
          {
LABEL_465:
            if (!v49) {
              break;
            }
            unsigned int v227 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) > v219 || v336 <= v219)
            {
              if (((uint64_t)theSet[1] & 4) == 0) {
                break;
              }
            }
            else if (HIWORD(v219) || ((uint64_t)theSet[1] & 2) != 0)
            {
              int v230 = CFCharacterSetIsLongCharacterMember(theSet[0], v219);
              int64_t v51 = v214;
              int v49 = v328;
              uint64_t v48 = v213;
              if (!v230) {
                break;
              }
            }
            else if (*((void *)&v336 + 1))
            {
              if ((uint64_t)theSet[1])
              {
                unsigned int v233 = v227 >> 2;
                uint64_t v234 = *(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)v219 >> 8));
                if (*(unsigned char *)(*((void *)&v336 + 1) + ((unint64_t)v219 >> 8)))
                {
                  if (v234 == 255)
                  {
                    unsigned int v233 = v227 == 0;
                  }
                  else
                  {
                    BOOL v237 = v227 == 0;
                    if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1)
                                                                + 32 * v234
                                                                + (v219 >> 3)
                                                                + 224) >> (v219 & 7)) & 1) != 0)
                      unsigned int v233 = v237;
                  }
                }
                if (!v233) {
                  break;
                }
              }
              else
              {
                BOOL v43 = v227 == 0;
                BOOL v228 = v227 != 0;
                char v229 = v43;
                if (((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)v219 >> 3)) >> (v219 & 7))) {
                  BOOL v228 = v229;
                }
                if (!v228) {
                  break;
                }
              }
            }
            else
            {
              BOOL v43 = v227 == 0;
              BOOL v231 = v227 != 0;
              char v232 = v43;
              if (((uint64_t)theSet[1] & 1) == 0) {
                BOOL v231 = v232;
              }
              if (!v231) {
                break;
              }
            }
          }
          if (v219 < 0x10000) {
            uint64_t v238 = 1;
          }
          else {
            uint64_t v238 = 2;
          }
          v58 += v238;
          if (v58 >= length) {
            break;
          }
          continue;
        }
      }
      if (v59 < v13)
      {
        while (2)
        {
          if (v59 < 0 || (int64_t v241 = v349, (uint64_t)v349 <= v59))
          {
            UniChar v244 = 0;
          }
          else
          {
            UniChar v242 = (UniChar *)*((void *)&v347 + 1);
            if (*((void *)&v347 + 1))
            {
              int64_t v243 = *((void *)&v348 + 1) + v59;
              goto LABEL_522;
            }
            if ((void)v348)
            {
              UniChar v244 = *(char *)(v348 + *((void *)&v348 + 1) + v59);
            }
            else
            {
              if (v350 <= v59 || (uint64_t v261 = *((void *)&v349 + 1), *((uint64_t *)&v349 + 1) > v59))
              {
                int64_t v262 = v59 - 4;
                if ((unint64_t)v59 < 4) {
                  int64_t v262 = 0;
                }
                if (v262 + 64 < (uint64_t)v349) {
                  int64_t v241 = v262 + 64;
                }
                *((void *)&v349 + 1) = v262;
                int64_t v350 = v241;
                v374.CFIndex location = *((void *)&v348 + 1) + v262;
                v374.CFIndex length = v241 - v262;
                CFStringGetCharacters((CFStringRef)v347, v374, buffer);
                int64_t v51 = v214;
                int v49 = v328;
                uint64_t v48 = v213;
                uint64_t v261 = *((void *)&v349 + 1);
              }
              int64_t v243 = v59 - v261;
              UniChar v242 = buffer;
LABEL_522:
              UniChar v244 = v242[v243];
            }
          }
          UTF32Char v245 = v244;
          if (((v244 < 0x80u) & ~v49) != 0) {
            break;
          }
          if (v244 >> 10 == 54 && v59 >= -1)
          {
            uint64_t v246 = v13;
            uint64_t v247 = v59 + 1;
            int64_t v248 = v349;
            if ((uint64_t)v349 <= v59 + 1)
            {
              uint64_t v13 = v246;
              int64_t v66 = *(void *)v316;
            }
            else
            {
              CFIndex v249 = (UniChar *)*((void *)&v347 + 1);
              if (*((void *)&v347 + 1))
              {
                uint64_t v250 = *((void *)&v348 + 1) + v247;
                goto LABEL_530;
              }
              if ((void)v348)
              {
                UniChar v251 = *(char *)(v348 + *((void *)&v348 + 1) + v247);
              }
              else
              {
                if (v350 <= v247 || (uint64_t v265 = *((void *)&v349 + 1), *((uint64_t *)&v349 + 1) > v247))
                {
                  int64_t v266 = v59 - 3;
                  if ((unint64_t)v247 < 4) {
                    int64_t v266 = 0;
                  }
                  if (v266 + 64 < (uint64_t)v349) {
                    int64_t v248 = v266 + 64;
                  }
                  *((void *)&v349 + 1) = v266;
                  int64_t v350 = v248;
                  v375.CFIndex location = *((void *)&v348 + 1) + v266;
                  v375.CFIndex length = v248 - v266;
                  CFStringGetCharacters((CFStringRef)v347, v375, buffer);
                  int64_t v51 = v214;
                  int v49 = v328;
                  uint64_t v48 = v213;
                  uint64_t v265 = *((void *)&v349 + 1);
                }
                uint64_t v250 = v247 - v265;
                CFIndex v249 = buffer;
LABEL_530:
                UniChar v251 = v249[v250];
              }
              uint64_t v13 = v246;
              int64_t v66 = *(void *)v316;
              if (v251 >> 10 == 55) {
                UTF32Char v245 = (v245 << 10) + v251 - 56613888;
              }
            }
          }
          if (!v319) {
            goto LABEL_543;
          }
          uint64_t v252 = BitmapPtrForPlane;
          if (v245 >= 0x10000)
          {
            uint64_t v252 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v245));
            int64_t v51 = v214;
            int v49 = v328;
            uint64_t v48 = v213;
          }
          if (!v252 || ((*(unsigned __int8 *)(v252 + ((unsigned __int16)v245 >> 3)) >> (v245 & 7)) & 1) == 0)
          {
LABEL_543:
            if (!v49) {
              break;
            }
            unsigned int v253 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) > v245 || v336 <= v245)
            {
              if (((uint64_t)theSet[1] & 4) == 0) {
                break;
              }
            }
            else if (HIWORD(v245) || ((uint64_t)theSet[1] & 2) != 0)
            {
              int v256 = CFCharacterSetIsLongCharacterMember(theSet[0], v245);
              int64_t v51 = v214;
              int v49 = v328;
              uint64_t v48 = v213;
              if (!v256) {
                break;
              }
            }
            else if (*((void *)&v336 + 1))
            {
              if ((uint64_t)theSet[1])
              {
                unsigned int v259 = v253 >> 2;
                uint64_t v260 = *(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)v245 >> 8));
                if (*(unsigned char *)(*((void *)&v336 + 1) + ((unint64_t)v245 >> 8)))
                {
                  if (v260 == 255)
                  {
                    unsigned int v259 = v253 == 0;
                  }
                  else
                  {
                    BOOL v263 = v253 == 0;
                    if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1)
                                                                + 32 * v260
                                                                + (v245 >> 3)
                                                                + 224) >> (v245 & 7)) & 1) != 0)
                      unsigned int v259 = v263;
                  }
                }
                if (!v259) {
                  break;
                }
              }
              else
              {
                BOOL v43 = v253 == 0;
                BOOL v254 = v253 != 0;
                char v255 = v43;
                if (((unint64_t)*(unsigned __int8 *)(*((void *)&v336 + 1) + ((unint64_t)v245 >> 3)) >> (v245 & 7))) {
                  BOOL v254 = v255;
                }
                if (!v254) {
                  break;
                }
              }
            }
            else
            {
              BOOL v43 = v253 == 0;
              BOOL v257 = v253 != 0;
              char v258 = v43;
              if (((uint64_t)theSet[1] & 1) == 0) {
                BOOL v257 = v258;
              }
              if (!v257) {
                break;
              }
            }
          }
          if (v245 < 0x10000) {
            uint64_t v264 = 1;
          }
          else {
            uint64_t v264 = 2;
          }
          v59 += v264;
          if (v59 >= v13) {
            break;
          }
          continue;
        }
      }
LABEL_595:
      if (locale)
      {
        char v267 = v306;
        if ((v303 & 1) == 0 && v48 && v58 == length && v59 == v13) {
          uint64_t v48 = _CFCompareStringsWithLocale(v351, v66, length - v66, buffer, v51, v13 - v51, v302, locale);
        }
      }
      else
      {
        char v267 = v306;
      }
      char v268 = v267 ^ 1;
      if (!locale) {
        char v268 = 1;
      }
      if ((v268 & 1) == 0)
      {
        uint64_t v269 = v48;
        CFRelease(locale);
        uint64_t v48 = v269;
      }
      if (v59 < v13) {
        CFComparisonResult v270 = kCFCompareLessThan;
      }
      else {
        CFComparisonResult v270 = v48;
      }
      if (v58 < length) {
        return 1;
      }
      else {
        return v270;
      }
    }
    goto LABEL_61;
  }
  BOOL v43 = v92 == 0;
  BOOL v132 = v92 != 0;
  char v133 = v43;
  if ((v90 & 1) == 0) {
    BOOL v132 = v133;
  }
  if (v132) {
    goto LABEL_251;
  }
LABEL_262:
  int64_t v54 = v59;
  uint64_t v298 = v61;
  int64_t v21 = v58;
  uint64_t v60 = v89;
  uint64_t v304 = v89;
  int64_t v66 = *(void *)v315;
  uint64_t v53 = v332;
LABEL_263:
  char v138 = v319 ^ 1;
  if (v21 < 1) {
    char v138 = 1;
  }
  unint64_t v139 = v302;
  if (v138)
  {
    uint64_t v142 = v289;
    uint64_t v57 = v298;
    goto LABEL_293;
  }
  uint64_t v57 = v298;
  uint64_t v140 = v60;
  if (v60) {
    goto LABEL_267;
  }
  uint64_t v143 = BitmapPtrForPlane;
  if (v67 >= 0x10000)
  {
    uint64_t v144 = v48;
    int64_t v145 = v66;
    int64_t v146 = v51;
    int64_t v147 = v21;
    uint64_t v148 = v52;
    int64_t v149 = v54;
    uint64_t v143 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v67));
    uint64_t v61 = v329;
    unsigned int v46 = v331;
    int64_t v54 = v149;
    uint64_t v52 = v148;
    int64_t v21 = v147;
    uint64_t v57 = v298;
    int64_t v55 = v307;
    int64_t v47 = v308;
    char v50 = v318;
    int64_t v51 = v146;
    int64_t v66 = v145;
    int v49 = v328;
    uint64_t v48 = v144;
  }
  if (!v143)
  {
LABEL_267:
    BOOL v141 = 0;
    if (!v61) {
      goto LABEL_276;
    }
LABEL_288:
    if (v141) {
      v54 -= v337;
    }
LABEL_291:
    uint64_t v142 = v289;
    uint64_t v60 = v140;
    goto LABEL_292;
  }
  int v150 = (1 << (v67 & 7)) & *(unsigned __int8 *)(v143 + ((unsigned __int16)v67 >> 3));
  BOOL v141 = v150 != 0;
  if (v150) {
    UTF32Char v67 = theChar;
  }
  if (v61) {
    goto LABEL_288;
  }
LABEL_276:
  uint64_t v151 = BitmapPtrForPlane;
  if (theChar >= 0x10000)
  {
    uint64_t v152 = v48;
    int64_t v153 = v66;
    int64_t v154 = v51;
    int64_t v155 = v21;
    uint64_t v156 = v52;
    int64_t v311 = v54;
    uint64_t v151 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(theChar));
    uint64_t v61 = v329;
    unsigned int v46 = v331;
    int64_t v54 = v311;
    uint64_t v52 = v156;
    int64_t v21 = v155;
    uint64_t v57 = v298;
    int64_t v55 = v307;
    int64_t v47 = v308;
    char v50 = v318;
    int64_t v51 = v154;
    int64_t v66 = v153;
    int v49 = v328;
    uint64_t v48 = v152;
  }
  if (!v151) {
    goto LABEL_288;
  }
  int v157 = (1 << (theChar & 7)) & *(unsigned __int8 *)(v151 + ((unsigned __int16)theChar >> 3));
  if (v157) {
    UTF32Char v158 = v67;
  }
  else {
    UTF32Char v158 = theChar;
  }
  if (((v141 ^ (v157 != 0)) & 1) == 0)
  {
    UTF32Char theChar = v158;
    goto LABEL_291;
  }
  uint64_t v159 = v337;
  if (!v141) {
    uint64_t v159 = 0;
  }
  v54 -= v159;
  uint64_t v60 = v140;
  if (v157)
  {
    v21 -= v338;
    UTF32Char theChar = v67;
  }
  uint64_t v142 = v289;
LABEL_292:
  uint64_t v53 = v332;
LABEL_293:
  *(void *)v315 = v66;
  if (v67 == theChar)
  {
    locale = cf;
    CFIndex length = v327;
    goto LABEL_313;
  }
  if (v60)
  {
    BOOL v160 = 0;
    locale = cf;
    goto LABEL_311;
  }
  if (!v288 || v288 == v21)
  {
    int64_t v312 = v54;
    int64_t v286 = v51;
    uint64_t v162 = v48;
    char v334 = 0;
    uint64_t v163 = v21;
    int64_t v164 = v21;
    uint64_t v165 = v52;
    uint64_t v166 = __CFStringFoldCharacterClusterAtIndex(v67, v351, v163, v302, __s1, v364, &v338, &v334);
    uint64_t v161 = v166;
    if (v166 > 0) {
      uint64_t v52 = 1;
    }
    else {
      uint64_t v52 = v165;
    }
    if (v166 > 0) {
      UTF32Char v67 = v364[0];
    }
    int64_t v167 = v164;
    if (v334)
    {
      uint64_t v168 = v52;
      uint64_t RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex(theString, v164, 1);
      uint64_t v52 = v168;
      uint64_t v288 = RangeOfCharacterClusterAtIndex + v170;
    }
    else
    {
      uint64_t v288 = 0;
    }
    locale = cf;
    int64_t v55 = v307;
    int64_t v47 = v308;
    uint64_t v48 = v162;
    int v49 = v328;
    int64_t v51 = v286;
    uint64_t v61 = v329;
    unsigned int v46 = v331;
    char v50 = v318;
    int64_t v21 = v167;
    int64_t v54 = v312;
    uint64_t v57 = v298;
  }
  else
  {
    uint64_t v161 = 0;
    locale = cf;
  }
  BOOL v160 = v161 == 0;
  uint64_t v304 = v161;
  if (!v161 && v57 >= 1)
  {
    if (!locale)
    {
      BOOL v211 = v67 >= theChar;
      goto LABEL_616;
    }
    int64_t v277 = v327 - v47;
LABEL_651:
    int64_t v278 = v301 - v55;
    int64_t v279 = v55;
    unint64_t v280 = v139;
LABEL_652:
    CFComparisonResult v77 = _CFCompareStringsWithLocale(v351, v47, v277, buffer, v279, v278, v280, locale);
    if (!v306) {
      return v77;
    }
    CFLocaleRef v212 = locale;
LABEL_614:
    CFRelease(v212);
    return v77;
  }
LABEL_311:
  if (!v61)
  {
    if (v67 != theChar) {
      BOOL v160 = 1;
    }
    if (v160 && (!v289 || v289 == v54))
    {
      uint64_t v294 = v52;
      int64_t v175 = v51;
      uint64_t v176 = v48;
      char v334 = 0;
      int64_t v177 = v54;
      uint64_t v178 = __CFStringFoldCharacterClusterAtIndex(theChar, buffer, v54, v302, __s1, v363, &v337, &v334);
      unsigned int v179 = v363[0];
      if (v178 <= 0) {
        unsigned int v179 = theChar;
      }
      else {
        uint64_t v53 = 1;
      }
      if (v178 && v67 == v179)
      {
        uint64_t v180 = v178;
        if (v334)
        {
          uint64_t v181 = CFStringGetRangeOfCharacterClusterAtIndex(v283, v177, 1);
          uint64_t v142 = v181 + v182;
        }
        else
        {
          uint64_t v142 = 0;
        }
        CFIndex length = v327;
        uint64_t v48 = v176;
        int v49 = v328;
        int64_t v51 = v175;
        unsigned int v46 = v331;
        char v50 = v318;
        int64_t v55 = v307;
        int64_t v47 = v308;
        uint64_t v52 = v294;
        unint64_t v139 = v302;
        int64_t v54 = v177;
        uint64_t v57 = v180;
        goto LABEL_313;
      }
      if (!locale)
      {
        BOOL v211 = v67 >= v179;
        goto LABEL_616;
      }
      int64_t v279 = v307;
      int64_t v47 = v308;
      int64_t v277 = v327 - v308;
      unint64_t v280 = v302;
      int64_t v278 = v301 - v307;
      goto LABEL_652;
    }
    uint64_t v57 = 0;
    CFIndex length = v327;
LABEL_328:
    uint64_t v56 = v304;
    goto LABEL_329;
  }
  CFIndex length = v327;
  uint64_t v142 = v289;
LABEL_313:
  uint64_t v289 = v142;
  if (v304 < 1 || v57 < 1) {
    goto LABEL_328;
  }
  while (v52 < v304 && v53 < v57)
  {
    if (v364[v52] != v363[v53]) {
      goto LABEL_649;
    }
    ++v52;
    ++v53;
  }
  if (v52 >= v304) {
    goto LABEL_328;
  }
  uint64_t v56 = v304;
  if (v53 >= v57) {
    goto LABEL_329;
  }
LABEL_649:
  if (locale)
  {
    int64_t v277 = length - v47;
    goto LABEL_651;
  }
  BOOL v211 = v364[v52] >= v363[v53];
LABEL_616:
  if (v211) {
    return 1;
  }
  else {
    return -1;
  }
}

uint64_t __CFStringFillCharacterSetInlineBuffer(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x10000) != 0)
  {
    if (!__CFStringFillCharacterSetInlineBuffer_nonAlnumChars)
    {
      CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
      MutableCFStringRef Copy = CFCharacterSetCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Predefined);
      CFCharacterSetInvert(MutableCopy);
      uint64_t v6 = 0;
      atomic_compare_exchange_strong(&__CFStringFillCharacterSetInlineBuffer_nonAlnumChars, (unint64_t *)&v6, (unint64_t)MutableCopy);
      if (v6) {
        CFRelease(MutableCopy);
      }
    }
    CFCharacterSetInitInlineBuffer(__CFStringFillCharacterSetInlineBuffer_nonAlnumChars, a1);
  }
  return (a2 >> 16) & 1;
}

BOOL isEqualToString(uint64_t a1, void *a2)
{
  v20[2] = *(void *)off_1ECE0A5B0;
  int v4 = *(_DWORD *)off_1ECE0A6F0;
  unint64_t v5 = a1 & 0xC000000000000007;
  if ((a1 & 0xC000000000000007) == 0xC000000000000007) {
    int v4 = 7;
  }
  unint64_t v6 = ((unint64_t)(v4 ^ a1) >> 3) & 0xF;
  if (v6 != [a2 length]) {
    return 0;
  }
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v7 = *(void *)off_1ECE0A6F0;
  if (v5 == 0xC000000000000007) {
    uint64_t v7 = 0;
  }
  unint64_t v8 = v7 ^ a1;
  BOOL v9 = (~(v7 ^ a1) & 7) == 0;
  uint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  if (v9) {
    uint64_t v10 = 0xFFFFFFFFFFFFFLL;
  }
  unint64_t v11 = (v8 >> 3) & 0xF;
  unint64_t v12 = (v10 & (v8 >> 3)) >> 4;
  if (v11 < 8)
  {
    v20[0] = v12;
  }
  else
  {
    uint64_t v13 = (v8 >> 3) & 0xF;
    if (v11 >= 0xA)
    {
      do
      {
        *((unsigned char *)&v19[15] + v13 + 1) = sixBitToCharLookup[v12 & 0x1F];
        v12 >>= 5;
        --v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        *((unsigned char *)&v19[15] + v13 + 1) = sixBitToCharLookup[v12 & 0x3F];
        v12 >>= 6;
        --v13;
      }
      while (v13);
    }
  }
  objc_msgSend(a2, "getCharacters:range:", v19, 0, v6);
  if (!v11) {
    return 1;
  }
  if (v19[0] != LOBYTE(v20[0])) {
    return 0;
  }
  uint64_t v14 = 1;
  do
  {
    unint64_t v15 = v14;
    if (v11 == v14) {
      break;
    }
    int v16 = *((unsigned __int8 *)v20 + v14);
    int v17 = (unsigned __int16)v19[v14++];
  }
  while (v17 == v16);
  return v15 >= v11;
}

uint64_t _NSIsNSString(uint64_t a1)
{
  if (a1 < 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    if ((~a1 & 0xC000000000000007) == 0) {
      uint64_t v3 = 0;
    }
    uint64_t v4 = v3 ^ a1;
    do
    {
      if ((v4 & 7) == *((unsigned char *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    unint64_t v5 = v2 | v4;
    uint64_t v6 = v2 & 7;
    int v7 = (v5 >> 55) + 8;
    if (v6 == 7) {
      LODWORD(v6) = v7;
    }
    LOBYTE(Class) = v6 == 2 || v6 == 22;
    return Class & 1;
  }
  if (_NSStringClass)
  {
    if (a1) {
      goto LABEL_17;
    }
    goto LABEL_23;
  }
  Class Class = objc_getClass("NSString");
  _NSStringClass Class = (uint64_t)Class;
  if (!Class) {
    return Class & 1;
  }
  if (!a1)
  {
LABEL_23:
    LOBYTE(Class) = 0;
    return Class & 1;
  }
LABEL_17:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
    return Class & 1;
  }

  return MethodImplementation(a1, sel_isNSString__);
}

uint64_t _CFStringCheckAndGetCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *__dst)
{
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  unint64_t v5 = (unsigned __int8 ***)(a1 + 16);
  if ((v4 & 0x60) != 0)
  {
    uint64_t v6 = *v5;
  }
  else
  {
    char v7 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v6 = (unsigned __int8 **)&v5[(v7 & 5) != 4];
  }
  char v8 = atomic_load((unint64_t *)(a1 + 8));
  if ((v8 & 5) == 4)
  {
    BOOL v9 = (unsigned __int8 **)*(unsigned __int8 *)v6;
  }
  else
  {
    char v10 = atomic_load((unint64_t *)(a1 + 8));
    if ((v10 & 0x60) != 0) {
      BOOL v9 = *(unsigned __int8 ***)(a1 + 24);
    }
    else {
      BOOL v9 = *v5;
    }
  }
  if (a2 + a3 > (uint64_t)v9) {
    return 3;
  }
  char v12 = atomic_load((unint64_t *)(a1 + 8));
  if ((v12 & 0x10) != 0)
  {
    memmove(__dst, (char *)v6 + 2 * a2, 2 * a3);
  }
  else
  {
    unint64_t v13 = atomic_load((unint64_t *)(a1 + 8));
    __CFStrConvertBytesToUnicode((unsigned __int8 *)v6 + a2 + ((v13 >> 2) & 1), __dst, a3);
  }
  return 0;
}

unsigned __int8 *__CFStrConvertBytesToUnicode(unsigned __int8 *result, _WORD *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = __CFCharToUniCharTable;
    do
    {
      unsigned int v4 = *result++;
      *a2++ = *(_WORD *)(v3 + 2 * v4);
      --a3;
    }
    while (a3);
  }
  return result;
}

uint64_t CFUniCharGetBitmapPtrForPlane(unsigned int a1, unsigned int a2)
{
  if (a1 - 16 >= 0x54) {
    unsigned int v2 = a1;
  }
  else {
    unsigned int v2 = a1 + 85;
  }
  if (a1 == 1) {
    unsigned int v2 = 108;
  }
  if (v2 <= 0xF && ((1 << v2) & 0x900F) != 0) {
    return 0;
  }
  if (v2 > 0x63) {
    v2 -= 85;
  }
  uint64_t v5 = v2 - 4;
  if (v5 <= 0x15 && *((_DWORD *)&__CFUniCharBitmapDataArray + 4 * v5) > a2) {
    return *(void *)(*((void *)&__CFUniCharBitmapDataArray + 2 * v5 + 1) + 8 * a2);
  }
  else {
    return 0;
  }
}

uint64_t _CFCompareStringsWithLocale(UniChar *buffer, int64_t a2, int64_t a3, UniChar *a4, int64_t a5, int64_t a6, unint64_t a7, const __CFLocale *a8)
{
  uint64_t v136 = *(void *)off_1ECE0A5B0;
  int v133 = 0;
  BOOL v132 = 0;
  if (!_CFCompareStringsWithLocale_alnumBMP)
  {
    _CFCompareStringsWithLocale_alnumBMP = CFUniCharGetBitmapPtrForPlane(0xAu, 0);
    _CFCompareStringsWithLocale_nonBaseBMP = CFUniCharGetBitmapPtrForPlane(8u, 0);
    _CFCompareStringsWithLocale_punctBMP = CFUniCharGetBitmapPtrForPlane(0xBu, 0);
    _CFCompareStringsWithLocale_controlBMP = CFUniCharGetBitmapPtrForPlane(0x6Cu, 0);
  }
  uint64_t v15 = a2;
  if (a2 >= 1) {
    uint64_t v15 = __extendLocationBackward(a2 - 1, buffer, _CFCompareStringsWithLocale_nonBaseBMP, _CFCompareStringsWithLocale_punctBMP);
  }
  uint64_t v16 = a5;
  if (a5 >= 1) {
    uint64_t v16 = __extendLocationBackward(a5 - 1, a4, _CFCompareStringsWithLocale_nonBaseBMP, _CFCompareStringsWithLocale_punctBMP);
  }
  uint64_t v17 = _CFGetTSD(9u);
  uint64_t v116 = _CFGetTSD(8u);
  uint64_t v117 = v17;
  CFLocaleRef cf = a8;
  uint64_t v119 = buffer;
  if ((const __CFLocale *)v116 == a8)
  {
    int v126 = 1;
    uint64_t Collator = v17;
    if (v15 < 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  os_unfair_lock_lock_with_options();
  if ((const __CFLocale *)__CFDefaultCollatorLocale == a8)
  {
    CFLocaleRef v19 = 0;
    BOOL v20 = 1;
    goto LABEL_23;
  }
  CFLocaleRef v18 = CFLocaleCopyCurrent();
  if (v18 == a8)
  {
    CFLocaleRef v21 = a8;
    BOOL v20 = a8 == 0;
    if (v21)
    {
      CFStringRef v22 = (const void *)__CFDefaultCollatorLocale;
      CFLocaleRef v19 = v21;
      if ((const __CFLocale *)__CFDefaultCollatorLocale != v21)
      {
        uint64_t v23 = __CFDefaultCollatorsCount;
        if (__CFDefaultCollatorsCount >= 1)
        {
          do
          {
            __CFDefaultCollatorsCount = v23 - 1;
            ucol_close();
            uint64_t v23 = __CFDefaultCollatorsCount;
          }
          while (__CFDefaultCollatorsCount > 0);
          CFStringRef v22 = (const void *)__CFDefaultCollatorLocale;
        }
        CFLocaleRef v19 = cf;
        if (v22) {
          CFRelease(v22);
        }
        BOOL v20 = 0;
        __CFDefaultCollatorLocale = (uint64_t)CFRetain(cf);
      }
    }
    else
    {
      CFLocaleRef v19 = 0;
    }
LABEL_23:
    CFLocaleRef v130 = v19;
    if (__CFDefaultCollatorsCount <= 0)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    }
    else
    {
      uint64_t v24 = __CFDefaultCollators[--__CFDefaultCollatorsCount];
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
      uint64_t Collator = v24;
      if (v24)
      {
        if (v20) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }
    uint64_t Collator = __CFStringCreateCollator(cf);
    if (v20)
    {
LABEL_27:
      a8 = cf;
      if (Collator)
      {
        int v126 = 0;
        if (v15 < 0) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      goto LABEL_30;
    }
LABEL_26:
    CFRelease(v130);
    goto LABEL_27;
  }
  CFRelease(v18);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
LABEL_30:
  uint64_t Collator = __CFStringCreateCollator(a8);
  _CFSetTSD(0x11u, 0, 0);
  int v126 = 1;
  if (v15 < 0) {
    goto LABEL_32;
  }
LABEL_31:
  uint64_t v25 = *((void *)buffer + 20);
  if (v15 + a3 <= v25)
  {
    uint64_t v27 = *((void *)buffer + 17);
    if (v27)
    {
      uint64_t Typed = (UniChar *)(v27 + 2 * *((void *)buffer + 19) + 2 * v15);
      if (v16 < 0) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }
    if (a3 <= 64)
    {
      if (v15 + a3 > *((void *)buffer + 22) || (uint64_t v28 = *((void *)buffer + 21), v15 < v28))
      {
        if (v15 + 64 < v25) {
          uint64_t v25 = v15 + 64;
        }
        *((void *)buffer + 21) = v15;
        *((void *)buffer + 22) = v25;
        v29.CFIndex length = v25 - v15;
        uint64_t v31 = *((void *)buffer + 18);
        uint64_t v30 = *((void *)buffer + 19);
        if (v31)
        {
          uint64_t v28 = v15;
          if (v29.length)
          {
            uint64_t v32 = v31 + v30;
            unint64_t v33 = buffer;
            do
            {
              *v33++ = *(char *)(v32 + v15);
              ++v32;
              --v25;
            }
            while (v15 != v25);
            uint64_t v28 = v15;
          }
        }
        else
        {
          v29.CFIndex location = v30 + v15;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v29, buffer);
          uint64_t v28 = *((void *)buffer + 21);
        }
      }
      uint64_t Typed = &buffer[v15 - v28];
      if (v16 < 0) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }
  }
LABEL_32:
  uint64_t Typed = 0;
  if (v16 < 0) {
    goto LABEL_53;
  }
LABEL_52:
  uint64_t v34 = *((void *)a4 + 20);
  if (v16 + a6 <= v34)
  {
    uint64_t v104 = *((void *)a4 + 17);
    if (v104)
    {
      int v35 = (UniChar *)(v104 + 2 * *((void *)a4 + 19) + 2 * v16);
      if (!Typed) {
        goto LABEL_54;
      }
    }
    else
    {
      if (a6 > 64) {
        goto LABEL_53;
      }
      if (v16 + a6 > *((void *)a4 + 22) || (uint64_t v105 = *((void *)a4 + 21), v16 < v105))
      {
        if (v16 + 64 < v34) {
          uint64_t v34 = v16 + 64;
        }
        *((void *)a4 + 21) = v16;
        *((void *)a4 + 22) = v34;
        v106.CFIndex length = v34 - v16;
        uint64_t v108 = *((void *)a4 + 18);
        uint64_t v107 = *((void *)a4 + 19);
        if (v108)
        {
          uint64_t v105 = v16;
          if (v106.length)
          {
            uint64_t v109 = v108 + v107;
            BOOL v110 = a4;
            do
            {
              *v110++ = *(char *)(v109 + v16);
              ++v109;
              --v34;
            }
            while (v16 != v34);
            uint64_t v105 = v16;
          }
        }
        else
        {
          v106.CFIndex location = v107 + v16;
          CFStringGetCharacters(*((CFStringRef *)a4 + 16), v106, a4);
          uint64_t v105 = *((void *)a4 + 21);
        }
      }
      int v35 = &a4[v16 - v105];
      if (!Typed) {
        goto LABEL_54;
      }
    }
    if (v35)
    {
      int64_t v111 = a2 + a3 - v15;
      int64_t v112 = a5 + a6 - v16;
      uint64_t v100 = Collator;
      if (Collator && !__CompareTextDefault(Collator, v126, a7, Typed, v111, v35, v112, &v132, &v133))
      {
        uint64_t v114 = (a7 >> 9) & 1;
        if (!v132) {
          LODWORD(v114) = 1;
        }
        uint64_t v115 = 1;
        if (v133 < 0) {
          uint64_t v115 = -1;
        }
        if (v114) {
          uint64_t v97 = v115;
        }
        else {
          uint64_t v97 = 0;
        }
      }
      else
      {
        if (v111 >= v112) {
          int64_t v113 = v112;
        }
        else {
          int64_t v113 = v111;
        }
        if (memcmp(Typed, v35, 2 * v113) >= 0) {
          uint64_t v97 = 1;
        }
        else {
          uint64_t v97 = -1;
        }
      }
      uint64_t v99 = v117;
      CFLocaleRef v98 = cf;
      goto LABEL_189;
    }
    goto LABEL_54;
  }
LABEL_53:
  int v35 = 0;
LABEL_54:
  uint64_t v120 = 0;
  uint64_t v121 = 0;
  char ptr = 0;
  int v124 = 0;
  uint64_t v122 = 0;
  int64_t v36 = a2 + a3;
  int64_t v37 = a5 + a6;
  __src = a4;
  int64_t v128 = a2 + a3;
  CFTypeRef v131 = (CFTypeRef)(a5 + a6);
  do
  {
    if (a2 >= v36) {
      goto LABEL_101;
    }
    uint64_t v38 = __extendLocationForward(a2, buffer, _CFCompareStringsWithLocale_alnumBMP, _CFCompareStringsWithLocale_punctBMP, _CFCompareStringsWithLocale_controlBMP, v36);
    a2 = v38;
    a3 = v38 - v15;
    if (v15 < 0) {
      goto LABEL_58;
    }
    uint64_t v39 = *((void *)buffer + 20);
    if (v38 > v39) {
      goto LABEL_58;
    }
    uint64_t v43 = *((void *)buffer + 17);
    if (!v43)
    {
      if (a3 <= 64)
      {
        if (v38 > *((void *)buffer + 22) || (uint64_t v44 = *((void *)buffer + 21), v15 < v44))
        {
          if (v15 + 64 < v39) {
            uint64_t v39 = v15 + 64;
          }
          *((void *)buffer + 21) = v15;
          *((void *)buffer + 22) = v39;
          v45.CFIndex length = v39 - v15;
          uint64_t v47 = *((void *)buffer + 18);
          uint64_t v46 = *((void *)buffer + 19);
          if (v47)
          {
            uint64_t v44 = v15;
            if (v45.length)
            {
              uint64_t v48 = v47 + v46;
              int v49 = buffer;
              do
              {
                *v49++ = *(char *)(v48 + v15);
                ++v48;
                --v39;
              }
              while (v15 != v39);
              uint64_t v44 = v15;
            }
          }
          else
          {
            v45.CFIndex location = v46 + v15;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v45, buffer);
            uint64_t v44 = *((void *)buffer + 21);
          }
        }
        uint64_t Typed = &buffer[v15 - v44];
        goto LABEL_100;
      }
LABEL_58:
      if (v121 < 0 || a3 >= 129)
      {
        if (v121 >= a3)
        {
          uint64_t Typed = ptr;
        }
        else
        {
          if (a3 <= 0) {
            uint64_t v40 = -((v15 - v38) & 0x7F);
          }
          else {
            uint64_t v40 = a3 & 0x7F;
          }
          int64_t v41 = a3 - v40;
          uint64_t v42 = v41 + 128;
          if (v121)
          {
            uint64_t Typed = (UniChar *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, ptr, 2 * (v41 + 128), 0x1000040BDFB0063, 0, 0);
          }
          else
          {
            uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * (v41 + 128), 0x1000040BDFB0063, 0);
            if (!Typed) {
              __CFStringHandleOutOfMemory();
            }
          }
          uint64_t v121 = v42;
          a4 = __src;
        }
      }
      else
      {
        uint64_t Typed = (UniChar *)&__dst;
      }
      uint64_t v50 = *((void *)buffer + 17);
      if (v50)
      {
        memmove(Typed, (const void *)(v50 + 2 * *((void *)buffer + 19) + 2 * v15), 2 * a3);
        char ptr = Typed;
      }
      else
      {
        uint64_t v51 = *((void *)buffer + 21);
        if (v15 < v51 || (uint64_t v52 = *((void *)buffer + 22), v53 = v52 <= v15, v54 = v52 - v15, v53))
        {
          uint64_t v56 = Typed;
          uint64_t v57 = v15;
          CFIndex v58 = a3;
          if (a2 > v51)
          {
            uint64_t v56 = Typed;
            uint64_t v57 = v15;
            CFIndex v58 = a3;
            if (a2 < *((void *)buffer + 22))
            {
              CFIndex v58 = v51 - v15;
              memmove(&Typed[v51 - v15], buffer, 2 * (a2 - v51));
              uint64_t v56 = Typed;
              uint64_t v57 = v15;
            }
          }
        }
        else
        {
          if (a3 >= v54) {
            int64_t v55 = v54;
          }
          else {
            int64_t v55 = a3;
          }
          memmove(Typed, &buffer[v15 - v51], 2 * v55);
          uint64_t v56 = &Typed[v55];
          uint64_t v57 = v55 + v15;
          CFIndex v58 = a3 - v55;
        }
        if (v58 >= 1)
        {
          uint64_t v59 = *((void *)buffer + 18);
          v60.CFIndex location = *((void *)buffer + 19) + v57;
          if (v59)
          {
            uint64_t v61 = (char *)(v59 + v60.location);
            do
            {
              UniChar v62 = *v61++;
              *v56++ = v62;
              --v58;
            }
            while (v58);
          }
          else
          {
            v60.CFIndex length = v58;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v60, v56);
          }
        }
        char ptr = Typed;
        a4 = __src;
      }
      goto LABEL_100;
    }
    uint64_t Typed = (UniChar *)(v43 + 2 * *((void *)buffer + 19) + 2 * v15);
LABEL_100:
    int64_t v37 = (int64_t)v131;
LABEL_101:
    if (a5 < v37)
    {
      uint64_t v63 = __extendLocationForward(a5, a4, _CFCompareStringsWithLocale_alnumBMP, _CFCompareStringsWithLocale_punctBMP, _CFCompareStringsWithLocale_controlBMP, v37);
      a5 = v63;
      a6 = v63 - v16;
      if (v16 < 0 || (uint64_t v64 = *((void *)a4 + 20), v63 > v64))
      {
LABEL_104:
        if (v122 < 0 || a6 >= 129)
        {
          if (v122 >= a6)
          {
            int v35 = v124;
          }
          else
          {
            if (a6 <= 0) {
              uint64_t v65 = -((v16 - v63) & 0x7F);
            }
            else {
              uint64_t v65 = a6 & 0x7F;
            }
            int64_t v66 = a6 - v65;
            uint64_t v67 = v66 + 128;
            if (v122)
            {
              int v35 = (UniChar *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v124, 2 * (v66 + 128), 0x1000040BDFB0063, 0, 0);
            }
            else
            {
              int v35 = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * (v66 + 128), 0x1000040BDFB0063, 0);
              if (!v35) {
                __CFStringHandleOutOfMemory();
              }
            }
            uint64_t v122 = v67;
            a4 = __src;
          }
        }
        else
        {
          int v35 = (UniChar *)&v134;
        }
        uint64_t v75 = *((void *)a4 + 17);
        if (v75)
        {
          memmove(v35, (const void *)(v75 + 2 * *((void *)a4 + 19) + 2 * v16), 2 * a6);
          int v124 = v35;
          goto LABEL_146;
        }
        uint64_t v76 = *((void *)a4 + 21);
        uint64_t v77 = v16 - v76;
        if (v16 < v76 || (v78 = *((void *)a4 + 22), BOOL v53 = v78 <= v16, v79 = v78 - v16, v53))
        {
          long long v82 = v35;
          uint64_t v83 = v16;
          CFIndex v84 = a6;
          if (a5 > v76)
          {
            long long v82 = v35;
            uint64_t v83 = v16;
            CFIndex v84 = a6;
            if (a5 < *((void *)__src + 22))
            {
              CFIndex v84 = v76 - v16;
              memmove(&v35[v76 - v16], __src, 2 * (a5 - v76));
              long long v82 = v35;
              uint64_t v83 = v16;
            }
          }
        }
        else
        {
          uint64_t v80 = a4;
          if (a6 >= v79) {
            int64_t v81 = v79;
          }
          else {
            int64_t v81 = a6;
          }
          memmove(v35, &v80[v77], 2 * v81);
          long long v82 = &v35[v81];
          uint64_t v83 = v81 + v16;
          CFIndex v84 = a6 - v81;
        }
        if (v84 >= 1)
        {
          uint64_t v85 = *((void *)__src + 18);
          v86.CFIndex location = *((void *)__src + 19) + v83;
          if (!v85)
          {
            v86.CFIndex length = v84;
            CFStringGetCharacters(*((CFStringRef *)__src + 16), v86, v82);
            int v124 = v35;
            a4 = __src;
            goto LABEL_145;
          }
          uint64_t v87 = (char *)(v85 + v86.location);
          do
          {
            UniChar v88 = *v87++;
            *v82++ = v88;
            --v84;
          }
          while (v84);
        }
        int v124 = v35;
        a4 = __src;
LABEL_145:
        buffer = v119;
        goto LABEL_146;
      }
      uint64_t v68 = *((void *)a4 + 17);
      if (v68)
      {
        int v35 = (UniChar *)(v68 + 2 * *((void *)a4 + 19) + 2 * v16);
      }
      else
      {
        if (a6 > 64) {
          goto LABEL_104;
        }
        if (v63 > *((void *)a4 + 22) || (uint64_t v69 = *((void *)a4 + 21), v16 < v69))
        {
          if (v16 + 64 < v64) {
            uint64_t v64 = v16 + 64;
          }
          *((void *)a4 + 21) = v16;
          *((void *)a4 + 22) = v64;
          v70.CFIndex length = v64 - v16;
          uint64_t v72 = *((void *)a4 + 18);
          uint64_t v71 = *((void *)a4 + 19);
          if (v72)
          {
            uint64_t v69 = v16;
            if (v70.length)
            {
              uint64_t v73 = v72 + v71;
              uint64_t v74 = a4;
              do
              {
                *v74++ = *(char *)(v73 + v16);
                ++v73;
                --v64;
              }
              while (v16 != v64);
              uint64_t v69 = v16;
            }
          }
          else
          {
            v70.CFIndex location = v71 + v16;
            CFStringGetCharacters(*((CFStringRef *)a4 + 16), v70, a4);
            uint64_t v69 = *((void *)a4 + 21);
          }
        }
        int v35 = &a4[v16 - v69];
      }
    }
LABEL_146:
    if (Collator && !__CompareTextDefault(Collator, v126, a7, Typed, a3, v35, a6, &v132, &v133))
    {
      int v91 = v133;
      if (v132)
      {
        uint64_t v92 = v120;
        int64_t v36 = v128;
        uint64_t v93 = 1;
        if (v133 < 0) {
          uint64_t v93 = -1;
        }
        if (((v120 == 0) & (a7 >> 9) & (v133 != 0)) != 0) {
          uint64_t v92 = v93;
        }
        uint64_t v120 = v92;
        int v133 = 0;
        int v91 = 0;
        int64_t v37 = (int64_t)v131;
        goto LABEL_169;
      }
    }
    else
    {
      if (!Typed || !v35) {
        _CFCompareStringsWithLocale_cold_1();
      }
      if (a3 >= a6) {
        int64_t v89 = a6;
      }
      else {
        int64_t v89 = a3;
      }
      int v90 = memcmp(Typed, v35, 2 * v89);
      int v133 = v90;
      if (!v90)
      {
        int64_t v36 = v128;
        int64_t v37 = (int64_t)v131;
        if (a3 < a6)
        {
          int v133 = -2;
          uint64_t v97 = -1;
          goto LABEL_185;
        }
        if (a6 < a3)
        {
          int v133 = 2;
          uint64_t v97 = 1;
          goto LABEL_185;
        }
        int v91 = 0;
        goto LABEL_169;
      }
      if (v90 < 0) {
        int v91 = v90 - 1;
      }
      else {
        int v91 = v90 + 1;
      }
      int v133 = v91;
    }
    int64_t v36 = v128;
    int64_t v37 = (int64_t)v131;
    if ((v91 - 2) < 0xFFFFFFFD) {
      break;
    }
LABEL_169:
    if (!v91)
    {
      uint64_t v15 = a2;
      uint64_t v16 = a5;
    }
  }
  while (a2 < v36 || a5 < v37);
  BOOL v94 = v91 == 0;
  BOOL v95 = v91 < 0;
  uint64_t v96 = 1;
  if (v95) {
    uint64_t v96 = -1;
  }
  if (v94) {
    uint64_t v97 = v120;
  }
  else {
    uint64_t v97 = v96;
  }
LABEL_185:
  uint64_t v99 = v117;
  CFLocaleRef v98 = cf;
  uint64_t v100 = Collator;
  if (v121 >= 1) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  }
  if (v122 >= 1) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v124);
  }
LABEL_189:
  if (v100 != v99)
  {
    if (v116)
    {
      uint64_t v101 = _CFGetTSD(9u);
      __collatorFinalize(v101);
    }
    _CFSetTSD(9u, v100, (uint64_t)__collatorFinalize);
    CFTypeRef v102 = CFRetain(v98);
    _CFSetTSD(8u, (uint64_t)v102, 0);
  }
  _CFSetTSD(0x11u, a7, 0);
  return v97;
}

uint64_t __CompareTextDefault(uint64_t a1, int a2, unsigned int a3, unsigned __int16 *a4, unint64_t a5, unsigned __int16 *a6, unint64_t a7, BOOL *a8, int *a9)
{
  char v14 = a3;
  *a8 = 1;
  *a9 = 0;
  if (!a2 || ((_CFGetTSD(0x11u) >> 6) & 1) != ((a3 >> 6) & 1)) {
    ucol_setAttribute();
  }
  int v15 = ucol_strcoll();
  if (v15)
  {
    if (v15 == -1) {
      int v16 = -2;
    }
    else {
      int v16 = 2;
    }
LABEL_8:
    *a9 = v16;
    goto LABEL_10;
  }
  int v16 = *a9;
  if (!*a9)
  {
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    int v20 = ucol_strcoll();
    if (v20)
    {
      if (v20 == -1) {
        int v21 = -1;
      }
      else {
        int v21 = 1;
      }
      *a9 = v21;
    }
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    int v16 = *a9;
    if ((v14 & 0x10) == 0 && !v16)
    {
      ucol_openElements();
      uint64_t v25 = ucol_openElements();
      unint64_t v40 = a7;
      unsigned int v26 = ucol_next();
      int v27 = ucol_next();
      uint64_t v42 = v25;
      int v41 = 0;
      if (v26 == -1)
      {
        int v16 = 0;
        goto LABEL_71;
      }
      int v28 = v27;
      int v16 = 0;
      if (v27 != -1)
      {
        unint64_t v39 = a5;
        int v29 = 0;
        int v30 = 0;
        int v41 = 0;
        uint64_t v31 = v42;
        while (1)
        {
          int v44 = MEMORY[0x185312A10]();
          int v32 = MEMORY[0x185312A10](v31);
          int v43 = v32;
          if ((v28 ^ v26) <= 0xFF)
          {
            if (v26 >= 0x10000)
            {
              int v35 = v26;
              int v36 = v28;
              if (v26 - 143 < 9) {
                int v35 = v26 - 138;
              }
              if (v28 - 143 < 9) {
                int v36 = v28 - 138;
              }
              if (v35 != v36)
              {
                if (v35 < v36) {
                  int v16 = -1;
                }
                else {
                  int v16 = 1;
                }
LABEL_70:
                a5 = v39;
                break;
              }
            }
            else
            {
              if (v44 - v30 > v32 - v29) {
                int v33 = -1;
              }
              else {
                int v33 = 1;
              }
              if (v44 - v30 == v32 - v29) {
                int v33 = 0;
              }
              int v34 = v41;
              if (v41) {
                int v33 = v41;
              }
              if ((v26 & 0xFF00) != 0) {
                int v34 = v33;
              }
              int v41 = v34;
            }
          }
          unsigned int v26 = ucol_next();
          uint64_t v31 = v42;
          int v37 = ucol_next();
          int v28 = v37;
          BOOL v38 = v26 == -1 || v37 == -1;
          int v29 = v43;
          int v30 = v44;
          if (v38)
          {
            int v16 = 0;
            goto LABEL_70;
          }
        }
      }
LABEL_71:
      ucol_closeElements();
      ucol_closeElements();
      a7 = v40;
      if (!v16) {
        int v16 = v41;
      }
      goto LABEL_8;
    }
  }
LABEL_10:
  *a8 = v16 == 0;
  if (!*a9)
  {
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    int v18 = ucol_strcoll();
    if (v18)
    {
      if (v18 == -1) {
        int v19 = -1;
      }
      else {
        int v19 = 1;
      }
    }
    else
    {
      if (a5 >= a7) {
        int v22 = a7;
      }
      else {
        int v22 = a5;
      }
      if (v22)
      {
        while (1)
        {
          unsigned int v23 = *a4;
          unsigned int v24 = *a6;
          if (v23 != v24) {
            break;
          }
          ++a4;
          ++a6;
          if (!--v22) {
            goto LABEL_30;
          }
        }
        if (v23 < v24) {
          int v19 = -1;
        }
        else {
          int v19 = 1;
        }
      }
      else
      {
LABEL_30:
        if (a5 < a7) {
          int v19 = -1;
        }
        else {
          int v19 = 1;
        }
        if (a5 == a7) {
          int v19 = 0;
        }
      }
    }
    *a9 = v19;
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
  }
  return 0;
}

uint64_t _CFStringCompareASCIICaseInsensitive(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  while (1)
  {
    uint64_t v3 = __ASCII_LOWERCASE_TABLE[*a1] - __ASCII_LOWERCASE_TABLE[*a2];
    if (v3) {
      break;
    }
    ++a2;
    ++a1;
    if (!--a3) {
      return 0;
    }
  }
  return v3;
}

uint64_t __extendLocationBackward(uint64_t a1, UniChar *buffer, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1;
  if (a1 >= 1)
  {
    uint64_t v8 = -a1;
    for (uint64_t i = a1 + 64; ; --i)
    {
      if ((unint64_t)v4 >= 5) {
        uint64_t v10 = 5;
      }
      else {
        uint64_t v10 = v4;
      }
      if ((unint64_t)v4 >= 4) {
        uint64_t v11 = 4;
      }
      else {
        uint64_t v11 = v4;
      }
      uint64_t v12 = *((void *)buffer + 20);
      if (v12 <= v4)
      {
        UniChar v14 = 0;
      }
      else
      {
        uint64_t v13 = *((void *)buffer + 17);
        if (v13)
        {
          UniChar v14 = *(_WORD *)(v13 + 2 * (v4 + *((void *)buffer + 19)));
        }
        else
        {
          uint64_t v15 = *((void *)buffer + 18);
          if (v15)
          {
            UniChar v14 = *(char *)(v15 + *((void *)buffer + 19) + v4);
          }
          else
          {
            if (*((void *)buffer + 22) <= v4 || (uint64_t v16 = *((void *)buffer + 21), v16 > v4))
            {
              uint64_t v17 = -v11;
              uint64_t v18 = v11 + v8;
              uint64_t v19 = i - v11;
              uint64_t v20 = v4 + v17;
              uint64_t v21 = v20 + 64;
              if (v20 + 64 >= v12) {
                uint64_t v21 = *((void *)buffer + 20);
              }
              *((void *)buffer + 21) = v20;
              *((void *)buffer + 22) = v21;
              if (v12 >= v19) {
                uint64_t v12 = v19;
              }
              v32.CFIndex length = v12 + v18;
              v32.CFIndex location = v20 + *((void *)buffer + 19);
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              uint64_t v16 = *((void *)buffer + 21);
            }
            UniChar v14 = buffer[v4 - v16];
          }
        }
        if (v14 >> 10 == 55)
        {
          uint64_t v22 = *((void *)buffer + 20);
          if (v22 >= v4)
          {
            uint64_t v23 = *((void *)buffer + 17);
            if (v23)
            {
              unsigned int v24 = (UniChar *)(v23 + 2 * (v4 + *((void *)buffer + 19)));
              goto LABEL_27;
            }
            uint64_t v26 = *((void *)buffer + 18);
            if (v26)
            {
              unsigned __int16 v25 = *(char *)(v26 + *((void *)buffer + 19) + v4 - 1);
            }
            else
            {
              if (*((void *)buffer + 22) < v4 || (uint64_t v28 = *((void *)buffer + 21), v28 >= v4))
              {
                uint64_t v29 = v4 - v10;
                uint64_t v30 = v4 - v10 + 64;
                if (v30 >= v22) {
                  uint64_t v30 = *((void *)buffer + 20);
                }
                *((void *)buffer + 21) = v29;
                *((void *)buffer + 22) = v30;
                if (v22 >= i - v10) {
                  uint64_t v22 = i - v10;
                }
                v33.CFIndex length = v22 + v10 + v8;
                v33.CFIndex location = v29 + *((void *)buffer + 19);
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v33, buffer);
                uint64_t v28 = *((void *)buffer + 21);
              }
              unsigned int v24 = &buffer[v4 - v28];
LABEL_27:
              unsigned __int16 v25 = *(v24 - 1);
            }
            if (v25 >> 10 == 54) {
              return v4;
            }
          }
        }
      }
      if (a3 && ((*(unsigned __int8 *)(a3 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0)
      {
        if ((unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu) {
          return v4;
        }
      }
      else if (!a4 {
             || (unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu
      }
             || ((1 << (v14 & 7)) & *(unsigned __int8 *)(a4 + (v14 >> 3))) == 0)
      {
        return v4;
      }
      ++v8;
      if (v4-- <= 1) {
        return 0;
      }
    }
  }
  return v4;
}

uint64_t __CFStringCreateCollator(const __CFLocale *a1)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(a1, @"locale:collator id");
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v5 = 0u;
  CFStringGetCString(Value, buffer, 128, 0x600u);
  uint64_t v2 = ucol_open();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  return v2;
}

uint64_t chcompar(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 - *a2;
}

CFTypeID CFBagGetTypeID(void)
{
  return 4;
}

uint64_t __CFStringIsCF(unint64_t *a1, unsigned char *a2, unint64_t *a3, BOOL *a4)
{
  if (CF_IS_OBJC(7uLL, (unint64_t)a1)) {
    return 0;
  }
  char v9 = atomic_load(a1 + 1);
  *a2 = v9 & 1;
  char v10 = atomic_load(a1 + 1);
  uint64_t v11 = v10 & 5;
  char v12 = atomic_load(a1 + 1);
  uint64_t v13 = v12 & 0x60;
  if (v11 == 4)
  {
    UniChar v14 = (unsigned __int8 ***)(a1 + 2);
    if (v13)
    {
      uint64_t v15 = *v14;
    }
    else
    {
      uint64_t v17 = atomic_load(a1 + 1);
      uint64_t v15 = (unsigned __int8 **)&v14[(v17 & 5) != 4];
    }
    unint64_t v16 = *(unsigned __int8 *)v15;
  }
  else if ((v12 & 0x60) != 0)
  {
    unint64_t v16 = a1[3];
  }
  else
  {
    unint64_t v16 = a1[2];
  }
  *a3 = v16;
  unsigned int v18 = atomic_load(a1 + 1);
  uint64_t result = 1;
  *a4 = ((v18 >> 4) & 1) == 0;
  return result;
}

void sub_182BA241C(_Unwind_Exception *exception_object)
{
}

void sub_182BA2BC4(_Unwind_Exception *a1)
{
}

uint64_t _NSIsNSArray(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSArray__);
}

char *__NSArrayI_new(id *a1, void *a2, unint64_t a3, char a4)
{
  unsigned int v18 = a2;
  long long v8 = (objc_class *)self;
  char v9 = (char *)__CFAllocateObject(v8, 8 * a3);
  char v10 = v9;
  if (a3)
  {
    uint64_t v11 = (id *)(v9 + 16);
    if (a2)
    {
      *uint64_t v11 = *a1;
      if (a3 >= 2)
      {
        unint64_t v12 = a3 - 1;
        uint64_t v13 = v9 + 24;
        do
        {
          UniChar v14 = v18++;
          *v13++ = *v14;
          --v12;
        }
        while (v12);
      }
    }
    else if (a1)
    {
      memmove(v9 + 16, a1, 8 * a3);
    }
    if ((a4 & 1) == 0)
    {
      if (a3 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = a3;
      }
      do
      {
        if (((unint64_t)*v11 & 0x8000000000000000) == 0) {
          id v16 = *v11;
        }
        ++v11;
        --v15;
      }
      while (v15);
    }
    *((void *)v10 + 1) = a3;
  }
  return v10;
}

__objc2_class **__NSArrayMutablePlaceholder()
{
  return &___mutablePlaceholderArray;
}

__objc2_class **__NSArrayImmutablePlaceholder()
{
  return &___immutablePlaceholderArray;
}

uint64_t __createArray(void *a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  return [a1 initWithObjects:v3 count:1];
}

void *__NSSingleObjectArrayI_new(uint64_t a1, char a2)
{
  uint64_t v4 = (objc_class *)self;
  long long v5 = __CFAllocateObject(v4, 0);
  long long v6 = v5;
  if (v5)
  {
    v5[1] = a1;
    if (a1 >= 1 && (a2 & 1) == 0) {
      id v7 = (id)a1;
    }
  }
  return v6;
}

_DWORD *__NSDictionaryM_new(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char v34 = a4;
  uint64_t v5 = 0;
  unint64_t v6 = 0xFFFFFFFF80000000 * ((a4 >> 1) & 1);
  while (__NSDictionaryCapacities_0[v5] < a3)
  {
    ++v5;
    v6 -= 0x400000000000000;
    if (v5 == 40)
    {
      __break(1u);
      break;
    }
  }
  uint64_t v7 = __NSDictionarySizes_0[v5];
  long long v8 = (objc_class *)self;
  char v9 = __CFAllocateObject(v8, 0);
  v9[4] = 1;
  *((void *)v9 + 2) = (*((void *)v9 + 2) & 0x3FFFFFF7FFFFFFFLL) - v6;
  uint64_t v31 = v9;
  if (a3)
  {
    char v10 = v9;
    uint64_t v11 = (char *)malloc_type_calloc(1uLL, 16 * v7, 0x8448092BuLL);
    *((void *)v10 + 1) = v11;
    if (a1 && a2)
    {
      unint64_t v12 = v11;
      uint64_t v13 = 0;
      int v36 = &v11[8 * v7];
      if ((v7 & 0xFFFFFFFE) != 0) {
        uint64_t v14 = v7;
      }
      else {
        uint64_t v14 = 1;
      }
      uint64_t v32 = v14;
      do
      {
        uint64_t v15 = *(void **)(a1 + 8 * v13);
        unint64_t v16 = [v15 hash];
        unint64_t v17 = v7;
        if (v5 * 8)
        {
          unint64_t v18 = v16 % v7;
          uint64_t v19 = v32;
          unint64_t v17 = v7;
          while (1)
          {
            uint64_t v20 = *(void **)&v12[8 * v18];
            if (!v20) {
              break;
            }
            if (v20 == &___NSDictionaryM_DeletedMarker)
            {
              if (v17 == v7) {
                unint64_t v17 = v18;
              }
            }
            else if (v20 == v15 || ([v20 isEqual:v15] & 1) != 0)
            {
              unint64_t v17 = v18;
              goto LABEL_29;
            }
            if (v18 + 1 >= v7) {
              uint64_t v21 = v7;
            }
            else {
              uint64_t v21 = 0;
            }
            unint64_t v18 = v18 + 1 - v21;
            if (!--v19) {
              goto LABEL_29;
            }
          }
          if (v17 == v7) {
            unint64_t v17 = v18;
          }
        }
LABEL_29:
        if (*(void *)&v12[8 * v17])
        {
          uint64_t v22 = *(void *)&v36[8 * v17];
          if (v22 >= 1) {
        }
          }
        else
        {
          uint64_t v23 = *(void *)(a1 + 8 * v13);
          if (v34)
          {
            uint64_t v25 = [*(id *)(a1 + 8 * v13) copyWithZone:0];
            *(void *)&v12[8 * v17] = v25;
            if (!v25)
            {
              CFStringRef v29 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSDictionary: -copyWithZone: for key %@ returned nil", v23);
              uint64_t v30 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v29) userInfo:0];
              objc_exception_throw(v30);
            }
          }
          else
          {
            *(void *)&v12[8 * v17] = v23;
            if (v23 >= 1) {
              id v24 = (id)v23;
            }
          }
          *((void *)v31 + 2) = *((void *)v31 + 2) & 0xFE000000FFFFFFFFLL | ((((unint64_t)(*((void *)v31 + 2) + 0x100000000) >> 32) & 0x1FFFFFF) << 32);
        }
        uint64_t v26 = *(void *)(a2 + 8 * v13);
        *(void *)&v36[8 * v17] = v26;
        if ((v34 & 4) == 0 && v26 >= 1) {
          id v27 = (id)v26;
        }
        ++v13;
      }
      while (v13 != a3);
    }
  }
  else
  {
    *((void *)v9 + 1) = 0;
  }
  uint64_t result = v31;
  atomic_store(0, (unint64_t *)v31 + 3);
  return result;
}

id __NSArrayM_new(const void *a1, unint64_t a2, char a3)
{
  unint64_t v6 = (objc_class *)self;
  id v7 = __CFAllocateObject(v6, 0);
  if (v7)
  {
    if (a2)
    {
      if (a2 >> 61)
      {
LABEL_4:

        return 0;
      }
      uint64_t v10 = 8 * a2;
      size_t v11 = malloc_good_size(8 * a2);
      if (HIDWORD(v11)) {
        __NSArrayM_new_cold_1();
      }
      size_t v12 = v11;
      if (a1)
      {
        uint64_t v13 = malloc_type_malloc(v11, 0xB9DF98CuLL);
        if (!v13) {
          goto LABEL_4;
        }
        char v9 = v13;
        memmove(v13, a1, 8 * a2);
        if (a3)
        {
          uint64_t v14 = (char *)&v9[a2];
          size_t v15 = v12 - v10;
        }
        else
        {
          uint64_t v17 = 0;
          do
          {
            unint64_t v18 = v9[v17];
            if ((v18 & 0x8000000000000000) == 0) {
              id v19 = (id)v18;
            }
            ++v17;
          }
          while (a2 != v17);
          uint64_t v14 = (char *)&v9[a2];
          size_t v15 = v12 - v10;
        }
        bzero(v14, v15);
        unsigned int v8 = v12 >> 3;
      }
      else
      {
        unint64_t v16 = malloc_type_calloc(1uLL, v11, 0xBA4241FuLL);
        if (!v16) {
          goto LABEL_4;
        }
        char v9 = v16;
        LODWORD(a2) = 0;
        unsigned int v8 = v12 >> 3;
      }
    }
    else
    {
      unsigned int v8 = 0;
      char v9 = 0;
    }
    *((void *)v7 + 2) = v9;
    *((_DWORD *)v7 + 6) = 0;
    *((_DWORD *)v7 + 7) = v8;
    *((_DWORD *)v7 + 8) = 1;
    *((_DWORD *)v7 + 9) = a2;
  }
  return v7;
}

id __CFAllocateObject(objc_class *a1, size_t a2)
{
  id Instance = class_createInstance(a1, a2);
  if (!Instance) {
    objc_exception_throw(+[NSException exceptionWithName:@"NSMallocException" reason:@"*** NSAllocateObject(): attempt to allocate object failed" userInfo:0]);
  }
  id v3 = Instance;
  if (__CFOASafe)
  {
    object_getClassName(Instance);
    __CFSetLastAllocationEventName();
  }
  return v3;
}

unsigned char *__NSDictionaryI_new(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  unint64_t v6 = a4;
  uint64_t v10 = 0;
  uint64_t v29 = *(void *)off_1ECE0A5B0;
  uint64_t v28 = a3;
  while (__NSDictionaryCapacities[v10] < a4)
  {
    if (++v10 == 64)
    {
      __break(1u);
      break;
    }
  }
  uint64_t v11 = __NSDictionarySizes[v10];
  size_t v12 = (objc_class *)self;
  uint64_t v13 = __CFAllocateObject(v12, 16 * v11);
  uint64_t v14 = v13;
  v13[15] = v13[15] & 3 | (4 * v10);
  *((void *)v13 + 1) = *((void *)v13 + 1) & 0xFE00000000000000 | v6 & 0x1FFFFFFFFFFFFFFLL;
  v13[15] = v13[15] & 0xFD | a5 & 2;
  if (v6)
  {
    v21[0] = off_1ECE0A5A0;
    v21[1] = 3221225472;
    uint64_t v22 = ____NSDictionaryI_new_block_invoke;
    uint64_t v23 = &unk_1ECDABC38;
    uint64_t v26 = v11;
    uint64_t v27 = a5;
    id v24 = v13;
    uint64_t v25 = v13 + 16;
    if (a3)
    {
      uint64_t v15 = *a1;
      unint64_t v16 = v28++;
      ____NSDictionaryI_new_block_invoke(v21, *v16, v15);
      if (v6 >= 2)
      {
        unint64_t v17 = v6 - 1;
        do
        {
          unint64_t v18 = v28++;
          uint64_t v19 = *v18;
          uint64_t v28 = v18 + 2;
          v22(v21, v18[1], v19);
          --v17;
        }
        while (v17);
      }
    }
    else
    {
      do
      {
        v22(v21, *a1++, *a2++);
        --v6;
      }
      while (v6);
    }
  }
  return v14;
}

void sub_182BA48BC(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    if (v2) {

    }
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t CFStringHashISOLatin1CString(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0;
    uint64_t v3 = a2;
    do
    {
      uint64_t v3 = a1[v5 + 3] + 67503105 * v3 + 257 * (257 * ((a1[v5] | (a1[v5] << 8)) + a1[v5 + 1]) + a1[v5 + 2]);
      BOOL v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      uint64_t v3 = *(unsigned __int8 *)(v8 + v7 + 3)
         + 67503105 * v3
         + 257
         * (257
          * ((*(unsigned __int8 *)(v8 + v7) | (*(unsigned __int8 *)(v8 + v7) << 8)) + *(unsigned __int8 *)(v8 + v7 + 1))
          + *(unsigned __int8 *)(v8 + v7 + 2));
      uint64_t v9 = v7 - 16;
      v7 += 4;
    }
    while (v9 < 12);
    uint64_t v10 = &a1[a2 - 32];
    do
    {
      uint64_t v3 = v10[3] + 67503105 * v3 + 257 * (257 * ((*v10 | (*v10 << 8)) + v10[1]) + v10[2]);
      v10 += 4;
    }
    while (v10 < &a1[a2]);
  }
  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      uint64_t v2 = a1;
      uint64_t v4 = a1;
      uint64_t v3 = a2;
    }
    else
    {
      uint64_t v2 = a1;
      uint64_t v3 = a2;
      uint64_t v4 = a1;
      do
      {
        uint64_t v3 = v4[3] + 67503105 * v3 + 257 * (257 * ((*v4 | (*v4 << 8)) + v4[1]) + v4[2]);
        v4 += 4;
        v2 += 4;
      }
      while (v4 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }
    if (v4 < &a1[a2])
    {
      uint64_t v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        unsigned int v12 = *v4++;
        uint64_t v3 = 257 * v3 + v12;
        --v11;
      }
      while (v11);
    }
  }
  return (v3 << (a2 & 0x1F)) + v3;
}

unint64_t *_CFNonObjCRetain(unint64_t *a1)
{
  return _CFRetain(a1, 0);
}

void mdict_rehashd(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x28)
  {
    __break(1u);
  }
  else
  {
    unint64_t v3 = LODWORD(__NSDictionarySizes_0[a2]);
    uint64_t v4 = malloc_type_calloc(1uLL, 16 * v3, 0x6B90FCE3uLL);
    uint64_t v18 = a1;
    unint64_t v5 = *(void **)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16) >> 58;
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = LODWORD(__NSDictionarySizes_0[v6]);
      if (v3 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v3;
      }
      do
      {
        uint64_t v10 = (void *)v5[v7];
        if (v10) {
          BOOL v11 = v10 == &___NSDictionaryM_DeletedMarker;
        }
        else {
          BOOL v11 = 1;
        }
        if (!v11)
        {
          unint64_t v12 = [(id)v5[v7] hash];
          if (!a2) {
            goto LABEL_22;
          }
          unint64_t v13 = v12 % v3;
          uint64_t v14 = v9;
          while (v4[v13])
          {
            unint64_t v15 = v13 + 1;
            if (v15 >= v3) {
              unint64_t v16 = v3;
            }
            else {
              unint64_t v16 = 0;
            }
            unint64_t v13 = v15 - v16;
            if (!--v14) {
              goto LABEL_22;
            }
          }
          if (v13 == 0x7FFFFFFFFFFFFFFFLL) {
LABEL_22:
          }
            __NSMUTABLEDICTIONARY_CONCURRENT_MODIFICATION_DETECTED__();
          v4[v13] = v10;
          v4[v3 + v13] = v5[v8 + v7];
        }
        ++v7;
      }
      while (v7 != v8);
    }
    free(v5);
    unint64_t v17 = *(void *)(v18 + 16) & 0x3FFFFFFFFFFFFFFLL | ((unint64_t)a2 << 58);
    *(void *)(v18 + 8) = v4;
    *(void *)(v18 + 16) = v17;
  }
}

uint64_t _cow_mutate_slow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (((*(uint64_t (**)(void))(a3 + 8))() & 1) == 0) {
    _cow_mutate_slow_cold_1();
  }
  unint64_t v5 = *(uint64_t (**)(uint64_t, void))(a3 + 16);

  return v5(a1, 0);
}

uint64_t cow_copy_storage(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (!v2)
  {
    unint64_t v5 = 0;
LABEL_21:
    uint64_t result = 1;
    goto LABEL_22;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 28);
  uint64_t result = (uint64_t)malloc_type_malloc(8 * v3, 0x80040B8603338uLL);
  unint64_t v5 = (char *)result;
  if (result)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = *(unsigned int *)(a1 + 24);
    unsigned int v8 = v3 - v7;
    if ((int)v3 - (int)v7 >= v6) {
      uint64_t v9 = v6;
    }
    else {
      uint64_t v9 = v8;
    }
    if (v9)
    {
      uint64_t v10 = (id *)(result + 8 * v7);
      memcpy(v10, &v2[8 * v7], 8 * v9);
      uint64_t v11 = v9;
      do
      {
        if (((unint64_t)*v10 & 0x8000000000000000) == 0) {
          id v12 = *v10;
        }
        ++v10;
        --v11;
      }
      while (v11);
    }
    if (v6 > v8)
    {
      memcpy(v5, v2, 8 * (v6 - v9));
      uint64_t v13 = 0;
      if (v6 - v9 <= 1uLL) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = v6 - v9;
      }
      uint64_t v15 = 8 * v14;
      do
      {
        unint64_t v16 = *(void *)&v5[v13];
        if ((v16 & 0x8000000000000000) == 0) {
          id v17 = (id)v16;
        }
        v13 += 8;
      }
      while (v15 != v13);
    }
    goto LABEL_21;
  }
LABEL_22:
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t cow_set_cow(uint64_t result, unint64_t a2)
{
  return result;
}

void sub_182BA67D8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void __NSMUTABLEDICTIONARY_CONCURRENT_MODIFICATION_DETECTED__()
{
  v0 = (objc_class *)objc_opt_class();
  __int16 Name = (unsigned __int16)class_getName(v0);
  CFLog(3, @"*** Collection <%s: %p> was mutated while rehashing.", v2, v3, v4, v5, v6, v7, Name);
  __break(1u);
}

const char *__cdecl NSGetSizeAndAlignment(const char *typePtr, NSUInteger *sizep, NSUInteger *alignp)
{
  return __NSGetSizeAndAlignment(typePtr, (uint64_t *)sizep, (uint64_t *)alignp, (uint64_t)typePtr, 1, 0, 1uLL);
}

uint64_t __CFBinaryPlistCreateObject(const void *a1, int a2, unint64_t a3, uint64_t a4, __objc2_class **a5, uint64_t a6, const __CFDictionary *a7, CFTypeRef *a8)
{
  return __CFBinaryPlistCreateObjectFiltered(a1, a2, a3, a4, a5, a6, 0, a7, 0, 0, 0, a8, 0);
}

uint64_t __CFBinaryPlistCreateObjectFiltered(const void *Value, int a2, unint64_t a3, uint64_t a4, __objc2_class **a5, uint64_t a6, uint64_t a7, const __CFDictionary *a8, CFSetRef theSet, uint64_t a10, CFIndex a11, CFTypeRef *a12, CFTypeID *a13)
{
  v204[1] = *(__CFSet **)off_1ECE0A5B0;
  if ((unint64_t)a10 >= 0x81)
  {
    uint64_t v13 = _CFOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      __CFBinaryPlistCreateObjectFiltered_cold_1(v13);
    }
    return 0;
  }
  uint64_t v20 = (uint64_t)Value;
  uint64_t v196 = a5;
  uint64_t v197 = a13;
  unint64_t v198 = ~a3;
  if (a8)
  {
    if (a12)
    {
      CFStringRef Value = CFDictionaryGetValue(a8, (const void *)v198);
      *a12 = Value;
      if (Value)
      {
        CFRetain(Value);
        if (v197) {
          CFTypeID *v197 = CFGetTypeID(*a12);
        }
        return 1;
      }
    }
  }
  unint64_t v195 = (CFMutableSetRef *)a12;
  if (theSet)
  {
    CFStringRef Value = (const void *)CFSetContainsValue(theSet, (const void *)v198);
    if (Value) {
      return 0;
    }
  }
  CFMutableDictionaryRef v194 = a8;
  uint64_t Typed = 0;
  if (a3 >= 8)
  {
    CFSetRef v193 = theSet;
    unint64_t v23 = *(void *)(a4 + 24) - 1;
    if (v23 >= a3)
    {
      uint64_t Typed = 0;
      unint64_t v24 = v20 + a3;
      unsigned int v25 = *(unsigned __int8 *)(v20 + a3);
      switch(v25 >> 4)
      {
        case 0u:
          if (v25 == 9)
          {
            if (v195) {
              CFMutableSetRef *v195 = (CFMutableSetRef)&__kCFBooleanTrue;
            }
            if (v197) {
              CFTypeID *v197 = 21;
            }
            return 1;
          }
          if (v25 == 8)
          {
            int v49 = (uint64_t *)v197;
            if (v195) {
              CFMutableSetRef *v195 = (CFMutableSetRef)&__kCFBooleanFalse;
            }
            if (!v49) {
              return 1;
            }
            uint64_t v50 = 21;
          }
          else
          {
            int v49 = (uint64_t *)v197;
            if (*(unsigned char *)(v20 + a3)) {
              return 0;
            }
            if (v195) {
              CFMutableSetRef *v195 = (CFMutableSetRef)&__kCFNull;
            }
            if (!v49) {
              return 1;
            }
            uint64_t v50 = 16;
          }
          *int v49 = v50;
          return 1;
        case 1u:
          if (v24 == -1) {
            return 0;
          }
          unsigned int v51 = v25 & 0xF;
          uint64_t v52 = 1 << (v25 & 0xF);
          if (v24 >= ~v52) {
            return 0;
          }
          uint64_t Typed = 0;
          if (v51 > 4) {
            return Typed;
          }
          BOOL v53 = (unsigned int *)(v24 + 1);
          if (v20 + v23 < v24 + v52) {
            return Typed;
          }
          switch((1 << (v25 & 0xF)))
          {
            case 1u:
              unint64_t v54 = *(unsigned __int8 *)v53;
              goto LABEL_124;
            case 2u:
              unint64_t v54 = __rev16(*(unsigned __int16 *)v53);
              goto LABEL_124;
            case 4u:
              unint64_t v54 = bswap32(*v53);
              goto LABEL_124;
            case 8u:
              unint64_t v54 = bswap64(*(void *)v53);
LABEL_124:
              uint64_t v64 = v197;
              break;
            default:
              unint64_t v54 = 0;
              if ((v52 & 0xFE) != 0) {
                uint64_t v66 = (1 << (v25 & 0xF));
              }
              else {
                uint64_t v66 = 1;
              }
              uint64_t v64 = v197;
              do
              {
                unsigned int v67 = *(unsigned __int8 *)v53;
                BOOL v53 = (unsigned int *)((char *)v53 + 1);
                unint64_t v54 = v67 | (v54 << 8);
                --v66;
              }
              while (v66);
              break;
          }
          v204[0] = (__CFSet *)v54;
          if (v64) {
            *uint64_t v64 = 22;
          }
          if (!v195) {
            return 1;
          }
          if (v51 < 4)
          {
            CFNumberRef v65 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberSInt64Type, v204);
          }
          else
          {
            valuePtr[0] = 0;
            valuePtr[1] = (__CFSet *)v54;
            CFNumberRef v65 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberMaxType|kCFNumberSInt8Type, valuePtr);
          }
          CFNumberRef v48 = v65;
          uint64_t Typed = v65 != 0;
          if (v194 && v65) {
            goto LABEL_133;
          }
          goto LABEL_134;
        case 2u:
          if ((v25 & 0xF) == 3)
          {
            if (v24 == -1) {
              return 0;
            }
            uint64_t Typed = 0;
            if (v24 <= 0xFFFFFFFFFFFFFFF6 && v20 + v23 >= v24 + 8)
            {
              valuePtr[0] = (__CFSet *)bswap64(*(void *)(v24 + 1));
              if (v197) {
                CFTypeID *v197 = 22;
              }
              if (!v195) {
                return 1;
              }
              CFNumberRef v48 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberFloat64Type, valuePtr);
              uint64_t Typed = v48 != 0;
              if (v48) {
                BOOL v60 = v194 != 0;
              }
              else {
                BOOL v60 = 0;
              }
              if (v60) {
LABEL_133:
              }
                CFDictionarySetValue(v194, (const void *)v198, v48);
LABEL_134:
              CFMutableSetRef *v195 = v48;
              return Typed;
            }
          }
          else
          {
            if ((v25 & 0xF) != 2 || v24 == -1) {
              return 0;
            }
            uint64_t Typed = 0;
            if (v24 <= 0xFFFFFFFFFFFFFFFALL && v20 + v23 >= v24 + 4)
            {
              LODWORD(valuePtr[0]) = bswap32(*(_DWORD *)(v24 + 1));
              if (v197) {
                CFTypeID *v197 = 22;
              }
              if (!v195) {
                return 1;
              }
              CFNumberRef v48 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberFloat32Type, valuePtr);
              uint64_t Typed = v48 != 0;
              if (v48) {
                BOOL v55 = v194 != 0;
              }
              else {
                BOOL v55 = 0;
              }
              if (v55) {
                goto LABEL_133;
              }
              goto LABEL_134;
            }
          }
          return Typed;
        case 3u:
          uint64_t Typed = 0;
          if (v24 == -1) {
            return Typed;
          }
          if (v25 != 51) {
            return Typed;
          }
          uint64_t Typed = 0;
          if (v24 > 0xFFFFFFFFFFFFFFF6 || v20 + v23 < v24 + 8) {
            return Typed;
          }
          unint64_t v46 = *(void *)(v24 + 1);
          if (v197) {
            CFTypeID *v197 = 42;
          }
          if (!v195) {
            return 1;
          }
          CFDateRef v47 = CFDateCreate((CFAllocatorRef)v196, COERCE_CFABSOLUTETIME(bswap64(v46)));
          CFNumberRef v48 = v47;
          uint64_t Typed = v47 != 0;
          if (v194 && v47) {
LABEL_120:
          }
            CFDictionarySetValue(v194, (const void *)v198, v48);
          goto LABEL_134;
        case 4u:
          if (v24 == -1) {
            return 0;
          }
          unint64_t v39 = (const UInt8 *)(v24 + 1);
          CFIndex v40 = v25 & 0xF;
          if ((v25 & 0xF) == 0xF)
          {
            if (v20 + v23 < (unint64_t)v39) {
              return 0;
            }
            int v41 = (unsigned __int8 *)(v24 + 2);
            UInt8 v42 = *v39;
            if ((*v39 & 0xF0) != 0x10) {
              return 0;
            }
            uint64_t Typed = 0;
            unsigned int v43 = v42 & 0xF;
            uint64_t v44 = 1 << (v42 & 0xF);
            if (!__CFADD__(v44, v41) && (unint64_t)&v39[v44] <= v20 + v23)
            {
              switch((char)v44)
              {
                case 1:
                  CFIndex v40 = *v41;
                  goto LABEL_408;
                case 2:
                  CFIndex v40 = __rev16(*(unsigned __int16 *)(v24 + 2));
                  goto LABEL_408;
                case 4:
                  CFIndex v40 = bswap32(*(_DWORD *)(v24 + 2));
                  goto LABEL_408;
                case 8:
                  CFIndex v40 = bswap64(*(void *)(v24 + 2));
                  goto LABEL_407;
                default:
                  if (v43 <= 7)
                  {
                    CFIndex v40 = 0;
                    if ((v44 & 0xFE) != 0) {
                      uint64_t v172 = v44;
                    }
                    else {
                      uint64_t v172 = 1;
                    }
                    uint64_t v173 = (unsigned __int8 *)(v24 + 2);
                    do
                    {
                      unsigned int v174 = *v173++;
                      CFIndex v40 = v174 | (unint64_t)(v40 << 8);
                      --v172;
                    }
                    while (v172);
LABEL_407:
                    if (v40 < 0) {
                      return 0;
                    }
                  }
                  else
                  {
                    CFIndex v40 = 0;
                  }
LABEL_408:
                  unint64_t v39 = &v41[v44];
                  goto LABEL_409;
              }
            }
          }
          else
          {
LABEL_409:
            uint64_t Typed = 0;
            if (!__CFADD__(v40, v39) && v20 + v23 >= (unint64_t)&v39[v40 - 1])
            {
              if (v197) {
                CFTypeID *v197 = 20;
              }
              if (!v195) {
                return 1;
              }
              if (a6 == 2)
              {
                Mutable = CFDataCreateMutable((CFAllocatorRef)v196, 0);
                uint64_t v176 = Mutable;
                if (Mutable) {
                  CFDataAppendBytes(Mutable, v39, v40);
                }
                uint64_t Typed = v176 != 0;
              }
              else
              {
                CFDataRef v177 = CFDataCreate((CFAllocatorRef)v196, v39, v40);
                uint64_t v176 = v177;
                uint64_t Typed = v177 != 0;
                if (v194 && v177)
                {
                  CFDictionarySetValue(v194, (const void *)v198, v177);
                  uint64_t Typed = 1;
                }
              }
              CFMutableSetRef *v195 = v176;
            }
          }
          return Typed;
        case 5u:
          v202[0] = off_1ECE0A5A0;
          v202[1] = 3221225472;
          v202[2] = ____CFBinaryPlistCreateObjectFiltered_block_invoke;
          v202[3] = &__block_descriptor_104_e12_B24__0r_8q16l;
          v202[4] = v197;
          v202[5] = v195;
          v202[6] = a6;
          v202[7] = a6;
          v202[8] = v196;
          v202[9] = a7;
          v202[10] = a3;
          v202[11] = v194;
          v202[12] = v198;
          return __CFBinaryPlistParseASCIIString(v20, v23, (unsigned char *)v24, (uint64_t)v202);
        case 6u:
          v201[0] = off_1ECE0A5A0;
          v201[1] = 3221225472;
          v201[2] = ____CFBinaryPlistCreateObjectFiltered_block_invoke_2;
          v201[3] = &__block_descriptor_104_e13_B24__0r_S8q16l;
          v201[4] = v197;
          v201[5] = v195;
          v201[6] = a6;
          v201[7] = a6;
          v201[8] = v196;
          v201[9] = a7;
          v201[10] = a3;
          v201[11] = v194;
          v201[12] = v198;
          return __CFBinaryPlistParseUnicode16String(v20, v23, (unsigned char *)v24, (uint64_t)v201);
        case 8u:
          if (v24 != -1)
          {
            uint64_t v56 = (unsigned int *)(v24 + 1);
            uint64_t v57 = (v25 & 0xF) + 1;
            if (v24 < ~v57 && v20 + v23 >= v24 + v57)
            {
              switch(v25 & 0xF)
              {
                case 0u:
                  LODWORD(v59) = *(unsigned __int8 *)v56;
                  goto LABEL_110;
                case 1u:
                  LODWORD(v59) = __rev16(*(unsigned __int16 *)v56);
                  goto LABEL_110;
                case 3u:
                  LODWORD(v59) = bswap32(*v56);
LABEL_110:
                  uint64_t v61 = v197;
                  goto LABEL_115;
                case 7u:
                  unint64_t v59 = bswap64(*(void *)v56);
                  uint64_t v61 = v197;
                  goto LABEL_114;
                default:
                  unint64_t v59 = 0;
                  uint64_t v61 = v197;
                  do
                  {
                    unsigned int v62 = *(unsigned __int8 *)v56;
                    uint64_t v56 = (unsigned int *)((char *)v56 + 1);
                    unint64_t v59 = v62 | (v59 << 8);
                    --v57;
                  }
                  while (v57);
LABEL_114:
                  if (HIDWORD(v59)) {
                    return 0;
                  }
LABEL_115:
                  if (v61) {
                    *uint64_t v61 = 41;
                  }
                  if (!v195) {
                    return 1;
                  }
                  uint64_t Instance = _CFRuntimeCreateInstance(v196, 0x29uLL, 8, 0);
                  CFNumberRef v48 = (CFNumberRef)Instance;
                  uint64_t Typed = Instance != 0;
                  if (Instance)
                  {
                    *(_DWORD *)(Instance + 16) = v59;
                    if (v194) {
                      goto LABEL_120;
                    }
                  }
                  goto LABEL_134;
              }
            }
          }
          return 0;
        case 0xAu:
        case 0xCu:
          CFIndex v191 = a11;
          uint64_t v192 = a6;
          if (v24 == -1) {
            return 0;
          }
          uint64_t v26 = (unsigned __int8 *)(v24 + 1);
          unint64_t v27 = v25 & 0xF;
          if ((v25 & 0xF) == 0xF)
          {
            unint64_t v28 = v20 + v23;
            if (v20 + v23 >= (unint64_t)v26)
            {
              uint64_t v29 = (unsigned __int8 *)(v24 + 2);
              unsigned __int8 v30 = *v26;
              if ((*v26 & 0xF0) == 0x10)
              {
                uint64_t Typed = 0;
                unsigned int v31 = v30 & 0xF;
                uint64_t v32 = 1 << (v30 & 0xF);
                if (__CFADD__(v32, v29) || (unint64_t)&v26[v32] > v28) {
                  return Typed;
                }
                switch((char)v32)
                {
                  case 1:
                    unint64_t v27 = *v29;
                    goto LABEL_164;
                  case 2:
                    unint64_t v27 = __rev16(*(unsigned __int16 *)(v24 + 2));
                    goto LABEL_164;
                  case 4:
                    unint64_t v27 = bswap32(*(_DWORD *)(v24 + 2));
                    goto LABEL_164;
                  case 8:
                    unint64_t v68 = bswap64(*(void *)(v24 + 2));
                    goto LABEL_162;
                  default:
                    if (v31 > 7)
                    {
                      uint64_t v187 = (const void **)&v29[v32];
                      if (v28 < (unint64_t)&v29[v32 - 1]) {
                        return 0;
                      }
                      unint64_t v27 = 0;
                      UniChar v188 = 0;
                      uint64_t v189 = (__CFSet **)(a4 + 7);
                      goto LABEL_175;
                    }
                    unint64_t v68 = 0;
                    if ((v32 & 0xFE) != 0) {
                      uint64_t v69 = v32;
                    }
                    else {
                      uint64_t v69 = 1;
                    }
                    CFRange v70 = (unsigned __int8 *)(v24 + 2);
                    do
                    {
                      unsigned int v71 = *v70++;
                      unint64_t v68 = v71 | (v68 << 8);
                      --v69;
                    }
                    while (v69);
LABEL_162:
                    if ((v68 & 0x8000000000000000) == 0)
                    {
                      unint64_t v27 = v68;
LABEL_164:
                      uint64_t v26 = &v29[v32];
                      goto LABEL_165;
                    }
                    break;
                }
              }
            }
            return 0;
          }
LABEL_165:
          unint64_t v72 = *(unsigned __int8 *)(a4 + 7);
          uint64_t v189 = (__CFSet **)(a4 + 7);
          if (v27)
          {
            if (!is_mul_ok(v27, v72)) {
              return 0;
            }
            unint64_t v73 = v27 * v72;
          }
          else
          {
            unint64_t v73 = 0;
          }
          uint64_t Typed = 0;
          if (__CFADD__(v73, v26)) {
            return Typed;
          }
          uint64_t v187 = (const void **)v26;
          if (v20 + v23 < (unint64_t)&v26[v73 - 1]) {
            return Typed;
          }
          if (v27)
          {
            if (v27 >> 61) {
              return 0;
            }
            UniChar v188 = (unsigned __int8 *)(8 * v27);
          }
          else
          {
            UniChar v188 = 0;
          }
LABEL_175:
          uint64_t v186 = (__CFSet **)v179;
          CFArrayRef v190 = (const __CFArray *)v27;
          MEMORY[0x1F4188790](Value, v23);
          uint64_t Typed = (uint64_t)&v179[-v75];
          if (v74 >= 0x200) {
            size_t v76 = 512;
          }
          else {
            size_t v76 = v74;
          }
          bzero(&v179[-v75], v76);
          uint64_t v182 = (unsigned __int8 *)Typed;
          if (v195)
          {
            if ((unint64_t)v190 >= 0x101)
            {
              uint64_t Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v188, 1181297625, 0);
              if (!Typed) {
                return Typed;
              }
            }
          }
          else
          {
            uint64_t Typed = 0;
          }
          UniChar v188 = (unsigned __int8 *)Typed;
          CFSetRef v77 = 0;
          if (!v193 && a10 >= 16)
          {
            CFSetRef v77 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
            CFSetRef v193 = v77;
          }
          uint64_t v183 = (uint64_t)v77;
          if (v193) {
            CFSetAddValue(v193, (const void *)v198);
          }
          valuePtr[0] = 0;
          v204[0] = 0;
          CFAllocatorRef v181 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
          CFIndex v78 = v191;
          __CFPropertyListCreateSplitKeypaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, (CFSetRef)v191, valuePtr, v204);
          int v180 = v25 & 0xF0;
          if (v78) {
            BOOL v79 = (v25 & 0xF0) == 160;
          }
          else {
            BOOL v79 = 0;
          }
          int v80 = !v79;
          if (valuePtr[0])
          {
            int v81 = CFSetContainsValue(valuePtr[0], @"*");
            CFAllocatorRef v82 = (const __CFAllocator *)v196;
            BOOL v83 = v81 != 0;
          }
          else
          {
            BOOL v83 = 0;
            CFAllocatorRef v82 = (const __CFAllocator *)v196;
          }
          if ((v80 | v83) == 1)
          {
            unint64_t v84 = (unint64_t)v187;
            if (v190)
            {
              uint64_t v85 = 0;
              CFIndex v191 = v20 + 8;
              CFRange v86 = &v200;
              if (!v195) {
                CFRange v86 = 0;
              }
              unint64_t v184 = (unint64_t)v86;
              uint64_t v185 = a10 + 1;
              uint64_t v87 = -1;
              while (v191 <= v84)
              {
                UniChar v88 = (unsigned int *)v84;
                uint64_t v89 = v20 + *(void *)(a4 + 24);
                uint64_t v90 = *(unsigned __int8 *)(a4 + 7);
                if (v89 - v90 < (unint64_t)v88) {
                  break;
                }
                unint64_t v91 = *(unsigned __int8 *)(a4 + 7);
                switch(*(unsigned char *)(a4 + 7))
                {
                  case 0:
                    break;
                  case 1:
                    unint64_t v91 = *(unsigned __int8 *)v88;
                    break;
                  case 2:
                    unint64_t v91 = __rev16(*(unsigned __int16 *)v88);
                    break;
                  case 4:
                    unint64_t v91 = bswap32(*v88);
                    break;
                  case 8:
                    unint64_t v91 = bswap64(*(void *)v88);
                    break;
                  default:
                    unint64_t v91 = 0;
                    uint64_t v92 = v88;
                    do
                    {
                      unsigned int v93 = *(unsigned __int8 *)v92;
                      uint64_t v92 = (unsigned int *)((char *)v92 + 1);
                      unint64_t v91 = v93 | (v91 << 8);
                      --v90;
                    }
                    while (v90);
                    break;
                }
                if (*(void *)(a4 + 8) <= v91) {
                  break;
                }
                uint64_t v94 = *(unsigned __int8 *)(a4 + 6);
                BOOL v95 = (unsigned int *)(v89 + v91 * v94);
                switch(*(unsigned char *)(a4 + 6))
                {
                  case 0:
                    break;
                  case 1:
                    LODWORD(v94) = *(unsigned __int8 *)v95;
                    break;
                  case 2:
                    LODWORD(v94) = __rev16(*(unsigned __int16 *)v95);
                    break;
                  case 4:
                    LODWORD(v94) = bswap32(*v95);
                    break;
                  case 8:
                    LODWORD(v94) = bswap64(*(void *)v95);
                    break;
                  default:
                    uint64_t v96 = *(unsigned __int8 *)(a4 + 6);
                    LODWORD(v94) = 0;
                    do
                    {
                      int v97 = *(unsigned __int8 *)v95;
                      BOOL v95 = (unsigned int *)((char *)v95 + 1);
                      LODWORD(v94) = v97 | (v94 << 8);
                      --v96;
                    }
                    while (v96);
                    break;
                }
                unint64_t v200 = 0;
                CFLocaleRef v98 = v204[0];
                if (v80) {
                  CFLocaleRef v98 = 0;
                }
                if ((__CFBinaryPlistCreateObjectFiltered(v20, a2, v94, a4, (int)v196, a6, a7, (int)v194, v193, v185, (uint64_t)v98, v184, 0) & 1) == 0)
                {
                  int64_t v123 = v188;
                  if (v188)
                  {
                    while (v87 != -1)
                    {
                      int v124 = *(const void **)&v123[8 * v87--];
                      CFRelease(v124);
                    }
                    if (v123 != v182) {
                      CFAllocatorDeallocate(v181, v188);
                    }
                  }
                  goto LABEL_285;
                }
                if (v188) {
                  *(void *)&v188[8 * v85] = v200;
                }
                unint64_t v84 = (unint64_t)v88 + *(unsigned __int8 *)v189;
                ++v85;
                ++v87;
                if (v85 >= (uint64_t)v190) {
                  goto LABEL_227;
                }
              }
              uint64_t v115 = v188;
              if (v188)
              {
                uint64_t v116 = v182;
                while (v87 != -1)
                {
                  uint64_t v117 = (const void *)v115[v87--];
                  CFRelease(v117);
                }
                if (v115 != v116) {
                  CFAllocatorDeallocate(v181, v115);
                }
              }
LABEL_285:
              uint64_t Typed = 0;
              goto LABEL_306;
            }
LABEL_227:
            if (v180 != 160)
            {
              if (!v195)
              {
LABEL_277:
                int v105 = 1;
                uint64_t v102 = 17;
LABEL_279:
                uint64_t v104 = (uint64_t *)v197;
                goto LABEL_290;
              }
              if (v192)
              {
                CFMutableSetRef v99 = CFSetCreateMutable((CFAllocatorRef)v196, 0, &kCFTypeSetCallBacks);
                CFMutableSetRef *v195 = v99;
                if (v190)
                {
                  uint64_t v100 = (const void **)v188;
                  CFArrayRef v101 = v190;
                  do
                  {
                    CFSetAddValue(*v195, *v100++);
                    CFArrayRef v101 = (const __CFArray *)((char *)v101 - 1);
                  }
                  while (v101);
                  if (v190)
                  {
                    uint64_t v102 = 17;
                    BOOL v103 = (CFTypeRef *)v188;
                    uint64_t v104 = (uint64_t *)v197;
                    int v105 = 1;
                    do
                    {
                      CFRelease(*v103++);
                      CFArrayRef v190 = (const __CFArray *)((char *)v190 - 1);
                    }
                    while (v190);
                    goto LABEL_290;
                  }
                }
                goto LABEL_277;
              }
              CFArrayRef Transfer = (const __CFArray *)__CFSetCreateTransfer(v196, (unint64_t *)v188, (uint64_t)v190);
              uint64_t v102 = 17;
LABEL_288:
              uint64_t v104 = (uint64_t *)v197;
LABEL_289:
              CFMutableSetRef *v195 = Transfer;
              int v105 = 1;
              goto LABEL_290;
            }
            if (v195)
            {
              if (!v192)
              {
                CFArrayRef Transfer = (const __CFArray *)__CFArrayCreateTransfer(v196, v188, (unint64_t)v190);
                uint64_t v102 = 19;
                goto LABEL_288;
              }
              uint64_t v118 = CFArrayCreateMutable((CFAllocatorRef)v196, 0, &kCFTypeArrayCallBacks);
              CFMutableSetRef *v195 = v118;
              v205.CFIndex location = 0;
              v205.CFIndex length = 0;
              CFArrayReplaceValues(v118, v205, (const void **)v188, (CFIndex)v190);
              if (v190)
              {
                uint64_t v102 = 19;
                uint64_t v119 = (CFTypeRef *)v188;
                do
                {
                  CFRelease(*v119++);
                  CFArrayRef v190 = (const __CFArray *)((char *)v190 - 1);
                }
                while (v190);
                int v105 = 1;
                goto LABEL_279;
              }
            }
            int v105 = 1;
            uint64_t v102 = 19;
            goto LABEL_279;
          }
          CFIndex Count = CFSetGetCount(valuePtr[0]);
          uint64_t v104 = (uint64_t *)v197;
          CFArrayRef v190 = CFArrayCreateMutable(v82, Count, &kCFTypeArrayCallBacks);
          if (!valuePtr[0])
          {
            int v105 = 1;
            goto LABEL_269;
          }
          CFIndex v107 = CFSetGetCount(valuePtr[0]);
          uint64_t v108 = (const void **)malloc_type_malloc(8 * v107, 0xC0040B8AA526DuLL);
          CFSetGetValues(valuePtr[0], v108);
          uint64_t v185 = (uint64_t)v108;
          CFIndex v191 = CFSetGetCount(valuePtr[0]);
          uint64_t v104 = (uint64_t *)v197;
          if (v191 < 1)
          {
            int v105 = 1;
            goto LABEL_268;
          }
          uint64_t v189 = (__CFSet **)(a10 + 1);
          uint64_t v109 = &v199;
          if (!v195) {
            uint64_t v109 = 0;
          }
          uint64_t v187 = v109;
          BOOL v110 = (CFStringRef *)v185;
          while (1)
          {
            CFStringRef v111 = *v110;
            IntCFStringRef Value = CFStringGetIntValue(*v110);
            unsigned int v114 = IntValue;
            if (IntValue != 0x7FFFFFFF)
            {
              if (IntValue)
              {
                if (IntValue < 0) {
                  goto LABEL_251;
                }
              }
              else if (CFStringCompare(@"0", v111, 0))
              {
                goto LABEL_251;
              }
              unint64_t v200 = 0;
              if (__CFBinaryPlistGetOffsetForValueFromArray2(v20, v113, a3, a4, v114, &v200))
              {
                UniChar v199 = 0;
                if (!__CFBinaryPlistCreateObjectFiltered(v20, a2, v200, a4, (int)v196, a6, a7, (int)v194, v193, (uint64_t)v189, (uint64_t)v204[0], (uint64_t)v187, 0))
                {
                  int v105 = 0;
LABEL_253:
                  uint64_t v104 = (uint64_t *)v197;
LABEL_268:
                  free((void *)v185);
LABEL_269:
                  if (v195 && v105)
                  {
                    if ((unint64_t)(v192 - 1) < 2)
                    {
                      uint64_t v102 = 19;
                      CFArrayRef Transfer = v190;
                      goto LABEL_289;
                    }
                    CFArrayRef v121 = v190;
                    CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)v196, v190);
                    CFMutableSetRef *v195 = Copy;
                    CFRelease(v121);
                    int v105 = 1;
                  }
                  else if (v190)
                  {
                    CFRelease(v190);
                  }
                  uint64_t v102 = 19;
LABEL_290:
                  if (v104) {
                    uint64_t *v104 = v102;
                  }
                  if (v193) {
                    CFSetRemoveValue(v193, (const void *)v198);
                  }
                  uint64_t Typed = v105 != 0;
                  if (v195 && v194 && !v192 && v105) {
                    CFDictionarySetValue(v194, (const void *)v198, *v195);
                  }
                  if (v188 && v188 != v182) {
                    CFAllocatorDeallocate(v181, v188);
                  }
                  if (valuePtr[0]) {
                    CFRelease(valuePtr[0]);
                  }
                  if (v204[0]) {
                    CFRelease(v204[0]);
                  }
LABEL_306:
                  if (v183) {
                    CFRelease((CFTypeRef)v183);
                  }
                  return Typed;
                }
                if (v199)
                {
                  CFArrayAppendValue(v190, v199);
                  CFRelease(v199);
                }
              }
            }
LABEL_251:
            ++v110;
            if (!--v191)
            {
              int v105 = 1;
              goto LABEL_253;
            }
          }
        case 0xDu:
          CFIndex v191 = a11;
          uint64_t v192 = a6;
          if (v24 == -1) {
            return 0;
          }
          CFArrayRef v33 = (const __CFArray *)(v24 + 1);
          unint64_t v34 = v25 & 0xF;
          if ((v25 & 0xF) != 0xF) {
            goto LABEL_317;
          }
          if (v20 + v23 < (unint64_t)v33) {
            return 0;
          }
          int v35 = (unsigned __int8 *)(v24 + 2);
          char v36 = *(unsigned char *)v33;
          if ((*(unsigned char *)v33 & 0xF0) != 0x10) {
            return 0;
          }
          uint64_t Typed = 0;
          unsigned int v37 = v36 & 0xF;
          uint64_t v38 = 1 << (v36 & 0xF);
          if (__CFADD__(v38, v35) || (unint64_t)v33 + v38 > v20 + v23) {
            return Typed;
          }
          switch((char)v38)
          {
            case 1:
              unint64_t v34 = *v35;
              goto LABEL_316;
            case 2:
              unint64_t v34 = __rev16(*(unsigned __int16 *)(v24 + 2));
              goto LABEL_316;
            case 4:
              unint64_t v34 = bswap32(*(_DWORD *)(v24 + 2));
              goto LABEL_316;
            case 8:
              unint64_t v34 = bswap64(*(void *)(v24 + 2));
              goto LABEL_315;
            default:
              if (v37 >= 8)
              {
                CFArrayRef v33 = (const __CFArray *)&v35[v38];
                goto LABEL_320;
              }
              unint64_t v34 = 0;
              if ((v38 & 0xFE) != 0) {
                uint64_t v125 = v38;
              }
              else {
                uint64_t v125 = 1;
              }
              int v126 = (unsigned __int8 *)(v24 + 2);
              do
              {
                unsigned int v127 = *v126++;
                unint64_t v34 = v127 | (v34 << 8);
                --v125;
              }
              while (v125);
LABEL_315:
              if ((v34 & 0x8000000000000000) != 0) {
                return 0;
              }
LABEL_316:
              CFArrayRef v33 = (const __CFArray *)&v35[v38];
              break;
          }
LABEL_317:
          if (v34)
          {
            unint64_t v128 = 2 * v34;
            CFLocaleRef v130 = (unsigned __int8 *)(a4 + 7);
            unint64_t v129 = *(unsigned __int8 *)(a4 + 7);
            if (!is_mul_ok(2 * v34, v129)) {
              return 0;
            }
            CFArrayRef v190 = v33;
            char v131 = 0;
            unint64_t v132 = v128 * v129;
          }
          else
          {
LABEL_320:
            CFArrayRef v190 = v33;
            unint64_t v132 = 0;
            unint64_t v128 = 0;
            CFLocaleRef v130 = (unsigned __int8 *)(a4 + 7);
            char v131 = 1;
          }
          uint64_t Typed = 0;
          if (__CFADD__(v132, v190) || v20 + v23 < (unint64_t)v190 + v132 - 1) {
            return Typed;
          }
          if (v131)
          {
            UniChar v188 = v130;
            uint64_t v185 = 0;
          }
          else
          {
            if (v128 >> 61) {
              return 0;
            }
            UniChar v188 = v130;
            uint64_t v185 = 8 * v128;
          }
          uint64_t v187 = (const void **)v179;
          MEMORY[0x1F4188790](Value, v23);
          uint64_t v136 = v135;
          uint64_t v137 = (__CFSet **)&v179[-v134];
          if (v133 >= 0x200) {
            size_t v138 = 512;
          }
          else {
            size_t v138 = v133;
          }
          bzero(&v179[-v134], v138);
          uint64_t v186 = v137;
          uint64_t v183 = v136;
          if (v195)
          {
            uint64_t v189 = v137;
            unint64_t v139 = v196;
            if (v136 >= 257)
            {
              uint64_t v189 = (__CFSet **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v185, 303780961, 0);
              if (!v189) {
                return 0;
              }
            }
          }
          else
          {
            uint64_t v189 = 0;
            unint64_t v139 = v196;
          }
          CFSetRef v140 = 0;
          if (v193)
          {
            CFSetRef v141 = (const __CFSet *)v191;
          }
          else
          {
            CFSetRef v141 = (const __CFSet *)v191;
            if (a10 >= 16)
            {
              CFSetRef v140 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
              CFSetRef v193 = v140;
            }
          }
          CFIndex v191 = (CFIndex)v140;
          if (v193) {
            CFSetAddValue(v193, (const void *)v198);
          }
          if (v141)
          {
            CFAllocatorRef v142 = (const __CFAllocator *)v139;
            uint64_t v143 = v192;
            CFDictionaryRef FilteredDictionary = __CFPropertyListCreateFilteredDictionary(v142, v141, v20, a2, a3, a4, v195 == 0, v192, a7, SHIDWORD(a7), (int)v194, v193, a10);
            CFDictionaryRef v145 = FilteredDictionary;
            if (v195 && FilteredDictionary)
            {
              if ((unint64_t)(v143 - 1) < 2)
              {
                CFMutableSetRef *v195 = FilteredDictionary;
LABEL_390:
                uint64_t Typed = 1;
                goto LABEL_391;
              }
              CFDictionaryRef v166 = CFDictionaryCreateCopy((CFAllocatorRef)v196, FilteredDictionary);
              CFMutableSetRef *v195 = v166;
            }
            else if (!FilteredDictionary)
            {
              uint64_t Typed = 0;
LABEL_391:
              int64_t v167 = v193;
              goto LABEL_430;
            }
            CFRelease(v145);
            goto LABEL_390;
          }
          uint64_t v185 = v183 >> 1;
          uint64_t v146 = v183;
          CFArrayRef v147 = v190;
          if (v183 >= 1)
          {
            uint64_t v148 = 0;
            unint64_t v184 = v20 + 8;
            CFAllocatorRef v149 = (const __CFAllocator *)valuePtr;
            if (!v195) {
              CFAllocatorRef v149 = 0;
            }
            CFAllocatorRef v181 = v149;
            uint64_t v182 = (unsigned __int8 *)(a10 + 1);
            uint64_t v150 = -1;
            while (v184 <= (unint64_t)v147)
            {
              uint64_t v151 = (unsigned int *)v147;
              uint64_t v152 = v20 + *(void *)(a4 + 24);
              uint64_t v153 = *(unsigned __int8 *)(a4 + 7);
              if (v152 - v153 < (unint64_t)v151) {
                break;
              }
              unint64_t v154 = *(unsigned __int8 *)(a4 + 7);
              switch(*(unsigned char *)(a4 + 7))
              {
                case 0:
                  break;
                case 1:
                  unint64_t v154 = *(unsigned __int8 *)v151;
                  break;
                case 2:
                  unint64_t v154 = __rev16(*(unsigned __int16 *)v151);
                  break;
                case 4:
                  unint64_t v154 = bswap32(*v151);
                  break;
                case 8:
                  unint64_t v154 = bswap64(*(void *)v151);
                  break;
                default:
                  unint64_t v154 = 0;
                  int64_t v155 = v151;
                  do
                  {
                    unsigned int v156 = *(unsigned __int8 *)v155;
                    int64_t v155 = (unsigned int *)((char *)v155 + 1);
                    unint64_t v154 = v156 | (v154 << 8);
                    --v153;
                  }
                  while (v153);
                  break;
              }
              if (*(void *)(a4 + 8) <= v154) {
                break;
              }
              uint64_t v157 = *(unsigned __int8 *)(a4 + 6);
              UTF32Char v158 = (unsigned int *)(v152 + v154 * v157);
              switch(*(unsigned char *)(a4 + 6))
              {
                case 0:
                  break;
                case 1:
                  LODWORD(v157) = *(unsigned __int8 *)v158;
                  break;
                case 2:
                  LODWORD(v157) = __rev16(*(unsigned __int16 *)v158);
                  break;
                case 4:
                  LODWORD(v157) = bswap32(*v158);
                  break;
                case 8:
                  LODWORD(v157) = bswap64(*(void *)v158);
                  break;
                default:
                  uint64_t v159 = *(unsigned __int8 *)(a4 + 6);
                  LODWORD(v157) = 0;
                  do
                  {
                    int v160 = *(unsigned __int8 *)v158;
                    UTF32Char v158 = (unsigned int *)((char *)v158 + 1);
                    LODWORD(v157) = v160 | (v157 << 8);
                    --v159;
                  }
                  while (v159);
                  break;
              }
              valuePtr[0] = 0;
              v204[0] = 0;
              if (!__CFBinaryPlistCreateObjectFiltered(v20, a2, v157, a4, (int)v196, a6, a7, (int)v194, v193, (uint64_t)v182, 0, (uint64_t)v181, (uint64_t)v204)|| v148 < v185 && v204[0] != (__CFSet *)7)
              {
                uint64_t v170 = v189;
                if (valuePtr[0]) {
                  CFRelease(valuePtr[0]);
                }
                if (v170)
                {
                  while (v150 != -1)
                  {
                    uint64_t v171 = v170[v150--];
                    CFRelease(v171);
                  }
                  if (v170 != v186) {
                    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v170);
                  }
                }
LABEL_424:
                uint64_t Typed = 0;
                goto LABEL_442;
              }
              if (v189) {
                v189[v148] = valuePtr[0];
              }
              CFArrayRef v147 = (const __CFArray *)((char *)v151 + *v188);
              ++v148;
              ++v150;
              if (v148 == v146) {
                goto LABEL_375;
              }
            }
            uint64_t v168 = v189;
            if (v189)
            {
              while (v150 != -1)
              {
                uint64_t v169 = v168[v150--];
                CFRelease(v169);
              }
              if (v168 != v186) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v189);
              }
            }
            goto LABEL_424;
          }
LABEL_375:
          if (v195)
          {
            if (v192)
            {
              uint64_t v161 = CFDictionaryCreateMutable((CFAllocatorRef)v196, v185, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (v146 >= 1)
              {
                uint64_t v162 = v185;
                if (v185 <= 1) {
                  uint64_t v163 = 1;
                }
                else {
                  uint64_t v163 = v185;
                }
                int64_t v164 = (const void **)v189;
                do
                {
                  CFDictionaryAddValue(v161, *v164, v164[v162]);
                  ++v164;
                  --v163;
                }
                while (v163);
                uint64_t v165 = (CFTypeRef *)v189;
                do
                {
                  CFRelease(*v165++);
                  --v146;
                }
                while (v146);
              }
            }
            else
            {
              uint64_t v161 = (__CFDictionary *)__CFDictionaryCreateTransfer(v196, (uint64_t *)v189, (uint64_t *)&v189[v185], v185);
            }
            CFMutableSetRef *v195 = v161;
          }
          int64_t v167 = v193;
          if (v197) {
            CFTypeID *v197 = 18;
          }
          uint64_t Typed = 1;
LABEL_430:
          if (v167) {
            CFSetRemoveValue(v167, (const void *)v198);
          }
          if (v192) {
            int v178 = 0;
          }
          else {
            int v178 = Typed;
          }
          if (v195 && v194 && v178) {
            CFDictionarySetValue(v194, (const void *)v198, *v195);
          }
          if (v189 && v189 != v186) {
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v189);
          }
LABEL_442:
          if (v191) {
            CFRelease((CFTypeRef)v191);
          }
          break;
        default:
          return Typed;
      }
    }
  }
  return Typed;
}

void sub_182BA8338(_Unwind_Exception *exception_object)
{
  if (*(void *)(v1 + 88)) {
    CFRelease(*(CFTypeRef *)(v1 + 88));
  }
  _Unwind_Resume(exception_object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  uint64_t v5 = (__objc2_class **)allocator;
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      uint64_t v5 = (__objc2_class **)v6;
    }
    else {
      uint64_t v5 = &__kCFAllocatorSystemDefault;
    }
  }
  if ((__CFNumberTaggedPointersDisabled & 1) == 0
    && (&__kCFAllocatorSystemDefault == v5
     || !v5 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
    && __CFNumberCaching != 2)
  {
    switch(__CFNumberTypeTable[theType] & 0x1F)
    {
      case 1:
        uint64_t v7 = *(void *)off_1ECE0A6F0;
        unint64_t v8 = ((uint64_t)*(char *)valuePtr << 7) | 0x8000000000000003;
        goto LABEL_15;
      case 2:
        uint64_t v9 = *(__int16 *)valuePtr;
        uint64_t v7 = *(void *)off_1ECE0A6F0;
        unint64_t v10 = 0x800000000000000BLL;
        goto LABEL_14;
      case 3:
        uint64_t v9 = *(int *)valuePtr;
        uint64_t v7 = *(void *)off_1ECE0A6F0;
        unint64_t v10 = 0x8000000000000013;
LABEL_14:
        unint64_t v8 = v10 | (v9 << 7);
LABEL_15:
        unint64_t v11 = v8 ^ v7;
        goto LABEL_103;
      case 4:
        if ((unint64_t)(*(void *)valuePtr - 0x80000000000000) < 0xFF00000000000001) {
          goto LABEL_36;
        }
        uint64_t v12 = *(void *)off_1ECE0A6F0;
        unint64_t v8 = (*(void *)valuePtr << 7) | 0x800000000000001BLL;
        goto LABEL_102;
      case 5:
        uint64_t v13 = (uint64_t)*(float *)valuePtr;
        if (*(float *)valuePtr != (float)v13) {
          goto LABEL_36;
        }
        BOOL v14 = *(int *)valuePtr < 0 && v13 == 0;
        if (v14 || (unint64_t)(v13 - 0x80000000000000) < 0xFF00000000000001) {
          goto LABEL_36;
        }
        uint64_t v12 = *(void *)off_1ECE0A6F0;
        unint64_t v8 = (v13 << 7) | 0x8000000000000023;
        goto LABEL_102;
      case 6:
        double v16 = *(double *)valuePtr;
        if (*(double *)valuePtr != (double)(uint64_t)*(double *)valuePtr) {
          goto LABEL_36;
        }
        uint64_t v17 = (uint64_t)v16;
        BOOL v18 = v16 < 0.0 && v17 == 0;
        if (v18 || (unint64_t)(v17 - 0x80000000000000) < 0xFF00000000000001) {
          goto LABEL_36;
        }
        uint64_t v12 = *(void *)off_1ECE0A6F0;
        unint64_t v8 = (v17 << 7) | 0x800000000000002BLL;
LABEL_102:
        unint64_t v11 = v12 ^ v8;
LABEL_103:
        if ((~v11 & 0xC000000000000007) != 0) {
          unint64_t v8 = v11 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)off_1ECE0A6E0 + (v11 & 7));
        }
        break;
      default:
        goto LABEL_36;
    }
    return (CFNumberRef)v8;
  }
LABEL_36:
  unsigned int v20 = (unsigned __int16)__CFNumberTypeTable[theType];
  if ((v20 & 0x20) == 0)
  {
    if (&__kCFAllocatorSystemDefault == v5)
    {
      BOOL v21 = 1;
      goto LABEL_48;
    }
    if (!v5)
    {
      BOOL v21 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
LABEL_48:
      uint64_t v25 = -2;
      if (v21 && !__CFNumberCaching)
      {
        switch(v20 & 0x1F)
        {
          case 1u:
            uint64_t v25 = *(char *)valuePtr;
            unsigned int v26 = (v25 + 1);
            goto LABEL_63;
          case 2u:
            uint64_t v25 = *(__int16 *)valuePtr;
            unsigned int v26 = (unsigned __int16)(v25 + 1);
            goto LABEL_63;
          case 3u:
            uint64_t v25 = *(int *)valuePtr;
            unsigned int v26 = v25 + 1;
LABEL_63:
            if (v26 <= 0xD) {
              goto LABEL_64;
            }
            goto LABEL_69;
          case 4u:
            uint64_t v25 = *(void *)valuePtr;
            if ((unint64_t)(*(void *)valuePtr + 1) > 0xD) {
              goto LABEL_69;
            }
LABEL_64:
            unint64_t v23 = (__objc2_class **)__CFNumberCache[v25 + 1];
            if (v23) {
              goto LABEL_65;
            }
            break;
          default:
            break;
        }
      }
LABEL_70:
      if ((v20 & 0x20) != 0) {
        uint64_t v29 = 8;
      }
      else {
        uint64_t v29 = ((v20 >> 3) & 8) + 8;
      }
      if (CFNumberGetTypeID_initOnce != -1) {
        dispatch_once(&CFNumberGetTypeID_initOnce, &__block_literal_global_8);
      }
      uint64_t Instance = _CFRuntimeCreateInstance(v5, 0x16uLL, v29, 0);
      unint64_t v8 = Instance;
      if (Instance)
      {
        uint64_t v31 = __CFNumberCanonicalTypeIndex[v20 & 0x1F] & 7;
        unint64_t v32 = atomic_load((unint64_t *)(Instance + 8));
        unint64_t v33 = v32;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v33, v32 & 0xFFFFFFFFFFFFFFC0 | v31);
          BOOL v14 = v33 == v32;
          unint64_t v32 = v33;
        }
        while (!v14);
        __CFNumberInit(Instance, theType, (char *)valuePtr);
        if (v25 != -2)
        {
          *(void *)(v8 + 16) = v25;
          if ((v8 & 0x8000000000000000) == 0) {
            goto LABEL_91;
          }
          uint64_t v34 = 0;
          uint64_t v35 = *(void *)off_1ECE0A6F0;
          if ((~v8 & 0xC000000000000007) == 0) {
            uint64_t v35 = 0;
          }
          unint64_t v36 = v35 ^ v8;
          unint64_t v37 = v36 & 7;
          while (v37 != *((unsigned __int8 *)off_1ECE0A6E0 + v34))
          {
            if (++v34 == 7) {
              goto LABEL_91;
            }
          }
          if (v34 == 3)
          {
            uint64_t v38 = 0xFFFFFFFFFFFFFFFLL;
            if (v37 == 7) {
              uint64_t v38 = 0xFFFFFFFFFFFFFLL;
            }
            uint64_t v39 = v38 & (v36 >> 3);
          }
          else
          {
LABEL_91:
            LOBYTE(v39) = atomic_load((unint64_t *)(v8 + 8));
          }
          uint64_t v40 = __CFNumberCanonicalTypes[v39 & 7];
          unint64_t v41 = atomic_load((unint64_t *)(v8 + 8));
          unint64_t v42 = v41;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v8 + 8), &v42, v41 & 0xFFFFFFFFFFFFFFC0 | 2);
            BOOL v14 = v42 == v41;
            unint64_t v41 = v42;
          }
          while (!v14);
          uint64_t v43 = 0;
          atomic_compare_exchange_strong(&__CFNumberCache[v25 + 1], (unint64_t *)&v43, v8);
          if (v43)
          {
            uint64_t v44 = __CFNumberCanonicalTypeIndex[v40] & 7;
            unint64_t v45 = atomic_load((unint64_t *)(v8 + 8));
            unint64_t v46 = v45;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v8 + 8), &v46, v45 & 0xFFFFFFFFFFFFFFC0 | v44);
              BOOL v14 = v46 == v45;
              unint64_t v45 = v46;
            }
            while (!v14);
          }
          else
          {
            CFRetain((CFTypeRef)v8);
          }
        }
      }
      return (CFNumberRef)v8;
    }
LABEL_69:
    uint64_t v25 = -2;
    goto LABEL_70;
  }
  if ((v20 & 0x40) != 0)
  {
    double v24 = *(double *)valuePtr;
    if (!*(void *)valuePtr)
    {
      unint64_t v23 = &__kCFNumberFloat64Zero;
      goto LABEL_65;
    }
    if (*(void *)valuePtr == 0x3FF0000000000000)
    {
      unint64_t v23 = &__kCFNumberFloat64One;
      goto LABEL_65;
    }
    if (fabs(v24) != INFINITY) {
      goto LABEL_69;
    }
    BOOL v27 = v24 < 0.0;
LABEL_58:
    if (v27) {
      unint64_t v23 = &__kCFNumberNegativeInfinity;
    }
    else {
      unint64_t v23 = &__kCFNumberPositiveInfinity;
    }
    goto LABEL_65;
  }
  float v22 = *(float *)valuePtr;
  if (!*(_DWORD *)valuePtr)
  {
    unint64_t v23 = &__kCFNumberFloat32Zero;
    goto LABEL_65;
  }
  if (*(_DWORD *)valuePtr != 1065353216)
  {
    if (fabsf(v22) != INFINITY) {
      goto LABEL_69;
    }
    BOOL v27 = v22 < 0.0;
    goto LABEL_58;
  }
  unint64_t v23 = &__kCFNumberFloat32One;
LABEL_65:

  return (CFNumberRef)CFRetain(v23);
}

void _flattenPlist(const void *a1, const __CFArray *a2, __CFDictionary *a3, const __CFSet *a4)
{
  v30[1] = *(void *)off_1ECE0A5B0;
  CFTypeID v8 = CFGetTypeID(a1);
  CFTypeID v9 = v8;
  if (v8 > 0x2A
    || ((1 << v8) & 0x40000500080) == 0
    || (CFIndex v10 = CFSetGetCount(a4), CFSetAddValue(a4, a1), CFSetGetCount(a4) != v10))
  {
    unsigned int Count = CFArrayGetCount(a2);
    CFArrayAppendValue(a2, a1);
    CFDictionaryAddValue(a3, a1, (const void *)Count);
    if (v9 != 19)
    {
      if (v9 != 18) {
        return;
      }
      CFIndex v14 = CFDictionaryGetCount((CFDictionaryRef)a1);
      MEMORY[0x1F4188790](v14, v15);
      BOOL v18 = (const void **)((char *)v30 - v17);
      if (v16 >= 0x200) {
        size_t v19 = 512;
      }
      else {
        size_t v19 = v16;
      }
      bzero((char *)v30 - v17, v19);
      if (v14 >= 129)
      {
        uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * v14, 0xC0040B8AA526DLL, 0);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, Typed, &Typed[v14]);
      }
      else
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v18, &v18[v14]);
        uint64_t Typed = v18;
        if (v14 < 1) {
          goto LABEL_27;
        }
      }
      uint64_t v27 = 0;
      if (2 * v14 <= 1) {
        uint64_t v28 = 1;
      }
      else {
        uint64_t v28 = 2 * v14;
      }
      do
        _flattenPlist(Typed[v27++], a2, a3, a4);
      while (v28 != v27);
LABEL_27:
      if (Typed == v18) {
        return;
      }
LABEL_33:
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      return;
    }
    uint64_t v21 = CFArrayGetCount((CFArrayRef)a1);
    MEMORY[0x1F4188790](v21, v22);
    uint64_t v25 = (const void **)((char *)v30 - v24);
    if (v23 >= 0x200) {
      size_t v26 = 512;
    }
    else {
      size_t v26 = v23;
    }
    bzero((char *)v30 - v24, v26);
    if (v21 >= 257)
    {
      uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v21, 0xC0040B8AA526DLL, 0);
      v33.CFIndex location = 0;
      v33.CFIndex length = v21;
      CFArrayGetValues((CFArrayRef)a1, v33, Typed);
    }
    else
    {
      v32.CFIndex location = 0;
      v32.CFIndex length = v21;
      CFArrayGetValues((CFArrayRef)a1, v32, v25);
      uint64_t Typed = v25;
      if (v21 < 1) {
        goto LABEL_32;
      }
    }
    for (uint64_t i = 0; i != v21; ++i)
      _flattenPlist(Typed[i], a2, a3, a4);
LABEL_32:
    if (Typed == v25) {
      return;
    }
    goto LABEL_33;
  }
  CFStringRef Value = CFSetGetValue(a4, a1);
  if (Value != a1)
  {
    unint64_t v12 = CFDictionaryGetValue(a3, Value);
    CFDictionaryAddValue(a3, a1, (const void *)v12);
  }
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  if (((unint64_t)cf & 0x8000000000000000) != 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)cf & 0xC000000000000007) == 0) {
      uint64_t v3 = 0;
    }
    unint64_t v4 = v3 ^ (unint64_t)cf;
    do
    {
      if ((v4 & 7) == *((unsigned char *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    unint64_t v5 = v2 | v4;
    uint64_t v6 = v2 & 7;
    int v7 = (v5 >> 55) + 8;
    if (v6 == 7) {
      int v8 = v7;
    }
    else {
      int v8 = v6;
    }
    CFTypeID result = 22;
    switch(v8)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFGetTypeID_cold_1();
        }
        goto LABEL_21;
      case 1:
        goto LABEL_14;
      case 2:
        goto LABEL_20;
      case 3:
        return result;
      case 4:
      case 5:
        goto LABEL_21;
      case 6:
        return 42;
      default:
        if (v8 == 20)
        {
LABEL_21:
          CFTypeID result = 1;
        }
        else
        {
          if (v8 != 22) {
            goto LABEL_14;
          }
LABEL_20:
          CFTypeID result = 7;
        }
        break;
    }
  }
  else
  {
    unint64_t v10 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v10 >> 8) & 0x3FF, (unint64_t)cf))
    {
LABEL_14:
      return [(id)cf _cfTypeID];
    }
    else
    {
      unint64_t v11 = atomic_load((unint64_t *)cf + 1);
      return (v11 >> 8) & 0x3FF;
    }
  }
  return result;
}

uint64_t CFBasicHashGetCount(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 18);
  if ((v2 & 0x18) == 0) {
    return *(unsigned int *)(a1 + 20);
  }
  uint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  if (v3 < 1) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t result = 0;
  uint64_t v6 = *(void *)(a1 + (v2 & 0x18) + 40);
  uint64_t v7 = (v2 >> 5) & 3;
  do
  {
    switch(v7)
    {
      case 1:
        uint64_t v8 = *(unsigned __int16 *)(v6 + 2 * v4);
        break;
      case 2:
        uint64_t v8 = *(unsigned int *)(v6 + 4 * v4);
        break;
      case 3:
        uint64_t v8 = *(void *)(v6 + 8 * v4);
        break;
      default:
        uint64_t v8 = *(unsigned __int8 *)(v6 + v4);
        break;
    }
    result += v8;
    ++v4;
  }
  while (v3 != v4);
  return result;
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  if (!CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    return *((void *)theArray + 2);
  }

  return [(__CFArray *)theArray count];
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict __addObject:value forKey:key];
  }
  else
  {
    char v6 = atomic_load((unint64_t *)theDict + 1);
    if ((v6 & 0x40) != 0)
    {
      unint64_t v11 = "void CFDictionaryAddValue(CFMutableDictionaryRef, const void *, const void *)";
      CFMutableDictionaryRef v12 = theDict;
      CFLog(3, @"%s(): immutable collection %p given to mutating function");
    }
    char v7 = atomic_load((unint64_t *)theDict + 1);
    if (v7)
    {
      uint64_t v8 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        uint64_t v8 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v8;
      }
      objc_msgSend(theDict, v8, key, v11, v12);
    }
    CFBasicHashAddValue((uint64_t)theDict, (unint64_t)key, (uint64_t)value);
    char v9 = atomic_load((unint64_t *)theDict + 1);
    if (v9)
    {
      unint64_t v10 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        unint64_t v10 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v10;
      }
      objc_msgSend(theDict, v10, key);
    }
  }
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict __setObject:value forKey:key];
  }
  else
  {
    char v12 = atomic_load((unint64_t *)theDict + 1);
    if ((v12 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function", v6, v7, v8, v9, v10, v11, (__int16)"void CFDictionarySetValue(CFMutableDictionaryRef, const void *, const void *)");
    }
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if (v13)
    {
      CFIndex v14 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        CFIndex v14 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v14;
      }
      objc_msgSend(theDict, v14, key);
    }
    CFBasicHashSetValue((uint64_t)theDict, (unint64_t)key, (uint64_t)value);
    char v15 = atomic_load((unint64_t *)theDict + 1);
    if (v15)
    {
      unint64_t v16 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        unint64_t v16 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v16;
      }
      objc_msgSend(theDict, v16, key);
    }
  }
}

uint64_t CFBasicHashAddValue(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233) {
    goto LABEL_28;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  if (*(unsigned char *)(a1 + 26))
  {
    int v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        default:
          goto LABEL_28;
      }
    }
    else if (v7 == 3)
    {
      ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v10);
    }
    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v10);
          goto LABEL_21;
        }
LABEL_28:
        __break(1u);
      }
      ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v10);
    }
  }
  else
  {
    long long v10 = xmmword_182EDDE80;
    long long v11 = *(_OWORD *)algn_182EDDE90;
  }
LABEL_21:
  unint64_t v8 = *((void *)&v11 + 1);
  if (!*((void *)&v11 + 1))
  {
    __CFBasicHashAddValue(a1, v10, a2, a3);
    return 1;
  }
  uint64_t result = 0;
  ++*(_WORD *)(a1 + 16);
  if (v8 <= 0x7FFFFFFFFFFFFFFELL && (*(_WORD *)(a1 + 18) & 0x18) != 0)
  {
    __CFBasicHashIncSlotCount((unsigned __int16 *)a1, v10);
    return 1;
  }
  return result;
}

void __CFBasicHashAddValue(uint64_t cf, uint64_t a2, unint64_t a3, uint64_t a4)
{
  ++*(_WORD *)(cf + 16);
  uint64_t v7 = *(void *)(cf + 24);
  if (__CFBasicHashTableCapacities[BYTE2(v7)] >= (uint64_t)(*(_DWORD *)(cf + 20) + 1))
  {
    uint64_t v10 = a2;
    if (*(void *)(*(void *)(cf + 40) + 8 * a2) == -1)
    {
      uint64_t v11 = *(void *)(cf + 32);
      *(void *)(cf + 24) = v7 & 0xFFFFFFFFFFFF0000 | (unsigned __int16)(v7 - 1);
      *(void *)(cf + 32) = v11;
    }
    goto LABEL_20;
  }
  __CFBasicHashRehash(cf, 1);
  if (!*(unsigned char *)(cf + 26))
  {
    uint64_t v10 = -1;
    goto LABEL_20;
  }
  int v8 = *(_WORD *)(cf + 18) & 3;
  if ((*(_WORD *)(cf + 18) & 0x8000) != 0)
  {
    switch(v8)
    {
      case 3:
        unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
      case 2:
        unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
      case 1:
        unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
    }
LABEL_76:
    __break(1u);
    return;
  }
  if (v8 == 3)
  {
    unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(cf, a3);
    goto LABEL_19;
  }
  if (v8 == 2)
  {
    unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(cf, a3);
    goto LABEL_19;
  }
  if (v8 != 1) {
    goto LABEL_76;
  }
  unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(cf, a3);
LABEL_19:
  uint64_t v10 = Bucket_Exponential_Indirect_NoCollision;
LABEL_20:
  if ((*(void *)(cf + 32) & 2) == 0)
  {
    uint64_t v12 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 39) & 0x1FLL]
                                                                  + 8 * ((*(void *)(cf + 24) >> 34) & 0x1FLL));
    if (v12)
    {
      if (cf < 0)
      {
        char v13 = &kCFAllocatorSystemDefault;
      }
      else
      {
        char v14 = atomic_load((unint64_t *)(cf + 8));
        if (v14 < 0) {
          char v13 = &kCFAllocatorSystemDefault;
        }
        else {
          char v13 = (const CFAllocatorRef *)(cf - 16);
        }
      }
      a4 = v12(*v13, a4);
    }
  }
  if ((*(_WORD *)(cf + 18) & 4) != 0 && (*(void *)(cf + 32) & 2) == 0)
  {
    char v15 = *(uint64_t (**)(const CFAllocatorRef, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(cf + 27) >> 5) & 0x1F]
                                                                           + 8 * (*(_DWORD *)(cf + 27) & 0x1FLL));
    if (v15)
    {
      if (cf < 0 || (char v16 = atomic_load((unint64_t *)(cf + 8)), v16 < 0)) {
        uint64_t v17 = &kCFAllocatorSystemDefault;
      }
      else {
        uint64_t v17 = (const CFAllocatorRef *)(cf - 16);
      }
      a3 = v15(*v17, a3);
    }
  }
  uint64_t v18 = *(void *)(cf + 40);
  uint64_t v19 = *(void *)(v18 + 8 * v10);
  if (a4) {
    uint64_t v20 = a4;
  }
  else {
    uint64_t v20 = 2814029233;
  }
  if (v20 == -1) {
    uint64_t v20 = 2780474809;
  }
  *(void *)(v18 + 8 * v10) = v20;
  if ((unint64_t)(v19 + 1) >= 2)
  {
    if (v19 == 2814029233) {
      uint64_t v19 = 0;
    }
    if (v19 == 2780474809) {
      uint64_t v21 = -1;
    }
    else {
      uint64_t v21 = v19;
    }
    if ((*(void *)(cf + 32) & 2) == 0)
    {
      uint64_t v22 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                              + (HIBYTE(*(void *)(cf + 24)) & 0xF8))
                                                                 + 8 * ((*(void *)(cf + 24) >> 54) & 0x1FLL));
      if (v22)
      {
        if (cf < 0 || (char v23 = atomic_load((unint64_t *)(cf + 8)), v23 < 0)) {
          uint64_t v24 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v24 = (const CFAllocatorRef *)(cf - 16);
        }
        v22(*v24, v21);
      }
    }
  }
  unint64_t v25 = *(unsigned __int16 *)(cf + 18);
  if ((v25 & 4) != 0)
  {
    uint64_t v26 = *(void *)(cf + 8 * ((v25 >> 2) & 1) + 40);
    uint64_t v27 = *(void *)(v26 + 8 * v10);
    if (a3) {
      uint64_t v28 = a3;
    }
    else {
      uint64_t v28 = 2814029233;
    }
    if (v28 == -1) {
      uint64_t v28 = 2780474809;
    }
    *(void *)(v26 + 8 * v10) = v28;
    if ((unint64_t)(v27 + 1) >= 2)
    {
      if (v27 == 2814029233) {
        uint64_t v27 = 0;
      }
      if (v27 == 2780474809) {
        uint64_t v29 = -1;
      }
      else {
        uint64_t v29 = v27;
      }
      if ((*(void *)(cf + 32) & 2) == 0)
      {
        unsigned __int8 v30 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 49) & 0x1FLL]
                                                                   + 8 * ((*(void *)(cf + 24) >> 44) & 0x1FLL));
        if (v30)
        {
          if (cf < 0 || (char v31 = atomic_load((unint64_t *)(cf + 8)), v31 < 0)) {
            CFRange v32 = &kCFAllocatorSystemDefault;
          }
          else {
            CFRange v32 = (const CFAllocatorRef *)(cf - 16);
          }
          v30(*v32, v29);
        }
      }
    }
  }
  if ((*(_WORD *)(cf + 18) & 0x18) != 0) {
    __CFBasicHashIncSlotCount((unsigned __int16 *)cf, v10);
  }
  ++*(_DWORD *)(cf + 20);
}

CFTypeRef __CFTypeCollectionRetain(int a1, CFTypeRef cf)
{
  if (!cf) {
    __CFTypeCollectionRetain_cold_1();
  }
  return CFRetain(cf);
}

void CFBasicHashSetValue(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233) {
    goto LABEL_28;
  }
  long long v9 = 0u;
  long long v10 = 0u;
  if (*(unsigned char *)(a1 + 26))
  {
    int v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v9);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v9);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v9);
          break;
        default:
          goto LABEL_28;
      }
    }
    else if (v7 == 3)
    {
      ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v9);
    }
    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v9);
          goto LABEL_21;
        }
LABEL_28:
        __break(1u);
      }
      ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v9);
    }
  }
  else
  {
    long long v9 = xmmword_182EDDE80;
    long long v10 = *(_OWORD *)algn_182EDDE90;
  }
LABEL_21:
  uint64_t v8 = v9;
  if (*((void *)&v10 + 1))
  {
    __CFBasicHashReplaceValue(a1, v8, a2, a3);
  }
  else
  {
    __CFBasicHashAddValue(a1, v8, a2, a3);
  }
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict)) {
    return [(__CFDictionary *)theDict __getValue:value forKey:key];
  }
  long long v7 = 0u;
  long long v8 = 0u;
  CFBasicHashFindBucket((uint64_t)theDict, (unint64_t)key, (uint64_t *)&v7);
  if (!*((void *)&v8 + 1)) {
    return 0;
  }
  if (value) {
    *value = (const void *)v8;
  }
  return 1;
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    return (const void *)[(__CFDictionary *)theDict objectForKey:key];
  }
  else
  {
    long long v5 = 0u;
    long long v6 = 0u;
    CFBasicHashFindBucket((uint64_t)theDict, (unint64_t)key, (uint64_t *)&v5);
    if (*((void *)&v6 + 1)) {
      return (const void *)v6;
    }
    else {
      return 0;
    }
  }
}

unint64_t ___CFBasicHashFindBucket_Linear@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  unint64_t v9 = *(unsigned __int16 *)(a1 + 18);
  long long v10 = (void *)(a1 + 40);
  if ((v9 & 4) != 0) {
    uint64_t v11 = (uint64_t *)(a1 + 40 + 8 * ((v9 >> 2) & 1));
  }
  else {
    uint64_t v11 = (uint64_t *)(a1 + 40);
  }
  uint64_t v27 = a3;
  if (!v6)
  {
    uint64_t v14 = -1;
LABEL_27:
    uint64_t v16 = 0;
    uint64_t v20 = v27;
    v27[1] = 0;
    v27[2] = 0;
    *uint64_t v27 = v14;
    goto LABEL_28;
  }
  unint64_t v12 = result % v6;
  uint64_t v13 = *v11;
  uint64_t v14 = -1;
  unint64_t v15 = v6;
  while (1)
  {
    uint64_t v16 = *(void *)(v13 + 8 * v12);
    switch(v16)
    {
      case -1:
        if (v14 == -1) {
          uint64_t v14 = v12;
        }
        goto LABEL_21;
      case 0:
        uint64_t v20 = v27;
        v27[1] = 0;
        v27[2] = 0;
        if (v14 == -1) {
          uint64_t v21 = v12;
        }
        else {
          uint64_t v21 = v14;
        }
        *uint64_t v27 = v21;
        goto LABEL_28;
      case 2814029233:
        uint64_t v16 = 0;
        break;
    }
    uint64_t v17 = v16 == 2780474809 ? -1 : v16;
    if (v17 == a2) {
      break;
    }
    uint64_t v18 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v18)
    {
      unint64_t result = v18(v17, a2);
      if (result) {
        goto LABEL_34;
      }
    }
LABEL_21:
    if (v6 <= v12 + 1) {
      unint64_t v19 = v6;
    }
    else {
      unint64_t v19 = 0;
    }
    unint64_t v12 = v12 + 1 - v19;
    if (!--v15) {
      goto LABEL_27;
    }
  }
  uint64_t v17 = a2;
LABEL_34:
  uint64_t v22 = *(void *)(*v10 + 8 * v12);
  uint64_t v23 = -1;
  if (v22 != 2780474809) {
    uint64_t v23 = *(void *)(*v10 + 8 * v12);
  }
  if (v22 == 2814029233) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = v23;
  }
  uint64_t v20 = v27;
  v27[1] = v17;
  v27[2] = v24;
  *uint64_t v27 = v12;
  unsigned int v25 = *(unsigned __int16 *)(a1 + 18);
  if ((v25 & 0x18) != 0)
  {
    uint64_t v26 = *(void *)(a1 + (v25 & 0x18) + 40);
    switch((v25 >> 5) & 3)
    {
      case 1u:
        uint64_t v16 = *(unsigned __int16 *)(v26 + 2 * v12);
        break;
      case 2u:
        uint64_t v16 = *(unsigned int *)(v26 + 4 * v12);
        break;
      case 3u:
        uint64_t v16 = *(void *)(v26 + 8 * v12);
        break;
      default:
        uint64_t v16 = *(unsigned __int8 *)(v26 + v12);
        break;
    }
  }
  else
  {
    uint64_t v16 = 1;
  }
LABEL_28:
  void v20[3] = v16;
  return result;
}

uint64_t CFBasicHashFindBucket@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL v3 = a2 == 2814029233 || a2 == 2780474809;
  if (v3 || !*(unsigned char *)(a1 + 26))
  {
    *(_OWORD *)a3 = xmmword_182EDDE80;
    *((_OWORD *)a3 + 1) = *(_OWORD *)algn_182EDDE90;
    return a1;
  }
  int v4 = *(_WORD *)(a1 + 18) & 3;
  if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
  {
    switch(v4)
    {
      case 3:
        return ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, a3);
      case 2:
        return ___CFBasicHashFindBucket_Double_Indirect(a1, a2, a3);
      case 1:
        return ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, a3);
    }
  }
  else
  {
    switch(v4)
    {
      case 3:
        return ___CFBasicHashFindBucket_Exponential(a1, a2, a3);
      case 2:
        return ___CFBasicHashFindBucket_Double(a1, a2, a3);
      case 1:
        return ___CFBasicHashFindBucket_Linear(a1, a2, a3);
    }
  }
  __break(1u);
  return a1;
}

CFHashCode CFHash(CFTypeRef cf)
{
  if (!cf) {
    CFHash_cold_1();
  }
  if (((unint64_t)cf & 0x8000000000000000) != 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    unint64_t v4 = (unint64_t)cf & 0xC000000000000007;
    if (((unint64_t)cf & 0xC000000000000007) == 0xC000000000000007) {
      uint64_t v3 = 0;
    }
    unint64_t v5 = v3 ^ (unint64_t)cf;
    unint64_t v6 = v5 & 7;
    do
    {
      if (v6 == *((unsigned __int8 *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    unint64_t v7 = v2 | v5;
    uint64_t v8 = v2 & 7;
    int v9 = (v7 >> 55) + 8;
    if (v8 == 7) {
      LODWORD(v8) = v9;
    }
    if (v8)
    {
      if (v8 == 3)
      {
        long long v10 = off_1ECE0E048;
LABEL_43:
        return ((uint64_t (*)(CFTypeRef))v10)(cf);
      }
    }
    else
    {
      if (dyld_program_sdk_at_least()) {
        CFHash_cold_4();
      }
      uint64_t v24 = *(void *)off_1ECE0A6F0;
      if (v4 == 0xC000000000000007) {
        uint64_t v24 = 0;
      }
      unint64_t v5 = v24 ^ (unint64_t)cf;
      unint64_t v6 = v5 & 7;
    }
    for (uint64_t i = 0; i != 7; ++i)
    {
      if (v6 == *((unsigned __int8 *)off_1ECE0A6E0 + i)) {
        break;
      }
    }
    int v26 = ((i | v5) >> 55) + 8;
    if ((i & 7) == 7) {
      int v27 = v26;
    }
    else {
      int v27 = i & 7;
    }
    unint64_t v12 = 22;
    switch(v27)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFHash_cold_3();
        }
        goto LABEL_62;
      case 1:
        goto LABEL_63;
      case 2:
        goto LABEL_61;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_62;
      case 6:
        unint64_t v12 = 42;
        break;
      default:
        if (v27 == 20)
        {
LABEL_62:
          unint64_t v12 = 1;
        }
        else if (v27 == 22)
        {
LABEL_61:
          unint64_t v12 = 7;
        }
        else
        {
LABEL_63:
          unint64_t v12 = [(id)cf _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v11 = atomic_load((unint64_t *)cf + 1);
    unint64_t v12 = (v11 >> 8) & 0x3FF;
  }
  if (!CF_IS_OBJC(v12, (unint64_t)cf))
  {
    __CFCheckCFInfoPACSignature_Bridged((uint64_t)cf);
    if (((unint64_t)cf & 0x8000000000000000) != 0)
    {
      uint64_t v14 = 0;
      uint64_t v15 = *(void *)off_1ECE0A6F0;
      if ((~(unint64_t)cf & 0xC000000000000007) == 0) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = v15 ^ (unint64_t)cf;
      do
      {
        if ((v16 & 7) == *((unsigned char *)off_1ECE0A6E0 + v14)) {
          break;
        }
        ++v14;
      }
      while (v14 != 7);
      unint64_t v17 = v14 | v16;
      uint64_t v18 = v14 & 7;
      int v19 = (v17 >> 55) + 8;
      if (v18 == 7) {
        int v20 = v19;
      }
      else {
        int v20 = v18;
      }
      unint64_t v21 = 22;
      switch(v20)
      {
        case 0:
          if (dyld_program_sdk_at_least()) {
            CFHash_cold_2();
          }
          goto LABEL_38;
        case 1:
          goto LABEL_39;
        case 2:
          goto LABEL_37;
        case 3:
          goto LABEL_41;
        case 4:
        case 5:
          goto LABEL_38;
        case 6:
          unint64_t v21 = 42;
          goto LABEL_41;
        default:
          if (v20 == 20)
          {
LABEL_38:
            unint64_t v21 = 1;
            goto LABEL_41;
          }
          if (v20 == 22)
          {
LABEL_37:
            unint64_t v21 = 7;
            goto LABEL_41;
          }
LABEL_39:
          unint64_t v21 = [(id)cf _cfTypeID];
          break;
      }
    }
    else
    {
      unint64_t v22 = atomic_load((unint64_t *)cf + 1);
      unint64_t v21 = (v22 >> 8) & 0x3FF;
    }
    if (v21 <= 0x47) {
LABEL_41:
    }
      uint64_t v23 = &__CFRuntimeBuiltinClassTable + v21;
    else {
      uint64_t v23 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v21 - 72) >> 6] + 8 * ((v21 - 72) & 0x3F));
    }
    long long v10 = (uint64_t (*)())*((void *)*v23 + 6);
    if (!v10) {
      return (CFHashCode)cf;
    }
    goto LABEL_43;
  }

  return [(id)cf hash];
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  v4[1] = *(void *)off_1ECE0A5B0;
  v4[0] = value;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    [(__CFArray *)theArray addObject:value];
  }
  else
  {
    _CFArrayReplaceValues((unint64_t)theArray, *((void *)theArray + 2), 0, v4, 1);
  }
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    return [(__CFSet *)theSet count];
  }
  else
  {
    return CFBasicHashGetCount((uint64_t)theSet);
  }
}

unint64_t ___CFBasicHashFindBucket_Exponential_Indirect@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v7 = __CFBasicHashTableSizes[v6];
  uint64_t v8 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v8) {
    unint64_t result = v8(a2);
  }
  uint64_t v31 = a2;
  if (result / v7 % v7) {
    unint64_t v10 = result / v7 % v7;
  }
  else {
    unint64_t v10 = v7 - 1;
  }
  unint64_t v11 = *(unsigned __int16 *)(a1 + 18);
  if ((v11 & 4) != 0) {
    unint64_t v12 = (uint64_t *)(a1 + 40 + 8 * ((v11 >> 2) & 1));
  }
  else {
    unint64_t v12 = (uint64_t *)(a1 + 40);
  }
  uint64_t v29 = a3;
  if (!v7)
  {
    uint64_t v16 = -1;
LABEL_35:
    uint64_t v20 = 0;
    uint64_t v24 = v29;
    v29[1] = 0;
    v29[2] = 0;
    uint64_t *v29 = v16;
    goto LABEL_36;
  }
  unint64_t v13 = result % v7;
  unint64_t v14 = __CFBasicHashPrimitiveRoots[v6];
  uint64_t v15 = *v12;
  uint64_t v16 = -1;
  unint64_t v17 = v7;
  unint64_t v18 = v14;
  unint64_t v19 = result % v7;
  unint64_t v30 = v10;
  while (1)
  {
    uint64_t v20 = *(void *)(v15 + 8 * v19);
    switch(v20)
    {
      case -1:
        if (v16 == -1) {
          uint64_t v16 = v19;
        }
        goto LABEL_28;
      case 0:
        uint64_t v24 = v29;
        v29[1] = 0;
        v29[2] = 0;
        if (v16 == -1) {
          uint64_t v25 = v19;
        }
        else {
          uint64_t v25 = v16;
        }
        uint64_t *v29 = v25;
        goto LABEL_36;
      case 2814029233:
        uint64_t v20 = 0;
        break;
    }
    if (v20 == 2780474809) {
      uint64_t v21 = -1;
    }
    else {
      uint64_t v21 = v20;
    }
    unint64_t v22 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
    if (v22)
    {
      unint64_t result = v22(v21);
      uint64_t v21 = result;
    }
    if (v21 == v31) {
      break;
    }
    uint64_t v23 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                            + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v23)
    {
      unint64_t result = v23(v21);
      unint64_t v10 = v30;
      if (result) {
        goto LABEL_42;
      }
    }
    else
    {
      unint64_t v10 = v30;
    }
LABEL_28:
    unint64_t v19 = v13 + v18 * v10;
    if (v7 <= v19) {
      v19 %= v7;
    }
    v18 *= v14;
    if (v7 <= v18) {
      v18 %= v7;
    }
    if (!--v17) {
      goto LABEL_35;
    }
  }
  uint64_t v21 = v31;
LABEL_42:
  uint64_t v24 = v29;
  uint64_t *v29 = v19;
  uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8 * v19);
  if (v26 == 2814029233)
  {
    uint64_t v26 = 0;
  }
  else if (v26 == 2780474809)
  {
    uint64_t v26 = -1;
  }
  v29[1] = v21;
  v29[2] = v26;
  unsigned int v27 = *(unsigned __int16 *)(a1 + 18);
  if ((v27 & 0x18) != 0)
  {
    uint64_t v28 = *(void *)(a1 + (v27 & 0x18) + 40);
    switch((v27 >> 5) & 3)
    {
      case 1u:
        uint64_t v20 = *(unsigned __int16 *)(v28 + 2 * v19);
        break;
      case 2u:
        uint64_t v20 = *(unsigned int *)(v28 + 4 * v19);
        break;
      case 3u:
        uint64_t v20 = *(void *)(v28 + 8 * v19);
        break;
      default:
        uint64_t v20 = *(unsigned __int8 *)(v28 + v19);
        break;
    }
  }
  else
  {
    uint64_t v20 = 1;
  }
LABEL_36:
  v24[3] = v20;
  return result;
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    return (const void *)[(__CFSet *)theSet member:value];
  }
  else
  {
    long long v5 = 0u;
    long long v6 = 0u;
    CFBasicHashFindBucket((uint64_t)theSet, (unint64_t)value, (uint64_t *)&v5);
    if (*((void *)&v6 + 1)) {
      return (const void *)v6;
    }
    else {
      return 0;
    }
  }
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    return [(__CFDictionary *)theDict count];
  }
  else
  {
    return CFBasicHashGetCount((uint64_t)theDict);
  }
}

uint64_t __NSOrderedSetEquateKeys(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet addObject:value];
  }
  else
  {
    char v4 = atomic_load((unint64_t *)theSet + 1);
    if ((v4 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function");
    }
    CFBasicHashAddValue((uint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)bytes, numBytes, *(uint64_t *)&encoding, (isExternalRepresentation != 0) | 2u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

__n128 __CFNumberInit(uint64_t a1, uint64_t a2, char *a3)
{
  switch(__CFNumberTypeTable[a2] & 0x1F)
  {
    case 1:
      uint64_t v3 = *a3;
      goto LABEL_6;
    case 2:
      uint64_t v3 = *(__int16 *)a3;
      goto LABEL_6;
    case 3:
      uint64_t v3 = *(int *)a3;
      goto LABEL_6;
    case 4:
    case 6:
      uint64_t v3 = *(void *)a3;
LABEL_6:
      *(void *)(a1 + 16) = v3;
      break;
    case 5:
      *(_DWORD *)(a1 + 16) = *(_DWORD *)a3;
      break;
    case 0x11:
      __n128 result = *(__n128 *)a3;
      *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t __CFRunLoopModeEqual(uint64_t a1, uint64_t a2)
{
  return CFEqual(*(CFTypeRef *)(a1 + 80), *(CFTypeRef *)(a2 + 80));
}

uint64_t _dependentNotificationsEqual(CFTypeRef **a1, CFTypeRef **a2)
{
  return CFEqual(**a1, **a2);
}

void *__CFDictionaryCreateTransfer(__objc2_class **a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  long long v5 = a3;
  long long v6 = (unint64_t *)a2;
  v16[10] = *(void *)off_1ECE0A5B0;
  CFArrayRef Transfer = __NSCFDictionaryCreateTransfer(a1, a2, a3, a4);
  if (!Transfer)
  {
    v16[0] = (uint64_t)__CFTypeCollectionRetain;
    v16[1] = (uint64_t)__CFTypeCollectionRetain;
    _DWORD v16[2] = (uint64_t)__CFTypeCollectionRelease;
    v16[3] = (uint64_t)__CFTypeCollectionRelease;
    v16[4] = (uint64_t)CFEqual;
    v16[5] = (uint64_t)CFEqual;
    v16[6] = (uint64_t)CFHash;
    v16[7] = 0;
    v16[8] = (uint64_t)CFCopyDescription;
    v16[9] = (uint64_t)CFCopyDescription;
    CFArrayRef Transfer = (void *)CFBasicHashCreate(a1, 0x2001u, v16);
    CFBasicHashSuppressRC((uint64_t)Transfer);
    if (v4 >= 1)
    {
      CFBasicHashSetCapacity((uint64_t)Transfer, v4);
      do
      {
        unint64_t v10 = *v6++;
        unint64_t v9 = v10;
        uint64_t v11 = *v5++;
        CFBasicHashAddValue((uint64_t)Transfer, v9, v11);
        --v4;
      }
      while (v4);
    }
    CFBasicHashUnsuppressRC((uint64_t)Transfer);
    unint64_t v12 = atomic_load(Transfer + 1);
    unint64_t v13 = v12;
    do
    {
      atomic_compare_exchange_strong(Transfer + 1, &v13, v12 | 0x40);
      BOOL v14 = v13 == v12;
      unint64_t v12 = v13;
    }
    while (!v14);
    _CFRuntimeSetInstanceTypeIDAndIsa(Transfer, 0x12uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return Transfer;
}

__objc2_class **__NSCFDictionaryCreateTransfer(__objc2_class **a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (__FoundationPresent_static_init_0 != -1) {
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  }
  if (!__FoundationPresent_present_0
    || &__kCFAllocatorSystemDefault != a1
    && (a1 || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return 0;
  }
  if (a4 == 1)
  {
    unint64_t v9 = *a2;
    unint64_t v10 = *a3;
    return (__objc2_class **)__NSSingleEntryDictionaryI_new(v9, v10, 12);
  }
  else if (a4)
  {
    return (__objc2_class **)__NSDictionaryI_new(a2, a3, 0, a4, 12);
  }
  else
  {
    return &__NSDictionary0__struct;
  }
}

BOOL typeStringEqual(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

void __CFBasicHashIncSlotCount(unsigned __int16 *cf, uint64_t a2)
{
  while (2)
  {
    unsigned int v4 = cf[9];
    long long v5 = *(_WORD **)((char *)cf + (v4 & 0x18) + 40);
    switch((v4 >> 5) & 3)
    {
      case 1u:
        unsigned int v15 = (unsigned __int16)v5[a2];
        if (v15 > 0x7FFE)
        {
          CFAllocatorRef v16 = CFGetAllocator(cf);
          unsigned int v17 = cf[9];
          CFAllocatorRef v9 = v16;
          switch((v17 >> 5) & 3)
          {
            case 1u:
              cf[9] = v17 & 0xFF9F | 0x40;
              uint64_t v44 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v44 - 0x2000000000000000) >> 62 != 3) {
                __CFBasicHashIncSlotCount_cold_5();
              }
              CFAllocatorRef v45 = CFGetAllocator(cf);
              uint64_t Typed = CFAllocatorAllocateTyped(v45, 4 * v44, 1198341549, 0);
              if (!Typed) {
                goto LABEL_110;
              }
              uint64_t v13 = Typed;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v44 >= 1)
              {
                for (uint64_t i = 0; i != v44; ++i)
                  *(_DWORD *)(v13 + 4 * i) = (unsigned __int16)v5[i];
              }
              break;
            case 2u:
              cf[9] = v17 | 0x60;
              uint64_t v48 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v48 - 0x1000000000000000) >> 61 != 7) {
                __CFBasicHashIncSlotCount_cold_6();
              }
              CFAllocatorRef v49 = CFGetAllocator(cf);
              uint64_t v50 = CFAllocatorAllocateTyped(v49, 8 * v48, 1198341549, 0);
              if (!v50) {
                goto LABEL_110;
              }
              uint64_t v13 = v50;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v48 >= 1)
              {
                for (uint64_t j = 0; j != v48; ++j)
                  *(void *)(v13 + 8 * j) = *(unsigned int *)&v5[2 * j];
              }
              break;
            case 3u:
              goto LABEL_110;
            default:
              cf[9] = v17 & 0xFF9F | 0x20;
              uint64_t v18 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if (v18 + 0x4000000000000000 < 0) {
                __CFBasicHashIncSlotCount_cold_4();
              }
              CFAllocatorRef v19 = CFGetAllocator(cf);
              uint64_t v20 = CFAllocatorAllocateTyped(v19, 2 * v18, 1198341549, 0);
              if (!v20) {
                goto LABEL_110;
              }
              uint64_t v13 = v20;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v18 >= 1)
              {
                for (uint64_t k = 0; k != v18; ++k)
                  *(_WORD *)(v13 + 2 * k) = *((unsigned __int8 *)v5 + k);
              }
              break;
          }
          goto LABEL_105;
        }
        v5[a2] = v15 + 1;
        break;
      case 2u:
        unsigned int v22 = *(_DWORD *)&v5[2 * a2];
        if (v22 > 0x7FFFFFFE)
        {
          CFAllocatorRef v23 = CFGetAllocator(cf);
          unsigned int v24 = cf[9];
          CFAllocatorRef v9 = v23;
          switch((v24 >> 5) & 3)
          {
            case 1u:
              cf[9] = v24 & 0xFF9F | 0x40;
              uint64_t v52 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v52 - 0x2000000000000000) >> 62 != 3) {
                __CFBasicHashIncSlotCount_cold_8();
              }
              CFAllocatorRef v53 = CFGetAllocator(cf);
              uint64_t v54 = CFAllocatorAllocateTyped(v53, 4 * v52, 1198341549, 0);
              if (!v54) {
                goto LABEL_110;
              }
              uint64_t v13 = v54;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v52 >= 1)
              {
                for (uint64_t m = 0; m != v52; ++m)
                  *(_DWORD *)(v13 + 4 * m) = (unsigned __int16)v5[m];
              }
              break;
            case 2u:
              cf[9] = v24 | 0x60;
              uint64_t v56 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v56 - 0x1000000000000000) >> 61 != 7) {
                __CFBasicHashIncSlotCount_cold_9();
              }
              CFAllocatorRef v57 = CFGetAllocator(cf);
              uint64_t v58 = CFAllocatorAllocateTyped(v57, 8 * v56, 1198341549, 0);
              if (!v58) {
                goto LABEL_110;
              }
              uint64_t v13 = v58;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v56 >= 1)
              {
                for (uint64_t n = 0; n != v56; ++n)
                  *(void *)(v13 + 8 * n) = *(unsigned int *)&v5[2 * n];
              }
              break;
            case 3u:
              goto LABEL_110;
            default:
              cf[9] = v24 & 0xFF9F | 0x20;
              uint64_t v25 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if (v25 + 0x4000000000000000 < 0) {
                __CFBasicHashIncSlotCount_cold_7();
              }
              CFAllocatorRef v26 = CFGetAllocator(cf);
              uint64_t v27 = CFAllocatorAllocateTyped(v26, 2 * v25, 1198341549, 0);
              if (!v27) {
                goto LABEL_110;
              }
              uint64_t v13 = v27;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v25 >= 1)
              {
                for (iuint64_t i = 0; ii != v25; ++ii)
                  *(_WORD *)(v13 + 2 * ii) = *((unsigned __int8 *)v5 + ii);
              }
              break;
          }
          goto LABEL_105;
        }
        *(_DWORD *)&v5[2 * a2] = v22 + 1;
        break;
      case 3u:
        unint64_t v29 = *(void *)&v5[4 * a2];
        if (v29 > 0x7FFFFFFFFFFFFFFELL)
        {
          CFAllocatorRef v30 = CFGetAllocator(cf);
          unsigned int v31 = cf[9];
          CFAllocatorRef v9 = v30;
          switch((v31 >> 5) & 3)
          {
            case 1u:
              cf[9] = v31 & 0xFF9F | 0x40;
              uint64_t v60 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v60 - 0x2000000000000000) >> 62 != 3) {
                __CFBasicHashIncSlotCount_cold_11();
              }
              CFAllocatorRef v61 = CFGetAllocator(cf);
              uint64_t v62 = CFAllocatorAllocateTyped(v61, 4 * v60, 1198341549, 0);
              if (!v62) {
                goto LABEL_110;
              }
              uint64_t v13 = v62;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v60 >= 1)
              {
                for (juint64_t j = 0; jj != v60; ++jj)
                  *(_DWORD *)(v13 + 4 * jj) = (unsigned __int16)v5[jj];
              }
              break;
            case 2u:
              cf[9] = v31 | 0x60;
              uint64_t v64 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v64 - 0x1000000000000000) >> 61 != 7) {
                __CFBasicHashIncSlotCount_cold_12();
              }
              CFAllocatorRef v65 = CFGetAllocator(cf);
              uint64_t v66 = CFAllocatorAllocateTyped(v65, 8 * v64, 1198341549, 0);
              if (!v66) {
                goto LABEL_110;
              }
              uint64_t v13 = v66;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v64 >= 1)
              {
                for (kuint64_t k = 0; kk != v64; ++kk)
                  *(void *)(v13 + 8 * kk) = *(unsigned int *)&v5[2 * kk];
              }
              break;
            case 3u:
              goto LABEL_110;
            default:
              cf[9] = v31 & 0xFF9F | 0x20;
              uint64_t v32 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if (v32 + 0x4000000000000000 < 0) {
                __CFBasicHashIncSlotCount_cold_10();
              }
              CFAllocatorRef v33 = CFGetAllocator(cf);
              uint64_t v34 = CFAllocatorAllocateTyped(v33, 2 * v32, 1198341549, 0);
              if (!v34) {
                goto LABEL_110;
              }
              uint64_t v13 = v34;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v32 >= 1)
              {
                for (uint64_t mm = 0; mm != v32; ++mm)
                  *(_WORD *)(v13 + 2 * mm) = *((unsigned __int8 *)v5 + mm);
              }
              break;
          }
          goto LABEL_105;
        }
        *(void *)&v5[4 * a2] = v29 + 1;
        break;
      default:
        unsigned int v6 = *((unsigned __int8 *)v5 + a2);
        if (v6 > 0x7E)
        {
          CFAllocatorRef v7 = CFGetAllocator(cf);
          unsigned int v8 = cf[9];
          CFAllocatorRef v9 = v7;
          switch((v8 >> 5) & 3)
          {
            case 1u:
              cf[9] = v8 & 0xFF9F | 0x40;
              uint64_t v36 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v36 - 0x2000000000000000) >> 62 != 3) {
                __CFBasicHashIncSlotCount_cold_2();
              }
              CFAllocatorRef v37 = CFGetAllocator(cf);
              uint64_t v38 = CFAllocatorAllocateTyped(v37, 4 * v36, 1198341549, 0);
              if (!v38) {
                goto LABEL_110;
              }
              uint64_t v13 = v38;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v36 >= 1)
              {
                for (uint64_t nn = 0; nn != v36; ++nn)
                  *(_DWORD *)(v13 + 4 * nn) = (unsigned __int16)v5[nn];
              }
              break;
            case 2u:
              cf[9] = v8 | 0x60;
              uint64_t v40 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if ((unint64_t)(v40 - 0x1000000000000000) >> 61 != 7) {
                __CFBasicHashIncSlotCount_cold_3();
              }
              CFAllocatorRef v41 = CFGetAllocator(cf);
              uint64_t v42 = CFAllocatorAllocateTyped(v41, 8 * v40, 1198341549, 0);
              if (!v42) {
                goto LABEL_110;
              }
              uint64_t v13 = v42;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v40 >= 1)
              {
                for (uint64_t i1 = 0; i1 != v40; ++i1)
                  *(void *)(v13 + 8 * i1) = *(unsigned int *)&v5[2 * i1];
              }
              break;
            case 3u:
              goto LABEL_110;
            default:
              cf[9] = v8 & 0xFF9F | 0x20;
              uint64_t v10 = __CFBasicHashTableSizes[*((unsigned __int8 *)cf + 26)];
              if (v10 + 0x4000000000000000 < 0) {
                goto LABEL_111;
              }
              CFAllocatorRef v11 = CFGetAllocator(cf);
              uint64_t v12 = CFAllocatorAllocateTyped(v11, 2 * v10, 1198341549, 0);
              if (!v12)
              {
LABEL_110:
                __break(1u);
LABEL_111:
                __CFBasicHashIncSlotCount_cold_1();
              }
              uint64_t v13 = v12;
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              if (v10 >= 1)
              {
                for (uint64_t i2 = 0; i2 != v10; ++i2)
                  *(_WORD *)(v13 + 2 * i2) = *((unsigned __int8 *)v5 + i2);
              }
              break;
          }
LABEL_105:
          *(void *)((char *)cf + (cf[9] & 0x18) + 40) = v13;
          CFAllocatorDeallocate(v9, v5);
          continue;
        }
        *((unsigned char *)v5 + a2) = v6 + 1;
        break;
    }
    break;
  }
}

uint64_t __CFBinaryPlistParseUnicode16String(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  if (a3 == (unsigned char *)-1) {
    return 0;
  }
  unsigned int v4 = a3 + 1;
  char v5 = *a3;
  unint64_t v6 = *a3 & 0xF;
  if ((v5 & 0xF) == 0xF)
  {
    if (a1 + a2 >= (unint64_t)v4)
    {
      CFAllocatorRef v7 = v4 + 1;
      char v8 = *v4;
      if ((*v4 & 0xF0) == 0x10)
      {
        unsigned int v9 = v8 & 0xF;
        uint64_t v10 = 1 << (v8 & 0xF);
        if (!__CFADD__(v10, v7) && (unint64_t)&v4[v10] <= a1 + a2)
        {
          switch((char)v10)
          {
            case 1:
              unint64_t v6 = *v7;
              goto LABEL_20;
            case 2:
              unint64_t v6 = __rev16(*(unsigned __int16 *)(v4 + 1));
              goto LABEL_20;
            case 4:
              unint64_t v6 = bswap32(*(_DWORD *)(v4 + 1));
              goto LABEL_20;
            case 8:
              unint64_t v6 = bswap64(*(void *)(v4 + 1));
              goto LABEL_19;
            default:
              if (v9 > 7)
              {
                unint64_t v6 = 0;
LABEL_20:
                unsigned int v4 = &v7[v10];
                goto LABEL_21;
              }
              unint64_t v6 = 0;
              if ((v10 & 0xFE) != 0) {
                uint64_t v11 = v10;
              }
              else {
                uint64_t v11 = 1;
              }
              uint64_t v12 = v7;
              do
              {
                unsigned int v13 = *v12++;
                unint64_t v6 = v13 | (v6 << 8);
                --v11;
              }
              while (v11);
LABEL_19:
              if ((v6 & 0x8000000000000000) == 0) {
                goto LABEL_20;
              }
              break;
          }
        }
      }
    }
    return 0;
  }
LABEL_21:
  unint64_t v14 = (unint64_t)&v4[v6 - 1];
  BOOL v16 = ~v6 >= v14;
  unint64_t v15 = v6 + v14;
  BOOL v16 = v16 && ~v6 >= (unint64_t)v4;
  if (!v16 || a1 + a2 < v15) {
    return 0;
  }
  return (*(uint64_t (**)(uint64_t, unsigned __int8 *))(a4 + 16))(a4, v4);
}

unint64_t *__CFArrayCreateTransfer(__objc2_class **a1, const void *a2, unint64_t a3)
{
  size_t v5 = 8 * a3;
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(a1, 0x13uLL, (8 * a3 + 32), 0);
  CFAllocatorRef v7 = Instance;
  if (Instance)
  {
    unint64_t v8 = atomic_load(Instance + 1);
    unint64_t v9 = v8;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v9, v8 & 0xFFFFFFFFFFFFFF80 | 4);
      BOOL v10 = v9 == v8;
      unint64_t v8 = v9;
    }
    while (!v10);
    Instance[2] = a3;
    char v11 = atomic_load(Instance + 1);
    int v12 = v11 & 3;
    if (v12 == 2)
    {
      unint64_t v15 = (unint64_t *)(Instance[5] + 8 * *(void *)Instance[5] + 16);
    }
    else if (v12)
    {
      unint64_t v15 = 0;
    }
    else
    {
      char v13 = atomic_load(Instance + 1);
      BOOL v10 = (~v13 & 0xC) == 0;
      uint64_t v14 = 6;
      if (v10) {
        uint64_t v14 = 11;
      }
      unint64_t v15 = &Instance[v14];
    }
    memmove(v15, a2, v5);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return v7;
}

char *typeStringRetain(int a1, char *__s)
{
  uint64_t v2 = __s;
  size_t v3 = strlen(__s) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    unsigned int v4 = malloc_type_malloc(v3, 0xE9BF9616uLL);
    memcpy(v4, v2, v3);
    return (char *)v4;
  }
  return v2;
}

uint64_t __CFRunLoopSourceEqual(unint64_t *a1, unint64_t *a2)
{
  if (a1 == a2) {
    return 1;
  }
  int v2 = atomic_load(a1 + 1);
  int v3 = atomic_load(a2 + 1);
  if (((v3 ^ v2) & 8) != 0) {
    return 0;
  }
  if (a1[10] != a2[10]) {
    return 0;
  }
  unint64_t v4 = a1[13];
  if (v4 != a2[13]) {
    return 0;
  }
  if (a1[19] != a2[19]) {
    return 0;
  }
  size_t v5 = (uint64_t (*)(unint64_t, unint64_t))a1[18];
  if (v5 != (uint64_t (*)(unint64_t, unint64_t))a2[18]) {
    return 0;
  }
  if (v4 == 1)
  {
    unint64_t v7 = a1[21];
    unint64_t v8 = a2[21];
LABEL_13:
    if (v7 != v8) {
      return 0;
    }
    goto LABEL_14;
  }
  if (!v4)
  {
    unint64_t v7 = a1[22];
    unint64_t v8 = a2[22];
    goto LABEL_13;
  }
LABEL_14:
  unint64_t v9 = a1[14];
  unint64_t v10 = a2[14];
  if (v5) {
    return v5(v9, v10);
  }
  else {
    return v9 == v10;
  }
}

BOOL __CFisEqualUUIDBytes(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL _cfmp_equal(int *a1, uint64_t a2)
{
  if (a1 == (int *)a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    int v4 = *a1;
    int v5 = *((unsigned __int8 *)a1 + 4);
    return v4 == *(_DWORD *)a2 && v5 == *(unsigned __int8 *)(a2 + 4);
  }
  return result;
}

uint64_t CFBasicHashUnsuppressRC(uint64_t result)
{
  *(void *)(result + 32) &= ~2uLL;
  return result;
}

uint64_t CFBasicHashSuppressRC(uint64_t result)
{
  *(void *)(result + 32) |= 2uLL;
  return result;
}

uint64_t _cfmp_deallocation_record_retain(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 5)) {
    _cfmp_deallocation_record_retain_cold_1();
  }
  *(unsigned char *)(a2 + 5) |= 1u;
  return a2;
}

void *blockCopyValueCallBack(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

BOOL __CFMachPortEqual(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
}

uint64_t _CFBurstTrieRetainWrapper(uint64_t a1, uint64_t a2)
{
  return CFBurstTrieRetain(a2);
}

BOOL __CFCanonicalNameCompare(const char *a1, const char *a2)
{
  return strncasecmp_l(a1, a2, 0x100uLL, 0) == 0;
}

uint64_t __CFCanonicalNameHash(char *a1)
{
  char v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = 1;
  do
  {
    v2 += v1 + 32 * ((v1 - 65) < 0x1Au);
    char v1 = a1[v3];
    uint64_t v4 = v3 + 1;
    if (!v1) {
      break;
    }
  }
  while (v3++ < 256);
  return (v4 - 1) * v2;
}

Boolean CFStringIsEncodingAvailable(CFStringEncoding encoding)
{
  uint64_t v1 = *(void *)&encoding;
  Boolean result = 1;
  if ((int)v1 > 134217983)
  {
    if ((int)v1 > 335544575)
    {
      if (v1 == 335544576 || v1 == 402653440) {
        return result;
      }
      int v3 = 469762304;
    }
    else
    {
      if (v1 == 134217984 || v1 == 201326848) {
        return result;
      }
      int v3 = 268435712;
    }
    if (v1 == v3) {
      return result;
    }
    return CFStringEncodingIsValidEncoding(v1);
  }
  if ((int)v1 <= 1535)
  {
    if (!v1 || v1 == 256 || v1 == 1280) {
      return result;
    }
    return CFStringEncodingIsValidEncoding(v1);
  }
  if (v1 != 1536 && v1 != 2817 && v1 != 3071) {
    return CFStringEncodingIsValidEncoding(v1);
  }
  return result;
}

CFIndex __CFStringLength(uint64_t a1)
{
  return CFStringGetLength(*(CFStringRef *)(a1 + 72));
}

uint64_t __CFStringAccess(uint64_t a1, uint64_t a2, int a3)
{
  return doAccess(a1, a2, a3, *(CFStringRef *)(a1 + 72));
}

BOOL __NSCacheKeyEqual(const void *a1, const void *a2)
{
  return CFEqual(a1, a2) != 0;
}

uint64_t doAccess(uint64_t a1, uint64_t a2, int a3, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v9 = Length;
  if (Length >= a2) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = Length;
  }
  if (a2 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  if (a3)
  {
    if (v11 >= v12 || (uint64_t v13 = *(void *)(a1 + 32), v11 < v13))
    {
      if (v11 >= Length && v12 == Length)
      {
        uint64_t result = 0;
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
        return result;
      }
      goto LABEL_21;
    }
    int v17 = v11 - v13;
LABEL_30:
    *(_DWORD *)(a1 + 40) = v17;
    return 1;
  }
  if (v11 <= v12)
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (v11 > v16)
    {
      int v17 = v11 - v16;
      goto LABEL_30;
    }
  }
  if (!v11 && !*(void *)(a1 + 32))
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 40) = 0;
    return result;
  }
LABEL_21:
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
  *(void *)(a1 + 48) = CharactersPtr;
  if (CharactersPtr)
  {
    if (v11 > 2147483646)
    {
      uint64_t v19 = v11 - 0x7FFFFFFF;
      if (a3)
      {
        uint64_t v19 = v10;
        int v32 = 0;
      }
      else
      {
        int v32 = 0x7FFFFFFF;
      }
      *(void *)(a1 + 32) = v19;
      *(_DWORD *)(a1 + 40) = v32;
      *(void *)(a1 + 48) = &CharactersPtr[v19];
    }
    else
    {
      uint64_t v19 = 0;
      *(void *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 40) = v11;
    }
    int v20 = v9 - v19;
    if (v9 - v19 > 2147483646)
    {
      int v20 = 0x7FFFFFFF;
      *(void *)(a1 + 16) = v19 + 0x7FFFFFFF;
      *(_DWORD *)(a1 + 44) = 0x7FFFFFFF;
    }
    else
    {
      *(void *)(a1 + 16) = v9;
      *(_DWORD *)(a1 + 44) = v20;
    }
LABEL_57:
    *(_DWORD *)(a1 + 28) = v20;
    return 1;
  }
  uint64_t result = *(void *)(a1 + 88);
  if (result)
  {
    if (a3)
    {
      uint64_t v21 = *(void *)(a1 + 16);
      uint64_t v22 = v11;
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = v11;
    }
    uint64_t v23 = v22 - v21;
    if (v23 < 0) {
      uint64_t v23 = -v23;
    }
    if ((unint64_t)v23 <= 0x10)
    {
      unsigned int v24 = *(_DWORD *)(a1 + 124);
      if (v24 <= 4) {
        *(_DWORD *)(a1 + 124) = ++v24;
      }
      goto LABEL_40;
    }
LABEL_39:
    unsigned int v24 = 0;
    *(_DWORD *)(a1 + 124) = 0;
LABEL_40:
    *(void *)(a1 + 48) = result;
    uint64_t v25 = (int)v24;
    if (a3)
    {
      *(void *)(a1 + 32) = v11;
      uint64_t v26 = _bufferSizes[v24];
      *(void *)(a1 + 16) = v11 + v26;
      if (v11 + v26 <= v9)
      {
        if (v11 + v26 < v9)
        {
          CFIndex v9 = __pinIndex(v11 + v26, v9, theString, a3, 1);
          *(void *)(a1 + 16) = v9;
          uint64_t v11 = *(void *)(a1 + 32);
        }
        else
        {
          LODWORD(v9) = v11 + v26;
        }
      }
      else
      {
        *(void *)(a1 + 16) = v9;
      }
      int v29 = 0;
      int v30 = v9 - v11;
      int v31 = v9 - v11;
    }
    else
    {
      if (v11 >= v9) {
        CFIndex v27 = v9;
      }
      else {
        CFIndex v27 = v11;
      }
      *(void *)(a1 + 16) = v27;
      uint64_t v28 = _bufferSizes[v25];
      uint64_t v11 = v27 - v28;
      *(void *)(a1 + 32) = v27 - v28;
      if (v27 - v28 < 0)
      {
        uint64_t v11 = 0;
        *(void *)(a1 + 32) = 0;
      }
      else if (v27 != v28)
      {
        uint64_t v11 = __pinIndex(v27 - v28, v9, theString, 0, 1);
        *(void *)(a1 + 32) = v11;
        CFIndex v27 = *(void *)(a1 + 16);
      }
      int v29 = v27 - v11;
      int v30 = v29;
      int v31 = v29;
    }
    *(_DWORD *)(a1 + 40) = v29;
    *(_DWORD *)(a1 + 44) = v30;
    v33.CFIndex length = v31;
    v33.CFIndex location = v11;
    CFStringGetCharacters(theString, v33, *(UniChar **)(a1 + 48));
    int v20 = *(_DWORD *)(a1 + 44);
    goto LABEL_57;
  }
  uint64_t result = (uint64_t)malloc_type_malloc(0x400uLL, 0x1000040BDFB0063uLL);
  *(void *)(a1 + 88) = result;
  if (result) {
    goto LABEL_39;
  }
  return result;
}

CFIndex __pinIndex(CFIndex idx, CFIndex a2, CFStringRef theString, int a4, int a5)
{
  if (idx < 0) {
    return 0;
  }
  if (idx <= a2)
  {
    if (idx < a2 && idx && a5 && (CFStringGetCharacterAtIndex(theString, idx) & 0xFC00) == 0xDC00)
    {
      int v8 = CFStringGetCharacterAtIndex(theString, idx - 1) & 0xFC00;
      if (a4) {
        CFIndex v9 = idx - 1;
      }
      else {
        CFIndex v9 = idx + 1;
      }
      if (v8 == 55296) {
        return v9;
      }
      else {
        return idx;
      }
    }
    else
    {
      return idx;
    }
  }
  return a2;
}

uint64_t _CFStringCheckAndGetCharacterAtIndex(uint64_t a1, uint64_t a2, _WORD *a3)
{
  if (a2 < 0 && !dyld_program_sdk_at_least())
  {
    __int16 v17 = 0;
  }
  else
  {
    char v6 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v7 = (unsigned __int8 ***)(a1 + 16);
    if ((v6 & 0x60) != 0)
    {
      int v8 = *v7;
      if (a2 < 0) {
        return 3;
      }
    }
    else
    {
      char v9 = atomic_load((unint64_t *)(a1 + 8));
      int v8 = (unsigned __int8 **)&v7[(v9 & 5) != 4];
      if (a2 < 0) {
        return 3;
      }
    }
    char v10 = atomic_load((unint64_t *)(a1 + 8));
    if ((v10 & 5) == 4)
    {
      uint64_t v11 = (unsigned __int8 **)*(unsigned __int8 *)v8;
    }
    else
    {
      char v12 = atomic_load((unint64_t *)(a1 + 8));
      if ((v12 & 0x60) != 0) {
        uint64_t v11 = *(unsigned __int8 ***)(a1 + 24);
      }
      else {
        uint64_t v11 = *v7;
      }
    }
    if ((uint64_t)v11 <= a2) {
      return 3;
    }
    char v13 = atomic_load((unint64_t *)(a1 + 8));
    if ((v13 & 0x10) != 0)
    {
      unint64_t v15 = (unsigned __int8 *)v8 + 2 * a2;
    }
    else
    {
      unint64_t v14 = atomic_load((unint64_t *)(a1 + 8));
      unint64_t v15 = (unsigned __int8 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v8 + ((v14 >> 2) & 1) + a2));
    }
    __int16 v17 = *(_WORD *)v15;
  }
  uint64_t result = 0;
  *a3 = v17;
  return result;
}

UText *CFStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 0, a2);
}

uint64_t __CFBinaryPlistWriteOrPresize(const void *a1, const void *a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  uint64_t v42 = *(void *)off_1ECE0A5B0;
  long long __src = 0u;
  long long v41 = 0u;
  memset(v39, 0, sizeof(v39));
  char v9 = (__CFDictionary *)CFBasicHashCreate(&__kCFAllocatorSystemDefault, 0xA001u, (uint64_t *)v39);
  _CFRuntimeSetInstanceTypeIDAndIsa(v9, 0x12uLL);
  CFArrayCallBacks callBacks = *(CFArrayCallBacks *)byte_1ECE0FBC0;
  CFArrayRef v10 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
  CFSetCallBacks v37 = *(CFSetCallBacks *)byte_1ECE0FBE8;
  CFSetRef v11 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v37);
  _flattenPlist(a1, v10, v9, v11);
  CFRelease(v11);
  CFIndex Count = CFArrayGetCount(v10);
  uint64_t Typed = (unint64_t *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 557344345, 0);
  unint64_t v14 = (int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8208, 0x10E0040DB85EAC6, 0);
  *(void *)unint64_t v14 = a2;
  *((void *)v14 + 1) = 0;
  *((void *)v14 + 2) = 0;
  *((void *)v14 + 3) = 0;
  if (a2)
  {
    CFTypeID v15 = CFGetTypeID(a2);
    BOOL v16 = v15 == CFDataGetTypeID();
  }
  else
  {
    BOOL v16 = 1;
  }
  *((unsigned char *)v14 + 44) = v16;
  *((void *)v14 + 4) = 0;
  v14[10] = 0;
  bufferWrite((uint64_t)v14, "bplist00", 8, a5);
  *(void *)&long long __src = 0;
  *((void *)&__src + 1) = bswap64(Count);
  *(void *)&long long v41 = 0;
  unsigned __int8 v17 = 0;
  if (!Count) {
    goto LABEL_12;
  }
  uint64_t v18 = -1;
  do
  {
    ++v17;
    BOOL v20 = (Count & (v18 << 8)) == 0;
    v18 <<= 8;
  }
  while (!v20);
  if (v17 <= 7u)
  {
LABEL_12:
    while (1)
    {
      unsigned int v19 = v17;
      BOOL v20 = v17 > 4u || ((1 << v17) & 0x16) == 0;
      if (!v20) {
        break;
      }
      ++v17;
      if (v19 >= 7)
      {
        unsigned __int8 v17 = 8;
        break;
      }
    }
  }
  BYTE7(__src) = v17;
  if (Count < 1)
  {
LABEL_20:
    CFRelease(v9);
    CFRelease(v10);
    unint64_t v23 = *((void *)v14 + 4) + v14[10];
    *((void *)&v41 + 1) = bswap64(v23);
    unsigned __int8 v24 = 0;
    if (!v23) {
      goto LABEL_28;
    }
    uint64_t v25 = -1;
    do
    {
      ++v24;
      BOOL v20 = (v23 & (v25 << 8)) == 0;
      v25 <<= 8;
    }
    while (!v20);
    if (v24 <= 7u)
    {
LABEL_28:
      while (1)
      {
        unsigned int v26 = v24;
        if (v24 <= 4u && ((1 << v24) & 0x16) != 0) {
          break;
        }
        ++v24;
        if (v26 >= 7)
        {
          unsigned __int8 v24 = 8;
          break;
        }
      }
    }
    BYTE6(__src) = v24;
    if (Count >= 1)
    {
      uint64_t v28 = Typed;
      CFIndex v29 = Count;
      do
      {
        unint64_t v30 = *v28++;
        unint64_t v36 = bswap64(v30);
        bufferWrite((uint64_t)v14, (unsigned char *)&v36 - v24 + 8, v24, a5);
        --v29;
      }
      while (v29);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    bufferWrite((uint64_t)v14, &__src, 32, a5);
    writeBytes((uint64_t)v14, (const UInt8 *)v14 + 45, v14[10], a5);
    v14[10] = 0;
    int v31 = (const void *)*((void *)v14 + 3);
    if (v31)
    {
      if (a6)
      {
        uint64_t v32 = 0;
        *a6 = v31;
      }
      else
      {
        CFRelease(v31);
        uint64_t v32 = 0;
      }
    }
    else
    {
      uint64_t v32 = v23 + Count * v24 + 32;
    }
    uint64_t Typed = (unint64_t *)v14;
  }
  else
  {
    CFIndex v21 = 0;
    while (1)
    {
      Typed[v21] = *((void *)v14 + 4) + v14[10];
      ValueAtIndex = CFArrayGetValueAtIndex(v10, v21);
      if (!_appendObject((uint64_t)v14, (uint64_t)ValueAtIndex)) {
        break;
      }
      if (Count == ++v21) {
        goto LABEL_20;
      }
    }
    CFRelease(v9);
    CFRelease(v10);
    CFRange v33 = (const void *)*((void *)v14 + 3);
    if (a6)
    {
      if (v33) {
        *a6 = v33;
      }
    }
    else if (v33)
    {
      CFRelease(v33);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
    uint64_t v32 = 0;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v32;
}

uint64_t _CFArrayCheckAndGetValueAtIndex(unint64_t *a1, int64_t a2, unsigned char *a3)
{
  if (a2 < 0 || (uint64_t)a1[2] <= a2)
  {
    if (a3) {
      *a3 = 1;
    }
    return -1;
  }
  else
  {
    atomic_load(a1 + 1);
    char v3 = atomic_load(a1 + 1);
    if ((v3 & 3) != 0)
    {
      uint64_t v4 = a1[5] + 8 * *(void *)a1[5] + 16;
    }
    else
    {
      char v6 = atomic_load(a1 + 1);
      BOOL v7 = (~v6 & 0xC) == 0;
      uint64_t v8 = 6;
      if (v7) {
        uint64_t v8 = 11;
      }
      uint64_t v4 = (uint64_t)&a1[v8];
    }
    return *(void *)(v4 + 8 * a2);
  }
}

uint64_t _appendObject(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  CFDictionaryRef v8 = v7;
  CFDateRef v10 = v9;
  uint64_t v11 = v2;
  uint64_t v78 = *(void *)off_1ECE0A5B0;
  int64_t v12 = CFGetTypeID(v9);
  uint64_t v13 = 0;
  if (v12 > 40)
  {
    if (v12 == 41)
    {
      unsigned int v34 = _CFKeyedArchiverUIDGetValue((uint64_t)v10);
      uint64_t v35 = 4;
      if (v34 < 0x10000) {
        uint64_t v35 = 2;
      }
      if (v34 < 0x100) {
        uint64_t v36 = 1;
      }
      else {
        uint64_t v36 = v35;
      }
      v43.i8[0] = (v36 - 1) | 0x80;
      keys[0] = (void *)bswap64(v34);
      uint64_t v13 = 1;
      bufferWrite(v11, &v43, 1, v4);
      uint64_t v19 = v11;
      uint64_t v18 = (void **)((char *)&keys[1] - v36);
      int64_t v20 = v36;
    }
    else
    {
      if (v12 != 42) {
        return v13;
      }
      v43.i8[0] = 51;
      uint64_t v13 = 1;
      bufferWrite(v11, &v43, 1, v4);
      keys[0] = (void *)bswap64(COERCE_UNSIGNED_INT64(CFDateGetAbsoluteTime(v10)));
      uint64_t v18 = keys;
      uint64_t v19 = v11;
      int64_t v20 = 8;
    }
    bufferWrite(v19, v18, v20, v4);
    return v13;
  }
  switch(v12)
  {
    case 18:
      CFIndex Count = CFDictionaryGetCount(v10);
      int64_t v15 = Count;
      char v16 = 15;
      if (Count < 15) {
        char v16 = Count;
      }
      LOBYTE(valuePtr) = v16 | 0xD0;
      bufferWrite(v11, &valuePtr, 1, v4);
      if (v15 < 15)
      {
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        uint64_t Typed = keys;
        *(_OWORD *)keys = 0u;
        long long v47 = 0u;
        CFDictionaryGetKeysAndValues(v10, (const void **)keys, (const void **)&keys[v15]);
        if (v15 < 1) {
          goto LABEL_69;
        }
      }
      else
      {
        _appendInt(v11, v15, v4);
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)keys = 0u;
        long long v47 = 0u;
        if ((unint64_t)v15 >= 0x101) {
          uint64_t Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * v15, 0xC0040B8AA526DLL, 0);
        }
        else {
          uint64_t Typed = keys;
        }
        CFDictionaryGetKeysAndValues(v10, (const void **)Typed, (const void **)&Typed[v15]);
      }
      uint64_t v37 = 0;
      if (2 * v15 <= 1) {
        uint64_t v38 = 1;
      }
      else {
        uint64_t v38 = 2 * v15;
      }
      do
      {
        uint64_t v39 = Typed[v37];
        if (v8)
        {
          v43.i32[0] = 0;
          v43.i32[0] = bswap32(CFDictionaryGetValue(v8, v39));
          bufferWrite(v11, &v43.i8[-v6 + 4], v6, v4);
        }
        else if (!_appendObject(v11, v39, 0, v6, v4))
        {
          goto LABEL_65;
        }
        ++v37;
      }
      while (v38 != v37);
      goto LABEL_63;
    case 19:
      CFIndex v21 = CFArrayGetCount(v10);
      uint64_t v22 = v21;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      char v23 = 15;
      *(_OWORD *)keys = 0u;
      long long v47 = 0u;
      if (v21 < 15) {
        char v23 = v21;
      }
      LOBYTE(valuePtr) = v23 | 0xA0;
      bufferWrite(v11, &valuePtr, 1, v4);
      if (v22 < 15)
      {
        uint64_t Typed = keys;
        v79.CFIndex location = 0;
        v79.CFIndex length = v22;
        CFArrayGetValues(v10, v79, (const void **)keys);
        if (v22 < 1) {
          goto LABEL_69;
        }
      }
      else
      {
        _appendInt(v11, v22, v4);
        if ((unint64_t)v22 >= 0x101) {
          uint64_t Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v22, 0xC0040B8AA526DLL, 0);
        }
        else {
          uint64_t Typed = keys;
        }
        v80.CFIndex location = 0;
        v80.CFIndex length = v22;
        CFArrayGetValues(v10, v80, (const void **)Typed);
      }
      uint64_t v40 = 0;
      while (2)
      {
        long long v41 = Typed[v40];
        if (v8)
        {
          v43.i32[0] = 0;
          v43.i32[0] = bswap32(CFDictionaryGetValue(v8, v41));
          bufferWrite(v11, &v43.i8[-v6 + 4], v6, v4);
          goto LABEL_62;
        }
        if (_appendObject(v11, v41, 0, v6, v4))
        {
LABEL_62:
          if (v22 == ++v40)
          {
LABEL_63:
            if (Typed != keys) {
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
            }
            goto LABEL_69;
          }
          continue;
        }
        break;
      }
LABEL_65:
      if (Typed != keys) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      }
      return 0;
    case 20:
      CFIndex Length = CFDataGetLength(v10);
      int64_t v25 = Length;
      char v26 = 15;
      if (Length < 15) {
        char v26 = Length;
      }
      LOBYTE(keys[0]) = v26 | 0x40;
      bufferWrite(v11, keys, 1, v4);
      if (v25 >= 15) {
        _appendInt(v11, v25, v4);
      }
      BytePtr = (int8x16_t *)CFDataGetBytePtr(v10);
      uint64_t v28 = v11;
      int64_t v29 = v25;
      goto LABEL_45;
    case 21:
      if (CFBooleanGetValue(v10)) {
        char v30 = 9;
      }
      else {
        char v30 = 8;
      }
      LOBYTE(keys[0]) = v30;
      uint64_t v13 = 1;
      bufferWrite(v11, keys, 1, v4);
      return v13;
    case 22:
      unint64_t valuePtr = 0;
      if (CFNumberIsFloatType(v10))
      {
        keys[0] = 0;
        unsigned int __src = 0;
        if (CFNumberGetByteSize(v10) > 4)
        {
          v43.i64[0] = 0;
          CFNumberGetValue(v10, kCFNumberFloat64Type, &v43);
          keys[0] = (void *)bswap64(v43.u64[0]);
          p_src = keys;
          char v32 = 35;
          uint64_t v33 = 8;
        }
        else
        {
          v43.i32[0] = 0;
          CFNumberGetValue(v10, kCFNumberFloat32Type, &v43);
          unsigned int __src = bswap32(v43.u32[0]);
          p_src = (void **)&__src;
          char v32 = 34;
          uint64_t v33 = 4;
        }
        v43.i8[0] = v32;
        bufferWrite(v11, &v43, 1, v4);
        uint64_t v28 = v11;
        BytePtr = (int8x16_t *)p_src;
        int64_t v29 = v33;
        goto LABEL_45;
      }
      if (_CFNumberGetType2((unint64_t *)v10) == 17)
      {
        keys[0] = 0;
        keys[1] = 0;
        CFNumberGetValue(v10, kCFNumberMaxType|kCFNumberSInt8Type, keys);
        int8x16_t v43 = vrev64q_s8(*(int8x16_t *)keys);
        LOBYTE(__src) = 20;
        bufferWrite(v11, &__src, 1, v4);
        BytePtr = &v43;
        uint64_t v28 = v11;
        int64_t v29 = 16;
LABEL_45:
        bufferWrite(v28, BytePtr, v29, v4);
        goto LABEL_69;
      }
      CFNumberGetValue(v10, kCFNumberSInt64Type, &valuePtr);
      _appendInt(v11, valuePtr, v4);
LABEL_69:
      uint64_t v13 = 1;
      break;
    default:
      if (v12 != 7) {
        return v13;
      }
      _appendString(v11, (CFStringRef)v10, v4);
      goto LABEL_69;
  }
  return v13;
}

void bufferWrite(uint64_t a1, unsigned char *__src, int64_t a3, int a4)
{
  if (a3)
  {
    if (a3 < 8160)
    {
      int v8 = *(_DWORD *)(a1 + 40);
      if (8160 - v8 >= a3) {
        size_t v9 = a3;
      }
      else {
        size_t v9 = 8160 - v8;
      }
      if (!a4 && (*(void *)a1 || *(void *)(a1 + 8)))
      {
        uint64_t v10 = v8;
        switch(v9)
        {
          case 1uLL:
            goto LABEL_16;
          case 2uLL:
            goto LABEL_15;
          case 3uLL:
            goto LABEL_14;
          case 4uLL:
            *(unsigned char *)(v8 + a1 + 48) = __src[3];
            int v8 = *(_DWORD *)(a1 + 40);
LABEL_14:
            *(unsigned char *)(a1 + v8 + 47) = __src[2];
            int v8 = *(_DWORD *)(a1 + 40);
LABEL_15:
            *(unsigned char *)(a1 + v8 + 46) = __src[1];
            uint64_t v10 = *(int *)(a1 + 40);
LABEL_16:
            *(unsigned char *)(a1 + v10 + 45) = *__src;
            break;
          default:
            memmove((void *)(a1 + v8 + 45), __src, v9);
            break;
        }
      }
      int v11 = *(_DWORD *)(a1 + 40) + v9;
      *(_DWORD *)(a1 + 40) = v11;
      if (v11 == 8160)
      {
        writeBytes(a1, (const UInt8 *)(a1 + 45), 8160, a4);
        if (!a4 && (*(void *)a1 || *(void *)(a1 + 8))) {
          memmove((void *)(a1 + 45), &__src[v9], a3 - v9);
        }
        *(_DWORD *)(a1 + 40) = a3 - v9;
      }
    }
    else
    {
      writeBytes(a1, (const UInt8 *)(a1 + 45), *(int *)(a1 + 40), a4);
      *(_DWORD *)(a1 + 40) = 0;
      writeBytes(a1, __src, a3, a4);
    }
  }
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict getObjects:values andKeys:keys];
  }
  else
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    CFBasicHashGetElements((uint64_t)theDict, Count, (uint64_t)values, (uint64_t)keys);
  }
}

void _appendString(uint64_t a1, CFStringRef theString, int a3)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(theString);
  if (Length >= 1025) {
    uint64_t Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, Length, 3515625951, 0);
  }
  else {
    uint64_t Typed = buffer;
  }
  usedBufLeuint64_t n = 0;
  v18.CFIndex location = 0;
  v18.CFIndex length = Length;
  if (CFStringGetBytes(theString, v18, 0x600u, 0, 0, Typed, Length, &usedBufLen) == Length)
  {
    char v8 = usedBufLen;
    if (usedBufLen >= 15) {
      char v8 = 15;
    }
    char __src = v8 | 0x50;
    bufferWrite(a1, &__src, 1, a3);
    CFIndex v9 = usedBufLen;
    if (usedBufLen >= 15)
    {
      _appendInt(a1, usedBufLen, a3);
      CFIndex v9 = usedBufLen;
    }
    bufferWrite(a1, Typed, v9, a3);
  }
  else
  {
    char v10 = 15;
    if (Length < 15) {
      char v10 = Length;
    }
    char __src = v10 | 0x60;
    bufferWrite(a1, &__src, 1, a3);
    if (Length >= 15) {
      _appendInt(a1, Length, a3);
    }
    int64_t v11 = 2 * Length;
    int64_t v12 = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * Length, 0x1000040BDFB0063, 0);
    v19.CFIndex location = 0;
    v19.CFIndex length = Length;
    CFStringGetCharacters(theString, v19, v12);
    if (Length >= 1)
    {
      uint64_t v13 = v12;
      do
      {
        *uint64_t v13 = bswap32(*v13) >> 16;
        ++v13;
        --Length;
      }
      while (Length);
    }
    bufferWrite(a1, v12, v11, a3);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
  }
  if (Typed != buffer) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  if (CF_IS_OBJC(0x15uLL, (unint64_t)BOOLean)) {
    return [(__CFBoolean *)BOOLean BOOLValue];
  }
  else {
    return &__kCFBooleanTrue == (__objc2_class **)BOOLean;
  }
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return ((unsigned __int16)__CFNumberTypeTable[CFNumberGetType(number)] >> 5) & 1;
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  if (((unint64_t)number & 0x8000000000000000) != 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)number & 0xC000000000000007) == 0) {
      uint64_t v3 = 0;
    }
    unint64_t v4 = v3 ^ (unint64_t)number;
    unint64_t v5 = (v3 ^ (unint64_t)number) & 7;
    while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v2))
    {
      if (++v2 == 7) {
        goto LABEL_15;
      }
    }
    if (v2 == 3)
    {
      uint64_t v6 = 0;
      while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v6))
      {
        if (++v6 == 7) {
          goto LABEL_34;
        }
      }
      if (v6 != 3)
      {
LABEL_34:
        LOBYTE(v12) = atomic_load((unint64_t *)number + 1);
        return __CFNumberCanonicalTypes[v12 & 7];
      }
      uint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7) {
        uint64_t v11 = 0xFFFFFFFFFFFFFLL;
      }
      unint64_t v12 = v11 & (v4 >> 3);
      return __CFNumberCanonicalTypes[v12 & 7];
    }
LABEL_15:
    if (CF_IS_OBJC(0x16uLL, (unint64_t)number)) {
      goto LABEL_16;
    }
    uint64_t v8 = 0;
    while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v8))
    {
      if (++v8 == 7) {
        goto LABEL_25;
      }
    }
    if (v8 == 3)
    {
      uint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7) {
        uint64_t v9 = 0xFFFFFFFFFFFFFLL;
      }
      unint64_t v10 = v9 & (v4 >> 3);
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  if (!CF_IS_OBJC(0x16uLL, (unint64_t)number))
  {
LABEL_25:
    LOBYTE(v10) = atomic_load((unint64_t *)number + 1);
LABEL_26:
    CFNumberType result = __CFNumberCanonicalTypes[v10 & 7];
    goto LABEL_27;
  }
LABEL_16:
  CFNumberType result = [(__CFNumber *)number _cfNumberType];
LABEL_27:
  if (result == (kCFNumberMaxType|kCFNumberSInt8Type)) {
    return 4;
  }
  return result;
}

uint64_t _CFNumberGetType2(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
      uint64_t v3 = 0;
    }
    unint64_t v4 = v3 ^ (unint64_t)a1;
    uint64_t v5 = (v3 ^ (unint64_t)a1) & 7;
    while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v2))
    {
      if (++v2 == 7) {
        goto LABEL_15;
      }
    }
    if (v2 == 3)
    {
      uint64_t v6 = 0;
      while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v6))
      {
        if (++v6 == 7) {
          goto LABEL_27;
        }
      }
      goto LABEL_23;
    }
LABEL_15:
    if (CF_IS_OBJC(0x16uLL, (unint64_t)a1)) {
      goto LABEL_16;
    }
    uint64_t v6 = 0;
    while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v6))
    {
      if (++v6 == 7) {
        goto LABEL_27;
      }
    }
LABEL_23:
    if (v6 == 3)
    {
      uint64_t v8 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7) {
        uint64_t v8 = 0xFFFFFFFFFFFFFLL;
      }
      uint64_t v9 = v8 & (v4 >> 3);
      return __CFNumberCanonicalTypes[v9 & 7];
    }
LABEL_27:
    LOBYTE(v9) = atomic_load(a1 + 1);
    return __CFNumberCanonicalTypes[v9 & 7];
  }
  if (!CF_IS_OBJC(0x16uLL, (unint64_t)a1)) {
    goto LABEL_27;
  }
LABEL_16:

  return [a1 _cfNumberType];
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  uint64_t v3 = valuePtr;
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (((unint64_t)number & 0x8000000000000000) == 0) {
    goto LABEL_18;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)off_1ECE0A6F0;
  if ((~(unint64_t)number & 0xC000000000000007) == 0) {
    uint64_t v7 = 0;
  }
  unint64_t v8 = v7 ^ (unint64_t)number;
  unint64_t v9 = v8 & 7;
  while (v9 != *((unsigned __int8 *)off_1ECE0A6E0 + v6))
  {
    if (++v6 == 7) {
      goto LABEL_18;
    }
  }
  if (v6 == 3)
  {
    if (!valuePtr) {
      unint64_t valuePtr = v16;
    }
    if (v9 == 7) {
      uint64_t v10 = (uint64_t)(v8 << 9) >> 12;
    }
    else {
      uint64_t v10 = (uint64_t)(2 * v8) >> 4;
    }
    BOOL v11 = (v8 & 0x40) == 0;
    char v12 = 6;
    if (v11) {
      char v12 = 4;
    }
    uint64_t v13 = v10 >> v12;
    switch(__CFNumberTypeTable[theType] & 0x1F)
    {
      case 1:
        *(unsigned char *)unint64_t valuePtr = v13;
        break;
      case 2:
        *(_WORD *)unint64_t valuePtr = v13;
        break;
      case 3:
        *(_DWORD *)unint64_t valuePtr = v13;
        break;
      case 4:
        *(void *)unint64_t valuePtr = v13;
        break;
      case 5:
        *(float *)unint64_t valuePtr = (float)v13;
        break;
      case 6:
        *(double *)unint64_t valuePtr = (double)v13;
        break;
      default:
        return __CFNumberGetValueCompat((uint64_t)number, theType, (uint64_t)valuePtr);
    }
    return 1;
  }
  else
  {
LABEL_18:
    if (CF_IS_OBJC(0x16uLL, (unint64_t)number))
    {
      uint64_t v14 = __CFNumberTypeTable[theType] & 0x1FLL;
      return [(__CFNumber *)number _getValue:v3 forType:v14];
    }
    else
    {
      if (v3) {
        unint64_t valuePtr = v3;
      }
      else {
        unint64_t valuePtr = v16;
      }
      return __CFNumberGetValueCompat((uint64_t)number, theType, (uint64_t)valuePtr);
    }
  }
}

uint64_t __CFNumberGetValueCompat(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v70[1] = *(void *)off_1ECE0A5B0;
  if ((a1 & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v4 = 0;
  }
  unint64_t v5 = v4 ^ a1;
  uint64_t v6 = v5 & 7;
  while (v6 != *((unsigned __int8 *)off_1ECE0A6E0 + v3))
  {
    if (++v3 == 7) {
      goto LABEL_12;
    }
  }
  if (v3 == 3)
  {
    uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7) {
      uint64_t v7 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v8 = v7 & (v5 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(a1 + 8));
  }
  uint64_t v9 = __CFNumberTypeTable[a2] & 0x1FLL;
  uint64_t v10 = __CFNumberCanonicalTypes[v8 & 7];
  BOOL v11 = (unint64_t *)(a1 + 16);
  v70[0] = 0;
  if (a1 < 0)
  {
    uint64_t v12 = 0;
    uint64_t v13 = *(void *)off_1ECE0A6F0;
    if ((~a1 & 0xC000000000000007) == 0) {
      uint64_t v13 = 0;
    }
    uint64_t v14 = v13 ^ a1;
    uint64_t v15 = v14 & 7;
    while (v15 != *((unsigned __int8 *)off_1ECE0A6E0 + v12))
    {
      if (++v12 == 7) {
        goto LABEL_28;
      }
    }
    if (v12 == 3)
    {
      uint64_t v16 = v14 << 9 >> 12;
      if (v15 != 7) {
        uint64_t v16 = (2 * v14) >> 4;
      }
      char v17 = 6;
      if ((v14 & 0x40) == 0) {
        char v17 = 4;
      }
      v70[0] = v16 >> v17;
      if ((unint64_t)(v10 - 5) < 2) {
        uint64_t v10 = 4;
      }
      BOOL v11 = v70;
    }
  }
LABEL_28:
  uint64_t result = 0;
  switch(v9)
  {
    case 1:
      __int16 v19 = __CFNumberTypeTable[v10];
      if ((v19 & 0x20) == 0)
      {
        if ((v19 & 0x40) == 0)
        {
          double v20 = *(double *)v11;
          *(unsigned char *)a3 = *v11;
          int v21 = _CFExecutableLinkedOnOrAfter(6uLL);
          BOOL v22 = *(void *)&v20 == SLOBYTE(v20);
          BOOL v23 = *(void *)&v20 >= 0x100uLL;
          goto LABEL_35;
        }
        unint64_t v50 = v11[1];
        *(unsigned char *)a3 = v50;
        return v50 == (char)v50;
      }
      if ((v19 & 0x40) == 0)
      {
        float v37 = *(float *)v11;
        int v38 = (int)*(float *)v11;
        *(unsigned char *)a3 = v38;
        goto LABEL_64;
      }
      double v48 = *(double *)v11;
      int v49 = (int)*(double *)v11;
      *(unsigned char *)a3 = v49;
      goto LABEL_102;
    case 2:
      __int16 v24 = __CFNumberTypeTable[v10];
      if ((v24 & 0x20) == 0)
      {
        if ((v24 & 0x40) != 0)
        {
          unint64_t v43 = v11[1];
          *(_WORD *)a3 = v43;
          return v43 == (__int16)v43;
        }
        unint64_t v25 = *v11;
        *(_WORD *)a3 = *v11;
        int v21 = _CFExecutableLinkedOnOrAfter(6uLL);
        BOOL v22 = v25 == (__int16)v25;
        BOOL v23 = v25 >= 0x10000;
LABEL_35:
        if (!v23) {
          BOOL v22 = 1;
        }
        return !v21 || v22;
      }
      if ((v24 & 0x40) != 0)
      {
        double v48 = *(double *)v11;
        int v49 = (int)*(double *)v11;
        *(_WORD *)a3 = v49;
        goto LABEL_102;
      }
      float v37 = *(float *)v11;
      int v38 = (int)*(float *)v11;
      *(_WORD *)a3 = v38;
LABEL_64:
      float v39 = (float)v38;
      return v37 == v39;
    case 3:
      __int16 v29 = __CFNumberTypeTable[v10];
      if ((v29 & 0x20) == 0)
      {
        if ((v29 & 0x40) != 0) {
          unint64_t v30 = v11[1];
        }
        else {
          unint64_t v30 = *v11;
        }
        *(_DWORD *)a3 = v30;
        return v30 == (int)v30;
      }
      if ((v29 & 0x40) == 0)
      {
        float v37 = *(float *)v11;
        *(_DWORD *)a3 = (int)*(float *)v11;
        float v39 = (float)(int)v37;
        return v37 == v39;
      }
      double v48 = *(double *)v11;
      int v49 = (int)*(double *)v11;
      *(_DWORD *)a3 = v49;
LABEL_102:
      double v57 = (double)v49;
      return v48 == v57;
    case 4:
      __int16 v31 = __CFNumberTypeTable[v10];
      if ((v31 & 0x20) == 0)
      {
        if ((v31 & 0x40) == 0) {
          goto LABEL_60;
        }
        unint64_t v32 = v11[1];
        goto LABEL_61;
      }
      if ((v31 & 0x40) == 0)
      {
        float v37 = *(float *)v11;
        uint64_t v40 = (uint64_t)*(float *)v11;
        *(void *)a3 = v40;
        float v39 = (float)v40;
        return v37 == v39;
      }
      double v48 = *(double *)v11;
      *(void *)a3 = (uint64_t)*(double *)v11;
      double v57 = (double)(uint64_t)v48;
      return v48 == v57;
    case 5:
      __int16 v33 = __CFNumberTypeTable[v10];
      if ((v33 & 0x20) != 0)
      {
        if ((v33 & 0x40) == 0)
        {
          *(_DWORD *)a3 = *(_DWORD *)v11;
          return 1;
        }
        double v48 = *(double *)v11;
        float v58 = *(double *)v11;
        *(float *)a3 = v58;
        double v57 = v58;
        return v48 == v57;
      }
      uint64_t v27 = *v11;
      if ((v33 & 0x40) == 0)
      {
        *(float *)a3 = (float)v27;
        uint64_t v28 = (uint64_t)(float)v27;
        return v27 == v28;
      }
      unint64_t v44 = v11[1];
      uint64_t v51 = -v27;
      if (v44) {
        uint64_t v51 = ~v27;
      }
      if (v27 < 0)
      {
        unint64_t v52 = -(uint64_t)v44;
      }
      else
      {
        uint64_t v51 = v27;
        unint64_t v52 = v44;
      }
      double v53 = -((double)v52 + (double)v51 * 1.84467441e19);
      if (v27 >= 0) {
        double v53 = (double)v52 + (double)v51 * 1.84467441e19;
      }
      float v54 = v53;
      *(float *)a3 = v54;
      if (v54 < -1.7014e38) {
        goto LABEL_97;
      }
      if (v54 >= 1.7014e38) {
        goto LABEL_117;
      }
      double v47 = v54;
      goto LABEL_112;
    case 6:
      __int16 v26 = __CFNumberTypeTable[v10];
      if ((v26 & 0x20) != 0)
      {
        if ((v26 & 0x40) == 0)
        {
          *(double *)a3 = *(float *)v11;
          return 1;
        }
LABEL_60:
        unint64_t v32 = *v11;
LABEL_61:
        *(void *)a3 = v32;
        return 1;
      }
      uint64_t v27 = *v11;
      if ((v26 & 0x40) != 0)
      {
        unint64_t v44 = v11[1];
        uint64_t v45 = -v27;
        if (v44) {
          uint64_t v45 = ~v27;
        }
        if (v27 < 0)
        {
          unint64_t v46 = -(uint64_t)v44;
        }
        else
        {
          uint64_t v45 = v27;
          unint64_t v46 = v44;
        }
        double v47 = -((double)v46 + (double)v45 * 1.84467441e19);
        if (v27 >= 0) {
          double v47 = (double)v46 + (double)v45 * 1.84467441e19;
        }
        *(double *)a3 = v47;
        if (v47 < -1.70141183e38)
        {
LABEL_97:
          unint64_t v55 = 0;
          int64_t v56 = 0x8000000000000000;
        }
        else
        {
          if (v47 >= 1.70141183e38)
          {
LABEL_117:
            int64_t v56 = 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v55 = -1;
LABEL_118:
            BOOL v63 = v56 <= v27;
            BOOL v64 = v55 > v44;
            BOOL v65 = v55 >= v44 && v63;
            return !v64 && v65;
          }
LABEL_112:
          int64_t v56 = vcvtmd_s64_f64(v47 * 5.42101086e-20);
          unint64_t v55 = (unint64_t)(v47 + floor(v47 * 5.42101086e-20) * -1.84467441e19);
        }
        if (v56 < v27) {
          return 0;
        }
        goto LABEL_118;
      }
      *(double *)a3 = (double)v27;
      uint64_t v28 = (uint64_t)(double)v27;
      return v27 == v28;
    case 17:
      __int16 v35 = __CFNumberTypeTable[v10];
      if ((v35 & 0x20) == 0)
      {
        if ((v35 & 0x40) != 0)
        {
          *(_OWORD *)a3 = *(_OWORD *)v11;
        }
        else
        {
          uint64_t v36 = *v11;
          *(void *)a3 = v36 >> 63;
          *(void *)(a3 + 8) = v36;
        }
        return 1;
      }
      if ((v35 & 0x40) != 0)
      {
        double v59 = *(double *)v11;
        if (*(double *)v11 >= -1.70141183e38)
        {
          if (v59 >= 1.70141183e38)
          {
            unint64_t v60 = -1;
            uint64_t v61 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v61 = vcvtmd_s64_f64(v59 * 5.42101086e-20);
            unint64_t v60 = (unint64_t)(v59 + floor(v59 * 5.42101086e-20) * -1.84467441e19);
          }
        }
        else
        {
          unint64_t v60 = 0;
          uint64_t v61 = 0x8000000000000000;
        }
        *(void *)a3 = v61;
        *(void *)(a3 + 8) = v60;
        uint64_t v68 = -v61;
        if (v60) {
          uint64_t v68 = ~v61;
        }
        if (v61 < 0) {
          unint64_t v60 = -(uint64_t)v60;
        }
        else {
          uint64_t v68 = v61;
        }
        double v69 = -((double)v60 + (double)v68 * 1.84467441e19);
        if (v61 >= 0) {
          double v69 = (double)v60 + (double)v68 * 1.84467441e19;
        }
        return v69 == v59;
      }
      else
      {
        float v37 = *(float *)v11;
        if (*(float *)v11 >= -1.7014e38)
        {
          if (v37 >= 1.7014e38)
          {
            unint64_t v41 = -1;
            uint64_t v42 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
            double v62 = v37 * 5.42101086e-20;
            uint64_t v42 = vcvtmd_s64_f64(v62);
            unint64_t v41 = (unint64_t)(v37 + floor(v62) * -1.84467441e19);
          }
        }
        else
        {
          unint64_t v41 = 0;
          uint64_t v42 = 0x8000000000000000;
        }
        *(void *)a3 = v42;
        *(void *)(a3 + 8) = v41;
        uint64_t v66 = -v42;
        if (v41) {
          uint64_t v66 = ~v42;
        }
        if (v42 < 0) {
          unint64_t v41 = -(uint64_t)v41;
        }
        else {
          uint64_t v66 = v42;
        }
        double v67 = -((double)v41 + (double)v66 * 1.84467441e19);
        if (v42 >= 0) {
          double v67 = (double)v41 + (double)v66 * 1.84467441e19;
        }
        float v39 = v67;
        return v37 == v39;
      }
    default:
      return result;
  }
}

void _appendInt(uint64_t a1, unint64_t a2, int a3)
{
  v7[1] = *(void *)off_1ECE0A5B0;
  if (a2 > 0xFF)
  {
    if (a2 >> 16)
    {
      if (HIDWORD(a2))
      {
        char __src = 19;
        int64_t v5 = 8;
      }
      else
      {
        char __src = 18;
        int64_t v5 = 4;
      }
    }
    else
    {
      char __src = 17;
      int64_t v5 = 2;
    }
  }
  else
  {
    char __src = 16;
    int64_t v5 = 1;
  }
  v7[0] = bswap64(a2);
  bufferWrite(a1, &__src, 1, a3);
  bufferWrite(a1, (unsigned char *)&v7[1] - v5, v5, a3);
}

uint64_t _CFKeyedArchiverUIDGetValue(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 41) {
    _CFAssertMismatchedTypeID(0x29uLL, v2);
  }
  return *(unsigned int *)(a1 + 16);
}

uint64_t _CFGetNonObjCTypeID(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    uint64_t v1 = 0;
    uint64_t v2 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
      uint64_t v2 = 0;
    }
    unint64_t v3 = v2 ^ (unint64_t)a1;
    do
    {
      if ((v3 & 7) == *((unsigned char *)off_1ECE0A6E0 + v1)) {
        break;
      }
      ++v1;
    }
    while (v1 != 7);
    unint64_t v4 = v1 | v3;
    uint64_t v5 = v1 & 7;
    int v6 = (v4 >> 55) + 8;
    if (v5 == 7) {
      int v7 = v6;
    }
    else {
      int v7 = v5;
    }
    uint64_t v8 = 22;
    switch(v7)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          _CFGetNonObjCTypeID_cold_1();
        }
        return 1;
      case 1:
        goto LABEL_18;
      case 2:
        return 7;
      case 3:
        return v8;
      case 4:
      case 5:
        return 1;
      case 6:
        return 42;
      default:
        if (v7 == 20) {
          return 1;
        }
        if (v7 == 22) {
          return 7;
        }
LABEL_18:
        uint64_t result = [a1 _cfTypeID];
        break;
    }
  }
  else
  {
    unint64_t v9 = atomic_load(a1 + 1);
    return (v9 >> 8) & 0x3FF;
  }
  return result;
}

BOOL __writeObject15(void *a1, __CFString *a2)
{
  uint64_t v58 = *(void *)off_1ECE0A5B0;
  int64_t v4 = CFGetTypeID(a2);
  int64_t v5 = v4;
  char __src = 0;
  memset(v57, 0, 512);
  if (v4 > 19)
  {
    switch(v4)
    {
      case 20:
        CFIndex Length = CFDataGetLength((CFDataRef)a2);
        unint64_t v7 = Length;
        char v8 = 15;
        if (Length < 15) {
          char v8 = Length;
        }
        char __src = v8 | 0x40;
        bufferWrite_0((uint64_t)a1, &__src, 1);
        if ((uint64_t)v7 < 15) {
          goto LABEL_69;
        }
        if (v7 <= 0x7F)
        {
          LOBYTE(valuePtr[0]) = v7 ^ 0x80;
          LOBYTE(v56) = 16;
          bufferWrite_0((uint64_t)a1, &v56, 1);
          p_usedBufLeuint64_t n = (CFIndex *)valuePtr;
LABEL_67:
          uint64_t v35 = (uint64_t)a1;
          uint64_t v36 = 1;
          goto LABEL_68;
        }
        if (!(v7 >> 15))
        {
          LOBYTE(valuePtr[0]) = 17;
          bufferWrite_0((uint64_t)a1, valuePtr, 1);
          LOBYTE(v56) = v7;
          LOBYTE(usedBufLen) = BYTE1(v7) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &v56, 1);
          p_usedBufLeuint64_t n = &usedBufLen;
          goto LABEL_67;
        }
        if (!(v7 >> 31))
        {
          LOBYTE(valuePtr[0]) = 18;
          bufferWrite_0((uint64_t)a1, valuePtr, 1);
          LOBYTE(usedBufLen) = BYTE1(v7);
          LOBYTE(v56) = v7;
          char v54 = BYTE2(v7);
          char v53 = BYTE3(v7) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &v56, 1);
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
          bufferWrite_0((uint64_t)a1, &v54, 1);
          p_usedBufLeuint64_t n = (CFIndex *)&v53;
          goto LABEL_67;
        }
        LOBYTE(valuePtr[0]) = 19;
        *(_WORD *)((char *)valuePtr + 1) = v7;
        BYTE3(valuePtr[0]) = BYTE2(v7);
        BYTE4(valuePtr[0]) = BYTE3(v7);
        BYTE5(valuePtr[0]) = BYTE4(v7);
        BYTE6(valuePtr[0]) = BYTE5(v7);
        BYTE7(valuePtr[0]) = BYTE6(v7);
        BYTE8(valuePtr[0]) = HIBYTE(v7) ^ 0x80;
        p_usedBufLeuint64_t n = (CFIndex *)valuePtr;
        uint64_t v35 = (uint64_t)a1;
        uint64_t v36 = 9;
LABEL_68:
        bufferWrite_0(v35, p_usedBufLen, v36);
LABEL_69:
        BytePtr = (CFUUIDBytes *)CFDataGetBytePtr((CFDataRef)a2);
        uint64_t v31 = (uint64_t)a1;
        uint64_t v32 = v7;
        goto LABEL_70;
      case 21:
        if (CFBooleanGetValue((CFBooleanRef)a2)) {
          char v13 = 9;
        }
        else {
          char v13 = 8;
        }
        char __src = v13;
        uint64_t v10 = 1;
        p_src = &__src;
        uint64_t v15 = (uint64_t)a1;
        uint64_t v16 = 1;
        goto LABEL_54;
      case 22:
        if (CFNumberIsFloatType((CFNumberRef)a2))
        {
          if (CFNumberGetByteSize((CFNumberRef)a2) > 4)
          {
            *(void *)&valuePtr[0] = 0;
            CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat64Type, valuePtr);
            *(void *)&long long v56 = bswap64(*(unint64_t *)&valuePtr[0]);
            char __src = 35;
            uint64_t v10 = 1;
            bufferWrite_0((uint64_t)a1, &__src, 1);
            p_src = (char *)&v56;
            uint64_t v15 = (uint64_t)a1;
            uint64_t v16 = 8;
          }
          else
          {
            LODWORD(valuePtr[0]) = 0;
            CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat32Type, valuePtr);
            LODWORD(v56) = bswap32(valuePtr[0]);
            char __src = 34;
            uint64_t v10 = 1;
            bufferWrite_0((uint64_t)a1, &__src, 1);
            p_src = (char *)&v56;
            uint64_t v15 = (uint64_t)a1;
            uint64_t v16 = 4;
          }
LABEL_54:
          bufferWrite_0(v15, p_src, v16);
          return v10;
        }
        if (_CFNumberGetType2((unint64_t *)a2) == 17)
        {
          long long v56 = 0uLL;
          CFNumberGetValue((CFNumberRef)a2, kCFNumberMaxType|kCFNumberSInt8Type, &v56);
          LOBYTE(valuePtr[0]) = 20;
          *(void *)((char *)valuePtr + 1) = *((void *)&v56 + 1);
          *(void *)((char *)valuePtr + 9) = v56 ^ 0x8000000000000000;
          BytePtr = (CFUUIDBytes *)valuePtr;
          uint64_t v31 = (uint64_t)a1;
          uint64_t v32 = 17;
          goto LABEL_70;
        }
        *(void *)&long long v56 = 0;
        CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &v56);
        int v34 = v56;
        if ((void)v56 == (char)v56)
        {
          LOBYTE(valuePtr[0]) = v56 ^ 0x80;
          LOBYTE(usedBufLen) = 16;
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
          BytePtr = (CFUUIDBytes *)valuePtr;
LABEL_115:
          uint64_t v31 = (uint64_t)a1;
          uint64_t v32 = 1;
          goto LABEL_70;
        }
        if ((void)v56 == (int)v56)
        {
          LOBYTE(valuePtr[0]) = 18;
          bufferWrite_0((uint64_t)a1, valuePtr, 1);
          char v54 = BYTE1(v34);
          LOBYTE(usedBufLen) = v34;
          char v53 = BYTE2(v34);
          char v52 = HIBYTE(v34) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
          bufferWrite_0((uint64_t)a1, &v54, 1);
          bufferWrite_0((uint64_t)a1, &v53, 1);
          BytePtr = (CFUUIDBytes *)&v52;
          goto LABEL_115;
        }
        LOBYTE(valuePtr[0]) = 19;
        *(void *)((char *)valuePtr + 1) = v56 ^ 0x8000000000000000;
        BytePtr = (CFUUIDBytes *)valuePtr;
        uint64_t v31 = (uint64_t)a1;
        uint64_t v32 = 9;
        break;
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
        goto LABEL_14;
      case 29:
        CFStringRef v17 = CFURLGetString((CFURLRef)a2);
        if (!v17) {
          return 0;
        }
        CFStringRef v18 = v17;
        CFURLRef v19 = CFURLGetBaseURL((CFURLRef)a2);
        if (v19) {
          char v20 = 13;
        }
        else {
          char v20 = 12;
        }
        char __src = v20;
        bufferWrite_0((uint64_t)a1, &__src, 1);
        if (v19) {
          __writeObject15(a1, v19);
        }
        __writeObject15(a1, v18);
        return 1;
      default:
        if (v4 == 34)
        {
          char __src = 14;
          bufferWrite_0((uint64_t)a1, &__src, 1);
          CFTypeID v25 = CFUUIDGetTypeID();
          if (CF_IS_OBJC(v25, (unint64_t)a2))
          {
            valuePtr[0] = 0uLL;
            [(__CFString *)a2 getUUIDBytes:valuePtr];
            CFUUIDBytes v49 = (CFUUIDBytes)valuePtr[0];
          }
          else
          {
            CFUUIDBytes v49 = CFUUIDGetUUIDBytes((CFUUIDRef)a2);
          }
          BytePtr = &v49;
          uint64_t v31 = (uint64_t)a1;
          uint64_t v32 = 16;
          goto LABEL_70;
        }
        if (v4 != 42) {
          goto LABEL_14;
        }
        char __src = 51;
        bufferWrite_0((uint64_t)a1, &__src, 1);
        unint64_t v48 = bswap64(COERCE_UNSIGNED_INT64(CFDateGetAbsoluteTime((CFDateRef)a2)));
        bufferWrite_0((uint64_t)a1, &v48, 8);
        return 1;
    }
    goto LABEL_70;
  }
  if (v4 != 7)
  {
    if (v4 == 16)
    {
      char __src = 0;
      uint64_t v10 = 1;
      bufferWrite_0((uint64_t)a1, &__src, 1);
      return v10;
    }
LABEL_14:
    switch(v4)
    {
      case 18:
        uint64_t Count = CFDictionaryGetCount((CFDictionaryRef)a2);
        if ((unint64_t)(2 * Count) < 0x101) {
          uint64_t Typed = (const void **)v57;
        }
        else {
          uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * Count, 0xC0040B8AA526DLL, 0);
        }
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a2, Typed, &Typed[Count]);
        char v33 = -48;
        break;
      case 17:
        uint64_t Count = CFSetGetCount((CFSetRef)a2);
        if ((unint64_t)Count < 0x101) {
          uint64_t Typed = (const void **)v57;
        }
        else {
          uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
        }
        CFSetGetValues((CFSetRef)a2, Typed);
        char v33 = -64;
        break;
      case 19:
        uint64_t Count = CFArrayGetCount((CFArrayRef)a2);
        if ((unint64_t)Count < 0x101) {
          uint64_t Typed = (const void **)v57;
        }
        else {
          uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
        }
        v60.CFIndex location = 0;
        v60.CFIndex length = Count;
        CFArrayGetValues((CFArrayRef)a2, v60, Typed);
        char v33 = -96;
        break;
      default:
        return 0;
    }
    char v37 = 15;
    if (Count < 15) {
      char v37 = Count;
    }
    char __src = v33 | v37;
    bufferWrite_0((uint64_t)a1, &__src, 1);
    if (Count < 15)
    {
      if (Count < 1)
      {
LABEL_97:
        if (Typed != (const void **)v57) {
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
        }
        return 1;
      }
      goto LABEL_92;
    }
    if ((unint64_t)Count > 0x7F)
    {
      if ((unint64_t)Count >> 15)
      {
        if ((unint64_t)Count >> 31)
        {
          LOBYTE(valuePtr[0]) = 19;
          *(_WORD *)((char *)valuePtr + 1) = Count;
          BYTE3(valuePtr[0]) = BYTE2(Count);
          BYTE4(valuePtr[0]) = BYTE3(Count);
          BYTE5(valuePtr[0]) = BYTE4(Count);
          BYTE6(valuePtr[0]) = BYTE5(Count);
          BYTE7(valuePtr[0]) = BYTE6(Count);
          BYTE8(valuePtr[0]) = HIBYTE(Count) ^ 0x80;
          int v38 = (CFIndex *)valuePtr;
          uint64_t v39 = (uint64_t)a1;
          uint64_t v40 = 9;
          goto LABEL_91;
        }
        LOBYTE(valuePtr[0]) = 18;
        bufferWrite_0((uint64_t)a1, valuePtr, 1);
        LOBYTE(usedBufLen) = BYTE1(Count);
        LOBYTE(v56) = Count;
        char v54 = BYTE2(Count);
        char v53 = BYTE3(Count) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
        bufferWrite_0((uint64_t)a1, &v54, 1);
        int v38 = (CFIndex *)&v53;
      }
      else
      {
        LOBYTE(valuePtr[0]) = 17;
        bufferWrite_0((uint64_t)a1, valuePtr, 1);
        LOBYTE(v56) = Count;
        LOBYTE(usedBufLen) = BYTE1(Count) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        int v38 = &usedBufLen;
      }
    }
    else
    {
      LOBYTE(valuePtr[0]) = Count ^ 0x80;
      LOBYTE(v56) = 16;
      bufferWrite_0((uint64_t)a1, &v56, 1);
      int v38 = (CFIndex *)valuePtr;
    }
    uint64_t v39 = (uint64_t)a1;
    uint64_t v40 = 1;
LABEL_91:
    bufferWrite_0(v39, v38, v40);
LABEL_92:
    uint64_t v41 = 0;
    if (Count << (v5 == 18) <= 1) {
      uint64_t v42 = 1;
    }
    else {
      uint64_t v42 = Count << (v5 == 18);
    }
    while (__writeObject15(a1, Typed[v41]))
    {
      if (v42 == ++v41) {
        goto LABEL_97;
      }
    }
    if (Typed != (const void **)v57) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    return 0;
  }
  CFIndex v21 = CFStringGetLength(a2);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v21, 0x8000100u);
  CFIndex v23 = MaximumSizeForEncoding;
  if (!*a1 && !a1[1])
  {
    uint64_t v32 = MaximumSizeForEncoding + 10;
    uint64_t v31 = (uint64_t)a1;
    BytePtr = 0;
LABEL_70:
    bufferWrite_0(v31, BytePtr, v32);
    return 1;
  }
  if (MaximumSizeForEncoding <= 1024)
  {
    usedBufLeuint64_t n = 0;
    __int16 v24 = (UInt8 *)valuePtr;
LABEL_42:
    v59.CFIndex location = 0;
    v59.CFIndex length = v21;
    CFIndex Bytes = CFStringGetBytes(a2, v59, 0x8000100u, 0, 0, v24, v23, &usedBufLen);
    goto LABEL_43;
  }
  __int16 v24 = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, MaximumSizeForEncoding, 3027758341, 0);
  usedBufLeuint64_t n = 0;
  if (v24) {
    goto LABEL_42;
  }
  CFIndex Bytes = 0;
LABEL_43:
  if (Bytes == v21)
  {
    char v27 = usedBufLen;
    if (usedBufLen >= 15) {
      char v27 = 15;
    }
    char v46 = v27 | 0x70;
    bufferWrite_0((uint64_t)a1, &v46, 1);
    int v28 = usedBufLen;
    if (usedBufLen < 15) {
      goto LABEL_108;
    }
    if ((unint64_t)usedBufLen > 0x7F)
    {
      if ((unint64_t)usedBufLen >> 15)
      {
        if ((unint64_t)usedBufLen >> 31)
        {
          LOBYTE(v56) = 19;
          *(void *)((char *)&v56 + 1) = usedBufLen ^ 0x8000000000000000;
          __int16 v29 = (char *)&v56;
          uint64_t v43 = (uint64_t)a1;
          uint64_t v44 = 9;
          goto LABEL_107;
        }
        LOBYTE(v56) = 18;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        char v53 = BYTE1(v28);
        char v54 = v28;
        char v52 = BYTE2(v28);
        char v51 = HIBYTE(v28) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v54, 1);
        bufferWrite_0((uint64_t)a1, &v53, 1);
        bufferWrite_0((uint64_t)a1, &v52, 1);
        __int16 v29 = &v51;
      }
      else
      {
        LOBYTE(v56) = 17;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        char v54 = v28;
        char v53 = BYTE1(v28) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v54, 1);
        __int16 v29 = &v53;
      }
    }
    else
    {
      LOBYTE(v56) = usedBufLen ^ 0x80;
      char v54 = 16;
      bufferWrite_0((uint64_t)a1, &v54, 1);
      __int16 v29 = (char *)&v56;
    }
    uint64_t v43 = (uint64_t)a1;
    uint64_t v44 = 1;
LABEL_107:
    bufferWrite_0(v43, v29, v44);
LABEL_108:
    bufferWrite_0((uint64_t)a1, v24, usedBufLen);
  }
  if (v24 != (UInt8 *)valuePtr) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v24);
  }
  return Bytes == v21;
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  Generic = (__CFSet *)__CFSetCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  int64_t v4 = Generic;
  if (Generic)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Generic, 0x11uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return v4;
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  int v4 = capacity;
  if (callBacks != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    goto LABEL_2;
  }
  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present)
  {
    unint64_t v7 = [NSMutableArray alloc];
    return (CFMutableArrayRef)[(NSMutableArray *)v7 initWithCapacity:0];
  }
  else
  {
LABEL_2:
    return (CFMutableArrayRef)__CFArrayCreateMutable0((__objc2_class **)allocator, v4, callBacks);
  }
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  Mutable = (__CFDictionary *)__NSCFDictionaryCreateMutable((__objc2_class **)allocator, capacity, keyCallBacks, valueCallBacks);
  if (!Mutable)
  {
    uint64_t Generic = __CFDictionaryCreateGeneric((__objc2_class **)allocator, (uint64_t)keyCallBacks, valueCallBacks);
    Mutable = (__CFDictionary *)Generic;
    if (Generic)
    {
      if (capacity >= 1)
      {
        if (capacity >= 1000) {
          CFIndex v10 = 1000;
        }
        else {
          CFIndex v10 = capacity;
        }
        CFBasicHashSetCapacity(Generic, v10);
      }
      _CFRuntimeSetInstanceTypeIDAndIsa(Mutable, 0x12uLL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }
  return Mutable;
}

_DWORD *__NSCFDictionaryCreateMutable(__objc2_class **a1, unint64_t a2, const CFDictionaryKeyCallBacks *a3, const CFDictionaryValueCallBacks *a4)
{
  if (__FoundationPresent_static_init_0 != -1) {
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  }
  if (!__FoundationPresent_present_0
    || &__kCFAllocatorSystemDefault != a1
    && (a1 || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return 0;
  }
  if (a3 != &kCFTypeDictionaryKeyCallBacks || a4 != &kCFTypeDictionaryValueCallBacks)
  {
    if (a3 == &kCFCopyStringDictionaryKeyCallBacks && a4 == &kCFTypeDictionaryValueCallBacks)
    {
      unint64_t v8 = 3;
      goto LABEL_13;
    }
    return 0;
  }
  unint64_t v8 = 0;
LABEL_13:

  return __NSDictionaryM_new(0, 0, a2, v8);
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  CFAllocatorRef result = (CFAllocatorRef)_CFGetTSD(1u);
  if (!result) {
    return (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  return result;
}

Class _CFRuntimeSetInstanceTypeIDAndIsa(void *a1, unint64_t a2)
{
  Class result = (Class)_CFRuntimeSetInstanceTypeID((uint64_t)a1, a2);
  unint64_t v5 = *a1 & ~(unint64_t)off_1ECE0A6D0;
  if ((*a1 & (unint64_t)off_1ECE0A6D0) != 0) {
    v5 |= *a1 & (unint64_t)off_1ECE0A6D0;
  }
  if (a2 < 0x48)
  {
    int v6 = &__CFRuntimeBuiltinObjCClassTable[a2];
    if (v5 == *v6) {
      return result;
    }
    unint64_t v7 = (objc_class *)*v6;
    goto LABEL_15;
  }
  int v8 = a2 - 72;
  if ((int)a2 - 72 < dword_1EB1DE0D8 && (uint64_t v9 = __CFRuntimeClassTables[(v8 >> 6) + 16]) != 0) {
    uint64_t v10 = *(void *)(v9 + 8 * (v8 & 0x3F));
  }
  else {
    uint64_t v10 = 0;
  }
  if (v5 != v10)
  {
    if (v8 >= dword_1EB1DE0D8 || (uint64_t v11 = __CFRuntimeClassTables[(v8 >> 6) + 16]) == 0)
    {
      uint64_t v12 = 0;
      goto LABEL_17;
    }
    unint64_t v7 = *(objc_class **)(v11 + 8 * (v8 & 0x3F));
LABEL_15:
    uint64_t v12 = v7;
LABEL_17:
    return object_setClass(a1, v12);
  }
  return result;
}

uint64_t _CFRuntimeSetInstanceTypeID(uint64_t result, unint64_t a2)
{
  if (a2 > 0x47)
  {
    int v3 = a2 - 72;
    if ((int)a2 - 72 >= dword_1EB1DE0D8) {
      goto LABEL_23;
    }
    uint64_t v4 = __CFRuntimeClassTables[v3 >> 6];
    if (!v4) {
      goto LABEL_23;
    }
    uint64_t v2 = (void **)(v4 + 8 * (v3 & 0x3F));
  }
  else
  {
    uint64_t v2 = (void **)(&__CFRuntimeBuiltinClassTable + a2);
  }
  unint64_t v5 = *v2;
  if (!v5)
  {
LABEL_23:
    __break(1u);
    return result;
  }
  unint64_t v6 = atomic_load((unint64_t *)(result + 8));
  unint64_t v7 = (v6 >> 8) & 0x3FF;
  if (v7 > 0x47)
  {
    unsigned int v9 = v7 - 72;
    if ((int)v7 - 72 >= dword_1EB1DE0D8 || (uint64_t v10 = __CFRuntimeClassTables[v9 >> 6]) == 0)
    {
      uint64_t v11 = 0;
      goto LABEL_14;
    }
    int v8 = (unsigned char **)(v10 + 8 * (v9 & 0x3F));
  }
  else
  {
    int v8 = (unsigned char **)(&__CFRuntimeBuiltinClassTable + v7);
  }
  uint64_t v11 = *v8;
LABEL_14:
  if ((*v11 & 8) != 0 || v7 && (*v5 & 8) != 0) {
    return CFLog(3, @"*** Cannot change the CFTypeID of a %s to a %s due to custom ref counting");
  }
  unint64_t v12 = atomic_load((unint64_t *)(result + 8));
  unint64_t v13 = v12;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v13, v12 & 0xFFFFFFFFFFFC00FFLL | ((unint64_t)a2 << 8));
    BOOL v14 = v13 == v12;
    unint64_t v12 = v13;
  }
  while (!v14);
  atomic_fetch_and((atomic_ullong *volatile)(result + 8), 0xFFFF000000FFFFFFLL);
  unint64_t v15 = atomic_load((unint64_t *)(result + 8));
  atomic_fetch_or((atomic_ullong *volatile)(result + 8), ((v15 & 0x83FF00) >> 16) & 0xFFFFFF000000);
  return result;
}

uint64_t __CFDictionaryCreateGeneric(__objc2_class **a1, uint64_t a2, void *a3)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 8);
    uint64_t v4 = *(void *)(a2 + 16);
    long long v5 = *(_OWORD *)(a2 + 32);
    uint64_t v6 = *(void *)(a2 + 24);
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v6 = 0;
    long long v5 = 0uLL;
  }
  v12[1] = v3;
  v12[3] = v4;
  long long v13 = v5;
  uint64_t v14 = 0;
  uint64_t v16 = v6;
  if (a3)
  {
    uint64_t v7 = a3[1];
    uint64_t v8 = a3[2];
    uint64_t v10 = a3[3];
    uint64_t v9 = a3[4];
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  v12[0] = v7;
  v12[2] = v8;
  v12[4] = v9;
  uint64_t v15 = v10;
  return CFBasicHashCreate(a1, 0x2001u, v12);
}

uint64_t CFBasicHashCreate(__objc2_class **a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5 = 40;
  if ((a2 & 1) == 0) {
    uint64_t v5 = 32;
  }
  if ((a2 & 2) != 0) {
    v5 += 8;
  }
  if ((a2 & 4) != 0) {
    uint64_t v6 = v5 + 8;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t result = _CFRuntimeCreateInstance(a1, 3uLL, v6, 0);
  uint64_t v8 = result;
  if (!result) {
    return v8;
  }
  int v9 = *(_WORD *)(result + 18) & 0xFFFC | (a2 >> 13) & 3;
  *(_WORD *)(result + 18) = *(_WORD *)(result + 18) & 0xFFFC | (a2 >> 13) & 3;
  if ((a2 & 0x8000) != 0) {
    *(void *)(result + 32) |= 4uLL;
  }
  int v10 = ((_WORD)a2 << 7) & 0x6000 | (((a2 >> 8) & 0xF) << 9) & 0x7FFF | (a2 >> 12 << 15) | v9;
  if ((a2 & 0x1FC0) != 0) {
    *(_WORD *)(result + 18) = v10;
  }
  *(_WORD *)(result + 16) = 1;
  if ((~v10 & 0xA00) != 0
    && (~v10 & 0x2200) != 0
    && (~v10 & 0x1400) != 0
    && (~v10 & 0x4400) != 0
    && (~v10 & 0x2800) != 0
    && (~v10 & 0x5000) != 0
    && (~v10 & 0x8400) != 0
    && (~v10 & 0x9000) != 0
    && (unsigned __int16)v10 < 0xC000u)
  {
    if (a2)
    {
      LOWORD(v10) = v10 | 4;
      *(_WORD *)(result + 18) = v10;
      char v11 = 2;
      if ((a2 & 2) == 0)
      {
LABEL_27:
        if ((a2 & 4) != 0) {
          *(_WORD *)(result + 18) = v10 & 0xFE7F | ((v11 & 3) << 7);
        }
        *(void *)(result + 24) = *(void *)(result + 24) & 0xFFFFFFFC00FFFFFFLL | ((CFBasicHashGetPtrIndex(a3[1]) & 0x3FF) << 24);
        *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0xFFFFF003FFFFFFFFLL | ((CFBasicHashGetPtrIndex(*a3) & 0x3FF) << 34);
        *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0xFFC00FFFFFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[3]) & 0x3FF) << 44);
        *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0x3FFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)CFBasicHashGetPtrIndex(a3[2]) << 54);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFFFFFFFFFC00FLL | (16
                                                                            * (CFBasicHashGetPtrIndex(a3[9]) & 0x3FF));
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFFFFFFF003FFFLL | ((CFBasicHashGetPtrIndex(a3[8]) & 0x3FF) << 14);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFFFFC00FFFFFFLL | ((CFBasicHashGetPtrIndex(a3[5]) & 0x3FF) << 24);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFF003FFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[4]) & 0x3FF) << 34);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFC00FFFFFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[6]) & 0x3FF) << 44);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0x3FFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)CFBasicHashGetPtrIndex(a3[7]) << 54);
        return v8;
      }
    }
    else
    {
      char v11 = 1;
      if ((a2 & 2) == 0) {
        goto LABEL_27;
      }
    }
    LOWORD(v10) = v10 & 0xFFE7 | (8 * (v11++ & 3));
    *(_WORD *)(result + 18) = v10;
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

uint64_t CFBasicHashGetPtrIndex(uint64_t a1)
{
  if (CFBasicHashGetPtrIndex_once != -1) {
    dispatch_once(&CFBasicHashGetPtrIndex_once, &__block_literal_global_35);
  }
  uint64_t result = os_unfair_lock_lock_with_options();
  int v3 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCount);
  if (v3 >= 1)
  {
    uint64_t add = 0;
    while (*(void *)(CFBasicHashCallBackPtrs[add >> 5] + 8 * (add & 0x1F)) != a1)
    {
      uint64_t add = (add + 1);
      int v5 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCount);
      if ((int)add >= v5) {
        goto LABEL_7;
      }
    }
    goto LABEL_11;
  }
LABEL_7:
  int v6 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCount);
  if (v6 < 1024)
  {
    unsigned int v7 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCount);
    unsigned int v8 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCapacity);
    if (v7 == v8)
    {
      int v9 = malloc_type_malloc(0x100uLL, 0x80040B8603338uLL);
      int v10 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCount);
      int v11 = v10;
      unsigned int v7 = v10 + (v10 < 0 ? 0x1F : 0);
      CFBasicHashCallBackPtrs[v11 / 32] = (uint64_t)v9;
      atomic_fetch_add(&CFBasicHashCallBackPtrsCapacity, 0x20u);
    }
    uint64_t add = atomic_fetch_add(&CFBasicHashCallBackPtrsCount, 1u);
    *(void *)(CFBasicHashCallBackPtrs[(int)add / 32] + 8 * (int)(add - (v7 & 0xFFFFFFE0))) = a1;
LABEL_11:
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBasicHashCallBackPtrsLock);
    return add;
  }
  __break(1u);
  return result;
}

uint64_t __CFSetCreateGeneric(__objc2_class **a1, uint64_t a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    uint64_t v3 = *(void *)(a2 + 16);
    long long v4 = *(_OWORD *)(a2 + 32);
    uint64_t v5 = *(void *)(a2 + 24);
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    uint64_t v5 = 0;
    long long v4 = 0uLL;
  }
  long long v8 = v4;
  uint64_t v10 = v5;
  uint64_t v11 = v5;
  v7[0] = v2;
  v7[1] = v2;
  void v7[2] = v3;
  v7[3] = v3;
  v7[4] = v4;
  uint64_t v9 = 0;
  return CFBasicHashCreate(a1, 0x2000u, v7);
}

uint64_t __CFArrayCreateMutable0(__objc2_class **a1, int a2, const CFArrayCallBacks *a3)
{
  return __CFArrayCreateInit(a1, 2, a2, a3);
}

void writeBytes(uint64_t a1, const UInt8 *__src, int64_t __len, int a4)
{
  if (__len >= 1)
  {
    uint64_t v19 = v7;
    uint64_t v20 = v6;
    uint64_t v21 = v5;
    uint64_t v22 = v4;
    if (!*(void *)(a1 + 24))
    {
      CFIndex v12 = __len;
      long long v13 = __src;
      uint64_t v14 = *(void *)(a1 + 8);
      if (v14)
      {
        uint64_t v15 = *(void *)(a1 + 32);
        if (__CFADD__(__len, v15) || *(void *)(a1 + 16) < (unint64_t)(v15 + __len))
        {
          CFErrorRef Error = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because databytes is full.", v19, v20, v21, v22, v8, v9);
LABEL_7:
          *(void *)(a1 + 24) = Error;
          return;
        }
        if (!a4) {
          memmove((void *)(v14 + v15), __src, __len);
        }
      }
      if (!*(unsigned char *)(a1 + 44))
      {
        while (1)
        {
          CFIndex v17 = v12;
          if (!a4)
          {
            CFIndex v17 = v12;
            if (*(void *)a1)
            {
              CFIndex v17 = CFWriteStreamWrite(*(CFWriteStreamRef *)a1, v13, v12);
              if (!v17)
              {
                CFErrorRef Error = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because stream is full.", v19, v20, v21, v22, v8, v9);
                goto LABEL_7;
              }
              if (v17 < 0) {
                break;
              }
            }
          }
          *(void *)(a1 + 32) += v17;
          v13 += v17;
          BOOL v18 = v12 <= v17;
          v12 -= v17;
          if (v18) {
            return;
          }
        }
        if (!*(void *)a1 || (CFErrorRef Error = CFWriteStreamCopyError(*(CFWriteStreamRef *)a1)) == 0) {
          CFErrorRef Error = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because the stream had an unknown error.", v19, v20, v21, v22, v8, v9);
        }
        goto LABEL_7;
      }
      if (!a4)
      {
        if (*(void *)a1) {
          CFDataAppendBytes(*(CFMutableDataRef *)a1, v13, v12);
        }
      }
      *(void *)(a1 + 32) += v12;
    }
  }
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return 1 << (((unint64_t)(unsigned __int16)__CFNumberTypeTable[CFNumberGetType(number)] >> 7) & 7);
}

unint64_t CFLog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  return _CFLogvEx3(0, 0, 0, 0, a1, a2, &a9);
}

const void *_CFBundleGetMappedStringsFile(CFIndex a1)
{
  os_unfair_lock_lock_with_options();
  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)_mappedStringsFiles, a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&_mappedStringsFilesLock);
  return ValueAtIndex;
}

uint64_t __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_2;
  }
  unsigned int v11 = atomic_load((unint64_t *)theArray + 1);
  int v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 == 1)
    {
LABEL_2:
      uint64_t v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    char v13 = atomic_load((unint64_t *)theArray + 1);
    int v14 = v13 & 3;
    if (v14) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v14 == 2) {
      uint64_t v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      uint64_t v7 = v15;
    }
  }
  else
  {
    uint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (length < 1) {
    return 0;
  }
  while (1)
  {
    uint64_t v8 = (const void *)[(__CFArray *)theArray objectAtIndex:location];
    if (v8 == value) {
      break;
    }
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal)
    {
      if (equal(value, v8)) {
        break;
      }
    }
    ++location;
    if (!--length) {
      return 0;
    }
  }
  return 1;
}

const void *__CFPropertyListIsDictPlistAux(const void *cf, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)a3)
  {
    uint64_t v5 = cf;
    if (!cf)
    {
      uint64_t v9 = *(void **)(a3 + 24);
      if (v9)
      {
        if (!*v9) {
          **(void **)(a3 + 24) = CFRetain(@"property list dictionaries cannot contain NULL keys");
        }
      }
    }
    if (!a2)
    {
      uint64_t v10 = *(void **)(a3 + 24);
      if (v10)
      {
        if (!*v10) {
          **(void **)(a3 + 24) = CFRetain(@"property list dictionaries cannot contain NULL values");
        }
      }
    }
    if (CFGetTypeID(v5) != 7)
    {
      uint64_t v6 = *(void **)(a3 + 24);
      if (v6)
      {
        if (!*v6)
        {
          CFTypeID v7 = CFGetTypeID(v5);
          CFStringRef v8 = CFCopyTypeIDDescription(v7);
          **(void **)(a3 + 24) = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"property list dictionaries may only have keys which are CFStrings, not '%@'", v8);
          CFRelease(v8);
        }
      }
    }
    CFLocaleRef cf = 0;
    if (v5 && a2)
    {
      if (CFGetTypeID(v5) == 7) {
        CFLocaleRef cf = (const void *)__CFPropertyListIsValidAux(a2, a3);
      }
      else {
        CFLocaleRef cf = 0;
      }
    }
    *(unsigned char *)a3 = (_BYTE)cf;
  }
  return cf;
}

BOOL __CFPropertyListIsValidAux(const void *a1, unsigned char *a2)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (!a1)
  {
    if (*((void *)a2 + 3))
    {
      CFStringRef v8 = @"property lists cannot contain NULL";
      goto LABEL_11;
    }
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  BOOL v5 = 1;
  if (v4 != 7)
  {
    CFTypeID v6 = v4;
    if (v4 != 20
      && (*((void *)a2 + 1) == 1
       || (v4 > 0x2A || ((1 << v4) & 0x40000600000) == 0) && _CFKeyedArchiverUIDGetTypeID() != v4))
    {
      uint64_t v7 = *((void *)a2 + 2);
      if (v7)
      {
        if (CFSetContainsValue(*((CFSetRef *)a2 + 2), a1))
        {
          if (*((void *)a2 + 3))
          {
            CFStringRef v8 = @"property lists cannot contain recursive container references";
LABEL_11:
            BOOL v5 = 0;
            **((void **)a2 + 3) = CFRetain(v8);
            return v5;
          }
          return 0;
        }
      }
      else
      {
        *((void *)a2 + 2) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
      }
      uint64_t v9 = *((void *)a2 + 1);
      if (v9 != 200)
      {
        CFBagRef v10 = (const __CFBag *)*((void *)a2 + 4);
        if (!v10)
        {
          *(_OWORD *)&callBacks.versiouint64_t n = *(_OWORD *)&kCFTypeBagCallBacks.version;
          *(_OWORD *)&callBacks.release = *(_OWORD *)&kCFTypeBagCallBacks.release;
          callBacks.equal = 0;
          callBacks.hash = 0;
          *((void *)a2 + 4) = CFBagCreateMutable(0, 0, &callBacks);
          int v12 = 1;
LABEL_26:
          if (v6 == 18)
          {
            CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
            if (v9 != 200 && Count >= 1) {
              CFBagAddValue(*((CFMutableBagRef *)a2 + 4), a1);
            }
            CFSetAddValue(*((CFMutableSetRef *)a2 + 2), a1);
            CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)__CFPropertyListIsDictPlistAux, a2);
          }
          else
          {
            if (v6 != 19)
            {
              if (*((void *)a2 + 3))
              {
                CFStringRef v16 = CFCopyTypeIDDescription(v6);
                **((void **)a2 + 3) = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"property lists cannot contain objects of type '%@'", v16);
                CFRelease(v16);
              }
              BOOL v5 = 0;
              if (v7) {
                goto LABEL_38;
              }
LABEL_37:
              CFRelease(*((CFTypeRef *)a2 + 2));
              *((void *)a2 + 2) = 0;
LABEL_38:
              if (v12)
              {
                CFRelease(*((CFTypeRef *)a2 + 4));
                *((void *)a2 + 4) = 0;
              }
              return v5;
            }
            CFIndex v13 = CFArrayGetCount((CFArrayRef)a1);
            CFIndex v14 = v13;
            if (v9 != 200 && v13 >= 1) {
              CFBagAddValue(*((CFMutableBagRef *)a2 + 4), a1);
            }
            CFSetAddValue(*((CFMutableSetRef *)a2 + 2), a1);
            v19.CFIndex location = 0;
            v19.CFIndex length = v14;
            CFArrayApplyFunction((CFArrayRef)a1, v19, (CFArrayApplierFunction)__CFPropertyListIsArrayPlistAux, a2);
          }
          CFSetRemoveValue(*((CFMutableSetRef *)a2 + 2), a1);
          BOOL v5 = *a2 != 0;
          if (v7) {
            goto LABEL_38;
          }
          goto LABEL_37;
        }
        if ((unint64_t)CFBagGetCountOfValue(v10, a1) >= 0x181)
        {
          if (*((void *)a2 + 3))
          {
            CFStringRef v8 = @"Too many nested arrays or dictionaries please use kCFPropertyListBinaryFormat_v1_0 instead which supports references";
            goto LABEL_11;
          }
          return 0;
        }
      }
      int v12 = 0;
      goto LABEL_26;
    }
  }
  return v5;
}

CFTypeID CFNumberGetTypeID(void)
{
  if (CFNumberGetTypeID_initOnce != -1) {
    dispatch_once(&CFNumberGetTypeID_initOnce, &__block_literal_global_8);
  }
  return 22;
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict)) {
    return [(__CFDictionary *)theDict containsKey:key];
  }
  else {
    return CFBasicHashGetCountOfKey((uint64_t)theDict, (unint64_t)key) > 0;
  }
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet)) {
    return [(__CFSet *)theSet containsObject:value];
  }
  else {
    return CFBasicHashGetCountOfKey((uint64_t)theSet, (unint64_t)value) > 0;
  }
}

uint64_t CFBasicHashGetCountOfKey(uint64_t result, unint64_t a2)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  BOOL v2 = a2 == 2780474809 || a2 == 2814029233;
  if (v2 || !*(_DWORD *)(result + 20)) {
    return 0;
  }
  if (!*(unsigned char *)(result + 26))
  {
    long long v4 = xmmword_182EDDE80;
    long long v5 = *(_OWORD *)algn_182EDDE90;
    return *((void *)&v5 + 1);
  }
  int v3 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v4);
        return *((void *)&v5 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v4);
        return *((void *)&v5 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v4);
        return *((void *)&v5 + 1);
    }
LABEL_25:
    __break(1u);
    return result;
  }
  if (v3 == 3)
  {
    ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v4);
    return *((void *)&v5 + 1);
  }
  if (v3 == 2)
  {
    ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v4);
    return *((void *)&v5 + 1);
  }
  if (v3 != 1) {
    goto LABEL_25;
  }
  ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v4);
  return *((void *)&v5 + 1);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  v6[6] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict __apply:applier context:context];
  }
  else
  {
    v6[0] = off_1ECE0A5A0;
    v6[1] = 3221225472;
    v6[2] = __CFDictionaryApplyFunction_block_invoke;
    v6[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
    v6[4] = applier;
    v6[5] = context;
    CFBasicHashApply((uint64_t)theDict, (uint64_t)v6);
  }
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet removeObject:value];
  }
  else
  {
    char v4 = atomic_load((unint64_t *)theSet + 1);
    if ((v4 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function");
    }
    CFBasicHashRemoveValue((uint64_t)theSet, (unint64_t)value);
  }
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  if (range.length >= 1)
  {
    uint64_t v17 = v9;
    uint64_t v18 = v8;
    uint64_t v19 = v7;
    uint64_t v20 = v6;
    uint64_t v21 = v5;
    uint64_t v22 = v4;
    uint64_t v23 = v10;
    uint64_t v24 = v11;
    CFIndex length = range.length;
    CFIndex location = range.location;
    do
    {
      ((void (*)(uint64_t, void *))applier)(-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location++, v17, v18, v19, v20, v21, v22, v23, v24), context);
      --length;
    }
    while (length);
  }
}

uint64_t __CFRunLoopDoObservers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *(void *)off_1ECE0A5B0;
  uint64_t v34 = a1;
  kdebug_trace();
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t result = *(void *)(a2 + 112);
  if (result)
  {
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      unint64_t v7 = result;
      char v33 = &v30;
      MEMORY[0x1F4188790](result, v6);
      uint64_t v10 = (char *)&v30 - v9;
      if (v8 >= 0x200) {
        size_t v11 = 512;
      }
      else {
        size_t v11 = v8;
      }
      bzero((char *)&v30 - v9, v11);
      uint64_t v32 = v10;
      if (v7 >= 0x401) {
        uint64_t v10 = (char *)malloc_type_malloc(8 * v7, 0x2004093837F09uLL);
      }
      uint64_t v12 = 0;
      for (CFIndex i = 0; i != v7; ++i)
      {
        ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 112), i);
        if ((ValueAtIndex[12] & a3) != 0)
        {
          char v15 = atomic_load(ValueAtIndex + 1);
          if ((v15 & 8) != 0)
          {
            char v16 = atomic_load(ValueAtIndex + 1);
            if ((v16 & 1) == 0) {
              *(void *)&v10[8 * v12++] = CFRetain(ValueAtIndex);
            }
          }
        }
      }
      uint64_t v31 = (pthread_mutex_t *)(a2 + 16);
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
      unint64_t v30 = (pthread_mutex_t *)(v34 + 16);
      pthread_mutex_unlock((pthread_mutex_t *)(v34 + 16));
      if (v12 >= 1)
      {
        for (uint64_t j = 0; j != v12; ++j)
        {
          uint64_t v18 = *(void *)&v10[8 * j];
          pthread_mutex_lock((pthread_mutex_t *)(v18 + 16));
          uint64_t v19 = (unint64_t *)(v18 + 8);
          char v20 = atomic_load((unint64_t *)(v18 + 8));
          if ((v20 & 8) != 0)
          {
            char v21 = atomic_load(v19);
            unint64_t v22 = atomic_load(v19);
            unint64_t v23 = v22;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v18 + 8), &v23, v22 | 1);
              BOOL v24 = v23 == v22;
              unint64_t v22 = v23;
            }
            while (!v24);
            pthread_mutex_unlock((pthread_mutex_t *)(v18 + 16));
            CFTypeID v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v18 + 112);
            uint64_t v26 = *(void *)(v18 + 128);
            if (v34 && !*(unsigned char *)(v34 + 681)) {
              char v27 = 0;
            }
            else {
              char v27 = (void *)_CFAutoreleasePoolPush();
            }
            kdebug_trace();
            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(v25, v18, a3, v26);
            kdebug_trace();
            __CFRunLoopPerCalloutARPEnd(v27);
            if ((v21 & 2) == 0) {
              CFRunLoopObserverInvalidate((CFRunLoopObserverRef)v18);
            }
            unint64_t v28 = atomic_load((unint64_t *)(v18 + 8));
            unint64_t v29 = v28;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v18 + 8), &v29, v28 & 0xFFFFFFFFFFFFFFFELL);
              BOOL v24 = v29 == v28;
              unint64_t v28 = v29;
            }
            while (!v24);
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v18 + 16));
          }
          CFRelease((CFTypeRef)v18);
        }
      }
      pthread_mutex_lock(v30);
      pthread_mutex_lock(v31);
      if (v10 != v32) {
        free(v10);
      }
      return kdebug_trace();
    }
  }
  return result;
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)[(__CFArray *)theArray objectAtIndex:idx];
}

void *__CFRunLoopPerCalloutARPEnd(void *result)
{
  if (result) {
    return _CFAutoreleasePoolPop(result);
  }
  return result;
}

void sub_182BB1790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, int a10, __int16 a11, __int16 a12, uint64_t a13)
{
  if (a2)
  {
    id v14 = objc_begin_catch(exception_object);
    if (a2 == 2)
    {
      char v15 = v14;
      char v16 = _CFOSLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = [v15 name];
        uint64_t v18 = [v15 reason];
        uint64_t v19 = [v15 userInfo];
        LODWORD(a9) = 138543875;
        *(void *)((char *)&a9 + 4) = v17;
        WORD6(a9) = 2113;
        *(void *)((char *)&a9 + 14) = v18;
        a12 = 2113;
        a13 = v19;
        _os_log_error_impl(&dword_182B90000, v16, OS_LOG_TYPE_ERROR, "Caught exception during runloop's autorelease pool drain of client objects %{public}@: %{private}@ userInfo: %{private}@", (uint8_t *)&a9, 0x20u);
      }
      objc_terminate();
    }
    objc_terminate();
  }
  _Unwind_Resume(exception_object);
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(uint64_t (*result)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t)
{
  if (result) {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))result(a2, a3, a4);
  }
  return result;
}

void _CFStringAppendFormatAndArgumentsAux2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  v14[1] = *(CFErrorRef *)off_1ECE0A5B0;
  v14[0] = 0;
  __CFStringAppendFormatCore(a1, a2, a3, a4, 0, a5, 0, a6, 0, 0, 0, 0, a7, 0, v14);
  if (!v13)
  {
    CFLog(3, @"ERROR: Failed to format string: %@", v7, v8, v9, v10, v11, v12, (__int16)v14[0]);
    if (v14[0]) {
      CFRelease(v14[0]);
    }
  }
}

void __CFXPCDictionaryApplier(const __CFString *a1, uint64_t a2, xpc_object_t *a3)
{
  if (CFGetTypeID(a1) == 7)
  {
    CFIndex Length = CFStringGetLength(a1);
    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
    if (MaximumSizeForEncoding != -1)
    {
      CFIndex v8 = MaximumSizeForEncoding;
      uint64_t v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xCB2E0E6uLL);
      if (v9)
      {
        uint64_t v10 = v9;
        if (CFStringGetCString(a1, v9, v8, 0x8000100u))
        {
          uint64_t v11 = (void *)_CFXPCCreateXPCObjectFromCFObject(a2);
          if (v11)
          {
            uint64_t v12 = v11;
            xpc_dictionary_set_value(*a3, v10, v11);
            xpc_release(v12);
          }
        }
        free(v10);
      }
    }
  }
}

xpc_object_t _CFXPCCreateXPCObjectFromCFObject(__CFString *a1)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (CFNullGetTypeID() == v2)
  {
    return xpc_null_create();
  }
  if (CFBooleanGetTypeID() == v2)
  {
    return xpc_BOOL_create(&__kCFBooleanTrue == (__objc2_class **)a1);
  }
  if (v2 == 7)
  {
    CFIndex Length = CFStringGetLength(a1);
    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
    if (MaximumSizeForEncoding != -1)
    {
      CFIndex v6 = MaximumSizeForEncoding;
      uint64_t v7 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0x9B28DDC6uLL);
      if (v7)
      {
        CFIndex v8 = v7;
        if (CFStringGetCString(a1, v7, v6, 0x8000100u)) {
          uint64_t v9 = xpc_string_create(v8);
        }
        else {
          uint64_t v9 = 0;
        }
        free(v8);
        return v9;
      }
    }
    return 0;
  }
  if (CFDataGetTypeID() == v2)
  {
    DispatchData = _CFDataCreateDispatchData(a1);
    xpc_object_t v11 = xpc_data_create_with_dispatch_data(DispatchData);
    dispatch_release(DispatchData);
    return v11;
  }
  if (v2 != 42)
  {
    if (v2 == 22)
    {
      if (CFNumberIsFloatType((CFNumberRef)a1))
      {
        *(void *)&valuePtr.byte0 = 0;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr)) {
          return xpc_double_create(*(double *)&valuePtr.byte0);
        }
      }
      else
      {
        *(void *)&valuePtr.byte0 = 0;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, &valuePtr)) {
          return xpc_int64_create(*(int64_t *)&valuePtr.byte0);
        }
      }
      return 0;
    }
    if (CFUUIDGetTypeID() == v2)
    {
      CFUUIDBytes valuePtr = CFUUIDGetUUIDBytes((CFUUIDRef)a1);
      return xpc_uuid_create(&valuePtr.byte0);
    }
    if (v2 == 18)
    {
      *(void *)&valuePtr.byte0 = xpc_dictionary_create(0, 0, 0);
      if (!*(void *)&valuePtr.byte0) {
        return 0;
      }
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)__CFXPCDictionaryApplier, &valuePtr);
      size_t v19 = xpc_dictionary_get_count(*(xpc_object_t *)&valuePtr.byte0);
      uint64_t v9 = *(void **)&valuePtr.byte0;
    }
    else
    {
      if (v2 != 19)
      {
        if (CFURLGetTypeID() != v2) {
          return 0;
        }
        uint64_t v9 = (void *)CFURLGetString((CFURLRef)a1);
        if (!v9) {
          return v9;
        }
        CFURLRef v21 = CFURLGetBaseURL((CFURLRef)a1);
        if (!v21) {
          CFURLRef v21 = (CFURLRef)&__kCFNull;
        }
        uint64_t v22 = _CFXPCCreateXPCObjectFromCFObject(v21);
        if (!v22) {
          return 0;
        }
        unint64_t v23 = (void *)v22;
        uint64_t v9 = (void *)_CFXPCCreateXPCObjectFromCFObject(v9);
        if (!v9)
        {
          xpc_release(v23);
          return v9;
        }
        memset(uu, 0, sizeof(uu));
        if (uuid_parse("C3853DCC-9776-4114-B6C1-FD9F51944A6D", uu) || (xpc_object_t v24 = xpc_uuid_create(uu)) == 0)
        {
          xpc_release(v9);
          char v20 = v23;
          goto LABEL_50;
        }
        CFTypeID v25 = v24;
        *(void *)&valuePtr.byte0 = "com.apple.CFURL.magic";
        *(void *)&valuePtr.byte8 = "com.apple.CFURL.string";
        unint64_t v30 = "com.apple.CFURL.base";
        values[0] = v24;
        values[1] = v9;
        values[2] = v23;
        xpc_object_t v26 = xpc_dictionary_create((const char *const *)&valuePtr, values, 3uLL);
        char v27 = v9;
        uint64_t v9 = v26;
        xpc_release(v27);
        xpc_release(v23);
        xpc_release(v25);
        if (!v9 || xpc_dictionary_get_count(v9) == 3) {
          return v9;
        }
LABEL_49:
        char v20 = v9;
LABEL_50:
        xpc_release(v20);
        return 0;
      }
      uint64_t v9 = xpc_array_create(0, 0);
      if (!v9) {
        return v9;
      }
      CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
          uint64_t v17 = (void *)_CFXPCCreateXPCObjectFromCFObject(ValueAtIndex);
          if (v17)
          {
            uint64_t v18 = v17;
            xpc_array_append_value(v9, v17);
            xpc_release(v18);
          }
        }
      }
      size_t v19 = xpc_array_get_count(v9);
    }
    if (v19 == Count) {
      return v9;
    }
    goto LABEL_49;
  }
  double v13 = CFDateGetAbsoluteTime((CFDateRef)a1) + 978307200.0;
  if (v13 < -9223372040.0 || v13 > 9223372040.0)
  {
    return _CFXPCCreateXPCObjectFromOutOfRangeCFTimeInterval(v13);
  }
  else
  {
    return xpc_date_create((uint64_t)(v13 * 1000000000.0));
  }
}

CFTypeID CFBooleanGetTypeID(void)
{
  return 21;
}

CFTypeID CFDataGetTypeID(void)
{
  return 20;
}

CFTypeID CFNullGetTypeID(void)
{
  return 16;
}

uint64_t _CFNonObjCStringGetCStringPtr(unint64_t *a1, unsigned int a2, int a3)
{
  return _CFStringGetCStringPtrInternal(a1, a2, a3, 0);
}

uint64_t __CFStringMtbl(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  if (encoding == 4) {
    return 134217984;
  }
  if (encoding - 1 <= 0xE) {
    return word_182E0F9EC[encoding - 1];
  }
  CFStringEncoding v2 = encoding & 0x7FFFFFFF;
  if ((encoding & 0x80000000) == 0) {
    CFStringEncoding v2 = -1;
  }
  if (encoding == 21) {
    CFStringEncoding v2 = 2080;
  }
  if (encoding == 30) {
    return 0;
  }
  else {
    return v2;
  }
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  v24[1] = *(void *)off_1ECE0A5B0;
  CFIndex v4 = bufferSize - 1;
  if (bufferSize < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)&encoding;
  unint64_t v9 = CF_IS_OBJC(7uLL, (unint64_t)theString);
  if (v9) {
    return [(__CFString *)(id)theString _getCString:buffer maxLength:v4 encoding:v5];
  }
  char v11 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v11 & 0x60) != 0)
  {
    double v13 = *p_data;
  }
  else
  {
    char v14 = atomic_load((unint64_t *)&theString->info);
    double v13 = (char *)&p_data[(v14 & 5) != 4];
  }
  char v15 = atomic_load((unint64_t *)&theString->info);
  if ((v15 & 5) == 4)
  {
    CFIndex length = *v13;
  }
  else
  {
    char v17 = atomic_load((unint64_t *)&theString->info);
    if ((v17 & 0x60) != 0) {
      CFIndex length = theString->length;
    }
    else {
      CFIndex length = (CFIndex)*p_data;
    }
  }
  char v18 = atomic_load((unint64_t *)&theString->info);
  if ((v18 & 0x10) != 0) {
    goto LABEL_41;
  }
  int v19 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    unint64_t v9 = ((uint64_t (*)(void))__CFStringComputeEightBitStringEncoding)();
    int v19 = __CFDefaultEightBitStringEncoding;
  }
  if (v19 == v5) {
    goto LABEL_17;
  }
  if (v19 == -1)
  {
    __CFStringComputeEightBitStringEncoding(v9);
    int v19 = __CFDefaultEightBitStringEncoding;
  }
  if (v19 != 1536) {
    goto LABEL_41;
  }
  switch(BYTE1(v5))
  {
    case 0:
      if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || v5 == 152) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 1:
      if (v5 != 134217984) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 2:
      if (v5 == 518) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 6:
      if (v5 != 1536) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 8:
    case 0xC:
      goto LABEL_41;
    case 0xA:
      if ((v5 - 2561) > 0xF) {
        goto LABEL_17;
      }
      int v21 = 1 << (v5 - 1);
      int v22 = 32785;
      break;
    case 0xB:
      if ((v5 - 3059) > 0xC) {
        goto LABEL_17;
      }
      int v21 = 1 << (v5 + 13);
      int v22 = 4099;
      break;
    default:
      if (((unsigned __int16)v5 & 0xFF00u) > 0xC00) {
        goto LABEL_41;
      }
      goto LABEL_17;
  }
  if ((v21 & v22) == 0)
  {
LABEL_17:
    if (length >= bufferSize)
    {
      Boolean result = 0;
      *buffer = 0;
    }
    else
    {
      unint64_t v20 = atomic_load((unint64_t *)&theString->info);
      memmove(buffer, &v13[(v20 >> 2) & 1], length);
      buffer[length] = 0;
      return 1;
    }
  }
  else
  {
LABEL_41:
    v24[0] = 0;
    v25.CFIndex location = 0;
    v25.CFIndex length = length;
    Boolean result = __CFStringEncodeByteStream(theString, v25, 0, v5, 0, (UniChar *)buffer, v4, (uint64_t)v24) == length;
    uint64_t v23 = v24[0];
    if (!result) {
      uint64_t v23 = 0;
    }
    buffer[v23] = 0;
  }
  return result;
}

uint64_t _CFKeyedArchiverUIDGetTypeID()
{
  return 41;
}

void *_CFAutoreleasePoolPop(void *context)
{
  return context;
}

uint64_t _CFAutoreleasePoolPush()
{
  return MEMORY[0x185311AE0]();
}

uint64_t __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t __NSCollectionHandleConcurrentEnumerationIfSpecified(char a1, char a2, size_t a3, uint64_t a4)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if ((a1 & 1) == 0 || __CFActiveProcessorCount() < 2) {
    return 0;
  }
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2020000000;
  char v11 = 0;
  v8[0] = off_1ECE0A5A0;
  v8[1] = 3221225472;
  v8[2] = ____NSCollectionHandleConcurrentEnumerationIfSpecified_block_invoke;
  v8[3] = &unk_1ECDFE770;
  char v9 = a2;
  v8[4] = a4;
  v8[5] = v10;
  dispatch_apply(a3, 0, v8);
  _Block_object_dispose(v10, 8);
  return 1;
}

__CFString *_CFPrefsCreateCacheKeyForQuintuplet(__CFString *a1, const __CFString *a2, int a3, const __CFString *a4, char a5)
{
  v47[1] = *(void *)off_1ECE0A5B0;
  CacheStringForBundleID = (__CFString *)_CFPrefsGetCacheStringForBundleID(a1);
  uint64_t v10 = (const void *)_CFPrefsGetCacheStringForBundleID(@"kCFPreferencesCurrentApplication");
  if (CFEqual(CacheStringForBundleID, v10))
  {
    char v11 = @"C";
  }
  else if (CFEqual(CacheStringForBundleID, @"kCFPreferencesAnyApplication"))
  {
    char v11 = @"A";
  }
  else
  {
    char v11 = CacheStringForBundleID;
  }
  if (CFEqual(a2, @"kCFPreferencesCurrentUser"))
  {
LABEL_7:
    CFStringRef Copy = @"C";
    double v13 = @"kCFPreferencesCurrentUser";
    if (!@"kCFPreferencesCurrentUser") {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  double v13 = @"kCFPreferencesAnyUser";
  CFStringRef Copy = @"kCFPreferencesAnyUser";
  if (!CFEqual(a2, @"kCFPreferencesAnyUser"))
  {
    CFStringRef v17 = CFCopyUserName();
    int v18 = CFEqual(a2, v17);
    CFRelease(v17);
    if (@"kCFPreferencesCurrentUser") {
      BOOL v19 = v18 == 0;
    }
    else {
      BOOL v19 = 1;
    }
    if (!v19)
    {
      CFStringRef Copy = @"C";
      double v13 = @"kCFPreferencesCurrentUser";
LABEL_8:
      CFRelease(v13);
      goto LABEL_9;
    }
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
  }
  if (Copy == @"kCFPreferencesCurrentUser") {
    goto LABEL_7;
  }
  if (Copy == @"kCFPreferencesAnyUser")
  {
    CFStringRef Copy = @"A";
    if (@"kCFPreferencesAnyUser") {
      goto LABEL_8;
    }
  }
  else if (!Copy)
  {
    return 0;
  }
LABEL_9:
  if ((a5 & 1) == 0)
  {
    if (!a4 || CFEqual(a4, @"kCFPreferencesNoContainer"))
    {
      if (CFEqual(v11, @"C"))
      {
        if (Copy != @"kCFPreferencesCurrentUser")
        {
          char v15 = @"C/A//*/L";
          char v16 = @"C/A//B/L";
          goto LABEL_30;
        }
        uint64_t v43 = @"C/C//*/L";
        uint64_t v44 = @"C/C//B/L";
        goto LABEL_52;
      }
      if (CFEqual(v11, @"kCFPreferencesAnyApplication"))
      {
        if (Copy != @"kCFPreferencesCurrentUser")
        {
          char v15 = @"A/A//*/L";
          char v16 = @"A/A//B/L";
LABEL_30:
          if (a3) {
            unint64_t v20 = v16;
          }
          else {
            unint64_t v20 = v15;
          }
          if (Copy != @"kCFPreferencesAnyUser") {
            goto LABEL_34;
          }
LABEL_55:
          CFRelease(Copy);
          return v20;
        }
        uint64_t v43 = @"A/C//*/L";
        uint64_t v44 = @"A/C//B/L";
LABEL_52:
        if (a3) {
          unint64_t v20 = v44;
        }
        else {
          unint64_t v20 = v43;
        }
        goto LABEL_55;
      }
    }
LABEL_34:
    char v14 = "L";
    goto LABEL_35;
  }
  char v14 = "C";
LABEL_35:
  v46[0] = v14;
  if (a4) {
    CFStringRef v21 = a4;
  }
  else {
    CFStringRef v21 = &stru_1ECE10768;
  }
  if (a3) {
    int v22 = "B";
  }
  else {
    int v22 = "*";
  }
  CFIndex Length = CFStringGetLength(v11);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex v25 = CFStringGetLength(Copy);
  CFIndex v26 = CFStringGetMaximumSizeForEncoding(v25, 0x8000100u);
  CFIndex v27 = CFStringGetLength(v21);
  CFIndex v28 = CFStringGetMaximumSizeForEncoding(v27, 0x8000100u);
  v46[1] = (const char *)v46;
  CFIndex v29 = MaximumSizeForEncoding + v26 + v28;
  uint64_t v30 = v29 + 2;
  size_t v31 = v29 + 7;
  MEMORY[0x1F4188790](v28, v32);
  uint64_t v34 = (UInt8 *)v46 - v33;
  if (v30 < 1019) {
    bzero((char *)v46 - v33, v31);
  }
  else {
    uint64_t v34 = (UInt8 *)malloc_type_calloc(v31, 1uLL, 0x100004077774924uLL);
  }
  v47[0] = 0;
  v48.CFIndex length = CFStringGetLength(v11);
  v48.CFIndex location = 0;
  CFStringGetBytes(v11, v48, 0x8000100u, 0, 0, v34, v31, v47);
  size_t v35 = v31 + ~v47[0];
  uint64_t v36 = (UInt8 *)(strncat((char *)&v34[v47[0]], "/", v35) + 1);
  v49.CFIndex length = CFStringGetLength(Copy);
  v49.CFIndex location = 0;
  CFStringGetBytes(Copy, v49, 0x8000100u, 0, 0, v36, v35, v47);
  size_t v37 = v35 - v47[0];
  CFIndex v38 = v35 - v47[0] - 1;
  uint64_t v39 = (UInt8 *)(strncat((char *)&v36[v47[0]], "/", v38) + 1);
  v50.CFIndex length = CFStringGetLength(v21);
  v50.CFIndex location = 0;
  CFStringGetBytes(v21, v50, 0x8000100u, 0, 0, v39, v38, v47);
  uint64_t v40 = (char *)&v39[v47[0]];
  strncat((char *)&v39[v47[0]], "/", v37 - 2);
  strncat(v40 + 1, v22, v37 - 3);
  strncat(v40 + 2, "/", v37 - 4);
  strncat(v40 + 3, v46[0], v37 - 5);
  size_t v41 = strlen((const char *)v34);
  if (v30 < 1019) {
    CFStringRef v42 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v41, 0x8000100u, 0);
  }
  else {
    CFStringRef v42 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v41, 0x8000100u, 0, (CFAllocatorRef)&__kCFAllocatorMalloc);
  }
  unint64_t v20 = (__CFString *)v42;
  CFRelease(Copy);
  return v20;
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  CFIndex v2 = length;
  HIDWORD(v4) = encoding - 134217984;
  LODWORD(v4) = encoding - 134217984;
  int v3 = v4 >> 26;
  if ((v3 - 4) < 2 || v3 == 1)
  {
    CFIndex v6 = 4 * length;
    unint64_t v7 = (unint64_t)length >> 61;
    goto LABEL_7;
  }
  if (!v3)
  {
    CFIndex v8 = 3 * length;
    CFIndex v9 = 0x2AAAAAAAAAAAAAAALL;
    goto LABEL_12;
  }
  CFStringEncoding v11 = encoding & 0xFFF;
  if (v11 > 0x4FF)
  {
    if ((encoding & 0xFFF) > 0xB00)
    {
      if (v11 == 2817) {
        return v2;
      }
      if (v11 == 3071)
      {
        CFIndex v8 = 6 * length;
        CFIndex v9 = 0x1555555555555555;
LABEL_12:
        if (length > v9) {
          return -1;
        }
        else {
          return v8;
        }
      }
    }
    else if (v11 == 1280 || v11 == 1536)
    {
      return v2;
    }
    goto LABEL_29;
  }
  if ((encoding & 0xFFF) == 0) {
    return v2;
  }
  if (v11 == 256)
  {
    CFIndex v6 = 2 * length;
    unint64_t v7 = (unint64_t)length >> 62;
LABEL_7:
    if (v7) {
      return -1;
    }
    else {
      return v6;
    }
  }
  if (v11 == 513) {
    return v2;
  }
LABEL_29:
  uint64_t Converter = CFStringEncodingGetConverter(*(void *)&encoding);
  if (Converter)
  {
    unint64_t v13 = *(unsigned __int16 *)(Converter + 16);
    int64_t v14 = 0x7FFFFFFFFFFFFFFFLL / v13;
    CFIndex v15 = v13 * v2;
    if (v14 < v2) {
      return -1;
    }
    else {
      return v15;
    }
  }
  return v2;
}

uint64_t _CFPrefsGetCacheStringForBundleID(__CFString *a1)
{
  char v1 = (unint64_t *)_CFPrefsCurrentAppIdentifierCache;
  BOOL v2 = a1 == @"kCFPreferencesCurrentApplication" || _CFPrefsCurrentAppIdentifierCache == (void)a1;
  if (v2 || CFEqual(a1, @"kCFPreferencesCurrentApplication"))
  {
    if (!v1)
    {
      if ((MainBundle = CFBundleGetMainBundle()) != 0
        && (CFStringRef Identifier = CFBundleGetIdentifier(MainBundle)) != 0
        && (char v1 = (unint64_t *)Identifier, CFStringGetLength(Identifier))
        || (char v1 = (unint64_t *)_CFProcessNameString()) != 0)
      {
        unint64_t v7 = _CFStringCopyBundleUnloadingProtectedString(v1);
        char v1 = (unint64_t *)v7;
        uint64_t v8 = 0;
        atomic_compare_exchange_strong(&_CFPrefsCurrentAppIdentifierCache, (unint64_t *)&v8, (unint64_t)v7);
        if (v8)
        {
          CFRelease(v7);
          return _CFPrefsCurrentAppIdentifierCache;
        }
      }
    }
  }
  else if (!v1 || !CFEqual(v1, a1))
  {
    char v1 = (unint64_t *)@"kCFPreferencesAnyApplication";
    if (!CFEqual(a1, @"kCFPreferencesAnyApplication")
      && !CFEqual(a1, @"Apple Global Domain")
      && !CFEqual(a1, @".GlobalPreferences"))
    {
      return (uint64_t)a1;
    }
  }
  return (uint64_t)v1;
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  result.CFIndex location = 0;
  result.CFIndex length = 0;
  v13.CFIndex length = CFStringGetLength(theString);
  v13.CFIndex location = 0;
  int v6 = CFStringFindWithOptionsAndLocale(theString, stringToFind, v13, compareOptions, 0, &result);
  BOOL v7 = v6 == 0;
  if (v6) {
    CFIndex location = result.location;
  }
  else {
    CFIndex location = -1;
  }
  if (v7) {
    CFIndex length = 0;
  }
  else {
    CFIndex length = result.length;
  }
  v12.CFIndex length = length;
  v12.CFIndex location = location;
  return v12;
}

uint64_t __CFPropertyListIsArrayPlistAux(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (result)
    {
      CFRange result = __CFPropertyListIsValidAux(result, a2);
    }
    else
    {
      int v3 = *(void **)(a2 + 24);
      if (v3 && !*v3)
      {
        CFTypeRef v4 = CFRetain(@"property list arrays cannot contain NULL");
        CFRange result = 0;
        **(void **)(a2 + 24) = v4;
      }
      else
      {
        CFRange result = 0;
      }
    }
    *(unsigned char *)a2 = result;
  }
  return result;
}

CFTypeID CFUUIDGetTypeID(void)
{
  return 34;
}

uint64_t CFTypeGetTypeID()
{
  return 1;
}

uint64_t _runLoopObserverWithBlockContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t applyBlockApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  if (!CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
    return (CFURLRef)*((void *)anURL + 4);
  }

  return (CFURLRef)[(__CFURL *)anURL baseURL];
}

uint64_t notifySearchListOfRemoteChangesCallback(uint64_t a1, void *a2, uint64_t a3)
{
  return [a2 handleChangeNotificationForDomainIdentifier:a3 isRemote:1];
}

CFTypeID CFURLGetTypeID(void)
{
  return 29;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  if (otherRange.length >= 1)
  {
    uint64_t v13 = v6;
    uint64_t v14 = v5;
    uint64_t v15 = v4;
    uint64_t v16 = v3;
    uint64_t v17 = v7;
    uint64_t v18 = v8;
    CFIndex location = otherRange.location;
    CFIndex v12 = otherRange.location + otherRange.length;
    do
      CFArrayAppendValue(theArray, (const void *)-[__CFArray objectAtIndex:](otherArray, "objectAtIndex:", location++, v13, v14, v15, v16, v17, v18));
    while (location < v12);
  }
}

void CFBitVectorSetBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx, CFBit value)
{
  uint64_t v3 = *((void *)bv + 4);
  CFIndex v4 = idx / 8;
  int v5 = 1 << (~(_BYTE)idx & 7);
  if (value) {
    char v6 = *(unsigned char *)(v3 + v4) | v5;
  }
  else {
    char v6 = *(unsigned char *)(v3 + v4) & ~(_BYTE)v5;
  }
  *(unsigned char *)(v3 + v4) = v6;
}

uint64_t synchronizeApplier(uint64_t a1, void *a2)
{
  return [a2 synchronize];
}

void ___copyIngestedCacheResult_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
  int v5 = *(__CFSet **)(a1 + 40);

  CFSetRemoveValue(v5, a2);
}

dispatch_data_t _CFDataCreateDispatchData(void *a1)
{
  uint64_t v7[5] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x14uLL, (unint64_t)a1))
  {
    return (dispatch_data_t)[a1 _createDispatchData];
  }
  else
  {
    CFAllocatorRef v3 = CFGetAllocator(a1);
    CFDataRef Copy = CFDataCreateCopy(v3, (CFDataRef)a1);
    BytePtr = CFDataGetBytePtr(Copy);
    if (CF_IS_OBJC(0x14uLL, (unint64_t)Copy)) {
      size_t v6 = [(__CFData *)Copy length];
    }
    else {
      size_t v6 = *((void *)Copy + 2);
    }
    v7[0] = off_1ECE0A5A0;
    v7[1] = 3221225472;
    void v7[2] = ___CFDataCreateDispatchData_block_invoke;
    v7[3] = &__block_descriptor_40_e5_v8__0l;
    v7[4] = Copy;
    return dispatch_data_create(BytePtr, v6, 0, v7);
  }
}

BOOL _CFBundleSupportedProductName(const __CFString *a1, CFRange rangeToSearch)
{
  CFIndex length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  v9.CFIndex location = rangeToSearch.location;
  v9.CFIndex length = length;
  if (CFStringFindWithOptions(a1, @"iphone", v9, 8uLL, 0)) {
    return 1;
  }
  unint64_t v6 = 0;
  do
  {
    unint64_t v7 = v6;
    if (v6 == 2) {
      break;
    }
    v10.CFIndex location = location;
    v10.CFIndex length = length;
    int v8 = CFStringFindWithOptions(a1, _CFBundleSupportedProductName_platforms[v6 + 1], v10, 8uLL, 0);
    unint64_t v6 = v7 + 1;
  }
  while (!v8);
  return v7 < 2;
}

void ___parseBundleStrings_block_invoke(uint64_t a1, const void *a2, __CFString *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    int v8 = *(__CFBundle **)(a1 + 32);
    unint64_t v7 = (void *)(a1 + 32);
    CFRange v9 = (const void *)_CFStringCreateByParsingMarkdownAndInflectingIfNeeded(cf, v8, 0);
    CFRange v10 = (__CFDictionary *)v7[1];
    if (v9)
    {
      CFDictionaryAddValue(v10, a2, v9);
      CFRelease(v9);
    }
    else
    {
      CFDictionaryAddValue(v10, a2, cf);
      CFIndex v12 = _CFBundleResourceLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        ___parseBundleStrings_block_invoke_cold_1((uint64_t)a2, v7, v12);
      }
    }
  }
  else
  {
    uint64_t v11 = *(__CFDictionary **)(a1 + 40);
    CFDictionaryAddValue(v11, a2, cf);
  }
}

void __CFStringsDictAddFunction(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t applyDictBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_182BB46C8(_Unwind_Exception *a1)
{
}

void __CFVariableWidthStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"NSStringVariableWidthRuleType");
    if (Value)
    {
      CFDictionaryRef v8 = Value;
      if (CFDictionaryGetCount(Value))
      {
        uint64_t context = *(void *)(a3 + 16);
        CFTypeRef cf = CFDictionaryCreateMutableCopy(0, 0, v8);
        CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)__CFVariableWidthStringApplyFunction, &context);
        CFRange v9 = _CFStringCreateWithWidthContexts((uint64_t)cf);
        CFRelease(cf);
        if (v9)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v9);
          CFRelease(v9);
        }
      }
      else if (*(void *)a3 && (CFRange v10 = CFDictionaryGetValue(*(CFDictionaryRef *)a3, a1)) != 0)
      {
        uint64_t v11 = v10;
        CFIndex v12 = *(__CFDictionary **)(a3 + 8);
        CFDictionarySetValue(v12, a1, v11);
      }
      else
      {
        uint64_t v13 = *(__CFDictionary **)(a3 + 8);
        CFDictionaryRemoveValue(v13, a1);
      }
    }
  }
}

void __CFPlatformSpecificStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, CFDictionaryRef *a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"NSStringDeviceSpecificRuleType");
    if (Value)
    {
      CFDictionaryRef v8 = Value;
      CFRange v9 = (const void *)_CFGetProductName();
      if (!CFDictionaryGetCount(v8)) {
        goto LABEL_16;
      }
      if (!v9
        || (CFRange v10 = CFDictionaryGetValue(v8, v9)) == 0
        && (!CFEqual(v9, @"ipod") && !CFEqual(v9, @"ipad")
         || (CFRange v10 = CFDictionaryGetValue(v8, @"iphone")) == 0))
      {
        CFRange v10 = CFDictionaryGetValue(v8, @"other");
        if (!v10) {
          goto LABEL_16;
        }
      }
      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 == CFStringGetTypeID() || (CFTypeID v12 = CFGetTypeID(v10), v12 == CFDictionaryGetTypeID())) {
        CFDictionarySetValue(a3[1], a1, v10);
      }
      CFTypeID v13 = CFGetTypeID(v10);
      if (v13 != CFStringGetTypeID())
      {
        CFTypeID v14 = CFGetTypeID(v10);
        if (v14 != CFDictionaryGetTypeID())
        {
LABEL_16:
          uint64_t v15 = CFDictionaryGetValue(*a3, a1);
          uint64_t v16 = a3[1];
          if (v15)
          {
            CFDictionarySetValue(v16, a1, v15);
          }
          else
          {
            CFDictionaryRemoveValue(v16, a1);
          }
        }
      }
    }
  }
}

void __CFLocalizedFormatStringApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(a2, @"NSStringLocalizedFormatKey");
    if (Value)
    {
      CFDictionaryRef v8 = (const void *)_CFStringCopyWithFomatStringConfiguration(Value, (uint64_t)a2);
      if (v8)
      {
        CFRange v9 = v8;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v8);
        CFRelease(v9);
      }
    }
  }
}

void __CFAttributedLocalizedStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    CFDictionaryRef Value = CFDictionaryGetValue(a2, @"NSStringFormatSpecTypeKey");
    if (Value)
    {
      if (CFEqual(Value, @"NSStringDirectRuleType"))
      {
        CFDictionaryRef v8 = CFDictionaryGetValue(a2, @"NSStringLocalizationKey");
        if (v8
          && (CFRange v9 = v8, CFGetTypeID(v8) == 7)
          && ((CFRange v10 = CFDictionaryGetValue(a2, @"NSStringFormatIsMarkdownKey")) != 0
           && CFEqual(v10, &__kCFBooleanTrue)
           && !*(unsigned char *)(a3 + 40)
            ? (CFTypeID v11 = (const void *)_CFStringCreateWithMarkdownAndConfiguration((uint64_t)v9, (uint64_t)a2, *(void *)(a3 + 24), *(void *)(a3 + 32))): (CFTypeID v11 = CFRetain(v9)), (v12 = v11) != 0))
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v11);
          CFRelease(v12);
        }
        else if (*(void *)a3 && (CFTypeID v13 = CFDictionaryGetValue(*(CFDictionaryRef *)a3, a1)) != 0)
        {
          CFTypeID v14 = v13;
          uint64_t v15 = *(__CFDictionary **)(a3 + 8);
          CFDictionarySetValue(v15, a1, v14);
        }
        else
        {
          uint64_t v16 = *(__CFDictionary **)(a3 + 8);
          CFDictionaryRemoveValue(v16, a1);
        }
      }
    }
  }
}

uint64_t _CFStringCopyWithFomatStringConfiguration(void *a1, uint64_t a2)
{
  if (objc_opt_respondsToSelector())
  {
    return [a1 _copyFormatStringWithConfiguration:a2];
  }
  else
  {
    CFRetain(a1);
    return (uint64_t)a1;
  }
}

uint64_t _CFGetProductName()
{
  if (_CFGetProductName_onceToken != -1) {
    dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
  }
  return _CFGetProductName__cfBundlePlatform;
}

void _searchForExistingFactoryLocked(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  if (!*a3)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 != CFStringGetTypeID()
      || (CFTypeID v6 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) == 0)
    {
      CFTypeID v6 = CFRetain(a1);
    }
    if (_factoriesByFactoryID)
    {
      CFDictionaryRef Value = (CFTypeRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, v6);
      if (Value) {
        *a3 = CFRetain(Value[5]);
      }
    }
    if (v6)
    {
      CFRelease(v6);
    }
  }
}

CFStringRef _searchForDummyUUID(const __CFString *result, const __CFString *a2, unsigned char *a3)
{
  if (!*a3)
  {
    CFStringRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    CFRange result = (const __CFString *)CFStringGetTypeID();
    if ((const __CFString *)v6 == result)
    {
      CFRange result = (const __CFString *)CFStringCompare(v5, @"00000000-0000-0000-0000-000000000000", 0);
      if (a2)
      {
        if (!result)
        {
          CFTypeID v7 = CFGetTypeID(a2);
          CFRange result = (const __CFString *)CFStringGetTypeID();
          if ((const __CFString *)v7 == result)
          {
            CFRange result = (const __CFString *)CFStringCompare(a2, @"MyFactoryFunction", 0);
            if (!result) {
              *a3 = 1;
            }
          }
        }
      }
    }
  }
  return result;
}

void locallySetValueOverlayMergeFunc(void *key, __CFString *value, CFMutableDictionaryRef theDict)
{
  if (value == @"MagicRemovedValue") {
    CFDictionaryRemoveValue(theDict, key);
  }
  else {
    CFDictionarySetValue(theDict, key, value);
  }
}

uint64_t _CFPreferencesCopyAppValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0);
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return _CFAllocatorAllocateImpl((malloc_zone_t *)allocator, size, (v3 >> 2), hint);
}

uint64_t _CompareTestEntryPrefixToTableEntryKey(void *a1, unsigned char **a2)
{
  int v2 = *(unsigned __int8 *)*a1;
  int v3 = **a2;
  BOOL v4 = **a2 == 0;
  if (v2 == v3 && v3 != 0)
  {
    CFTypeID v6 = *a2 + 1;
    CFTypeID v7 = (unsigned __int8 *)(*a1 + 1);
    do
    {
      int v8 = *v7++;
      int v2 = v8;
      int v9 = *v6++;
      int v3 = v9;
      BOOL v4 = v9 == 0;
    }
    while (v2 == v9 && v3 != 0);
  }
  if ((char)v2 < (char)v3) {
    unsigned int v11 = -1;
  }
  else {
    unsigned int v11 = 1;
  }
  if (v4) {
    return 0;
  }
  else {
    return v11;
  }
}

uint64_t __CFSetLastAllocationEventName()
{
  if (__CFOASafe) {
    BOOL v0 = __CFObjectAllocSetLastAllocEventNameFunction == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (!v0) {
    return __CFObjectAllocSetLastAllocEventNameFunction();
  }
  return result;
}

void sub_182BB5E64(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void __NSDictionaryEnumerate(void *a1, char a2, uint64_t a3)
{
  uint64_t v36 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = [a1 count];
  if (v6)
  {
    unint64_t v7 = v6;
    if ((a2 & 1) == 0) {
      goto LABEL_20;
    }
    uint64_t v14 = __CFActiveProcessorCount();
    if (v14 < 2) {
      a2 = 0;
    }
    if (a2)
    {
      uint64_t v8 = 32;
      uint64_t v9 = 16;
      uint64_t v10 = 4;
      if (v7 < 4 * v14) {
        uint64_t v10 = 1;
      }
      if (v7 < 16 * v14) {
        uint64_t v9 = v10;
      }
      if (v7 < 32 * v14) {
        uint64_t v8 = v9;
      }
      if (48 * v14 > v7) {
        uint64_t v11 = v8;
      }
      else {
        uint64_t v11 = 48;
      }
      if (v7 < v14 << 6) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = 64;
      }
      CFTypeID v13 = (void *)_CFAutoreleasePoolPush();
      long long v34 = 0u;
      long long v33 = 0u;
      long long v32 = 0u;
      uint64_t v35 = 0;
      size_t v31 = 850045857;
      v29[0] = 0;
      v29[1] = v29;
      v29[2] = 0x2020000000;
      char v30 = 0;
      block[0] = off_1ECE0A5A0;
      block[1] = 3221225472;
      block[2] = ____NSDictionaryEnumerate_block_invoke;
      block[3] = &unk_1ECDB02C0;
      block[8] = v12;
      block[9] = &v31;
      block[6] = a3;
      block[7] = v29;
      block[4] = [a1 keyEnumerator];
      block[5] = a1;
      dispatch_apply((v7 + v12 - 1) / v12, 0, block);
      _CFAutoreleasePoolPop(v13);
      _Block_object_dispose(v29, 8);
    }
    else
    {
LABEL_20:
      uint64_t v15 = (void *)_CFAutoreleasePoolPush();
      objc_lookUpClass("__NSCFDictionary");
      if (objc_opt_isKindOfClass())
      {
        v27[0] = off_1ECE0A5A0;
        v27[1] = 3221225472;
        v27[2] = ____NSDictionaryEnumerate_block_invoke_2;
        v27[3] = &unk_1ECDABD20;
        v27[4] = a3;
        CFBasicHashApply((uint64_t)a1, (uint64_t)v27);
      }
      else
      {
        if (((v7 >> 59) & 0xF) != 0)
        {
          CFStringRef v25 = CFStringCreateWithFormat(0, 0, @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt", 2 * v7);
          CFIndex v26 = +[NSException exceptionWithName:@"NSGenericException" reason:v25 userInfo:0];
          CFRelease(v25);
          objc_exception_throw(v26);
        }
        if (2 * v7 <= 1) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = 2 * v7;
        }
        unint64_t v18 = MEMORY[0x1F4188790](v17, v16);
        unint64_t v20 = (char *)v27 - v19;
        size_t v31 = 0;
        if (v21 >= 0x101)
        {
          unint64_t v20 = (char *)_CFCreateArrayStorage(v18, 0, &v31);
          int v22 = v20;
        }
        else
        {
          int v22 = 0;
        }
        [a1 getObjects:&v20[8 * v7] andKeys:v20 count:v7];
        LOBYTE(v29[0]) = 0;
        unint64_t v23 = v7 - 1;
        do
        {
          __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(a3);
          if (LOBYTE(v29[0])) {
            BOOL v24 = 1;
          }
          else {
            BOOL v24 = v23 == 0;
          }
          --v23;
          v20 += 8;
        }
        while (!v24);
        free(v22);
      }
      _CFAutoreleasePoolPop(v15);
    }
  }
}

void sub_182BB6978(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void _CFBundleAddValueForType(void *key, __CFDictionary *a2, CFDictionaryRef theDict, const void *a4, __CFDictionary *a5, int a6)
{
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    if (!a5) {
      goto LABEL_7;
    }
  }
  else
  {
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@.%@", @"_CFBT_", key);
    CFDictionaryRef Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    CFDictionarySetValue(a2, v13, Value);
    CFDictionarySetValue(theDict, key, Value);
    CFRelease(Value);
    CFRelease(v13);
    if (!a5) {
      goto LABEL_7;
    }
  }
  if (a6)
  {
    CFDictionarySetValue(a5, key, key);
  }
  else if (CFDictionaryGetValue(a5, key))
  {
    return;
  }
LABEL_7:

  CFArrayAppendValue((CFMutableArrayRef)Value, a4);
}

uint64_t _CFDictionaryFastEnumeration(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (CF_IS_OBJC(0x12uLL, a1)) {
    return 0;
  }

  return __CFBasicHashFastEnumeration(a1, a2, a3, a4);
}

uint64_t __CFBinaryPlistGetOffsetForValueFromArray2(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  uint64_t v6 = 0;
  if (a3 < 8) {
    return v6;
  }
  uint64_t v7 = *(void *)(a4 + 24);
  uint64_t v8 = v7 - 1;
  if (v7 - 1 < a3) {
    return v6;
  }
  uint64_t v6 = 0;
  uint64_t v9 = (unsigned char *)(a1 + a3);
  if (a1 + a3 == -1) {
    return v6;
  }
  char v10 = *v9;
  if ((*v9 & 0xF0) != 0xA0) {
    return v6;
  }
  uint64_t v11 = v9 + 1;
  unint64_t v12 = v10 & 0xF;
  if ((v10 & 0xF) == 0xF)
  {
    if (a1 + v8 < (unint64_t)v11) {
      return 0;
    }
    CFStringRef v13 = v9 + 2;
    unsigned __int8 v14 = *v11;
    if ((*v11 & 0xF0) != 0x10) {
      return 0;
    }
    uint64_t v6 = 0;
    unsigned int v15 = v14 & 0xF;
    uint64_t v16 = 1 << (v14 & 0xF);
    if (__CFADD__(v16, v13) || (unint64_t)&v11[v16] > a1 + v8) {
      return v6;
    }
    switch((char)v16)
    {
      case 1:
        unint64_t v12 = *v13;
        goto LABEL_23;
      case 2:
        unint64_t v12 = __rev16(*(unsigned __int16 *)(v11 + 1));
        goto LABEL_23;
      case 4:
        unint64_t v12 = bswap32(*(_DWORD *)(v11 + 1));
        goto LABEL_23;
      case 8:
        unint64_t v12 = bswap64(*(void *)(v11 + 1));
        goto LABEL_22;
      default:
        if (v15 > 7) {
          return 0;
        }
        unint64_t v12 = 0;
        if ((v16 & 0xFE) != 0) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = 1;
        }
        unint64_t v18 = v11 + 1;
        do
        {
          unsigned int v19 = *v18++;
          unint64_t v12 = v19 | (v12 << 8);
          --v17;
        }
        while (v17);
LABEL_22:
        if ((v12 & 0x8000000000000000) != 0) {
          return 0;
        }
LABEL_23:
        uint64_t v11 = &v13[v16];
        break;
    }
  }
  if (v12 <= a5) {
    return 0;
  }
  unint64_t v20 = *(unsigned __int8 *)(a4 + 7);
  if (!is_mul_ok(v12, v20)) {
    return 0;
  }
  uint64_t v6 = 0;
  if (__CFADD__(v12 * v20, v11) || a1 + v8 < (unint64_t)&v11[v12 * v20 - 1]) {
    return v6;
  }
  unint64_t v21 = (unsigned int *)&v11[v20 * a5];
  if (a1 + 8 > (unint64_t)v21) {
    return 0;
  }
  uint64_t v22 = a1 + v7;
  if (v22 - v20 < (unint64_t)v21) {
    return 0;
  }
  unint64_t v23 = *(unsigned __int8 *)(a4 + 7);
  switch((int)v20)
  {
    case 0:
      break;
    case 1:
      unint64_t v23 = *(unsigned __int8 *)v21;
      break;
    case 2:
      unint64_t v23 = __rev16(*(unsigned __int16 *)v21);
      break;
    case 4:
      unint64_t v23 = bswap32(*v21);
      break;
    case 8:
      unint64_t v23 = bswap64(*(void *)v21);
      break;
    default:
      unint64_t v23 = 0;
      do
      {
        unsigned int v24 = *(unsigned __int8 *)v21;
        unint64_t v21 = (unsigned int *)((char *)v21 + 1);
        unint64_t v23 = v24 | (v23 << 8);
        --v20;
      }
      while (v20);
      break;
  }
  if (*(void *)(a4 + 8) <= v23) {
    return 0;
  }
  if (a6)
  {
    unint64_t v25 = *(unsigned __int8 *)(a4 + 6);
    CFIndex v26 = (unsigned int *)(v22 + v23 * v25);
    switch(*(unsigned char *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        unint64_t v25 = *(unsigned __int8 *)v26;
        break;
      case 2:
        unint64_t v25 = __rev16(*(unsigned __int16 *)v26);
        break;
      case 4:
        unint64_t v25 = bswap32(*v26);
        break;
      case 8:
        unint64_t v25 = bswap64(*(void *)v26);
        break;
      default:
        uint64_t v28 = *(unsigned __int8 *)(a4 + 6);
        unint64_t v25 = 0;
        do
        {
          unsigned int v29 = *(unsigned __int8 *)v26;
          CFIndex v26 = (unsigned int *)((char *)v26 + 1);
          unint64_t v25 = v29 | (v25 << 8);
          --v28;
        }
        while (v28);
        break;
    }
    *a6 = v25;
  }
  return 1;
}

uint64_t _CFKeyedArchiverUIDCreate(__objc2_class **a1, int a2)
{
  uint64_t result = _CFRuntimeCreateInstance(a1, 0x29uLL, 8, 0);
  if (result) {
    *(_DWORD *)(result + 16) = a2;
  }
  return result;
}

unint64_t _CFStringCreateTaggedPointerString(unsigned __int8 *a1, uint64_t a2)
{
  if (!a2) {
    return (unint64_t)&stru_1ECE10768;
  }
  if (!__CFTaggedStringClass) {
    return 0;
  }
  if (a2 > 7)
  {
    if ((unint64_t)a2 <= 0xB)
    {
      if ((unint64_t)a2 >= 0xA)
      {
        uint64_t v6 = 0;
        uint64_t v9 = a2;
        while (1)
        {
          unint64_t v10 = charToSixBitLookup_0[*a1];
          if (v10 > 0x1F) {
            break;
          }
          uint64_t v6 = v10 | (32 * v6);
          ++a1;
          if (!--v9)
          {
LABEL_15:
            unint64_t result = (8 * a2) | (v6 << 7) | 0x8000000000000002;
            unint64_t v5 = result ^ *(void *)off_1ECE0A6F0;
            goto LABEL_16;
          }
        }
      }
      else
      {
        uint64_t v6 = 0;
        uint64_t v7 = a2;
        while (1)
        {
          unint64_t v8 = charToSixBitLookup_0[*a1];
          if (v8 > 0x3F) {
            break;
          }
          uint64_t v6 = v8 | (v6 << 6);
          ++a1;
          if (!--v7) {
            goto LABEL_15;
          }
        }
      }
    }
    return 0;
  }
  __memmove_chk();
  unint64_t result = (8 * a2) | 0x8000000000000002;
  unint64_t v5 = *(void *)off_1ECE0A6F0 ^ result;
LABEL_16:
  if ((~v5 & 0xC000000000000007) != 0) {
    return v5 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)off_1ECE0A6E0 + (v5 & 7));
  }
  return result;
}

CFNumberRef _CFURLCreateFromPropertyListRepresentation(const __CFAllocator *a1, CFTypeRef cf)
{
  valuePtr[1] = *(void *)off_1ECE0A5B0;
  if (CFGetTypeID(cf) != 18) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLString");
  if (!Value) {
    return 0;
  }
  CFStringRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID()) {
    return 0;
  }
  CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLStringType");
  CFNumberRef v8 = v7;
  if (!v7) {
    return v8;
  }
  CFTypeID v9 = CFGetTypeID(v7);
  if (v9 != CFNumberGetTypeID()) {
    return 0;
  }
  valuePtr[0] = 0;
  if (!CFNumberGetValue(v8, kCFNumberSInt32Type, valuePtr)) {
    return 0;
  }
  CFNumberRef v8 = 0;
  if (LODWORD(valuePtr[0]) > 0xF || ((1 << SLOBYTE(valuePtr[0])) & 0x8007) == 0) {
    return v8;
  }
  CFStringRef v10 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLBaseURLString");
  if (v10)
  {
    CFStringRef v11 = v10;
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 == CFStringGetTypeID())
    {
      CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLBaseStringType");
      if (v13)
      {
        CFNumberRef v14 = v13;
        CFTypeID v15 = CFGetTypeID(v13);
        if (v15 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue(v14, kCFNumberSInt32Type, (char *)valuePtr + 4))
          {
            uint64_t v16 = HIDWORD(valuePtr[0]);
            if (HIDWORD(valuePtr[0]) < 3)
            {
              CFIndex Length = CFStringGetLength(v11);
              BOOL v18 = CFStringGetCharacterAtIndex(v11, Length - 1) == 47;
              CFURLRef v19 = (const __CFURL *)_CFURLCreateWithFileSystemPath(a1, v11, v16, v18, 0);
LABEL_24:
              CFURLRef v20 = v19;
              goto LABEL_17;
            }
            if (HIDWORD(valuePtr[0]) == 15)
            {
              CFURLRef v19 = (const __CFURL *)_CFURLCreateWithURLString((__objc2_class **)a1, v11, 0, 0);
              goto LABEL_24;
            }
          }
        }
      }
    }
    return 0;
  }
  CFURLRef v20 = 0;
LABEL_17:
  uint64_t v21 = SLODWORD(valuePtr[0]);
  if (LODWORD(valuePtr[0]) == 15)
  {
    CFNumberRef v22 = (const __CFNumber *)_CFURLCreateWithURLString((__objc2_class **)a1, v5, 0, v20);
  }
  else
  {
    CFIndex v23 = CFStringGetLength(v5);
    BOOL v24 = CFStringGetCharacterAtIndex(v5, v23 - 1) == 47;
    CFNumberRef v22 = (const __CFNumber *)_CFURLCreateWithFileSystemPath(a1, v5, v21, v24, v20);
  }
  CFNumberRef v8 = v22;
  if (v20) {
    CFRelease(v20);
  }
  return v8;
}

void sub_182BB99F0(_Unwind_Exception *exception_object)
{
}

Boolean CFDictionaryContainsValue(CFDictionaryRef theDict, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict)) {
    return [(__CFDictionary *)theDict containsObject:value];
  }
  else {
    return CFBasicHashGetCountOfValue((uint64_t)theDict, (unint64_t)value) > 0;
  }
}

void sub_182BBA20C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CFStringHashCharacters(unsigned __int16 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0;
    uint64_t v4 = a2;
    do
    {
      uint64_t v4 = a1[v5 + 3] + 67503105 * v4 + 257 * (257 * (257 * a1[v5] + a1[v5 + 1]) + a1[v5 + 2]);
      BOOL v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    CFNumberRef v7 = (unsigned __int16 *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFFELL) - 32);
    for (uint64_t i = -20; i < 12; i += 4)
    {
      uint64_t v4 = v7[3] + 67503105 * v4 + 257 * (257 * (257 * *v7 + v7[1]) + v7[2]);
      v7 += 4;
    }
    CFTypeID v9 = &a1[a2];
    CFStringRef v10 = v9 - 32;
    do
    {
      uint64_t v4 = v10[3] + 67503105 * v4 + 257 * (257 * (257 * *v10 + v10[1]) + v10[2]);
      v10 += 4;
    }
    while (v10 < v9);
  }
  else
  {
    int v2 = &a1[a2];
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      uint64_t v4 = a2;
    }
    else
    {
      int v3 = &a1[a2 & 0xFFFFFFFFFFFFFFFCLL];
      uint64_t v4 = a2;
      do
      {
        uint64_t v4 = a1[3] + 67503105 * v4 + 257 * (257 * (257 * *a1 + a1[1]) + a1[2]);
        a1 += 4;
      }
      while (a1 < v3);
    }
    while (a1 < v2)
    {
      unsigned int v11 = *a1++;
      uint64_t v4 = 257 * v4 + v11;
    }
  }
  return (v4 << (a2 & 0x1F)) + v4;
}

uint64_t CFBasicHashGetCountOfValue(uint64_t result, unint64_t a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (a2 == 2814029233 || !*(_DWORD *)(result + 20)) {
    return 0;
  }
  __int16 v2 = *(_WORD *)(result + 18);
  if ((v2 & 4) != 0)
  {
    uint64_t v6 = 0;
    CFNumberRef v7 = &v6;
    uint64_t v8 = 0x2020000000;
    uint64_t v9 = 0;
    v5[0] = off_1ECE0A5A0;
    v5[1] = 3221225472;
    v5[2] = __CFBasicHashGetCountOfValue_block_invoke;
    v5[3] = &unk_1ECDFFA68;
    v5[5] = a2;
    v5[6] = result;
    _OWORD v5[4] = &v6;
    CFBasicHashApply(result, (uint64_t)v5);
    uint64_t v4 = v7[3];
    _Block_object_dispose(&v6, 8);
    return v4;
  }
  if (!*(unsigned char *)(result + 26))
  {
    long long v10 = xmmword_182EDDE80;
    long long v11 = *(_OWORD *)algn_182EDDE90;
    return *((void *)&v11 + 1);
  }
  int v3 = v2 & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
    }
  }
  else
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
    }
  }
  __break(1u);
  return result;
}

void sub_182BBA5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t _NSIsNSNumber(uint64_t a1)
{
  if (a1 < 0)
  {
    uint64_t v2 = 0;
    int v3 = *(_DWORD *)off_1ECE0A6F0;
    if ((~a1 & 0xC000000000000007) == 0) {
      LOBYTE(v3) = 0;
    }
    uint64_t v4 = (v3 ^ a1) & 7;
    do
    {
      if (v4 == *((unsigned __int8 *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    LOBYTE(Class) = (v2 & 7) == 3;
    return Class & 1;
  }
  if (_NSNumberClass)
  {
    if (a1) {
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  Class Class = objc_getClass("NSNumber");
  _NSNumberClass Class = (uint64_t)Class;
  if (!Class) {
    return Class & 1;
  }
  if (!a1)
  {
LABEL_16:
    LOBYTE(Class) = 0;
    return Class & 1;
  }
LABEL_10:
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
    return Class & 1;
  }

  return MethodImplementation(a1, sel_isNSNumber__);
}

uint64_t __CFNumberHash(uint64_t a1)
{
  v16[1] = *(double *)off_1ECE0A5B0;
  if ((a1 & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  unint64_t v3 = v2 ^ a1;
  unint64_t v4 = v3 & 7;
  while (v4 != *((unsigned __int8 *)off_1ECE0A6E0 + v1))
  {
    if (++v1 == 7) {
      goto LABEL_12;
    }
  }
  if (v1 == 3)
  {
    uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 == 7) {
      uint64_t v5 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v6 = v5 & (v3 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v6) = atomic_load((unint64_t *)(a1 + 8));
  }
  if ((unint64_t)(__CFNumberCanonicalTypes[v6 & 7] - 1) > 2)
  {
    v16[0] = 0.0;
    __CFNumberGetValue(a1, 6, (uint64_t)v16);
    double v9 = -v16[0];
    if (v16[0] >= 0.0) {
      double v9 = v16[0];
    }
    long double v10 = floor(v9 + 0.5);
    double v11 = (v9 - v10) * 1.84467441e19;
    double v12 = fmod(v10, 1.84467441e19);
    unint64_t v13 = 2654435761u * (unint64_t)v12;
    unint64_t v14 = v13 + (unint64_t)v11;
    if (v11 <= 0.0) {
      unint64_t v14 = 2654435761u * (unint64_t)v12;
    }
    unint64_t v15 = v13 - (unint64_t)fabs(v11);
    if (v11 < 0.0) {
      return v15;
    }
    else {
      return v14;
    }
  }
  else
  {
    LODWORD(v16[0]) = 0;
    __CFNumberGetValue(a1, 3, (uint64_t)v16);
    unsigned int v7 = LODWORD(v16[0]);
    if (SLODWORD(v16[0]) < 0) {
      unsigned int v7 = -LODWORD(v16[0]);
    }
    return 2654435761 * v7;
  }
}

uint64_t __CFNumberGetValue(uint64_t result, uint64_t a2, uint64_t a3)
{
  v75[1] = *(void *)off_1ECE0A5B0;
  if ((result & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)off_1ECE0A6F0;
  if ((~result & 0xC000000000000007) == 0) {
    uint64_t v4 = 0;
  }
  unint64_t v5 = v4 ^ result;
  uint64_t v6 = v5 & 7;
  while (v6 != *((unsigned __int8 *)off_1ECE0A6E0 + v3))
  {
    if (++v3 == 7) {
      goto LABEL_12;
    }
  }
  if (v3 == 3)
  {
    uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7) {
      uint64_t v7 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v8 = v7 & (v5 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(result + 8));
  }
  unsigned int v9 = (unsigned __int16)__CFNumberTypeTable[__CFNumberCanonicalTypes[v8 & 7]];
  uint64_t v10 = __CFNumberTypeTable[a2] & 0x1FLL;
  unint64_t v11 = result + 16;
  int v12 = (v9 >> 5) & 1;
  int v13 = (v9 >> 6) & 1;
  v75[0] = 0;
  if (result < 0)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *(void *)off_1ECE0A6F0;
    if ((~result & 0xC000000000000007) == 0) {
      uint64_t v15 = 0;
    }
    uint64_t v16 = v15 ^ result;
    uint64_t v17 = v16 & 7;
    while (v17 != *((unsigned __int8 *)off_1ECE0A6E0 + v14))
    {
      if (++v14 == 7) {
        goto LABEL_26;
      }
    }
    if (v14 == 3)
    {
      int v13 = 0;
      int v12 = 0;
      uint64_t v18 = v16 << 9 >> 12;
      if (v17 != 7) {
        uint64_t v18 = (2 * v16) >> 4;
      }
      char v19 = 6;
      if ((v16 & 0x40) == 0) {
        char v19 = 4;
      }
      v75[0] = v18 >> v19;
      unint64_t v11 = (unint64_t)v75;
    }
  }
LABEL_26:
  switch(v10)
  {
    case 1:
      if (v12)
      {
        if (v13)
        {
          double v20 = *(double *)v11;
          double v21 = 127.0;
          if (*(double *)v11 <= 127.0) {
            double v21 = *(double *)v11;
          }
          LODWORD(v22) = (int)v21;
          BOOL v23 = v20 < -128.0;
        }
        else
        {
          float v52 = *(float *)v11;
          float v53 = 127.0;
          if (*(float *)v11 <= 127.0) {
            float v53 = *(float *)v11;
          }
          LODWORD(v22) = (int)v53;
          BOOL v23 = v52 < -128.0;
        }
        if (v23) {
          LOBYTE(v22) = 0x80;
        }
LABEL_108:
        *(unsigned char *)a3 = v22;
        return result;
      }
      double v40 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v40 > 0 || (unint64_t v22 = *(void *)(v11 + 8), v40 == 0.0) && v22 > 0x7F)
        {
          LOBYTE(v22) = 127;
        }
        else
        {
          if (v22 < 0xFFFFFFFFFFFFFF80 && *(void *)&v40 == -1) {
            LOBYTE(v22) = 0x80;
          }
          if (*(uint64_t *)&v40 < -1) {
            LOBYTE(v22) = 0x80;
          }
        }
        goto LABEL_108;
      }
      uint64_t v68 = 127;
      if (*(uint64_t *)&v40 < 127) {
        uint64_t v68 = *(void *)&v40;
      }
      if (v68 <= -128) {
        LOBYTE(v68) = 0x80;
      }
      *(unsigned char *)a3 = v68;
      return result;
    case 2:
      if (v12)
      {
        if (v13)
        {
          double v24 = *(double *)v11;
          double v25 = 32767.0;
          if (*(double *)v11 <= 32767.0) {
            double v25 = *(double *)v11;
          }
          LODWORD(v26) = (int)v25;
          BOOL v27 = v24 < -32768.0;
        }
        else
        {
          float v54 = *(float *)v11;
          float v55 = 32767.0;
          if (*(float *)v11 <= 32767.0) {
            float v55 = *(float *)v11;
          }
          LODWORD(v26) = (int)v55;
          BOOL v27 = v54 < -32768.0;
        }
        if (v27) {
          LOWORD(v26) = 0x8000;
        }
LABEL_114:
        *(_WORD *)a3 = v26;
        return result;
      }
      double v41 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v41 > 0 || (unint64_t v26 = *(void *)(v11 + 8), v41 == 0.0) && v26 >> 15)
        {
          LOWORD(v26) = 0x7FFF;
        }
        else
        {
          if (v26 < 0xFFFFFFFFFFFF8000 && *(void *)&v41 == -1) {
            LOWORD(v26) = 0x8000;
          }
          if (*(uint64_t *)&v41 < -1) {
            LOWORD(v26) = 0x8000;
          }
        }
        goto LABEL_114;
      }
      uint64_t v69 = 0x7FFFLL;
      if (*(uint64_t *)&v41 < 0x7FFF) {
        uint64_t v69 = *(void *)&v41;
      }
      if (v69 <= -32768) {
        LOWORD(v69) = 0x8000;
      }
      *(_WORD *)a3 = v69;
      return result;
    case 3:
      if (v12)
      {
        if (v13)
        {
          double v28 = *(double *)v11;
          double v29 = 2147483650.0;
          if (*(double *)v11 <= 2147483650.0) {
            double v29 = *(double *)v11;
          }
          LODWORD(v11) = (int)v29;
          BOOL v30 = v28 < -2147483650.0;
        }
        else
        {
          float v56 = *(float *)v11;
          float v57 = 2147500000.0;
          if (*(float *)v11 <= 2147500000.0) {
            float v57 = *(float *)v11;
          }
          LODWORD(v11) = (int)v57;
          BOOL v30 = v56 < -2147500000.0;
        }
        unsigned int v58 = 0x80000000;
        goto LABEL_119;
      }
      double v42 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v42 > 0 || (unint64_t v11 = *(void *)(v11 + 8), v42 == 0.0) && v11 >> 31)
        {
          LODWORD(v11) = 0x7FFFFFFF;
        }
        else
        {
          if (v11 < 0xFFFFFFFF80000000 && *(void *)&v42 == -1) {
            LODWORD(v11) = 0x80000000;
          }
          if (*(uint64_t *)&v42 < -1) {
            LODWORD(v11) = 0x80000000;
          }
        }
        goto LABEL_130;
      }
      int64_t v70 = 0x7FFFFFFFLL;
      if (*(uint64_t *)&v42 < 0x7FFFFFFF) {
        int64_t v70 = *(void *)&v42;
      }
      if (v70 <= (uint64_t)0xFFFFFFFF80000000) {
        LODWORD(v70) = 0x80000000;
      }
      *(_DWORD *)a3 = v70;
      return result;
    case 4:
      if (v12)
      {
        if (v13)
        {
          double v31 = *(double *)v11;
          double v32 = 9.22337204e18;
          if (*(double *)v11 <= 9.22337204e18) {
            double v32 = *(double *)v11;
          }
          uint64_t v33 = (uint64_t)v32;
          BOOL v34 = v31 < -9.22337204e18;
        }
        else
        {
          float v59 = *(float *)v11;
          float v60 = 9.2234e18;
          if (*(float *)v11 <= 9.2234e18) {
            float v60 = *(float *)v11;
          }
          uint64_t v33 = (uint64_t)v60;
          BOOL v34 = v59 < -9.2234e18;
        }
        unint64_t v61 = 0x8000000000000000;
        goto LABEL_126;
      }
      double v43 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v43 > 0 || (uint64_t v33 = *(void *)(v11 + 8), v43 == 0.0) && v33 < 0)
        {
          uint64_t v33 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else
        {
          if (v33 > -1 && *(void *)&v43 == -1) {
            uint64_t v33 = 0x8000000000000000;
          }
          if (*(uint64_t *)&v43 < -1) {
            uint64_t v33 = 0x8000000000000000;
          }
        }
        goto LABEL_128;
      }
      *(double *)a3 = v43;
      return result;
    case 5:
      if (v12)
      {
        if (v13)
        {
          double v35 = *(double *)v11;
          if (fabs(*(double *)v11) != INFINITY)
          {
            double v36 = 3.40282347e38;
            if (v35 <= 3.40282347e38) {
              double v36 = *(double *)v11;
            }
            float v37 = v36;
            BOOL v23 = v35 < -3.40282347e38;
            float v38 = -3.4028e38;
            if (!v23) {
              float v38 = v37;
            }
LABEL_158:
            *(float *)a3 = v38;
            return result;
          }
          BOOL v30 = v35 < 0.0;
          LODWORD(v11) = 2139095040;
          unsigned int v58 = -8388608;
LABEL_119:
          if (v30) {
            LODWORD(v11) = v58;
          }
        }
        else
        {
          LODWORD(v11) = *(_DWORD *)v11;
        }
LABEL_130:
        *(_DWORD *)a3 = v11;
        return result;
      }
      double v44 = *(double *)v11;
      if (v13)
      {
        unint64_t v45 = *(void *)(v11 + 8);
        uint64_t v46 = -*(void *)&v44;
        if (v45) {
          uint64_t v46 = ~*(void *)&v44;
        }
        if (v44 < 0.0) {
          unint64_t v45 = -(uint64_t)v45;
        }
        else {
          uint64_t v46 = *(void *)&v44;
        }
        double v47 = -((double)v45 + (double)v46 * 1.84467441e19);
        if (v44 >= 0.0) {
          double v47 = (double)v45 + (double)v46 * 1.84467441e19;
        }
        float v38 = v47;
      }
      else
      {
        float v38 = (float)*(uint64_t *)&v44;
        if ((float)*(uint64_t *)&v44 > 3.4028e38) {
          float v38 = 3.4028e38;
        }
      }
      goto LABEL_158;
    case 6:
      if (v12)
      {
        if (v13)
        {
          uint64_t v33 = *(void *)v11;
LABEL_128:
          *(void *)a3 = v33;
          return result;
        }
        float v62 = *(float *)v11;
        if (fabsf(*(float *)v11) == INFINITY)
        {
          BOOL v34 = v62 < 0.0;
          uint64_t v33 = 0x7FF0000000000000;
          unint64_t v61 = 0xFFF0000000000000;
LABEL_126:
          if (v34) {
            uint64_t v33 = v61;
          }
          goto LABEL_128;
        }
        double v63 = v62;
        double v64 = 1.79769313e308;
        if (v63 <= 1.79769313e308) {
          double v64 = v63;
        }
        if (v63 >= -1.79769313e308) {
          double v51 = v64;
        }
        else {
          double v51 = -1.79769313e308;
        }
      }
      else
      {
        double v48 = *(double *)v11;
        if (v13)
        {
          unint64_t v49 = *(void *)(v11 + 8);
          uint64_t v50 = -*(void *)&v48;
          if (v49) {
            uint64_t v50 = ~*(void *)&v48;
          }
          if (v48 < 0.0) {
            unint64_t v49 = -(uint64_t)v49;
          }
          else {
            uint64_t v50 = *(void *)&v48;
          }
          double v51 = -((double)v49 + (double)v50 * 1.84467441e19);
          if (v48 >= 0.0) {
            double v51 = (double)v49 + (double)v50 * 1.84467441e19;
          }
        }
        else
        {
          double v51 = (double)*(uint64_t *)&v48;
          if ((double)*(uint64_t *)&v48 > 1.79769313e308) {
            double v51 = 1.79769313e308;
          }
        }
      }
      *(double *)a3 = v51;
      return result;
    case 17:
      if (!v12)
      {
        if (v13)
        {
          *(_OWORD *)a3 = *(_OWORD *)v11;
          return result;
        }
        uint64_t v66 = *(void *)v11;
        uint64_t v67 = v66 >> 63;
        goto LABEL_167;
      }
      if (v13)
      {
        double v39 = *(double *)v11;
        if (*(double *)v11 >= -1.70141183e38)
        {
          if (v39 >= 1.70141183e38) {
            goto LABEL_166;
          }
          goto LABEL_165;
        }
LABEL_138:
        uint64_t v66 = 0;
        uint64_t v67 = 0x8000000000000000;
        goto LABEL_167;
      }
      float v65 = *(float *)v11;
      if (*(float *)v11 < -1.7014e38) {
        goto LABEL_138;
      }
      if (v65 >= 1.7014e38)
      {
LABEL_166:
        uint64_t v66 = -1;
        uint64_t v67 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_167;
      }
      double v39 = v65;
LABEL_165:
      uint64_t v67 = vcvtmd_s64_f64(v39 * 5.42101086e-20);
      uint64_t v66 = (unint64_t)(v39 + floor(v39 * 5.42101086e-20) * -1.84467441e19);
LABEL_167:
      *(void *)a3 = v67;
      *(void *)(a3 + 8) = v66;
      return result;
    default:
      return result;
  }
}

uint64_t _CFNonObjCHash(uint64_t a1)
{
  __CFCheckCFInfoPACSignature_Bridged(a1);
  if (a1 < 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    if ((~a1 & 0xC000000000000007) == 0) {
      uint64_t v3 = 0;
    }
    unint64_t v4 = v3 ^ a1;
    do
    {
      if ((v4 & 7) == *((unsigned char *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    unint64_t v5 = v2 | v4;
    uint64_t v6 = v2 & 7;
    int v7 = (v5 >> 55) + 8;
    if (v6 == 7) {
      int v8 = v7;
    }
    else {
      int v8 = v6;
    }
    unint64_t v9 = 22;
    switch(v8)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          _CFNonObjCHash_cold_1();
        }
        goto LABEL_19;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_18;
      case 3:
        goto LABEL_22;
      case 4:
      case 5:
        goto LABEL_19;
      case 6:
        unint64_t v9 = 42;
        goto LABEL_22;
      default:
        if (v8 == 20)
        {
LABEL_19:
          unint64_t v9 = 1;
          goto LABEL_22;
        }
        if (v8 == 22)
        {
LABEL_18:
          unint64_t v9 = 7;
          goto LABEL_22;
        }
LABEL_20:
        unint64_t v9 = [(id)a1 _cfTypeID];
        break;
    }
  }
  else
  {
    unint64_t v10 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v9 = (v10 >> 8) & 0x3FF;
  }
  if (v9 <= 0x47) {
LABEL_22:
  }
    unint64_t v11 = &__CFRuntimeBuiltinClassTable + v9;
  else {
    unint64_t v11 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v9 - 72) >> 6] + 8 * ((v9 - 72) & 0x3F));
  }
  int v12 = (uint64_t (*)(uint64_t))*((void *)*v11 + 6);
  if (!v12) {
    return a1;
  }

  return v12(a1);
}

uint64_t _NSIsNSDictionary(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSDictionary__);
}

uint64_t _CFNonObjCEqual(unint64_t *a1, unint64_t a2)
{
  if (a1 == (unint64_t *)a2) {
    return 1;
  }
  if (!a2) {
    _CFNonObjCEqual_cold_1();
  }
  if ((a2 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)off_1ECE0A6F0;
    if ((~a2 & 0xC000000000000007) == 0) {
      uint64_t v5 = 0;
    }
    unint64_t v6 = v5 ^ a2;
    do
    {
      if ((v6 & 7) == *((unsigned char *)off_1ECE0A6E0 + v4)) {
        break;
      }
      ++v4;
    }
    while (v4 != 7);
    unint64_t v7 = v4 | v6;
    uint64_t v8 = v4 & 7;
    int v9 = (v7 >> 55) + 8;
    if (v8 == 7) {
      int v10 = v9;
    }
    else {
      int v10 = v8;
    }
    unint64_t v11 = 22;
    switch(v10)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          _CFNonObjCEqual_cold_5();
        }
        goto LABEL_20;
      case 1:
        goto LABEL_21;
      case 2:
        goto LABEL_19;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_20;
      case 6:
        unint64_t v11 = 42;
        break;
      default:
        if (v10 == 20)
        {
LABEL_20:
          unint64_t v11 = 1;
        }
        else if (v10 == 22)
        {
LABEL_19:
          unint64_t v11 = 7;
        }
        else
        {
LABEL_21:
          unint64_t v11 = [(id)a2 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v13 = atomic_load((unint64_t *)(a2 + 8));
    unint64_t v11 = (v13 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v11, a2)) {
    return [(id)a2 isEqual:a1];
  }
  __CFCheckCFInfoPACSignature_Bridged((uint64_t)a1);
  __CFCheckCFInfoPACSignature_Bridged(a2);
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
      uint64_t v15 = 0;
    }
    unint64_t v16 = v15 ^ (unint64_t)a1;
    do
    {
      if ((v16 & 7) == *((unsigned char *)off_1ECE0A6E0 + v14)) {
        break;
      }
      ++v14;
    }
    while (v14 != 7);
    unint64_t v17 = v14 | v16;
    uint64_t v18 = v14 & 7;
    int v19 = (v17 >> 55) + 8;
    if (v18 == 7) {
      int v20 = v19;
    }
    else {
      int v20 = v18;
    }
    uint64_t v21 = 22;
    switch(v20)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          _CFNonObjCEqual_cold_4();
        }
        goto LABEL_41;
      case 1:
        goto LABEL_42;
      case 2:
        goto LABEL_40;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_41;
      case 6:
        uint64_t v21 = 42;
        break;
      default:
        if (v20 == 20)
        {
LABEL_41:
          uint64_t v21 = 1;
        }
        else if (v20 == 22)
        {
LABEL_40:
          uint64_t v21 = 7;
        }
        else
        {
LABEL_42:
          uint64_t v21 = [a1 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v22 = atomic_load(a1 + 1);
    uint64_t v21 = (v22 >> 8) & 0x3FF;
  }
  if ((a2 & 0x8000000000000000) != 0)
  {
    uint64_t v23 = 0;
    uint64_t v24 = *(void *)off_1ECE0A6F0;
    if ((~a2 & 0xC000000000000007) == 0) {
      uint64_t v24 = 0;
    }
    unint64_t v25 = v24 ^ a2;
    do
    {
      if ((v25 & 7) == *((unsigned char *)off_1ECE0A6E0 + v23)) {
        break;
      }
      ++v23;
    }
    while (v23 != 7);
    unint64_t v26 = v23 | v25;
    uint64_t v27 = v23 & 7;
    int v28 = (v26 >> 55) + 8;
    if (v27 == 7) {
      int v29 = v28;
    }
    else {
      int v29 = v27;
    }
    uint64_t v30 = 22;
    switch(v29)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          _CFNonObjCEqual_cold_3();
        }
        goto LABEL_60;
      case 1:
        goto LABEL_61;
      case 2:
        goto LABEL_59;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_60;
      case 6:
        uint64_t v30 = 42;
        break;
      default:
        if (v29 == 20)
        {
LABEL_60:
          uint64_t v30 = 1;
        }
        else if (v29 == 22)
        {
LABEL_59:
          uint64_t v30 = 7;
        }
        else
        {
LABEL_61:
          uint64_t v30 = [(id)a2 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v31 = atomic_load((unint64_t *)(a2 + 8));
    uint64_t v30 = (v31 >> 8) & 0x3FF;
  }
  if (v21 != v30) {
    return 0;
  }
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    uint64_t v32 = 0;
    uint64_t v33 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
      uint64_t v33 = 0;
    }
    unint64_t v34 = v33 ^ (unint64_t)a1;
    do
    {
      if ((v34 & 7) == *((unsigned char *)off_1ECE0A6E0 + v32)) {
        break;
      }
      ++v32;
    }
    while (v32 != 7);
    unint64_t v35 = v32 | v34;
    uint64_t v36 = v32 & 7;
    int v37 = (v35 >> 55) + 8;
    int v38 = v36 == 7 ? v37 : v36;
    unint64_t v39 = 22;
    switch(v38)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          _CFNonObjCEqual_cold_2();
        }
        goto LABEL_82;
      case 1:
        goto LABEL_83;
      case 2:
        goto LABEL_81;
      case 3:
        goto LABEL_85;
      case 4:
      case 5:
        goto LABEL_82;
      case 6:
        unint64_t v39 = 42;
        goto LABEL_85;
      default:
        if (v38 == 20)
        {
LABEL_82:
          unint64_t v39 = 1;
          goto LABEL_85;
        }
        if (v38 == 22)
        {
LABEL_81:
          unint64_t v39 = 7;
          goto LABEL_85;
        }
LABEL_83:
        unint64_t v39 = [a1 _cfTypeID];
        break;
    }
  }
  else
  {
    unint64_t v40 = atomic_load(a1 + 1);
    unint64_t v39 = (v40 >> 8) & 0x3FF;
  }
  if (v39 <= 0x47) {
LABEL_85:
  }
    double v41 = &__CFRuntimeBuiltinClassTable + v39;
  else {
    double v41 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v39 - 72) >> 6] + 8 * ((v39 - 72) & 0x3F));
  }
  double v42 = (uint64_t (*)(unint64_t *, unint64_t))*((void *)*v41 + 5);
  if (!v42) {
    return 0;
  }

  return v42(a1, a2);
}

BOOL __CFDataEqual(unint64_t *a1, unint64_t *a2)
{
  size_t v2 = a1[2];
  if (v2 != a2[2]) {
    return 0;
  }
  char v3 = atomic_load(a1 + 1);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (const void *)(((unint64_t)a1 + 63) & 0xFFFFFFFFFFFFFFF0);
  }
  else {
    uint64_t v4 = (const void *)a1[5];
  }
  char v6 = atomic_load(a2 + 1);
  if ((v6 & 4) != 0) {
    unint64_t v7 = (const void *)(((unint64_t)a2 + 63) & 0xFFFFFFFFFFFFFFF0);
  }
  else {
    unint64_t v7 = (const void *)a2[5];
  }
  return v4 == v7 || memcmp(v4, v7, v2) == 0;
}

uint64_t _NSIsNSDate(uint64_t a1)
{
  if (a1 < 0)
  {
    uint64_t v2 = 0;
    int v3 = *(_DWORD *)off_1ECE0A6F0;
    if ((~a1 & 0xC000000000000007) == 0) {
      LOBYTE(v3) = 0;
    }
    uint64_t v4 = (v3 ^ a1) & 7;
    do
    {
      if (v4 == *((unsigned __int8 *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    isKindOfClass Class = (v2 & 7) == 6;
    return isKindOfClass & 1;
  }
  if (!a1)
  {
    isKindOfClass Class = 0;
    return isKindOfClass & 1;
  }
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    isKindOfClass Class = objc_opt_isKindOfClass();
    return isKindOfClass & 1;
  }

  return MethodImplementation(a1, sel_isNSDate__);
}

uint64_t __CFArrayEqual(unint64_t *a1, unint64_t *a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v4 = a1[2];
  if (v4 != a2[2]) {
    return 0;
  }
  unsigned int v5 = atomic_load(a1 + 1);
  int v6 = (v5 >> 2) & 3;
  if (v6)
  {
    if (v6 == 1)
    {
      unint64_t v7 = &kCFTypeArrayCallBacks;
    }
    else
    {
      char v9 = atomic_load(a1 + 1);
      int v10 = v9 & 3;
      uint64_t v11 = v10 ? 0 : (uint64_t)(a1 + 6);
      unint64_t v7 = v10 == 2 ? (const CFArrayCallBacks *)(a1 + 6) : (const CFArrayCallBacks *)v11;
    }
  }
  else
  {
    unint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  unsigned int v12 = atomic_load(a2 + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      uint64_t v14 = &kCFTypeArrayCallBacks;
    }
    else
    {
      atomic_load(a2 + 1);
      uint64_t v14 = (const CFArrayCallBacks *)(a2 + 6);
    }
  }
  else
  {
    uint64_t v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  if (v7->equal != v14->equal) {
    return 0;
  }
  if (v4 < 1) {
    return 1;
  }
  uint64_t v15 = 0;
  while (1)
  {
    atomic_load(a1 + 1);
    char v16 = atomic_load(a1 + 1);
    if ((v16 & 3) != 0)
    {
      uint64_t v17 = a1[5] + 8 * *(void *)a1[5] + 16;
    }
    else
    {
      char v18 = atomic_load(a1 + 1);
      uint64_t v19 = (~v18 & 0xC) != 0 ? 48 : 88;
      uint64_t v17 = (uint64_t)a1 + v19;
    }
    uint64_t v20 = *(void *)(v17 + 8 * v15);
    atomic_load(a2 + 1);
    char v21 = atomic_load(a2 + 1);
    if ((v21 & 3) != 0)
    {
      uint64_t v22 = a2[5] + 8 * *(void *)a2[5] + 16;
    }
    else
    {
      char v23 = atomic_load(a2 + 1);
      uint64_t v24 = (~v23 & 0xC) != 0 ? 48 : 88;
      uint64_t v22 = (uint64_t)a2 + v24;
    }
    if (v20 != *(void *)(v22 + 8 * v15))
    {
      equal = (uint64_t (*)(void))v7->equal;
      if (!equal) {
        return 0;
      }
      uint64_t result = equal();
      if (!result) {
        break;
      }
    }
    if (v4 == ++v15) {
      return 1;
    }
  }
  return result;
}

unint64_t _CFDataGetBytePtrNonObjC(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 4) != 0) {
    return (a1 + 63) & 0xFFFFFFFFFFFFFFF0;
  }
  else {
    return *(void *)(a1 + 40);
  }
}

uint64_t _NSIsNSObject(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSObject__);
}

uint64_t __exceptionMatch(objc_class *a1, void *a2)
{
  return objectIsKindOfClass(a2, a1);
}

id *__exceptionPreprocess(id *a1)
{
  if (objectIsKindOfClass(a1, (objc_class *)NSException))
  {
    id v2 = a1[4];
    if (v2)
    {
      if ([a1[4] objectForKey:@"callStackReturnAddresses"]
        || [v2 objectForKey:@"callStackSymbols"])
      {
        return a1;
      }
    }
    else
    {
      __CFLookUpClass("NSMutableDictionary");
      id v2 = (id)objc_opt_new();
      a1[4] = v2;
    }
    if ((objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "userInfo"), "objectForKey:", @"NSExceptionOmitCallstacks"), "BOOLValue") & 1) == 0)
    {
      Class v3 = __CFLookUpClass("NSThread");
      uint64_t v4 = [(objc_class *)v3 callStackReturnAddresses];
      uint64_t v5 = [(objc_class *)v3 callStackSymbols];
      if (v4) {
        [v2 setObject:v4 forKey:@"callStackReturnAddresses"];
      }
      if (v5) {
        [v2 setObject:v5 forKey:@"callStackSymbols"];
      }
    }
  }
  return a1;
}

uint64_t objectIsKindOfClass(void *a1, objc_class *a2)
{
  if (a1)
  {
    Class v3 = a1;
    Class Class = object_getClass(a1);
    if (class_respondsToSelector(Class, sel_isKindOfClass_))
    {
      LOBYTE(a1) = objc_opt_isKindOfClass();
    }
    else
    {
      Superclass = object_getClass(v3);
      for (LOBYTE(a1) = Superclass != 0; Superclass != a2 && Superclass; LOBYTE(a1) = Superclass != 0)
        Superclass = class_getSuperclass(Superclass);
    }
  }
  return a1 & 1;
}

CFArrayRef CFPlugInFindFactoriesForPlugInTypeInPlugIn(CFUUIDRef typeUUID, CFPlugInRef plugIn)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByTypeID
    && (CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, typeUUID)) != 0)
  {
    CFArrayRef v5 = Value;
    CFIndex Count = CFArrayGetCount(Value);
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    if (Count >= 1)
    {
      CFIndex v8 = 0;
      while (1)
      {
        ValueAtIndex = (__CFBundle **)CFArrayGetValueAtIndex(v5, v8);
        int v10 = ValueAtIndex;
        uint64_t v11 = ValueAtIndex[5];
        if (v11) {
          CFRetain(ValueAtIndex[5]);
        }
        if (v11 == plugIn) {
          break;
        }
        if (v11) {
          goto LABEL_9;
        }
LABEL_10:
        if (Count == ++v8) {
          goto LABEL_17;
        }
      }
      unsigned int v12 = v10[2];
      if (v12) {
        CFRetain(v12);
      }
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      if (!v11) {
        goto LABEL_10;
      }
LABEL_9:
      CFRelease(v11);
      goto LABEL_10;
    }
  }
  else
  {
    Mutable = 0;
  }
LABEL_17:
  os_unfair_recursive_lock_unlock();
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  int v13 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
  {
    if (Mutable) {
      CFIndex v15 = CFArrayGetCount(Mutable);
    }
    else {
      CFIndex v15 = 0;
    }
    int v16 = 134349570;
    CFIndex v17 = v15;
    __int16 v18 = 2114;
    CFUUIDRef v19 = typeUUID;
    __int16 v20 = 2114;
    CFPlugInRef v21 = plugIn;
    _os_log_debug_impl(&dword_182B90000, v13, OS_LOG_TYPE_DEBUG, "%{public}ld factories found for requested plugin type %{public}@ in plugin %{public}@", (uint8_t *)&v16, 0x20u);
  }
  return Mutable;
}

uint64_t _getFlags(uint64_t a1)
{
  if ((a1 & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  unint64_t v3 = v2 ^ a1;
  uint64_t v4 = v3 & 7;
  do
  {
    if (v4 == *((unsigned __int8 *)off_1ECE0A6E0 + v1)) {
      break;
    }
    ++v1;
  }
  while (v1 != 7);
  if ((~(_BYTE)v1 & 7) == 0 && ((v1 | v3) & 0x7F80000000000000) == 0x600000000000000)
  {
    BOOL v5 = v4 == 7;
    uint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5) {
      uint64_t v6 = 0xFFFFFFFFFFFFFLL;
    }
    unint64_t v7 = __CFGetSignatureROMEntryAtIndex(v6 & (v3 >> 3)) + 2;
  }
  else
  {
LABEL_12:
    unint64_t v7 = (_UNKNOWN **)(a1 + 24);
  }
  return (uint64_t)*v7;
}

uint64_t __NSMS6(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 != 0;
  BOOL v3 = a2 != 0;
  if (!(a1 | a2)) {
    return 1;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  while (1)
  {
    uint64_t result = 0;
    if (!v2 || !v3) {
      break;
    }
    if (*(unsigned char *)(v5 + 36) != 64 || *(unsigned char *)(v4 + 36) != 64)
    {
      uint64_t result = __NSMS6(*(void *)v5, *(void *)v4);
      if (result)
      {
        uint64_t result = __NSMS6(*(void *)(v5 + 8), *(void *)(v4 + 8));
        if (result) {
          return strcmp((const char *)(v5 + 37), (const char *)(v4 + 37)) == 0;
        }
      }
      return result;
    }
    int v7 = *(unsigned __int16 *)(v5 + 34);
    int v8 = *(unsigned __int16 *)(v4 + 34);
    if (((v8 ^ v7) & 0x8000) != 0) {
      return 0;
    }
    uint64_t v9 = *(void *)v5;
    if (*(void *)v5)
    {
      uint64_t v10 = *(void *)v4;
      if (*(void *)v4)
      {
        if ((v8 & v7 & 0x8000) != 0)
        {
          if ((__NSMS6(v9, v10) & 1) == 0) {
            return 0;
          }
        }
        else if (strcmp((const char *)(v9 + 37), (const char *)(v10 + 37)))
        {
          return 0;
        }
      }
    }
    uint64_t v5 = *(void *)(v5 + 8);
    uint64_t v4 = *(void *)(v4 + 8);
    BOOL v2 = v5 != 0;
    BOOL v3 = v4 != 0;
    if (!(v5 | v4)) {
      return 1;
    }
  }
  return result;
}

const UInt8 *__NSI3(const UInt8 *result, uint64_t a2, id *a3, char a4)
{
  if (result)
  {
    int v7 = result;
    while (1)
    {
      unsigned int v8 = (a4 & 1) != 0 ? *((_DWORD *)v7 + 7) + v7[32] : *((_DWORD *)v7 + 5);
      uint64_t v9 = v8;
      int v10 = *((unsigned __int16 *)v7 + 17);
      if ((v10 & 0x80) == 0) {
        break;
      }
      a4 = 0;
      int v7 = *(const UInt8 **)v7;
      a2 = *(void *)(a2 + v9);
      if (!v7) {
        return result;
      }
    }
    if ((~v10 & 0x1800) != 0)
    {
      if ((v10 & 0xC00) != 0)
      {
        for (uint64_t i = *(const UInt8 **)v7; i; uint64_t i = (const UInt8 *)*((void *)i + 1))
          uint64_t result = (const UInt8 *)__NSI3(i, a2, a3, a4 & 1);
      }
      else if ((v10 & 0x2000) != 0)
      {
        __int16 v20 = *(const UInt8 **)(a2 + v9);
        if ((v10 & 0x8000) != 0)
        {
          uint64_t result = (const UInt8 *)(id)[*(id *)(a2 + v9) copy];
          __int16 v20 = result;
          *(void *)(a2 + v9) = result;
        }
        if (v20)
        {
          id v21 = *a3;
          if (!*a3)
          {
            id v21 = (id)objc_opt_new();
            *a3 = v21;
          }
          return (const UInt8 *)[v21 addObject:v20];
        }
      }
      else if ((v10 & 0x4000) != 0)
      {
        CFIndex v17 = *(const char **)(a2 + v9);
        if (v17)
        {
          if (!*a3) {
            *a3 = (id)objc_opt_new();
          }
          __int16 v18 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
          size_t v19 = strlen(v17);
          CFDataAppendBytes(v18, (const UInt8 *)v17, v19 + 1);
          [*a3 addObject:v18];
          uint64_t result = CFDataGetMutableBytePtr(v18);
          *(void *)(a2 + v9) = result;
        }
      }
    }
    else
    {
      uint64_t v11 = *(const UInt8 **)(a2 + v9);
      if (v11)
      {
        int v12 = v10 & 3;
        uint64_t result = (const UInt8 *)_CFExecutableLinkedOnOrAfter(6uLL);
        if (v12 == 1 || !result)
        {
          int v13 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
          CFDataAppendBytes(v13, v11, *((unsigned int *)v7 + 4));
          uint64_t v14 = *a3;
          if (!*a3)
          {
            uint64_t v14 = objc_opt_new();
            *a3 = v14;
          }
          [v14 addObject:v13];
          uint64_t result = CFDataGetMutableBytePtr(v13);
          uint64_t v11 = result;
          *(void *)(a2 + v9) = result;
        }
        CFIndex v15 = *(const UInt8 **)v7;
        if (*(void *)v7)
        {
          do
          {
            uint64_t result = (const UInt8 *)__NSI3(v15, v11, a3, 0);
            CFIndex v15 = (const UInt8 *)*((void *)v15 + 1);
          }
          while (v15);
        }
      }
    }
  }
  return result;
}

uint64_t _getFrameDescriptor(uint64_t a1)
{
  if ((a1 & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  unint64_t v3 = v2 ^ a1;
  uint64_t v4 = v3 & 7;
  do
  {
    if (v4 == *((unsigned __int8 *)off_1ECE0A6E0 + v1)) {
      break;
    }
    ++v1;
  }
  while (v1 != 7);
  if ((~(_BYTE)v1 & 7) == 0 && ((v1 | v3) & 0x7F80000000000000) == 0x600000000000000)
  {
    BOOL v5 = v4 == 7;
    uint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5) {
      uint64_t v6 = 0xFFFFFFFFFFFFFLL;
    }
    int v7 = __CFGetSignatureROMEntryAtIndex(v6 & (v3 >> 3));
  }
  else
  {
LABEL_12:
    int v7 = (_UNKNOWN **)(a1 + 8);
  }
  return (uint64_t)*v7;
}

_UNKNOWN **__CFGetSignatureROMEntryAtIndex(unint64_t a1)
{
  if (a1 >= 0x28FB) {
    __CFGetSignatureROMEntryAtIndex_cold_1();
  }
  return &MethodSignatureROMTable + 3 * a1;
}

void __NSICreateBackingForArgumentIfNeeded(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if ((*(_WORD *)(a2 + 34) & 0x80) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (!v8)
    {
      Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, [*(id *)(a1 + 24) numberOfArguments] + 1);
      if (!Mutable) {
        __NSICreateBackingForArgumentIfNeeded_cold_1();
      }
      int v10 = Mutable;
      *(void *)(a1 + 40) = CFDataGetMutableBytePtr(Mutable);
      uint64_t v11 = *(void **)(a1 + 32);
      if (!v11)
      {
        uint64_t v11 = objc_opt_new();
        *(void *)(a1 + 32) = v11;
        if (!v11) {
          __NSICreateBackingForArgumentIfNeeded_cold_2();
        }
      }
      [v11 addObject:v10];
      CFRelease(v10);
      uint64_t v8 = *(void *)(a1 + 40);
    }
    uint64_t v12 = a3 + 1;
    if (!*(unsigned char *)(v8 + a3 + 1))
    {
      int v13 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
      uint64_t v14 = v13;
      if (a4)
      {
        CFIndex v15 = *(const UInt8 **)(*(void *)(a1 + 8) + *(_DWORD *)(a2 + 28) + *(unsigned __int8 *)(a2 + 32));
        if (v15)
        {
          CFDataAppendBytes(v13, v15, *(unsigned int *)(*(void *)a2 + 16));
LABEL_14:
          CFIndex v17 = *(void **)(a1 + 32);
          if (!v17)
          {
            CFIndex v17 = objc_opt_new();
            *(void *)(a1 + 32) = v17;
          }
          [v17 addObject:v14];
          *(void *)(*(void *)(a1 + 8) + *(unsigned int *)(a2 + 28)) = CFDataGetMutableBytePtr(v14);
          *(unsigned char *)(v8 + v12) = 1;
          return;
        }
        CFIndex v16 = *(unsigned int *)(*(void *)a2 + 16);
      }
      else
      {
        CFIndex v16 = *(unsigned int *)(*(void *)a2 + 16);
      }
      CFDataSetLength(v13, v16);
      goto LABEL_14;
    }
  }
}

uint64_t __NSI1(uint64_t result, uint64_t a2, unsigned char *a3, char a4)
{
  if (result)
  {
    BOOL v5 = a3;
    uint64_t v7 = result;
    while (1)
    {
      unsigned int v8 = (a4 & 1) != 0 ? *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32) : *(_DWORD *)(v7 + 20);
      __int16 v9 = *(_WORD *)(v7 + 34);
      if ((v9 & 0x80) == 0) {
        break;
      }
      a4 = 0;
      uint64_t v7 = *(void *)v7;
      a2 = *(void *)(a2 + v8);
      if (!v7) {
        return result;
      }
    }
    if ((*(_WORD *)(v7 + 34) & 0x400) != 0 || (v9 & 0x1800) == 0x800)
    {
      uint64_t v12 = *(void *)v7;
      if (!v12)
      {
        CFIndex v15 = "array";
        if ((v9 & 0x400) != 0) {
          CFIndex v15 = "struct";
        }
        CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%s with unknown contents found while getting argument", v15);
        CFIndex v17 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v16) userInfo:0];
        objc_exception_throw(v17);
      }
      do
      {
        uint64_t result = __NSI1(v12, a2, v5, a4 & 1);
        uint64_t v12 = *(void *)(v12 + 8);
      }
      while (v12);
    }
    else if ((*(_WORD *)(v7 + 34) & 0x2000) != 0)
    {
      *(void *)&a3[*(unsigned int *)(v7 + 20)] = *(void *)(a2 + v8);
    }
    else
    {
      if (a4)
      {
        unsigned int v10 = *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32);
        int v11 = *(_DWORD *)(v7 + 24) + *(char *)(v7 + 33);
      }
      else
      {
        int v11 = *(_DWORD *)(v7 + 16);
        unsigned int v10 = *(_DWORD *)(v7 + 20);
      }
      int v13 = (__int16 *)(a2 + v10);
      if ((v9 & 0x1800) == 0x1800)
      {
        LOWORD(v14) = 8;
      }
      else
      {
        int v14 = *(_DWORD *)(v7 + 16);
        BOOL v5 = &a3[*(unsigned int *)(v7 + 20)];
      }
      bzero(v5, (unsigned __int16)v14);
      return __NSI0(v7, v13, (unsigned __int16)v11, v5, (unsigned __int16)v14);
    }
  }
  return result;
}

uint64_t __NSI2(uint64_t result, uint64_t a2, __int16 *a3, char a4)
{
  if (!result) {
    return result;
  }
  BOOL v5 = a3;
  uint64_t v7 = result;
  while (1)
  {
    unsigned int v8 = (a4 & 1) != 0 ? *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32) : *(_DWORD *)(v7 + 20);
    __int16 v9 = *(_WORD *)(v7 + 34);
    if ((v9 & 0x80) == 0) {
      break;
    }
    a4 = 0;
    uint64_t v7 = *(void *)v7;
    a2 = *(void *)(a2 + v8);
    if (!v7) {
      return result;
    }
  }
  if ((*(_WORD *)(v7 + 34) & 0x400) == 0 && (v9 & 0x1800) != 0x800)
  {
    if ((*(_WORD *)(v7 + 34) & 0x2000) != 0)
    {
      *(void *)(a2 + v8) = *(void *)((char *)a3 + *(unsigned int *)(v7 + 20));
      return result;
    }
    if ((v9 & 0x1800) == 0x1800)
    {
      LOWORD(v10) = 8;
      if ((a4 & 1) == 0)
      {
LABEL_14:
        unsigned int v11 = *(_DWORD *)(v7 + 20);
        LOWORD(v12) = *(_WORD *)(v7 + 16);
LABEL_22:
        int v14 = (unsigned char *)(a2 + v11);
        int v15 = (unsigned __int16)v12;
        bzero(v14, (unsigned __int16)v12);
        return __NSI0(v7, v5, (unsigned __int16)v10, v14, v15);
      }
    }
    else
    {
      int v10 = *(_DWORD *)(v7 + 16);
      BOOL v5 = (__int16 *)((char *)a3 + *(unsigned int *)(v7 + 20));
      if ((a4 & 1) == 0) {
        goto LABEL_14;
      }
    }
    unsigned int v11 = *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32);
    int v12 = *(_DWORD *)(v7 + 24) + *(char *)(v7 + 33);
    goto LABEL_22;
  }
  uint64_t v13 = *(void *)v7;
  if (!v13)
  {
    CFStringRef v16 = "array";
    if ((v9 & 0x400) != 0) {
      CFStringRef v16 = "struct";
    }
    CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%s with unknown contents found while setting argument", v16);
    __int16 v18 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v17) userInfo:0];
    objc_exception_throw(v18);
  }
  do
  {
    uint64_t result = __NSI2(v13, a2, v5, a4 & 1);
    uint64_t v13 = *(void *)(v13 + 8);
  }
  while (v13);
  return result;
}

uint64_t __NSI0(uint64_t result, __int16 *a2, int a3, unsigned char *a4, int a5)
{
  if ((*(_WORD *)(result + 34) & 0x200) == 0)
  {
    int v5 = a5 + (a3 << 8);
    if ((*(_WORD *)(result + 34) & 0x100) == 0)
    {
      if (v5 <= 1024)
      {
        if (v5 > 0x400)
        {
          switch(v5)
          {
            case 513:
              goto LABEL_35;
            case 514:
              goto LABEL_16;
            case 516:
              int v6 = (unsigned __int16)*a2;
              goto LABEL_49;
            case 520:
              uint64_t v11 = (unsigned __int16)*a2;
              goto LABEL_51;
            default:
              goto LABEL_52;
          }
        }
        switch(v5)
        {
          case 257:
            goto LABEL_35;
          case 258:
            __int16 v8 = *(unsigned __int8 *)a2;
            goto LABEL_47;
          case 259:
          case 261:
          case 262:
          case 263:
            goto LABEL_52;
          case 260:
            int v6 = *(unsigned __int8 *)a2;
            goto LABEL_49;
          case 264:
            uint64_t v11 = *(unsigned __int8 *)a2;
            goto LABEL_51;
          default:
            goto LABEL_53;
        }
      }
      switch(v5)
      {
        case 2049:
          goto LABEL_23;
        case 2050:
          goto LABEL_38;
        case 2052:
          goto LABEL_39;
        case 2056:
          goto LABEL_40;
        default:
          goto LABEL_52;
      }
    }
    if (v5 <= 1024)
    {
      if (v5 > 0x400)
      {
        switch(v5)
        {
          case 513:
            goto LABEL_35;
          case 514:
LABEL_16:
            __int16 v8 = *a2;
            goto LABEL_47;
          case 516:
            int v6 = *a2;
            goto LABEL_49;
          case 520:
            uint64_t v11 = *a2;
            goto LABEL_51;
          default:
            goto LABEL_52;
        }
      }
      switch(v5)
      {
        case 257:
LABEL_35:
          *a4 = *(unsigned char *)a2;
          return result;
        case 258:
          __int16 v8 = *(char *)a2;
LABEL_47:
          *(_WORD *)a4 = v8;
          return result;
        case 259:
        case 261:
        case 262:
        case 263:
          goto LABEL_52;
        case 260:
          int v6 = *(char *)a2;
LABEL_49:
          *(_DWORD *)a4 = v6;
          return result;
        case 264:
          uint64_t v11 = *(char *)a2;
          goto LABEL_51;
        default:
LABEL_53:
          JUMPOUT(0);
      }
    }
    switch(v5)
    {
      case 2049:
LABEL_23:
        *a4 = *(void *)a2;
        return result;
      case 2050:
LABEL_38:
        *(_WORD *)a4 = *(void *)a2;
        return result;
      case 2052:
LABEL_39:
        *(_DWORD *)a4 = *(void *)a2;
        return result;
      case 2056:
LABEL_40:
        uint64_t v11 = *(void *)a2;
LABEL_51:
        *(void *)a4 = v11;
        return result;
      default:
        goto LABEL_52;
    }
  }
  int v7 = a5 + (a3 << 8);
  if (v7 > 2055)
  {
    if (v7 <= 4099)
    {
      if (v7 != 2056 && v7 != 2064)
      {
LABEL_52:
        __break(1u);
        JUMPOUT(0x182BBFD88);
      }
      goto LABEL_26;
    }
    if (v7 != 4100)
    {
      if (v7 != 4104 && v7 != 4112) {
        goto LABEL_52;
      }
LABEL_26:
      double v9 = *(double *)a2;
LABEL_31:
      *(double *)a4 = v9;
      return result;
    }
    goto LABEL_29;
  }
  if (v7 <= 1039)
  {
    if (v7 == 1028)
    {
      float v10 = *(float *)a2;
      goto LABEL_37;
    }
    if (v7 != 1032) {
      goto LABEL_52;
    }
LABEL_30:
    double v9 = *(float *)a2;
    goto LABEL_31;
  }
  if (v7 == 1040) {
    goto LABEL_30;
  }
  if (v7 != 2052) {
    goto LABEL_52;
  }
LABEL_29:
  float v10 = *(double *)a2;
LABEL_37:
  *(float *)a4 = v10;
  return result;
}

uint64_t __invoking___(uint64_t (*a1)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128), uint64_t a2, __n128 *a3, uint64_t a4)
{
  uint64_t v26 = a2;
  uint64_t v4 = a4 - 224;
  int v5 = a3 + 14;
  int v6 = (unint64_t *)(((unint64_t)&v26 - a4 + 224) & 0xFFFFFFFFFFFFFFF0);
  while (v4)
  {
    unint64_t v7 = v5->n128_u64[0];
    int v5 = (__n128 *)((char *)v5 + 8);
    v4 -= 8;
    *v6++ = v7;
  }
  uint64_t result = a1(a3->n128_u64[0], a3->n128_u64[1], a3[1].n128_u64[0], a3[1].n128_u64[1], a3[2].n128_u64[0], a3[2].n128_u64[1], a3[3].n128_u64[0], a3[3].n128_u64[1], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12]);
  uint64_t v9 = v26;
  *(_OWORD *)(v26 + 192) = v10;
  *(_OWORD *)(v9 + 176) = v11;
  *(_OWORD *)(v9 + 160) = v12;
  *(_OWORD *)(v9 + 144) = v13;
  *(_OWORD *)(v9 + 128) = v14;
  *(_OWORD *)(v9 + 112) = v15;
  *(_OWORD *)(v9 + 96) = v16;
  *(_OWORD *)(v9 + 80) = v17;
  *(void *)(v9 + 64) = v18;
  *(void *)(v9 + 56) = v19;
  *(void *)(v9 + 48) = v20;
  *(void *)(v9 + 40) = v21;
  *(void *)(v9 + 32) = v22;
  *(void *)(v9 + 24) = v23;
  *(void *)(v9 + 16) = v24;
  *(void *)(v9 + 8) = v25;
  *(void *)uint64_t v9 = result;
  return result;
}

id _CF_forwarding_prep_0@<X0>(void *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, __n128 a10@<Q0>, __n128 a11@<Q1>, __n128 a12@<Q2>, __n128 a13@<Q3>, __n128 a14@<Q4>, __n128 a15@<Q5>, __n128 a16@<Q6>, __n128 a17@<Q7>)
{
  __n128 v35 = a17;
  __n128 v34 = a16;
  __n128 v33 = a15;
  __n128 v32 = a14;
  __n128 v31 = a13;
  __n128 v30 = a12;
  __n128 v29 = a11;
  __n128 v28 = a10;
  uint64_t v27 = a9;
  uint64_t v26 = a8;
  uint64_t v25 = a7;
  uint64_t v24 = a6;
  uint64_t v23 = a5;
  uint64_t v22 = a4;
  uint64_t v21 = a3;
  SEL v20 = a2;
  id v19 = a1;
  long long v17 = ___forwarding___((uint64_t)&v19, 0);
  if (v17) {
    return (id)v17->n128_u64[0];
  }
  else {
    return objc_msgSend(v19, v20, v21, v22, v23, v24, v25, v26, v28.n128_f64[0], v29.n128_f64[0], v30.n128_f64[0], v31.n128_f64[0], v32.n128_f64[0], v33.n128_f64[0], v34.n128_f64[0], v35.n128_f64[0]);
  }
}

__n128 *___forwarding___(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (__n128 *)a1;
  uint64_t v72 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *(void *)a1;
  int v5 = *(const char **)(a1 + 8);
  if ((*(void *)a1 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = 0;
    int v7 = *(_DWORD *)off_1ECE0A6F0;
    if ((~v4 & 0xC000000000000007) == 0) {
      LOBYTE(v7) = 0;
    }
    uint64_t v8 = (v7 ^ v4) & 7;
    while (v8 != *((unsigned __int8 *)off_1ECE0A6E0 + v6))
    {
      if (++v6 == 7) {
        goto LABEL_9;
      }
    }
    if (!v6)
    {
LABEL_55:
      if (dyld_program_sdk_at_least()) {
        ___forwarding____cold_1();
      }
      uint64_t AtomTarget = getAtomTarget(v4);
      v3->n128_u64[0] = AtomTarget;
      __invoking___((uint64_t (*)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))off_1ECE0A6F8, (uint64_t)v3, v3, 1024);
      if (v3->n128_u64[0] == AtomTarget) {
        v3->n128_u64[0] = v4;
      }
      return v3;
    }
  }
LABEL_9:
  Class Class = object_getClass(*(id *)a1);
  __int16 Name = class_getName(Class);
  if (class_respondsToSelector(Class, sel_forwardingTargetForSelector_))
  {
    uint64_t v11 = [(id)v4 forwardingTargetForSelector:v5];
    if (v11)
    {
      if (v11 != v4)
      {
        if ((v11 & 0x8000000000000000) == 0) {
          goto LABEL_52;
        }
        uint64_t v12 = 0;
        int v13 = *(_DWORD *)off_1ECE0A6F0;
        if ((~v11 & 0xC000000000000007) == 0) {
          LOBYTE(v13) = 0;
        }
        uint64_t v14 = (v13 ^ v11) & 7;
        while (v14 != *((unsigned __int8 *)off_1ECE0A6E0 + v12))
        {
          if (++v12 == 7) {
            goto LABEL_52;
          }
        }
        if (v12)
        {
LABEL_52:
          v3->n128_u64[0] = v11;
          return 0;
        }
        uint64_t v4 = v11;
        goto LABEL_55;
      }
    }
  }
  if (!strncmp(Name, "_NSZombie_", 0xAuLL)) {
    ___forwarding____cold_2(v4, (__int16)Name, v5);
  }
  if (!class_respondsToSelector(Class, sel_methodSignatureForSelector_))
  {
    Class Superclass = class_getSuperclass(Class);
    object_getClassName((id)v4);
    if (Superclass)
    {
      CFLog(4, @"*** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- trouble ahead", v49, v50, v51, v52, v53, v54, v4);
    }
    else
    {
      object_getClassName((id)v4);
      CFLog(4, @"*** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- did you forget to declare the superclass of '%s'?", v55, v56, v57, v58, v59, v60, v4);
    }
LABEL_65:
    unint64_t v61 = sel_getName(v5);
    if (sel_getUid(v61) != v5) {
      CFLog(4, @"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort", v62, v63, v64, v65, v66, v67, (__int16)v5);
    }
    uint64_t v68 = object_getClass((id)v4);
    if (class_respondsToSelector(v68, sel_doesNotRecognizeSelector_))
    {
      [(id)v4 doesNotRecognizeSelector:v5];
      __break(1u);
    }
    ___forwarding____cold_3((void *)v4);
  }
  long long v15 = (void *)[(id)v4 methodSignatureForSelector:v5];
  if (!v15) {
    goto LABEL_65;
  }
  long long v16 = v15;
  uint64_t v17 = [v15 _frameDescriptor];
  if ((((unint64_t)*(unsigned __int16 *)(*(void *)v17 + 34) >> 6) & 1) != a2)
  {
    __int16 v18 = (unsigned __int16)sel_getName(v5);
    CFLog(4, @"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.", v19, v20, v21, v22, v23, v24, v18);
  }
  uint64_t v25 = object_getClass((id)v4);
  BOOL v26 = class_respondsToSelector(v25, sel__forwardStackInvocation_);
  BOOL v27 = v26;
  if (!v26)
  {
    unint64_t v39 = object_getClass((id)v4);
    if (!class_respondsToSelector(v39, sel_forwardInvocation_)) {
      ___forwarding____cold_6(v71, (id)v4);
    }
    __n128 v31 = +[NSInvocation _invocationWithMethodSignature:v16 frame:v3];
    [*((id *)v31 + 3) numberOfArguments];
    objc_opt_class();
    uint64_t v40 = [*((id *)v31 + 3) frameLength];
    if (v40)
    {
      if ((v40 & 7) != 0) {
        ___forwarding____cold_5();
      }
      for (uint64_t i = 0; i != 64; i += 8)
        ;
    }
    if (v41 == *((void *)v31 + 6))
    {
      [(id)v4 forwardInvocation:v31];
      size_t v28 = 0;
      goto LABEL_40;
    }
LABEL_62:
    _NSIPoisoned();
  }
  BOOL v70 = v26;
  self;
  size_t v28 = [v16 frameLength] + 320;
  size_t InstanceSize = class_getInstanceSize((Class)NSInvocation);
  __n128 v31 = &v69[-((MEMORY[0x1F4188790](InstanceSize, v30) + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v31, InstanceSize);
  bzero(v31, InstanceSize);
  MEMORY[0x1F4188790](v32, v33);
  __n128 v35 = &v69[-v34];
  bzero(&v69[-v34], v28);
  objc_constructInstance((Class)NSInvocation, v31);
  -[NSInvocation _initWithMethodSignature:frame:buffer:size:]((uint64_t)v31, v16, v3, v35, v28);
  [*((id *)v31 + 3) numberOfArguments];
  objc_opt_class();
  uint64_t v36 = [*((id *)v31 + 3) frameLength];
  if (v36)
  {
    if ((v36 & 7) != 0) {
      ___forwarding____cold_4();
    }
    uint64_t v38 = 0;
    BOOL v27 = v70;
    do
      v38 += 8;
    while (v38 != 64);
  }
  else
  {
    BOOL v27 = v70;
  }
  if (v37 != *((void *)v31 + 6)) {
    goto LABEL_62;
  }
  [(id)v4 _forwardStackInvocation:v31];
LABEL_40:
  if (v31[60] && (*(_WORD *)(*(void *)v17 + 34) & 0x80) != 0)
  {
    uint64_t v43 = *(void *)v17;
    memmove(*(void **)((char *)v3->n128_u64 + *(unsigned int *)(v43 + 28) + *(unsigned __int8 *)(v43 + 32)), *(const void **)(*((void *)v31 + 1) + *(unsigned int *)(v43 + 28) + *(unsigned __int8 *)(v43 + 32)), *(unsigned int *)(*(void *)v43 + 16));
  }
  double v44 = (unsigned __int8 *)[v16 methodReturnType];
  int v45 = *v44;
  if (v45 == 118 || v45 == 86 && v44[1] == 118)
  {
    if (v27) {

    }
    return (__n128 *)&___forwarding____placeholder;
  }
  else
  {
    unint64_t v3 = (__n128 *)*((void *)v31 + 2);
    if (v27)
    {
      unint64_t v3 = [+[NSData dataWithBytes:*((void *)v31 + 2) length:v28] bytes];
    }
  }
  return v3;
}

__CFArray *_CFBundleDYLDCreateLoadedImagePathVariants(const char *a1, const __CFString *a2)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  if (a1)
  {
    if (*a1)
    {
      CFStringRef v5 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, 0x8000100u, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v5)
      {
        CFStringRef v6 = v5;
        CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, @":");
        CFRelease(v6);
        if (ArrayBySeparatingStrings)
        {
          CFIndex Length = CFStringGetLength(a2);
          CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
          if (Count >= 1)
          {
            CFIndex v10 = Count;
            for (CFIndex i = 0; i != v10; ++i)
            {
              CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, i);
              CFIndex v13 = CFStringGetLength(ValueAtIndex);
              if (v13)
              {
                CFIndex v14 = v13;
                result.CFIndex location = 0;
                result.CFIndex length = 0;
                v24.CFIndex location = 0;
                v24.CFIndex length = Length;
                int v15 = CFStringFindWithOptions(a2, @".", v24, 4uLL, &result);
                CFIndex location = result.location;
                if (!v15) {
                  CFIndex location = Length;
                }
                CFIndex v17 = location - v14;
                if (location - v14 >= 1)
                {
                  v25.CFIndex location = location - v14;
                  v25.CFIndex length = v14;
                  if (CFStringCompareWithOptions(a2, ValueAtIndex, v25, 8uLL) == kCFCompareEqualTo)
                  {
                    MutableCFDataRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a2);
                    if (MutableCopy)
                    {
                      uint64_t v19 = MutableCopy;
                      v23.CFIndex location = v17;
                      v23.CFIndex length = v14;
                      CFStringReplace(MutableCopy, v23, &stru_1ECE10768);
                      CFArrayAppendValue(Mutable, v19);
                      CFRelease(v19);
                    }
                  }
                }
              }
            }
          }
          CFRelease(ArrayBySeparatingStrings);
        }
      }
    }
  }
  CFArrayAppendValue(Mutable, a2);
  return Mutable;
}

SEL __methodDescriptionForSelector(Class cls, SEL name)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (cls)
  {
    Class Superclass = cls;
    while (1)
    {
      outCFIndex Count = 0;
      CFStringRef v5 = class_copyProtocolList(Superclass, &outCount);
      CFStringRef v6 = v5;
      if (outCount) {
        break;
      }
      if (v5) {
LABEL_10:
      }
        free(v6);
      Class Superclass = class_getSuperclass(Superclass);
      if (!Superclass) {
        goto LABEL_12;
      }
    }
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v8 = v6[v7];
      isMetaClass Class = class_isMetaClass(Superclass);
      SEL v10 = protocol_getMethodDescription(v8, name, 1, !isMetaClass).name;
      if (v10) {
        break;
      }
      uint64_t v11 = v6[v7];
      BOOL v12 = class_isMetaClass(Superclass);
      SEL v10 = protocol_getMethodDescription(v11, name, 0, !v12).name;
      if (v10) {
        break;
      }
      if (++v7 >= (unint64_t)outCount) {
        goto LABEL_10;
      }
    }
    SEL v15 = v10;
    free(v6);
  }
  else
  {
LABEL_12:
    InstanceMethod = class_getInstanceMethod(cls, name);
    if (InstanceMethod)
    {
      CFIndex v14 = InstanceMethod;
      SEL v15 = method_getName(InstanceMethod);
      method_getTypeEncoding(v14);
    }
    else
    {
      return 0;
    }
  }
  return v15;
}

CFIndex CFBitVectorGetCount(CFBitVectorRef bv)
{
  return *((void *)bv + 2);
}

CFStringRef _CFStringCreateWithFormatAndArgumentsReturningMetadata(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFArrayRef *a8, __int16 *a9)
{
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  Mutable[1].info = Mutable[1].info & 0xF | 0x780;
  cf[0] = 0;
  __CFStringAppendFormatCore((uint64_t)Mutable, a2, a3, a4, a5, a6, 0, a7, 0, 0, 0, 0, a9, a8, (CFErrorRef *)cf);
  if (v18)
  {
    CFStringRef Copy = CFStringCreateCopy(a1, Mutable);
  }
  else
  {
    CFLog(3, @"ERROR: Failed to format string: %@");
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    CFStringRef Copy = 0;
  }
  CFRelease(Mutable);
  return Copy;
}

unint64_t *_CFNonObjCStringCreateCopy(uint64_t IsImmortal, uint64_t a2)
{
  unint64_t v3 = (__objc2_class **)IsImmortal;
  uint64_t v4 = (unint64_t *)(a2 + 8);
  char v5 = atomic_load((unint64_t *)(a2 + 8));
  if (v5) {
    goto LABEL_12;
  }
  CFStringRef v6 = (__objc2_class **)IsImmortal;
  if (IsImmortal)
  {
    if (a2 < 0)
    {
LABEL_4:
      uint64_t v7 = &kCFAllocatorSystemDefault;
      goto LABEL_11;
    }
  }
  else
  {
    IsImmortal = _CFGetTSD(1u);
    CFStringRef v6 = &__kCFAllocatorSystemDefault;
    if (IsImmortal) {
      CFStringRef v6 = (__objc2_class **)IsImmortal;
    }
    if (a2 < 0) {
      goto LABEL_4;
    }
  }
  char v8 = atomic_load((unint64_t *)(a2 + 8));
  if (v8 < 0) {
    uint64_t v7 = &kCFAllocatorSystemDefault;
  }
  else {
    uint64_t v7 = (const CFAllocatorRef *)(a2 - 16);
  }
LABEL_11:
  if (v6 == *(__objc2_class ***)v7)
  {
    char v15 = atomic_load((unint64_t *)(a2 + 8));
    if ((v15 & 0x60) == 0
      || (char v16 = atomic_load((unint64_t *)(a2 + 8)), (v16 & 0x20) != 0)
      || (IsImmortal = __CFRuntimeIsImmortal(a2), IsImmortal))
    {
      return _CFNonObjCRetain((unint64_t *)a2);
    }
  }
LABEL_12:
  char v9 = atomic_load(v4);
  char v10 = atomic_load(v4);
  uint64_t v11 = v10 & 0x60;
  BOOL v12 = (int8x16_t **)(a2 + 16);
  if ((v9 & 0x10) != 0)
  {
    if (v11)
    {
      CFIndex v14 = *v12;
    }
    else
    {
      uint64_t v23 = atomic_load((unint64_t *)(a2 + 8));
      CFIndex v14 = (int8x16_t *)&v12[(v23 & 5) != 4];
    }
    char v24 = atomic_load((unint64_t *)(a2 + 8));
    if ((v24 & 5) == 4)
    {
      CFRange v25 = (int8x16_t *)v14->u8[0];
    }
    else
    {
      char v26 = atomic_load((unint64_t *)(a2 + 8));
      if ((v26 & 0x60) != 0) {
        CFRange v25 = *(int8x16_t **)(a2 + 24);
      }
      else {
        CFRange v25 = *v12;
      }
    }
    int64_t v29 = 2 * (void)v25;
    size_t v28 = v3;
    uint64_t v27 = 256;
    unsigned int v30 = 2;
  }
  else
  {
    if (v11)
    {
      CFIndex v13 = *v12;
    }
    else
    {
      char v18 = atomic_load((unint64_t *)(a2 + 8));
      CFIndex v13 = (int8x16_t *)&v12[(v18 & 5) != 4];
    }
    unint64_t v19 = atomic_load((unint64_t *)(a2 + 8));
    uint64_t v20 = (int8x16_t *)((char *)v13 + ((v19 >> 2) & 1));
    LOBYTE(v19) = atomic_load((unint64_t *)(a2 + 8));
    if ((v19 & 5) == 4)
    {
      int64_t v21 = v13->u8[0];
    }
    else
    {
      char v22 = atomic_load((unint64_t *)(a2 + 8));
      if ((v22 & 0x60) != 0) {
        int64_t v21 = *(void *)(a2 + 24);
      }
      else {
        int64_t v21 = (int64_t)*v12;
      }
    }
    uint64_t v27 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(IsImmortal);
      uint64_t v27 = __CFDefaultEightBitStringEncoding;
    }
    size_t v28 = v3;
    CFIndex v14 = v20;
    int64_t v29 = v21;
    unsigned int v30 = 0;
  }

  return (unint64_t *)__CFStringCreateImmutableFunnel3(v28, v14, v29, v27, v30, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000) != 0) {
    return theString;
  }
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    return (CFStringRef)[(__CFString *)(id)theString copy];
  }
  else
  {
    return (CFStringRef)_CFNonObjCStringCreateCopy((uint64_t)alloc, (uint64_t)theString);
  }
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  unint64_t v3 = (__objc2_class **)alloc;
  if (!alloc)
  {
    uint64_t v4 = _CFGetTSD(1u);
    if (v4) {
      unint64_t v3 = (__objc2_class **)v4;
    }
    else {
      unint64_t v3 = &__kCFAllocatorSystemDefault;
    }
  }
  uint64_t Instance = (__CFString *)_CFRuntimeCreateInstance(v3, 7uLL, 32, 0);
  if (Instance)
  {
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    unint64_t v6 = atomic_load((unint64_t *)&Instance->info);
    unint64_t v7 = v6;
    do
    {
      atomic_compare_exchange_strong(&Instance->info, &v7, v6 & 0xFFFFFFFFFFFFFF9FLL | 0x20);
      BOOL v8 = v7 == v6;
      unint64_t v6 = v7;
    }
    while (!v8);
    unint64_t v9 = atomic_load((unint64_t *)&Instance->info);
    unint64_t v10 = v9;
    do
    {
      atomic_compare_exchange_strong(&Instance->info, &v10, v9 & 0xFFFFFFFFFFFFFFEFLL);
      BOOL v8 = v10 == v9;
      unint64_t v9 = v10;
    }
    while (!v8);
    unint64_t v11 = atomic_load((unint64_t *)&Instance->info);
    unint64_t v12 = v11;
    do
    {
      atomic_compare_exchange_strong(&Instance->info, &v12, v11 | 1);
      BOOL v8 = v12 == v11;
      unint64_t v11 = v12;
    }
    while (!v8);
    Instance->data = 0;
    char v13 = atomic_load((unint64_t *)&Instance->info);
    BOOL v8 = (v13 & 0x60) == 0;
    uint64_t v14 = 24;
    if (v8) {
      uint64_t v14 = 16;
    }
    *(void **)((char *)&Instance->isa + v14) = 0;
    CFIndex v15 = (16 * maxLength) | 2;
    if (!maxLength) {
      CFIndex v15 = 512;
    }
    Instance[1].isa = 0;
    Instance[1].info = v15;
    char v16 = atomic_load((unint64_t *)&Instance->info);
    if ((~v16 & 0x60) == 0)
    {
      CFRetain(v3);
      Instance[1].data = (char *)v3;
    }
  }
  return Instance;
}

void __CFStringAppendFormatCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _OWORD *a11, uint64_t a12, __int16 *a13, CFArrayRef *a14, CFErrorRef *a15)
{
  uint64_t v15 = MEMORY[0x1F4188790](a1, a2);
  CFIndex v17 = v16;
  CFStringRef v19 = v18;
  CFTypeRef cf = v21;
  long long v492 = v20;
  CFDictionaryRef v23 = v22;
  CFRange v25 = v24;
  long long v489 = v26;
  uint64_t v27 = (__CFString *)v15;
  int64_t v29 = a14;
  size_t v28 = a15;
  uint64_t v549 = *(void *)off_1ECE0A5B0;
  bzero(v546, 0x3D0uLL);
  v494 = v25;
  if (v25)
  {
    CFTypeID v30 = CFGetTypeID(v25);
    BOOL v493 = v30 == CFLocaleGetTypeID();
  }
  else
  {
    BOOL v493 = 0;
  }
  uint64_t v545 = 0;
  memset(v544, 0, sizeof(v544));
  p_CFArrayRef theArray = &theArray;
  if (!a14) {
    p_CFArrayRef theArray = 0;
  }
  long long v495 = p_theArray;
  CFArrayRef theArray = 0;
  FormatSpecifierConfiguratiouint64_t n = _CFStringGetFormatSpecifierConfiguration(v17);
  ptr.i64[1] = 0;
  if (FormatSpecifierConfiguration) {
    CFDictionaryRef v33 = (const __CFDictionary *)FormatSpecifierConfiguration;
  }
  else {
    CFDictionaryRef v33 = v23;
  }
  if (v19)
  {
    if (a10 >= 11)
    {
      if (!a15) {
        return;
      }
      CFMutableStringRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(Mutable, @"NSDebugDescription", @"Exceeded maximum number of allowed nested stringsdict entry references");
      *a15 = CFErrorCreate(0, @"NSCocoaErrorDomain", 2048, Mutable);
LABEL_43:
      CFRelease(Mutable);
      return;
    }
    CFStringRef v505 = v27;
    *(void *)&v507[0] = 0;
    uint64_t v35 = (uint64_t)v17;
    v543[0] = 0;
    v510 = 0;
    ptr.i64[0] = 0;
    uint64_t v509 = 0;
    uint64_t v542 = 0;
    long long v540 = 0u;
    long long v541 = 0u;
    long long v538 = 0u;
    long long v539 = 0u;
    long long v536 = 0u;
    long long v537 = 0u;
    long long v534 = 0u;
    long long v535 = 0u;
    long long v532 = 0u;
    long long v533 = 0u;
    long long v530 = 0u;
    long long v531 = 0u;
    long long v528 = 0u;
    long long v529 = 0u;
    long long v526 = 0u;
    long long v527 = 0u;
    long long v524 = 0u;
    long long v525 = 0u;
    long long v522 = 0u;
    long long v523 = 0u;
    long long v520 = 0u;
    long long v521 = 0u;
    long long v518 = 0u;
    long long v519 = 0u;
    long long v516 = 0u;
    long long v517 = 0u;
    long long v514 = 0u;
    long long v515 = 0u;
    memset(chars, 0, sizeof(chars));
    CFIndex Length = CFStringGetLength(v19);
    __CFStringSetUpFormatAndSpecBuffers(v19, Length, v543, (UniChar **)v507, (UniChar **)&ptr, v548, (uint64_t *)&v510, (uint64_t)v547, (uint64_t *)&v509, (uint64_t)chars);
    uint64_t v37 = v510;
    int FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString((uint64_t)v543[0], *(uint64_t *)&v507[0], Length, (uint64_t)v510, 0, 0);
    if ((UniChar *)ptr.i64[0] != v548) {
      CFAllocatorDeallocate(0, (void *)ptr.i64[0]);
    }
    if (v37 != v547) {
      CFAllocatorDeallocate(0, v37);
    }
    if (v509 != chars) {
      CFAllocatorDeallocate(0, v509);
    }
    if (!Length || !FormatSpecifiersInString)
    {
      if (!a15) {
        return;
      }
      CFMutableStringRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFStringRef v54 = CFStringCreateWithFormat(0, 0, @"Expected format '%@' is invalid", v19);
      CFDictionarySetValue(Mutable, @"NSDebugDescription", v54);
      *a15 = CFErrorCreate(0, @"NSCocoaErrorDomain", 2048, Mutable);
      CFRelease(v54);
      goto LABEL_43;
    }
    CFIndex v17 = (__CFString *)v35;
    if (!v33 && __CFStringValidateFormat((uint64_t)v19, v35) < 0) {
      return;
    }
    uint64_t v27 = (__CFString *)v505;
  }
  CFIndex v39 = CFStringGetLength(v17);
  if (v39 >= 0x80000000)
  {
    if (a15)
    {
LABEL_26:
      uint64_t v40 = _CFGetTSD(1u);
      if (v40) {
        CFAllocatorRef v41 = (const __CFAllocator *)v40;
      }
      else {
        CFAllocatorRef v41 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      double v42 = CFDictionaryCreateMutable(v41, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v42, @"NSDebugDescription", @"Overflow occurred");
      CFErrorRef v43 = CFErrorCreate(v41, @"NSCocoaErrorDomain", 2048, v42);
      CFAllocatorRef v44 = 0;
      int v45 = 0;
      goto LABEL_70;
    }
LABEL_882:
    CFAllocatorRef v44 = 0;
    CFDictionaryRef v490 = 0;
    uint64_t v69 = 0;
    BOOL v70 = 0;
    long long v71 = 0;
    int v45 = 0;
    goto LABEL_883;
  }
  CFIndex range = v39;
  if (CF_IS_OBJC(7uLL, (unint64_t)v17))
  {
    unint64_t v46 = 0;
    unint64_t v47 = 0;
LABEL_32:
    v48.CFIndex length = range;
    goto LABEL_33;
  }
  char v60 = atomic_load((unint64_t *)&v17->info);
  char v61 = atomic_load((unint64_t *)&v17->info);
  uint64_t v62 = v61 & 0x60;
  p_data = &v17->data;
  if ((v60 & 0x10) != 0)
  {
    unint64_t v47 = 0;
    if (v62)
    {
      unint64_t v46 = (unint64_t)*p_data;
    }
    else
    {
      uint64_t v434 = atomic_load((unint64_t *)&v17->info);
      unint64_t v46 = (unint64_t)&p_data[(v434 & 5) != 4];
    }
    goto LABEL_32;
  }
  if (v62)
  {
    uint64_t v64 = (char **)*p_data;
  }
  else
  {
    uint64_t v432 = atomic_load((unint64_t *)&v17->info);
    uint64_t v64 = &p_data[(v432 & 5) != 4];
  }
  v48.CFIndex length = range;
  unint64_t v46 = 0;
  if (v64)
  {
    unint64_t v433 = atomic_load((unint64_t *)&v17->info);
    unint64_t v47 = (unint64_t)v64 + ((v433 >> 2) & 1);
  }
  else
  {
    unint64_t v47 = 0;
  }
LABEL_33:
  unint64_t v486 = v47;
  CFStringRef theString = v17;
  CFStringRef v460 = v19;
  if (v47 | v46)
  {
    if (v47)
    {
      if (v48.length >= 1)
      {
        int v49 = 0;
        CFIndex v50 = v48.length;
        uint64_t v51 = (unsigned __int8 *)v47;
        while (1)
        {
          int v52 = *v51++;
          if (v52 == 37)
          {
            BOOL v53 = __OFADD__(v49++, 1);
            if (v53) {
              break;
            }
          }
          if (!--v50)
          {
            int v45 = 0;
            CFAllocatorRef v44 = 0;
            goto LABEL_64;
          }
        }
        size_t v28 = a15;
        if (a15) {
          goto LABEL_26;
        }
        goto LABEL_882;
      }
      unint64_t v485 = v46;
      CFDictionaryRef theDict = v33;
      int v49 = 0;
      int v45 = 0;
      goto LABEL_77;
    }
    int v45 = 0;
    CFAllocatorRef v44 = 0;
  }
  else
  {
    if (v48.length < 401)
    {
      CFAllocatorRef v44 = 0;
      uint64_t v58 = v548;
    }
    else
    {
      CFIndex v55 = v48.length;
      uint64_t v56 = _CFGetTSD(1u);
      if (v56) {
        CFAllocatorRef v44 = (const __CFAllocator *)v56;
      }
      else {
        CFAllocatorRef v44 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(v44, 2 * v55, 0x1000040BDFB0063, 0);
      uint64_t v58 = Typed;
      if (Typed != v548 && __CFOASafe)
      {
        uint64_t v59 = Typed;
        __CFSetLastAllocationEventName();
        uint64_t v58 = v59;
      }
      v48.CFIndex length = range;
    }
    v48.uint64_t location = 0;
    uint64_t v65 = v58;
    CFStringGetCharacters(theString, v48, v58);
    unint64_t v46 = (unint64_t)v65;
    v48.CFIndex length = range;
    int v45 = v65;
  }
  if (v48.length < 1)
  {
    unint64_t v485 = v46;
    CFDictionaryRef theDict = v33;
    int v49 = 0;
  }
  else
  {
    uint64_t v66 = 0;
    int v49 = 0;
    do
    {
      if (*(_WORD *)(v46 + 2 * v66) == 37)
      {
        BOOL v53 = __OFADD__(v49++, 1);
        if (v53) {
          goto LABEL_65;
        }
      }
      ++v66;
    }
    while (v48.length != v66);
LABEL_64:
    if (v49 >= 0x100000)
    {
LABEL_65:
      size_t v28 = a15;
      if (!a15)
      {
        CFDictionaryRef v490 = 0;
        uint64_t v69 = 0;
        BOOL v70 = 0;
        long long v71 = 0;
        goto LABEL_883;
      }
      uint64_t v67 = _CFGetTSD(1u);
      if (v67) {
        CFAllocatorRef v68 = (const __CFAllocator *)v67;
      }
      else {
        CFAllocatorRef v68 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      double v42 = CFDictionaryCreateMutable(v68, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v42, @"NSDebugDescription", @"Overflow occurred");
      CFErrorRef v43 = CFErrorCreate(v68, @"NSCocoaErrorDomain", 2048, v42);
LABEL_70:
      CFRelease(v42);
      CFDictionaryRef v490 = 0;
      uint64_t v69 = 0;
      BOOL v70 = 0;
      long long v71 = 0;
      CFErrorRef *v28 = v43;
LABEL_883:
      CFAllocatorDeallocate(v44, v71);
      goto LABEL_884;
    }
    unint64_t v485 = v46;
    CFDictionaryRef theDict = v33;
  }
LABEL_77:
  uint64_t v72 = _CFGetTSD(1u);
  if (v72) {
    long long v73 = (__objc2_class **)v72;
  }
  else {
    long long v73 = &__kCFAllocatorSystemDefault;
  }
  long long v71 = v547;
  if (((2 * v49) | 1) > 61)
  {
    long long v74 = (unsigned char *)CFAllocatorAllocateTyped(v73, 32 * ((2 * v49) | 1u), 0x10000408E5DAE1CLL, 0);
    long long v71 = v74;
    BOOL v75 = v74 == v547 || __CFOASafe == 0;
    if (!v75)
    {
      long long v76 = v74;
      __CFSetLastAllocationEventName();
      long long v71 = v76;
    }
  }
  long long v502 = v71;
  if (v49 >= 61)
  {
    long long v77 = (char *)CFAllocatorAllocateTyped(v73, 8 * v49, 0x6004044C4A2DFLL, 0);
    long long v71 = v502;
  }
  else
  {
    long long v77 = (char *)v544;
  }
  unint64_t v79 = v486;
  CFIndex v78 = range;
  unint64_t v80 = v485;
  long long v477 = v77;
  p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
  CFAllocatorRef alloc = (const __CFAllocator *)v73;
  uint64_t v461 = v45;
  v506 = v27;
  if (range < 1)
  {
    uint64_t v476 = 0;
    CFDictionaryRef v490 = 0;
    LODWORD(v82) = 0;
    goto LABEL_288;
  }
  CFAllocatorRef v82 = 0;
  LODWORD(v83) = 0;
  CFDictionaryRef v490 = 0;
  uint64_t v476 = 0;
  long long v84 = xmmword_182DAF8B0;
  do
  {
    uint64_t v85 = &v71[32 * (void)v82];
    *((_DWORD *)v85 + 1) = v83;
    CFRange v86 = v85 + 4;
    *(_OWORD *)(v85 + 8) = v84;
    uint64_t v87 = v85 + 8;
    *(_DWORD *)uint64_t v85 = 0;
    UniChar v88 = v85 + 27;
    uint64_t v89 = (__int16 *)(v85 + 2);
    *((_DWORD *)v85 + 6) = -1;
    int v90 = v83;
    if (v79)
    {
      if (v78 > (int)v83)
      {
        uint64_t v83 = (int)v83;
        while (*(unsigned char *)(v79 + v83) != 37)
        {
          if (v78 == ++v83) {
            goto LABEL_100;
          }
        }
        goto LABEL_101;
      }
    }
    else
    {
      uint64_t v83 = (int)v83;
      if (v78 > (int)v83)
      {
        while (*(_WORD *)(v80 + 2 * v83) != 37)
        {
          if (v78 == ++v83)
          {
LABEL_100:
            LODWORD(v83) = v78;
            break;
          }
        }
LABEL_101:
        if (v83 != v90) {
          goto LABEL_215;
        }
      }
    }
    char __src = v82;
    unint64_t v91 = v85 + 20;
    if (v90 + 1 >= (int)v78)
    {
      LODWORD(v83) = v90 + 1;
LABEL_203:
      CFStringRef ImmutableFunnel3 = 0;
      *uint64_t v89 = 43;
      goto LABEL_205;
    }
    unsigned int v92 = 0;
    uint64_t v93 = 0;
    int v94 = 0;
    int v95 = 0;
    int v96 = 0;
    int v483 = 0;
    v470 = v85 + 16;
    uint64_t v462 = v85 + 25;
    int v97 = v85 + 26;
    uint64_t v98 = -1;
    uint64_t v99 = 255;
    unsigned __int8 v100 = -1;
    LODWORD(v83) = v90 + 1;
    CFIndex v496 = v85 + 20;
    while (1)
    {
      uint64_t v101 = (int)v83;
      if (v79) {
        unsigned int v102 = *(unsigned __int8 *)(v79 + (int)v83);
      }
      else {
        unsigned int v102 = *(unsigned __int16 *)(v80 + 2 * (int)v83);
      }
      LODWORD(v83) = v83 + 1;
      if (v98 < 0)
      {
        v498 = v89;
        while (1)
        {
          while (v102 - 49 < 9)
          {
            uint64_t v107 = 0;
            if ((int)v83 <= (int)v78) {
              int v108 = v78;
            }
            else {
              int v108 = v83;
            }
            uint64_t v109 = v108 - (uint64_t)(int)v83;
            BOOL v110 = (unsigned __int16 *)(v80 + 2 * (int)v83);
            CFStringRef v111 = (unsigned __int8 *)(v79 + (int)v83);
            do
            {
              uint64_t v112 = (unsigned __int128)(v107 * (__int128)10) >> 64;
              uint64_t v113 = 10 * v107;
              if (v112 != v113 >> 63) {
                goto LABEL_282;
              }
              uint64_t v114 = v102 - 48;
              BOOL v53 = __OFADD__(v113, v114);
              uint64_t v107 = v113 + v114;
              if (v53) {
                goto LABEL_282;
              }
              if (!v109)
              {
                CFStringRef ImmutableFunnel3 = 0;
                unint64_t v91 = v85 + 20;
                uint64_t v89 = v498;
                __int16 *v498 = 43;
                LODWORD(v83) = v108;
                unint64_t v80 = v485;
                goto LABEL_205;
              }
              if (v79) {
                unsigned int v102 = *v111;
              }
              else {
                unsigned int v102 = *v110;
              }
              --v109;
              ++v110;
              ++v111;
              LODWORD(v83) = v83 + 1;
            }
            while (v102 - 48 < 0xA);
            if (v102 == 36)
            {
              unint64_t v91 = v85 + 20;
              uint64_t v89 = v498;
              if (v107 < 128)
              {
                unint64_t v80 = v485;
                if (v100 == 254)
                {
                  unsigned __int8 v100 = v107 - 1;
                  *uint64_t v462 = v107 - 1;
                }
                else
                {
                  uint64_t v119 = (v107 - 1);
                  if (v99 == 254)
                  {
                    *int v97 = v119;
                    uint64_t v99 = v119;
                  }
                  else
                  {
                    v85[24] = v119;
                  }
                }
                goto LABEL_157;
              }
              if (a15)
              {
                uint64_t v443 = _CFGetTSD(1u);
                if (v443) {
                  CFAllocatorRef v444 = (const __CFAllocator *)v443;
                }
                else {
                  CFAllocatorRef v444 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
                }
                uint64_t v445 = CFDictionaryCreateMutable(v444, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                CFDictionarySetValue(v445, @"NSDebugDescription", @"Overflow occurred");
                CFErrorRef v446 = CFErrorCreate(v444, @"NSCocoaErrorDomain", 2048, v445);
                CFRelease(v445);
                BOOL v70 = 0;
                *a15 = v446;
              }
              else
              {
                BOOL v70 = 0;
              }
              int64_t v29 = a14;
LABEL_909:
              CFAllocatorRef v44 = alloc;
              int v45 = v461;
              goto LABEL_873;
            }
            if (v483) {
              uint64_t v115 = v85 + 16;
            }
            else {
              uint64_t v115 = v85 + 12;
            }
            unint64_t v91 = v85 + 20;
            if (v107 >= 0x80000000)
            {
LABEL_282:
              if (a15)
              {
                uint64_t v153 = _CFGetTSD(1u);
                if (v153) {
                  CFAllocatorRef v154 = (const __CFAllocator *)v153;
                }
                else {
                  CFAllocatorRef v154 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
                }
                int64_t v155 = CFDictionaryCreateMutable(v154, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                CFDictionarySetValue(v155, @"NSDebugDescription", @"Overflow occurred");
                CFErrorRef v156 = CFErrorCreate(v154, @"NSCocoaErrorDomain", 2048, v155);
                CFRelease(v155);
                long long v71 = v502;
                BOOL v70 = 0;
                *a15 = v156;
              }
              else
              {
                BOOL v70 = 0;
              }
              int64_t v29 = a14;
              CFAllocatorRef v44 = alloc;
              int v45 = v461;
              uint64_t v69 = v477;
              goto LABEL_874;
            }
            _DWORD *v115 = v107;
            unint64_t v80 = v485;
          }
          switch(v102)
          {
            case ' ':
              if ((v92 & 4) != 0) {
                goto LABEL_179;
              }
              v92 |= 8u;
LABEL_171:
              *unint64_t v91 = v92;
              goto LABEL_179;
            case '#':
              int v96 = 1;
              goto LABEL_179;
            case '*':
              uint64_t v99 = 254;
              *int v97 = -2;
              goto LABEL_179;
            case '+':
              unsigned int v92 = v92 & 0xFFFFFFF3 | 4;
              goto LABEL_171;
            case '-':
              unsigned int v92 = v92 & 0xFFFFFFFC | 2;
              goto LABEL_171;
            case '.':
              if ((int)v83 >= (int)v78)
              {
                CFStringRef ImmutableFunnel3 = 0;
                __int16 v150 = 43;
LABEL_262:
                uint64_t v89 = v498;
                __int16 *v498 = v150;
                goto LABEL_205;
              }
              if (v79) {
                unsigned int v102 = *(unsigned __int8 *)(v79 + (int)v83);
              }
              else {
                unsigned int v102 = *(unsigned __int16 *)(v80 + 2 * (int)v83);
              }
              LODWORD(v83) = v83 + 1;
              int v483 = 1;
              if (v102 == 42)
              {
                unsigned __int8 v100 = -2;
                *uint64_t v462 = -2;
LABEL_174:
                int v483 = 1;
                goto LABEL_179;
              }
              break;
            case '0':
              if (v483)
              {
                _DWORD *v470 = 0;
                goto LABEL_174;
              }
              uint64_t v89 = v498;
              int v483 = 0;
              if ((v92 & 2) == 0)
              {
                v92 |= 1u;
                *unint64_t v91 = v92;
              }
              goto LABEL_157;
            case '@':
              if (v96)
              {
                int v96 = 0;
                uint64_t v98 = (int)v83;
LABEL_179:
                uint64_t v89 = v498;
                goto LABEL_157;
              }
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v152 = 37;
LABEL_275:
              uint64_t v89 = v498;
              __int16 *v498 = v152;
LABEL_276:
              __int16 v151 = 4;
LABEL_277:
              *(_WORD *)uint64_t v85 = v151;
              goto LABEL_205;
            case 'A':
            case 'a':
              goto LABEL_243;
            case 'C':
              CFStringRef ImmutableFunnel3 = 0;
              uint64_t v89 = v498;
              __int16 *v498 = 41;
              __int16 v151 = 2;
              goto LABEL_277;
            case 'D':
            case 'U':
            case 'd':
            case 'i':
            case 'u':
              int v148 = _CFExecutableLinkedOnOrAfter(8uLL);
              unint64_t v91 = v85 + 20;
              if (v148) {
                *v496 |= 0x20u;
              }
              long long v71 = v502;
              if ((v102 & 0xFFDF) == 0x55) {
                char v149 = 4;
              }
              else {
                char v149 = 1;
              }
              v502[32 * (void)v82 + 28] = v149;
              unint64_t v79 = v486;
              CFIndex v78 = range;
              unint64_t v80 = v485;
              long long v84 = xmmword_182DAF8B0;
              goto LABEL_261;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              int v138 = _CFExecutableLinkedOnOrAfter(8uLL);
              unint64_t v91 = v85 + 20;
              if (v138) {
                *v496 |= 0x20u;
              }
              if (v102 - 65 >= 0x1A) {
                __int16 v139 = v102;
              }
              else {
                __int16 v139 = v102 + 32;
              }
              long long v71 = v502;
              v502[32 * (void)v82 + 28] = ((v139 & 0xFFFE) == 102) | (2 * ((v139 & 0xFFFD) == 101));
              unint64_t v79 = v486;
              CFIndex v78 = range;
              unint64_t v80 = v485;
              long long v84 = xmmword_182DAF8B0;
              if (v483 && *v470 == -1 && *v462 == 255) {
                _DWORD *v470 = 0;
              }
LABEL_243:
              uint64_t v89 = v498;
              __int16 *v498 = 34;
              if (*(_WORD *)v85 == 5)
              {
                CFStringRef ImmutableFunnel3 = 0;
                goto LABEL_205;
              }
              CFStringRef ImmutableFunnel3 = 0;
              goto LABEL_276;
            case 'L':
              __int16 v118 = 5;
              goto LABEL_178;
            case 'O':
            case 'X':
            case 'o':
            case 'x':
LABEL_261:
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v150 = 33;
              goto LABEL_262;
            case 'P':
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v152 = 40;
              goto LABEL_275;
            case 'S':
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v152 = 38;
              goto LABEL_275;
            case '[':
              if (!v95) {
                uint64_t v98 = (int)v83;
              }
              int v95 = 1;
              goto LABEL_179;
            case 'c':
              CFStringRef ImmutableFunnel3 = 0;
              uint64_t v89 = v498;
              __int16 *v498 = 33;
              __int16 v151 = 1;
              goto LABEL_277;
            case 'h':
              uint64_t v89 = v498;
              if ((int)v83 < (int)v78
                && (!v79
                  ? (int v120 = *(unsigned __int16 *)(v80 + 2 * (int)v83))
                  : (int v120 = *(unsigned __int8 *)(v79 + (int)v83)),
                    v120 == 104))
              {
                LODWORD(v83) = v83 + 1;
                __int16 v122 = 1;
              }
              else
              {
                __int16 v122 = 2;
              }
              goto LABEL_200;
            case 'j':
            case 'q':
            case 't':
            case 'z':
              __int16 v118 = 4;
LABEL_178:
              *(_WORD *)uint64_t v85 = v118;
              goto LABEL_179;
            case 'l':
              uint64_t v89 = v498;
              if ((int)v83 < (int)v78)
              {
                int v121 = v79 ? *(unsigned __int8 *)(v79 + (int)v83) : *(unsigned __int16 *)(v80 + 2 * (int)v83);
                if (v121 == 108) {
                  LODWORD(v83) = v83 + 1;
                }
              }
              __int16 v122 = 4;
LABEL_200:
              *(_WORD *)uint64_t v85 = v122;
              goto LABEL_157;
            case 'n':
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v152 = 42;
              goto LABEL_275;
            case 'p':
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v152 = 35;
              goto LABEL_275;
            case 's':
              CFStringRef ImmutableFunnel3 = 0;
              __int16 v152 = 39;
              goto LABEL_275;
            default:
              __int16 *v498 = 32;
              goto LABEL_279;
          }
        }
      }
      if (v102 >= 0x30 && v102 - 58 >= 7)
      {
        BOOL v104 = v102 == 95 || v102 - 91 >= 6;
        BOOL v105 = !v104;
        if (v102 <= 0x7A && !v105) {
          goto LABEL_157;
        }
      }
      if (v102 != 93) {
        break;
      }
      uint64_t v116 = v101 - v98;
      BOOL v117 = v95 == 0;
      if (v95) {
        int v94 = 1;
      }
      else {
        int v95 = 0;
      }
      if (!v117) {
        uint64_t v93 = v116;
      }
LABEL_157:
      if ((int)v83 >= (int)v78) {
        goto LABEL_203;
      }
    }
    if (v102 != 64)
    {
      uint64_t v98 = -1;
      goto LABEL_157;
    }
    int v140 = v92 | 0x40;
    if (!v94) {
      int v140 = v92;
    }
    *unint64_t v91 = v140 | 0x10;
    if (v94) {
      uint64_t v141 = v93;
    }
    else {
      uint64_t v141 = v101 - v98;
    }
    *uint64_t v89 = 37;
    *(_WORD *)uint64_t v85 = 4;
    if (v141 < 1)
    {
      CFStringRef ImmutableFunnel3 = 0;
      goto LABEL_205;
    }
    CFAllocatorRef v142 = v89;
    if (v79)
    {
      uint64_t v143 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding(v99);
        unint64_t v79 = v486;
        uint64_t v143 = __CFDefaultEightBitStringEncoding;
      }
      uint64_t v144 = (int8x16_t *)(v79 + v98);
      int64_t v145 = v141;
      unsigned int v146 = 2;
      CFArrayRef v147 = (__objc2_class **)-1;
    }
    else
    {
      int64_t v145 = 2 * v141;
      uint64_t v144 = (int8x16_t *)(v80 + 2 * v98);
      uint64_t v143 = 256;
      unsigned int v146 = 16;
      CFArrayRef v147 = &__kCFAllocatorNull;
    }
    CFStringRef ImmutableFunnel3 = (const __CFString *)__CFStringCreateImmutableFunnel3(0, v144, v145, v143, v146, v147, 0);
    uint64_t v89 = v142;
    long long v71 = v502;
    unint64_t v79 = v486;
    CFIndex v78 = range;
    unint64_t v80 = v485;
    long long v84 = xmmword_182DAF8B0;
    unint64_t v91 = v496;
    if (*v142 != 32)
    {
LABEL_205:
      if ((*v91 & 0x10) == 0)
      {
LABEL_229:
        *uint64_t v87 = v83 - v90;
        goto LABEL_230;
      }
      long long v499 = v89;
      if ((*v91 & 0x40) == 0)
      {
        if (!theDict || !ImmutableFunnel3)
        {
          int v126 = (__CFDictionary **)&v477[8 * v476];
          *int v126 = 0;
          if (!ImmutableFunnel3)
          {
LABEL_215:
            __int16 v127 = 32;
LABEL_228:
            *uint64_t v89 = v127;
            goto LABEL_229;
          }
          goto LABEL_220;
        }
        CFArrayRef Value = (__CFDictionary *)CFDictionaryGetValue(theDict, ImmutableFunnel3);
LABEL_219:
        int v126 = (__CFDictionary **)&v477[8 * v476];
        *int v126 = Value;
LABEL_220:
        CFRelease(ImmutableFunnel3);
        CFDictionaryRef v128 = *v126;
        long long v71 = v502;
        unint64_t v79 = v486;
        goto LABEL_221;
      }
      if (!ImmutableFunnel3)
      {
        CFDictionaryRef v128 = v490;
        *(void *)&v477[8 * v476] = v490;
LABEL_221:
        if (v128)
        {
          *UniChar v88 = v476;
          uint64_t v135 = CFDictionaryGetValue(v128, @"NSStringFormatSpecTypeKey");
          uint64_t v136 = CFDictionaryGetValue(v128, @"NSStringFormatValueTypeKey");
          if (!v135 || (uint64_t v137 = v136, !CFEqual(v135, @"NSStringPluralRuleType")))
          {
            ++v476;
            long long v71 = v502;
            unint64_t v79 = v486;
            CFIndex v78 = range;
            unint64_t v80 = v485;
            long long v84 = xmmword_182DAF8B0;
            goto LABEL_229;
          }
          long long v71 = v502;
          unint64_t v79 = v486;
          CFIndex v78 = range;
          unint64_t v80 = v485;
          long long v84 = xmmword_182DAF8B0;
          if (v137)
          {
            ++v476;
            goto LABEL_229;
          }
          __int16 v127 = 44;
          ++v476;
        }
        else
        {
          __int16 v127 = 32;
          CFIndex v78 = range;
          unint64_t v80 = v485;
          long long v84 = xmmword_182DAF8B0;
        }
        uint64_t v89 = v499;
        goto LABEL_228;
      }
      v551.CFIndex length = CFStringGetLength(ImmutableFunnel3);
      v551.uint64_t location = 0;
      if (CFStringCompareWithOptionsAndLocale(ImmutableFunnel3, @"tt", v551, 0, 0))
      {
        v552.CFIndex length = CFStringGetLength(ImmutableFunnel3);
        uint64_t v125 = @"VocativeName";
        v552.uint64_t location = 0;
        if (!CFStringFindWithOptionsAndLocale(ImmutableFunnel3, @"VocativeName", v552, 8uLL, 0, 0))
        {
          CFArrayRef Value = 0;
          CFDictionaryRef v490 = 0;
          goto LABEL_219;
        }
      }
      else
      {
        uint64_t v125 = @"TechnicalTerm";
      }
      unint64_t v129 = CFDictionaryGetValue((CFDictionaryRef)&unk_1ECF55520, @"NSStringFormatFamilyInfoKey");
      uint64_t InputIdentifierFormatterMappingFromDescriptor = _CFStringGetInputIdentifierFormatterMappingFromDescriptor((uint64_t)v129);
      CFDictionaryRef v131 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)&unk_1ECF55520, @"NSStringFormatRuleInfoKey");
      CFDictionaryRef v132 = (const __CFDictionary *)CFDictionaryGetValue(v131, v125);
      CFIndex Count = CFDictionaryGetCount(v132);
      CFArrayRef Value = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, v132);
      uint64_t v134 = (const void *)InputIdentifierFormatterMappingFromDescriptor;
      CFAllocatorRef v82 = __src;
      CFDictionaryAddValue(Value, @"NSStringFormatFamilyInfoKey", v134);
      CFDictionaryRef v490 = Value;
      goto LABEL_219;
    }
LABEL_279:
    *CFRange v86 = v90 + 1;
    *uint64_t v87 = v83 + ~v90;
    *v91 |= 0x80u;
LABEL_230:
    CFAllocatorRef v82 = (char *)v82 + 1;
  }
  while (v78 > (int)v83);
  long long v73 = (__objc2_class **)alloc;
  int v45 = v461;
  p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
LABEL_288:
  int v157 = a9;
  int v158 = 3 * (v49 + a9) + 1;
  uint64_t v159 = v546;
  if (v158 >= 62)
  {
    uint64_t v159 = (unsigned char *)CFAllocatorAllocateTyped(v73, 16 * (3 * (v49 + a9) + 1), 0x1082040F23858EBLL, 0);
    if (v159 != v546)
    {
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }
  bzero(v159, 16 * v158);
  long long v508 = 0;
  if (v476 >= 1) {
    long long v508 = a13;
  }
  __srca = v159;
  long long v71 = v502;
  if (v82)
  {
    uint64_t v161 = 0;
    if (v460) {
      BOOL v162 = theDict == 0;
    }
    else {
      BOOL v162 = 1;
    }
    int v163 = !v162;
    int v465 = v163;
    uint64_t v164 = v82;
    int v500 = v158;
    uint64_t v471 = a9;
    while (2)
    {
      uint64_t v165 = &v71[32 * v161];
      unsigned int v166 = *((unsigned __int16 *)v165 + 1);
      uint64_t v167 = (1 << v166) & 0x180100000001;
      if (v166 <= 0x2C && v167 != 0) {
        goto LABEL_306;
      }
      int v169 = v500 - 1;
      uint64_t v170 = v165 + 24;
      if (v500 <= (char)v165[24]) {
        int v169 = (char)v165[24];
      }
      uint64_t v172 = v165 + 25;
      int v171 = (char)v165[25];
      if (v169 > v171) {
        int v171 = v169;
      }
      uint64_t v173 = v165 + 26;
      if (v171 <= (char)v165[26]) {
        int v171 = (char)v165[26];
      }
      if (v500 > v171)
      {
        int v174 = v165[26];
        goto LABEL_330;
      }
      int v175 = 3 * v171 + 1;
      if (v171 < 21)
      {
        uint64_t v176 = __srca;
      }
      else
      {
        uint64_t location = CFAllocatorAllocateTyped(alloc, 16 * (3 * v171 + 1), 0x1082040F23858EBLL, 0);
        uint64_t v176 = (char *)location;
        if ((unsigned char *)location != v546 && __CFOASafe != 0)
        {
          __CFSetLastAllocationEventName();
          goto LABEL_325;
        }
        if ((unsigned char *)location == v546)
        {
          long long v71 = v502;
          uint64_t v176 = __srca;
          uint64_t v172 = v165 + 25;
        }
        else
        {
LABEL_325:
          memcpy(v176, __srca, 16 * v500);
          bzero(&v176[16 * v500], 16 * (v175 - (uint64_t)v500));
          if (__srca != v546) {
            CFAllocatorDeallocate(alloc, __srca);
          }
          long long v71 = v502;
          p_info = &OBJC_METACLASS_____NSCFAttributedString.info;
          uint64_t v172 = v165 + 25;
          uint64_t v173 = v165 + 26;
        }
        uint64_t v170 = v165 + 24;
      }
      int v174 = *v173;
      __srca = v176;
      int v500 = v175;
LABEL_330:
      if (v174 == 254)
      {
        *uint64_t v173 = v157;
        if (((char)v157 - 127) <= 0xFFFFFEFF) {
          goto LABEL_897;
        }
        ++v157;
      }
      if (*v172 == 254)
      {
        *uint64_t v172 = v157;
        if (((char)v157 - 127) <= 0xFFFFFEFF) {
          goto LABEL_897;
        }
        ++v157;
      }
      int v178 = *v170;
      if (v178 == 255)
      {
        *uint64_t v170 = v157;
        if (((char)v157 - 127) <= 0xFFFFFEFF)
        {
LABEL_897:
          if (a15)
          {
            uint64_t v435 = _CFGetTSD(1u);
            if (v435) {
              CFAllocatorRef v436 = (const __CFAllocator *)v435;
            }
            else {
              CFAllocatorRef v436 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
            }
            uint64_t v437 = CFDictionaryCreateMutable(v436, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v437, @"NSDebugDescription", @"Overflow occurred");
            CFErrorRef v438 = CFErrorCreate(v436, @"NSCocoaErrorDomain", 2048, v437);
            CFRelease(v437);
            long long v71 = v502;
            *a15 = v438;
          }
          CFAllocatorRef v44 = alloc;
          goto LABEL_903;
        }
        LOBYTE(v178) = v157++;
      }
      unsigned int v179 = &__srca[16 * (char)v178];
      *((_WORD *)v179 + 1) = *(_WORD *)v165;
      int v180 = *((unsigned __int16 *)v165 + 1);
      *(_WORD *)unsigned int v179 = v180;
      uint64_t v181 = (char)v71[32 * v161 + 27];
      if (v181 == -1)
      {
        BOOL v75 = v180 == 32;
        int v190 = v465;
        if (v75) {
          int v190 = 0;
        }
        if (v190 == 1)
        {
          CFIndex v191 = &v71[32 * v161];
          uint64_t v192 = *((int *)v191 + 1);
          int64_t v193 = *((int *)v191 + 2);
          CFAllocatorRef v44 = alloc;
          unint64_t v194 = v486;
          if (v486)
          {
            uint64_t v195 = *((unsigned int *)p_info + 956);
            if (v195 == -1)
            {
              __CFStringComputeEightBitStringEncoding(location);
              unint64_t v194 = v486;
              uint64_t v195 = *((unsigned int *)p_info + 956);
            }
            uint64_t v196 = (int8x16_t *)(v194 + v192);
            uint64_t v197 = (__objc2_class **)alloc;
            int64_t v198 = v193;
            unsigned int v199 = 18;
          }
          else
          {
            int64_t v198 = 2 * v193;
            uint64_t v196 = (int8x16_t *)(v485 + 2 * v192);
            uint64_t v197 = (__objc2_class **)alloc;
            uint64_t v195 = 256;
            unsigned int v199 = 16;
          }
          CFTypeRef v229 = __CFStringCreateImmutableFunnel3(v197, v196, v198, v195, v199, &__kCFAllocatorNull, 0);
          uint64_t v69 = v477;
          if (!v229)
          {
            v440 = CFDictionaryCreateMutable(alloc, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v440, @"NSDebugDescription", @"Unable to allocate CFString to validate format specifiers");
            *a15 = CFErrorCreate(alloc, @"NSCocoaErrorDomain", 2048, v440);
            CFRelease(v440);
            int v45 = v461;
LABEL_906:
            long long v71 = v502;
LABEL_907:
            BOOL v70 = __srca;
            int64_t v29 = a14;
            goto LABEL_874;
          }
          uint64_t v230 = __CFStringValidateFormat((uint64_t)v460, (uint64_t)v229);
          CFRelease(v229);
          long long v71 = v502;
          uint64_t v471 = v230;
          if (v230 < 0)
          {
            CFAllocatorRef v44 = alloc;
            int v45 = v461;
            goto LABEL_907;
          }
        }
      }
      else
      {
        uint64_t v182 = v170;
        uint64_t location = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)&v477[8 * v181], @"NSStringFormatValueTypeKey");
        if (location)
        {
          CFStringRef v183 = (const __CFString *)location;
          CFStringRef CharactersPtr = CFStringGetCharactersPtr((CFStringRef)location);
          unint64_t v185 = (unint64_t)CharactersPtr;
          uint64_t v186 = *((unsigned int *)p_info + 956);
          if (v186 == -1)
          {
            __CFStringComputeEightBitStringEncoding(CharactersPtr);
            uint64_t v186 = *((unsigned int *)p_info + 956);
          }
          uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal(v183, v186, 1, 1);
          uint64_t location = CFStringGetLength(v183);
          CFIndex v188 = location;
          if (v185 | CStringPtrInternal)
          {
            uint64_t v189 = 0;
          }
          else
          {
            unint64_t v185 = CFAllocatorAllocateTyped(alloc, 2 * location, 0x1000040BDFB0063, 0);
            v550.uint64_t location = 0;
            v550.CFIndex length = v188;
            CFStringGetCharacters(v183, v550, (UniChar *)v185);
            uint64_t v189 = (void *)v185;
          }
          CFStringRef v467 = v183;
          if ((int)v188 >= 1)
          {
            int v200 = 0;
            int v201 = 0;
            BOOL v202 = 0;
            UniChar v463 = 0;
            int v203 = 0;
            unsigned __int8 v204 = -1;
            uint64_t v205 = -1;
            unsigned __int8 v206 = -1;
            while (1)
            {
              if (CStringPtrInternal) {
                uint64_t location = *(unsigned __int8 *)(CStringPtrInternal + v203);
              }
              else {
                uint64_t location = *(unsigned __int16 *)(v185 + 2 * v203);
              }
              ++v203;
              if (v205 < 0)
              {
                while (2)
                {
                  uint64_t v211 = 0;
                  if (v203 <= (int)v188) {
                    int v212 = v188;
                  }
                  else {
                    int v212 = v203;
                  }
                  uint64_t v213 = (UniChar *)(v185 + 2 * v203);
                  int v214 = v203;
                  while (2)
                  {
                    int64_t v215 = (UniChar *)v185;
                    UniChar v216 = 1;
                    UniChar v217 = 33;
                    switch((int)location)
                    {
                      case ' ':
                      case '+':
                      case '-':
                        v203 += v211;
                        goto LABEL_422;
                      case '#':
                        v203 += v211;
                        int v201 = 1;
                        goto LABEL_422;
                      case '*':
                        v203 += v211;
                        unsigned __int8 v204 = -2;
                        goto LABEL_422;
                      case '.':
                        if (!(v203 - (uint64_t)v212 + v211)) {
                          goto LABEL_455;
                        }
                        if (CStringPtrInternal) {
                          uint64_t location = *(unsigned __int8 *)(CStringPtrInternal + v203 + v211);
                        }
                        else {
                          uint64_t location = v213[v211];
                        }
                        unint64_t v185 = (unint64_t)v215;
                        ++v211;
                        ++v214;
                        BOOL v202 = 1;
                        if (location != 42) {
                          continue;
                        }
                        v203 += v211;
                        unsigned __int8 v206 = -2;
                        goto LABEL_423;
                      case '0':
                        v203 += v211;
                        BOOL v202 = v202;
                        goto LABEL_422;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        uint64_t v218 = 0;
                        uint64_t v219 = v203 + v211;
                        int v203 = v214;
                        unint64_t v185 = (unint64_t)v215;
                        break;
                      case '@':
                        if (!v201) {
                          goto LABEL_472;
                        }
                        int v201 = 0;
                        uint64_t v205 = v211 + v203;
                        v203 += v211;
                        goto LABEL_422;
                      case 'A':
                      case 'a':
                        goto LABEL_448;
                      case 'C':
                        UniChar v216 = 2;
                        UniChar v217 = 41;
                        goto LABEL_457;
                      case 'D':
                      case 'U':
                      case 'd':
                      case 'i':
                      case 'u':
                        char v232 = v189;
                        uint64_t location = _CFExecutableLinkedOnOrAfter(8uLL);
                        uint64_t v189 = v232;
                        goto LABEL_453;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        BOOL v231 = v189;
                        uint64_t location = _CFExecutableLinkedOnOrAfter(8uLL);
                        uint64_t v189 = v231;
LABEL_448:
                        if (v463 == 5) {
                          UniChar v216 = 5;
                        }
                        else {
                          UniChar v216 = 4;
                        }
                        UniChar v217 = 34;
                        goto LABEL_457;
                      case 'L':
                        v203 += v211;
                        __int16 v222 = 5;
                        goto LABEL_409;
                      case 'O':
                      case 'X':
                      case 'o':
                      case 'x':
LABEL_453:
                        UniChar v217 = 33;
                        goto LABEL_456;
                      case 'P':
                        UniChar v216 = 4;
                        UniChar v217 = 40;
                        goto LABEL_457;
                      case 'S':
                        UniChar v216 = 4;
                        UniChar v217 = 38;
                        goto LABEL_457;
                      case '[':
                        uint64_t v223 = v211 + v203;
                        v203 += v211;
                        if (!v200) {
                          uint64_t v205 = v223;
                        }
                        int v200 = 1;
                        goto LABEL_422;
                      case 'c':
                        goto LABEL_457;
                      case 'h':
                        int v224 = v211 + v203;
                        if ((int)v211 + v203 >= (int)v188)
                        {
                          __int16 v227 = 2;
                          goto LABEL_421;
                        }
                        if (CStringPtrInternal) {
                          int v225 = *(unsigned __int8 *)(CStringPtrInternal + v203 + v211);
                        }
                        else {
                          int v225 = v213[v211];
                        }
                        unint64_t v185 = (unint64_t)v215;
                        if (v225 == 104) {
                          ++v203;
                        }
                        v203 += v211;
                        if (v225 == 104) {
                          __int16 v228 = 1;
                        }
                        else {
                          __int16 v228 = 2;
                        }
                        goto LABEL_435;
                      case 'j':
                      case 'q':
                      case 't':
                      case 'z':
                        v203 += v211;
                        __int16 v222 = 4;
LABEL_409:
                        UniChar v463 = v222;
                        goto LABEL_422;
                      case 'l':
                        int v224 = v211 + v203;
                        if ((int)v211 + v203 >= (int)v188)
                        {
                          __int16 v227 = 4;
LABEL_421:
                          UniChar v463 = v227;
                          int v203 = v224;
                          goto LABEL_422;
                        }
                        if (CStringPtrInternal) {
                          int v226 = *(unsigned __int8 *)(CStringPtrInternal + v203 + v211);
                        }
                        else {
                          int v226 = v213[v211];
                        }
                        unint64_t v185 = (unint64_t)v215;
                        if (v226 == 108) {
                          ++v203;
                        }
                        v203 += v211;
                        __int16 v228 = 4;
LABEL_435:
                        UniChar v463 = v228;
                        goto LABEL_423;
                      case 'n':
                        UniChar v216 = 4;
                        UniChar v217 = 42;
                        goto LABEL_457;
                      case 'p':
                        UniChar v216 = 4;
                        UniChar v217 = 35;
                        goto LABEL_457;
                      case 's':
                        UniChar v216 = 4;
                        UniChar v217 = 39;
                        goto LABEL_457;
                      default:
                        UniChar v216 = v463;
                        UniChar v217 = 32;
                        goto LABEL_457;
                    }
                    break;
                  }
                  do
                  {
                    uint64_t v220 = (unsigned __int128)(v218 * (__int128)10) >> 64;
                    uint64_t v221 = 10 * v218;
                    if (v220 != v221 >> 63) {
                      goto LABEL_454;
                    }
                    uint64_t location = location - 48;
                    BOOL v53 = __OFADD__(v221, location);
                    uint64_t v218 = v221 + location;
                    if (v53) {
                      goto LABEL_454;
                    }
                    if (v219 >= (int)v188)
                    {
LABEL_455:
                      UniChar v217 = 43;
                      goto LABEL_456;
                    }
                    if (CStringPtrInternal) {
                      uint64_t location = *(unsigned __int8 *)(CStringPtrInternal + v219);
                    }
                    else {
                      uint64_t location = v215[v219];
                    }
                    ++v219;
                    ++v203;
                  }
                  while ((location - 48) < 0xA);
                  if (location != 36)
                  {
                    if (v218 <= 0x7FFFFFFF) {
                      continue;
                    }
LABEL_454:
                    UniChar v217 = 0;
LABEL_456:
                    UniChar v216 = v463;
                    goto LABEL_457;
                  }
                  break;
                }
                if (v218 > 127) {
                  goto LABEL_454;
                }
                if (v206 == 254)
                {
                  unsigned __int8 v206 = v218 - 1;
                }
                else if (v204 == 254)
                {
                  unsigned __int8 v204 = v218 - 1;
                }
LABEL_422:
                unint64_t v185 = (unint64_t)v215;
              }
              else
              {
                BOOL v207 = location >= 0x30 && (location - 58) >= 7;
                if (!v207
                  || (location != 95 ? (BOOL v208 = (location - 91) >= 6) : (BOOL v208 = 1),
                      v208 ? (int v209 = 0) : (int v209 = 1),
                      location <= 0x7A ? (BOOL v210 = v209 == 0) : (BOOL v210 = 0),
                      !v210))
                {
                  if (location != 93)
                  {
                    if (location == 64)
                    {
LABEL_472:
                      UniChar v216 = 4;
                      UniChar v217 = 37;
                      goto LABEL_457;
                    }
                    uint64_t v205 = -1;
                  }
                }
              }
LABEL_423:
              if (v203 >= (int)v188)
              {
                UniChar v216 = v463;
                goto LABEL_442;
              }
            }
          }
          UniChar v216 = 0;
LABEL_442:
          UniChar v217 = 43;
LABEL_457:
          if (v189) {
            CFAllocatorDeallocate(alloc, v189);
          }
          p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
          if (!v460) {
            goto LABEL_465;
          }
          CFRange v233 = CFStringFind(v467, @"%", 0);
          uint64_t location = v233.location;
          if (v233.location != -1 || v233.length)
          {
            CFAllocatorRef v44 = alloc;
            uint64_t v439 = CFDictionaryCreateMutable(alloc, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v439, @"NSDebugDescription", @"Invalid format for NSStringFormatValueTypeKey");
            *a15 = CFErrorCreate(alloc, @"NSCocoaErrorDomain", 2048, v439);
            CFRelease(v439);
            int v45 = v461;
            uint64_t v69 = v477;
            goto LABEL_906;
          }
          if ((0xC0100000000uLL >> v217))
          {
LABEL_465:
            long long v71 = v502;
          }
          else
          {
            chars[0] = v216;
            chars[1] = v217;
            *(_OWORD *)&chars[2] = *(_OWORD *)(v165 + 4);
            *(_OWORD *)&chars[8] = *((_OWORD *)v165 + 1);
            uint64_t location = __CFStringValidateFormatSpec(v460, chars, v471);
            long long v71 = v502;
            uint64_t v471 = location;
            if (location < 0)
            {
              CFAllocatorRef v44 = alloc;
              CFStringRef v441 = CFStringCreateWithFormat(alloc, 0, @"NSStringFormatValueTypeKey '%@' does not match expected specifiers '%@'", v467, v460);
              uint64_t v442 = CFDictionaryCreateMutable(alloc, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              CFDictionarySetValue(v442, @"NSDebugDescription", v441);
              *a15 = CFErrorCreate(alloc, @"NSCocoaErrorDomain", 2048, v442);
              CFRelease(v442);
              CFRelease(v441);
              long long v71 = v502;
LABEL_903:
              int v45 = v461;
              uint64_t v69 = v477;
              goto LABEL_907;
            }
          }
          uint64_t v234 = (UniChar *)&__srca[16 * *v182];
          v234[1] = v216;
          *uint64_t v234 = v217;
        }
        else
        {
          long long v71 = v502;
        }
      }
      uint64_t v235 = (char)v165[26];
      if (v235 != -1) {
        *(_DWORD *)&__srca[16 * v235] = 33;
      }
      uint64_t v236 = (char)*v172;
      if (v236 != -1) {
        *(_DWORD *)&__srca[16 * v236] = 33;
      }
      int v45 = v461;
      uint64_t v164 = v82;
LABEL_306:
      if (++v161 == v164) {
        goto LABEL_483;
      }
      continue;
    }
  }
  int v500 = 3 * (v49 + a9) + 1;
LABEL_483:
  if (v500 >= 1)
  {
    uint64_t v237 = 0;
    int v238 = 0;
    uint64_t v239 = a11;
    int64_t v240 = (__int16 *)__srca;
    do
    {
      if (a11 && v237 < a12 && !*v240) {
        *(_OWORD *)int64_t v240 = *v239;
      }
      unsigned int v241 = *v240;
      if (v241 > 0x2C)
      {
LABEL_917:
        __break(1u);
        return;
      }
      if (((1 << v241) & 0x7EE00000000) != 0)
      {
        int v238 = v237;
      }
      else if (((1 << v241) & 0x180100000001) == 0)
      {
        goto LABEL_917;
      }
      ++v237;
      v240 += 8;
      ++v239;
    }
    while (v500 != v237);
    uint64_t v242 = 0;
    uint64_t v243 = v238;
    UniChar v244 = __srca + 8;
    do
    {
      switch(*((_WORD *)v244 - 4))
      {
        case '!':
        case ')':
          switch(*((_WORD *)v244 - 3))
          {
            case 1:
              uint64_t v247 = (char *)a13;
              a13 += 4;
              uint64_t v246 = *v247;
              break;
            case 2:
              UniChar v251 = a13;
              a13 += 4;
              uint64_t v246 = *v251;
              break;
            case 4:
              goto LABEL_496;
            default:
              uint64_t v250 = a13;
              a13 += 4;
              uint64_t v246 = *(int *)v250;
              break;
          }
          goto LABEL_497;
        case '""':
          CFIndex v249 = a13;
          a13 += 4;
          *UniChar v244 = *(void *)v249;
          break;
        case '#':
        case '%':
        case '&':
        case '\'':
        case '(':
LABEL_496:
          UTF32Char v245 = a13;
          a13 += 4;
          uint64_t v246 = *(void *)v245;
LABEL_497:
          *UniChar v244 = v246;
          break;
        case '$':
          break;
        case '*':
          a13 += 4;
          *UniChar v244 = &ptr.i64[1];
          break;
        default:
          if (!*((_WORD *)v244 - 4))
          {
            int v248 = dyld_program_sdk_at_least();
            if (v242 < v243)
            {
              if (v248) {
                a13 += 4;
              }
            }
          }
          break;
      }
      v244 += 2;
      ++v242;
    }
    while (v500 != v242);
  }
  uint64_t v252 = v500;
  BOOL v70 = __srca;
  if (a11) {
    unsigned int v253 = (char *)a11;
  }
  else {
    unsigned int v253 = __srca;
  }
  uint64_t v488 = v500;
  if (a11) {
    uint64_t v252 = a12;
  }
  uint64_t v455 = v252;
  CFStringCompareFlags v456 = v253;
  if (!v82)
  {
    uint64_t v431 = 0;
    goto LABEL_872;
  }
  CFIndex v497 = v82;
  CFIndex v254 = (CFIndex)malloc_type_calloc(v82, 0x20uLL, 0x10000408E5DAE1CuLL);
  CFIndex v484 = (char *)v254;
  uint64_t v255 = 0;
  int cf2 = 0;
  char key = 0;
  CFIndex v453 = 0;
  int v256 = v502;
  BOOL v257 = v502 - 8;
  uint64_t v258 = 1;
  while (2)
  {
    ptr.i16[0] = 0;
    unsigned int v259 = &v256[32 * v255];
    uint64_t v261 = v259 + 26;
    uint64_t v260 = (char)v259[26];
    if (v260 == -1)
    {
      unsigned int v262 = 0;
      int v263 = 0;
    }
    else
    {
      unsigned int v262 = v70[4 * v260 + 2];
      int v263 = 1;
    }
    uint64_t v265 = v259 + 25;
    uint64_t v264 = (char)v259[25];
    long long v501 = &v256[32 * v255];
    if (v264 == -1)
    {
      unsigned int v266 = 0;
      int v267 = 0;
    }
    else
    {
      unsigned int v266 = v70[4 * v264 + 2];
      int v267 = 1;
    }
    char v268 = &v256[32 * v255];
    int v271 = *((__int16 *)v268 + 1);
    CFComparisonResult v270 = v268 + 2;
    int v269 = v271;
    unsigned int v272 = *(_DWORD *)(v270 + 10);
    if (v272 == -1) {
      uint64_t v273 = v262;
    }
    else {
      uint64_t v273 = v272;
    }
    if (v272 == -1) {
      int v274 = v263;
    }
    else {
      int v274 = 1;
    }
    unsigned int v275 = *(_DWORD *)(v270 + 14);
    if (v275 == -1) {
      uint64_t v276 = v266;
    }
    else {
      uint64_t v276 = v275;
    }
    if (v275 == -1) {
      int v277 = v267;
    }
    else {
      int v277 = 1;
    }
    switch(v269)
    {
      case ' ':
        if (a14)
        {
          int64_t v307 = (unint64_t *)v506;
          CFIndex v254 = CFStringGetLength(v506);
          int v256 = v502;
          CFIndex v308 = v254;
        }
        else
        {
          CFIndex v308 = 0;
          int64_t v307 = (unint64_t *)v506;
        }
        int64_t v350 = &v256[32 * v255];
        uint64_t v352 = *((int *)v350 + 1);
        unint64_t v351 = *((int *)v350 + 2);
        unint64_t v353 = v486;
        if (v486)
        {
          uint64_t v354 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding(v254);
            unint64_t v353 = v486;
            uint64_t v354 = __CFDefaultEightBitStringEncoding;
          }
          __CFStringAppendBytes(v307, (unsigned __int8 *)(v353 + v352), v351, v354);
          if (a14)
          {
LABEL_635:
            CFIndex v349 = CFStringGetLength((CFStringRef)v307);
            goto LABEL_651;
          }
        }
        else
        {
          CFStringAppendCharacters((CFMutableStringRef)v307, (const UniChar *)(v485 + 2 * v352), v351);
          if (a14) {
            goto LABEL_635;
          }
        }
        CFIndex v349 = 0;
LABEL_651:
        *(_OWORD *)chars = *v501;
        *(_OWORD *)&chars[8] = v501[1];
        long long v358 = v495;
        CFIndex v357 = v497;
        BOOL v70 = __srca;
LABEL_655:
        uint64_t v359 = (uint64_t)v70;
        uint64_t v360 = v488;
        CFIndex v312 = v308;
LABEL_721:
        int v377 = 0;
        goto LABEL_825;
      case '!':
      case '""':
        if (!v493 || (v256[32 * v255 + 20] & 0x20) == 0) {
          goto LABEL_538;
        }
        if (a14)
        {
          uint64_t v347 = v273;
          cStrc = (char *)CFStringGetLength(v506);
          BOOL v70 = __srca;
          int v348 = __CFStringFormatLocalizedNumber(v506, v494, (uint64_t)__srca, (uint64_t)v501, v347, v276, v277);
          uint64_t v273 = v347;
          int v256 = v502;
          if (v348)
          {
            CFIndex v349 = CFStringGetLength(v506);
            CFIndex v312 = (CFIndex)cStrc;
            goto LABEL_698;
          }
        }
        else
        {
          uint64_t v371 = v273;
          int v372 = __CFStringFormatLocalizedNumber(v506, v494, (uint64_t)v70, (uint64_t)v501, v273, v276, v277);
          uint64_t v273 = v371;
          int v256 = v502;
          if (v372)
          {
            CFIndex v312 = 0;
            CFIndex v349 = 0;
LABEL_698:
            CFRange v368 = v501;
LABEL_690:
            *(_OWORD *)chars = *v368;
            *(_OWORD *)&chars[8] = v368[1];
            long long v358 = v495;
            CFIndex v357 = v497;
            uint64_t v359 = (uint64_t)v70;
            uint64_t v360 = v488;
            goto LABEL_721;
          }
        }
LABEL_538:
        int64_t v278 = &v256[32 * v255];
        uint64_t v280 = *((int *)v278 + 2);
        int64_t v279 = (int *)(v278 + 8);
        uint64_t v281 = v280 + 1;
        if ((v280 + 1) < 0x81)
        {
          uint64_t v283 = 0;
          int64_t v284 = (const char *)v543;
        }
        else
        {
          uint64_t v282 = v273;
          uint64_t v283 = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v281, 1729151376, 0);
          uint64_t v273 = v282;
          int64_t v284 = (const char *)v283;
        }
        uint64_t v472 = v273;
        uint64_t v468 = (__CFString *)v283;
        if ((int)v276 + (int)v273 < 17)
        {
          uint64_t v290 = 0;
          uint64_t v291 = chars;
          uint64_t v289 = 528;
        }
        else
        {
          uint64_t v289 = (int)v276 + (int)v273 + 512;
          uint64_t v290 = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v289, 1387548496, 0);
          uint64_t v291 = (UniChar *)v290;
        }
        uint64_t v292 = v502;
        uint64_t v293 = *(int *)&v502[32 * v255 + 4];
        int v294 = *v279;
        if (v486)
        {
          if (v294 >= 1)
          {
            uint64_t v295 = 0;
            int v296 = 0;
            do
            {
              int v297 = *(unsigned __int8 *)(v486 + v295 + v293);
              if (v297 == 36)
              {
                if ((v296 & 0x80000000) == 0)
                {
                  uint64_t v298 = &v284[v296 - 1];
                  do
                  {
                    int v299 = *(unsigned __int8 *)v298--;
                    --v296;
                  }
                  while ((v299 - 48) < 0xA);
                }
              }
              else
              {
                v284[v296] = v297;
                int v294 = *v279;
              }
              ++v296;
              ++v295;
            }
            while (v295 < v294);
            goto LABEL_570;
          }
        }
        else if (v294 >= 1)
        {
          uint64_t v300 = 0;
          int v296 = 0;
          do
          {
            int v301 = *(unsigned __int16 *)(v485 + 2 * (v300 + v293));
            if (v301 == 36)
            {
              if ((v296 & 0x80000000) == 0)
              {
                unint64_t v302 = &v284[v296 - 1];
                do
                {
                  int v303 = *(unsigned __int8 *)v302--;
                  --v296;
                }
                while ((v303 - 48) < 0xA);
              }
            }
            else
            {
              v284[v296] = v301;
              int v294 = *v279;
            }
            ++v296;
            ++v300;
          }
          while (v300 < v294);
LABEL_570:
          int v466 = (void *)v290;
          v284[v296] = 0;
          cStrb = (char *)v291;
          *((unsigned char *)v291 + v289 - 1) = 0;
          if (a14)
          {
            uint64_t v290 = CFStringGetLength(v506);
            uint64_t v292 = v502;
            uint64_t v464 = v290;
          }
          else
          {
            uint64_t v464 = 0;
          }
          switch(*(_WORD *)v270)
          {
            case '!':
              uint64_t v304 = *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
              if (*(_WORD *)v501 == 4)
              {
                int v343 = *v265;
                uint64_t v344 = v472;
                unsigned int v306 = cStrb;
                if (*v261 != 255) {
                  goto LABEL_657;
                }
              }
              else
              {
                int v343 = *v265;
                uint64_t v344 = v472;
                unsigned int v306 = cStrb;
                if (*v261 != 255)
                {
LABEL_657:
                  if (v343 == 255) {
                    uint64_t v290 = snprintf_l(v306, 0x1FFuLL, 0, v284, v344, *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8], v448, v449, v450, v451, v452);
                  }
                  else {
                    uint64_t v290 = snprintf_l(v306, 0x1FFuLL, 0, v284, v344, v276, *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8], v449, v450, v451, v452);
                  }
                  goto LABEL_734;
                }
              }
              if (v343 != 255) {
                goto LABEL_629;
              }
LABEL_661:
              uint64_t v290 = snprintf_l(v306, 0x1FFuLL, 0, v284, v304, v447, v448, v449, v450, v451, v452);
LABEL_734:
              CFStringEncoding v381 = __CFDefaultEightBitStringEncoding;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding(v290);
                CFStringEncoding v381 = __CFDefaultEightBitStringEncoding;
              }
              CFStringRef v382 = v506;
              CFStringAppendCString(v506, cStrb, v381);
              char v384 = v501;
              unsigned int v383 = a14;
LABEL_737:
              BOOL v70 = __srca;
              if (v383) {
                CFIndex v385 = CFStringGetLength(v382);
              }
              else {
                CFIndex v385 = 0;
              }
              long long v386 = v384[1];
              v507[0] = *v384;
              v507[1] = v386;
              _CFStringFormatAppendMetadata(v495, v497, (uint64_t)__srca, v488, (uint64_t)v507, v464, v385, 0);
              if (v466) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v466);
              }
              if (v468) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v468);
              }
              break;
            case '""':
              double v345 = *(double *)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
              int v346 = *v265;
              if (*v261 == 255)
              {
                if (v346 == 255)
                {
                  uint64_t v290 = snprintf_l(cStrb, 0x1FFuLL, 0, v284, v345, *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8]);
                }
                else
                {
                  uint64_t v447 = *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
                  uint64_t v290 = snprintf_l(cStrb, 0x1FFuLL, 0, v284, v345, v276);
                }
              }
              else
              {
                if (v346 == 255)
                {
                  uint64_t v447 = *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
                }
                else
                {
                  uint64_t v448 = *(char **)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
                  uint64_t v447 = v276;
                }
                uint64_t v290 = snprintf_l(cStrb, 0x1FFuLL, 0, v284, v345, v472);
              }
              if (!v494) {
                goto LABEL_734;
              }
              CFTypeID v378 = CFGetTypeID(v494);
              uint64_t v290 = (uint64_t)(v378 == CFLocaleGetTypeID()
                             ? CFLocaleGetValue((CFLocaleRef)v494, @"kCFLocaleDecimalSeparatorKey")
                             : CFDictionaryGetValue((CFDictionaryRef)v494, @"NSDecimalSeparator"));
              CFStringRef v379 = (const __CFString *)v290;
              if (!v290) {
                goto LABEL_734;
              }
              UniChar v380 = cStrb + 1;
              while (2)
              {
                if (!*(v380 - 1)) {
                  goto LABEL_734;
                }
                if (*(v380 - 1) != 46)
                {
                  ++v380;
                  continue;
                }
                break;
              }
              *((unsigned char *)v380 - 1) = 0;
              CFStringEncoding v392 = __CFDefaultEightBitStringEncoding;
              char v384 = v501;
              unsigned int v383 = a14;
              CFStringRef v382 = v506;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding(v290);
                CFStringEncoding v392 = __CFDefaultEightBitStringEncoding;
              }
              CFStringAppendCString(v506, cStrb, v392);
              CFStringAppend(v506, v379);
              CFStringEncoding v394 = __CFDefaultEightBitStringEncoding;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding(v393);
                CFStringEncoding v394 = __CFDefaultEightBitStringEncoding;
              }
              CFStringAppendCString(v506, v380, v394);
              goto LABEL_737;
            case '#':
            case '*':
              uint64_t v304 = *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
              int v305 = *v265;
              if (*v261 != 255)
              {
                unsigned int v306 = cStrb;
                if (v305 == 255)
                {
                  uint64_t v447 = *(void *)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
                }
                else
                {
                  uint64_t v447 = v276;
                  uint64_t v448 = *(char **)&__srca[16 * (char)v292[32 * v255 + 24] + 8];
                }
                uint64_t v304 = v472;
                goto LABEL_661;
              }
              unsigned int v306 = cStrb;
              if (v305 == 255) {
                goto LABEL_661;
              }
LABEL_629:
              uint64_t v290 = snprintf_l(v306, 0x1FFuLL, 0, v284, v276, v304, v448, v449, v450, v451, v452);
              goto LABEL_734;
            default:
              goto LABEL_734;
          }
          goto LABEL_826;
        }
        int v296 = 0;
        goto LABEL_570;
      case '#':
        goto LABEL_538;
      case '%':
      case ',':
        int v285 = v273;
        if (a14)
        {
          CFIndex v286 = CFStringGetLength(v506);
          int v256 = v502;
          cStr = (char *)v286;
        }
        else
        {
          cStr = 0;
        }
        int64_t v313 = &v256[32 * v255];
        uint64_t v314 = v313 + 27;
        if (v313[27] != 255)
        {
          if (*(_WORD *)v270 == 44)
          {
            if (!cf) {
              goto LABEL_815;
            }
            v315 = cf;
LABEL_590:
            uint64_t v316 = (unint64_t *)CFRetain(v315);
LABEL_810:
            UniChar v406 = v316;
          }
          else
          {
            uint64_t v333 = &v256[32 * v255];
            uint64_t v336 = (char)v333[24];
            uint64_t v335 = v333 + 24;
            uint64_t v334 = v336;
            switch(*(_WORD *)&__srca[16 * v336])
            {
              case '!':
                uint64_t v395 = (UniChar *)&__srca[16 * v334 + 8];
                CFAllocatorRef v396 = alloc;
                CFNumberType v397 = kCFNumberSInt64Type;
                goto LABEL_809;
              case '""':
                uint64_t v398 = &__srca[16 * v334];
                if (*((_WORD *)v398 + 1) == 5)
                {
                  *(void *)chars = 0;
                  *(void *)chars = *(void *)&__srca[16 * *v335 + 8];
                  uint64_t v395 = chars;
                }
                else
                {
                  uint64_t v395 = (UniChar *)(v398 + 8);
                }
                CFAllocatorRef v396 = alloc;
                CFNumberType v397 = kCFNumberDoubleType;
                goto LABEL_809;
              case '#':
                uint64_t v395 = (UniChar *)&__srca[16 * v334 + 8];
                CFAllocatorRef v396 = alloc;
                CFNumberType v397 = kCFNumberCFIndexType;
LABEL_809:
                uint64_t v316 = (unint64_t *)CFNumberCreate(v396, v397, v395);
                goto LABEL_810;
              case '%':
                v315 = *(const void **)&__srca[16 * v334 + 8];
                if (!v315) {
                  goto LABEL_815;
                }
                goto LABEL_590;
              case '&':
                int v399 = *(const UniChar **)&__srca[16 * v334 + 8];
                if (!v399) {
                  goto LABEL_815;
                }
                BOOL v400 = CFStringCreateMutable(alloc, 0);
                uint64_t v401 = 0;
                while (v399[v401++])
                  ;
                int v403 = v401 - 1;
                if ((int)v276 >= v403 || v277 == 0) {
                  int v405 = v403;
                }
                else {
                  int v405 = v276;
                }
                if ((v502[32 * v255 + 20] & 2) == 0)
                {
                  long long v474 = v314;
                  UniChar v406 = (unint64_t *)v400;
                  if (v274)
                  {
                    int v407 = v285 - v405;
                    if (v285 > v405)
                    {
                      do
                      {
                        if (v407 >= 10) {
                          int v408 = 10;
                        }
                        else {
                          int v408 = v407;
                        }
                        __CFStringAppendBytes(v406, "          ", v408, 1536);
                        BOOL v53 = __OFSUB__(v407, 10);
                        v407 -= 10;
                      }
                      while (!((v407 < 0) ^ v53 | (v407 == 0)));
                    }
                  }
                  CFStringAppendCharacters((CFMutableStringRef)v406, v399, v405);
                  goto LABEL_863;
                }
                UniChar v406 = (unint64_t *)v400;
                CFStringAppendCharacters(v400, v399, v405);
                if (v274)
                {
                  int v418 = v285 - v405;
                  if (v285 > v405)
                  {
                    do
                    {
                      if (v418 >= 10) {
                        int v419 = 10;
                      }
                      else {
                        int v419 = v418;
                      }
                      __CFStringAppendBytes(v406, "          ", v419, 1536);
                      BOOL v53 = __OFSUB__(v418, 10);
                      v418 -= 10;
                    }
                    while (!((v418 < 0) ^ v53 | (v418 == 0)));
                  }
                }
                break;
              case '\'':
              case '(':
                if (!*(void *)&__srca[16 * v334 + 8]) {
                  goto LABEL_815;
                }
                uint64_t v469 = CFStringCreateMutable(alloc, 0);
                uint64_t v337 = *(unsigned __int8 **)&__srca[16 * *v335 + 8];
                long long v474 = v314;
                if (*(_WORD *)v270 == 40)
                {
                  int v339 = *v337++;
                  int v338 = v339;
                  if ((int)v276 >= v339 || v277 == 0) {
                    int v341 = v338;
                  }
                  else {
                    int v341 = v276;
                  }
                }
                else if (v277)
                {
                  uint64_t v410 = memchr(v337, 0, (int)v276);
                  if (v410) {
                    int v341 = v410 - v337;
                  }
                  else {
                    int v341 = v276;
                  }
                }
                else
                {
                  int v341 = strlen((const char *)v337);
                }
                UniChar v406 = (unint64_t *)v469;
                if ((v502[32 * v255 + 20] & 2) != 0)
                {
                  if (__CFDefaultSystemEncoding)
                  {
                    int v424 = 1;
                  }
                  else
                  {
                    CFStringGetSystemEncoding();
                    int v424 = __CFDefaultSystemEncoding;
                  }
                  __CFStringAppendBytes((unint64_t *)v469, v337, v341, (v424 - 1));
                  if (v274)
                  {
                    int v425 = v285 - v341;
                    if (v285 > v341)
                    {
                      do
                      {
                        if (v425 >= 10) {
                          int v426 = 10;
                        }
                        else {
                          int v426 = v425;
                        }
                        __CFStringAppendBytes((unint64_t *)v469, "          ", v426, 1536);
                        BOOL v53 = __OFSUB__(v425, 10);
                        v425 -= 10;
                      }
                      while (!((v425 < 0) ^ v53 | (v425 == 0)));
                    }
                  }
LABEL_863:
                  uint64_t v314 = v474;
                }
                else
                {
                  if (v274)
                  {
                    int v421 = v285 - v341;
                    if (v285 > v341)
                    {
                      do
                      {
                        if (v421 >= 10) {
                          int v422 = 10;
                        }
                        else {
                          int v422 = v421;
                        }
                        __CFStringAppendBytes((unint64_t *)v469, "          ", v422, 1536);
                        BOOL v53 = __OFSUB__(v421, 10);
                        v421 -= 10;
                      }
                      while (!((v421 < 0) ^ v53 | (v421 == 0)));
                    }
                  }
                  if (__CFDefaultSystemEncoding)
                  {
                    int v423 = 1;
                  }
                  else
                  {
                    CFStringGetSystemEncoding();
                    int v423 = __CFDefaultSystemEncoding;
                  }
                  __CFStringAppendBytes((unint64_t *)v469, v337, v341, (v423 - 1));
                }
                break;
              case ')':
                ptr.i16[0] = *(void *)&__srca[16 * v334 + 8];
                uint64_t v316 = (unint64_t *)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, &ptr, 2, 256, 0x10u, &__kCFAllocatorNull, 0);
                goto LABEL_810;
              default:
                goto LABEL_815;
            }
          }
          if (v406)
          {
            CFStringRef v412 = _CFCopyResolvedFormatStringWithConfiguration((__CFString *)v406, *(CFDictionaryRef *)&v477[8 * *v314], v494);
            CFRelease(v406);
            if (v412)
            {
              *(void *)chars = v508;
              if ((char)v502[32 * v255 + 24] < 0)
              {
                uint64_t v414 = v257;
                uint64_t v415 = v258;
                BOOL v70 = __srca;
                CFStringRef v325 = v506;
                CFDictionaryRef v413 = theDict;
                uint64_t v326 = v501;
                int64_t v29 = a14;
                if (v255)
                {
                  do
                  {
                    int v416 = *v414;
                    v414 -= 32;
                    if ((v416 & 0x80000000) == 0) {
                      break;
                    }
                    --v415;
                  }
                  while (v415 >= 2);
                }
              }
              else
              {
                BOOL v70 = __srca;
                CFStringRef v325 = v506;
                CFDictionaryRef v413 = theDict;
                uint64_t v326 = v501;
                int64_t v29 = a14;
              }
              uint64_t v451 = 0;
              unint64_t v452 = a15;
              uint64_t v449 = v455;
              uint64_t v450 = *(void *)chars;
              uint64_t v447 = a10 + 1;
              uint64_t v448 = v456;
              CFDictionaryRef theDict = v413;
              int appended = __CFStringAppendFormatCore(v325, v489, v492, v494, v413, 0, v460);
              CFRelease(v412);
              if (!appended)
              {
                free(v484);
                goto LABEL_909;
              }
              goto LABEL_820;
            }
          }
LABEL_815:
          CFStringRef v325 = v506;
          CFStringAppendCString(v506, "(null)", 0x600u);
          int v391 = 0;
          BOOL v70 = __srca;
          uint64_t v326 = v501;
          int64_t v29 = a14;
          goto LABEL_821;
        }
        uint64_t v323 = (char)v313[24];
        UniChar v322 = v313 + 24;
        uint64_t v324 = *(void *)&__srca[16 * v323 + 8];
        if (!v324) {
          goto LABEL_815;
        }
        CFStringRef v325 = v506;
        uint64_t v326 = v501;
        int64_t v29 = a14;
        if (v492)
        {
          LOBYTE(chars[0]) = 0;
          uint64_t v327 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(v492, v324, (uint64_t)theString);
          uint64_t v328 = (uint64_t)v494;
          if (LOBYTE(chars[0]))
          {
            CFStringRef v329 = (const __CFString *)CFRetain(@"%@NSCONTEXT");
            long long v330 = v501[1];
            CFStringCompareFlags v331 = &v484[32 * cf2];
            *(_OWORD *)CFStringCompareFlags v331 = *v501;
            *((_OWORD *)v331 + 1) = v330;
            ++cf2;
          }
          else
          {
            CFStringRef v329 = (const __CFString *)v327;
          }
          if (v329) {
            goto LABEL_752;
          }
          uint64_t v324 = *(void *)&__srca[16 * *v322 + 8];
        }
        else
        {
          uint64_t v328 = (uint64_t)v494;
        }
        if (!v489)
        {
          uint64_t v387 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__((uint64_t (*)(uint64_t, uint64_t))__CFCopyFormattingDescription, v324, v328);
          if (!v387)
          {
            uint64_t v411 = *v322;
            BOOL v70 = __srca;
            CFStringRef v329 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT__(*(const void **)&__srca[16 * v411 + 8]);
            if (v329) {
              goto LABEL_753;
            }
            goto LABEL_749;
          }
          CFStringRef v329 = (const __CFString *)v387;
LABEL_752:
          BOOL v70 = __srca;
LABEL_753:
          int v388 = __CFStringAppendFormatCore_disableIsolates;
          if (__CFStringAppendFormatCore_disableIsolates == 255)
          {
            if (dyld_program_sdk_at_least()) {
              int v388 = __CFgetenv("CFStringDisableIsolates") != 0;
            }
            else {
              int v388 = 1;
            }
            __CFStringAppendFormatCore_disableIsolates = v388;
          }
          BOOL v75 = v388 == 0;
          BOOL v389 = v493;
          if (!v75) {
            BOOL v389 = 0;
          }
          if (!v389)
          {
            CFStringAppend(v506, v329);
LABEL_764:
            int v391 = 0;
            goto LABEL_765;
          }
          if (key) {
            goto LABEL_762;
          }
          CFIndex v390 = CFStringGetLength(v329);
          if (_CFStringHasStrongRTL(v329, 0, v390)) {
            goto LABEL_762;
          }
          CFIndex v409 = CFStringGetLength(v506);
          if (v409)
          {
            if (v409 <= v453 || (_CFStringHasStrongRTL(v506, v453, v409 - v453) & 1) == 0)
            {
LABEL_839:
              CFStringAppend(v506, v329);
              CFIndex v453 = CFStringGetLength(v506);
              char key = 0;
              goto LABEL_764;
            }
          }
          else
          {
            uint64_t v420 = *(int *)&v502[32 * v255 + 8] + (uint64_t)*(int *)&v502[32 * v255 + 4];
            if (range <= v420 || !_CFStringHasStrongRTL(theString, v420, range - v420)) {
              goto LABEL_839;
            }
          }
LABEL_762:
          chars[0] = 8296;
          char key = 1;
          CFStringAppendCharacters(v506, chars, 1);
          CFStringAppend(v506, v329);
          chars[0] = 8297;
          CFStringAppendCharacters(v506, chars, 1);
          int v391 = 1;
LABEL_765:
          CFRelease(v329);
          goto LABEL_821;
        }
        CFStringRef v329 = (const __CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__(v489, v324, v328);
        BOOL v70 = __srca;
        if (v329) {
          goto LABEL_753;
        }
LABEL_749:
        CFStringAppendCString(v506, "(null description)", 0x600u);
LABEL_820:
        int v391 = 0;
LABEL_821:
        if (v29) {
          CFIndex v349 = CFStringGetLength(v325);
        }
        else {
          CFIndex v349 = 0;
        }
        *(_OWORD *)chars = *v326;
        *(_OWORD *)&chars[8] = v326[1];
        long long v358 = v495;
        CFIndex v357 = v497;
        uint64_t v359 = (uint64_t)v70;
        uint64_t v360 = v488;
        CFIndex v312 = (CFIndex)cStr;
        int v377 = v391;
LABEL_825:
        _CFStringFormatAppendMetadata(v358, v357, v359, v360, (uint64_t)chars, v312, v349, v377);
LABEL_826:
        int v256 = v502;
LABEL_827:
        ++v255;
        ++v258;
        v257 += 32;
        if (v255 != v497) {
          continue;
        }
        int v45 = v461;
        if (cf2 >= 1)
        {
          uint64_t v427 = 0;
          do
          {
            CFRange v428 = CFStringFind(v506, @"%@NSCONTEXT", 0);
            CFStringRef v429 = (const __CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(v492, *(void *)&v70[4 * v484[v427 + 24] + 2], (uint64_t)v506);
            if (v429)
            {
              CFStringRef v430 = v429;
              CFStringReplace(v506, v428, v429);
              CFRelease(v430);
            }
            v427 += 32;
            BOOL v70 = __srca;
          }
          while (32 * cf2 != v427);
        }
        uint64_t v431 = v484;
LABEL_872:
        free(v431);
        int64_t v29 = a14;
        CFAllocatorRef v44 = alloc;
LABEL_873:
        uint64_t v69 = v477;
        long long v71 = v502;
LABEL_874:
        if (v71 != v547) {
          goto LABEL_883;
        }
LABEL_884:
        if (v70 != (_DWORD *)v546) {
          CFAllocatorDeallocate(v44, v70);
        }
        if (v45 && v45 != v548) {
          CFAllocatorDeallocate(v44, v45);
        }
        if (v69 != v544) {
          CFAllocatorDeallocate(v44, v69);
        }
        if (v490) {
          CFRelease(v490);
        }
        if (v29)
        {
          if (theArray)
          {
            CFArrayRef *v29 = CFArrayCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theArray);
            CFRelease(theArray);
          }
        }
        return;
      case '&':
        int v473 = v273;
        if (a14)
        {
          CFIndex v309 = CFStringGetLength(v506);
          int v256 = v502;
        }
        else
        {
          CFIndex v309 = 0;
        }
        long long v355 = *(const UniChar **)&v70[4 * (char)v256[32 * v255 + 24] + 2];
        cStrd = (char *)v309;
        if (!v355)
        {
          CFStringRef v361 = v506;
          CFStringAppendCString(v506, "(null)", 0x600u);
          goto LABEL_717;
        }
        if (v277)
        {
          if ((int)v276 < 1)
          {
            LODWORD(i) = 0;
          }
          else
          {
            for (uint64_t i = 0; i != v276; ++i)
            {
              if (!v355[i]) {
                goto LABEL_701;
              }
            }
            LODWORD(i) = v276;
          }
        }
        else
        {
          LODWORD(i) = -1;
          CFRange v369 = v355;
          do
          {
            int v370 = *v369++;
            LODWORD(i) = i + 1;
          }
          while (v370);
        }
LABEL_701:
        CFStringRef v361 = v506;
        if ((v256[32 * v255 + 20] & 2) != 0)
        {
          CFStringAppendCharacters(v506, v355, i);
          if (v274)
          {
            int v375 = v473 - i;
            if (v473 > (int)i)
            {
              do
              {
                if (v375 >= 10) {
                  int v376 = 10;
                }
                else {
                  int v376 = v375;
                }
                __CFStringAppendBytes((unint64_t *)v506, "          ", v376, 1536);
                BOOL v53 = __OFSUB__(v375, 10);
                v375 -= 10;
              }
              while (!((v375 < 0) ^ v53 | (v375 == 0)));
            }
          }
        }
        else
        {
          if (v274)
          {
            int v373 = v473 - i;
            if (v473 > (int)i)
            {
              do
              {
                if (v373 >= 10) {
                  int v374 = 10;
                }
                else {
                  int v374 = v373;
                }
                __CFStringAppendBytes((unint64_t *)v506, "          ", v374, 1536);
                BOOL v53 = __OFSUB__(v373, 10);
                v373 -= 10;
              }
              while (!((v373 < 0) ^ v53 | (v373 == 0)));
            }
          }
          CFStringAppendCharacters(v506, v355, i);
        }
LABEL_717:
        BOOL v70 = __srca;
        if (a14) {
          CFIndex v349 = CFStringGetLength(v361);
        }
        else {
          CFIndex v349 = 0;
        }
        CFIndex v357 = v497;
        *(_OWORD *)chars = *v501;
        *(_OWORD *)&chars[8] = v501[1];
        long long v358 = v495;
        uint64_t v359 = (uint64_t)__srca;
        uint64_t v360 = v488;
        CFIndex v312 = (CFIndex)cStrd;
        goto LABEL_721;
      case '\'':
      case '(':
        int v287 = v273;
        if (a14)
        {
          CFIndex v288 = CFStringGetLength(v506);
          int v256 = v502;
          cStra = (char *)v288;
        }
        else
        {
          cStra = 0;
        }
        UniChar v317 = *(unsigned __int8 **)&v70[4 * (char)v256[32 * v255 + 24] + 2];
        if (v317)
        {
          if (*(_WORD *)v270 == 40)
          {
            int v319 = *v317++;
            int v318 = v319;
            if ((int)v276 >= v319 || v277 == 0) {
              int v321 = v318;
            }
            else {
              int v321 = v276;
            }
          }
          else
          {
            if (v277)
            {
              long long v342 = memchr(v317, 0, (int)v276);
              if (v342) {
                int v321 = v342 - v317;
              }
              else {
                int v321 = v276;
              }
            }
            else
            {
              int v321 = strlen((const char *)v317);
            }
            int v256 = v502;
          }
          CFStringRef v332 = v506;
          if ((v256[32 * v255 + 20] & 2) != 0)
          {
            if (__CFDefaultSystemEncoding)
            {
              int v365 = 1;
            }
            else
            {
              CFStringGetSystemEncoding();
              int v365 = __CFDefaultSystemEncoding;
            }
            __CFStringAppendBytes((unint64_t *)v506, v317, v321, (v365 - 1));
            if (v274)
            {
              int v366 = v287 - v321;
              if (v287 > v321)
              {
                do
                {
                  if (v366 >= 10) {
                    int v367 = 10;
                  }
                  else {
                    int v367 = v366;
                  }
                  __CFStringAppendBytes((unint64_t *)v506, "          ", v367, 1536);
                  BOOL v53 = __OFSUB__(v366, 10);
                  v366 -= 10;
                }
                while (!((v366 < 0) ^ v53 | (v366 == 0)));
              }
            }
          }
          else
          {
            if (v274)
            {
              int v362 = v287 - v321;
              if (v287 > v321)
              {
                do
                {
                  if (v362 >= 10) {
                    int v363 = 10;
                  }
                  else {
                    int v363 = v362;
                  }
                  __CFStringAppendBytes((unint64_t *)v506, "          ", v363, 1536);
                  BOOL v53 = __OFSUB__(v362, 10);
                  v362 -= 10;
                }
                while (!((v362 < 0) ^ v53 | (v362 == 0)));
              }
            }
            if (__CFDefaultSystemEncoding)
            {
              int v364 = 1;
            }
            else
            {
              CFStringGetSystemEncoding();
              int v364 = __CFDefaultSystemEncoding;
            }
            __CFStringAppendBytes((unint64_t *)v506, v317, v321, (v364 - 1));
          }
        }
        else
        {
          CFStringRef v332 = v506;
          CFStringAppendCString(v506, "(null)", 0x600u);
        }
        BOOL v70 = __srca;
        if (a14) {
          CFIndex v349 = CFStringGetLength(v332);
        }
        else {
          CFIndex v349 = 0;
        }
        CFRange v368 = v501;
        CFIndex v312 = (CFIndex)cStra;
        goto LABEL_690;
      case ')':
        if (a14)
        {
          int64_t v310 = v506;
          CFIndex v311 = CFStringGetLength(v506);
          int v256 = v502;
          CFIndex v308 = v311;
        }
        else
        {
          CFIndex v308 = 0;
          int64_t v310 = v506;
        }
        ptr.i16[0] = *(void *)&v70[4 * (char)v256[32 * v255 + 24] + 2];
        CFStringAppendCharacters(v310, (const UniChar *)&ptr, 1);
        if (a14) {
          CFIndex v349 = CFStringGetLength(v310);
        }
        else {
          CFIndex v349 = 0;
        }
        *(_OWORD *)chars = *v501;
        *(_OWORD *)&chars[8] = v501[1];
        long long v358 = v495;
        CFIndex v357 = v497;
        goto LABEL_655;
      case '+':
        if (a14) {
          CFIndex v312 = CFStringGetLength(v506);
        }
        else {
          CFIndex v312 = 0;
        }
        CFIndex v357 = v497;
        *(_OWORD *)chars = *v501;
        *(_OWORD *)&chars[8] = v501[1];
        long long v358 = v495;
        uint64_t v359 = (uint64_t)v70;
        uint64_t v360 = v488;
        CFIndex v349 = v312;
        goto LABEL_721;
      default:
        goto LABEL_827;
    }
  }
}

void _CFStringFormatAppendMetadata(CFMutableArrayRef *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    int v15 = *(unsigned __int16 *)(a5 + 2);
    if ((v15 - 43) >= 2)
    {
      if (v15 == 32)
      {
        if ((*(unsigned char *)(a5 + 20) & 0x80) == 0) {
          return;
        }
      }
      else
      {
        if (*(char *)(a5 + 24) < 0) {
          return;
        }
        if (*(unsigned __int8 *)(a5 + 24) >= a4) {
          _CFStringFormatAppendMetadata_cold_1();
        }
      }
    }
    if (!*a1) {
      *a1 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, &kCFTypeArrayCallBacks);
    }
    CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    BOOL v17 = a8 == 0;
    BOOL v18 = a8 != 0;
    int v19 = *(_DWORD *)(a5 + 4);
    if (v17) {
      uint64_t v20 = (void *)a6;
    }
    else {
      uint64_t v20 = (void *)(a6 + 1);
    }
    int v31 = *(_DWORD *)(a5 + 8);
    int valuePtr = v19;
    value[0] = v20;
    CFNumberRef v21 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(Mutable, @"SpecLocation", v21);
    CFRelease(v21);
    CFNumberRef v22 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &v31);
    CFDictionarySetValue(Mutable, @"SpecLength", v22);
    CFRelease(v22);
    CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
    CFDictionarySetValue(Mutable, @"ReplacementLocation", v23);
    CFRelease(v23);
    unint64_t v30 = (a7 - v18 - (unint64_t)value[0]) & ~((int64_t)(a7 - v18 - (unint64_t)value[0]) >> 63);
    CFNumberRef v24 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, &v30);
    CFDictionarySetValue(Mutable, @"ReplacementLength", v24);
    CFRelease(v24);
    uint64_t v25 = *(char *)(a5 + 24);
    if (v25 < 0) {
      goto LABEL_26;
    }
    if (v25 < a4 && *(_WORD *)(a5 + 2) != 32)
    {
      value[0] = (void *)(v25 + 1);
      CFNumberRef v26 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
      CFDictionarySetValue(Mutable, @"Index", v26);
      CFRelease(v26);
      LODWORD(v25) = *(char *)(a5 + 24);
      if ((v25 & 0x80000000) != 0) {
        goto LABEL_26;
      }
    }
    if (v25 >= a4) {
      goto LABEL_26;
    }
    *(_OWORD *)value = *(_OWORD *)(a3 + 16 * v25);
    if (SLOWORD(value[0]) == 33)
    {
      CFNumberType v27 = kCFNumberSInt64Type;
    }
    else
    {
      if (SLOWORD(value[0]) != 34)
      {
        if (SLOWORD(value[0]) == 37)
        {
          if (value[1]) {
            CFDictionarySetValue(Mutable, @"Object", value[1]);
          }
        }
        goto LABEL_26;
      }
      CFNumberType v27 = kCFNumberDoubleType;
    }
    CFNumberRef v28 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v27, &value[1]);
    CFDictionarySetValue(Mutable, @"Number", v28);
    CFRelease(v28);
LABEL_26:
    value[0] = (void *)v18;
    CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
    CFDictionarySetValue(Mutable, @"AddedIsolates", v29);
    CFRelease(v29);
    CFArrayAppendValue(*a1, Mutable);
    CFRelease(Mutable);
  }
}

uint64_t __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(uint64_t (*a1)(uint64_t, uint64_t, __CFString *), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3, @"%@NSCONTEXT");
}

uint64_t _CFExecutableLinkedOnOrAfter(unint64_t a1)
{
  active_platforuint64_t m = dyld_get_active_platform();
  _CFBuildVersionForCFSystemVersion(a1, active_platform);
  return dyld_program_sdk_at_least();
}

unint64_t _CFBuildVersionForCFSystemVersion(unint64_t a1, unsigned int a2)
{
  if (a1 <= 0x14)
  {
    if (a1 > 4)
    {
      if (a1 >= 0xA) {
        uint64_t v2 = 4294901760;
      }
      else {
        uint64_t v2 = 0;
      }
      if (a2 == 6 || a2 == 1)
      {
        unint64_t v3 = a1 - 5;
        a1 = _CFBuildVersionForCFSystemVersion_macos_map[a1 - 5];
        if (a2 == 6)
        {
          if (v3 >= 0xB)
          {
            if (a1 == 659456) {
              int v7 = 917504;
            }
            else {
              int v7 = -65536;
            }
            if (a1 == 720896) {
              unsigned int v8 = 917504;
            }
            else {
              unsigned int v8 = v7;
            }
            if (a1 == 659201) {
              a1 = 852480;
            }
            else {
              a1 = v8;
            }
            a2 = 2;
          }
          else
          {
            a2 = 2;
            a1 = 851968;
          }
        }
      }
      else
      {
        a1 = v2;
      }
      return a2 | (a1 << 32);
    }
    goto LABEL_16;
  }
  if (a1 - 1000 <= 0xF)
  {
    if (a1 > 0x3EC && a2 == 1)
    {
      if (a1 - 1005 >= 0xB)
      {
        a2 = 1;
        a1 = 4294901760;
      }
      else
      {
        a1 = dword_182EC7C10[a1 - 1005];
        a2 = 1;
      }
      return a2 | (a1 << 32);
    }
LABEL_16:
    a1 = 0;
    if (a2 == 6) {
      a2 = 2;
    }
    return a2 | (a1 << 32);
  }
  if (a2 == 6)
  {
    if (a1 == 659456) {
      int v4 = 917504;
    }
    else {
      int v4 = -65536;
    }
    if (a1 == 720896) {
      int v5 = 917504;
    }
    else {
      int v5 = v4;
    }
    if (a1 == 659201) {
      unsigned int v6 = 852480;
    }
    else {
      unsigned int v6 = v5;
    }
    if (a1 >= 0xA0F01) {
      a1 = v6;
    }
    else {
      a1 = 851968;
    }
    a2 = 2;
  }
  return a2 | (a1 << 32);
}

uint64_t _CFStringGetFormatSpecifierConfiguration(void *a1)
{
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }

  return [a1 formatConfiguration];
}

BOOL __CFRuntimeIsImmortal(uint64_t a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(a1 + 8));
  return HIWORD(v1) == 0;
}

uint64_t __CFCopyFormattingDescription(unint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  if ((a1 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)off_1ECE0A6F0;
    unint64_t v6 = a1 & 0xC000000000000007;
    if ((a1 & 0xC000000000000007) == 0xC000000000000007) {
      uint64_t v5 = 0;
    }
    unint64_t v7 = v5 ^ a1;
    unint64_t v8 = v7 & 7;
    do
    {
      if (v8 == *((unsigned __int8 *)off_1ECE0A6E0 + v4)) {
        break;
      }
      ++v4;
    }
    while (v4 != 7);
    unint64_t v9 = v4 | v7;
    uint64_t v10 = v4 & 7;
    int v11 = (v9 >> 55) + 8;
    if (v10 == 7) {
      LODWORD(v10) = v11;
    }
    if (v10)
    {
      if (v10 == 6) {
        return 0;
      }
      if (v10 == 3)
      {
        unint64_t v12 = off_1ECE0E050;
LABEL_45:
        return ((uint64_t (*)(unint64_t, uint64_t))v12)(a1, a2);
      }
    }
    else
    {
      if (dyld_program_sdk_at_least()) {
        __CFCopyFormattingDescription_cold_3();
      }
      uint64_t v26 = *(void *)off_1ECE0A6F0;
      if (v6 == 0xC000000000000007) {
        uint64_t v26 = 0;
      }
      unint64_t v7 = v26 ^ a1;
      unint64_t v8 = v7 & 7;
    }
    for (uint64_t i = 0; i != 7; ++i)
    {
      if (v8 == *((unsigned __int8 *)off_1ECE0A6E0 + i)) {
        break;
      }
    }
    int v28 = ((i | v7) >> 55) + 8;
    if ((i & 7) == 7) {
      int v29 = v28;
    }
    else {
      int v29 = i & 7;
    }
    unint64_t v14 = 22;
    switch(v29)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          __CFCopyFormattingDescription_cold_2();
        }
        goto LABEL_64;
      case 1:
        goto LABEL_65;
      case 2:
        goto LABEL_63;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_64;
      case 6:
        unint64_t v14 = 42;
        break;
      default:
        if (v29 == 20)
        {
LABEL_64:
          unint64_t v14 = 1;
        }
        else if (v29 == 22)
        {
LABEL_63:
          unint64_t v14 = 7;
        }
        else
        {
LABEL_65:
          unint64_t v14 = [(id)a1 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v13 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v14 = (v13 >> 8) & 0x3FF;
  }
  if (!CF_IS_OBJC(v14, a1))
  {
    __CFCheckCFInfoPACSignature_Bridged(a1);
    if ((a1 & 0x8000000000000000) != 0)
    {
      uint64_t v16 = 0;
      uint64_t v17 = *(void *)off_1ECE0A6F0;
      if ((~a1 & 0xC000000000000007) == 0) {
        uint64_t v17 = 0;
      }
      unint64_t v18 = v17 ^ a1;
      do
      {
        if ((v18 & 7) == *((unsigned char *)off_1ECE0A6E0 + v16)) {
          break;
        }
        ++v16;
      }
      while (v16 != 7);
      unint64_t v19 = v16 | v18;
      uint64_t v20 = v16 & 7;
      int v21 = (v19 >> 55) + 8;
      if (v20 == 7) {
        int v22 = v21;
      }
      else {
        int v22 = v20;
      }
      unint64_t v23 = 22;
      switch(v22)
      {
        case 0:
          if (dyld_program_sdk_at_least()) {
            __CFCopyFormattingDescription_cold_1();
          }
          goto LABEL_40;
        case 1:
          goto LABEL_41;
        case 2:
          goto LABEL_39;
        case 3:
          goto LABEL_43;
        case 4:
        case 5:
          goto LABEL_40;
        case 6:
          unint64_t v23 = 42;
          goto LABEL_43;
        default:
          if (v22 == 20)
          {
LABEL_40:
            unint64_t v23 = 1;
            goto LABEL_43;
          }
          if (v22 == 22)
          {
LABEL_39:
            unint64_t v23 = 7;
            goto LABEL_43;
          }
LABEL_41:
          unint64_t v23 = [(id)a1 _cfTypeID];
          break;
      }
    }
    else
    {
      unint64_t v24 = atomic_load((unint64_t *)(a1 + 8));
      unint64_t v23 = (v24 >> 8) & 0x3FF;
    }
    if (v23 <= 0x47) {
LABEL_43:
    }
      uint64_t v25 = &__CFRuntimeBuiltinClassTable + v23;
    else {
      uint64_t v25 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v23 - 72) >> 6] + 8 * ((v23 - 72) & 0x3F));
    }
    unint64_t v12 = (uint64_t (*)(CFNumberRef))*((void *)*v25 + 7);
    if (v12) {
      goto LABEL_45;
    }
    return 0;
  }
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }

  return [(id)a1 _copyFormattingDescription:a2];
}

CFStringRef __CFStringCopyFormattingDescription(CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    p_data = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
  }
  else
  {
    char v2 = atomic_load((unint64_t *)&theString->info);
    if (v2 < 0) {
      p_data = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }
    else {
      p_data = (CFAllocatorRef *)&theString[-1].data;
    }
  }
  return CFStringCreateCopy(*p_data, theString);
}

CFTypeRef _DescriptionWithLocaleFunc(void *a1, uint64_t a2)
{
  if (a1)
  {
    if (objc_opt_respondsToSelector()) {
      uint64_t v5 = (__CFString *)[a1 descriptionWithLocale:a2];
    }
    else {
      uint64_t v5 = (__CFString *)[a1 description];
    }
    uint64_t v2 = vars8;
  }
  else
  {
    uint64_t v5 = @"*nil*";
  }
  if (!v5) {
    uint64_t v5 = @"*nil description*";
  }
  return CFRetain(v5);
}

CFTypeRef _DescriptionWithStringProxyFunc(void *a1, uint64_t a2, uint64_t a3, int a4, unsigned char *a5)
{
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
    if (a5) {
      *a5 = 0;
    }
    return 0;
  }
  if (a5) {
    *a5 = 1;
  }
  if (!a4) {
    return 0;
  }
  uint64_t v10 = (const void *)[a1 _dynamicContextEvaluation:a2 patternString:a3];
  if (!v10) {
    return 0;
  }

  return CFRetain(v10);
}

uint64_t _CFStringHasStrongRTL(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x66u, 0);
  CFStringRef theString = a1;
  uint64_t v26 = a2;
  int64_t v27 = a3;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(a1);
  if (CharactersPtr) {
    uint64_t CStringPtrInternal = 0;
  }
  else {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal(a1, 1536, 1, 1);
  }
  int64_t v28 = 0;
  int64_t v29 = 0;
  uint64_t v25 = CStringPtrInternal;
  if (a3 < 1) {
    return 0;
  }
  int64_t v8 = 0;
  memset(v22, 0, sizeof(v22));
  while (1)
  {
    if (v8 < 0 || (int64_t v9 = v27, v27 <= v8))
    {
      LOWORD(v11) = 0;
      goto LABEL_11;
    }
    if (CharactersPtr)
    {
      UniChar v10 = CharactersPtr[v26 + v8];
    }
    else if (v25)
    {
      UniChar v10 = *(char *)(v25 + v26 + v8);
    }
    else
    {
      if (v29 <= v8 || (int64_t v14 = v28, v28 > v8))
      {
        int64_t v15 = v8 - 4;
        if ((unint64_t)v8 < 4) {
          int64_t v15 = 0;
        }
        if (v15 + 64 < v27) {
          int64_t v9 = v15 + 64;
        }
        int64_t v28 = v15;
        int64_t v29 = v9;
        v31.uint64_t location = v26 + v15;
        v31.CFIndex length = v9 - v15;
        CFStringGetCharacters(theString, v31, (UniChar *)v22);
        int64_t v14 = v28;
      }
      UniChar v10 = *((_WORD *)v22 + v8 - v14);
    }
    unsigned int v11 = v10;
    if (v10 >> 10 == 54) {
      break;
    }
LABEL_11:
    uint64_t v12 = BitmapPtrForPlane;
    if (BitmapPtrForPlane) {
      goto LABEL_12;
    }
LABEL_13:
    int64_t v13 = v8 + 1;
LABEL_14:
    int64_t v8 = v13;
    if (v13 >= a3) {
      return 0;
    }
  }
  int64_t v13 = v8 + 1;
  int64_t v16 = v27;
  if (v27 <= v8 + 1) {
    goto LABEL_14;
  }
  if (CharactersPtr)
  {
    UniChar v17 = CharactersPtr[v26 + v13];
  }
  else if (v25)
  {
    UniChar v17 = *(char *)(v25 + v26 + v13);
  }
  else
  {
    if (v29 <= v13 || (int64_t v18 = v28, v28 > v13))
    {
      int64_t v19 = v8 - 3;
      if ((unint64_t)v8 < 3) {
        int64_t v19 = 0;
      }
      if (v19 + 64 < v27) {
        int64_t v16 = v19 + 64;
      }
      int64_t v28 = v19;
      int64_t v29 = v16;
      v32.uint64_t location = v26 + v19;
      v32.CFIndex length = v16 - v19;
      CFStringGetCharacters(theString, v32, (UniChar *)v22);
      int64_t v18 = v28;
    }
    UniChar v17 = *((_WORD *)v22 + v13 - v18);
  }
  if (v17 >> 10 != 55) {
    goto LABEL_14;
  }
  unsigned int v11 = (v11 << 10) + v17 - 56613888;
  unsigned int v20 = HIWORD(v11) & 0x1F;
  if (!v20)
  {
    ++v8;
    goto LABEL_11;
  }
  uint64_t v12 = CFUniCharGetBitmapPtrForPlane(0x66u, v20);
  ++v8;
  if (!v12) {
    goto LABEL_13;
  }
LABEL_12:
  if (((*(unsigned __int8 *)(v12 + ((unsigned __int16)v11 >> 3)) >> (v11 & 7)) & 1) == 0) {
    goto LABEL_13;
  }
  return 1;
}

CFStringRef __CFNumberCopyFormattingDescription(uint64_t number)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  if ((number & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~number & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  unint64_t v3 = v2 ^ number;
  unint64_t v4 = v3 & 7;
  while (v4 != *((unsigned __int8 *)off_1ECE0A6E0 + v1))
  {
    if (++v1 == 7) {
      goto LABEL_12;
    }
  }
  if (v1 == 3)
  {
    uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 == 7) {
      uint64_t v5 = 0xFFFFFFFFFFFFFLL;
    }
    unint64_t v6 = v5 & (v3 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v6) = atomic_load((unint64_t *)(number + 8));
  }
  if ((__CFNumberTypeTable[__CFNumberCanonicalTypes[v6 & 7]] & 0x20) != 0)
  {
    return __CFNumberCreateFormattingDescriptionAsFloat64((const __CFAllocator *)&__kCFAllocatorSystemDefault, (CFNumberRef)number);
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0;
    __CFNumberGetValue(number, 17, (uint64_t)v8);
    emit128(v9, v8, 0);
    return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%s", v9);
  }
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  uint64_t v57 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)uuid);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)uuid);
  if (v4 != 34) {
    _CFAssertMismatchedTypeID(0x22uLL, v4);
  }
  CFMutableStringRef Mutable = CFStringCreateMutable(alloc, 0);
  unint64_t v6 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 16)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v7 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v6), (int8x8_t)(v6 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v6, (int32x2_t)0x3700000037));
  unint64_t v8 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 17)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v9 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v8), (int8x8_t)(v8 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v8, (int32x2_t)0x3700000037));
  unint64_t v10 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 18)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v11 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v10), (int8x8_t)(v10 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v10, (int32x2_t)0x3700000037));
  unint64_t v12 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 19)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v12), (int8x8_t)(v12 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v12, (int32x2_t)0x3700000037));
  __int16 v46 = v7.i16[2];
  UniChar v45 = v7.i16[0];
  __int16 v48 = v9.i16[2];
  __int16 v47 = v9.i16[0];
  __int16 v50 = v11.i16[2];
  __int16 v49 = v11.i16[0];
  __int16 v52 = v13.i16[2];
  __int16 v51 = v13.i16[0];
  __int16 v53 = 45;
  CFStringAppendCharacters(Mutable, &v45, 9);
  unint64_t v14 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 20)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v15 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v14), (int8x8_t)(v14 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v14, (int32x2_t)0x3700000037));
  __int16 v46 = v15.i16[2];
  UniChar v45 = v15.i16[0];
  unint64_t v16 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 21)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v17 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v16), (int8x8_t)(v16 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v16, (int32x2_t)0x3700000037));
  __int16 v48 = v17.i16[2];
  __int16 v47 = v17.i16[0];
  __int16 v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5);
  unint64_t v18 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 22)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v19 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v18), (int8x8_t)(v18 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v18, (int32x2_t)0x3700000037));
  __int16 v46 = v19.i16[2];
  UniChar v45 = v19.i16[0];
  unint64_t v20 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 23)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v21 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v20), (int8x8_t)(v20 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v20, (int32x2_t)0x3700000037));
  __int16 v48 = v21.i16[2];
  __int16 v47 = v21.i16[0];
  __int16 v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5);
  unint64_t v22 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 24)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v23 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v22), (int8x8_t)(v22 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v22, (int32x2_t)0x3700000037));
  __int16 v46 = v23.i16[2];
  UniChar v45 = v23.i16[0];
  unint64_t v24 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 25)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v25 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v24), (int8x8_t)(v24 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v24, (int32x2_t)0x3700000037));
  __int16 v48 = v25.i16[2];
  __int16 v47 = v25.i16[0];
  __int16 v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5);
  unint64_t v26 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 26)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v27 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v26), (int8x8_t)(v26 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v26, (int32x2_t)0x3700000037));
  __int16 v46 = v27.i16[2];
  UniChar v28 = v27.i16[0];
  unint64_t v29 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 27)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v30 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v29), (int8x8_t)(v29 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v29, (int32x2_t)0x3700000037));
  UniChar v45 = v28;
  __int16 v48 = v30.i16[2];
  __int16 v31 = v30.i16[0];
  uint32x2_t v32 = (uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 28));
  __int16 v47 = v31;
  unint64_t v33 = *(void *)&vshl_u32(v32, (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v34 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v33), (int8x8_t)(v33 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v33, (int32x2_t)0x3700000037));
  __int16 v50 = v34.i16[2];
  __int16 v49 = v34.i16[0];
  unint64_t v35 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 29)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v36 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v35), (int8x8_t)(v35 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v35, (int32x2_t)0x3700000037));
  __int16 v52 = v36.i16[2];
  __int16 v37 = v36.i16[0];
  unint64_t v38 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 30)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v39 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v38), (int8x8_t)(v38 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v38, (int32x2_t)0x3700000037));
  __int16 v51 = v37;
  __int16 v54 = v39.i16[2];
  __int16 v40 = v39.i16[0];
  uint32x2_t v41 = (uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 31));
  __int16 v53 = v40;
  unint64_t v42 = *(void *)&vshl_u32(v41, (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v43 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v42), (int8x8_t)(v42 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v42, (int32x2_t)0x3700000037));
  __int16 v56 = v43.i16[2];
  __int16 v55 = v43.i16[0];
  CFStringAppendCharacters(Mutable, &v45, 12);
  return Mutable;
}

CFTypeRef __CFBooleanCopyFormattingDescription(__objc2_class **a1)
{
  if (&__kCFBooleanTrue == a1) {
    return CFRetain(@"true");
  }
  else {
    return CFRetain(@"false");
  }
}

CFStringRef __CFURLCopyFormattingDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFStringRef v3 = CFURLCopyScheme((CFURLRef)a1);
  if (v3 && (CFStringRef v4 = v3, v5 = CFStringCompare(v3, @"data", 1uLL), CFRelease(v4), v5 == kCFCompareEqualTo))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    CFStringRef v10 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFStringRef TruncatedURLString = CreateTruncatedURLString(v2, v10);
    CFStringRef v12 = TruncatedURLString;
    if (!v9) {
      return TruncatedURLString;
    }
    CFStringRef v13 = CFURLGetString(*(CFURLRef *)(a1 + 32));
    CFStringRef v14 = CreateTruncatedURLString(v2, v13);
    CFStringRef v15 = CFStringCreateWithFormat(v2, 0, @"%@ -- %@", v12, v14);
    if (v12) {
      CFRelease(v12);
    }
    if (v14) {
      CFRelease(v14);
    }
    return v15;
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 32);
    CFStringRef v7 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    if (v6)
    {
      return CFStringCreateWithFormat(v2, 0, @"%@ -- %@", v7, *(void *)(a1 + 32));
    }
    else
    {
      return CFStringCreateCopy(v2, v7);
    }
  }
}

CFStringRef __CFUUIDCopyFormattingDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);

  return CFUUIDCreateString(v2, (CFUUIDRef)a1);
}

CFCharacterSetRef __InitializeURLAllowedCharacterSets_block_invoke()
{
  sURLAllowedCharacterSets = CFAllocatorAllocateTyped(0, 56, 0x6004044C4A2DFLL, 0);
  *(void *)sURLAllowedCharacterSets = CFCharacterSetCreateWithCharactersInString(0, @"!$&'()*+,-.0123456789;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 8) = CFCharacterSetCreateWithCharactersInString(0, @"!$&'()*+,-.0123456789;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 16) = CFCharacterSetCreateWithCharactersInString(0, @"!$&'()*+,-.0123456789:;=ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 48) = CFCharacterSetCreateWithCharactersInString(0, @"0123456789");
  if (_CFURIParserSemicolonAllowedInPath_onceToken != -1) {
    dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_19);
  }
  if (_CFURIParserSemicolonAllowedInPath_allowSemicolon) {
    CFStringRef v0 = @"!$&'()*+,-./0123456789:;=@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~";
  }
  else {
    CFStringRef v0 = @"!$&'()*+,-./0123456789:=@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~";
  }
  *(void *)(sURLAllowedCharacterSets + 24) = CFCharacterSetCreateWithCharactersInString(0, v0);
  *(void *)(sURLAllowedCharacterSets + 32) = CFCharacterSetCreateWithCharactersInString(0, @"!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  CFCharacterSetRef result = CFCharacterSetCreateWithCharactersInString(0, @"!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 40) = result;
  return result;
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (Length > 63)
  {
LABEL_27:
    CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(alloc);
    CFCharacterSetAddCharactersInString(Mutable, theString);
    __CFCSetMakeCompact((unint64_t *)Mutable);
    unint64_t v26 = atomic_load((unint64_t *)Mutable + 1);
    unint64_t v27 = v26;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Mutable + 1, &v27, v26 & 0xFFFFFFFFFFFFFFFELL);
      BOOL v10 = v27 == v26;
      unint64_t v26 = v27;
    }
    while (!v10);
    return Mutable;
  }
  uint64_t v5 = Length;
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  CFMutableCharacterSetRef Mutable = (CFMutableCharacterSetRef)Instance;
  if (!Instance) {
    return Mutable;
  }
  unint64_t v8 = atomic_load(Instance + 1);
  unint64_t v9 = v8;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v9, v8 & 0xFFFFFFFFFFFFFFFELL);
    BOOL v10 = v9 == v8;
    unint64_t v8 = v9;
  }
  while (!v10);
  unint64_t v11 = atomic_load(Instance + 1);
  unint64_t v12 = v11;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v12, v11 & 0xFFFFFFFFFFFFFF8FLL | 0x20);
    BOOL v10 = v12 == v11;
    unint64_t v11 = v12;
  }
  while (!v10);
  Instance[2] = 0;
  Instance[5] = 0;
  CFAllocatorRef v13 = CFGetAllocator(Instance);
  uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(v13, 128, 0x1000040BDFB0063, 0);
  *((void *)Mutable + 3) = Typed;
  *((void *)Mutable + 4) = v5;
  v29.uint64_t location = 0;
  v29.CFIndex length = v5;
  CFStringGetCharacters(theString, v29, Typed);
  qsort(*((void **)Mutable + 3), v5, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
  uint64_t v15 = v5;
  if (v5 >= 2)
  {
    uint64_t v16 = 0;
    uint64_t v17 = *((void *)Mutable + 3);
    uint64_t v18 = v5 - 1;
    int8x8_t v19 = (unsigned __int16 *)(v17 + 2);
    do
    {
      int v21 = *v19++;
      __int16 v20 = v21;
      if (*(unsigned __int16 *)(v17 + 2 * v16) != v21)
      {
        ++v16;
        *(_WORD *)(v17 + 2 * v16) = v20;
      }
      --v18;
    }
    while (v18);
    uint64_t v15 = v16 + 1;
  }
  *((void *)Mutable + 4) = v15;
  if (v5)
  {
    if (v5 >= 2)
    {
      unint64_t v22 = (_WORD *)*((void *)Mutable + 3);
      if ((unsigned __int16)*v22 >> 10 <= 0x36u)
      {
        int8x8_t v23 = &v22[v5];
        if ((unsigned __int16)*(v23 - 1) >> 10 >= 0x37u)
        {
          while ((*v22 & 0xF800 | 0x400) != 0xDC00)
          {
            if (++v22 >= v23) {
              return Mutable;
            }
          }
          CFRelease(Mutable);
          goto LABEL_27;
        }
      }
    }
  }
  else
  {
    unint64_t v24 = atomic_load((unint64_t *)Mutable + 1);
    unint64_t v25 = v24;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Mutable + 1, &v25, v24 | 4);
      BOOL v10 = v25 == v24;
      unint64_t v24 = v25;
    }
    while (!v10);
  }
  return Mutable;
}

CFMutableStringRef resolveAbsoluteURLStringBuffer(const __CFAllocator *a1, const __CFString *a2, unsigned int a3, uint64_t a4, const __CFString *a5, unsigned int a6, CFIndex *a7, UniChar *a8)
{
  uint64_t v120 = *(void *)off_1ECE0A5B0;
  memset(v117, 0, 512);
  CFIndex numChars = 0;
  CFMutableCharacterSetRef Mutable = CFStringCreateMutable(a1, 0);
  CFIndex v17 = 0;
  CFMutableStringRef theString = Mutable;
  if (a6)
  {
    if (*a7 == -1)
    {
      CFIndex v17 = 0;
    }
    else
    {
      uint64_t v18 = Mutable;
      CFIndex v19 = a7[1];
      v121.CFIndex length = v19;
      v121.CFIndex location = *a7;
      CFStringGetCharacters(a5, v121, a8);
      if (v19 < 1025)
      {
        __memcpy_chk();
        uint64_t v20 = numChars + v19;
        numChars += v19;
      }
      else
      {
        CFStringAppendCharacters(v18, a8, v19);
        uint64_t v20 = numChars;
      }
      if (v20 >= 1024)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, v20);
        uint64_t v20 = 0;
        CFIndex numChars = 0;
      }
      *((_WORD *)v117 + v20) = 58;
      CFIndex v17 = ++numChars;
    }
  }
  if ((a3 & 0x1E) != 0)
  {
    CFIndex Length = CFStringGetLength(a2);
    CFIndex v22 = numChars;
    if (Length >= 1025)
    {
      if (numChars)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        CFIndex numChars = 0;
      }
      CFStringAppend(theString, a2);
      goto LABEL_158;
    }
    CFIndex v34 = Length;
    if (numChars + Length >= 1025)
    {
      CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
      CFIndex v22 = 0;
      CFIndex numChars = 0;
    }
    unint64_t v35 = (UniChar *)v117 + v22;
    v124.CFIndex location = 0;
    v124.CFIndex length = v34;
    CFStringGetCharacters(a2, v124, v35);
    CFIndex v36 = numChars + v34;
LABEL_156:
    CFIndex numChars = v36;
    if (!v36) {
      return theString;
    }
    goto LABEL_159;
  }
  if (v17 >= 1023)
  {
    CFStringAppendCharacters(theString, (const UniChar *)v117, v17);
    CFIndex v17 = 0;
    CFIndex numChars = 0;
  }
  *(_DWORD *)((char *)v117 + 2 * v17) = 3080239;
  numChars += 2;
  CFIndex v23 = _netLocationRange(a6, (uint64_t)a7);
  if (v23 != -1)
  {
    CFIndex v25 = v24;
    v122.CFIndex location = v23;
    v122.CFIndex length = v25;
    CFStringGetCharacters(a5, v122, a8);
    CFIndex v26 = numChars;
    if (v25 < 1025)
    {
      if (numChars + v25 >= 1025)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        CFIndex v26 = 0;
        CFIndex numChars = 0;
      }
      memcpy((char *)v117 + 2 * v26, a8, 2 * v25);
      numChars += v25;
      if ((a3 & 0x20) == 0) {
        goto LABEL_23;
      }
      goto LABEL_37;
    }
    if (numChars)
    {
      CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
      CFIndex numChars = 0;
    }
    CFStringAppendCharacters(theString, a8, v25);
  }
  if ((a3 & 0x20) == 0)
  {
LABEL_23:
    if ((a6 & 0x20) != 0)
    {
      unsigned int v27 = 0;
      unsigned int v28 = 32;
      unsigned int v29 = a6;
      do
      {
        char v30 = v28;
        v28 >>= 1;
        v27 += v29 & 1;
        v29 >>= 1;
      }
      while ((v30 & 2) == 0);
      __int16 v31 = &a7[2 * v27];
      if (*v31 != -1)
      {
        CFIndex v32 = v31[1];
        v123.CFIndex length = v32;
        v123.CFIndex location = *v31;
        CFStringGetCharacters(a5, v123, a8);
        CFIndex v33 = numChars;
        if (v32 < 1025)
        {
          if (numChars + v32 >= 1025)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            CFIndex v33 = 0;
            CFIndex numChars = 0;
          }
          memcpy((char *)v117 + 2 * v33, a8, 2 * v32);
          numChars += v32;
        }
        else
        {
          if (numChars)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            CFIndex numChars = 0;
          }
          CFStringAppendCharacters(theString, a8, v32);
        }
      }
    }
    if ((a3 & 0x1C0) != 0)
    {
      if ((a3 & 0x40) == 0)
      {
        if ((a6 & 0x40) != 0)
        {
          unsigned int v64 = 0;
          unsigned int v65 = 64;
          unsigned int v66 = a6;
          do
          {
            char v67 = v65;
            v65 >>= 1;
            v64 += v66 & 1;
            v66 >>= 1;
          }
          while ((v67 & 2) == 0);
          CFAllocatorRef v68 = &a7[2 * v64];
          CFIndex v69 = *v68;
          if (*v68 != -1)
          {
            CFIndex v70 = v68[1];
            CFIndex v71 = numChars;
            if (numChars >= 1024)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              CFIndex v71 = 0;
              CFIndex numChars = 0;
            }
            *((_WORD *)v117 + v71) = 59;
            ++numChars;
            v127.CFIndex location = v69;
            v127.CFIndex length = v70;
            CFStringGetCharacters(a5, v127, a8);
            CFIndex v72 = numChars;
            if (v70 <= 1024)
            {
              if (numChars + v70 >= 1025)
              {
                CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
                CFIndex v72 = 0;
                CFIndex numChars = 0;
              }
              memcpy((char *)v117 + 2 * v72, a8, 2 * v70);
              numChars += v70;
            }
            else
            {
              if (numChars)
              {
                CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
                CFIndex numChars = 0;
              }
              CFStringAppendCharacters(theString, a8, v70);
            }
          }
        }
        if ((a3 & 0x80) == 0) {
          goto LABEL_168;
        }
        unsigned int v88 = 0;
        unsigned int v89 = 128;
        unsigned int v90 = a3;
        do
        {
          char v91 = v89;
          v89 >>= 1;
          v88 += v90 & 1;
          v90 >>= 1;
        }
        while ((v91 & 2) == 0);
        unsigned int v92 = (CFIndex *)(a4 + 16 * v88);
        CFIndex v93 = *v92;
        if (*v92 == -1)
        {
LABEL_168:
          if ((a6 & 0x80) == 0) {
            goto LABEL_146;
          }
          unsigned int v100 = 0;
          unsigned int v101 = 128;
          do
          {
            char v102 = v101;
            v101 >>= 1;
            v100 += a6 & 1;
            a6 >>= 1;
          }
          while ((v102 & 2) == 0);
          BOOL v103 = &a7[2 * v100];
          CFIndex v104 = *v103;
          if (*v103 == -1)
          {
LABEL_146:
            if ((a3 & 0x100) == 0) {
              goto LABEL_158;
            }
            unsigned int v110 = 0;
            unsigned int v111 = 256;
            do
            {
              char v112 = v111;
              v111 >>= 1;
              v110 += a3 & 1;
              a3 >>= 1;
            }
            while ((v112 & 2) == 0);
            uint64_t v113 = (CFIndex *)(a4 + 16 * v110);
            CFIndex v114 = *v113;
            if (*v113 == -1) {
              goto LABEL_158;
            }
            CFIndex v63 = v113[1];
            CFIndex v115 = numChars;
            if (numChars >= 1024)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              CFIndex v115 = 0;
              CFIndex numChars = 0;
            }
            *((_WORD *)v117 + v115) = 35;
            ++numChars;
            v132.CFIndex location = v114;
            v132.CFIndex length = v63;
            CFStringGetCharacters(a2, v132, a8);
            CFIndex v80 = numChars;
            if (v63 <= 1024) {
              goto LABEL_153;
            }
LABEL_98:
            if (v80)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, v80);
              CFIndex numChars = 0;
            }
            int v81 = theString;
            CFAllocatorRef v82 = a8;
            CFIndex v83 = v63;
            goto LABEL_109;
          }
          CFIndex v105 = v103[1];
          CFIndex v106 = numChars;
          if (numChars >= 1024)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            CFIndex v106 = 0;
            CFIndex numChars = 0;
          }
          *((_WORD *)v117 + v106) = 63;
          ++numChars;
          v131.CFIndex location = v104;
          v131.CFIndex length = v105;
          CFStringGetCharacters(a5, v131, a8);
          CFIndex v107 = numChars;
          if (v105 > 1024)
          {
            if (numChars)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              CFIndex numChars = 0;
            }
            int v97 = theString;
            uint64_t v98 = a8;
            CFIndex v99 = v105;
            goto LABEL_136;
          }
          if (numChars + v105 >= 1025)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            CFIndex v107 = 0;
            CFIndex numChars = 0;
          }
          memcpy((char *)v117 + 2 * v107, a8, 2 * v105);
          CFIndex v108 = numChars + v105;
        }
        else
        {
          CFIndex v94 = v92[1];
          CFIndex v95 = numChars;
          if (numChars >= 1024)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            CFIndex v95 = 0;
            CFIndex numChars = 0;
          }
          *((_WORD *)v117 + v95) = 63;
          ++numChars;
          v130.CFIndex location = v93;
          v130.CFIndex length = v94;
          CFStringGetCharacters(a2, v130, a8);
          CFIndex v96 = numChars;
          if (v94 > 1024)
          {
            if (numChars)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              CFIndex numChars = 0;
            }
            int v97 = theString;
            uint64_t v98 = a8;
            CFIndex v99 = v94;
LABEL_136:
            CFStringAppendCharacters(v97, v98, v99);
            goto LABEL_146;
          }
          if (numChars + v94 >= 1025)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            CFIndex v96 = 0;
            CFIndex numChars = 0;
          }
          memcpy((char *)v117 + 2 * v96, a8, 2 * v94);
          CFIndex v108 = numChars + v94;
        }
        CFIndex numChars = v108;
        goto LABEL_146;
      }
      unsigned int v77 = 0;
      unsigned int v78 = 64;
      do
      {
        char v79 = v78;
        v78 >>= 1;
        v77 += a3 & 1;
        a3 >>= 1;
      }
      while ((v79 & 2) == 0);
      uint64_t v61 = *(void *)(a4 + 16 * v77) - 1;
      CFIndex v63 = CFStringGetLength(a2) - v61;
LABEL_97:
      v128.CFIndex location = v61;
      v128.CFIndex length = v63;
      CFStringGetCharacters(a2, v128, a8);
      CFIndex v80 = numChars;
      if (v63 < 1025)
      {
LABEL_153:
        if (v80 + v63 >= 1025)
        {
          CFStringAppendCharacters(theString, (const UniChar *)v117, v80);
          CFIndex v80 = 0;
          CFIndex numChars = 0;
        }
        memcpy((char *)v117 + 2 * v80, a8, 2 * v63);
        CFIndex v36 = numChars + v63;
        goto LABEL_156;
      }
      goto LABEL_98;
    }
    unsigned int v73 = 0;
    for (unsigned int i = 256; i != 32; i >>= 1)
    {
      if ((i & a6) != 0) {
        unsigned int v73 = i;
      }
    }
    if (v73)
    {
      if ((v73 & a6) != 0)
      {
        if (v73)
        {
          uint64_t v75 = 0;
        }
        else
        {
          LODWORD(v75) = 0;
          do
          {
            char v76 = v73;
            v73 >>= 1;
            uint64_t v75 = (a6 & 1) + v75;
            a6 >>= 1;
          }
          while ((v76 & 2) == 0);
        }
        uint64_t v84 = a7[2 * v75];
      }
      else
      {
        uint64_t v84 = -1;
      }
      uint64_t v85 = CFStringGetLength(a5) - v84;
      v129.CFIndex location = v84 - 1;
      uint64_t v86 = v85 + 1;
      v129.CFIndex length = v85 + 1;
      CFStringGetCharacters(a5, v129, a8);
      CFIndex v87 = numChars;
      if (v85 < 1024)
      {
        if (numChars + v86 > 1024)
        {
          CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
          CFIndex v87 = 0;
          CFIndex numChars = 0;
        }
        memcpy((char *)v117 + 2 * v87, a8, 2 * v86);
        CFIndex v36 = numChars + v86;
        goto LABEL_156;
      }
      if (numChars)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        CFIndex numChars = 0;
      }
      int v81 = theString;
      CFAllocatorRef v82 = a8;
      CFIndex v83 = v85 + 1;
LABEL_109:
      CFStringAppendCharacters(v81, v82, v83);
    }
LABEL_158:
    CFIndex v36 = numChars;
    if (!numChars) {
      return theString;
    }
LABEL_159:
    CFStringAppendCharacters(theString, (const UniChar *)v117, v36);
    return theString;
  }
LABEL_37:
  unsigned int v37 = 0;
  unsigned int v38 = 32;
  do
  {
    char v39 = v38;
    v38 >>= 1;
    v37 += a3 & 1;
    a3 >>= 1;
  }
  while ((v39 & 2) == 0);
  __int16 v40 = (CFIndex *)(a4 + 16 * v37);
  CFIndex v41 = *v40;
  CFIndex v42 = v40[1];
  if ((a6 & 0x20) == 0)
  {
    CFIndex v43 = 0;
LABEL_52:
    char v49 = 1;
LABEL_53:
    v134.CFIndex location = v41;
    v134.CFIndex length = v42;
    CFStringRef v55 = CFStringCreateWithSubstring(a1, a2, v134);
    goto LABEL_54;
  }
  unsigned int v44 = 0;
  unsigned int v45 = 32;
  do
  {
    char v46 = v45;
    v45 >>= 1;
    v44 += a6 & 1;
    a6 >>= 1;
  }
  while ((v46 & 2) == 0);
  __int16 v47 = (CFRange *)&a7[2 * v44];
  CFIndex location = v47->location;
  CFIndex v43 = v47->length;
  if (v47->location == -1) {
    goto LABEL_52;
  }
  if (!v42)
  {
    CFStringRef v55 = CFStringCreateWithSubstring(a1, a5, *v47);
    char v49 = 0;
    goto LABEL_54;
  }
  char v49 = 0;
  if (CFStringGetCharacterAtIndex(a2, v41) == 47 || !v43) {
    goto LABEL_53;
  }
  uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(a1, 2 * (v43 + v42) + 2, 0x1000040BDFB0063, 0);
  if (Typed)
  {
    __int16 v51 = (char *)Typed;
    v125.CFIndex location = location;
    v125.CFIndex length = v43;
    CFStringGetCharacters(a5, v125, Typed);
    uint64_t v52 = 2 * v43;
    while (1)
    {
      __int16 v53 = (UniChar *)&v51[v52];
      v52 -= 2;
      if (!v52) {
        break;
      }
      if (*(v53 - 1) == 47)
      {
        __int16 v54 = (UniChar *)&v51[v52 + 2];
        goto LABEL_165;
      }
    }
    if (*(_WORD *)v51 == 47) {
      __int16 v54 = v53;
    }
    else {
      __int16 v54 = (UniChar *)v51;
    }
LABEL_165:
    v133.CFIndex location = v41;
    v133.CFIndex length = v42;
    CFStringGetCharacters(a2, v133, v54);
    uint64_t v116 = &v54[v42];
    *uint64_t v116 = 0;
    CFStringRef v55 = _resolvedPath(v51, (unint64_t)v116, 47, 0, 0, a1);
    char v49 = 0;
    CFIndex v43 = 1;
LABEL_54:
    if (((v49 & 1) != 0 || !v43) && CFStringGetCharacterAtIndex(v55, 0) != 47)
    {
      CFIndex v56 = numChars;
      if (numChars >= 1024)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        CFIndex v56 = 0;
        CFIndex numChars = 0;
      }
      *((_WORD *)v117 + v56) = 47;
      ++numChars;
    }
    CFIndex v57 = CFStringGetLength(v55);
    CFIndex v58 = numChars;
    if (v57 < 1025)
    {
      CFIndex v59 = v57;
      if (numChars + v57 >= 1025)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        CFIndex v58 = 0;
        CFIndex numChars = 0;
      }
      char v60 = (UniChar *)v117 + v58;
      v126.CFIndex location = 0;
      v126.CFIndex length = v59;
      CFStringGetCharacters(v55, v126, v60);
      numChars += v59;
    }
    else
    {
      if (numChars)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        CFIndex numChars = 0;
      }
      CFStringAppend(theString, v55);
    }
    CFRelease(v55);
    uint64_t v61 = v42 + v41;
    CFIndex v62 = CFStringGetLength(a2);
    CFIndex v63 = v62 - v61;
    if (v62 > v61) {
      goto LABEL_97;
    }
    goto LABEL_158;
  }
  CFMutableStringRef result = theString;
  if (theString)
  {
    CFRelease(theString);
    return 0;
  }
  return result;
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  uint64_t v2 = theChar;
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    LOBYTE(v4) = [(__CFCharacterSet *)theSet longCharacterIsMember:v2];
  }
  else
  {
    unsigned int v6 = atomic_load((unint64_t *)theSet + 1);
    unsigned int v7 = atomic_load((unint64_t *)theSet + 1);
    int v4 = (v6 >> 3) & 1;
    switch((v7 >> 4) & 7)
    {
      case 0u:
        v4 ^= CFUniCharIsMemberOf(v2, *((_DWORD *)theSet + 6));
        break;
      case 1u:
        uint64_t v18 = *((void *)theSet + 4);
        if (v18)
        {
          uint64_t v19 = *((unsigned int *)theSet + 6);
          char v20 = v4 ^ (v18 + v19 > v2);
          if (v19 <= v2) {
            LOBYTE(v4) = v20;
          }
        }
        break;
      case 2u:
        uint64_t v8 = *((void *)theSet + 4);
        if (v8)
        {
          unint64_t v9 = (unsigned __int16 *)*((void *)theSet + 3);
          if (*v9 <= v2)
          {
            BOOL v10 = &v9[v8];
            unsigned int v12 = *(v10 - 1);
            unint64_t v11 = v10 - 1;
            if (v12 >= v2 && v8 >= 1)
            {
              while (1)
              {
                CFStringRef v14 = &v9[((char *)v11 - (char *)v9) >> 2];
                unsigned int v15 = *v14;
                if (v15 <= v2)
                {
                  if (v15 >= v2)
                  {
                    LOBYTE(v4) = v4 ^ 1;
                    return v4;
                  }
                  unint64_t v9 = v14 + 1;
                }
                else
                {
                  unint64_t v11 = v14 - 1;
                }
                if (v9 > v11) {
                  return v4;
                }
              }
            }
          }
        }
        break;
      case 3u:
        uint64_t v21 = *((void *)theSet + 3);
        if (v21)
        {
          unsigned int v22 = *(unsigned __int8 *)(v21 + ((unint64_t)v2 >> 3));
          goto LABEL_29;
        }
        break;
      case 4u:
        uint64_t v16 = *((void *)theSet + 3);
        if (v16)
        {
          uint64_t v17 = *(unsigned __int8 *)(v16 + ((unint64_t)v2 >> 8));
          if (!*(unsigned char *)(v16 + ((unint64_t)v2 >> 8))) {
            goto LABEL_22;
          }
          if (v17 == 255)
          {
            LOBYTE(v4) = 1;
          }
          else
          {
            unsigned int v22 = *(unsigned __int8 *)(v16 + 32 * v17 + ((unint64_t)(v2 & 0xF8) >> 3) + 224);
LABEL_29:
            int v4 = (v22 >> (v2 & 7)) & 1;
          }
        }
        break;
      default:
LABEL_22:
        LOBYTE(v4) = 0;
        break;
    }
  }
  return v4;
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  char v6 = searchOptions;
  CFIndex length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v67 = *(void *)off_1ECE0A5B0;
  CFIndex v11 = CFStringGetLength(theString);
  Boolean v12 = 0;
  if (!length || location + length > v11) {
    return v12;
  }
  if ((v6 & 4) != 0) {
    uint64_t v13 = location;
  }
  else {
    uint64_t v13 = location + length - 1;
  }
  if ((v6 & 4) != 0) {
    uint64_t v14 = location + length - 1;
  }
  else {
    uint64_t v14 = location;
  }
  if ((v6 & 8) != 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = v13;
  }
  if (v14 > v15) {
    uint64_t v16 = -1;
  }
  else {
    uint64_t v16 = 1;
  }
  CFStringRef theStringa = theString;
  CFIndex v63 = location;
  CFIndex v64 = length;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr) {
    uint64_t CStringPtrInternal = 0;
  }
  else {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal(theString, 1536, 0, 1);
  }
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v53 = 0u;
  *(_OWORD *)theSeta = 0u;
  long long v51 = 0u;
  int64_t v65 = 0;
  int64_t v66 = 0;
  uint64_t v62 = CStringPtrInternal;
  CFCharacterSetInitInlineBuffer((unint64_t)theSet, (uint64_t)theSeta);
  for (CFIndex i = v14; ; i += v16)
  {
    int64_t v19 = i - location;
    if (i - location >= 0)
    {
      CFIndex v20 = v64;
      if (v64 > v19) {
        break;
      }
    }
    UniChar v23 = 0;
LABEL_25:
    unsigned int v24 = (uint64_t)theSeta[1] & 4;
    if (HIDWORD(theSeta[1]) <= v23 && v51 > v23)
    {
      if (((uint64_t)theSeta[1] & 2) != 0)
      {
        if (CFCharacterSetIsLongCharacterMember(theSeta[0], v23)) {
          goto LABEL_104;
        }
      }
      else if (*((void *)&v51 + 1))
      {
        if ((uint64_t)theSeta[1])
        {
          unsigned int v41 = v24 >> 2;
          uint64_t v42 = *(unsigned __int8 *)(*((void *)&v51 + 1) + ((unint64_t)v23 >> 8));
          if (*(unsigned char *)(*((void *)&v51 + 1) + ((unint64_t)v23 >> 8)))
          {
            if (v42 == 255)
            {
              unsigned int v41 = v24 == 0;
            }
            else
            {
              BOOL v45 = v24 == 0;
              if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v51 + 1)
                                                          + 32 * v42
                                                          + (v23 >> 3)
                                                          + 224) >> (v23 & 7)) & 1) != 0)
                unsigned int v41 = v45;
            }
          }
          if (v41)
          {
LABEL_104:
            Boolean v12 = 1;
            if (!result) {
              return v12;
            }
            CFRange v48 = (CFRange)vdupq_n_s64(1uLL);
            v48.CFIndex location = i;
            goto LABEL_106;
          }
        }
        else
        {
          BOOL v26 = v24 != 0;
          BOOL v27 = v24 == 0;
          if (((unint64_t)*(unsigned __int8 *)(*((void *)&v51 + 1) + ((unint64_t)v23 >> 3)) >> (v23 & 7))) {
            BOOL v26 = v27;
          }
          if (v26) {
            goto LABEL_104;
          }
        }
      }
      else
      {
        BOOL v29 = v24 == 0;
        BOOL v30 = v24 != 0;
        char v31 = v29;
        if ((uint64_t)theSeta[1]) {
          char v32 = v30;
        }
        else {
          char v32 = v31;
        }
        if (v32) {
          goto LABEL_104;
        }
      }
    }
    else if (((uint64_t)theSeta[1] & 4) != 0)
    {
      goto LABEL_104;
    }
    if (i == v15) {
      return 0;
    }
LABEL_92:
    ;
  }
  uint64_t v21 = (UniChar *)CharactersPtr;
  if (CharactersPtr)
  {
    CFIndex v22 = v63 + v19;
LABEL_23:
    UniChar v23 = v21[v22];
    goto LABEL_42;
  }
  if (!v62)
  {
    if (v66 <= v19 || (int64_t v43 = v65, v65 > v19))
    {
      int64_t v44 = v19 - 4;
      if ((unint64_t)v19 < 4) {
        int64_t v44 = 0;
      }
      if (v44 + 64 < v64) {
        CFIndex v20 = v44 + 64;
      }
      int64_t v65 = v44;
      int64_t v66 = v20;
      v68.CFIndex location = v63 + v44;
      v68.CFIndex length = v20 - v44;
      CFStringGetCharacters(theStringa, v68, buffer);
      int64_t v43 = v65;
    }
    CFIndex v22 = v19 - v43;
    uint64_t v21 = buffer;
    goto LABEL_23;
  }
  UniChar v23 = *(char *)(v62 + v63 + v19);
LABEL_42:
  if (v23 >> 11 != 27) {
    goto LABEL_25;
  }
  CFIndex v28 = (int)i + (int)v16;
  if (v14 <= v15)
  {
    if (v28 > v15) {
      return 0;
    }
  }
  else if (v28 < v15)
  {
    return 0;
  }
  int64_t v33 = v28 - location;
  if (v28 - location < 0 || (CFIndex v34 = v64, v64 <= v33))
  {
    UniChar v37 = 0;
  }
  else
  {
    unint64_t v35 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      CFIndex v36 = v63 + v33;
      goto LABEL_59;
    }
    if (v62)
    {
      UniChar v37 = *(char *)(v62 + v63 + v33);
    }
    else
    {
      if (v66 <= v33 || (int64_t v46 = v65, v65 > v33))
      {
        int64_t v47 = v33 - 4;
        if ((unint64_t)v33 < 4) {
          int64_t v47 = 0;
        }
        if (v47 + 64 < v64) {
          CFIndex v34 = v47 + 64;
        }
        int64_t v65 = v47;
        int64_t v66 = v34;
        v69.CFIndex location = v63 + v47;
        v69.CFIndex length = v34 - v47;
        CFStringGetCharacters(theStringa, v69, buffer);
        int64_t v46 = v65;
      }
      CFIndex v36 = v33 - v46;
      unint64_t v35 = buffer;
LABEL_59:
      UniChar v37 = v35[v36];
    }
  }
  if (i >= v28) {
    UniChar v38 = v37;
  }
  else {
    UniChar v38 = v23;
  }
  if (i >= v28) {
    UniChar v37 = v23;
  }
  if (v38 >> 10 != 54 || (v37 & 0xFC00) != 0xDC00)
  {
LABEL_86:
    CFIndex i = (int)i + (int)v16;
    if (v28 == v15) {
      return 0;
    }
    goto LABEL_92;
  }
  UTF32Char v39 = (v38 << 10) + v37 - 56613888;
  if (HIDWORD(theSeta[1]) > v39 || v51 <= v39)
  {
    if (((uint64_t)theSeta[1] & 4) != 0) {
      goto LABEL_109;
    }
    goto LABEL_86;
  }
  if (!CFCharacterSetIsLongCharacterMember(theSeta[0], v39)) {
    goto LABEL_86;
  }
LABEL_109:
  if (result)
  {
    if (i >= v28) {
      CFIndex v49 = (int)i + (int)v16;
    }
    else {
      CFIndex v49 = i;
    }
    CFRange v48 = (CFRange)vdupq_n_s64(2uLL);
    v48.CFIndex location = v49;
LABEL_106:
    *CFMutableStringRef result = v48;
  }
  return 1;
}

CFIndex __CFStringEncodeByteStream(CFStringRef theString, CFRange range, int a3, uint64_t a4, unsigned int a5, UniChar *buffer, uint64_t a7, int64_t *a8)
{
  uint64_t v8 = a7;
  unint64_t v9 = buffer;
  uint64_t length = range.length;
  CFIndex location = range.location;
  uint64_t v13 = a8;
  uint64_t v128 = *(void *)off_1ECE0A5B0;
  CFIndex v110 = 0;
  uint64_t v111 = 0;
  if (a4 == 3071)
  {
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    *(_OWORD *)buffera = 0u;
    long long v114 = 0u;
    CFStringRef theStringa = theString;
    CFRange v124 = range;
    CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
    CFIndex v108 = a8;
    if (CharactersPtr) {
      CStringPtr = 0;
    }
    else {
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    }
    CFIndex v125 = 0;
    CFIndex v126 = 0;
    CFRange v123 = CStringPtr;
    if (length < 1) {
      goto LABEL_249;
    }
    uint64_t v34 = 0;
    CFIndex v35 = 0;
    CFIndex v105 = 0;
    CFIndex v36 = 0;
    uint64_t v37 = 64;
    while (1)
    {
      if ((unint64_t)v36 >= 4) {
        uint64_t v38 = 4;
      }
      else {
        uint64_t v38 = v36;
      }
      CFIndex v39 = v124.length;
      if (v124.length <= v36)
      {
        unsigned int v41 = 0;
        LOBYTE(v42) = 0;
      }
      else
      {
        if (CharactersPtr)
        {
          UniChar v40 = CharactersPtr[v36 + v124.location];
        }
        else if (v123)
        {
          UniChar v40 = v123[v124.location + v36];
        }
        else
        {
          BOOL v44 = v126 > v36 && v105 <= v36;
          if (!v44)
          {
            uint64_t v45 = -v38;
            uint64_t v46 = v38 + v34;
            CFIndex v47 = v37 - v38;
            CFIndex v48 = v36 + v45;
            CFIndex v49 = v48 + 64;
            if (v48 + 64 >= v124.length) {
              CFIndex v49 = v124.length;
            }
            CFIndex v125 = v48;
            CFIndex v126 = v49;
            if (v124.length >= v47) {
              CFIndex v39 = v47;
            }
            v129.uint64_t length = v39 + v46;
            v129.CFIndex location = v48 + v124.location;
            CFStringGetCharacters(theStringa, v129, buffera);
            CFIndex v35 = v125;
          }
          UniChar v40 = buffera[v36 - v35];
          CFIndex v105 = v35;
        }
        unsigned int v41 = v40;
        BOOL v50 = (unsigned __int16)(v40 - 32) >= 0x5Fu || v40 == 92;
        if (!v50 || (v40 <= 0xDu ? (BOOL v51 = ((1 << v40) & 0x2600) == 0) : (BOOL v51 = 1), !v51))
        {
          size_t v43 = 1;
          goto LABEL_81;
        }
        if (v40 == 92)
        {
          LOBYTE(v41) = 92;
          BYTE1(__src) = 92;
          size_t v43 = 2;
          goto LABEL_81;
        }
        if (v40 > 0xFFu)
        {
          BYTE2(__src) = a0123456789abcd[(unint64_t)v40 >> 12];
          char v53 = a0123456789abcd[((unint64_t)v40 >> 8) & 0xF];
          BYTE1(__src) = 117;
          BYTE3(__src) = v53;
          BYTE4(__src) = a0123456789abcd[v41 >> 4];
          BYTE5(__src) = a0123456789abcd[v41 & 0xF];
          LOBYTE(v41) = 92;
          size_t v43 = 6;
          goto LABEL_81;
        }
        int v42 = v40 >> 6;
      }
      BYTE1(__src) = v42 + 48;
      BYTE2(__src) = (v41 >> 3) & 7 | 0x30;
      BYTE3(__src) = v41 & 7 | 0x30;
      LOBYTE(v41) = 92;
      size_t v43 = 4;
LABEL_81:
      LOBYTE(__src) = v41;
      uint64_t v52 = v111 + v43;
      if (v9)
      {
        if (v52 > v8) {
          goto LABEL_249;
        }
        memcpy((char *)v9 + v111, &__src, v43);
      }
      CFIndex v110 = ++v36;
      uint64_t v111 = v52;
      --v34;
      ++v37;
      if (v36 >= length) {
        goto LABEL_249;
      }
    }
  }
  if (a4 != 134217984)
  {
    if (a4 == 256 || a4 == 335544576 || a4 == 268435712)
    {
      uint64_t v20 = 2;
      if (a3 == 0 || a4 != 256) {
        uint64_t v20 = 0;
      }
      CFIndex v110 = range.length;
      uint64_t v21 = v20 + 2 * range.length;
      if (buffer)
      {
        if (v21 > a7)
        {
          if (a7 <= v20) {
            uint64_t length = 0;
          }
          else {
            uint64_t length = (unint64_t)(a7 - v20) >> 1;
          }
          CFIndex v110 = length;
          uint64_t v21 = v20 + 2 * length;
        }
        uint64_t v111 = v21;
        if (a3 != 0 && a4 == 256)
        {
          *buffer = -257;
          range.uint64_t length = length;
          CFStringGetCharacters(theString, range, buffer + 1);
        }
        else
        {
          range.uint64_t length = length;
          CFStringGetCharacters(theString, range, buffer);
          if (a4 == 268435712 && length >= 1)
          {
            long long v54 = &v9[length];
            do
            {
              *unint64_t v9 = bswap32(*v9) >> 16;
              ++v9;
            }
            while (v9 < v54);
          }
        }
      }
      else
      {
        uint64_t v111 = v20 + 2 * range.length;
      }
      goto LABEL_250;
    }
    CFIndex v108 = a8;
    if (a4 != 201326848 && a4 != 469762304 && a4 != 402653440)
    {
      uint64_t __src = 0;
      unsigned int v23 = 0;
      switch(BYTE1(a4))
      {
        case 0:
          unsigned int v23 = 0;
          if ((a4 > 0x22 || ((1 << a4) & 0x600000032) == 0) && a4 != 152) {
            goto LABEL_263;
          }
          goto LABEL_28;
        case 1:
          goto LABEL_24;
        case 2:
          unsigned int v23 = a4 != 518;
          goto LABEL_28;
        case 6:
          BOOL v22 = a4 == 1536;
          goto LABEL_25;
        case 8:
        case 0xC:
          goto LABEL_28;
        case 0xA:
          if ((a4 - 2561) >= 0x10) {
LABEL_263:
          }
            unsigned int v23 = 1;
          else {
            unsigned int v23 = (0x7FEEu >> (a4 - 1)) & 1;
          }
          goto LABEL_28;
        case 0xB:
          BOOL v100 = __CFADD__(a4 - 3061, 2);
          goto LABEL_260;
        default:
          BOOL v100 = ((unsigned __int16)a4 & 0xFF00u) >= 0xC01;
LABEL_260:
          unsigned int v23 = !v100;
          break;
      }
      goto LABEL_28;
    }
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    *(_OWORD *)buffera = 0u;
    long long v114 = 0u;
    if (a3)
    {
      if (a4 == 201326848)
      {
        uint64_t v111 = 4;
        if (buffer)
        {
          if (a7 > 3)
          {
            *(_DWORD *)buffer = 65279;
            unint64_t v9 = buffer + 2;
          }
          else
          {
            uint64_t v111 = 0;
          }
        }
      }
    }
    CFStringRef theStringa = theString;
    CFRange v124 = range;
    CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
    if (CharactersPtr) {
      uint64_t v62 = 0;
    }
    else {
      uint64_t v62 = CFStringGetCStringPtr(theString, 0x600u);
    }
    CFIndex v125 = 0;
    CFIndex v126 = 0;
    CFRange v123 = v62;
    if (length >= 1)
    {
      for (CFIndex i = 0; i < length; v110 = i)
      {
        CFIndex v64 = v124.length;
        if (v124.length <= i)
        {
          unsigned int v66 = 0;
        }
        else
        {
          if (CharactersPtr)
          {
            UniChar v65 = CharactersPtr[v124.location + i];
          }
          else if (v123)
          {
            UniChar v65 = v123[v124.location + i];
          }
          else
          {
            CFIndex v67 = v125;
            if (v126 <= i || v125 > i)
            {
              CFIndex v69 = i - 4;
              if ((unint64_t)i < 4) {
                CFIndex v69 = 0;
              }
              if (v69 + 64 < v124.length) {
                CFIndex v64 = v69 + 64;
              }
              CFIndex v125 = v69;
              CFIndex v126 = v64;
              v130.CFIndex location = v124.location + v69;
              v130.uint64_t length = v64 - v69;
              CFStringGetCharacters(theStringa, v130, buffera);
              CFIndex v67 = v125;
            }
            UniChar v65 = buffera[i - v67];
          }
          if ((v65 & 0xFC00) == 0xDC00)
          {
LABEL_169:
            unsigned int v66 = a5;
            if (!a5) {
              break;
            }
            goto LABEL_170;
          }
          unsigned int v66 = v65;
          if ((v65 & 0xFC00) == 0xD800)
          {
            CFIndex v70 = i + 1;
            if (i + 1 >= length) {
              goto LABEL_169;
            }
            CFIndex v71 = v124.length;
            if (v124.length <= v70) {
              goto LABEL_169;
            }
            if (CharactersPtr)
            {
              UniChar v72 = CharactersPtr[v124.location + v70];
            }
            else if (v123)
            {
              UniChar v72 = v123[v124.location + v70];
            }
            else
            {
              if (v126 <= v70 || (CFIndex v73 = v125, v125 > v70))
              {
                CFIndex v74 = i - 3;
                if ((unint64_t)i < 3) {
                  CFIndex v74 = 0;
                }
                if (v74 + 64 < v124.length) {
                  CFIndex v71 = v74 + 64;
                }
                CFIndex v125 = v74;
                CFIndex v126 = v71;
                v131.CFIndex location = v124.location + v74;
                v131.uint64_t length = v71 - v74;
                CFStringGetCharacters(theStringa, v131, buffera);
                CFIndex v73 = v125;
              }
              UniChar v72 = buffera[v70 - v73];
            }
            if (v72 >> 10 != 55) {
              goto LABEL_169;
            }
            unsigned int v66 = (v66 << 10) + v72 - 56613888;
          }
        }
LABEL_170:
        uint64_t v75 = v111;
        uint64_t v76 = v111 + 4;
        v111 += 4;
        if (v9)
        {
          if (v76 > v8)
          {
            uint64_t v111 = v75;
            break;
          }
          unsigned int v77 = bswap32(v66);
          if (a4 != 402653440) {
            unsigned int v77 = v66;
          }
          *(_DWORD *)unint64_t v9 = v77;
          v9 += 2;
        }
        if (HIWORD(v66)) {
          uint64_t v78 = 2;
        }
        else {
          uint64_t v78 = 1;
        }
        i += v78;
      }
    }
LABEL_249:
    uint64_t v13 = v108;
    goto LABEL_250;
  }
  uint64_t v17 = CFStringGetCharactersPtr(theString);
  if (v17)
  {
    if (v9) {
      uint64_t v18 = v8;
    }
    else {
      uint64_t v18 = 0;
    }
    CFIndex v110 = __CFConverterUTF8(0, (unsigned __int16 *)&v17[location], length, v9, v18, &v111);
LABEL_250:
    if (v13) {
      *uint64_t v13 = v111;
    }
    return v110;
  }
  CFIndex v108 = a8;
  uint64_t __src = 0;
LABEL_24:
  BOOL v22 = a4 == 134217984;
LABEL_25:
  unsigned int v23 = v22;
LABEL_28:
  if (CFStringEncodingIsValidEncoding(a4))
  {
    if (v23)
    {
      CFStringEncoding v24 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        CFStringEncoding v24 = __CFDefaultEightBitStringEncoding;
      }
      CFIndex v25 = CFStringGetCStringPtr(theString, v24);
      if (v25)
      {
        BOOL v26 = (const unsigned __int8 *)&v25[location];
        int v27 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          unsigned int v104 = v23;
          CFIndex v28 = &v25[location];
          __CFStringComputeEightBitStringEncoding();
          BOOL v26 = (const unsigned __int8 *)v28;
          unsigned int v23 = v104;
          int v27 = __CFDefaultEightBitStringEncoding;
        }
        if (v27 != a4)
        {
          if (v8 >= length) {
            uint64_t v29 = length;
          }
          else {
            uint64_t v29 = v8;
          }
          uint64_t v30 = length - v29;
          if (v9) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = 0;
          }
          if ((*(char *)v26 & 0x80000000) == 0 && v31 < length)
          {
            char v32 = v26;
            do
            {
              int v33 = *(char *)++v32;
              --length;
            }
            while ((v33 & 0x80000000) == 0 && length > v31);
            goto LABEL_188;
          }
LABEL_187:
          char v32 = v26;
LABEL_188:
          int64_t v60 = v32 - v26;
          CFIndex v110 = v32 - v26;
          char v102 = v26;
          if (v9)
          {
            if (v60 >= v8) {
              int64_t v60 = v8;
            }
            CFIndex v110 = v60;
            memmove(v9, v26, v60);
            unint64_t v9 = (UniChar *)((char *)v9 + v60);
            v8 -= v60;
          }
          if (!length || v9 && !v8) {
            goto LABEL_127;
          }
          location += v60;
          uint64_t v111 = v60;
          uint64_t v61 = v102;
          if (!v9) {
            goto LABEL_196;
          }
LABEL_125:
          if (!v8) {
            goto LABEL_126;
          }
LABEL_196:
          if (!v9) {
            uint64_t v8 = 0;
          }
          if (a5)
          {
            BOOL v81 = a5 == 255 && a4 == 1536;
            int v82 = (a5 << 24) | 1;
            if (v81) {
              int v82 = 1;
            }
          }
          else
          {
            int v82 = 0;
          }
          int v83 = v82 | ((a3 != 0) << 8);
          unsigned int v84 = __CFWantsToUseASCIICompatibleConversion;
          if (v23) {
            unsigned int v84 = 0;
          }
          uint64_t v85 = v83 | v84;
          if (!v61)
          {
            uint64_t v98 = CFStringGetCharactersPtr(theString);
            if (v98)
            {
              CFStringEncodingUnicodeToBytes(a4, v85, (unsigned __int16 *)&v98[location], length, &v110, (unsigned int *)v9, v8, &v111);
              goto LABEL_249;
            }
          }
          uint64_t v109 = 0;
          if (length < 1) {
            goto LABEL_249;
          }
          LOBYTE(v107) = 0;
          uint64_t v86 = 0;
          uint64_t v87 = 0;
          unsigned int v101 = v85 & 0xFFFFFEFF;
          while (1)
          {
            if (length >= 512) {
              unint64_t v88 = 512;
            }
            else {
              unint64_t v88 = length;
            }
            v132.CFIndex location = location;
            v132.uint64_t length = v88;
            CFStringGetCharacters(theString, v132, buffera);
            if ((unint64_t)length >= 0x201) {
              v88 -= (v127 & 0xFC00) == 55296;
            }
            unsigned int v103 = ((length > v88) << 12) | (v107 << 16) | v85;
            int v89 = CFStringEncodingUnicodeToBytes(a4, v103, buffera, v88, &__src, (unsigned int *)v9, v8, &v109);
            LOBYTE(v107) = BYTE2(v89);
            unsigned int v90 = v89 & 0xFF00FFFF;
            if ((v89 & 0xFF00FFFF) != 0)
            {
              if (v90 != 1) {
                goto LABEL_248;
              }
              uint64_t v91 = __src;
              if ((unint64_t)length >= 0x201 && (uint64_t)(v88 - __src) <= 5)
              {
                CFRange RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(theString, v88 + location);
                uint64_t v91 = __src;
                unsigned int v90 = 1;
                if (RangeOfComposedCharactersAtIndex.length <= 6
                  && RangeOfComposedCharactersAtIndex.location < __src + location)
                {
                  int v93 = CFStringEncodingUnicodeToBytes(a4, v103, buffera, RangeOfComposedCharactersAtIndex.location - location, &__src, (unsigned int *)v9, v8, &v109);
                  LOBYTE(v107) = BYTE2(v93);
                  unsigned int v90 = v93 & 0xFF00FFFF;
                  uint64_t v91 = __src;
                }
              }
              if (v90 && v86 >= 1 && v91 <= 5)
              {
                CFRange v94 = CFStringGetRangeOfComposedCharactersAtIndex(theString, location);
                if (v94.length > 6) {
                  goto LABEL_248;
                }
                if (v94.location >= location) {
                  goto LABEL_248;
                }
                CFStringGetCharacters(theString, v94, buffera);
                if (CFStringEncodingUnicodeToBytes(a4, v85, buffera, v94.length, &__src, 0, 0, &v109)) {
                  goto LABEL_248;
                }
                location -= v86;
                v133.CFIndex location = location;
                v133.uint64_t length = v94.location - location;
                CFStringGetCharacters(theString, v133, buffera);
                CFIndex v95 = v8 ? (unsigned int *)((char *)v9 - v87) : 0;
                uint64_t v96 = v8 ? v8 + v87 : 0;
                unsigned int v97 = CFStringEncodingUnicodeToBytes(a4, v103, buffera, v94.location - location, &__src, v95, v96, &v109);
                if ((v97 & 0xFF00FFFF) != 0)
                {
LABEL_248:
                  v111 += v109;
                  v110 += __src;
                  goto LABEL_249;
                }
                unsigned int v107 = HIWORD(v97);
                v111 -= v87;
                v110 -= v86;
                length += v86;
                if (v8) {
                  unint64_t v9 = (UniChar *)((char *)v9 - v87);
                }
                uint64_t v8 = v96;
              }
              else if (v90)
              {
                goto LABEL_248;
              }
            }
            uint64_t v87 = v109;
            uint64_t v86 = __src;
            v111 += v109;
            v110 += __src;
            if (v8)
            {
              v8 -= v109;
              if (v8 < 1) {
                goto LABEL_249;
              }
              unint64_t v9 = (UniChar *)((char *)v9 + v109);
            }
            location += __src;
            uint64_t v85 = v101;
            BOOL v44 = length <= __src;
            length -= __src;
            if (v44) {
              goto LABEL_249;
            }
          }
        }
        goto LABEL_116;
      }
      CFStringEncoding v55 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        CFStringEncoding v55 = __CFDefaultEightBitStringEncoding;
      }
      ConstStringPtr PascalStringPtr = CFStringGetPascalStringPtr(theString, v55);
      if (PascalStringPtr)
      {
        BOOL v26 = &PascalStringPtr[location + 1];
        int v57 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          unsigned int v106 = v23;
          uint64_t v58 = (uint64_t)&PascalStringPtr[location + 1];
          __CFStringComputeEightBitStringEncoding();
          BOOL v26 = (const unsigned __int8 *)v58;
          unsigned int v23 = v106;
          int v57 = __CFDefaultEightBitStringEncoding;
        }
        if (v57 != a4)
        {
          if ((*(char *)v26 & 0x80000000) == 0 && length >= 1)
          {
            char v32 = v26;
            do
            {
              int v79 = *(char *)++v32;
              BOOL v80 = length-- != 0;
            }
            while ((v79 & 0x80000000) == 0 && length != 0 && v80);
            goto LABEL_188;
          }
          goto LABEL_187;
        }
LABEL_116:
        if (length < v8 || v9 == 0) {
          int64_t v60 = length;
        }
        else {
          int64_t v60 = v8;
        }
        if (v9) {
          memmove(v9, v26, v60);
        }
        goto LABEL_127;
      }
    }
    uint64_t v61 = 0;
    if (!v9) {
      goto LABEL_196;
    }
    goto LABEL_125;
  }
LABEL_126:
  int64_t v60 = 0;
LABEL_127:
  if (v108) {
    *CFIndex v108 = v60;
  }
  return v60;
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    -[__CFString getCharacters:range:]((id)theString, "getCharacters:range:", buffer, location, length);
  }
  else
  {
    char v7 = atomic_load((unint64_t *)&theString->info);
    p_data = &theString->data;
    if ((v7 & 0x60) != 0)
    {
      unint64_t v9 = *p_data;
    }
    else
    {
      char v10 = atomic_load((unint64_t *)&theString->info);
      unint64_t v9 = (char *)&p_data[(v10 & 5) != 4];
    }
    char v11 = atomic_load((unint64_t *)&theString->info);
    if ((v11 & 0x10) != 0)
    {
      memmove(buffer, &v9[2 * location], 2 * length);
    }
    else
    {
      unint64_t v12 = atomic_load((unint64_t *)&theString->info);
      __CFStrConvertBytesToUnicode((unsigned __int8 *)&v9[location + ((v12 >> 2) & 1)], buffer, length);
    }
  }
}

_OWORD *CFStringEncodingIsValidEncoding(uint64_t a1)
{
  CFMutableStringRef result = __CFGetConverter(a1);
  if (result) {
    return (_OWORD *)(*(void *)result != 0);
  }
  return result;
}

_OWORD *__CFGetConverter(uint64_t a1)
{
  switch(a1)
  {
    case 0xFFFFFFFF:
      return 0;
    case 0x8000100:
      uint64_t v2 = &__CFGetConverter_commonConverters;
      goto LABEL_6;
    case 0:
      uint64_t v2 = &qword_1EB1DDD38;
LABEL_6:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
LABEL_9:
      int v4 = 0;
      CFArrayRef Value = (_OWORD *)*v2;
      goto LABEL_10;
  }
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
  if (SystemEncoding == a1)
  {
    uint64_t v2 = &qword_1EB1DDD40;
    goto LABEL_9;
  }
  if (!__CFGetConverter_mappingTable)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
    uint64_t v2 = 0;
    int v4 = 1;
    goto LABEL_11;
  }
  CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)__CFGetConverter_mappingTable, (const void *)a1);
  uint64_t v2 = 0;
  int v4 = 1;
LABEL_10:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
  if (!Value)
  {
LABEL_11:
    if ((int)a1 > 1535)
    {
      switch(a1)
      {
        case 0x600:
          Externaluint64_t Converter = __CFConverterASCII;
          goto LABEL_28;
        case 0xB01:
          Externaluint64_t Converter = __CFConverterNextStepLatin;
          goto LABEL_28;
        case 0x8000100:
          Externaluint64_t Converter = __CFConverterUTF8;
          goto LABEL_28;
      }
    }
    else
    {
      switch(a1)
      {
        case 0:
          Externaluint64_t Converter = __CFConverterMacRoman;
          goto LABEL_28;
        case 0x201:
          Externaluint64_t Converter = __CFConverterISOLatin1;
          goto LABEL_28;
        case 0x500:
          Externaluint64_t Converter = __CFConverterWinLatin1;
          goto LABEL_28;
      }
    }
    Externaluint64_t Converter = __CFStringEncodingGetExternalConverter(a1);
    if (ExternalConverter)
    {
LABEL_28:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
      if (v4)
      {
        if (!__CFGetConverter_mappingTable
          || (CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)__CFGetConverter_mappingTable, (const void *)a1)) == 0)
        {
LABEL_34:
          if ((__CFEncodingConverterFromDefinition__currentIndex - 9) > 0xFFFFFFF5)
          {
            uint64_t Typed = __CFEncodingConverterFromDefinition__allocatedEntries;
            if (__CFEncodingConverterFromDefinition__allocatedEntries)
            {
              unsigned int v8 = ++__CFEncodingConverterFromDefinition__currentIndex;
              goto LABEL_39;
            }
          }
          else
          {
            __CFEncodingConverterFromDefinition__currentIndex = 0;
            __CFEncodingConverterFromDefinition__allocatedEntries = 0;
          }
          uint64_t Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 480, 0xE004030B2989CLL, 0);
          __CFEncodingConverterFromDefinition__allocatedEntries = Typed;
          unsigned int v8 = __CFEncodingConverterFromDefinition__currentIndex;
LABEL_39:
          CFArrayRef Value = (_OWORD *)(Typed + 48 * v8);
          Value[1] = 0u;
          Value[2] = 0u;
          _OWORD *Value = 0u;
          *(void *)CFArrayRef Value = ExternalConverter;
          unsigned int v9 = v8;
          switch(*((unsigned char *)ExternalConverter + 20))
          {
            case 0:
              char v10 = (void *)(Typed + 48 * v8);
              v10[1] = 0;
              v10[2] = 0;
              void v10[3] = 0;
              goto LABEL_48;
            case 1:
              char v11 = (void *)(Typed + 48 * v8);
              v11[1] = __CFToBytesCheapEightBitWrapper;
              v11[2] = __CFToUnicodeCheapEightBitWrapper;
              unint64_t v12 = __CFToCanonicalUnicodeCheapEightBitWrapper;
              goto LABEL_46;
            case 2:
              char v11 = (void *)(Typed + 48 * v8);
              v11[1] = __CFToBytesStandardEightBitWrapper;
              v11[2] = __CFToUnicodeStandardEightBitWrapper;
              unint64_t v12 = __CFToCanonicalUnicodeStandardEightBitWrapper;
              goto LABEL_46;
            case 3:
              char v11 = (void *)(Typed + 48 * v8);
              v11[1] = __CFToBytesCheapMultiByteWrapper;
              v11[2] = __CFToUnicodeCheapMultiByteWrapper;
              unint64_t v12 = __CFToCanonicalUnicodeCheapMultiByteWrapper;
LABEL_46:
              v11[3] = v12;
              goto LABEL_48;
            case 4:
              goto LABEL_48;
            case 5:
              *(void *)(Typed + 48 * v8 + 8) = __CFStringEncodingGetICUName(a1);
LABEL_48:
              v13.i64[0] = (uint64_t)__CFDefaultToBytesFallbackProc;
              v13.i64[1] = (uint64_t)__CFDefaultToUnicodeFallbackProc;
              *(int8x16_t *)(Typed + 48 * v9 + 32) = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)(ExternalConverter + 5)), v13, *(int8x16_t *)(ExternalConverter + 5));
              if (v4) {
                goto LABEL_49;
              }
              goto LABEL_42;
            default:
              CFArrayRef Value = 0;
              if (v4)
              {
LABEL_49:
                CFMutableCharacterSetRef Mutable = (__CFDictionary *)__CFGetConverter_mappingTable;
                if (!__CFGetConverter_mappingTable)
                {
                  CFMutableCharacterSetRef Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
                  __CFGetConverter_mappingTable = (uint64_t)Mutable;
                }
                CFDictionarySetValue(Mutable, (const void *)a1, Value);
              }
              else
              {
LABEL_42:
                *uint64_t v2 = (uint64_t)Value;
              }
              break;
          }
        }
      }
      else
      {
        CFArrayRef Value = (_OWORD *)*v2;
        if (!*v2) {
          goto LABEL_34;
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
      return Value;
    }
    return 0;
  }
  return Value;
}

uint64_t _CFCharacterSetIsLongCharacterMember(uint64_t a1, unsigned int a2)
{
  if (BYTE2(a2))
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 0x70) == 0)
    {
      unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
      return (v10 >> 3) & 1 ^ CFUniCharIsMemberOf(a2, *(_DWORD *)(a1 + 24));
    }
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      uint64_t v4 = *(unsigned char *)(v3 + 13) != 0;
      unsigned int v5 = *(_DWORD *)(v3 + 8);
      if (BYTE2(a2) <= 0x10u
        && ((v5 >> SBYTE2(a2)) & 1) != 0
        && *(unsigned __int8 *)(v3 + 12) >= BYTE2(a2))
      {
        uint64_t v6 = *(void *)(*(void *)v3 + 8 * (BYTE2(a2) - 1));
        if (v6)
        {
          a2 = (unsigned __int16)a2;
          a1 = v6;
          goto LABEL_10;
        }
      }
      if (v5) {
        return v4;
      }
    }
    else
    {
      uint64_t v4 = 0;
    }
    char v11 = atomic_load((unint64_t *)(a1 + 8));
    if ((v11 & 0x70) == 0x10)
    {
      unsigned int v12 = atomic_load((unint64_t *)(a1 + 8));
      uint64_t v4 = (v12 >> 3) & 1;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        uint64_t v14 = *(unsigned int *)(a1 + 24);
        if (v14 <= a2) {
          return v4 ^ (v13 + v14 > a2);
        }
      }
    }
    return v4;
  }
  LODWORD(v4) = 0;
LABEL_10:
  unsigned int v7 = atomic_load((unint64_t *)(a1 + 8));
  unsigned int v8 = atomic_load((unint64_t *)(a1 + 8));
  int v9 = (v7 >> 3) & 1;
  switch((v8 >> 4) & 7)
  {
    case 0u:
      v9 ^= CFUniCharIsMemberOf(a2, *(_DWORD *)(a1 + 24));
      return v4 ^ v9;
    case 1u:
      uint64_t v25 = *(void *)(a1 + 32);
      if (v25)
      {
        uint64_t v26 = *(unsigned int *)(a1 + 24);
        if (v26 <= a2) {
          v9 ^= v25 + v26 > a2;
        }
      }
      return v4 ^ v9;
    case 2u:
      uint64_t v15 = *(void *)(a1 + 32);
      if (!v15) {
        return v4 ^ v9;
      }
      uint64_t v16 = *(unsigned __int16 **)(a1 + 24);
      if (*v16 > (unsigned __int16)a2) {
        return v4 ^ v9;
      }
      uint64_t v17 = &v16[v15];
      unsigned int v19 = *(v17 - 1);
      uint64_t v18 = v17 - 1;
      if (v19 < (unsigned __int16)a2 || v15 < 1) {
        return v4 ^ v9;
      }
      break;
    case 3u:
      uint64_t v27 = *(void *)(a1 + 24);
      if (!v27) {
        return v4 ^ v9;
      }
      unsigned int v28 = *(unsigned __int8 *)(v27 + ((unsigned __int16)a2 >> 3));
      goto LABEL_44;
    case 4u:
      uint64_t v23 = *(void *)(a1 + 24);
      if (!v23) {
        return v4 ^ v9;
      }
      uint64_t v24 = *(unsigned __int8 *)(v23 + BYTE1(a2));
      if (*(unsigned char *)(v23 + BYTE1(a2)))
      {
        if (v24 == 255)
        {
          int v9 = 1;
        }
        else
        {
          unsigned int v28 = *(unsigned __int8 *)(v23 + 32 * v24 + (a2 >> 3) + 224);
LABEL_44:
          int v9 = (v28 >> (a2 & 7)) & 1;
        }
      }
      else
      {
        int v9 = 0;
      }
      return v4 ^ v9;
    default:
      return 0;
  }
  while (1)
  {
    uint64_t v21 = &v16[((char *)v18 - (char *)v16) >> 2];
    unsigned int v22 = *v21;
    if (v22 <= (unsigned __int16)a2) {
      break;
    }
    uint64_t v18 = v21 - 1;
LABEL_30:
    if (v16 > v18) {
      return v4 ^ v9;
    }
  }
  if (v22 < (unsigned __int16)a2)
  {
    uint64_t v16 = v21 + 1;
    goto LABEL_30;
  }
  v9 ^= 1u;
  return v4 ^ v9;
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  uint64_t v2 = *(void *)&theChar;
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet)) {
    return [(__CFCharacterSet *)theSet longCharacterIsMember:v2];
  }

  return _CFCharacterSetIsLongCharacterMember((uint64_t)theSet, v2);
}

uint64_t CFStringEncodingUnicodeToBytes(int a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t *a5, unsigned int *a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v10 = (uint64_t)a6;
  unint64_t v13 = (unint64_t)a3;
  uint64_t v14 = a2;
  v76[1] = *(void *)off_1ECE0A5B0;
  if (a1 == 134217984)
  {
    uint64_t v75 = 0;
    v76[0] = 0;
    if ((a2 & 0xC0) != 0)
    {
      CFUniCharDecompose(a3, a4, v76, a6, a7, &v75, 1, 2, (a2 & 0x80) != 0);
      if (!a5)
      {
LABEL_5:
        if (a8) {
          *a8 = v75;
        }
        if (a4 == v76[0]) {
          return 0;
        }
        if (a7 < 1) {
          return 1;
        }
        if (a7 - v75 > 9) {
          return 1;
        }
        int v20 = *(_WORD *)(v13 + 2 * v76[0]) & 0xFC00;
        if (v20 == 56320
          || v20 == 55296
          && (a4 - v76[0] == 1
           || (unsigned __int16)((unsigned __int16)(*(_WORD *)(v13 + 2 * v76[0] + 2) + 0x2000) >> 10) < 0x3Fu))
        {
          return 1;
        }
        return 2;
      }
    }
    else
    {
      uint64_t v21 = CFStringEncodingUnicodeToBytes___CFToUTF8;
      if (!CFStringEncodingUnicodeToBytes___CFToUTF8)
      {
        uint64_t v21 = **(void ***)__CFGetConverter(134217984);
        CFStringEncodingUnicodeToBytes___CFToUTF8 = v21;
      }
      v76[0] = ((uint64_t (*)(void, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))v21)(0, v13, a4, v10, a7, &v75);
      if (!a5) {
        goto LABEL_5;
      }
    }
    *a5 = v76[0];
    goto LABEL_5;
  }
  uint64_t v16 = (uint64_t *)((uint64_t (*)(void))__CFGetConverter)();
  v76[0] = 0;
  if (!v16) {
    return 3;
  }
  uint64_t v17 = v16;
  if ((v14 & 8) != 0)
  {
    uint64_t v18 = *v16;
    unsigned int v19 = 0;
    if (v14) {
      CFIndex v74 = 0;
    }
    else {
      CFIndex v74 = *(uint64_t (**)(void))(v18 + 64);
    }
  }
  else
  {
    uint64_t v18 = *v16;
    CFIndex v74 = *(uint64_t (**)(void))(*v16 + 64);
    if ((v14 & 0x20) != 0)
    {
      unsigned int v19 = 0;
    }
    else
    {
      unsigned int v19 = *(uint64_t (**)(void, uint64_t, uint64_t))(v18 + 56);
      uint64_t v14 = v14 | 0x10;
    }
  }
  int v22 = *(unsigned __int8 *)(v18 + 20);
  if (v22 == 4) {
    return __CFStringEncodingPlatformUnicodeToBytes();
  }
  if (v22 == 5) {
    return __CFStringEncodingICUToBytes(v16[1], v14, v13, a4, a5, v10, a7, a8);
  }
  if (a4 >= 1)
  {
    CFIndex v69 = v19;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    unsigned int v71 = BYTE3(v14);
    unsigned int v73 = v14;
    uint64_t v72 = v10;
    while (1)
    {
      if (a7 && a7 <= v23) {
        goto LABEL_112;
      }
      uint64_t v25 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))v17[1];
      if (v25)
      {
        uint64_t v26 = a7 ? a7 - v23 : 0;
        uint64_t v27 = v25(v17, v14, v13 + 2 * v24, a4 - v24, v10 + v23, v26, v76);
      }
      else
      {
        uint64_t v28 = a7 ? a7 - v23 : 0;
        uint64_t v27 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))*v17)(v14, v13 + 2 * v24, a4 - v24, v10 + v23, v28, v76);
      }
      uint64_t v29 = v27 + v24;
      uint64_t v30 = a4 - (v27 + v24);
      if (a4 > v27 + v24) {
        break;
      }
      v24 += v27;
      uint64_t v14 = v73;
LABEL_74:
      v23 += v76[0];
      uint64_t v10 = v72;
      if (v24 >= a4) {
        goto LABEL_112;
      }
    }
    uint64_t v70 = v27;
    uint64_t v75 = 0;
    if (v74 && v29 >= 1 && (CFIndex v67 = (unsigned __int16 *)(v13 + 2 * v29), v74(*v67)))
    {
      if (v69)
      {
        unint64_t v66 = v13;
        CFRange v68 = (void (**)(void))v17;
        CFIndex v64 = a5;
        UniChar v65 = a8;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        uint64_t v33 = v29;
        unint64_t v34 = v13 + 2 * v29;
        do
        {
          uint64_t v35 = v33;
          unint64_t v36 = v29 + v31;
          char v37 = v74(*(unsigned __int16 *)(v34 + 2 * v31 - 2));
          v32 += 2;
          --v31;
          if (v36 < 2) {
            break;
          }
          uint64_t v33 = v35 - 1;
        }
        while ((v37 & 1) != 0);
        unint64_t v13 = v66;
        uint64_t v38 = v66 + 2 * v29 - v32;
        uint64_t v39 = v76[0] + v23;
        if (*((unsigned __int16 *)*v68 + 8) < 2u)
        {
          uint64_t v23 = v39 - 1;
          uint64_t v48 = v70;
        }
        else
        {
          UniChar v40 = v68[1];
          if (v40) {
            v40();
          }
          else {
            (*(void (**)(void, unint64_t, uint64_t, void, void, void *))*v68)(v73, v66 + 2 * v29 - v32, -v31, 0, 0, v76);
          }
          uint64_t v23 = v39 - v76[0];
          uint64_t v48 = v70;
          uint64_t v38 = v66 + 2 * v29 - v32;
        }
        uint64_t v62 = a4 - v48 - v24;
        if (a7) {
          uint64_t v49 = a7 - v23;
        }
        else {
          uint64_t v49 = 0;
        }
        uint64_t v60 = v49;
        uint64_t v61 = (unsigned char *)(v72 + v23);
        uint64_t v50 = v69(v73, v38, v62 - v31);
        if (v50 < 1)
        {
          if ((v73 & 1) == 0)
          {
            uint64_t v29 = v70 + v24 + v31;
            uint64_t result = 1;
            a5 = v64;
            a8 = v65;
            uint64_t v17 = (uint64_t *)v68;
            goto LABEL_146;
          }
          if (v71)
          {
            do
            {
              uint64_t v42 = v35;
              if (v35 >= a4) {
                break;
              }
              char v51 = v74(*(unsigned __int16 *)(v66 + 2 * v35++));
            }
            while ((v51 & 1) != 0);
            v76[0] = 1;
            a8 = v65;
            uint64_t v14 = v73;
            if (a7) {
              *uint64_t v61 = v71;
            }
            a5 = v64;
            uint64_t v17 = (uint64_t *)v68;
            goto LABEL_73;
          }
          uint64_t v17 = (uint64_t *)v68;
          uint64_t v42 = ((uint64_t (*)(unint64_t, uint64_t, unsigned char *, uint64_t, void *))v68[4])(v66 + 2 * v29 - v32 + 2, ~v31 + v62, v61, v60, v76)+ v29+ v31+ 1;
          a5 = v64;
          a8 = v65;
        }
        else
        {
          uint64_t v42 = v50 + v29 + v31;
          if (v42 >= a4)
          {
            a5 = v64;
            a8 = v65;
            uint64_t v17 = (uint64_t *)v68;
          }
          else
          {
            uint64_t v63 = v50;
            a5 = v64;
            a8 = v65;
            uint64_t v17 = (uint64_t *)v68;
            if (v74(*(unsigned __int16 *)(v66 + 2 * v42)))
            {
              v23 += v76[0];
              uint64_t v29 = v70 + v24 + v63 + v31;
LABEL_145:
              uint64_t result = 1;
LABEL_146:
              LODWORD(v14) = v73;
LABEL_147:
              uint64_t v24 = v29;
              if (a7) {
                goto LABEL_113;
              }
              goto LABEL_126;
            }
          }
        }
        goto LABEL_72;
      }
      if (a7)
      {
        if (v76[0] + v23 == a7) {
          goto LABEL_143;
        }
        CFIndex v47 = (uint64_t (*)(uint64_t *, void, unsigned __int16 *, uint64_t, void, void, uint64_t *))v17[1];
        if (v47)
        {
          if (v47(v17, v73, v67, v30, 0, 0, &v75)) {
            goto LABEL_143;
          }
        }
        else if ((*(uint64_t (**)(void, unsigned __int16 *, uint64_t, void, void, uint64_t *))*v17)(v73, v67, v30, 0, 0, &v75))
        {
LABEL_143:
          v23 += v76[0];
          uint64_t result = 2;
          goto LABEL_146;
        }
      }
      if ((v73 & 0x20) != 0)
      {
        uint64_t v52 = v70 + v24 + 1;
        uint64_t v14 = v73;
        do
        {
          uint64_t v42 = v52;
          if (v52 >= a4) {
            break;
          }
          char v53 = v74(*(unsigned __int16 *)(v13 + 2 * v52));
          uint64_t v52 = v42 + 1;
        }
        while ((v53 & 1) != 0);
        goto LABEL_73;
      }
      v23 += v76[0];
      if (!v71)
      {
        size_t v43 = (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))v17[4];
        uint64_t v45 = v72 + v23;
        if (a7) {
          uint64_t v46 = a7 - v23;
        }
        else {
          uint64_t v46 = 0;
        }
        unint64_t v44 = v13 + 2 * v29;
        goto LABEL_71;
      }
    }
    else
    {
      if (a7)
      {
        if (v76[0] + v23 == a7) {
          goto LABEL_132;
        }
        unsigned int v41 = (uint64_t (*)(uint64_t *, void, unint64_t, uint64_t, void, void, uint64_t *))v17[1];
        if (v41)
        {
          if (v41(v17, v73, v13 + 2 * v29, v30, 0, 0, &v75)) {
            goto LABEL_132;
          }
        }
        else if ((*(uint64_t (**)(void, unint64_t, uint64_t, void, void, uint64_t *))*v17)(v73, v13 + 2 * v29, v30, 0, 0, &v75))
        {
LABEL_132:
          v23 += v76[0];
          LODWORD(v14) = v73;
          if ((v73 & 0xFF000001) == 1)
          {
            v76[0] = 0;
            do
            {
              uint64_t v57 = ((uint64_t (*)(unint64_t, uint64_t, void, void, void *))v17[4])(v13 + 2 * v29, a4 - v29, 0, 0, v76);
              if (!v57) {
                break;
              }
              uint64_t v58 = v76[0] ? 0 : v57;
              v29 += v58;
            }
            while (v29 < a4 && v76[0] == 0);
          }
          uint64_t result = 2 * (v29 < a4);
          goto LABEL_147;
        }
      }
      v23 += v76[0];
      if ((v73 & 1) == 0) {
        goto LABEL_145;
      }
      if (!v71)
      {
        size_t v43 = (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))v17[4];
        unint64_t v44 = v13 + 2 * v29;
        uint64_t v45 = v72 + v23;
        if (a7) {
          uint64_t v46 = a7 - v23;
        }
        else {
          uint64_t v46 = 0;
        }
LABEL_71:
        uint64_t v42 = v43(v44, v30, v45, v46, v76) + v29;
LABEL_72:
        uint64_t v14 = v73;
LABEL_73:
        uint64_t v24 = v42;
        goto LABEL_74;
      }
    }
    uint64_t v42 = v29 + 1;
    v76[0] = 1;
    if (a7) {
      *(unsigned char *)(v72 + v23) = v71;
    }
    goto LABEL_72;
  }
  uint64_t v24 = 0;
  uint64_t v23 = 0;
LABEL_112:
  uint64_t result = 0;
  if (a7)
  {
LABEL_113:
    if (v24 < a4 && !result)
    {
      if ((v14 & 0xFF000001) == 1)
      {
        v76[0] = 0;
        do
        {
          uint64_t v54 = ((uint64_t (*)(unint64_t, uint64_t, void, void, void *))v17[4])(v13 + 2 * v24, a4 - v24, 0, 0, v76);
          if (!v54) {
            break;
          }
          uint64_t v55 = v76[0] ? 0 : v54;
          v24 += v55;
        }
        while (v24 < a4 && v76[0] == 0);
      }
      uint64_t result = 2 * (v24 < a4);
    }
  }
LABEL_126:
  if (a8) {
    *a8 = v23;
  }
  if (a5) {
    *a5 = v24;
  }
  return result;
}

ConstStringPtr CFStringGetPascalStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    uint64_t v4 = 0;
    int v5 = *(_DWORD *)off_1ECE0A6F0;
    if ((~(unint64_t)theString & 0xC000000000000007) == 0) {
      LOBYTE(v5) = 0;
    }
    uint64_t v6 = (v5 ^ theString) & 7;
    while (v6 != *((unsigned __int8 *)off_1ECE0A6E0 + v4))
    {
      if (++v4 == 7) {
        goto LABEL_9;
      }
    }
    if (v4 == 2) {
      return 0;
    }
  }
LABEL_9:
  if (CF_IS_OBJC(7uLL, (unint64_t)theString)) {
    return 0;
  }
  char v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 4) == 0) {
    return 0;
  }
  char v8 = atomic_load((unint64_t *)&theString->info);
  if ((v8 & 0x10) != 0) {
    return 0;
  }
  int v9 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v9 = __CFDefaultEightBitStringEncoding;
  }
  if (v9 != encoding)
  {
    if (v9 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v9 = __CFDefaultEightBitStringEncoding;
    }
    if (v9 == 1536)
    {
      ConstStringPtr result = 0;
      switch(BYTE1(encoding))
      {
        case 0:
          ConstStringPtr result = 0;
          if ((encoding > 0x22 || ((1 << encoding) & 0x600000032) == 0) && encoding != 152) {
            goto LABEL_15;
          }
          return result;
        case 1:
          if (encoding != 134217984) {
            return 0;
          }
          goto LABEL_15;
        case 2:
          if (encoding == 518) {
            return 0;
          }
          goto LABEL_15;
        case 6:
          if (encoding != 1536) {
            return 0;
          }
          goto LABEL_15;
        case 8:
        case 0xC:
          return result;
        case 0xA:
          if (encoding - 2561 > 0xF) {
            goto LABEL_15;
          }
          int v18 = 1 << (encoding - 1);
          int v19 = 32785;
          goto LABEL_46;
        case 0xB:
          if (encoding - 3059 > 0xC) {
            goto LABEL_15;
          }
          int v18 = 1 << (encoding + 13);
          int v19 = 4099;
LABEL_46:
          if ((v18 & v19) != 0) {
            return 0;
          }
          goto LABEL_15;
        default:
          if ((encoding & 0xFF00) > 0xC00) {
            return 0;
          }
          goto LABEL_15;
      }
    }
    return 0;
  }
LABEL_15:
  char v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    ConstStringPtr result = (ConstStringPtr)*p_data;
  }
  else
  {
    char v13 = atomic_load((unint64_t *)&theString->info);
    ConstStringPtr result = (ConstStringPtr)&p_data[(v13 & 5) != 4];
  }
  char v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) != 4)
  {
    char v15 = atomic_load((unint64_t *)&theString->info);
    if ((v15 & 5) == 4)
    {
      uint64_t v16 = *result;
    }
    else
    {
      char v17 = atomic_load((unint64_t *)&theString->info);
      uint64_t v16 = (v17 & 0x60) != 0 ? theString->length : (uint64_t)*p_data;
    }
    if (v16 != *result) {
      return 0;
    }
  }
  return result;
}

uint64_t __CFToUTF8(char a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v6 = a4;
  char v7 = a2;
  if (a3 < 1)
  {
LABEL_45:
    if (!a6) {
      return v7 - a2;
    }
    goto LABEL_46;
  }
  unint64_t v8 = (unint64_t)&a2[a3];
  unint64_t v9 = (unint64_t)&a4[a5];
  char v10 = a2;
  uint64_t v6 = a4;
  while (1)
  {
    if (a5 && (unint64_t)v6 >= v9)
    {
LABEL_44:
      char v7 = v10;
      goto LABEL_45;
    }
    char v7 = v10 + 1;
    unsigned int v11 = *v10;
    if (v11 <= 0x7F)
    {
      if (a5) {
        unsigned char *v6 = v11;
      }
      uint64_t v12 = 1;
      goto LABEL_42;
    }
    if (v11 >> 11 >= 0x1B)
    {
      if (v11 >> 10 > 0x36)
      {
        if ((a1 & 0x80) == 0 && v11 < 0xE000) {
          goto LABEL_44;
        }
      }
      else if ((unint64_t)v7 < v8 && (int v13 = *v7, (v13 & 0xFC00) == 0xDC00))
      {
        char v7 = v10 + 2;
        unsigned int v11 = v13 + (v11 << 10) - 56613888;
      }
      else if ((a1 & 0x80) == 0)
      {
        goto LABEL_44;
      }
    }
    if (!a5)
    {
      if (v11 < 0x10000) {
        __int16 v16 = 3;
      }
      else {
        __int16 v16 = 4;
      }
      if (v11 < 0x800) {
        __int16 v16 = 2;
      }
      if (v11 >= 0x80) {
        unsigned __int16 v15 = v16;
      }
      else {
        unsigned __int16 v15 = 1;
      }
      goto LABEL_41;
    }
    if (v11 < 0x10000) {
      __int16 v14 = 3;
    }
    else {
      __int16 v14 = 4;
    }
    if (v11 < 0x800) {
      __int16 v14 = 2;
    }
    unsigned __int16 v15 = v11 >= 0x80 ? v14 : 1;
    if (v15 > (v9 - v6)) {
      break;
    }
    switch(v15)
    {
      case 1u:
        goto LABEL_32;
      case 2u:
        goto LABEL_31;
      case 3u:
        goto LABEL_30;
      case 4u:
        v6[3] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_30:
        v6[2] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_31:
        v6[1] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_32:
        unsigned char *v6 = firstByteMark[v15] | v11;
        break;
      default:
        break;
    }
LABEL_41:
    uint64_t v12 = v15;
LABEL_42:
    v6 += v12;
    char v10 = v7;
    if ((unint64_t)v7 >= v8) {
      goto LABEL_45;
    }
  }
  uint64_t v18 = -4;
  if (v11 < 0x10000) {
    uint64_t v18 = -2;
  }
  char v7 = (unsigned __int16 *)((char *)v7 + v18);
  if (a6) {
LABEL_46:
  }
    *a6 = v6 - a4;
  return v7 - a2;
}

uint64_t CFUniCharIsMemberOf(int a1, unsigned int a2)
{
  if (a2 - 16 >= 0x54) {
    unsigned int v2 = a2;
  }
  else {
    unsigned int v2 = a2 + 85;
  }
  if (a2 == 1) {
    unsigned int v3 = 108;
  }
  else {
    unsigned int v3 = v2;
  }
  if (v3 == 15)
  {
    BOOL v5 = (a1 - 8232) < 2 || a1 == 133;
    return (a1 - 10) < 4 || v5;
  }
  if (v3 != 3)
  {
    if (v3 == 2)
    {
      uint64_t v4 = 1;
      if (a1 > 159)
      {
        if (a1 == 160 || a1 == 5760) {
          return v4;
        }
      }
      else if (a1 == 9 || a1 == 32)
      {
        return v4;
      }
      if ((a1 - 0x2000) >= 0xC)
      {
        uint64_t v4 = 1;
        if (a1 == 8239 || a1 == 8287) {
          return v4;
        }
        goto LABEL_38;
      }
      return 1;
    }
    unsigned int v6 = v3 - 85;
    if (v3 <= 0x63) {
      unsigned int v6 = v3;
    }
    uint64_t v7 = v6 - 4;
    if (v7 > 0x15) {
      return 0;
    }
    unint64_t v8 = (unsigned int *)&__CFUniCharBitmapDataArray[2 * v7];
    if (v3 == 108)
    {
      unsigned int v10 = BYTE2(a1);
      if (BYTE2(a1) == 14)
      {
        BOOL v9 = a1 != 1 && a1 - 32 >= 0x60;
        return !v9;
      }
    }
    else
    {
      if (v3 == 12)
      {
        if (BYTE2(a1) == 14)
        {
          BOOL v9 = a1 == 1 || a1 - 128 >= 0xFFFFFFA0;
          return !v9;
        }
        if (BYTE2(a1) - 15 >= 2)
        {
          if (BYTE2(a1) < *v8)
          {
            uint64_t v12 = *(void *)(__CFUniCharBitmapDataArray[2 * v7 + 1] + 8 * BYTE2(a1));
            if (v12) {
              return ((*(unsigned __int8 *)(v12 + ((unsigned __int16)a1 >> 3)) >> (a1 & 7)) & 1) == 0;
            }
          }
          return 1;
        }
        return 0;
      }
      unsigned int v10 = BYTE2(a1);
    }
    if (v10 < *v8)
    {
      uint64_t v4 = *(void *)(__CFUniCharBitmapDataArray[2 * v7 + 1] + 8 * v10);
      if (v4) {
        return (*(unsigned __int8 *)(v4 + ((unsigned __int16)a1 >> 3)) >> (a1 & 7)) & 1;
      }
      return v4;
    }
    return 0;
  }
  uint64_t v4 = 1;
  if (a1 > 159)
  {
    if (a1 == 160 || a1 == 5760) {
      return v4;
    }
  }
  else if (a1 == 9 || a1 == 32)
  {
    return v4;
  }
  if ((a1 - 0x2000) < 0xC) {
    return 1;
  }
  uint64_t v4 = 1;
  if (a1 <= 8231)
  {
    if ((a1 - 10) >= 4 && a1 != 133) {
      return 0;
    }
    return v4;
  }
  if ((a1 - 8232) <= 0x37 && ((1 << (a1 - 40)) & 0x80000000000083) != 0) {
    return v4;
  }
LABEL_38:
  if (a1 != 12288) {
    return 0;
  }
  return v4;
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  if ((__CFDefaultSystemEncoding & 1) == 0)
  {
    if (__CFIsReadyToInitializeSystemEncoding)
    {
      if ((__CFStringIsBeingInitialized & 1) == 0)
      {
        __CFStringIsBeingInitialized = 1;
        uint64_t Converter = CFStringEncodingGetConverter(0);
        __CFDefaultCFStringEncoding SystemEncoding = 1;
        if (!Converter) {
          uint64_t Converter = CFStringEncodingGetConverter(0);
        }
        if (*((unsigned char *)Converter + 20) == 1) {
          uint64_t v1 = (_OWORD *)*((void *)Converter + 1);
        }
        else {
          uint64_t v1 = 0;
        }
        __CFSetCharToUniCharFunc(v1);
        __CFStringIsBeingInitialized = 0;
      }
    }
    else if (!__CFCharToUniCharFunc)
    {
      unsigned int v2 = CFStringEncodingGetConverter(0);
      __CFSetCharToUniCharFunc(*((_OWORD **)v2 + 1));
    }
  }
  return 0;
}

_OWORD *CFStringEncodingGetConverter(uint64_t a1)
{
  ConstStringPtr result = __CFGetConverter(a1);
  if (result) {
    return *(_OWORD **)result;
  }
  return result;
}

uint64_t CFCharacterSetInitInlineBuffer(unint64_t a1, uint64_t a2)
{
  unint64_t v3 = a1;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)a2 = a1;
  *(_DWORD *)(a2 + 16) = 0x10000;
  uint64_t result = CF_IS_OBJC(0x19uLL, a1);
  if (result && (uint64_t result = [(id)v3 _expandedCFCharacterSet], (v3 = result) == 0))
  {
    *(_DWORD *)(a2 + 8) = 2;
LABEL_24:
    *(_DWORD *)(a2 + 16) = 1114112;
  }
  else
  {
    unsigned int v5 = atomic_load((unint64_t *)(v3 + 8));
    switch((v5 >> 4) & 7)
    {
      case 0u:
        uint64_t result = CFUniCharGetBitmapPtrForPlane(*(_DWORD *)(v3 + 24), 0);
        *(void *)(a2 + 24) = result;
        *(_DWORD *)(a2 + 16) = 1114112;
        if (result)
        {
          char v9 = atomic_load((unint64_t *)(v3 + 8));
          if ((v9 & 8) == 0) {
            goto LABEL_22;
          }
          int v8 = 4;
        }
        else
        {
          int v8 = 2;
        }
        goto LABEL_21;
      case 1u:
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(v3 + 24);
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 24) + *(_DWORD *)(v3 + 32);
        char v10 = atomic_load((unint64_t *)(v3 + 8));
        if ((v10 & 8) != 0) {
          *(_DWORD *)(a2 + 8) = 4;
        }
        return result;
      case 2u:
        *(_DWORD *)(a2 + 8) = 2;
        if (*(uint64_t *)(v3 + 32) >= 1)
        {
          *(_DWORD *)(a2 + 12) = **(unsigned __int16 **)(v3 + 24);
          *(_DWORD *)(a2 + 16) = *(unsigned __int16 *)(*(void *)(v3 + 24) + 2 * *(void *)(v3 + 32) - 2) + 1;
          char v11 = atomic_load((unint64_t *)(v3 + 8));
          if ((v11 & 8) != 0)
          {
            int v12 = *(_DWORD *)(a2 + 12);
            int v13 = *(_DWORD *)(a2 + 16);
            if (v12)
            {
              if (v13 == 0x10000)
              {
                *(_DWORD *)(a2 + 12) = 0;
                *(_DWORD *)(a2 + 16) = v12;
              }
              else
              {
                *(void *)(a2 + 12) = 0x1000000000000;
              }
            }
            else
            {
              *(_DWORD *)(a2 + 12) = v13;
              *(_DWORD *)(a2 + 16) = 0x10000;
            }
          }
        }
        goto LABEL_22;
      case 3u:
      case 4u:
        uint64_t v6 = *(void *)(v3 + 24);
        *(void *)(a2 + 24) = v6;
        if (v6)
        {
          char v7 = atomic_load((unint64_t *)(v3 + 8));
          if ((v7 & 0x70) != 0x40) {
            goto LABEL_22;
          }
          int v8 = 1;
        }
        else
        {
          *(_DWORD *)(a2 + 8) = 1;
          uint64_t v14 = atomic_load((unint64_t *)(v3 + 8));
          if ((v14 & 8) == 0) {
            goto LABEL_22;
          }
          int v8 = *(_DWORD *)(a2 + 8) | 4;
        }
LABEL_21:
        *(_DWORD *)(a2 + 8) = v8;
LABEL_22:
        uint64_t v15 = *(void *)(v3 + 40);
        if (!v15) {
          return result;
        }
        if (*(unsigned char *)(v15 + 13)) {
          goto LABEL_24;
        }
        unsigned int v16 = *(_DWORD *)(v15 + 8);
        if (!v16) {
          return result;
        }
        int v17 = 1114112;
        uint64_t v18 = 15;
        break;
      default:
        return result;
    }
    while (1)
    {
      unint64_t v19 = v18 + 1;
      unsigned int v20 = (v18 + 1);
      if (v20 <= 0x10
        && ((v16 >> v19) & 1) != 0
        && *(unsigned __int8 *)(v15 + 12) >= v20
        && *(void *)(*(void *)v15 + 8 * v18))
      {
        break;
      }
      --v18;
      v17 -= 0x10000;
      if (v19 <= 1) {
        return result;
      }
    }
    *(_DWORD *)(a2 + 16) = v17;
  }
  return result;
}

uint64_t __CFToBytesCheapEightBitWrapper(unsigned int (***a1)(uint64_t, void, char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (a6 >= a4 || a6 == 0) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = a6;
  }
  if (v9 < 1)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    char v17 = 0;
    while ((**a1)(a2, *(unsigned __int16 *)(a3 + 2 * v15), &v17))
    {
      if (a6) {
        *(unsigned char *)(a5 + v15) = v17;
      }
      if (v9 == ++v15)
      {
        uint64_t v15 = v9;
        break;
      }
    }
  }
  *a7 = v15;
  return v15;
}

BOOL __CFToISOLatin1(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xFF) {
    *a3 = a2;
  }
  return a2 < 0x100;
}

uint64_t __CFToMacRoman(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1277) >= 0x59Du)
    {
      uint64_t v4 = (unsigned __int16 *)&macRoman_from_uni;
      unsigned int v5 = (unsigned __int16 *)&unk_182D9E3B4;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        char v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          uint64_t v4 = v7 + 2;
        }
        else
        {
          unsigned int v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFToASCII(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F) {
    *a3 = a2;
  }
  return a2 < 0x80;
}

uint64_t _netLocationRange(unsigned int a1, uint64_t a2)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  if ((a1 & 0x1E) == 0) {
    return -1;
  }
  long long v2 = xmmword_182D9EC80;
  long long v3 = xmmword_182D9EC80;
  if ((a1 & 2) != 0) {
    long long v3 = *(_OWORD *)(a2 + 16 * (a1 & 1));
  }
  v12[0] = v3;
  int v4 = (a1 >> 1) & 1;
  long long v5 = xmmword_182D9EC80;
  if ((a1 & 4) != 0) {
    long long v5 = *(_OWORD *)(a2 + 16 * (v4 + (a1 & 1)));
  }
  v12[1] = v5;
  long long v6 = xmmword_182D9EC80;
  if ((a1 & 8) != 0) {
    long long v6 = *(_OWORD *)(a2 + 16 * (((a1 >> 2) & 1) + v4 + (a1 & 1)));
  }
  v12[2] = v6;
  if ((a1 & 0x10) != 0)
  {
    unsigned int v7 = 0;
    unsigned int v8 = 16;
    do
    {
      char v9 = v8;
      v8 >>= 1;
      v7 += a1 & 1;
      a1 >>= 1;
    }
    while ((v9 & 2) == 0);
    long long v2 = *(_OWORD *)(a2 + 16 * v7);
  }
  uint64_t v10 = 0;
  v12[3] = v2;
  uint64_t result = -1;
  do
  {
    if (*(void *)&v12[v10] != -1 && result == -1) {
      uint64_t result = *(void *)&v12[v10];
    }
    ++v10;
  }
  while (v10 != 4);
  return result;
}

uint64_t CFStringEncodingIsValidCombiningCharacterForLatin1(int a1)
{
  if ((a1 - 768) > 0x5F) {
    return 0;
  }
  else {
    return (__CFLatin1CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

_OWORD *__CFSetCharToUniCharFunc(_OWORD *result)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  if ((_OWORD *)__CFCharToUniCharFunc != result)
  {
    uint64_t v1 = (uint64_t (*)(void, void, __int16 *))result;
    if (result)
    {
      uint64_t result = CFStringEncodingGetConverter(0);
      if (result && *((uint64_t (**)(void, void, __int16 *))result + 1) == v1)
      {
        __CFCharToUniCharTable = (uint64_t)__CFMacRomanCharToUnicharTable;
      }
      else
      {
        __CFCharToUniCharTable = (uint64_t)__CFMutableCharToUniCharTable;
        for (uint64_t i = 128; i != 256; ++i)
        {
          __int16 v4 = 0;
          uint64_t result = (_OWORD *)v1(0, i, &v4);
          if (result) {
            __int16 v3 = v4;
          }
          else {
            __int16 v3 = -3;
          }
          __CFMutableCharToUniCharTable[i] = v3;
        }
      }
      __CFCharToUniCharFunc = (uint64_t)v1;
    }
    else
    {
      __CFCharToUniCharTable = (uint64_t)&__CFIdempotentCharToUniCharTable;
    }
  }
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
  }
  return 42;
}

uint64_t _CompareLowerTestEntryPrefixToTableEntryKey(char **a1, unsigned char **a2)
{
  uint64_t v2 = (uint64_t)*a1;
  __int16 v3 = *a2;
  __darwin_ct_rune_t v5 = __tolower(**a1);
  __darwin_ct_rune_t v4 = v5 << 24;
  __darwin_ct_rune_t v5 = (char)v5;
  __darwin_ct_rune_t v6 = (char)*v3;
  int v7 = *v3;
  if ((char)v5 == v6)
  {
    BOOL v8 = !*v3 || v4 == 1593835520;
    __darwin_ct_rune_t v6 = (char)v5;
    if (!v8)
    {
      char v9 = (char *)(v2 + 1);
      uint64_t v10 = v3 + 1;
      do
      {
        __darwin_ct_rune_t v11 = *v9++;
        __darwin_ct_rune_t v5 = __tolower(v11);
        __darwin_ct_rune_t v4 = v5 << 24;
        __darwin_ct_rune_t v5 = (char)v5;
        __darwin_ct_rune_t v12 = *v10++;
        __darwin_ct_rune_t v6 = v12;
        int v7 = v12;
        if ((char)v5 != v12) {
          break;
        }
        BOOL v13 = !v7 || v4 == 1593835520;
        __darwin_ct_rune_t v6 = (char)v5;
      }
      while (!v13);
    }
  }
  if (v7)
  {
    uint64_t v14 = 0xFFFFFFFFLL;
    if (v4 != 1593835520)
    {
      if (v5 < v6) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1;
      }
    }
  }
  else
  {
    if (v4 < 0) {
      int v15 = __maskrune(v5, 0x500uLL);
    }
    else {
      int v15 = *((_DWORD *)off_1ECE0A578 + v5 + 15) & 0x500;
    }
    return v15 != 0;
  }
  return v14;
}

void __CFUUIDDeallocate(uint64_t a1)
{
  v1[5] = *(void *)off_1ECE0A5B0;
  v1[0] = off_1ECE0A5A0;
  v1[1] = 0x40000000;
  v1[2] = ____CFUUIDDeallocate_block_invoke;
  v1[3] = &__block_descriptor_tmp_3_0;
  v1[4] = a1;
  os_unfair_lock_lock_with_options();
  ____CFUUIDDeallocate_block_invoke((uint64_t)v1);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
}

void _CFBundleInfoPlistProcessInfoDictionary(void *a1)
{
  v7[7] = *(void *)off_1ECE0A5B0;
  if (a1 && CFDictionaryGetCount((CFDictionaryRef)a1))
  {
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    CFMutableDictionaryRef v3 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v7[0] = off_1ECE0A5A0;
    v7[1] = 0x40000000;
    void v7[2] = ___CFBundleInfoPlistProcessInfoDictionary_block_invoke;
    v7[3] = &__block_descriptor_tmp_27;
    v7[4] = Mutable;
    uint64_t v7[5] = v3;
    void v7[6] = a1;
    CFDictionaryApply(a1, (uint64_t)v7);
    if (CFArrayGetCount(Mutable) >= 1)
    {
      CFIndex v4 = 0;
      do
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v4);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, ValueAtIndex);
        ++v4;
      }
      while (v4 < CFArrayGetCount(Mutable));
    }
    v6[0] = off_1ECE0A5A0;
    v6[1] = 0x40000000;
    v6[2] = ___CFBundleInfoPlistProcessInfoDictionary_block_invoke_2;
    v6[3] = &__block_descriptor_tmp_28;
    v6[4] = a1;
    CFDictionaryApply(v3, (uint64_t)v6);
    CFRelease(Mutable);
    CFRelease(v3);
  }
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict removeObjectForKey:key];
  }
  else
  {
    char v4 = atomic_load((unint64_t *)theDict + 1);
    if ((v4 & 0x40) != 0)
    {
      char v9 = "void CFDictionaryRemoveValue(CFMutableDictionaryRef, const void *)";
      CFMutableDictionaryRef v10 = theDict;
      CFLog(3, @"%s(): immutable collection %p given to mutating function");
    }
    char v5 = atomic_load((unint64_t *)theDict + 1);
    if (v5)
    {
      __darwin_ct_rune_t v6 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        __darwin_ct_rune_t v6 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v6;
      }
      objc_msgSend(theDict, v6, key, v9, v10);
    }
    CFBasicHashRemoveValue((uint64_t)theDict, (unint64_t)key);
    char v7 = atomic_load((unint64_t *)theDict + 1);
    if (v7)
    {
      BOOL v8 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        BOOL v8 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v8;
      }
      objc_msgSend(theDict, v8, key);
    }
  }
}

uint64_t CFDictionaryApply(void *a1, uint64_t a2)
{
  v5[5] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x12uLL, (unint64_t)a1))
  {
    return [a1 enumerateKeysAndObjectsWithOptions:0 usingBlock:a2];
  }
  else
  {
    v5[0] = off_1ECE0A5A0;
    v5[1] = 3221225472;
    v5[2] = __CFDictionaryApply_block_invoke;
    v5[3] = &unk_1ECDABD20;
    _OWORD v5[4] = a2;
    return CFBasicHashApply((uint64_t)a1, (uint64_t)v5);
  }
}

void mdict_removeObjectForKey(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1 + 1;
  unint64_t v3 = (unint64_t)a1[2] >> 58;
  if (v3)
  {
    unint64_t v6 = LODWORD(__NSDictionarySizes_0[v3]);
    uint64_t v7 = *v2;
    uint64_t v20 = *v2 + 8 * v6;
    unint64_t v8 = 0;
    unint64_t v9 = [a2 hash] % v6;
    if (v6 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v6;
    }
    unint64_t v11 = v6;
    while (1)
    {
      __darwin_ct_rune_t v12 = *(void **)(v7 + 8 * v9);
      if (!v12) {
        break;
      }
      if (v12 == &___NSDictionaryM_DeletedMarker)
      {
        ++v8;
        if (v11 == v6) {
          unint64_t v11 = v9;
        }
      }
      else if (v12 == a2 || ([v12 isEqual:a2] & 1) != 0)
      {
        unint64_t v11 = v9;
        goto LABEL_21;
      }
      if (v9 + 1 >= v6) {
        unint64_t v13 = v6;
      }
      else {
        unint64_t v13 = 0;
      }
      unint64_t v9 = v9 + 1 - v13;
      if (!--v10) {
        goto LABEL_21;
      }
    }
    if (v11 == v6) {
      unint64_t v11 = v9;
    }
LABEL_21:
    if (v11 < v6)
    {
      unint64_t v14 = *(void *)(v7 + 8 * v11);
      if (v14 && v14 != (void)&___NSDictionaryM_DeletedMarker)
      {
        uint64_t v16 = a1[2];
        if ((v16 & 0x200000000000000) != 0) {
          [a1 willChangeValueForKey:a2];
        }
        uint64_t v19 = *(void *)(v20 + 8 * v11);
        *(void *)(v7 + 8 * v11) = &___NSDictionaryM_DeletedMarker;
        *(void *)(v20 + 8 * v11) = 0;
        a1[2] = a1[2] & 0xFE000000FFFFFFFFLL | ((((unint64_t)(a1[2] + 0x1FFFFFF00000000) >> 32) & 0x1FFFFFF) << 32);
        if (v8 > 0xF)
        {
          mdict_rehashd((uint64_t)a1, v3);
        }
        else
        {
          if (v11 + 1 < v6) {
            unint64_t v17 = v11 + 1;
          }
          else {
            unint64_t v17 = 0;
          }
          if (!*(void *)(v7 + 8 * v17))
          {
            do
            {
              *(void *)(v7 + 8 * v11) = 0;
              if (v11) {
                unint64_t v18 = v11;
              }
              else {
                unint64_t v18 = v6;
              }
              unint64_t v11 = v18 - 1;
            }
            while (*(_UNKNOWN **)(v7 + 8 * (v18 - 1)) == &___NSDictionaryM_DeletedMarker);
          }
        }
        if ((v16 & 0x200000000000000) != 0) {
          [a1 didChangeValueForKey:a2];
        }
        if ((v14 & 0x8000000000000000) == 0) {

        }
        if (v19 >= 1)
        {
        }
      }
    }
  }
}

void sub_182BCC318(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t CFBasicHashRemoveValue(uint64_t result, unint64_t a2)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  char v2 = atomic_load((unint64_t *)(result + 8));
  if ((v2 & 0x40) != 0) {
    goto LABEL_30;
  }
  unint64_t v3 = 0;
  if (a2 == 2780474809 || a2 == 2814029233) {
    return v3;
  }
  uint64_t v4 = result;
  long long v8 = 0u;
  long long v9 = 0u;
  if (!*(unsigned char *)(result + 26))
  {
    long long v8 = xmmword_182EDDE80;
    long long v9 = *(_OWORD *)algn_182EDDE90;
    goto LABEL_20;
  }
  int v5 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v5)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v8);
        break;
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v8);
        break;
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v8);
        break;
      default:
        goto LABEL_30;
    }
LABEL_20:
    unint64_t v3 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) < 2uLL)
    {
      if (*((void *)&v9 + 1) == 1) {
        __CFBasicHashRemoveValue(v4, v8);
      }
    }
    else
    {
      ++*(_WORD *)(v4 + 16);
      if (v3 <= 0x7FFFFFFFFFFFFFFELL)
      {
        unsigned int v6 = *(unsigned __int16 *)(v4 + 18);
        if ((v6 & 0x18) != 0)
        {
          uint64_t v7 = *(void *)(v4 + (v6 & 0x18) + 40);
          switch((v6 >> 5) & 3)
          {
            case 1u:
              --*(_WORD *)(v7 + 2 * v8);
              break;
            case 2u:
              --*(_DWORD *)(v7 + 4 * v8);
              break;
            case 3u:
              --*(void *)(v7 + 8 * v8);
              break;
            default:
              --*(unsigned char *)(v7 + v8);
              break;
          }
        }
      }
    }
    return v3;
  }
  switch(v5)
  {
    case 3:
      ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v8);
      goto LABEL_20;
    case 2:
      ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v8);
      goto LABEL_20;
    case 1:
      ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v8);
      goto LABEL_20;
  }
LABEL_30:
  __break(1u);
  return result;
}

void __CFBasicHashRehash(uint64_t cf, uint64_t a2)
{
  unint64_t v5 = BYTE2(*(void *)(cf + 24));
  unint64_t v6 = v5;
  if (!a2) {
    goto LABEL_9;
  }
  uint64_t v7 = 0;
  unint64_t v2 = *(void *)(cf + 32);
  unint64_t v3 = (uint64_t *)(a2 & ~(a2 >> 63));
  do
  {
    if (__CFBasicHashTableCapacities[v7] >= (uint64_t)v3 + *(unsigned int *)(cf + 20)) {
      goto LABEL_6;
    }
    ++v7;
  }
  while (v7 != 64);
  do
  {
    while (1)
    {
      do
      {
        while (1)
        {
          do
          {
            while (1)
            {
LABEL_5:
              __break(1u);
LABEL_6:
              unint64_t v2 = ((v2 >> 2) & 1) + v7;
              if (v3 == (uint64_t *)1) {
                unint64_t v6 = v2;
              }
              else {
                unint64_t v6 = v7;
              }
LABEL_9:
              uint64_t v8 = __CFBasicHashTableSizes[v6];
              uint64_t v9 = __CFBasicHashTableSizes[v5];
              if (v8 < 1)
              {
                uint64_t Typed = 0;
                uint64_t v12 = 0;
LABEL_32:
                uint64_t v19 = 0;
                goto LABEL_37;
              }
              if ((unint64_t)(v8 - 0x1000000000000000) >> 61 != 7) {
                __CFBasicHashRehash_cold_1();
              }
              uint64_t v10 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
              if (!__CFAllocatorRespectsHintZeroWhenAllocating(v10)) {
                break;
              }
              uint64_t Typed = CFAllocatorAllocateTyped(v10, 8 * v8, 3506094911, 1);
              if (Typed) {
                goto LABEL_17;
              }
            }
            unint64_t v13 = (void *)CFAllocatorAllocateTyped(v10, 8 * v8, 3112355480, 0);
          }
          while (!v13);
          uint64_t Typed = (uint64_t)v13;
          bzero(v13, 8 * v8);
LABEL_17:
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          if ((*(_WORD *)(cf + 18) & 4) == 0)
          {
            uint64_t v12 = 0;
            goto LABEL_28;
          }
          unint64_t v14 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
          if (!__CFAllocatorRespectsHintZeroWhenAllocating(v14)) {
            break;
          }
          uint64_t v12 = CFAllocatorAllocateTyped(v14, 8 * v8, 3506094911, 1);
          if (v12) {
            goto LABEL_26;
          }
        }
        int v15 = (void *)CFAllocatorAllocateTyped(v14, 8 * v8, 3112355480, 0);
      }
      while (!v15);
      uint64_t v12 = (uint64_t)v15;
      bzero(v15, 8 * v8);
LABEL_26:
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
LABEL_28:
      unint64_t v16 = *(unsigned __int16 *)(cf + 18);
      if ((v16 & 0x18) == 0) {
        goto LABEL_32;
      }
      size_t v17 = v8 << ((v16 >> 5) & 3);
      unint64_t v18 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
      if (!__CFAllocatorRespectsHintZeroWhenAllocating(v18)) {
        break;
      }
      uint64_t v19 = CFAllocatorAllocateTyped(v18, v17, 3506094911, 1);
      if (v19) {
        goto LABEL_35;
      }
    }
    uint64_t v20 = (void *)CFAllocatorAllocateTyped(v18, v17, 3112355480, 0);
  }
  while (!v20);
  uint64_t v19 = (uint64_t)v20;
  bzero(v20, v17);
LABEL_35:
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
LABEL_37:
  *(void *)(cf + 24) = *(void *)(cf + 24) & 0xFFFFFFFFFF000000 | ((unint64_t)v6 << 16);
  uint64_t v21 = *(void **)(cf + 40);
  *(void *)(cf + 40) = Typed;
  unint64_t v22 = *(unsigned __int16 *)(cf + 18);
  if ((v22 & 4) != 0)
  {
    uint64_t v24 = (char *)(cf + 8 * ((v22 >> 2) & 1));
    uint64_t v23 = (void *)*((void *)v24 + 5);
    *((void *)v24 + 5) = v12;
  }
  else
  {
    uint64_t v23 = 0;
  }
  if ((v22 & 0x18) != 0)
  {
    uint64_t v25 = (char *)(cf + (v22 & 0x18));
    int8x16_t ptr = (_WORD *)*((void *)v25 + 5);
    *((void *)v25 + 5) = v19;
  }
  else
  {
    int8x16_t ptr = 0;
  }
  if (v9 >= 1)
  {
    uint64_t v26 = 0;
    if (v19) {
      BOOL v27 = ptr == 0;
    }
    else {
      BOOL v27 = 1;
    }
    int v28 = !v27;
    int v53 = v28;
    do
    {
      uint64_t v29 = v21[v26];
      if ((unint64_t)(v29 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v29 == 2814029233) {
          uint64_t v29 = 0;
        }
        if (v29 == 2780474809) {
          uint64_t v30 = -1;
        }
        else {
          uint64_t v30 = v29;
        }
        unint64_t v31 = v30;
        if (v23)
        {
          unint64_t v32 = v23[v26];
          if (v32 == 2814029233) {
            unint64_t v32 = 0;
          }
          if (v32 == 2780474809) {
            unint64_t v31 = -1;
          }
          else {
            unint64_t v31 = v32;
          }
        }
        uint64_t v33 = *(void *)(cf + 24);
        if (*(__int16 *)(cf + 18) < 0)
        {
          unint64_t v34 = *(void *)(cf + 32);
          unint64_t v3 = CFBasicHashCallBackPtrs;
          unint64_t v2 = CFBasicHashCallBackPtrs[(v34 >> 54) >> 5];
          uint64_t v35 = *(uint64_t (**)(uint64_t))(v2 + 8 * ((v34 >> 54) & 0x1F));
          if (v35)
          {
            unint64_t v31 = v35(v30);
            uint64_t v33 = *(void *)(cf + 24);
          }
          else
          {
            unint64_t v31 = v30;
          }
        }
        if ((v33 & 0xFF0000) != 0)
        {
          uint64_t v7 = *(unsigned __int16 *)(cf + 18);
          unint64_t v5 = v7 & 3;
          if ((v7 & 0x8000) != 0)
          {
            switch(v5)
            {
              case 3:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(cf, v31);
                break;
              case 2:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(cf, v31);
                break;
              case 1:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(cf, v31);
                break;
              default:
                goto LABEL_5;
            }
          }
          else
          {
            switch(v5)
            {
              case 3:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(cf, v31);
                break;
              case 2:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(cf, v31);
                break;
              case 1:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(cf, v31);
                break;
              default:
                goto LABEL_5;
            }
          }
          uint64_t v37 = Bucket_Exponential_Indirect_NoCollision;
        }
        else
        {
          uint64_t v37 = -1;
        }
        uint64_t v38 = *(void *)(cf + 40);
        uint64_t v39 = *(void *)(v38 + 8 * v37);
        if (v30) {
          unint64_t v2 = v30;
        }
        else {
          unint64_t v2 = 2814029233;
        }
        if (v2 == -1) {
          unint64_t v2 = 2780474809;
        }
        *(void *)(v38 + 8 * v37) = v2;
        uint64_t v7 = v39 + 1;
        if ((unint64_t)(v39 + 1) >= 2)
        {
          if (v39 == 2814029233) {
            uint64_t v39 = 0;
          }
          if (v39 == 2780474809) {
            uint64_t v40 = -1;
          }
          else {
            uint64_t v40 = v39;
          }
          if ((*(void *)(cf + 32) & 2) == 0)
          {
            unint64_t v41 = *(void *)(cf + 24);
            unint64_t v2 = (unint64_t)CFBasicHashCallBackPtrs;
            uint64_t v7 = *(uint64_t *)((char *)CFBasicHashCallBackPtrs + (HIBYTE(v41) & 0xF8));
            uint64_t v42 = *(void (**)(const CFAllocatorRef, uint64_t))(v7 + 8 * ((v41 >> 54) & 0x1F));
            if (v42)
            {
              size_t v43 = &kCFAllocatorSystemDefault;
              if ((cf & 0x8000000000000000) == 0)
              {
                char v44 = atomic_load((unint64_t *)(cf + 8));
                BOOL v27 = (v44 & 0x80) == 0;
                size_t v43 = (const CFAllocatorRef *)(cf - 16);
                if (!v27) {
                  size_t v43 = &kCFAllocatorSystemDefault;
                }
              }
              v42(*v43, v40);
            }
          }
        }
        if (v23)
        {
          unint64_t v5 = *(unsigned __int16 *)(cf + 18);
          if ((v5 & 4) == 0) {
            goto LABEL_5;
          }
          uint64_t v45 = *(void *)(cf + 8 * ((v5 >> 2) & 1) + 40);
          uint64_t v46 = *(void *)(v45 + 8 * v37);
          if (v31) {
            unint64_t v2 = v31;
          }
          else {
            unint64_t v2 = 2814029233;
          }
          if (v2 == -1) {
            unint64_t v2 = 2780474809;
          }
          *(void *)(v45 + 8 * v37) = v2;
          if ((unint64_t)(v46 + 1) >= 2)
          {
            if (v46 == 2814029233) {
              uint64_t v46 = 0;
            }
            if (v46 == 2780474809) {
              uint64_t v47 = -1;
            }
            else {
              uint64_t v47 = v46;
            }
            if ((*(void *)(cf + 32) & 2) == 0)
            {
              unint64_t v2 = (unint64_t)CFBasicHashCallBackPtrs;
              uint64_t v48 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 49) & 0x1FLL]
                                                                         + 8 * ((*(void *)(cf + 24) >> 44) & 0x1FLL));
              if (v48)
              {
                uint64_t v49 = &kCFAllocatorSystemDefault;
                if ((cf & 0x8000000000000000) == 0)
                {
                  char v50 = atomic_load((unint64_t *)(cf + 8));
                  BOOL v27 = (v50 & 0x80) == 0;
                  uint64_t v49 = (const CFAllocatorRef *)(cf - 16);
                  if (!v27) {
                    uint64_t v49 = &kCFAllocatorSystemDefault;
                  }
                }
                v48(*v49, v47);
              }
            }
          }
        }
        if (v53)
        {
          switch((*(unsigned __int16 *)(cf + 18) >> 5) & 3)
          {
            case 1:
              *(_WORD *)(v19 + 2 * v37) = ptr[v26];
              break;
            case 2:
              *(_DWORD *)(v19 + 4 * v37) = *(_DWORD *)&ptr[2 * v26];
              break;
            case 3:
              *(void *)(v19 + 8 * v37) = *(void *)&ptr[4 * v26];
              break;
            default:
              *(unsigned char *)(v19 + v37) = *((unsigned char *)ptr + v26);
              break;
          }
        }
      }
      ++v26;
    }
    while (v9 != v26);
  }
  CFAllocatorRef v51 = CFGetAllocator((CFTypeRef)cf);
  CFAllocatorDeallocate(v51, v21);
  CFAllocatorDeallocate(v51, v23);
  CFAllocatorDeallocate(v51, ptr);

  CFAllocatorDeallocate(v51, 0);
}

uint64_t ___CFBasicHashFindBucket_Linear_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = *(unsigned __int16 *)(a1 + 18);
  if ((v5 & 4) != 0) {
    unint64_t v6 = (uint64_t *)(a1 + 40 + 8 * ((v5 >> 2) & 1));
  }
  else {
    unint64_t v6 = (uint64_t *)(a1 + 40);
  }
  if (!v3) {
    return -1;
  }
  uint64_t v7 = *v6;
  uint64_t result = a2 % v3;
  unint64_t v9 = v3;
  while (*(void *)(v7 + 8 * result))
  {
    if (v3 <= result + 1) {
      unint64_t v10 = v3;
    }
    else {
      unint64_t v10 = 0;
    }
    uint64_t result = result + 1 - v10;
    if (!--v9) {
      return -1;
    }
  }
  return result;
}

void __CFBasicHashRemoveValue(uint64_t cf, uint64_t a2)
{
  ++*(_WORD *)(cf + 16);
  uint64_t v4 = *(void *)(cf + 40);
  uint64_t v5 = *(void *)(v4 + 8 * a2);
  *(void *)(v4 + 8 * a2) = -1;
  if ((unint64_t)(v5 + 1) >= 2)
  {
    if (v5 == 2814029233) {
      uint64_t v5 = 0;
    }
    if (v5 == 2780474809) {
      uint64_t v6 = -1;
    }
    else {
      uint64_t v6 = v5;
    }
    if ((*(void *)(cf + 32) & 2) == 0)
    {
      uint64_t v7 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                             + (HIBYTE(*(void *)(cf + 24)) & 0xF8))
                                                                + 8 * ((*(void *)(cf + 24) >> 54) & 0x1FLL));
      if (v7)
      {
        if (cf < 0)
        {
          uint64_t v8 = &kCFAllocatorSystemDefault;
        }
        else
        {
          char v9 = atomic_load((unint64_t *)(cf + 8));
          if (v9 < 0) {
            uint64_t v8 = &kCFAllocatorSystemDefault;
          }
          else {
            uint64_t v8 = (const CFAllocatorRef *)(cf - 16);
          }
        }
        v7(*v8, v6);
      }
    }
  }
  unint64_t v10 = *(unsigned __int16 *)(cf + 18);
  if ((v10 & 4) != 0)
  {
    uint64_t v11 = *(void *)(cf + 8 * ((v10 >> 2) & 1) + 40);
    uint64_t v12 = *(void *)(v11 + 8 * a2);
    *(void *)(v11 + 8 * a2) = -1;
    if ((unint64_t)(v12 + 1) >= 2)
    {
      if (v12 == 2814029233) {
        uint64_t v12 = 0;
      }
      if (v12 == 2780474809) {
        uint64_t v13 = -1;
      }
      else {
        uint64_t v13 = v12;
      }
      if ((*(void *)(cf + 32) & 2) == 0)
      {
        unint64_t v14 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 49) & 0x1FLL]
                                                                   + 8 * ((*(void *)(cf + 24) >> 44) & 0x1FLL));
        if (v14)
        {
          if (cf < 0 || (char v15 = atomic_load((unint64_t *)(cf + 8)), v15 < 0)) {
            unint64_t v16 = &kCFAllocatorSystemDefault;
          }
          else {
            unint64_t v16 = (const CFAllocatorRef *)(cf - 16);
          }
          v14(*v16, v13);
        }
      }
    }
  }
  unsigned int v17 = *(unsigned __int16 *)(cf + 18);
  if ((v17 & 0x18) != 0)
  {
    uint64_t v18 = *(void *)(cf + (v17 & 0x18) + 40);
    switch((v17 >> 5) & 3)
    {
      case 1u:
        --*(_WORD *)(v18 + 2 * a2);
        break;
      case 2u:
        --*(_DWORD *)(v18 + 4 * a2);
        break;
      case 3u:
        --*(void *)(v18 + 8 * a2);
        break;
      default:
        --*(unsigned char *)(v18 + a2);
        break;
    }
  }
  unsigned int v19 = *(_DWORD *)(cf + 20) - 1;
  *(_DWORD *)(cf + 20) = v19;
  uint64_t v20 = *(void *)(cf + 24);
  uint64_t v21 = *(void *)(cf + 32);
  unsigned int v22 = BYTE2(v20);
  unint64_t v23 = v20 & 0xFFFFFFFFFFFF0000 | (unsigned __int16)(v20 + 1);
  *(void *)(cf + 24) = v23;
  if ((v21 & 4) != 0)
  {
    if (v22 < 6) {
      goto LABEL_41;
    }
    unsigned int v24 = v22 - 5;
  }
  else
  {
    if (v22 < 3) {
      goto LABEL_41;
    }
    unsigned int v24 = v22 - 2;
  }
  if (__CFBasicHashTableCapacities[v24] > (uint64_t)v19)
  {
    uint64_t v25 = -1;
LABEL_49:
    __CFBasicHashRehash(cf, v25);
    return;
  }
LABEL_41:
  unint64_t v26 = (unsigned __int16)v23;
  if (!(_WORD)v23
    || ((uint64_t v27 = __CFBasicHashTableSizes[BYTE2(v23)], v27 >= 20) ? (v28 = (unint64_t)v27 >> 2 > v26) : (v28 = 1),
        !v28))
  {
    uint64_t v25 = 0;
    goto LABEL_49;
  }
}

uint64_t CFStringHashCString(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0;
    uint64_t v3 = a2;
    do
    {
      uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5])
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 2]));
      BOOL v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 3))
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7))
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 1)))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 2)));
      uint64_t v9 = v7 - 16;
      v7 += 4;
    }
    while (v9 < 12);
    unint64_t v10 = &a1[a2 - 32];
    do
    {
      uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v10)
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[2]));
      v10 += 4;
    }
    while (v10 < &a1[a2]);
  }
  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      unint64_t v2 = a1;
      uint64_t v4 = a1;
      uint64_t v3 = a2;
    }
    else
    {
      unint64_t v2 = a1;
      uint64_t v3 = a2;
      uint64_t v4 = a1;
      do
      {
        uint64_t v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[3])
           + 67503105 * v3
           + 257
           * (257
            * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v4)
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[1]))
            + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[2]));
        v4 += 4;
        v2 += 4;
      }
      while (v4 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }
    if (v4 < &a1[a2])
    {
      uint64_t v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        unsigned int v12 = *v4++;
        uint64_t v3 = 257 * v3 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v12);
        --v11;
      }
      while (v11);
    }
  }
  return (v3 << (a2 & 0x1F)) + v3;
}

CFHashCode _dependentNotificationHash(CFTypeRef **a1)
{
  return CFHash(**a1);
}

CFHashCode __CFRunLoopModeHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 80));
}

uint64_t typeStringHash(char *a1)
{
  size_t v2 = strlen(a1);

  return CFStringHashCString((unsigned __int8 *)a1, v2);
}

uint64_t __CFDataHash(unint64_t *a1)
{
  char v1 = atomic_load(a1 + 1);
  if ((v1 & 4) != 0) {
    unint64_t v2 = ((unint64_t)a1 + 63) & 0xFFFFFFFFFFFFFFF0;
  }
  else {
    unint64_t v2 = a1[5];
  }
  if ((uint64_t)a1[2] >= 80) {
    uint64_t v3 = 80;
  }
  else {
    uint64_t v3 = a1[2];
  }
  return CFHashBytes(v2, v3);
}

uint64_t __CFBooleanHash(__objc2_class **a1)
{
  if (&__kCFBooleanTrue == a1) {
    return 2654435761;
  }
  else {
    return 0;
  }
}

uint64_t __CFRunLoopSourceHash(uint64_t a1)
{
  char v1 = *(uint64_t (**)(uint64_t))(a1 + 152);
  uint64_t result = *(void *)(a1 + 112);
  if (v1) {
    return v1(result);
  }
  return result;
}

void *__CFAllocatorSystemAllocate(size_t size, uint64_t a2, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }
  if (a2 == 1)
  {
    return malloc_type_zone_calloc(zone, 1uLL, size, 0x53AEF0D3uLL);
  }
  else
  {
    return malloc_type_zone_malloc(zone, size, 0xD90F5EB9uLL);
  }
}

uint64_t __CFhashUUIDBytes(uint64_t a1)
{
  return CFHashBytes(a1, 16);
}

uint64_t _cfmp_hash(uint64_t result)
{
  if (result) {
    return 2654435761 * (*(unsigned __int8 *)(result + 4) | (*(_DWORD *)result << 8));
  }
  return result;
}

uint64_t __CFMachPortHash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t CFStringHashNSString(void *a1)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = [a1 length];
  uint64_t v3 = v2;
  uint64_t v4 = v9;
  if (v2 >= 97)
  {
    objc_msgSend(a1, "getCharacters:range:", v9, 0, 32);
    objc_msgSend(a1, "getCharacters:range:", &v10, ((unint64_t)v2 >> 1) - 16, 32);
    objc_msgSend(a1, "getCharacters:range:", &v11, v2 - 32, 32);
    unint64_t v5 = (unsigned __int16 *)&v12;
    BOOL v6 = (unsigned __int16 *)&v12;
LABEL_5:
    uint64_t v4 = v9;
    do
    {
      uint64_t v3 = v4[3] + 67503105 * v3 + 257 * (257 * (257 * *v4 + v4[1]) + v4[2]);
      v4 += 4;
    }
    while (v4 < v6);
    goto LABEL_9;
  }
  objc_msgSend(a1, "getCharacters:range:", v9, 0, v2);
  unint64_t v5 = &v9[v2];
  if ((uint64_t)(v2 & 0xFFFFFFFFFFFFFFFCLL) >= 1)
  {
    BOOL v6 = &v9[v2 & 0xFFFFFFFFFFFFFFFCLL];
    goto LABEL_5;
  }
LABEL_9:
  while (v4 < v5)
  {
    unsigned int v7 = *v4++;
    uint64_t v3 = 257 * v3 + v7;
  }
  return (v3 << (v2 & 0x1F)) + v3;
}

void _cfmp_deallocation_record_release(int a1, int *a2)
{
  if ((*((unsigned char *)a2 + 5) & 1) == 0) {
    _cfmp_log_failure((uint64_t)"Freeing a record not in the set", a2, *((unsigned __int8 *)a2 + 4), *a2);
  }

  free(a2);
}

uint64_t compareHashesAscending(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void __CFStringClose(uint64_t a1)
{
  unint64_t v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 80) = 0;
  }
  unint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 88) = 0;
  }
  if ((*(unsigned char *)(a1 + 8) & 0x20) != 0)
  {
    CFRelease(*(CFTypeRef *)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
}

CFBit CFBitVectorGetBitAtIndex(CFBitVectorRef bv, CFIndex idx)
{
  return (*(unsigned __int8 *)(*((void *)bv + 4) + idx / 8) >> (~(_BYTE)idx & 7)) & 1;
}

uint64_t _registrar_compare(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void *)(a2 + 48);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(unint64_t *a1, void *a2, __CFString *a3, __CFString *a4, const __CFArray *a5, int a6, CFTypeRef *a7)
{
  uint64_t v50 = *(void *)off_1ECE0A5B0;
  char key = a2;
  __CFCheckCFInfoPACSignature((uint64_t)a1);
  unint64_t v14 = _CFGetNonObjCTypeID(a1);
  if (v14 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v14);
  }
  if (a2)
  {
    CFBundleAllowMixedLocalizations();
    if (!a4 || CFEqual(a4, &stru_1ECE10768)) {
      a4 = @"Localizable";
    }
    char v15 = [[NSSet alloc] initWithObjects:&key count:1];
    CFTypeRef cf = 0;
    CFDictionaryRef v16 = _copyStringTable((uint64_t)a1, a4, v15, a5, a6, &cf);
    if (v16)
    {
      CFDictionaryRef v17 = v16;
      CFArrayRef Value = (__CFString *)CFDictionaryGetValue(v16, key);
      if (Value)
      {
        MutableCFStringRef Copy = Value;
        CFRetain(Value);
        CFRelease(v17);

        goto LABEL_27;
      }
      CFRelease(v17);
    }

    if (a3 && !CFEqual(a3, &stru_1ECE10768)) {
      uint64_t v21 = a3;
    }
    else {
      uint64_t v21 = key;
    }
    CFStringRef v23 = (const __CFString *)CFRetain(v21);
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once != -1) {
      dispatch_once(&_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once, &__block_literal_global_38);
    }
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_capitalize)
    {
      MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v23);
      unsigned int v24 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412802;
        uint64_t v39 = key;
        __int16 v40 = 2112;
        unint64_t v41 = a4;
        __int16 v42 = 2112;
        size_t v43 = a1;
        _os_log_error_impl(&dword_182B90000, v24, OS_LOG_TYPE_ERROR, "ERROR: %@ not found in table %@ of bundle %@", buf, 0x20u);
      }
      CFStringUppercase(MutableCopy, 0);
      CFRelease(v23);
    }
    else
    {
      MutableCFStringRef Copy = (CFMutableStringRef)v23;
    }
LABEL_27:
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once_10 != -1) {
      dispatch_once(&_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once_10, &__block_literal_global_13_1);
    }
    if (CFStringGetLength(MutableCopy) >= 1)
    {
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_doubleStrings == 1)
      {
        CFMutableStringRef v25 = _CFDoubledStringCreate(MutableCopy);
        CFRelease(MutableCopy);
        MutableCFStringRef Copy = v25;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_accentuateStrings == 1)
      {
        CFStringRef v26 = _CFAccentuatedStringCreate(MutableCopy);
        CFRelease(MutableCopy);
        MutableCFStringRef Copy = (CFMutableStringRef)v26;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_forceRightToLeftStrings == 1)
      {
        CFStringRef v27 = _CFRLORightToLeftStringCreate((uint64_t)MutableCopy);
        CFRelease(MutableCopy);
        MutableCFStringRef Copy = (CFMutableStringRef)v27;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_surroundStrings == 1)
      {
        CFStringRef v28 = _CFAffixedStringCreate((uint64_t)MutableCopy, @"[# ", @" #]");
        CFRelease(MutableCopy);
        MutableCFStringRef Copy = (CFMutableStringRef)v28;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_tallStrings == 1)
      {
        CFStringRef v29 = _CFTallStringCreate((uint64_t)MutableCopy);
        CFRelease(MutableCopy);
        MutableCFStringRef Copy = (CFMutableStringRef)v29;
      }
    }
    if (!a6 && MutableCopy)
    {
      uint64_t v30 = _CFStringCreateByParsingMarkdownAndInflectingIfNeeded(MutableCopy, (__CFBundle *)a1, (uint64_t)cf);
      CFRelease(MutableCopy);
      MutableCFStringRef Copy = (CFMutableStringRef)v30;
    }
    if (a7)
    {
      *a7 = cf;
    }
    else if (cf)
    {
      CFRelease(cf);
    }
    if (a5 && (unint64_t v31 = _CFBundleLocalizedStringLogger(), os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)))
    {
      CFArrayRef Mutable = CFStringCreateMutable(0, 0);
      CFStringAppend(Mutable, @"[");
      if (CFArrayGetCount(a5) >= 1)
      {
        CFIndex v33 = 0;
        do
        {
          if (v33) {
            CFStringAppend(Mutable, @", ");
          }
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a5, v33);
          CFStringAppend(Mutable, ValueAtIndex);
          ++v33;
        }
        while (v33 < CFArrayGetCount(a5));
      }
      CFStringAppend(Mutable, @"]");
    }
    else
    {
      CFArrayRef Mutable = 0;
    }
    uint64_t v35 = _CFBundleLocalizedStringLogger();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138479107;
      uint64_t v39 = a1;
      __int16 v40 = 2114;
      unint64_t v41 = key;
      __int16 v42 = 2114;
      size_t v43 = (unint64_t *)a3;
      __int16 v44 = 2114;
      uint64_t v45 = a4;
      __int16 v46 = 2114;
      uint64_t v47 = Mutable;
      __int16 v48 = 2114;
      CFMutableStringRef v49 = MutableCopy;
      _os_log_debug_impl(&dword_182B90000, v35, OS_LOG_TYPE_DEBUG, "Bundle: %{private}@, key: %{public}@, value: %{public}@, table: %{public}@, localizationNames: %{public}@, result: %{public}@", buf, 0x3Eu);
      if (!Mutable) {
        return MutableCopy;
      }
    }
    else if (!Mutable)
    {
      return MutableCopy;
    }
    CFRelease(Mutable);
    return MutableCopy;
  }
  if (a3) {
    uint64_t v20 = a3;
  }
  else {
    uint64_t v20 = &stru_1ECE10768;
  }

  return (CFMutableStringRef)CFRetain(v20);
}

void sub_182BCF4E4(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BCF9E0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t __NSSetM_copy(uint64_t Function, uint64_t a2)
{
  uint64_t v3 = Function;
  v15[1] = *(void *)off_1ECE0A5B0;
  if (__cf_tsanReadFunction) {
    Functiouint64_t n = __cf_tsanReadFunction(Function, v2, __CFTSANTagMutableSet);
  }
  uint64_t v4 = *(_DWORD *)(v3 + 28) & 0x3FFFFFF;
  if (atomic_load((unint64_t *)(v3 + 8)))
  {
    if (v4 >= 2) {
      goto LABEL_5;
    }
LABEL_10:
    MEMORY[0x1F4188790](Function, a2);
    uint64_t v13 = (char *)v15 - v12;
    [(id)v3 getObjects:(char *)v15 - v12 count:v4];
    return [objc_allocWithZone((Class)NSSet) initWithObjects:v13 count:v4];
  }
  if (v4 <= 3) {
    goto LABEL_10;
  }
LABEL_5:
  if (!atomic_load((unint64_t *)(v3 + 8)))
  {
    unsigned int v7 = _cow_create(v3, 1);
    uint64_t v8 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(v3 + 8), (unint64_t *)&v8, (unint64_t)v7);
    if (v8) {
      free(v7);
    }
  }
  uint64_t v9 = (objc_class *)self;
  id v10 = __CFAllocateObject(v9, 0);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)(v3 + 8));
  _cow_copy(v3, 1, v11, (uint64_t)__NSSet_cowCallbacks, (uint64_t)v10, 0);
  return (uint64_t)v10;
}

unint64_t *__NSSetM_new(uint64_t a1, unint64_t a2, char a3)
{
  int v4 = 0;
  unint64_t v5 = 0;
  while (__NSSetCapacities_0[v5 / 2] < a2)
  {
    v5 += 2;
    v4 -= 0x4000000;
    if (v5 == 128)
    {
      __break(1u);
      break;
    }
  }
  unint64_t v6 = __NSSetSizes_0[v5];
  unsigned int v7 = (objc_class *)self;
  uint64_t v8 = (unint64_t *)__CFAllocateObject(v7, 0);
  atomic_store(0, v8 + 1);
  uint64_t v8[2] = 0;
  *((_DWORD *)v8 + 6) = 1;
  CFStringRef v23 = v8;
  *((_DWORD *)v8 + 7) = (*((_DWORD *)v8 + 7) & 0x3FFFFFF) - v4;
  if (a2)
  {
    uint64_t v9 = malloc_type_calloc(1uLL, 8 * v6, 0x55ECBBD0uLL);
    v23[2] = (unint64_t)v9;
    if (a1)
    {
      id v10 = v9;
      uint64_t v11 = 0;
      if (v6 <= 1) {
        uint64_t v12 = 1;
      }
      else {
        uint64_t v12 = v6;
      }
      uint64_t v25 = v12;
      do
      {
        uint64_t v13 = *(void **)(a1 + 8 * v11);
        unint64_t v14 = [v13 hash];
        unint64_t v15 = v6;
        if ((v5 * 4))
        {
          unint64_t v16 = v14 % v6;
          uint64_t v17 = v25;
          unint64_t v15 = v6;
          while (1)
          {
            uint64_t v18 = (void *)v10[v16];
            if (!v18) {
              break;
            }
            if (v18 == &___NSSetM_DeletedMarker)
            {
              if (v15 == v6) {
                unint64_t v15 = v16;
              }
            }
            else if (v18 == v13 || ([v18 isEqual:v13] & 1) != 0)
            {
              unint64_t v15 = v16;
              goto LABEL_28;
            }
            if (v16 + 1 >= v6) {
              unint64_t v19 = v6;
            }
            else {
              unint64_t v19 = 0;
            }
            unint64_t v16 = v16 + 1 - v19;
            if (!--v17) {
              goto LABEL_28;
            }
          }
          if (v15 == v6) {
            unint64_t v15 = v16;
          }
        }
LABEL_28:
        if (!v10[v15])
        {
          uint64_t v20 = *(void *)(a1 + 8 * v11);
          v10[v15] = v20;
          if ((a3 & 1) == 0 && v20 >= 1) {
            id v21 = (id)v20;
          }
          *((_DWORD *)v23 + 7) = *((_DWORD *)v23 + 7) & 0xFC000000 | (*((_DWORD *)v23 + 7) + 1) & 0x3FFFFFF;
        }
        ++v11;
      }
      while (v11 != a2);
    }
  }
  return v23;
}

__objc2_class **__NSSetMutablePlaceholder()
{
  return &___mutablePlaceholderSet;
}

__objc2_class **__NSSetImmutablePlaceholder()
{
  return &___immutablePlaceholderSet;
}

uint64_t __createSet(void *a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  return [a1 initWithObjects:v3 count:1];
}

void *__NSSingleObjectSetI_new(uint64_t a1, char a2)
{
  int v4 = (objc_class *)self;
  unint64_t v5 = __CFAllocateObject(v4, 0);
  unint64_t v6 = v5;
  if (v5)
  {
    v5[1] = a1;
    if (a1 >= 1 && (a2 & 1) == 0) {
      id v7 = (id)a1;
    }
  }
  return v6;
}

__objc2_class **__NSDictionaryImmutablePlaceholder()
{
  return &___immutablePlaceholderDictionary;
}

void *__NSSingleEntryDictionaryI_new(unint64_t a1, unint64_t a2, char a3)
{
  v26[1] = *(void *)off_1ECE0A5B0;
  if (!a1)
  {
    uint64_t v12 = _os_log_pack_size();
    unint64_t v14 = (char *)v26 - ((MEMORY[0x1F4188790](v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v15 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v15 = 136315138;
    *(void *)(v15 + 4) = "__NSSingleEntryDictionaryI_new";
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** %s: key cannot be nil", "__NSSingleEntryDictionaryI_new");
    uint64_t v17 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v16) userInfo:0 osLogPack:v14 size:v12];
    objc_exception_throw(v17);
  }
  if (!a2)
  {
    uint64_t v18 = _os_log_pack_size();
    uint64_t v20 = (char *)v26 - ((MEMORY[0x1F4188790](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v21 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v21 = 136315138;
    *(void *)(v21 + 4) = "__NSSingleEntryDictionaryI_new";
    CFStringRef v22 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** %s: object cannot be nil", "__NSSingleEntryDictionaryI_new");
    CFStringRef v23 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v22) userInfo:0 osLogPack:v20 size:v18];
    objc_exception_throw(v23);
  }
  unint64_t v6 = (objc_class *)self;
  id v7 = __CFAllocateObject(v6, 0);
  if (v7)
  {
    if (a3)
    {
      uint64_t v9 = [(id)a1 copyWithZone:0];
      void v7[2] = v9;
      if (!v9)
      {
        CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSDictionary: -copyWithZone: for key %@ returned nil", a1);
        uint64_t v25 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v24) userInfo:0];
        objc_exception_throw(v25);
      }
    }
    else
    {
      if ((a3 & 8) == 0 && (a1 & 0x8000000000000000) == 0) {
        id v8 = (id)a1;
      }
      void v7[2] = a1;
    }
    v7[1] = a2;
    if ((a2 & 0x8000000000000000) == 0 && (a3 & 4) == 0) {
      id v10 = (id)a2;
    }
  }
  return v7;
}

void sub_182BD0A64(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    if (v2 >= 1) {

    }
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_182BD0AA4()
{
}

__objc2_class **__NSDictionaryMutablePlaceholder()
{
  return &___mutablePlaceholderDictionary;
}

void sub_182BD1084(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BD2330(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

unsigned char *__NSSetI_new(uint64_t *a1, uint64_t *a2, unint64_t a3, char a4)
{
  unint64_t v5 = a3;
  uint64_t v8 = 0;
  uint64_t v25 = *(void *)off_1ECE0A5B0;
  CFStringRef v24 = a2;
  while (__NSSetCapacities[v8] < a3)
  {
    if (++v8 == 64)
    {
      __break(1u);
      break;
    }
  }
  uint64_t v9 = __NSSetSizes[v8];
  id v10 = (objc_class *)self;
  uint64_t v11 = __CFAllocateObject(v10, 8 * v9);
  uint64_t v12 = v11;
  v11[15] = v11[15] & 3 | (4 * v8);
  if (v5)
  {
    v17[0] = off_1ECE0A5A0;
    v17[1] = 3221225472;
    uint64_t v18 = ____NSSetI_new_block_invoke;
    uint64_t v19 = &unk_1ECDB0808;
    uint64_t v21 = v11 + 16;
    uint64_t v22 = v9;
    char v23 = a4;
    uint64_t v20 = v11;
    if (a2)
    {
      ____NSSetI_new_block_invoke((uint64_t)v17, *a1);
      if (v5 >= 2)
      {
        unint64_t v13 = v5 - 1;
        do
        {
          unint64_t v14 = v24++;
          v18((uint64_t)v17, *v14);
          --v13;
        }
        while (v13);
      }
    }
    else
    {
      do
      {
        uint64_t v15 = *a1++;
        v18((uint64_t)v17, v15);
        --v5;
      }
      while (v5);
    }
  }
  return v12;
}

uint64_t _CFBundleLocalizedStringLogger()
{
  if (_CFBundleLocalizedStringLogger_onceToken != -1) {
    dispatch_once(&_CFBundleLocalizedStringLogger_onceToken, &__block_literal_global_143);
  }
  return _CFBundleLocalizedStringLogger__log;
}

uint64_t CFBundleAllowMixedLocalizations()
{
  if (CFBundleAllowMixedLocalizations_once != -1) {
    dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
  }
  return CFBundleAllowMixedLocalizations_allowMixed;
}

uint64_t CFBasicHashGetUsedBucketCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

id __NSFrozenSetM_mutableCopy(uint64_t a1)
{
  if (__cf_tsanReadFunction) {
    __cf_tsanReadFunction(a1, v1, __CFTSANTagMutableSet);
  }
  if (!atomic_load((unint64_t *)(a1 + 24)))
  {
    int v4 = _cow_create(a1, 0);
    uint64_t v5 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 24), (unint64_t *)&v5, (unint64_t)v4);
    if (v5) {
      free(v4);
    }
  }
  unint64_t v6 = (objc_class *)self;
  id v7 = __CFAllocateObject(v6, 0);
  uint64_t v8 = (os_unfair_lock_s *)atomic_load((unint64_t *)(a1 + 24));
  _cow_copy(a1, 0, v8, (uint64_t)__NSSet_cowCallbacks, (uint64_t)v7, 1);
  return v7;
}

double __os_log_helper_1_2_3_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)&double result = 136315650;
  *(_DWORD *)a1 = 136315650;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  return result;
}

uint64_t _CFURLFileCacheGetFlags()
{
  return MEMORY[0x1F4114FB0]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  CFNotificationCenterPostNotificationWithOptions(center, name, object, userInfo, deliverImmediately != 0);
}

BOOL _CFPrefsGetPathForTriplet(__CFString *a1, const __CFString *a2, int a3, CFStringRef filePath, UInt8 *a5)
{
  if (filePath)
  {
    CFURLRef v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, filePath, kCFURLPOSIXPathStyle, 1u);
    CFURLRef PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, v9);
    if (v9) {
      CFRelease(v9);
    }
    if (!PreferencesDirectoryURLForTriplet) {
      return 0;
    }
  }
  else
  {
    CFURLRef PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, 0);
    if (!PreferencesDirectoryURLForTriplet) {
      return 0;
    }
  }
  CacheStringForBundleID = (__CFString *)_CFPrefsGetCacheStringForBundleID(a1);
  if (CFEqual(CacheStringForBundleID, @"kCFPreferencesAnyApplication")) {
    CacheStringForBundleID = @".GlobalPreferences";
  }
  CFIndex location = CFStringFind(CacheStringForBundleID, @".plist", 0xDuLL).location;
  if (location == -1)
  {
    CFRetain(CacheStringForBundleID);
    if (!a3) {
      goto LABEL_14;
    }
  }
  else
  {
    v19.CFIndex length = location;
    v19.CFIndex location = 0;
    CacheStringForBundleID = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, CacheStringForBundleID, v19);
    if (!a3) {
      goto LABEL_14;
    }
  }
  if (!CFEqual(a2, @"kCFPreferencesAnyUser"))
  {
    uint64_t v18 = _CFXPreferencesGetByHostIdentifierString();
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@.%@.plist", CacheStringForBundleID, v18);
    goto LABEL_16;
  }
LABEL_14:
  CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@.plist", CacheStringForBundleID);
LABEL_16:
  CFStringRef v14 = v13;
  CFRelease(CacheStringForBundleID);
  if (!v14)
  {
    BOOL v16 = 0;
    goto LABEL_21;
  }
  CFURLRef v15 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, kCFURLPOSIXPathStyle, 0, PreferencesDirectoryURLForTriplet);
  CFRelease(v14);
  CFRelease(PreferencesDirectoryURLForTriplet);
  if (v15)
  {
    BOOL v16 = CFURLGetFileSystemRepresentation(v15, 1u, a5, 1024) != 0;
    CFURLRef PreferencesDirectoryURLForTriplet = v15;
LABEL_21:
    CFRelease(PreferencesDirectoryURLForTriplet);
    return v16;
  }
  return 0;
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  int v6 = resolveAgainstBase;
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  CFAllocatorRef v8 = CFGetAllocator(url);
  if (!url) {
    return 0;
  }
  CFAllocatorRef v9 = v8;
  if (v6)
  {
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)url))
    {
      if ([(__CFURL *)url baseURL]) {
        goto LABEL_9;
      }
    }
    else if (*((void *)url + 4))
    {
      goto LABEL_9;
    }
  }
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url) || (*((unsigned char *)url + 17) & 0x10) == 0)
  {
LABEL_9:
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)url))
    {
      if ([(__CFURL *)url baseURL]) {
        goto LABEL_26;
      }
    }
    else if (*((void *)url + 4))
    {
      goto LABEL_26;
    }
    if (CFURLIsFileReferenceURL(url))
    {
      CFStringRef v10 = CFURLCopyPath(url);
      if (v10)
      {
        CFStringRef v11 = v10;
        if (!CFStringGetCString(v10, buffera, 2048, 0x8000100u)) {
          goto LABEL_25;
        }
        if (*(void *)buffera != 0x692F656C69662E2FLL || v22 != 15716) {
          goto LABEL_25;
        }
        uint64_t v20 = 0;
        strtoll(v23, &v20, 10);
        if (*v20 != 46) {
          goto LABEL_25;
        }
        strtoll(v20 + 1, &v20, 10);
        CFStringRef v13 = v20;
        if (*v20 == 47) {
          CFStringRef v13 = v20 + 1;
        }
        if (!*v13)
        {
          int v19 = _FSGetFileSystemRepresentationForFileID();
          CFRelease(v11);
          if (v19) {
            return 1;
          }
        }
        else
        {
LABEL_25:
          CFRelease(v11);
        }
      }
    }
LABEL_26:
    CFStringRef v14 = CFURLCreateStringWithFileSystemPath(v9, (unint64_t)url, 0, v6);
    if (v14)
    {
      CFStringRef v15 = v14;
      FileSystemRepresentatiouint64_t n = CFStringGetFileSystemRepresentation(v14, (char *)buffer, maxBufLen);
      CFRelease(v15);
      return FileSystemRepresentation;
    }
    return 0;
  }
  CFStringRef v18 = (const __CFString *)atomic_load((unint64_t *)url + 3);

  return CanonicalFileURLStringToFileSystemRepresentation(v18, buffer, maxBufLen);
}

CFTypeRef _CFURLCreateWithFileSystemRepresentation(const __CFAllocator *a1, char *__s1, uint64_t a3, int a4, CFTypeRef cf)
{
  CFTypeRef v5 = cf;
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  if (a3 >= 1)
  {
    int v10 = *__s1;
    char v27 = 0;
    if (v10 != 47)
    {
      BOOL v13 = cf == 0;
      if (!cf) {
        CFTypeRef v5 = (CFTypeRef)_CFURLCreateCurrentDirectoryURL(a1);
      }
      CFStringRef v14 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(a1, __s1, a3, a4, v10 == 47, 0, &v27);
      if (v14)
      {
        CFStringRef v15 = v14;
        BOOL v11 = 0;
        uint64_t v16 = 56;
        goto LABEL_17;
      }
      uint64_t v19 = 0;
      if (v13)
      {
LABEL_39:
        if (v5) {
          CFRelease(v5);
        }
      }
      return (CFTypeRef)v19;
    }
    BOOL v11 = (unint64_t)a3 >= 0xA && strncmp(__s1, "/.file/id=", 0xAuLL) == 0;
    CFStringRef v17 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(a1, __s1, a3, a4, 1, 0, &v27);
    if (v17)
    {
      CFStringRef v15 = v17;
      BOOL v13 = 0;
      CFTypeRef v5 = 0;
      uint64_t v16 = 72;
LABEL_17:
      uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)a1, 0x1DuLL, v16, 0);
      uint64_t v19 = Instance;
      if (Instance)
      {
        *(_DWORD *)(Instance + 20) = 134217984;
        atomic_store((unint64_t)CFStringCreateCopy(a1, v15), (unint64_t *)(Instance + 24));
        if (v5) {
          CFURLRef v20 = CFURLCopyAbsoluteURL((CFURLRef)v5);
        }
        else {
          CFURLRef v20 = 0;
        }
        *(void *)(v19 + 32) = v20;
        if (v10 == 47)
        {
          if (v27) {
            int v21 = 4096;
          }
          else {
            int v21 = 36864;
          }
          if (v11) {
            int v21 = 0x2000;
          }
          if (a4) {
            int v22 = 1610696737;
          }
          else {
            int v22 = 1610694689;
          }
          *(_DWORD *)(v19 + 16) = v22 | v21;
          *(_OWORD *)(v19 + 56) = xmmword_182E0FA40;
          CFIndex Length = CFStringGetLength(v15);
          *(void *)(v19 + 72) = 7;
          *(void *)(v19 + 80) = Length - 7;
        }
        else
        {
          if (a4) {
            int v24 = 84000;
          }
          else {
            int v24 = 81952;
          }
          *(_DWORD *)(v19 + 16) = v24 | ((v27 == 0) << 15);
          CFStringRef v25 = (const __CFString *)atomic_load((unint64_t *)(v19 + 24));
          CFIndex v26 = CFStringGetLength(v25);
          *(void *)(v19 + 56) = 0;
          *(void *)(v19 + 64) = v26;
        }
      }
      CFRelease(v15);
      if (!v13) {
        return (CFTypeRef)v19;
      }
      goto LABEL_39;
    }
    return 0;
  }
  if (!cf) {
    return 0;
  }

  return CFRetain(cf);
}

CFTypeRef _CFURLCreateWithFileSystemPath(const __CFAllocator *a1, CFStringRef theString, uint64_t a3, BOOL a4, const __CFURL *a5)
{
  CFStringRef v8 = theString;
  uint64_t v77 = *(void *)off_1ECE0A5B0;
  BOOL v75 = 0;
  CFIndex Length = CFStringGetLength(theString);
  if (Length >= 1)
  {
    CFIndex v11 = Length;
    if (a3 == 2)
    {
      unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(v8, 0);
      if ((unint64_t)v11 < 2) {
        int v25 = 0;
      }
      else {
        int v25 = CFStringGetCharacterAtIndex(v8, 1);
      }
      if (CharacterAtIndex <= 0x7F && (sURLValidCharacters[CharacterAtIndex] & 2) != 0 && (v25 == 124 || v25 == 58)) {
        goto LABEL_72;
      }
      if (CharacterAtIndex == 47)
      {
        BOOL v12 = 1;
        CFStringRef v48 = POSIXPathToURLPath(v8, a4, 1, &v75);
        BOOL v13 = 0;
        goto LABEL_78;
      }
      if (CharacterAtIndex == 92)
      {
LABEL_72:
        BOOL v12 = 1;
        CFStringRef v48 = WindowsPathToURLPath(v8, a1, a4, 1);
        BOOL v13 = 0;
        uint64_t v49 = 2;
        if (v48) {
          goto LABEL_100;
        }
      }
      else
      {
        CFStringRef v50 = WindowsPathToURLPath(v8, a1, a4, 0);
        if (v50)
        {
          CFStringRef v48 = v50;
          BOOL v13 = 0;
          uint64_t v49 = 2;
          goto LABEL_104;
        }
      }
      return 0;
    }
    if (a3 != 1)
    {
      if (!a3)
      {
        BOOL v12 = CFStringGetCharacterAtIndex(v8, 0) == 47;
        if (v8) {
          BOOL v13 = CFStringHasPrefix(v8, @"/.file/id=") != 0;
        }
        else {
          BOOL v13 = 0;
        }
        CFStringRef v48 = POSIXPathToURLPath(v8, a4, v12, &v75);
LABEL_78:
        uint64_t v49 = 0;
        if (!v48) {
          return 0;
        }
LABEL_100:
        if (v12)
        {
          int v55 = 0;
          int v56 = 0;
          a5 = 0;
          if (a4) {
            goto LABEL_110;
          }
          goto LABEL_108;
        }
LABEL_104:
        if (a5)
        {
          int v56 = 0;
          int v55 = 1;
          if (a4) {
            goto LABEL_110;
          }
        }
        else
        {
          a5 = (const __CFURL *)_CFURLCreateCurrentDirectoryURL(a1);
          int v55 = 1;
          int v56 = 1;
          if (a4)
          {
LABEL_110:
            if (v55) {
              uint64_t v58 = 56;
            }
            else {
              uint64_t v58 = 72;
            }
            uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)a1, 0x1DuLL, v58, 0);
            uint64_t v57 = Instance;
            if (Instance)
            {
              *(_DWORD *)(Instance + 20) = 134217984;
              atomic_store((unint64_t)CFStringCreateCopy(a1, v48), (unint64_t *)(Instance + 24));
              if (a5) {
                CFURLRef v60 = CFURLCopyAbsoluteURL(a5);
              }
              else {
                CFURLRef v60 = 0;
              }
              *(void *)(v57 + 32) = v60;
              if (v55)
              {
                if (a4) {
                  int v61 = 84000;
                }
                else {
                  int v61 = 81952;
                }
                *(_DWORD *)(v57 + 16) = v61;
                CFStringRef v62 = (const __CFString *)atomic_load((unint64_t *)(v57 + 24));
                CFIndex v63 = CFStringGetLength(v62);
                *(void *)(v57 + 56) = 0;
                *(void *)(v57 + 64) = v63;
              }
              else
              {
                int v64 = 84001;
                if (!a4) {
                  int v64 = 81953;
                }
                if (v13) {
                  int v65 = v64 | 0x2000;
                }
                else {
                  int v65 = (v75 << 15) | ((v49 == 0) << 12) | v64;
                }
                *(_DWORD *)(v57 + 16) = v65 | 0x60000000;
                *(_OWORD *)(v57 + 56) = xmmword_182E0FA40;
                CFIndex v66 = CFStringGetLength(v48);
                *(void *)(v57 + 72) = 7;
                *(void *)(v57 + 80) = v66 - 7;
              }
            }
            if (a5) {
              int v67 = v56;
            }
            else {
              int v67 = 0;
            }
            if (v67 == 1) {
              CFRelease(a5);
            }
            CFRelease(v48);
            return (CFTypeRef)v57;
          }
        }
LABEL_108:
        if (v11 == 1) {
          a4 = CFStringGetCharacterAtIndex(v48, 0) == 47;
        }
        goto LABEL_110;
      }
      return 0;
    }
    int v70 = CFStringGetCharacterAtIndex(v8, 0);
    BOOL v12 = v70 != 58;
    v80.CFIndex location = 0;
    v80.CFIndex length = v11;
    int v73 = CFStringFindWithOptions(v8, @"::", v80, 0, 0);
    if (v73)
    {
      CFStringRef v15 = (UniChar *)malloc_type_malloc(2 * v11, 0x1000040BDFB0063uLL);
      v79.CFIndex location = 0;
      v79.CFIndex length = v11;
      CFStringGetCharacters(v8, v79, v15);
      CFIndex v16 = 0;
      CFIndex v17 = 0;
      uint64_t v18 = -1;
      do
      {
        int v19 = v15[v17];
        if (v19 == 58)
        {
          CFIndex v20 = v17 + 1;
          if (v17 + 1 < v11 && v15[v20] == 58)
          {
            if (v16 >= 1 && (v18 & 0x8000000000000000) == 0)
            {
              if (v18 >= v16) {
                CFIndex v21 = v16;
              }
              else {
                CFIndex v21 = v18;
              }
              CFIndex v22 = v21 - 1;
              while (1)
              {
                if (v16 < 2)
                {
                  CFIndex v16 = 0;
                  goto LABEL_27;
                }
                if (v16 <= v18) {
                  break;
                }
                int v23 = v15[--v16];
                if (v23 == 58) {
                  goto LABEL_27;
                }
              }
              CFIndex v16 = v22;
            }
          }
          else
          {
            CFIndex v20 = v17;
          }
LABEL_27:
          if (v18 == -1) {
            uint64_t v18 = v16;
          }
          LOWORD(v19) = v15[v20];
          CFIndex v17 = v20;
        }
        v15[v16++] = v19;
        ++v17;
      }
      while (v17 < v11);
      CFStringRef v8 = CFStringCreateWithCharacters(a1, v15, v16);
      CFIndex v11 = CFStringGetLength(v8);
      free(v15);
    }
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v8, @":");
    MutableCFStringRef Copy = CFArrayCreateMutableCopy(a1, 0, ArrayBySeparatingStrings);
    int v28 = CFStringGetCharacterAtIndex(v8, 0);
    CFRelease(ArrayBySeparatingStrings);
    CFIndex v74 = v11;
    if (v28 == 58)
    {
      CFArrayRemoveValueAtIndex(MutableCopy, 0);
    }
    else
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0);
      if (CFStringGetLength(ValueAtIndex) == 1 && CFStringGetCharacterAtIndex(ValueAtIndex, 0) == 47) {
        CFArrayRemoveValueAtIndex(MutableCopy, 0);
      }
      CFArrayInsertValueAtIndex(MutableCopy, 0, &stru_1ECE10768);
    }
    CFURLRef v72 = a5;
    unsigned int Count = CFArrayGetCount(MutableCopy);
    uint64_t v31 = Count;
    CFStringRef cf = v8;
    if (Count)
    {
      unsigned int v68 = Count;
      BOOL v69 = a4;
      CFIndex v32 = 0;
      do
      {
        CFStringRef v33 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v32);
        result.CFIndex location = 0;
        result.CFIndex length = 0;
        CFIndex v34 = CFStringGetLength(v33);
        v81.CFIndex location = 0;
        v81.CFIndex length = v34;
        if (CFStringFindWithOptions(v33, @"/", v81, 0, &result))
        {
          CFIndex v35 = 0;
          unint64_t v36 = 0;
          do
          {
            CFIndex v37 = v35 + v34;
            if (!v36) {
              unint64_t v36 = CFStringCreateMutableCopy(a1, v37, v33);
            }
            CFStringReplace(v36, result, @":");
            CFIndex v34 = v37 + ~result.location;
            CFIndex v35 = result.location + 1;
            v82.CFIndex location = result.location + 1;
            v82.CFIndex length = v34;
          }
          while (CFStringFindWithOptions(v33, @"/", v82, 0, &result));
          if (v36)
          {
            CFArraySetValueAtIndex(MutableCopy, v32, v36);
            CFRelease(v36);
          }
        }
        ++v32;
      }
      while (v32 != v31);
      a4 = v69;
      if (v69)
      {
        CFStringRef v38 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v68 - 1);
        if (CFStringGetLength(v38)) {
          CFArrayAppendValue(MutableCopy, &stru_1ECE10768);
        }
      }
    }
    if (!MutableCopy)
    {
      CFStringRef v48 = 0;
      goto LABEL_97;
    }
    BOOL v39 = a4;
    CFAllocatorRef v40 = CFGetAllocator(MutableCopy);
    CFIndex v41 = CFArrayGetCount(MutableCopy);
    CFIndex v42 = v41;
    if (v41 >= 1)
    {
      CFIndex v43 = 0;
      __int16 v44 = 0;
      while (1)
      {
        CFStringRef v45 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v43);
        CFStringRef v46 = CFURLCreateStringByAddingPercentEscapes(v40, v45, 0, @";?/", 0x8000100u);
        if (!v46) {
          break;
        }
        CFStringRef v47 = v46;
        if (v46 != v45)
        {
          if (!v44) {
            __int16 v44 = CFArrayCreateMutableCopy(v40, v42, MutableCopy);
          }
          CFArraySetValueAtIndex(v44, v43, v47);
        }
        CFRelease(v47);
        if (v42 == ++v43) {
          goto LABEL_85;
        }
      }
      if (v42 == v43)
      {
LABEL_85:
        CFArrayRef v51 = v44;
        if (v44) {
          goto LABEL_87;
        }
        goto LABEL_86;
      }
      CFStringRef v54 = 0;
      CFStringRef v48 = 0;
      a5 = v72;
      BOOL v12 = v70 != 58;
      if (!v44) {
        goto LABEL_96;
      }
      goto LABEL_95;
    }
    if (v41)
    {
      CFStringRef v48 = 0;
      a5 = v72;
      BOOL v12 = v70 != 58;
    }
    else
    {
LABEL_86:
      CFRetain(MutableCopy);
      CFArrayRef v51 = MutableCopy;
LABEL_87:
      CFRelease(MutableCopy);
      BOOL v12 = v70 != 58;
      if (CFArrayGetCount(v51) == 1
        && (CFStringRef v52 = (const __CFString *)CFArrayGetValueAtIndex(v51, 0), !CFStringGetLength(v52)))
      {
        int v53 = (__CFArray *)CFRetain(@"/");
      }
      else
      {
        int v53 = (__CFArray *)CFStringCreateByCombiningStrings(a1, v51, @"/");
      }
      __int16 v44 = v53;
      a5 = v72;
      if (v70 != 58 && v53)
      {
        CFStringRef v54 = CFStringCreateWithFormat(a1, 0, @"file://%@", v53);
        MutableCFStringRef Copy = v51;
LABEL_95:
        CFRelease(v44);
        CFStringRef v48 = v54;
        goto LABEL_96;
      }
      MutableCFStringRef Copy = v51;
      CFStringRef v48 = (const __CFString *)v53;
    }
LABEL_96:
    CFRelease(MutableCopy);
    a4 = v39;
LABEL_97:
    CFIndex v11 = v74;
    if (v73) {
      CFRelease(cf);
    }
    BOOL v13 = 0;
    uint64_t v49 = 1;
    if (!v48) {
      return 0;
    }
    goto LABEL_100;
  }
  if (!a5) {
    return 0;
  }

  return CFRetain(a5);
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  v4.CFIndex length = CFStringGetLength(theString);
  v4.CFIndex location = 0;

  return CFStringFindWithOptionsAndLocale(theString, prefix, v4, 8uLL, 0, 0);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  v16[18] = *(void *)off_1ECE0A5B0;
  CFAllocatorRef v2 = CFGetAllocator(relativeURL);
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)relativeURL))
  {
    CFURLRef v3 = (const __CFURL *)[(__CFURL *)relativeURL absoluteURL];
    CFURLRef v4 = v3;
    if (v3) {
      CFRetain(v3);
    }
    return v4;
  }
  unint64_t v5 = *((void *)relativeURL + 4);
  if (v5)
  {
    if (CFURLIsFileReferenceURL(*((CFURLRef *)relativeURL + 4)) && !CFURLHasDirectoryPath((CFURLRef)v5))
    {
      CFURLRef v13 = CFURLCreateFilePathURL(v2, (CFURLRef)v5, 0);
      if (!v13) {
        return 0;
      }
      unint64_t v5 = (unint64_t)v13;
      char v6 = 0;
    }
    else
    {
      char v6 = 1;
    }
    unsigned int v15 = 0;
    char v14 = 0;
    if (CF_IS_OBJC(0x1DuLL, v5))
    {
      CFStringRef v7 = CFURLGetString((CFURLRef)v5);
      unsigned int v15 = 0;
      CFStringRef v8 = v16;
      _parseComponents(v7, 0, &v15, v16, &v14);
    }
    else
    {
      CFStringRef v7 = (const __CFString *)atomic_load((unint64_t *)(v5 + 24));
      unsigned int v15 = *(_DWORD *)(v5 + 16);
      CFStringRef v8 = (CFIndex *)(v5 + 56);
    }
    CFStringRef v10 = (const __CFString *)atomic_load((unint64_t *)relativeURL + 3);
    CFIndex v11 = resolveAbsoluteURLString(v2, v10, *((_DWORD *)relativeURL + 4), (uint64_t)relativeURL + 56, v7, v15, v8);
    if (v11)
    {
      BOOL v12 = v11;
      CFURLRef v4 = (const __CFURL *)_CFURLCreateWithURLString((int)v2, (CFStringRef)v11);
      CFRelease(v12);
      *((_DWORD *)v4 + 5) = *((_DWORD *)relativeURL + 5);
      if (v6) {
        return v4;
      }
    }
    else
    {
      CFURLRef v4 = 0;
      if (v6) {
        return v4;
      }
    }
    CFRelease((CFTypeRef)v5);
    return v4;
  }

  return (CFURLRef)CFRetain(relativeURL);
}

CFStringRef POSIXPathToURLPath(const __CFString *a1, int a2, int a3, BOOL *a4)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  char v14 = 0;
  if (CFStringGetLength(a1))
  {
    MaximumSizeOfFileSystemRepresentatiouint64_t n = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
    CFIndex v9 = MaximumSizeOfFileSystemRepresentation;
    if (MaximumSizeOfFileSystemRepresentation >= 1025) {
      CFStringRef v10 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0xC529D2D2uLL);
    }
    else {
      CFStringRef v10 = buffer;
    }
  }
  else
  {
    CFStringRef v10 = buffer;
    CFIndex v9 = 1;
  }
  if (CFStringGetFileSystemRepresentation(a1, v10, v9))
  {
    size_t v11 = strlen(v10);
    CFStringRef v12 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v10, v11, a2, a3, 0, &v14);
  }
  else
  {
    CFStringRef v12 = 0;
  }
  if (v10 != buffer) {
    free(v10);
  }
  if (a4) {
    *a4 = v14 == 0;
  }
  return v12;
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  if (CFStringGetLength(string)) {
    return [(__CFString *)(id)string getFileSystemRepresentation:buffer maxLength:maxBufLen];
  }
  if (!maxBufLen) {
    return 0;
  }
  *buffer = 0;
  return 1;
}

CFStringRef CreateStringFromFileSystemRepresentationByAddingPercentEscapes(const __CFAllocator *a1, unsigned char *a2, uint64_t a3, int a4, int a5, int a6, char *a7)
{
  v34[1] = *(void *)off_1ECE0A5B0;
  size_t v14 = (a4 != 0) | (8 * (a5 != 0)) | 0xC00;
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v18 = (char *)v34 - v17;
  if (v19 >= 1025)
  {
    size_t v14 = 3 * a3 + 8 * v15 + v16;
    CFIndex v21 = (char *)malloc_type_malloc(v14, 0x42281852uLL);
    if (!v21)
    {
      CFStringRef v32 = 0;
      char v23 = 0;
      goto LABEL_62;
    }
    CFIndex v20 = v21;
    v34[0] = a7;
  }
  else
  {
    v34[0] = a7;
    CFIndex v20 = (char *)v34 - v17;
  }
  CFIndex v22 = v20;
  if (a5)
  {
    strlcpy(v20, "file://", v14);
    CFIndex v22 = v20 + 7;
  }
  if (!a6)
  {
    if (a3 >= 1)
    {
      char v23 = 0;
      uint64_t v24 = 0;
      while (1)
      {
        uint64_t v27 = a2[v24];
        if (!a2[v24]) {
          goto LABEL_28;
        }
        if (sURLValidBytes[v27])
        {
          *v22++ = v27;
        }
        else
        {
          *CFIndex v22 = 37;
          v22[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)a2[v24] >> 4];
          void v22[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[a2[v24] & 0xF];
          v22 += 3;
          char v23 = 1;
        }
        if (a3 == ++v24) {
          goto LABEL_34;
        }
      }
    }
LABEL_27:
    uint64_t v24 = 0;
    char v23 = 0;
    int v28 = a2;
    goto LABEL_29;
  }
  if (a3 < 1) {
    goto LABEL_27;
  }
  char v23 = 0;
  uint64_t v24 = 0;
  while (1)
  {
    uint64_t v25 = a2[v24];
    if (!a2[v24]) {
      break;
    }
    if (v25 == 47 || (sURLValidBytes[v25] & 1) == 0)
    {
      *CFIndex v22 = 37;
      v22[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)a2[v24] >> 4];
      void v22[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[a2[v24] & 0xF];
      v22 += 3;
      char v23 = 1;
    }
    else
    {
      *v22++ = v25;
    }
    if (a3 == ++v24) {
      goto LABEL_34;
    }
  }
LABEL_28:
  int v28 = &a2[v24];
LABEL_29:
  if (v24 < a3)
  {
    while (!*v28)
    {
      ++v24;
      ++v28;
      if (a3 == v24) {
        goto LABEL_34;
      }
    }
  }
  if (v24 != a3)
  {
    CFStringRef v32 = 0;
    goto LABEL_60;
  }
LABEL_34:
  if (!a4)
  {
    if (a6)
    {
      if (a3 >= 2 && v22 - v20 >= 4)
      {
        uint64_t v30 = v22 - v20 - 3;
        do
        {
          uint64_t v29 = (uint64_t)v22;
          v22 -= 3;
          if (strncmp(v22, "%2F", 3uLL)) {
            break;
          }
          if (a3 < 3) {
            goto LABEL_58;
          }
          --a3;
          uint64_t v29 = (uint64_t)v22;
          BOOL v31 = v30 < 4;
          v30 -= 3;
        }
        while (!v31);
        goto LABEL_59;
      }
    }
    else if (a3 >= 2)
    {
      uint64_t v29 = (uint64_t)&v22[-a3 + 1];
      while (a2[a3 - 1] == 47)
      {
        --a3;
        --v22;
        if ((unint64_t)(a3 + 1) <= 2) {
          goto LABEL_59;
        }
      }
    }
    goto LABEL_58;
  }
  if (!a6)
  {
    if (a3 >= 1 && a2[a3 - 1] != 47) {
      *v22++ = 47;
    }
    goto LABEL_58;
  }
  if (v22 - v20 < 4 || !strncmp(v22 - 3, "%2F", 3uLL))
  {
LABEL_58:
    uint64_t v29 = (uint64_t)v22;
    goto LABEL_59;
  }
  *(_WORD *)CFIndex v22 = 12837;
  uint64_t v29 = (uint64_t)(v22 + 3);
  void v22[2] = 70;
LABEL_59:
  CFStringRef v32 = CFStringCreateWithBytes(a1, (const UInt8 *)v20, v29 - (void)v20, 0x8000100u, 0);
LABEL_60:
  a7 = (char *)v34[0];
  if (v20 != v18) {
    free(v20);
  }
LABEL_62:
  if (a7) {
    *a7 = v23;
  }
  return v32;
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  CFIndex Length = CFStringGetLength(string);
  CFStringEncoding FastestEncoding = CFStringGetFastestEncoding(string);
  if (FastestEncoding != 1536 && FastestEncoding)
  {
    BOOL v4 = Length <= 0xE38E38E38E38E38;
    uint64_t v5 = 9 * Length;
  }
  else
  {
    BOOL v4 = Length <= 0x2AAAAAAAAAAAAAAALL;
    uint64_t v5 = 3 * Length;
  }
  if (v4) {
    return v5 + 1;
  }
  else {
    return -1;
  }
}

CFStringEncoding CFStringGetFastestEncoding(CFStringRef theString)
{
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    return [(__CFString *)(id)theString _fastestEncodingInCFStringEncoding];
  }
  else
  {
    char v3 = atomic_load((unint64_t *)&theString->info);
    if ((v3 & 0x10) != 0)
    {
      return 256;
    }
    else
    {
      CFStringEncoding result = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding(0xFFFFFFFFLL);
        return __CFDefaultEightBitStringEncoding;
      }
    }
  }
  return result;
}

Boolean CFURLIsFileReferenceURL(CFURLRef url)
{
  do
  {
    while (1)
    {
      CFURLRef v1 = url;
      if (!CF_IS_OBJC(0x1DuLL, (unint64_t)url)) {
        break;
      }
      url = (CFURLRef)[(__CFURL *)v1 baseURL];
      if (!url) {
        goto LABEL_5;
      }
    }
    url = (CFURLRef)*((void *)v1 + 4);
  }
  while (url);
LABEL_5:
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)v1)) {
    return [(__CFURL *)v1 isFileReferenceURL];
  }
  else {
    return (*((_DWORD *)v1 + 4) & 0xE0002000) == 1610620928;
  }
}

uint64_t _CFPrefsHashKeyOrSource(uint64_t a1)
{
  uint64_t v25 = *(void *)off_1ECE0A5B0;
  Class Class = (__objc2_class *)object_getClass((id)a1);
  CFStringRef v22 = 0;
  CFStringRef v23 = 0;
  uint64_t v24 = 0;
  if (Class == CFPDSourceLookUpKey)
  {
    CFStringRef v4 = *(const __CFString **)(a1 + 8);
    if (v4)
    {
      CFIndex Length = CFStringGetLength(v4);
      CFIndex v6 = Length;
      if (Length >= 80) {
        CFIndex v7 = 80;
      }
      else {
        CFIndex v7 = Length;
      }
      v26.CFIndex location = 0;
      v26.CFIndex length = v7;
      CFStringRef v22 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(a1 + 8), v26);
      v27.CFIndex location = v6 - v7;
      v27.CFIndex length = v7;
      CFStringRef v8 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(a1 + 8), v27);
    }
    else
    {
      CFStringRef v8 = &stru_1ECE10768;
      CFStringRef v22 = &stru_1ECE10768;
    }
    CFStringRef v23 = v8;
    CFStringRef v10 = *(const void **)(a1 + 16);
    if (v10) {
      size_t v11 = (__CFString *)CFRetain(v10);
    }
    else {
      size_t v11 = &stru_1ECE10768;
    }
    uint64_t v24 = v11;
  }
  else
  {
    if (Class == CFPDCloudSource)
    {
      CFIndex v9 = *(const void **)(a1 + 160);
      if (v9) {
        char v3 = (__CFString *)CFRetain(v9);
      }
      else {
        char v3 = &stru_1ECE10768;
      }
    }
    else
    {
      char v3 = 0;
    }
    CFStringRef v12 = (const __CFString *)[(id)a1 copyUncanonicalizedPath];
    if (v12)
    {
      CFStringRef v13 = v12;
      CFIndex v14 = CFStringGetLength(v12);
      CFIndex v15 = v14;
      if (v14 >= 80) {
        CFIndex v16 = 80;
      }
      else {
        CFIndex v16 = v14;
      }
      v28.CFIndex location = 0;
      v28.CFIndex length = v16;
      CFStringRef v22 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v28);
      v29.CFIndex location = v15 - v16;
      v29.CFIndex length = v16;
      CFStringRef v23 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v29);
      CFRelease(v13);
    }
    else
    {
      CFStringRef v22 = &stru_1ECE10768;
      CFStringRef v23 = &stru_1ECE10768;
    }
    if (v3) {
      uint64_t v17 = v3;
    }
    else {
      uint64_t v17 = &stru_1ECE10768;
    }
    uint64_t v24 = v17;
  }
  uint64_t v18 = 0;
  memset(v21, 0, sizeof(v21));
  do
  {
    uint64_t v19 = *(CFStringRef *)((char *)&v22 + v18 * 8);
    v21[v18] = CFHash(v19);
    if (v19) {
      CFRelease(v19);
    }
    ++v18;
  }
  while (v18 != 3);
  return CFHashBytes((uint64_t)v21, 24);
}

uint64_t CFHashBytes(uint64_t a1, uint64_t a2)
{
  if ((int)a2 < 4)
  {
    unsigned int v2 = 0;
    unsigned int v9 = a2;
  }
  else
  {
    unsigned int v2 = 0;
    char v3 = (unsigned __int8 *)((a2 & 0xFFFFFFFF00000000) + a1 + 1);
    unsigned int v4 = a2;
    do
    {
      unsigned int v5 = *(v3 - 1) + 16 * v2;
      unsigned int v6 = *v3 + 16 * (v5 ^ (16 * (v5 >> 28)));
      unsigned int v7 = v3[1] + 16 * (v6 ^ (16 * (v6 >> 28)));
      int v8 = v3[2] + 16 * (v7 ^ (16 * (v7 >> 28)));
      unsigned int v2 = (v8 ^ ((v8 & 0xF0000000) >> 24)) & ~(v8 & 0xF0000000);
      unsigned int v9 = v4 - 4;
      v3 += 4;
      BOOL v10 = v4 > 7;
      v4 -= 4;
    }
    while (v10);
  }
  switch(v9)
  {
    case 1u:
      goto LABEL_11;
    case 2u:
LABEL_10:
      int v12 = *(unsigned __int8 *)(a2 + a1 - 2) + 16 * v2;
      unsigned int v2 = (v12 ^ ((v12 & 0xF0000000) >> 24)) & ~(v12 & 0xF0000000);
LABEL_11:
      int v13 = *(unsigned __int8 *)(a2 + a1 - 1) + 16 * v2;
      return (v13 ^ ((v13 & 0xF0000000) >> 24)) & ~(v13 & 0xF0000000);
    case 3u:
      int v11 = *(unsigned __int8 *)(a2 + a1 - 3) + 16 * v2;
      unsigned int v2 = (v11 ^ ((v11 & 0xF0000000) >> 24)) & ~(v11 & 0xF0000000);
      goto LABEL_10;
  }
  return v2;
}

CFStringRef CFURLCreateStringWithFileSystemPath(const __CFAllocator *a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = a2;
  if (a4)
  {
    if (CF_IS_OBJC(0x1DuLL, a2))
    {
      CFURLRef v7 = (const __CFURL *)[(id)v5 baseURL];
      if (!v7) {
        goto LABEL_6;
      }
LABEL_8:
      CFStringRef v8 = (const __CFString *)CFURLCreateStringWithFileSystemPath(a1, v7, a3, 0);
      int v9 = 0;
      goto LABEL_9;
    }
    CFURLRef v7 = *(const __CFURL **)(v5 + 32);
    if (v7) {
      goto LABEL_8;
    }
  }
  else
  {
    CFURLRef v7 = 0;
  }
LABEL_6:
  CFStringRef v8 = 0;
  int v9 = 1;
LABEL_9:
  int v10 = CF_IS_OBJC(0x1DuLL, v5);
  if (a3 || v10 || (*(unsigned char *)(v5 + 17) & 0x80) == 0 || (CFStringRef v11 = _retainedComponentString(v5, 32, 1, 1)) == 0)
  {
    if (CF_IS_OBJC(0x1DuLL, v5)) {
      uint64_t v5 = [(id)v5 _cfurl];
    }
    CFStringRef v13 = CFURLCopyPath((CFURLRef)v5);
    CFStringEncoding v14 = *(_DWORD *)(v5 + 20);
    if (v9 && CFURLIsFileReferenceURL((CFURLRef)v5))
    {
      CFStringRef v15 = FileReferenceURLPathToFullURLPath(v13, a1);
      CFRelease(v13);
      CFStringRef v13 = v15;
    }
    if (!v13) {
      return v8;
    }
    if (a3 == 2)
    {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v13, @"/");
      int Count = CFArrayGetCount(ArrayBySeparatingStrings);
      MutableCFStringRef Copy = CFArrayCreateMutableCopy(a1, Count, ArrayBySeparatingStrings);
      CFRelease(ArrayBySeparatingStrings);
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, Count - 1);
      if (!CFStringGetLength(ValueAtIndex)) {
        CFArrayRemoveValueAtIndex(MutableCopy, --Count);
      }
      if (Count >= 2)
      {
        CFStringRef v21 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0);
        if (!CFStringGetLength(v21))
        {
          CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 1);
          CFStringRef v23 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(a1, v22, @"\\"", v14);
          if (v23)
          {
            CFStringRef v24 = v23;
            if (CFStringGetLength(v23) == 2)
            {
              int CharacterAtIndex = CFStringGetCharacterAtIndex(v24, 1);
              int v26 = CharacterAtIndex;
              if (CharacterAtIndex == 124 || CharacterAtIndex == 58)
              {
                CFArrayRemoveValueAtIndex(MutableCopy, 0);
                if (v26 == 124)
                {
                  unsigned int v27 = CFStringGetCharacterAtIndex(v24, 0);
                  CFStringRef v28 = CFStringCreateWithFormat(a1, 0, @"%c:", v27);
                  CFArraySetValueAtIndex(MutableCopy, 0, v28);
                  CFRelease(v28);
                }
              }
            }
            CFRelease(v24);
          }
        }
      }
      CFStringRef v29 = CFStringCreateByCombiningStrings(a1, MutableCopy, @"\\"");
      CFRelease(MutableCopy);
      CFStringRef v12 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(a1, v29, @"\\"", v14);
      CFRelease(v29);
    }
    else
    {
      if (a3)
      {
        CFStringRef v12 = v8;
LABEL_65:
        CFRelease(v13);
        return v12;
      }
      BOOL v16 = _CFURLHasFileURLScheme(v5, 0);
      CFStringRef v12 = URLPathToPOSIXPath(v13, a1, v14, v16);
    }
    CFRelease(v13);
    if (!v12) {
      return v8;
    }
  }
  else
  {
    CFStringRef v12 = v11;
  }
  if (!CFURLHasDirectoryPath((CFURLRef)v5)
    || CFStringGetLength(v12) < 2
    || (CFIndex v30 = CFStringGetLength(v12), CFStringGetCharacterAtIndex(v12, v30 - 1) != 47)
    || (v49.CFIndex length = CFStringGetLength(v12) - 1,
        v49.CFIndex location = 0,
        CFStringRef v31 = CFStringCreateWithSubstring(a1, v12, v49),
        CFRelease(v12),
        (CFStringRef v12 = v31) != 0))
  {
    CFIndex Length = CFStringGetLength(v12);
    if (a3 != 2)
    {
      if (Length >= 1)
      {
        BOOL v33 = CFStringGetCharacterAtIndex(v12, 0) != 47;
LABEL_53:
        if (v8 && v33)
        {
          int v34 = CFURLHasDirectoryPath(v7);
          uint64_t v35 = CFStringGetLength(v8);
          CFIndex v36 = CFStringGetLength(v12);
          int v37 = _CFGetSlash();
          uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(a1, 2 * (v36 + v35) + 4, 0x1000040BDFB0063, 0);
          v47.CFIndex location = 0;
          v47.CFIndex length = v35;
          CFStringGetCharacters(v8, v47, Typed);
          if (v34)
          {
            if (Typed[v35 - 1] != v37) {
              Typed[v35++] = v37;
            }
          }
          else
          {
            uint64_t v39 = 2 * v35 - 2;
            do
            {
              uint64_t v40 = v39;
              CFIndex v41 = (UniChar *)((char *)Typed + v39);
              if (v41 <= Typed) {
                break;
              }
              int v42 = *v41;
              uint64_t v39 = v40 - 2;
            }
            while (v42 != v37);
            uint64_t v35 = (v40 >> 1) + 1;
          }
          CFIndex v43 = &Typed[v35 - (a3 == 1)];
          v48.CFIndex location = 0;
          v48.CFIndex length = v36;
          CFStringGetCharacters(v12, v48, v43);
          __int16 v44 = &v43[v36];
          *__int16 v44 = 0;
          CFStringRef v45 = _resolvedPath((char *)Typed, (unint64_t)v44, v37, 0, 1, a1);
          CFRelease(v8);
          CFStringRef v13 = v12;
          CFStringRef v12 = v45;
          goto LABEL_65;
        }
LABEL_58:
        CFStringRef v13 = v8;
        if (!v8) {
          return v12;
        }
        goto LABEL_65;
      }
LABEL_52:
      BOOL v33 = 1;
      goto LABEL_53;
    }
    if (Length < 3)
    {
      if (Length != 2) {
        goto LABEL_52;
      }
    }
    else if (CFStringGetCharacterAtIndex(v12, 0) == 92 && CFStringGetCharacterAtIndex(v12, 1) == 92)
    {
      goto LABEL_58;
    }
    BOOL v33 = 1;
    if (CFStringGetCharacterAtIndex(v12, 1) == 58) {
      goto LABEL_58;
    }
    goto LABEL_53;
  }
  return v8;
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)chars, 2 * numChars, 256, 0x10u, (__objc2_class **)contentsDeallocator, 0);
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  do
  {
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
      anURL = (CFURLRef)[(__CFURL *)anURL _cfurl];
    }
    unsigned int v2 = *((_DWORD *)anURL + 4);
    anURL = (CFURLRef)*((void *)anURL + 4);
    if (anURL) {
      BOOL v3 = (v2 & 0x3E) == 0;
    }
    else {
      BOOL v3 = 0;
    }
  }
  while (v3);
  return (v2 >> 11) & 1;
}

CFStringRef _retainedComponentString(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & a2) == 0) {
    return 0;
  }
  CFAllocatorRef v10 = v8;
  if (a2)
  {
    v16.CFIndex location = *(void *)(a1 + 56);
    if (v16.location != -1)
    {
      v16.CFIndex length = *(void *)(a1 + 64);
      goto LABEL_10;
    }
    return 0;
  }
  unsigned int v11 = 0;
  unsigned int v12 = a2;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  do
  {
    char v14 = v12;
    v12 >>= 1;
    v11 += v13 & 1;
    v13 >>= 1;
  }
  while ((v14 & 2) == 0);
  CFStringRef v15 = (CFIndex *)(a1 + 56 + 16 * v11);
  v16.CFIndex location = *v15;
  if (*v15 == -1) {
    return 0;
  }
  v16.CFIndex length = v15[1];
  if ((a2 & 1) == 0)
  {
LABEL_13:
    CFStringRef v19 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFStringRef v20 = CFStringCreateWithSubstring(v8, v19, v16);
    goto LABEL_19;
  }
LABEL_10:
  switch(v9 >> 29)
  {
    case 1u:
      uint64_t v17 = @"http";
      break;
    case 2u:
      uint64_t v17 = @"https";
      break;
    case 3u:
      uint64_t v17 = @"file";
      break;
    case 4u:
      uint64_t v17 = @"data";
      break;
    case 5u:
      uint64_t v17 = @"ftp";
      break;
    default:
      goto LABEL_13;
  }
  CFStringRef v20 = (const __CFString *)CFRetain(v17);
LABEL_19:
  CFStringRef v21 = v20;
  if (a4 | a3 || !v20 || (*(unsigned char *)(a1 + 18) & 1) != 0) {
    goto LABEL_29;
  }
  uint64_t v22 = *(void *)(a1 + 40);
  if (v22) {
    LODWORD(v22) = *(_DWORD *)(v22 + 16);
  }
  if ((v22 & a2) == 0)
  {
LABEL_29:
    CFStringRef v18 = v20;
    if (!a4) {
      return v18;
    }
    goto LABEL_30;
  }
  int v23 = *(_DWORD *)(a1 + 20);
  CFAllocatorRef v24 = CFGetAllocator(v20);
  CFIndex Length = CFStringGetLength(v21);
  v36[2] = (CFMutableStringRef)v36;
  CFMutableStringRef theString = 0;
  __int16 v41 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v38 = 0;
  constructBuffers(v21, v42, &v40, &v39, (char *)&v41 + 1, (char *)&v41);
  uint64_t v26 = v40;
  int v27 = HIBYTE(v41);
  CFAllocatorRef v28 = v24;
  uint64_t v29 = v39;
  scanCharacters(v28, &theString, 0, v40, v39, HIBYTE(v41), 0, Length, &v38, a2, v23);
  CFStringRef v18 = theString;
  if (theString)
  {
    unint64_t v30 = Length - v38;
    if (Length > v38)
    {
      if (v27) {
        __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)(v26 + v38), v30, 513);
      }
      else {
        CFStringAppendCharacters(theString, (const UniChar *)(v29 + 2 * v38), v30);
      }
    }
  }
  else
  {
    CFRetain(v21);
    CFStringRef v18 = v21;
  }
  if ((_BYTE)v41)
  {
    if (v27) {
      uint64_t v35 = (void *)v26;
    }
    else {
      uint64_t v35 = (void *)v29;
    }
    free(v35);
  }
  CFRelease(v21);
  if (a4)
  {
LABEL_30:
    if (v18)
    {
      CFStringEncoding v31 = *(_DWORD *)(a1 + 20);
      if (v31 == 134217984) {
        CFStringRef v32 = CFURLCreateStringByReplacingPercentEscapes(v10, v18, &stru_1ECE10768);
      }
      else {
        CFStringRef v32 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v10, v18, &stru_1ECE10768, v31);
      }
      CFStringRef v33 = v32;
      CFRelease(v18);
      return v33;
    }
  }
  return v18;
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  unint64_t v7 = CF_IS_OBJC(7uLL, (unint64_t)str);
  if (v7)
  {
    return (CFStringRef)-[__CFString _createSubstringWithRange:]((id)str, "_createSubstringWithRange:", location, length);
  }
  else
  {
    if (location) {
      goto LABEL_18;
    }
    char v9 = atomic_load((unint64_t *)&str->info);
    uint64_t v10 = v9 & 5;
    char v11 = atomic_load((unint64_t *)&str->info);
    uint64_t v12 = v11 & 0x60;
    if (v10 == 4)
    {
      p_data = &str->data;
      if (v12)
      {
        char v14 = *p_data;
      }
      else
      {
        uint64_t v16 = atomic_load((unint64_t *)&str->info);
        char v14 = (char *)&p_data[(v16 & 5) != 4];
      }
      CFStringRef v15 = (char *)*v14;
    }
    else
    {
      CFStringRef v15 = (v11 & 0x60) != 0 ? (char *)str->length : str->data;
    }
    if ((char *)length != v15)
    {
LABEL_18:
      char v17 = atomic_load((unint64_t *)&str->info);
      char v18 = atomic_load((unint64_t *)&str->info);
      uint64_t v19 = v18 & 0x60;
      CFStringRef v20 = &str->data;
      if ((v17 & 0x10) != 0)
      {
        if (v19)
        {
          uint64_t v22 = *v20;
        }
        else
        {
          uint64_t v31 = atomic_load((unint64_t *)&str->info);
          uint64_t v22 = (char *)&v20[(v31 & 5) != 4];
        }
        CFAllocatorRef v28 = (int8x16_t *)&v22[2 * location];
        int64_t v29 = 2 * length;
        int v27 = (__objc2_class **)alloc;
        uint64_t v26 = 256;
        unsigned int v30 = 2;
      }
      else
      {
        if (v19)
        {
          CFStringRef v21 = *v20;
        }
        else
        {
          uint64_t v23 = atomic_load((unint64_t *)&str->info);
          CFStringRef v21 = (char *)&v20[(v23 & 5) != 4];
        }
        unint64_t v24 = atomic_load((unint64_t *)&str->info);
        uint64_t v25 = (uint64_t)&v21[location + ((v24 >> 2) & 1)];
        uint64_t v26 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding(v7);
          uint64_t v26 = __CFDefaultEightBitStringEncoding;
        }
        int v27 = (__objc2_class **)alloc;
        CFAllocatorRef v28 = (int8x16_t *)v25;
        int64_t v29 = length;
        unsigned int v30 = 0;
      }
      return (CFStringRef)__CFStringCreateImmutableFunnel3(v27, v28, v29, v26, v30, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
    }
    else
    {
      return (CFStringRef)_CFNonObjCStringCreateCopy((uint64_t)alloc, (uint64_t)str);
    }
  }
}

BOOL _CFURLHasFileURLScheme(unint64_t a1, unsigned char *a2)
{
  do
  {
    while (1)
    {
      unint64_t v3 = a1;
      if (!CF_IS_OBJC(0x1DuLL, a1)) {
        break;
      }
      a1 = [(id)v3 baseURL];
      if (!a1) {
        goto LABEL_5;
      }
    }
    a1 = *(void *)(v3 + 32);
  }
  while (a1);
LABEL_5:
  if (!CF_IS_OBJC(0x1DuLL, v3) && (unsigned int v4 = *(_DWORD *)(v3 + 16), v4 >> 29))
  {
    if (a2)
    {
      *a2 = v4 & 1;
      unsigned int v4 = *(_DWORD *)(v3 + 16);
    }
    return v4 >> 29 == 3;
  }
  else
  {
    CFStringRef v5 = CFURLCopyScheme((CFURLRef)v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      if (v5 == @"file")
      {
        BOOL v7 = 1;
        if (!a2) {
          goto LABEL_11;
        }
      }
      else
      {
        BOOL v7 = CFStringCompare(v5, @"file", 1uLL) == kCFCompareEqualTo;
        if (!a2)
        {
LABEL_11:
          CFRelease(v6);
          return v7;
        }
      }
      *a2 = 1;
      goto LABEL_11;
    }
    BOOL v7 = 0;
    if (a2) {
      *a2 = 0;
    }
  }
  return v7;
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  uint64_t v3 = MEMORY[0x1F4188790](allocator, originalString);
  CFStringRef v6 = v5;
  CFStringRef v7 = v4;
  CFAllocatorRef v8 = (const __CFAllocator *)v3;
  uint64_t v77 = *(void *)off_1ECE0A5B0;
  if (v5)
  {
    BOOL v9 = CFStringGetLength(v5) == 0;
    if (!v7) {
      return 0;
    }
  }
  else
  {
    BOOL v9 = 0;
    if (!v4) {
      return 0;
    }
  }
  CFIndex Length = CFStringGetLength(v7);
  if (v6)
  {
    CFIndex v11 = Length;
    if (Length)
    {
      v73.CFIndex location = 0;
      v73.CFIndex length = 0;
      UniChar v72 = 0;
      if (v9)
      {
        CFAllocatorRef v12 = v8;
        unint64_t v13 = CFStringGetLength(v7);
        CFIndex v14 = v13;
        if (v13 <= 1) {
          unint64_t v13 = 1;
        }
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v13, 0x8000100u);
        CFIndex v16 = MaximumSizeForEncoding;
        if (MaximumSizeForEncoding < 2097)
        {
          char v17 = &v75;
LABEL_91:
          CFIndex v74 = 0;
          v80.CFIndex location = 0;
          v80.CFIndex length = v14;
          if (CFStringGetBytes(v7, v80, 0x8000100u, 0, 0, v17, v16, &v74))
          {
            CFIndex v56 = v74;
            uint64_t v57 = &v17[v16];
            if (v74 >= 1)
            {
              CFIndex v58 = 0;
              long long v59 = v17;
              uint64_t v57 = &v17[v16];
              do
              {
                int v60 = *v59;
                if (v60 == 37)
                {
                  v58 += 2;
                  if (v58 >= v56) {
                    goto LABEL_105;
                  }
                  int v61 = UnescapeAllWithUTF8_hexvalues[v59[1]];
                  int v60 = UnescapeAllWithUTF8_hexvalues[v59[2]];
                  if (((v60 | v61) & 0x80) != 0) {
                    goto LABEL_105;
                  }
                  v59 += 3;
                  LOBYTE(v60) = v60 + 16 * v61;
                }
                else
                {
                  ++v59;
                }
                *v57++ = v60;
                ++v58;
                CFIndex v56 = v74;
              }
              while (v58 < v74);
            }
            uint64_t v22 = (__CFString *)CFStringCreateWithBytes(v12, &v17[v16], v57 - &v17[v16], 0x8000100u, 0);
          }
          else
          {
LABEL_105:
            uint64_t v22 = 0;
          }
          if (v17 != &v75) {
            free(v17);
          }
          return v22;
        }
        char v17 = (UInt8 *)malloc_type_malloc(2 * MaximumSizeForEncoding, 0xD59F743FuLL);
        if (v17) {
          goto LABEL_91;
        }
      }
      else
      {
        v81.CFIndex location = 0;
        v81.CFIndex length = Length;
        int v19 = CFStringFindWithOptions(v7, @"%", v81, 0, &v73);
        BOOL v20 = v19 == 0;
        if (v19)
        {
          CFStringRef v69 = v6;
          CFMutableStringRef v21 = 0;
          CFIndex v67 = 0;
          uint64_t v22 = 0;
          CFAllocatorRef v63 = (CFAllocatorRef)&__kCFAllocatorNull;
          CFAllocatorRef v64 = v8;
          CFIndex v71 = v11;
          while (1)
          {
            LODWORD(v70) = v20;
            if (v11 - v73.location < 3) {
              break;
            }
            int CharacterAtIndex = CFStringGetCharacterAtIndex(v7, v73.location + 1);
            int v24 = CFStringGetCharacterAtIndex(v7, v73.location + 2);
            if ((CharacterAtIndex - 48) >= 0xA)
            {
              if ((CharacterAtIndex - 97) >= 6)
              {
                if ((CharacterAtIndex - 65) > 5) {
                  break;
                }
                char v25 = -55;
              }
              else
              {
                char v25 = -87;
              }
            }
            else
            {
              char v25 = -48;
            }
            char v26 = 16 * (v25 + CharacterAtIndex);
            if ((v24 - 48) > 9)
            {
              if ((v24 - 97) > 5)
              {
                if ((v24 - 65) > 5) {
                  break;
                }
                UInt8 v27 = v24 + v26 - 55;
              }
              else
              {
                UInt8 v27 = v24 + v26 - 87;
              }
            }
            else
            {
              UInt8 v27 = v24 + v26 - 48;
            }
            UInt8 v75 = v27;
            CFIndex v11 = v71;
            if ((v27 & 0x80) != 0)
            {
              if ((v27 & 0x10) != 0) {
                unsigned int v30 = 4;
              }
              else {
                unsigned int v30 = 3;
              }
              if ((v27 & 0x20) != 0) {
                uint64_t v31 = v30;
              }
              else {
                uint64_t v31 = 2;
              }
              if (v71 < v73.location + (3 * v31)) {
                break;
              }
              unsigned int v68 = v21;
              uint64_t v65 = v31;
              CFIndex v66 = v22;
              unint64_t v32 = v31;
              if (CFStringGetCharacterAtIndex(v7, v73.location + 3) == 37)
              {
                uint64_t v33 = 0;
                BOOL v34 = 1;
                uint64_t v35 = 4;
                do
                {
                  int v36 = CFStringGetCharacterAtIndex(v7, v35 + v73.location);
                  int v37 = CFStringGetCharacterAtIndex(v7, v35 + v73.location + 1);
                  v76[v33] = 0;
                  if ((v36 - 48) >= 0xA)
                  {
                    if ((v36 - 97) >= 6)
                    {
                      if ((v36 - 65) > 5) {
                        break;
                      }
                      char v38 = -55;
                    }
                    else
                    {
                      char v38 = -87;
                    }
                  }
                  else
                  {
                    char v38 = -48;
                  }
                  char v39 = 16 * (v38 + v36);
                  v76[v33] = v39;
                  if ((v37 - 48) >= 0xA)
                  {
                    if ((v37 - 97) >= 6)
                    {
                      if ((v37 - 65) > 5) {
                        break;
                      }
                      char v40 = -55;
                    }
                    else
                    {
                      char v40 = -87;
                    }
                  }
                  else
                  {
                    char v40 = -48;
                  }
                  v76[v33] = v40 + v37 + v39;
                  BOOL v34 = v33 + 2 < v32;
                  if (v32 - 2 == v33) {
                    break;
                  }
                  int v41 = CFStringGetCharacterAtIndex(v7, v35 + v73.location + 2);
                  v35 += 3;
                  ++v33;
                }
                while (v41 == 37);
              }
              else
              {
                BOOL v34 = 1;
              }
              CFAllocatorRef v8 = v64;
              CFStringRef v42 = CFStringCreateWithBytes(v64, &v75, v32, 0x8000100u, 0);
              int v29 = v65;
              uint64_t v22 = v66;
              CFMutableStringRef v21 = v68;
              if (!v42) {
                break;
              }
              CFStringRef v28 = v42;
              CFIndex v43 = CFStringGetLength(v42);
              if ((v27 & 0x30) == 0x20)
              {
                CFMutableStringRef v21 = v68;
                if (!v43 && v75 == 239 && v76[0] == 187 && v76[1] == 191)
                {
                  UniChar v72 = -257;
                  if (!v68) {
                    CFMutableStringRef v21 = CFStringCreateMutableWithExternalCharactersNoCopy(v8, &v72, 1, 1, v63);
                  }
                  CFRelease(v28);
                  CFStringRef v28 = (const __CFString *)CFRetain(v21);
                }
                if (v34)
                {
LABEL_81:
                  if (v28) {
                    CFRelease(v28);
                  }
                  break;
                }
              }
              else
              {
                CFMutableStringRef v21 = v68;
                if (v34) {
                  goto LABEL_81;
                }
              }
              CFIndex v11 = v71;
            }
            else
            {
              UniChar v72 = v27;
              if (!v21) {
                CFMutableStringRef v21 = CFStringCreateMutableWithExternalCharactersNoCopy(v8, &v72, 1, 1, v63);
              }
              CFStringRef v28 = (const __CFString *)CFRetain(v21);
              int v29 = 1;
            }
            CFIndex v44 = v73.location + (3 * v29);
            CFIndex location = CFStringFind(v69, v28, 0).location;
            if (location == -1)
            {
              if (!v22)
              {
                CFIndex location = (CFIndex)CFStringCreateMutable(v8, v11);
                uint64_t v22 = (__CFString *)location;
              }
              CFStringRef v46 = v22;
              CFIndex v47 = v73.location - v67;
              if (v73.location - v67 >= 1)
              {
                int v70 = &v62;
                MEMORY[0x1F4188790](location, v67);
                CFAllocatorRef v49 = v8;
                CFStringRef v50 = v21;
                CFArrayRef v51 = (UniChar *)((char *)&v62 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0));
                v79.CFIndex length = v47;
                CFStringGetCharacters(v7, v79, v51);
                CFStringRef v52 = v51;
                CFMutableStringRef v21 = v50;
                CFAllocatorRef v8 = v49;
                CFStringAppendCharacters(v46, v52, v47);
                CFIndex v11 = v71;
              }
              CFStringAppend(v46, v28);
              CFIndex v67 = v44;
              uint64_t v22 = v46;
            }
            if (v28) {
              CFRelease(v28);
            }
            v82.CFIndex length = v11 - v44;
            v82.CFIndex location = v44;
            int v53 = CFStringFindWithOptions(v7, @"%", v82, 0, &v73);
            BOOL v20 = v53 == 0;
            if (!v53) {
              goto LABEL_84;
            }
          }
          CFIndex v11 = v71;
          LOBYTE(v20) = (_BYTE)v70;
LABEL_84:
          if (v21) {
            CFRelease(v21);
          }
        }
        else
        {
          uint64_t v22 = 0;
          CFIndex v67 = 0;
        }
        if (v20)
        {
          if (!v22) {
            return CFStringCreateCopy(v8, v7);
          }
          v54.CFIndex location = v67;
          if (v11 > v67)
          {
            v54.CFIndex length = v11 - v67;
            CFStringRef v55 = CFStringCreateWithSubstring(v8, v7, v54);
            CFStringAppend(v22, v55);
            CFRelease(v55);
          }
          return v22;
        }
        if (!v22) {
          return v22;
        }
        CFRelease(v22);
      }
      return 0;
    }
  }

  return CFStringCreateCopy(v8, v7);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return CFStringFindWithOptionsAndLocale(theString, stringToFind, rangeToSearch, searchOptions, 0, result);
}

CFStringRef _resolvedPath(char *__dst, unint64_t a2, int a3, int a4, int a5, CFAllocatorRef alloc)
{
  CFAllocatorRef v8 = (char *)a2;
  if ((unint64_t)__dst >= a2) {
    goto LABEL_40;
  }
  CFIndex v11 = (unsigned __int16 *)__dst;
  while (2)
  {
    CFAllocatorRef v12 = (char *)(v11 + 1);
    unint64_t v13 = (char *)(v11 + 2);
    unint64_t v14 = (unint64_t)(v11 + 3);
    while (1)
    {
      if (*v11 != 46) {
        goto LABEL_32;
      }
      if (v12 == v8)
      {
        CFAllocatorRef v8 = (char *)(v11 + 1);
        if (v11 != (unsigned __int16 *)__dst)
        {
          *CFIndex v11 = 0;
          CFAllocatorRef v8 = (char *)v11;
        }
        goto LABEL_40;
      }
      int v15 = *(unsigned __int16 *)v12;
      if (v15 == a3)
      {
        if (v11 == (unsigned __int16 *)__dst && v13 == v8)
        {
          CFAllocatorRef v8 = (char *)(v11 + 2);
          goto LABEL_40;
        }
        memmove(v11, v11 + 2, v8 - v13 + 2);
        uint64_t v16 = -2;
        goto LABEL_19;
      }
      if (v8 - (char *)v11 < 3
        || v15 != 46
        || v13 != v8 && ((unint64_t)(v8 - (char *)v11) < 5 || *(unsigned __int16 *)v13 != a3))
      {
        goto LABEL_32;
      }
      if ((char *)v11 - __dst >= 3) {
        break;
      }
      if (!a4) {
        goto LABEL_32;
      }
      if (v14 >= (unint64_t)v8) {
        goto LABEL_40;
      }
      memmove(v11, v11 + 3, (unint64_t)&v8[-v14 + 2] & 0x1FFFFFFFELL);
      uint64_t v16 = -3;
LABEL_19:
      v8 += 2 * v16;
      if (v11 >= (unsigned __int16 *)v8) {
        goto LABEL_40;
      }
    }
    for (uint64_t i = (char *)(v11 - 2); i >= __dst && *(unsigned __int16 *)i != a3; i -= 2)
      ;
    char v18 = i + 2;
    if (i + 2 == (char *)v11 || (char *)v11 - v18 == 6 && *(_WORD *)v18 == 46 && *((_WORD *)i + 2) == 46)
    {
LABEL_32:
      while (v11 < (unsigned __int16 *)v8 && *v11 != a3)
        ++v11;
      char v18 = (char *)(v11 + 1);
      goto LABEL_35;
    }
    if (v13 == v8)
    {
      if (v18 == __dst)
      {
        *(_DWORD *)char __dst = 3080238;
        *((_WORD *)__dst + 2) = 0;
        CFAllocatorRef v8 = __dst + 6;
      }
      else
      {
        *(_WORD *)char v18 = 0;
        CFAllocatorRef v8 = i + 2;
      }
      break;
    }
    memmove(v18, v11 + 3, (unint64_t)&v8[-v14 + 2] & 0x1FFFFFFFELL);
    CFAllocatorRef v8 = &v18[(void)v8 - v14];
LABEL_35:
    CFIndex v11 = (unsigned __int16 *)v18;
    if (v18 < v8) {
      continue;
    }
    break;
  }
LABEL_40:
  if (a5 && v8 > __dst && v8 - 2 != __dst && *((unsigned __int16 *)v8 - 1) == a3) {
    v8 -= 2;
  }
  if (v8 >= __dst) {
    CFIndex v19 = (v8 - __dst) >> 1;
  }
  else {
    CFIndex v19 = 0;
  }

  return CFStringCreateWithCharactersNoCopy(alloc, (const UniChar *)__dst, v19, alloc);
}

void _CFBundleSplitFileName(const __CFString *a1, __CFString **a2, CFStringRef *a3, CFStringRef *a4, const __CFString *a5, const __CFString *a6, uint64_t a7, int *a8)
{
  CFIndex Length = CFStringGetLength(a1);
  if ((unint64_t)a3 | (unint64_t)a4)
  {
    uint64_t v15 = Length;
    CFIndex v16 = Length;
    do
    {
      if (v16-- < 1)
      {
        uint64_t v18 = 0;
        goto LABEL_9;
      }
    }
    while (CFStringGetCharacterAtIndex(a1, v16) != 46);
    uint64_t v18 = (unsigned __int16)v16;
    if (a3 && v15 - 1 != (unsigned __int16)v16)
    {
      v49.CFIndex length = CFStringGetLength(a1) + ~(unint64_t)(unsigned __int16)v16;
      v49.CFIndex location = (unsigned __int16)v16 + 1;
      *a3 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, v49);
    }
LABEL_9:
    if (a4 && v15 >= 1)
    {
      CFIndex v19 = 0;
      while (CFStringGetCharacterAtIndex(a1, v19) != 46)
      {
        if (v15 == ++v19) {
          goto LABEL_17;
        }
      }
      if (v18 != v19)
      {
        v50.CFIndex length = ~v19 + CFStringGetLength(a1);
        v50.CFIndex location = v19 + 1;
        *a4 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, v50);
      }
    }
  }
LABEL_17:
  CFIndex v20 = CFStringGetLength(a1);
  CFIndex v21 = v20 - 1;
  if (v20 <= 1)
  {
    CFIndex v23 = 0;
    CFIndex v24 = 0;
    CFIndex v31 = 0;
    CFIndex v32 = 0;
    int v33 = 0;
    int v34 = 3;
    goto LABEL_44;
  }
  CFIndex v22 = v20;
  CFStringRef theString2 = a6;
  CFIndex v47 = a8;
  CFIndex v23 = 0;
  CFIndex v24 = 0;
  BOOL v25 = 0;
  CFIndex v26 = 0;
  CFIndex v27 = 1 - v20;
  while (1)
  {
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v21);
    if (CharacterAtIndex == 46) {
      CFIndex v22 = v21;
    }
    if (CharacterAtIndex == 126 && !v25)
    {
      v51.CFIndex location = v21;
      v51.CFIndex length = v22 + v27;
      CFComparisonResult v29 = CFStringCompareWithOptions(a1, a5, v51, 8uLL);
      if (v29 == kCFCompareEqualTo)
      {
        CFIndex v23 = v21;
        CFIndex v24 = v22 + v27;
      }
      BOOL v25 = v29 == kCFCompareEqualTo;
      CFIndex v26 = v21;
      goto LABEL_27;
    }
    if (CharacterAtIndex == 45) {
      break;
    }
LABEL_27:
    unint64_t v30 = v21-- + 1;
    ++v27;
    if (v30 <= 2)
    {
      CFIndex v31 = 0;
      CFIndex v32 = 0;
      int v33 = 0;
      goto LABEL_39;
    }
  }
  if (v25) {
    CFIndex v35 = v26;
  }
  else {
    CFIndex v35 = v22;
  }
  CFIndex v32 = v35 - v21;
  v52.CFIndex location = v21;
  v52.CFIndex length = v35 - v21;
  CFComparisonResult v36 = CFStringCompareWithOptions(a1, theString2, v52, 8uLL);
  if (v36) {
    CFIndex v31 = 0;
  }
  else {
    CFIndex v31 = v21;
  }
  if (v36)
  {
    CFIndex v32 = 0;
    int v33 = 0;
  }
  else
  {
    int v33 = 1;
  }
LABEL_39:
  a8 = v47;
  if ((v33 & v25) != 0) {
    int v34 = 4;
  }
  else {
    int v34 = 3;
  }
  if (v25)
  {
    int v37 = 2;
    goto LABEL_45;
  }
LABEL_44:
  int v37 = 1;
LABEL_45:
  if (v33) {
    int v38 = v34;
  }
  else {
    int v38 = v37;
  }
  *a8 = v38;
  if ((v38 - 2) <= 2)
  {
    unsigned int v39 = v38 - 3;
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a1);
    int v41 = MutableCopy;
    if (v38 == 4 || v38 == 2) {
      CFIndex v43 = v24;
    }
    else {
      CFIndex v43 = 0;
    }
    if (v39 >= 2) {
      v44.CFIndex location = v23;
    }
    else {
      v44.CFIndex location = v31;
    }
    if (v39 >= 2) {
      CFIndex v45 = 0;
    }
    else {
      CFIndex v45 = v32;
    }
    v44.CFIndex length = v43 + v45;
    CFStringDelete(MutableCopy, v44);
    *a2 = v41;
  }
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    return [(__CFString *)(id)theString characterAtIndex:idx];
  }
  else
  {
    char v5 = atomic_load((unint64_t *)&theString->info);
    p_data = &theString->data;
    if ((v5 & 0x60) != 0)
    {
      CFStringRef v7 = *p_data;
    }
    else
    {
      char v8 = atomic_load((unint64_t *)&theString->info);
      CFStringRef v7 = (char *)&p_data[(v8 & 5) != 4];
    }
    char v9 = atomic_load((unint64_t *)&theString->info);
    if ((v9 & 0x10) != 0)
    {
      CFIndex v11 = (UniChar *)&v7[2 * idx];
    }
    else
    {
      unint64_t v10 = atomic_load((unint64_t *)&theString->info);
      CFIndex v11 = (UniChar *)(__CFCharToUniCharTable + 2 * v7[((v10 >> 2) & 1) + idx]);
    }
    return *v11;
  }
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  CFURLRef v1 = anURL;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
    CFURLRef v1 = (CFURLRef)[(__CFURL *)v1 _cfurl];
  }

  return _retainedComponentString((uint64_t)v1, 32, 0, 0);
}

CFStringRef URLPathToPOSIXPath(CFStringRef origString, CFAllocatorRef allocator, CFStringEncoding encoding, int a4)
{
  if (a4) {
    CFStringRef v6 = @"/";
  }
  else {
    CFStringRef v6 = &stru_1ECE10768;
  }
  CFStringRef v7 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(allocator, origString, v6, encoding);
  CFStringRef v8 = v7;
  if (!v7) {
    return v8;
  }
  CFIndex Length = CFStringGetLength(v7);
  if (Length < 2) {
    return v8;
  }
  CFIndex v10 = Length - 1;
  if (CFStringGetCharacterAtIndex(v8, Length - 1) != 47) {
    return v8;
  }
  v13.CFIndex location = 0;
  v13.CFIndex length = v10;
  CFStringRef v11 = CFStringCreateWithSubstring(allocator, v8, v13);
  CFRelease(v8);
  return v11;
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  CFAllocatorRef v6 = allocator;
  uint64_t v46 = *(void *)off_1ECE0A5B0;
  if (encoding == 134217984)
  {
    return CFURLCreateStringByReplacingPercentEscapes(allocator, origString, charsToLeaveEscaped);
  }
  result.CFIndex location = 0;
  result.CFIndex length = 0;
  if (charsToLeaveEscaped)
  {
    CFIndex Length = CFStringGetLength(charsToLeaveEscaped);
    if (origString)
    {
      CFIndex v9 = Length;
      CFIndex v10 = CFStringGetLength(origString);
      v48.CFIndex location = 0;
      v48.CFIndex length = v10;
      if (!CFStringFindWithOptions(origString, @"%", v48, 0, &result)) {
        return CFStringCreateCopy(v6, origString);
      }
      CFIndex v37 = v9;
      CFAllocatorRef alloc = v6;
      CFStringRef range_8 = charsToLeaveEscaped;
      CFStringRef cf = 0;
      CFMutableStringRef Mutable = 0;
      CFIndex v12 = 0;
      int v13 = 8;
      unint64_t v14 = &v45;
LABEL_9:
      uint64_t v15 = 0;
      CFIndex range = v12;
      UniChar chars = 0;
      CFIndex v16 = result.location + 3;
      CFIndex v17 = -result.location;
      while (1)
      {
        uint64_t v18 = v15;
        if (v10 + v17 < 3) {
          break;
        }
        CFIndex v12 = v16;
        if (v15 == v13)
        {
          if (v14 == &v45)
          {
            unint64_t v14 = (char *)malloc_type_malloc(0x10uLL, 0x100004077774924uLL);
            __memmove_chk();
            int v13 = 16;
          }
          else
          {
            CFIndex v19 = malloc_type_malloc(2 * v13, 0x100004077774924uLL);
            memmove(v19, v14, v13);
            free(v14);
            v13 *= 2;
            unint64_t v14 = (char *)v19;
          }
        }
        UniChar chars = CFStringGetCharacterAtIndex(origString, v12 - 2);
        int CharacterAtIndex = CFStringGetCharacterAtIndex(origString, v12 - 1);
        int v21 = chars;
        v14[v18] = 0;
        if ((v21 - 48) >= 0xA)
        {
          if ((v21 - 97) >= 6)
          {
            if ((v21 - 65) > 5) {
              break;
            }
            char v22 = -55;
          }
          else
          {
            char v22 = -87;
          }
        }
        else
        {
          char v22 = -48;
        }
        char v23 = 16 * (v22 + v21);
        v14[v18] = v23;
        if ((CharacterAtIndex - 48) >= 0xA)
        {
          if ((CharacterAtIndex - 97) >= 6)
          {
            if ((CharacterAtIndex - 65) > 5) {
              break;
            }
            char v24 = -55;
          }
          else
          {
            char v24 = -87;
          }
        }
        else
        {
          char v24 = -48;
        }
        v14[v18] = v24 + CharacterAtIndex + v23;
        if (v10 > v12)
        {
          int v25 = CFStringGetCharacterAtIndex(origString, v12);
          CFIndex v16 = v12 + 3;
          v17 -= 3;
          uint64_t v15 = v18 + 1;
          if (v25 == 37) {
            continue;
          }
        }
        CFAllocatorRef v6 = alloc;
        CFStringRef v26 = CFStringCreateWithBytes(alloc, (const UInt8 *)v14, (v18 + 1), encoding, 0);
        if (!v26) {
          goto LABEL_52;
        }
        CFStringRef v27 = v26;
        if (!Mutable) {
          CFMutableStringRef Mutable = CFStringCreateMutable(alloc, v10);
        }
        v28.CFIndex location = range;
        if (result.location - range >= 1)
        {
          v28.CFIndex length = result.location - range;
          CFStringRef v29 = CFStringCreateWithSubstring(alloc, origString, v28);
          CFStringAppend(Mutable, v29);
          CFRelease(v29);
        }
        if (v37)
        {
          CFIndex v30 = CFStringGetLength(v27);
          CFMutableStringRef v31 = (CFMutableStringRef)cf;
          if (!cf) {
            CFMutableStringRef v31 = CFStringCreateMutableWithExternalCharactersNoCopy(alloc, &chars, 1, 1, (CFAllocatorRef)&__kCFAllocatorNull);
          }
          CFStringRef cf = v31;
          if (v30 >= 1)
          {
            for (CFIndex i = 0; i != v30; ++i)
            {
              UniChar chars = CFStringGetCharacterAtIndex(v27, i);
              if (CFStringFind(range_8, cf, 0).location == -1) {
                CFStringAppendCharacters(Mutable, &chars, 1);
              }
              else {
                _appendPercentEscapesForCharacter(&chars, 0, encoding, Mutable);
              }
            }
          }
        }
        else
        {
          CFStringAppend(Mutable, v27);
        }
        CFRelease(v27);
        v49.CFIndex location = v12;
        v49.CFIndex length = v10 - v12;
        if (!CFStringFindWithOptions(origString, @"%", v49, 0, &result))
        {
          char v33 = 1;
          CFIndex range = v12;
          CFAllocatorRef v6 = alloc;
          CFStringRef v34 = cf;
          goto LABEL_53;
        }
        goto LABEL_9;
      }
      CFAllocatorRef v6 = alloc;
LABEL_52:
      CFStringRef v34 = cf;
      char v33 = 0;
LABEL_53:
      if (v34) {
        CFRelease(v34);
      }
      if (v14 != &v45) {
        free(v14);
      }
      if (v33)
      {
        if (Mutable)
        {
          v35.CFIndex location = range;
          if (v10 > range)
          {
            v35.CFIndex length = v10 - range;
            CFStringRef v36 = CFStringCreateWithSubstring(v6, origString, v35);
            CFStringAppend(Mutable, v36);
            CFRelease(v36);
          }
          return Mutable;
        }
        return CFStringCreateCopy(v6, origString);
      }
      if (!Mutable) {
        return Mutable;
      }
      CFRelease(Mutable);
    }
    return 0;
  }
  if (!origString) {
    return 0;
  }

  return CFStringCreateCopy(allocator, origString);
}

uint64_t _CFGetSlash()
{
  return 47;
}

UniChar *resolveAbsoluteURLString(const __CFAllocator *a1, const __CFString *a2, unsigned int a3, uint64_t a4, CFStringRef theString, unsigned int a6, CFIndex *a7)
{
  v21[1] = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v15 = CFStringGetLength(a2);
  if (v15 + Length > 1024)
  {
    CFRange result = (UniChar *)malloc_type_malloc(2 * (v15 + Length), 0x1000040BDFB0063uLL);
    if (result)
    {
      CFIndex v19 = result;
      CFMutableStringRef v20 = resolveAbsoluteURLStringBuffer(a1, a2, a3, a4, theString, a6, a7, result);
      free(v19);
      return (UniChar *)v20;
    }
  }
  else
  {
    MEMORY[0x1F4188790](v15, v16);
    return (UniChar *)resolveAbsoluteURLStringBuffer(a1, a2, a3, a4, theString, a6, a7, (UniChar *)((char *)v21 - v17));
  }
  return result;
}

CFStringRef FileReferenceURLPathToFullURLPath(const __CFString *a1, const __CFAllocator *a2)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (!CFStringGetCString(a1, buffer, 2048, 0x8000100u)) {
    return 0;
  }
  if (*(void *)buffer != 0x692F656C69662E2FLL || v19 != 15716) {
    return 0;
  }
  __endint8x16_t ptr = 0;
  strtoll(v20, &__endptr, 10);
  CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
  if (*__endptr != 46) {
    return StringFromFileSystemRepresentationByAddingPercentEscapes;
  }
  strtoll(__endptr + 1, &__endptr, 10);
  CFAllocatorRef v6 = *__endptr == 47 ? __endptr + 1 : __endptr;
  CFStringRef v7 = (const __CFString *)_FSCreatePathForFileID();
  if (!v7) {
    return 0;
  }
  CFStringRef v8 = v7;
  unint64_t Length = CFStringGetLength(v7);
  if (Length <= 1) {
    unint64_t Length = 1;
  }
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex v11 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding >= 1024) {
    CFIndex v12 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xBB047E6uLL);
  }
  else {
    CFIndex v12 = v21;
  }
  if (CFStringGetCString(v8, v12, v11, 0x8000100u))
  {
    size_t v13 = strlen(v12);
    CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v12, v13, 0, 0, 0, 0);
  }
  else
  {
    CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
  }
  if (v12 != v21) {
    free(v12);
  }
  CFRelease(v8);
  if (*v6)
  {
    CFStringRef v14 = CFStringCreateWithCString(a2, v6, 0x8000100u);
    if (v14)
    {
      CFStringRef v15 = v14;
      CFStringRef v16 = CFStringCreateWithFormat(a2, 0, @"%@/%@", StringFromFileSystemRepresentationByAddingPercentEscapes, v14);
      CFRelease(v15);
    }
    else
    {
      CFStringRef v16 = 0;
    }
    CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
    return v16;
  }
  return StringFromFileSystemRepresentationByAddingPercentEscapes;
}

CFTypeRef _CFURLCreateCurrentDirectoryURL(const __CFAllocator *a1)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  if (!_CFGetCurrentDirectory(__s, 1026)) {
    return 0;
  }
  size_t v2 = strlen(__s);
  return _CFURLCreateWithFileSystemRepresentation(a1, __s, v2, 1, 0);
}

BOOL _CFGetCurrentDirectory(char *a1, int a2)
{
  return getcwd(a1, a2) != 0;
}

uint64_t __CFStringReplaceableLength(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    [(__CFData *)theData increaseLengthBy:extraLength];
  }
  else if (extraLength < 0)
  {
    __break(1u);
  }
  else
  {
    CFIndex v4 = *((void *)theData + 2) + extraLength;
    CFDataSetLength(theData, v4);
  }
}

void sub_182BD7AA0(_Unwind_Exception *a1)
{
  free(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_182BD8AC0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void __rehashs(uint64_t a1, int a2)
{
  unsigned __int8 v2 = a2;
  unint64_t v4 = __NSSetSizes_0[2 * a2];
  uint64_t v5 = malloc_type_calloc(1uLL, 8 * v4, 0x69585060uLL);
  unint64_t v6 = *(unsigned int *)(a1 + 28);
  CFStringRef v7 = *(void **)(a1 + 16);
  if (v6 >> 26)
  {
    uint64_t v8 = 0;
    unint64_t v9 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v6 >> 23) & 0x1F8));
    if (v9 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v9;
    }
    do
    {
      CFIndex v11 = (void *)v7[v8];
      if (v11) {
        BOOL v12 = v11 == &___NSSetM_DeletedMarker;
      }
      else {
        BOOL v12 = 1;
      }
      if (!v12)
      {
        unint64_t v13 = [(id)v7[v8] hash] % v4;
        do
        {
          unint64_t v14 = v13;
          uint64_t v15 = v5[v13];
          unint64_t v16 = v13 + 1;
          if (v16 >= v4) {
            unint64_t v17 = v4;
          }
          else {
            unint64_t v17 = 0;
          }
          unint64_t v13 = v16 - v17;
        }
        while (v15);
        v5[v14] = v11;
      }
      ++v8;
    }
    while (v8 != v10);
  }
  free(v7);
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 28) & 0x3FFFFFF | (v2 << 26);
}

uint64_t _NSIsNSSet(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSSet__);
}

void sub_182BD9A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFURLRef __CFURLHash(const __CFURL *result)
{
  if (result)
  {
    CFStringRef v1 = CFURLGetString(result);
    return (const __CFURL *)CFHash(v1);
  }
  return result;
}

uint64_t __CFURLEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (((*(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16)) & 0xE0006DFF) != 0) {
    return 0;
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  unint64_t v6 = *(const void **)(a2 + 32);
  if (!v5)
  {
    if (v6) {
      return 0;
    }
LABEL_10:
    CFStringRef v7 = CFURLGetString((CFURLRef)a1);
    CFStringRef v8 = CFURLGetString((CFURLRef)a2);
    return CFEqual(v7, v8);
  }
  if (!v6) {
    return 0;
  }
  uint64_t result = CFEqual(v5, v6);
  if (result) {
    goto LABEL_10;
  }
  return result;
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL))
  {
    return (CFStringRef)[(__CFURL *)anURL relativeString];
  }
  else if (*((unsigned char *)anURL + 18))
  {
    return (CFStringRef)atomic_load((unint64_t *)anURL + 3);
  }
  else
  {
    uint64_t v3 = *((void *)anURL + 5);
    if (v3) {
      return *(CFStringRef *)(v3 + 8);
    }
    else {
      return 0;
    }
  }
}

void sub_182BDA2D0(_Unwind_Exception *a1)
{
}

unint64_t *__NSOrderedSetM_new(id *a1, unint64_t a2, char a3)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  uint64_t result = (unint64_t *)CFBasicHashCreate(&__kCFAllocatorSystemDefault, 0x7000u, __NSOrderedSetMCB);
  if (result)
  {
    CFStringRef v7 = result;
    v16[0] = 0;
    CFStringRef v8 = _CFCreateArrayStorage(a2, 0, v16);
    if (v8)
    {
      unint64_t v9 = v8;
      uint64_t v10 = 0;
      if (a1 && a2)
      {
        uint64_t v10 = 0;
        do
        {
          if (CFBasicHashAddValue((uint64_t)v7, (unint64_t)*a1, (uint64_t)*a1))
          {
            if ((a3 & 1) == 0) {
              id v11 = *a1;
            }
            v9[v10++] = *a1;
          }
          ++a1;
          --a2;
        }
        while (a2);
      }
      BOOL v12 = [NSMutableArray alloc];
      uint64_t v13 = [(NSArray *)v12 _initByAdoptingBuffer:v9 count:v10 size:v16[0]];
      if (v13)
      {
        unint64_t v14 = (void *)v13;
        uint64_t v15 = (objc_class *)self;
        uint64_t result = (unint64_t *)__CFAllocateObject(v15, 0);
        if (result)
        {
          result[2] = (unint64_t)v7;
          result[3] = (unint64_t)v14;
          atomic_store(0, result + 1);
          return result;
        }
        CFRelease(v7);

        return 0;
      }
      if ((a3 & 1) == 0 && ((v10 - 1) & 0x8000000000000000) == 0)
      {
        do

        while (v10);
      }
      free(v9);
    }
    CFRelease(v7);
    return 0;
  }
  return result;
}

void sub_182BDA614(_Unwind_Exception *exception_object)
{
}

void sub_182BDA828(_Unwind_Exception *exception_object)
{
}

void *_CFCreateArrayStorage(unint64_t a1, int a2, size_t *a3)
{
  if (a1 >> 61) {
    goto LABEL_7;
  }
  size_t v5 = malloc_good_size(8 * a1);
  if (HIDWORD(v5)) {
    _CFCreateArrayStorage_cold_2();
  }
  size_t v6 = v5;
  uint64_t result = a2 ? malloc_type_calloc(1uLL, v5, 0xBA4241FuLL) : malloc_type_malloc(v5, 0xB9DF98CuLL);
  *a3 = v6 >> 3;
  if (!result) {
LABEL_7:
  }
    _CFCreateArrayStorage_cold_1();
  return result;
}

void *__NSArrayI_transferNew(void *a1, uint64_t a2)
{
  unint64_t v4 = (objc_class *)self;
  size_t v5 = __CFAllocateObject(v4, 0);
  size_t v6 = v5;
  if (v5)
  {
    v5[1] = a2;
    v5[2] = a1;
  }
  else
  {
    free(a1);
  }
  return v6;
}

void *__NSArrayM_transferNew(void *a1, int a2, int a3)
{
  size_t v6 = (objc_class *)self;
  CFStringRef v7 = __CFAllocateObject(v6, 0);
  CFStringRef v8 = v7;
  if (v7)
  {
    void v7[2] = a1;
    *((_DWORD *)v7 + 6) = 0;
    *((_DWORD *)v7 + 7) = a3;
    *((_DWORD *)v7 + 8) = 1;
    *((_DWORD *)v7 + 9) = a2;
  }
  else
  {
    free(a1);
  }
  return v8;
}

unint64_t *_NSSetI_mutableCopyWithZone(void *a1, uint64_t a2)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  uint64_t v3 = a1[1];
  unint64_t v4 = v3 & 0x3FFFFFFFFFFFFFFLL;
  if ((v3 & 0x3FFFFFFFFFFFFFELL) != 0) {
    uint64_t v5 = v3 & 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v5 = 1;
  }
  unint64_t v6 = MEMORY[0x1F4188790](v5, a2);
  CFStringRef v8 = (char *)&v12 - v7;
  size_t v12 = 0;
  if (v4 >= 0x101)
  {
    CFStringRef v8 = (char *)_CFCreateArrayStorage(v6, 0, &v12);
    unint64_t v9 = v8;
  }
  else
  {
    unint64_t v9 = 0;
  }
  objc_msgSend(a1, "getObjects:count:", v8, v4, v12, v13);
  uint64_t v10 = __NSSetM_new((uint64_t)v8, v4, 0);
  free(v9);
  return v10;
}

void sub_182BDADF4(_Unwind_Exception *exception_object)
{
}

uint64_t __CFDateComponentsHash(void *a1)
{
  if (!a1) {
    __CFDateComponentsHash_cold_1();
  }
  unsigned __int8 v2 = (const void *)a1[2];
  if (v2) {
    CFHashCode v3 = CFHash(v2);
  }
  else {
    CFHashCode v3 = 0;
  }
  CFHashCode v4 = a1[3];
  if (v4) {
    CFHashCode v4 = CFHash((CFTypeRef)v4);
  }
  CFHashCode v5 = v4 ^ v3;
  uint64_t v6 = a1[5];
  uint64_t v7 = a1[6];
  if (v6 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v6 = 0;
  }
  uint64_t v8 = 2678437 * v7;
  uint64_t v9 = a1[8];
  uint64_t v10 = a1[9];
  if (v9 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v9 = 0;
  }
  uint64_t v12 = a1[10];
  uint64_t v11 = a1[11];
  if (v11 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v11 = 0;
  }
  uint64_t v13 = a1[18];
  if (v13 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v13 = 0;
  }
  uint64_t v14 = v13 + v6;
  uint64_t v15 = a1[20];
  if (v15 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v15 = 0;
  }
  if (v7 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v8 = 0;
  }
  uint64_t v16 = v15 + v9;
  if (v10 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = 3607 * v10;
  }
  if (v12 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = 61 * v12;
  }
  return v8
       + v5
       + v17
       + v18
       + v11
       + 32832013 * v14
       + 86413 * v16
       + 32 * (41 * a1[17] + 11 * a1[16] - a1[13] + 8 * a1[13] + 3 * a1[14] + a1[15]);
}

uint64_t __CFBinaryPlistWriteToStreamWithOptions(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0);
}

uint64_t __CFCalendarCreateUCalendar(const void *a1, CFLocaleIdentifier localeID, const __CFTimeZone *a3)
{
  CFStringRef LocaleIdentifierFromComponents = localeID;
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, localeID);
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, ComponentsFromLocaleIdentifier);
    CFDictionarySetValue(MutableCopy, @"calendar", a1);
    CFStringRef LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(ComponentsFromLocaleIdentifier);
  }
  MEMORY[0x1F4188790](a1, localeID);
  CStringPtr = (char *)CFStringGetCStringPtr(LocaleIdentifierFromComponents, 0x600u);
  uint64_t v10 = CStringPtr;
  if (CStringPtr
    || (CStringPtr = (char *)CFStringGetCString(LocaleIdentifierFromComponents, v17, 512, 0x600u),
        uint64_t v10 = v17,
        CStringPtr))
  {
    MEMORY[0x1F4188790](CStringPtr, v9);
    CFStringRef Name = CFTimeZoneGetName(a3);
    unint64_t Length = CFStringGetLength(Name);
    if (Length >= 0x200) {
      CFIndex v13 = 512;
    }
    else {
      CFIndex v13 = Length;
    }
    v20.CFIndex location = 0;
    v20.CFIndex length = v13;
    CFStringGetCharacters(Name, v20, v16);
    int v18 = 0;
    uint64_t v14 = __cficu_ucal_open(v16, v13, (uint64_t)v10, 0, &v18);
    if (a1) {
      CFRelease(LocaleIdentifierFromComponents);
    }
  }
  else
  {
    if (a1) {
      CFRelease(LocaleIdentifierFromComponents);
    }
    return 0;
  }
  return v14;
}

const void *_CFErrorCopyUserInfoKey(void *a1, const void *a2)
{
  uint64_t result = _CFErrorCopyUserInfoKeyFromUserInfo(a1, a2);
  if (!result)
  {
    return _CFErrorCopyUserInfoKeyFromCallBack(a1, (uint64_t)a2);
  }
  return result;
}

uint64_t useTemplatePatternGenerator(const __CFLocale *a1, uint64_t a2)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (a1) {
    CFStringRef Identifier = CFLocaleGetIdentifier(a1);
  }
  else {
    CFStringRef Identifier = &stru_1ECE10768;
  }
  CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(Identifier, buffer, 768, 0x600u)) {
      CStringPtr = 0;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  if (!useTemplatePatternGenerator_ptgLocaleName
    || !strcmp((const char *)useTemplatePatternGenerator_ptgLocaleName, CStringPtr))
  {
    uint64_t v5 = useTemplatePatternGenerator_ptg;
    int v13 = 0;
    if (useTemplatePatternGenerator_ptg)
    {
      int v6 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    __cficu_udatpg_close(useTemplatePatternGenerator_ptg);
    useTemplatePatternGenerator_ptg = 0;
    free((void *)useTemplatePatternGenerator_ptgLocaleName);
    useTemplatePatternGenerator_ptgLocaleCFStringRef Name = 0;
    int v13 = 0;
  }
  uint64_t v5 = __cficu_udatpg_open((uint64_t)CStringPtr, &v13);
  useTemplatePatternGenerator_ptg = v5;
  int v6 = v13;
  if (v5)
  {
    if (v13 <= 0)
    {
      useTemplatePatternGenerator_ptgLocaleCFStringRef Name = (uint64_t)strdup(CStringPtr);
      if (!useTemplatePatternGenerator_pressureSrc)
      {
        qos_class_t v7 = qos_class_main();
        global_queue = dispatch_get_global_queue(v7, 2uLL);
        useTemplatePatternGenerator_pressureSrc = (uint64_t)dispatch_source_create((dispatch_source_type_t)off_1ECE0A608, 0, 6uLL, global_queue);
        handler[0] = off_1ECE0A5A0;
        handler[1] = 3221225472;
        handler[2] = __useTemplatePatternGenerator_block_invoke_2;
        handler[3] = &unk_1ECDABCB0;
        handler[4] = &__block_literal_global_1;
        dispatch_source_set_event_handler((dispatch_source_t)useTemplatePatternGenerator_pressureSrc, handler);
        dispatch_resume((dispatch_object_t)useTemplatePatternGenerator_pressureSrc);
        uint64_t v5 = useTemplatePatternGenerator_ptg;
        int v6 = v13;
      }
    }
  }
LABEL_16:
  if (v5) {
    BOOL v9 = v6 < 1;
  }
  else {
    BOOL v9 = 0;
  }
  uint64_t v10 = v9;
  if (a2 && v10) {
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  return v10;
}

const void *_CFErrorCopyUserInfoKeyFromUserInfo(void *a1, const void *a2)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1))
  {
    CFDictionaryRef v4 = (const __CFDictionary *)[a1 userInfo];
    if (v4) {
      goto LABEL_3;
    }
    return 0;
  }
  CFDictionaryRef v4 = (const __CFDictionary *)a1[4];
  if (!v4) {
    return 0;
  }
LABEL_3:
  CFArrayRef Value = CFDictionaryGetValue(v4, a2);
  int v6 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v6;
}

unint64_t *_CFXNotificationRemoveObservers(unint64_t *result, __CFString *a2, __CFString *a3, uint64_t a4)
{
  if (a2 && a3 && a4)
  {
    qos_class_t v7 = result;
    uint64_t v8 = result + 1;
    char v9 = atomic_load(result + 1);
    if ((v9 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
    {
      uint64_t v10 = (void *)_CFAutoreleasePoolPush();
      char v11 = atomic_load(v8);
      if (v11) {
        uint64_t v12 = @"kCFNotificationAnyObject";
      }
      else {
        uint64_t v12 = a3;
      }
      CFXNotificationRegistrarRemove(v7[2], a2, v12, a4);
      return (unint64_t *)_CFAutoreleasePoolPop(v10);
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

void CFXNotificationRegistrarRemove(uint64_t a1, __CFString *cf1, __CFString *a3, uint64_t a4)
{
  unsigned int v7 = *(unsigned __int8 *)(a1 + 24);
  uint64_t v8 = @"kCFNotificationAnyName";
  if (cf1)
  {
    char v9 = cf1;
    if (@"kCFNotificationAnyName" == cf1)
    {
      uint64_t v8 = cf1;
    }
    else if (CFEqual(cf1, @"kCFNotificationAnyName"))
    {
      char v9 = @"kCFNotificationAnyName";
    }
  }
  else
  {
    char v9 = @"kCFNotificationAnyName";
  }
  int v10 = (v7 >> 1) & 1;
  if (a3)
  {
    if (!v10)
    {
      CFHashCode v11 = CFHash(v9);
LABEL_12:
      unint64_t v12 = ((unint64_t)a3 >> 5) & 0x7F;
      goto LABEL_18;
    }
    if (@"kCFNotificationAnyObject" != a3 && CFEqual(a3, @"kCFNotificationAnyObject")) {
      a3 = @"kCFNotificationAnyObject";
    }
    CFHashCode v11 = CFHash(v9);
  }
  else
  {
    a3 = @"kCFNotificationAnyObject";
    CFHashCode v11 = CFHash(v9);
    if (!v10) {
      goto LABEL_12;
    }
  }
  unint64_t v12 = CFHash(a3);
LABEL_18:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationRegistrarRemoveNames(a1, a1 + 32, 0, v9, v11, a3, v12, v10, a4);
  if (v9 == v8)
  {
    _CFXNotificationRegistrarRemoveObjects(a1, a1 + 48, a3, v12, v10, a4);
    if (a3 == @"kCFNotificationAnyObject")
    {
      _CFXNotificationRegistrarRemoveNames(a1, a1 + 64, 1, v9, v11, a3, v12, v10, a4);
      _CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(a1 + 80), a4);
    }
  }
  else if (a3 == @"kCFNotificationAnyObject")
  {
    _CFXNotificationRegistrarRemoveNames(a1, a1 + 64, 1, v9, v11, a3, v12, v10, a4);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
}

void CFNotificationCenterPostNotificationWithOptions(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, CFOptionFlags options)
{
  __CFCheckCFInfoPACSignature((uint64_t)center);
  unint64_t v10 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v10 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v10);
  }
  CFHashCode v11 = [__CFNotification alloc];
  char v12 = atomic_load((unint64_t *)center + 1);
  if (v12) {
    int v13 = 0;
  }
  else {
    int v13 = object;
  }
  char v14 = atomic_load((unint64_t *)center + 1);
  if (v14) {
    CFDictionaryRef v15 = 0;
  }
  else {
    CFDictionaryRef v15 = userInfo;
  }
  uint64_t v16 = [(__CFNotification *)v11 initWithName:name object:v13 userInfo:v15 foundation:0];
  _CFXNotificationPost((unint64_t *)center, v16, options);
}

void _CFXNotificationPost(unint64_t *a1, void *a2, uint64_t a3)
{
  v48[32] = *(void *)off_1ECE0A5B0;
  char v6 = atomic_load(a1 + 1);
  if (v6 & 2) != 0 && (__CFIsDistNoteDaemon) {
    return;
  }
  unsigned int v7 = (__CFString *)[a2 name];
  uint64_t v8 = [a2 object];
  if (v8) {
    char v9 = (__CFString *)v8;
  }
  else {
    char v9 = @"kCFNotificationAnyObject";
  }
  if (!a2 || !v7)
  {
    __break(1u);
    return;
  }
  unint64_t v10 = (void *)_CFAutoreleasePoolPush();
  CFHashCode v11 = v10;
  char v12 = atomic_load(a1 + 1);
  if (a3 & 0x100000) == 0 && (v12)
  {
    v48[0] = 0;
    v50.CFIndex length = CFStringGetLength(v7);
    v50.CFIndex location = 0;
    CFStringGetBytes(v7, v50, 0x8000100u, 0, 0, 0, 0, v48);
    int v13 = (UInt8 *)malloc_type_malloc(v48[0] + 1, 0x603CF76EuLL);
    v51.CFIndex length = CFStringGetLength(v7);
    v51.CFIndex location = 0;
    CFStringGetBytes(v7, v51, 0x8000100u, 0, 0, v13, v48[0], 0);
    v13[v48[0]] = 0;
    notify_post((const char *)v13);
    free(v13);
LABEL_11:
    _CFAutoreleasePoolPop(v11);
    return;
  }
  char v14 = atomic_load(a1 + 1);
  if ((a3 & 0x100000) != 0 || (v14 & 2) == 0)
  {
    uint64_t v17 = _CFAutoreleasePoolPop(v10);
    memset(v48, 0, 256);
    MEMORY[0x1F4188790](v17, v18);
    bzero(&v45, 0x810uLL);
    uint64_t v44 = 0x2000000000;
    uint64_t v46 = &v47;
    CFXNotificationRegistrarFind(a1[2], v7, v9, (unsigned int *)&v44);
    if (v44 < 0x21)
    {
      uint64_t v19 = v48;
      if (v44)
      {
LABEL_21:
        uint64_t v20 = 0;
        unint64_t v21 = 0;
        uint64_t v22 = 0;
        do
        {
          if (CFXNotificationRegistrarValidateToken(a1[2], v46[v20 + 6]))
          {
            char v23 = _CFXRegistrationPost(a1, (uint64_t)&v46[v20], 0, (uint64_t)a2, (void *)v46[v20 + 2]);
            if (v23) {
              v19[v22++] = (CFIndex)v23;
            }
          }
          ++v21;
          v20 += 8;
        }
        while (v21 < v44);
        _CFXNotificationRegistrationBufferDestroy((unsigned int *)&v44);
        if (v22 >= 1)
        {
          char v24 = (void **)v19;
          do
          {
            int v25 = *v24++;
            [v25 waitUntilFinished];

            --v22;
          }
          while (v22);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v19 = (CFIndex *)malloc_type_malloc(8 * v44, 0x80040B8603338uLL);
      if (v44) {
        goto LABEL_21;
      }
    }
    _CFXNotificationRegistrationBufferDestroy((unsigned int *)&v44);
LABEL_32:
    if (v19 != v48) {
      free(v19);
    }
    return;
  }
  CFDictionaryRef v15 = (const void *)[a2 userInfo];
  if (v15)
  {
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (!Data)
    {
      _CFAutoreleasePoolPop(v11);
      return;
    }
  }
  else
  {
    CFDataRef Data = 0;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (Data)
    {
      DispatchCFDataRef Data = _CFDataCreateDispatchData(Data);
      xpc_object_t v27 = xpc_data_create_with_dispatch_data(DispatchData);
      dispatch_release(DispatchData);
    }
    else
    {
      xpc_object_t v27 = 0;
    }
    v48[0] = 0;
    v52.CFIndex length = CFStringGetLength(v7);
    v52.CFIndex location = 0;
    CFStringGetBytes(v7, v52, 0x8000100u, 0, 0, 0, 0, v48);
    CFRange v28 = (UInt8 *)malloc_type_malloc(v48[0] + 1, 0x603CF76EuLL);
    v53.CFIndex length = CFStringGetLength(v7);
    v53.CFIndex location = 0;
    CFStringGetBytes(v7, v53, 0x8000100u, 0, 0, v28, v48[0], 0);
    v28[v48[0]] = 0;
    v48[0] = 0;
    v54.CFIndex length = CFStringGetLength(v9);
    v54.CFIndex location = 0;
    CFStringGetBytes(v9, v54, 0x8000100u, 0, 0, 0, 0, v48);
    CFStringRef v29 = (UInt8 *)malloc_type_malloc(v48[0] + 1, 0x603CF76EuLL);
    v55.CFIndex length = CFStringGetLength(v9);
    v55.CFIndex location = 0;
    CFStringGetBytes(v9, v55, 0x8000100u, 0, 0, v29, v48[0], 0);
    v29[v48[0]] = 0;
    xpc_object_t v30 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v30, "method", "post");
    xpc_dictionary_set_uint64(v30, "version", 1uLL);
    xpc_dictionary_set_string(v30, "name", (const char *)v28);
    xpc_dictionary_set_string(v30, "object", (const char *)v29);
    xpc_dictionary_set_value(v30, "userinfo", v27);
    xpc_dictionary_set_uint64(v30, "options", a3);
    double Current = CFAbsoluteTimeGetCurrent();
    os_unfair_lock_lock_with_options();
    double v32 = *(double *)&_CFXNotificationPost_lastPost;
    if (*(double *)&_CFXNotificationPost_lastPost == 0.0)
    {
      _CFXNotificationPost_lastPost = *(void *)&Current;
    }
    else
    {
      uint64_t v33 = 0;
      unint64_t v34 = (_CFXNotificationPost_sampleIndex + 1) % 0x64uLL;
      _CFXNotificationPost_lastPost = *(void *)&Current;
      _CFXNotificationPost_samples[v34] = Current - v32;
      _CFXNotificationPost_sampleIndex = v34;
      int64x2_t v35 = 0uLL;
      double v36 = 0.0;
      int8x16_t v37 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
      do
      {
        float64x2_t v38 = *(float64x2_t *)&_CFXNotificationPost_samples[v33];
        int8x16_t v39 = (int8x16_t)vceqzq_f64(v38);
        int64x2_t v35 = vsubq_s64(v35, (int64x2_t)vmvnq_s8(v39));
        int8x16_t v40 = vbslq_s8(v39, v37, (int8x16_t)v38);
        double v36 = v36 + *(double *)v40.i64 + *(double *)&v40.i64[1];
        v33 += 2;
      }
      while (v33 != 100);
      uint64_t v41 = vaddvq_s64(v35);
      if ((unint64_t)v41 >= 0xB && Current - *(double *)&_CFXNotificationPost_lastWarning > 10.0)
      {
        double v42 = (double)v41 / v36;
        if (v42 > 60.0)
        {
          _CFXNotificationPost_lastWarning = *(void *)&Current;
          os_unfair_lock_unlock((os_unfair_lock_t)&_CFXNotificationPost_sampleLock);
          if (os_log_type_enabled((os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR)) {
            _CFXNotificationPost_cold_1(v42);
          }
          goto LABEL_58;
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFXNotificationPost_sampleLock);
LABEL_58:
    CFIndex v43 = (_xpc_connection_s *)a1[3];
    _CFSuddenTerminationDisable();
    xpc_connection_send_message(v43, v30);
    xpc_connection_send_barrier(v43, &__block_literal_global_124);
    xpc_release(v30);
    free(v29);
    free(v28);
    if (v27) {
      xpc_release(v27);
    }
    if (Data) {
      CFRelease(Data);
    }
    goto LABEL_11;
  }
  if (Data)
  {
    CFRelease(Data);
  }
}

void _CFXNotificationRegistrationBufferDestroy(unsigned int *a1)
{
  if (*a1)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      _CFXNotificationRegistrationDispose(*((void *)a1 + 2) + v2, *((unsigned __int8 *)a1 + 8));
      ++v3;
      v2 += 64;
    }
    while (v3 < *a1);
  }
  CFDictionaryRef v4 = (unsigned int *)*((void *)a1 + 2);
  if (v4 != a1 + 6)
  {
    free(v4);
  }
}

void CFXNotificationRegistrarFind(uint64_t a1, __CFString *cf1, __CFString *a3, unsigned int *a4)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  xpc_object_t v27 = &v29;
  unsigned int v26 = 0;
  size_t v25 = 32;
  char v24 = 0;
  int v7 = (*(unsigned __int8 *)(a1 + 24) >> 1) & 1;
  *((unsigned char *)a4 + 8) = (*(unsigned char *)(a1 + 24) & 2) != 0;
  CFStringRef v8 = @"kCFNotificationAnyName";
  if (cf1)
  {
    char v9 = cf1;
    if (@"kCFNotificationAnyName" == cf1)
    {
      CFStringRef v8 = cf1;
    }
    else if (CFEqual(cf1, @"kCFNotificationAnyName"))
    {
      char v9 = @"kCFNotificationAnyName";
    }
  }
  else
  {
    char v9 = @"kCFNotificationAnyName";
  }
  if (!a3)
  {
    a3 = @"kCFNotificationAnyObject";
    CFHashCode v10 = CFHash(v9);
    if (!v7) {
      goto LABEL_12;
    }
LABEL_17:
    unint64_t v11 = CFHash(a3);
    goto LABEL_18;
  }
  if (v7)
  {
    if (@"kCFNotificationAnyObject" != a3 && CFEqual(a3, @"kCFNotificationAnyObject")) {
      a3 = @"kCFNotificationAnyObject";
    }
    CFHashCode v10 = CFHash(v9);
    goto LABEL_17;
  }
  CFHashCode v10 = CFHash(v9);
LABEL_12:
  unint64_t v11 = ((unint64_t)a3 >> 5) & 0x7F;
LABEL_18:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v9 != v8)
  {
    uint64_t Name = _CFXNotificationRegistrarFindName(a1, a1 + 32, v9, v10, 0);
    if (Name)
    {
      uint64_t v13 = Name;
      uint64_t Object = _CFXNotificationRegistrarFindObject(a1, Name + 24, a3, v11, v7, 0);
      if (Object)
      {
        uint64_t v15 = Object;
        CFStringRef v16 = (const __CFString *)CFCachedStringCopyString((CFTypeRef *)(v13 + 8));
        _CFXNotificationRegistrarFindObservers((void *)a1, (unsigned int *)(v15 + 16), v16, *(const __CFString **)(v15 + 8), a4, &v27, &v26, &v25, &v24);
        CFRelease(v16);
      }
    }
  }
  if (a3 != @"kCFNotificationAnyObject")
  {
    uint64_t v17 = _CFXNotificationRegistrarFindObject(a1, a1 + 48, a3, v11, v7, 0);
    if (v17) {
      _CFXNotificationRegistrarFindObservers((void *)a1, (unsigned int *)(v17 + 16), v8, *(const __CFString **)(v17 + 8), a4, &v27, &v26, &v25, &v24);
    }
  }
  uint64_t v18 = _CFXNotificationRegistrarFindName(a1, a1 + 64, v9, v10, 0);
  if (v18)
  {
    uint64_t v19 = v18;
    CFStringRef v20 = (const __CFString *)CFCachedStringCopyString((CFTypeRef *)(v18 + 8));
    _CFXNotificationRegistrarFindObservers((void *)a1, (unsigned int *)(v19 + 24), v20, @"kCFNotificationAnyObject", a4, &v27, &v26, &v25, &v24);
    CFRelease(v20);
  }
  _CFXNotificationRegistrarFindObservers((void *)a1, (unsigned int *)(a1 + 80), v8, @"kCFNotificationAnyObject", a4, &v27, &v26, &v25, &v24);
  memset(v28, 0, sizeof(v28));
  uint64_t v21 = v26;
  if (v26)
  {
    uint64_t v22 = (unsigned int *)v27;
    do
    {
      unsigned int v23 = *v22++;
      _CFXNotificationRegistrarInvalidateObserver(a1, v23, -1, -1, (unsigned int *)v28);
      --v21;
    }
    while (v21);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v28);
  if (*(unsigned char *)(a1 + 24)) {
    qsort(*((void **)a4 + 2), *a4, 0x40uLL, (int (__cdecl *)(const void *, const void *))_registrar_compare);
  }
  if (v24) {
    free(v27);
  }
}

uint64_t _CFXNotificationRegistrarFindObject(uint64_t a1, uint64_t a2, CFTypeRef cf1, unint64_t a4, int a5, _DWORD *a6)
{
  unint64_t v6 = *(unsigned int *)(a2 + 8);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *(unsigned int *)(*(void *)a2 + 4 * (a4 % v6));
  if (v7 == -1) {
    return 0;
  }
  while (1)
  {
    uint64_t v12 = *(void *)(a1 + 120);
    uint64_t v13 = v12 + 32 * v7;
    CFTypeRef v14 = *(CFTypeRef *)(v13 + 8);
    if (v14 == cf1 || a5 && CFEqual(cf1, v14)) {
      break;
    }
    uint64_t v7 = *(unsigned int *)(v12 + 32 * v7 + 4);
    if (v7 == -1) {
      return 0;
    }
  }
  if (a6) {
    *a6 = v7;
  }
  return v13;
}

void *_CFXNotificationRegistrarFindObservers(void *result, unsigned int *a2, const __CFString *a3, const __CFString *a4, unsigned int *a5, void **a6, unsigned int *a7, size_t *a8, unsigned char *a9)
{
  int8x16_t v39 = result;
  unsigned int v37 = *a7;
  size_t v34 = *a8;
  int8x16_t ptr = *a6;
  int v33 = *a9;
  uint64_t v9 = *a2;
  if (v9 != -1)
  {
    double v36 = a5 + 6;
    do
    {
      uint64_t v12 = v39[18];
      uint64_t v13 = *(unsigned int *)(v12 + 56 * v9 + 4);
      unsigned int v14 = *a5;
      if (a5[1] >= *a5 + 1)
      {
        uint64_t v17 = (char *)*((void *)a5 + 2);
      }
      else
      {
        size_t v15 = malloc_good_size((unint64_t)(*a5 + 1) << 6);
        CFStringRef v16 = (unsigned int *)*((void *)a5 + 2);
        if (v16 == v36)
        {
          uint64_t v17 = (char *)malloc_type_malloc(v15 & 0x3FFFFFFFC0, 0xBFFB94A8uLL);
          memcpy(v17, *((const void **)a5 + 2), (unint64_t)*a5 << 6);
        }
        else
        {
          uint64_t v17 = (char *)malloc_type_realloc(v16, v15 & 0x3FFFFFFFC0, 0x2C35A74FuLL);
        }
        a5[1] = v15 >> 6;
        *((void *)a5 + 2) = v17;
        unsigned int v14 = *a5;
      }
      uint64_t v18 = v14;
      uint64_t v19 = (CFStringRef *)&v17[64 * (unint64_t)v14];
      uint64_t v20 = v12 + 56 * v9;
      uint64_t v21 = (id *)(v20 + 8);
      if ((*(unsigned char *)(v20 + 45) & 4) != 0)
      {
        uint64_t result = objc_loadWeakRetained(v21);
        if (!result)
        {
          size_t v26 = v37 + 1;
          if (v34 < v26)
          {
            size_t v27 = malloc_good_size(4 * v26);
            size_t v28 = v27;
            if (v33)
            {
              uint64_t result = malloc_type_realloc(ptr, v27 & 0x3FFFFFFFCLL, 0x2C35A74FuLL);
              int8x16_t ptr = result;
            }
            else
            {
              char v29 = malloc_type_malloc(v27 & 0x3FFFFFFFCLL, 0xBFFB94A8uLL);
              uint64_t result = memcpy(v29, ptr, 4 * v37);
              int v33 = 1;
              int8x16_t ptr = v29;
            }
            size_t v34 = v28 >> 2;
          }
          *((_DWORD *)ptr + v37++) = v9;
          goto LABEL_17;
        }
        *(void *)&v17[64 * v18 + 16] = result;
        unsigned int v14 = *a5;
      }
      else
      {
        v19[2] = (CFStringRef)*v21;
      }
      *a5 = v14 + 1;
      uint64_t v22 = &v17[64 * v18];
      int v24 = *(_DWORD *)(v20 + 44);
      unsigned int v23 = (unsigned int *)(v20 + 44);
      CFXNotificationHandlerCopy((void *)v22 + 4, *(void **)(v12 + 56 * v9 + 16), *(CFTypeRef *)(v12 + 56 * v9 + 24), v24);
      CFStringRef *v19 = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
      uint64_t result = &a4->isa;
      if (*((unsigned char *)a5 + 8)) {
        uint64_t result = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4);
      }
      *((void *)v22 + 1) = result;
      *((void *)v22 + 3) = *v23;
      uint64_t v25 = v12 + 56 * v9;
      *((void *)v22 + 6) = v9 | ((unint64_t)*(unsigned int *)(v25 + 40) << 32);
      *((void *)v22 + 7) = *(void *)(v25 + 32);
LABEL_17:
      uint64_t v9 = v13;
    }
    while (v13 != 0xFFFFFFFFLL);
  }
  *a6 = ptr;
  *a7 = v37;
  *a8 = v34;
  *a9 = v33;
  return result;
}

BOOL CFXNotificationRegistrarValidateToken(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  BOOL v6 = *(_DWORD *)(a1 + 156) > a2
    && (uint64_t v5 = *(void *)(a1 + 144), *(_DWORD *)(v5 + 56 * a2 + 40) == HIDWORD(a2))
    && (*(unsigned char *)(v5 + 56 * a2 + 45) & 0x80) == 0;
  os_unfair_lock_unlock(v4);
  return v6;
}

void _CFXNotificationRegistrationDispose(uint64_t a1, int a2)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *(void *)(a1 + 24);
  memset(v7, 0, sizeof(v7));
  _CFXNotificationHandlerRelease((uint64_t *)(a1 + 32), v4, (unsigned int *)v7);
  _CFXNotificationDisposalListRelease((unsigned int *)v7);
  if (a2)
  {
    uint64_t v5 = *(const void **)(a1 + 8);
    if (v5) {
      CFRelease(v5);
    }
  }
  if ((*(unsigned char *)(a1 + 25) & 4) != 0) {

  }
  BOOL v6 = *(const void **)a1;
  if (*(void *)a1)
  {
    CFRelease(v6);
  }
}

void *_CFXRegistrationPost(const void *a1, uint64_t a2, int a3, uint64_t a4, void *a5)
{
  uint64_t v5 = 0;
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  if (a2 && a4)
  {
    if (!_CFXRegistrationPost_operationQueueClass) {
      _CFXRegistrationPost_operationQueueClass Class = (uint64_t)objc_lookUpClass("NSOperationQueue");
    }
    if (!_CFXRegistrationPost_blockOperationClass) {
      _CFXRegistrationPost_blockOperationClass Class = (uint64_t)objc_lookUpClass("NSBlockOperation");
    }
    long long v29 = 0uLL;
    uint64_t v11 = *(void *)(a2 + 24);
    CFXNotificationHandlerCopy(&v29, *(void **)(a2 + 32), *(CFTypeRef *)(a2 + 40), v11);
    uint64_t v12 = *((void *)&v29 + 1) & (v11 << 46 >> 63);
    if ((v11 & 0x400) != 0) {
      id v13 = a5;
    }
    uint64_t v14 = *(void *)(a2 + 48);
    if (v11 & 0x10000 | v12) {
      char v15 = 1;
    }
    else {
      char v15 = a3;
    }
    CFRetain(a1);
    block[0] = off_1ECE0A5A0;
    block[1] = 3221225472;
    uint64_t v20 = ___CFXRegistrationPost_block_invoke;
    uint64_t v21 = &unk_1ECDB0110;
    long long v23 = v29;
    char v28 = v15;
    int v24 = a1;
    uint64_t v25 = v14;
    uint64_t v22 = a4;
    size_t v26 = a5;
    uint64_t v27 = v11;
    if (v12)
    {
      if ([(id)_CFXRegistrationPost_operationQueueClass currentQueue] != v12
        && (pthread_main_np() != 1 || [(id)_CFXRegistrationPost_operationQueueClass mainQueue] != v12))
      {
        uint64_t v5 = objc_opt_new();
        [v5 addExecutionBlock:block];
        [(id)v12 addOperation:v5];
        return v5;
      }
      goto LABEL_20;
    }
    if (*(unsigned char *)(a2 + 26))
    {
      qos_class_t v17 = qos_class_main();
      global_queue = dispatch_get_global_queue(v17, 2uLL);
    }
    else
    {
      if (!a3)
      {
LABEL_20:
        v20((uint64_t)block);
        return 0;
      }
      global_queue = off_1ECE0A5E0;
    }
    dispatch_async(global_queue, block);
    return 0;
  }
  return v5;
}

unint64_t _CFXNotificationRegisterObserver(CFIndex a1, __CFString *a2, __CFString *a3, unint64_t a4, __CFString *a5, void *a6, const void *a7)
{
  unint64_t v10 = a4;
  uint64_t v42 = *(void *)off_1ECE0A5B0;
  char v14 = atomic_load((unint64_t *)(a1 + 8));
  if ((v14 & 1) == 0)
  {
    __int16 v15 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v10 = ~(v15 << 11) & 0x1000 | a4;
  }
  if (!a2 || !a3 || !a5 || a5 == @"kCFNotificationAnyObserver") {
    __break(1u);
  }
  char v16 = atomic_load((unint64_t *)(a1 + 8));
  if (v16 & 2) != 0 && (__CFIsDistNoteDaemon) {
    return 0;
  }
  if ((v10 & 0x400) != 0)
  {
    Class Class = object_getClass(a5);
    if (class_isMetaClass(Class)) {
      v10 &= ~0x400uLL;
    }
    if ((v10 & 0x400) != 0) {
      self;
    }
  }
  _CFNotificationCenterInitializeDependentNotificationIfNecessary((uint64_t)a2);
  unint64_t v17 = CFXNotificationRegistrarAdd(*(void *)(a1 + 16), a2, a3, a5, v10, a6, a7);
  out_tokeuint64_t n = 0;
  uint64_t v19 = (void *)_CFAutoreleasePoolPush();
  char v20 = atomic_load((unint64_t *)(a1 + 8));
  if (v20)
  {
    maxBufLen[0] = 0;
    v47.CFIndex length = CFStringGetLength(a2);
    v47.CFIndex location = 0;
    CFStringGetBytes(a2, v47, 0x8000100u, 0, 0, 0, 0, maxBufLen);
    size_t v34 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x603CF76EuLL);
    v48.CFIndex length = CFStringGetLength(a2);
    v48.CFIndex location = 0;
    CFStringGetBytes(a2, v48, 0x8000100u, 0, 0, v34, maxBufLen[0], 0);
    v34[maxBufLen[0]] = 0;
    if (__CFXNotificationCenterDarwinQueue_initOnce != -1) {
      dispatch_once(&__CFXNotificationCenterDarwinQueue_initOnce, &__block_literal_global_121);
    }
    maxBufLen[0] = (CFIndex)off_1ECE0A5A0;
    maxBufLen[1] = 3221225472;
    maxBufLen[2] = (CFIndex)____CFXNotificationRegisterObserver_block_invoke;
    maxBufLen[3] = (CFIndex)&__block_descriptor_48_e8_v12__0i8l;
    maxBufLen[4] = a1;
    maxBufLen[5] = v17;
    uint32_t v35 = notify_register_dispatch((const char *)v34, &out_token, (dispatch_queue_t)__CFXNotificationCenterDarwinQueue_queue, maxBufLen);
    CFXNotificationRegisteredObserverSetNotifyToken(*(void *)(a1 + 16), v17, out_token);
    free(v34);
    if (v35) {
      unint64_t v17 = 0;
    }
  }
  else
  {
    char v21 = atomic_load((unint64_t *)(a1 + 8));
    if ((v21 & 2) != 0)
    {
      maxBufLen[0] = 0;
      v43.CFIndex length = CFStringGetLength(a2);
      v43.CFIndex location = 0;
      CFStringGetBytes(a2, v43, 0x8000100u, 0, 0, 0, 0, maxBufLen);
      uint64_t v22 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x603CF76EuLL);
      v44.CFIndex length = CFStringGetLength(a2);
      v44.CFIndex location = 0;
      CFStringGetBytes(a2, v44, 0x8000100u, 0, 0, v22, maxBufLen[0], 0);
      v22[maxBufLen[0]] = 0;
      maxBufLen[0] = 0;
      v45.CFIndex length = CFStringGetLength(a3);
      v45.CFIndex location = 0;
      CFStringGetBytes(a3, v45, 0x8000100u, 0, 0, 0, 0, maxBufLen);
      long long v23 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x603CF76EuLL);
      v46.CFIndex length = CFStringGetLength(a3);
      v46.CFIndex location = 0;
      CFStringGetBytes(a3, v46, 0x8000100u, 0, 0, v23, maxBufLen[0], 0);
      v23[maxBufLen[0]] = 0;
      int v24 = strcmp("kCFNotificationAnyName", (const char *)v22);
      if (v24 | strcmp("kCFNotificationAnyObject", (const char *)v23) || (getpid(), !sandbox_check()))
      {
        int v33 = 1;
      }
      else
      {
        CFMutableStringRef v31 = __CFGenerateReport();
        double v32 = "\n\n";
        if (!v31) {
          double v32 = "";
        }
        CFLog(4, @"*** attempt to register for all distributed notifications thwarted by sandboxing.%s%s", v25, v26, v27, v28, v29, v30, (__int16)v32);
        free(v31);
        int v33 = 0;
      }
      xpc_object_t v36 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v36, "method", "register");
      xpc_dictionary_set_uint64(v36, "version", 1uLL);
      xpc_dictionary_set_string(v36, "name", (const char *)v22);
      xpc_dictionary_set_string(v36, "object", (const char *)v23);
      xpc_dictionary_set_uint64(v36, "options", v10 & 0xFFFFFFFFFFFFDBFFLL);
      xpc_dictionary_set_uint64(v36, "token", v17);
      unsigned int v37 = _CFGetProcessPath();
      xpc_dictionary_set_string(v36, "pn", (const char *)*v37);
      CFXNotificationRegisteredObserverSetDistributedConnection(*(void *)(a1 + 16), v17, *(void **)(a1 + 24));
      if (v33)
      {
        float64x2_t v38 = *(_xpc_connection_s **)(a1 + 24);
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(v38, v36);
        xpc_connection_send_barrier(v38, &__block_literal_global_124);
      }
      xpc_release(v36);
      free(v23);
      free(v22);
    }
  }
  _CFAutoreleasePoolPop(v19);
  return v17;
}

void _CFNotificationCenterInitializeDependentNotificationIfNecessary(uint64_t a1)
{
  v11[1] = *(void *)off_1ECE0A5B0;
  v11[0] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_dependentNotificationLock);
  for (uint64_t i = 0; i != 8; ++i)
  {
    uint64_t v2 = (const void **)(&_unprocessedDependentNotificationLists)[i];
    if (!v2) {
      break;
    }
    unint64_t v3 = *v2;
    if (*v2)
    {
      uint64_t v4 = v2 + 1;
      do
      {
        uint64_t v5 = (__CFSet *)_dependentNotifications;
        if (!_dependentNotifications)
        {
          *(_OWORD *)&callBacks.versiouint64_t n = xmmword_1ECE0FD90;
          *(_OWORD *)&callBacks.release = unk_1ECE0FDA0;
          *(_OWORD *)&callBacks.equal = xmmword_1ECE0FDB0;
          uint64_t v5 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
          _dependentNotifications = (uint64_t)v5;
        }
        CFSetAddValue(v5, v3);
        BOOL v6 = *v4++;
        unint64_t v3 = v6;
      }
      while (v6);
    }
    (&_unprocessedDependentNotificationLists)[i] = 0;
  }
  memset(&callBacks.retain, 0, sizeof(CFSetCallBacks));
  callBacks.versiouint64_t n = (CFIndex)v11;
  CFArrayRef Value = CFSetGetValue((CFSetRef)_dependentNotifications, &callBacks);
  os_unfair_lock_unlock((os_unfair_lock_t)&_dependentNotificationLock);
  if (Value)
  {
    uint64_t v8 = (dispatch_once_t *)*((void *)Value + 1);
    block[0] = off_1ECE0A5A0;
    block[1] = 3221225472;
    void block[2] = ___CFNotificationCenterInitializeDependentNotificationIfNecessary_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = Value;
    if (*v8 != -1) {
      dispatch_once(v8, block);
    }
  }
}

unint64_t CFXNotificationRegistrarAdd(uint64_t a1, __CFString *cf, __CFString *cf1, __CFString *a4, int a5, void *a6, const void *a7)
{
  uint64_t v37 = *(void *)off_1ECE0A5B0;
  unsigned int v10 = *(unsigned __int8 *)(a1 + 24);
  if (cf)
  {
    uint64_t v11 = cf;
    if (@"kCFNotificationAnyName" != cf && CFEqual(cf, @"kCFNotificationAnyName")) {
      uint64_t v11 = @"kCFNotificationAnyName";
    }
  }
  else
  {
    uint64_t v11 = @"kCFNotificationAnyName";
  }
  int v12 = (v10 >> 1) & 1;
  if (cf1)
  {
    if (v12 && @"kCFNotificationAnyObject" != cf1 && CFEqual(cf1, @"kCFNotificationAnyObject")) {
      cf1 = @"kCFNotificationAnyObject";
    }
  }
  else
  {
    cf1 = @"kCFNotificationAnyObject";
  }
  id v13 = @"kCFNotificationAnyObserver";
  if (a4) {
    id v13 = a4;
  }
  *(void *)uint64_t v29 = v13;
  CFHashCode v14 = CFHash(v11);
  if (v12) {
    CFHashCode v15 = CFHash(cf1);
  }
  else {
    CFHashCode v15 = ((unint64_t)cf1 >> 5) & 0x7F;
  }
  unint64_t v16 = (unint64_t)atomic_fetch_add((atomic_uint *volatile)(a1 + 168), 1u) << 32;
  unsigned int v34 = -1;
  unsigned int v35 = -1;
  unsigned int v33 = -1;
  memset(v36, 0, sizeof(v36));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v11 == @"kCFNotificationAnyName")
  {
    if (cf1 == @"kCFNotificationAnyObject")
    {
      uint64_t v18 = (unsigned int *)(a1 + 80);
      uint64_t v27 = v16;
      unint64_t v28 = -1;
      uint64_t v20 = a1;
      char v21 = a6;
      uint64_t v22 = a7;
      int v19 = -1;
      goto LABEL_25;
    }
    uint64_t v18 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, a1 + 48, cf1, v15, &v34, -1, v12) + 16);
    int v19 = v34;
    LODWORD(v28) = -1;
    HIDWORD(v28) = v34;
  }
  else
  {
    if (cf1 == @"kCFNotificationAnyObject")
    {
      uint64_t v18 = (unsigned int *)(_CFXNotificationRegistrarAddName(a1, a1 + 64, v11, v14, &v35, 1) + 24);
      char v21 = a6;
      int v24 = a5 | 0x800;
      int v19 = v35;
      unint64_t v28 = __PAIR64__(v34, v35);
      uint64_t v27 = v16;
      uint64_t v20 = a1;
      uint64_t v22 = a7;
      long long v23 = *(void **)v29;
      goto LABEL_27;
    }
    uint64_t v17 = _CFXNotificationRegistrarAddName(a1, a1 + 32, v11, v14, &v35, 0);
    uint64_t v18 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, v17 + 24, cf1, v15, &v34, v35, v12) + 16);
    int v19 = v34;
    unint64_t v28 = __PAIR64__(v34, v35);
  }
  uint64_t v27 = v16;
  uint64_t v20 = a1;
  char v21 = a6;
  uint64_t v22 = a7;
LABEL_25:
  long long v23 = *(void **)v29;
  int v24 = a5;
LABEL_27:
  _CFXNotificationRegistrarAddObserver(v20, v18, v21, v22, v19, v23, &v33, v24, v27, v28, SHIDWORD(v28), (unsigned int *)v36);
  uint64_t v25 = v33;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v36);
  return v16 | v25;
}

_DWORD *_CFXNotificationRegistrarAddObserver(uint64_t a1, unsigned int *a2, void *aBlock, CFTypeRef cf, int a5, void *a6, unsigned int *a7, int a8, uint64_t a9, int a10, int a11, unsigned int *a12)
{
  uint64_t v71 = *(void *)off_1ECE0A5B0;
  if ((*(void *)&a8 & 0xE0000) == 0) {
    _CFXNotificationRegistrarAddObserver_cold_1();
  }
  int v12 = a8;
  CFHashCode v14 = a6;
  int v15 = a5;
  unsigned int v18 = *(_DWORD *)(a1 + 160);
  if (v18 != -1) {
    goto LABEL_3;
  }
  unsigned int v23 = *(_DWORD *)(a1 + 156);
  if (v23 == -1) {
    goto LABEL_40;
  }
  uint64_t v65 = aBlock;
  CFTypeRef v66 = cf;
  size_t v24 = malloc_good_size(56 * v23 + 56);
  uint64_t v25 = *(unsigned int *)(a1 + 156);
  unint64_t v26 = v24 / 0x38;
  uint64_t v27 = *(char **)(a1 + 144);
  uint64_t v28 = (v24 / 0x38);
  uint64_t v29 = (char *)malloc_type_malloc(56 * v28, 0xBFFB94A8uLL);
  uint64_t v30 = v29;
  memset(__src, 0, sizeof(__src));
  if (!v25)
  {
    *(void *)(a1 + 144) = v29;
    CFRange v45 = v27;
    CFHashCode v14 = a6;
LABEL_30:
    free(v45);
    goto LABEL_31;
  }
  uint64_t v60 = v28;
  int v61 = v26;
  uint64_t v62 = a7;
  CFAllocatorRef v63 = a2;
  int v31 = 0;
  uint64_t v32 = 0;
  unsigned int v33 = 0;
  uint64_t v68 = 32;
  int v34 = a11;
  int8x16_t ptr = __src;
  do
  {
    uint64_t v35 = *(void *)&v27[v32 + 8];
    if ((v27[v32 + 45] & 4) == 0)
    {
      *(void *)&v30[v32 + 8] = v35;
      goto LABEL_21;
    }
    if (v35)
    {
      objc_moveWeak((id *)&v30[v32 + 8], (id *)&v27[v32 + 8]);
      goto LABEL_21;
    }
    unsigned int v36 = v33++;
    if (v33 <= v68)
    {
      uint64_t v37 = v68;
LABEL_19:
      float64x2_t v38 = ptr;
      goto LABEL_20;
    }
    uint64_t v37 = (v68 + 1);
    if (ptr == __src)
    {
      int8x16_t ptr = malloc_type_malloc(4 * (v68 + 1), 0xBFFB94A8uLL);
      memcpy(ptr, __src, 4 * v68);
      goto LABEL_19;
    }
    float64x2_t v38 = malloc_type_realloc(ptr, 4 * (v68 + 1), 0x2C35A74FuLL);
LABEL_20:
    v38[v36] = v31;
    *(void *)&v30[v32 + 8] = 0;
    uint64_t v68 = v37;
    int8x16_t ptr = v38;
    int v34 = a11;
LABEL_21:
    int8x16_t v39 = &v30[v32];
    *(void *)int8x16_t v39 = *(void *)&v27[v32];
    *((_OWORD *)v39 + 1) = *(_OWORD *)&v27[v32 + 16];
    *((void *)v39 + 4) = *(void *)&v27[v32 + 32];
    *((void *)v39 + 5) = *(void *)&v27[v32 + 40];
    *((_DWORD *)v39 + 12) = *(_DWORD *)&v27[v32 + 48];
    v32 += 56;
    ++v31;
  }
  while (56 * v25 != v32);
  *(void *)(a1 + 144) = v30;
  free(v27);
  unsigned int v40 = v33;
  a7 = v62;
  a2 = v63;
  CFHashCode v14 = a6;
  if (v40)
  {
    uint64_t v41 = v40;
    uint64_t v42 = (unsigned int *)ptr;
    do
    {
      unsigned int v44 = *v42++;
      unsigned int v43 = v44;
      if (v44 != v34) {
        _CFXNotificationRegistrarInvalidateObserver(a1, v43, a10, v34, a12);
      }
      --v41;
    }
    while (v41);
  }
  CFRange v45 = ptr;
  uint64_t v28 = v60;
  LODWORD(v26) = v61;
  if (ptr != __src) {
    goto LABEL_30;
  }
LABEL_31:
  if (v25 >= v26)
  {
    int v51 = *(_DWORD *)(a1 + 156);
    aBlocuint64_t k = v65;
    CFStringRef cf = v66;
  }
  else
  {
    uint64_t v46 = 56 * v25;
    aBlocuint64_t k = v65;
    CFStringRef cf = v66;
    do
    {
      CFRange v47 = &v30[v46];
      *((void *)v47 + 1) = 0;
      *((void *)v47 + 2) = 0;
      *((void *)v47 + 3) = 0;
      *(void *)(v47 + 44) = 0xFFFFFFFF00008000;
      uint64_t v48 = *(void *)(a1 + 144);
      unsigned int v49 = *(_DWORD *)(a1 + 160);
      if (v49 != -1) {
        *(_DWORD *)(v48 + 56 * v49) = v25;
      }
      CFRange v50 = (_DWORD *)(v48 + v46);
      *CFRange v50 = -1;
      v50[1] = v49;
      int v51 = *(_DWORD *)(a1 + 156) + 1;
      *(_DWORD *)(a1 + 156) = v51;
      *(_DWORD *)(a1 + 160) = v25++;
      v46 += 56;
    }
    while (v28 != v25);
  }
  int v15 = a5;
  if (v51 != v26) {
    _CFXNotificationRegistrarAddObserver_cold_2();
  }
  unsigned int v18 = *(_DWORD *)(a1 + 160);
  if (v18 == -1)
  {
LABEL_40:
    uint64_t v19 = *(void *)(a1 + 144);
    unsigned int v18 = -1;
    goto LABEL_41;
  }
LABEL_3:
  uint64_t v19 = *(void *)(a1 + 144);
  uint64_t v20 = (unsigned int *)(v19 + 56 * v18);
  unsigned int v21 = *v20;
  unsigned int v22 = v20[1];
  *(_DWORD *)(a1 + 160) = v22;
  if (v21 != -1) {
    *(_DWORD *)(v19 + 56 * v21 + 4) = v22;
  }
  if (v22 != -1) {
    *(_DWORD *)(v19 + 56 * v22) = v21;
  }
LABEL_41:
  ++*(_DWORD *)(a1 + 152);
  unsigned int v52 = v18;
  *a7 = v18;
  uint64_t v53 = v19 + 56 * v18;
  CFXNotificationHandlerCopy((void *)(v53 + 16), aBlock, cf, v12);
  *(_DWORD *)(v53 + 40) = HIDWORD(a9);
  *(_DWORD *)(v53 + 48) = v15;
  CFRange v54 = (id *)(v53 + 8);
  if ((v12 & 0x400) != 0)
  {
    if (!objc_storeWeakOrNil(v54, v14))
    {
      *CFRange v54 = v14;
      v12 &= ~0x400u;
    }
  }
  else
  {
    *CFRange v54 = v14;
  }
  uint64_t v55 = v19 + 56 * v52;
  *(_DWORD *)(v55 + 44) = v12;
  *(void *)(v55 + 32) = 0;
  unsigned int v56 = *a7;
  unsigned int v57 = *a2;
  if (*a2 != -1) {
    *(_DWORD *)(*(void *)(a1 + 144) + 56 * v57) = v56;
  }
  uint64_t result = (_DWORD *)(v19 + 56 * v52);
  *uint64_t result = -1;
  result[1] = v57;
  int v59 = a2[1] + 1;
  *a2 = v56;
  a2[1] = v59;
  return result;
}

void *CFXNotificationHandlerCopy(void *result, void *aBlock, CFTypeRef cf, int a4)
{
  uint64_t v4 = result;
  *uint64_t result = 0;
  result[1] = 0;
  if ((a4 & 0x20000) != 0)
  {
    if (aBlock)
    {
      uint64_t result = _Block_copy(aBlock);
      *uint64_t v4 = result;
    }
    if (cf)
    {
      uint64_t result = CFRetain(cf);
      v4[1] = result;
    }
  }
  else if ((a4 & 0x40000) != 0 || (a4 & 0x80000) != 0)
  {
    *uint64_t result = aBlock;
  }
  return result;
}

uint64_t _CFXNotificationRegistrarAddName(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, unsigned int *a5, int a6)
{
  unint64_t v8 = a4;
  uint64_t Name = _CFXNotificationRegistrarFindName(a1, a2, a3, a4, a5);
  if (Name) {
    return Name;
  }
  unsigned int v13 = *(_DWORD *)(a1 + 112);
  if (v13 == -1)
  {
    size_t v15 = malloc_good_size(40 * (*(_DWORD *)(a1 + 108) + 1)) / 0x28;
    uint64_t v16 = *(unsigned int *)(a1 + 108);
    uint64_t v17 = *(void **)(a1 + 96);
    if (v17) {
      unsigned int v18 = malloc_type_realloc(v17, 40 * v15, 0x2C35A74FuLL);
    }
    else {
      unsigned int v18 = malloc_type_malloc(40 * v15, 0xBFFB94A8uLL);
    }
    CFHashCode v14 = v18;
    *(_DWORD *)(a1 + 108) = v15;
    *(void *)(a1 + 96) = v18;
    if (v16 < v15)
    {
      uint64_t v19 = 40 * v16 + 36;
      do
      {
        uint64_t v20 = *(void *)(a1 + 96);
        unsigned int v21 = *(_DWORD *)(a1 + 112);
        if (v21 != -1) {
          *(_DWORD *)(v20 + 40 * v21) = v16;
        }
        uint64_t v22 = v20 + v19;
        *(_DWORD *)(v22 - 36) = -1;
        *(_DWORD *)(v22 - 32) = v21;
        *(_DWORD *)(a1 + 112) = v16;
        *(void *)(v22 - 28) = 0;
        *(_DWORD *)(v22 - 4) = 0;
        *(void *)(*(void *)(a1 + 96) + v19 - 12) = 0;
        *(_DWORD *)(*(void *)(a1 + 96) + v19) = 0;
        ++v16;
        v19 += 40;
      }
      while (v15 != v16);
      CFHashCode v14 = *(_DWORD **)(a1 + 96);
    }
    unsigned int v13 = *(_DWORD *)(a1 + 112);
    if (v13 == -1) {
      goto LABEL_18;
    }
  }
  else
  {
    CFHashCode v14 = *(_DWORD **)(a1 + 96);
  }
  unsigned int v23 = &v14[10 * v13];
  int v24 = *v23;
  int v25 = v23[1];
  *(_DWORD *)(a1 + 112) = v25;
  if (v24 != -1) {
    v14[10 * v24 + 1] = v25;
  }
  if (v25 != -1) {
    v14[10 * v25] = v24;
  }
LABEL_18:
  ++*(_DWORD *)(a1 + 104);
  *a5 = v13;
  uint64_t Name = (uint64_t)&v14[10 * v13];
  _CFXNotificationRegistrarAddCachedName(a3, (void **)(Name + 8));
  unint64_t v26 = (void *)(Name + 24);
  if (a6 == 1)
  {
    *unint64_t v26 = 0xFFFFFFFFLL;
  }
  else
  {
    *unint64_t v26 = 0;
    *(void *)(Name + 32) = 0;
  }
  unsigned int v27 = *a5;
  unsigned int v28 = 31 - __clz(*(_DWORD *)(a2 + 12) + 1);
  if (v28 <= 1) {
    unsigned int v28 = 1;
  }
  size_t v29 = malloc_good_size(4 * v28);
  size_t v30 = v29 >> 2;
  if (!(v29 >> 2)) {
    _CFXNotificationRegistrarAddName_cold_1();
  }
  unsigned int v31 = v13;
  uint64_t v32 = *(_DWORD **)a2;
  if (*(_DWORD *)(a2 + 8) >= v30)
  {
    uint64_t v37 = *(_DWORD **)a2;
  }
  else
  {
    size_t v33 = v29;
    unsigned int v58 = v31;
    unint64_t v59 = v8;
    unsigned int v34 = v27;
    size_t v35 = v29 & 0x3FFFFFFFCLL;
    unsigned int v36 = malloc_type_malloc(v29 & 0x3FFFFFFFCLL, 0xBFFB94A8uLL);
    uint64_t v37 = v36;
    if (v32)
    {
      memset(v36, 255, v35);
      float64x2_t v38 = *(_DWORD **)a2;
      unint64_t v39 = *(unsigned int *)(a2 + 8);
      unsigned int v27 = v34;
      unint64_t v8 = v59;
      if (v39)
      {
        unint64_t v40 = 0;
        unint64_t v41 = *(unsigned int *)(a2 + 8);
        do
        {
          uint64_t v42 = v38[v40];
          if (v42 != -1)
          {
            uint64_t v43 = *(void *)(a1 + 96);
            do
            {
              uint64_t v44 = v43 + 40 * v42;
              unsigned int v47 = *(_DWORD *)(v44 + 4);
              uint64_t v46 = v44 + 4;
              uint64_t v45 = v47;
              unint64_t v48 = *(void *)(v46 + 12);
              if (v38)
              {
                unsigned int v49 = *(_DWORD *)(v43 + 40 * v42);
                if (v38[v48 % v39] == v42) {
                  v38[v48 % v39] = v45;
                }
                if (v49 != -1) {
                  *(_DWORD *)(v43 + 40 * v49 + 4) = v45;
                }
                if (v45 != 0xFFFFFFFFLL) {
                  *(_DWORD *)(v43 + 40 * v45) = v49;
                }
              }
              if (v37)
              {
                unint64_t v50 = v48 % (v33 >> 2);
                unsigned int v51 = v37[v50];
                if (v51 != -1) {
                  *(_DWORD *)(v43 + 40 * v51) = v42;
                }
                *(_DWORD *)(v43 + 40 * v42) = -1;
                *(_DWORD *)uint64_t v46 = v51;
                v37[v50] = v42;
              }
              uint64_t v42 = v45;
            }
            while (v45 != 0xFFFFFFFFLL);
            unint64_t v41 = *(unsigned int *)(a2 + 8);
          }
          ++v40;
        }
        while (v40 < v41);
      }
      *(void *)a2 = v37;
      *(_DWORD *)(a2 + 8) = v30;
      free(v38);
      uint64_t v37 = *(_DWORD **)a2;
    }
    else
    {
      *(void *)a2 = v36;
      *(_DWORD *)(a2 + 8) = v30;
      memset(v36, 255, v35);
      unsigned int v27 = v34;
      unint64_t v8 = v59;
    }
    unsigned int v31 = v58;
  }
  unint64_t v52 = *(unsigned int *)(a2 + 8);
  *(void *)&v14[10 * v31 + 4] = v8;
  if (v27 != -1 && v37)
  {
    unint64_t v53 = v8 % v52;
    uint64_t v54 = *(void *)(a1 + 96);
    unsigned int v55 = v37[v53];
    if (v55 != -1) {
      *(_DWORD *)(v54 + 40 * v55) = v27;
    }
    unsigned int v56 = (_DWORD *)(v54 + 40 * v27);
    *unsigned int v56 = -1;
    v56[1] = v55;
    v37[v53] = v27;
  }
  ++*(_DWORD *)(a2 + 12);
  return Name;
}

void _CFXNotificationRegistrarAddCachedName(const void *a1, void **a2)
{
  key[1] = *(void **)off_1ECE0A5B0;
  key[0] = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  CFDictionaryRef NamePool = _CFXNotificationRegistrarGetNamePool();
  if (CFDictionaryGetKeyIfPresent((uint64_t)NamePool, (unint64_t)a1, key))
  {
    CFArrayRef Value = (char *)CFDictionaryGetValue(NamePool, key[0]);
    CFDictionarySetValue(NamePool, key[0], Value + 1);
  }
  else
  {
    CFDictionarySetValue(NamePool, a1, (const void *)1);
    CFDictionaryGetKeyIfPresent((uint64_t)NamePool, (unint64_t)a1, key);
  }
  *a2 = key[0];
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
}

uint64_t CFDictionaryGetKeyIfPresent(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  long long v5 = 0u;
  long long v6 = 0u;
  CFBasicHashFindBucket(a1, a2, (uint64_t *)&v5);
  if (!*((void *)&v6 + 1)) {
    return 0;
  }
  if (a3) {
    *a3 = *((void *)&v5 + 1);
  }
  return 1;
}

CFMutableDictionaryRef _CFXNotificationRegistrarGetNamePool()
{
  os_unfair_lock_assert_owner((const os_unfair_lock *)&__CFXNotificationRegistrarNamePoolLock);
  CFMutableDictionaryRef result = (CFMutableDictionaryRef)__CFXNotificationRegistrarNamePool;
  if (!__CFXNotificationRegistrarNamePool)
  {
    CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
    __CFXNotificationRegistrarCFDictionaryRef NamePool = (uint64_t)result;
  }
  return result;
}

id __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__(id result, const char *a2, uint64_t a3, void *a4, void *a5, int a6)
{
  if ((void *)kCFXNotificationPlaceholderObserver == a4) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = a4;
  }
  if ((a6 & 0x20000) != 0) {
    return (id)(*((uint64_t (**)(const char *, void *))a2 + 2))(a2, a5);
  }
  if ((a6 & 0x40000) != 0) {
    return objc_msgSend(v8, a2, a5);
  }
  if ((a6 & 0x80000) != 0)
  {
    uint64_t v9 = (uint64_t)result;
    uint64_t v10 = [a5 name];
    char v11 = atomic_load((unint64_t *)(v9 + 8));
    if (v11) {
      int v12 = @"kCFNotificationAnyObject";
    }
    else {
      int v12 = (__CFString *)[a5 object];
    }
    char v13 = atomic_load((unint64_t *)(v9 + 8));
    if (v13) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = [a5 userInfo];
    }
    return (id)((uint64_t (*)(uint64_t, void *, uint64_t, __CFString *, uint64_t))a2)(v9, v8, v10, v12, v14);
  }
  return result;
}

void CFXNotificationHandlerRelease(uint64_t *a1, int a2)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  memset(v2, 0, sizeof(v2));
  _CFXNotificationHandlerRelease(a1, a2, (unsigned int *)v2);
  _CFXNotificationDisposalListRelease((unsigned int *)v2);
}

uint64_t *_CFXNotificationHandlerRelease(uint64_t *result, int a2, unsigned int *a3)
{
  uint64_t v3 = result;
  if ((a2 & 0x20000) != 0)
  {
    if (*result) {
      CFMutableDictionaryRef result = (uint64_t *)__CFXNotificationDisposalListAddItem(a3, *result);
    }
    uint64_t v5 = v3[1];
    if (v5) {
      CFMutableDictionaryRef result = (uint64_t *)__CFXNotificationDisposalListAddItem(a3, v5);
    }
  }
  uint64_t *v3 = 0;
  v3[1] = 0;
  return result;
}

uint64_t _CFXNotificationRegistrarAddObject(uint64_t a1, uint64_t a2, void *a3, unint64_t a4, unsigned int *a5, int a6, int a7)
{
  unint64_t v10 = a4;
  uint64_t v12 = a2;
  uint64_t Object = _CFXNotificationRegistrarFindObject(a1, a2, a3, a4, a7, a5);
  if (Object) {
    return Object;
  }
  unsigned int v15 = *(_DWORD *)(a1 + 136);
  if (v15 == -1)
  {
    unint64_t v17 = v10;
    size_t v18 = malloc_good_size(32 * (*(_DWORD *)(a1 + 132) + 1));
    size_t v19 = v18 >> 5;
    uint64_t v20 = *(unsigned int *)(a1 + 132);
    unsigned int v21 = *(void **)(a1 + 120);
    if (v21) {
      uint64_t v16 = malloc_type_realloc(v21, v18 & 0x1FFFFFFFE0, 0x2C35A74FuLL);
    }
    else {
      uint64_t v16 = malloc_type_malloc(v18 & 0x1FFFFFFFE0, 0xBFFB94A8uLL);
    }
    *(_DWORD *)(a1 + 132) = v19;
    *(void *)(a1 + 120) = v16;
    if (v20 < v19)
    {
      uint64_t v22 = (uint64_t)&v16[8 * v20 + 4];
      do
      {
        uint64_t v23 = *(unsigned int *)(a1 + 136);
        if (v23 != -1) {
          v16[8 * v23] = v20;
        }
        *(_DWORD *)(v22 - 16) = -1;
        *(_DWORD *)(v22 - 12) = v23;
        *(_DWORD *)(a1 + 136) = v20;
        *(_DWORD *)(v22 + 8) = -1;
        ++v20;
        *(void *)(v22 - 8) = 0;
        *(void *)uint64_t v22 = 0xFFFFFFFFLL;
        v22 += 32;
      }
      while ((v18 >> 5) != v20);
    }
    unsigned int v15 = *(_DWORD *)(a1 + 136);
    unint64_t v10 = v17;
    if (v15 == -1) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v16 = *(_DWORD **)(a1 + 120);
  }
  int v24 = &v16[8 * v15];
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  *(_DWORD *)(a1 + 136) = v26;
  if (v25 != -1) {
    v16[8 * v25 + 1] = v26;
  }
  if (v26 != -1) {
    v16[8 * v26] = v25;
  }
LABEL_17:
  ++*(_DWORD *)(a1 + 128);
  *a5 = v15;
  uint64_t v27 = v15;
  unsigned int v56 = v16;
  uint64_t Object = (uint64_t)&v16[8 * v15];
  *(_DWORD *)(Object + 24) = -1;
  *(void *)(Object + 16) = 0xFFFFFFFFLL;
  unsigned int v28 = (void **)(Object + 8);
  if (a7) {
    _CFXNotificationRegistrarAddCachedName(a3, v28);
  }
  else {
    UInt8 *v28 = a3;
  }
  *(_DWORD *)(Object + 24) = a6;
  unsigned int v29 = *a5;
  unsigned int v30 = 31 - __clz(*(_DWORD *)(v12 + 12) + 1);
  if (v30 <= 1) {
    unsigned int v30 = 1;
  }
  size_t v31 = malloc_good_size(4 * v30);
  if (!(v31 >> 2)) {
    _CFXNotificationRegistrarAddObject_cold_1();
  }
  uint64_t v32 = *(unsigned int **)v12;
  if (*(_DWORD *)(v12 + 8) >= (v31 >> 2))
  {
    unsigned int v36 = *(unsigned int **)v12;
  }
  else
  {
    size_t v33 = v31;
    size_t v54 = v31 >> 2;
    unsigned int v55 = v29;
    size_t v34 = v31 & 0x3FFFFFFFCLL;
    size_t v35 = (unsigned int *)malloc_type_malloc(v31 & 0x3FFFFFFFCLL, 0xBFFB94A8uLL);
    unsigned int v36 = v35;
    if (v32)
    {
      uint64_t v52 = Object;
      unint64_t v53 = v10;
      memset(v35, 255, v34);
      uint64_t v37 = *(unsigned int **)v12;
      uint64_t v57 = v12;
      unint64_t v38 = *(unsigned int *)(v12 + 8);
      if (v38)
      {
        unint64_t v39 = 0;
        unint64_t v40 = (v33 >> 2);
        do
        {
          uint64_t v41 = v37[v39];
          if (v41 != -1)
          {
            do
            {
              uint64_t v42 = *(void *)(a1 + 120);
              uint64_t v43 = v42 + 32 * v41;
              unint64_t v44 = *(void *)(v43 + 8);
              if (a7) {
                CFHashCode v45 = CFHash((CFTypeRef)v44);
              }
              else {
                CFHashCode v45 = (v44 >> 5) & 0x7F;
              }
              uint64_t v46 = v42 + 32 * v41;
              uint64_t v47 = *(unsigned int *)(v46 + 4);
              uint64_t v48 = v36[v45 % v40];
              *(_DWORD *)(v46 + 4) = v48;
              *(_DWORD *)uint64_t v43 = -1;
              if (v48 != -1) {
                *(_DWORD *)(*(void *)(a1 + 120) + 32 * v48) = v41;
              }
              v36[v45 % v40] = v41;
              uint64_t v41 = v47;
            }
            while (v47 != 0xFFFFFFFFLL);
            unint64_t v38 = *(unsigned int *)(v57 + 8);
          }
          ++v39;
        }
        while (v39 < v38);
      }
      uint64_t v12 = v57;
      *(void *)uint64_t v57 = v36;
      *(_DWORD *)(v57 + 8) = v54;
      free(v37);
      unsigned int v36 = *(unsigned int **)v57;
      uint64_t Object = v52;
      unint64_t v10 = v53;
    }
    else
    {
      *(void *)uint64_t v12 = v35;
      *(_DWORD *)(v12 + 8) = v54;
      memset(v35, 255, v34);
    }
    unsigned int v29 = v55;
  }
  unint64_t v49 = v10 % *(unsigned int *)(v12 + 8);
  uint64_t v50 = v36[v49];
  if (v50 != -1) {
    *(_DWORD *)(*(void *)(a1 + 120) + 32 * v50) = v29;
  }
  *(_DWORD *)uint64_t Object = -1;
  v56[8 * v27 + 1] = v50;
  v36[v49] = v29;
  ++*(_DWORD *)(v12 + 12);
  return Object;
}

CFTypeRef CFCachedStringCopyString(CFTypeRef *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  CFTypeRef v2 = CFRetain(*a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  return v2;
}

void _CFXNotificationRegistrarRemoveNames(uint64_t a1, uint64_t a2, int a3, __CFString *a4, unint64_t a5, __CFString *cf1, unint64_t a7, int a8, uint64_t a9)
{
  unint64_t v27 = *(unsigned int *)(a2 + 8);
  if (!v27) {
    return;
  }
  if (@"kCFNotificationAnyName" == a4)
  {
    uint64_t v20 = 0;
    while (1)
    {
      unsigned int v21 = *(_DWORD *)(*(void *)a2 + 4 * v20);
      if (v21 != -1) {
        break;
      }
LABEL_20:
      if (++v20 == v27) {
        return;
      }
    }
    while (1)
    {
      uint64_t v22 = *(void *)(a1 + 96) + 40 * v21;
      unsigned int v23 = *(_DWORD *)(v22 + 4);
      int v24 = (unsigned int *)(v22 + 24);
      if (a3 == 1)
      {
        if (_CFXNotificationRegistrarRemoveObservers(a1, v24, a9))
        {
          int v25 = 1;
LABEL_18:
          _CFXNotificationRegistrarRecycleNameRegistration(a1, (uint64_t *)a2, v21, v25);
        }
      }
      else if (_CFXNotificationRegistrarRemoveObjects(a1, (uint64_t)v24, cf1, a7, a8, a9))
      {
        int v25 = 0;
        goto LABEL_18;
      }
      unsigned int v21 = v23;
      if (v23 == -1) {
        goto LABEL_20;
      }
    }
  }
  unsigned int v15 = *(_DWORD *)(*(void *)a2 + 4 * (a5 % v27));
  if (v15 == -1) {
    return;
  }
  while (1)
  {
    uint64_t v16 = *(void *)(a1 + 96);
    uint64_t v17 = v16 + 40 * v15;
    unsigned int v18 = *(_DWORD *)(v17 + 4);
    if (!CFCachedStringEqual((CFTypeRef *)(v17 + 8), a4)) {
      goto LABEL_9;
    }
    size_t v19 = (unsigned int *)(v16 + 40 * v15 + 24);
    if (a3 != 1) {
      break;
    }
    if (_CFXNotificationRegistrarRemoveObservers(a1, v19, a9))
    {
      int v26 = 1;
      goto LABEL_23;
    }
LABEL_9:
    unsigned int v15 = v18;
    if (v18 == -1) {
      return;
    }
  }
  if (!_CFXNotificationRegistrarRemoveObjects(a1, (uint64_t)v19, cf1, a7, a8, a9)) {
    goto LABEL_9;
  }
  int v26 = 0;
LABEL_23:

  _CFXNotificationRegistrarRecycleNameRegistration(a1, (uint64_t *)a2, v15, v26);
}

uint64_t _CFXNotificationRegistrarFindName(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, _DWORD *a5)
{
  unint64_t v5 = *(unsigned int *)(a2 + 8);
  if (v5)
  {
    uint64_t v9 = *(unsigned int *)(*(void *)a2 + 4 * (a4 % v5));
    while (v9 != 0xFFFFFFFFLL)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 96);
      uint64_t v12 = v11 + 40 * v9;
      uint64_t v9 = *(unsigned int *)(v12 + 4);
      if (CFCachedStringEqual((CFTypeRef *)(v12 + 8), a3))
      {
        uint64_t result = v11 + 40 * v10;
        if (a5) {
          *a5 = v10;
        }
        return result;
      }
    }
  }
  return 0;
}

BOOL CFCachedStringEqual(CFTypeRef *a1, const void *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  if (*a1) {
    BOOL v4 = CFEqual(*a1, a2) != 0;
  }
  else {
    BOOL v4 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  return v4;
}

BOOL _CFXNotificationRegistrarRemoveObservers(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  unsigned int v4 = *a2;
  memset(v10, 0, sizeof(v10));
  if (v4 == -1)
  {
LABEL_6:
    _CFXNotificationDisposalListRelease((unsigned int *)v10);
    return a2[1] == 0;
  }
  else
  {
    while (1)
    {
      uint64_t v7 = *(void *)(a1 + 144);
      unsigned int v8 = v4;
      unsigned int v4 = *(_DWORD *)(v7 + 56 * v4 + 4);
      if ((!a3 || *(void *)(v7 + 56 * v8 + 8) == a3)
        && _CFXNotificationRegistrarRecycleObserverRegistration(a1, a2, v8, (unsigned int *)v10))
      {
        return 1;
      }
      if (v4 == -1) {
        goto LABEL_6;
      }
    }
  }
}

void _CFXNotificationDisposalListRelease(unsigned int *a1)
{
  unsigned int v2 = *a1;
  if (*a1 >= 4) {
    int v3 = 4;
  }
  else {
    int v3 = *a1;
  }
  if (v3)
  {
    unint64_t v4 = 1;
    do
    {
      CFRelease(*(CFTypeRef *)&a1[2 * v4]);
      unsigned int v2 = *a1;
      if (*a1 >= 4) {
        unint64_t v5 = 4;
      }
      else {
        unint64_t v5 = v2;
      }
    }
    while (v4++ < v5);
  }
  if (v2 >= 5)
  {
    uint64_t v7 = 0;
    do
    {
      CFRelease(*(CFTypeRef *)(*((void *)a1 + 5) + 8 * v7));
      unint64_t v8 = v7 + 5;
      ++v7;
    }
    while (v8 < *a1);
  }
}

BOOL _CFXNotificationRegistrarRemoveObjects(uint64_t a1, uint64_t a2, __CFString *cf1, unint64_t a4, int a5, uint64_t a6)
{
  unint64_t v7 = *(unsigned int *)(a2 + 8);
  if (v7)
  {
    if (@"kCFNotificationAnyObject" == cf1)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        uint64_t v18 = *(unsigned int *)(*(void *)a2 + 4 * i);
        if (v18 != -1)
        {
          do
          {
            uint64_t v19 = *(void *)(a1 + 120) + 32 * v18;
            uint64_t v20 = *(unsigned int *)(v19 + 4);
            if (_CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(v19 + 16), a6)) {
              _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)a2, v18, a5);
            }
            uint64_t v18 = v20;
          }
          while (v20 != 0xFFFFFFFFLL);
        }
      }
    }
    else
    {
      unsigned int v12 = *(_DWORD *)(*(void *)a2 + 4 * (a4 % v7));
      while (v12 != -1)
      {
        unsigned int v13 = v12;
        uint64_t v14 = *(void *)(a1 + 120) + 32 * v12;
        unsigned int v12 = *(_DWORD *)(v14 + 4);
        unsigned int v15 = *(__CFString **)(v14 + 8);
        if ((v15 == cf1 || a5 && CFEqual(cf1, v15))
          && _CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(v14 + 16), a6)
          && _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)a2, v13, a5))
        {
          return 1;
        }
      }
    }
  }
  return *(_DWORD *)(a2 + 12) == 0;
}

unsigned int *__CFXNotificationDisposalListAddItem(unsigned int *result, uint64_t a2)
{
  int v3 = result;
  uint64_t v4 = *result;
  uint64_t v5 = (v4 - 3);
  if (v4 > 3)
  {
    unsigned int v7 = result[1];
    uint64_t result = (unsigned int *)*((void *)result + 5);
    if (v7 < v5)
    {
      if (result) {
        uint64_t result = (unsigned int *)malloc_type_realloc(result, (v4 - 3), 0x560EF604uLL);
      }
      else {
        uint64_t result = (unsigned int *)malloc_type_malloc(8 * v5, 0x80040B8603338uLL);
      }
      *((void *)v3 + 5) = result;
      v3[1] = v5;
      LODWORD(v4) = *v3;
    }
    long long v6 = &result[2 * (v4 - 4)];
  }
  else
  {
    long long v6 = &result[2 * v4 + 2];
  }
  *(void *)long long v6 = a2;
  unsigned int *v3 = v4 + 1;
  return result;
}

BOOL _CFXNotificationRegistrarRecycleObserverRegistration(uint64_t a1, unsigned int *a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v8 = *(void *)(a1 + 144);
  uint64_t v9 = a3;
  if (a2 && a3 != -1)
  {
    uint64_t v10 = (unsigned int *)(v8 + 56 * a3);
    unsigned int v11 = *v10;
    unsigned int v12 = v10[1];
    if (*a2 == a3) {
      *a2 = v12;
    }
    if (v11 != -1) {
      *(_DWORD *)(v8 + 56 * v11 + 4) = v12;
    }
    if (v12 != -1) {
      *(_DWORD *)(v8 + 56 * v12) = v11;
    }
  }
  if ((*(unsigned char *)(a1 + 24) & 2) != 0)
  {
    int v13 = *(_DWORD *)(v8 + 56 * a3 + 44);
    if ((v13 & 0x2000) != 0)
    {
      uint64_t v18 = v8 + 56 * a3;
      uint64_t v20 = *(void *)(v18 + 32);
      uint64_t v19 = (xpc_connection_t *)(v18 + 32);
      if (v20)
      {
        xpc_object_t v21 = xpc_array_create(0, 0);
        xpc_array_set_uint64(v21, 0xFFFFFFFFFFFFFFFFLL, v9 | ((unint64_t)*(unsigned int *)(v8 + 56 * v9 + 40) << 32));
        xpc_object_t v22 = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_string(v22, "method", "unregister");
        xpc_dictionary_set_uint64(v22, "version", 1uLL);
        xpc_dictionary_set_value(v22, "tokens", v21);
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(*v19, v22);
        xpc_connection_send_barrier(*v19, &__block_literal_global_36);
        xpc_release(v22);
        xpc_release(v21);
        xpc_release(*v19);
      }
      xpc_connection_t *v19 = 0;
    }
    else if ((v13 & 0x4000) != 0)
    {
      uint64_t v14 = v8 + 56 * a3;
      int v17 = *(_DWORD *)(v14 + 32);
      uint64_t v16 = (_DWORD *)(v14 + 32);
      int v15 = v17;
      if (v17) {
        notify_cancel(v15);
      }
      _DWORD *v16 = 0;
    }
  }
  uint64_t v23 = v8 + 56 * v9;
  int v25 = *(_DWORD *)(v23 + 44);
  uint64_t v24 = v23 + 44;
  _CFXNotificationHandlerRelease((uint64_t *)(v24 - 28), v25, a4);
  if ((*(unsigned char *)(v24 + 1) & 4) != 0) {
    objc_destroyWeak((id *)(v8 + 56 * v9 + 8));
  }
  *(void *)(v8 + 56 * v9 + 8) = 0;
  *(_DWORD *)uint64_t v24 = 0x8000;
  int v26 = a2[1] - 1;
  a2[1] = v26;
  if (a3 != -1)
  {
    uint64_t v27 = *(void *)(a1 + 144);
    unsigned int v28 = *(_DWORD *)(a1 + 160);
    if (v28 != -1) {
      *(_DWORD *)(v27 + 56 * v28) = a3;
    }
    *(_DWORD *)(v27 + 56 * v9) = -1;
    *(_DWORD *)(v27 + 56 * v9 + 4) = v28;
    *(_DWORD *)(a1 + 160) = a3;
    int v26 = a2[1];
  }
  --*(_DWORD *)(a1 + 152);
  return v26 == 0;
}

void CFXNotificationRegisteredObserverSetNotifyToken(uint64_t a1, uint64_t a2, int a3)
{
  long long v6 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2)
  {
    uint64_t v7 = *(void *)(a1 + 144);
    if (*(_DWORD *)(v7 + 56 * a2 + 40) == HIDWORD(a2))
    {
      uint64_t v8 = v7 + 56 * a2;
      *(_DWORD *)(v8 + 44) |= 0x4000u;
      *(_DWORD *)(v8 + 32) = a3;
    }
  }

  os_unfair_lock_unlock(v6);
}

uint64_t __cficu_ucal_open(UChar *a1, int32_t a2, uint64_t a3, int a4, int *a5)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  uint64_t v10 = ucal_open();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      unsigned int v11 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", v10);
      unsigned int v12 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a5);
      CFStringRef v13 = ___CFICUCreateErrorStringWithComment(a5, 1);
      CFStringRef v14 = ___CFICUCreateArgumentForUCharInput(a1, a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      int v15 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v17 = "<unknown UCalendarType>";
        int v18 = 138413826;
        __int16 v22 = 1024;
        uint64_t v19 = v11;
        if (a4 == 1) {
          int v17 = "UCAL_GREGORIAN";
        }
        __int16 v20 = 2112;
        CFStringRef v21 = v14;
        if (!a4) {
          int v17 = "UCAL_TRADITIONAL";
        }
        int32_t v23 = a2;
        __int16 v24 = 2080;
        uint64_t v25 = a3;
        __int16 v26 = 2080;
        uint64_t v27 = v17;
        __int16 v28 = 2112;
        unsigned int v29 = v12;
        __int16 v30 = 2112;
        CFStringRef v31 = v13;
        _os_log_debug_impl(&dword_182B90000, v15, OS_LOG_TYPE_DEBUG, "UCalendar *%@ = ucal_open(%@, %d, \"%s\", %s, &%@); %@",
          (uint8_t *)&v18,
          0x44u);
      }
      CFRelease(v11);
      CFRelease(v14);
      CFRelease(v12);
      CFRelease(v13);
    }
  }
  return v10;
}

uint64_t *_CFGetProcessPath()
{
  if (!__CFProcessPath) {
    _CFProcessPath();
  }
  return &__CFProcessPath;
}

uint64_t __cficu_udatpg_open(uint64_t a1, int *a2)
{
  uint64_t v4 = udatpg_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dtpg", v4);
    long long v6 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"UDateTimePatternGenerator *%@ = udatpg_open(\"%s\", &%@); %@", v5, a1, v6, v7);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
  }
  return v4;
}

CFDictionaryRef _copyStringTable(uint64_t a1, __CFString *a2, CFTypeRef cf, const __CFArray *a4, unsigned __int8 a5, CFTypeRef *a6)
{
  uint64_t v52 = *(void *)off_1ECE0A5B0;
  if (cf) {
    unsigned int v12 = (void *)CFRetain(cf);
  }
  else {
    unsigned int v12 = 0;
  }
  if (CFStringHasSuffix(a2, @".nocache"))
  {
    int v13 = _CFExecutableLinkedOnOrAfter(5uLL);
    int v14 = 0;
    if (a4 || v13) {
      goto LABEL_36;
    }
LABEL_10:
    os_unfair_lock_lock_with_options();
    CFDictionaryRef v15 = *(const __CFDictionary **)(a1 + 144);
    if (v15 && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v15, a2)) != 0)
    {
      CFDictionaryRef v17 = Value;
      CFSetRef v18 = *(const __CFSet **)(a1 + 152);
      if (v18 && CFSetContainsValue(v18, a2))
      {
        CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
LABEL_18:
        CFDictionaryRef v21 = Copy;
        CFTypeRef v22 = 0;
        goto LABEL_28;
      }
      if (v12)
      {
        *(void *)&long long v46 = 0;
        *((void *)&v46 + 1) = &v46;
        long long v47 = 0x2020000000uLL;
        *(void *)&long long v34 = off_1ECE0A5A0;
        *((void *)&v34 + 1) = 3221225472;
        *(void *)&long long v35 = ___stringTableFromCacheSatisfyingRequest_block_invoke;
        *((void *)&v35 + 1) = &unk_1ECDFFC10;
        *(void *)&long long v37 = a1;
        *((void *)&v37 + 1) = a2;
        *(void *)&long long v36 = &v46;
        *((void *)&v36 + 1) = v17;
        CFSetApply(v12, (uint64_t)&v34);
        CFTypeRef v22 = *(CFTypeRef *)(*((void *)&v46 + 1) + 24);
        if (v22) {
          CFDictionaryRef v21 = 0;
        }
        else {
          CFDictionaryRef v21 = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
        }
        _Block_object_dispose(&v46, 8);
LABEL_28:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
        if (v21)
        {
          if (a6) {
            *a6 = 0;
          }
          if (v12) {
            goto LABEL_80;
          }
          return v21;
        }
        goto LABEL_33;
      }
    }
    else
    {
      CFSetRef v20 = *(const __CFSet **)(a1 + 152);
      if (v20 && CFSetContainsValue(v20, a2))
      {
        CFDictionaryRef Copy = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        goto LABEL_18;
      }
      if (v12)
      {
        CFTypeRef v22 = CFRetain(v12);
LABEL_25:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
LABEL_33:
        if (v12) {
          CFRelease(v12);
        }
        int v14 = 1;
        unsigned int v12 = (void *)v22;
        goto LABEL_36;
      }
    }
    CFTypeRef v22 = 0;
    goto LABEL_25;
  }
  if (!a4) {
    goto LABEL_10;
  }
  int v14 = 0;
LABEL_36:
  long long v38 = 0u;
  *(_OWORD *)cfa = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  _CFBundleGetStringsSources(a1, 1, a2, a4, (uint64_t)&v34);
  BYTE8(v38) = v14;
  cfa[0] = 0;
  *(_DWORD *)((char *)&v38 + 9) = 0;
  *(_WORD *)((char *)&v38 + 13) = 0;
  cfa[1] = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if ((void)v35)
  {
    if (!(_BYTE)v38) {
      BYTE9(v38) = 1;
    }
    BYTE12(v38) = 1;
  }
  if (*((void *)&v36 + 1))
  {
    if (!BYTE1(v38)) {
      BYTE9(v38) = 1;
    }
    BYTE13(v38) = 1;
  }
  if (*((void *)&v37 + 1))
  {
    if (!BYTE2(v38)) {
      BYTE9(v38) = 1;
    }
    BYTE14(v38) = 1;
  }
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  _loadStringsInOrder((const void *)a1, a2, v12, Mutable, (uint64_t)&v34, a6);
  if (BYTE11(v38))
  {
    CFMutableDictionaryRef v24 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(void *)&long long v46 = off_1ECE0A5A0;
    *((void *)&v46 + 1) = 3221225472;
    *(void *)&long long v47 = ___postProcessStringsDict_block_invoke;
    *((void *)&v47 + 1) = &__block_descriptor_73_e34_____CFString__16__0____CFString__8l;
    *(void *)&long long v48 = Mutable;
    *((void *)&v48 + 1) = v24;
    *(void *)&long long v49 = a1;
    *((void *)&v49 + 1) = a2;
    uint64_t v50 = &v34;
    unsigned __int8 v51 = a5;
    CFTypeRef context = cfa[1];
    uint64_t v41 = (uint64_t)Mutable;
    uint64_t v42 = (void (*)(uint64_t, const void *))&v46;
    uint64_t v43 = (void *)a1;
    unint64_t v44 = (const void *)*((void *)&v35 + 1);
    uint64_t v45 = a5;
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFPlatformSpecificStringDictionaryApplyFunction, &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFLocalizedFormatStringApplyFunction, &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFVariableWidthStringDictionaryApplyFunction, &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFAttributedLocalizedStringDictionaryApplyFunction, &context);
    CFRelease(v24);
  }
  if (!v14)
  {
    CFDictionaryRef v21 = Mutable;
    goto LABEL_77;
  }
  os_unfair_lock_lock_with_options();
  CFDictionaryRef v25 = *(const __CFDictionary **)(a1 + 144);
  if (!v25)
  {
    CFAllocatorRef v26 = CFGetAllocator((CFTypeRef)a1);
    CFDictionaryRef v25 = CFDictionaryCreateMutable(v26, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(void *)(a1 + 144) = v25;
  }
  uint64_t v27 = (void *)CFDictionaryGetValue(v25, a2);
  if (!v27)
  {
    CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v27 = CFDictionaryCreateMutable(v28, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 144), a2, v27);
    CFRelease(v27);
  }
  if (!WORD6(v38) && !BYTE14(v38)) {
    goto LABEL_57;
  }
  if (cf)
  {
    MutableCFDictionaryRef Copy = CFSetCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFSetRef)cf);
    *(void *)&long long v46 = off_1ECE0A5A0;
    *((void *)&v46 + 1) = 3221225472;
    *(void *)&long long v47 = ___copyIngestedCacheResult_block_invoke;
    *((void *)&v47 + 1) = &__block_descriptor_48_e18_v32__0r_v8r_v16_24l;
    *(void *)&long long v48 = v27;
    *((void *)&v48 + 1) = MutableCopy;
    CFDictionaryApply(Mutable, (uint64_t)&v46);
    if (CFSetGetCount(MutableCopy) >= 1)
    {
      CFDictionaryRef v30 = *(const __CFDictionary **)(a1 + 160);
      if (!v30)
      {
        CFDictionaryRef v30 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)(a1 + 160) = v30;
      }
      CFStringRef v31 = CFDictionaryGetValue(v30, a2);
      if (!v31)
      {
        CFStringRef v31 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringSetCallBacks);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 160), a2, v31);
        CFRelease(v31);
      }
      CFTypeRef context = off_1ECE0A5A0;
      uint64_t v41 = 3221225472;
      uint64_t v42 = ___copyIngestedCacheResult_block_invoke_2;
      uint64_t v43 = &__block_descriptor_40_e13_v24__0r_v8_16l;
      unint64_t v44 = v31;
      CFSetApply(MutableCopy, (uint64_t)&context);
    }
    CFRelease(MutableCopy);
    goto LABEL_69;
  }
  if (CFDictionaryGetCount(Mutable) >= 1)
  {
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, v27);
  }
  else
  {
LABEL_57:
    BYTE10(v38) = 1;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 144), a2);
    uint64_t v27 = 0;
  }
LABEL_69:
  if (BYTE10(v38))
  {
    uint64_t v32 = *(__CFSet **)(a1 + 152);
    if (!v32)
    {
      uint64_t v32 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringSetCallBacks);
      *(void *)(a1 + 152) = v32;
    }
    CFSetAddValue(v32, a2);
  }
  if (v27) {
    CFDictionaryRef v21 = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFDictionaryRef)v27);
  }
  else {
    CFDictionaryRef v21 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  CFRelease(Mutable);
LABEL_77:
  long long v48 = v36;
  long long v49 = v37;
  uint64_t v50 = (long long *)v38;
  long long v46 = v34;
  long long v47 = v35;
  _CFBundleReleaseStringsSources((uint64_t)&v46);
  CFRelease(cfa[1]);
  if (cfa[0]) {
    CFRelease(cfa[0]);
  }
  if (v12) {
LABEL_80:
  }
    CFRelease(v12);
  return v21;
}

void sub_182BE01DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    return (CFDictionaryRef)[(__CFDictionary *)theDict copyWithZone:0];
  }
  else
  {
    CFDictionaryRef Copy = (unint64_t *)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theDict);
    CFDictionaryRef v6 = (const __CFDictionary *)Copy;
    if (Copy)
    {
      unint64_t v7 = atomic_load(Copy + 1);
      unint64_t v8 = v7;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)Copy + 1, &v8, v7 | 0x40);
        BOOL v9 = v8 == v7;
        unint64_t v7 = v8;
      }
      while (!v9);
      _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x12uLL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
    return v6;
  }
}

uint64_t __NSArrayM_copy(uint64_t a1)
{
  if (__cf_tsanReadFunction) {
    __cf_tsanReadFunction(a1, v1, __CFTSANTagMutableArray);
  }
  unint64_t v3 = atomic_load((unint64_t *)(a1 + 8));
  unsigned int v4 = *(_DWORD *)(a1 + 36);
  if (v3)
  {
    if (v4 >= 4)
    {
LABEL_5:
      if (!atomic_load((unint64_t *)(a1 + 8)))
      {
        CFDictionaryRef v6 = _cow_create(a1, 1);
        uint64_t v7 = 0;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), (unint64_t *)&v7, (unint64_t)v6);
        if (v7) {
          free(v6);
        }
      }
      unint64_t v8 = (objc_class *)self;
      id v9 = __CFAllocateObject(v8, 0);
      uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)(a1 + 8));
      _cow_copy(a1, 1, v10, (uint64_t)__NSArray_cowCallbacks, (uint64_t)v9, 0);
      return (uint64_t)v9;
    }
  }
  else if (v4 > 5)
  {
    goto LABEL_5;
  }
  unsigned int v12 = __NSArrayImmutablePlaceholder();
  uint64_t v13 = *(unsigned int *)(a1 + 36);

  return objc_msgSend(v12, "initWithArray:range:copyItems:", a1, 0, v13, 0);
}

void _cow_copy(uint64_t a1, uint64_t a2, os_unfair_lock_t lock, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_lock(lock);
  int os_unfair_lock_opaque_low = LOWORD(lock[1]._os_unfair_lock_opaque);
  int os_unfair_lock_opaque_high = HIWORD(lock[1]._os_unfair_lock_opaque);
  if (a6 == 1)
  {
    if (os_unfair_lock_opaque_high != 0xFFFF)
    {
      LOWORD(os_unfair_lock_opaque_high) = os_unfair_lock_opaque_high + 1;
LABEL_8:
      LOWORD(lock[1]._os_unfair_lock_opaque) = os_unfair_lock_opaque_low;
      HIWORD(lock[1]._os_unfair_lock_opaque) = os_unfair_lock_opaque_high;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))a4)(a1, a2, a5, a6);
      goto LABEL_9;
    }
  }
  else if (os_unfair_lock_opaque_low != 0xFFFF)
  {
    LOWORD(os_unfair_lock_opaque_low) = os_unfair_lock_opaque_low + 1;
    goto LABEL_8;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))a4)(a1, a2, a5, a6);
  if (((*(uint64_t (**)(uint64_t))(a4 + 8))(a5) & 1) == 0) {
    _cow_copy_cold_1();
  }
  (*(void (**)(uint64_t, void))(a4 + 16))(a5, 0);
LABEL_9:

  os_unfair_lock_unlock(lock);
}

__n128 cow_copy_instance(uint64_t a1, int a2, uint64_t a3, int a4)
{
  unsigned int v4 = &OBJC_IVAR_____NSFrozenArrayM_cow;
  if (a2 == 1) {
    uint64_t v5 = &OBJC_IVAR_____NSArrayM_cow;
  }
  else {
    uint64_t v5 = &OBJC_IVAR_____NSFrozenArrayM_cow;
  }
  if (a2 == 1) {
    CFDictionaryRef v6 = &OBJC_IVAR_____NSArrayM_storage;
  }
  else {
    CFDictionaryRef v6 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + *v5));
  unint64_t v8 = (__n128 *)(a1 + *v6);
  if (a4 == 1)
  {
    unsigned int v4 = &OBJC_IVAR_____NSArrayM_cow;
    id v9 = &OBJC_IVAR_____NSArrayM_storage;
  }
  else
  {
    id v9 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  }
  atomic_store(v7, (unint64_t *)(a3 + *v4));
  uint64_t v10 = *v9;
  unint64_t v11 = v8[1].n128_u64[0];
  __n128 result = *v8;
  uint64_t v13 = (__n128 *)(a3 + v10);
  *uint64_t v13 = *v8;
  v13[1].n128_u64[0] = v11;
  return result;
}

_WORD *_cow_create(uint64_t a1, int a2)
{
  __n128 result = malloc_type_calloc(8uLL, 1uLL, 0x56E69C1FuLL);
  if (!result) {
    _cow_create_cold_1();
  }
  *(_DWORD *)__n128 result = 0;
  result[2] = a2 != 1;
  result[3] = a2 == 1;
  return result;
}

uint64_t __initWithArrayDontCopyItems(__objc2_class **a1, void *a2)
{
  unsigned int v4 = (__objc2_class *)objc_opt_class();
  if (v4 != __NSArrayI && v4 != __NSArrayM && v4 != __NSFrozenArrayM) {
    return 0;
  }
  if (a1 == &___mutablePlaceholderArray)
  {
    return [a2 mutableCopyWithZone:0];
  }
  else
  {
    if (a1 != &___immutablePlaceholderArray) {
      return 0;
    }
    return [a2 copyWithZone:0];
  }
}

uint64_t __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void ___stringTableFromCacheSatisfyingRequest_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2))
  {
    CFDictionaryRef v4 = *(const __CFDictionary **)(*(void *)(a1 + 48) + 160);
    if (!v4
      || (CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(v4, *(const void **)(a1 + 56))) == 0
      || !CFSetContainsValue(Value, a2))
    {
      CFDictionaryRef v6 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (!v6)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        CFDictionaryRef v6 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      }
      CFSetAddValue(v6, a2);
      unint64_t v7 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 48);
        uint64_t v9 = *(void *)(a1 + 56);
        int v10 = 138412802;
        uint64_t v11 = v8;
        __int16 v12 = 2112;
        uint64_t v13 = a2;
        __int16 v14 = 2112;
        uint64_t v15 = v9;
        _os_log_debug_impl(&dword_182B90000, v7, OS_LOG_TYPE_DEBUG, "Lazy cache miss for bundle: %@ key: %@ table: %@", (uint8_t *)&v10, 0x20u);
      }
    }
  }
}

CFMutableDictionaryRef __CFPropertyListCreateFilteredDictionary(const __CFAllocator *a1, const __CFSet *a2, uint64_t a3, int a4, unint64_t a5, uint64_t a6, int a7, int a8, int a9, int a10, int a11, const __CFSet *a12, uint64_t a13)
{
  uint64_t v84 = *(void *)off_1ECE0A5B0;
  CFTypeRef cf = 0;
  CFSetRef theSet = 0;
  __CFPropertyListCreateSplitKeypaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, &theSet, (__CFSet **)&cf);
  if (!theSet) {
    return 0;
  }
  if (a5 < 8) {
    goto LABEL_36;
  }
  unint64_t v20 = *(void *)(a6 + 24) - 1;
  if (v20 < a5) {
    goto LABEL_36;
  }
  CFDictionaryRef v21 = (unsigned char *)(a3 + a5);
  if (a3 + a5 == -1) {
    goto LABEL_36;
  }
  char v22 = *v21;
  if ((*v21 & 0xF0) != 0xD0) {
    goto LABEL_36;
  }
  int32_t v23 = (unsigned int *)(v21 + 1);
  unint64_t v24 = v22 & 0xF;
  if ((v22 & 0xF) == 0xF)
  {
    if (a3 + v20 < (unint64_t)v23) {
      goto LABEL_36;
    }
    CFDictionaryRef v25 = v21 + 2;
    char v26 = *(unsigned char *)v23;
    if ((*(unsigned char *)v23 & 0xF0) != 0x10) {
      goto LABEL_36;
    }
    unsigned int v27 = v26 & 0xF;
    uint64_t v28 = 1 << (v26 & 0xF);
    if (__CFADD__(v28, v25) || (unint64_t)v23 + v28 > a3 + v20) {
      goto LABEL_36;
    }
    switch((char)v28)
    {
      case 1:
        unint64_t v24 = *v25;
        goto LABEL_24;
      case 2:
        unint64_t v24 = __rev16(*(unsigned __int16 *)((char *)v23 + 1));
        goto LABEL_24;
      case 4:
        unint64_t v24 = bswap32(*(unsigned int *)((char *)v23 + 1));
        goto LABEL_24;
      case 8:
        unint64_t v24 = bswap64(*(void *)((char *)v23 + 1));
        goto LABEL_23;
      default:
        if (v27 >= 8)
        {
          unint64_t v24 = 0;
          uint64_t v29 = 0;
          int32_t v23 = (unsigned int *)&v25[v28];
          goto LABEL_29;
        }
        unint64_t v24 = 0;
        if ((v28 & 0xFE) != 0) {
          uint64_t v30 = v28;
        }
        else {
          uint64_t v30 = 1;
        }
        CFStringRef v31 = (unsigned __int8 *)v23 + 1;
        do
        {
          unsigned int v32 = *v31++;
          unint64_t v24 = v32 | (v24 << 8);
          --v30;
        }
        while (v30);
LABEL_23:
        if ((v24 & 0x8000000000000000) != 0) {
          goto LABEL_36;
        }
LABEL_24:
        int32_t v23 = (unsigned int *)&v25[v28];
        break;
    }
  }
  if (v24)
  {
    if (!is_mul_ok(2 * v24, *(unsigned __int8 *)(a6 + 7))) {
      goto LABEL_36;
    }
    uint64_t v29 = 2 * v24 * *(unsigned __int8 *)(a6 + 7);
  }
  else
  {
    uint64_t v29 = 0;
  }
LABEL_29:
  if (__CFADD__(v29, v23) || a3 + v20 < (unint64_t)v23 + v29 - 1)
  {
LABEL_36:
    CFRelease(theSet);
    if (cf) {
      CFRelease(cf);
    }
    return 0;
  }
  uint64_t v69 = *(unsigned __int8 *)(a6 + 7);
  uint64_t v73 = 0;
  CFIndex v74 = &v73;
  uint64_t v75 = 0x2020000000;
  CFIndex Count = 0;
  CFIndex Count = CFSetGetCount(theSet);
  v72[0] = off_1ECE0A5A0;
  v72[1] = 3221225472;
  v72[2] = ____CFPropertyListCreateFilteredDictionary_block_invoke;
  v72[3] = &unk_1ECDAB878;
  v72[4] = &v73;
  CFSetApply(theSet, (uint64_t)v72);
  *(void *)buffer = 0;
  uint64_t v83 = 0;
  if (CFSetGetCount(theSet) != 1) {
    goto LABEL_40;
  }
  values[0] = 0;
  CFSetGetValues(theSet, (const void **)values);
  CStringPtr = CFStringGetCStringPtr((CFStringRef)values[0], 0);
  if (!CStringPtr)
  {
    if (CFStringGetCString((CFStringRef)values[0], buffer, 16, 0))
    {
      CStringPtr = buffer;
      goto LABEL_35;
    }
LABEL_40:
    CFTypeRef v66 = 0;
    CFIndex v67 = 0;
    goto LABEL_41;
  }
LABEL_35:
  CFIndex v67 = CStringPtr;
  CFTypeRef v66 = (void *)strlen(CStringPtr);
LABEL_41:
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v24)
  {
    uint64_t v71 = 0;
    unint64_t v65 = v24 * v69;
    unint64_t v70 = a3 + 8;
    if (v66) {
      BOOL v36 = v67 == 0;
    }
    else {
      BOOL v36 = 1;
    }
    char v37 = v36;
    char v68 = v37;
    if (a7) {
      long long v38 = 0;
    }
    else {
      long long v38 = values;
    }
    uint64_t v64 = (uint64_t)v38;
    while (1)
    {
      if (!v74[3]) {
        goto LABEL_123;
      }
      if (v70 > (unint64_t)v23) {
        goto LABEL_120;
      }
      uint64_t v39 = *(void *)(a6 + 24);
      uint64_t v40 = *(unsigned __int8 *)(a6 + 7);
      if (a3 + v39 - v40 < (unint64_t)v23) {
        goto LABEL_120;
      }
      unint64_t v41 = *(unsigned __int8 *)(a6 + 7);
      switch(*(unsigned char *)(a6 + 7))
      {
        case 0:
          break;
        case 1:
          unint64_t v41 = *(unsigned __int8 *)v23;
          break;
        case 2:
          unint64_t v41 = __rev16(*(unsigned __int16 *)v23);
          break;
        case 4:
          unint64_t v41 = bswap32(*v23);
          break;
        case 8:
          unint64_t v41 = bswap64(*(void *)v23);
          break;
        default:
          unint64_t v41 = 0;
          uint64_t v42 = v23;
          do
          {
            unsigned int v43 = *(unsigned __int8 *)v42;
            uint64_t v42 = (unsigned int *)((char *)v42 + 1);
            unint64_t v41 = v43 | (v41 << 8);
            --v40;
          }
          while (v40);
          break;
      }
      if (*(void *)(a6 + 8) <= v41)
      {
LABEL_120:
        CFRelease(Mutable);
LABEL_122:
        CFMutableDictionaryRef Mutable = 0;
        goto LABEL_123;
      }
      unint64_t v44 = *(unsigned __int8 *)(a6 + 6);
      uint64_t v45 = (unsigned int *)(a3 + v39 + v41 * v44);
      switch(*(unsigned char *)(a6 + 6))
      {
        case 0:
          break;
        case 1:
          unint64_t v44 = *(unsigned __int8 *)v45;
          break;
        case 2:
          unint64_t v44 = __rev16(*(unsigned __int16 *)v45);
          break;
        case 4:
          unint64_t v44 = bswap32(*v45);
          break;
        case 8:
          unint64_t v44 = bswap64(*(void *)v45);
          break;
        default:
          uint64_t v46 = *(unsigned __int8 *)(a6 + 6);
          unint64_t v44 = 0;
          do
          {
            unsigned int v47 = *(unsigned __int8 *)v45;
            uint64_t v45 = (unsigned int *)((char *)v45 + 1);
            unint64_t v44 = v47 | (v44 << 8);
            --v46;
          }
          while (v46);
          break;
      }
      CFSetRef v48 = theSet;
      CFStringRef Copy = 0;
      if ((v68 & 1) == 0 && (*(unsigned char *)(a3 + v44) & 0xF0) == 0x50) {
        break;
      }
      values[0] = 0;
      uint64_t v79 = 0;
      if (__CFBinaryPlistCreateObjectFiltered(a3, a4, v44, a6, (int)&__kCFAllocatorSystemDefault, 0x80000000, a9, a11, a12, 0, 0, (uint64_t)values, (uint64_t)&v79))
      {
        if ((unint64_t)(v79 - 17) >= 3 && v79 != 0)
        {
          if (v79 == 7 && __CFPropertyListKeyPassesFilterSet((uint64_t)values[0], v48)) {
            CFStringRef Copy = CFStringCreateCopy(a1, (CFStringRef)values[0]);
          }
          if (values[0]) {
            CFRelease(values[0]);
          }
          int v49 = 0;
LABEL_88:
          CFStringRef v51 = Copy;
          if (Copy) {
            goto LABEL_90;
          }
          goto LABEL_89;
        }
      }
      CFStringRef v51 = 0;
      int v49 = 1;
LABEL_89:
      if (v49) {
        goto LABEL_120;
      }
LABEL_90:
      if (v51)
      {
        uint64_t v52 = (unsigned int *)((char *)v23 + v65);
        if (v70 > (unint64_t)v23 + v65) {
          goto LABEL_121;
        }
        uint64_t v53 = a3 + *(void *)(a6 + 24);
        uint64_t v54 = *(unsigned __int8 *)(a6 + 7);
        if (v53 - v54 < (unint64_t)v52) {
          goto LABEL_121;
        }
        unint64_t v55 = *(unsigned __int8 *)(a6 + 7);
        switch(*(unsigned char *)(a6 + 7))
        {
          case 0:
            break;
          case 1:
            unint64_t v55 = *(unsigned __int8 *)v52;
            break;
          case 2:
            unint64_t v55 = __rev16(*(unsigned __int16 *)v52);
            break;
          case 4:
            unint64_t v55 = bswap32(*v52);
            break;
          case 8:
            unint64_t v55 = bswap64(*(void *)v52);
            break;
          default:
            unint64_t v55 = 0;
            do
            {
              unsigned int v56 = *(unsigned __int8 *)v52;
              uint64_t v52 = (unsigned int *)((char *)v52 + 1);
              unint64_t v55 = v56 | (v55 << 8);
              --v54;
            }
            while (v54);
            break;
        }
        if (*(void *)(a6 + 8) <= v55) {
          goto LABEL_121;
        }
        uint64_t v57 = *(unsigned __int8 *)(a6 + 6);
        unsigned int v58 = (unsigned int *)(v53 + v55 * v57);
        switch(*(unsigned char *)(a6 + 6))
        {
          case 0:
            break;
          case 1:
            LODWORD(v57) = *(unsigned __int8 *)v58;
            break;
          case 2:
            LODWORD(v57) = __rev16(*(unsigned __int16 *)v58);
            break;
          case 4:
            LODWORD(v57) = bswap32(*v58);
            break;
          case 8:
            LODWORD(v57) = bswap64(*(void *)v58);
            break;
          default:
            uint64_t v59 = *(unsigned __int8 *)(a6 + 6);
            LODWORD(v57) = 0;
            do
            {
              int v60 = *(unsigned __int8 *)v58;
              unsigned int v58 = (unsigned int *)((char *)v58 + 1);
              LODWORD(v57) = v60 | (v57 << 8);
              --v59;
            }
            while (v59);
            break;
        }
        values[0] = 0;
        if (!__CFBinaryPlistCreateObjectFiltered(a3, a4, v57, a6, (int)a1, a8, a9, a11, a12, a13 + 1, (uint64_t)cf, v64, 0))
        {
LABEL_121:
          CFRelease(v51);
          CFRelease(Mutable);
          goto LABEL_122;
        }
        uint64_t v61 = v74[3];
        BOOL v62 = v61 < 1;
        uint64_t v63 = v61 - 1;
        if (!v62) {
          v74[3] = v63;
        }
        if (values[0])
        {
          CFDictionarySetValue(Mutable, v51, values[0]);
          CFRelease(values[0]);
        }
        CFRelease(v51);
      }
      int32_t v23 = (unsigned int *)((char *)v23 + *(unsigned __int8 *)(a6 + 7));
      if (++v71 == v24) {
        goto LABEL_123;
      }
    }
    CFStringRef Copy = 0;
    values[0] = off_1ECE0A5A0;
    values[1] = (void *)3221225472;
    values[2] = ____CFPropertyListTryFilteredDictionaryASCIIFastPath_block_invoke;
    xpc_object_t values[3] = &__block_descriptor_64_e12_B24__0r_8q16l;
    values[4] = (void *)v67;
    values[5] = v66;
    values[6] = &Copy;
    values[7] = a1;
    int v49 = __CFBinaryPlistParseASCIIString(a3, v39 - 1, (unsigned char *)(a3 + v44), (uint64_t)values) ^ 1;
    goto LABEL_88;
  }
LABEL_123:
  if (theSet) {
    CFRelease(theSet);
  }
  if (cf) {
    CFRelease(cf);
  }
  _Block_object_dispose(&v73, 8);
  return Mutable;
}

void sub_182BE1A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t __CFBinaryPlistParseASCIIString(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  if (a3 != (unsigned char *)-1)
  {
    CFDictionaryRef v4 = a3 + 1;
    char v5 = *a3;
    unint64_t v6 = *a3 & 0xF;
    if ((v5 & 0xF) == 0xF)
    {
      if (a1 + a2 >= (unint64_t)v4)
      {
        unint64_t v7 = v4 + 1;
        unsigned __int8 v8 = *v4;
        if ((*v4 & 0xF0) == 0x10)
        {
          unsigned int v9 = v8 & 0xF;
          uint64_t v10 = 1 << (v8 & 0xF);
          if (!__CFADD__(v10, v7) && (unint64_t)&v4[v10] <= a1 + a2)
          {
            switch((char)v10)
            {
              case 1:
                unint64_t v6 = *v7;
                goto LABEL_20;
              case 2:
                unint64_t v6 = __rev16(*(unsigned __int16 *)(v4 + 1));
                goto LABEL_20;
              case 4:
                unint64_t v6 = bswap32(*(_DWORD *)(v4 + 1));
                goto LABEL_20;
              case 8:
                unint64_t v6 = bswap64(*(void *)(v4 + 1));
                goto LABEL_19;
              default:
                if (v9 > 7)
                {
                  unint64_t v6 = 0;
LABEL_20:
                  CFDictionaryRef v4 = &v7[v10];
                  goto LABEL_21;
                }
                unint64_t v6 = 0;
                if ((v10 & 0xFE) != 0) {
                  uint64_t v11 = v10;
                }
                else {
                  uint64_t v11 = 1;
                }
                __int16 v12 = v7;
                do
                {
                  unsigned int v13 = *v12++;
                  unint64_t v6 = v13 | (v6 << 8);
                  --v11;
                }
                while (v11);
LABEL_19:
                if ((v6 & 0x8000000000000000) == 0) {
                  goto LABEL_20;
                }
                break;
            }
          }
        }
      }
    }
    else
    {
LABEL_21:
      if (!__CFADD__(v6, v4) && a1 + a2 >= (unint64_t)&v4[v6 - 1]) {
        return (*(uint64_t (**)(uint64_t, unsigned __int8 *))(a4 + 16))(a4, v4);
      }
    }
  }
  return 0;
}

BOOL __CFPropertyListKeyBufferMatchesFilterBuffer(unsigned __int8 *a1, uint64_t a2, unsigned char *__s2, uint64_t __n)
{
  uint64_t v4 = __n - 1;
  if (__n != 1)
  {
    if (__n >= 2 && __s2[v4] == 42)
    {
      if (v4 <= a2)
      {
        unint64_t v7 = __s2;
        size_t v8 = __n - 1;
        return memcmp(a1, v7, v8) == 0;
      }
    }
    else if (a2 == __n)
    {
      unint64_t v7 = __s2;
      size_t v8 = __n;
      return memcmp(a1, v7, v8) == 0;
    }
    return 0;
  }
  int v5 = *__s2;
  if (v5 == 42) {
    return 1;
  }
  if (a2 != 1) {
    return 0;
  }
  return v5 == *a1;
}

void __CFPropertyListCreateSplitKeypaths(const __CFAllocator *a1, CFSetRef theSet, __CFSet **a3, __CFSet **a4)
{
  uint64_t v4 = a4;
  int v5 = a3;
  CFAllocatorRef v37 = a1;
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  if (!theSet)
  {
    *a3 = 0;
    *a4 = 0;
    return;
  }
  unint64_t Count = CFSetGetCount(theSet);
  if (Count >> 60) {
    __CFPropertyListCreateSplitKeypaths_cold_1();
  }
  unint64_t v9 = Count;
  if (Count <= 1) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = Count;
  }
  MEMORY[0x1F4188790](Count, v8);
  unsigned int v13 = (const void **)((char *)&v33 - v12);
  if (v11 >= 0x200) {
    size_t v14 = 512;
  }
  else {
    size_t v14 = v11;
  }
  bzero((char *)&v33 - v12, v14);
  long long v35 = &v33;
  if (v9 >= 0x101)
  {
    uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v10, 0xC0040B8AA526DLL, 0);
    if (!Typed) {
      __CFPropertyListCreateSplitKeypaths_cold_4();
    }
    unsigned int v13 = Typed;
    CFSetGetValues(theSet, Typed);
    goto LABEL_15;
  }
  bzero(v13, 8 * v10);
  CFSetGetValues(theSet, v13);
  if (v9)
  {
LABEL_15:
    size_t v33 = v5;
    long long v34 = v4;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v16 = 0;
    uint64_t v18 = 0;
    CFAllocatorRef v36 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    do
    {
      CFArrayRef v19 = (const __CFArray *)v13[v18];
      CFIndex v20 = CFArrayGetCount(v19);
      unint64_t v21 = v20 - 1;
      if (v20 >= 1)
      {
        unint64_t v22 = v20;
        if (!Mutable) {
          CFMutableDictionaryRef Mutable = CFSetCreateMutable(v37, 0, &kCFTypeSetCallBacks);
        }
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v19, 0);
        CFSetAddValue(Mutable, ValueAtIndex);
        if (v22 >= 2)
        {
          if (!v16)
          {
            CFMutableSetRef v24 = CFSetCreateMutable(v37, 0, &kCFTypeSetCallBacks);
            uint64_t v16 = v24;
          }
          if (v21 >> 60) {
            __CFPropertyListCreateSplitKeypaths_cold_2();
          }
          MEMORY[0x1F4188790](v24, v25);
          uint64_t v28 = (char *)&v33 - v27;
          if (v26 >= 0x200) {
            size_t v29 = 512;
          }
          else {
            size_t v29 = v26;
          }
          bzero((char *)&v33 - v27, v29);
          size_t v30 = 8 * v21;
          if (v22 > 0x101)
          {
            uint64_t v28 = (char *)CFAllocatorAllocateTyped(v36, v30, 0xC0040B8AA526DLL, 0);
            if (!v28) {
              __CFPropertyListCreateSplitKeypaths_cold_3();
            }
          }
          else
          {
            bzero(v28, v30);
          }
          v39.CFIndex length = CFArrayGetCount(v19) - 1;
          v39.CFIndex location = 1;
          CFArrayGetValues(v19, v39, (const void **)v28);
          CFIndex v31 = CFArrayGetCount(v19);
          CFArrayRef v32 = CFArrayCreate(v37, (const void **)v28, v31 - 1, &kCFTypeArrayCallBacks);
          CFSetAddValue(v16, v32);
          if (v32) {
            CFRelease(v32);
          }
          if (v22 >= 0x102) {
            CFAllocatorDeallocate(v36, v28);
          }
        }
      }
      ++v18;
    }
    while (v9 != v18);
    int v5 = v33;
    uint64_t v4 = v34;
    if (v9 >= 0x101) {
      CFAllocatorDeallocate(v36, v13);
    }
    goto LABEL_36;
  }
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v16 = 0;
LABEL_36:
  *int v5 = Mutable;
  *uint64_t v4 = v16;
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet getObjects:values];
  }
  else
  {
    CFIndex Count = CFSetGetCount(theSet);
    CFBasicHashGetElements((uint64_t)theSet, Count, 0, (uint64_t)values);
  }
}

uint64_t __CFPropertyListKeyPassesFilterSet(uint64_t a1, void *a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uint64_t v5 = 0;
  unint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = 0;
  v4[0] = off_1ECE0A5A0;
  v4[1] = 0x40000000;
  void v4[2] = ____CFPropertyListKeyPassesFilterSet_block_invoke;
  v4[3] = &unk_1ECDB0410;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApply(a2, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182BE2140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CFSetApply(void *a1, uint64_t a2)
{
  v5[5] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x11uLL, (unint64_t)a1))
  {
    return [a1 enumerateObjectsWithOptions:0 usingBlock:a2];
  }
  else
  {
    v5[0] = off_1ECE0A5A0;
    v5[1] = 3221225472;
    v5[2] = __CFSetApply_block_invoke;
    v5[3] = &unk_1ECDABD20;
    _OWORD v5[4] = a2;
    return CFBasicHashApply((uint64_t)a1, (uint64_t)v5);
  }
}

uint64_t __CFBasicHashFastEnumeration(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  uint64_t v7 = *a2;
  if (!*a2) {
    a2[2] = a1 + 16;
  }
  a2[1] = a3;
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  uint64_t v9 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  if (v8) {
    BOOL v10 = v7 < v9;
  }
  else {
    BOOL v10 = 0;
  }
  uint64_t v11 = 0;
  if (v10 && a4 >= 1)
  {
    do
    {
      long long v14 = 0u;
      long long v15 = 0u;
      CFBasicHashGetBucket(a1, v7, &v14);
      if (*((void *)&v15 + 1))
      {
        *(void *)(a2[1] + 8 * v11++) = *((void *)&v14 + 1);
        --v8;
      }
      ++*a2;
      if (v8 < 1) {
        break;
      }
      if (++v7 >= v9) {
        break;
      }
    }
    while (v11 < a4);
  }
  return v11;
}

uint64_t CFBasicHashGetElements(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *(unsigned int *)(result + 20);
  uint64_t v5 = __CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)];
  if (v4) {
    BOOL v6 = v5 < 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 && a2 >= 1)
  {
    uint64_t v11 = result;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    do
    {
      long long v18 = 0u;
      long long v19 = 0u;
      __n128 result = CFBasicHashGetBucket(v11, v12, &v18);
      if (*((void *)&v19 + 1))
      {
        --v4;
        if (v13 < a2)
        {
          uint64_t v15 = *((void *)&v18 + 1);
          uint64_t v14 = v19;
          uint64_t v16 = *((void *)&v19 + 1) - 1;
          do
          {
            if (a3) {
              *(void *)(a3 + 8 * v13) = v14;
            }
            if (a4) {
              *(void *)(a4 + 8 * v13) = v15;
            }
            ++v13;
            BOOL v17 = v16-- != 0;
          }
          while (v17 && v13 < a2);
        }
      }
      if (v4 < 1) {
        break;
      }
      if (++v12 >= v5) {
        break;
      }
    }
    while (v13 < a2);
  }
  return result;
}

uint64_t CFBasicHashApply(uint64_t result, uint64_t a2)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(unsigned int *)(result + 20);
  uint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)];
  if (v2) {
    BOOL v4 = v3 < 1;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v6 = result;
    uint64_t v7 = 1;
    do
    {
      long long v11 = 0u;
      long long v12 = 0u;
      __n128 result = CFBasicHashGetBucket(v6, v7 - 1, &v11);
      if (*((void *)&v12 + 1))
      {
        uint64_t v8 = *(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16);
        v10[0] = v11;
        v10[1] = v12;
        __n128 result = v8(a2, v10);
        if (!result) {
          return result;
        }
        v2 -= result != 0;
      }
    }
    while (v2 >= 1 && v7++ < v3);
  }
  return result;
}

uint64_t CFBasicHashGetBucket@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[2] = 0;
  a3[3] = 0;
  *a3 = a2;
  a3[1] = 0;
  uint64_t result = *(void *)(*(void *)(a1 + 40) + 8 * a2);
  if ((unint64_t)(result - 1) >= 0xFFFFFFFFFFFFFFFELL)
  {
    a3[1] = 0;
    a3[2] = 0;
    a3[3] = 0;
    return result;
  }
  unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 0x18) != 0)
  {
    uint64_t v7 = *(void *)(a1 + (v6 & 0x18) + 40);
    switch((v6 >> 5) & 3)
    {
      case 1u:
        uint64_t v8 = *(unsigned __int16 *)(v7 + 2 * a2);
        break;
      case 2u:
        uint64_t v8 = *(unsigned int *)(v7 + 4 * a2);
        break;
      case 3u:
        uint64_t v8 = *(void *)(v7 + 8 * a2);
        break;
      default:
        uint64_t v8 = *(unsigned __int8 *)(v7 + a2);
        break;
    }
  }
  else
  {
    uint64_t v8 = 1;
  }
  uint64_t v9 = -1;
  if (result != 2780474809) {
    uint64_t v9 = result;
  }
  if (result == 2814029233) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v9;
  }
  a3[2] = v10;
  a3[3] = v8;
  if ((v6 & 4) != 0)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 8 * ((v6 >> 2) & 1) + 40) + 8 * a2);
LABEL_21:
    if (result == 2814029233)
    {
      uint64_t result = 0;
    }
    else if (result == 2780474809)
    {
      uint64_t result = -1;
    }
    goto LABEL_28;
  }
  if ((v6 & 0x8000) == 0) {
    goto LABEL_21;
  }
  if (result == 2814029233)
  {
    uint64_t result = 0;
  }
  else if (result == 2780474809)
  {
    uint64_t result = -1;
  }
  long long v11 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                          + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
  if (v11) {
    uint64_t result = v11(result);
  }
LABEL_28:
  a3[1] = result;
  return result;
}

uint64_t __CFSetApplyFunction_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

void __CFRunLoopCollectSources0(CFTypeRef cf, CFTypeRef *a2)
{
  if (!*((void *)cf + 13))
  {
    char v3 = atomic_load((unint64_t *)cf + 1);
    if ((v3 & 8) != 0)
    {
      if (atomic_load_explicit((atomic_ullong *volatile)cf + 11, memory_order_acquire))
      {
        if (*a2)
        {
          CFTypeID v5 = CFGetTypeID(*a2);
          CFTypeRef v6 = *a2;
          if (v5 == 46)
          {
            CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
            *a2 = Mutable;
            CFArrayAppendValue(Mutable, v6);
            CFArrayAppendValue((CFMutableArrayRef)*a2, cf);
            CFRelease(v6);
          }
          else
          {
            uint64_t v8 = (__CFArray *)*a2;
            CFArrayAppendValue(v8, cf);
          }
        }
        else
        {
          *a2 = CFRetain(cf);
        }
      }
    }
  }
}

BOOL __CFSetApply_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  char v2 = 0;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  return v2 == 0;
}

uint64_t __CFDictionaryApplyFunction_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  CFIndex Count = CFArrayGetCount(theArray);
  int v67 = CF_IS_OBJC(7uLL, (unint64_t)separatorString);
  if (v67)
  {
    BOOL v7 = 0;
  }
  else
  {
    char v8 = atomic_load((unint64_t *)&separatorString->info);
    BOOL v7 = (v8 & 0x10) == 0;
  }
  if (Count == 1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
    return CFStringCreateCopy(alloc, ValueAtIndex);
  }
  else
  {
    if (Count)
    {
      if (!alloc)
      {
        CFAllocatorRef v17 = (const __CFAllocator *)_CFGetTSD(1u);
        if (v17) {
          CFAllocatorRef alloc = v17;
        }
        else {
          CFAllocatorRef alloc = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
        }
      }
      CFStringRef theString = separatorString;
      CFIndex v18 = CFStringGetLength(separatorString) * (Count - 1);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFStringRef v20 = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
          CFIndex Length = CFStringGetLength(v20);
          if (CF_IS_OBJC(7uLL, (unint64_t)v20)
            || (char v22 = atomic_load((unint64_t *)&v20->info), (v22 & 0x10) != 0))
          {
            BOOL v7 = 0;
          }
          v18 += Length;
        }
      }
      uint64_t v62 = 2 * v18;
      if (v7) {
        uint64_t v23 = v18 + 1;
      }
      else {
        uint64_t v23 = 2 * v18;
      }
      uint64_t Typed = (char *)CFAllocatorAllocateTyped(alloc, v23, 988215, 0);
      if (!Typed) {
        __CFStringHandleOutOfMemory();
      }
      CFAllocatorRef v63 = alloc;
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      char v68 = !v7;
      CFIndex v25 = CFStringGetLength(theString);
      __s = Typed;
      if (Count >= 1)
      {
        unint64_t v26 = 0;
        CFIndex v27 = 0;
        size_t v28 = v25 << v68;
        p_data = (uint64_t *)&theString->data;
        do
        {
          if (v27)
          {
            if (v26)
            {
              memmove(Typed, v26, v28);
            }
            else
            {
              if (v67)
              {
                v70.CFIndex length = CFStringGetLength(theString);
                v70.CFIndex location = 0;
                CFStringGetCharacters(theString, v70, (UniChar *)Typed);
              }
              else if (v7 || (char v29 = atomic_load((unint64_t *)&theString->info), (v29 & 0x10) != 0))
              {
                char v32 = atomic_load((unint64_t *)&theString->info);
                if ((v32 & 0x60) != 0)
                {
                  size_t v33 = (uint64_t *)*p_data;
                }
                else
                {
                  char v34 = atomic_load((unint64_t *)&theString->info);
                  size_t v33 = &p_data[(v34 & 5) != 4];
                }
                unint64_t v35 = atomic_load((unint64_t *)&theString->info);
                memmove(Typed, (char *)v33 + ((v35 >> 2) & 1), v28);
              }
              else
              {
                char v30 = atomic_load((unint64_t *)&theString->info);
                if ((v30 & 0x60) != 0)
                {
                  CFIndex v31 = (unsigned __int8 *)*p_data;
                }
                else
                {
                  char v53 = atomic_load((unint64_t *)&theString->info);
                  CFIndex v31 = (unsigned __int8 *)&p_data[(v53 & 5) != 4];
                }
                unint64_t v54 = atomic_load((unint64_t *)&theString->info);
                char v55 = atomic_load((unint64_t *)&theString->info);
                char v56 = atomic_load((unint64_t *)&theString->info);
                uint64_t v57 = v56 & 0x60;
                if ((v55 & 5) == 4)
                {
                  if (v57)
                  {
                    unsigned int v58 = (uint64_t *)*p_data;
                  }
                  else
                  {
                    char v60 = atomic_load((unint64_t *)&theString->info);
                    unsigned int v58 = &p_data[(v60 & 5) != 4];
                  }
                  uint64_t v59 = *(unsigned __int8 *)v58;
                }
                else if (v57)
                {
                  uint64_t v59 = theString->length;
                }
                else
                {
                  uint64_t v59 = *p_data;
                }
                __CFStrConvertBytesToUnicode(&v31[(v54 >> 2) & 1], Typed, v59);
              }
              unint64_t v26 = Typed;
            }
            Typed += v28;
          }
          CFStringRef v36 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v27);
          if (CF_IS_OBJC(7uLL, (unint64_t)v36))
          {
            CFIndex v37 = CFStringGetLength(v36);
            v71.CFIndex location = 0;
            v71.CFIndex length = v37;
            CFStringGetCharacters(v36, v71, (UniChar *)Typed);
            size_t v38 = 2 * v37;
          }
          else
          {
            char v39 = atomic_load((unint64_t *)&v36->info);
            uint64_t v40 = (uint64_t *)&v36->data;
            if ((v39 & 0x60) != 0)
            {
              unint64_t v41 = (unsigned __int8 **)*v40;
            }
            else
            {
              char v42 = atomic_load((unint64_t *)&v36->info);
              unint64_t v41 = (unsigned __int8 **)&v40[(v42 & 5) != 4];
            }
            char v43 = atomic_load((unint64_t *)&v36->info);
            if ((v43 & 5) == 4)
            {
              uint64_t v44 = *(unsigned __int8 *)v41;
            }
            else
            {
              char v45 = atomic_load((unint64_t *)&v36->info);
              if ((v45 & 0x60) != 0) {
                uint64_t v44 = v36->length;
              }
              else {
                uint64_t v44 = *v40;
              }
            }
            size_t v38 = v44 << v68;
            if (v7
              || (p_info = (unint64_t *)&v36->info,
                  char v47 = atomic_load((unint64_t *)&v36->info),
                  (v47 & 0x10) != 0))
            {
              unint64_t v51 = atomic_load((unint64_t *)&v36->info);
              CFIndex v25 = (CFIndex)memmove(Typed, (char *)v41 + ((v51 >> 2) & 1), v38);
            }
            else
            {
              unint64_t v48 = atomic_load(p_info);
              char v49 = atomic_load(p_info);
              if ((v49 & 5) == 4)
              {
                uint64_t v50 = *(unsigned __int8 *)v41;
              }
              else
              {
                char v52 = atomic_load((unint64_t *)&v36->info);
                if ((v52 & 0x60) != 0) {
                  uint64_t v50 = v36->length;
                }
                else {
                  uint64_t v50 = *v40;
                }
              }
              CFIndex v25 = (CFIndex)__CFStrConvertBytesToUnicode((unsigned __int8 *)v41 + ((v48 >> 2) & 1), Typed, v50);
            }
          }
          Typed += v38;
          ++v27;
        }
        while (Count != v27);
      }
      if (v7)
      {
        char *Typed = 0;
        uint64_t v61 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding(v25);
          uint64_t v61 = __CFDefaultEightBitStringEncoding;
        }
        size_t v11 = strlen(__s);
        uint64_t v9 = (__objc2_class **)v63;
        uint64_t v10 = (int8x16_t *)__s;
        uint64_t v12 = v61;
        unsigned int v13 = 24;
        uint64_t v14 = (uint64_t)v63;
      }
      else
      {
        size_t v11 = v62;
        uint64_t v9 = (__objc2_class **)v63;
        uint64_t v10 = (int8x16_t *)__s;
        uint64_t v12 = 256;
        unsigned int v13 = 16;
        uint64_t v14 = (uint64_t)v63;
      }
    }
    else
    {
      uint64_t v9 = (__objc2_class **)alloc;
      uint64_t v10 = 0;
      size_t v11 = 0;
      uint64_t v12 = 256;
      unsigned int v13 = 2;
      uint64_t v14 = -1;
    }
    return (CFStringRef)__CFStringCreateImmutableFunnel3(v9, v10, v11, v12, v13, (__objc2_class **)v14, 0);
  }
}

BOOL withClientContext(_xpc_connection_s *a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&_globalContextLock);
  CFTypeRef context = (os_unfair_lock_s *)xpc_connection_get_context(a1);
  if (!context) {
    withClientContext_cold_1();
  }
  CFTypeID v5 = context;
  CFTypeRef v6 = context + 12;
  os_unfair_lock_lock(context + 12);
  int v7 = BYTE1(v5[14]._os_unfair_lock_opaque);
  os_unfair_lock_unlock((os_unfair_lock_t)&_globalContextLock);
  if (v7) {
    (*(void (**)(uint64_t, os_unfair_lock_s *))(a2 + 16))(a2, v5);
  }
  os_unfair_lock_unlock(v6);
  return v7 != 0;
}

BOOL __CFPropertyListFilterKeyHasWildcard(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  return Length >= 1 && CFStringGetCharacterAtIndex(a1, Length - 1) == 42;
}

void _CFPrefsDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
}

void __RELEASE_OBJECTS_IN_THE_SET__(uint64_t a1, int a2)
{
  char v2 = &OBJC_IVAR_____NSFrozenSetM_storage;
  if (a2 == 1) {
    char v2 = &OBJC_IVAR_____NSSetM_storage;
  }
  uint64_t v3 = a1 + *v2;
  unint64_t v4 = *(unsigned int *)(v3 + 12);
  unint64_t v5 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v4 >> 23) & 0x1F8));
  int v6 = v4 & 0x3FFFFFF;
  int v7 = *(void **)v3;
  *(_DWORD *)(v3 + 12) = 0;
  *(void *)uint64_t v3 = 0;
  if ((v4 & 0x3FFFFFF) != 0 && v4 >> 26 != 0)
  {
    unint64_t v9 = 0;
    do
    {
      unint64_t v10 = v7[v9];
      if (v10) {
        BOOL v11 = v10 == (void)&___NSSetM_DeletedMarker;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11)
      {
        if ((v10 & 0x8000000000000000) == 0) {

        }
        --v6;
      }
      if (!v6) {
        break;
      }
      ++v9;
    }
    while (v9 < v5);
  }

  free(v7);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    CFIndex Count = CFSetGetCount(theSet);
    memset(v11, 0, 512);
    if (Count >= 257) {
      uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    }
    else {
      uint64_t Typed = (const void **)v11;
    }
    CFSetGetValues(theSet, Typed);
    uint64_t Generic = __CFSetCreateGeneric((__objc2_class **)allocator, (uint64_t)&kCFTypeSetCallBacks);
    CFStringRef Copy = (__CFSet *)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (CFIndex i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, (unint64_t)Typed[i], (uint64_t)Typed[i]);
    }
    if (Typed != (const void **)v11) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  else
  {
    CFStringRef Copy = (__CFSet *)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theSet);
  }
  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x11uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return Copy;
}

const void *___dictionaryContainsAllKeysInSet_block_invoke(uint64_t a1, const void *a2, unsigned char *a3)
{
  uint64_t result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (!result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    *a3 = 1;
  }
  return result;
}

void sub_182BE3A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CFRunLoopAddItemToCommonModes(const __CFString *a1, uint64_t a2)
{
  unint64_t v4 = *(__CFRunLoop **)a2;
  uint64_t v3 = *(void **)(a2 + 8);
  CFTypeID v5 = CFGetTypeID(v3);
  switch(v5)
  {
    case '-':
      CFRunLoopAddObserver(v4, (CFRunLoopObserverRef)v3, a1);
      break;
    case '/':
      CFRunLoopAddTimer(v4, (CFRunLoopTimerRef)v3, a1);
      break;
    case '.':
      CFRunLoopAddSource(v4, (CFRunLoopSourceRef)v3, a1);
      break;
  }
}

void ___loadLocTable_block_invoke(uint64_t a1, void *a2)
{
  values[2] = *(void **)off_1ECE0A5B0;
  values[0] = *(void **)(a1 + 32);
  values[1] = a2;
  CFArrayRef v3 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), v3);
  CFRelease(v3);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  context[2] = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
  }
  char v8 = atomic_load((unint64_t *)rl + 1);
  if ((v8 & 4) == 0)
  {
    char v9 = atomic_load((unint64_t *)observer + 1);
    if ((v9 & 8) != 0)
    {
      unint64_t v10 = (__CFRunLoop *)*((void *)observer + 10);
      if (!v10 || v10 == rl)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
        if (mode == @"kCFRunLoopCommonModes")
        {
          CFSetRef v18 = (const __CFSet *)*((void *)rl + 76);
          if (v18) {
            CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
          }
          else {
            CFSetRef Copy = 0;
          }
          CFMutableDictionaryRef Mutable = (__CFSet *)*((void *)rl + 77);
          if (!Mutable)
          {
            CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
            *((void *)rl + 77) = Mutable;
          }
          CFSetAddValue(Mutable, observer);
          if (!Copy) {
            goto LABEL_29;
          }
          context[0] = rl;
          context[1] = observer;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, context);
        }
        else
        {
          uint64_t v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
          if (!v11)
          {
LABEL_29:
            pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
            return;
          }
          CFSetRef Copy = (CFSetRef)v11;
          unsigned int v13 = (pthread_mutex_t *)(v11 + 16);
          pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
          CFArrayRef v14 = (const __CFArray *)*((void *)Copy + 14);
          if (!v14)
          {
            CFArrayRef v14 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
            *((void *)Copy + 14) = v14;
          }
          v21.CFIndex length = CFArrayGetCount(v14);
          v21.CFIndex location = 0;
          if (!CFArrayContainsValue(v14, v21, observer))
          {
            CFIndex v15 = CFArrayGetCount(*((CFArrayRef *)Copy + 14)) + 1;
            do
            {
              CFIndex v16 = v15 - 1;
              if (v15 == 1) {
                break;
              }
              CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)Copy + 14), v15 - 2);
              CFIndex v15 = v16;
            }
            while (ValueAtIndex[13] > *((void *)observer + 13));
            CFArrayInsertValueAtIndex(*((CFMutableArrayRef *)Copy + 14), v16, observer);
            *((void *)Copy + 18) |= *((void *)observer + 12);
            __CFRunLoopObserverSchedule((uint64_t)observer, (uint64_t)rl);
          }
          pthread_mutex_unlock(v13);
        }
        CFRelease(Copy);
        goto LABEL_29;
      }
    }
  }
}

void sub_182BE411C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t __CFRunLoopObserverSchedule(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    *(void *)(a1 + 80) = a2;
  }
  *(void *)(a1 + 88) = v5 + 1;

  return pthread_mutex_unlock(v4);
}

xpc_object_t _CFPrefsGetEntitlementForMessageWithLockedContext(void *a1, char *key, uint64_t a3)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  if (!a1) {
    _CFPrefsGetEntitlementForMessageWithLockedContext_cold_1();
  }
  xpc_object_t v5 = *(xpc_object_t *)(a3 + 32);
  if (v5)
  {
    if (key) {
      return xpc_dictionary_get_value(v5, key);
    }
  }
  else
  {
    size_t length = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
    if (data && length == 32)
    {
      long long v9 = data[1];
      long long v24 = *data;
      long long v25 = v9;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        xpc_object_t value = xpc_dictionary_get_value(a1, "connection");
        if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
          _CFPrefsGetEntitlementForMessageWithLockedContext_cold_3();
        }
      }
      xpc_connection_get_audit_token();
    }
    uint64_t v11 = (void *)xpc_copy_entitlement_for_token();
    if (!v11) {
      goto LABEL_27;
    }
    uint64_t v12 = v11;
    CFURLRef array = (const __CFURL *)xpc_dictionary_get_array(v11, "com.apple.security.application-groups");
    if (array)
    {
      CFURLRef v14 = array;
      if (xpc_array_get_count(array)) {
        *(void *)(a3 + 40) = _CFXPCCreateCFObjectFromXPCObject(v14);
      }
    }
    uint64_t v15 = 0;
    int v16 = 0;
    xpc_object_t v5 = 0;
    do
    {
      CFAllocatorRef v17 = entitlementsWeCareAbout[v15];
      if (key)
      {
        size_t v18 = strlen(entitlementsWeCareAbout[v15]);
        BOOL v19 = strncmp(v17, key, v18) == 0;
        char v20 = v19 | v16;
        v16 |= v19;
      }
      else
      {
        char v20 = 1;
      }
      xpc_object_t v21 = xpc_dictionary_get_value(v12, v17);
      if (v21)
      {
        char v22 = v21;
        if (!v5) {
          xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
        }
        xpc_dictionary_set_value(v5, v17, v22);
      }
      ++v15;
    }
    while (v15 != 6);
    if ((v20 & 1) == 0) {
      _CFPrefsGetEntitlementForMessageWithLockedContext_cold_2();
    }
    xpc_release(v12);
    if (!v5)
    {
LABEL_27:
      if (_CFPrefsGetEntitlementForMessageWithLockedContext_onceToken != -1) {
        dispatch_once(&_CFPrefsGetEntitlementForMessageWithLockedContext_onceToken, &__block_literal_global_180);
      }
      xpc_object_t v5 = xpc_retain((xpc_object_t)_CFPrefsGetEntitlementForMessageWithLockedContext_emptyEntitlements);
    }
    *(void *)(a3 + 32) = v5;
    if (key) {
      return xpc_dictionary_get_value(v5, key);
    }
  }
  return 0;
}

void __CFRunLoopRemoveItemFromCommonModes(const __CFString *a1, uint64_t a2)
{
  unint64_t v4 = *(__CFRunLoop **)a2;
  CFArrayRef v3 = *(void **)(a2 + 8);
  CFTypeID v5 = CFGetTypeID(v3);
  switch(v5)
  {
    case '-':
      CFRunLoopRemoveObserver(v4, (CFRunLoopObserverRef)v3, a1);
      break;
    case '/':
      CFRunLoopRemoveTimer(v4, (CFRunLoopTimerRef)v3, a1);
      break;
    case '.':
      CFRunLoopRemoveSource(v4, (CFRunLoopSourceRef)v3, a1);
      break;
  }
}

void __CFRunLoopGetModeName(uint64_t a1, CFMutableArrayRef theArray)
{
}

void ___copyIngestedCacheResult_block_invoke_2(uint64_t a1, const void *a2)
{
}

void sub_182BE47E0(_Unwind_Exception *a1)
{
}

void ___loadStringsFromData_block_invoke_2(uint64_t a1, const void *a2)
{
  CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (Value)
  {
    CFTypeID v5 = Value;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    unint64_t v6 = *(__CFDictionary **)(a1 + 48);
    CFDictionaryAddValue(v6, a2, v5);
  }
}

void ___loadStringsFromData_block_invoke(uint64_t a1, const void *a2)
{
  v4[1] = *(const void **)off_1ECE0A5B0;
  v4[0] = a2;
  CFArrayRef v3 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, 1, &kCFTypeArrayCallBacks);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v3);
  CFRelease(v3);
}

uint64_t __CFBagApplyFunction_block_invoke(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a2 + 24); i; --i)
    (*(void (**)(void, void))(a1 + 32))(*(void *)(a2 + 16), *(void *)(a1 + 40));
  return 1;
}

uint64_t __notifyFunc_block_invoke(uint64_t result, uint64_t a2)
{
  char v2 = (unsigned char *)(a2 + 55);
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(unsigned char *)(a2 + 55);
  if (*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24)) {
    char v2 = (unsigned char *)(a2 + 56);
  }
  *char v2 = 1;
  return result;
}

uint64_t __notifyFunc_block_invoke_3(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(unsigned char *)(a2 + 56);
  *(unsigned char *)(a2 + 56) = 0;
  *(unsigned char *)(a2 + 55) = 0;
  return result;
}

CFURLRef _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser(const __CFString *a1, const void *a2)
{
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  bzero(buffer, 0x400uLL);
  if (a1)
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    if (!CStringPtr)
    {
      CFStringEncoding FastestEncoding = CFStringGetFastestEncoding(a1);
      CStringPtr = buffer;
      if (!CFStringGetCString(a1, buffer, 1024, FastestEncoding)) {
        CStringPtr = 0;
      }
    }
  }
  else
  {
    CStringPtr = 0;
  }
  uint64_t v15 = 0;
  int v16 = &v15;
  uint64_t v17 = 0x2000000000;
  xpc_object_t v18 = 0;
  xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
  int current_persona = voucher_get_current_persona();
  uint64_t v42 = 0;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  int v20 = 2;
  if (current_persona != -1) {
    kpersona_info();
  }
  container_query_create();
  container_query_set_class();
  if (CStringPtr)
  {
    xpc_object_t v7 = xpc_string_create(CStringPtr);
    container_query_set_identifiers();
    xpc_release(v7);
  }
  container_query_set_persona_unique_string();
  container_query_operation_set_flags();
  container_query_set_uid();
  if ((container_query_iterate_results_sync() & 1) == 0)
  {
    container_query_get_last_error();
    char v8 = (void *)container_error_copy_unlocalized_description();
    long long v9 = _CFOSLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser_cold_1((uint64_t)CStringPtr, (uint64_t)v8, v9);
    }
    free(v8);
    xpc_release((xpc_object_t)v16[3]);
    v16[3] = 0;
  }
  container_query_free();
  CFURLRef v10 = (const __CFURL *)v16[3];
  _Block_object_dispose(&v15, 8);
  if (!v10) {
    return 0;
  }
  CFDictionaryRef v11 = _CFXPCCreateCFObjectFromXPCObject(v10);
  xpc_release(v10);
  if (!v11) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v11, a2);
  if (Value) {
    CFURLRef v13 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value, kCFURLPOSIXPathStyle, 1u);
  }
  else {
    CFURLRef v13 = 0;
  }
  CFRelease(v11);
  return v13;
}

void sub_182BE4E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFBasicHashesAreEqual_block_invoke(void *a1, void *a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t result = a1[5];
  if (!*(unsigned char *)(result + 26))
  {
    long long v10 = xmmword_182EDDE80;
    long long v11 = *(_OWORD *)algn_182EDDE90;
    goto LABEL_16;
  }
  unint64_t v5 = a2[1];
  int v6 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v6)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, v5, (uint64_t *)&v10);
        goto LABEL_16;
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, v5, (uint64_t *)&v10);
        goto LABEL_16;
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, v5, (uint64_t *)&v10);
        goto LABEL_16;
    }
LABEL_24:
    __break(1u);
    return result;
  }
  if (v6 == 3)
  {
    ___CFBasicHashFindBucket_Exponential(result, v5, (uint64_t *)&v10);
    goto LABEL_16;
  }
  if (v6 == 2)
  {
    ___CFBasicHashFindBucket_Double(result, v5, (uint64_t *)&v10);
    goto LABEL_16;
  }
  if (v6 != 1) {
    goto LABEL_24;
  }
  ___CFBasicHashFindBucket_Linear(result, v5, (uint64_t *)&v10);
LABEL_16:
  if (a2[3] == *((void *)&v11 + 1))
  {
    uint64_t v7 = a1[6];
    if ((*(_WORD *)(v7 + 18) & 4) == 0) {
      return 1;
    }
    uint64_t v8 = a2[2];
    if (v8 == (void)v11) {
      return 1;
    }
    long long v9 = *(unsigned int (**)(uint64_t, void))(CFBasicHashCallBackPtrs[((*(void *)(v7 + 32) >> 34) >> 5) & 0x1F]
                                                        + 8 * ((*(void *)(v7 + 32) >> 34) & 0x1FLL));
    if (v9)
    {
      if (v9(v8, v11)) {
        return 1;
      }
    }
  }
  uint64_t result = 0;
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 0;
  return result;
}

void _CFPrefsSynchronizeDirtySourceForTimer(void *a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  uint64_t v5 = 0;
  int v6 = &v5;
  uint64_t v7 = 0x3052000000;
  uint64_t v8 = __Block_byref_object_copy__364;
  long long v9 = __Block_byref_object_dispose__365;
  uint64_t v10 = 0;
  v4[0] = off_1ECE0A5A0;
  v4[1] = 3221225472;
  void v4[2] = ___CFPrefsSynchronizeDirtySourceForTimer_block_invoke;
  v4[3] = &unk_1ECE003C0;
  v4[4] = a1;
  v4[5] = &v5;
  [a1 lockedSync:v4];
  uint64_t v2 = v6[5];
  if (v2)
  {
    CFArrayRef v3 = (const void *)(*(uint64_t (**)(void))(v2 + 16))();
    [a1 finishedNonRequestWriteWithResult:v3];
    if (v3) {
      CFRelease(v3);
    }
  }

  _Block_object_dispose(&v5, 8);
}

void sub_182BE516C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsWritePlistToFDThenClose(void *a1, int a2, uid_t a3, gid_t a4, mode_t a5, int a6, int a7, const char *a8, uint64_t a9)
{
  uint64_t v59 = *(void *)off_1ECE0A5B0;
  if (a2 < 0)
  {
    long long v22 = _CFPrefsDaemonLog();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    *(_DWORD *)buf = 67109120;
    int v58 = a2;
    _os_log_fault_impl(&dword_182B90000, v22, OS_LOG_TYPE_FAULT, "Invalid file descriptor %d", buf, 8u);
LABEL_15:
    if (!buf[0]) {
      return 22;
    }
LABEL_16:
    unlinkat(-2, (const char *)buf, 2048);
    return 22;
  }
  if (!a1)
  {
    long long v23 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_1(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    close(a2);
    goto LABEL_15;
  }
  size_t v17 = [a1 length];
  xpc_object_t v18 = (char *)[a1 bytes];
  if (fcntl(a2, 50, buf) < 0)
  {
    uint64_t v21 = *__error();
    long long v32 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_2(a2, v32);
    }
    goto LABEL_21;
  }
  unsigned int v19 = atomic_load(&dword_1EC090E0C);
  if (v19 == 2)
  {
    int v20 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_3();
    }
    close(a2);
    if (buf[0]) {
      unlinkat(-2, (const char *)buf, 2048);
    }
    return 28;
  }
  int v50 = a7;
  if (v17)
  {
    char v49 = a8;
    int v33 = write(a2, v18, v17);
    uint64_t v34 = v33;
    if (v33 != v17)
    {
      int v35 = v33;
      do
      {
        long long v36 = __error();
        if (v35 == -1)
        {
          if (*v36 != 4 && *v36 != 35)
          {
            uint64_t v21 = *__error();
            uint64_t v43 = _CFPrefsDaemonLog();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
              _CFPrefsWritePlistToFDThenClose_cold_8();
            }
            goto LABEL_21;
          }
        }
        else
        {
          v18 += v34;
          v17 -= v34;
        }
        int v35 = write(a2, v18, v17);
        uint64_t v34 = v35;
      }
      while (v35 != v17);
    }
    a8 = v49;
    while (fsync(a2) < 0)
    {
      if (*__error() != 4)
      {
        uint64_t v21 = *__error();
        long long v37 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
          _CFPrefsWritePlistToFDThenClose_cold_7();
        }
        goto LABEL_21;
      }
    }
  }
  if (byte_1EC090E03)
  {
    sleep(1u);
    byte_1EC090E03 = 0;
  }
  fchown(a2, a3, a4);
  fchmod(a2, a5);
  int v38 = v50;
  if ([a1 validatePlist])
  {
    if (a6)
    {
      LOBYTE(CFDictionaryAddValue(theDict, key, value) = 1;
      uint64_t v39 = fsetxattr(a2, "com.apple.MobileBackup", &value, 1uLL, 0, 0);
      if (v39)
      {
        uint64_t v40 = v39;
        uint64_t v21 = *__error();
        long long v41 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
          _CFPrefsWritePlistToFDThenClose_cold_5((uint64_t)buf, v40, v41);
        }
LABEL_21:
        close(a2);
LABEL_22:
        if (buf[0]) {
          unlinkat(-2, (const char *)buf, 2048);
        }
        return v21;
      }
      int v38 = v50;
    }
    close(a2);
    int v45 = renameat(-2, (const char *)buf, v38, a8);
    uint64_t v21 = *__error();
    uint64_t v46 = _CFPrefsDaemonLog();
    char v47 = v46;
    if (v45)
    {
      if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
      {
        int value = 136315650;
        char v52 = buf;
        __int16 v53 = 2080;
        uint64_t v54 = a9;
        __int16 v55 = 1024;
        int v56 = v21;
        _os_log_fault_impl(&dword_182B90000, v47, OS_LOG_TYPE_FAULT, "error renaming file %s to %s (errno: %d).", (uint8_t *)&value, 0x1Cu);
      }
      goto LABEL_22;
    }
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v48 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG)) {
        _CFPrefsWritePlistToFDThenClose_cold_4();
      }
    }
    return 0;
  }
  else
  {
    uint64_t v42 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_6();
    }
    close(a2);
    if (buf[0]) {
      unlinkat(-2, (const char *)buf, 2048);
    }
    return 47837;
  }
}

void __CFRunLoopAddItemsToCommonMode(void *a1, uint64_t a2)
{
  unint64_t v4 = *(__CFRunLoop **)a2;
  CFStringRef v3 = *(const __CFString **)(a2 + 8);
  CFTypeID v5 = CFGetTypeID(a1);
  switch(v5)
  {
    case '-':
      CFRunLoopAddObserver(v4, (CFRunLoopObserverRef)a1, v3);
      break;
    case '/':
      CFRunLoopAddTimer(v4, (CFRunLoopTimerRef)a1, v3);
      break;
    case '.':
      CFRunLoopAddSource(v4, (CFRunLoopSourceRef)a1, v3);
      break;
  }
}

uint64_t CFBasicHashesAreEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  uint64_t Count = CFBasicHashGetCount(a1);
  if (Count != CFBasicHashGetCount(a2)) {
    return 0;
  }
  uint64_t v5 = 1;
  if (Count)
  {
    uint64_t v8 = 0;
    long long v9 = &v8;
    uint64_t v10 = 0x2020000000;
    char v11 = 1;
    v7[0] = off_1ECE0A5A0;
    v7[1] = 3221225472;
    void v7[2] = __CFBasicHashesAreEqual_block_invoke;
    _OWORD v7[3] = &unk_1ECDFFA68;
    v7[4] = &v8;
    uint64_t v7[5] = a2;
    void v7[6] = a1;
    CFBasicHashApply(a1, (uint64_t)v7);
    uint64_t v5 = *((unsigned __int8 *)v9 + 24);
    _Block_object_dispose(&v8, 8);
  }
  return v5;
}

void sub_182BE5ACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CFRunLoopDeallocateTimers(uint64_t a1, void *a2)
{
  CFArrayRef v3 = *(const __CFArray **)(a1 + 120);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count)
    {
      v8.size_t length = Count;
      v8.CFIndex location = 0;
      CFArrayApplyFunction(*(CFArrayRef *)(a1 + 120), v8, (CFArrayApplierFunction)__CFRunLoopKillOneTimer, a2);
      int v6 = *(__CFArray **)(a1 + 120);
      CFArrayRemoveAllValues(v6);
    }
  }
}

void __CFRunLoopDeallocateSources(uint64_t a1, const void *a2)
{
  uint64_t v25 = *(void *)off_1ECE0A5B0;
  CFSetRef v4 = *(const __CFSet **)(a1 + 96);
  if (v4)
  {
    CFIndex Count = CFSetGetCount(v4);
    uint64_t v7 = (CFMutableSetRef *)(a1 + 104);
    CFSetRef v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v7 = (CFMutableSetRef *)(a1 + 104);
    CFSetRef v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      return;
    }
    CFIndex Count = 0;
  }
  CFSetRef v6 = (const __CFSet *)CFSetGetCount(v6);
LABEL_7:
  uint64_t v8 = (uint64_t)v6 + Count;
  if ((uint64_t)v6 + Count >= 257) {
    uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v8, 0x80040B8603338, 0);
  }
  else {
    uint64_t Typed = (const void **)v24;
  }
  memset(v24, 0, 512);
  CFSetRef v10 = *(const __CFSet **)(a1 + 96);
  if (v10) {
    CFSetGetValues(v10, Typed);
  }
  CFSetRef v11 = *v7;
  if (*v7)
  {
    CFIndex v12 = *(void *)(a1 + 96);
    if (v12) {
      CFIndex v12 = CFSetGetCount((CFSetRef)v12);
    }
    CFSetGetValues(v11, &Typed[v12]);
  }
  if (v8 >= 1)
  {
    CFURLRef v13 = Typed;
    uint64_t v14 = v8;
    do
    {
      uint64_t v15 = *v13++;
      CFRetain(v15);
      --v14;
    }
    while (v14);
  }
  int v16 = *(__CFSet **)(a1 + 96);
  if (v16) {
    CFSetRemoveAllValues(v16);
  }
  if (*v7) {
    CFSetRemoveAllValues(*v7);
  }
  if (v8 >= 1)
  {
    size_t v17 = Typed;
    do
    {
      xpc_object_t v18 = *v17;
      unsigned int v19 = (pthread_mutex_t *)((char *)*v17 + 16);
      pthread_mutex_lock(v19);
      int v20 = (__CFBag *)*((void *)v18 + 12);
      if (v20) {
        CFBagRemoveValue(v20, a2);
      }
      pthread_mutex_unlock(v19);
      uint64_t v21 = *((void *)v18 + 13);
      if (v21 == 1)
      {
        mach_port_name_t v23 = (*((uint64_t (**)(void))v18 + 20))(*((void *)v18 + 14));
        if (v23) {
          mach_port_extract_member(*(_DWORD *)off_1ECE0A6C8, v23, *(_DWORD *)(a1 + 136));
        }
      }
      else if (!v21)
      {
        long long v22 = (void (*)(void, const void *, void))*((void *)v18 + 21);
        if (v22) {
          v22(*((void *)v18 + 14), a2, *(void *)(a1 + 80));
        }
      }
      CFRelease(v18);
      ++v17;
      --v8;
    }
    while (v8);
  }
  if (Typed != (const void **)v24) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

void __CFRunLoopDeallocateObservers(uint64_t a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  CFArrayRef v2 = *(const __CFArray **)(a1 + 112);
  if (v2)
  {
    uint64_t Count = CFArrayGetCount(v2);
    if (Count >= 257) {
      uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0x80040B8603338, 0);
    }
    else {
      uint64_t Typed = (const void **)v10;
    }
    memset(v10, 0, 512);
    v12.CFIndex location = 0;
    v12.size_t length = Count;
    CFArrayGetValues(*(CFArrayRef *)(a1 + 112), v12, Typed);
    if (Count < 1)
    {
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 112));
    }
    else
    {
      uint64_t v5 = Typed;
      uint64_t v6 = Count;
      do
      {
        uint64_t v7 = *v5++;
        CFRetain(v7);
        --v6;
      }
      while (v6);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 112));
      uint64_t v8 = (uint64_t *)Typed;
      do
      {
        __CFRunLoopObserverCancel(*v8);
        long long v9 = (const void *)*v8++;
        CFRelease(v9);
        --Count;
      }
      while (Count);
    }
    if (Typed != (const void **)v10) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
}

void __CFRunLoopCleanseSources(uint64_t a1, const void *a2)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  CFSetRef v4 = *(const __CFSet **)(a1 + 96);
  if (v4)
  {
    CFIndex Count = CFSetGetCount(v4);
    uint64_t v7 = (const __CFSet **)(a1 + 104);
    CFSetRef v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v7 = (const __CFSet **)(a1 + 104);
    CFSetRef v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      return;
    }
    CFIndex Count = 0;
  }
  CFSetRef v6 = (const __CFSet *)CFSetGetCount(v6);
LABEL_7:
  uint64_t v8 = (uint64_t)v6 + Count;
  if ((uint64_t)v6 + Count >= 257) {
    uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v8, 0x80040B8603338, 0);
  }
  else {
    uint64_t Typed = (const void **)v17;
  }
  memset(v17, 0, 512);
  CFSetRef v10 = *(const __CFSet **)(a1 + 96);
  if (v10) {
    CFSetGetValues(v10, Typed);
  }
  CFSetRef v11 = *v7;
  if (v11)
  {
    CFIndex v12 = *(void *)(a1 + 96);
    if (v12) {
      CFIndex v12 = CFSetGetCount((CFSetRef)v12);
    }
    CFSetGetValues(v11, &Typed[v12]);
  }
  if (v8 >= 1)
  {
    CFURLRef v13 = Typed;
    do
    {
      uint64_t v14 = *v13;
      uint64_t v15 = (pthread_mutex_t *)((char *)*v13 + 16);
      pthread_mutex_lock(v15);
      int v16 = (__CFBag *)*((void *)v14 + 12);
      if (v16) {
        CFBagRemoveValue(v16, a2);
      }
      pthread_mutex_unlock(v15);
      ++v13;
      --v8;
    }
    while (v8);
  }
  if (Typed != (const void **)v17) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

CFTypeRef _CFStringCreateWithBytesNoCopyDisallowROM(__objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, __objc2_class **a6)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | 0x22u, a6, 0);
}

__CFData *_CFPropertyListCreateXMLData(CFAllocatorRef allocator, const __CFString *a2, int a3)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  if (!a3 || (v7[0] = 1, long long v8 = 0u, v9 = 0, v7[1] = 100, Mutable = 0, __CFPropertyListIsValidAux(a2, v7)))
  {
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(allocator, 0);
    CFDataAppendBytes(Mutable, (const UInt8 *)"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE ", 49);
    _plistAppendCharacters(Mutable, L"plist", 5);
    CFDataAppendBytes(Mutable, (const UInt8 *)" PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<", 89);
    _plistAppendCharacters(Mutable, L"plist", 5);
    CFDataAppendBytes(Mutable, (const UInt8 *)" version=\"1.0\">\n", 16);
    _CFAppendXML0(a2, 0, Mutable);
    CFDataAppendBytes(Mutable, (const UInt8 *)"</", 2);
    _plistAppendCharacters(Mutable, L"plist", 5);
    CFDataAppendBytes(Mutable, (const UInt8 *)">\n", 2);
  }
  return Mutable;
}

CFSetRef __CFPropertyListCreateTopLevelKeyPaths(const __CFAllocator *a1, CFSetRef theSet)
{
  CFSetRef Mutable = theSet;
  v17[1] = *(void *)off_1ECE0A5B0;
  if (theSet)
  {
    unint64_t Count = CFSetGetCount(theSet);
    if (Count >> 60) {
      __CFPropertyListCreateTopLevelKeyPaths_cold_1();
    }
    unint64_t v6 = Count;
    if (Count <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = Count;
    }
    MEMORY[0x1F4188790](Count, v5);
    uint64_t Typed = (char *)v17 - v9;
    if (v8 >= 0x200) {
      size_t v11 = 512;
    }
    else {
      size_t v11 = v8;
    }
    bzero((char *)v17 - v9, v11);
    if (v6 > 0x100)
    {
      uint64_t Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v7, 0xC0040B8AA526DLL, 0);
      if (!Typed) {
        __CFPropertyListCreateTopLevelKeyPaths_cold_2();
      }
    }
    else
    {
      bzero(Typed, 8 * v7);
    }
    CFSetGetValues(Mutable, (const void **)Typed);
    CFSetRef Mutable = CFSetCreateMutable(a1, v6, &kCFTypeSetCallBacks);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        CFTypeID v13 = CFGetTypeID(*(CFTypeRef *)&Typed[8 * i]);
        CFStringRef v14 = *(const __CFString **)&Typed[8 * i];
        if (v13 == 19)
        {
          CFSetAddValue(Mutable, v14);
        }
        else
        {
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v14, @":");
          CFSetAddValue(Mutable, ArrayBySeparatingStrings);
          if (ArrayBySeparatingStrings) {
            CFRelease(ArrayBySeparatingStrings);
          }
        }
      }
      if (v6 >= 0x101) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      }
    }
  }
  return Mutable;
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  v17[1] = *(const void **)off_1ECE0A5B0;
  v17[0] = theString;
  CFIndex Length = CFStringGetLength(theString);
  v20.CFIndex location = 0;
  v20.size_t length = Length;
  CFArrayRef Results = CFStringCreateArrayWithFindResults(alloc, theString, separatorString, v20, 0);
  if (!Results) {
    return CFArrayCreate(alloc, v17, 1, &kCFTypeArrayCallBacks);
  }
  CFArrayRef v8 = Results;
  CFIndex Count = CFArrayGetCount(Results);
  CFSetRef Mutable = CFArrayCreateMutable(alloc, Count + 2, &kCFTypeArrayCallBacks);
  if (Count < 1)
  {
    CFIndex v11 = 0;
  }
  else
  {
    CFIndex v11 = 0;
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v8, i);
      v18.size_t length = *ValueAtIndex - v11;
      v18.CFIndex location = v11;
      CFStringRef v14 = CFStringCreateWithSubstring(alloc, theString, v18);
      CFArrayAppendValue(Mutable, v14);
      CFRelease(v14);
      CFIndex v11 = ValueAtIndex[1] + *ValueAtIndex;
    }
  }
  v19.size_t length = Length - v11;
  v19.CFIndex location = v11;
  CFStringRef v15 = CFStringCreateWithSubstring(alloc, theString, v19);
  CFArrayAppendValue(Mutable, v15);
  CFRelease(v15);
  CFRelease(v8);
  return Mutable;
}

CFDataRef _CFXPCCreateCFObjectFromXPCObject(const __CFURL *a1)
{
  CFURLRef v1 = a1;
  uint64_t v76 = *(void *)off_1ECE0A5B0;
  if (!a1) {
    return v1;
  }
  Class Class = object_getClass(a1);
  if (Class == (Class)off_1ECE0A6B0)
  {
    uint64_t v9 = &kCFNull;
LABEL_23:
    CFNullRef v11 = *v9;
    return (CFDataRef)CFRetain(v11);
  }
  if (Class == (Class)off_1ECE0A670)
  {
    BOOL value = xpc_BOOL_get_value(v1);
    uint64_t v9 = &kCFBooleanTrue;
    if (!value) {
      uint64_t v9 = &kCFBooleanFalse;
    }
    goto LABEL_23;
  }
  if (Class == (Class)off_1ECE0A6B8)
  {
    string_int8x16_t ptr = xpc_string_get_string_ptr(v1);
    return (CFDataRef)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string_ptr, 0x8000100u);
  }
  else if (Class == (Class)off_1ECE0A680)
  {
    size_t length = xpc_data_get_length(v1);
    if ((length & 0x8000000000000000) != 0) {
      return 0;
    }
    CFIndex v15 = length;
    bytes_int8x16_t ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v1);
    return CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes_ptr, v15);
  }
  else
  {
    if (Class == (Class)off_1ECE0A6A8)
    {
      *(void *)&long long uu1 = xpc_int64_get_value(v1);
      return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt64Type, &uu1);
    }
    if (Class == (Class)off_1ECE0A698)
    {
      *(void *)&long long uu1 = xpc_double_get_value(v1);
      return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberDoubleType, &uu1);
    }
    if (Class == (Class)off_1ECE0A688)
    {
      double v17 = (double)xpc_date_get_value(v1) / 1000000000.0 - 978307200.0;
      return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
    }
    else
    {
      if (Class != (Class)off_1ECE0A6C0)
      {
        if (Class != (Class)off_1ECE0A668)
        {
          if (Class != (Class)off_1ECE0A690) {
            return 0;
          }
          size_t count = xpc_dictionary_get_count(v1);
          if (count >> 58) {
            return 0;
          }
          CFIndex v4 = count;
          if (count == 3)
          {
            xpc_object_t v25 = xpc_dictionary_get_value(v1, "com.apple.CFURL.magic");
            if (v25)
            {
              uint64_t v26 = v25;
              if (object_getClass(v25) != (Class)off_1ECE0A6C0) {
                return 0;
              }
              long long uu1 = 0uLL;
              memset(uu, 0, sizeof(uu));
              long long uu1 = *(_OWORD *)xpc_uuid_get_bytes(v26);
              if (!uuid_parse("C3853DCC-9776-4114-B6C1-FD9F51944A6D", uu)
                && !uuid_compare((const unsigned __int8 *)&uu1, uu))
              {
                xpc_object_t v31 = xpc_dictionary_get_value(v1, "com.apple.CFURL.string");
                if (v31)
                {
                  CFURLRef v32 = (const __CFURL *)xpc_dictionary_get_value(v1, "com.apple.CFURL.base");
                  CFURLRef v1 = v32;
                  if (!v32) {
                    return v1;
                  }
                  if (object_getClass(v32) == (Class)off_1ECE0A690 || object_getClass(v1) == (Class)off_1ECE0A6B0)
                  {
                    int v33 = (__objc2_class **)_CFXPCCreateCFObjectFromXPCObject(v1);
                    if (v33)
                    {
                      CFTypeID v34 = CFURLGetTypeID();
                      if (v34 == CFGetTypeID(v33) || (CFTypeID TypeID = CFNullGetTypeID(), TypeID == CFGetTypeID(v33)))
                      {
                        CFStringRef v36 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject(v31);
                        CFStringRef v37 = v36;
                        if (v36)
                        {
                          if (CFGetTypeID(v36) == 7)
                          {
                            if (&__kCFNull == v33) {
                              CFURLRef v38 = 0;
                            }
                            else {
                              CFURLRef v38 = (const __CFURL *)v33;
                            }
                            CFURLRef v1 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v37, v38);
                            CFRelease(v33);
                            CFRelease(v37);
                            return v1;
                          }
                          CFRelease(v37);
                        }
                      }
                      CFRelease(v33);
                    }
                  }
                }
                return 0;
              }
            }
          }
          else
          {
            if (count != 2)
            {
              long long v74 = 0u;
              long long v75 = 0u;
              long long v72 = 0u;
              long long v73 = 0u;
              long long v70 = 0u;
              long long v71 = 0u;
              long long v68 = 0u;
              long long v69 = 0u;
              long long v66 = 0u;
              long long v67 = 0u;
              long long v64 = 0u;
              long long v65 = 0u;
              long long v62 = 0u;
              long long v63 = 0u;
              long long v60 = 0u;
              long long v61 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v56 = 0u;
              long long v57 = 0u;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              long long v48 = 0u;
              long long v49 = 0u;
              long long v46 = 0u;
              long long v47 = 0u;
              long long uu1 = 0u;
              long long v45 = 0u;
              if (count < 0x81) {
                goto LABEL_62;
              }
              p_long long uu1 = (const void **)malloc_type_malloc(16 * count, 0xC0040B8AA526DuLL);
              if (p_uu1) {
                goto LABEL_63;
              }
              return 0;
            }
            xpc_object_t v5 = xpc_dictionary_get_value(v1, "com.apple.CFDate.magic");
            if (v5)
            {
              unint64_t v6 = v5;
              if (object_getClass(v5) == (Class)off_1ECE0A6C0)
              {
                memset(uu, 0, sizeof(uu));
                long long uu1 = *(_OWORD *)xpc_uuid_get_bytes(v6);
                if (!uuid_parse("C119A421-DF31-48EF-843D-21B4030D1621", uu)
                  && !uuid_compare((const unsigned __int8 *)&uu1, uu))
                {
                  double v7 = xpc_dictionary_get_double(v1, "com.apple.CFDate.ti");
                  return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7 - 978307200.0);
                }
                goto LABEL_60;
              }
              return 0;
            }
          }
LABEL_60:
          long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v60 = 0u;
          long long v61 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long uu1 = 0u;
          long long v45 = 0u;
LABEL_62:
          p_long long uu1 = (const void **)&uu1;
LABEL_63:
          *(void *)uuid_t uu = 0;
          *(void *)&uu[8] = uu;
          uint64_t v42 = 0x2000000000;
          uint64_t v43 = 0;
          v39[0] = off_1ECE0A5A0;
          v39[1] = 0x40000000;
          v39[2] = ___CFXPCCreateCFObjectFromXPCObject_block_invoke_2;
          v39[3] = &unk_1ECDFFDF8;
          v39[4] = uu;
          _OWORD v39[5] = p_uu1;
          v39[6] = v4;
          xpc_dictionary_apply(v1, v39);
          uint64_t v28 = *(void *)(*(void *)&uu[8] + 24);
          if (v4 == v28)
          {
            CFURLRef v1 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, p_uu1, &p_uu1[v4], v4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            uint64_t v28 = *(void *)(*(void *)&uu[8] + 24);
          }
          else
          {
            CFURLRef v1 = 0;
          }
          if (v28 >= 1)
          {
            uint64_t v29 = 0;
            uint64_t v30 = &p_uu1[v4];
            do
            {
              CFRelease(p_uu1[v29]);
              CFRelease(v30[v29++]);
            }
            while (v29 < *(void *)(*(void *)&uu[8] + 24));
          }
          if (p_uu1 == (const void **)&uu1) {
            goto LABEL_72;
          }
          uint64_t v24 = p_uu1;
LABEL_71:
          free(v24);
LABEL_72:
          _Block_object_dispose(uu, 8);
          return v1;
        }
        size_t v19 = xpc_array_get_count(v1);
        if (!(v19 >> 59))
        {
          CFIndex v20 = v19;
          long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v60 = 0u;
          long long v61 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long uu1 = 0u;
          long long v45 = 0u;
          if (v19 >= 0x101)
          {
            uint64_t v21 = (const void **)malloc_type_malloc(8 * v19, 0xC0040B8AA526DuLL);
            if (!v21) {
              return 0;
            }
          }
          else
          {
            uint64_t v21 = (const void **)&uu1;
          }
          *(void *)uuid_t uu = 0;
          *(void *)&uu[8] = uu;
          uint64_t v42 = 0x2000000000;
          uint64_t v43 = 0;
          applier[0] = off_1ECE0A5A0;
          applier[1] = 0x40000000;
          applier[2] = ___CFXPCCreateCFObjectFromXPCObject_block_invoke;
          applier[3] = &unk_1ECDFFDD0;
          applier[4] = uu;
          applier[5] = v21;
          xpc_array_apply(v1, applier);
          uint64_t v22 = *(void *)(*(void *)&uu[8] + 24);
          if (v20 == v22)
          {
            CFURLRef v1 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21, v20, &kCFTypeArrayCallBacks);
            uint64_t v22 = *(void *)(*(void *)&uu[8] + 24);
          }
          else
          {
            CFURLRef v1 = 0;
          }
          if (v22 >= 1)
          {
            uint64_t v23 = 0;
            do
              CFRelease(v21[v23++]);
            while (v23 < *(void *)(*(void *)&uu[8] + 24));
          }
          if (v21 == (const void **)&uu1) {
            goto LABEL_72;
          }
          uint64_t v24 = v21;
          goto LABEL_71;
        }
        return 0;
      }
      CFUUIDBytes v18 = *(CFUUIDBytes *)xpc_uuid_get_bytes(v1);
      return CFUUIDCreateFromUUIDBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
    }
  }
}

void sub_182BE711C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, length, bytes, length, 0);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  if (callBacks != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    goto LABEL_2;
  }
  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present)
  {
    uint64_t v9 = [NSArray alloc];
    return (CFArrayRef)[(NSArray *)v9 initWithObjects:values count:numValues];
  }
  else
  {
LABEL_2:
    return (CFArrayRef)__CFArrayCreate0((__objc2_class **)allocator, (uint64_t *)values, numValues, callBacks);
  }
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  CFIndex v8 = numValues;
  uint64_t v9 = values;
  uint64_t v10 = keys;
  CFIndex v12 = __NSCFDictionaryCreate((__objc2_class **)allocator, (unint64_t *)keys, (unint64_t *)values, numValues, keyCallBacks, valueCallBacks);
  if (!v12)
  {
    uint64_t Generic = __CFDictionaryCreateGeneric((__objc2_class **)allocator, (uint64_t)keyCallBacks, valueCallBacks);
    CFIndex v12 = (__objc2_class **)Generic;
    if (Generic)
    {
      if (v8 >= 1)
      {
        CFBasicHashSetCapacity(Generic, v8);
        do
        {
          unint64_t v15 = (unint64_t)*v10++;
          unint64_t v14 = v15;
          uint64_t v16 = (uint64_t)*v9++;
          CFBasicHashAddValue((uint64_t)v12, v14, v16);
          --v8;
        }
        while (v8);
      }
      unint64_t v17 = atomic_load((unint64_t *)v12 + 1);
      unint64_t v18 = v17;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)v12 + 1, &v18, v17 | 0x40);
        BOOL v19 = v18 == v17;
        unint64_t v17 = v18;
      }
      while (!v19);
      _CFRuntimeSetInstanceTypeIDAndIsa(v12, 0x12uLL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }
  return (CFDictionaryRef)v12;
}

__objc2_class **__NSCFDictionaryCreate(__objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4, const CFDictionaryKeyCallBacks *a5, const CFDictionaryValueCallBacks *a6)
{
  if (__FoundationPresent_static_init_0 != -1) {
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  }
  if (!__FoundationPresent_present_0
    || &__kCFAllocatorSystemDefault != a1
    && (a1 || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return 0;
  }
  BOOL v12 = a5 == &kCFCopyStringDictionaryKeyCallBacks || a5 == &kCFTypeDictionaryKeyCallBacks;
  if (!v12 || a6 != &kCFTypeDictionaryValueCallBacks) {
    return 0;
  }
  if (a5 != &kCFCopyStringDictionaryKeyCallBacks)
  {
    unint64_t v15 = (uint64_t *)a2;
    uint64_t v16 = (uint64_t *)a3;
    unint64_t v17 = a4;
    uint64_t v18 = 0;
LABEL_17:
    return (__objc2_class **)__NSDictionaryI_new(v15, v16, 0, v17, v18);
  }
  if (a4)
  {
    if (a4 != 1)
    {
      unint64_t v15 = (uint64_t *)a2;
      uint64_t v16 = (uint64_t *)a3;
      unint64_t v17 = a4;
      uint64_t v18 = 1;
      goto LABEL_17;
    }
    unint64_t v19 = *a2;
    unint64_t v20 = *a3;
    return (__objc2_class **)__NSSingleEntryDictionaryI_new(v19, v20, 1);
  }
  else
  {
    return &__NSDictionary0__struct;
  }
}

CFArrayRef CFStringCreateArrayWithFindResults(CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  uint64_t length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  CFAllocatorRef allocator = alloc;
  if (!alloc)
  {
    uint64_t v9 = _CFGetTSD(1u);
    uint64_t v10 = &__kCFAllocatorSystemDefault;
    if (v9) {
      uint64_t v10 = (__objc2_class **)v9;
    }
    CFAllocatorRef allocator = (const __CFAllocator *)v10;
  }
  if (length < 1) {
    return 0;
  }
  uint64_t v11 = 0;
  CFSetRef Mutable = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  result.CFIndex location = 0;
  result.uint64_t length = 0;
  uint64_t v16 = (location + length);
  while (1)
  {
    v25.CFIndex location = location;
    v25.uint64_t length = length;
    if (!CFStringFindWithOptionsAndLocale(theString, stringToFind, v25, compareOptions, 0, &result)) {
      break;
    }
    if ((compareOptions & 4) != 0)
    {
      uint64_t length = result.location - location;
    }
    else
    {
      CFIndex location = result.length + result.location;
      uint64_t length = v16 - (result.length + result.location);
    }
    if (v14 >= v13)
    {
      if (!Mutable) {
        CFSetRef Mutable = CFDataCreateMutable(allocator, 0);
      }
      uint64_t v13 = 2 * v13 + 8;
      CFDataSetLength(Mutable, 24 * v13);
      unint64_t v15 = (CFRange *)&CFDataGetMutableBytePtr(Mutable)[v11];
    }
    *unint64_t v15 = result;
    v15[1].CFIndex location = (CFIndex)Mutable;
    unint64_t v15 = (CFRange *)((char *)v15 + 24);
    ++v14;
    v11 += 24;
    if (length <= 0) {
      goto LABEL_18;
    }
  }
  if (!v14) {
    return 0;
  }
LABEL_18:
  CFArrayCallBacks callBacks = *(CFArrayCallBacks *)byte_1ECE0FFE8;
  CFDataSetLength(Mutable, 24 * v14);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v18 = CFArrayCreateMutable(allocator, 8 * v14, &callBacks);
  do
  {
    CFArrayAppendValue(v18, MutableBytePtr);
    MutableBytePtr += 24;
    --v14;
  }
  while (v14);
  CFRelease(Mutable);
  return v18;
}

uint64_t __CFArrayCreateInit(__objc2_class **a1, char a2, int a3, const CFArrayCallBacks *a4)
{
  int v5 = a2 & 3;
  unsigned int v6 = v5;
  if (a4)
  {
    retaiuint64_t n = (CFTypeRef (*)(int, CFTypeRef))a4->retain;
    if (retain || a4->release || a4->copyDescription || (unsigned int v6 = a2 & 3, a4->equal))
    {
      if (a4 == &kCFTypeArrayCallBacks
        || retain == __CFTypeCollectionRetain
        && (void (*)(int, CFTypeRef))a4->release == __CFTypeCollectionRelease
        && a4->copyDescription == CFCopyDescription
        && a4->equal == CFEqual)
      {
        unsigned int v6 = v5 | 4;
      }
      else
      {
        unsigned int v6 = v5 | 0xC;
      }
    }
  }
  int v8 = v6 & 0xC;
  int v9 = 8 * a3;
  if ((a2 & 3) != 0) {
    int v9 = 0;
  }
  if (v8 == 12) {
    int v10 = 72;
  }
  else {
    int v10 = 32;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x13uLL, (v10 + v9), 0);
  uint64_t v12 = Instance;
  if (Instance)
  {
    unint64_t v13 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v14 = v13;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v14, v13 & 0xFFFFFFFFFFFFFF80 | v6);
      BOOL v15 = v14 == v13;
      unint64_t v13 = v14;
    }
    while (!v15);
    *(void *)(Instance + 16) = 0;
    if (v5 == 2)
    {
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      *(void *)(v12 + 24) = 1;
      *(_DWORD *)(v12 + 32) = 0;
      *(void *)(v12 + 40) = 0;
    }
    else if (!v5 && __CFOASafe)
    {
      __CFSetLastAllocationEventName();
    }
    if (v8 == 12)
    {
      unsigned int v16 = atomic_load((unint64_t *)(v12 + 8));
      int v17 = (v16 >> 2) & 3;
      if (v17)
      {
        if (v17 == 1)
        {
          uint64_t v18 = (CFArrayCallBacks *)&kCFTypeArrayCallBacks;
        }
        else
        {
          atomic_load((unint64_t *)(v12 + 8));
          uint64_t v18 = (CFArrayCallBacks *)(v12 + 48);
        }
      }
      else
      {
        uint64_t v18 = (CFArrayCallBacks *)&__kCFNullArrayCallBacks;
      }
      long long v19 = *(_OWORD *)&a4->version;
      long long v20 = *(_OWORD *)&a4->release;
      v18->equal = a4->equal;
      *(_OWORD *)&v18->versiouint64_t n = v19;
      *(_OWORD *)&v18->release = v20;
    }
  }
  return v12;
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  if (!CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    uint64_t v4 = *((void *)theData + 2);
    char v5 = atomic_load((unint64_t *)theData + 1);
    char v6 = atomic_load((unint64_t *)theData + 1);
    if (v6)
    {
      if (length < 0)
      {
        if ((v5 & 2) != 0) {
          __CFDataHandleOutOfMemory(length);
        }
        __break(1u);
      }
      else
      {
        if (*((void *)theData + 3) >= length)
        {
          if (length > v4 && (char v7 = atomic_load((unint64_t *)theData + 1), (v7 & 0x40) != 0))
          {
            char v11 = atomic_load((unint64_t *)theData + 1);
            if ((v11 & 4) != 0) {
              unint64_t v12 = ((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0;
            }
            else {
              unint64_t v12 = *((void *)theData + 5);
            }
            bzero((void *)(v12 + v4), length - v4);
          }
          else if (length < v4)
          {
            unint64_t v8 = atomic_load((unint64_t *)theData + 1);
            unint64_t v9 = v8;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theData + 1, &v9, v8 | 0x40);
              BOOL v10 = v9 == v8;
              unint64_t v8 = v9;
            }
            while (!v10);
          }
          goto LABEL_21;
        }
        if ((v5 & 2) != 0)
        {
          __CFDataGrow((unint64_t *)theData, length - v4, 1);
          goto LABEL_21;
        }
      }
      CFDataSetLength_cold_1();
    }
LABEL_21:
    *((void *)theData + 2) = length;
    return;
  }

  [(__CFData *)theData setLength:length];
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    return (UInt8 *)[(__CFData *)theData mutableBytes];
  }
  else
  {
    char v3 = atomic_load((unint64_t *)theData + 1);
    if ((v3 & 4) != 0) {
      return (UInt8 *)(((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0);
    }
    else {
      return (UInt8 *)*((void *)theData + 5);
    }
  }
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  if (capacity) {
    char v3 = 1;
  }
  else {
    char v3 = 3;
  }
  return (CFMutableDataRef)__CFDataInit((__objc2_class **)allocator, v3, capacity, 0, 0, 0);
}

void _CFAppendXML0(const __CFString *a1, unsigned int a2, __CFData *a3)
{
  valuePtr[11] = *(void *)off_1ECE0A5B0;
  int v6 = CFGetTypeID(a1);
  uint64_t v7 = a2;
  if (a2)
  {
    uint64_t v8 = a2;
    do
    {
      if (v8 >= 4) {
        uint64_t v9 = 4;
      }
      else {
        uint64_t v9 = v8;
      }
      _plistAppendCharacters(a3, _appendIndents_tabs, v9);
      BOOL v10 = (unint64_t)v8 > 4;
      v8 -= 4;
    }
    while (v10);
  }
  if (v6 == 7)
  {
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
    _plistAppendCharacters(a3, L"string", 6);
    CFDataAppendBytes(a3, (const UInt8 *)">", 1);
    _appendEscapedString(a1, a3);
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
    char v11 = a3;
    unint64_t v12 = L"string";
    uint64_t v13 = 6;
LABEL_9:
    _plistAppendCharacters(v11, v12, v13);
    unint64_t v14 = ">\n";
    BOOL v15 = a3;
    CFIndex v16 = 2;
LABEL_10:
    CFDataAppendBytes(v15, (const UInt8 *)v14, v16);
    return;
  }
  if (_CFKeyedArchiverUIDGetTypeID() == v6)
  {
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
    _plistAppendCharacters(a3, L"dict", 4);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    uint64_t v17 = a2 + 1;
    if (a2 == -1)
    {
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1);
      _appendEscapedString(@"CF$UID", a3);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    }
    else
    {
      uint64_t v25 = a2 + 1;
      do
      {
        if (v25 >= 4) {
          uint64_t v26 = 4;
        }
        else {
          uint64_t v26 = v25;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v26);
        BOOL v10 = (unint64_t)v25 > 4;
        v25 -= 4;
      }
      while (v10);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1);
      _appendEscapedString(@"CF$UID", a3);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      do
      {
        if (v17 >= 4) {
          uint64_t v27 = 4;
        }
        else {
          uint64_t v27 = v17;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v27);
        BOOL v10 = (unint64_t)v17 > 4;
        v17 -= 4;
      }
      while (v10);
    }
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
    _plistAppendCharacters(a3, L"integer", 7);
    CFDataAppendBytes(a3, (const UInt8 *)">", 1);
    valuePtr[0] = _CFKeyedArchiverUIDGetValue((uint64_t)a1);
    CFNumberRef v28 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt64Type, valuePtr);
    _plistAppendFormat(a3, @"%@", v28);
    CFRelease(v28);
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
    _plistAppendCharacters(a3, L"integer", 7);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    if (a2)
    {
      do
      {
        if (v7 >= 4) {
          uint64_t v29 = 4;
        }
        else {
          uint64_t v29 = v7;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v29);
        BOOL v10 = (unint64_t)v7 > 4;
        v7 -= 4;
      }
      while (v10);
    }
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
    uint64_t v30 = L"dict";
    goto LABEL_39;
  }
  switch(v6)
  {
    case 18:
      unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"dict", 4);
      if (!Count) {
        goto LABEL_84;
      }
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      MEMORY[0x1F4188790](v19, v20);
      uint64_t v23 = (char *)v76 - v22;
      if (v21 >= 0x200) {
        size_t v24 = 512;
      }
      else {
        size_t v24 = v21;
      }
      bzero((char *)v76 - v22, v24);
      v76[1] = (CFAllocatorRef)v76;
      if (Count > 0x100)
      {
        uint64_t Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
        if (!Typed) {
          _CFAppendXML0_cold_1();
        }
        uint64_t v23 = (char *)Typed;
      }
      else
      {
        bzero(v23, 8 * Count);
      }
      CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, (const void **)v23, 0);
      v76[0] = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
      CFSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
      v81.CFIndex location = 0;
      v81.uint64_t length = 0;
      CFArrayReplaceValues(Mutable, v81, (const void **)v23, Count);
      v82.CFIndex location = 0;
      v82.uint64_t length = Count;
      CFArraySortValues(Mutable, v82, (CFComparatorFunction)CFStringCompare, 0);
      v83.CFIndex location = 0;
      v83.uint64_t length = Count;
      uint64_t v78 = v23;
      CFArrayGetValues(Mutable, v83, (const void **)v23);
      CFRelease(Mutable);
      uint64_t v66 = 0;
      unsigned int v77 = a2;
      do
      {
        CFStringRef v67 = (const __CFString *)v78[v66];
        if (a2 != -1)
        {
          uint64_t v68 = a2 + 1;
          do
          {
            if (v68 >= 4) {
              uint64_t v69 = 4;
            }
            else {
              uint64_t v69 = v68;
            }
            _plistAppendCharacters(a3, _appendIndents_tabs, v69);
            BOOL v10 = (unint64_t)v68 > 4;
            v68 -= 4;
          }
          while (v10);
        }
        CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
        _plistAppendCharacters(a3, L"key", 3);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1);
        _appendEscapedString(v67, a3);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
        _plistAppendCharacters(a3, L"key", 3);
        CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
        CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, v67);
        _CFAppendXML0(Value, a2 + 1, a3);
        ++v66;
      }
      while (v66 != Count);
      if (Count >= 0x101) {
        CFAllocatorDeallocate(v76[0], v78);
      }
      if (v77)
      {
        do
        {
          if (v7 >= 4) {
            uint64_t v71 = 4;
          }
          else {
            uint64_t v71 = v7;
          }
          _plistAppendCharacters(a3, _appendIndents_tabs, v71);
          BOOL v10 = (unint64_t)v7 > 4;
          v7 -= 4;
        }
        while (v10);
      }
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      _plistAppendCharacters(a3, L"dict", 4);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      return;
    case 19:
      uint64_t v33 = CFArrayGetCount((CFArrayRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"array", 5);
      if (!v33) {
        goto LABEL_84;
      }
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      for (CFIndex i = 0; i != v33; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        _CFAppendXML0(ValueAtIndex, a2 + 1, a3);
      }
      if (a2)
      {
        do
        {
          if (v7 >= 4) {
            uint64_t v36 = 4;
          }
          else {
            uint64_t v36 = v7;
          }
          _plistAppendCharacters(a3, _appendIndents_tabs, v36);
          BOOL v10 = (unint64_t)v7 > 4;
          v7 -= 4;
        }
        while (v10);
      }
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      unint64_t v12 = L"array";
      char v11 = a3;
      uint64_t v13 = 5;
      goto LABEL_9;
    case 20:
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"data", 4);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      CFIndex Length = CFDataGetLength((CFDataRef)a1);
      if (a2 >= 8uLL) {
        uint64_t v39 = 8;
      }
      else {
        uint64_t v39 = a2;
      }
      if (Length < 1) {
        goto LABEL_113;
      }
      unint64_t v40 = Length;
      unsigned int v77 = a2;
      uint64_t v41 = 0;
      unint64_t v42 = 0;
      uint64_t v78 = (void *)v39;
      uint64_t v43 = 76 - 8 * v39;
      break;
    case 21:
      int v58 = CFBooleanGetValue((CFBooleanRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      if (v58)
      {
        long long v59 = L"true";
        long long v60 = a3;
        uint64_t v61 = 4;
      }
      else
      {
        long long v59 = L"false";
        long long v60 = a3;
        uint64_t v61 = 5;
      }
      _plistAppendCharacters(v60, v59, v61);
LABEL_84:
      unint64_t v14 = "/>\n";
      BOOL v15 = a3;
      CFIndex v16 = 3;
      goto LABEL_10;
    case 22:
      int IsFloatType = CFNumberIsFloatType((CFNumberRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      if (IsFloatType)
      {
        _plistAppendCharacters(a3, L"real", 4);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1);
        CFStringRef v63 = __CFNumberCopyFormattingDescriptionAsFloat64((CFNumberRef)a1);
        _plistAppendString(a3, v63);
        CFRelease(v63);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
        char v11 = a3;
        unint64_t v12 = L"real";
LABEL_81:
        uint64_t v13 = 4;
      }
      else
      {
        _plistAppendCharacters(a3, L"integer", 7);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1);
        _plistAppendFormat(a3, @"%@", a1);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
        char v11 = a3;
        unint64_t v12 = L"integer";
        uint64_t v13 = 7;
      }
      goto LABEL_9;
    default:
      if (v6 != 42) {
        return;
      }
      CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
      CFGregorianDate GregorianDate = CFAbsoluteTimeGetGregorianDate(AbsoluteTime, 0);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"date", 4);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1);
      _plistAppendFormat(a3, @"%04d-%02d-%02dT%02d:%02d:%02dZ", *(void *)&GregorianDate.year, ((int)(*(void *)&GregorianDate.year >> 8) >> 24), ((int)(*(void *)&GregorianDate.year >> 16) >> 24), ((int)(*(void *)&GregorianDate.year >> 24) >> 24), (*(int *)&GregorianDate.month >> 24), (int)GregorianDate.second);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      char v11 = a3;
      unint64_t v12 = L"date";
      goto LABEL_81;
  }
  do
  {
    uint64_t v44 = BytePtr;
    unint64_t v45 = v42 % 3;
    if (v42 % 3 == 2)
    {
      int v47 = *BytePtr;
      uint64_t v48 = v41 + 1;
      *((unsigned char *)valuePtr + v41) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[((unint64_t)(v47 | (*(BytePtr - 1) << 8)) >> 6) & 0x3F];
      unint64_t v46 = v47 & 0x3F;
      uint64_t v49 = 2;
    }
    else
    {
      if (v45 == 1)
      {
        unint64_t v46 = ((unint64_t)(*BytePtr | (*(BytePtr - 1) << 8)) >> 4) & 0x3F;
      }
      else
      {
        if (v45) {
          goto LABEL_65;
        }
        unint64_t v46 = (unint64_t)*BytePtr >> 2;
      }
      uint64_t v49 = 1;
      uint64_t v48 = v41;
    }
    v41 += v49;
    *((unsigned char *)valuePtr + v48) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[v46];
LABEL_65:
    if (v41 >= v43)
    {
      *(_WORD *)((char *)valuePtr + v41) = 10;
      if (v77)
      {
        uint64_t v50 = (uint64_t)v78;
        do
        {
          if (v50 >= 4) {
            uint64_t v51 = 4;
          }
          else {
            uint64_t v51 = v50;
          }
          _plistAppendCharacters(a3, _appendIndents_tabs, v51);
          BOOL v10 = (unint64_t)v50 > 4;
          v50 -= 4;
        }
        while (v10);
      }
      size_t v52 = strlen((const char *)valuePtr);
      CFDataAppendBytes(a3, (const UInt8 *)valuePtr, v52);
      uint64_t v41 = 0;
    }
    ++v42;
    BytePtr = v44 + 1;
  }
  while (v42 != v40);
  if (v40 % 3 == 2)
  {
    char v55 = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[4 * (*v44 & 0xF)];
    uint64_t v56 = 2;
    uint64_t v57 = 1;
    uint64_t v54 = v41;
    a2 = v77;
    uint64_t v53 = (uint64_t)v78;
LABEL_105:
    uint64_t v72 = v57 + v41;
    *((unsigned char *)valuePtr + v54) = v55;
    v41 += v56;
    *((unsigned char *)valuePtr + v72) = 61;
  }
  else
  {
    a2 = v77;
    uint64_t v53 = (uint64_t)v78;
    if (v40 % 3 == 1)
    {
      uint64_t v54 = v41 + 1;
      *((unsigned char *)valuePtr + v41) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[16 * (*v44 & 3)];
      char v55 = 61;
      uint64_t v56 = 3;
      uint64_t v57 = 2;
      goto LABEL_105;
    }
  }
  if (v41 >= 1)
  {
    *(_WORD *)((char *)valuePtr + v41) = 10;
    if (a2)
    {
      do
      {
        if (v53 >= 4) {
          uint64_t v73 = 4;
        }
        else {
          uint64_t v73 = v53;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v73);
        BOOL v10 = (unint64_t)v53 > 4;
        v53 -= 4;
      }
      while (v10);
    }
    size_t v74 = strlen((const char *)valuePtr);
    CFDataAppendBytes(a3, (const UInt8 *)valuePtr, v74);
  }
LABEL_113:
  if (a2)
  {
    do
    {
      if (v7 >= 4) {
        uint64_t v75 = 4;
      }
      else {
        uint64_t v75 = v7;
      }
      _plistAppendCharacters(a3, _appendIndents_tabs, v75);
      BOOL v10 = (unint64_t)v7 > 4;
      v7 -= 4;
    }
    while (v10);
  }
  CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
  uint64_t v30 = L"data";
LABEL_39:
  _plistAppendCharacters(a3, v30, 4);
  CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    [(__CFData *)theData appendBytes:bytes length:length];
  }
  else
  {
    v6.CFIndex location = *((void *)theData + 2);
    v6.uint64_t length = 0;
    CFDataReplaceBytes(theData, v6, bytes, length);
  }
}

unint64_t *__CFDataInit(__objc2_class **a1, char a2, unint64_t a3, const UInt8 *a4, CFIndex a5, const void *a6)
{
  CFRange v6 = a6;
  char v11 = a1;
  BOOL v12 = 0;
  if ((a2 & 2) == 0 && !a6) {
    BOOL v12 = 4 * *(void *)off_1ECE0A708 - 63 > a3;
  }
  if (!a1)
  {
    uint64_t v13 = _CFGetTSD(1u);
    if (v13) {
      char v11 = (__objc2_class **)v13;
    }
    else {
      char v11 = &__kCFAllocatorSystemDefault;
    }
  }
  BOOL ShouldUseAllocator = __CFDataShouldUseAllocator(v11);
  if (v12) {
    uint64_t v15 = a3 + 47;
  }
  else {
    uint64_t v15 = 32;
  }
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(v11, 0x14uLL, v15, 0);
  uint64_t v17 = Instance;
  if (!Instance) {
    return v17;
  }
  Instance[2] = 0;
  unint64_t v18 = atomic_load(Instance + 1);
  uint64_t v19 = 4;
  if (!v12) {
    uint64_t v19 = 0;
  }
  unint64_t v20 = v18;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v20, v18 & 0xFFFFFFFFFFFFFFFBLL | v19);
    BOOL v21 = v20 == v18;
    unint64_t v18 = v20;
  }
  while (!v21);
  unint64_t v22 = atomic_load(Instance + 1);
  unint64_t v23 = v22;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v23, v22 & 0xFFFFFFFFFFFFFFF7 | (8 * (ShouldUseAllocator & 0x1F)));
    BOOL v21 = v23 == v22;
    unint64_t v22 = v23;
  }
  while (!v21);
  if ((a2 & 1) != 0 && (a2 & 2) != 0)
  {
    Instance[3] = 16;
    unint64_t v24 = atomic_load(Instance + 1);
    unint64_t v25 = v24;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v25, v24 | 3);
      BOOL v21 = v25 == v24;
      unint64_t v24 = v25;
    }
    while (!v21);
  }
  else
  {
    Instance[3] = a3;
    unint64_t v26 = atomic_load(Instance + 1);
    unint64_t v27 = v26;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v27, v26 & 0xFFFFFFFFFFFFFFFCLL | 1);
      BOOL v21 = v27 == v26;
      unint64_t v26 = v27;
    }
    while (!v21);
  }
  if (v6)
  {
    Instance[5] = (unint64_t)a4;
    Instance[4] = (unint64_t)CFRetain(v6);
    void v17[2] = a5;
    if (a2) {
      return v17;
    }
    goto LABEL_66;
  }
  if ((a2 & 1) != 0 && (a2 & 2) == 0) {
    LODWORD(v6) = _CFExecutableLinkedOnOrAfter(6uLL) == 0;
  }
  if (v12)
  {
    if ((a2 & 1) != 0 || a5)
    {
LABEL_61:
      uint64_t v34 = 0;
      unint64_t v33 = atomic_load(v17 + 1);
      goto LABEL_62;
    }
    v17[5] = 0;
    unint64_t v28 = atomic_load(v17 + 1);
    unint64_t v29 = v28;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v17 + 1, &v29, v28 & 0xFFFFFFFFFFFFFFFBLL);
      BOOL v21 = v29 == v28;
      unint64_t v28 = v29;
    }
    while (!v21);
    if (__CFDataInit_didCheck)
    {
LABEL_57:
      if (__CFDataInit_setToNull == 1)
      {
        v17[5] = ((unint64_t)v17 + 63) & 0xFFFFFFFFFFFFFFF0;
        unint64_t v35 = atomic_load(v17 + 1);
        unint64_t v36 = v35;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)v17 + 1, &v36, v35 | 4);
          BOOL v21 = v36 == v35;
          unint64_t v35 = v36;
        }
        while (!v21);
      }
      goto LABEL_61;
    }
    uint64_t v30 = (char *)_CFProcessPath();
    if (v30)
    {
      xpc_object_t v31 = strrchr(v30, 47);
      if (!v31)
      {
LABEL_56:
        __CFDataInit_didChecuint64_t k = 1;
        goto LABEL_57;
      }
    }
    else
    {
      xpc_object_t v31 = "";
    }
    if (!strcmp(v31, "/Remote") && _CFAppVersionCheckLessThan(@"com.apple.Remote", -1, 2.1)) {
      __CFDataInit_setToNull = 1;
    }
    goto LABEL_56;
  }
  CFURLRef v32 = __CFDataAllocate((uint64_t)v17, v17[3], (int)v6);
  v17[5] = (unint64_t)v32;
  if (__CFOASafe)
  {
    __CFSetLastAllocationEventName();
    CFURLRef v32 = (void *)v17[5];
  }
  if (!v32)
  {
    CFRelease(v17);
    return 0;
  }
  unint64_t v33 = atomic_load(v17 + 1);
  uint64_t v34 = 64;
  if (v6) {
    uint64_t v34 = 0;
  }
LABEL_62:
  unint64_t v37 = v33;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)v17 + 1, &v37, v33 & 0xFFFFFFFFFFFFFFBFLL | v34);
    BOOL v21 = v37 == v33;
    unint64_t v33 = v37;
  }
  while (!v21);
  v17[4] = 0;
  v41.CFIndex location = 0;
  v41.uint64_t length = 0;
  CFDataReplaceBytes((CFMutableDataRef)v17, v41, a4, a5);
  if ((a2 & 1) == 0)
  {
LABEL_66:
    unint64_t v38 = atomic_load(v17 + 1);
    unint64_t v39 = v38;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v17 + 1, &v39, v38 & 0xFFFFFFFFFFFFFFFCLL);
      BOOL v21 = v39 == v38;
      unint64_t v38 = v39;
    }
    while (!v21);
  }
  return v17;
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v8 = (uint64_t)theData;
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    objc_msgSend((id)v8, "replaceBytesInRange:withBytes:length:", location, length, newBytes, newLength);
    return;
  }
  CFIndex v9 = *(void *)(v8 + 16);
  CFIndex v10 = *(void *)(v8 + 24);
  if (location < 0)
  {
    if (dyld_program_sdk_at_least()) {
      CFDataReplaceBytes_cold_11();
    }
    char v11 = _CFOSLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      CFDataReplaceBytes_cold_12();
    }
  }
  else
  {
    if (location <= v9)
    {
      if (length < 0)
      {
        if (dyld_program_sdk_at_least()) {
          CFDataReplaceBytes_cold_9();
        }
        uint64_t v8 = _CFOSLog();
        if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_FAULT)) {
          CFDataReplaceBytes_cold_10();
        }
        goto LABEL_61;
      }
      if (location + length > v9)
      {
        if (dyld_program_sdk_at_least()) {
          CFDataReplaceBytes_cold_7();
        }
        unint64_t v24 = _CFOSLog();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          CFDataReplaceBytes_cold_8();
        }
      }
      goto LABEL_21;
    }
    if (dyld_program_sdk_at_least()) {
      CFDataReplaceBytes_cold_1();
    }
    BOOL v12 = _CFOSLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      goto LABEL_62;
    }
  }
  while (length < 0)
  {
LABEL_61:
    qword_1EC093AA8 = (uint64_t)"Negative range.length passed to CFDataReplaceBytes";
    __break(1u);
LABEL_62:
    CFDataReplaceBytes_cold_6();
  }
LABEL_21:
  if (newLength < 0) {
    CFDataReplaceBytes_cold_2();
  }
  CFIndex v13 = v9 - length + newLength;
  if (v13 < 0) {
    CFDataReplaceBytes_cold_3();
  }
  if (!newBytes && newLength) {
    CFDataReplaceBytes_cold_4();
  }
  char v14 = atomic_load((unint64_t *)(v8 + 8));
  if ((v14 & 4) != 0) {
    unint64_t v15 = (v8 + 63) & 0xFFFFFFFFFFFFFFF0;
  }
  else {
    unint64_t v15 = *(void *)(v8 + 40);
  }
  char v16 = atomic_load((unint64_t *)(v8 + 8));
  int v17 = v16 & 3;
  if (v17 == 1)
  {
    unint64_t v18 = (UInt8 *)newBytes;
    if (v13 > v10) {
      CFDataReplaceBytes_cold_5();
    }
  }
  else if (v17 == 3 && v10 < v13)
  {
    unint64_t v18 = (UInt8 *)newBytes;
    if (newLength)
    {
      unint64_t v18 = (UInt8 *)newBytes;
      if (newBytes)
      {
        unint64_t v18 = (UInt8 *)newBytes;
        if (v15)
        {
          unint64_t v18 = (UInt8 *)newBytes;
          if (v15 + v10 > (unint64_t)newBytes)
          {
            uint64_t v19 = (UInt8 *)malloc_type_malloc(newLength, 0x65CD2194uLL);
            if (!v19) {
              __CFDataHandleOutOfMemory(newLength);
            }
            unint64_t v18 = v19;
            memmove(v19, newBytes, newLength);
          }
        }
      }
    }
    __CFDataGrow((unint64_t *)v8, newLength - length, 0);
    char v20 = atomic_load((unint64_t *)(v8 + 8));
    if ((v20 & 4) != 0) {
      unint64_t v15 = (v8 + 63) & 0xFFFFFFFFFFFFFFF0;
    }
    else {
      unint64_t v15 = *(void *)(v8 + 40);
    }
  }
  else
  {
    unint64_t v18 = (UInt8 *)newBytes;
  }
  if (newLength) {
    BOOL v21 = v18 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  int v22 = !v21;
  if (length != newLength)
  {
    int64_t v23 = v9 - (location + length);
    if (v23 >= 1) {
      memmove((void *)(v15 + location + newLength), (const void *)(v15 + location + length), v23);
    }
  }
  if (v22) {
    memmove((void *)(v15 + location), v18, newLength);
  }
  if (v18 != newBytes) {
    free(v18);
  }
  *(void *)(v8 + 16) = v13;
}

BOOL __CFDataShouldUseAllocator(__objc2_class **a1)
{
  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1) {
      a1 = &__kCFAllocatorSystemDefault;
    }
  }
  return a1 != &__kCFAllocatorSystemDefault && a1 != &__kCFAllocatorMalloc && a1 != &__kCFAllocatorMallocZone;
}

void _plistAppendCharacters(CFMutableDataRef theData, _WORD *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  unint64_t v7 = a3 - 1;
  uint64_t v8 = a2 + 1;
  while (1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    if (a3 >= 1 && v6 >= -399)
    {
      unint64_t v11 = v6 + 399;
      if (v7 < v6 + 399) {
        unint64_t v11 = v7;
      }
      if ((unsigned __int16)*a2 > 0x7Fu)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
      }
      else
      {
        uint64_t v9 = 0;
        UInt8 v12 = *a2;
        while (1)
        {
          uint64_t v13 = v9;
          bytes[v9] = v12;
          if (v11 == v9) {
            break;
          }
          unsigned int v14 = (unsigned __int16)v8[v9];
          UInt8 v12 = v8[v9++];
          if (v14 > 0x7F) {
            goto LABEL_13;
          }
        }
        uint64_t v9 = v11 + 1;
LABEL_13:
        uint64_t v10 = v13 + 1;
      }
    }
    if (v9 > v6)
    {
      CFDataAppendBytes(theData, bytes, v10 - v6);
      uint64_t v6 = v9;
    }
    if (a3 <= v6) {
      break;
    }
    if ((unsigned __int16)a2[v6] >= 0x80u)
    {
      CFStringRef v15 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, &a2[v6], a3 - v6, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v15)
      {
        CFStringRef v16 = v15;
        ExternalRepresentatiouint64_t n = CFStringCreateExternalRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, 0x8000100u, 0);
        if (ExternalRepresentation)
        {
          CFDataRef v18 = ExternalRepresentation;
          BytePtr = CFDataGetBytePtr(ExternalRepresentation);
          CFIndex Length = CFDataGetLength(v18);
          CFDataAppendBytes(theData, BytePtr, Length);
          CFRelease(v18);
        }
        CFRelease(v16);
      }
      return;
    }
  }
}

void __CFDataGrow(unint64_t *cf, int64_t a2, int a3)
{
  int64_t v3 = cf[2];
  unint64_t v4 = v3 + a2;
  if ((unint64_t)(v3 + a2) >> 42) {
    __CFDataHandleOutOfMemory(v3 + a2);
  }
  if (v4 >= 0x10)
  {
    if (v4 >> 20)
    {
      if (HIDWORD(v4))
      {
        char v10 = flsl(0x20000000);
        if ((v4 >> (v10 - 1) << 29) + 0x20000000 >= 0x3FFFFFFFFFFLL) {
          uint64_t v8 = 0x3FFFFFFFFFFLL;
        }
        else {
          uint64_t v8 = (v4 >> (v10 - 1) << 29) + 0x20000000;
        }
      }
      else
      {
        uint64_t v8 = 1 << flsl(v3 + a2);
      }
    }
    else
    {
      char v9 = flsl(v3 + a2);
      uint64_t v8 = 1 << ((v9 & 1u) + v9);
    }
  }
  else
  {
    uint64_t v8 = 16;
  }
  CFAllocatorRef v11 = CFGetAllocator(cf);
  UInt8 v12 = (const void *)cf[5];
  if (!a3
    || (char v13 = atomic_load(cf + 1), v8 <= 0x20000)
    || (v13 & 8) != 0
    || (char v14 = atomic_load(cf + 1), (v14 & 8) != 0)
    || v3 && (uint64_t)v4 / v3 < 5
    || (CFStringRef v15 = __CFDataAllocate((uint64_t)cf, v8, 1)) == 0)
  {
    char v18 = atomic_load(cf + 1);
    if ((v18 & 8) != 0) {
      uint64_t v19 = __CFSafelyReallocateWithAllocatorTyped(v11, v12, v8, 0x100004077774924, 0, 0);
    }
    else {
      uint64_t v19 = __CFSafelyReallocateTyped(v12, v8, 0x100004077774924, 0);
    }
    uint64_t v16 = v19;
    if (!v19) {
      __CFDataHandleOutOfMemory(v8);
    }
    uint64_t v17 = 64;
    if (a3 && a2 >= 1)
    {
      bzero((void *)(v19 + v3), a2);
      uint64_t v17 = 64;
    }
  }
  else
  {
    uint64_t v16 = (uint64_t)v15;
    memmove(v15, v12, v3);
    __CFDataDeallocate((uint64_t)cf);
    uint64_t v17 = 0;
  }
  cf[3] = v8;
  unint64_t v20 = atomic_load(cf + 1);
  unint64_t v21 = v20;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v21, v20 & 0xFFFFFFFFFFFFFFBFLL | v17);
    BOOL v22 = v21 == v20;
    unint64_t v20 = v21;
  }
  while (!v22);
  cf[5] = v16;
  if (__CFOASafe)
  {
    __CFSetLastAllocationEventName();
  }
}

void *__CFSafelyReallocateImpl(void *a1, size_t a2, malloc_type_id_t a3, uint64_t a4)
{
  unint64_t v7 = malloc_type_realloc(a1, a2, a3);
  if (!v7) {
    __CFReallocationFailed((uint64_t)a1, a2, a4);
  }
  return v7;
}

void *__CFDataAllocate(uint64_t a1, size_t size, int a3)
{
  char v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 8) != 0)
  {
    if (a1 < 0)
    {
      unint64_t v7 = &kCFAllocatorSystemDefault;
    }
    else
    {
      char v8 = atomic_load((unint64_t *)(a1 + 8));
      if (v8 < 0) {
        unint64_t v7 = &kCFAllocatorSystemDefault;
      }
      else {
        unint64_t v7 = (const CFAllocatorRef *)(a1 - 16);
      }
    }
    uint64_t Typed = (void *)CFAllocatorAllocateTyped(*v7, size, 2869208503, 0);
    char v10 = Typed;
    if (a3) {
      bzero(Typed, size);
    }
    return v10;
  }
  else if (a3)
  {
    return malloc_type_calloc(1uLL, size, 0xB552CF23uLL);
  }
  else
  {
    return malloc_type_malloc(size, 0x4400A1E1uLL);
  }
}

void _appendEscapedString(const __CFString *a1, __CFData *a2)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v27 = 0;
  CFIndex v28 = Length;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  unint64_t v25 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v26 = CStringPtr;
  if (Length >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 64;
    memset(v23, 0, sizeof(v23));
    while (1)
    {
      uint64_t v11 = (unint64_t)v8 >= 4 ? 4 : v8;
      if (v25)
      {
        UniChar v12 = v25[v8 + v27];
      }
      else if (v26)
      {
        UniChar v12 = v26[v27 + v8];
      }
      else
      {
        uint64_t v13 = v29;
        if (v30 <= v8 || v29 > v8)
        {
          uint64_t v15 = -v11;
          uint64_t v16 = v11 + v7;
          uint64_t v17 = v10 - v11;
          uint64_t v18 = v8 + v15;
          CFIndex v19 = v18 + 64;
          if (v18 + 64 >= v28) {
            CFIndex v19 = v28;
          }
          uint64_t v29 = v18;
          uint64_t v30 = v19;
          if (v28 < v17) {
            uint64_t v17 = v28;
          }
          v33.CFIndex length = v17 + v16;
          v33.CFIndex location = v18 + v27;
          CFStringGetCharacters(theString, v33, (UniChar *)v23);
          uint64_t v13 = v29;
        }
        UniChar v12 = *((_WORD *)v23 + v8 - v13);
      }
      if (v9 >= 62 && (v12 & 0xFC00) == 0xD800)
      {
        _plistAppendCharacters(a2, v31, v9);
        uint64_t v9 = 0;
      }
      if (v12 == 38) {
        break;
      }
      if (v12 == 62)
      {
        if (v9) {
          _plistAppendCharacters(a2, v31, v9);
        }
        unint64_t v20 = a2;
        unint64_t v21 = "&gt;";
LABEL_34:
        CFIndex v22 = 4;
LABEL_38:
        CFDataAppendBytes(v20, (const UInt8 *)v21, v22);
        goto LABEL_39;
      }
      if (v12 == 60)
      {
        if (v9) {
          _plistAppendCharacters(a2, v31, v9);
        }
        unint64_t v20 = a2;
        unint64_t v21 = "&lt;";
        goto LABEL_34;
      }
      v31[v9++] = v12;
      if (v9 != 64) {
        goto LABEL_40;
      }
      _plistAppendCharacters(a2, v31, 64);
LABEL_39:
      uint64_t v9 = 0;
LABEL_40:
      ++v8;
      --v7;
      ++v10;
      if (Length == v8)
      {
        if (v9) {
          _plistAppendCharacters(a2, v31, v9);
        }
        return;
      }
    }
    if (v9) {
      _plistAppendCharacters(a2, v31, v9);
    }
    unint64_t v20 = a2;
    unint64_t v21 = "&amp;";
    CFIndex v22 = 5;
    goto LABEL_38;
  }
}

DIR *_CFIterateDirectory(const __CFString *a1, int a2, const __CFArray *a3, uint64_t a4)
{
  uint64_t v35 = *(void *)off_1ECE0A5B0;
  CFRange result = (DIR *)CFStringGetFileSystemRepresentation(a1, buffer, 1026);
  if (result)
  {
    CFRange result = opendir(buffer);
    if (result)
    {
      uint64_t v8 = result;
      uint64_t v29 = a4;
      uint64_t v27 = result;
      int v28 = a2;
      while (1)
      {
        uint64_t v9 = readdir(v8);
        if (!v9) {
          return (DIR *)closedir(v8);
        }
        uint64_t v10 = v9;
        d_namleuint64_t n = v9->d_namlen;
        if (!v9->d_namlen || !v9->d_ino) {
          goto LABEL_44;
        }
        if (v9->d_name[0] != 46) {
          goto LABEL_14;
        }
        if (d_namlen != 1)
        {
          if (d_namlen == 2)
          {
            int v12 = v9->d_name[1];
            if (v12 == 46) {
              goto LABEL_44;
            }
          }
          else
          {
            int v12 = v9->d_name[1];
          }
          if (v12 != 95)
          {
LABEL_14:
            CFStringRef cf = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9->d_name);
            v33[0] = 0;
            if (a3)
            {
              if (CFArrayGetCount(a3) < 1)
              {
                uint64_t v14 = 0;
              }
              else
              {
                CFIndex v13 = 0;
                uint64_t v14 = 0;
                do
                {
                  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, v13);
                  *(void *)char __dst = 0;
                  CFIndex Length = CFStringGetLength(ValueAtIndex);
                  CFStringEncoding v17 = CFStringFileSystemEncoding();
                  v36.CFIndex location = 0;
                  v36.CFIndex length = Length;
                  v14 += CFStringGetBytes(ValueAtIndex, v36, v17, 0, 0, (UInt8 *)&v33[v14], 1025 - v14, (CFIndex *)__dst);
                  if (v14 >= 1)
                  {
                    uint64_t v18 = *(void *)__dst;
                    if (v14 >= *(uint64_t *)__dst)
                    {
                      if (v33[v14 - 1] != 47) {
                        v33[v14++] = 47;
                      }
                    }
                    else if (v33[*(void *)__dst - 1] != 47)
                    {
                      v33[*(void *)__dst] = 47;
                      uint64_t v14 = v18 + 1;
                    }
                  }
                  ++v13;
                }
                while (v13 < CFArrayGetCount(a3));
              }
              v33[v14] = 0;
              a4 = v29;
              a2 = v28;
              uint64_t v8 = v27;
            }
            if (a2
              && (v10->d_type == 4
               || !v10->d_type
               && (memset(&v32, 0, sizeof(v32)),
                   strncpy(__dst, buffer, 0x400uLL),
                   __strlcat_chk(),
                   __strlcat_chk(),
                   !stat(__dst, &v32))
               && (v32.st_mode & 0xF000) == 0x4000))
            {
              __strlcat_chk();
            }
            else if (!a3)
            {
              CFStringRef v21 = cf;
              if (cf) {
                goto LABEL_40;
              }
              goto LABEL_44;
            }
            __strlcat_chk();
            CFStringRef v19 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v33);
            CFStringRef v20 = v19;
            CFStringRef v21 = cf;
            if (cf)
            {
              if (!v19)
              {
LABEL_40:
                CFStringRef v22 = (const __CFString *)CFRetain(v21);
                CFStringRef v21 = cf;
                CFStringRef v20 = v22;
              }
              uint64_t d_type = v10->d_type;
              CFStringRef v24 = v21;
              int v25 = (*(uint64_t (**)(uint64_t, CFStringRef, CFStringRef, uint64_t))(a4 + 16))(a4, v21, v20, d_type);
              CFRelease(v24);
              CFRelease(v20);
              if (v25) {
                int v26 = 0;
              }
              else {
                int v26 = 3;
              }
              goto LABEL_45;
            }
            if (v19) {
              CFRelease(v19);
            }
          }
        }
LABEL_44:
        int v26 = 2;
LABEL_45:
        if (v26 == 3) {
          return (DIR *)closedir(v8);
        }
      }
    }
  }
  return result;
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  uint64_t v3 = *(void *)&encoding;
  size_t v6 = strlen(cStr);

  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)cStr, v6, v3, 8u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  CFStringEncoding v4 = CFStringFileSystemEncoding();

  return CFStringCreateWithCString(alloc, buffer, v4);
}

uint64_t CFStringFileSystemEncoding()
{
  if ((__CFDefaultFileSystemEncoding & 1) == 0) {
    __CFDefaultFileCFStringEncoding SystemEncoding = 1;
  }
  return 134217984;
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return CFStringCompareWithOptionsAndLocale(theString1, theString2, rangeToCompare, compareOptions, 0);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  if (URLString) {
    return (CFURLRef)_CFURLCreateWithURLString((__objc2_class **)allocator, URLString, 1, baseURL);
  }
  else {
    return 0;
  }
}

CFStringRef __CFNumberCreateFormattingDescriptionAsFloat64(const __CFAllocator *a1, CFNumberRef number)
{
  valuePtr[1] = *(double *)off_1ECE0A5B0;
  valuePtr[0] = 0.0;
  CFNumberGetValue(number, kCFNumberFloat64Type, valuePtr);
  if (fabs(valuePtr[0]) == INFINITY)
  {
    if (valuePtr[0] <= 0.0) {
      uint64_t v3 = @"-infinity";
    }
    else {
      uint64_t v3 = @"+infinity";
    }
    return (CFStringRef)CFRetain(v3);
  }
  if (valuePtr[0] == 0.0)
  {
    uint64_t v3 = @"0.0";
    return (CFStringRef)CFRetain(v3);
  }
  return CFStringCreateWithFormat(a1, 0, @"%.*g", 17, *(void *)&valuePtr[0]);
}

CFStringRef __CFNumberCopyFormattingDescriptionAsFloat64(CFNumberRef number)
{
  return __CFNumberCreateFormattingDescriptionAsFloat64((const __CFAllocator *)&__kCFAllocatorSystemDefault, number);
}

CFURLEnumeratorResult CFURLEnumeratorGetNextURL(CFURLEnumeratorRef enumerator, CFURLRef *url, CFErrorRef *error)
{
  return MEMORY[0x1F4115018](enumerator, url, error);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return _CFURLCopyHostName((unint64_t)anURL, 1);
}

void sub_182BEA758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFBinaryPlistGetOffsetForValueFromDictionary3(char *a1, int a2, unint64_t a3, uint64_t a4, const __CFString *cf, unint64_t *a6, unint64_t *a7)
{
  uint64_t v87 = *(void *)off_1ECE0A5B0;
  if (!cf) {
    return 0;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 < 0x14 && ((0xE0001u >> v14) & 1) != 0) {
    return 0;
  }
  uint64_t v15 = 0;
  if (a3 < 8) {
    return v15;
  }
  unint64_t v16 = *(void *)(a4 + 24) - 1;
  if (v16 < a3) {
    return v15;
  }
  uint64_t v15 = 0;
  CFStringEncoding v17 = &a1[a3];
  if (&a1[a3] == (char *)-1) {
    return v15;
  }
  char v18 = *v17;
  if ((*v17 & 0xF0) != 0xD0) {
    return v15;
  }
  CFStringRef v19 = (unsigned int *)(v17 + 1);
  unint64_t v20 = v18 & 0xF;
  if ((v18 & 0xF) == 0xF)
  {
    if (&a1[v16] < (char *)v19) {
      return 0;
    }
    CFStringRef v21 = (unsigned __int8 *)(v17 + 2);
    char v22 = *(unsigned char *)v19;
    if ((*(unsigned char *)v19 & 0xF0) != 0x10) {
      return 0;
    }
    uint64_t v15 = 0;
    unsigned int v23 = v22 & 0xF;
    uint64_t v24 = 1 << (v22 & 0xF);
    if (__CFADD__(v24, v21) || (char *)v19 + v24 > &a1[v16]) {
      return v15;
    }
    switch((char)v24)
    {
      case 1:
        unint64_t v20 = *v21;
        goto LABEL_26;
      case 2:
        unint64_t v20 = __rev16(*(unsigned __int16 *)((char *)v19 + 1));
        goto LABEL_26;
      case 4:
        unint64_t v20 = bswap32(*(unsigned int *)((char *)v19 + 1));
        goto LABEL_26;
      case 8:
        unint64_t v20 = bswap64(*(void *)((char *)v19 + 1));
        goto LABEL_25;
      default:
        if (v23 >= 8)
        {
          unint64_t v20 = 0;
          uint64_t v25 = 0;
          CFStringRef v19 = (unsigned int *)&v21[v24];
          goto LABEL_33;
        }
        unint64_t v20 = 0;
        if ((v24 & 0xFE) != 0) {
          uint64_t v26 = v24;
        }
        else {
          uint64_t v26 = 1;
        }
        uint64_t v27 = (unsigned __int8 *)v19 + 1;
        do
        {
          unsigned int v28 = *v27++;
          unint64_t v20 = v28 | (v20 << 8);
          --v26;
        }
        while (v26);
LABEL_25:
        if ((v20 & 0x8000000000000000) != 0) {
          return 0;
        }
LABEL_26:
        CFStringRef v19 = (unsigned int *)&v21[v24];
        break;
    }
  }
  if (v20)
  {
    if (!is_mul_ok(2 * v20, *(unsigned __int8 *)(a4 + 7))) {
      return 0;
    }
    uint64_t v25 = 2 * v20 * *(unsigned __int8 *)(a4 + 7);
  }
  else
  {
    uint64_t v25 = 0;
  }
LABEL_33:
  uint64_t v15 = 0;
  if (__CFADD__(v25, v19) || &a1[v16] < (char *)v19 + v25 - 1) {
    return v15;
  }
  unsigned int v77 = a6;
  if (v14 != 7)
  {
    uint64_t v35 = 0;
    unsigned int v31 = *(unsigned __int8 *)(a4 + 7);
    uint64_t v79 = (unsigned __int8 *)(a4 + 7);
LABEL_47:
    int64_t v34 = -1;
    goto LABEL_48;
  }
  CFIndex Length = CFStringGetLength(cf);
  unsigned int v31 = *(unsigned __int8 *)(a4 + 7);
  uint64_t v79 = (unsigned __int8 *)(a4 + 7);
  if (Length == -1)
  {
    uint64_t v35 = 0;
    goto LABEL_47;
  }
  uint64_t v32 = Length;
  CStringPtr = CFStringGetCStringPtr(cf, 0);
  int64_t v34 = v32;
  uint64_t v35 = (char *)CStringPtr;
  if (v32 > 15 || CStringPtr)
  {
LABEL_48:
    if (!v20) {
      goto LABEL_113;
    }
    goto LABEL_49;
  }
  if (CFStringGetCString(cf, buffer, 16, 0))
  {
    size_t v36 = strnlen(buffer, 0x10uLL);
    int64_t v34 = v32;
    if (v36 == v32) {
      uint64_t v35 = buffer;
    }
    else {
      uint64_t v35 = 0;
    }
    if (!v20) {
      goto LABEL_113;
    }
    goto LABEL_49;
  }
  uint64_t v35 = 0;
  int64_t v34 = v32;
  if (!v20)
  {
LABEL_113:
    BOOL v38 = 0;
LABEL_114:
    int v69 = 0;
    return v38 & v69;
  }
LABEL_49:
  uint64_t v37 = 0;
  unint64_t v75 = v20 * v31;
  CFRange v83 = a1 + 8;
  unint64_t v78 = (unint64_t)&a1[*(void *)(a4 + 24) - 1];
  unint64_t v76 = ~v34;
  BOOL v38 = 1;
  __uint64_t n = v34;
  unint64_t v81 = v20;
  __s2 = v35;
  while (1)
  {
    if (v83 > (char *)v19) {
      goto LABEL_114;
    }
    unint64_t v39 = &a1[*(void *)(a4 + 24)];
    uint64_t v40 = *(unsigned __int8 *)(a4 + 7);
    if (&v39[-v40] < (char *)v19) {
      goto LABEL_114;
    }
    unint64_t v41 = *(unsigned __int8 *)(a4 + 7);
    switch(*(unsigned char *)(a4 + 7))
    {
      case 0:
        break;
      case 1:
        unint64_t v41 = *(unsigned __int8 *)v19;
        break;
      case 2:
        unint64_t v41 = __rev16(*(unsigned __int16 *)v19);
        break;
      case 4:
        unint64_t v41 = bswap32(*v19);
        break;
      case 8:
        unint64_t v41 = bswap64(*(void *)v19);
        break;
      default:
        unint64_t v41 = 0;
        uint64_t v42 = *(unsigned __int8 *)(a4 + 7);
        uint64_t v43 = v19;
        do
        {
          unsigned int v44 = *(unsigned __int8 *)v43;
          uint64_t v43 = (unsigned int *)((char *)v43 + 1);
          unint64_t v41 = v44 | (v41 << 8);
          --v42;
        }
        while (v42);
        break;
    }
    if (*(void *)(a4 + 8) <= v41) {
      goto LABEL_114;
    }
    unint64_t v45 = *(unsigned __int8 *)(a4 + 6);
    unint64_t v46 = (unsigned int *)&v39[v41 * v45];
    switch(*(unsigned char *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        unint64_t v45 = *(unsigned __int8 *)v46;
        break;
      case 2:
        unint64_t v45 = __rev16(*(unsigned __int16 *)v46);
        break;
      case 4:
        unint64_t v45 = bswap32(*v46);
        break;
      case 8:
        unint64_t v45 = bswap64(*(void *)v46);
        break;
      default:
        uint64_t v47 = *(unsigned __int8 *)(a4 + 6);
        unint64_t v45 = 0;
        do
        {
          unsigned int v48 = *(unsigned __int8 *)v46;
          unint64_t v46 = (unsigned int *)((char *)v46 + 1);
          unint64_t v45 = v48 | (v45 << 8);
          --v47;
        }
        while (v47);
        break;
    }
    if (v35)
    {
      char v49 = a1[v45];
      if ((v49 & 0xF0) == 0x50) {
        break;
      }
    }
    char v55 = v19;
    uint64_t v56 = v37;
    BOOL v57 = v38;
    CFTypeRef v85 = 0;
    CFTypeID v84 = 0;
    if (!__CFBinaryPlistCreateObjectFiltered(a1, a2, v45, a4, &__kCFAllocatorSystemDefault, 0xFFFFFFFF80000000, 0, 0, 0, 0, 0, &v85, &v84)|| v84 <= 0x13 && ((1 << v84) & 0xE0001) != 0)
    {
      if (v85) {
        CFRelease(v85);
      }
      goto LABEL_111;
    }
    int v58 = CFEqual(cf, v85);
    CFRelease(v85);
    int64_t v34 = __n;
    uint64_t v35 = __s2;
    uint64_t v37 = v56;
    CFStringRef v19 = v55;
    if (v58) {
      goto LABEL_105;
    }
    uint64_t v40 = *v79;
LABEL_86:
    CFStringRef v19 = (unsigned int *)((char *)v19 + v40);
    BOOL v38 = ++v37 < v81;
    if (v37 == v81) {
      goto LABEL_114;
    }
  }
  if (__CFADD__(v45, a1) || &a1[v45] == (char *)-1) {
    goto LABEL_114;
  }
  unint64_t v50 = v49 & 0xF;
  uint64_t v51 = (unsigned __int8 *)&a1[v45 + 1];
  if (v34 >= 15 && v50 == 15)
  {
    if (v78 < (unint64_t)v51) {
      goto LABEL_114;
    }
    size_t v52 = &a1[v45 + 2];
    if ((*v51 & 0xF0) != 0x10) {
      goto LABEL_114;
    }
    unsigned int v53 = *v51 & 0xF;
    uint64_t v54 = 1 << v53;
    if (__CFADD__(1 << v53, v52) || (unint64_t)&v51[v54] > v78) {
      goto LABEL_114;
    }
    switch((1 << v53))
    {
      case 1u:
        unint64_t v50 = *v52;
        goto LABEL_92;
      case 2u:
        unint64_t v50 = __rev16(*(unsigned __int16 *)&a1[v45 + 2]);
        goto LABEL_92;
      case 4u:
        unint64_t v50 = bswap32(*(_DWORD *)&a1[v45 + 2]);
        goto LABEL_92;
      case 8u:
        unint64_t v50 = bswap64(*(void *)&a1[v45 + 2]);
        goto LABEL_99;
      default:
        if (v53 < 8)
        {
          unint64_t v50 = 0;
          if ((v54 & 0xFE) != 0) {
            uint64_t v59 = v54;
          }
          else {
            uint64_t v59 = 1;
          }
          long long v60 = &a1[v45 + 2];
          do
          {
            unsigned int v61 = *v60++;
            unint64_t v50 = v61 | (v50 << 8);
            --v59;
          }
          while (v59);
LABEL_99:
          if ((v50 & 0x8000000000000000) != 0) {
            goto LABEL_114;
          }
          uint64_t v51 = (unsigned __int8 *)&v52[v54];
          int64_t v34 = __n;
        }
        else
        {
          unint64_t v50 = 0;
LABEL_92:
          uint64_t v51 = (unsigned __int8 *)&v52[v54];
        }
        break;
    }
  }
  if (v50 != v34) {
    goto LABEL_86;
  }
  if (v76 < (unint64_t)v51 || v78 < (unint64_t)&v51[v34 - 1]) {
    goto LABEL_114;
  }
  long long v62 = v19;
  uint64_t v63 = v37;
  BOOL v57 = v38;
  int v64 = memcmp(v51, __s2, v34);
  uint64_t v35 = __s2;
  int64_t v34 = __n;
  uint64_t v37 = v63;
  CFStringRef v19 = v62;
  if (v64) {
    goto LABEL_86;
  }
LABEL_105:
  long long v65 = (unsigned int *)((char *)v19 + v75);
  if (v83 > (char *)v19 + v75)
  {
LABEL_111:
    int v69 = 0;
    BOOL v38 = v57;
    return v38 & v69;
  }
  uint64_t v66 = &a1[*(void *)(a4 + 24)];
  uint64_t v67 = *(unsigned __int8 *)(a4 + 7);
  BOOL v38 = v57;
  if (&v66[-v67] < (char *)v65) {
    goto LABEL_114;
  }
  unint64_t v68 = *(unsigned __int8 *)(a4 + 7);
  switch(*(unsigned char *)(a4 + 7))
  {
    case 0:
      break;
    case 1:
      unint64_t v68 = *(unsigned __int8 *)v65;
      break;
    case 2:
      unint64_t v68 = __rev16(*(unsigned __int16 *)v65);
      break;
    case 4:
      unint64_t v68 = bswap32(*v65);
      break;
    case 8:
      unint64_t v68 = bswap64(*(void *)v65);
      break;
    default:
      unint64_t v68 = 0;
      do
      {
        unsigned int v70 = *(unsigned __int8 *)v65;
        long long v65 = (unsigned int *)((char *)v65 + 1);
        unint64_t v68 = v70 | (v68 << 8);
        --v67;
      }
      while (v67);
      break;
  }
  if (*(void *)(a4 + 8) <= v68) {
    goto LABEL_114;
  }
  if (a7)
  {
    unint64_t v71 = *(unsigned __int8 *)(a4 + 6);
    uint64_t v72 = (unsigned int *)&v66[v68 * v71];
    switch(*(unsigned char *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        unint64_t v71 = *(unsigned __int8 *)v72;
        break;
      case 2:
        unint64_t v71 = __rev16(*(unsigned __int16 *)v72);
        break;
      case 4:
        unint64_t v71 = bswap32(*v72);
        break;
      case 8:
        unint64_t v71 = bswap64(*(void *)v72);
        break;
      default:
        uint64_t v73 = *(unsigned __int8 *)(a4 + 6);
        unint64_t v71 = 0;
        do
        {
          unsigned int v74 = *(unsigned __int8 *)v72;
          uint64_t v72 = (unsigned int *)((char *)v72 + 1);
          unint64_t v71 = v74 | (v71 << 8);
          --v73;
        }
        while (v73);
        break;
    }
    *a7 = v71;
  }
  if (v77) {
    *unsigned int v77 = v45;
  }
  int v69 = 1;
  return v38 & v69;
}

__CFString *parsePlistObject(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v44 = *(void *)off_1ECE0A5B0;
  if (a3 >= 0x201)
  {
    uint64_t v34 = lineNumberStrings((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Too many nested arrays or dictionaries at line %d", v34);
    goto LABEL_3;
  }
  if (!advanceToNonSpace(a1))
  {
    if (a2)
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unexpected EOF while parsing plist");
      goto LABEL_3;
    }
    return 0;
  }
  uint64_t v11 = *(unsigned __int16 **)(a1 + 8);
  int v13 = *v11;
  uint64_t v12 = *v11;
  *(void *)(a1 + 8) = v11 + 1;
  if (v13 > 39)
  {
    if (v12 == 40)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeArrayCallBacks);
      if (!Mutable)
      {
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate array string while parsing plist");
        goto LABEL_3;
      }
      uint64_t v7 = Mutable;
      uint64_t v16 = a3 + 1;
      uint64_t v17 = parsePlistObject(a1, 0, v16);
      if (v17)
      {
        char v18 = (const void *)v17;
        do
        {
          CFArrayAppendValue(v7, v18);
          CFRelease(v18);
          if (!advanceToNonSpace(a1))
          {
            CFRelease(v7);
            uint64_t v40 = lineNumberStrings((unint64_t *)a1);
            CFErrorRef Error = __CFPropertyListCreateError(3840, @"Expected ',' for array at line %d", v40);
            goto LABEL_3;
          }
          CFStringRef v19 = *(_WORD **)(a1 + 8);
          if (*v19 != 44) {
            break;
          }
          *(void *)(a1 + 8) = v19 + 1;
          char v18 = (const void *)parsePlistObject(a1, 0, v16);
        }
        while (v18);
      }
      if (advanceToNonSpace(a1))
      {
        CFTypeID v14 = *(__int16 **)(a1 + 8);
        if (*v14 == 41)
        {
          unint64_t v20 = *(const void **)(a1 + 24);
          if (v20)
          {
            CFRelease(v20);
            *(void *)(a1 + 24) = 0;
            CFTypeID v14 = *(__int16 **)(a1 + 8);
          }
          goto LABEL_67;
        }
      }
      CFRelease(v7);
      uint64_t v37 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Expected terminating '' for array at line %d"), v37);
LABEL_3:
      CFErrorRef v5 = Error;
      size_t v6 = *(const void **)(a1 + 24);
      if (v6) {
        CFRelease(v6);
      }
      uint64_t v7 = 0;
      *(void *)(a1 + 24) = v5;
      return (__CFString *)v7;
    }
    if (v12 != 60)
    {
      if (v12 == 123)
      {
        uint64_t v7 = parsePlistDictContent(a1, a3);
        if (!v7) {
          return (__CFString *)v7;
        }
        if (advanceToNonSpace(a1))
        {
          CFTypeID v14 = *(__int16 **)(a1 + 8);
          if (*v14 == 125) {
            goto LABEL_67;
          }
        }
        CFRelease(v7);
        uint64_t v35 = lineNumberStrings((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Expected terminating '}' for dictionary at line %d", v35);
        goto LABEL_3;
      }
      goto LABEL_68;
    }
    CFMutableDataRef v21 = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
    if (!v21)
    {
      uint64_t v36 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate data while parsing property list at line %d", v36);
      goto LABEL_3;
    }
    uint64_t v7 = v21;
    CFTypeID v14 = *(__int16 **)(a1 + 8);
    unint64_t v22 = *(void *)(a1 + 16);
    if ((unint64_t)v14 >= v22) {
      goto LABEL_63;
    }
LABEL_35:
    int v23 = 0;
    while (1)
    {
      unsigned int v24 = (unsigned __int16)*v14;
      if (v24 == 62)
      {
LABEL_60:
        if (v23 < 0)
        {
          CFRelease(v7);
          if (v23 == -2)
          {
LABEL_84:
            uint64_t v38 = lineNumberStrings((unint64_t *)a1);
            CFErrorRef v31 = __CFPropertyListCreateError(3840, @"Malformed data byte group at line %d; uneven length", v38);
          }
          else
          {
LABEL_94:
            uint64_t v41 = lineNumberStrings((unint64_t *)a1);
            CFErrorRef v31 = __CFPropertyListCreateError(3840, @"Malformed data byte group at line %d; invalid hex", v41);
          }
          CFErrorRef v32 = v31;
          CFRange v33 = *(const void **)(a1 + 24);
          if (v33) {
            CFRelease(v33);
          }
          *(void *)(a1 + 24) = v32;
          return 0;
        }
        if (v23)
        {
          CFDataAppendBytes(v7, bytes, v23);
          CFTypeID v14 = *(__int16 **)(a1 + 8);
          unint64_t v22 = *(void *)(a1 + 16);
          if ((unint64_t)v14 < v22) {
            goto LABEL_35;
          }
        }
LABEL_63:
        unsigned int v28 = *(const void **)(a1 + 24);
        if (v28)
        {
          CFRelease(v28);
          *(void *)(a1 + 24) = 0;
          CFTypeID v14 = *(__int16 **)(a1 + 8);
          unint64_t v22 = *(void *)(a1 + 16);
        }
        if ((unint64_t)v14 < v22 && *v14 == 62)
        {
LABEL_67:
          *(void *)(a1 + 8) = v14 + 1;
          return (__CFString *)v7;
        }
        CFRelease(v7);
        uint64_t v39 = lineNumberStrings((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Expected terminating '>' for data at line %d", v39);
        goto LABEL_3;
      }
      if ((v24 & 0xFE) - 48 <= 9) {
        break;
      }
      if ((v24 - 97) <= 5u)
      {
        char v25 = v24 - 87;
LABEL_43:
        *(void *)(a1 + 8) = ++v14;
        if ((unint64_t)v14 >= v22) {
          goto LABEL_83;
        }
        __int16 v26 = *v14;
        if ((*v14 & 0xFEu) - 48 > 9)
        {
          if ((v26 - 97) > 5u)
          {
            if ((v26 - 65) > 5u) {
              goto LABEL_83;
            }
            char v27 = v26 - 55;
            goto LABEL_56;
          }
          char v27 = v26 - 87;
        }
        else
        {
          char v27 = v26 - 48;
LABEL_56:
          if (v27 == -1)
          {
LABEL_83:
            CFRelease(v7);
            goto LABEL_84;
          }
        }
        bytes[v23++] = v27 + 16 * v25;
        goto LABEL_58;
      }
      if ((v24 - 65) <= 5u)
      {
        char v25 = v24 - 55;
LABEL_39:
        if (v25 != -1) {
          goto LABEL_43;
        }
      }
      if ((v24 > 0x20 || ((1 << v24) & 0x100002600) == 0) && v24 - 8232 >= 2)
      {
        CFRelease(v7);
        goto LABEL_94;
      }
LABEL_58:
      *(void *)(a1 + 8) = ++v14;
      if ((unint64_t)v14 >= v22 || v23 >= 400) {
        goto LABEL_60;
      }
    }
    char v25 = v24 - 48;
    goto LABEL_39;
  }
  if (v12 != 34 && v12 != 39)
  {
LABEL_68:
    BOOL v29 = (v12 - 48) >= 0xA && (unsigned __int16)((v12 & 0xFFDF) - 65) >= 0x1Au;
    if (!v29
      || ((v12 - 36) <= 0x3B
        ? (BOOL v30 = ((1 << (v12 - 36)) & 0x800000000400E01) == 0)
        : (BOOL v30 = 1),
          !v30))
    {
      *(void *)(a1 + 8) = v11;
      return parseUnquotedPlistString(a1);
    }
    *(void *)(a1 + 8) = v11;
    if (a2)
    {
      uint64_t v42 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unexpected character '0x%x' at line %d", v12, v42);
      goto LABEL_3;
    }
    return 0;
  }

  return parseQuotedPlistString(a1, v12);
}

CFErrorRef __CFPropertyListCreateError(CFIndex code, CFStringRef format, ...)
{
  va_start(va, format);
  if (format)
  {
    CFStringRef v3 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, @"NSDebugDescription", v3);
    CFErrorRef v5 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", code, Mutable);
    CFRelease(v3);
    CFRelease(Mutable);
    return v5;
  }
  else
  {
    return CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", code, 0);
  }
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  CFErrorRef result = CFDictionaryCreate(allocator, (const void **)userInfoKeys, (const void **)userInfoValues, numUserInfoValues, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (result)
  {
    CFErrorRef v10 = result;
    uint64_t v11 = CFErrorCreate(allocator, domain, code, result);
    CFRelease(v10);
    return v11;
  }
  return result;
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  uint64_t Instance = (__CFError *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x1BuLL, 24, 0);
  if (Instance)
  {
    CFStringRef Copy = CFStringCreateCopy(allocator, domain);
    *((void *)Instance + 2) = code;
    *((void *)Instance + 3) = Copy;
    CFArrayRef v10 = _CFErrorCreateCallStackReturnAddresses(allocator);
    if (v10)
    {
      CFArrayRef v11 = v10;
      if (userInfo) {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(allocator, 0, userInfo);
      }
      else {
        MutableCFStringRef Copy = CFDictionaryCreateMutable(allocator, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      CFDictionaryRef v13 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionarySetValue(MutableCopy, @"NSCallStackReturnAddresses", v11);
        userInfo = v13;
      }
      CFRelease(v11);
    }
    else
    {
      CFDictionaryRef v13 = 0;
    }
    if (userInfo) {
      CFDictionaryRef EmptyDictionary = CFDictionaryCreateCopy(allocator, userInfo);
    }
    else {
      CFDictionaryRef EmptyDictionary = _CFErrorCreateEmptyDictionary(allocator);
    }
    *((void *)Instance + 4) = EmptyDictionary;
    if (v13) {
      CFRelease(v13);
    }
  }
  return Instance;
}

CFArrayRef _CFErrorCreateCallStackReturnAddresses(const __CFAllocator *a1)
{
  if ((atomic_load_explicit(_CFErrorCallStackCaptureEnabled, memory_order_acquire) & 1) == 0) {
    return 0;
  }
  CFStringEncoding v4 = (void *)MEMORY[0x185311AE0]();
  CFErrorRef v5 = +[NSThread callStackReturnAddresses];
  if (v5) {
    CFArrayRef Copy = CFArrayCreateCopy(a1, (CFArrayRef)v5);
  }
  else {
    CFArrayRef Copy = 0;
  }
  return Copy;
}

CFDictionaryRef _CFErrorCreateEmptyDictionary(CFAllocatorRef allocator)
{
  if (allocator)
  {
    CFAllocatorRef v1 = allocator;
  }
  else
  {
    uint64_t v2 = _CFGetTSD(1u);
    if (v2) {
      CFAllocatorRef v1 = (const __CFAllocator *)v2;
    }
    else {
      CFAllocatorRef v1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  if (&__kCFAllocatorSystemDefault == (__objc2_class **)v1
    || !v1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
  {
    return (CFDictionaryRef)CFRetain(&__NSDictionary0__struct);
  }
  else
  {
    return CFDictionaryCreate(v1, 0, 0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

const void *__CFCreateOldStylePropertyListOrStringsFile(const __CFAllocator *a1, CFDataRef theData, CFTypeRef cf, CFStringEncoding a4, int a5, CFErrorRef *a6, void *a7)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  if (cf)
  {
    CFStringRef v11 = (const __CFString *)CFRetain(cf);
  }
  else
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    CFStringRef v11 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, BytePtr, Length, a4, 0, (CFAllocatorRef)&__kCFAllocatorNull);
    if (!v11)
    {
      if (a6)
      {
        unsigned int v24 = 0;
        *a6 = __CFPropertyListCreateError(3840, @"Conversion of string failed.");
        return v24;
      }
      return 0;
    }
  }
  CFIndex v16 = CFStringGetLength(v11);
  if (!v16)
  {
    if (a6) {
      *a6 = __CFPropertyListCreateError(3840, @"Conversion of string failed. The string is empty.");
    }
    goto LABEL_19;
  }
  CFIndex v17 = v16;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(v11);
  CFStringRef v19 = CharactersPtr;
  if (CharactersPtr)
  {
    uint64_t v38 = 0;
    CFRange v33 = CharactersPtr;
    if (!__OFADD__(CharactersPtr, v17))
    {
      int v23 = (UniChar *)CharactersPtr;
      goto LABEL_22;
    }
    unint64_t v20 = (void *)&unk_1EC093000;
    CFMutableDataRef v21 = "Unable to address entirety of CFPropertyList";
    goto LABEL_18;
  }
  uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(a1, 2 * v17, 0x1000040BDFB0063, 0);
  if (!Typed)
  {
    unint64_t v20 = &unk_1EC093000;
    CFMutableDataRef v21 = "CFPropertyList ran out of memory while attempting to allocate temporary storage.";
LABEL_18:
    v20[341] = v21;
LABEL_19:
    CFRelease(v11);
    return 0;
  }
  int v23 = Typed;
  v41.CFIndex location = 0;
  v41.CFIndex length = v17;
  CFStringGetCharacters(v11, v41, Typed);
  CFRelease(v11);
  uint64_t v38 = 0;
  CFRange v33 = v23;
  if (__OFADD__(v23, v17))
  {
    qword_1EC093AA8 = (uint64_t)"Unable to address entirety of CFPropertyList";
LABEL_31:
    CFAllocatorDeallocate(a1, v23);
    return 0;
  }
  CFStringRef v11 = 0;
LABEL_22:
  uint64_t v34 = v23;
  uint64_t v35 = (char *)&v23[v17];
  CFAllocatorRef v37 = a1;
  LODWORD(v38) = a5;
  CFTypeRef Mutable = CFSetCreateMutable(a1, 0, &kCFTypeSetCallBacks);
  if (!Mutable)
  {
    qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
    if (!v19) {
      goto LABEL_31;
    }
    goto LABEL_19;
  }
  CFTypeRef cfa = 0;
  if (advanceToNonSpace((uint64_t)&v33))
  {
    __int16 v26 = parsePlistObject((uint64_t)&v33, 1, 0);
    if (!v26)
    {
LABEL_40:
      CFErrorRef Error = (__CFError *)cfa;
      if (!a6)
      {
        if (cfa) {
          CFRelease(cfa);
        }
        unsigned int v24 = 0;
        if (!v19) {
          goto LABEL_36;
        }
        goto LABEL_45;
      }
      if (!cfa)
      {
        uint64_t v32 = lineNumberStrings((unint64_t *)&v33);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unknown error parsing property list around line %d", v32);
      }
      unsigned int v24 = 0;
      *a6 = Error;
      goto LABEL_44;
    }
    unsigned int v24 = v26;
    if (!advanceToNonSpace((uint64_t)&v33)) {
      goto LABEL_34;
    }
    CFTypeID v27 = CFGetTypeID(v24);
    CFTypeID TypeID = CFStringGetTypeID();
    CFRelease(v24);
    if (v27 != TypeID)
    {
      if (cfa) {
        CFRelease(cfa);
      }
      uint64_t v30 = lineNumberStrings((unint64_t *)&v33);
      CFTypeRef cfa = __CFPropertyListCreateError(3840, @"Junk after plist at line %d", v30);
      goto LABEL_40;
    }
    if (cfa)
    {
      CFRelease(cfa);
      CFTypeRef cfa = 0;
    }
    uint64_t v34 = v23;
    BOOL v29 = parsePlistDictContent((uint64_t)&v33, 0);
  }
  else
  {
    BOOL v29 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  unsigned int v24 = v29;
  if (!v29) {
    goto LABEL_40;
  }
LABEL_34:
  if (!a7)
  {
LABEL_44:
    if (!v19) {
      goto LABEL_36;
    }
    goto LABEL_45;
  }
  *a7 = 1;
  if (!v19)
  {
LABEL_36:
    CFAllocatorDeallocate(a1, v23);
    goto LABEL_46;
  }
LABEL_45:
  CFRelease(v11);
LABEL_46:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v24;
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)bytes, numBytes, *(uint64_t *)&encoding, (isExternalRepresentation != 0) | 0x12u, (__objc2_class **)contentsDeallocator, 0);
}

uint64_t advanceToNonSpace(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  unint64_t v1 = *(void *)(a1 + 16);
  if ((unint64_t)v2 >= v1) {
    return 0;
  }
  while (1)
  {
    CFStringRef v3 = v2 + 1;
    int v4 = *v2;
    BOOL v5 = (v4 - 9) >= 5 && (v4 - 8232) >= 2;
    if (!v5 || v4 == 32) {
      goto LABEL_6;
    }
    if (v4 != 47 || (unint64_t)v3 >= v1) {
      break;
    }
    int v6 = *v3;
    if (v6 == 42)
    {
      CFStringRef v3 = v2 + 2;
      if ((unint64_t)(v2 + 2) < v1)
      {
        v2 += 2;
        while (1)
        {
          int v10 = *v2++;
          BOOL v11 = v10 != 42 || (unint64_t)v2 >= v1;
          if (!v11 && *v2 == 47) {
            break;
          }
          CFStringRef v3 = v2;
          if ((unint64_t)v2 >= v1) {
            goto LABEL_7;
          }
        }
        uint64_t v2 = v3 + 2;
        goto LABEL_7;
      }
LABEL_6:
      uint64_t v2 = v3;
      goto LABEL_7;
    }
    if (v6 != 47) {
      break;
    }
    for (v2 += 2; (unint64_t)v2 < v1; ++v2)
    {
      int v7 = *v2;
      BOOL v8 = (v7 - 8232) < 2 || v7 == 10;
      if (v8 || v7 == 13) {
        break;
      }
    }
LABEL_7:
    if ((unint64_t)v2 >= v1)
    {
      uint64_t v12 = 0;
      goto LABEL_36;
    }
  }
  uint64_t v12 = 1;
LABEL_36:
  *(void *)(a1 + 8) = v2;
  return v12;
}

uint64_t lineNumberStrings(unint64_t *a1)
{
  unint64_t v1 = (unsigned __int16 *)*a1;
  unint64_t v2 = a1[2];
  if (*a1 >= v2) {
    return 1;
  }
  unint64_t v3 = a1[1];
  uint64_t result = 1;
  do
  {
    if ((unint64_t)v1 >= v3) {
      break;
    }
    int v5 = *v1;
    if (v5 == 10)
    {
      uint64_t result = (result + 1);
    }
    else if (v5 == 13)
    {
      uint64_t result = (result + 1);
      if ((unint64_t)(v1 + 1) < v2 && (unint64_t)(v1 + 1) < v3 && v1[1] == 10) {
        ++v1;
      }
    }
    ++v1;
  }
  while ((unint64_t)v1 < v2);
  return result;
}

unint64_t *_CFTryRetain(unint64_t *result)
{
  if (result)
  {
    if (((unint64_t)result & 0x8000000000000000) == 0) {
      return _CFRetain(result, 1);
    }
  }
  return result;
}

uint64_t _CFURLFileCacheGetPropertyValueForKey()
{
  return MEMORY[0x1F4114FC0]();
}

uint64_t _NSIsNSCFConstantString(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSCFConstantString__);
}

BOOL _CFPreferencesGetAppBooleanValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, Boolean *a4)
{
  int v5 = (__objc2_class **)_CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0);
  BooleanValueWithCFStringRef Value = _CFPreferencesGetBooleanValueWithValue(v5, a4);
  if (v5) {
    CFRelease(v5);
  }
  return BooleanValueWithValue;
}

BOOL _CFPreferencesGetBooleanValueWithValue(__objc2_class **cf, Boolean *a2)
{
  v9[1] = *(double *)off_1ECE0A5B0;
  if (!cf) {
    goto LABEL_26;
  }
  if (&__kCFBooleanTrue == cf) {
    goto LABEL_11;
  }
  if (&__kCFBooleanFalse == cf)
  {
LABEL_24:
    if (a2)
    {
      BOOL result = 0;
      *a2 = 1;
      return result;
    }
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != 22)
  {
    if (v4 == 7)
    {
      if (CFStringCompare((CFStringRef)cf, @"YES", 1uLL) == kCFCompareEqualTo
        || CFStringCompare((CFStringRef)cf, @"true", 1uLL) == kCFCompareEqualTo)
      {
        goto LABEL_11;
      }
      if (CFStringCompare((CFStringRef)cf, @"NO", 1uLL) == kCFCompareEqualTo
        || CFStringCompare((CFStringRef)cf, @"false", 1uLL) == kCFCompareEqualTo)
      {
        goto LABEL_24;
      }
      if (CFEqual(cf, @"1"))
      {
LABEL_11:
        BOOL result = 1;
        if (a2) {
          *a2 = 1;
        }
        return result;
      }
      if (CFEqual(cf, @"0")) {
        goto LABEL_24;
      }
    }
LABEL_26:
    if (a2)
    {
      BOOL result = 0;
      *a2 = 0;
      return result;
    }
    return 0;
  }
  if (CFNumberIsFloatType((CFNumberRef)cf))
  {
    v9[0] = 0.0;
    Boolean Value = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, v9);
    if (a2) {
      *a2 = Value;
    }
    BOOL v7 = v9[0] == 0.0;
  }
  else
  {
    v9[0] = 0.0;
    Boolean v8 = CFNumberGetValue((CFNumberRef)cf, kCFNumberCFIndexType, v9);
    if (a2) {
      *a2 = v8;
    }
    BOOL v7 = *(void *)&v9[0] == 0;
  }
  return !v7;
}

Boolean CFPreferencesAppValueIsForced(CFStringRef key, CFStringRef applicationID)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    CFTypeID v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    CFTypeID v4 = (os_unfair_lock *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  Boolean v5 = -[_CFXPreferences appValueIsForcedForKey:appIdentifier:](v4, (uint64_t)key, (__CFString *)applicationID);

  return v5;
}

uint64_t _CFPreferencesCopyValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    int v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    int v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v11 = [v10 copyValueForKey:a1 identifier:a2 user:a3 host:a4 container:a5];

  return v11;
}

uint64_t _CFPreferencesCopyAppValueWithContainerAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    Boolean v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    Boolean v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v9 = [v8 copyAppValueForKey:a1 identifier:a2 container:a3 configurationURL:a4];

  return v9;
}

uint64_t _CFPrefsCurrentProcessIsCFPrefsD()
{
  return isCFPrefsD;
}

uint64_t _CFGetEUID()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  unsigned int v1 = 0;
  __CFGetUGIDs(&v1, 0);
  return v1;
}

unint64_t __CFGetUGIDs(_DWORD *a1, _DWORD *a2)
{
  void v6[5] = *(void *)off_1ECE0A5B0;
  if (_CFCanChangeEUIDs_onceToken != -1) {
    dispatch_once(&_CFCanChangeEUIDs_onceToken, &__block_literal_global_121_0);
  }
  if (_CFCanChangeEUIDs_canChangeEUIDs)
  {
    unint64_t result = ____CFGetUGIDs_block_invoke();
    unint64_t v5 = HIDWORD(result);
    if (!a1) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  v6[0] = off_1ECE0A5A0;
  v6[1] = 0x40000000;
  v6[2] = ____CFGetUGIDs_block_invoke_2;
  v6[3] = &unk_1ECDFDCE8;
  v6[4] = &__block_literal_global_82;
  if (__CFGetUGIDs_onceToken != -1) {
    dispatch_once(&__CFGetUGIDs_onceToken, v6);
  }
  unint64_t result = __CFGetUGIDs_cachedUGIDs;
  LODWORD(v5) = HIDWORD(__CFGetUGIDs_cachedUGIDs);
  if (a1) {
LABEL_5:
  }
    *a1 = result;
LABEL_6:
  if (a2) {
    *a2 = v5;
  }
  return result;
}

void sub_182BECC94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void normalizeQuintuplet(__CFString *theString, __CFString *a2, unsigned __int8 a3, CFStringRef a4, uint64_t a5, uint64_t a6)
{
  CFStringRef v8 = a4;
  int v10 = theString;
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  unsigned __int8 v20 = a3;
  CFTypeRef v18 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v17 = 0;
  if (a4)
  {
    if (CFStringHasPrefix(a4, @"/private/var/containers/Shared/SystemGroup")
      || CFStringHasPrefix(v8, @"/var/containers/Shared/SystemGroup"))
    {
      a2 = @"kCFPreferencesAnyUser";
      unsigned __int8 v20 = 1;
    }
LABEL_8:
    if (CFStringHasSuffix(v10, @".plist"))
    {
      v22.CFIndex length = CFStringGetLength(v10) - 6;
      v22.CFIndex location = 0;
      uint64_t v11 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, v22);
      CFTypeRef cf = v11;
    }
    else
    {
      uint64_t v11 = (__CFString *)cf;
    }
    goto LABEL_11;
  }
  if (CFStringGetCharacterAtIndex(theString, 0) != 47) {
    goto LABEL_8;
  }
  if (a5) {
    normalizeQuintuplet_cold_1();
  }
  __int16 v16 = 0;
  _CFPrefsExtractQuadrupleFromPathIfPossible(v10, (CFStringRef *)&cf, (CFStringRef *)&v18, &v17, &v20, (unsigned char *)&v16 + 1, &v16);
  uint64_t v11 = (__CFString *)cf;
  if (!cf) {
    goto LABEL_8;
  }
LABEL_11:
  if (v17) {
    CFStringRef v8 = (const __CFString *)v17;
  }
  if (v11) {
    int v10 = v11;
  }
  if (v18) {
    CFStringRef v12 = (const __CFString *)v18;
  }
  else {
    CFStringRef v12 = a2;
  }
  CFStringRef v13 = _CFPrefsCopyUserForContainer(v12, v8);
  if (CFEqual(@"kCFPreferencesAnyUser", v13)) {
    BOOL v14 = v20 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    unsigned __int8 v20 = 1;
  }
  uint64_t CacheStringForBundleID = _CFPrefsGetCacheStringForBundleID(v10);
  (*(void (**)(uint64_t, uint64_t, CFStringRef, void, const __CFString *, uint64_t))(a6 + 16))(a6, CacheStringForBundleID, v13, v20, v8, a5);
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v13) {
    CFRelease(v13);
  }
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  v4.CFIndex length = CFStringGetLength(theString);
  v4.CFIndex location = 0;

  return CFStringFindWithOptionsAndLocale(theString, suffix, v4, 0xCuLL, 0, 0);
}

CFStringRef _CFPrefsCopyUserForContainer(const __CFString *cf1, CFStringRef theString)
{
  if (theString && CFStringHasPrefix(theString, @"/private/var/containers/Shared/SystemGroup/")) {
    return @"kCFPreferencesAnyUser";
  }
  if (CFEqual(cf1, @"kCFPreferencesCurrentUser")) {
    return @"kCFPreferencesCurrentUser";
  }
  unint64_t v3 = @"kCFPreferencesAnyUser";
  if (CFEqual(cf1, @"kCFPreferencesAnyUser")) {
    return v3;
  }
  CFStringRef v4 = CFCopyUserName();
  int v5 = CFEqual(cf1, v4);
  CFRelease(v4);
  BOOL v6 = !@"kCFPreferencesCurrentUser" || v5 == 0;
  unint64_t v3 = @"kCFPreferencesCurrentUser";
  if (!v6) {
    return v3;
  }

  return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf1);
}

void sub_182BED218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182BED4CC(_Unwind_Exception *a1)
{
}

BOOL eduModeEnabled()
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  if (eduModeOverride) {
    return 1;
  }
  uint32_t multiuser_mode = 0;
  if (host_check_multiuser_mode(0, &multiuser_mode)) {
    BOOL v1 = 1;
  }
  else {
    BOOL v1 = multiuser_mode == 0;
  }
  return !v1;
}

CFStringRef CFCopyUserName()
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uid_t v4 = 0;
  __CFGetUGIDs(&v4, 0);
  uid_t v0 = v4;
  if (!v4) {
    uid_t v0 = getuid();
  }
  BOOL v1 = getpwuid(v0);
  if (!v1 || (pw_name = v1->pw_name) == 0)
  {
    pw_name = __CFgetenv("USER");
    if (!pw_name) {
      return (CFStringRef)CFRetain(&stru_1ECE10768);
    }
  }
  CFStringRef result = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_name, 0x8000100u);
  if (!result) {
    return (CFStringRef)CFRetain(&stru_1ECE10768);
  }
  return result;
}

void sub_182BED7A8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 88), 8);
  _Unwind_Resume(a1);
}

void sub_182BED950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182BED99C(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x182BED994);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  va_start(va, format);
  return CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, va);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  if (!CF_IS_OBJC(7uLL, (unint64_t)format)
    || !_CFStringObjCFormatRequiresInflection((void *)format))
  {
    return (CFStringRef)_CFStringCreateWithFormatAndArgumentsReturningMetadata(alloc, 0, 0, formatOptions, 0, 0, format, 0, arguments);
  }

  return (CFStringRef)_CFStringCreateFormatWithInflectionAndArguments((uint64_t)alloc, (uint64_t)formatOptions, (uint64_t)format, (uint64_t)arguments);
}

CFTypeRef _copyValueForKey(uint64_t a1, void *key)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  if (byte_1EC090E01) {
    objc_msgSend((id)a1, "alreadylocked_clearCache");
  }
  *(void *)CFTypeRef v18 = off_1ECE0A5A0;
  *(void *)&v18[8] = 3221225472;
  *(void *)&v18[16] = __alreadylocked_requestNewDataIfStale_block_invoke;
  CFStringRef v19 = &unk_1ECDB0298;
  uint64_t v20 = a1;
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 105));
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = (unsigned int *)atomic_load((unint64_t *)(a1 + 40));
    if (!v5
      || (v6 = atomic_load(v5), unsigned int v7 = atomic_load((unsigned int *)&sentinelGeneration), v6 != v7)
      && (unsigned int v8 = atomic_load((unsigned int *)(a1 + 48)), v6 != v8))
    {
      os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 52));
      (*(void (**)(unsigned char *))&v18[16])(v18);
    }
  }
  if (atomic_load((unint64_t *)(a1 + 88)))
  {
    os_unfair_lock_lock(&locallySetDictLock);
    CFDictionaryRef v10 = (const __CFDictionary *)atomic_load((unint64_t *)(a1 + 88));
    Boolean Value = (__CFString *)CFDictionaryGetValue(v10, key);
    os_unfair_lock_unlock(&locallySetDictLock);
    if (Value == @"MagicRemovedValue") {
      goto LABEL_13;
    }
    if (Value) {
      goto LABEL_14;
    }
  }
  CFDictionaryRef v12 = *(const __CFDictionary **)(a1 + 16);
  if (v12)
  {
    Boolean Value = (__CFString *)CFDictionaryGetValue(v12, key);
    goto LABEL_14;
  }
LABEL_13:
  Boolean Value = 0;
LABEL_14:
  CFStringRef v13 = _CFPrefsClientLog();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    BOOL v14 = objc_msgSend((id)a1, "copyOSLogDescription", *(void *)v18, *(void *)&v18[8]);
    if (Value)
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
      uint64_t v15 = _CFPrefsClientLog();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)CFTypeRef v18 = 138478339;
        *(void *)&v18[4] = Value;
        *(_WORD *)&v18[12] = 2114;
        *(void *)&v18[14] = key;
        *(_WORD *)&v18[22] = 2114;
        CFStringRef v19 = v14;
        _os_log_debug_impl(&dword_182B90000, v15, OS_LOG_TYPE_DEBUG, "looked up value %{private}@ for key %{public}@ in %{public}@", v18, 0x20u);
      }
    }
    else
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
      __int16 v16 = _CFPrefsClientLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        _copyValueForKey_cold_1();
      }
    }
    _CFSetTSD(0xFu, 0, 0);
    CFRelease(v14);
  }
  if (Value) {
    return CFRetain(Value);
  }
  else {
    return 0;
  }
}

void sub_182BEE118(_Unwind_Exception *a1)
{
}

uint64_t _CFPrefsClientLog()
{
  if (makeLogHandles_logToken != -1) {
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_167);
  }
  return clientHandle;
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppBooleanValueWithContainer((uint64_t)key, (uint64_t)applicationID, 0, keyExistsAndHasValidFormat);
}

__CFString *_CFStringCopyBundleUnloadingProtectedString(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0) {
    return (__CFString *)a1;
  }
  uint64_t CStringPtrInternal = (const char *)_CFStringGetCStringPtrInternal(a1, 0x8000100u, 1, 1);
  if (CStringPtrInternal
    && (unsigned __int8 v4 = (int8x16_t *)CStringPtrInternal, strlen(CStringPtrInternal), _dyld_is_memory_immutable()))
  {
    unint64_t v5 = *a1 & ~(unint64_t)off_1ECE0A6D0;
    if ((*a1 & (unint64_t)off_1ECE0A6D0) != 0) {
      v5 |= *a1 & (unint64_t)off_1ECE0A6D0;
    }
    if ((__objc2_class *)v5 == __CFConstantStringClassReferencePtr) {
      return (__CFString *)a1;
    }
    size_t v6 = strlen(v4->i8);
    return (__CFString *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v4, v6, 134217984, 0x18u, &__kCFAllocatorNull, 0);
  }
  else
  {
    return _CFStringSlowPathCopyBundleUnloadingProtectedString((__CFString *)a1);
  }
}

uint64_t __alreadylocked_requestNewDataIfStale_block_invoke(uint64_t a1)
{
  return -[CFPrefsPlistSource alreadylocked_requestNewData](*(void *)(a1 + 32));
}

void sub_182BEEAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unint64_t _CFLogvEx3(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  if (os_log_shim_enabled())
  {
    unint64_t result = _CFGetTSD(2u);
    if (result <= 3)
    {
      uint64_t v15 = result;
      _CFSetTSD(2u, result + 1, 0);
      if (a5 <= 7) {
        os_log_shim_with_CFString();
      }
      _CFSetTSD(2u, v15, 0);
      unint64_t result = also_do_stderr(0);
      if (result) {
        return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 0);
      }
    }
  }
  else
  {
    return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 1);
  }
  return result;
}

BOOL also_do_stderr(int a1)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    if (issetugid() || !getenv("CFLOG_FORCE_STDERR"))
    {
      memset(&v6, 0, sizeof(v6));
      if (fstat(2, &v6) < 0) {
        return 0;
      }
      if ((v6.st_mode & 0xB000) != 0x8000)
      {
        int v1 = v6.st_mode & 0xF000;
        if (v1 != 4096 && v1 != 0x2000) {
          return 0;
        }
      }
    }
    return 1;
  }
  memset(&v6, 0, 64);
  pid_t v2 = getpid();
  if (proc_pidinfo(v2, 13, 0, &v6, 64) == 64 && (v6.st_atimespec.tv_sec & 2) != 0
    || getenv("OS_ACTIVITY_DT_MODE")
    || getenv("CFLOG_FORCE_DISABLE_STDERR"))
  {
    return 0;
  }
  if (!__CFProcessIsRestricted() && getenv("CFLOG_FORCE_STDERR")) {
    return 1;
  }
  memset(&v6, 0, sizeof(v6));
  int v4 = fstat(2, &v6);
  if ((v4 & 0x80000000) == 0)
  {
    unsigned int v5 = v6.st_mode & 0xF000;
    if (v5 >= 0x8000)
    {
      if (v5 != 49152 && v5 != 0x8000) {
        return 0;
      }
    }
    else if (v5 != 4096 && v5 != 0x2000)
    {
      return 0;
    }
  }
  return v4 >= 0;
}

uint64_t __CFProcessIsRestricted()
{
  return issetugid();
}

unint64_t _CFLogvEx2Predicate(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7, int a8)
{
  unint64_t result = _CFGetTSD(2u);
  if (result <= 3)
  {
    uint64_t v17 = result;
    _CFSetTSD(2u, result + 1, 0);
    if (a6)
    {
      CFStringRef v18 = _CFStringCreateWithFormatAndArgumentsAux2((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, a3, a4, 0, a6, a7);
      if (v18)
      {
        CFStringRef v19 = v18;
        CFIndex Length = CFStringGetLength(v18);
        CFIndex v21 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
        CFRange v22 = (char *)malloc_type_malloc(v21, 0x10BF2CF2uLL);
        if (v22)
        {
          int v23 = v22;
          int CString = CFStringGetCString(v19, v22, v21, 0x8000100u);
          size_t v25 = strlen(v23);
          if (a5 <= 7)
          {
            BOOL v26 = !CString || v25 == 0;
            if (!v26 && v25 <= 0x1000000)
            {
              if (a1)
              {
                a1(a5, v23, v25, 1);
              }
              else if (a8)
              {
                __CFLogCStringLegacy(a5, v23, v25, 1);
              }
              else
              {
                __CFLogCString((uint64_t)v23, v25);
              }
            }
          }
          free(v23);
        }
        CFRelease(v19);
      }
    }
    return _CFSetTSD(2u, v17, 0);
  }
  return result;
}

CFStringRef _CFStringCreateWithFormatAndArgumentsAux2(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  return _CFStringCreateWithFormatAndArgumentsReturningMetadata(a1, a2, a3, a4, 0, a5, a6, 0, a7);
}

void __CFLogCString(uint64_t a1, uint64_t a2)
{
  __s[1] = *(char **)off_1ECE0A5B0;
  unsigned int v5 = 0;
  __s[0] = 0;
  int v4 = 0;
  _populateBanner(__s, (char **)&v5, (char **)&v4);
  _logToStderr(__s[0], a1, a2);
  if (v4) {
    free(v4);
  }
  if (v5) {
    free(v5);
  }
  if (__s[0]) {
    free(__s[0]);
  }
}

uint64_t _populateBanner(char **a1, char **a2, char **a3)
{
  __y[1] = *(long double *)off_1ECE0A5B0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  time_t v25 = vcvtmd_s64_f64(Current + 978307200.0);
  memset(&v24, 0, sizeof(v24));
  localtime_r(&v25, &v24);
  tm_mouint64_t n = v24.tm_mon;
  int tm_year = v24.tm_year;
  int tm_hour = v24.tm_hour;
  int tm_mday = v24.tm_mday;
  int tm_sec = v24.tm_sec;
  tm_miuint64_t n = v24.tm_min;
  double v12 = modf(Current, __y);
  __uint64_t v23 = 0;
  if (pthread_threadid_np(0, &v23))
  {
    CFStringRef v13 = pthread_self();
    __uint64_t v23 = pthread_mach_thread_np(v13);
  }
  unsigned int v14 = vcvtmd_s64_f64(v12 * 1000.0);
  int v15 = tm_mon + 1;
  int v16 = tm_year + 1900;
  uint64_t v17 = (const char *)*_CFGetProgname();
  pid_t v18 = getpid();
  asprintf(a1, "%04d-%02d-%02d %02d:%02d:%02d.%03d %s[%d:%llu] ", v16, v15, tm_mday, tm_hour, tm_min, tm_sec, v14, v17, v18, v23);
  CFStringRef v19 = pthread_self();
  mach_port_t v20 = pthread_mach_thread_np(v19);
  asprintf(a3, "%x", v20);
  return asprintf(a2, "%04d-%02d-%02d %02d:%02d:%02d.%03d", v16, v15, tm_mday, tm_hour, tm_min, tm_sec, v14);
}

uint64_t *_CFGetProgname()
{
  if (!__CFprogname) {
    _CFProcessPath();
  }
  return &__CFprogname;
}

void _logToStderr(char *__s, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = __s;
  v10[6] = *(void *)off_1ECE0A5B0;
  v10[0] = __s;
  if (__s)
  {
    __s = (char *)strlen(__s);
    int v6 = 2;
  }
  else
  {
    int v6 = 1;
  }
  BOOL v7 = v5 == 0;
  v10[1] = __s;
  _OWORD v10[2] = a2;
  _OWORD v10[3] = a3;
  v10[4] = "\n";
  int v8 = *(unsigned __int8 *)(a3 + a2 - 1);
  v10[5] = v8 != 10;
  if (v8 == 10) {
    int v9 = v6;
  }
  else {
    int v9 = v6 + 1;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&_logToStderr_lock);
  writev(2, (const iovec *)&v10[2 * v7], v9);
  os_unfair_lock_unlock((os_unfair_lock_t)&_logToStderr_lock);
}

void sub_182BEFFB8(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_USER_CFPREFSD(const os_unfair_lock *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

void sub_182BF013C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_SYSTEM_CFPREFSD(const os_unfair_lock *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

BOOL _CFStringObjCFormatRequiresInflection(void *a1)
{
  Class Class = object_getClass(a1);
  if (__NSGetCFLocalizedAttributedStringClass_onceToken != -1) {
    dispatch_once(&__NSGetCFLocalizedAttributedStringClass_onceToken, &__block_literal_global_140);
  }
  return Class == (Class)__NSCFLocalizedAttributedStringClass;
}

Boolean CFCalendarGetComponentDifference(CFCalendarRef calendar, CFAbsoluteTime startingAT, CFAbsoluteTime resultAT, CFOptionFlags options, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t vars0 = va_arg(va, void);
  uint64_t v5 = vars0;
  uint64_t vars8 = va_arg(va, unsigned char *);
  uint64_t v6 = 0;
  va_copy(v23, va);
  for (CFIndex i = vars8; ; ++i)
  {
    unsigned int v8 = *i;
    if (v8 <= 0x63) {
      break;
    }
    uint64_t v9 = v6 | 0x80;
    uint64_t v10 = v6 | 0x2100;
    uint64_t v11 = v6 | 4;
    if (v8 != 121) {
      uint64_t v11 = v6;
    }
    if (v8 != 119) {
      uint64_t v10 = v11;
    }
    if (v8 != 115) {
      uint64_t v9 = v10;
    }
    uint64_t v12 = v6 | 0x10;
    uint64_t v13 = v6 | 8;
    uint64_t v14 = v6 | 0x40;
    if (v8 != 109) {
      uint64_t v14 = v6;
    }
    if (v8 != 108) {
      uint64_t v13 = v14;
    }
    if (v8 != 100) {
      uint64_t v12 = v13;
    }
    if (*i <= 0x72u) {
      uint64_t v6 = v12;
    }
    else {
      uint64_t v6 = v9;
    }
LABEL_20:
    ;
  }
  switch(*i)
  {
    case 'D':
      v6 |= 0x10000uLL;
      goto LABEL_20;
    case 'E':
      v6 |= 0x200uLL;
      goto LABEL_20;
    case 'F':
      v6 |= 0x400uLL;
      goto LABEL_20;
    case 'G':
      v6 |= 2uLL;
      goto LABEL_20;
    case 'H':
      v6 |= 0x20uLL;
      goto LABEL_20;
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'X':
      goto LABEL_20;
    case 'M':
      v6 |= 8uLL;
      goto LABEL_20;
    case 'Q':
      v6 |= 0x800uLL;
      goto LABEL_20;
    case 'W':
      v6 |= 0x1000uLL;
      goto LABEL_20;
    case 'Y':
      v6 |= 0x4000uLL;
      goto LABEL_20;
    default:
      if (v8 == 35)
      {
        v6 |= 0x8000uLL;
        goto LABEL_20;
      }
      if (*i) {
        goto LABEL_20;
      }
      uint64_t v15 = [(__CFCalendar *)calendar components:v6 fromDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", startingAT) toDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:resultAT] options:v5];
      if (!v15) {
        return v15;
      }
      int v16 = *vars8;
      if (*vars8)
      {
        uint64_t v17 = (void *)v15;
        pid_t v18 = vars8 + 1;
        do
        {
          CFStringRef v19 = va_arg(v23, _DWORD *);
          if (v16 <= 99)
          {
            switch(v16)
            {
              case 'D':
                int v20 = [v17 dayOfYear];
                goto LABEL_62;
              case 'E':
                int v20 = [v17 weekday];
                goto LABEL_62;
              case 'F':
                int v20 = [v17 weekdayOrdinal];
                goto LABEL_62;
              case 'G':
                int v20 = [v17 era];
                goto LABEL_62;
              case 'H':
                int v20 = [v17 hour];
                goto LABEL_62;
              case 'I':
              case 'J':
              case 'K':
              case 'L':
              case 'N':
              case 'O':
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'U':
              case 'V':
              case 'X':
                goto LABEL_63;
              case 'M':
                int v20 = [v17 month];
                goto LABEL_62;
              case 'Q':
                int v20 = [v17 quarter];
                goto LABEL_62;
              case 'W':
                int v20 = [v17 weekOfMonth];
                goto LABEL_62;
              case 'Y':
                int v20 = [v17 yearForWeekOfYear];
                goto LABEL_62;
              default:
                if (v16 != 35) {
                  goto LABEL_63;
                }
                int v20 = [v17 nanosecond];
                break;
            }
            goto LABEL_62;
          }
          if (v16 > 114)
          {
            switch(v16)
            {
              case 's':
                int v20 = [v17 second];
                goto LABEL_62;
              case 'w':
                _DWORD *v19 = [v17 weekOfYear];
                if ([v17 weekOfYear] == 0x7FFFFFFFFFFFFFFFLL)
                {
                  int v20 = [v17 week];
                  goto LABEL_62;
                }
                break;
              case 'y':
                int v20 = [v17 year];
                goto LABEL_62;
            }
          }
          else
          {
            switch(v16)
            {
              case 'd':
                int v20 = [v17 day];
                goto LABEL_62;
              case 'l':
                int v20 = [v17 isLeapMonth];
                goto LABEL_62;
              case 'm':
                int v20 = [v17 minute];
LABEL_62:
                _DWORD *v19 = v20;
                break;
            }
          }
LABEL_63:
          int v21 = *v18++;
          int v16 = v21;
        }
        while (v21);
      }
      LOBYTE(v15) = 1;
      return v15;
  }
}

uint64_t parseDateTag(uint64_t a1, CFDateRef *a2)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v3 < v4 && *v3 == 45)
  {
    int v5 = 0;
    *(void *)(a1 + 8) = ++v3;
  }
  else
  {
    int v5 = 1;
  }
  if ((unint64_t)v3 >= v4) {
    goto LABEL_38;
  }
  uint64_t v6 = 0;
  int v7 = 0;
  while (1)
  {
    int v8 = (char)v3[v6];
    if ((v8 - 48) > 9) {
      break;
    }
    int v7 = v8 + 10 * v7 - 48;
    *(void *)(a1 + 8) = &v3[++v6];
    if (v4 - (void)v3 == v6) {
      goto LABEL_38;
    }
  }
  if (v8 != 45) {
    goto LABEL_38;
  }
  uint64_t v9 = &v3[v6 + 1];
  *(void *)(a1 + 8) = v9;
  uint64_t v10 = &v3[v6 + 3];
  if ((unint64_t)v10 >= v4) {
    goto LABEL_38;
  }
  int v11 = *v9;
  int v12 = (char)v3[v6 + 2];
  *(void *)(a1 + 8) = v10;
  if ((v11 - 48) > 9) {
    goto LABEL_38;
  }
  if ((v12 - 48) > 9) {
    goto LABEL_38;
  }
  if (*v10 != 45) {
    goto LABEL_38;
  }
  uint64_t v13 = &v3[v6 + 4];
  *(void *)(a1 + 8) = v13;
  uint64_t v14 = &v3[v6 + 6];
  if ((unint64_t)v14 >= v4) {
    goto LABEL_38;
  }
  int v15 = *v13;
  int v16 = (char)v3[v6 + 5];
  *(void *)(a1 + 8) = v14;
  if ((v15 - 48) > 9) {
    goto LABEL_38;
  }
  if ((v16 - 48) > 9) {
    goto LABEL_38;
  }
  if (*v14 != 84) {
    goto LABEL_38;
  }
  uint64_t v17 = &v3[v6 + 7];
  *(void *)(a1 + 8) = v17;
  pid_t v18 = &v3[v6 + 9];
  if ((unint64_t)v18 >= v4) {
    goto LABEL_38;
  }
  int v19 = *v17;
  int v20 = (char)v3[v6 + 8];
  *(void *)(a1 + 8) = v18;
  if ((v19 - 48) > 9) {
    goto LABEL_38;
  }
  if ((v20 - 48) > 9) {
    goto LABEL_38;
  }
  if (*v18 != 58) {
    goto LABEL_38;
  }
  int v21 = &v3[v6 + 10];
  *(void *)(a1 + 8) = v21;
  CFRange v22 = &v3[v6 + 12];
  if ((unint64_t)v22 >= v4) {
    goto LABEL_38;
  }
  int v23 = *v21;
  int v24 = (char)v3[v6 + 11];
  *(void *)(a1 + 8) = v22;
  if ((v23 - 48) > 9) {
    goto LABEL_38;
  }
  if ((v24 - 48) > 9) {
    goto LABEL_38;
  }
  if (*v22 != 58) {
    goto LABEL_38;
  }
  time_t v25 = &v3[v6 + 13];
  *(void *)(a1 + 8) = v25;
  BOOL v26 = &v3[v6 + 15];
  if ((unint64_t)v26 >= v4) {
    goto LABEL_38;
  }
  int v27 = *v25;
  int v28 = (char)v3[v6 + 14];
  *(void *)(a1 + 8) = v26;
  if ((v27 - 48) > 9) {
    goto LABEL_38;
  }
  if ((v28 - 48) > 9) {
    goto LABEL_38;
  }
  if (*v26 != 90) {
    goto LABEL_38;
  }
  *(void *)(a1 + 8) = &v3[v6 + 16];
  unsigned int v42 = v7;
  int v43 = v5;
  int v37 = v15;
  int v38 = v11;
  int v40 = v16;
  int v41 = v12;
  int v36 = v19;
  int v39 = v20;
  if (checkForCloseTag((unint64_t *)a1, (const UInt8 *)"date", 4uLL))
  {
    if (v43) {
      uint64_t v29 = v42;
    }
    else {
      uint64_t v29 = -v42;
    }
    *(void *)&v44.year = v29 | ((unint64_t)(v41 + 10 * v38 - 528) << 32) | ((unint64_t)(v40 + 10 * v37 - 528) << 40) | ((unint64_t)(v39 + 10 * v36 - 528) << 48) | ((unint64_t)(v24 + 10 * v23 - 528) << 56);
    v44.second = (double)(v28 + 10 * v27 - 528);
    double AbsoluteTime = CFGregorianDateGetAbsoluteTime(v44, 0);
    CFDateRef v31 = 0;
    if (!*(unsigned char *)(a1 + 80)) {
      CFDateRef v31 = CFDateCreate(*(CFAllocatorRef *)(a1 + 32), AbsoluteTime);
    }
    *a2 = v31;
    return 1;
  }
  else
  {
LABEL_38:
    uint64_t v33 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Could not interpret <date> at line %u", v33);
    uint64_t result = 0;
    *(void *)(a1 + 24) = Error;
  }
  return result;
}

BOOL CFDateComponentsIsValidDateInCalendar(void *a1, void *a2)
{
  if (!a1) {
    CFDateComponentsIsValidDateInCalendar_cold_1();
  }
  if (!a2) {
    CFDateComponentsIsValidDateInCalendar_cold_2();
  }
  unint64_t v3 = a1[19];
  if (v3 == 0x7FFFFFFFFFFFFFFFLL || v3 <= 0x3B9AC9FF)
  {
    CFArrayRef Copy = (void *)_CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, a2);
    if (v3 - 1 >= 0x7FFFFFFFFFFFFFFELL)
    {
      id DateFromComponents = CFCalendarCreateDateFromComponents((uint64_t)&__kCFAllocatorSystemDefault, Copy, (uint64_t)a1);
      if (DateFromComponents) {
        goto LABEL_9;
      }
    }
    else
    {
      a1[19] = 0;
      id DateFromComponents = CFCalendarCreateDateFromComponents((uint64_t)&__kCFAllocatorSystemDefault, Copy, (uint64_t)a1);
      a1[19] = v3;
      if (DateFromComponents)
      {
LABEL_9:
        DateComponentsFromDate = CFCalendarCreateDateComponentsFromDate((uint64_t)&__kCFAllocatorSystemDefault, Copy);
        int v8 = DateComponentsFromDate;
        uint64_t v9 = a1[4];
        if (v9 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[4] != v9) {
          goto LABEL_40;
        }
        uint64_t v10 = a1[5];
        if (v10 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[5] != v10) {
          goto LABEL_40;
        }
        uint64_t v11 = a1[6];
        if (v11 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[6] != v11) {
          goto LABEL_40;
        }
        uint64_t v12 = a1[7];
        if (v12 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[7] != v12) {
          goto LABEL_40;
        }
        uint64_t v13 = a1[8];
        if (v13 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[8] != v13) {
          goto LABEL_40;
        }
        uint64_t v14 = a1[9];
        if (v14 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[9] != v14) {
          goto LABEL_40;
        }
        uint64_t v15 = a1[10];
        if (v15 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[10] != v15) {
          goto LABEL_40;
        }
        if (((uint64_t v16 = a1[11], v16 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[11] == v16)
          && ((uint64_t v17 = a1[13], v17 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[13] == v17)
          && ((uint64_t v18 = a1[14], v18 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[14] == v18)
          && ((uint64_t v19 = a1[15], v19 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[15] == v19)
          && ((uint64_t v20 = a1[16], v20 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[16] == v20)
          && ((uint64_t v21 = a1[17], v21 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[17] == v21)
          && ((uint64_t v22 = a1[20], v22 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[20] == v22))
        {
          uint64_t v23 = a1[18];
          BOOL v24 = v23 == 0x7FFFFFFFFFFFFFFFLL || DateComponentsFromDate[18] == v23;
        }
        else
        {
LABEL_40:
          BOOL v24 = 0;
        }
        CFRelease(DateFromComponents);
        CFRelease(v8);
        goto LABEL_44;
      }
    }
    BOOL v24 = 1;
LABEL_44:
    CFRelease(Copy);
    return v24;
  }
  return 0;
}

id CFCalendarCreateDateFromComponents(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = [[NSDateComponents alloc] _initWithCFDateComponents:a3];
  id v5 = (id)[a2 dateFromComponents:v4];

  return v5;
}

CFTypeRef CFCalendarCreateDateComponentsFromDate(uint64_t a1, void *a2)
{
  pid_t v2 = (const void *)objc_msgSend((id)objc_msgSend(a2, "components:fromDate:"), "_dateComponents");

  return CFRetain(v2);
}

CFAbsoluteTime CFAbsoluteTimeAddGregorianUnits(CFAbsoluteTime at, CFTimeZoneRef tz, CFGregorianUnits *units)
{
  CFGregorianDate GregorianDate = CFAbsoluteTimeGetGregorianDate(at, tz);
  unsigned int v7 = units->years + GregorianDate.year;
  int v8 = units->months + ((int)(*(void *)&GregorianDate.year >> 8) >> 24);
  if (v8 >= 13)
  {
    if (v8 >= 24) {
      int v9 = 24;
    }
    else {
      int v9 = units->months + ((int)(*(void *)&GregorianDate.year >> 8) >> 24);
    }
    unsigned int v10 = (v8 - v9 + 11) / 0xCu;
    int v8 = v8 - 12 * v10 - 12;
    v7 += v10 + 1;
  }
  int v11 = (int)(*(void *)&GregorianDate.year >> 16) >> 24;
  if (v8 <= 0)
  {
    if (v8 <= -11) {
      int v12 = -11;
    }
    else {
      int v12 = v8;
    }
    if (v8 >= -11) {
      int v13 = v8;
    }
    else {
      int v13 = v8 + 1;
    }
    unsigned int v14 = (v12 - v13) / 0xCu;
    if (v8 < -11) {
      ++v14;
    }
    v8 += 12 * v14 + 12;
    v7 += ~v14;
  }
  int v15 = (int)(v7 - 2000) % 400;
  if (v15 < 0) {
    int v15 = -v15;
  }
  BOOL v16 = v15 != 300;
  if (v15 == 200) {
    BOOL v16 = 0;
  }
  if (v15 == 100) {
    BOOL v16 = 0;
  }
  if ((v15 & 3) != 0) {
    BOOL v16 = 0;
  }
  char v17 = daysInMonth[v8];
  if (v8 != 2) {
    BOOL v16 = 0;
  }
  unsigned __int8 v18 = v17 + v16;
  int v19 = (v17 + v16);
  if (v11 >= v18) {
    int v11 = v19;
  }
  int v20 = v11 + units->days;
  while (v20 > v18)
  {
    if (v8 <= 11)
    {
      ++v8;
    }
    else
    {
      ++v7;
      int v8 = 1;
    }
    int v21 = (int)(v7 - 2000) % 400;
    if (v21 < 0) {
      int v21 = -v21;
    }
    BOOL v22 = v21 != 300;
    if (v21 == 200) {
      BOOL v22 = 0;
    }
    if (v21 == 100) {
      BOOL v22 = 0;
    }
    BOOL v23 = (v21 & 3) == 0 && v22;
    if (v8 >= 0x10u) {
      goto LABEL_66;
    }
    char v24 = daysInMonth[v8];
    v20 -= v19;
    BOOL v25 = v8 == 2 && v23;
    unsigned __int8 v18 = v24 + v25;
    int v19 = (v24 + v25);
  }
  if (v20 <= 0)
  {
    while (1)
    {
      int v27 = v8 < 2;
      if (v8 >= 2) {
        --v8;
      }
      else {
        int v8 = 12;
      }
      v7 -= v27;
      int v28 = (int)(v7 - 2000) % 400;
      if (v28 < 0) {
        int v28 = -v28;
      }
      BOOL v29 = v28 != 300;
      if (v28 == 200) {
        BOOL v29 = 0;
      }
      if (v28 == 100) {
        BOOL v29 = 0;
      }
      if ((v28 & 3) != 0) {
        BOOL v29 = 0;
      }
      if (v8 >= 0x10u) {
        break;
      }
      uint64_t v26 = v8;
      BOOL v30 = v8 == 2 && v29;
      v20 += (daysInMonth[v8] + v30);
      if (v20 >= 1) {
        goto LABEL_65;
      }
    }
LABEL_66:
    __break(1u);
    return result;
  }
  uint64_t v26 = v8;
LABEL_65:
  *(void *)&GregorianDate.year = *(void *)&GregorianDate.year & 0xFFFF000000000000 | ((unint64_t)v20 << 40) | (v26 << 32) | v7;
  return units->seconds
       + CFGregorianDateGetAbsoluteTime(GregorianDate, tz)
       + (double)units->hours * 3600.0
       + (double)units->minutes * 60.0;
}

CFAbsoluteTime CFGregorianDateGetAbsoluteTime(CFGregorianDate gdate, CFTimeZoneRef tz)
{
  unint64_t v3 = *(void *)&gdate.year;
  double second = gdate.second;
  double v5 = __CFAbsoluteFromYMD(gdate.year - 2001, (int)(v3 >> 8) >> 24, (int)(v3 >> 16) >> 24) * 86400.0;
  double v6 = (double)((uint64_t)v3 >> 56) * 60.0 + (double)((int)(v3 >> 24) >> 24) * 3600.0 + second;
  double v7 = v6 + v5;
  if (tz)
  {
    CFTimeInterval SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, v6 + v5);
    return v7 - CFTimeZoneGetSecondsFromGMT(tz, v7 - SecondsFromGMT);
  }
  return v7;
}

double __CFAbsoluteFromYMD(uint64_t a1, unsigned int a2, int a3)
{
  double v3 = (double)(a1 / 400) * 146097.0 + 0.0;
  uint64_t v4 = a1 % 400;
  if (a1 % 400 < 0)
  {
    unint64_t v9 = ~a1 + 400 * (a1 / 400);
    uint64_t v10 = a1 % 400;
    do
    {
      unint64_t v11 = v9 % 0x190;
      if (((v9 % 0x190) & 3) != 0 || v11 == 100 || v11 == 300 || (double v12 = 366.0, v11 == 200)) {
        double v12 = 365.0;
      }
      double v3 = v3 - v12;
      --v9;
      ++v10;
    }
    while (v10);
  }
  else if (v4)
  {
    unint64_t v5 = 1;
    uint64_t v6 = a1 % 400;
    do
    {
      unint64_t v7 = v5 % 0x190;
      if (((v5 % 0x190) & 3) != 0 || v7 == 100 || v7 == 300 || (double v8 = 366.0, v7 == 200)) {
        double v8 = 365.0;
      }
      double v3 = v3 + v8;
      ++v5;
      --v6;
    }
    while (v6);
  }
  uint64_t v13 = (v4 + 1) % 400;
  if (v13 >= 0) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = -v13;
  }
  if ((v14 & 3) != 0)
  {
    __int16 v15 = 0;
  }
  else
  {
    __int16 v15 = 0;
    if (v14 != 100 && v14 != 200) {
      __int16 v15 = v14 != 300;
    }
  }
  if (a2 <= 0xF)
  {
    if (a2 <= 2) {
      __int16 v15 = 0;
    }
    unsigned int v16 = (unsigned __int16)(daysBeforeMonth[a2] + v15);
    if (v16 != 0xFFFF) {
      double v3 = v3 + (double)v16;
    }
  }
  return v3 + (double)(a3 - 1);
}

CFTimeInterval CFTimeZoneGetSecondsFromGMT(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint64_t v4 = (void *)_CFAutoreleasePoolPush();
  CFTimeInterval v5 = (double)[(__CFTimeZone *)tz secondsFromGMTForDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  _CFAutoreleasePoolPop(v4);
  return v5;
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t vars8 = va_arg(va, unsigned char *);
  uint64_t v3 = 0;
  va_copy(v13, va);
  for (CFIndex i = vars8; *i > 0x6Bu; ++i)
  {
    switch(*i)
    {
      case 'l':
LABEL_7:
        v3 |= 8uLL;
        break;
      case 'm':
        v3 |= 0x40uLL;
        break;
      case 'r':
      case 'y':
LABEL_6:
        v3 |= 4uLL;
        break;
      case 's':
        v3 |= 0x80uLL;
        break;
      case 'w':
LABEL_8:
        v3 |= 0x2100uLL;
        break;
      default:
        continue;
    }
LABEL_22:
    ;
  }
  switch(*i)
  {
    case 'D':
      v3 |= 0x10000uLL;
      goto LABEL_22;
    case 'E':
    case 'c':
      v3 |= 0x200uLL;
      goto LABEL_22;
    case 'F':
      v3 |= 0x400uLL;
      goto LABEL_22;
    case 'G':
      v3 |= 2uLL;
      goto LABEL_22;
    case 'H':
      v3 |= 0x20uLL;
      goto LABEL_22;
    case 'I':
    case 'J':
    case 'K':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'S':
    case 'T':
    case 'V':
    case 'X':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '_':
    case 'a':
    case 'b':
      goto LABEL_22;
    case 'L':
    case 'M':
      goto LABEL_7;
    case 'Q':
      v3 |= 0x800uLL;
      goto LABEL_22;
    case 'U':
      goto LABEL_6;
    case 'W':
      v3 |= 0x1000uLL;
      goto LABEL_22;
    case 'Y':
      v3 |= 0x4000uLL;
      goto LABEL_22;
    case '^':
      goto LABEL_8;
    case 'd':
      v3 |= 0x10uLL;
      goto LABEL_22;
    default:
      if (*i == 35)
      {
        v3 |= 0x8000uLL;
        goto LABEL_22;
      }
      if (*i) {
        goto LABEL_22;
      }
      uint64_t v5 = [(__CFCalendar *)calendar components:v3 fromDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
      if (v5)
      {
        int v6 = *vars8;
        if (*vars8)
        {
          unint64_t v7 = (void *)v5;
          double v8 = vars8 + 1;
          while (2)
          {
            unint64_t v9 = va_arg(v13, _DWORD *);
            switch(v6)
            {
              case 'D':
                int v10 = [v7 dayOfYear];
                goto LABEL_46;
              case 'E':
              case 'c':
                int v10 = [v7 weekday];
                goto LABEL_46;
              case 'F':
                int v10 = [v7 weekdayOrdinal];
                goto LABEL_46;
              case 'G':
                int v10 = [v7 era];
                goto LABEL_46;
              case 'H':
                int v10 = [v7 hour];
                goto LABEL_46;
              case 'I':
              case 'J':
              case 'K':
              case 'N':
              case 'O':
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'V':
              case 'X':
              case 'Z':
              case '[':
              case '\\':
              case ']':
              case '_':
              case 'a':
              case 'b':
                goto LABEL_47;
              case 'L':
              case 'M':
                int v10 = [v7 month];
                goto LABEL_46;
              case 'Q':
                int v10 = [v7 quarter];
                goto LABEL_46;
              case 'U':
LABEL_29:
                int v10 = objc_msgSend(v7, "year", v13);
                goto LABEL_46;
              case 'W':
                int v10 = [v7 weekOfMonth];
                goto LABEL_46;
              case 'Y':
                int v10 = [v7 yearForWeekOfYear];
                goto LABEL_46;
              case '^':
LABEL_31:
                *unint64_t v9 = objc_msgSend(v7, "weekOfYear", v13);
                if ([v7 weekOfYear] != 0x7FFFFFFFFFFFFFFFLL) {
                  goto LABEL_47;
                }
                int v10 = [v7 week];
LABEL_46:
                *unint64_t v9 = v10;
LABEL_47:
                int v11 = *v8++;
                int v6 = v11;
                if (!v11) {
                  break;
                }
                continue;
              case 'd':
                int v10 = [v7 day];
                goto LABEL_46;
              default:
                switch(v6)
                {
                  case 'l':
                    int v10 = [v7 isLeapMonth];
                    goto LABEL_46;
                  case 'm':
                    int v10 = [v7 minute];
                    goto LABEL_46;
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'x':
                    goto LABEL_47;
                  case 'r':
                  case 'y':
                    goto LABEL_29;
                  case 's':
                    int v10 = [v7 second];
                    goto LABEL_46;
                  case 'w':
                    goto LABEL_31;
                  default:
                    if (v6 != 35) {
                      goto LABEL_47;
                    }
                    int v10 = [v7 nanosecond];
                    break;
                }
                goto LABEL_46;
            }
            break;
          }
        }
        LOBYTE(v5) = 1;
      }
      return v5;
  }
}

uint64_t CFDateComponentsGetValue(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    CFDateComponentsGetValue_cold_1();
  }
  uint64_t v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 <= 511)
  {
    if (a2 > 31)
    {
      if (a2 > 127)
      {
        if (a2 == 128)
        {
          uint64_t v3 = a1 + 88;
          return *(void *)v3;
        }
        if (a2 == 256)
        {
          uint64_t v3 = a1 + 96;
          return *(void *)v3;
        }
      }
      else
      {
        if (a2 == 32)
        {
          uint64_t v3 = a1 + 72;
          return *(void *)v3;
        }
        if (a2 == 64)
        {
          uint64_t v3 = a1 + 80;
          return *(void *)v3;
        }
      }
    }
    else if (a2 > 7)
    {
      if (a2 == 8)
      {
        uint64_t v3 = a1 + 48;
        return *(void *)v3;
      }
      if (a2 == 16)
      {
        uint64_t v3 = a1 + 64;
        return *(void *)v3;
      }
    }
    else
    {
      if (a2 == 2)
      {
        uint64_t v3 = a1 + 32;
        return *(void *)v3;
      }
      if (a2 == 4)
      {
        uint64_t v3 = a1 + 40;
        return *(void *)v3;
      }
    }
  }
  else if (a2 < 0x2000)
  {
    if (a2 > 2047)
    {
      if (a2 == 2048)
      {
        uint64_t v3 = a1 + 120;
        return *(void *)v3;
      }
      if (a2 == 4096)
      {
        uint64_t v3 = a1 + 128;
        return *(void *)v3;
      }
    }
    else
    {
      if (a2 == 512)
      {
        uint64_t v3 = a1 + 104;
        return *(void *)v3;
      }
      if (a2 == 1024)
      {
        uint64_t v3 = a1 + 112;
        return *(void *)v3;
      }
    }
  }
  else if (a2 < 0x8000)
  {
    if (a2 == 0x2000)
    {
      uint64_t v3 = a1 + 136;
      return *(void *)v3;
    }
    if (a2 == 0x4000)
    {
      uint64_t v3 = a1 + 144;
      return *(void *)v3;
    }
  }
  else
  {
    switch(a2)
    {
      case 0x8000:
        uint64_t v3 = a1 + 152;
        return *(void *)v3;
      case 0x10000:
        uint64_t v3 = a1 + 160;
        return *(void *)v3;
      case 0x40000000:
        uint64_t v3 = a1 + 56;
        return *(void *)v3;
    }
  }
  return v2;
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  v21[1] = *(void *)off_1ECE0A5B0;
  double SecondsFromGMT = 0.0;
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  v21[0] = 0;
  __int16 v20 = 0;
  double v19 = SecondsFromGMT + at;
  __CFYMDFromAbsolute(vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0), v21, (unint64_t)&v20 + 1, (unint64_t)&v20);
  if (v21[0] >= 2147481646) {
    int v4 = 2147481646;
  }
  else {
    int v4 = v21[0];
  }
  _Q1 = vrndmq_f64(vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v19, 0), (float64x2_t)xmmword_182D9EBE0));
  _D0 = 0x404E000000000000;
  __asm { FMLS            D2, D0, V1.D[0] }
  double v12 = _D2 + 60.0;
  if (_D2 >= 0.0) {
    double v12 = _D2;
  }
  if (v12 == 0.0) {
    double v12 = 0.0;
  }
  int32x2_t v13 = vcvt_s32_f32(vcvt_f32_f64(vrndmq_f64(vmlsq_f64(_Q1, (float64x2_t)xmmword_182D9EBF0, vrndmq_f64(vdivq_f64(_Q1, (float64x2_t)xmmword_182D9EBF0))))));
  int8x8_t v14 = vand_s8(vbsl_s8((int8x8_t)vcltz_s32(v13), (int8x8_t)vadd_s32(v13, (int32x2_t)0x180000003CLL), (int8x8_t)v13), (int8x8_t)0xFF000000FFLL);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  int64x2_t v16 = (int64x2_t)vshlq_u64(v15, (uint64x2_t)xmmword_182D9EC00);
  unint64_t v17 = vorrq_s8((int8x16_t)v16, (int8x16_t)vdupq_laneq_s64(v16, 1)).u64[0] | ((unint64_t)v20 << 40) | ((unint64_t)HIBYTE(v20) << 32) | (v4 + 2001);
  double v18 = v12;
  result.double second = v18;
  result.year = v17;
  result.month = BYTE4(v17);
  result.day = BYTE5(v17);
  result.hour = BYTE6(v17);
  result.minute = HIBYTE(v17);
  return result;
}

uint64_t __CFYMDFromAbsolute(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = 400 * (result / 146097);
  for (uint64_t i = result % 146097; i < 0; --v4)
  {
    uint64_t v21 = v4 % 400;
    if (v4 % 400 < 0) {
      uint64_t v21 = -v21;
    }
    if ((v21 & 3) != 0 || v21 == 100 || v21 == 300 || v21 == 200) {
      uint64_t v22 = 365;
    }
    else {
      uint64_t v22 = 366;
    }
    i += v22;
  }
  uint64_t v6 = (v4 + 1) % 400;
  if (v6 < 0) {
    uint64_t v6 = -v6;
  }
  if ((v6 & 3) != 0 || v6 == 100 || v6 == 300 || v6 == 200) {
    unint64_t v7 = 365;
  }
  else {
    unint64_t v7 = 366;
  }
  if (i >= v7)
  {
    do
    {
      uint64_t v19 = (v4 + 2) % 400;
      if (v19 < 0) {
        uint64_t v19 = 400 * ((v4 + 2) / 400) - (v4 + 2);
      }
      if ((v19 & 3) != 0 || v19 == 100 || v19 == 300 || v19 == 200) {
        uint64_t v20 = 365;
      }
      else {
        uint64_t v20 = 366;
      }
      i -= v7;
      ++v4;
      unint64_t v7 = v20;
    }
    while (i >= v20);
  }
  if (a2) {
    *a2 = v4;
  }
  if (a3 | a4)
  {
    uint64_t v8 = (v4 + 1) % 400;
    if (v8 >= 0) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = -v8;
    }
    if ((v9 & 3) != 0)
    {
      __int16 v10 = 0;
    }
    else
    {
      __int16 v10 = 0;
      if (v9 != 100 && v9 != 200) {
        __int16 v10 = v9 != 300;
      }
    }
    int v11 = (int)i / 33;
    if (((int)i / 33 + 1) <= 0xCu) {
      char v12 = 12;
    }
    else {
      char v12 = (int)i / 33 + 1;
    }
    while (1)
    {
      int v13 = v11 + 1;
      if ((v11 + 1) > 0xBu) {
        break;
      }
      unsigned __int8 v14 = v11 + 2;
      __int16 v15 = daysBeforeMonth[v14];
      if (v14 > 2u) {
        __int16 v16 = v10;
      }
      else {
        __int16 v16 = 0;
      }
      BOOL v17 = i < (unsigned __int16)(v15 + v16);
      int v11 = v13;
      if (v17)
      {
        if (!a3) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }
    LOBYTE(v13) = v12;
    if (a3) {
LABEL_25:
    }
      *(unsigned char *)a3 = v13;
LABEL_26:
    if (a4)
    {
      if (v13 > 0xFu)
      {
        char v18 = -1;
      }
      else
      {
        if (v13 <= 2u) {
          LOBYTE(v10) = 0;
        }
        char v18 = daysBeforeMonth[v13] + v10;
      }
      *(unsigned char *)a4 = i - v18 + 1;
    }
  }
  return result;
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  va_copy(v14, va);
  uint64_t v6 = (void *)[objc_allocWithZone((Class)NSDateComponents) init];
  int v7 = *(unsigned __int8 *)componentDesc;
  if (*componentDesc)
  {
    uint64_t v8 = componentDesc + 1;
    do
    {
      int v9 = va_arg(v14, void);
      if (v7 > 99)
      {
        if (v7 > 114)
        {
          switch(v7)
          {
            case 's':
              [v6 setSecond:v9];
              break;
            case 'w':
              [v6 setWeekOfYear:v9];
              [v6 setWeek:v9];
              break;
            case 'y':
              [v6 setYear:v9];
              break;
          }
        }
        else
        {
          switch(v7)
          {
            case 'd':
              [v6 setDay:v9];
              break;
            case 'l':
              [v6 setLeapMonth:v9 != 0];
              break;
            case 'm':
              [v6 setMinute:v9];
              break;
          }
        }
      }
      else
      {
        switch(v7)
        {
          case 'D':
            [v6 setDayOfYear:v9];
            break;
          case 'E':
            [v6 setWeekday:v9];
            break;
          case 'F':
            [v6 setWeekdayOrdinal:v9];
            break;
          case 'G':
            [v6 setEra:v9];
            break;
          case 'H':
            [v6 setHour:v9];
            break;
          case 'I':
          case 'J':
          case 'K':
          case 'L':
          case 'N':
          case 'O':
          case 'P':
          case 'R':
          case 'S':
          case 'T':
          case 'U':
          case 'V':
          case 'X':
            break;
          case 'M':
            [v6 setMonth:v9];
            break;
          case 'Q':
            [v6 setQuarter:v9];
            break;
          case 'W':
            [v6 setWeekOfMonth:v9];
            break;
          case 'Y':
            [v6 setYearForWeekOfYear:v9];
            break;
          default:
            if (v7 == 35) {
              [v6 setNanosecond:v9];
            }
            break;
        }
      }
      int v10 = *(unsigned __int8 *)v8++;
      int v7 = v10;
    }
    while (v10);
  }
  int v11 = (void *)-[__CFCalendar dateFromComponents:](calendar, "dateFromComponents:", v6, v14);

  if (!v11) {
    return 0;
  }
  [v11 timeIntervalSinceReferenceDate];
  *(void *)at = v12;
  return 1;
}

void *CFDateComponentsSetValue(void *result, uint64_t a2, uint64_t a3)
{
  if (!result) {
    CFDateComponentsSetValue_cold_1();
  }
  if (a2 <= 511)
  {
    if (a2 > 31)
    {
      if (a2 > 127)
      {
        if (a2 == 128)
        {
          uint64_t v3 = result + 11;
        }
        else
        {
          if (a2 != 256) {
            return result;
          }
          uint64_t v3 = result + 12;
        }
      }
      else if (a2 == 32)
      {
        uint64_t v3 = result + 9;
      }
      else
      {
        if (a2 != 64) {
          return result;
        }
        uint64_t v3 = result + 10;
      }
    }
    else if (a2 > 7)
    {
      if (a2 == 8)
      {
        uint64_t v3 = result + 6;
      }
      else
      {
        if (a2 != 16) {
          return result;
        }
        uint64_t v3 = result + 8;
      }
    }
    else if (a2 == 2)
    {
      uint64_t v3 = result + 4;
    }
    else
    {
      if (a2 != 4) {
        return result;
      }
      uint64_t v3 = result + 5;
    }
  }
  else if (a2 < 0x2000)
  {
    if (a2 > 2047)
    {
      if (a2 == 2048)
      {
        uint64_t v3 = result + 15;
      }
      else
      {
        if (a2 != 4096) {
          return result;
        }
        uint64_t v3 = result + 16;
      }
    }
    else if (a2 == 512)
    {
      uint64_t v3 = result + 13;
    }
    else
    {
      if (a2 != 1024) {
        return result;
      }
      uint64_t v3 = result + 14;
    }
  }
  else if (a2 < 0x8000)
  {
    if (a2 == 0x2000)
    {
      uint64_t v3 = result + 17;
    }
    else
    {
      if (a2 != 0x4000) {
        return result;
      }
      uint64_t v3 = result + 18;
    }
  }
  else
  {
    switch(a2)
    {
      case 0x8000:
        uint64_t v3 = result + 19;
        break;
      case 0x10000:
        uint64_t v3 = result + 20;
        break;
      case 0x40000000:
        uint64_t v3 = result + 7;
        break;
      default:
        return result;
    }
  }
  void *v3 = a3;
  return result;
}

uint64_t CFDateComponentsCreateCopy(__objc2_class **a1, uint64_t a2)
{
  CFDateComponentsCreate(a1);
  if (!v3) {
    CFDateComponentsCreateCopy_cold_1();
  }
  uint64_t v4 = v3;
  uint64_t v5 = (void *)CFDateComponentsCopyCalendar(a2);
  if (v5)
  {
    uint64_t v6 = v5;
    CFDateComponentsSetCalendar(v4, v5);
    CFRelease(v6);
  }
  CFTypeRef v7 = CFDateComponentsCopyTimeZone(a2);
  if (v7)
  {
    uint64_t v8 = v7;
    CFDateComponentsSetTimeZone(v4, v7);
    CFRelease(v8);
  }
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v4 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v4 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v4 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v4 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v4 + 128) = *(_OWORD *)(a2 + 128);
  *(void *)(v4 + 160) = *(void *)(a2 + 160);
  *(_OWORD *)(v4 + 144) = *(_OWORD *)(a2 + 144);
  return v4;
}

CFTypeRef CFDateComponentsCopyCalendar(uint64_t a1)
{
  if (!a1) {
    CFDateComponentsCopyCalendar_cold_1();
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

int64x2_t CFDateComponentsCreate(__objc2_class **Default)
{
  if (!Default) {
    Default = (__objc2_class **)CFAllocatorGetDefault();
  }
  uint64_t Instance = (int64x2_t *)_CFRuntimeCreateInstance(Default, 0x42uLL, 152, 0);
  if (Instance)
  {
    Instance[1].i64[0] = 0;
    Instance[1].i64[1] = 0;
    int64x2_t result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    Instance[2] = result;
    Instance[3] = result;
    Instance[4] = result;
    Instance[5] = result;
    Instance[6] = result;
    Instance[7] = result;
    Instance[10].i64[0] = 0x7FFFFFFFFFFFFFFFLL;
    Instance[8] = result;
    Instance[9] = result;
  }
  return result;
}

CFTypeRef CFDateComponentsCopyTimeZone(uint64_t a1)
{
  if (!a1) {
    CFDateComponentsCopyTimeZone_cold_1();
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void CFDateComponentsSetTimeZone(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    CFDateComponentsSetTimeZone_cold_1();
  }
  uint64_t v4 = *(const void **)(a1 + 24);
  if (cf && v4)
  {
    if (CFEqual(v4, cf)) {
      return;
    }
    uint64_t v4 = *(const void **)(a1 + 24);
    goto LABEL_7;
  }
  if (v4)
  {
LABEL_7:
    CFRelease(v4);
    *(void *)(a1 + 24) = 0;
  }
  if (cf)
  {
    *(void *)(a1 + 24) = CFRetain(cf);
    uint64_t v5 = *(__CFCalendar **)(a1 + 16);
    if (v5)
    {
      CFCalendarSetTimeZone(v5, (CFTimeZoneRef)cf);
    }
  }
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  uint64_t v3 = [NSDate alloc];

  return (CFDateRef)[(NSDate *)v3 initWithTimeIntervalSinceReferenceDate:at];
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  CFAllocatorRef v5 = allocator;
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      CFAllocatorRef v5 = (const __CFAllocator *)v6;
    }
    else {
      CFAllocatorRef v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  }
  double AbsoluteTime = CFDateGetAbsoluteTime(date);

  return CFDateFormatterCreateStringWithAbsoluteTime(v5, formatter, AbsoluteTime);
}

double decodeTaggedTimeInterval(unint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  if (a1 == -1)
  {
    uint64_t v1 = 0x8000000000000000;
  }
  else
  {
    if (a1 >> 60) {
      decodeTaggedTimeInterval_cold_1();
    }
    uint64_t v1 = a1 & 0xFFFFFFFFFFFFFLL | (a1 >> 59 << 63) | (((uint64_t)(32 * a1) >> 57 << 52) + 0x3EF0000000000000);
  }
  return *(double *)&v1;
}

void CFRunLoopTimerGetContext(CFRunLoopTimerRef timer, CFRunLoopTimerContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)timer);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v4 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  long long v5 = *(_OWORD *)((char *)timer + 152);
  long long v6 = *(_OWORD *)((char *)timer + 168);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)timer + 23);
  *(_OWORD *)&context->versiouint64_t n = v5;
  *(_OWORD *)&context->retaiuint64_t n = v6;
}

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (unint64_t)timer))
  {
    LOBYTE(v2) = [(__CFRunLoopTimer *)timer isValid];
  }
  else
  {
    unint64_t v3 = atomic_load((unint64_t *)timer + 1);
    return (v3 >> 3) & 1;
  }
  return v2;
}

CFIndex _CFAttributedStringGetLength(uint64_t a1)
{
  return CFStringGetLength(*(CFStringRef *)(a1 + 16));
}

void sub_182BF4320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFURLRegisterFilePropertyWithOptions()
{
  return MEMORY[0x1F4114FE0]();
}

void __CFRepositionTimerInMode(uint64_t a1, const void *a2, int a3)
{
  if (a2)
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 120);
    if (v4)
    {
      CFArrayRef v6 = *(const __CFArray **)(a1 + 120);
      if (a3)
      {
        v12.CFIndex length = CFArrayGetCount(v6);
        v12.CFIndex location = 0;
        FirstIndexOfBoolean Value = CFArrayGetFirstIndexOfValue(v4, v12, a2);
        if (FirstIndexOfValue != -1)
        {
          CFIndex v8 = FirstIndexOfValue;
          CFRetain(a2);
          CFArrayRemoveValueAtIndex(v4, v8);
          CFIndex v9 = __CFRunLoopInsertionIndexInTimerArray(v4, (uint64_t)a2);
          CFArrayInsertValueAtIndex(v4, v9, a2);
          __CFArmNextTimerInMode(a1);
          CFRelease(a2);
        }
      }
      else
      {
        CFIndex v10 = __CFRunLoopInsertionIndexInTimerArray(v6, (uint64_t)a2);
        CFArrayInsertValueAtIndex(v4, v10, a2);
        __CFArmNextTimerInMode(a1);
      }
    }
  }
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    [(__CFArray *)theArray removeObjectAtIndex:idx];
  }
  else
  {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 1, 0, 0);
  }
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_2;
  }
  unsigned int v12 = atomic_load((unint64_t *)theArray + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_2:
      unint64_t v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    char v14 = atomic_load((unint64_t *)theArray + 1);
    int v15 = v14 & 3;
    if (v15) {
      __int16 v16 = 0;
    }
    else {
      __int16 v16 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v15 == 2) {
      unint64_t v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      unint64_t v7 = v16;
    }
  }
  else
  {
    unint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (length < 1) {
    return -1;
  }
  uint64_t v8 = 0;
  for (CFIndex i = location; ; ++i)
  {
    CFIndex v10 = (const void *)[(__CFArray *)theArray objectAtIndex:i];
    if (v10 == value) {
      break;
    }
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal && equal(value, v10)) {
      return i;
    }
    ++v8;
    if (!--length) {
      return -1;
    }
  }
  return v8 + location;
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  v6[1] = *(void *)off_1ECE0A5B0;
  v6[0] = value;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    [(__CFArray *)theArray insertObject:value atIndex:idx];
  }
  else
  {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 0, v6, 1);
  }
}

void _CFArrayReplaceValues(unint64_t a1, uint64_t a2, uint64_t a3, void *__src, uint64_t a5)
{
  uint64_t v68 = *(void *)off_1ECE0A5B0;
  memset(v67, 0, 512);
  unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
  int v11 = (v10 >> 2) & 3;
  if (v11)
  {
    if (v11 == 1)
    {
      unsigned int v12 = &kCFTypeArrayCallBacks;
    }
    else
    {
      char v13 = atomic_load((unint64_t *)(a1 + 8));
      int v14 = v13 & 3;
      if (v14 != 2 && v14) {
        unsigned int v12 = 0;
      }
      else {
        unsigned int v12 = (const CFArrayCallBacks *)(a1 + 48);
      }
    }
  }
  else
  {
    unsigned int v12 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  int v15 = &kCFAllocatorSystemDefault;
  if ((a1 & 0x8000000000000000) == 0)
  {
    char v16 = atomic_load((unint64_t *)(a1 + 8));
    if (v16 < 0) {
      int v15 = &kCFAllocatorSystemDefault;
    }
    else {
      int v15 = (const CFAllocatorRef *)(a1 - 16);
    }
  }
  unint64_t v17 = *(void *)(a1 + 16) - a3;
  CFAllocatorRef v18 = *v15;
  uint64_t Typed = __src;
  if (v12->retain)
  {
    if (a5 >= 257)
    {
      uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * a5, 0x80040B8603338, 0);
      if (Typed != v67 && __CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
    else
    {
      uint64_t Typed = v67;
      if (a5 < 1) {
        goto LABEL_21;
      }
    }
    uint64_t v20 = 0;
    do
    {
      *((void *)Typed + v20) = ((uint64_t (*)(CFAllocatorRef, void))v12->retain)(v18, __src[v20]);
      ++v20;
    }
    while (a5 != v20);
  }
LABEL_21:
  unint64_t v21 = v17 + a5;
  ++*(void *)(a1 + 24);
  if (a3 >= 1) {
    __CFArrayReleaseValues(a1, a2, a3, 0);
  }
  uint64_t v22 = *(uint64_t **)(a1 + 40);
  uint64_t v66 = v21;
  if (v22)
  {
    uint64_t v23 = a5 - a3;
    if (a5 == a3) {
      goto LABEL_88;
    }
    int64_t v24 = *(void *)(a1 + 16);
    uint64_t v25 = v24 - a3 + a5;
    uint64_t v63 = v22 + 2;
    uint64_t v64 = v24 - a3 - a2;
    uint64_t v27 = *v22;
    unint64_t v26 = v22[1];
    uint64_t v28 = v26 >> 17;
    if (v26 >> 17 <= 4) {
      uint64_t v28 = 4;
    }
    if (v26 < v25 || (uint64_t v29 = v26 - v24, v24 < v25) && v29 < v28)
    {
      uint64_t v30 = v28 + v25;
      uint64_t v62 = *v22;
      if (v28 + v25 >= 4)
      {
        if (flsl(v28 + v25) == 31) {
          uint64_t v31 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v31 = 1 << flsl(v30);
        }
      }
      else
      {
        uint64_t v31 = 4;
      }
      uint64_t v65 = a2;
      if ((a1 & 0x8000000000000000) != 0)
      {
        unint64_t v50 = &kCFAllocatorSystemDefault;
      }
      else
      {
        char v51 = atomic_load((unint64_t *)(a1 + 8));
        if (v51 < 0) {
          unint64_t v50 = &kCFAllocatorSystemDefault;
        }
        else {
          unint64_t v50 = (const CFAllocatorRef *)(a1 - 16);
        }
      }
      CFAllocatorRef allocator = *v50;
      size_t v52 = (uint64_t *)CFAllocatorAllocateTyped(*v50, 8 * v31 + 16, 1166748410, 0);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      unsigned int v53 = v52 + 2;
      if (v31 >= v25) {
        uint64_t v54 = v31 - v25;
      }
      else {
        uint64_t v54 = v31 - v25 + 1;
      }
      *size_t v52 = v54 >> 1;
      v52[1] = v31;
      if (v65 >= 1) {
        memmove(&v53[v54 >> 1], &v63[v62], 8 * v65);
      }
      if (v64 >= 1) {
        memmove(&v53[v65 + a5 + (v54 >> 1)], &v63[a3 + v65 + v62], 8 * v64);
      }
      *(void *)(a1 + 40) = v52;
      CFAllocatorDeallocate(allocator, v22);
      a2 = v65;
      goto LABEL_88;
    }
    BOOL v33 = v23 <= v29 - v27 || v23 < 0;
    uint64_t v34 = v24 - a3 - a2;
    if (v33 && v64 < a2)
    {
      uint64_t v58 = v27 + a2 + a3;
      uint64_t v59 = v27 + a2 + a5;
      if (v64 >= 1)
      {
        memmove(&v63[v59], &v63[v58], 8 * v64);
        uint64_t v34 = v64;
      }
      if (a5 < a3)
      {
        char v49 = &v63[v59 + v34];
        uint64_t v48 = v58 - v59;
        goto LABEL_99;
      }
    }
    else
    {
      uint64_t v36 = v27 - v23;
      BOOL v38 = v27 < v23 || v64 < a2;
      if (v23 < 0 || !v38)
      {
        *uint64_t v22 = v36;
        if (a2 >= 1) {
          memmove(&v22[v36 + 2], &v22[v27 + 2], 8 * a2);
        }
        if (v23 < 0)
        {
          char v49 = &v63[v27];
          size_t v60 = -8 * v23;
          goto LABEL_110;
        }
      }
      else
      {
        BOOL v39 = v29 < v23;
        uint64_t v40 = v29 - v23;
        if (v39) {
          uint64_t v41 = v40 + 1;
        }
        else {
          uint64_t v41 = v40;
        }
        uint64_t v42 = v41 >> 1;
        if (v39) {
          v40 += 3;
        }
        uint64_t v43 = *v22;
        uint64_t v44 = v42 - (v40 >> 2);
        uint64_t v45 = a3 + a2 + *v22;
        uint64_t v46 = a2 + a5 + v44;
        *uint64_t v22 = v44;
        uint64_t v47 = v43;
        if (v44 >= v43)
        {
          if (v64 >= 1) {
            memmove(&v63[v46], &v63[v45], 8 * v64);
          }
          if (a2 >= 1) {
            memmove(&v63[v44], &v63[v47], 8 * a2);
          }
          if (v44 > v47)
          {
            size_t v60 = 8 * (v44 - v47);
            char v49 = &v63[v47];
            goto LABEL_110;
          }
        }
        else
        {
          if (a2 >= 1)
          {
            memmove(&v63[v44], &v63[v43], 8 * a2);
            uint64_t v34 = v64;
          }
          if (v34 >= 1)
          {
            memmove(&v63[v46], &v63[v45], 8 * v34);
            uint64_t v34 = v64;
          }
          uint64_t v48 = v45 - v46;
          if (v45 > v46)
          {
            char v49 = &v63[v46 + v34];
LABEL_99:
            size_t v60 = 8 * v48;
LABEL_110:
            bzero(v49, v60);
          }
        }
      }
    }
  }
  else if ((v21 & 0x8000000000000000) == 0)
  {
    if (v21 >= 4)
    {
      if (flsl(v21) == 31) {
        uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v32 = 1 << flsl(v21);
      }
    }
    else
    {
      uint64_t v32 = 4;
    }
    char v55 = (uint64_t *)CFAllocatorAllocateTyped(v18, 8 * v32 + 16, 1424118679, 0);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    uint64_t v56 = v32 - a5;
    if (v32 < a5) {
      ++v56;
    }
    *char v55 = v56 >> 1;
    v55[1] = v32;
    *(void *)(a1 + 40) = v55;
  }
LABEL_88:
  if (a5 >= 1)
  {
    BOOL v57 = *(void **)(a1 + 40);
    if (!v57) {
      _CFArrayReplaceValues_cold_1();
    }
    memmove(&v57[*v57 + 2 + a2], Typed, 8 * a5);
  }
  *(void *)(a1 + 16) = v66;
  if (Typed != v67 && Typed != (_OWORD *)__src) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

void __CFArrayReleaseValues(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v8 = atomic_load((unint64_t *)(a1 + 8));
  int v9 = (v8 >> 2) & 3;
  if (v9)
  {
    if (v9 == 1)
    {
      unsigned int v10 = &kCFTypeArrayCallBacks;
    }
    else
    {
      char v11 = atomic_load((unint64_t *)(a1 + 8));
      int v12 = v11 & 3;
      if (v12) {
        char v13 = 0;
      }
      else {
        char v13 = (const CFArrayCallBacks *)(a1 + 48);
      }
      if (v12 == 2) {
        unsigned int v10 = (const CFArrayCallBacks *)(a1 + 48);
      }
      else {
        unsigned int v10 = v13;
      }
    }
  }
  else
  {
    unsigned int v10 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  char v14 = atomic_load((unint64_t *)(a1 + 8));
  int v15 = v14 & 3;
  if (v15 == 2)
  {
    uint64_t v23 = *(void **)(a1 + 40);
    if (a3 >= 1 && v23)
    {
      char v24 = atomic_load((unint64_t *)(a1 + 8));
      int v25 = v24 & 3;
      if (v25 == 2)
      {
        uint64_t v28 = *(void *)(a1 + 40) + 8 * **(void **)(a1 + 40) + 16;
      }
      else if (v25)
      {
        uint64_t v28 = 0;
      }
      else
      {
        char v26 = atomic_load((unint64_t *)(a1 + 8));
        BOOL v20 = (~v26 & 0xC) == 0;
        uint64_t v27 = 48;
        if (v20) {
          uint64_t v27 = 88;
        }
        uint64_t v28 = a1 + v27;
      }
      if (v10->release)
      {
        if ((a1 & 0x8000000000000000) != 0)
        {
          uint64_t v35 = &kCFAllocatorSystemDefault;
        }
        else
        {
          char v36 = atomic_load((unint64_t *)(a1 + 8));
          if (v36 < 0) {
            uint64_t v35 = &kCFAllocatorSystemDefault;
          }
          else {
            uint64_t v35 = (const CFAllocatorRef *)(a1 - 16);
          }
        }
        CFAllocatorRef v37 = *v35;
        BOOL v38 = (uint64_t *)(v28 + 8 * a2);
        uint64_t v39 = a3;
        do
        {
          uint64_t v40 = *v38++;
          ((void (*)(CFAllocatorRef, uint64_t))v10->release)(v37, v40);
          --v39;
        }
        while (v39);
      }
      bzero((void *)(v28 + 8 * a2), 8 * a3);
    }
    if (a4 && !a2 && *(void *)(a1 + 16) == a3)
    {
      if ((a1 & 0x8000000000000000) != 0)
      {
        uint64_t v41 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      }
      else
      {
        char v42 = atomic_load((unint64_t *)(a1 + 8));
        if (v42 < 0) {
          uint64_t v41 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v41 = (CFAllocatorRef *)(a1 - 16);
        }
      }
      if (v23) {
        CFAllocatorDeallocate(*v41, v23);
      }
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 40) = 0;
    }
  }
  else if (!v15 && v10->release && a3 >= 1)
  {
    char v17 = atomic_load((unint64_t *)(a1 + 8));
    int v18 = v17 & 3;
    if (v18 == 2)
    {
      uint64_t v22 = *(void *)(a1 + 40) + 8 * **(void **)(a1 + 40) + 16;
      if ((a1 & 0x8000000000000000) == 0) {
        goto LABEL_31;
      }
    }
    else
    {
      if (!v18)
      {
        char v19 = atomic_load((unint64_t *)(a1 + 8));
        BOOL v20 = (~v19 & 0xC) == 0;
        uint64_t v21 = 48;
        if (v20) {
          uint64_t v21 = 88;
        }
        uint64_t v22 = a1 + v21;
        if ((a1 & 0x8000000000000000) != 0) {
          goto LABEL_35;
        }
LABEL_31:
        char v29 = atomic_load((unint64_t *)(a1 + 8));
        if (v29 < 0) {
          uint64_t v30 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v30 = (const CFAllocatorRef *)(a1 - 16);
        }
        goto LABEL_36;
      }
      uint64_t v22 = 0;
      if ((a1 & 0x8000000000000000) == 0) {
        goto LABEL_31;
      }
    }
LABEL_35:
    uint64_t v30 = &kCFAllocatorSystemDefault;
LABEL_36:
    CFAllocatorRef v31 = *v30;
    uint64_t v32 = (uint64_t *)(v22 + 8 * a2);
    uint64_t v33 = a3;
    do
    {
      uint64_t v34 = *v32++;
      ((void (*)(CFAllocatorRef, uint64_t))v10->release)(v31, v34);
      --v33;
    }
    while (v33);
    bzero((void *)(v22 + 8 * a2), 8 * a3);
  }
}

uint64_t __rangeRetain(uint64_t a1, uint64_t a2)
{
  return a2;
}

void __rangeRelease(uint64_t a1, uint64_t a2)
{
}

void __CFArmNextTimerInMode(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 120);
  if (!v2)
  {
    unint64_t v7 = -1;
    unint64_t v6 = -1;
    goto LABEL_34;
  }
  CFIndex Count = CFArrayGetCount(v2);
  if (Count < 1)
  {
    unint64_t v6 = -1;
  }
  else
  {
    CFIndex v4 = Count;
    CFIndex v5 = 0;
    unint64_t v6 = -1;
    unint64_t v7 = -1;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 120), v5);
      if ((*((_WORD *)ValueAtIndex + 8) & 1) == 0)
      {
        unint64_t v9 = *((void *)ValueAtIndex + 16);
        unint64_t v10 = __CFTimeIntervalToTSR(*((double *)ValueAtIndex + 15));
        if (v9 > v6) {
          break;
        }
        unint64_t v11 = v9 + v10;
        if (__CFADD__(v9, v10)) {
          unint64_t v11 = -1;
        }
        if (v9 < v7) {
          unint64_t v7 = v9;
        }
        if (v11 < v6) {
          unint64_t v6 = v11;
        }
      }
      ++v5;
    }
    while (v4 != v5);
    if (v7 != -1)
    {
      if (v6 != *(void *)(a1 + 192) || v7 != *(void *)(a1 + 184))
      {
        mach_absolute_time();
        kdebug_trace();
        uint64_t v12 = __CFTSRToNanoseconds(v6 - v7);
        dispatch_time_t v13 = __CFTSRToDispatchTime(v7);
        if (v12)
        {
          dispatch_time_t v14 = v13;
          if (*(unsigned char *)(a1 + 176) && *(_DWORD *)(a1 + 172))
          {
            mk_timer_cancel();
            *(unsigned char *)(a1 + 176) = 0;
          }
          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), v14, 0xFFFFFFFFFFFFFFFFLL, v12);
          *(unsigned char *)(a1 + 169) = 1;
        }
        else
        {
          if (*(unsigned char *)(a1 + 169))
          {
            dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x378uLL);
            *(unsigned char *)(a1 + 169) = 0;
          }
          if (*(_DWORD *)(a1 + 172))
          {
            mk_timer_arm();
            *(unsigned char *)(a1 + 176) = 1;
          }
        }
      }
      goto LABEL_34;
    }
  }
  if (*(unsigned char *)(a1 + 176) && *(_DWORD *)(a1 + 172))
  {
    mk_timer_cancel();
    *(unsigned char *)(a1 + 176) = 0;
  }
  unint64_t v7 = -1;
  if (*(unsigned char *)(a1 + 169))
  {
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x14DuLL);
    *(unsigned char *)(a1 + 169) = 0;
  }
LABEL_34:
  *(void *)(a1 + 184) = v7;
  *(void *)(a1 + 192) = v6;
}

unint64_t __CFTimeIntervalToTSR(double a1)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
  }
  if (*(double *)&__CFTSRRate * a1 <= 4.61168602e18) {
    return (unint64_t)(*(double *)&__CFTSRRate * a1);
  }
  else {
    return 0x3FFFFFFFFFFFFFFFLL;
  }
}

void sub_182BF5CD0(_Unwind_Exception *a1)
{
  free(*(void **)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_182BF6CB4(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t __CFRunLoopInsertionIndexInTimerArray(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  uint64_t v5 = Count;
  if ((unint64_t)Count >= 0x101)
  {
    if (*((void *)CFArrayGetValueAtIndex(a1, Count - 1) + 16) <= *(void *)(a2 + 128)) {
      return v5;
    }
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
    uint64_t result = 0;
    if (*(void *)(a2 + 128) < ValueAtIndex[16]) {
      return result;
    }
  }
  uint64_t v8 = 0;
  uint64_t v9 = 2 << flsl(v5);
  do
  {
    if (v9 >= 0) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 + 1;
    }
    if (v8 + (v10 >> 1) >= v5)
    {
      BOOL v14 = 0;
    }
    else
    {
      unint64_t v11 = *((void *)CFArrayGetValueAtIndex(a1, v8 + (v10 >> 1)) + 16);
      unint64_t v12 = *(void *)(a2 + 128);
      BOOL v13 = v11 > v12;
      BOOL v14 = v11 <= v12;
      if (!v13) {
        v8 += v10 >> 1;
      }
    }
    BOOL v13 = v9 <= 1;
    uint64_t v9 = v10 >> 1;
  }
  while (!v13);
  return v14 + v8;
}

unint64_t __CFTSRToNanoseconds(unint64_t a1)
{
  return vcvtmd_u64_f64(*(double *)&__CF1_TSRRate * (double)a1 * 1000000000.0);
}

dispatch_time_t __CFTSRToDispatchTime(unint64_t a1)
{
  unint64_t v1 = vcvtmd_u64_f64(*(double *)&__CF1_TSRRate * (double)a1 * 1000000000.0);
  if (v1 >= 0x7FFFFFFFFFFFFFFELL) {
    int64_t v2 = 0x7FFFFFFFFFFFFFFELL;
  }
  else {
    int64_t v2 = v1;
  }
  return dispatch_time(1uLL, v2);
}

void _CFArrayReplaceValues_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFArray expectation failed";
  __break(1u);
}

CFTypeRef __NSCacheKeyRetain(const void *a1, void *a2)
{
  CFTypeRef result = CFRetain(a1);
  *a2 = result;
  return result;
}

void destroyBlock(uint64_t a1)
{
}

uint64_t __CFHyphenationGetHyphensForString(const __CFString *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, CFIndex a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v40 = a4;
  uint64_t v42 = *(void *)off_1ECE0A5B0;
  if (a3 > 200) {
    return -1;
  }
  CFIndex v13 = a3;
  uint64_t v16 = MEMORY[0x1F4188790](a1, a2);
  MEMORY[0x1F4188790](v16, v17);
  char v19 = (unsigned int *)__CFHyphenationCopyTrieInstance(v18);
  if (!v19) {
    return -1;
  }
  BOOL v20 = v19;
  CFAllocatorRef v37 = &v35;
  uint64_t v38 = a8;
  uint64_t v35 = a5;
  uint64_t v36 = a9;
  memset(v34, 0, 406);
  v43.CFIndex location = a2;
  v43.CFIndex length = v13;
  CFStringGetCharacters(a1, v43, &v34[1]);
  v34[0] = 46;
  v34[v13 + 1] = 46;
  uint64_t v21 = v13 + 2;
  v34[v13 + 2] = 0;
  uint64_t v39 = &v33;
  __memset_chk();
  if ((v13 & 0x8000000000000000) == 0)
  {
    uint64_t v22 = (char *)v39 + 2;
    CFIndex v23 = v13;
    do
    {
      if ((unint64_t)v21 >= 8) {
        uint64_t v24 = v21 - 8;
      }
      else {
        uint64_t v24 = 0;
      }
      if (v24 <= a6)
      {
        if (v40 && v21 <= v13 && *(unsigned char *)(v21 + v40 - 1)) {
          *((unsigned char *)v39 + v21) = 9;
        }
        v34[v21] = 0;
        if (v24 < (unint64_t)v21)
        {
          do
          {
            unsigned int v41 = 0;
            if (v24 > a6) {
              break;
            }
            CFBurstTrieContainsCharacters((uint64_t)v20, (uint64_t)&v34[v24], v21 - v24, &v41);
            unsigned int v25 = v41;
            BOOL v26 = v41 + 0x10000000 < 0x10000001 || v21 < v24;
            if (!v26)
            {
              CFIndex v27 = v23;
              do
              {
                if ((v25 & 7) > v22[v27]) {
                  v22[v27] = v25 & 7;
                }
                v25 >>= 3;
                uint64_t v28 = v27 + 2;
                --v27;
              }
              while (v28 > v24);
            }
            ++v24;
          }
          while (v24 != v21);
        }
      }
      --v23;
      BOOL v26 = v21-- <= 2;
    }
    while (!v26);
  }
  CFBurstTrieRelease(v20);
  uint64_t result = 0;
  uint64_t v29 = v36;
  uint64_t v30 = v35 - 2;
  uint64_t v31 = v38;
  uint64_t v32 = (char *)v39 - 1;
  while (v13 >= 4)
  {
    if ((v32[v13] & 1) != 0 && v13 - 1 <= a6) {
      *(void *)(v31 + 8 * result++) = v30 + v13;
    }
    --v13;
    if (result == v29) {
      return v29;
    }
  }
  return result;
}

uint64_t CFBurstTrieContainsCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  if (a3 > 1023) {
    return 0;
  }
  uint64_t v8 = v12;
  if (a3 >= 86) {
    uint64_t v8 = (unsigned __int8 *)malloc_type_malloc((4 * a3) | 1, 0x1774C9FuLL);
  }
  uint64_t v9 = burstTrieConvertCharactersToUTF8(a2, a3, (uint64_t)v8);
  v8[v9] = 0;
  uint64_t v10 = CFBurstTrieContainsUTF8String(a1, v8, v9, a4);
  if (v12 != v8) {
    free(v8);
  }
  return v10;
}

uint64_t burstTrieConvertCharactersToUTF8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    LODWORD(result) = 0;
    while (1)
    {
      unsigned int v6 = *(unsigned __int16 *)(v3 + 2 * v4);
      if ((v6 & 0xFC00) == 0xD800)
      {
        uint64_t v7 = v5 + 1;
        if (v7 >= a2 || (int v8 = *(unsigned __int16 *)(v3 + 2 * v7), (v8 & 0xFC00) != 0xDC00))
        {
LABEL_11:
          *(unsigned char *)(a3 + result) = (v6 >> 12) | 0xE0;
          unsigned int v10 = result + 2;
          *(unsigned char *)(a3 + (result + 1)) = (v6 >> 6) & 0x3F | 0x80;
          char v11 = v6 & 0x3F | 0x80;
          int v12 = 3;
          goto LABEL_12;
        }
        unsigned int v9 = v8 + (v6 << 10) - 56613888;
        *(unsigned char *)(a3 + result) = (v9 >> 18) - 16;
        *(unsigned char *)(a3 + (result + 1)) = (v9 >> 12) & 0x3F | 0x80;
        unsigned int v10 = result + 3;
        *(unsigned char *)(a3 + (result + 2)) = (v9 >> 6) & 0x3F | 0x80;
        char v11 = v8 & 0x3F | 0x80;
        int v12 = 4;
        unsigned int v5 = v7;
      }
      else if (v6 > 0x7F)
      {
        if (v6 > 0x7FF) {
          goto LABEL_11;
        }
        unsigned int v10 = result + 1;
        *(unsigned char *)(a3 + result) = (v6 >> 6) - 64;
        char v11 = v6 & 0x3F | 0x80;
        int v12 = 2;
      }
      else
      {
        char v11 = *(_WORD *)(v3 + 2 * v4);
        int v12 = 1;
        unsigned int v10 = result;
      }
LABEL_12:
      uint64_t result = (result + v12);
      *(unsigned char *)(a3 + v10) = v11;
      uint64_t v4 = ++v5;
      if (v5 >= a2) {
        goto LABEL_15;
      }
    }
  }
  uint64_t result = 0;
LABEL_15:
  *(unsigned char *)(a3 + result) = 0;
  return result;
}

uint64_t parseArrayTag(uint64_t a1, CFArrayRef *a2, unint64_t a3)
{
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  cf[0] = 0;
  if (!*(unsigned char *)(a1 + 80))
  {
    CFArrayRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeArrayCallBacks);
    CFSetRef v8 = *(const __CFSet **)(a1 + 72);
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    __CFPropertyListCreateSplitKeypaths(*(const __CFAllocator **)(a1 + 32), v8, &v21, &v22);
    CFSetRef v9 = v21;
    BOOL v20 = a2;
    if (!v21)
    {
      Contentuint64_t Object = getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3);
      uint64_t v13 = 0;
      char v11 = v22;
      if (ContentObject) {
        goto LABEL_17;
      }
      goto LABEL_31;
    }
    CFStringRef v10 = CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 32), 0, @"%ld", 0);
    if (!CFSetContainsValue(v9, v10) && !CFSetContainsValue(v9, @"*")) {
      *(unsigned char *)(a1 + 80) = 1;
    }
    if (v10) {
      CFRelease(v10);
    }
    char v11 = v22;
    *(void *)(a1 + 72) = v22;
    int v12 = getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3);
    *(void *)(a1 + 72) = v8;
    *(unsigned char *)(a1 + 80) = 0;
    uint64_t v13 = 1;
    if (!v12)
    {
LABEL_31:
      if (v11) {
        CFRelease(v11);
      }
      if (v9) {
        CFRelease(v9);
      }
      if (!*(void *)(a1 + 24) && checkForCloseTag((unint64_t *)a1, (const UInt8 *)"array", 5uLL))
      {
        int v17 = allowImmutableCollections;
        if (allowImmutableCollections == -1)
        {
          int v17 = getenv("CFPropertyListAllowImmutableCollections") != 0;
          allowImmutableCollections = v17;
        }
        if (v17 == 1)
        {
          CFLocaleRef v18 = v20;
          if (*(_DWORD *)(a1 + 40))
          {
            CFArrayRef Copy = Mutable;
          }
          else
          {
            CFArrayRef Copy = CFArrayCreateCopy(*(CFAllocatorRef *)(a1 + 32), Mutable);
            if (Mutable) {
              CFRelease(Mutable);
            }
          }
        }
        else
        {
          CFArrayRef Copy = Mutable;
          CFLocaleRef v18 = v20;
        }
        *CFLocaleRef v18 = Copy;
        return 1;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      return 0;
    }
    while (1)
    {
      while (1)
      {
LABEL_17:
        if (cf[0])
        {
          CFArrayAppendValue(Mutable, cf[0]);
          if (cf[0]) {
            CFRelease(cf[0]);
          }
        }
        if (v9) {
          break;
        }
        if (!getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3)) {
          goto LABEL_31;
        }
      }
      CFStringRef v15 = CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 32), 0, @"%ld", v13);
      if (!CFSetContainsValue(v9, v15) && !CFSetContainsValue(v9, @"*")) {
        break;
      }
      if (v15) {
        goto LABEL_24;
      }
LABEL_25:
      ++v13;
      *(void *)(a1 + 72) = v11;
      int v16 = getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3);
      *(void *)(a1 + 72) = v8;
      *(unsigned char *)(a1 + 80) = 0;
      if (!v16) {
        goto LABEL_31;
      }
    }
    *(unsigned char *)(a1 + 80) = 1;
    if (!v15) {
      goto LABEL_25;
    }
LABEL_24:
    CFRelease(v15);
    goto LABEL_25;
  }
  while (getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3))
  {
    if (cf[0]) {
      CFRelease(cf[0]);
    }
  }
  if (*(void *)(a1 + 24)) {
    return 0;
  }
  uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"array", 5uLL);
  if (!result) {
    return result;
  }
  *a2 = 0;
  return 1;
}

void CFMergeSortArray(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v42[8] = *(void *)off_1ECE0A5B0;
  if (a2 < 2 || a3 < 1) {
    return;
  }
  if ((unsigned __int128)(a2 * (__int128)a3) >> 64 != (a2 * a3) >> 63)
  {
    uint64_t v17 = CFLog(3, @"Unable to mergesort array - count: %ld elementSize: %ld overflows", a3, a4, a5, a6, a7, a8, a2);
    uint64_t v39 = (void *)&unk_1EC093000;
    uint64_t v40 = "merge sort - count/elementSize overflow";
LABEL_23:
    v39[341] = v40;
    __break(1u);
    goto LABEL_24;
  }
  uint64_t v11 = a3 * a2;
  if (__CFADD__(a1, a3 * a2))
  {
    uint64_t v17 = CFLog(3, @"Unable to mergesort array - list: %lu count: %ld elementSize: %ld - array access overflows", a3, a4, a5, a6, a7, a8, (__int16)a1);
    uint64_t v39 = (void *)&unk_1EC093000;
    uint64_t v40 = "merge sort - array access overflow";
    goto LABEL_23;
  }
  MEMORY[0x1F4188790](a1, a2);
  CFStringRef v15 = (char *)&v42[-1] - v14;
  int v16 = (char *)&v42[-1] - v14;
  if ((unint64_t)a2 > 0x1000)
  {
    uint64_t v17 = (uint64_t)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    int v16 = (char *)v17;
    if (!v17) {
LABEL_24:
    }
      CFMergeSortArray_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
  }
  v42[0] = off_1ECE0A5A0;
  v42[1] = 0x40000000;
  v42[2] = __CFMergeSortArray_block_invoke;
  v42[3] = &__block_descriptor_tmp_31;
  v42[4] = a4;
  v42[5] = a1;
  v42[6] = a3;
  v42[7] = a5;
  CFSortIndexes((uint64_t)v16, a2, 16, (uint64_t)v42);
  MEMORY[0x1F4188790](v25, v26);
  uint64_t v34 = (char *)&v42[-1] - v33;
  uint64_t v35 = (char *)&v42[-1] - v33;
  if (v36 < a2) {
    uint64_t v35 = (char *)malloc_type_malloc(a3 * a2, 0x973A3909uLL);
  }
  uint64_t v41 = (uint64_t)&v41;
  if (__CFADD__(v35, v11))
  {
    uint64_t v17 = CFLog(3, @"Unable to mergesort array - list: %lu count: %ld elementSize: %ld - array store overflows", v27, v28, v29, v30, v31, v32, (__int16)a1);
    uint64_t v39 = &unk_1EC093000;
    uint64_t v40 = "merge sort - overflow array storage";
    goto LABEL_23;
  }
  uint64_t v37 = 0;
  uint64_t v38 = v35;
  do
  {
    if (a3 == 8) {
      *(void *)&v35[8 * v37] = a1[*(void *)&v16[8 * v37]];
    }
    else {
      memmove(v38, (char *)a1 + *(void *)&v16[8 * v37] * a3, a3);
    }
    ++v37;
    v38 += a3;
  }
  while (a2 != v37);
  memmove(a1, v35, a3 * a2);
  if (v34 != v35) {
    free(v35);
  }
  if (v15 != v16) {
    free(v16);
  }
}

void CFSortIndexes(uint64_t a1, unint64_t a2, char a3, uint64_t a4)
{
  block[7] = *(void *)off_1ECE0A5B0;
  if ((uint64_t)a2 >= 1)
  {
    if (a2 >> 60) {
      CFSortIndexes_cold_1();
    }
    char v6 = a3;
    uint64_t v7 = (char *)a1;
    if (a3)
    {
      a1 = __CFActiveProcessorCount();
      if (a2 < 0xA0 || (int)a1 < 2)
      {
        char v6 = 0;
      }
      else if (a2 > 0x27F || a1 <= 2)
      {
        if (a2 > 0xC7F || a1 <= 4)
        {
          if (a1 <= 8 || a2 >> 7 >= 0x7D) {
            a1 = a1;
          }
          else {
            a1 = 8;
          }
        }
        else
        {
          a1 = 4;
        }
      }
      else
      {
        a1 = 2;
      }
      if ((int)a1 >= 16) {
        int v8 = 16;
      }
      else {
        int v8 = a1;
      }
    }
    else
    {
      int v8 = 0;
    }
    if (a2 > 0x10000)
    {
      int v12 = dispatch_queue_create("com.apple.NSSortIndexes", (dispatch_queue_attr_t)off_1ECE0A5E8);
      block[0] = off_1ECE0A5A0;
      block[1] = 0x40000000;
      void block[2] = __CFSortIndexes_block_invoke;
      block[3] = &__block_descriptor_tmp_9;
      block[4] = ((a2 + 15) >> 3) & 0x1FFFFFFFFFFFFFFELL;
      void block[5] = a2;
      block[6] = v7;
      dispatch_apply(8uLL, 0, block);
      dispatch_release(v12);
      if ((v6 & 1) == 0)
      {
LABEL_18:
        MEMORY[0x1F4188790](a1, a2);
        uint64_t v11 = (char *)block - v10;
        if ((uint64_t)a2 > 4096)
        {
          uint64_t v13 = (char *)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
          __CFSimpleMergeSort((uint64_t)v7, a2, (uint64_t)v13, a4);
          if (v11 != v13) {
            free(v13);
          }
        }
        else
        {
          __CFSimpleMergeSort((uint64_t)v7, a2, (uint64_t)block - v10, a4);
        }
        return;
      }
    }
    else
    {
      uint64_t v9 = 0;
      do
      {
        *(void *)&v7[8 * v9] = v9;
        ++v9;
      }
      while (a2 != v9);
      if ((v6 & 1) == 0) {
        goto LABEL_18;
      }
    }
    __CFSortIndexesN(v7, a2, v8, a4);
  }
}

uint64_t __CFSimpleMergeSort(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= 2)
  {
    unint64_t v5 = a2;
    char v6 = (void *)result;
    if (a2 == 3)
    {
      uint64_t v9 = *(void *)result;
      uint64_t v10 = *(void *)(result + 8);
      uint64_t v11 = *(void *)(result + 16);
      int v12 = (uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16);
      uint64_t v13 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a4 + 16))(a4, *(void *)result, v10);
      if (v13 <= 0) {
        uint64_t v14 = v9;
      }
      else {
        uint64_t v14 = v10;
      }
      if (v13 <= 0) {
        uint64_t v9 = v10;
      }
      uint64_t result = (*v12)(a4, v9, v11);
      if (result < 1)
      {
        uint64_t v15 = v9;
        uint64_t v9 = v11;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v14, v11);
        if (result <= 0) {
          uint64_t v15 = v11;
        }
        else {
          uint64_t v15 = v14;
        }
        if (result > 0) {
          uint64_t v14 = v11;
        }
      }
      void *v6 = v14;
      v6[1] = v15;
      void v6[2] = v9;
    }
    else if (a2 == 2)
    {
      uint64_t v7 = *(void *)result;
      uint64_t v8 = *(void *)(result + 8);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(a4 + 16))(a4, *(void *)result, v8);
      if (result >= 1)
      {
        void *v6 = v8;
        v6[1] = v7;
      }
    }
    else
    {
      __CFSimpleMergeSort(result, (unint64_t)a2 >> 1, a3, a4);
      unint64_t v24 = v5 >> 1;
      uint64_t result = __CFSimpleMergeSort(&v6[v5 >> 1], v5 - (v5 >> 1), a3, a4);
      if ((uint64_t)(v5 - (v5 >> 1)) >= 1)
      {
        if (v5 < 0x11
          || (uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(a4 + 16))(a4, v6[v24 - 1], v6[v24]),
              result >= 1))
        {
          unint64_t v17 = 0;
          int64_t v18 = 0;
          int64_t v19 = v5 >> 1;
          while (v19 < (uint64_t)v5)
          {
            uint64_t v20 = v6[v17];
            uint64_t v21 = v6[v19];
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v20, v21);
            if (result >= 1) {
              uint64_t v22 = v21;
            }
            else {
              uint64_t v22 = v20;
            }
            if (result < 1) {
              ++v17;
            }
            if (result > 0) {
              ++v19;
            }
            *(void *)(a3 + 8 * v18++) = v22;
            if (v17 >= v24)
            {
              do
              {
                v6[v18 - 1] = *(void *)(a3 - 8 + 8 * v18);
                --v18;
              }
              while (v18);
              return result;
            }
          }
          if (v18 < (uint64_t)v5)
          {
            uint64_t v23 = v24;
            do
              v6[--v5] = v6[--v23];
            while (v18 < (uint64_t)v5);
          }
          for (; v18; --v18)
            v6[v18 - 1] = *(void *)(a3 - 8 + 8 * v18);
        }
      }
    }
  }
  return result;
}

uint64_t __CFMergeSortArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40) + *(void *)(a1 + 48) * a2, *(void *)(a1 + 40) + *(void *)(a1 + 48) * a3, *(void *)(a1 + 56));
}

uint64_t __CFQSortArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40) + *(void *)(a1 + 48) * a2, *(void *)(a1 + 40) + *(void *)(a1 + 48) * a3, *(void *)(a1 + 56));
}

uint64_t __CFArrayCompareValues(void *a1, void *a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, void))a3)(*a1, *a2, *(void *)(a3 + 8));
}

uint64_t parseRealTag(uint64_t a1, void *a2)
{
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  CFStringRef theString1 = 0;
  if (!parseStringTag(a1, (CFMutableStringRef *)&theString1))
  {
    if (*(void *)(a1 + 24)) {
      return 0;
    }
    uint64_t v13 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty <real> on line %u", v13);
    goto LABEL_34;
  }
  CFStringRef v4 = theString1;
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v5 = 0;
    if (!theString1) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (CFStringCompare(theString1, @"nan", 1uLL) == kCFCompareEqualTo)
  {
    uint64_t v7 = (CFTypeRef *)&kCFNumberNaN;
    goto LABEL_17;
  }
  if (CFStringCompare(v4, @"+infinity", 1uLL) == kCFCompareEqualTo) {
    goto LABEL_14;
  }
  if (CFStringCompare(v4, @"-infinity", 1uLL) == kCFCompareEqualTo)
  {
LABEL_16:
    uint64_t v7 = (CFTypeRef *)&kCFNumberNegativeInfinity;
LABEL_17:
    unint64_t v5 = *v7;
    if (*v7)
    {
      CFRetain(*v7);
      if (!v4)
      {
LABEL_20:
        if (checkForCloseTag((unint64_t *)a1, (const UInt8 *)"real", 4uLL))
        {
          *a2 = v5;
          return 1;
        }
        if (v5) {
          CFRelease(v5);
        }
        return 0;
      }
LABEL_19:
      CFRelease(v4);
      goto LABEL_20;
    }
    goto LABEL_25;
  }
  if (CFStringCompare(v4, @"infinity", 1uLL) == kCFCompareEqualTo)
  {
LABEL_14:
    uint64_t v7 = (CFTypeRef *)&kCFNumberPositiveInfinity;
    goto LABEL_17;
  }
  if (CFStringCompare(v4, @"-inf", 1uLL) == kCFCompareEqualTo) {
    goto LABEL_16;
  }
  if (CFStringCompare(v4, @"inf", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v4, @"+inf", 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_14;
  }
LABEL_25:
  CFIndex Length = CFStringGetLength(v4);
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v19 = 0u;
  CFStringRef v26 = v4;
  uint64_t v29 = 0;
  CFIndex v30 = Length;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(v4);
  CStringPtr = 0;
  uint64_t v27 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v4, 0x600u);
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v28 = CStringPtr;
  int v16 = 0;
  double valuePtr = 0.0;
  if (__CFStringScanDouble(buffer, 0, &v16, &valuePtr) && Length == v16)
  {
    unint64_t v5 = CFNumberCreate(*(CFAllocatorRef *)(a1 + 32), kCFNumberDoubleType, &valuePtr);
    if (!v4) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v14 = lineNumber((unint64_t *)a1);
  CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered misformatted real on line %u", v14);
LABEL_34:
  CFErrorRef v12 = Error;
  uint64_t result = 0;
  *(void *)(a1 + 24) = v12;
  return result;
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  v6.CFIndex length = CFStringGetLength(theString1);
  v6.CFIndex location = 0;

  return CFStringCompareWithOptionsAndLocale(theString1, theString2, v6, compareOptions, 0);
}

uint64_t __CFStringScanDouble(UniChar *buffer, uint64_t a2, int *a3, double *a4)
{
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  uint64_t v31 = 0;
  int v7 = *a3;
  if (*a3 < 0) {
    goto LABEL_5;
  }
LABEL_2:
  uint64_t v8 = v7;
  uint64_t v9 = *((void *)buffer + 20);
  if (v9 > v8)
  {
    uint64_t v10 = *((void *)buffer + 17);
    if (v10)
    {
      UniChar v11 = *(_WORD *)(v10 + 2 * (*((void *)buffer + 19) + v8));
    }
    else
    {
      uint64_t v12 = *((void *)buffer + 18);
      if (v12)
      {
        UniChar v11 = *(char *)(v12 + *((void *)buffer + 19) + v8);
      }
      else
      {
        if (*((void *)buffer + 22) <= v8 || (uint64_t v13 = *((void *)buffer + 21), v13 > v8))
        {
          uint64_t v14 = v8 - 4;
          if (v8 < 4) {
            uint64_t v14 = 0;
          }
          if (v14 + 64 < v9) {
            uint64_t v9 = v14 + 64;
          }
          *((void *)buffer + 21) = v14;
          *((void *)buffer + 22) = v9;
          v34.CFIndex location = *((void *)buffer + 19) + v14;
          v34.CFIndex length = v9 - v14;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v34, buffer);
          uint64_t v13 = *((void *)buffer + 21);
        }
        UniChar v11 = buffer[v8 - v13];
      }
    }
    goto LABEL_6;
  }
LABEL_5:
  while (1)
  {
    UniChar v11 = -1;
LABEL_6:
    if (v11 != 12288
      && (unsigned __int16)(v11 - 0x2000) >= 0xCu
      && v11 >= 0x21u
      && (unsigned __int16)(v11 - 127) >= 0x22u)
    {
      break;
    }
    int v7 = *a3 + 1;
    *a3 = v7;
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_2;
    }
  }
  if (v11 >= 0x80u)
  {
    __src[0] = 0;
    uint64_t Typed = __src;
    double v28 = strtod_l(__src, &v31, 0);
  }
  else
  {
    CFIndex v30 = a4;
    int64_t v15 = 0;
    CFAllocatorRef v16 = 0;
    int v17 = 256;
    uint64_t Typed = __src;
    while (1)
    {
      size_t v19 = v15;
      if (((__CFNumberSet[v11 >> 3] >> (v11 & 7)) & 1) == 0) {
        break;
      }
      if (v15 >= v17 - 1)
      {
        if (!v16)
        {
          uint64_t v20 = _CFGetTSD(1u);
          if (v20) {
            CFAllocatorRef v16 = (const __CFAllocator *)v20;
          }
          else {
            CFAllocatorRef v16 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
          }
        }
        v17 += 256;
        if (Typed == __src)
        {
          uint64_t Typed = (char *)CFAllocatorAllocateTyped(v16, v17, 0x100004077774924, 0);
          memmove(Typed, __src, v19);
        }
        else
        {
          uint64_t Typed = (char *)__CFSafelyReallocateWithAllocatorTyped(v16, Typed, v17, 0x100004077774924, 0, 0);
        }
      }
      Typed[v19] = v11;
      signed int v21 = v19 + *a3 + 1;
      if ((v21 & 0x80000000) == 0)
      {
        uint64_t v22 = v21;
        uint64_t v23 = *((void *)buffer + 20);
        if (v23 > v21)
        {
          uint64_t v24 = *((void *)buffer + 17);
          if (v24)
          {
            UniChar v11 = *(_WORD *)(v24 + 2 * (*((void *)buffer + 19) + v21));
          }
          else
          {
            uint64_t v25 = *((void *)buffer + 18);
            if (v25)
            {
              UniChar v11 = *(char *)(v25 + *((void *)buffer + 19) + v21);
            }
            else
            {
              if (*((void *)buffer + 22) <= v21 || (uint64_t v26 = *((void *)buffer + 21), v26 > v21))
              {
                if (v21 >= 4) {
                  uint64_t v27 = v21 - 4;
                }
                else {
                  uint64_t v27 = 0;
                }
                if (v27 + 64 < v23) {
                  uint64_t v23 = v27 + 64;
                }
                *((void *)buffer + 21) = v27;
                *((void *)buffer + 22) = v23;
                v35.CFIndex location = *((void *)buffer + 19) + v27;
                v35.CFIndex length = v23 - v27;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v35, buffer);
                uint64_t v26 = *((void *)buffer + 21);
              }
              UniChar v11 = buffer[v22 - v26];
            }
          }
          int64_t v15 = v19 + 1;
          if (v11 < 0x80u) {
            continue;
          }
        }
      }
      LODWORD(v19) = v19 + 1;
      break;
    }
    Typed[v19] = 0;
    double v28 = strtod_l(Typed, &v31, 0);
    if (v16) {
      CFAllocatorDeallocate(v16, Typed);
    }
    a4 = v30;
  }
  if (Typed == v31) {
    return 0;
  }
  *a3 += v31 - Typed;
  if (a4) {
    *a4 = v28;
  }
  return 1;
}

uint64_t parseDictTag(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  char v33 = 0;
  CFTypeRef v31 = 0;
  CFTypeRef cf = 0;
  if (*(unsigned char *)(a1 + 80))
  {
    while (getContentObject((unint64_t *)a1, &v33, (uint64_t)&cf, a3))
    {
      if (!v33)
      {
        if (*(void *)(a1 + 24)) {
          return 0;
        }
        uint64_t v26 = lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Found non-key inside <dict> at line %u", v26);
LABEL_49:
        CFErrorRef v18 = Error;
        uint64_t result = 0;
        *(void *)(a1 + 24) = v18;
        return result;
      }
      if (!getContentObject((unint64_t *)a1, 0, (uint64_t)&v31, a3))
      {
        if (*(void *)(a1 + 24)) {
          return 0;
        }
        uint64_t v27 = lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Value missing for key inside <dict> at line %u", v27);
        goto LABEL_49;
      }
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0;
      if (v31) {
        CFRelease(v31);
      }
      CFTypeRef v31 = 0;
    }
    uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"dict", 4uLL);
    if (!result) {
      return result;
    }
    *a2 = 0;
    return 1;
  }
  CFSetRef v6 = *(const __CFSet **)(a1 + 72);
  CFTypeRef v29 = 0;
  CFTypeRef v30 = 0;
  __CFPropertyListCreateSplitKeypaths(*(const __CFAllocator **)(a1 + 32), v6, (__CFSet **)&v29, (__CFSet **)&v30);
  CFDictionaryRef v7 = 0;
  if (!getContentObject((unint64_t *)a1, &v33, (uint64_t)&cf, a3) || (CFTypeRef v8 = cf) == 0)
  {
LABEL_31:
    if (v30) {
      CFRelease(v30);
    }
    if (v29) {
      CFRelease(v29);
    }
    if (*(void *)(a1 + 24) || !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"dict", 4uLL)) {
      goto LABEL_66;
    }
    if (v7)
    {
      if (CFDictionaryGetCount(v7) == 1)
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v7, @"CF$UID");
        if (Value)
        {
          CFNumberRef v14 = Value;
          if (CFGetTypeID(Value) == 22)
          {
            int valuePtr = 0;
            CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr);
            uint64_t v15 = _CFKeyedArchiverUIDCreate(*(__objc2_class ***)(a1 + 32), valuePtr);
            CFRelease(v7);
            *a2 = v15;
            return 1;
          }
        }
      }
      int v22 = allowImmutableCollections;
      if (allowImmutableCollections == -1)
      {
        int v22 = getenv("CFPropertyListAllowImmutableCollections") != 0;
        allowImmutableCollections = v22;
      }
      if (v22 == 1 && !*(_DWORD *)(a1 + 40))
      {
        CFDictionaryRef Copy = CFDictionaryCreateCopy(*(CFAllocatorRef *)(a1 + 32), v7);
        CFRelease(v7);
        CFDictionaryRef v7 = Copy;
      }
    }
    else
    {
      CFAllocatorRef v24 = *(const __CFAllocator **)(a1 + 32);
      if (*(_DWORD *)(a1 + 40)) {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v24, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      else {
        CFMutableDictionaryRef Mutable = CFDictionaryCreate(v24, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      CFDictionaryRef v7 = Mutable;
    }
    *a2 = v7;
    return 1;
  }
  CFDictionaryRef v7 = 0;
  while (1)
  {
    if (!v33)
    {
      if (*(void *)(a1 + 24)
        || (uint64_t v19 = lineNumber((unint64_t *)a1),
            *(void *)(a1 + 24) = __CFPropertyListCreateError(3840, @"Found non-key inside <dict> at line %u", v19), (CFTypeRef v8 = cf) != 0))
      {
        CFRelease(v8);
      }
      if (v30) {
        CFRelease(v30);
      }
      CFTypeRef v20 = v29;
      if (v29) {
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    CFTypeRef v9 = v29;
    if (v29) {
      break;
    }
    if (!getContentObject((unint64_t *)a1, 0, (uint64_t)&v31, a3)) {
      goto LABEL_57;
    }
LABEL_20:
    CFTypeRef v11 = cf;
    if (cf)
    {
      CFTypeRef v12 = v31;
      if (v31)
      {
        if (!v7)
        {
          CFDictionaryRef v7 = CFDictionaryCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          _CFDictionarySetCapacity((unint64_t)v7, 10);
          CFTypeRef v12 = v31;
          CFTypeRef v11 = cf;
        }
        CFDictionarySetValue(v7, v11, v12);
        CFTypeRef v11 = cf;
      }
    }
    if (v11) {
      CFRelease(v11);
    }
    CFTypeRef cf = 0;
    if (v31) {
      CFRelease(v31);
    }
    CFTypeRef v31 = 0;
    if (getContentObject((unint64_t *)a1, &v33, (uint64_t)&cf, a3))
    {
      CFTypeRef v8 = cf;
      if (cf) {
        continue;
      }
    }
    goto LABEL_31;
  }
  if (!__CFPropertyListKeyPassesFilterSet((uint64_t)v8, (void *)v29)) {
    *(unsigned char *)(a1 + 80) = 1;
  }
  *(void *)(a1 + 72) = v30;
  Contentuint64_t Object = getContentObject((unint64_t *)a1, 0, (uint64_t)&v31, a3);
  *(void *)(a1 + 72) = v6;
  *(unsigned char *)(a1 + 80) = 0;
  if (ContentObject) {
    goto LABEL_20;
  }
LABEL_57:
  if (!*(void *)(a1 + 24))
  {
    uint64_t v21 = lineNumber((unint64_t *)a1);
    *(void *)(a1 + 24) = __CFPropertyListCreateError(3840, @"Value missing for key inside <dict> at line %u", v21);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v9)
  {
    CFTypeRef v20 = v9;
LABEL_65:
    CFRelease(v20);
  }
LABEL_66:
  if (v7) {
    CFRelease(v7);
  }
  return 0;
}

uint64_t getContentObject(unint64_t *a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4 >= 0x81)
  {
    uint64_t v16 = lineNumber(a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Too many nested arrays or dictionaries, failing on line %u", v16);
LABEL_26:
    a1[3] = (unint64_t)Error;
    return 0;
  }
  if (a2) {
    *a2 = 0;
  }
  if (a1[3]) {
    return 0;
  }
  while (2)
  {
    CFTypeRef v9 = (char *)a1[1];
    unint64_t v10 = a1[2];
    if ((unint64_t)v9 >= v10) {
      return 0;
    }
    unint64_t v11 = v10 - (void)v9;
    while (1)
    {
      uint64_t v12 = *v9;
      if (v12 > 0x20 || ((1 << *v9) & 0x100002600) == 0) {
        break;
      }
      a1[1] = (unint64_t)++v9;
      if (!--v11) {
        goto LABEL_25;
      }
    }
    if (v12 != 60)
    {
      uint64_t v17 = lineNumber(a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected character %c on line %u while looking for open tag", v12, v17);
      goto LABEL_26;
    }
    a1[1] = (unint64_t)(v9 + 1);
    if ((unint64_t)(v9 + 1) >= v10) {
      goto LABEL_25;
    }
    int v14 = v9[1];
    switch(v14)
    {
      case '!':
        if ((unint64_t)(v9 + 3) < v10 && v9[2] == 45 && v9[3] == 45)
        {
          a1[1] = (unint64_t)(v9 + 4);
          skipXMLComment(a1);
LABEL_23:
          if (!a1[3]) {
            continue;
          }
          return 0;
        }
LABEL_25:
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected EOF");
        goto LABEL_26;
      case '?':
        skipXMLProcessingInstruction(a1);
        goto LABEL_23;
      case '/':
        a1[1] = (unint64_t)v9;
        return 0;
    }
  }

  return parseXMLElement(a1, a2, a3, a4);
}

uint64_t parseXMLElement(uint64_t a1, unsigned char *a2, CFTypeRef *a3, uint64_t a4)
{
  CFSetRef v6 = *(unsigned __int8 **)(a1 + 8);
  CFDictionaryRef v7 = v6;
  if (a2)
  {
    *a2 = 0;
    CFDictionaryRef v7 = *(unsigned __int8 **)(a1 + 8);
  }
  CFTypeRef v8 = *(unsigned __int8 **)(a1 + 16);
  if (v7 >= v8)
  {
    int v11 = -1;
  }
  else
  {
    uint64_t v9 = v8 - v7;
    int v10 = v7 - v6;
    int v11 = -1;
    do
    {
      uint64_t v12 = *v7;
      if (v12 <= 0x3E)
      {
        if (((1 << v12) & 0x100002600) != 0)
        {
          if (v11 == -1) {
            int v11 = v10;
          }
        }
        else if (v12 == 62)
        {
          goto LABEL_14;
        }
      }
      *(void *)(a1 + 8) = ++v7;
      ++v10;
      --v9;
    }
    while (v9);
    CFDictionaryRef v7 = v8;
  }
LABEL_14:
  if (v7 >= v8) {
    return 0;
  }
  int v13 = *(v7 - 1);
  if (v11 == -1) {
    int v11 = v7 - (v13 == 47) - v6;
  }
  *(void *)(a1 + 8) = v7 + 1;
  if (v11)
  {
    int v14 = -1;
    BOOL v15 = 1;
    size_t v16 = 6;
    BOOL v17 = 1;
    int v18 = 1;
    BOOL v19 = 1;
    int v20 = 1;
    int v21 = 1;
    switch(*v6)
    {
      case 'a':
        if (v11 != 5) {
          goto LABEL_65;
        }
        int v22 = *(_DWORD *)v6 ^ 0x61727261 | v6[4] ^ 0x79;
        BOOL v17 = v22 != 0;
        if (v22) {
          int v14 = -1;
        }
        else {
          int v14 = 1;
        }
        BOOL v15 = 1;
        goto LABEL_49;
      case 'd':
        if (v11 != 4) {
          goto LABEL_65;
        }
        if (*(_DWORD *)v6 == 1952672100)
        {
          int v18 = 0;
          int v14 = 2;
          goto LABEL_64;
        }
        size_t v16 = 6;
        if (*(_DWORD *)v6 == 1635017060)
        {
          int v21 = 0;
          int v14 = 5;
        }
        else if (*(_DWORD *)v6 == 1702125924)
        {
          int v14 = 6;
        }
        else
        {
          int v14 = -1;
        }
        BOOL v15 = 1;
        goto LABEL_77;
      case 'f':
        if (v11 != 5) {
          goto LABEL_65;
        }
        BOOL v24 = (*(_DWORD *)v6 ^ 0x736C6166 | v6[4] ^ 0x65) == 0;
        int v25 = 10;
        goto LABEL_54;
      case 'i':
        if (v11 != 7) {
          goto LABEL_65;
        }
        BOOL v24 = (*(_DWORD *)v6 ^ 0x65746E69 | *(_DWORD *)(v6 + 3) ^ 0x72656765) == 0;
        int v25 = 8;
        goto LABEL_54;
      case 'k':
        if (v11 != 3) {
          goto LABEL_65;
        }
        if (*(_WORD *)v6 != 25963 || v6[2] != 121) {
          goto LABEL_57;
        }
        BOOL v15 = 1;
        int v20 = 0;
        size_t v16 = 3;
        if (a2) {
          *a2 = 1;
        }
        BOOL v17 = 1;
        int v18 = 1;
        int v14 = 3;
        goto LABEL_66;
      case 'p':
        if (v11 != 5) {
          goto LABEL_65;
        }
        int v27 = *(_DWORD *)v6 ^ 0x73696C70 | v6[4] ^ 0x74;
        BOOL v24 = v27 == 0;
        BOOL v15 = v27 != 0;
        if (v24) {
          int v14 = 0;
        }
        else {
          int v14 = -1;
        }
        BOOL v17 = 1;
LABEL_49:
        size_t v16 = 6;
        goto LABEL_58;
      case 'r':
        if (v11 != 4) {
          goto LABEL_65;
        }
        BOOL v28 = *(_DWORD *)v6 == 1818322290;
        int v29 = 7;
        goto LABEL_61;
      case 's':
        if (v11 != 6) {
          goto LABEL_65;
        }
        int v30 = *(_DWORD *)v6 ^ 0x69727473 | *((unsigned __int16 *)v6 + 2) ^ 0x676E;
        BOOL v24 = v30 == 0;
        BOOL v19 = v30 != 0;
        int v25 = 4;
LABEL_54:
        if (v24) {
          int v14 = v25;
        }
        else {
          int v14 = -1;
        }
LABEL_57:
        BOOL v15 = 1;
        size_t v16 = 6;
        BOOL v17 = 1;
LABEL_58:
        int v18 = 1;
        goto LABEL_66;
      case 't':
        if (v11 == 4)
        {
          BOOL v28 = *(_DWORD *)v6 == 1702195828;
          int v29 = 9;
LABEL_61:
          if (v28) {
            int v14 = v29;
          }
          else {
            int v14 = -1;
          }
LABEL_64:
          BOOL v15 = 1;
          size_t v16 = 6;
LABEL_77:
          BOOL v17 = 1;
          if (!v21) {
            goto LABEL_78;
          }
        }
        else
        {
LABEL_65:
          size_t v16 = 6;
        }
LABEL_66:
        if (v20 && v19 && v18 && v17 && v15 && !*(unsigned char *)(a1 + 64))
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered new tag when expecting only old-style property list objects");
          goto LABEL_73;
        }
LABEL_78:
        switch(v14)
        {
          case 0:
            if (v13 == 47)
            {
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty plist tag");
              goto LABEL_73;
            }
            return parsePListTag((unint64_t *)a1, a3, a4 + 1);
          case 1:
            if (v13 == 47)
            {
              if (*(unsigned char *)(a1 + 80)) {
                goto LABEL_99;
              }
              int v40 = *(_DWORD *)(a1 + 40);
              CFAllocatorRef v41 = *(const __CFAllocator **)(a1 + 32);
              if (v40) {
                CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v41, 0, &kCFTypeArrayCallBacks);
              }
              else {
                CFMutableDictionaryRef Mutable = CFArrayCreate(v41, 0, 0, &kCFTypeArrayCallBacks);
              }
              goto LABEL_150;
            }
            return parseArrayTag(a1, (CFArrayRef *)a3, a4 + 1);
          case 2:
            if (v13 == 47)
            {
              if (*(unsigned char *)(a1 + 80)) {
                goto LABEL_99;
              }
              int v43 = *(_DWORD *)(a1 + 40);
              CFAllocatorRef v44 = *(const __CFAllocator **)(a1 + 32);
              if (v43) {
                CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v44, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              }
              else {
                CFMutableDictionaryRef Mutable = CFDictionaryCreate(v44, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              }
              goto LABEL_150;
            }
            return parseDictTag(a1, a3, a4 + 1);
          case 3:
          case 4:
            if (v13 == 47)
            {
              if (*(unsigned char *)(a1 + 80))
              {
LABEL_99:
                *a3 = 0;
                goto LABEL_151;
              }
              int v33 = *(_DWORD *)(a1 + 40);
              CFAllocatorRef v34 = *(const __CFAllocator **)(a1 + 32);
              if (v33 == 2) {
                CFMutableDictionaryRef Mutable = CFStringCreateMutable(v34, 0);
              }
              else {
                CFMutableDictionaryRef Mutable = (void *)CFStringCreateWithCharacters(v34, 0, 0);
              }
              goto LABEL_150;
            }
            uint64_t result = parseStringTag(a1, (CFMutableStringRef *)a3);
            if (result)
            {
              if (checkForCloseTag((unint64_t *)a1, &CFXMLPlistTags[10 * v14], v16)) {
                goto LABEL_151;
              }
              uint64_t result = (uint64_t)*a3;
              if (*a3) {
                goto LABEL_88;
              }
            }
            return result;
          case 5:
            if (v13 == 47)
            {
              uint64_t v46 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty <data> on line %u", v46);
              goto LABEL_73;
            }
            return parseDataTag(a1, (__CFData **)a3);
          case 6:
            if (v13 == 47)
            {
              uint64_t v47 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty <date> on line %u", v47);
              goto LABEL_73;
            }
            return parseDateTag(a1, (CFDateRef *)a3);
          case 7:
            if (v13 == 47)
            {
              uint64_t v48 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty <real> on line %u", v48);
              goto LABEL_73;
            }
            return parseRealTag(a1, a3);
          case 8:
            if (v13 == 47)
            {
              uint64_t v49 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty <integer> on line %u", v49);
              goto LABEL_73;
            }
            return parseIntegerTag(a1, (CFNumberRef *)a3);
          case 9:
            if (v13 != 47 && !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"true", 4uLL))
            {
              uint64_t v50 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered non-empty <true> on line %u", v50);
              goto LABEL_73;
            }
            if (*(unsigned char *)(a1 + 80)) {
              goto LABEL_115;
            }
            uint64_t v42 = (CFTypeRef *)&kCFBooleanTrue;
            goto LABEL_142;
          case 10:
            if (v13 != 47 && !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"false", 5uLL))
            {
              uint64_t v51 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered non-empty <false> on line %u", v51);
              goto LABEL_73;
            }
            if (*(unsigned char *)(a1 + 80))
            {
LABEL_115:
              CFMutableDictionaryRef Mutable = 0;
            }
            else
            {
              uint64_t v42 = (CFTypeRef *)&kCFBooleanFalse;
LABEL_142:
              CFMutableDictionaryRef Mutable = (void *)CFRetain(*v42);
            }
LABEL_150:
            *a3 = Mutable;
LABEL_151:
            uint64_t result = 1;
            break;
          default:
            CFStringRef v36 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, v11, 0x8000100u, 0);
            CFStringRef v37 = v36;
            *(void *)(a1 + 8) = v6;
            if (v36) {
              uint64_t v38 = (__CFString *)v36;
            }
            else {
              uint64_t v38 = @"<unknown>";
            }
            uint64_t v39 = lineNumber((unint64_t *)a1);
            *(void *)(a1 + 24) = __CFPropertyListCreateError(3840, @"Encountered unknown tag %@ on line %u", v38, v39);
            if (!v37) {
              return 0;
            }
            uint64_t result = (uint64_t)v37;
LABEL_88:
            CFRelease((CFTypeRef)result);
            return 0;
        }
        break;
      default:
        goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 8) = v6;
    uint64_t v45 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Malformed tag on line %u", v45);
LABEL_73:
    CFErrorRef v31 = Error;
    uint64_t result = 0;
    *(void *)(a1 + 24) = v31;
  }
  return result;
}

uint64_t checkForCloseTag(unint64_t *a1, const UInt8 *a2, size_t a3)
{
  CFStringRef v4 = (unsigned __int8 *)a1[1];
  unint64_t v5 = (unsigned __int8 *)a1[2];
  if (v5 - v4 < (uint64_t)(a3 + 3)) {
    goto LABEL_27;
  }
  int v7 = *v4;
  if (v7 != 60 || (a1[1] = (unint64_t)(v4 + 1), int v7 = v4[1], v7 != 47))
  {
    if (!a1[3])
    {
      uint64_t v21 = lineNumber(a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected character %c on line %u while looking for close tag", (char)v7, v21);
      goto LABEL_13;
    }
    return 0;
  }
  int v10 = v4 + 2;
  a1[1] = (unint64_t)(v4 + 2);
  if (memcmp(v4 + 2, a2, a3))
  {
    CFStringRef v11 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, a3, 0x8000100u, 0);
    if (!a1[3])
    {
      uint64_t v12 = lineNumber(a1);
      a1[3] = (unint64_t)__CFPropertyListCreateError(3840, @"Close tag on line %u does not match open tag %@", v12, v11);
    }
    CFRelease(v11);
    return 0;
  }
  BOOL v15 = &v10[a3];
  for (a1[1] = (unint64_t)&v10[a3]; v15 < v5; a1[1] = (unint64_t)v15)
  {
    unsigned int v16 = (char)*v15;
    BOOL v17 = v16 > 0x20;
    uint64_t v18 = (1 << v16) & 0x100002600;
    if (v17 || v18 == 0) {
      break;
    }
    ++v15;
  }
  if (v15 == v5)
  {
LABEL_27:
    if (!a1[3])
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected EOF");
LABEL_13:
      CFErrorRef v14 = Error;
      uint64_t result = 0;
      a1[3] = (unint64_t)v14;
      return result;
    }
    return 0;
  }
  if (*v15 != 62)
  {
    if (!a1[3])
    {
      uint64_t v20 = (char)*v15;
      uint64_t v22 = lineNumber(a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected character %c on line %u while looking for close tag", v20, v22);
      goto LABEL_13;
    }
    return 0;
  }
  a1[1] = (unint64_t)(v15 + 1);
  return 1;
}

uint64_t parseStringTag(uint64_t a1, CFMutableStringRef *a2)
{
  uint64_t v58 = *(void *)off_1ECE0A5B0;
  if (*(void *)(a1 + 24)) {
    return 0;
  }
  CFMutableDictionaryRef Mutable = 0;
  CFSetRef v6 = *(UInt8 **)(a1 + 8);
  int v7 = v6;
  while (1)
  {
    unint64_t v8 = *(void *)(a1 + 16);
    if ((unint64_t)v6 >= v8) {
      break;
    }
    int v9 = *v6;
    if (v9 == 38)
    {
      if (!Mutable)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
        CFSetRef v6 = *(UInt8 **)(a1 + 8);
      }
      CFDataAppendBytes(Mutable, v7, v6 - v7);
      CFErrorRef v14 = *(unsigned char **)(a1 + 8);
      unint64_t v15 = *(void *)(a1 + 16);
      *(void *)(a1 + 8) = v14 + 1;
      unsigned int v16 = v15 - (v14 + 1);
      if ((int)v16 <= 0) {
        goto LABEL_72;
      }
      int v17 = (char)v14[1];
      if (v17 <= 102)
      {
        if (v17 == 35)
        {
          if (v16 > 3)
          {
            uint64_t v26 = v14 + 2;
            *(void *)(a1 + 8) = v14 + 2;
            int v27 = v14[2];
            if (v27 == 120)
            {
              uint64_t v26 = v14 + 3;
              *(void *)(a1 + 8) = v14 + 3;
            }
            if ((unint64_t)v26 < v15)
            {
              uint64_t v28 = 0;
              unsigned int v29 = 0;
              unint64_t v30 = v15 - (void)v26;
              while (1)
              {
                uint64_t v31 = (char)v26[v28];
                *(void *)(a1 + 8) = &v26[v28 + 1];
                if (v31 == 59) {
                  break;
                }
                if (v28 == 8)
                {
                  usedBufLend = (CFIndex *)lineNumber((unint64_t *)a1);
                  CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unparseable unicode sequence at line %u while parsing data (too large of a value for a Unicode sequence)", usedBufLend, v53, *(void *)bytes);
                  goto LABEL_81;
                }
                int v32 = 16 * v29;
                if ((v31 - 48) > 9)
                {
                  if (v27 != 120) {
                    goto LABEL_89;
                  }
                  if ((v31 - 97) > 5)
                  {
                    if ((v31 - 65) > 5)
                    {
LABEL_89:
                      uint64_t v54 = lineNumber((unint64_t *)a1);
                      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected character %c at line %u while parsing data", v31, v54, *(void *)bytes);
                      goto LABEL_81;
                    }
                    unsigned int v29 = v32 + v31 - 55;
                  }
                  else
                  {
                    unsigned int v29 = v32 + v31 - 87;
                  }
                }
                else
                {
                  int v33 = 10 * v29;
                  if (v27 == 120) {
                    int v33 = v32;
                  }
                  unsigned int v29 = v31 + v33 - 48;
                }
                *(_DWORD *)uint64_t v56 = v29;
                if (v30 == ++v28) {
                  goto LABEL_72;
                }
              }
              *(_DWORD *)uint64_t v56 = bswap32(v29);
              CFStringRef v34 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), v56, 4, 0x18000100u, 0);
              if (v34)
              {
                CFStringRef v35 = v34;
                *(void *)bytes = 0;
                v59.CFIndex length = CFStringGetLength(v34);
                v59.CFIndex location = 0;
                CFStringGetBytes(v35, v59, 0x8000100u, 0, 0, buffer, 6, (CFIndex *)bytes);
                CFDataAppendBytes(Mutable, buffer, *(CFIndex *)bytes);
                CFRelease(v35);
                goto LABEL_82;
              }
              usedBufLene = (CFIndex *)lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unparseable Unicode sequence at line %u while parsing data (input did not result in a real string)", usedBufLene, v53, *(void *)bytes);
              goto LABEL_81;
            }
          }
          goto LABEL_72;
        }
        if (v17 != 97) {
          goto LABEL_80;
        }
        if (v16 <= 3) {
          goto LABEL_72;
        }
        int v19 = v14[2];
        if (v19 != 109)
        {
          if (v16 < 5 || v19 != 112 || v14[3] != 111 || v14[4] != 115 || v14[5] != 59) {
            goto LABEL_80;
          }
          UInt8 v25 = 39;
          goto LABEL_79;
        }
        if (v14[3] != 112 || v14[4] != 59) {
          goto LABEL_80;
        }
        bytes[0] = 38;
        uint64_t v20 = 5;
      }
      else if (v17 == 103)
      {
        if (v16 < 3 || v14[2] != 116 || v14[3] != 59) {
          goto LABEL_80;
        }
        UInt8 v18 = 62;
LABEL_47:
        bytes[0] = v18;
        uint64_t v20 = 4;
      }
      else
      {
        if (v17 != 113)
        {
          if (v17 == 108 && v16 >= 3 && v14[2] == 116 && v14[3] == 59)
          {
            UInt8 v18 = 60;
            goto LABEL_47;
          }
LABEL_80:
          usedBufLenc = (CFIndex *)lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unknown ampersand-escape sequence at line %u", usedBufLenc, v53, *(void *)bytes);
          goto LABEL_81;
        }
        if (v16 < 5 || v14[2] != 117 || v14[3] != 111 || v14[4] != 116 || v14[5] != 59) {
          goto LABEL_80;
        }
        UInt8 v25 = 34;
LABEL_79:
        bytes[0] = v25;
        uint64_t v20 = 6;
      }
      *(void *)(a1 + 8) = &v14[v20];
      CFDataAppendBytes(Mutable, bytes, 1);
      goto LABEL_82;
    }
    if (v9 == 60)
    {
      if ((unint64_t)(v6 + 1) >= v8 || v6[1] != 33) {
        break;
      }
      if (!Mutable)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
        CFSetRef v6 = *(UInt8 **)(a1 + 8);
      }
      CFDataAppendBytes(Mutable, v7, v6 - v7);
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(void *)(a1 + 16);
      if (v11 - v10 > 8)
      {
        if (*(void *)v10 != 0x41544144435B213CLL || *(unsigned char *)(v10 + 8) != 91)
        {
          usedBufLena = (CFIndex *)lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered improper CDATA opening at line %u", usedBufLena, v53, *(void *)bytes);
          goto LABEL_81;
        }
        uint64_t v21 = (const UInt8 *)(v10 + 9);
        *(void *)(a1 + 8) = v10 + 9;
        if (v10 + 9 < (unint64_t)(v11 - 2))
        {
          CFIndex v22 = 0;
          uint64_t v23 = v11 - v10 - 11;
          while (1)
          {
            CFIndex v24 = v10 + v22;
            if (*(unsigned char *)(v10 + v22 + 9) == 93 && *(unsigned char *)(v24 + 10) == 93 && *(unsigned char *)(v10 + v22 + 11) == 62) {
              break;
            }
            *(void *)(a1 + 8) = v24 + 10;
            if (v23 == ++v22) {
              goto LABEL_42;
            }
          }
          CFDataAppendBytes(Mutable, v21, v22);
          *(void *)(a1 + 8) += 3;
          goto LABEL_82;
        }
LABEL_42:
        *(void *)(a1 + 8) = v21;
        usedBufLenb = (CFIndex *)lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Could not find end of CDATA started on line %u", usedBufLenb, v53, *(void *)bytes);
LABEL_81:
        *(void *)(a1 + 24) = Error;
LABEL_82:
        CFSetRef v6 = *(UInt8 **)(a1 + 8);
        int v7 = v6;
        goto LABEL_83;
      }
LABEL_72:
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected EOF", usedBufLen, v53, *(void *)bytes);
      goto LABEL_81;
    }
    *(void *)(a1 + 8) = ++v6;
LABEL_83:
    if (*(void *)(a1 + 24))
    {
      if (Mutable) {
        CFRelease(Mutable);
      }
      return 0;
    }
  }
  if (!Mutable)
  {
    if (*(unsigned char *)(a1 + 80))
    {
      *a2 = 0;
      return 1;
    }
    if (*(_DWORD *)(a1 + 40) != 2)
    {
      UniqueStringWithUTF8CFIndex Bytes = (__CFString *)_createUniqueStringWithUTF8Bytes(a1, v7, v6 - v7);
      if (!UniqueStringWithUTF8Bytes) {
        goto LABEL_112;
      }
      *a2 = UniqueStringWithUTF8Bytes;
      return 1;
    }
    CFStringRef v41 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), v7, v6 - v7, 0x8000100u, 0);
    if (!v41) {
      goto LABEL_112;
    }
    CFMutableDictionaryRef Mutable = (__CFData *)v41;
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(*(CFAllocatorRef *)(a1 + 32), 0, v41);
LABEL_105:
    *a2 = MutableCopy;
LABEL_106:
    CFRelease(Mutable);
    return 1;
  }
  if (*(unsigned char *)(a1 + 80))
  {
    *a2 = 0;
    goto LABEL_106;
  }
  CFDataAppendBytes(Mutable, v7, v6 - v7);
  if (*(_DWORD *)(a1 + 40) != 2)
  {
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(Mutable);
    CFIndex Length = CFDataGetLength(Mutable);
    MutableCFDictionaryRef Copy = (__CFString *)_createUniqueStringWithUTF8Bytes(a1, BytePtr, Length);
    if (!MutableCopy) {
      goto LABEL_109;
    }
    goto LABEL_105;
  }
  CFAllocatorRef v36 = *(const __CFAllocator **)(a1 + 32);
  CFStringRef v37 = CFDataGetBytePtr(Mutable);
  CFIndex v38 = CFDataGetLength(Mutable);
  CFStringRef v39 = CFStringCreateWithBytes(v36, v37, v38, 0x8000100u, 0);
  if (v39)
  {
    CFStringRef v40 = v39;
    *a2 = CFStringCreateMutableCopy(*(CFAllocatorRef *)(a1 + 32), 0, v39);
    CFRelease(v40);
    goto LABEL_106;
  }
LABEL_109:
  CFRelease(Mutable);
LABEL_112:
  CFErrorRef v46 = __CFPropertyListCreateError(3840, @"Unable to convert string to correct encoding");
  uint64_t result = 0;
  *(void *)(a1 + 24) = v46;
  return result;
}

CFTypeRef _createUniqueStringWithUTF8Bytes(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  if (a3)
  {
    unsigned int v9 = 0;
    if (CFBurstTrieContainsUTF8String(*(void *)(a1 + 48), a2, a3, &v9)) {
      BOOL v6 = v9 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6)
    {
      CFStringRef ValueAtIndex = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), a2, a3, 0x8000100u, 0);
      if (ValueAtIndex)
      {
        unsigned int v9 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) + 1;
        if (CFBurstTrieAddUTF8String(*(void *)(a1 + 48), (uint64_t)a2, a3, v9)) {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), ValueAtIndex);
        }
      }
    }
    else
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v9 - 1);
      CFRetain(ValueAtIndex);
    }
    return ValueAtIndex;
  }
  else
  {
    return CFRetain(&stru_1ECE10768);
  }
}

uint64_t CFBurstTrieContainsUTF8String(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (a3 > 1023) {
    return 0;
  }
  int v7 = *(_DWORD **)(a1 + 2056);
  if (!v7) {
    goto LABEL_15;
  }
  int v8 = *(_DWORD *)(a1 + 2072);
  if (*v7 == -1161889074)
  {
    uint64_t v9 = (uint64_t)v7 + v7[1];
    return burstTrieMappedFind(v9, (uint64_t)v7, (uint64_t)a2, a3, a4, (v8 & 8) != 0);
  }
  if ((v8 & 0x18) == 0)
  {
LABEL_15:
    traverseCFBurstTrieWithCursor(a1, (uint64_t)a2);
    return 0;
  }
  char v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  CFBurstTrieSetCursorForBytes(a1, (uint64_t)&v13, a2, a3);
  int v12 = v11;
  uint64_t result = 0;
  if (!v12 || *(void *)((char *)&v14 + 1) != 1) {
    return result;
  }
  if (!HIDWORD(v13)) {
    return 0;
  }
  if (a4) {
    *a4 = HIDWORD(v13);
  }
  return 1;
}

size_t traverseCFBurstTrieWithCursor(uint64_t a1, uint64_t a2)
{
  size_t result = MEMORY[0x1F4188790](a1, a2);
  int v8 = v7;
  uint64_t v9 = v6;
  uint64_t v10 = v5;
  uint64_t v51 = *(void *)off_1ECE0A5B0;
  uint64_t v11 = *(void *)(result + 2056);
  if (v11)
  {
    if ((*(unsigned char *)(result + 2072) & 8) != 0)
    {
      int v19 = *(FILE **)off_1ECE0A5B8;
      return fwrite("Please use CFBurstTrieCursorRef API for file based trie.\n", 0x39uLL, 1uLL, v19);
    }
    else
    {
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      *(_OWORD *)&v21[16] = 0u;
      long long v22 = 0u;
      long long v20 = 0u;
      *(_OWORD *)uint64_t v21 = 0u;
      int v12 = *(_DWORD *)(v11 + 4);
      *(void *)&v21[12] = v3;
      *(_DWORD *)uint64_t v21 = v12;
      *(void *)&v21[4] = v4;
      return findCFBurstTrieMappedLevel(result, (uint64_t)&v20, v5, v6, v7);
    }
  }
  else
  {
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    *(_DWORD *)&v21[8] = 0;
    uint64_t v13 = result | 1;
    *(void *)uint64_t v21 = result | 1;
    *(_OWORD *)&v21[16] = v3;
    *(_DWORD *)&v21[12] = v4;
    if (v4)
    {
      uint64_t v14 = 0;
      while (1)
      {
        uint64_t v15 = *(unsigned __int8 *)(v3 + v14);
        uint64_t v13 = *(void *)((v13 & 0xFFFFFFFFFFFFFFFCLL) + 8 * v15);
        *(void *)uint64_t v21 = v13;
        v21[v14 + 24] = v15;
        if ((v13 & 3) != 1) {
          break;
        }
        if (v4 == ++v14) {
          goto LABEL_8;
        }
      }
      if ((v13 & 3) == 2)
      {
        *(_DWORD *)&v21[8] = v14 + 1;
        return findCFBurstTrieList((uint64_t)&v20, v6, v7);
      }
    }
    else
    {
LABEL_8:
      *(_DWORD *)&v21[8] = v4;
      unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v17 = *(unsigned int *)((v13 & 0xFFFFFFFFFFFFFFFCLL) + 2052);
      unsigned int v18 = v4;
      if (v17)
      {
        size_t result = ((uint64_t (*)(uint64_t, unsigned char *, uint64_t, uint64_t))v7)(v6, &v21[24], v17, 1);
        if (result) {
          return result;
        }
        unsigned int v18 = *(_DWORD *)&v21[8];
        unsigned int v4 = *(_DWORD *)&v21[12];
      }
      if (v18 != v4 || (v10 & 1) == 0) {
        return traverseCFBurstTrieLevel(v16, (uint64_t)&v20, v10, v9, v8);
      }
    }
  }
  return result;
}

uint64_t findCFBurstTrieList(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  uint64_t v3 = *(void *)(result + 16);
  size_t v4 = (*(_DWORD *)(result + 28) - *(_DWORD *)(result + 24));
  if ((int)v4 >= 1) {
    int v5 = *(_DWORD *)(result + 28) - *(_DWORD *)(result + 24);
  }
  else {
    int v5 = 0;
  }
  unint64_t v6 = v3 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v3 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    uint64_t v9 = result;
    uint64_t v10 = result + 40;
    do
    {
      size_t v11 = *(unsigned __int16 *)(v6 + 16);
      if (v5 <= (int)v11)
      {
        uint64_t v12 = *(unsigned int *)(v9 + 24);
        if ((int)v4 <= 0
          || (size_t result = memcmp((const void *)(v6 + 18), (const void *)(*(void *)(v9 + 32) + v12), v4), !result))
        {
          size_t result = (uint64_t)memcpy((void *)(v10 + v12), (const void *)(v6 + 18), v11);
          *(unsigned char *)(v9 + *(_DWORD *)(v9 + 24) + *(unsigned __int16 *)(v6 + 16) + 40) = 0;
          *(void *)(v9 + 16) = v6;
          if (*(_DWORD *)(v6 + 12))
          {
            size_t result = a3(a2, v10);
            if (result) {
              break;
            }
          }
        }
      }
      unint64_t v6 = *(void *)v6;
    }
    while (v6);
  }
  return result;
}

uint64_t containsKey(_DWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a4) {
    *a1 = a3;
  }
  return a4;
}

uint64_t CFBurstTrieAddUTF8StringWithWeight(unint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  BOOL v6 = a3 >= 4096 || *(void *)(a1 + 2056) != 0 || a5 == 0;
  uint64_t v7 = !v6;
  if (v6) {
    return v7;
  }
  unint64_t v8 = a1;
  unint64_t v9 = a1;
  if (!a3)
  {
LABEL_15:
    int v13 = *(_DWORD *)(v9 + 2048);
    *(_DWORD *)(v9 + 2048) = v13 + a4;
    *(_DWORD *)(v9 + 2052) = a5;
    if (v13) {
      return v7;
    }
LABEL_34:
    ++*(_DWORD *)(v8 + 2076);
    return v7;
  }
  uint64_t v11 = 0;
  unint64_t v9 = a1;
  while (1)
  {
    uint64_t v12 = *(void *)(v9 + 8 * *(unsigned __int8 *)(a2 + v11));
    if ((v12 & 3) != 1) {
      break;
    }
    unint64_t v9 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    if (a3 == ++v11) {
      goto LABEL_15;
    }
  }
  if ((v12 & 3) != 2)
  {
    *(void *)(v9 + 8 * *(unsigned __int8 *)(a2 + v11)) = (unint64_t)makeCFBurstTrieListNode((const void *)(a2 + v11 + 1), ~v11 + (int)a3, a4, a5) | 2;
    goto LABEL_34;
  }
  unsigned int v29 = v7;
  uint64_t v14 = (_DWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v12 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    CFBurstTrieAddUTF8StringWithWeight_cold_1();
  }
  uint64_t v15 = (a3 - 1);
  unsigned int v16 = 1;
  unint64_t v17 = v12 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    unint64_t v18 = v17;
    if (v15 - *(unsigned __int16 *)(v17 + 16) == v11
      && !memcmp((const void *)(a2 + v11 + 1), (const void *)(v17 + 18), v15 - v11))
    {
      break;
    }
    ++v16;
    unint64_t v17 = *(void *)v18;
    if (!*(void *)v18)
    {
      *(void *)unint64_t v18 = makeCFBurstTrieListNode((const void *)(a2 + v11 + 1), (int)v15 - (int)v11, a4, a5);
      int v19 = 1;
      goto LABEL_26;
    }
  }
  int v19 = 0;
  *(_DWORD *)(v18 + 8) += a4;
  *(_DWORD *)(v18 + 12) = a5;
LABEL_26:
  unint64_t v8 = a1;
  if (v16 > *(_DWORD *)(a1 + 2080))
  {
    unint64_t v20 = (unint64_t)malloc_type_calloc(1uLL, 0x808uLL, 0x100004078B9B834uLL);
    do
    {
      int v22 = v14[2];
      int v21 = v14[3];
      if (*((_WORD *)v14 + 8))
      {
        uint64_t v23 = *(void *)(v20 + 8 * *((unsigned __int8 *)v14 + 18));
        CFBurstTrieListNode = makeCFBurstTrieListNode((char *)v14 + 19, *((unsigned __int16 *)v14 + 8) - 1, v14[2], v21);
        *((_DWORD *)CFBurstTrieListNode + 2) = v22;
        *(void *)CFBurstTrieListNode = v23 & 0xFFFFFFFFFFFFFFFCLL;
        *(void *)(v20 + 8 * *((unsigned __int8 *)v14 + 18)) = (unint64_t)CFBurstTrieListNode | 2;
      }
      else
      {
        *(_DWORD *)(v20 + 2048) = v22;
        *(_DWORD *)(v20 + 2052) = v21;
      }
      long long v25 = *(_DWORD **)v14;
      free(v14);
      uint64_t v14 = v25;
    }
    while (v25);
    uint64_t v12 = v20 | 1;
  }
  *(void *)(v9 + 8 * *(unsigned __int8 *)(a2 + v11)) = v12;
  uint64_t v7 = v29;
  if (v19) {
    goto LABEL_34;
  }
  return v7;
}

char *makeCFBurstTrieListNode(const void *a1, unsigned int a2, int a3, int a4)
{
  size_t v8 = a2;
  unint64_t v9 = (char *)malloc_type_calloc(1uLL, a2 + 19, 0x91998343uLL);
  memcpy(v9 + 18, a1, v8);
  v9[a2 + 18] = 0;
  *(void *)unint64_t v9 = 0;
  *((_WORD *)v9 + 8) = a2;
  *((_DWORD *)v9 + 2) = a3;
  *((_DWORD *)v9 + 3) = a4;
  return v9;
}

uint64_t CFBurstTrieAddUTF8String(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddUTF8StringWithWeight(a1, a2, a3, 1, a4);
}

uint64_t findCFBurstTrieMappedLevel(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9 = result;
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  unsigned int v11 = *(_DWORD *)(a2 + 24);
  uint64_t v12 = (*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(void *)(result + 2056);
  if (v11 <= v10) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = v11;
  }
  if (v11 >= v10)
  {
    LODWORD(v15) = *(_DWORD *)(a2 + 24);
LABEL_10:
    if (*(_DWORD *)(v12 + 1024))
    {
      size_t result = a5(a4, a2 + 36);
      if (result) {
        return result;
      }
      unsigned int v10 = *(_DWORD *)(a2 + 20);
      LODWORD(v15) = *(_DWORD *)(a2 + 24);
    }
    if (v15 != v10 || (a3 & 1) == 0)
    {
      return traverseCFBurstTrieMappedLevel(v9, v12, (_DWORD *)a2, a3, a4, a5);
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a2 + 28);
    uint64_t v15 = *(unsigned int *)(a2 + 24);
    while (1)
    {
      uint64_t v16 = *(unsigned __int8 *)(v14 + v15);
      int v17 = *(_DWORD *)(v12 + 4 * v16);
      *(_DWORD *)(a2 + 16) = v17;
      *(_DWORD *)(a2 + 24) = v15 + 1;
      *(unsigned char *)(a2 + 36 + v15) = v16;
      int v18 = v17 & 3;
      if (v18 != 1) {
        break;
      }
      ++v15;
      uint64_t v12 = (v17 & 0xFFFFFFFC) + *(void *)(result + 2056);
      if (v13 == v15) {
        goto LABEL_10;
      }
    }
    if (v18 == 2)
    {
      return findCFBurstTrieMappedPage(result, a2, a4, a5);
    }
    else if (v18 == 3)
    {
      return findCFBurstTrieCompactMappedLevel(result, a2, a3, a4, a5);
    }
  }
  return result;
}

uint64_t findCFBurstTrieCompactMappedLevel(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9 = result;
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  unsigned int v11 = *(_DWORD *)(a2 + 24);
  uint64_t v12 = (int8x8_t *)((*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(void *)(result + 2056));
  if (v11 <= v10) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = v11;
  }
  if (v11 >= v10)
  {
    LODWORD(v17) = *(_DWORD *)(a2 + 24);
LABEL_18:
    if (v12[4].i32[0])
    {
      size_t result = a5(a4, a2 + 36);
      if (result) {
        return result;
      }
      unsigned int v10 = *(_DWORD *)(a2 + 20);
      LODWORD(v17) = *(_DWORD *)(a2 + 24);
    }
    if (v17 != v10 || (a3 & 1) == 0)
    {
      return traverseCFBurstTrieCompactMappedLevel(v9, v12, (_DWORD *)a2, a3, a4, a5);
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a2 + 28);
    uint64_t v15 = *(unsigned int *)(a2 + 24);
    while (1)
    {
      unsigned int v16 = *(unsigned __int8 *)(v14 + v15);
      uint64_t v17 = v15 + 1;
      *(_DWORD *)(a2 + 24) = v15 + 1;
      *(unsigned char *)(a2 + v15 + 36) = v16;
      LODWORD(v18) = v16 >> 6;
      int8x8_t v19 = v12[v16 >> 6];
      uint64_t v20 = 1 << v16;
      if ((*(void *)&v19 & (1 << v16)) == 0) {
        break;
      }
      if (v16 >= 0x40)
      {
        int v21 = 0;
        if (v18 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v18;
        }
        size_t result = (uint64_t)v12;
        do
        {
          int8x8_t v22 = *(int8x8_t *)result;
          result += 8;
          uint8x8_t v23 = (uint8x8_t)vcnt_s8(v22);
          v23.i16[0] = vaddlv_u8(v23);
          v21 += v23.i32[0];
          --v18;
        }
        while (v18);
      }
      else
      {
        int v21 = 0;
      }
      uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)((v20 - 1) & *(void *)&v19));
      v24.i16[0] = vaddlv_u8(v24);
      __int32 v25 = v12[4].i32[v21 + v24.i32[0] + 1];
      *(_DWORD *)(a2 + 16) = v25;
      int v26 = v25 & 3;
      if (v26 != 3)
      {
        if (v26 == 1)
        {
          return findCFBurstTrieMappedLevel(v9, a2);
        }
        else if (v26 == 2)
        {
          return findCFBurstTrieMappedPage(v9, a2, a4, a5);
        }
        return result;
      }
      uint64_t v12 = (int8x8_t *)((v25 & 0xFFFFFFFC) + *(void *)(v9 + 2056));
      uint64_t v15 = v17;
      if (v17 == v13) {
        goto LABEL_18;
      }
    }
  }
  return result;
}

uint64_t findCFBurstTrieMappedPage(uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  int v5 = (unsigned int *)((*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(void *)(result + 2056));
  unsigned int v6 = *v5;
  int v27 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24);
  if (v27 >= 1) {
    int v7 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24);
  }
  else {
    int v7 = 0;
  }
  if ((*(unsigned char *)(result + 2072) & 8) != 0)
  {
    if (v6)
    {
      uint64_t v14 = 0;
      unsigned int v15 = 0;
      uint64_t v26 = a2 + 36;
      do
      {
        unsigned int v16 = v14;
        uint64_t v17 = (char *)v5 + v15;
        unsigned int v19 = v17[4];
        uint64_t v14 = (unsigned __int8 *)(v17 + 4);
        uint64_t v18 = v19;
        int v20 = *(unsigned __int16 *)(v14 + 1);
        if (v16 && v18 > *v16) {
          size_t result = (uint64_t)memcpy(&__s1[*v16], v16 + 7, v18 - *v16);
        }
        if ((int)v18 + v20 >= v7)
        {
          uint64_t v21 = *(unsigned int *)(a2 + 24);
          size_t v22 = *v14;
          if (v27 <= 0
            || (v23 = (char *)(*(void *)(a2 + 28) + v21), size_t result = memcmp(__s1, v23, *v14), !result)
            && (size_t result = memcmp(v14 + 7, &v23[v22], (*(_DWORD *)(a2 + 20) - v21 - v22)), !result))
          {
            memcpy((void *)(v26 + v21), __s1, v22);
            size_t result = (uint64_t)memcpy((void *)(v26 + *(unsigned int *)(a2 + 24) + *v14), v14 + 7, *(unsigned __int16 *)(v14 + 1));
            *(unsigned char *)(a2 + *(_DWORD *)(a2 + 24) + *v14 + *(unsigned __int16 *)(v14 + 1) + 36) = 0;
            if (*(_DWORD *)(v14 + 3))
            {
              size_t result = a4(a3, v26);
              if (result) {
                break;
              }
            }
          }
        }
        v15 += *(unsigned __int16 *)(v14 + 1) + 7;
      }
      while (v15 < v6);
    }
  }
  else if (v6)
  {
    unsigned int v8 = 0;
    uint64_t v28 = a2 + 36;
    do
    {
      uint64_t v9 = (char *)v5 + v8;
      int v12 = *((unsigned __int16 *)v9 + 2);
      unsigned int v10 = (unsigned __int16 *)(v9 + 4);
      size_t v11 = v12;
      if (v7 <= v12)
      {
        uint64_t v13 = *(unsigned int *)(a2 + 24);
        size_t result = memcmp(v10 + 3, (const void *)(*(void *)(a2 + 28) + v13), v7);
        if (!result)
        {
          size_t result = (uint64_t)memcpy((void *)(v28 + v13), v10 + 3, v11);
          *(unsigned char *)(a2 + *(_DWORD *)(a2 + 24) + *v10 + 36) = 0;
          if (*(_DWORD *)(v10 + 1))
          {
            size_t result = a4(a3, v28);
            if (result) {
              break;
            }
          }
        }
      }
      v8 += *v10 + 6;
    }
    while (v8 < v6);
  }
  return result;
}

uint64_t parseIntegerTag(uint64_t a1, CFNumberRef *a2)
{
  double valuePtr[2] = *(void *)off_1ECE0A5B0;
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unsigned int v6 = *(unsigned __int8 **)(a1 + 8);
    goto LABEL_23;
  }
  unsigned int v6 = *(unsigned __int8 **)(a1 + 16);
  int v7 = (unsigned __int8 *)(v5 + 1);
  uint64_t v8 = -(uint64_t)v5;
  while (1)
  {
    unsigned int v9 = *(v7 - 1);
    if (v9 < 0x21 || v9 - 127 < 0x22) {
      goto LABEL_19;
    }
    if ((uint64_t)(v4 + v8) < 3 || (v9 & 0xFE) != 0xE2) {
      break;
    }
    int v10 = *v7;
    int v11 = v7[1];
    if (v9 == 226 && v10 == 128)
    {
      if (v11 != 175 && (v11 - 80) > 0x3B) {
        break;
      }
    }
    else if (v9 == 226 && v10 == 129)
    {
      if (v11 != 159) {
        break;
      }
    }
    else if (v9 != 227 || v10 != 128 || v11 != 128)
    {
      break;
    }
LABEL_19:
    *(void *)(a1 + 8) = v7++;
    --v8;
    if (!(v4 + v8))
    {
      unint64_t v5 = v4;
      goto LABEL_23;
    }
  }
  unsigned int v6 = v7 - 1;
  unint64_t v5 = -v8;
LABEL_23:
  if (v6 == (unsigned __int8 *)v4) {
    goto LABEL_98;
  }
  int v12 = *v6;
  if (v12 == 60)
  {
    uint64_t v43 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty <integer> on line %u", v43);
    goto LABEL_99;
  }
  int v14 = v12 == 45;
  if (v12 == 45 || v12 == 43)
  {
    unsigned int v15 = v6 + 1;
    *(void *)(a1 + 8) = v6 + 1;
    if ((unint64_t)(v6 + 1) >= v4)
    {
LABEL_48:
      unsigned int v6 = v15;
    }
    else
    {
      unsigned int v16 = &v6[v4 - v5];
      unint64_t v17 = v4 - 1 - v5;
      uint64_t v18 = v4 - 1 - (void)v6;
      do
      {
        unsigned int v19 = *v15;
        if (v19 >= 0x21 && v19 - 127 >= 0x22)
        {
          if (v18 < 3 || (v19 & 0xFE) != 0xE2) {
            goto LABEL_48;
          }
          int v20 = v15[1];
          int v21 = v15[2];
          if (v19 == 226 && v20 == 128)
          {
            if (v21 != 175 && (v21 - 80) > 0x3B) {
              goto LABEL_48;
            }
          }
          else if (v19 == 226 && v20 == 129)
          {
            if (v21 != 159) {
              goto LABEL_48;
            }
          }
          else if (v19 != 227 || v20 != 128 || v21 != 128)
          {
            goto LABEL_48;
          }
        }
        *(void *)(a1 + 8) = ++v15;
        --v18;
        --v17;
      }
      while (v17);
      unsigned int v6 = v16;
    }
  }
  else
  {
    int v14 = 0;
  }
  if (v6 == (unsigned __int8 *)v4) {
    goto LABEL_98;
  }
  if (*v6 == 48)
  {
    if ((unint64_t)(v6 + 1) >= v4)
    {
      int v23 = 0;
      BOOL v24 = 1;
    }
    else
    {
      BOOL v22 = (v6[1] | 0x20) == 120;
      if ((v6[1] | 0x20) == 0x78)
      {
        ++v6;
        int v23 = 1;
      }
      else
      {
        int v23 = 0;
      }
      BOOL v24 = !v22;
    }
    *(void *)(a1 + 8) = ++v6;
  }
  else
  {
    int v23 = 0;
    BOOL v24 = 0;
  }
  if (v6 == (unsigned __int8 *)v4)
  {
LABEL_98:
    uint64_t v45 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Premature end of file after <integer> on line %u", v45);
    goto LABEL_99;
  }
  int v25 = *v6;
  if (v25 == 48)
  {
    uint64_t v26 = v6 + 1;
    while (1)
    {
      *(void *)(a1 + 8) = v26;
      if (v26 == (unsigned __int8 *)v4) {
        goto LABEL_98;
      }
      int v27 = *v26++;
      int v25 = v27;
      if (v27 != 48)
      {
        unsigned int v6 = v26 - 1;
        BOOL v24 = 1;
        break;
      }
    }
  }
  if (!v24 || v25 != 60)
  {
    if (v25 != 60)
    {
      uint64_t v30 = 0;
      unint64_t v31 = 0x1999999999999999;
      if (v23) {
        unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
      }
      uint64_t v32 = 10;
      if (v23) {
        uint64_t v32 = 16;
      }
      long long v33 = v6 + 1;
      do
      {
        uint64_t v34 = (char)v25;
        unsigned int v35 = v34 - 48;
        if ((v34 - 48) > 0x36)
        {
LABEL_114:
          uint64_t v49 = lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unknown character '%c' (0x%x) in <integer> on line %u", v34, v34, v49);
          goto LABEL_99;
        }
        if (((1 << v35) & 0x3FF) == 0)
        {
          if (((1 << v35) & 0x7E0000) != 0)
          {
            int v36 = -55;
          }
          else
          {
            if (((1 << v35) & 0x7E000000000000) == 0) {
              goto LABEL_114;
            }
            int v36 = -87;
          }
          if ((v23 & 1) == 0)
          {
            uint64_t v48 = lineNumber((unint64_t *)a1);
            CFErrorRef Error = __CFPropertyListCreateError(3840, @"Hex digit in non-hex <integer> on line %u", v48);
            goto LABEL_99;
          }
          unsigned int v35 = v36 + v34;
        }
        if (v31 < v30 || __CFADD__(v30 * v32, v35))
        {
          uint64_t v46 = lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Integer overflow in <integer> on line %u", v46);
          goto LABEL_99;
        }
        uint64_t v30 = v30 * v32 + v35;
        char v37 = v14 ^ 1;
        if ((unint64_t)v30 < 0x8000000000000001) {
          char v37 = 1;
        }
        if ((v37 & 1) == 0)
        {
          uint64_t v47 = lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Integer underflow in <integer> on line %u", v47);
          goto LABEL_99;
        }
        *(void *)(a1 + 8) = v33;
        if (v33 == (unsigned __int8 *)v4) {
          goto LABEL_98;
        }
        int v38 = *v33++;
        LOBYTE(v25) = v38;
      }
      while (v38 != 60);
      uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"integer", 7uLL);
      if (!result) {
        return result;
      }
      if (*(unsigned char *)(a1 + 80))
      {
        *a2 = 0;
        return 1;
      }
      if (((v30 < 0) & ~v14) != 0)
      {
        valuePtr[0] = 0;
        valuePtr[1] = v30;
        CFAllocatorRef v40 = *(const __CFAllocator **)(a1 + 32);
        CFNumberType v41 = kCFNumberMaxType|kCFNumberSInt8Type;
      }
      else
      {
        if (v14) {
          uint64_t v42 = -v30;
        }
        else {
          uint64_t v42 = v30;
        }
        valuePtr[0] = v42;
        CFAllocatorRef v40 = *(const __CFAllocator **)(a1 + 32);
        CFNumberType v41 = kCFNumberSInt64Type;
      }
      goto LABEL_102;
    }
    uint64_t v44 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Incomplete <integer> on line %u", v44);
LABEL_99:
    CFErrorRef v39 = Error;
    uint64_t result = 0;
    *(void *)(a1 + 24) = v39;
    return result;
  }
  LODWORD(valuePtr[0]) = 0;
  uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"integer", 7uLL);
  if (!result) {
    return result;
  }
  if (!*(unsigned char *)(a1 + 80))
  {
    CFAllocatorRef v40 = *(const __CFAllocator **)(a1 + 32);
    CFNumberType v41 = kCFNumberSInt32Type;
LABEL_102:
    CFNumberRef v29 = CFNumberCreate(v40, v41, valuePtr);
    goto LABEL_103;
  }
  CFNumberRef v29 = 0;
LABEL_103:
  *a2 = v29;
  return 1;
}

uint64_t parseDataTag(uint64_t a1, __CFData **a2)
{
  uint64_t v20 = *(void *)(a1 + 8);
  if (*(unsigned char *)(a1 + 80))
  {
    uint64_t Typed = 0;
    unint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  }
  else
  {
    uint64_t Typed = (UInt8 *)CFAllocatorAllocateTyped(*(void *)(a1 + 32), 256, 3027262758, 0);
    unint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  }
  if ((unint64_t)v4 >= *(void *)(a1 + 16))
  {
    int v8 = 0;
LABEL_29:
    if (*(unsigned char *)(a1 + 80))
    {
      uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"data", 4uLL);
      if (!result) {
        return result;
      }
      CFMutableDictionaryRef Mutable = 0;
    }
    else
    {
      CFAllocatorRef v16 = *(const __CFAllocator **)(a1 + 32);
      if (*(_DWORD *)(a1 + 40) == 2)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(v16, 0);
        CFDataAppendBytes(Mutable, Typed, v8);
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), Typed);
      }
      else
      {
        CFMutableDictionaryRef Mutable = CFDataCreateWithBytesNoCopy(v16, Typed, v8, *(CFAllocatorRef *)(a1 + 32));
      }
      if (!Mutable)
      {
        *(void *)(a1 + 8) = v20;
        uint64_t v18 = lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Could not interpret <data> at line %u (should be base64-encoded)", v18);
        uint64_t result = 0;
        *(void *)(a1 + 24) = Error;
        return result;
      }
      if (!checkForCloseTag((unint64_t *)a1, (const UInt8 *)"data", 4uLL))
      {
        CFRelease(Mutable);
        return 0;
      }
    }
    *a2 = Mutable;
    return 1;
  }
  char v5 = 0;
  int v6 = 0;
  int v7 = 0;
  int v8 = 0;
  int v9 = 256;
  int v10 = off_1ECE0A578;
  while (1)
  {
    uint64_t v11 = *v4;
    if (v11 != 61) {
      break;
    }
    ++v7;
LABEL_11:
    if ((parseDataTag_dataDecodeTable[v11] & 0x80000000) == 0)
    {
      ++v5;
      int v6 = parseDataTag_dataDecodeTable[v11] + (v6 << 6);
      if (!*(unsigned char *)(a1 + 80) && (v5 & 3) == 0)
      {
        uint64_t v12 = v8 + 2;
        if (v9 <= (int)v12)
        {
          if (v9 >= 0x40000)
          {
            if (HIBYTE(v9)) {
              v9 += 0x40000;
            }
            else {
              v9 *= 2;
            }
          }
          else
          {
            v9 *= 4;
          }
          uint64_t Typed = (UInt8 *)__CFSafelyReallocateWithAllocatorTyped(*(void *)(a1 + 32), Typed, v9, 3151119965, 0, 0);
          int v10 = off_1ECE0A578;
        }
        Typed[v8] = BYTE2(v6);
        if (v7 > 1)
        {
          ++v8;
        }
        else
        {
          Typed[v8 + 1] = BYTE1(v6);
          if (v7 == 1)
          {
            v8 += 2;
          }
          else
          {
            v8 += 3;
            Typed[v12] = v6;
          }
        }
      }
    }
    unint64_t v13 = *(void *)(a1 + 16);
    unint64_t v4 = (unsigned __int8 *)(*(void *)(a1 + 8) + 1);
    *(void *)(a1 + 8) = v4;
    if ((unint64_t)v4 >= v13) {
      goto LABEL_29;
    }
  }
  if (v11 == 60) {
    goto LABEL_29;
  }
  if ((v11 & 0x80) == 0)
  {
    v7 &= (int)(v10[v11 + 15] << 17) >> 31;
    goto LABEL_11;
  }
  __maskrune(*v4, 0x4000uLL);
  uint64_t v17 = lineNumber((unint64_t *)a1);
  *(void *)(a1 + 24) = __CFPropertyListCreateError(3840, @"Could not interpret <data> on line %u (invalid character 0x%hhX)", v17, v11);
  if (Typed) {
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), Typed);
  }
  return 0;
}

uint64_t __CFRunLoopSourceComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  if (v2 < v3) {
    return -1;
  }
  if (v3 < v2) {
    return 1;
  }
  double explicit = (double)atomic_load_explicit((atomic_ullong *volatile)(a1 + 88), memory_order_acquire);
  double v6 = (double)atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire);
  if (explicit < v6) {
    return -1;
  }
  else {
    return explicit > v6;
  }
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return [(__CFDate *)theDate compare:otherDate];
}

unint64_t *skipXMLComment(unint64_t *result)
{
  unint64_t v1 = result;
  unint64_t v3 = result[1];
  unint64_t v2 = result[2];
  if (v3 >= v2 - 3)
  {
LABEL_7:
    uint64_t v6 = lineNumber(result);
    uint64_t result = (unint64_t *)__CFPropertyListCreateError(3840, @"Unterminated comment started on line %u", v6);
    v1[3] = (unint64_t)result;
  }
  else
  {
    uint64_t v4 = v2 - v3 - 3;
    unint64_t v5 = v3 + 3;
    while (*(unsigned char *)(v5 - 3) != 45 || *(unsigned char *)(v5 - 2) != 45 || *(unsigned char *)(v5 - 1) != 62)
    {
      ++v5;
      if (!--v4) {
        goto LABEL_7;
      }
    }
    result[1] = v5;
  }
  return result;
}

UText *__CFStringUTextInit(UText *a1, int32_t a2, const void *a3)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  UErrorCode status = U_ZERO_ERROR;
  if (!a3) {
    return 0;
  }
  uint64_t result = utext_setup(a1, 0, &status);
  if (status > U_ZERO_ERROR) {
    return 0;
  }
  result->providerProperties = a2;
  uint64_t v6 = (const UTextFuncs *)&__CFAttributedStringFuncs;
  result->CFTypeRef context = a3;
  if ((a2 & 0x10) == 0) {
    uint64_t v6 = (const UTextFuncs *)&__CFStringFuncs;
  }
  result->pFuncs = v6;
  return result;
}

void CFStringFold(CFMutableStringRef theString, CFStringCompareFlags theFlags, CFLocaleRef theLocale)
{
  uint64_t v117 = *(void *)off_1ECE0A5B0;
  char v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) == 0)
  {
    uint64_t v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringFold_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    return;
  }
  __int16 v13 = theFlags;
  CFIndex v116 = 0;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long theStringa = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  *(_OWORD *)buffer = 0u;
  uint64_t Length = CFStringGetLength(theString);
  int v16 = CF_IS_OBJC(7uLL, (unint64_t)theString);
  BOOL v97 = v16 != 0;
  CFLocaleRef v17 = theLocale;
  if ((v13 & 0x20) != 0)
  {
    CFLocaleRef v17 = theLocale;
    if (!theLocale) {
      CFLocaleRef v17 = CFLocaleCopyCurrent();
    }
  }
  CFStringCompareFlags theFlagsa = v13 & 0x181;
  if ((v13 & 0x181) != 0 && Length)
  {
    if (v17) {
      uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(v17, 1);
    }
    else {
      uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = 0;
    }
    unsigned int v18 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unsigned int v18 = __CFDefaultEightBitStringEncoding;
    }
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)theString, v18, 0, v97);
    if (!CStringPtrInternal || (v13 & 1) != 0 || v18 != 1536)
    {
      *(void *)&long long theStringa = theString;
      *((void *)&v114 + 1) = 0;
      *(void *)&long long v115 = Length;
      CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
      uint64_t v21 = 0;
      *((void *)&theStringa + 1) = CharactersPtr;
      if (!CharactersPtr) {
        uint64_t v21 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, v97);
      }
      uint64_t v22 = 0;
      CFIndex v116 = 0;
      *(void *)&long long v114 = v21;
      *((void *)&v115 + 1) = 0;
      CFLocaleRef v96 = v17;
      CFIndex v23 = 0;
      if ((v13 & 0x81) == 0 || !CStringPtrInternal) {
        goto LABEL_45;
      }
      CFLocaleRef v94 = theLocale;
      if (v16)
      {
        BOOL v24 = 0;
      }
      else
      {
        char v25 = atomic_load((unint64_t *)&theString->info);
        p_data = &theString->data;
        if ((v25 & 0x60) != 0)
        {
          int v27 = *p_data;
        }
        else
        {
          char v28 = atomic_load((unint64_t *)&theString->info);
          int v27 = (char *)&p_data[(v28 & 5) != 4];
        }
        unint64_t v29 = atomic_load((unint64_t *)&theString->info);
        BOOL v24 = &v27[(v29 >> 2) & 1];
      }
      if (Length <= 0)
      {
        uint64_t v22 = 0;
        uint64_t v31 = CStringPtrInternal;
        goto LABEL_44;
      }
      uint64_t v30 = 0;
      uint64_t v22 = 0;
      uint64_t v31 = CStringPtrInternal;
      while (1)
      {
        if (*(char *)(CStringPtrInternal + v30) < 0 || SpecialCaseHandlingLanguageIdentifierForLocale)
        {
          uint64_t v32 = __CFStringFoldCharacterClusterAtIndex(*(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(CStringPtrInternal + v30)), buffer, v30, theFlagsa, SpecialCaseHandlingLanguageIdentifierForLocale, v103, 0, 0);
          uint64_t v22 = v32;
          if (v32 >= 1)
          {
            if (v32 != 1 || v103[0] > 0x7F || !v24) {
              goto LABEL_44;
            }
            v24[v30] = v103[0];
            uint64_t v22 = 1;
          }
          goto LABEL_40;
        }
        if ((v13 & 1) != 0 && *(unsigned __int8 *)(CStringPtrInternal + v30) - 65 <= 0x19) {
          break;
        }
LABEL_40:
        ++v31;
        ++v30;
        if (CStringPtrInternal + v30 >= (unint64_t)(CStringPtrInternal + Length))
        {
          uint64_t v31 = CStringPtrInternal + v30;
          goto LABEL_44;
        }
      }
      if (v24)
      {
        v24[v30] += 32;
        goto LABEL_40;
      }
      uint64_t v31 = CStringPtrInternal + v30;
LABEL_44:
      theLocale = v94;
      CFIndex v23 = v31 - CStringPtrInternal;
      CFLocaleRef v17 = v96;
LABEL_45:
      if (Length > v23)
      {
        if (v16)
        {
          uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * (Length - v23), 0x1000040BDFB0063, 0);
          v118.CFIndex location = v23;
          v118.CFIndex length = Length - v23;
          CFStringGetCharacters(theString, v118, Typed);
          uint64_t v34 = Typed;
          CFLocaleRef v17 = v96;
          MutableWithExternalCharactersNoCFDictionaryRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, Length - v23, Length - v23, 0);
          if (MutableWithExternalCharactersNoCopy)
          {
            CFStringRef v36 = MutableWithExternalCharactersNoCopy;
            CFStringFold(MutableWithExternalCharactersNoCopy, theFlagsa, v96);
            v119.CFIndex location = v23;
            v119.CFIndex length = Length - v23;
            CFStringReplace(theString, v119, v36);
            CFRelease(v36);
            goto LABEL_155;
          }
        }
        uint64_t v100 = 0;
        if (v22 >= 1)
        {
          uint64_t v101 = v23 + 1;
          uint64_t v102 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v101, 1, v22 - 1, 1);
          char v37 = atomic_load((unint64_t *)&theString->info);
          uint64_t v38 = v37 & 5;
          char v39 = atomic_load((unint64_t *)&theString->info);
          uint64_t v40 = v39 & 0x60;
          if (v38 == 4)
          {
            CFNumberType v41 = &theString->data;
            if (v40)
            {
              uint64_t v42 = *v41;
            }
            else
            {
              uint64_t v43 = atomic_load((unint64_t *)&theString->info);
              uint64_t v42 = (char *)&v41[(v43 & 5) != 4];
            }
            uint64_t Length = *v42;
          }
          else if ((v39 & 0x60) != 0)
          {
            uint64_t Length = theString->length;
          }
          else
          {
            uint64_t Length = (uint64_t)theString->data;
          }
          *(void *)&long long theStringa = theString;
          *((void *)&v114 + 1) = 0;
          *(void *)&long long v115 = Length;
          uint64_t v44 = CFStringGetCharactersPtr(theString);
          uint64_t v45 = 0;
          *((void *)&theStringa + 1) = v44;
          if (!v44) {
            uint64_t v45 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, v97);
          }
          *(void *)&long long v114 = v45;
          *((void *)&v115 + 1) = 0;
          CFIndex v116 = 0;
          char v46 = atomic_load((unint64_t *)&theString->info);
          uint64_t v47 = &theString->data;
          if ((v46 & 0x60) != 0)
          {
            uint64_t v48 = *v47;
          }
          else
          {
            char v49 = atomic_load((unint64_t *)&theString->info);
            uint64_t v48 = (char *)&v47[(v49 & 5) != 4];
          }
          long long v50 = v103;
          uint64_t v51 = &v48[2 * v23];
          do
          {
            int v52 = *v50++;
            *(_WORD *)uint64_t v51 = v52;
            v51 += 2;
          }
          while (v50 < &v103[v22]);
          ++v23;
        }
        if (v23 < Length)
        {
          CFIndex v95 = &theString->data;
          do
          {
            if (*((void *)&theStringa + 1))
            {
              UniChar v53 = *(_WORD *)(*((void *)&theStringa + 1) + 2 * (*((void *)&v114 + 1) + v23));
            }
            else if ((void)v114)
            {
              UniChar v53 = *(char *)(v114 + *((void *)&v114 + 1) + v23);
            }
            else
            {
              uint64_t v54 = *((void *)&v115 + 1);
              if (v116 <= v23 || *((void *)&v115 + 1) > v23)
              {
                CFIndex v56 = v23 - 4;
                if (v23 < 4) {
                  CFIndex v56 = 0;
                }
                CFIndex v57 = v56 + 64;
                if (v56 + 64 >= (uint64_t)v115) {
                  CFIndex v57 = v115;
                }
                *((void *)&v115 + 1) = v56;
                CFIndex v116 = v57;
                v120.CFIndex location = *((void *)&v114 + 1) + v56;
                v120.CFIndex length = v57 - v56;
                CFStringGetCharacters((CFStringRef)theStringa, v120, buffer);
                uint64_t v54 = *((void *)&v115 + 1);
              }
              UniChar v53 = buffer[v23 - v54];
            }
            unsigned int v58 = v53;
            uint64_t v100 = 0;
            if ((v13 & 0x80) != 0 || SpecialCaseHandlingLanguageIdentifierForLocale || v53 > 0x7Fu)
            {
              uint64_t v62 = v23 + 1;
              if (v53 >> 10 == 54 && v62 < Length)
              {
                if (*((void *)&theStringa + 1))
                {
                  UniChar v64 = *(_WORD *)(*((void *)&theStringa + 1) + 2 * (*((void *)&v114 + 1) + v62));
                }
                else if ((void)v114)
                {
                  UniChar v64 = *(char *)(v114 + *((void *)&v114 + 1) + v62);
                }
                else
                {
                  if (v116 <= v62 || (uint64_t v65 = *((void *)&v115 + 1), *((uint64_t *)&v115 + 1) > v62))
                  {
                    CFIndex v66 = v23 - 3;
                    if (v23 < 3) {
                      CFIndex v66 = 0;
                    }
                    CFIndex v67 = v66 + 64;
                    if (v66 + 64 >= (uint64_t)v115) {
                      CFIndex v67 = v115;
                    }
                    *((void *)&v115 + 1) = v66;
                    CFIndex v116 = v67;
                    v121.CFIndex location = *((void *)&v114 + 1) + v66;
                    v121.CFIndex length = v67 - v66;
                    CFStringGetCharacters((CFStringRef)theStringa, v121, buffer);
                    uint64_t v65 = *((void *)&v115 + 1);
                  }
                  UniChar v64 = buffer[v62 - v65];
                }
                BOOL v68 = v64 >> 10 == 55;
                int v69 = (v58 << 10) + v64 - 56613888;
                if (v68) {
                  unsigned int v58 = v69;
                }
              }
              uint64_t v70 = __CFStringFoldCharacterClusterAtIndex(v58, buffer, v23, theFlagsa, SpecialCaseHandlingLanguageIdentifierForLocale, v103, &v100, 0);
              uint64_t v60 = v100;
              if (v100 >= 1)
              {
                uint64_t v61 = v70;
                CFRange v59 = &v103[v70];
                if (v70 >= 1) {
                  goto LABEL_112;
                }
                int v73 = 0;
LABEL_119:
                if (v61 == v60)
                {
                  char v74 = atomic_load((unint64_t *)&theString->info);
                  if ((v74 & 0x10) == 0)
                  {
                    uint64_t v60 = v100;
                    goto LABEL_122;
                  }
                }
                else
                {
LABEL_122:
                  uint64_t v75 = v60 - v61;
                  if (v60 < v61)
                  {
                    uint64_t v75 = 0;
                    uint64_t v76 = v61 - v60;
                  }
                  else
                  {
                    uint64_t v60 = v61;
                    uint64_t v76 = 0;
                  }
                  uint64_t v101 = v60 + v23;
                  uint64_t v102 = v75;
                  __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v101, 1, v76, 1);
                  char v77 = atomic_load((unint64_t *)&theString->info);
                  char v78 = atomic_load((unint64_t *)&theString->info);
                  uint64_t v79 = v78 & 0x60;
                  if ((v77 & 5) == 4)
                  {
                    if (v79)
                    {
                      CFRange v80 = *v95;
                    }
                    else
                    {
                      char v81 = atomic_load((unint64_t *)&theString->info);
                      CFRange v80 = (char *)&v95[(v81 & 5) != 4];
                    }
                    uint64_t Length = *v80;
                  }
                  else if (v79)
                  {
                    uint64_t Length = theString->length;
                  }
                  else
                  {
                    uint64_t Length = (uint64_t)*v95;
                  }
                  *(void *)&long long theStringa = theString;
                  *((void *)&v114 + 1) = 0;
                  *(void *)&long long v115 = Length;
                  CFRange v82 = CFStringGetCharactersPtr(theString);
                  uint64_t v83 = 0;
                  *((void *)&theStringa + 1) = v82;
                  if (!v82) {
                    uint64_t v83 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, v97);
                  }
                  *(void *)&long long v114 = v83;
                  *((void *)&v115 + 1) = 0;
                  CFIndex v116 = 0;
                }
                char v84 = atomic_load((unint64_t *)&theString->info);
                if ((v84 & 0x60) != 0)
                {
                  CFTypeRef v85 = *v95;
                  if (v73) {
                    goto LABEL_138;
                  }
                  goto LABEL_153;
                }
                char v93 = atomic_load((unint64_t *)&theString->info);
                CFTypeRef v85 = (char *)&v95[(v93 & 5) != 4];
                if (!v73)
                {
LABEL_153:
                  CFLocaleRef v17 = v96;
                  goto LABEL_154;
                }
LABEL_138:
                uint64_t v86 = &v85[2 * v23];
                uint64_t v87 = v103;
                unint64_t v88 = v103;
                CFLocaleRef v17 = v96;
                while (2)
                {
                  unsigned int v90 = *v88++;
                  unsigned int v89 = v90;
                  unsigned int v91 = HIWORD(v90);
                  if (HIWORD(v90))
                  {
                    if (v91 > 0x10) {
                      goto LABEL_146;
                    }
                    *(_WORD *)uint64_t v86 = ((v89 + 67043328) >> 10) - 10240;
                    v86 += 2;
                    LOWORD(v92) = v89 & 0x3FF | 0xDC00;
                  }
                  else if ((v89 & 0xFC00) == 0xD800)
                  {
                    if (v88 < v59)
                    {
                      unsigned int v92 = *v88;
                      if (*v88 >> 10 == 55)
                      {
                        *(_WORD *)uint64_t v86 = v89;
                        v86 += 2;
                        unint64_t v88 = v87 + 2;
                        goto LABEL_150;
                      }
                    }
LABEL_146:
                    LOWORD(v92) = -3;
                  }
                  else if ((v89 & 0xFC00) == 0xDC00)
                  {
                    LOWORD(v92) = -3;
                  }
                  else
                  {
                    LOWORD(v92) = v89;
                  }
LABEL_150:
                  *(_WORD *)uint64_t v86 = v92;
                  v86 += 2;
                  uint64_t v87 = v88;
                  if (v88 >= v59) {
                    goto LABEL_154;
                  }
                  continue;
                }
              }
              uint64_t v61 = 1;
            }
            else
            {
              if ((v13 & 1) != 0 && v53 >= 0x41u && v53 <= 0x5Au)
              {
                uint64_t v100 = 1;
                v103[0] = v53 + 32;
                CFRange v59 = v104;
                uint64_t v60 = 1;
                uint64_t v61 = 1;
LABEL_112:
                unint64_t v71 = v103;
                do
                {
                  uint64_t v72 = v71 + 1;
                  if (*((_WORD *)v71 + 1)) {
                    ++v61;
                  }
                  ++v71;
                }
                while (v72 < v59);
                int v73 = 1;
                goto LABEL_119;
              }
              uint64_t v61 = 1;
            }
LABEL_154:
            v23 += v61;
          }
          while (v23 < Length);
        }
      }
    }
  }
LABEL_155:
  if (!theLocale && v17) {
    CFRelease(v17);
  }
}

uint64_t __CFStringFoldCharacterClusterAtIndex(unsigned int a1, UniChar *buffer, uint64_t a3, __int16 a4, char *__s1, unsigned int *a6, void *a7, unsigned char *a8)
{
  uint64_t v115 = *(void *)off_1ECE0A5B0;
  unsigned int v113 = a1;
  if (!a1) {
    return 0;
  }
  unsigned int v14 = a1;
  unsigned int v15 = HIWORD(a1);
  if (!__CFStringFoldCharacterClusterAtIndex_decompBMP)
  {
    __CFStringFoldCharacterClusterAtIndex_decompBMP = CFUniCharGetBitmapPtrForPlane(9u, 0);
    __CFStringFoldCharacterClusterAtIndex_graphemeBMP = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
  }
  uint64_t v16 = 1;
  if (v15) {
    uint64_t v16 = 2;
  }
  uint64_t v110 = a3;
  long long v111 = a8;
  int64_t v17 = v16 + a3;
  if (v14 <= 0x7F)
  {
    if (!__s1 || v14 != 73)
    {
      uint64_t v18 = 0;
      char v19 = 0;
      if ((a4 & 1) == 0 || v14 - 65 > 0x19) {
        goto LABEL_118;
      }
      char v19 = 0;
      unsigned int v113 = v14 + 32;
      *a6 = v14 + 32;
      goto LABEL_17;
    }
    uint64_t v18 = 0;
LABEL_36:
    unsigned int v15 = 0;
    goto LABEL_37;
  }
  if ((a4 & 0x100) != 0 && v14 - 65280 <= 0xEF)
  {
    uint64_t v18 = 1;
    CFUniCharCompatibilityDecompose((int *)&v113, 1, 1);
    LOWORD(v14) = v113;
    *a6 = v113;
  }
  else
  {
    uint64_t v18 = 0;
    if (v15) {
      goto LABEL_37;
    }
  }
  unsigned int v15 = 0;
  if ((v14 & 0xFC00) == 0xD800 && (v17 & 0x8000000000000000) == 0)
  {
    int64_t v20 = *((void *)buffer + 20);
    if (v20 > v17)
    {
      uint64_t v21 = *((void *)buffer + 17);
      if (v21)
      {
        UniChar v22 = *(_WORD *)(v21 + 2 * (*((void *)buffer + 19) + v17));
      }
      else
      {
        uint64_t v23 = *((void *)buffer + 18);
        if (v23)
        {
          UniChar v22 = *(char *)(v23 + *((void *)buffer + 19) + v17);
        }
        else
        {
          if (*((void *)buffer + 22) <= v17 || (int64_t v24 = *((void *)buffer + 21), v24 > v17))
          {
            int64_t v25 = v17 - 4;
            if ((unint64_t)v17 < 4) {
              int64_t v25 = 0;
            }
            if (v25 + 64 < v20) {
              int64_t v20 = v25 + 64;
            }
            *((void *)buffer + 21) = v25;
            *((void *)buffer + 22) = v20;
            v116.CFIndex location = *((void *)buffer + 19) + v25;
            v116.CFIndex length = v20 - v25;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v116, buffer);
            int64_t v24 = *((void *)buffer + 21);
          }
          UniChar v22 = buffer[v17 - v24];
        }
      }
      if (v22 >> 10 == 55)
      {
        unsigned int v113 = ((unsigned __int16)v113 << 10) + v22 - 56613888;
        ++v17;
        unsigned int v15 = HIWORD(v113);
        goto LABEL_37;
      }
    }
    goto LABEL_36;
  }
LABEL_37:
  if ((a4 & 0x90) == 0) {
    goto LABEL_51;
  }
  unsigned __int16 v26 = v113;
  if (v15)
  {
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, v15);
    if (!BitmapPtrForPlane) {
      goto LABEL_51;
    }
  }
  else
  {
    uint64_t BitmapPtrForPlane = __CFStringFoldCharacterClusterAtIndex_decompBMP;
    if (!__CFStringFoldCharacterClusterAtIndex_decompBMP) {
      goto LABEL_51;
    }
  }
  if ((*(unsigned __int8 *)(BitmapPtrForPlane + (v26 >> 3)) >> (v26 & 7)))
  {
    unsigned int v28 = v113;
    uint64_t v29 = CFUniCharDecomposeCharacter(v113, a6, 64);
    uint64_t v18 = v29;
    unsigned int v30 = *a6;
    unsigned int v113 = *a6;
    if ((a4 & 0x80) != 0 && v30 < 0x510)
    {
      uint64_t v18 = 1;
    }
    else if ((a4 & 0x10) != 0)
    {
      if (v111 && !v29) {
        *long long v111 = 1;
      }
    }
    else
    {
      uint64_t v18 = 0;
      unsigned int v113 = v28;
    }
  }
LABEL_51:
  if ((a4 & 1) == 0)
  {
LABEL_52:
    char v19 = 0;
    goto LABEL_118;
  }
  unsigned int v31 = v113;
  BOOL v33 = (a4 & 0x80) == 0 || v113 > 0x50F;
  if (!__CFStringFoldCharacterClusterAtIndex_lowerBMP)
  {
    __CFStringFoldCharacterClusterAtIndex_lowerBMP = CFUniCharGetBitmapPtrForPlane(0x67u, 0);
    __CFStringFoldCharacterClusterAtIndex_caseFoldBMP = CFUniCharGetBitmapPtrForPlane(0x6Au, 0);
    unsigned int v31 = v113;
  }
  if (__s1 && v31 == 73)
  {
    if (!strcmp(__s1, "tr") || !strcmp(__s1, "az"))
    {
      if (v18 >= 2)
      {
        if (a6[1] == 775)
        {
          if ((unint64_t)v18 >= 3) {
            memmove(a6 + 1, a6 + 2, 4 * v18 - 8);
          }
          *a6 = 105;
          unsigned int v113 = 105;
          char v19 = 1;
          --v18;
          goto LABEL_118;
        }
        goto LABEL_78;
      }
      if ((v17 & 0x8000000000000000) == 0)
      {
        int64_t v34 = *((void *)buffer + 20);
        if (v34 > v17)
        {
          uint64_t v35 = *((void *)buffer + 17);
          if (v35)
          {
            CFStringRef v36 = (UniChar *)(v35 + 2 * (*((void *)buffer + 19) + v17));
LABEL_74:
            if (*v36 != 775)
            {
              LOWORD(v31) = v113;
              goto LABEL_79;
            }
            *a6 = 105;
            unsigned int v113 = 105;
            ++v17;
            char v19 = 1;
LABEL_17:
            uint64_t v18 = 1;
            goto LABEL_118;
          }
          if (!*((void *)buffer + 18))
          {
            if (*((void *)buffer + 22) <= v17 || (int64_t v86 = *((void *)buffer + 21), v86 > v17))
            {
              int64_t v87 = v17 - 4;
              if ((unint64_t)v17 < 4) {
                int64_t v87 = 0;
              }
              if (v87 + 64 < v34) {
                int64_t v34 = v87 + 64;
              }
              *((void *)buffer + 21) = v87;
              *((void *)buffer + 22) = v34;
              v118.CFIndex location = *((void *)buffer + 19) + v87;
              v118.CFIndex length = v34 - v87;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v118, buffer);
              int64_t v86 = *((void *)buffer + 21);
            }
            CFStringRef v36 = &buffer[v17 - v86];
            goto LABEL_74;
          }
        }
      }
    }
LABEL_78:
    LOWORD(v31) = 73;
  }
LABEL_79:
  if (v15)
  {
    uint64_t v37 = CFUniCharGetBitmapPtrForPlane(0x67u, v15);
    if (!v37) {
      goto LABEL_84;
    }
  }
  else
  {
    uint64_t v37 = __CFStringFoldCharacterClusterAtIndex_lowerBMP;
    if (!__CFStringFoldCharacterClusterAtIndex_lowerBMP)
    {
LABEL_84:
      unsigned __int16 v38 = v113;
      if (v15)
      {
        uint64_t v39 = CFUniCharGetBitmapPtrForPlane(0x6Au, v15);
        if (!v39) {
          goto LABEL_52;
        }
      }
      else
      {
        uint64_t v39 = __CFStringFoldCharacterClusterAtIndex_caseFoldBMP;
        if (!__CFStringFoldCharacterClusterAtIndex_caseFoldBMP) {
          goto LABEL_52;
        }
      }
      if (((*(unsigned __int8 *)(v39 + (v38 >> 3)) >> (v38 & 7)) & 1) == 0) {
        goto LABEL_52;
      }
      goto LABEL_89;
    }
  }
  if (((*(unsigned __int8 *)(v37 + ((unsigned __int16)v31 >> 3)) >> (v31 & 7)) & 1) == 0) {
    goto LABEL_84;
  }
LABEL_89:
  unsigned int v40 = CFUniCharMapCaseTo(v113, v114, 8, 3, 0, (unsigned __int16 *)__s1);
  uint64_t v41 = v40;
  uint64_t v42 = &v114[v40];
  v18 -= v18 > 0;
  if (v18 >= 1 && (v40 & 0xFFFFFFFE) != 0)
  {
    uint64_t v43 = 0;
    if (v40)
    {
      uint64_t v44 = v114;
      uint64_t v45 = v114;
      do
      {
        __int16 v46 = *v45++;
        if ((v46 & 0xFC00) == 0xD800 && v45 < v42)
        {
          int v48 = v44[1] & 0xFC00;
          char v49 = v44 + 2;
          if (v48 == 56320) {
            uint64_t v45 = v49;
          }
        }
        ++v43;
        uint64_t v44 = v45;
      }
      while (v45 < v42);
    }
    memmove(&a6[v43], a6 + 1, 4 * v18);
  }
  char v109 = a4;
  if (v41)
  {
    long long v50 = v114;
    uint64_t v51 = a6;
    do
    {
      UniChar v53 = (unsigned __int16 *)(v50 + 1);
      unsigned int v52 = (unsigned __int16)*v50;
      unsigned int v113 = v52;
      BOOL v54 = (v52 & 0xFC00) != 0xD800 || v53 >= (unsigned __int16 *)v42;
      if (v54 || (int v55 = *v53, (v55 & 0xFC00) != 0xDC00))
      {
        uint64_t v56 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
        ++v50;
      }
      else
      {
        v50 += 2;
        unsigned int v113 = (v52 << 10) - 56613888 + v55;
        uint64_t v56 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v113));
        unsigned int v52 = v113;
      }
      if (v56) {
        char v57 = v33;
      }
      else {
        char v57 = 1;
      }
      if ((v57 & 1) != 0 || ((*(unsigned __int8 *)(v56 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
      {
        *v51++ = v52;
        ++v18;
      }
    }
    while (v50 < v42);
  }
  char v19 = 0;
  LOBYTE(a4) = v109;
LABEL_118:
  if ((a4 & 0x90) != 0)
  {
    LODWORD(v59) = (a4 & 0x80) == 0 || v113 > 0x50F;
    if (v18) {
      goto LABEL_126;
    }
    *a6 = v113;
    if (v59)
    {
      if (v17 < 0 || (int64_t v68 = *((void *)buffer + 20), v68 <= v17))
      {
        unsigned int v71 = 0;
      }
      else
      {
        uint64_t v69 = *((void *)buffer + 17);
        if (v69)
        {
          UniChar v70 = *(_WORD *)(v69 + 2 * (*((void *)buffer + 19) + v17));
        }
        else
        {
          uint64_t v78 = *((void *)buffer + 18);
          if (v78)
          {
            UniChar v70 = *(char *)(v78 + *((void *)buffer + 19) + v17);
          }
          else
          {
            if (*((void *)buffer + 22) <= v17 || (int64_t v79 = *((void *)buffer + 21), v79 > v17))
            {
              int64_t v80 = v17 - 4;
              if ((unint64_t)v17 < 4) {
                int64_t v80 = 0;
              }
              if (v80 + 64 < v68) {
                int64_t v68 = v80 + 64;
              }
              *((void *)buffer + 21) = v80;
              *((void *)buffer + 22) = v68;
              v117.CFIndex location = *((void *)buffer + 19) + v80;
              v117.CFIndex length = v68 - v80;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v117, buffer);
              int64_t v79 = *((void *)buffer + 21);
            }
            UniChar v70 = buffer[v17 - v79];
          }
        }
        unsigned int v71 = v70;
        if (v70 >> 10 == 54)
        {
          int64_t v81 = v17 + 1;
          int64_t v82 = *((void *)buffer + 20);
          if (v82 > v17 + 1)
          {
            uint64_t v83 = *((void *)buffer + 17);
            if (v83)
            {
              UniChar v84 = *(_WORD *)(v83 + 2 * (*((void *)buffer + 19) + v81));
            }
            else
            {
              uint64_t v85 = *((void *)buffer + 18);
              if (v85)
              {
                UniChar v84 = *(char *)(v85 + *((void *)buffer + 19) + v81);
              }
              else
              {
                if (*((void *)buffer + 22) <= v81 || (int64_t v88 = *((void *)buffer + 21), v88 > v81))
                {
                  int64_t v89 = v17 - 3;
                  if ((unint64_t)v17 < 3) {
                    int64_t v89 = 0;
                  }
                  if (v89 + 64 < v82) {
                    int64_t v82 = v89 + 64;
                  }
                  *((void *)buffer + 21) = v89;
                  *((void *)buffer + 22) = v82;
                  v119.CFIndex location = *((void *)buffer + 19) + v89;
                  v119.CFIndex length = v82 - v89;
                  CFStringGetCharacters(*((CFStringRef *)buffer + 16), v119, buffer);
                  int64_t v88 = *((void *)buffer + 21);
                }
                UniChar v84 = buffer[v81 - v88];
              }
            }
            if (v84 >> 10 == 55)
            {
              unsigned int v71 = (v71 << 10) + v84 - 56613888;
              uint64_t v59 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v71));
              uint64_t v72 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v71));
              if (!v59) {
                goto LABEL_200;
              }
LABEL_151:
              uint64_t v73 = (unsigned __int16)v71 >> 3;
              int v74 = 1 << (v71 & 7);
              if ((v74 & *(unsigned char *)(v59 + v73)) == 0)
              {
                uint64_t v18 = 0;
                LODWORD(v59) = 0;
                goto LABEL_201;
              }
              if ((a4 & 0x80) != 0 && v71 < 0x510)
              {
                uint64_t v18 = 1;
              }
              else if (v72 && (v74 & *(unsigned char *)(v72 + v73)) != 0)
              {
                uint64_t v75 = CFUniCharDecomposeCharacter(v71, a6 + 1, 63);
                uint64_t v18 = v75 + 1;
                if (v111 && !v75)
                {
                  uint64_t v18 = 1;
                  *long long v111 = 1;
                }
              }
              else
              {
                a6[1] = v71;
                uint64_t v18 = 2;
              }
              BOOL v76 = v59 == __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
              LODWORD(v59) = 1;
              if (v76) {
                uint64_t v77 = 1;
              }
              else {
                uint64_t v77 = 2;
              }
              v17 += v77;
LABEL_126:
              if (v18 > 63)
              {
LABEL_127:
                if (v111) {
                  *long long v111 = 1;
                }
LABEL_129:
                if (v18 >= 2)
                {
                  uint64_t v60 = a7;
                  uint64_t v61 = &a6[v18];
                  uint64_t v62 = -4;
                  do
                  {
                    uint64_t v63 = v62;
                    UniChar v64 = (unsigned int *)((char *)v61 + v62);
                    if ((unsigned int *)((char *)v61 + v62) <= a6) {
                      break;
                    }
                    unsigned int v65 = *v64;
                    if (HIWORD(*v64))
                    {
                      uint64_t v66 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(*v64));
                      if (!v66) {
                        break;
                      }
                    }
                    else
                    {
                      uint64_t v66 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
                      if (!__CFStringFoldCharacterClusterAtIndex_graphemeBMP) {
                        break;
                      }
                    }
                    uint64_t v62 = v63 - 4;
                  }
                  while (((*(unsigned __int8 *)(v66 + ((unsigned __int16)v65 >> 3)) >> (v65 & 7)) & 1) != 0);
                  if (-v63 >= 5) {
                    CFUniCharPrioritySort(v64, (unint64_t)-v63 >> 2);
                  }
                  a7 = v60;
                }
                goto LABEL_140;
              }
LABEL_201:
              while ((v17 & 0x8000000000000000) == 0)
              {
                int64_t v90 = *((void *)buffer + 20);
                if (v90 <= v17) {
                  break;
                }
                uint64_t v91 = *((void *)buffer + 17);
                if (v91)
                {
                  UniChar v92 = *(_WORD *)(v91 + 2 * (*((void *)buffer + 19) + v17));
                }
                else
                {
                  uint64_t v99 = *((void *)buffer + 18);
                  if (v99)
                  {
                    UniChar v92 = *(char *)(v99 + *((void *)buffer + 19) + v17);
                  }
                  else
                  {
                    if (*((void *)buffer + 22) <= v17 || (int64_t v100 = *((void *)buffer + 21), v100 > v17))
                    {
                      int64_t v101 = v17 - 4;
                      if ((unint64_t)v17 < 4) {
                        int64_t v101 = 0;
                      }
                      if (v101 + 64 < v90) {
                        int64_t v90 = v101 + 64;
                      }
                      *((void *)buffer + 21) = v101;
                      *((void *)buffer + 22) = v90;
                      v120.CFIndex location = *((void *)buffer + 19) + v101;
                      v120.CFIndex length = v90 - v101;
                      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v120, buffer);
                      int64_t v100 = *((void *)buffer + 21);
                    }
                    UniChar v92 = buffer[v17 - v100];
                  }
                }
                unsigned int v113 = v92;
                if (v92 >> 10 != 54) {
                  goto LABEL_206;
                }
                int64_t v102 = v17 + 1;
                int64_t v103 = *((void *)buffer + 20);
                if (v103 <= v17 + 1) {
                  goto LABEL_206;
                }
                uint64_t v104 = *((void *)buffer + 17);
                if (v104)
                {
                  UniChar v105 = *(_WORD *)(v104 + 2 * (*((void *)buffer + 19) + v102));
                }
                else
                {
                  uint64_t v106 = *((void *)buffer + 18);
                  if (v106)
                  {
                    UniChar v105 = *(char *)(v106 + *((void *)buffer + 19) + v102);
                  }
                  else
                  {
                    if (*((void *)buffer + 22) <= v102 || (int64_t v107 = *((void *)buffer + 21), v107 > v102))
                    {
                      int64_t v108 = v17 - 3;
                      if ((unint64_t)v17 < 3) {
                        int64_t v108 = 0;
                      }
                      if (v108 + 64 < v103) {
                        int64_t v103 = v108 + 64;
                      }
                      *((void *)buffer + 21) = v108;
                      *((void *)buffer + 22) = v103;
                      v121.CFIndex location = *((void *)buffer + 19) + v108;
                      v121.CFIndex length = v103 - v108;
                      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v121, buffer);
                      int64_t v107 = *((void *)buffer + 21);
                    }
                    UniChar v105 = buffer[v102 - v107];
                  }
                }
                if (v105 >> 10 != 55) {
                  goto LABEL_206;
                }
                unsigned int v113 = ((unsigned __int16)v113 << 10) + v105 - 56613888;
                uint64_t v93 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v113));
                uint64_t v94 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v113));
                if (v19) {
                  goto LABEL_222;
                }
LABEL_207:
                if (!v93) {
                  goto LABEL_129;
                }
                uint64_t v95 = (unsigned __int16)v113 >> 3;
                int v96 = 1 << (v113 & 7);
                if ((v96 & *(unsigned char *)(v93 + v95)) == 0) {
                  goto LABEL_129;
                }
                if (v59)
                {
                  if (v94 && (v96 & *(unsigned char *)(v94 + v95)) != 0)
                  {
                    uint64_t v97 = CFUniCharDecomposeCharacter(v113, &a6[v18], 64 - v18);
                    v18 += v97;
                    if (!v97) {
                      goto LABEL_127;
                    }
                  }
                  else
                  {
                    a6[v18++] = v113;
                  }
                }
                else if ((unint64_t)v18 <= 1)
                {
                  uint64_t v18 = 1;
                }
                if (v93 == __CFStringFoldCharacterClusterAtIndex_graphemeBMP) {
                  uint64_t v98 = 1;
                }
                else {
                  uint64_t v98 = 2;
                }
                v17 += v98;
LABEL_222:
                char v19 = 0;
                if (v18 >= 64) {
                  goto LABEL_127;
                }
              }
              unsigned int v113 = 0;
LABEL_206:
              uint64_t v93 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
              uint64_t v94 = __CFStringFoldCharacterClusterAtIndex_decompBMP;
              if (v19) {
                goto LABEL_222;
              }
              goto LABEL_207;
            }
          }
        }
      }
      uint64_t v59 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
      uint64_t v72 = __CFStringFoldCharacterClusterAtIndex_decompBMP;
      if (__CFStringFoldCharacterClusterAtIndex_graphemeBMP) {
        goto LABEL_151;
      }
    }
LABEL_200:
    uint64_t v18 = 0;
    goto LABEL_201;
  }
LABEL_140:
  if (a7 && v18 >= 1) {
    *a7 = v17 - v110;
  }
  return v18;
}

CFIndex CFStringGetHyphenationLocationBeforeIndex(CFStringRef string, CFIndex location, CFRange limitRange, CFOptionFlags options, CFLocaleRef locale, UTF32Char *character)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  CFIndex result = -1;
  if (string)
  {
    if (locale)
    {
      CFIndex v9 = limitRange.location;
      if ((limitRange.location & 0x8000000000000000) == 0)
      {
        int length = limitRange.length;
        if (limitRange.length >= 1
          && limitRange.location <= location
          && limitRange.location + limitRange.length >= location)
        {
          if (limitRange.length <= CFStringGetLength(string))
          {
            if (character) {
              *character = 45;
            }
            v16[0] = 0;
            uint64_t HyphenationLocations = _CFHyphenationGetHyphenationLocations(string, location, v9, length, options, locale, (uint64_t)v16, 1);
            if (v16[0] >= location || HyphenationLocations <= 0) {
              return -1;
            }
            else {
              return v16[0];
            }
          }
          else
          {
            return -1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t _CFHyphenationGetHyphenationLocations(const __CFString *a1, CFIndex a2, CFIndex a3, int a4, uint64_t a5, CFLocaleRef locale, uint64_t a7, uint64_t a8)
{
  CFLocaleRef v9 = locale;
  uint64_t v109 = *(void *)off_1ECE0A5B0;
  uint64_t v15 = 100;
  if (a8 < 100) {
    uint64_t v15 = a8;
  }
  uint64_t v106 = v15;
  if (!CFStringIsHyphenationAvailableForLocale(locale)) {
    return -1;
  }
  uint64_t v105 = a5;
  CFStringRef Identifier = (__CFString *)CFLocaleGetIdentifier(v9);
  os_unfair_lock_lock_with_options();
  CFArrayRef TokenizersForLocale = (const __CFArray *)getTokenizersForLocale(Identifier);
  if (!TokenizersForLocale || (CFArrayRef v18 = TokenizersForLocale, (Count = CFArrayGetCount(TokenizersForLocale)) == 0))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
    goto LABEL_9;
  }
  CFStringRef v104 = a1;
  uint64_t v20 = a7;
  int v21 = a4;
  CFIndex v22 = a3;
  CFLocaleRef v23 = v9;
  CFIndex v24 = a2;
  CFIndex v25 = Count - 1;
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v18, Count - 1);
  CFIndex v27 = v25;
  a2 = v24;
  CFLocaleRef v9 = v23;
  a3 = v22;
  a4 = v21;
  a7 = v20;
  a1 = v104;
  CFArrayRemoveValueAtIndex(v18, v27);
  os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
  if (!ValueAtIndex)
  {
LABEL_9:
    int v107 = 0;
    CFStringGetCString(Identifier, (char *)v108, 256, 0x8000100u);
    CFStringRef ValueAtIndex = (const void *)ubrk_open();
    if (!ValueAtIndex) {
      return 0;
    }
  }
  CFStringRef v104 = (const __CFString *)a7;
  CFIndex Length = CFStringGetLength(a1);
  unsigned int v30 = &v92;
  int v31 = a2 + 20 - a3;
  if (a2 <= a3) {
    int v31 = a4;
  }
  if (a2 + 20 <= Length) {
    int v32 = v31;
  }
  else {
    int v32 = Length - a3;
  }
  CFIndex v33 = v32;
  int v107 = 0;
  MEMORY[0x1F4188790](Length, v29);
  uint64_t v35 = (char *)&v92 - v34;
  v110.CFIndex location = a3;
  v110.int length = v33;
  CFStringGetCharacters(a1, v110, (UniChar *)((char *)&v92 - v34));
  ubrk_setText();
  int v36 = ubrk_last();
  if (v36 != -1)
  {
    int v37 = v36;
    int64_t v103 = v35;
    uint64_t v38 = 0;
    CFIndex v100 = a2;
    int v39 = a2 - a3;
    CFAllocatorRef v102 = 0;
    CFIndex v99 = a3 + 1;
    CFAllocatorRef v101 = (CFAllocatorRef)&__kCFAllocatorNull;
    char v40 = v105;
    while (1)
    {
      do
      {
        int v41 = v37;
        uint64_t v42 = ubrk_preceding();
        if (v42 == -1) {
          goto LABEL_103;
        }
        int v37 = v42;
      }
      while ((int)v42 >= v39);
      uint64_t v43 = (v41 - v42);
      if ((int)v43 < 5) {
        goto LABEL_98;
      }
      uint64_t v44 = &v103[2 * (int)v42];
      int v45 = *(unsigned __int16 *)v44;
      if (v45 == 39)
      {
        uint64_t v46 = 1;
        goto LABEL_39;
      }
      if (v45 == 99)
      {
LABEL_27:
        int v49 = *((unsigned __int16 *)v44 + 1);
        uint64_t v46 = 2;
        if (v49 == 39 || v49 == 8217) {
          goto LABEL_39;
        }
      }
      else
      {
        uint64_t v46 = 1;
        if (v45 == 8217) {
          goto LABEL_39;
        }
        uint64_t v47 = 0;
        while (v47 != 7)
        {
          int v48 = __CFHyphenationRangeOfCharactersExcludingContraction_singleCharacterPrefixes[v47++ + 3];
          if (v48 == v45)
          {
            if ((unint64_t)(v47 - 1) > 6) {
              break;
            }
            goto LABEL_27;
          }
        }
      }
      if (v45 == 113 && *((_WORD *)v44 + 1) == 117)
      {
        int v50 = *((unsigned __int16 *)v44 + 2);
        BOOL v51 = v50 == 8217 || v50 == 39;
        uint64_t v46 = 3;
        if (!v51) {
          uint64_t v46 = 0;
        }
      }
      else
      {
        uint64_t v46 = 0;
      }
LABEL_39:
      unint64_t v52 = v43 - v46;
      if (v43 - v46 >= 1)
      {
        uint64_t v53 = (v43 - 1);
        int v54 = *(unsigned __int16 *)&v44[2 * v53];
        if (v54 == 8217 || v54 == 39)
        {
          LODWORD(v53) = v43 - 2;
          goto LABEL_43;
        }
        if (v52 >= 2)
        {
          int v74 = (unsigned __int16 *)&v44[2 * (int)v43];
          int v77 = *(v74 - 2);
          uint64_t v75 = v74 - 2;
          int v76 = v77;
          if ((v77 == 8217 || v76 == 39) && (unsigned int v78 = v54 - 100, v78 <= 0x10) && ((1 << v78) & 0x18001) != 0)
          {
            LODWORD(v53) = v43 - 3;
LABEL_43:
            uint64_t v53 = (int)v53;
          }
          else if (v52 >= 3)
          {
            int v83 = *(unsigned __int16 *)&v44[2 * (int)v43 - 6];
            if (v83 == 8217 || v83 == 39)
            {
              unint64_t v84 = 0;
              BOOL v85 = 1;
              int64_t v86 = &word_182EDED12;
              do
              {
                if (v76 == (unsigned __int16)*(v86 - 1))
                {
                  uint64_t v42 = (unsigned __int16)*v86;
                  if (v75[1] == v42) {
                    break;
                  }
                }
                BOOL v85 = v84 < 4;
                v86 += 2;
                ++v84;
              }
              while (v84 != 5);
              if (v85) {
                uint64_t v53 = (int)v43 - 4;
              }
            }
          }
        }
        BOOL v55 = v53 <= v46;
        uint64_t v56 = v53 - v46;
        if (v55) {
          uint64_t v57 = 0;
        }
        else {
          uint64_t v57 = v46;
        }
        if (v55) {
          CFIndex v58 = (v41 - v37);
        }
        else {
          CFIndex v58 = v56 + 1;
        }
        if (v58 < 5) {
          goto LABEL_98;
        }
        uint64_t v98 = v30;
        uint64_t v93 = v37;
        CFIndex v95 = a3 + v37;
        MEMORY[0x1F4188790](v42, &v44[2 * v57]);
        uint64_t v61 = (char *)&v92 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0);
        unint64_t v62 = 0;
        do
        {
          BOOL v63 = 0;
          CFIndex v64 = v62 + 2;
          if (v62 >= 3 && v64 < v58) {
            BOOL v63 = v59[v62 - 1] - 97 <= 0x19 && v59[v62] - 65 < 0x1A;
          }
          v61[v62++] = v63;
        }
        while (v64 - 1 != v58);
        uint64_t v96 = v60;
        MutableWithExternalCharactersNoCFDictionaryRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy(v102, v59, v58, v58, v101);
        if (!MutableWithExternalCharactersNoCopy) {
          goto LABEL_103;
        }
        uint64_t v97 = &v92;
        uint64_t v66 = MutableWithExternalCharactersNoCopy;
        CFStringLowercase(MutableWithExternalCharactersNoCopy, v9);
        CFIndex v67 = (unsigned int *)__CFHyphenationCopyTrieInstance(v9);
        CFStringRef v68 = v66;
        if (v67)
        {
          uint64_t v69 = v67;
          v108[0] = 0;
          CFStringRef v94 = v68;
          CFBurstTrieContains((uint64_t)v67, v68, 0, v58, v108);
          CFBurstTrieRelease(v69);
          if (v108[0] >> 28 != 15)
          {
            CFStringRef v68 = v94;
            goto LABEL_77;
          }
          uint64_t v70 = v106;
          if (v106 < 1 || v108[0] == -1)
          {
            CFRelease(v94);
          }
          else
          {
            uint64_t v71 = 0;
            unsigned int v72 = ~v108[0];
            CFIndex v73 = v99 + v96 + v93;
            do
            {
              if (v72) {
                *((void *)&v104->isa + v71++) = v73;
              }
              if (v72 < 2) {
                break;
              }
              v72 >>= 1;
              ++v73;
            }
            while (v71 < v70);
            CFStringRef v68 = v94;
            if (v71 == -1) {
              goto LABEL_77;
            }
LABEL_83:
            CFRelease(v68);
            if (v71 >= 1)
            {
              v38 += v71;
              if (v106 - v71 < 1) {
                goto LABEL_103;
              }
              v106 -= v71;
              CFStringRef v104 = (const __CFString *)((char *)v104 + 8 * v71);
            }
          }
          char v40 = v105;
          unsigned int v30 = v98;
          goto LABEL_98;
        }
LABEL_77:
        CFIndex v79 = v58 - 200;
        if (v58 >= 200) {
          uint64_t v80 = 200;
        }
        else {
          uint64_t v80 = v58;
        }
        if (v58 <= 200) {
          CFIndex v79 = 0;
        }
        CFStringRef v81 = v68;
        uint64_t HyphensForString = __CFHyphenationGetHyphensForString(v68, 0, v80, (uint64_t)v61, v95 + v96 + v79, v100 - (v95 + v96 + v79), (uint64_t)v9, (uint64_t)v104, v106);
        CFStringRef v68 = v81;
        uint64_t v71 = HyphensForString;
        goto LABEL_83;
      }
LABEL_98:
      if ((v40 & 1) == 0) {
        goto LABEL_103;
      }
    }
  }
  uint64_t v38 = 0;
LABEL_103:
  int64_t v87 = (__CFString *)CFLocaleGetIdentifier(v9);
  os_unfair_lock_lock_with_options();
  CFArrayRef v88 = (const __CFArray *)getTokenizersForLocale(v87);
  if (v88 && (int64_t v89 = v88, v90 = CFArrayGetCount(v88), v90 <= 2))
  {
    CFArraySetValueAtIndex(v89, v90, ValueAtIndex);
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
    ubrk_close();
  }
  return v38;
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  v26[1] = *(void *)off_1ECE0A5B0;
  v26[0] = value;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    [(__CFArray *)theArray setObject:value atIndex:idx];
    return;
  }
  if (*((void *)theArray + 2) == idx)
  {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 0, v26, 1);
    return;
  }
  unsigned int v6 = atomic_load((unint64_t *)theArray + 1);
  int v7 = (v6 >> 2) & 3;
  if (v7)
  {
    if (v7 == 1)
    {
      uint64_t v8 = &kCFTypeArrayCallBacks;
      if (((unint64_t)theArray & 0x8000000000000000) == 0) {
        goto LABEL_20;
      }
    }
    else
    {
      char v9 = atomic_load((unint64_t *)theArray + 1);
      int v10 = v9 & 3;
      if (v10 == 2)
      {
        uint64_t v8 = (const CFArrayCallBacks *)((char *)theArray + 48);
        if (((unint64_t)theArray & 0x8000000000000000) == 0) {
          goto LABEL_20;
        }
      }
      else
      {
        if (v10) {
          uint64_t v8 = 0;
        }
        else {
          uint64_t v8 = (const CFArrayCallBacks *)((char *)theArray + 48);
        }
        if (((unint64_t)theArray & 0x8000000000000000) == 0) {
          goto LABEL_20;
        }
      }
    }
  }
  else
  {
    uint64_t v8 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
    if (((unint64_t)theArray & 0x8000000000000000) == 0)
    {
LABEL_20:
      char v12 = atomic_load((unint64_t *)theArray + 1);
      if (v12 < 0) {
        uint64_t v11 = &kCFAllocatorSystemDefault;
      }
      else {
        uint64_t v11 = (const CFAllocatorRef *)((char *)theArray - 16);
      }
      goto LABEL_23;
    }
  }
  uint64_t v11 = &kCFAllocatorSystemDefault;
LABEL_23:
  CFAllocatorRef v13 = *v11;
  char v14 = atomic_load((unint64_t *)theArray + 1);
  if ((v14 & 1 | 2) == 2)
  {
    char v15 = atomic_load((unint64_t *)theArray + 1);
    int v16 = v15 & 3;
    if (v16 == 2)
    {
      uint64_t v20 = (char *)(*((void *)theArray + 5) + 8 * **((void **)theArray + 5) + 16);
    }
    else if (v16)
    {
      uint64_t v20 = 0;
    }
    else
    {
      char v17 = atomic_load((unint64_t *)theArray + 1);
      BOOL v18 = (~v17 & 0xC) == 0;
      uint64_t v19 = 48;
      if (v18) {
        uint64_t v19 = 88;
      }
      uint64_t v20 = (char *)theArray + v19;
    }
    int v21 = (uint64_t *)&v20[8 * idx];
  }
  else
  {
    int v21 = 0;
  }
  retaiuint64_t n = (uint64_t (*)(void, void))v8->retain;
  uint64_t v23 = v26[0];
  if (retain) {
    uint64_t v23 = retain(v13, v26[0]);
  }
  uint64_t v24 = *v21;
  *int v21 = v23;
  release = (void (*)(CFAllocatorRef, uint64_t))v8->release;
  if (release) {
    release(v13, v24);
  }
  ++*((void *)theArray + 3);
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t v55 = *(void *)off_1ECE0A5B0;
  p_info = &theString->info;
  unsigned int v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString _cfUppercase:locale];
    return;
  }
  char v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    int v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringUppercase_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }
  char v15 = atomic_load((unint64_t *)&theString->info);
  uint64_t v16 = v15 & 5;
  char v17 = atomic_load((unint64_t *)&theString->info);
  uint64_t v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_data = &theString->data;
    if (v18)
    {
      uint64_t v20 = *p_data;
    }
    else
    {
      uint64_t v22 = atomic_load((unint64_t *)&theString->info);
      uint64_t v20 = (char *)&p_data[(v22 & 5) != 4];
    }
    uint64_t length = *v20;
  }
  else if ((v17 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }
  else
  {
    uint64_t length = (uint64_t)theString->data;
  }
  if (locale) {
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  }
  uint64_t v23 = 0;
  if (locale || ((v5 >> 4) & 1) != 0)
  {
LABEL_30:
    if (v23 >= length) {
      return;
    }
    if (((v5 >> 4) & 1) == 0)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
    }
    char v31 = atomic_load((unint64_t *)&theString->info);
    int v32 = &theString->data;
    if ((v31 & 0x60) != 0)
    {
      unint64_t v33 = (unint64_t)*v32;
    }
    else
    {
      char v34 = atomic_load((unint64_t *)&theString->info);
      unint64_t v33 = (unint64_t)&v32[(v34 & 5) != 4];
    }
    unsigned int ConditionalCaseMappingFlags = 0;
    while (1)
    {
      unsigned int v36 = *(unsigned __int16 *)(v33 + 2 * v23);
      uint64_t v37 = v23 + 1;
      if ((v36 & 0xFC00) == 0xD800 && v37 < length)
      {
        int v44 = *(unsigned __int16 *)(v33 + 2 * v37);
        if ((v44 & 0xFC00) == 0xDC00) {
          unsigned int v36 = v44 + (v36 << 10) - 56613888;
        }
      }
      if (locale) {
        unsigned int ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags(v36, v33, v23, length, 1, (unsigned __int16 *)locale, ConditionalCaseMappingFlags);
      }
      else {
        unsigned int ConditionalCaseMappingFlags = 0;
      }
      uint64_t v39 = CFUniCharMapCaseTo(v36, &v53, 8, 1, ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      uint64_t v40 = v39 - 1;
      if (v39 >= 1) {
        *(_WORD *)(v33 + 2 * v23) = v53;
      }
      if (v36 < 0x10000)
      {
        if (!v39)
        {
          uint64_t v51 = v23;
LABEL_61:
          uint64_t v52 = 1;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
          char v45 = atomic_load((unint64_t *)&theString->info);
          if ((v45 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }
          else
          {
            char v47 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v47 & 5) != 4];
          }
          --length;
          goto LABEL_74;
        }
        if (v39 >= 2)
        {
          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v40, 1);
          char v43 = atomic_load((unint64_t *)&theString->info);
          if ((v43 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }
          else
          {
            char v48 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v48 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v40;
LABEL_73:
          v23 += v40;
        }
      }
      else
      {
        uint64_t v41 = v39 - 2;
        if (v39 != 2)
        {
          uint64_t v40 = v39 - 1;
          if (v39 == 1)
          {
            uint64_t v51 = v23 + 1;
            goto LABEL_61;
          }
          if (!v39)
          {
            uint64_t v51 = v23;
            uint64_t v52 = 2;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
            char v42 = atomic_load((unint64_t *)&theString->info);
            if ((v42 & 0x60) != 0)
            {
              unint64_t v33 = (unint64_t)*v32;
            }
            else
            {
              char v49 = atomic_load((unint64_t *)&theString->info);
              unint64_t v33 = (unint64_t)&v32[(v49 & 5) != 4];
            }
            length -= 2;
            goto LABEL_74;
          }
          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v41, 1);
          char v46 = atomic_load((unint64_t *)&theString->info);
          if ((v46 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }
          else
          {
            char v50 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v50 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v41;
          goto LABEL_73;
        }
        ++v23;
        *(_WORD *)(v33 + 2 * v23) = v54[0];
      }
LABEL_74:
      if (++v23 >= length) {
        return;
      }
    }
  }
  char v24 = atomic_load((unint64_t *)&theString->info);
  CFIndex v25 = &theString->data;
  if ((v24 & 0x60) != 0)
  {
    unsigned __int16 v26 = *v25;
  }
  else
  {
    char v27 = atomic_load((unint64_t *)&theString->info);
    unsigned __int16 v26 = (char *)&v25[(v27 & 5) != 4];
  }
  unint64_t v28 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    uint64_t v23 = 0;
    uint64_t v29 = &v26[(v28 >> 2) & 1];
    do
    {
      int v30 = v29[v23];
      if ((v30 - 97) > 0x19)
      {
        if (v30 < 0) {
          goto LABEL_30;
        }
      }
      else
      {
        v29[v23] = v30 - 32;
      }
      ++v23;
    }
    while (length != v23);
  }
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t v55 = *(void *)off_1ECE0A5B0;
  p_info = &theString->info;
  unsigned int v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString _cfLowercase:locale];
    return;
  }
  char v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    int v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringLowercase_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }
  char v15 = atomic_load((unint64_t *)&theString->info);
  uint64_t v16 = v15 & 5;
  char v17 = atomic_load((unint64_t *)&theString->info);
  uint64_t v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_data = &theString->data;
    if (v18)
    {
      uint64_t v20 = *p_data;
    }
    else
    {
      uint64_t v22 = atomic_load((unint64_t *)&theString->info);
      uint64_t v20 = (char *)&p_data[(v22 & 5) != 4];
    }
    uint64_t length = *v20;
  }
  else if ((v17 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }
  else
  {
    uint64_t length = (uint64_t)theString->data;
  }
  if (locale) {
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  }
  uint64_t v23 = 0;
  if (locale || ((v5 >> 4) & 1) != 0)
  {
LABEL_30:
    if (v23 >= length) {
      return;
    }
    if (((v5 >> 4) & 1) == 0)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
    }
    char v31 = atomic_load((unint64_t *)&theString->info);
    int v32 = &theString->data;
    if ((v31 & 0x60) != 0)
    {
      unint64_t v33 = (unint64_t)*v32;
    }
    else
    {
      char v34 = atomic_load((unint64_t *)&theString->info);
      unint64_t v33 = (unint64_t)&v32[(v34 & 5) != 4];
    }
    unsigned int ConditionalCaseMappingFlags = 0;
    while (1)
    {
      unsigned int v36 = *(unsigned __int16 *)(v33 + 2 * v23);
      uint64_t v37 = v23 + 1;
      if ((v36 & 0xFC00) == 0xD800 && v37 < length)
      {
        int v44 = *(unsigned __int16 *)(v33 + 2 * v37);
        if ((v44 & 0xFC00) == 0xDC00) {
          unsigned int v36 = v44 + (v36 << 10) - 56613888;
        }
      }
      if (locale || v36 == 931) {
        unsigned int ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags(v36, v33, v23, length, 0, (unsigned __int16 *)locale, ConditionalCaseMappingFlags);
      }
      else {
        unsigned int ConditionalCaseMappingFlags = 0;
      }
      uint64_t v39 = CFUniCharMapCaseTo(v36, &v53, 8, 0, ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      uint64_t v40 = v39 - 1;
      if (v39 >= 1) {
        *(_WORD *)(v33 + 2 * v23) = v53;
      }
      if (v36 < 0x10000)
      {
        if (!v39)
        {
          uint64_t v51 = v23;
LABEL_62:
          uint64_t v52 = 1;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
          char v45 = atomic_load((unint64_t *)&theString->info);
          if ((v45 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }
          else
          {
            char v47 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v47 & 5) != 4];
          }
          --length;
          goto LABEL_75;
        }
        if (v39 >= 2)
        {
          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v40, 1);
          char v43 = atomic_load((unint64_t *)&theString->info);
          if ((v43 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }
          else
          {
            char v48 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v48 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v40;
LABEL_74:
          v23 += v40;
        }
      }
      else
      {
        uint64_t v41 = v39 - 2;
        if (v39 != 2)
        {
          uint64_t v40 = v39 - 1;
          if (v39 == 1)
          {
            uint64_t v51 = v23 + 1;
            goto LABEL_62;
          }
          if (!v39)
          {
            uint64_t v51 = v23;
            uint64_t v52 = 2;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
            char v42 = atomic_load((unint64_t *)&theString->info);
            if ((v42 & 0x60) != 0)
            {
              unint64_t v33 = (unint64_t)*v32;
            }
            else
            {
              char v49 = atomic_load((unint64_t *)&theString->info);
              unint64_t v33 = (unint64_t)&v32[(v49 & 5) != 4];
            }
            length -= 2;
            goto LABEL_75;
          }
          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v41, 1);
          char v46 = atomic_load((unint64_t *)&theString->info);
          if ((v46 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }
          else
          {
            char v50 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v50 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v41;
          goto LABEL_74;
        }
        ++v23;
        *(_WORD *)(v33 + 2 * v23) = v54[0];
      }
LABEL_75:
      if (++v23 >= length) {
        return;
      }
    }
  }
  char v24 = atomic_load((unint64_t *)&theString->info);
  CFIndex v25 = &theString->data;
  if ((v24 & 0x60) != 0)
  {
    unsigned __int16 v26 = *v25;
  }
  else
  {
    char v27 = atomic_load((unint64_t *)&theString->info);
    unsigned __int16 v26 = (char *)&v25[(v27 & 5) != 4];
  }
  unint64_t v28 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    uint64_t v23 = 0;
    uint64_t v29 = &v26[(v28 >> 2) & 1];
    do
    {
      int v30 = v29[v23];
      if ((v30 - 65) > 0x19)
      {
        if ((v30 & 0x80) != 0) {
          goto LABEL_30;
        }
      }
      else
      {
        v29[v23] = v30 + 32;
      }
      ++v23;
    }
    while (length != v23);
  }
}

uint64_t _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(const __CFLocale *a1, int a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (!__CFLocaleGetDoesNotRequireSpecialCaseHandling(a1))
  {
    os_unfair_lock_lock_with_options();
    uint64_t v5 = _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLocale;
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lock);
    if (v5) {
      BOOL v6 = v5 == (void)a1;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      return _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLangID;
    }
    if (a2) {
      CFStringRef Value = (const __CFString *)CFLocaleGetValue(a1, @"locale:collator id");
    }
    else {
      CFStringRef Value = CFLocaleGetIdentifier(a1);
    }
    CFStringRef v8 = Value;
    if (CFStringGetLength(Value) >= 2)
    {
      uint64_t CStringPtrInternal = (UInt8 *)_CFStringGetCStringPtrInternal(v8, 134217984, 1, 1);
      if (CStringPtrInternal
        || (uint64_t CStringPtrInternal = buffer,
            v13.CFIndex location = 0,
            v13.uint64_t length = 2,
            CFStringGetBytes(v8, v13, 0x8000100u, 0, 0, buffer, 2, 0) == 2))
      {
        uint64_t v4 = "az";
        if (!strncmp((const char *)CStringPtrInternal, "az", 2uLL)
          || (uint64_t v4 = "lt", !strncmp((const char *)CStringPtrInternal, "lt", 2uLL))
          || (uint64_t v4 = "tr", !strncmp((const char *)CStringPtrInternal, "tr", 2uLL))
          || (uint64_t v4 = "nl", !strncmp((const char *)CStringPtrInternal, "nl", 2uLL))
          || (uint64_t v4 = "el", !strncmp((const char *)CStringPtrInternal, "el", 2uLL)))
        {
          os_unfair_lock_lock_with_options();
          _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLocale = (uint64_t)a1;
          _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLangID = (uint64_t)v4;
          os_unfair_lock_unlock((os_unfair_lock_t)&_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lock);
          return (uint64_t)v4;
        }
      }
    }
  }
  return 0;
}

uint64_t __CFLocaleGetDoesNotRequireSpecialCaseHandling(void *a1)
{
  return [a1 _doesNotRequireSpecialCaseHandling];
}

uint64_t CFUniCharMapCaseTo(unsigned int a1, __int16 *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, unsigned __int16 *a6)
{
  uint64_t v8 = a4;
  *(void *)&v62[36] = *(void *)off_1ECE0A5B0;
  uint64_t v10 = (a1 == 931) & a5;
  uint64_t v11 = (unsigned int *)v62;
  unsigned int v58 = a1 & 0xFFFFFFDF;
  BOOL v12 = (a5 & 2) != 0 && a1 == 775;
  int v13 = !v12;
  uint64_t v14 = BYTE2(a1);
  int v15 = 1 << (a1 & 7);
  uint64_t v60 = (unsigned __int16)a1 >> 3;
  int v55 = a4;
  uint64_t v16 = __CFUniCharBitmapDataArray;
  while (1)
  {
    if (v10)
    {
      BOOL v31 = v55 == 0;
      __int16 v32 = 931;
      __int16 v33 = 962;
      goto LABEL_75;
    }
    if (!a6) {
      goto LABEL_51;
    }
    if ((a5 & 0x10) != 0)
    {
      if (a1 == 769) {
        return 0;
      }
      if (a1 == 836)
      {
        __int16 v32 = 776;
        goto LABEL_77;
      }
      char v17 = v16;
      uint64_t v18 = v10;
      int IsMemberOf = CFUniCharIsMemberOf(a1, 9u);
      uint64_t v10 = v18;
      uint64_t v16 = v17;
      if (IsMemberOf) {
        break;
      }
    }
LABEL_19:
    unsigned int v23 = *a6;
    if (v23 <= 0x746B)
    {
      if (v23 == 27758)
      {
        if (v58 == 74)
        {
          if ((a5 & 8) != 0) {
            __int16 v41 = 74;
          }
          else {
            __int16 v41 = 106;
          }
          if ((v8 - 1) >= 2) {
            __int16 v32 = v41;
          }
          else {
            __int16 v32 = 74;
          }
          goto LABEL_77;
        }
        goto LABEL_51;
      }
      if (v23 != 29300) {
        goto LABEL_51;
      }
LABEL_31:
      if ((int)a1 <= 304)
      {
        if (a1 == 73) {
          goto LABEL_103;
        }
        if (a1 == 105 || a1 == 304)
        {
          BOOL v31 = v8 == 3 || v8 == 0;
          __int16 v32 = 304;
          __int16 v33 = 105;
          goto LABEL_75;
        }
      }
      else if (a1 == 775)
      {
        if ((a5 & 2) != 0)
        {
          if (!v8) {
            return 0;
          }
          __int16 v32 = 775;
LABEL_77:
          *a2 = v32;
          return 1;
        }
      }
      else if (a1 == 305)
      {
LABEL_103:
        if (v8 != 3 && v8)
        {
          __int16 v32 = 73;
          goto LABEL_77;
        }
        BOOL v31 = (a5 & 4) == 0;
        __int16 v32 = 105;
        __int16 v33 = 305;
LABEL_75:
        if (v31) {
          __int16 v32 = v33;
        }
        goto LABEL_77;
      }
      goto LABEL_51;
    }
    if (v23 == 31329) {
      goto LABEL_31;
    }
    if (v23 != 29804) {
      goto LABEL_51;
    }
    if (!v13) {
      return 0;
    }
    if (v8) {
      goto LABEL_51;
    }
    if ((a5 & 4) != 0)
    {
      if ((int)a1 > 204)
      {
        switch(a1)
        {
          case 0xCDu:
            goto LABEL_126;
          case 0x128u:
LABEL_127:
            char v46 = a2;
            *(_DWORD *)a2 = 50790505;
            __int16 v47 = 771;
            goto LABEL_128;
          case 0x12Eu:
            unsigned __int16 v48 = 303;
            goto LABEL_137;
        }
        goto LABEL_51;
      }
      if (a1 == 73)
      {
        unsigned __int16 v48 = 105;
LABEL_137:
        *(_DWORD *)a2 = v48 | 0x3070000;
        return 2;
      }
      if (a1 == 74)
      {
        unsigned __int16 v48 = 106;
        goto LABEL_137;
      }
    }
    else
    {
      if (a1 == 296) {
        goto LABEL_127;
      }
      if (a1 == 205)
      {
LABEL_126:
        char v46 = a2;
        *(_DWORD *)a2 = 50790505;
        __int16 v47 = 769;
        goto LABEL_128;
      }
    }
    if (a1 == 204)
    {
      char v46 = a2;
      *(_DWORD *)a2 = 50790505;
      __int16 v47 = 768;
LABEL_128:
      v46[2] = v47;
      return 3;
    }
LABEL_51:
    if ((v8 + 87) >= 0x54) {
      unsigned int v24 = v8 + 103;
    }
    else {
      unsigned int v24 = v8 + 188;
    }
    if (v8 == -102) {
      unsigned int v25 = 108;
    }
    else {
      unsigned int v25 = v24;
    }
    if (v25 > 0x63) {
      v25 -= 85;
    }
    uint64_t v26 = v25 - 4;
    if (v14 < LODWORD(v16[2 * v26]))
    {
      uint64_t v27 = *(void *)(v16[2 * v26 + 1] + 8 * v14);
      if (v27)
      {
        if ((v15 & *(unsigned char *)(v27 + v60)) != 0)
        {
          char v34 = (&__CFUniCharCaseMappingTable)[v8];
          if (*v34 <= a1)
          {
            uint64_t v35 = &v34[2 * (__CFUniCharCaseMappingTableCounts[v8] - 1)];
            if (*v35 >= a1)
            {
              do
              {
                unsigned int v36 = (unsigned int *)&v34[2 * (((char *)v35 - (char *)v34) >> 4)];
                if (*v36 <= a1)
                {
                  if (*v36 >= a1)
                  {
                    unsigned int v37 = v36[1];
LABEL_89:
                    if (v8 != 2 || v37)
                    {
                      if (!v37) {
                        goto LABEL_63;
                      }
                      goto LABEL_107;
                    }
                    if (a1 - 125252 < 0xFFFE171D) {
                      goto LABEL_63;
                    }
                    uint64_t v38 = (unsigned int *)&__CFUniCharToUppercaseMappingTable;
                    uint64_t v39 = (unsigned int *)((char *)&__CFUniCharToUppercaseMappingTable + 12192);
                    while (1)
                    {
                      uint64_t v40 = &v38[2 * (((char *)v39 - (char *)v38) >> 4)];
                      if (*v40 <= a1)
                      {
                        if (*v40 >= a1)
                        {
                          unsigned int v37 = v40[1];
                          if (!v37) {
                            goto LABEL_63;
                          }
                          LODWORD(v8) = 1;
LABEL_107:
                          uint64_t result = HIBYTE(v37) & 0x1F;
                          if (result == 1)
                          {
                            if ((v37 & 0x80000000) != 0)
                            {
                              if (a3 < 2) {
                                goto LABEL_63;
                              }
                              *a2 = (((v37 & 0xFFFC00) + 67043328) >> 10) - 10240;
                              a2[1] = v37 & 0x3FF | 0xDC00;
                              return 2;
                            }
                            *a2 = v37;
                            return 1;
                          }
                          if (result >= a3) {
                            goto LABEL_63;
                          }
                          char v42 = (unsigned int *)((char *)*(&__CFUniCharCaseMappingExtraTable + v8)
                                               + 4 * (v37 & 0xFFFFFF));
                          if ((v37 & 0x80000000) != 0)
                          {
                            if (!result) {
                              goto LABEL_63;
                            }
                            unint64_t v49 = result + 1;
                            uint64_t result = 0;
                            while (1)
                            {
                              unsigned int v51 = *v42++;
                              unsigned int v50 = v51;
                              if (v51 < 0x10000)
                              {
                                uint64_t v52 = result + 1;
                                __int16 v53 = a2;
                                if (result + 1 >= a3)
                                {
LABEL_147:
                                  if (v49 == 2) {
                                    return result;
                                  }
LABEL_63:
                                  if (a1 >= 0x10000)
                                  {
                                    *a2 = (((a1 & 0xFFFC00) + 67043328) >> 10) - 10240;
                                    a2[1] = a1 & 0x3FF | 0xDC00;
                                    return 2;
                                  }
                                  *a2 = a1;
                                  return 1;
                                }
                                __int16 v54 = v50;
                              }
                              else
                              {
                                uint64_t v52 = result + 2;
                                __int16 v53 = a2;
                                if (result + 2 >= a3) {
                                  goto LABEL_147;
                                }
                                a2[result++] = (((v50 & 0xFFFC00) + 67043328) >> 10) - 10240;
                                __int16 v54 = v50 & 0x3FF | 0xDC00;
                              }
                              v53[result] = v54;
                              --v49;
                              uint64_t result = v52;
                              if (v49 <= 1) {
                                goto LABEL_63;
                              }
                            }
                          }
                          if (result)
                          {
                            uint64_t v43 = HIBYTE(v37) & 0x1F;
                            int v44 = a2;
                            do
                            {
                              int v45 = *v42++;
                              *v44++ = v45;
                              --v43;
                            }
                            while (v43);
                            return result;
                          }
                          return 0;
                        }
                        uint64_t v38 = v40 + 2;
                      }
                      else
                      {
                        uint64_t v39 = v40 - 2;
                      }
                      if (v38 > v39) {
                        goto LABEL_63;
                      }
                    }
                  }
                  char v34 = (int *)(v36 + 2);
                }
                else
                {
                  uint64_t v35 = (int *)(v36 - 2);
                }
              }
              while (v34 <= v35);
            }
          }
          unsigned int v37 = 0;
          goto LABEL_89;
        }
      }
    }
    BOOL v12 = v8 == 3;
    uint64_t v8 = 0;
    if (!v12) {
      goto LABEL_63;
    }
  }
  int v57 = v15;
  uint64_t v20 = CFUniCharDecomposeCharacter(a1, &v61, 10);
  if (v20 < 2)
  {
LABEL_18:
    int v15 = v57;
    uint64_t v16 = v17;
    uint64_t v10 = v18;
    goto LABEL_19;
  }
  int v21 = (unsigned int *)&v62[4 * v20 - 4];
  uint64_t v22 = v62;
  while (*v22 != 769)
  {
    if (++v22 >= v21) {
      goto LABEL_18;
    }
  }
  uint64_t result = CFUniCharMapCaseTo(v61, a2, a3, v8, 0, a6);
  if (!result)
  {
    *a2 = v61;
    uint64_t result = 1;
  }
  do
  {
    unsigned int v29 = *v11;
    if (*v11 != 769)
    {
      if (HIWORD(v29))
      {
        int v30 = &a2[result];
        *int v30 = ((v29 + 67043328) >> 10) - 10240;
        result += 2;
        v30[1] = v29 & 0x3FF | 0xDC00;
      }
      else
      {
        a2[result++] = v29;
      }
    }
    ++v11;
  }
  while (v11 < v21);
  return result;
}

CFTypeRef getTokenizersForLocale(void *key)
{
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  cf[0] = 0;
  CFDictionaryRef Mutable = (const __CFDictionary *)gTokenizers;
  if (!gTokenizers)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    gTokenizers = (uint64_t)Mutable;
  }
  if (!CFDictionaryGetValueIfPresent(Mutable, key, cf))
  {
    CFMutableArrayRef v3 = CFArrayCreateMutable(0, 3, 0);
    cf[0] = v3;
    if (v3)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)gTokenizers, key, v3);
      CFRelease(cf[0]);
    }
  }
  return cf[0];
}

Boolean CFStringIsHyphenationAvailableForLocale(CFLocaleRef locale)
{
  if (locale)
  {
    locale = (CFLocaleRef)__CFHyphenationCopyTrieInstance(locale);
    if (locale)
    {
      CFBurstTrieRelease((unsigned int *)locale);
      LOBYTE(locale) = 1;
    }
  }
  return locale;
}

void *__CFHyphenationCopyTrieInstance(const __CFLocale *a1)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  CFLocaleIdentifier Identifier = CFLocaleGetIdentifier(a1);
  os_unfair_lock_lock_with_options();
  CFDictionaryRef v3 = (const __CFDictionary *)__CFHyphenationCopyTrieInstance_gTries;
  if (!__CFHyphenationCopyTrieInstance_gTries)
  {
    CFDictionaryValueCallBacks v14 = *(CFDictionaryValueCallBacks *)byte_1ECE10510;
    CFDictionaryRef v3 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &v14);
    __CFHyphenationCopyTrieInstance_gTries = (uint64_t)v3;
  }
  CFStringRef Value = CFDictionaryGetValue(v3, Identifier);
  if (Value)
  {
    uint64_t v5 = Value;
    CFBurstTrieRetain((uint64_t)Value);
    goto LABEL_16;
  }
  CFStringRef v6 = (const __CFString *)CFLocaleGetValue(a1, @"kCFLocaleLanguageCodeKey");
  CFTypeRef v7 = CFLocaleGetValue(a1, @"kCFLocaleCountryCodeKey");
  DictionaryPathForLanguageAndRegiouint64_t n = __CFHyphenationCreateDictionaryPathForLanguageAndRegion(v6, (unint64_t)v7);
  if (!DictionaryPathForLanguageAndRegion) {
    goto LABEL_15;
  }
  CFStringRef v9 = DictionaryPathForLanguageAndRegion;
  uint64_t v5 = CFBurstTrieCreateFromFile(DictionaryPathForLanguageAndRegion);
  CFRelease(v9);
  if (v7) {
    BOOL v10 = v5 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10) {
    goto LABEL_13;
  }
  CFStringRef v11 = __CFHyphenationCreateDictionaryPathForLanguageAndRegion(v6, 0);
  if (!v11)
  {
LABEL_15:
    uint64_t v5 = 0;
    goto LABEL_16;
  }
  CFStringRef v12 = v11;
  uint64_t v5 = CFBurstTrieCreateFromFile(v11);
  CFRelease(v12);
LABEL_13:
  if (v5) {
    CFDictionaryAddValue((CFMutableDictionaryRef)__CFHyphenationCopyTrieInstance_gTries, Identifier, v5);
  }
LABEL_16:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFHyphenationCopyTrieInstance_trieMutex);
  return v5;
}

uint64_t CFBurstTrieRetain(uint64_t result)
{
  return result;
}

uint64_t _CFPropertyListCreateFromUTF8Data(const __CFAllocator *a1, CFDataRef theData, uint64_t a3, const void *a4, CFStringEncoding a5, int a6, void *a7, char a8, void *a9, const __CFSet *a10, void *a11, char a12, char a13)
{
  v78[1] = *(CFTypeRef *)off_1ECE0A5B0;
  CFIndex Length = CFDataGetLength(theData);
  if (!Length)
  {
    if (!a7) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Conversion of string failed. The string is empty.");
    goto LABEL_8;
  }
  CFIndex v22 = Length;
  v78[0] = 0;
  *(_OWORD *)int v77 = 0u;
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)uint64_t v75 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  uint64_t v70 = &BytePtr[a3];
  if (__OFADD__(&BytePtr[a3], v22))
  {
    if (!a7) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to address entirety of CFPropertyList");
LABEL_8:
    unsigned int v25 = Error;
    goto LABEL_9;
  }
  uint64_t v27 = a9;
  uint64_t v71 = (char *)&BytePtr[a3];
  unint64_t v72 = (unint64_t)&BytePtr[v22];
  CFTypeRef v73 = 0;
  CFAllocatorRef v74 = a1;
  LODWORD(v75[0]) = a6;
  LOBYTE(cf[1]) = a8;
  LOBYTE(v77[1]) = 0;
  if (!a12) {
    goto LABEL_79;
  }
  CFRetain(theData);
  v75[1] = CFBurstTrieCreate();
  cf[0] = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  v77[0] = __CFPropertyListCreateTopLevelKeyPaths(a1, a10);
  while (1)
  {
    unint64_t v28 = v71;
    if ((unint64_t)v71 >= v72)
    {
      CFErrorRef v50 = __CFPropertyListCreateError(3840, @"Encountered unexpected EOF", v64, v66);
LABEL_69:
      CFTypeRef v51 = 0;
      int v52 = 0;
      CFTypeRef v73 = v50;
      goto LABEL_75;
    }
    unint64_t v29 = v72 - (void)v71;
    while (1)
    {
      unsigned int v30 = *v28;
      BOOL v31 = v30 > 0x20;
      uint64_t v32 = (1 << v30) & 0x100002600;
      if (v31 || v32 == 0) {
        break;
      }
      ++v28;
      if (!--v29)
      {
        unint64_t v28 = (char *)v72;
        break;
      }
    }
    uint64_t v71 = v28;
    if ((unint64_t)(v28 + 1) >= v72)
    {
      CFErrorRef v50 = __CFPropertyListCreateError(3840, @"No XML content found", v64, v66);
      goto LABEL_69;
    }
    uint64_t v34 = *v28;
    if (v34 != 60)
    {
      uint64_t v68 = lineNumber((unint64_t *)&v70);
      CFErrorRef v50 = __CFPropertyListCreateError(3840, @"Unexpected character %c at line %u", v34, v68);
      goto LABEL_69;
    }
    uint64_t v71 = v28 + 1;
    int v35 = v28[1];
    if (v35 == 63)
    {
      uint64_t v71 = v28 + 2;
      skipXMLProcessingInstruction((unint64_t *)&v70);
      goto LABEL_29;
    }
    if ((unsigned __int16)v35 != 33) {
      break;
    }
    unsigned int v36 = v28 + 2;
    uint64_t v71 = v28 + 2;
    if ((unint64_t)(v28 + 3) < v72 && *(unsigned char *)v36 == 45 && v28[3] == 45)
    {
      uint64_t v71 = v28 + 5;
      skipXMLComment((unint64_t *)&v70);
LABEL_29:
      if (v73) {
        goto LABEL_70;
      }
    }
    else
    {
      if ((uint64_t)(v72 - (void)v36) >= 7
        && (*v36 == 1413697348 ? (BOOL v37 = *(_DWORD *)(v28 + 5) == 1162893652) : (BOOL v37 = 0), v37))
      {
        uint64_t v39 = (unsigned __int8 *)(v28 + 9);
        uint64_t v71 = v28 + 9;
        if ((unint64_t)(v28 + 9) < v72)
        {
          uint64_t v40 = v72 - (void)v28 - 9;
          while (1)
          {
            unsigned int v41 = (char)*v39;
            BOOL v31 = v41 > 0x20;
            uint64_t v42 = (1 << v41) & 0x100002600;
            if (v31 || v42 == 0) {
              break;
            }
            uint64_t v71 = (char *)++v39;
            if (!--v40)
            {
              uint64_t v39 = (unsigned __int8 *)v72;
              break;
            }
          }
        }
        if ((unint64_t)v39 < v72)
        {
          unint64_t v44 = v72 - (void)v39;
          while (1)
          {
            int v45 = *v39;
            if (v45 == 91) {
              break;
            }
            if (v45 == 62)
            {
              __int16 v47 = (char *)(v39 + 1);
              goto LABEL_63;
            }
            uint64_t v71 = (char *)++v39;
            if (!--v44)
            {
              uint64_t v39 = (unsigned __int8 *)v72;
              break;
            }
          }
        }
        if (v39 == (unsigned __int8 *)v72 || (unint64_t)v39 >= v72)
        {
LABEL_61:
          CFErrorRef v38 = __CFPropertyListCreateError(3840, @"Encountered unexpected EOF while parsing DTD", v64, v66);
        }
        else
        {
          unint64_t v46 = v72 - (void)v39;
          __int16 v47 = (char *)(v39 + 1);
          while (1)
          {
            uint64_t v48 = *(v47 - 1);
            if (v48 > 0x20 || ((1 << *(v47 - 1)) & 0x100002600) == 0) {
              break;
            }
            uint64_t v71 = v47++;
            if (!--v46) {
              goto LABEL_61;
            }
          }
          if (v48 == 62)
          {
LABEL_63:
            uint64_t v71 = v47;
            goto LABEL_29;
          }
          uint64_t v67 = lineNumber((unint64_t *)&v70);
          CFErrorRef v38 = __CFPropertyListCreateError(3840, @"Encountered unexpected character %c on line %u while parsing DTD", v48, v67);
        }
      }
      else
      {
        uint64_t v65 = lineNumber((unint64_t *)&v70);
        CFErrorRef v38 = __CFPropertyListCreateError(3840, @"Malformed DTD on line %u", v65, v66);
      }
      CFTypeRef v73 = v38;
      if (v38)
      {
LABEL_70:
        CFTypeRef v51 = 0;
        int v52 = 0;
        goto LABEL_75;
      }
    }
  }
  int v53 = parseXMLElement((uint64_t)&v70, 0, v78, 0);
  int v52 = v53;
  CFTypeRef v51 = v78[0];
  if (a9 && v53 && v78[0])
  {
    *a9 = 100;
    int v52 = 1;
  }
LABEL_75:
  CFBurstTrieRelease((unsigned int *)v75[1]);
  CFRelease(cf[0]);
  if (v77[0]) {
    CFRelease(v77[0]);
  }
  CFRelease(theData);
  uint64_t v27 = a9;
  if (v52)
  {
    *a11 = v51;
    return 1;
  }
LABEL_79:
  if (!a13)
  {
    if (a7)
    {
      if (a12)
      {
        unsigned int v25 = (void *)v73;
        if (v73) {
          goto LABEL_9;
        }
      }
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unsupported property list");
      goto LABEL_8;
    }
    uint64_t result = (uint64_t)v73;
    if (!v73) {
      return result;
    }
    goto LABEL_100;
  }
  BOOL value = 0;
  if (a7) {
    p_BOOL value = &value;
  }
  else {
    p_BOOL value = 0;
  }
  int v55 = __CFCreateOldStylePropertyListOrStringsFile(a1, theData, a4, a5, a6, (CFErrorRef *)p_value, v27);
  uint64_t v56 = (__CFError *)v73;
  if (!v55)
  {
    if (a7)
    {
      unsigned int v25 = value;
      if (v73 && value)
      {
        CFDictionaryRef v58 = CFErrorCopyUserInfo((CFErrorRef)v73);
        CFIndex Count = CFDictionaryGetCount(v58);
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count + 1, v58);
        CFDictionaryAddValue(MutableCopy, @"kCFPropertyListOldStyleParsingError", value);
        Domaiuint64_t n = CFErrorGetDomain(v56);
        CFIndex Code = CFErrorGetCode(v56);
        CFErrorRef v63 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Domain, Code, MutableCopy);
        CFRelease(v58);
        CFRelease(MutableCopy);
        CFRelease(value);
        CFRelease(v56);
        uint64_t result = 0;
        *a7 = v63;
        return result;
      }
      if (v73 && !value)
      {
        uint64_t result = 0;
        *a7 = v73;
        return result;
      }
      if (!v73 && value)
      {
LABEL_9:
        uint64_t result = 0;
        *a7 = v25;
        return result;
      }
      if (!((unint64_t)v73 | (unint64_t)value))
      {
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unknown error during parse");
        goto LABEL_8;
      }
      return 0;
    }
    if (!v73) {
      return 0;
    }
    uint64_t result = (uint64_t)v73;
LABEL_100:
    CFRelease((CFTypeRef)result);
    return 0;
  }
  int v57 = v55;
  if (v73) {
    CFRelease(v73);
  }
  *a11 = v57;
  return 1;
}

void CFBurstTrieRelease(unsigned int *a1)
{
  if (atomic_fetch_add((atomic_uint *volatile)a1 + 521, 0xFFFFFFFF) == 1)
  {
    unint64_t v2 = (void *)*((void *)a1 + 257);
    if (v2)
    {
      if (*((unsigned char *)a1 + 2088)) {
        munmap(v2, a1[516]);
      }
    }
    else
    {
      finalizeCFBurstTrie((uint64_t)a1);
    }
    free(a1);
  }
}

void finalizeCFBurstTrie(uint64_t a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v3 = *(void *)(a1 + 8 * i);
    if ((v3 & 3) == 2)
    {
      uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        uint64_t v5 = (void *)*v4;
        free(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    else if ((v3 & 3) == 1)
    {
      finalizeCFBurstTrie(v3 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*(void *)(a1 + 8 * i) & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

_DWORD *CFBurstTrieCreate()
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  int valuePtr = 256;
  CFNumberRef v0 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, 0, 0);
  CFDictionarySetValue(Mutable, @"ContainerSize", v0);
  unint64_t v2 = CFBurstTrieCreateWithOptions(Mutable);
  CFRelease(v0);
  CFRelease(Mutable);
  return v2;
}

_DWORD *CFBurstTrieCreateWithOptions(const __CFDictionary *a1)
{
  value[1] = *(void **)off_1ECE0A5B0;
  unint64_t v2 = malloc_type_calloc(1uLL, 0x830uLL, 0x1010040873DE71CuLL);
  v2[520] = 256;
  value[0] = 0;
  if (CFDictionaryGetValueIfPresent(a1, @"ContainerSize", (const void **)value))
  {
    int valuePtr = 0;
    CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &valuePtr);
    int v3 = valuePtr;
    if ((valuePtr - 3) >= 0xFFD) {
      int v3 = 256;
    }
    v2[520] = v3;
  }
  atomic_store(1u, v2 + 521);
  return v2;
}

uint64_t parsePListTag(unint64_t *a1, CFTypeRef *a2, unint64_t a3)
{
  v13[1] = *(CFTypeRef *)off_1ECE0A5B0;
  v13[0] = 0;
  if (!getContentObject(a1, 0, (uint64_t)v13, a3))
  {
    if (!a1[3])
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered empty plist tag");
LABEL_10:
      CFErrorRef v8 = Error;
      uint64_t result = 0;
      a1[3] = (unint64_t)v8;
      return result;
    }
    return 0;
  }
  unint64_t v6 = a1[1];
  CFTypeRef cf = 0;
  if (getContentObject(a1, 0, (uint64_t)&cf, a3))
  {
    if (cf) {
      CFRelease(cf);
    }
    if (v13[0]) {
      CFRelease(v13[0]);
    }
    a1[1] = v6;
    uint64_t v11 = lineNumber(a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Encountered unexpected element at line %u (plist can only include one object)", v11);
    goto LABEL_10;
  }
  if (a1[3])
  {
    uint64_t result = (uint64_t)v13[0];
  }
  else
  {
    int v10 = checkForCloseTag(a1, (const UInt8 *)"plist", 5uLL);
    uint64_t result = (uint64_t)v13[0];
    if (v10)
    {
      *a2 = v13[0];
      return 1;
    }
  }
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

unint64_t *skipXMLProcessingInstruction(unint64_t *result)
{
  unint64_t v1 = result;
  unint64_t v2 = result[1];
  unint64_t v3 = result[2];
  if (v2 >= v3 - 2)
  {
LABEL_6:
    result[1] = v2;
    uint64_t v6 = lineNumber(result);
    uint64_t result = (unint64_t *)__CFPropertyListCreateError(3840, @"Encountered unexpected EOF while parsing the processing instruction begun on line %u", v6);
    v1[3] = (unint64_t)result;
  }
  else
  {
    uint64_t v4 = v3 - v2 - 2;
    uint64_t v5 = (unsigned char *)(v2 + 1);
    while (*(v5 - 1) != 63 || *v5 != 62)
    {
      result[1] = (unint64_t)v5++;
      if (!--v4) {
        goto LABEL_6;
      }
    }
    result[1] = (unint64_t)(v5 + 1);
  }
  return result;
}

uint64_t lineNumber(unint64_t *a1)
{
  unint64_t v1 = (unsigned __int8 *)*a1;
  unint64_t v2 = a1[2];
  if (*a1 >= v2) {
    return 1;
  }
  unint64_t v3 = a1[1];
  uint64_t result = 1;
  do
  {
    if ((unint64_t)v1 >= v3) {
      break;
    }
    int v5 = *v1;
    if (v5 == 10)
    {
      uint64_t result = (result + 1);
    }
    else if (v5 == 13)
    {
      uint64_t result = (result + 1);
      if ((unint64_t)(v1 + 1) < v2 && (unint64_t)(v1 + 1) < v3 && v1[1] == 10) {
        ++v1;
      }
    }
    ++v1;
  }
  while ((unint64_t)v1 < v2);
  return result;
}

uint64_t CFBurstTrieContains(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, _DWORD *a5)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (a4 > 1023) {
    return 0;
  }
  usedBufLeuint64_t n = 0;
  if (a4 < 86)
  {
    CFIndex v10 = 342;
    uint64_t v11 = v16;
  }
  else
  {
    CFIndex v10 = 4 * a4;
    uint64_t v11 = (UInt8 *)malloc_type_malloc((4 * a4) | 1, 0x4E9C7E14uLL);
  }
  v18.CFIndex location = a3;
  v18.uint64_t length = a4;
  CFStringGetBytes(a2, v18, 0x8000100u, 0x2Du, 0, v11, v10, &usedBufLen);
  CFIndex v13 = usedBufLen;
  v11[usedBufLen] = 0;
  uint64_t v12 = CFBurstTrieContainsUTF8String(a1, v11, v13, a5);
  if (v16 != v11) {
    free(v11);
  }
  return v12;
}

CFStringRef __CFHyphenationCreateDictionaryPathForLanguageAndRegion(const __CFString *a1, unint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = a2 | CFStringCompare(a1, @"en", 0) ? (__CFString *)a2 : @"US";
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 10, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return 0;
  }
  uint64_t v6 = Mutable;
  LinguisticDataPath = (const void *)_CFHyphenationGetLinguisticDataPath();
  CFArrayAppendValue(v6, LinguisticDataPath);
  CFArrayAppendValue(v6, a1);
  if (v4) {
    CFArrayAppendValue(v6, v4);
  }
  CFArrayAppendValue(v6, @"hyphenation.dat");
  CFStringRef v8 = CFStringCreateByCombiningStrings(0, v6, @"/");
  CFRelease(v6);
  return v8;
}

void sub_182C01158(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFHyphenationGetLinguisticDataPath()
{
  uint64_t result = _CFCustomHyphenationLinguisticDataPath;
  if (!_CFCustomHyphenationLinguisticDataPath)
  {
    if (_CFHyphenationGetLinguisticDataPath_once_token != -1) {
      dispatch_once(&_CFHyphenationGetLinguisticDataPath_once_token, &__block_literal_global_41);
    }
    return _CFDefaultHyphenationLinguisticDataPath;
  }
  return result;
}

void *CFBurstTrieCreateFromFile(const __CFString *a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  memset(&v10, 0, sizeof(v10));
  if (CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    if (!stat(buffer, &v10))
    {
      int v3 = open(buffer, 0, 0);
      if ((v3 & 0x80000000) == 0)
      {
        int v4 = v3;
        int v5 = (int *)mmap(0, v10.st_size, 1, 1, v3, 0);
        int v6 = *v5;
        if (*v5 == 14531089 || v6 == -889275714)
        {
          CFStringRef v8 = malloc_type_calloc(1uLL, 0x830uLL, 0x1010040873DE71CuLL);
          unint64_t v1 = v8;
          v8[257] = v5;
          *((_DWORD *)v8 + 516) = v10.st_size;
        }
        else
        {
          unint64_t v1 = 0;
          if (v6 != -1161889074)
          {
LABEL_15:
            close(v4);
            return v1;
          }
          CFStringRef v8 = malloc_type_calloc(1uLL, 0x830uLL, 0x1010040873DE71CuLL);
          unint64_t v1 = v8;
          v8[257] = v5;
          *((_DWORD *)v8 + 516) = v10.st_size;
          *((_DWORD *)v8 + 517) = v5[1];
        }
        *((_DWORD *)v8 + 518) = v5[4];
        *((_DWORD *)v1 + 519) = v5[2];
        atomic_store(1u, (unsigned int *)v1 + 521);
        *((unsigned char *)v1 + 2088) = 1;
        goto LABEL_15;
      }
    }
  }
  return 0;
}

void _CFPrefsRegisterUserDefaultsInstanceWithCloudConfigurationURL(uint64_t a1, uint64_t a2)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    int v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    int v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v5 = v4;
  [v4 registerUserDefaultsInstance:a1 configurationURL:a2];
}

CFPropertyListRef CFPropertyListCreateFromStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags mutabilityOption, CFPropertyListFormat *format, CFStringRef *errorString)
{
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  if (errorString) {
    *errorString = 0;
  }
  cf[0] = 0;
  CFPropertyListRef v7 = CFPropertyListCreateWithStream(allocator, stream, streamLength, mutabilityOption, format, (CFErrorRef *)cf);
  CFTypeRef v8 = cf[0];
  if (errorString && cf[0])
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf[0]);
    CFTypeRef v8 = cf[0];
  }
  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

CFSetRef _CFPropertyListCopyTopLevelKeys(__objc2_class **a1, CFDataRef theData, unsigned int a3, CFErrorRef *a4)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (theData)
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    unint64_t Length = CFDataGetLength(theData);
    if (Length >= 8)
    {
      int v10 = Length;
      char v19 = 0;
      *(_OWORD *)CFTypeRef cf = 0u;
      long long v21 = 0u;
      unint64_t v18 = 0;
      if (__CFDataGetBinaryPlistTopLevelInfo(theData, &v19, &v18, (uint64_t)cf))
      {
        CFSetRef v11 = __CFBinaryPlistCopyTopLevelKeys(a1, BytePtr, v10, v18, (uint64_t)cf);
        if (!a4) {
          return v11;
        }
        goto LABEL_19;
      }
    }
    cf[0] = 0;
    _CFPropertyListCreateWithData(a1, theData, a3, a4, 1, 0, 0, cf);
    CFDictionaryRef v12 = (const __CFDictionary *)cf[0];
    if (cf[0])
    {
      if (CFGetTypeID(cf[0]) == 18)
      {
        CFIndex Count = CFDictionaryGetCount(v12);
        CFDictionaryValueCallBacks v14 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
        if (v14)
        {
          uint64_t v15 = v14;
          CFDictionaryGetKeysAndValues(v12, v14, 0);
          CFSetRef v11 = CFSetCreate((CFAllocatorRef)a1, v15, Count, &kCFTypeSetCallBacks);
          free(v15);
          goto LABEL_18;
        }
        if (a4)
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to convert string to correct encoding");
          goto LABEL_16;
        }
      }
      else if (a4)
      {
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Cannot copy top-level keys for plist with non-dictionary root object");
LABEL_16:
        CFSetRef v11 = 0;
        *a4 = Error;
        goto LABEL_18;
      }
      CFSetRef v11 = 0;
LABEL_18:
      CFRelease(v12);
      if (!a4) {
        return v11;
      }
      goto LABEL_19;
    }
  }
  CFSetRef v11 = 0;
  if (!a4) {
    return v11;
  }
LABEL_19:
  if (!v11) {
    *a4 = __CFPropertyListCreateError(3840, @"Unable to extract top-level keys");
  }
  return v11;
}

CFSetRef __CFBinaryPlistCopyTopLevelKeys(__objc2_class **a1, char *a2, int a3, unint64_t a4, uint64_t a5)
{
  CFSetRef v5 = 0;
  v41[1] = *(CFTypeRef *)off_1ECE0A5B0;
  if (a4 < 8) {
    return v5;
  }
  unint64_t v7 = *(void *)(a5 + 24) - 1;
  if (v7 < a4) {
    return v5;
  }
  CFSetRef v5 = 0;
  CFStringRef v9 = &a2[a4];
  if (&a2[a4] == (char *)-1) {
    return v5;
  }
  char v10 = *v9;
  if ((*v9 & 0xF0) != 0xD0) {
    return v5;
  }
  CFIndex v13 = (unsigned int *)(v9 + 1);
  unint64_t v14 = v10 & 0xF;
  if ((v10 & 0xF) == 0xF)
  {
    if (&a2[v7] < (char *)v13) {
      return 0;
    }
    uint64_t v15 = (unsigned __int8 *)(v9 + 2);
    char v16 = *(unsigned char *)v13;
    if ((*(unsigned char *)v13 & 0xF0) != 0x10) {
      return 0;
    }
    CFSetRef v5 = 0;
    unsigned int v17 = v16 & 0xF;
    uint64_t v18 = 1 << (v16 & 0xF);
    if (__CFADD__(v18, v15) || (char *)v13 + v18 > &a2[v7]) {
      return v5;
    }
    switch((char)v18)
    {
      case 1:
        unint64_t v14 = *v15;
        goto LABEL_23;
      case 2:
        unint64_t v14 = __rev16(*(unsigned __int16 *)((char *)v13 + 1));
        goto LABEL_23;
      case 4:
        unint64_t v14 = bswap32(*(unsigned int *)((char *)v13 + 1));
        goto LABEL_23;
      case 8:
        unint64_t v14 = bswap64(*(void *)((char *)v13 + 1));
        goto LABEL_22;
      default:
        if (v17 >= 8)
        {
          unint64_t v14 = 0;
          unint64_t v19 = 0;
          CFIndex v13 = (unsigned int *)&v15[v18];
          goto LABEL_28;
        }
        unint64_t v14 = 0;
        if ((v18 & 0xFE) != 0) {
          uint64_t v20 = v18;
        }
        else {
          uint64_t v20 = 1;
        }
        long long v21 = (unsigned __int8 *)v13 + 1;
        do
        {
          unsigned int v22 = *v21++;
          unint64_t v14 = v22 | (v14 << 8);
          --v20;
        }
        while (v20);
LABEL_22:
        if ((v14 & 0x8000000000000000) != 0) {
          return 0;
        }
LABEL_23:
        CFIndex v13 = (unsigned int *)&v15[v18];
        break;
    }
  }
  if (v14)
  {
    CFSetRef v5 = 0;
    unint64_t v19 = 2 * v14;
    if (!is_mul_ok(2 * v14, *(unsigned __int8 *)(a5 + 7))) {
      return v5;
    }
    unint64_t v14 = v19 * *(unsigned __int8 *)(a5 + 7);
  }
  else
  {
    unint64_t v19 = 0;
  }
LABEL_28:
  CFSetRef v5 = 0;
  if (!__CFADD__(v14, v13) && &a2[v7] >= (char *)v13 + v14 - 1)
  {
    if (v19 >= 0x402) {
      unint64_t v23 = 512;
    }
    else {
      unint64_t v23 = v19 >> 1;
    }
    unsigned int v24 = malloc_type_malloc(8 * v23, 0x6004044C4A2DFuLL);
    if (v24)
    {
      unsigned int v25 = v24;
      if (v19)
      {
        unint64_t v26 = 0;
        if (v19 >> 1 <= 1) {
          unint64_t v19 = 1;
        }
        else {
          v19 >>= 1;
        }
        while (1)
        {
          if (v26 >= v23)
          {
            unint64_t v23 = (3 * v23) >> 1;
            uint64_t v27 = malloc_type_realloc(v25, 8 * v23, 0x6004044C4A2DFuLL);
            if (!v27) {
              break;
            }
            unsigned int v25 = v27;
          }
          if (a2 + 8 > (char *)v13) {
            break;
          }
          unint64_t v28 = &a2[*(void *)(a5 + 24)];
          uint64_t v29 = *(unsigned __int8 *)(a5 + 7);
          if (&v28[-v29] < (char *)v13) {
            break;
          }
          unint64_t v30 = *(unsigned __int8 *)(a5 + 7);
          switch(*(unsigned char *)(a5 + 7))
          {
            case 0:
              break;
            case 1:
              unint64_t v30 = *(unsigned __int8 *)v13;
              break;
            case 2:
              unint64_t v30 = __rev16(*(unsigned __int16 *)v13);
              break;
            case 4:
              unint64_t v30 = bswap32(*v13);
              break;
            case 8:
              unint64_t v30 = bswap64(*(void *)v13);
              break;
            default:
              unint64_t v30 = 0;
              BOOL v31 = v13;
              do
              {
                unsigned int v32 = *(unsigned __int8 *)v31;
                BOOL v31 = (unsigned int *)((char *)v31 + 1);
                unint64_t v30 = v32 | (v30 << 8);
                --v29;
              }
              while (v29);
              break;
          }
          if (*(void *)(a5 + 8) <= v30) {
            break;
          }
          unint64_t v33 = *(unsigned __int8 *)(a5 + 6);
          uint64_t v34 = (unsigned int *)&v28[v30 * v33];
          switch(*(unsigned char *)(a5 + 6))
          {
            case 0:
              break;
            case 1:
              unint64_t v33 = *(unsigned __int8 *)v34;
              break;
            case 2:
              unint64_t v33 = __rev16(*(unsigned __int16 *)v34);
              break;
            case 4:
              unint64_t v33 = bswap32(*v34);
              break;
            case 8:
              unint64_t v33 = bswap64(*(void *)v34);
              break;
            default:
              uint64_t v35 = *(unsigned __int8 *)(a5 + 6);
              unint64_t v33 = 0;
              do
              {
                unsigned int v36 = *(unsigned __int8 *)v34;
                uint64_t v34 = (unsigned int *)((char *)v34 + 1);
                unint64_t v33 = v36 | (v33 << 8);
                --v35;
              }
              while (v35);
              break;
          }
          CFTypeID v40 = 0;
          v41[0] = 0;
          if (__CFBinaryPlistCreateObjectFiltered(a2, a3, v33, a5, a1, 0, 0, 0, 0, 0, 0, v41, &v40))BOOL v37 = v40 == 7; {
          else
          }
            BOOL v37 = 0;
          if (!v37)
          {
            if (v41[0]) {
              CFRelease(v41[0]);
            }
            break;
          }
          *((CFTypeRef *)v25 + v26++) = v41[0];
          CFIndex v13 = (unsigned int *)((char *)v13 + *(unsigned __int8 *)(a5 + 7));
          if (v26 == v19) {
            goto LABEL_66;
          }
        }
        CFSetRef v5 = 0;
      }
      else
      {
LABEL_66:
        CFSetRef v5 = CFSetCreate((CFAllocatorRef)a1, (const void **)v25, v19, &kCFTypeSetCallBacks);
        unint64_t v26 = v19;
      }
      if (v26)
      {
        CFErrorRef v38 = (CFTypeRef *)v25;
        do
        {
          if (*v38) {
            CFRelease(*v38);
          }
          ++v38;
          --v26;
        }
        while (v26);
      }
      free(v25);
      return v5;
    }
    return 0;
  }
  return v5;
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  uint64_t Generic = __CFSetCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  unint64_t v7 = (unint64_t *)Generic;
  if (Generic)
  {
    if (numValues >= 1)
    {
      CFBasicHashSetCapacity(Generic, numValues);
      do
      {
        unint64_t v8 = (unint64_t)*values++;
        CFBasicHashAddValue((uint64_t)v7, v8, v8);
        --numValues;
      }
      while (numValues);
    }
    unint64_t v9 = atomic_load(v7 + 1);
    unint64_t v10 = v9;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v7 + 1, &v10, v9 | 0x40);
      BOOL v11 = v10 == v9;
      unint64_t v9 = v10;
    }
    while (!v11);
    _CFRuntimeSetInstanceTypeIDAndIsa(v7, 0x11uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return (CFSetRef)v7;
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (format == kCFPropertyListBinaryFormat_v1_0)
  {
    CFIndex v13 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)&__kCFAllocatorSystemDefault, allocator);
    CFWriteStreamOpen(v13);
    if (CFPropertyListWrite(propertyList, v13, kCFPropertyListBinaryFormat_v1_0, options, error) < 1) {
      CFDataRef v14 = 0;
    }
    else {
      CFDataRef v14 = (const __CFData *)CFWriteStreamCopyProperty(v13, @"kCFStreamPropertyDataWritten");
    }
    CFWriteStreamClose(v13);
    CFRelease(v13);
  }
  else
  {
    if (format != kCFPropertyListXMLFormat_v1_0)
    {
      if (format == kCFPropertyListOpenStepFormat) {
        BOOL v11 = @"Property list format kCFPropertyListOpenStepFormat not supported for writing";
      }
      else {
        BOOL v11 = @"Unknown format option";
      }
      CFLog(3, (uint64_t)v11, format, options, (uint64_t)error, v5, v6, v7, v16);
      return 0;
    }
    CFTypeRef cf = 0;
    long long v18 = xmmword_182DA12E0;
    uint64_t v19 = 0;
    p_CFTypeRef cf = &cf;
    uint64_t v21 = 0;
    if (!__CFPropertyListIsValidAux(propertyList, &v18))
    {
      if (error) {
        *error = __CFPropertyListCreateError(3851, @"Property list invalid for format: %ld (%@)", 100, cf);
      }
      if (cf) {
        CFRelease(cf);
      }
      return 0;
    }
    return _CFPropertyListCreateXMLData(allocator, (const __CFString *)propertyList, 0);
  }
  return v14;
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    [(__CFWriteStream *)stream open];
    return 1;
  }
  else
  {
    return _CFStreamOpen((uint64_t)stream);
  }
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    [(__CFWriteStream *)stream close];
  }
  else
  {
    _CFStreamClose((uint64_t)stream);
  }
}

CFIndex CFPropertyListWriteToStream(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFStringRef *errorString)
{
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  if (errorString) {
    *errorString = 0;
  }
  cf[0] = 0;
  if (format != kCFPropertyListBinaryFormat_v1_0 && format != kCFPropertyListXMLFormat_v1_0)
  {
    if (format == kCFPropertyListOpenStepFormat)
    {
      if (errorString)
      {
        uint64_t v5 = @"Property list format kCFPropertyListOpenStepFormat not supported for writing";
LABEL_15:
        CFIndex v6 = 0;
        *errorString = (CFStringRef)CFRetain(v5);
        return v6;
      }
    }
    else if (errorString)
    {
      uint64_t v5 = @"Unknown format option";
      goto LABEL_15;
    }
    return 0;
  }
  CFIndex v6 = CFPropertyListWrite(propertyList, stream, format, 0, (CFErrorRef *)cf);
  CFTypeRef v7 = cf[0];
  if (errorString && cf[0])
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf[0]);
    CFTypeRef v7 = cf[0];
  }
  if (v7) {
    CFRelease(v7);
  }
  return v6;
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  v32[5] = *(void *)off_1ECE0A5B0;
  CFTypeRef cf = 0;
  v32[0] = 1;
  v32[1] = format;
  v32[2] = 0;
  v32[3] = &cf;
  v32[4] = 0;
  if (!__CFPropertyListIsValidAux(propertyList, v32))
  {
    if (error) {
      *error = __CFPropertyListCreateError(3851, @"Property list invalid for format: %ld (%@)", format, cf);
    }
    CFTypeRef v17 = cf;
    if (!cf) {
      return 0;
    }
    goto LABEL_9;
  }
  if (format == kCFPropertyListBinaryFormat_v1_0) {
    return __CFBinaryPlistWrite(propertyList, stream, 0, options, error);
  }
  if (format != kCFPropertyListXMLFormat_v1_0)
  {
    if (format == kCFPropertyListOpenStepFormat) {
      __int16 v16 = @"Property list format kCFPropertyListOpenStepFormat not supported for writing";
    }
    else {
      __int16 v16 = @"Unknown format option";
    }
    goto LABEL_21;
  }
  XMLCFDataRef Data = _CFPropertyListCreateXMLData((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const __CFString *)propertyList, 1);
  if (!XMLData)
  {
    __int16 v16 = @"Property list format kCFPropertyListXMLFormat_v1_0 specified but was not a valid property list type";
LABEL_21:
    CFLog(3, (uint64_t)v16, v10, v11, v12, v13, v14, v15, v30);
    return 0;
  }
  CFDataRef v20 = XMLData;
  uint64_t Length = CFDataGetLength(XMLData);
  BytePtr = CFDataGetBytePtr(v20);
  if (Length >= 1)
  {
    unint64_t v23 = BytePtr;
    while (1)
    {
      CFIndex v24 = CFWriteStreamWrite(stream, v23, Length);
      if (!v24) {
        break;
      }
      if (v24 < 0)
      {
        CFErrorRef v27 = CFWriteStreamCopyError(stream);
        if (v27)
        {
          CFErrorRef v28 = v27;
          if (error)
          {
            CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(Mutable, @"NSDebugDescription", @"Property list writing could not be completed because the stream had an unknown error.");
            CFDictionarySetValue(Mutable, @"NSUnderlyingError", v28);
            *error = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", 3851, Mutable);
            CFRelease(Mutable);
          }
          CFRelease(v28);
        }
        goto LABEL_30;
      }
      v23 += v24;
      BOOL v25 = Length <= v24;
      Length -= v24;
      if (v25) {
        goto LABEL_18;
      }
    }
    if (error) {
      *error = __CFPropertyListCreateError(3851, @"Property list writing could not be completed because stream is full.");
    }
LABEL_30:
    CFTypeRef v17 = v20;
LABEL_9:
    CFRelease(v17);
    return 0;
  }
LABEL_18:
  CFIndex v18 = CFDataGetLength(v20);
  CFRelease(v20);
  return v18;
}

uint64_t __CFBinaryPlistWrite(const void *a1, const void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, a5);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  uint64_t v6 = MEMORY[0x1F4188790](allocator, stream);
  unint64_t v9 = v8;
  unsigned int v30 = v10;
  BOOL v31 = v11;
  uint64_t v13 = v12;
  uint64_t v29 = (__objc2_class **)v6;
  int v14 = 0;
  int v15 = 0;
  __int16 v16 = 0;
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  if (v7) {
    uint64_t v17 = v7;
  }
  else {
    uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
  }
  do
  {
    if (v17 >= 0x2000) {
      CFIndex v18 = 0x2000;
    }
    else {
      CFIndex v18 = v17;
    }
    int v19 = CFReadStreamRead(v13, buffer, v18);
    unsigned int v20 = v19;
    if (v19 <= 0)
    {
      if (!v19)
      {
        int v21 = v14;
        if (!v16) {
          goto LABEL_38;
        }
        goto LABEL_36;
      }
      CFErrorRef v24 = CFReadStreamCopyError(v13);
      if (!v9) {
        goto LABEL_32;
      }
      goto LABEL_27;
    }
    int v21 = v14 + v19;
    if (__OFADD__(v14, v19)) {
      goto LABEL_23;
    }
    if (v15 < v21)
    {
      if (v15 < 0x40000)
      {
        int v22 = 4 * v15;
LABEL_15:
        if (v22 <= v21) {
          int v15 = v14 + v19;
        }
        else {
          int v15 = v22;
        }
        uint64_t v23 = __CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v16, v15, 3267573040, 0, 0);
        if (!v23) {
          __break(1u);
        }
        __int16 v16 = (char *)v23;
        goto LABEL_20;
      }
      if (!HIBYTE(v15))
      {
        int v22 = 2 * v15;
        goto LABEL_15;
      }
      int v22 = v15 + 0x40000;
      if (!__OFADD__(v15, 0x40000)) {
        goto LABEL_15;
      }
LABEL_23:
      CFErrorRef v24 = __CFPropertyListCreateError(3840, @"Stream too large");
      __int16 v16 = 0;
      if (!v9)
      {
LABEL_32:
        if (v24) {
          CFRelease(v24);
        }
        return 0;
      }
LABEL_27:
      if (v16) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
      }
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(Mutable, @"NSDebugDescription", @"Property list reading could not be completed because the stream had an unknown error. Did you forget to open the stream?");
      if (v24) {
        CFDictionarySetValue(Mutable, @"NSUnderlyingError", v24);
      }
      *unint64_t v9 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", 3842, Mutable);
      CFRelease(Mutable);
      goto LABEL_32;
    }
LABEL_20:
    memmove(&v16[v14], buffer, v20);
    v17 -= v20;
    v14 += v20;
  }
  while (v17 >= 1);
  if (!v16)
  {
LABEL_38:
    if (v16) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
    }
    if (v9)
    {
      CFErrorRef v28 = __CFPropertyListCreateError(3840, @"stream had too few bytes");
      CFPropertyListRef result = 0;
      *unint64_t v9 = v28;
      return result;
    }
    return 0;
  }
LABEL_36:
  if (v21 <= 5) {
    goto LABEL_38;
  }
  CFDataRef v27 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v16, v21, (CFAllocatorRef)&__kCFAllocatorSystemDefault);
  *(void *)buffer = 0;
  _CFPropertyListCreateWithData(v29, v27, v30, v9, 1, v31, 0, buffer);
  CFRelease(v27);
  return *(CFPropertyListRef *)buffer;
}

void *__CFSafelyReallocateWithAllocatorImpl(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3, uint64_t a4, malloc_type_id_t type_id, uint64_t a6)
{
  CFPropertyListRef result = CFAllocatorReallocateImpl(a1, a2, a3, type_id, a4);
  if (!result && (a2 || a3))
  {
    __CFReallocationFailed((uint64_t)a2, a3, a6);
    return 0;
  }
  return result;
}

void *CFAllocatorReallocateImpl(malloc_zone_t *a1, malloc_zone_t *zone, uint64_t a3, malloc_type_id_t type_id, uint64_t a5)
{
  if (a1)
  {
    if (zone)
    {
LABEL_16:
      if (zone && !a3)
      {
        unint64_t v15 = (unint64_t)a1->reserved1 & ~(unint64_t)off_1ECE0A6D0;
        if (((unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0) != 0) {
          v15 |= (unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0;
        }
        if (v15 == qword_1EB1DDDA0)
        {
          vCFAllocatorRef alloc = a1[1].valloc;
          if (valloc) {
            ((void (*)(malloc_zone_t *, void (__cdecl *)(_malloc_zone_t *, void *)))valloc)(zone, a1->try_free_default);
          }
        }
        else
        {
          malloc_zone_free(a1, zone);
        }
        return 0;
      }
      if (!zone && !a3) {
        return 0;
      }
      unint64_t v17 = (unint64_t)a1->reserved1 & ~(unint64_t)off_1ECE0A6D0;
      if (((unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0) != 0) {
        v17 |= (unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0;
      }
      if (v17 == qword_1EB1DDDA0)
      {
        destroy = a1[1].destroy;
        if (destroy)
        {
          try_free_default = a1->try_free_default;
          return (void *)((uint64_t (*)(malloc_zone_t *, uint64_t, malloc_type_id_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))destroy)(zone, a3, type_id, a5, try_free_default);
        }
        cCFAllocatorRef alloc = (uint64_t (*)(malloc_zone_t *, uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))a1[1].calloc;
        if (calloc)
        {
          uint64_t v11 = a1->try_free_default;
          uint64_t v12 = zone;
          uint64_t v13 = a3;
          goto LABEL_13;
        }
        return 0;
      }
      return malloc_type_zone_realloc(a1, zone, a3, type_id);
    }
  }
  else
  {
    a1 = (malloc_zone_t *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    }
    if (zone) {
      goto LABEL_16;
    }
  }
  if (a3 < 1) {
    goto LABEL_16;
  }
  unint64_t v9 = (unint64_t)a1->reserved1 & ~(unint64_t)off_1ECE0A6D0;
  if (((unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0) != 0) {
    v9 |= (unint64_t)a1->reserved1 & (unint64_t)off_1ECE0A6D0;
  }
  if (v9 == qword_1EB1DDDA0)
  {
    cCFAllocatorRef alloc = (uint64_t (*)(malloc_zone_t *, uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))a1[1].realloc;
    if (calloc)
    {
      uint64_t v11 = a1->try_free_default;
      uint64_t v12 = (malloc_zone_t *)a3;
      uint64_t v13 = type_id;
LABEL_13:
      return (void *)calloc(v12, v13, a5, v11);
    }
    mCFAllocatorRef alloc = a1[1].malloc;
    if (!malloc) {
      return 0;
    }
    int v21 = a1->try_free_default;
    return (void *)((uint64_t (*)(uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))malloc)(a3, a5, v21);
  }
  else
  {
    return malloc_type_zone_malloc(a1, a3, type_id);
  }
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    int v4 = (void *)[(__CFWriteStream *)stream propertyForKey:propertyName];
    return v4;
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(CFWriteStreamRef, CFStreamPropertyKey, void))(*((void *)stream + 6) + 96);
    if (v6)
    {
      *((void *)stream + 2) |= 0x40uLL;
      CFTypeRef result = (CFTypeRef)v6(stream, propertyName, *((void *)stream + 5));
      *((void *)stream + 2) &= ~0x40uLL;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  CFAllocatorRef v4 = bytesDeallocator;
  if (!bytesDeallocator)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      CFAllocatorRef v4 = (CFAllocatorRef)v8;
    }
    else {
      CFAllocatorRef v4 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }

  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, length, bytes, length, v4);
}

CFDataRef dataCopyProperty(int a1, CFTypeRef cf1, uint64_t *a3)
{
  if (!CFEqual(cf1, @"kCFStreamPropertyDataWritten")) {
    return 0;
  }
  CFAllocatorRef v4 = (__objc2_class **)a3[2];
  if (v4 == &__kCFAllocatorNull) {
    return 0;
  }
  uint64_t v5 = *a3;
  if (*a3)
  {
    CFIndex v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(v5 + 16);
      uint64_t v5 = *(void *)(v5 + 24);
      v6 += v7;
    }
    while (v5);
    if (v6 >= 1)
    {
      uint64_t Typed = CFAllocatorAllocateTyped(a3[2], v6, 2558180666, 0);
      if (Typed)
      {
        unint64_t v9 = (const UInt8 *)Typed;
        uint64_t v10 = *a3;
        if (*a3)
        {
          uint64_t v11 = (char *)Typed;
          do
          {
            memmove(v11, *(const void **)v10, *(void *)(v10 + 16));
            uint64_t v12 = *(void *)(v10 + 16);
            uint64_t v10 = *(void *)(v10 + 24);
            v11 += v12;
          }
          while (v10);
        }
        goto LABEL_15;
      }
      return 0;
    }
  }
  else
  {
    CFIndex v6 = 0;
  }
  unint64_t v9 = 0;
LABEL_15:

  return CFDataCreateWithBytesNoCopy((CFAllocatorRef)v4, v9, v6, (CFAllocatorRef)v4);
}

void *__CFAllocatorSystemReallocateTyped(void *ptr, size_t size, malloc_type_id_t type_id, int a4, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }

  return malloc_type_zone_realloc(zone, ptr, size, type_id);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    return [(__CFReadStream *)stream read:buffer maxLength:bufferLength];
  }
  else
  {
    uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
    uint64_t v8 = *((void *)stream + 6);
    if (Status == 1)
    {
      *((void *)stream + 2) |= 0x40uLL;
      waitForOpen((uint64_t)stream);
      *((void *)stream + 2) &= ~0x40uLL;
      uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
    }
    if ((unint64_t)(Status - 2) >= 2)
    {
      if (Status == 5) {
        return 0;
      }
      else {
        return -1;
      }
    }
    else
    {
      char v22 = 0;
      uint64_t v9 = *((void *)stream + 2);
      *((void *)stream + 2) = v9 | 0x40;
      uint64_t v10 = *((void *)stream + 4);
      if (v10) {
        *(void *)(v10 + 72) &= ~2uLL;
      }
      if ((v9 & 0x1E) != 6) {
        *((void *)stream + 2) = v9 & 0xFFFFFFA0 | 0x43;
      }
      if (*(uint64_t *)v8 > 1)
      {
        CFIndex v11 = (*(uint64_t (**)(CFReadStreamRef, UInt8 *, CFIndex, char *, char *, void))(v8 + 48))(stream, buffer, bufferLength, (char *)stream + 24, &v22, *((void *)stream + 5));
      }
      else
      {
        long long v21 = 0uLL;
        CFIndex v11 = (*(uint64_t (**)(CFReadStreamRef, UInt8 *, CFIndex, long long *, char *, void))(v8 + 48))(stream, buffer, bufferLength, &v21, &v22, *((void *)stream + 5));
        if (DWORD2(v21))
        {
          uint64_t Typed = (_OWORD *)*((void *)stream + 3);
          if (!Typed)
          {
            CFAllocatorRef v13 = CFGetAllocator(stream);
            uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v13, 16, 0x1000040D9A13B51, 0);
            *((void *)stream + 3) = Typed;
          }
          _OWORD *Typed = v21;
        }
      }
      if (*((void *)stream + 3))
      {
        uint64_t v14 = *((void *)stream + 2);
        if ((v14 & 0x1F) != 7) {
          *((void *)stream + 2) = v14 & 0xFFFFFFE0 | 7;
        }
        uint64_t v15 = *((void *)stream + 4);
        if (v15 && (*(unsigned char *)(v15 + 48) & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
          uint64_t v16 = *((void *)stream + 4);
          if (v16 && (unint64_t v17 = *(__CFRunLoopSource **)(v16 + 56)) != 0)
          {
            CFRetain(*(CFTypeRef *)(v16 + 56));
            pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
            *(void *)(*((void *)stream + 4) + 72) |= 8uLL;
            CFRunLoopSourceSignal(v17);
            CFRelease(v17);
            _wakeUpRunLoop((uint64_t)stream);
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          }
        }
        CFIndex v11 = -1;
      }
      else if (v22)
      {
        if ((*((void *)stream + 2) & 0x1ELL) != 6) {
          *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0 | 5;
        }
        uint64_t v18 = *((void *)stream + 4);
        if (v18 && (*(unsigned char *)(v18 + 48) & 0x10) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
          uint64_t v19 = *((void *)stream + 4);
          if (v19 && (unsigned int v20 = *(__CFRunLoopSource **)(v19 + 56)) != 0)
          {
            CFRetain(*(CFTypeRef *)(v19 + 56));
            pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
            *(void *)(*((void *)stream + 4) + 72) |= 0x10uLL;
            CFRunLoopSourceSignal(v20);
            CFRelease(v20);
            _wakeUpRunLoop((uint64_t)stream);
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          }
        }
      }
      else if ((*((void *)stream + 2) & 0x1ELL) != 6)
      {
        *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0 | 2;
      }
      *((void *)stream + 2) &= ~0x40uLL;
    }
    return v11;
  }
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  if (!CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
    uint64_t v8 = *((void *)stream + 6);
    if (Status == 1)
    {
      *((void *)stream + 2) |= 0x40uLL;
      waitForOpen((uint64_t)stream);
      *((void *)stream + 2) &= ~0x40uLL;
      uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
    }
    if (Status != 4 && Status != 2) {
      return -1;
    }
    if ((*((void *)stream + 2) & 0x1ELL) == 6) {
      uint64_t v9 = *((void *)stream + 2) | 0x40;
    }
    else {
      uint64_t v9 = *((void *)stream + 2) & 0xFFFFFFA0 | 0x44;
    }
    *((void *)stream + 2) = v9;
    uint64_t v10 = *((void *)stream + 4);
    if (v10) {
      *(void *)(v10 + 72) &= ~4uLL;
    }
    if (*(uint64_t *)v8 > 1)
    {
      CFIndex v11 = (*(uint64_t (**)(CFWriteStreamRef, const UInt8 *, CFIndex, char *, void))(v8 + 72))(stream, buffer, bufferLength, (char *)stream + 24, *((void *)stream + 5));
    }
    else
    {
      long long v23 = 0uLL;
      CFIndex v11 = (*(uint64_t (**)(CFWriteStreamRef, const UInt8 *, CFIndex, long long *, void))(v8 + 72))(stream, buffer, bufferLength, &v23, *((void *)stream + 5));
      if (DWORD2(v23))
      {
        uint64_t Typed = (_OWORD *)*((void *)stream + 3);
        if (!Typed)
        {
          CFAllocatorRef v13 = CFGetAllocator(stream);
          uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v13, 16, 0x1000040D9A13B51, 0);
          *((void *)stream + 3) = Typed;
        }
        _OWORD *Typed = v23;
      }
    }
    if (*((void *)stream + 3))
    {
      uint64_t v14 = *((void *)stream + 2);
      if ((v14 & 0x1F) != 7) {
        *((void *)stream + 2) = v14 & 0xFFFFFFE0 | 7;
      }
      uint64_t v15 = *((void *)stream + 4);
      if (!v15 || (*(unsigned char *)(v15 + 48) & 8) == 0) {
        goto LABEL_41;
      }
      uint64_t v16 = (pthread_mutex_t *)((char *)stream + 56);
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v17 = *((void *)stream + 4);
      if (v17)
      {
        uint64_t v18 = *(__CFRunLoopSource **)(v17 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v17 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          uint64_t v19 = *((void *)stream + 4);
          uint64_t v20 = *(void *)(v19 + 72) | 8;
LABEL_28:
          *(void *)(v19 + 72) = v20;
          CFRunLoopSourceSignal(v18);
          CFRelease(v18);
          _wakeUpRunLoop((uint64_t)stream);
LABEL_41:
          *((void *)stream + 2) &= ~0x40uLL;
          return v11;
        }
      }
    }
    else
    {
      if (v11)
      {
        if ((*((void *)stream + 2) & 0x1ELL) != 6) {
          *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0 | 2;
        }
        goto LABEL_41;
      }
      if ((*((void *)stream + 2) & 0x1ELL) != 6) {
        *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0 | 5;
      }
      uint64_t v21 = *((void *)stream + 4);
      if (!v21 || (*(unsigned char *)(v21 + 48) & 0x10) == 0) {
        goto LABEL_41;
      }
      uint64_t v16 = (pthread_mutex_t *)((char *)stream + 56);
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v22 = *((void *)stream + 4);
      if (v22)
      {
        uint64_t v18 = *(__CFRunLoopSource **)(v22 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v22 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          uint64_t v19 = *((void *)stream + 4);
          uint64_t v20 = *(void *)(v19 + 72) | 0x10;
          goto LABEL_28;
        }
      }
    }
    pthread_mutex_unlock(v16);
    goto LABEL_41;
  }

  return [(__CFWriteStream *)stream write:buffer maxLength:bufferLength];
}

uint64_t _CFStreamOpen(uint64_t a1)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  unint64_t v2 = *(uint64_t **)(a1 + 48);
  if (!_CFStreamGetStatus(a1))
  {
    char v16 = 0;
    if ((*(void *)(a1 + 16) & 0x1ELL) == 6) {
      uint64_t v4 = *(void *)(a1 + 16) | 0x40;
    }
    else {
      uint64_t v4 = *(void *)(a1 + 16) & 0xFFFFFFA0 | 0x41;
    }
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = (uint64_t (*)(uint64_t, uint64_t, char *, void))v2[4];
    if (v5)
    {
      if (*v2 > 1)
      {
        uint64_t v3 = v5(a1, a1 + 24, &v16, *(void *)(a1 + 40));
      }
      else
      {
        long long v15 = 0uLL;
        uint64_t v3 = v5(a1, (uint64_t)&v15, &v16, *(void *)(a1 + 40));
        if (DWORD2(v15))
        {
          uint64_t Typed = *(_OWORD **)(a1 + 24);
          if (!Typed)
          {
            CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
            uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v7, 16, 0x1000040D9A13B51, 0);
            *(void *)(a1 + 24) = Typed;
          }
          _OWORD *Typed = v15;
        }
      }
      if (!v16) {
        goto LABEL_33;
      }
      uint64_t v4 = *(void *)(a1 + 16);
      if (!v3)
      {
        if ((*(void *)(a1 + 16) & 0x1FLL) != 7) {
          *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFE0 | 7;
        }
        uint64_t v11 = *(void *)(a1 + 32);
        if (v11 && (*(unsigned char *)(v11 + 48) & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
          uint64_t v12 = *(void *)(a1 + 32);
          if (v12 && (CFAllocatorRef v13 = *(__CFRunLoopSource **)(v12 + 56)) != 0)
          {
            CFRetain(*(CFTypeRef *)(v12 + 56));
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
            *(void *)(*(void *)(a1 + 32) + 72) |= 8uLL;
            CFRunLoopSourceSignal(v13);
            CFRelease(v13);
            _wakeUpRunLoop(a1);
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
          }
        }
        uint64_t v3 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v3 = 1;
      char v16 = 1;
    }
    if ((v4 & 0x1F) == 1) {
      *(void *)(a1 + 16) = v4 & 0xFFFFFFE0 | 2;
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8 && (*(unsigned char *)(v8 + 48) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v9 = *(void *)(a1 + 32);
      if (v9 && (uint64_t v10 = *(__CFRunLoopSource **)(v9 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v9 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(void *)(*(void *)(a1 + 32) + 72) |= 1uLL;
        CFRunLoopSourceSignal(v10);
        CFRelease(v10);
        _wakeUpRunLoop(a1);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }
LABEL_33:
    *(void *)(a1 + 16) &= ~0x40uLL;
    return v3;
  }
  return 0;
}

void __CFStreamDeallocate(uint64_t a1)
{
  unint64_t v2 = *(uint64_t **)(a1 + 48);
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  _CFStreamClose(a1);
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
    if (v4[1])
    {
      uint64_t v5 = (void (*)(void))v4[3];
      if (v5)
      {
        v5();
        uint64_t v4 = *(void **)(a1 + 32);
      }
    }
    CFIndex v6 = (const void *)v4[8];
    if (v6)
    {
      CFRelease(v6);
      uint64_t v4 = *(void **)(a1 + 32);
    }
    CFAllocatorDeallocate(v3, v4);
    *(void *)(a1 + 32) = 0;
  }
  if (v2)
  {
    CFAllocatorRef v7 = (void (*)(void))v2[2];
    if (v7)
    {
      if (*v2) {
        ((void (*)(uint64_t, void))v7)(a1, *(void *)(a1 + 40));
      }
      else {
        v7(*(void *)(a1 + 40));
      }
    }
    uint64_t v8 = *(void **)(a1 + 24);
    if (v8)
    {
      if (*v2 <= 1)
      {
        CFAllocatorDeallocate(v3, v8);
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v8 = *(void **)(a1 + 24);
    if (v8) {
LABEL_18:
    }
      CFRelease(v8);
  }
LABEL_19:
  if ((*(unsigned char *)(a1 + 16) & 0x20) == 0) {
    CFAllocatorDeallocate(v3, *(void **)(a1 + 48));
  }
  uint64_t v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v10 = *(NSObject **)(a1 + 128);
  if (v10)
  {
    dispatch_release(v10);
    *(void *)(a1 + 128) = 0;
  }
}

void _CFStreamClose(uint64_t a1)
{
  uint64_t Status = _CFStreamGetStatus(a1);
  if (!Status || Status == 6) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (Status == 7)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if ((v4 & 0x80) != 0) {
      return;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if ((v4 & 0x80) != 0) {
      return;
    }
  }
  *(void *)(a1 + 16) = v4 | 0xC0;
  uint64_t v5 = *(void (**)(uint64_t, void))(v3 + 88);
  if (v5) {
    v5(a1, *(void *)(a1 + 40));
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6 && *(void *)(v6 + 56))
  {
    if ((*(unsigned char *)(a1 + 17) & 1) == 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7)
      {
        uint64_t v8 = *(void **)(v7 + 56);
        if (v8)
        {
          CFRetain(*(CFTypeRef *)(v7 + 56));
          *(void *)(*(void *)(a1 + 32) + 56) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
          CFRelease(v8);
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v8);
          CFRelease(v8);
          goto LABEL_33;
        }
        *(void *)(v7 + 56) = 0;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      goto LABEL_33;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, (const void *)a1);
    CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, Value);
    CFIndex Count = CFArrayGetCount(v10);
    v20.CFIndex location = 0;
    v20.uint64_t length = Count;
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v10, v20, (const void *)a1);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex(v10, FirstIndexOfValue);
      --Count;
    }
    if (!Count)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13 && (uint64_t v14 = *(__CFRunLoopSource **)(v13 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v13 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)Value, 0);
        CFStringRef v16 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)Value, 1);
        CFRunLoopRemoveSource(ValueAtIndex, v14, v16);
        CFRelease(v14);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, Value);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, (const void *)a1);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    uint64_t v17 = *(void *)(a1 + 32);
    if (v17)
    {
      uint64_t v18 = *(void **)(v17 + 56);
      if (v18)
      {
        CFRetain(*(CFTypeRef *)(v17 + 56));
        *(void *)(*(void *)(a1 + 32) + 56) = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        CFRelease(v18);
        if (!Count) {
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v18);
        }
        CFRelease(v18);
        goto LABEL_32;
      }
      *(void *)(v17 + 56) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
LABEL_32:
    *(void *)(a1 + 16) &= ~0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
  }
LABEL_33:
  uint64_t v19 = *(void *)(a1 + 16);
  if ((v19 & 0x1E) != 6) {
    uint64_t v19 = v19 & 0xFFFFFFA0 | 6;
  }
  *(void *)(a1 + 16) = v19 & 0xFFFFFFFFFFFFFFBFLL;
}

uint64_t _CFStreamGetStatus(uint64_t a1)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = v2 & 0x1F;
  *(void *)(a1 + 16) = v2 | 0x40;
  if (result != 1) {
    goto LABEL_39;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 48);
  uint64_t v5 = (uint64_t (*)(uint64_t, long long *, void))v4[5];
  if (!v5) {
    goto LABEL_29;
  }
  if (*v4 <= 1)
  {
    long long v19 = 0uLL;
    int v6 = v5(a1, &v19, *(void *)(a1 + 40));
    if (DWORD2(v19))
    {
      uint64_t Typed = *(_OWORD **)(a1 + 24);
      if (!Typed)
      {
        CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
        uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v8, 16, 0x1000040D9A13B51, 0);
        *(void *)(a1 + 24) = Typed;
      }
      _OWORD *Typed = v19;
    }
    if (v6) {
      goto LABEL_9;
    }
LABEL_29:
    uint64_t result = 1;
    goto LABEL_39;
  }
  if (!v5(a1, (long long *)(a1 + 24), *(void *)(a1 + 40))) {
    goto LABEL_29;
  }
LABEL_9:
  uint64_t v9 = *(void *)(a1 + 24);
  if (v9) {
    BOOL v10 = (*(void *)(a1 + 16) & 0x1FLL) == 6;
  }
  else {
    BOOL v10 = 0;
  }
  int v11 = v10;
  if ((*(void *)(a1 + 16) & 0x1FuLL) - 8 < 0xFFFFFFFFFFFFFFFELL || v11 != 0)
  {
    uint64_t v13 = 2;
    if (v9) {
      uint64_t v13 = 7;
    }
    *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFE0 | v13;
  }
  uint64_t v14 = *(void *)(a1 + 32);
  if (v9)
  {
    if (v14 && (*(unsigned char *)(v14 + 48) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v15 = *(void *)(a1 + 32);
      if (v15 && (CFStringRef v16 = *(__CFRunLoopSource **)(v15 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v15 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(void *)(*(void *)(a1 + 32) + 72) |= 8uLL;
        CFRunLoopSourceSignal(v16);
        CFRelease(v16);
        _wakeUpRunLoop(a1);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }
    uint64_t result = 7;
  }
  else
  {
    if (v14 && (*(unsigned char *)(v14 + 48) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v17 = *(void *)(a1 + 32);
      if (v17 && (uint64_t v18 = *(__CFRunLoopSource **)(v17 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v17 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(void *)(*(void *)(a1 + 32) + 72) |= 1uLL;
        CFRunLoopSourceSignal(v18);
        CFRelease(v18);
        _wakeUpRunLoop(a1);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }
    uint64_t result = 2;
  }
LABEL_39:
  *(void *)(a1 + 16) &= ~0x40uLL;
  return result;
}

uint64_t dataWrite(char *a1, char *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Typed = *(void **)(a5 + 8);
  int64_t v11 = Typed[1] - Typed[2];
  if (*(__objc2_class ***)(a5 + 16) == &__kCFAllocatorNull && v11 < a3)
  {
LABEL_17:
    *(_DWORD *)(a4 + 8) = 12;
    *(void *)a4 = 1;
    return -1;
  }
  else
  {
    uint64_t v14 = a3;
    if (a3 >= 1)
    {
      uint64_t v16 = a3;
      while (1)
      {
        if (v11 >= 1)
        {
          if (v16 < v11) {
            int64_t v11 = v16;
          }
          memmove((void *)(*Typed + Typed[2]), __src, v11);
          v16 -= v11;
          uint64_t Typed = *(void **)(a5 + 8);
          Typed[2] += v11;
          if (v16 < 1) {
            break;
          }
          __src += v11;
        }
        if (v16 <= 1024) {
          int64_t v11 = 1024;
        }
        else {
          int64_t v11 = v16;
        }
        uint64_t Typed = (void *)CFAllocatorAllocateTyped(*(void *)(a5 + 16), v11 + 32, 2750053540, 0);
        if (!Typed) {
          goto LABEL_17;
        }
        void *Typed = Typed + 4;
        Typed[1] = v11;
        Typed[2] = 0;
        Typed[3] = 0;
        *(void *)(*(void *)(a5 + 8) + 24) = Typed;
        *(void *)(a5 + 8) = Typed;
      }
    }
    *(_DWORD *)(a4 + 8) = 0;
    if (*(unsigned char *)(a5 + 24) && (*(__objc2_class ***)(a5 + 16) != &__kCFAllocatorNull || Typed[1] > Typed[2])) {
      CFWriteStreamSignalEvent(a1, 4uLL, 0, a4, a5, a6, a7, a8);
    }
  }
  return v14;
}

uint64_t writeDataOpen(char *a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a4 + 24))
  {
    if (*(__objc2_class ***)(a4 + 16) == &__kCFAllocatorNull)
    {
      if (*(void *)(*(void *)(a4 + 8) + 8) <= *(void *)(*(void *)(a4 + 8) + 16)) {
        unint64_t v10 = 16;
      }
      else {
        unint64_t v10 = 4;
      }
    }
    else
    {
      unint64_t v10 = 4;
    }
    CFWriteStreamSignalEvent(a1, v10, 0, a4, a5, a6, a7, a8);
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

void writeDataFinalize(CFTypeRef cf, CFAllocatorRef *a2)
{
  uint64_t v4 = (__objc2_class **)a2[2];
  if (v4 != &__kCFAllocatorNull)
  {
    uint64_t v5 = (void *)*((void *)*a2 + 3);
    if (v5)
    {
      do
      {
        int v6 = (void *)v5[3];
        CFAllocatorDeallocate(a2[2], v5);
        uint64_t v5 = v6;
      }
      while (v6);
      uint64_t v4 = (__objc2_class **)a2[2];
    }
    CFRelease(v4);
  }
  CFAllocatorRef v7 = CFGetAllocator(cf);

  CFAllocatorDeallocate(v7, a2);
}

uint64_t __CFRunLoopDoSource0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  if (!atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire))
  {
    pthread_mutex_unlock(v4);
    return 0;
  }
  atomic_store(0, (unint64_t *)(a2 + 88));
  char v5 = atomic_load((unint64_t *)(a2 + 8));
  pthread_mutex_unlock(v4);
  if ((v5 & 8) == 0) {
    return 0;
  }
  int v6 = *(uint64_t (**)(uint64_t))(a2 + 176);
  uint64_t v7 = *(void *)(a2 + 112);
  if (a1 && !*(unsigned char *)(a1 + 681)) {
    CFAllocatorRef v8 = 0;
  }
  else {
    CFAllocatorRef v8 = (void *)_CFAutoreleasePoolPush();
  }
  kdebug_trace();
  __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(v6, v7);
  kdebug_trace();
  __CFRunLoopPerCalloutARPEnd(v8);
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return 1;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(uint64_t (*result)(uint64_t), uint64_t a2))(uint64_t)
{
  if (result) {
    return (uint64_t (*)(uint64_t))result(a2);
  }
  return result;
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
  __CFCheckCFInfoPACSignature((uint64_t)source);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
  char v3 = atomic_load((unint64_t *)source + 1);
  if ((v3 & 8) != 0)
  {
    kdebug_trace();
    uint64_t v4 = mach_absolute_time();
    uint64_t v5 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)source + 11, (unint64_t *)&v5, v4);
    kdebug_trace();
  }

  pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
}

uint64_t dataRead(char *a1, void *a2, uint64_t a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a6);
  uint64_t v18 = &BytePtr[CFDataGetLength(*(CFDataRef *)a6)];
  long long v19 = *(const UInt8 **)(a6 + 8);
  uint64_t v20 = v18 - v19;
  if (v18 - v19 >= a3) {
    uint64_t v20 = a3;
  }
  uint64_t v21 = v20 & ~(v20 >> 63);
  if (v20 >= 1)
  {
    memmove(a2, v19, v20 & ~(v20 >> 63));
    long long v19 = (const UInt8 *)(*(void *)(a6 + 8) + v21);
    *(void *)(a6 + 8) = v19;
  }
  *(_DWORD *)(a4 + 8) = 0;
  *a5 = v19 >= v18;
  if (*(unsigned char *)(a6 + 16) && v19 < v18) {
    CFReadStreamSignalEvent(a1, 2uLL, 0, v13, v14, v15, v16, v17);
  }
  return v21;
}

uint64_t readDataOpen(char *a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  if (*(unsigned char *)(a4 + 16))
  {
    if (CFDataGetLength(*(CFDataRef *)a4)) {
      unint64_t v12 = 2;
    }
    else {
      unint64_t v12 = 16;
    }
    CFReadStreamSignalEvent(a1, v12, 0, v7, v8, v9, v10, v11);
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  cf[3] = *(CFTypeRef *)off_1ECE0A5B0;
  cf[1] = 0;
  CFTypeRef cf[2] = 0;
  cf[0] = CFDataCreateWithBytesNoCopy(alloc, bytes, length, bytesDeallocator);
  uint64_t v5 = (__CFReadStream *)_CFStreamCreateWithConstantCallbacks((__objc2_class **)alloc, (uint64_t)cf, readDataCallBacks, 1);
  CFRelease(cf[0]);
  return v5;
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  v3[0] = 0u;
  v3[1] = (unint64_t)bufferAllocator;
  return (CFWriteStreamRef)_CFStreamCreateWithConstantCallbacks((__objc2_class **)alloc, (uint64_t)v3, writeDataCallBacks, 0);
}

uint64_t _CFStreamCreateWithConstantCallbacks(__objc2_class **a1, uint64_t a2, void *a3, int a4)
{
  if (*a3 != 1) {
    return 0;
  }
  double v7 = _CFStreamCreate(a1, a4);
  uint64_t v8 = v6;
  if (v6)
  {
    *(void *)(v6 + 16) |= 0x20uLL;
    *(void *)(v6 + 48) = a3;
    uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, double))a3[1];
    if (v9) {
      a2 = v9(v6, a2, v7);
    }
    *(void *)(v8 + 40) = a2;
  }
  return v8;
}

double _CFStreamCreate(__objc2_class **a1, int a2)
{
  if (a2) {
    unint64_t v2 = 38;
  }
  else {
    unint64_t v2 = 39;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, v2, 128, 0);
  if (Instance)
  {
    uint64_t v5 = *(void *)(Instance + 16);
    if ((v5 & 0x1E) != 6) {
      *(void *)(Instance + 16) = v5 & 0xFFFFFFE0;
    }
    *(void *)(Instance + 56) = 850045857;
    double result = 0.0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(void *)(Instance + 112) = 0;
  }
  return result;
}

uint64_t writeDataCreate(CFTypeRef cf, void *a2)
{
  CFAllocatorRef Default = (CFAllocatorRef)a2[2];
  if (Default == (CFAllocatorRef)&__kCFAllocatorNull)
  {
    CFAllocatorRef v7 = CFGetAllocator(cf);
    uint64_t result = CFAllocatorAllocateTyped(v7, 64, 2152488875, 0);
    *(void *)uint64_t result = result + 32;
    uint64_t v8 = *(void *)(*a2 + 8);
    *(void *)(result + 32) = *(void *)*a2;
    *(void *)(result + 40) = v8;
    *(void *)(result + 48) = 0;
    *(void *)(result + 56) = 0;
    *(void *)(result + 8) = result + 32;
  }
  else
  {
    if (!Default)
    {
      CFAllocatorRef Default = CFAllocatorGetDefault();
      a2[2] = Default;
    }
    CFRetain(Default);
    CFAllocatorRef v5 = CFGetAllocator(cf);
    uint64_t result = CFAllocatorAllocateTyped(v5, 1088, 1466909623, 0);
    *(void *)(result + 32) = result + 64;
    *(void *)(result + 48) = 0;
    *(void *)(result + 56) = 0;
    *(void *)(result + 40) = 1024;
    *(void *)uint64_t result = result + 32;
    *(void *)(result + 8) = result + 32;
    CFAllocatorRef Default = (CFAllocatorRef)a2[2];
  }
  *(void *)(result + 16) = Default;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t readDataCreate(const void *a1, CFTypeRef *a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t Typed = CFAllocatorAllocateTyped(v3, 24, 0x107004054E2031FLL, 0);
  if (Typed)
  {
    CFDataRef v5 = (const __CFData *)CFRetain(*a2);
    *(void *)uint64_t Typed = v5;
    *(void *)(Typed + 8) = CFDataGetBytePtr(v5);
    *(unsigned char *)(Typed + 16) = 0;
  }
  return Typed;
}

void readDataFinalize(const void *a1, CFTypeRef *a2)
{
  CFRelease(*a2);
  CFAllocatorRef v4 = CFGetAllocator(a1);

  CFAllocatorDeallocate(v4, a2);
}

uint64_t _CFPropertyListCreateFiltered(const __CFAllocator *a1, CFDataRef theData, uint64_t a3, const __CFSet *a4, CFTypeRef *a5, CFErrorRef *a6)
{
  uint64_t v6 = 0;
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  if (theData && a4)
  {
    char v22 = 0;
    memset(v23, 0, sizeof(v23));
    unint64_t v21 = 0;
    BytePtr = CFDataGetBytePtr(theData);
    unint64_t Length = CFDataGetLength(theData);
    CFTypeRef cf = 0;
    if (Length >= 8
      && (int v15 = Length, __CFDataGetBinaryPlistTopLevelInfo(theData, &v22, &v21, (uint64_t)v23)))
    {
      unint64_t v16 = v21;
      CFSetRef TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths(a1, a4);
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, 0, &kCFTypeDictionaryValueCallBacks);
      uint64_t v6 = __CFBinaryPlistCreateObjectFiltered(BytePtr, v15, v16, (uint64_t)v23, (__objc2_class **)a1, a3, (unint64_t)theData & (a3 << 47 >> 63), Mutable, 0, 0, (CFIndex)TopLevelKeyPaths, &cf, 0);
      CFRelease(TopLevelKeyPaths);
      CFRelease(Mutable);
    }
    else
    {
      uint64_t v6 = _CFPropertyListCreateWithData((__objc2_class **)a1, theData, a3, a6, 1, 0, a4, &cf) != 0;
    }
    if (a5 && v6)
    {
      *a5 = cf;
    }
    else if (cf)
    {
      CFRelease(cf);
    }
  }
  return v6;
}

uint64_t _CFPropertyListCreateWithData(__objc2_class **a1, CFDataRef theData, unsigned int a3, CFErrorRef *a4, char a5, void *a6, const __CFSet *a7, void *a8)
{
  char v10 = BYTE1(a3) | (a3 >> 9) | (a3 >> 10);
  if (BYTE1(a3) & 1 | ((a3 & 0x200) != 0) | ((a3 & 0x400) != 0)) {
    int v11 = (a3 >> 8) & 1;
  }
  else {
    int v11 = 1;
  }
  if (BYTE1(a3) & 1 | ((a3 & 0x200) != 0) | ((a3 & 0x400) != 0)) {
    int v12 = (a3 >> 10) & 1;
  }
  else {
    int v12 = 1;
  }
  if (!theData || !CFDataGetLength(theData))
  {
    if (!a4) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Cannot parse a NULL or zero-length data");
LABEL_17:
    uint64_t v18 = 0;
    *a4 = Error;
    return v18;
  }
  if (((a3 & 0x200) != 0 || (v10 & 1) == 0)
    && __CFTryParseBinaryPlist(a1, theData, a3, a8, 0))
  {
    if (a6) {
      *a6 = 200;
    }
    return 1;
  }
  if (!(v12 | v11))
  {
    if (!a4) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unsupported property list");
    goto LABEL_17;
  }
  char v50 = a5;
  BytePtr = CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  unsigned int v22 = Length;
  if (Length < 5)
  {
    if (Length != 4)
    {
      if (Length < 3)
      {
LABEL_51:
        uint64_t v26 = 0;
        goto LABEL_52;
      }
      int v23 = *BytePtr;
LABEL_36:
      switch(v23)
      {
        case 0:
          goto LABEL_54;
        case 254:
          int v25 = BytePtr[1];
          if (v25 == 255)
          {
            unint64_t v49 = a6;
            int v24 = 268435712;
            goto LABEL_55;
          }
          break;
        case 255:
          int v25 = BytePtr[1];
          if (v25 == 254)
          {
            unint64_t v49 = a6;
LABEL_44:
            int v24 = 335544576;
LABEL_55:
            uint64_t v28 = 2;
            goto LABEL_56;
          }
          break;
        default:
          int v25 = BytePtr[1];
          break;
      }
      goto LABEL_48;
    }
    int v23 = *BytePtr;
  }
  else
  {
    int v23 = *BytePtr;
    if (v23 == 255)
    {
      int v25 = BytePtr[1];
      if (v25 == 254)
      {
        unint64_t v49 = a6;
        if (!BytePtr[2] && !BytePtr[3])
        {
          int v24 = 469762304;
          goto LABEL_90;
        }
        goto LABEL_44;
      }
LABEL_48:
      if (v25) {
        goto LABEL_49;
      }
LABEL_54:
      unint64_t v49 = a6;
      int v24 = 256;
      goto LABEL_55;
    }
    if (!*BytePtr)
    {
      if (!BytePtr[1] && BytePtr[2] == 254 && BytePtr[3] == 255)
      {
        unint64_t v49 = a6;
        int v24 = 402653440;
LABEL_90:
        uint64_t v28 = 4;
LABEL_56:
        CFStringEncoding v29 = v24;
        unsigned int v30 = &CFDataGetBytePtr(theData)[v28];
        CFIndex v31 = CFDataGetLength(theData);
        CFStringRef v32 = CFStringCreateWithBytes((CFAllocatorRef)a1, v30, v31 - v28, v29, 0);
        if (v32)
        {
          CFStringRef v33 = v32;
          CFDataRef UTF8DataFromString = _createUTF8DataFromString((const __CFAllocator *)a1, v32);
          uint64_t v18 = _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, UTF8DataFromString, 0, v33, 0, a3, a4, v50, v49, a7, a8, v12, v11);
          CFRelease(v33);
          if (UTF8DataFromString) {
            CFRelease(UTF8DataFromString);
          }
          return v18;
        }
        if (a4)
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Could not determine the encoding of the XML data (string creation failed)");
          goto LABEL_17;
        }
        return 0;
      }
      goto LABEL_54;
    }
  }
  if (v23 != 239) {
    goto LABEL_36;
  }
  int v25 = BytePtr[1];
  if (v25 != 187) {
    goto LABEL_48;
  }
  if (BytePtr[2] == 191)
  {
    uint64_t v26 = 3;
LABEL_52:
    char v27 = v50;
    return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
  }
LABEL_49:
  if (Length < 5 || strncmp((const char *)BytePtr, "<?xml", 5uLL)) {
    goto LABEL_51;
  }
  uint64_t i = (unsigned __int8 *)(BytePtr + 5);
  unsigned int v36 = &BytePtr[v22];
  if (v22 < 6uLL)
  {
LABEL_76:
    char v27 = v50;
    if (i < v36)
    {
      int v39 = *i;
      if (v39 == 39 || v39 == 34)
      {
        int v40 = (char)v39;
        unsigned int v41 = i + 1;
        uint64_t v42 = 1;
        while (&i[v42] < v36)
        {
          int v43 = i[v42++];
          if (v43 == v40)
          {
            if (v42 == 7
              && (*v41 | 0x20) == 0x75
              && (i[2] | 0x20) == 0x74
              && (i[3] | 0x20) == 0x66
              && i[4] == 45
              && i[5] == 56)
            {
              goto LABEL_88;
            }
            CFStringRef v45 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, (v42 - 2), 0x201u, 0);
            CFStringEncoding v46 = CFStringConvertIANACharSetNameToEncoding(v45);
            if (v46 == -1)
            {
              CFErrorRef v44 = __CFPropertyListCreateError(3840, @"Encountered unknown encoding (%@)", v45);
              if (v45) {
                CFRelease(v45);
              }
              goto LABEL_92;
            }
            int v24 = v46;
            unint64_t v49 = a6;
            if (v45)
            {
              CFStringEncoding v47 = v46;
              CFRelease(v45);
              int v24 = v47;
            }
            if (v24 == 134217984)
            {
              uint64_t v26 = 0;
              char v27 = v50;
              a6 = v49;
              return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
            }
            CFErrorRef v44 = 0;
            uint64_t v28 = 0;
            if (!v24) {
              goto LABEL_92;
            }
            goto LABEL_56;
          }
        }
      }
    }
    goto LABEL_88;
  }
  int v37 = *i;
  char v27 = v50;
  if ((v37 & 0xFE) == 0x3E)
  {
LABEL_88:
    uint64_t v26 = 0;
    return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
  }
  for (uint64_t i = (unsigned __int8 *)(BytePtr + 14); i < v36; ++i)
  {
    int v38 = *(i - 8);
    if (v37 == 101
      && v38 == 110
      && *(i - 7) == 99
      && *(i - 6) == 111
      && *(i - 5) == 100
      && *(i - 4) == 105
      && *(i - 3) == 110
      && *(i - 2) == 103
      && *(i - 1) == 61)
    {
      goto LABEL_76;
    }
    uint64_t v26 = 0;
    int v37 = v38;
    if ((v38 & 0xFE) == 0x3E) {
      return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
    }
  }
  CFErrorRef v44 = __CFPropertyListCreateError(3840, @"End of buffer while looking for encoding name", v26);
LABEL_92:
  if (a4 && !v44)
  {
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Could not determine the encoding of the XML data");
    goto LABEL_17;
  }
  if (a4 && v44)
  {
    uint64_t v18 = 0;
    *a4 = v44;
    return v18;
  }
  uint64_t v18 = 0;
  if (!a4 && v44)
  {
    CFRelease(v44);
    return 0;
  }
  return v18;
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  if (!CF_IS_OBJC(0x14uLL, (unint64_t)theData)) {
    return *((void *)theData + 2);
  }

  return [(__CFData *)theData length];
}

uint64_t __CFTryParseBinaryPlist(__objc2_class **a1, CFDataRef theData, uint64_t a3, void *a4, CFTypeRef *a5)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  BytePtr = CFDataGetBytePtr(theData);
  unint64_t Length = CFDataGetLength(theData);
  if (Length < 8) {
    return 0;
  }
  int v12 = Length;
  char v18 = 0;
  memset(v19, 0, sizeof(v19));
  *(void *)uint64_t v17 = 0;
  if (!__CFDataGetBinaryPlistTopLevelInfo(theData, &v18, (unint64_t *)v17, (uint64_t)v19)) {
    return 0;
  }
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  _CFDictionarySetCapacity((unint64_t)Mutable, *((uint64_t *)&v19[0] + 1));
  CFTypeRef v16 = 0;
  uint64_t v14 = __CFBinaryPlistCreateObjectFiltered(BytePtr, v12, *(unint64_t *)v17, (uint64_t)v19, a1, a3, 0, Mutable, 0, 0, 0, &v16, 0);
  if (v14)
  {
    if (a4) {
      *a4 = v16;
    }
  }
  else
  {
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = CFRetain(@"binary data is corrupt");
    }
  }
  CFRelease(Mutable);
  return v14;
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    return (const UInt8 *)[(__CFData *)theData bytes];
  }
  else
  {
    char v3 = atomic_load((unint64_t *)theData + 1);
    if ((v3 & 4) != 0) {
      return (const UInt8 *)(((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0);
    }
    else {
      return (const UInt8 *)*((void *)theData + 5);
    }
  }
}

void _CFDictionarySetCapacity(unint64_t a1, uint64_t a2)
{
  if (!CF_IS_OBJC(0x12uLL, a1))
  {
    CFBasicHashSetCapacity(a1, a2);
  }
}

void CFBasicHashSetCapacity(uint64_t a1, uint64_t a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0)
  {
    __break(1u);
  }
  else
  {
    uint64_t v3 = *(unsigned int *)(a1 + 20);
    BOOL v4 = a2 <= v3;
    uint64_t v5 = a2 - v3;
    if (!v4)
    {
      ++*(_WORD *)(a1 + 16);
      __CFBasicHashRehash(a1, v5);
    }
  }
}

uint64_t __CFDataGetBinaryPlistTopLevelInfo(void *a1, unsigned char *a2, unint64_t *a3, uint64_t a4)
{
  if (CF_IS_OBJC(0x14uLL, (unint64_t)a1)) {
    return [a1 _getBPlistMarker:a2 offset:a3 trailer:a4];
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)a1);
  if (CF_IS_OBJC(0x14uLL, (unint64_t)a1)) {
    unint64_t v10 = [a1 length];
  }
  else {
    unint64_t v10 = a1[2];
  }
  return __CFBinaryPlistGetTopLevelInfo(BytePtr, v10, a2, a3, a4);
}

uint64_t __CFBinaryPlistGetTopLevelInfo(_DWORD *a1, unint64_t a2, unsigned char *a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v5 = 0;
  if (a1 && a2 >= 0x29)
  {
    if (*a1 != 1768714338 || *(_DWORD *)((char *)a1 + 3) != 812938089) {
      return 0;
    }
    uint64_t v5 = 0;
    uint64_t v8 = (char *)a1 + a2;
    unint64_t v9 = bswap64(*(void *)((char *)a1 + a2 - 24));
    if ((uint64_t)v9 >= 1)
    {
      unint64_t v10 = bswap64(*((void *)v8 - 1));
      if ((v10 & 0x8000000000000000) == 0)
      {
        unint64_t v11 = bswap64(*((void *)v8 - 2));
        if (v9 > v11 && v10 >= 9 && a2 - 32 > v10)
        {
          unint64_t v12 = *(v8 - 26);
          if (!*(v8 - 26)) {
            return 0;
          }
          unsigned int v13 = *(v8 - 25);
          if (!*(v8 - 25)) {
            return 0;
          }
          if (!is_mul_ok(v9, v12)) {
            return 0;
          }
          unint64_t v14 = v9 * v12;
          if (!(v9 * v12) || v10 + v14 > 0xFFFFFFFFFFFFFFDFLL) {
            return 0;
          }
          uint64_t v5 = 0;
          if (v10 > ~v14 || v10 + v14 + 32 != a2) {
            return v5;
          }
          if (v13 <= 7 && v9 >> (8 * v13)
            || v12 <= 7 && v10 >> (8 * v12))
          {
            return 0;
          }
          uint64_t v5 = 0;
          BOOL v15 = __CFADD__(v10, a1);
          if ((unint64_t)a1 <= 0xFFFFFFFFFFFFFFF7 && !v15)
          {
            if ((unint64_t)a1 + v10 <= -(uint64_t)v14)
            {
              uint64_t v16 = 0;
              uint64_t v17 = v8 - 32;
              if (v12 <= 1) {
                uint64_t v18 = 1;
              }
              else {
                uint64_t v18 = v12;
              }
              long long v19 = (_DWORD *)((char *)a1 + v10);
              while (1)
              {
                switch((int)v12)
                {
                  case 1:
                    unint64_t v20 = *(unsigned __int8 *)v19;
                    break;
                  case 2:
                    unint64_t v20 = __rev16(*(unsigned __int16 *)v19);
                    break;
                  case 4:
                    unint64_t v20 = bswap32(*v19);
                    break;
                  case 8:
                    unint64_t v20 = bswap64(*(void *)v19);
                    break;
                  default:
                    uint64_t v21 = 0;
                    unint64_t v20 = 0;
                    do
                      unint64_t v20 = *((unsigned __int8 *)v19 + v21++) | (v20 << 8);
                    while (v18 != v21);
                    break;
                }
                if (v10 - 1 < v20) {
                  break;
                }
                long long v19 = (unsigned int *)((char *)v19 + v12);
                if (++v16 == v9)
                {
                  unsigned int v22 = (_DWORD *)((char *)a1 + v10 + v11 * v12);
                  switch((int)v12)
                  {
                    case 1:
                      unint64_t v23 = *(unsigned __int8 *)v22;
                      break;
                    case 2:
                      unint64_t v23 = __rev16(*(unsigned __int16 *)v22);
                      break;
                    case 4:
                      unint64_t v23 = bswap32(*v22);
                      break;
                    case 8:
                      unint64_t v23 = bswap64(*(void *)v22);
                      break;
                    default:
                      unint64_t v23 = 0;
                      do
                      {
                        unsigned int v24 = *(unsigned __int8 *)v22;
                        unsigned int v22 = (unsigned int *)((char *)v22 + 1);
                        unint64_t v23 = v24 | (v23 << 8);
                        --v18;
                      }
                      while (v18);
                      break;
                  }
                  if (v23 >= 8 && v10 > v23)
                  {
                    if (a5)
                    {
                      int v26 = *(_DWORD *)v17;
                      *(_WORD *)(a5 + 4) = *((_WORD *)v17 + 2);
                      *(_DWORD *)a5 = v26;
                      *(unsigned char *)(a5 + 6) = v12;
                      *(unsigned char *)(a5 + 7) = v13;
                      *(void *)(a5 + 8) = v9;
                      *(void *)(a5 + 16) = v11;
                      *(void *)(a5 + 24) = v10;
                    }
                    if (a4) {
                      *a4 = v23;
                    }
                    if (a3) {
                      *a3 = *((unsigned char *)a1 + v23);
                    }
                    return 1;
                  }
                  return 0;
                }
              }
            }
            return 0;
          }
        }
      }
    }
  }
  return v5;
}

ssize_t fileWrite(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  ssize_t v6 = fdWrite(*(_DWORD *)(a5 + 8), a2, a3, a4);
  uint64_t v7 = *(void *)(a5 + 24);
  if (v7)
  {
    *(void *)(a5 + 24) = v7 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v8 = *(__CFFileDescriptor **)(a5 + 16);
    if (v8) {
      CFFileDescriptorEnableCallBacks(v8, 2uLL);
    }
  }
  return v6;
}

ssize_t fdWrite(int a1, const void *a2, size_t a3, uint64_t a4)
{
  ssize_t result = write(a1, a2, a3);
  if (result < 0)
  {
    int v6 = *__error();
    *(void *)a4 = 1;
    ssize_t result = -1;
  }
  else
  {
    int v6 = 0;
  }
  *(_DWORD *)(a4 + 8) = v6;
  return result;
}

ssize_t fileRead(uint64_t a1, void *a2, size_t a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  ssize_t v8 = fdRead(*(_DWORD *)(a6 + 8), a2, a3, a4, a5);
  uint64_t v9 = *(void *)(a6 + 24);
  if ((v9 & 2) != 0)
  {
    *(void *)(a6 + 24) = v9 & 0xFFFFFFFFFFFFFFFDLL;
    if (!*a5)
    {
      if (*(void *)(a6 + 16))
      {
        memset(&v13, 0, sizeof(v13));
        if ((fstat(*(_DWORD *)(a6 + 8), &v13) & 0x80000000) == 0 && (v13.st_mode & 0xF000) == 0x8000)
        {
          off_t v12 = lseek(*(_DWORD *)(a6 + 8), 0, 1);
          if (v13.st_size == v12) {
            _CFFileDescriptorInduceFakeReadCallBack(*(void *)(a6 + 16));
          }
        }
      }
    }
    unint64_t v10 = *(__CFFileDescriptor **)(a6 + 16);
    if (v10) {
      CFFileDescriptorEnableCallBacks(v10, 1uLL);
    }
  }
  return v8;
}

ssize_t fdRead(int a1, void *a2, size_t a3, uint64_t a4, BOOL *a5)
{
  ssize_t result = read(a1, a2, a3);
  if (result < 0)
  {
    int v8 = *__error();
    *(void *)a4 = 1;
    ssize_t result = -1;
  }
  else
  {
    int v8 = 0;
    *a5 = result == 0;
  }
  *(_DWORD *)(a4 + 8) = v8;
  return result;
}

void *__CFAllocatorSystemReallocate(void *ptr, size_t size, int a3, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }

  return malloc_type_zone_realloc(zone, ptr, size, 0x82F82C52uLL);
}

uint64_t fileCreate(const void *a1, uint64_t a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t Typed = CFAllocatorAllocateTyped(v3, 40, 0x10600401BE82CDFLL, 0);
  if (Typed)
  {
    uint64_t v5 = *(const void **)a2;
    *(void *)uint64_t Typed = *(void *)a2;
    if (v5) {
      CFRetain(v5);
    }
    *(_DWORD *)(Typed + 8) = *(_DWORD *)(a2 + 8);
    *(void *)(Typed + 16) = 0;
    *(void *)(Typed + 24) = 0;
    *(void *)(Typed + 32) = -1;
  }
  return Typed;
}

void fileClose(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 < 0)
  {
    uint64_t v5 = (const void **)(a2 + 16);
    uint64_t v7 = *(const void **)(a2 + 16);
    if (!v7) {
      return;
    }
  }
  else
  {
    close(v3);
    int v6 = *(__CFFileDescriptor **)(a2 + 16);
    uint64_t v5 = (const void **)(a2 + 16);
    BOOL v4 = v6;
    *((_DWORD *)v5 - 2) = -1;
    if (!v6) {
      return;
    }
    CFFileDescriptorInvalidate(v4);
    uint64_t v7 = *v5;
  }
  CFRelease(v7);
  *uint64_t v5 = 0;
}

void fileFinalize(const void *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  if (v4 < 1)
  {
    if (v5) {
      CFRelease(*(CFTypeRef *)(a2 + 16));
    }
  }
  else
  {
    if (v5)
    {
      CFFileDescriptorInvalidate(*(CFFileDescriptorRef *)(a2 + 16));
      CFRelease(*(CFTypeRef *)(a2 + 16));
      *(void *)(a2 + 16) = 0;
      int v4 = *(_DWORD *)(a2 + 8);
    }
    close(v4);
  }
  if (*(void *)a2) {
    CFRelease(*(CFTypeRef *)a2);
  }
  CFAllocatorRef v6 = CFGetAllocator(a1);

  CFAllocatorDeallocate(v6, (void *)a2);
}

void _CFFileDescriptorInduceFakeReadCallBack(uint64_t a1)
{
  v3[5] = *(void *)off_1ECE0A5B0;
  char v2 = __fdQueue();
  v3[0] = off_1ECE0A5A0;
  v3[1] = 0x40000000;
  _OWORD v3[2] = ___CFFileDescriptorInduceFakeReadCallBack_block_invoke;
  v3[3] = &__block_descriptor_tmp_7;
  v3[4] = a1;
  dispatch_async(v2, v3);
}

uint64_t __CFRunLoopRun(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  uint64_t v74 = *(void *)off_1ECE0A5B0;
  uint64_t v10 = mach_absolute_time();
  uint64_t v11 = a1 + *(unsigned __int8 *)(a1 + 84);
  int v13 = *(unsigned __int8 *)(v11 + 85);
  off_t v12 = (unsigned char *)(v11 + 85);
  if (v13)
  {
    *off_t v12 = 0;
    return 2;
  }
  if (*(unsigned char *)(a2 + 88))
  {
    *(unsigned char *)(a2 + 88) = 0;
    return 2;
  }
  uint64_t v16 = v10;
  if (pthread_main_np() == 1
    && !_CFGetTSD(4u)
    && CFRunLoopGetMain() == (CFRunLoopRef)a1
    && CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
  {
    mach_port_name_t main_queue_port_4CF = _dispatch_get_main_queue_port_4CF();
  }
  else
  {
    mach_port_name_t main_queue_port_4CF = 0;
  }
  if (!*(void *)(a2 + 160)) {
    goto LABEL_14;
  }
  int port_4CF = _dispatch_runloop_root_queue_get_port_4CF();
  if (!port_4CF)
  {
    qword_1EC093AA8 = (uint64_t)"Unable to get port for run loop mode queue";
    __break(1u);
LABEL_14:
    int port_4CF = 0;
  }
  if (a5 <= 0.0)
  {
    uint64_t v19 = 0;
    source = 0;
  }
  else if (a5 <= 504911232.0)
  {
    uint64_t v19 = __CFTimeIntervalToTSR(a5) + v16;
    if (pthread_main_np() == 1) {
      intptr_t v20 = qos_class_main();
    }
    else {
      intptr_t v20 = 17;
    }
    global_queue = dispatch_get_global_queue(v20, 2uLL);
    unsigned int v22 = dispatch_source_create((dispatch_source_type_t)off_1ECE0A620, 0, 0, global_queue);
    CFRetain((CFTypeRef)a1);
    handler[0] = off_1ECE0A5A0;
    handler[1] = 3221225472;
    handler[2] = ____CFRunLoopRun_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = a1;
    dispatch_source_set_event_handler(v22, handler);
    v68[0] = off_1ECE0A5A0;
    v68[1] = 3221225472;
    v68[2] = ____CFRunLoopRun_block_invoke_2;
    v68[3] = &__block_descriptor_40_e5_v8__0l;
    v68[4] = a1;
    dispatch_source_set_cancel_handler(v22, v68);
    double v23 = __CFTSRToTimeInterval(v16);
    dispatch_time_t v24 = dispatch_time(1uLL, (unint64_t)((v23 + a5) * 1000000000.0));
    dispatch_source_set_timer(v22, v24, 0xFFFFFFFFFFFFFFFFLL, 0x3E8uLL);
    source = v22;
    dispatch_resume(v22);
  }
  else
  {
    source = 0;
    uint64_t v19 = -1;
  }
  uint64_t v57 = v19;
  BOOL v59 = v19 != 0;
  uint64_t v60 = (pthread_mutex_t *)(a1 + 16);
  unsigned int v61 = (pthread_mutex_t *)(a2 + 16);
  mach_port_name_t name = main_queue_port_4CF;
  int v25 = 1;
  uint64_t v58 = a4;
  int v62 = a3;
  do
  {
    __cftrace_runloop_trace_iteration_start(a4, (__CFRunLoop *)a1);
    id v66 = 0;
    voucher_mach_msg_state_t state = (voucher_mach_msg_state_t)-1;
    uint64_t v65 = 0;
    mach_port_t v64 = 0;
    mach_port_name_t v26 = *(_DWORD *)(a2 + 136);
    *(unsigned char *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 0;
    uint64_t v27 = *(void *)(a2 + 144);
    if ((v27 & 2) != 0)
    {
      __CFRunLoopDoObservers(a1, a2, 2);
      uint64_t v27 = *(void *)(a2 + 144);
    }
    if ((v27 & 4) != 0) {
      __CFRunLoopDoObservers(a1, a2, 4);
    }
    __CFRunLoopDoBlocks(a1, a2);
    int v28 = __CFRunLoopDoSources0(a1, a2, a3);
    int v29 = v59;
    if (v28)
    {
      __CFRunLoopDoBlocks(a1, a2);
      int v29 = 0;
    }
    if (!name
      || v25
      || (uint64_t v65 = v73, !__CFRunLoopServiceMachPort(name, (mach_msg_header_t **)&v65, &v64, 0, &state, 0)))
    {
      if (v29)
      {
        if ((*(unsigned char *)(a2 + 144) & 0x20) != 0) {
          __CFRunLoopDoObservers(a1, a2, 32);
        }
        unint64_t v30 = atomic_load((unint64_t *)(a1 + 8));
        unint64_t v31 = v30;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v31, v30 | 2);
          BOOL v32 = v31 == v30;
          unint64_t v30 = v31;
        }
        while (!v32);
        if (name) {
          mach_port_insert_member(*(_DWORD *)off_1ECE0A6C8, name, v26);
        }
        pthread_mutex_unlock(v61);
        pthread_mutex_unlock(v60);
        double Current = CFAbsoluteTimeGetCurrent();
      }
      else
      {
        unint64_t v34 = atomic_load((unint64_t *)(a1 + 8));
        unint64_t v35 = v34;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v35, v34 | 2);
          BOOL v32 = v35 == v34;
          unint64_t v34 = v35;
        }
        while (!v32);
        if (name) {
          mach_port_insert_member(*(_DWORD *)off_1ECE0A6C8, name, v26);
        }
        pthread_mutex_unlock(v61);
        pthread_mutex_unlock(v60);
        double Current = 0.0;
      }
      kdebug_trace();
      kdebug_trace();
      uint64_t v65 = v73;
      __CFRunLoopServiceMachPort(v26, (mach_msg_header_t **)&v65, &v64, v29 << 31 >> 31, &state, &v66);
      if (port_4CF && v64 == port_4CF)
      {
        while (1)
        {
          while ((_dispatch_runloop_root_queue_perform_4CF() & 1) != 0)
            ;
          if (*(unsigned char *)(a2 + 168)) {
            break;
          }
          if (v65 && v65 != v73) {
            free(v65);
          }
          uint64_t v65 = v73;
          __CFRunLoopServiceMachPort(v26, (mach_msg_header_t **)&v65, &v64, v29 << 31 >> 31, &state, &v66);
          if (v64 != port_4CF) {
            goto LABEL_58;
          }
        }
        *(unsigned char *)(a2 + 168) = 0;
      }
LABEL_58:
      kdebug_trace();
      kdebug_trace();
      pthread_mutex_lock(v60);
      pthread_mutex_lock(v61);
      if (v29)
      {
        *(double *)(a1 + 664) = *(double *)(a1 + 664) + CFAbsoluteTimeGetCurrent() - Current;
        a4 = v58;
        if (name) {
          mach_port_extract_member(*(_DWORD *)off_1ECE0A6C8, name, v26);
        }
        *(unsigned char *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
        unint64_t v36 = atomic_load((unint64_t *)(a1 + 8));
        unint64_t v37 = v36;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v37, v36 & 0xFFFFFFFFFFFFFFFDLL);
          BOOL v32 = v37 == v36;
          unint64_t v36 = v37;
        }
        while (!v32);
        if ((*(unsigned char *)(a2 + 144) & 0x40) != 0) {
          __CFRunLoopDoObservers(a1, a2, 64);
        }
      }
      else
      {
        *(double *)(a1 + 664) = *(double *)(a1 + 664) + 0.0;
        a4 = v58;
        if (name) {
          mach_port_extract_member(*(_DWORD *)off_1ECE0A6C8, name, v26);
        }
        *(unsigned char *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
        unint64_t v38 = atomic_load((unint64_t *)(a1 + 8));
        unint64_t v39 = v38;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v39, v38 & 0xFFFFFFFFFFFFFFFDLL);
          BOOL v32 = v39 == v38;
          unint64_t v38 = v39;
        }
        while (!v32);
      }
    }
    *(unsigned char *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
    int v40 = (const void *)v64;
    if (!v64)
    {
      int v25 = 0;
      goto LABEL_99;
    }
    if (v64 != *(_DWORD *)(a1 + 80))
    {
      if (port_4CF && v64 == port_4CF)
      {
        uint64_t v41 = mach_absolute_time();
        if (!__CFRunLoopDoTimers(a1, a2, v41)) {
          goto LABEL_83;
        }
      }
      else
      {
        int v42 = *(_DWORD *)(a2 + 172);
        if (v42 && v64 == v42)
        {
          uint64_t v43 = mach_absolute_time();
          if (!__CFRunLoopDoTimers(a1, a2, v43))
          {
            *(void *)(a2 + 184) = -1;
            *(void *)(a2 + 192) = -1;
LABEL_83:
            __CFArmNextTimerInMode(a2);
          }
        }
        else
        {
          if (v64 == name)
          {
            pthread_mutex_unlock(v61);
            pthread_mutex_unlock(v60);
            _CFSetTSD(4u, 6, 0);
            CFErrorRef v44 = (void *)_CFAutoreleasePoolPush();
            kdebug_trace();
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();
            kdebug_trace();
            __CFRunLoopPerCalloutARPEnd(v44);
            _CFSetTSD(4u, 0, 0);
            pthread_mutex_lock(v60);
            pthread_mutex_lock(v61);
            int v25 = 1;
            int v28 = 1;
            goto LABEL_99;
          }
          kdebug_trace();
          uint64_t v45 = _CFSetTSD(0xDu, (uint64_t)v66, (uint64_t)off_1ECE0A700);
          if ((__CF_FORK_STATE & 2) == 0) {
            __CF_USED();
          }
          if (__CF_FORK_STATE) {
            __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
          }
          CFDictionaryRef v46 = *(const __CFDictionary **)(a2 + 128);
          if (v46 && CFDictionaryGetValue(v46, v40))
          {
            *(void *)msg = 0;
            int v47 = __CFRunLoopDoSource1(a1, a2);
            uint64_t v48 = *(void **)msg;
            if (*(void *)msg)
            {
              mach_msg(*(mach_msg_header_t **)msg, 1, *(_DWORD *)(*(void *)msg + 4), 0, 0, 0, 0);
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v48);
            }
            v28 |= v47;
          }
          else
          {
            unint64_t v49 = _CFOSLog();
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              uint64_t v55 = *(void *)(a2 + 80);
              *(_DWORD *)msg = 138412546;
              *(void *)&msg[4] = v55;
              __int16 v71 = 1024;
              int v72 = (int)v40;
              _os_log_error_impl(&dword_182B90000, v49, OS_LOG_TYPE_ERROR, "__CFRunLoopModeFindSourceForMachPort returned NULL for mode '%@' livePort: %u", msg, 0x12u);
            }
          }
          _CFSetTSD(0xDu, v45, (uint64_t)off_1ECE0A700);
          kdebug_trace();
        }
      }
      int v25 = 0;
      goto LABEL_99;
    }
    int v25 = 0;
LABEL_99:
    if (v65 && v65 != v73) {
      free(v65);
    }
    __CFRunLoopDoBlocks(a1, a2);
    if (v62 && v28)
    {
      BOOL v50 = 0;
      uint64_t v14 = 4;
LABEL_107:
      a3 = v62;
      goto LABEL_113;
    }
    if (v57 < mach_absolute_time())
    {
      BOOL v50 = 0;
      uint64_t v14 = 3;
      goto LABEL_107;
    }
    uint64_t v51 = a1 + *(unsigned __int8 *)(a1 + 84);
    int v53 = *(unsigned __int8 *)(v51 + 85);
    int v52 = (unsigned char *)(v51 + 85);
    a3 = v62;
    if (v53)
    {
      BOOL v50 = 0;
      *int v52 = 0;
LABEL_112:
      uint64_t v14 = 2;
      goto LABEL_113;
    }
    if (*(unsigned char *)(a2 + 88))
    {
      BOOL v50 = 0;
      *(unsigned char *)(a2 + 88) = 0;
      goto LABEL_112;
    }
    int IsEmpty = __CFRunLoopModeIsEmpty(a1, a2);
    BOOL v50 = IsEmpty == 0;
    uint64_t v14 = IsEmpty != 0;
LABEL_113:
    voucher_mach_msg_revert(state);

    kdebug_trace();
  }
  while (v50);
  if (source)
  {
    dispatch_source_cancel(source);
    dispatch_release(source);
  }
  return v14;
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &__tp);
  return (double)__tp.tv_sec + -978307200.0 + (double)__tp.tv_nsec * 0.000000001;
}

uint64_t __CFRunLoopDoBlocks(uint64_t a1, uint64_t a2)
{
  uint64_t result = kdebug_trace();
  uint64_t v5 = *(void **)(a1 + 640);
  if (!v5) {
    return result;
  }
  CFAllocatorRef v6 = *(const void **)(a2 + 80);
  if (!v6) {
    return result;
  }
  uint64_t v7 = *(void **)(a1 + 648);
  *(void *)(a1 + 640) = 0;
  *(void *)(a1 + 648) = 0;
  CFSetRef theSet = *(const __CFSet **)(a1 + 608);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  int v8 = 0;
  uint64_t v9 = v5;
  do
  {
    while (1)
    {
      uint64_t v10 = v5;
      uint64_t v5 = (void *)*v5;
      CFTypeID v11 = CFGetTypeID((CFTypeRef)v10[1]);
      off_t v12 = (const void *)v10[1];
      if (v11 == 7)
      {
        if (CFEqual(v12, v6)) {
          goto LABEL_11;
        }
        if (!CFEqual((CFTypeRef)v10[1], @"kCFRunLoopCommonModes")) {
          goto LABEL_22;
        }
        break;
      }
      if (CFSetContainsValue((CFSetRef)v12, v6)) {
        goto LABEL_11;
      }
      if (CFSetContainsValue((CFSetRef)v10[1], @"kCFRunLoopCommonModes")) {
        break;
      }
LABEL_22:
      int v8 = v10;
      if (!v5) {
        goto LABEL_23;
      }
    }
    if (!CFSetContainsValue(theSet, v6)) {
      goto LABEL_22;
    }
LABEL_11:
    if (v8) {
      *int v8 = v5;
    }
    if (v10 == v9) {
      uint64_t v9 = v5;
    }
    if (v10 == v7) {
      uint64_t v7 = v8;
    }
    int v13 = (const void *)v10[2];
    CFRelease((CFTypeRef)v10[1]);
    free(v10);
    if (*(unsigned char *)(a1 + 681)) {
      uint64_t v14 = (void *)_CFAutoreleasePoolPush();
    }
    else {
      uint64_t v14 = 0;
    }
    kdebug_trace();
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__((uint64_t)v13);
    kdebug_trace();
    __CFRunLoopPerCalloutARPEnd(v14);
    _Block_release(v13);
  }
  while (v5);
LABEL_23:
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  if (v9)
  {
    if (v7)
    {
      *uint64_t v7 = *(void *)(a1 + 640);
      *(void *)(a1 + 640) = v9;
      if (!*(void *)(a1 + 648)) {
        *(void *)(a1 + 648) = v7;
      }
    }
  }

  return kdebug_trace();
}

uint64_t __CFRunLoopServiceMachPort(mach_port_name_t rcv_name, mach_msg_header_t **a2, mach_port_t *a3, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *a5, id *a6)
{
  char v11 = 0;
  unsigned int v12 = 3072;
  while (1)
  {
    int v13 = *a2;
    v13->msgh_remote_port = 0;
    v13->mach_port_t msgh_local_port = rcv_name;
    v13->msgh_bits = 0;
    v13->mach_msg_size_t msgh_size = v12;
    v13->msgh_id = 0;
    if (timeout == -1) {
      mach_msg_option_t v14 = 117442566;
    }
    else {
      mach_msg_option_t v14 = 117442822;
    }
    BOOL v15 = (char *)mach_msg(v13, v14, 0, v13->msgh_size, rcv_name, timeout, 0);
    voucher_mach_msg_revert(*a5);
    voucher_mach_msg_state_t v16 = voucher_mach_msg_adopt(v13);
    *a5 = v16;
    if (a6)
    {
      if (v16 == (voucher_mach_msg_state_t)-1) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = voucher_copy();
      }
      *a6 = (id)v17;
    }
    if (v15 != 268451844) {
      break;
    }
    mach_msg_size_t msgh_size = v13->msgh_size;
    if (v11)
    {
      uint64_t v19 = *a2;
    }
    else
    {
      uint64_t v19 = 0;
      *a2 = 0;
    }
    unsigned int v12 = (msgh_size + 71) & 0xFFFFFFFC;
    *a2 = (mach_msg_header_t *)__CFSafelyReallocateTyped(v19, (msgh_size + 68 + 3) & 0x1FFFFFFFCLL, 1908778544, 0);
    char v11 = 1;
    if (a6)
    {
      if (*a6) {
    }
      }
  }
  if (v15 == 268451843)
  {
    if (v11) {
      free(v13);
    }
    mach_port_t msgh_local_port = 0;
    uint64_t result = 0;
    *a2 = 0;
  }
  else
  {
    if (v15) {
      __CFRunLoopServiceMachPort_cold_1(v15);
    }
    mach_port_t msgh_local_port = v13->msgh_local_port;
    uint64_t result = 1;
  }
  *a3 = msgh_local_port;
  return result;
}

uint64_t __CFRunLoopModeIsEmpty(uint64_t a1, uint64_t a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (pthread_main_np() == 1
    && !_CFGetTSD(4u)
    && CFRunLoopGetMain() == (CFRunLoopRef)a1
    && CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
  {
    return 0;
  }
  CFSetRef v4 = *(const __CFSet **)(a2 + 96);
  if (v4)
  {
    if (CFSetGetCount(v4) > 0) {
      return 0;
    }
  }
  CFSetRef v5 = *(const __CFSet **)(a2 + 104);
  if (v5)
  {
    if (CFSetGetCount(v5) > 0) {
      return 0;
    }
  }
  CFArrayRef v6 = *(const __CFArray **)(a2 + 120);
  if (v6)
  {
    if (CFArrayGetCount(v6) > 0) {
      return 0;
    }
  }
  int v8 = *(void **)(a1 + 640);
  while (v8)
  {
    uint64_t v9 = v8;
    int v8 = (void *)*v8;
    CFTypeID v10 = CFGetTypeID((CFTypeRef)v9[1]);
    char v11 = (const void *)v9[1];
    unsigned int v12 = *(const void **)(a2 + 80);
    if (v10 == 7)
    {
      if (CFEqual(v11, v12)) {
        return 0;
      }
      if (CFEqual((CFTypeRef)v9[1], @"kCFRunLoopCommonModes")) {
        goto LABEL_23;
      }
    }
    else
    {
      if (CFSetContainsValue((CFSetRef)v11, v12)) {
        return 0;
      }
      if (CFSetContainsValue((CFSetRef)v9[1], @"kCFRunLoopCommonModes"))
      {
LABEL_23:
        if (CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80))) {
          return 0;
        }
      }
    }
  }
  return 1;
}

uint64_t __CFRunLoopDoSources0(uint64_t a1, uint64_t a2, int a3)
{
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  kdebug_trace();
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  cf[0] = 0;
  CFSetRef v6 = *(const __CFSet **)(a2 + 96);
  if (v6
    && CFSetGetCount(v6) >= 1
    && (CFSetApplyFunction(*(CFSetRef *)(a2 + 96), (CFSetApplierFunction)__CFRunLoopCollectSources0, cf), cf[0]))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    if (CFGetTypeID(cf[0]) == 46)
    {
      uint64_t v7 = __CFRunLoopDoSource0(a1, (uint64_t)cf[0]);
    }
    else
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)cf[0]);
      v14.CFIndex location = 0;
      v14.uint64_t length = Count;
      CFArraySortValues((CFMutableArrayRef)cf[0], v14, (CFComparatorFunction)__CFRunLoopSourceComparator, 0);
      if (Count < 1)
      {
        uint64_t v7 = 0;
      }
      else
      {
        CFIndex v9 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf[0], v9);
          uint64_t v11 = __CFRunLoopDoSource0(a1, (uint64_t)ValueAtIndex);
          uint64_t v7 = v11;
          if (a3)
          {
            if (v11) {
              break;
            }
          }
          if (Count == ++v9) {
            goto LABEL_19;
          }
        }
        uint64_t v7 = 1;
      }
    }
LABEL_19:
    CFRelease(cf[0]);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  }
  else
  {
    uint64_t v7 = 0;
  }
  kdebug_trace();
  return v7;
}

uint64_t __cftrace_runloop_trace_iteration_start(uint64_t a1, __CFRunLoop *a2)
{
  v15[1] = *(void *)off_1ECE0A5B0;
  uint64_t result = kdebug_is_enabled();
  if (result)
  {
    CFStringRef v4 = CFRunLoopCopyCurrentMode(a2);
    if (CFEqual(v4, @"kCFRunLoopDefaultMode"))
    {
      BOOL v5 = 0;
    }
    else if (CFEqual(v4, @"kCFRunLoopCommonModes"))
    {
      BOOL v5 = 0;
    }
    else if (CFEqual(v4, @"NSModalPanelRunLoopMode"))
    {
      BOOL v5 = 0;
    }
    else if (CFEqual(v4, @"NSEventTrackingRunLoopMode"))
    {
      BOOL v5 = 0;
    }
    else if (CFEqual(v4, @"UITrackingRunLoopMode"))
    {
      BOOL v5 = 0;
    }
    else if (CFEqual(v4, @"com.apple.run-loop-mode.view-bridge.blocks"))
    {
      BOOL v5 = 0;
    }
    else
    {
      if (CFStringGetCStringPtr(v4, 0x8000100u))
      {
        unint64_t v6 = kdebug_trace_string();
        BOOL v5 = 1;
      }
      else
      {
        CFIndex Length = CFStringGetLength(v4);
        if (Length < 177)
        {
          CFIndex v8 = Length;
        }
        else
        {
          CFIndex v8 = 176;
          v16.CFIndex location = 0;
          v16.uint64_t length = 176;
          CFStringRef v9 = CFStringCreateWithSubstring(0, v4, v16);
          CFRelease(v4);
          CFStringRef v4 = v9;
        }
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u);
        MEMORY[0x1F4188790](MaximumSizeForEncoding, v11);
        int CString = CFStringGetCString(v4, (char *)v15 - v12, v13, 0x8000100u);
        BOOL v5 = CString != 0;
        if (CString) {
          unint64_t v6 = kdebug_trace_string();
        }
        else {
          unint64_t v6 = -1;
        }
      }
      if (v6 >= 0xFFFFFFFFFFFFFFF9)
      {
        kdebug_trace_string();
        BOOL v5 = 0;
      }
    }
    CFRelease(v4);
    _CFRunLoopCurrentIsMain();
    uint64_t result = kdebug_trace();
    if (v5) {
      return kdebug_trace_string();
    }
  }
  return result;
}

BOOL _CFRunLoopCurrentIsMain()
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_t v0 = (pthread_t)pthread_main_thread_np();
  return v0 == pthread_self();
}

CFRunLoopMode CFRunLoopCopyCurrentMode(CFRunLoopRef rl)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v3 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  uint64_t v4 = *((void *)rl + 78);
  if (v4) {
    CFStringRef v5 = (const __CFString *)CFRetain(*(CFTypeRef *)(v4 + 80));
  }
  else {
    CFStringRef v5 = 0;
  }
  pthread_mutex_unlock(v3);
  return v5;
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  void v6[6] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet __applyValues:applier context:context];
  }
  else
  {
    v6[0] = off_1ECE0A5A0;
    v6[1] = 3221225472;
    void v6[2] = __CFSetApplyFunction_block_invoke;
    v6[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
    v6[4] = applier;
    void v6[5] = context;
    CFBasicHashApply((uint64_t)theSet, (uint64_t)v6);
  }
}

void sub_182C07498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C076F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 120), 8);
  _Unwind_Resume(a1);
}

BOOL _CFPrefsArmPendingKVOSlot()
{
  uint64_t v0 = _CFGetTSD(0x10u);
  if (!v0) {
    _CFSetTSD(0x10u, 16, (uint64_t)dummyKVODestructor);
  }
  return v0 == 0;
}

uint64_t _CFSetTSD(unsigned int a1, uint64_t a2, uint64_t a3)
{
  if (a1 >= 0x46) {
    _CFSetTSD_cold_1(a1);
  }
  unint64_t v6 = (char *)__CFTSDGetTable(1);
  if (v6)
  {
    uint64_t v7 = &v6[8 * a1];
    uint64_t result = *((void *)v7 + 1);
    *((void *)v7 + 1) = a2;
    *((void *)v7 + 71) = a3;
  }
  else
  {
    _CFLogSimple(4, "Warning: TSD slot %d set but the thread data has already been torn down.", a1);
    return 0;
  }
  return result;
}

void sub_182C08020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    -[__CFArray getObjects:range:](theArray, "getObjects:range:", values, location, length);
  }
  else
  {
    if (length < 1) {
      return;
    }
    char v7 = atomic_load((unint64_t *)theArray + 1);
    int v8 = v7 & 3;
    if (v8 == 2)
    {
      uint64_t v12 = (char *)(*((void *)theArray + 5) + 8 * **((void **)theArray + 5) + 16);
    }
    else
    {
      if (v8) {
        return;
      }
      char v9 = atomic_load((unint64_t *)theArray + 1);
      BOOL v10 = (~v9 & 0xC) == 0;
      uint64_t v11 = 48;
      if (v10) {
        uint64_t v11 = 88;
      }
      uint64_t v12 = (char *)theArray + v11;
    }
    memmove(values, &v12[8 * location], 8 * length);
  }
}

uint64_t generationCountFromListOfSources(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  v22[1] = *(void *)off_1ECE0A5B0;
  if (a2 >= 1)
  {
    uint64_t v4 = a2;
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *a1;
      if (*(unsigned char *)(*a1 + 56))
      {
        CFArrayRef v8 = *(const __CFArray **)(v7 + 80);
        if (v8)
        {
          CFIndex Count = CFArrayGetCount(v8);
          if (Count >= 1)
          {
            CFIndex v11 = Count;
            MEMORY[0x1F4188790](Count, v10);
            CFIndex v13 = (const void **)((char *)v22 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
            v23.CFIndex location = 0;
            v23.CFIndex length = v11;
            CFArrayGetValues(*(CFArrayRef *)(v7 + 80), v23, v13);
            v6 += generationCountFromListOfSources(v13, v11, a3);
          }
        }
        goto LABEL_13;
      }
      uint64_t v14 = (unsigned int *)atomic_load((unint64_t *)(v7 + 40));
      if (!v14) {
        break;
      }
      unsigned int v15 = atomic_load(v14);
      unsigned int v16 = atomic_load((unsigned int *)&sentinelGeneration);
      if (v15 == v16)
      {
        unint64_t v17 = atomic_load((unint64_t *)(v7 + 32));
        v6 += v17;
      }
      else
      {
        unsigned int v19 = atomic_load((unsigned int *)(v7 + 48));
        unint64_t v20 = atomic_load((unint64_t *)(v7 + 32));
        v6 += v20;
        if (v15 != v19) {
          goto LABEL_12;
        }
      }
LABEL_13:
      ++a1;
      if (!--v4) {
        return v6;
      }
    }
    unint64_t v18 = atomic_load((unint64_t *)(v7 + 32));
    v6 += v18;
LABEL_12:
    *a3 = 1;
    goto LABEL_13;
  }
  return 0;
}

void _CFPrefsExtractQuadrupleFromPathIfPossible(const __CFString *a1, CFStringRef *a2, CFStringRef *a3, CFTypeRef *a4, unsigned char *a5, unsigned char *a6, unsigned char *a7)
{
  uint64_t v72 = *(void *)off_1ECE0A5B0;
  *a7 = 0;
  if (!a1) {
    return;
  }
  CFStringRef v13 = a1;
  if (CFStringGetCharacterAtIndex(a1, 0) != 47 && CFStringFind(v13, @"..", 0).location == -1) {
    return;
  }
  if (CFStringHasSuffix(v13, @".plist")) {
    CFRetain(v13);
  }
  else {
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@.plist", v13);
  }
  uint64_t v65 = a2;
  id v66 = a4;
  CFErrorRef v63 = a7;
  mach_port_t v64 = a6;
  if (CFStringFind(v13, @"/containers/Shared/SystemGroup/", 0).location == -1
    || (CFRange v14 = CFStringFind(v13, @"/Library/Preferences/", 4uLL), v14.location == -1))
  {
    CFStringRef v17 = 0;
    CFStringRef v16 = 0;
    CFStringRef v15 = 0;
  }
  else
  {
    v73.CFIndex length = CFStringGetLength(v13) - (v14.location + v14.length);
    v73.CFIndex location = v14.location + v14.length;
    CFStringRef v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v73);
    v74.CFIndex length = v14.location + 1;
    v74.CFIndex location = 0;
    CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v74);
    CFStringRef v17 = @"kCFPreferencesAnyUser";
  }
  CFIndex location = CFStringFind(v13, @"/Containers/Shared/AppGroup/", 0).location;
  if (location >= 1)
  {
    CFIndex v19 = location;
    CFRange v20 = CFStringFind(v13, @"/Library/Preferences/", 4uLL);
    if (v20.location != -1)
    {
      CFIndex v21 = CFStringGetLength(v13) - (v20.location + v20.length);
      if (v15) {
        CFRelease(v15);
      }
      v75.CFIndex location = v20.location + v20.length;
      v75.CFIndex length = v21;
      CFStringRef v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v75);
      if (v16) {
        CFRelease(v16);
      }
      v76.CFIndex length = v20.location + 1;
      v76.CFIndex location = 0;
      CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v76);
      result.CFIndex length = 0;
      result.CFIndex location = 0;
      v77.CFIndex location = 0;
      v77.CFIndex length = v19;
      if (!CFStringFindWithOptions(v13, @"/", v77, 4uLL, &result)) {
        _CFPrefsExtractQuadrupleFromPathIfPossible_cold_1();
      }
      v78.CFIndex location = result.location + 1;
      v78.CFIndex length = v19 - (result.location + 1);
      CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v78);
    }
  }
  if (v15)
  {
    CFRelease(v13);
    int v22 = 0;
    goto LABEL_43;
  }
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v13);
  CFRelease(v13);
  CFRange v24 = CFStringFind(MutableCopy, @"/private/var/preferences/", 8uLL);
  if (v24.location == -1)
  {
    CFRange v28 = CFStringFind(MutableCopy, @"/private/var/", 8uLL);
    if (v28.location == -1) {
      goto LABEL_26;
    }
    CFIndex v25 = v28.location;
    v26.CFIndex length = v28.length;
    CFStringRef v27 = @"/var/";
  }
  else
  {
    CFIndex v25 = v24.location;
    v26.CFIndex length = v24.length;
    CFStringRef v27 = @"/Library/Preferences/";
  }
  v26.CFIndex location = v25;
  CFStringReplace(MutableCopy, v26, v27);
LABEL_26:
  CFRange v31 = CFStringFind(MutableCopy, @"/Containers/Data/Application/", 0);
  CFIndex length = v31.length;
  CFIndex v29 = v31.location;
  if (v31.location == -1)
  {
    CFRange v32 = CFStringFind(MutableCopy, @"/Applications/", 0);
    CFIndex length = v32.length;
    CFIndex v29 = v32.location;
    result.CFIndex length = 0;
    result.CFIndex location = 0;
    if (v32.location == -1) {
      goto LABEL_33;
    }
  }
  else
  {
    result.CFIndex length = 0;
    result.CFIndex location = 0;
  }
  uint64_t v33 = v29 + length + 1;
  v79.CFIndex length = CFStringGetLength(MutableCopy) - v33;
  v79.CFIndex location = v33;
  if (CFStringFindWithOptions(MutableCopy, @"/", v79, 0, &result))
  {
    if (v16) {
      CFRelease(v16);
    }
    v80.CFIndex length = result.location;
    v80.CFIndex location = 0;
    CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v80);
    CFIndex v34 = result.location;
    CFIndex v35 = CFStringGetLength(MutableCopy);
    v81.CFIndex length = v35 - result.location;
    v81.CFIndex location = v34;
    CFStringRef v36 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v81);
    CFRelease(MutableCopy);
    MutableCFStringRef Copy = (CFMutableStringRef)v36;
  }
LABEL_33:
  CFRange v38 = CFStringFind(MutableCopy, @"/var/Managed Preferences/", 8uLL);
  CFIndex v37 = v38.length;
  if (v38.location != -1
    || (CFRange v39 = CFStringFind(MutableCopy, @"/Library/Managed Preferences/", 8uLL),
        CFIndex v37 = v39.length,
        v39.location != -1))
  {
    CFIndex v40 = v37;
    *mach_port_t v64 = 1;
    v82.CFIndex length = CFStringGetLength(MutableCopy) - v37;
    v82.CFIndex location = v40;
    CFStringRef v41 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v82);
    CFRelease(MutableCopy);
    CFIndex v42 = CFStringFind(v41, @"/", 0).location;
    if (v42 == -1)
    {
      CFStringRef v15 = (const __CFString *)CFRetain(v41);
      if (v17) {
        CFRelease(v17);
      }
      int v22 = 0;
      CFStringRef v17 = @"kCFPreferencesAnyUser";
    }
    else
    {
      CFIndex v43 = v42;
      if (v17) {
        CFRelease(v17);
      }
      v83.CFIndex location = 0;
      v83.CFIndex length = v43;
      CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, v83);
      CFIndex v44 = v43 + 1;
      v84.CFIndex length = CFStringGetLength(v41) - v44;
      v84.CFIndex location = v44;
      CFStringRef v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, v84);
      int v22 = 1;
    }
LABEL_42:
    CFRelease(v41);
    if (v15)
    {
LABEL_43:
      if (CFStringHasSuffix(v15, @".plist"))
      {
        v85.CFIndex length = CFStringGetLength(v15) - 6;
        v85.CFIndex location = 0;
        CFStringRef v45 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v85);
        CFRelease(v15);
        CFStringRef v15 = v45;
      }
      *uint64_t v65 = v15;
      CFDictionaryRef v46 = @"kCFPreferencesNoContainer";
      if (v16) {
        CFDictionaryRef v46 = (__CFString *)v16;
      }
      *id v66 = v46;
      bzero(&result, 0x400uLL);
      long long v70 = 0u;
      long long v69 = 0u;
      if (!_CFPrefsGetImpersonatedApplicationAuditToken(&v69))
      {
        if (_CFAuditTokenForSelf_onceToken != -1) {
          dispatch_once(&_CFAuditTokenForSelf_onceToken, &__block_literal_global_21);
        }
        long long v69 = _CFAuditTokenForSelf_auditToken;
        long long v70 = unk_1EB1DD678;
      }
      *(_OWORD *)buffer = v69;
      long long v68 = v70;
      int v47 = sandbox_container_path_for_audit_token();
      int v48 = CFEqual(*v66, @"kCFPreferencesNoContainer");
      if (v47)
      {
        if (v48)
        {
          *id v66 = 0;
          goto LABEL_64;
        }
      }
      else if (v48)
      {
        bzero(buffer, 0x400uLL);
        if (CFStringGetCString(*v65, buffer, 1024, 0x8000100u)
          && (!sandbox_check_by_audit_token() || !sandbox_check_by_audit_token()))
        {
          *id v66 = 0;
        }
      }
      else
      {
        CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
        CFStringRef v50 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)&result, SystemEncoding, (CFAllocatorRef)&__kCFAllocatorNull);
        if (CFEqual(*v66, v50))
        {
          CFRelease(*v66);
          *id v66 = 0;
        }
        CFRelease(v50);
      }
      if (*v66)
      {
        CFStringRef v51 = _CFPrefsCopyUserForContainer(v17, (CFStringRef)*v66);
        CFRelease(v17);
        CFStringRef v17 = v51;
      }
LABEL_64:
      if (CFEqual(v17, @"wireless"))
      {
        CFRelease(v17);
        CFStringRef v17 = @"_wireless";
      }
      if (!eduModeEnabled()) {
        goto LABEL_82;
      }
      int v52 = _CFPrefsCopyUsernameForMobileUser();
      if (CFEqual(v17, v52))
      {
        CFRelease(v17);
        if (CFEqual(@"mobile", @"kCFPreferencesCurrentUser"))
        {
          CFStringRef v17 = @"kCFPreferencesCurrentUser";
LABEL_81:
          CFRelease(v52);
LABEL_82:
          *a3 = v17;
          if (CFEqual(v17, @"kCFPreferencesAnyUser")) {
            *a5 = 1;
          }
          return;
        }
        CFStringRef v17 = @"kCFPreferencesAnyUser";
        if (CFEqual(@"mobile", @"kCFPreferencesAnyUser")) {
          goto LABEL_81;
        }
        CFStringRef v54 = CFCopyUserName();
        int v55 = CFEqual(@"mobile", v54);
        CFRelease(v54);
        if (@"kCFPreferencesCurrentUser")
        {
          CFStringRef v17 = @"kCFPreferencesCurrentUser";
          if (v55) {
            goto LABEL_81;
          }
        }
        CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"mobile");
      }
      else
      {
        if (!v22) {
          goto LABEL_81;
        }
        if (_CFPrefsExtractQuadrupleFromPathIfPossible_onceToken != -1) {
          dispatch_once(&_CFPrefsExtractQuadrupleFromPathIfPossible_onceToken, &__block_literal_global_63);
        }
        if (!_CFPrefsExtractQuadrupleFromPathIfPossible_mobileHome
          || CFStringFind((CFStringRef)_CFPrefsExtractQuadrupleFromPathIfPossible_mobileHome, v17, 0).location == -1)
        {
          goto LABEL_81;
        }
        CFRelease(v17);
        CFStringRef Copy = _CFPrefsCopyUserConstantForUserName(@"mobile");
      }
      CFStringRef v17 = Copy;
      goto LABEL_81;
    }
    goto LABEL_108;
  }
  int v62 = a3;
  *mach_port_t v64 = 0;
  uint64_t v56 = (const char *)_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser();
  CFStringRef v57 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v56);
  CFRange v58 = CFStringFind(MutableCopy, @"/Library/Preferences/", 0);
  if (v58.location == -1)
  {
    int v22 = 0;
  }
  else if (v58.location)
  {
    if (CFStringHasPrefix(MutableCopy, @"/var/db/"))
    {
      if (v17) {
        CFRelease(v17);
      }
      v61.CFIndex length = v58.location - 8;
      CFStringRef v60 = MutableCopy;
      v61.CFIndex location = 8;
    }
    else
    {
      if (!CFStringHasPrefix(MutableCopy, @"/var/"))
      {
        if (!v57)
        {
          int v22 = 0;
          goto LABEL_104;
        }
        if (CFStringHasPrefix(MutableCopy, v57))
        {
          if (v17) {
            CFRelease(v17);
          }
          int v22 = 0;
          CFStringRef v17 = @"kCFPreferencesCurrentUser";
        }
        else
        {
          int v22 = 0;
        }
        goto LABEL_103;
      }
      if (v17) {
        CFRelease(v17);
      }
      v61.CFIndex length = v58.location - 5;
      CFStringRef v60 = MutableCopy;
      v61.CFIndex location = 5;
    }
    CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v60, v61);
    int v22 = 1;
  }
  else
  {
    if (v17) {
      CFRelease(v17);
    }
    int v22 = 0;
    BOOL v59 = &kCFPreferencesCurrentUser;
    if (!v16) {
      BOOL v59 = &kCFPreferencesAnyUser;
    }
    CFStringRef v17 = *v59;
  }
  if (v57) {
LABEL_103:
  }
    CFRelease(v57);
LABEL_104:
  if (v58.location != -1 && v17)
  {
    v86.CFIndex length = CFStringGetLength(MutableCopy) - (v58.location + v58.length);
    v86.CFIndex location = v58.location + v58.length;
    CFStringRef v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v86);
    CFStringRef v41 = MutableCopy;
    a3 = v62;
    goto LABEL_42;
  }
  CFRelease(MutableCopy);
LABEL_108:
  *CFErrorRef v63 = 1;
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
}

void sub_182C096A0(_Unwind_Exception *a1)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CFRunLoopGetMain_onceToken != -1) {
    dispatch_once(&CFRunLoopGetMain_onceToken, &__block_literal_global_14);
  }
  return (CFRunLoopRef)__CFRunLoopMain;
}

uint64_t __CFRunLoopDoSource1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  uint64_t v13 = v2;
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRetain((CFTypeRef)v10);
  CFRange v14 = (pthread_mutex_t *)(v12 + 16);
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 16));
  CFStringRef v15 = (pthread_mutex_t *)(v13 + 16);
  pthread_mutex_unlock((pthread_mutex_t *)(v13 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 16));
  char v16 = atomic_load((unint64_t *)(v10 + 8));
  if ((v16 & 8) != 0)
  {
    atomic_store(0, (unint64_t *)(v10 + 88));
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
    uint64_t v18 = v8;
    uint64_t v19 = v6;
    CFRange v20 = *(uint64_t (**)(uint64_t, uint64_t, __objc2_class **, uint64_t))(v10 + 168);
    uint64_t v21 = *(void *)(v10 + 112);
    if (v13 && !*(unsigned char *)(v13 + 681)) {
      int v22 = 0;
    }
    else {
      int v22 = (void *)_CFAutoreleasePoolPush();
    }
    kdebug_trace();
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(v20, v18, v19, v4, v21);
    kdebug_trace();
    __CFRunLoopPerCalloutARPEnd(v22);
    if ((__CF_FORK_STATE & 2) == 0) {
      __CF_USED();
    }
    CFStringRef v15 = (pthread_mutex_t *)(v13 + 16);
    CFRange v14 = (pthread_mutex_t *)(v12 + 16);
    if (__CF_FORK_STATE) {
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
    uint64_t v17 = 1;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
    uint64_t v17 = 0;
  }
  CFRelease((CFTypeRef)v10);
  pthread_mutex_lock(v15);
  pthread_mutex_lock(v14);
  return v17;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(uint64_t (*result)(uint64_t, uint64_t, __objc2_class **, uint64_t), uint64_t a2, uint64_t a3, uint64_t (**a4)(uint64_t, uint64_t, __objc2_class **, uint64_t), uint64_t a5))(uint64_t, uint64_t, __objc2_class **, uint64_t)
{
  if (result)
  {
    CFRange result = (uint64_t (*)(uint64_t, uint64_t, __objc2_class **, uint64_t))result(a2, a3, &__kCFAllocatorSystemDefault, a5);
    *a4 = result;
  }
  return result;
}

uint64_t __CFMachPortPerform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a4 + 96));
    if (*(_DWORD *)(a4 + 16))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a4 + 96));
    }
    else
    {
      uint64_t v7 = *(uint64_t (**)(void))(a4 + 104);
      uint64_t v8 = *(void *)(a4 + 64);
      if (v7)
      {
        uint64_t v8 = v7(*(void *)(a4 + 64));
        uint64_t v9 = *(void (**)(uint64_t))(a4 + 112);
      }
      else
      {
        uint64_t v9 = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a4 + 96));
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 48))(a4, a1, a2, v8);
      if (v9) {
        v9(v8);
      }
      if ((__CF_FORK_STATE & 2) == 0) {
        __CF_USED();
      }
      if (__CF_FORK_STATE) {
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
      }
    }
  }
  return 0;
}

uint64_t __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
{
  return _dispatch_main_queue_callback_4CF();
}

uint64_t __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

double __CFTSRToTimeInterval(unint64_t a1)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
  }
  return *(double *)&__CF1_TSRRate * (double)a1;
}

BOOL _CFPrefsGetImpersonatedApplicationAuditToken(_OWORD *a1)
{
  uint64_t v1 = _CFPrefsAuditTokenToImpersonate | *((void *)&_CFPrefsAuditTokenToImpersonate + 1) | qword_1EC094024 | unk_1EC09402C;
  if (a1 && v1)
  {
    long long v2 = *(_OWORD *)&qword_1EC094024;
    *a1 = _CFPrefsAuditTokenToImpersonate;
    a1[1] = v2;
  }
  return v1 != 0;
}

uint64_t _CFGetCachedUnsandboxedHomeDirectoryForCurrentUser()
{
  if (_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_onceToken != -1) {
    dispatch_once(&_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_onceToken, &__block_literal_global_179);
  }
  return _CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_unsandboxedHomePath;
}

void sub_182C0A4FC(_Unwind_Exception *a1)
{
}

void _CFPrefsDeliverPendingKVONotificationsGuts(const __CFArray *a1)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v4 = Count;
    for (CFIndex i = 0; i != v4; ++i)
    {
      CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      uint64_t v8 = ValueAtIndex;
      if (ValueAtIndex) {
        id Property = objc_getProperty(ValueAtIndex, v7, 8, 1);
      }
      else {
        id Property = 0;
      }
      CFStringRef Value = (void *)CFDictionaryGetValue(Mutable, Property);
      if (!Value)
      {
        CFStringRef Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        if (v8) {
          id v12 = objc_getProperty(v8, v11, 8, 1);
        }
        else {
          id v12 = 0;
        }
        CFDictionarySetValue(Mutable, v12, Value);
        CFRelease(Value);
      }
      CFArrayAppendValue((CFMutableArrayRef)Value, v8);
    }
  }
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)applyBlockApplier, &__block_literal_global_232);
  CFRelease(Mutable);
}

void sub_182C0A6D0(_Unwind_Exception *a1)
{
}

void sub_182C0A6F0(void *a1)
{
}

char *__CFMessagePortPerform(int *a1, unint64_t a2, const __CFAllocator *a3, uint64_t a4)
{
  address[1] = *(void *)off_1ECE0A5B0;
  address[0] = 0;
  uint64_t v8 = (os_unfair_lock_s *)(a4 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a4 + 112));
  char v9 = atomic_load((unint64_t *)(a4 + 8));
  if ((v9 & 1) == 0)
  {
    os_unfair_lock_unlock(v8);
    return 0;
  }
  uint64_t v11 = *(void *)(a4 + 128);
  uint64_t v10 = *(uint64_t (**)(void))(a4 + 136);
  if (v10)
  {
    uint64_t v11 = v10(*(void *)(a4 + 128));
    id v12 = *(void (**)(uint64_t))(a4 + 144);
  }
  else
  {
    id v12 = 0;
  }
  os_unfair_lock_unlock(v8);
  if (a2 < 0x18) {
    goto LABEL_7;
  }
  int v28 = *a1;
  if (*a1 < 0)
  {
    if (a2 >= 0x3C)
    {
      LODWORD(v31) = a1[1];
      if (v31 >= 0x3C)
      {
        int v32 = a1[11];
        BOOL v19 = v32 != -252513032 && v32 != -118164752;
        BOOL v34 = a1[6] != 1;
        goto LABEL_78;
      }
    }
    goto LABEL_7;
  }
  if (a1[5] == 1128680784)
  {
    if (a2 >= 0x38)
    {
      unint64_t v29 = 56;
      goto LABEL_38;
    }
LABEL_7:
    LOWORD(v19) = 0;
LABEL_100:
    CFLog(4, @"*** CFMessagePort: dropping corrupt request Mach message (0b%d%d%d%d%d%d)", v13, v14, v15, v16, v17, v18, v19);
    mach_msg_destroy((mach_msg_header_t *)a1);
    return 0;
  }
  if (a2 < 0x3C) {
    goto LABEL_7;
  }
  unint64_t v29 = 60;
LABEL_38:
  unint64_t v31 = a1[1];
  if (v29 > v31) {
    goto LABEL_7;
  }
  if (a1[5] != 1128680784)
  {
    if (a1[11] == -252513032)
    {
      BOOL v19 = 0;
      goto LABEL_76;
    }
    uint64_t v52 = 11;
LABEL_75:
    BOOL v19 = a1[v52] != -118164752;
LABEL_76:
    BOOL v34 = 0;
    if (a1[5] == 1128680784) {
      goto LABEL_77;
    }
LABEL_78:
    unsigned int v53 = 4060;
    goto LABEL_79;
  }
  if (a1[10] != -252513032)
  {
    uint64_t v52 = 10;
    goto LABEL_75;
  }
  BOOL v34 = 0;
  BOOL v19 = 0;
LABEL_77:
  unsigned int v53 = 4056;
LABEL_79:
  BOOL v54 = v53 < v31;
  if (!v34 && v53 >= v31)
  {
    if (v28 < 0)
    {
      int v55 = a1[14];
      BOOL v58 = (v55 - 1610612737) < 0x9FFFFFFE || a1[10] != v55;
      BOOL v57 = v58;
      goto LABEL_98;
    }
    if (a1[5] == 1128680784)
    {
      int v55 = a1[13];
      if ((v55 - 1610612737) >= 0x9FFFFFFE)
      {
        int v56 = -56;
LABEL_94:
        BOOL v59 = v56 + (int)v31 < v55;
        goto LABEL_95;
      }
    }
    else
    {
      int v55 = a1[14];
      if ((v55 - 1610612737) >= 0x9FFFFFFE)
      {
        int v56 = -60;
        goto LABEL_94;
      }
    }
    BOOL v59 = 1;
LABEL_95:
    BOOL v57 = v59;
    goto LABEL_96;
  }
  BOOL v57 = 0;
  int v55 = 0;
  if (v28 < 0) {
    goto LABEL_98;
  }
LABEL_96:
  if (a1[5] != 1128680784)
  {
LABEL_98:
    uint64_t v60 = 11;
    goto LABEL_99;
  }
  uint64_t v60 = 10;
LABEL_99:
  BOOL v61 = a1[v60 + 2] < 1;
  if (v34 || v19 || v54 || v57 || v61) {
    goto LABEL_100;
  }
  if (*a1 < 0)
  {
    uint64_t v26 = a1[12];
    unint64_t v30 = *(const UInt8 **)(a1 + 7);
    CFIndex v20 = a1[10];
  }
  else
  {
    CFIndex v20 = v55 & ~(v55 >> 31);
    unint64_t v21 = (unint64_t)a1 + a1[1];
    int v22 = a1[5];
    BOOL v23 = v22 == 1128680784;
    if (v22 == 1128680784) {
      uint64_t v24 = 40;
    }
    else {
      uint64_t v24 = 44;
    }
    unint64_t v25 = (unint64_t)a1 + v20 + v24 + 16;
    if (v23)
    {
      uint64_t v26 = a1[11];
      if (v25 > v21)
      {
LABEL_35:
        CFDataRef v35 = 0;
        goto LABEL_45;
      }
      uint64_t v27 = 10;
    }
    else
    {
      uint64_t v26 = a1[12];
      if (v25 > v21) {
        goto LABEL_35;
      }
      uint64_t v27 = 11;
    }
    unint64_t v30 = (const UInt8 *)&a1[v27 + 4];
  }
  CFDataRef v35 = CFDataCreateWithBytesNoCopy(a3, v30, v20, (CFAllocatorRef)&__kCFAllocatorNull);
LABEL_45:
  CFStringRef v36 = *(uint64_t (**)(uint64_t, uint64_t, CFDataRef, uint64_t))(a4 + 96);
  if (v36) {
    CFDataRef v37 = (const __CFData *)v36(a4, v26, v35, v11);
  }
  else {
    CFDataRef v37 = (const __CFData *)(*(uint64_t (**)(uint64_t, uint64_t, CFDataRef, uint64_t, unint64_t, void))(a4 + 104))(a4, v26, v35, v11, ((unint64_t)a1 + a1[1] + 3) & 0xFFFFFFFFFFFFFFFCLL, 0);
  }
  CFDataRef v38 = v37;
  if (!v37)
  {
    LODWORD(v46) = -1;
    goto LABEL_56;
  }
  int64_t Length = CFDataGetLength(v37);
  if (Length >= 1610612737)
  {
    CFLog(4, @"*** CFMessagePort reply: CFMessagePort cannot send more than %lu bytes of data", v40, v41, v42, v43, v44, v45, 0);
    CFRelease(v38);
    CFDataRef v38 = 0;
LABEL_55:
    LODWORD(v46) = 0;
    goto LABEL_56;
  }
  size_t v46 = Length;
  if (Length <= 3999)
  {
    address[0] = (vm_address_t)CFDataGetBytePtr(v38);
    goto LABEL_56;
  }
  address[0] = 0;
  if (vm_allocate(*(_DWORD *)off_1ECE0A6C8, address, Length, 335544321)) {
    goto LABEL_55;
  }
  CFStringRef v50 = (void *)address[0];
  BytePtr = CFDataGetBytePtr(v38);
  memmove(v50, BytePtr, v46);
LABEL_56:
  if (*a1 < 0 || a1[5] != 1128680784) {
    uint64_t v47 = 11;
  }
  else {
    uint64_t v47 = 10;
  }
  Message = __CFMessagePortCreateMessage(1, a1[2], 0, -a1[v47 + 2], v26, (const void *)address[0], v46);
  unint64_t v49 = Message;
  if ((*(_DWORD *)Message & 0x80000000) != 0) {
    Message[36] = 1;
  }
  if (v35) {
    CFRelease(v35);
  }
  if (*a1 < 0) {
    mach_vm_deallocate(*(_DWORD *)off_1ECE0A6C8, *(void *)(a1 + 7), a1[10]);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (v12) {
    v12(v11);
  }
  return v49;
}

void sub_182C0B088(_Unwind_Exception *a1)
{
}

CFTypeRef _CFLocaleCopyPreferredTemperatureUnit()
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  CFPropertyListRef v0 = CFPreferencesCopyValue(@"AppleTemperatureUnit", @"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
  char v4 = 0;
  if (!_CFLocaleGetTemperatureUnitForPreferences((uint64_t)v0, &v4))
  {
    CFTypeRef v2 = 0;
    if (!v0) {
      return v2;
    }
LABEL_7:
    CFRelease(v0);
    return v2;
  }
  uint64_t v1 = (CFTypeRef *)&kCFLocaleTemperatureUnitCelsius;
  if (!v4) {
    uint64_t v1 = (CFTypeRef *)&kCFLocaleTemperatureUnitFahrenheit;
  }
  CFTypeRef v2 = CFRetain(*v1);
  if (v0) {
    goto LABEL_7;
  }
  return v2;
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)_CFPreferencesCopyValueWithContainer((uint64_t)key, (uint64_t)applicationID, (uint64_t)userName, (uint64_t)hostName, 0);
}

uint64_t _CFLocaleGetTemperatureUnitForPreferences(uint64_t result, char *a2)
{
  if (result)
  {
    int v3 = (const void *)result;
    if (CFEqual((CFTypeRef)result, @"Celsius"))
    {
      char v4 = 1;
    }
    else
    {
      CFRange result = CFEqual(v3, @"Fahrenheit");
      char v4 = 0;
      if (!result) {
        return result;
      }
    }
    *a2 = v4;
    return 1;
  }
  return result;
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    [(__CFReadStream *)stream open];
    return 1;
  }
  else
  {
    return _CFStreamOpen((uint64_t)stream);
  }
}

uint64_t _CFRuntimeGetClassWithTypeID(unint64_t a1)
{
  if (a1 <= 0x47)
  {
    uint64_t v1 = &__CFRuntimeBuiltinClassTable + a1;
    return (uint64_t)*v1;
  }
  int v2 = a1 - 72;
  if ((int)a1 - 72 < dword_1EB1DE0D8)
  {
    uint64_t v3 = __CFRuntimeClassTables[v2 >> 6];
    if (v3)
    {
      uint64_t v1 = (_UNKNOWN **)(v3 + 8 * (v2 & 0x3F));
      return (uint64_t)*v1;
    }
  }
  return 0;
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    [(__CFReadStream *)stream close];
  }
  else
  {
    _CFStreamClose((uint64_t)stream);
  }
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizations(unint64_t *a1, void *a2, __CFString *a3, __CFString *a4, const __CFArray *a5)
{
  return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, a5, 0, 0);
}

id _CFLocaleCreateCopyWithNewCalendarIdentifier(uint64_t a1, void *a2)
{
  int v2 = objc_msgSend(a2, "_localeWithNewCalendarIdentifier:");

  return v2;
}

UText *__CFStringClone(UText *a1, uint64_t a2, int a3, UErrorCode *status)
{
  if (*(int *)status > 0) {
    return 0;
  }
  uint64_t v8 = utext_setup(a1, 0, status);
  char v4 = v8;
  if (*(int *)status <= 0)
  {
    v8->providerProperties = *(_DWORD *)(a2 + 8);
    v8->chunkNativeStart = *(void *)(a2 + 32);
    int64_t v9 = *(void *)(a2 + 32);
    v8->chunkNativeLimit = v9;
    v8->nativeIndexingLimit = v9;
    v8->chunkOffset = 0;
    uint64_t v10 = (const UTextFuncs *)&__CFAttributedStringFuncs;
    int v11 = *(_DWORD *)(a2 + 8);
    if ((v11 & 0x10) == 0) {
      uint64_t v10 = (const UTextFuncs *)&__CFStringFuncs;
    }
    v8->pFuncs = v10;
    if (*(int *)status <= 0)
    {
      if (a3)
      {
        CFAttributedStringRef v12 = *(const __CFAttributedString **)(a2 + 72);
        if ((v11 & 0x10) != 0) {
          MutableCFStringRef Copy = CFAttributedStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v12);
        }
        else {
          MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFStringRef)v12);
        }
        v4->CFTypeRef context = MutableCopy;
        v4->providerProperties |= 0x28u;
      }
      else
      {
        v8->CFTypeRef context = *(const void **)(a2 + 72);
      }
    }
  }
  return v4;
}

uint64_t __RELEASE_OBJECTS_IN_THE_ORDEREDSET__(uint64_t a1, int a2)
{
  int v2 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  if (a2 == 1) {
    int v2 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }
  uint64_t v3 = (CFTypeRef *)(a1 + *v2);
  if (*v3) {
    CFRelease(*v3);
  }

  return MEMORY[0x1F41817F8]();
}

uint64_t __createOrderedSet(void *a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  return [a1 initWithObjects:v3 count:1];
}

void sub_182C0C338(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

__objc2_class **__NSOrderedSetImmutablePlaceholder()
{
  return &___immutablePlaceholderOrderedSet;
}

void sub_182C0C958(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

char *__NSOrderedSetI_new(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  uint64_t v6 = 2;
  uint64_t v7 = 4;
  if (a2 < 0xFFFFFFFF)
  {
    int v8 = 2;
  }
  else
  {
    uint64_t v7 = 8;
    int v8 = 8;
  }
  if (a2 >= 0xFFFF) {
    int v9 = v8;
  }
  else {
    int v9 = 1;
  }
  if (a2 >= 0xFFFF) {
    uint64_t v6 = v7;
  }
  if (a2 >= 0xFF) {
    int v10 = v9;
  }
  else {
    int v10 = 0;
  }
  if (a2 >= 0xFF) {
    uint64_t v5 = v6;
  }
  while (__NSOrderedSetCapacities[v4] < a2)
  {
    if (++v4 == 64)
    {
      __break(1u);
      break;
    }
  }
  if (a2)
  {
    unint64_t v11 = __NSOrderedSetSizes[v4];
    size_t v31 = v11 * v5;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = malloc_type_calloc(1uLL, v11 * v5 + 8 * a2, 0x3C0B7052uLL);
    uint64_t __src = &v14[a2];
    if (v11 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v11;
    }
    uint64_t v32 = v15;
    unint64_t v34 = a2;
    do
    {
      uint64_t v16 = *(void **)(a1 + 8 * v12);
      unint64_t v17 = objc_msgSend(v16, "hash", v31);
      unint64_t v18 = v11;
      if (v4)
      {
        unint64_t v18 = v11;
        if (v4 != 63)
        {
          unint64_t v18 = v17 % v11;
          uint64_t v22 = v32;
          unint64_t v23 = v17 % v11;
          while (2)
          {
            switch(v10)
            {
              case 0:
                uint64_t v24 = __src[v23];
                if (!__src[v23]) {
                  goto LABEL_51;
                }
                goto LABEL_38;
              case 1:
                uint64_t v24 = *(unsigned __int16 *)&__src[2 * v23];
                if (!*(_WORD *)&__src[2 * v23]) {
                  goto LABEL_51;
                }
                goto LABEL_38;
              case 2:
                uint64_t v24 = *(unsigned int *)&__src[4 * v23];
                if (!*(_DWORD *)&__src[4 * v23]) {
                  goto LABEL_51;
                }
                goto LABEL_38;
              case 8:
                uint64_t v24 = *(void *)&__src[8 * v23];
                if (!v24)
                {
LABEL_51:
                  unint64_t v18 = v23;
                  break;
                }
LABEL_38:
                unint64_t v25 = (void *)v14[v24 - 1];
                if (v25 == v16 || ([v25 isEqual:v16] & 1) != 0)
                {
                  unint64_t v21 = v34;
                  goto LABEL_49;
                }
                if (v23 + 1 >= v11) {
                  unint64_t v26 = v11;
                }
                else {
                  unint64_t v26 = 0;
                }
                unint64_t v23 = v23 + 1 - v26;
                if (--v22) {
                  continue;
                }
                unint64_t v18 = v11;
                break;
              default:
                goto LABEL_24;
            }
            break;
          }
        }
      }
LABEL_24:
      uint64_t v19 = *(void *)(a1 + 8 * v12);
      v14[v13] = v19;
      if ((a3 & 1) == 0 && v19 >= 1) {
        id v20 = (id)v19;
      }
      ++v13;
      unint64_t v21 = v34;
      switch(v10)
      {
        case 0:
          __src[v18] = v13;
          break;
        case 1:
          *(_WORD *)&__src[2 * v18] = v13;
          break;
        case 2:
          *(_DWORD *)&__src[4 * v18] = v13;
          break;
        case 8:
          *(void *)&__src[8 * v18] = v13;
          break;
        default:
          break;
      }
LABEL_49:
      ++v12;
    }
    while (v12 != v21);
    uint64_t v27 = (objc_class *)self;
    int v28 = (char *)__CFAllocateObject(v27, v31 + 8 * v13);
    v28[14] = BYTE6(v13);
    *((_WORD *)v28 + 6) = WORD2(v13);
    *((_DWORD *)v28 + 2) = v13;
    v28[15] = v28[15] & 3 | (4 * v4);
    v28[15] = v28[15] & 0xFC | v10 & 3;
    memmove(v28 + 16, v14, 8 * v13);
    memmove(&v28[8 * v13 + 16], __src, v31);
    free(v14);
  }
  else
  {
    unint64_t v29 = (objc_class *)self;
    int v28 = (char *)__CFAllocateObject(v29, 0);
    v28[14] = 0;
    *((_WORD *)v28 + 6) = 0;
    *((_DWORD *)v28 + 2) = 0;
    v28[15] &= 3u;
    v28[15] &= 0xFCu;
  }
  return v28;
}

__objc2_class **__NSOrderedSetMutablePlaceholder()
{
  return &___mutablePlaceholderOrderedSet;
}

void sub_182C0D5BC(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSOrderedSet(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSOrderedSet__);
}

void sub_182C0F624(_Unwind_Exception *a1)
{
  free(v2);
  free(v1);
  _Unwind_Resume(a1);
}

void _CFXNotificationCancelToken(uint64_t a1, uint64_t a2)
{
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  size_t length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    -[__CFData getBytes:range:](theData, "getBytes:range:", buffer, location, length);
  }
  else
  {
    if (location < 0)
    {
      if (dyld_program_sdk_at_least()) {
        CFDataGetBytes_cold_7();
      }
      int v8 = _CFOSLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        CFDataGetBytes_cold_8();
      }
    }
    else
    {
      CFIndex v7 = *((void *)theData + 2);
      if (location <= v7)
      {
        if ((length & 0x8000000000000000) != 0)
        {
          if (dyld_program_sdk_at_least()) {
            CFDataGetBytes_cold_5();
          }
          int v10 = _CFOSLog();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
            CFDataGetBytes_cold_6();
          }
        }
        else if ((uint64_t)(location + length) > v7)
        {
          if (dyld_program_sdk_at_least()) {
            CFDataGetBytes_cold_3();
          }
          unint64_t v11 = _CFOSLog();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
            CFDataGetBytes_cold_4();
          }
        }
      }
      else
      {
        if (dyld_program_sdk_at_least()) {
          CFDataGetBytes_cold_1();
        }
        int v9 = _CFOSLog();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
          CFDataGetBytes_cold_2();
        }
      }
    }
    char v12 = atomic_load((unint64_t *)theData + 1);
    if ((v12 & 4) != 0) {
      unint64_t v13 = ((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0;
    }
    else {
      unint64_t v13 = *((void *)theData + 5);
    }
    memmove(buffer, (const void *)(v13 + location), length);
  }
}

CFStringRef _CFErrorCreateLocalizedDescription(void *a1)
{
  char v2 = 1;
  do
  {
    char v3 = v2;
    if (v2)
    {
      uint64_t v4 = (uint64_t (*)(void *, __CFString *))_CFErrorCopyUserInfoKeyFromUserInfo;
      uint64_t v5 = _CFErrorCopyUserInfoKeyFromUserInfo(a1, @"NSLocalizedDescription");
    }
    else
    {
      uint64_t v4 = (uint64_t (*)(void *, __CFString *))_CFErrorCopyUserInfoKeyFromCallBack;
      uint64_t v5 = _CFErrorCopyUserInfoKeyFromCallBack(a1, @"NSLocalizedDescription");
    }
    if (v5) {
      return (CFStringRef)v5;
    }
    uint64_t v6 = v4(a1, @"NSLocalizedFailure");
    if (v6)
    {
      CFStringRef v11 = (CFStringRef)v6;
      unint64_t v13 = _CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
      if (v13)
      {
        uint64_t v14 = v13;
        BundleWithCFLocaleIdentifier Identifier = CFBundleGetBundleWithIdentifier(@"com.apple.CoreFoundation");
        if (!BundleWithIdentifier
          || (CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"%@ %@", @"%@ %@", @"Error"),
              CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v16, v11, v14),
              CFRelease(v16),
              !v17))
        {
          CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@ %@", v11, v14);
        }
        CFRelease(v11);
        CFRelease(v14);
        return v17;
      }
      return v11;
    }
    char v2 = 0;
  }
  while ((v3 & 1) != 0);
  CFIndex v7 = CFBundleGetBundleWithIdentifier(@"com.apple.CoreFoundation");
  int v8 = _CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
  int v9 = v8;
  if (v7)
  {
    if (v8)
    {
      CFStringRef v10 = CFBundleCopyLocalizedString(v7, @"The operation couldn\\U2019t be completed. %@", @"The operation couldn\\U2019t be completed. %@", @"Error");
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v10, v9);
      CFStringRef v12 = v10;
    }
    else
    {
      CFStringRef v19 = (const __CFString *)_CFErrorCopyUserInfoKey(a1, @"NSDescription");
      if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
        CFStringRef v20 = (const __CFString *)[a1 domain];
      }
      else {
        CFStringRef v20 = (const __CFString *)a1[3];
      }
      if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
        CFStringRef v23 = (const __CFString *)[a1 domain];
      }
      else {
        CFStringRef v23 = (const __CFString *)a1[3];
      }
      int v9 = CFBundleCopyLocalizedString(v7, v20, v23, @"Error");
      if (v19)
      {
        CFStringRef v24 = CFBundleCopyLocalizedString(v7, @"The operation couldn\\U2019t be completed. (%@ error %ld - %@)", @"The operation couldn\\U2019t be completed. (%@ error %ld - %@)", @"Error");
        if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
          uint64_t v25 = [a1 code];
        }
        else {
          uint64_t v25 = a1[2];
        }
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v24, v9, v25, v19);
        CFRelease(v24);
      }
      else
      {
        CFStringRef v19 = CFBundleCopyLocalizedString(v7, @"The operation couldn\\U2019t be completed. (%@ error %ld.)", @"The operation couldn\\U2019t be completed. (%@ error %ld.)", @"Error");
        if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
          uint64_t v26 = [a1 code];
        }
        else {
          uint64_t v26 = a1[2];
        }
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v19, v9, v26);
      }
      CFStringRef v12 = v19;
    }
    CFRelease(v12);
LABEL_48:
    CFRelease(v9);
    return v11;
  }
  if (v8)
  {
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"The operation couldn\\U2019t be completed. %@", v8);
LABEL_47:
    CFStringRef v11 = v18;
    goto LABEL_48;
  }
  int v9 = _CFErrorCopyUserInfoKey(a1, @"NSDescription");
  int v21 = CF_IS_OBJC(0x1BuLL, (unint64_t)a1);
  if (v9)
  {
    if (v21) {
      uint64_t v22 = [a1 domain];
    }
    else {
      uint64_t v22 = a1[3];
    }
    if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
      uint64_t v28 = [a1 code];
    }
    else {
      uint64_t v28 = a1[2];
    }
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"The operation couldn\\U2019t be completed. (%@ error %ld - %@)", v22, v28, v9);
    goto LABEL_47;
  }
  if (v21) {
    uint64_t v27 = [a1 domain];
  }
  else {
    uint64_t v27 = a1[3];
  }
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    uint64_t v30 = [a1 code];
  }
  else {
    uint64_t v30 = a1[2];
  }
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"The operation couldn\\U2019t be completed. (%@ error %ld.)", v27, v30);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption((unint64_t *)bundle, (void *)key, (__CFString *)value, (__CFString *)tableName, 0, 0, 0);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return _CFBundleGetBundleWithIdentifier((__CFString *)bundleID, v1);
}

void _onelineFormatArrayApply(uint64_t a1, CFMutableStringRef theString)
{
}

__CFAttributedString *_CFDateFormatterCreateAttributedStringAndFieldsWithAbsoluteTime(const __CFAllocator *a1, uint64_t a2, double a3)
{
  CFAllocatorRef v5 = a1;
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  if (!a1)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      CFAllocatorRef v5 = (const __CFAllocator *)v6;
    }
    else {
      CFAllocatorRef v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature(a2);
  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)a2);
  if (v7 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  }
  int v23 = 0;
  double v8 = (a3 + 978307200.0) * 1000.0 + 0.5;
  uint64_t v9 = ufieldpositer_open();
  int v10 = __cficu_udat_formatForFields(*(void *)(a2 + 16), v25, 768, v9, &v23, v8);
  CFIndex v11 = v10;
  int v12 = v23;
  if (v23 == 15 || v10 >= 769)
  {
    uint64_t v14 = v10 + 2;
    uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v14, 0x1000040BDFB0063, 0);
    int v23 = 0;
    ufieldpositer_close();
    uint64_t v9 = ufieldpositer_open();
    CFIndex v11 = (int)__cficu_udat_formatForFields(*(void *)(a2 + 16), Typed + 1, v14, v9, &v23, v8);
    int v12 = v23;
  }
  else
  {
    uint64_t Typed = 0;
  }
  if (v12 > 0)
  {
    CFStringRef v15 = 0;
    if (!Typed) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (Typed) {
    int v21 = Typed;
  }
  else {
    int v21 = (UniChar *)&v24;
  }
  if (*(__objc2_class ***)(a2 + 304) == &__kCFBooleanTrue
    && (CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a2 + 24)),
        CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
  {
    *int v21 = 8207;
    ++v11;
  }
  else if (Typed)
  {
    int v21 = Typed + 1;
  }
  else
  {
    int v21 = v25;
  }
  CFStringRef v15 = CFStringCreateWithCharacters(v5, v21, v11);
  if (Typed) {
LABEL_12:
  }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
LABEL_13:
  if (!v15)
  {
    CFDictionaryRef Mutable = 0;
    if (!v9) {
      return Mutable;
    }
    goto LABEL_19;
  }
  CFIndex Length = CFStringGetLength(v15);
  CFDictionaryRef Mutable = CFAttributedStringCreateMutable(v5, Length);
  v27.CFIndex location = 0;
  v27.size_t length = 0;
  CFAttributedStringReplaceString(Mutable, v27, v15);
  CFRelease(v15);
  for (unsigned int i = ufieldpositer_next(); (i & 0x80000000) == 0; unsigned int i = ufieldpositer_next())
  {
    if (i <= 0x23)
    {
      CFStringRef v19 = CFStringCreateWithBytes(v5, (const UInt8 *)&aGymdkhmssedfww[i], 1, 0x600u, 0);
      v28.CFIndex location = 0;
      v28.size_t length = 0;
      CFAttributedStringSetAttribute(Mutable, v28, @"kCFDateFormatterPatternCharacterKey", v19);
      CFRelease(v19);
    }
  }
  if (v9) {
LABEL_19:
  }
    ufieldpositer_close();
  return Mutable;
}

uint64_t _CFErrorCreateDebugDescription(void *a1)
{
  v3[3] = *(void *)off_1ECE0A5B0;
  v3[1] = 0;
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  void v3[2] = 1;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

uint64_t _CFErrorCreateRedactedDescription(void *a1)
{
  v3[3] = *(void *)off_1ECE0A5B0;
  v3[1] = 0;
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  void v3[2] = 257;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

void _CFErrorFormatDebugDescriptionAux(void *a1, uint64_t a2)
{
  uint64_t v4 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSDebugDescription");
  CFAllocatorRef v5 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSDescription");
  if (v5)
  {
    uint64_t v6 = v5;
  }
  else
  {
    if (v4)
    {
      uint64_t v6 = v4;
    }
    else if (*(unsigned char *)(a2 + 16))
    {
      unint64_t v7 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSLocalizedDescription");
      if (!v7) {
        unint64_t v7 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
      }
      uint64_t v6 = v7;
    }
    else
    {
      uint64_t v6 = 0;
    }
    uint64_t v4 = 0;
  }
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    CFDictionaryRef v8 = (const __CFDictionary *)[a1 userInfo];
  }
  else {
    CFDictionaryRef v8 = (const __CFDictionary *)a1[4];
  }
  uint64_t v9 = *(__CFString **)a2;
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    uint64_t v10 = [a1 domain];
  }
  else {
    uint64_t v10 = a1[3];
  }
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    uint64_t v11 = [a1 code];
  }
  else {
    uint64_t v11 = a1[2];
  }
  CFStringAppendFormat(v9, 0, @"Error Domain=%@ Code=%ld", v10, v11);
  if (*(unsigned char *)(a2 + 17))
  {
    if (objc_opt_respondsToSelector()) {
      CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, @" \"%@\"", [(__CFString *)v6 redactedDescription]);
    }
  }
  else
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, @" \"%@\"", v6);
  }
  if (v6 && v4 && CFStringGetLength(v4) >= 1 && !CFEqual(v6, v4))
  {
    if (*(unsigned char *)(a2 + 17))
    {
      if (objc_opt_respondsToSelector()) {
        CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, @" (%@)", [(__CFString *)v4 redactedDescription]);
      }
    }
    else
    {
      CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, @" (%@)", v4);
    }
  }
  if (!v8 || !CFDictionaryGetCount(v8))
  {
LABEL_36:
    if (!v4) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  uint64_t v12 = *(void *)(a2 + 8);
  if (v12 <= 2)
  {
    *(void *)(a2 + 8) = v12 + 1;
    CFStringAppend(*(CFMutableStringRef *)a2, @" UserInfo={");
    CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)userInfoKeyValueShow, (void *)a2);
    BOOL v13 = CFStringHasSuffix(*(CFStringRef *)a2, @", ") != 0;
    uint64_t v14 = *(__CFString **)a2;
    v16.CFIndex location = CFStringGetLength(*(CFStringRef *)a2) - 2 * v13;
    v16.size_t length = 2 * v13;
    CFStringReplace(v14, v16, @"}");
    --*(void *)(a2 + 8);
    goto LABEL_36;
  }
  CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, @" UserInfo=%p (not displayed)", v8);
  if (v4) {
LABEL_37:
  }
    CFRelease(v4);
LABEL_38:
  if (v6)
  {
    CFRelease(v6);
  }
}

void userInfoKeyValueShow(const void *a1, void *a2, uint64_t a3)
{
  if (!a3) {
    userInfoKeyValueShow_cold_1();
  }
  int v6 = CFEqual(a1, @"NSUnderlyingError");
  if (a2 && v6 && CFGetTypeID(a2) == 27)
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, @"%@=%p {", a1, a2);
    _CFErrorFormatDebugDescriptionAux(a2, a3);
    unint64_t v7 = *(__CFString **)a3;
    CFStringAppend(v7, @"}, ");
  }
  else if (*(unsigned char *)(a3 + 17))
  {
    char v8 = objc_opt_respondsToSelector();
    uint64_t v9 = *(__CFString **)a3;
    if (v8)
    {
      uint64_t v11 = a1;
      uint64_t v12 = [a2 redactedDescription];
      CFStringRef v10 = @"%@=%@, ";
    }
    else
    {
      uint64_t v11 = a1;
      CFStringRef v10 = @"%@=<private>, ";
    }
    CFStringAppendFormat(v9, 0, v10, v11, v12);
  }
  else
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, @"%@=%@, ", a1, a2);
  }
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  va_start(va, format);
  char v3 = atomic_load((unint64_t *)&theString->info);
  if (v3)
  {
    CFStringAppendFormatAndArguments(theString, formatOptions, format, va);
  }
  else
  {
    uint64_t v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringAppendFormat_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

void CFStringAppendFormatAndArguments(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  char v4 = atomic_load((unint64_t *)&theString->info);
  if (v4)
  {
    if (!__CFStringAppendFormatCore(theString, 0, 0, formatOptions, 0, 0, 0)) {
      CFLog(3, @"ERROR: Failed to format string: %@");
    }
  }
  else
  {
    uint64_t v5 = _CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      CFStringAppendFormatAndArguments_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
}

const void *_CFErrorCopyUserInfoKeyFromCallBack(void *a1, uint64_t a2)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    char v4 = (const void *)[a1 domain];
  }
  else {
    char v4 = (const void *)a1[3];
  }
  uint64_t v5 = CFErrorCopyCallBackBlockForDomain(v4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = (const void *)(*((uint64_t (**)(const void *, void *, uint64_t))v5 + 2))(v5, a1, a2);
  uint64_t v8 = v7;
  if (v7) {
    CFRetain(v7);
  }
  CFRelease(v6);
  return v8;
}

const void *CFErrorCopyCallBackBlockForDomain(const void *a1)
{
  if (!_CFErrorCallBackTable) {
    _CFErrorInitializeCallBackTable();
  }
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
  {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)_CFErrorCallBackTable, a1);
    char v3 = Value;
    if (Value) {
      CFRetain(Value);
    }
  }
  else
  {
    char v3 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  return v3;
}

objc_class *__NSDictionaryParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v3 = __CFExceptionProem(result, a2);
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@: block is nil", v3);
    uint64_t v5 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v4) userInfo:0];
    objc_exception_throw(v5);
  }
  return result;
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  v32[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    -[__CFString replaceCharactersInRange:withString:](theString, "replaceCharactersInRange:withString:", location, length, replacement);
    return;
  }
  char v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 1) == 0)
  {
    uint64_t v8 = _CFOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      CFStringReplace_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    return;
  }
  if (replacement == theString)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    replacement = Copy;
  }
  else
  {
    CFStringRef Copy = 0;
  }
  CFIndex v17 = CFStringGetLength(replacement);
  if (v17 < 1)
  {
    BOOL v19 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (unint64_t)replacement))
    {
      int v18 = [(__CFString *)(id)replacement _encodingCantBeStoredInEightBitCFString];
    }
    else
    {
      unsigned int v20 = atomic_load((unint64_t *)&replacement->info);
      int v18 = (v20 >> 4) & 1;
    }
    BOOL v19 = v18 != 0;
  }
  v32[0] = location;
  v32[1] = length;
  __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v32, 1, v17, v19);
  char v22 = atomic_load((unint64_t *)&theString->info);
  char v23 = atomic_load((unint64_t *)&theString->info);
  uint64_t v24 = v23 & 0x60;
  p_data = &theString->data;
  if ((v22 & 0x10) == 0)
  {
    if (v24)
    {
      uint64_t v26 = *p_data;
    }
    else
    {
      uint64_t v28 = atomic_load((unint64_t *)&theString->info);
      uint64_t v26 = (char *)&p_data[(v28 & 5) != 4];
    }
    CFStringEncoding v29 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v21);
      CFStringEncoding v29 = __CFDefaultEightBitStringEncoding;
    }
    unint64_t v30 = atomic_load((unint64_t *)&theString->info);
    v34.CFIndex location = 0;
    v34.CFIndex length = v17;
    CFStringGetBytes(replacement, v34, v29, 0, 0, (UInt8 *)&v26[location + ((v30 >> 2) & 1)], v17, 0);
    goto LABEL_29;
  }
  if (!v24)
  {
    uint64_t v31 = atomic_load((unint64_t *)&theString->info);
    CFRange v27 = (char *)&p_data[(v31 & 5) != 4];
    if (!v27) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  CFRange v27 = *p_data;
  if (v27)
  {
LABEL_28:
    v35.CFIndex location = 0;
    v35.CFIndex length = v17;
    CFStringGetCharacters(replacement, v35, (UniChar *)&v27[2 * location]);
  }
LABEL_29:
  if (Copy)
  {
    CFRelease(Copy);
  }
}

uint64_t __CFBasicHashCopyDescription_block_invoke(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 56))
  {
    CFStringRef v4 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[((*(void *)(*(void *)(a1 + 32)
                                                                                               + 32) >> 14) >> 5) & 0x1F]
                                           + 8 * ((*(void *)(*(void *)(a1 + 32) + 32) >> 14) & 0x1FLL));
    if (v4) {
      CFStringRef v5 = (CFStringRef)v4(a2[2]);
    }
    else {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<%p>", a2[2]);
    }
    CFStringRef v6 = v5;
    uint64_t v7 = *(void *)(a1 + 32);
    if ((*(_WORD *)(v7 + 18) & 4) == 0) {
      goto LABEL_8;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[((*(void *)(v7 + 32) >> 4) >> 5) & 0x1F]
                                           + 8 * ((*(void *)(v7 + 32) >> 4) & 0x1FLL));
    if (v9)
    {
      CFStringRef v10 = (CFStringRef)v9(a2[1]);
LABEL_12:
      CFStringRef v8 = v10;
      goto LABEL_13;
    }
LABEL_11:
    CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<%p>", a2[1]);
    goto LABEL_12;
  }
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<%p>", a2[2]);
  if ((*(_WORD *)(*(void *)(a1 + 32) + 18) & 4) != 0) {
    goto LABEL_11;
  }
LABEL_8:
  CFStringRef v8 = 0;
LABEL_13:
  uint64_t v11 = *(__CFString **)(a1 + 40);
  __int16 v12 = *(_WORD *)(*(void *)(a1 + 32) + 18);
  uint64_t v13 = *(void *)(a1 + 48);
  uint64_t v14 = *a2;
  if ((v12 & 4) != 0 && (v12 & 0x18) != 0)
  {
    CFStringAppendFormat(v11, 0, @"%@%ld : %@ = %@ (%ld)\n", v13, v14, v8, v6, a2[3]);
  }
  else if ((v12 & 4) != 0)
  {
    CFStringAppendFormat(v11, 0, @"%@%ld : %@ = %@\n", v13, v14, v8, v6);
  }
  else if ((v12 & 0x18) != 0)
  {
    CFStringAppendFormat(v11, 0, @"%@%ld : %@ (%ld)\n", v13, v14, v6, a2[3]);
  }
  else
  {
    CFStringAppendFormat(v11, 0, @"%@%ld : %@\n", v13, *a2, v6);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  return 1;
}

CFStringRef __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT__(const void *a1)
{
  return CFCopyDescription(a1);
}

CFStringRef CFCopyDescription(CFStringRef cf)
{
  if (!cf) {
    return cf;
  }
  uint64_t v1 = (__CFString *)cf;
  if (((unint64_t)cf & 0x8000000000000000) != 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)off_1ECE0A6F0;
    unint64_t v4 = (unint64_t)cf & 0xC000000000000007;
    if (((unint64_t)cf & 0xC000000000000007) == 0xC000000000000007) {
      uint64_t v3 = 0;
    }
    unint64_t v5 = v3 ^ (unint64_t)cf;
    unint64_t v6 = v5 & 7;
    do
    {
      if (v6 == *((unsigned __int8 *)off_1ECE0A6E0 + v2)) {
        break;
      }
      ++v2;
    }
    while (v2 != 7);
    unint64_t v7 = v2 | v5;
    uint64_t v8 = v2 & 7;
    int v9 = (v7 >> 55) + 8;
    if (v8 == 7) {
      LODWORD(v8) = v9;
    }
    if (v8)
    {
      if (v8 == 6)
      {
        CFStringRef v10 = (__CFString *(*)(unint64_t *))off_1ECE0DA58;
        goto LABEL_34;
      }
      if (v8 == 3)
      {
        CFStringRef v10 = (__CFString *(*)(unint64_t *))off_1ECE0E058;
LABEL_34:
        return v10((unint64_t *)cf);
      }
    }
    else
    {
      if (dyld_program_sdk_at_least()) {
        CFCopyDescription_cold_3();
      }
      uint64_t v27 = *(void *)off_1ECE0A6F0;
      if (v4 == 0xC000000000000007) {
        uint64_t v27 = 0;
      }
      unint64_t v5 = v27 ^ (unint64_t)v1;
      unint64_t v6 = v5 & 7;
    }
    for (uint64_t i = 0; i != 7; ++i)
    {
      if (v6 == *((unsigned __int8 *)off_1ECE0A6E0 + i)) {
        break;
      }
    }
    int v29 = ((i | v5) >> 55) + 8;
    if ((i & 7) == 7) {
      int v30 = v29;
    }
    else {
      int v30 = i & 7;
    }
    unint64_t v12 = 22;
    switch(v30)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          CFCopyDescription_cold_2();
        }
        goto LABEL_66;
      case 1:
        goto LABEL_67;
      case 2:
        goto LABEL_65;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_66;
      case 6:
        unint64_t v12 = 42;
        break;
      default:
        if (v30 == 20)
        {
LABEL_66:
          unint64_t v12 = 1;
        }
        else if (v30 == 22)
        {
LABEL_65:
          unint64_t v12 = 7;
        }
        else
        {
LABEL_67:
          unint64_t v12 = [(__CFString *)v1 _cfTypeID];
        }
        break;
    }
  }
  else
  {
    unint64_t v11 = atomic_load((unint64_t *)&cf->info);
    unint64_t v12 = (v11 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v12, (unint64_t)v1))
  {
    return (CFStringRef)[(__CFString *)v1 _copyDescription];
  }
  else
  {
    __CFCheckCFInfoPACSignature_Bridged((uint64_t)v1);
    if (((unint64_t)v1 & 0x8000000000000000) != 0)
    {
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)off_1ECE0A6F0;
      if ((~(unint64_t)v1 & 0xC000000000000007) == 0) {
        uint64_t v14 = 0;
      }
      unint64_t v15 = v14 ^ (unint64_t)v1;
      do
      {
        if ((v15 & 7) == *((unsigned char *)off_1ECE0A6E0 + v13)) {
          break;
        }
        ++v13;
      }
      while (v13 != 7);
      unint64_t v16 = v13 | v15;
      uint64_t v17 = v13 & 7;
      int v18 = (v16 >> 55) + 8;
      if (v17 == 7) {
        int v19 = v18;
      }
      else {
        int v19 = v17;
      }
      unint64_t v20 = 22;
      switch(v19)
      {
        case 0:
          if (dyld_program_sdk_at_least()) {
            CFCopyDescription_cold_1();
          }
          goto LABEL_43;
        case 1:
          goto LABEL_44;
        case 2:
          goto LABEL_42;
        case 3:
          goto LABEL_46;
        case 4:
        case 5:
          goto LABEL_43;
        case 6:
          unint64_t v20 = 42;
          goto LABEL_46;
        default:
          if (v19 == 20)
          {
LABEL_43:
            unint64_t v20 = 1;
            goto LABEL_46;
          }
          if (v19 == 22)
          {
LABEL_42:
            unint64_t v20 = 7;
            goto LABEL_46;
          }
LABEL_44:
          unint64_t v20 = [(__CFString *)v1 _cfTypeID];
          break;
      }
    }
    else
    {
      unint64_t v21 = atomic_load((unint64_t *)&v1->info);
      unint64_t v20 = (v21 >> 8) & 0x3FF;
    }
    if (v20 <= 0x47) {
LABEL_46:
    }
      char v22 = &__CFRuntimeBuiltinClassTable + v20;
    else {
      char v22 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v20 - 72) >> 6] + 8 * ((v20 - 72) & 0x3F));
    }
    char v23 = *v22;
    uint64_t v24 = (uint64_t (*)(__CFString *))*((void *)*v22 + 8);
    if (!v24 || (CFTypeRef cf = (CFStringRef)v24(v1)) == 0)
    {
      uint64_t v25 = v23[1];
      CFAllocatorRef v26 = CFGetAllocator(v1);
      return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<%s %p [%p]>", v25, v1, v26);
    }
  }
  return cf;
}

void sub_182C11CF0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C1249C(_Unwind_Exception *a1)
{
  *(void *)(v3 - 280) = v2;
  *(void *)(v3 - 272) = v1;
  free(*(void **)(v3 - 280));
  free(*(void **)(v3 - 272));
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSData(uint64_t a1)
{
  if (!a1) {
    return a1 & 1;
  }
  uint64_t v1 = a1;
  MethodImplementatiouint64_t n = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
    return a1 & 1;
  }

  return MethodImplementation(v1, sel_isNSData__);
}

void sub_182C12F94(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFStringRef __CFStringCopyDescription(uint64_t a1)
{
  uint64_t v1 = &kCFAllocatorSystemDefault;
  if ((a1 & 0x8000000000000000) == 0)
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if (v2 < 0) {
      uint64_t v1 = &kCFAllocatorSystemDefault;
    }
    else {
      uint64_t v1 = (const CFAllocatorRef *)(a1 - 16);
    }
  }
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFString %p [%p]>{contents = \"%@\"}", a1, *v1, a1);
}

uint64_t _CFAutoreleasePoolAddObject(uint64_t a1, uint64_t a2)
{
  if (__CFOASafe) {
    __CFRecordAllocationEvent();
  }

  return MEMORY[0x1F4181450](a2);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  CFPropertyListRef v0 = (void *)+[NSLocale _current];

  return (CFLocaleRef)v0;
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v6 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v6);
  }

  __CFDateFormatterSetProperty((uint64_t)formatter, key, (__CFString *)value, 0);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)__CreateCFDateFormatter((__objc2_class **)allocator, locale, dateStyle, timeStyle, &__kCFBooleanFalse);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  if (!arg) {
    CFAutorelease_cold_1();
  }
  CFTypeRef v2 = (id)arg;
  return arg;
}

IMP _CFErrorCocoaCallBack(uint64_t a1, uint64_t a2)
{
  IMP result = (IMP)_CFErrorCocoaCallBack_cocoaCallBack;
  if (!_CFErrorCocoaCallBack_cocoaCallBack)
  {
    Class v5 = objc_lookUpClass("NSError");
    if (v5)
    {
      unint64_t v6 = v5;
      unint64_t v7 = sel_registerName("_retainedUserInfoCallBackForKey:");
      IMP result = class_getMethodImplementation(v6, v7);
      _CFErrorCocoaCallBack_cocoaCallBacuint64_t k = result;
      if (!result) {
        return result;
      }
    }
    else
    {
      IMP result = (IMP)_CFErrorCocoaCallBack_cocoaCallBack;
      if (!_CFErrorCocoaCallBack_cocoaCallBack) {
        return result;
      }
    }
  }
  int v9 = (uint64_t (*)(uint64_t, SEL, uint64_t))result;
  SEL v8 = sel_registerName("_retainedUserInfoCallBackForKey:");

  return (IMP)v9(a1, v8, a2);
}

uint64_t __cficu_udat_formatForFields(uint64_t a1, const UniChar *a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = udat_formatForFields();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a2, a3);
    CFStringRef v16 = ___CFICUCreateArgumentForDouble(a6);
    CFStringRef v17 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
    {
      CFStringRef v18 = CFStringCreateWithCharacters(0, a2, (int)v12);
      if (!a4) {
        goto LABEL_7;
      }
    }
    else
    {
      CFStringRef v18 = 0;
      if (!a4)
      {
LABEL_7:
        ___CFICULogWithArguments(1, @"udat_format(%@, %@, %@, %d, NULL, &%@); // %d %@ %@",
          v13,
          v16,
          v15,
          a3,
          v14,
          v12,
          v18,
          v17);
        ___CFICULogWithArguments(1, @"u_printf(\"%@: '%%S'\\n\", %@);", v15, v15);
        CFRelease(v13);
        CFRelease(v14);
        CFRelease(v15);
        CFRelease(v16);
        if (v18) {
          CFRelease(v18);
        }
        CFRelease(v17);
        return v12;
      }
    }
    ___CFICULogWithArguments(1, @"#warning non-NULL UFieldPositionIterator ignored");
    goto LABEL_7;
  }
  return v12;
}

CFTypeID CFErrorGetTypeID(void)
{
  return 27;
}

CFStringRef _CFErrorPOSIXCallBack(void *a1, CFTypeRef cf1)
{
  if (!CFEqual(cf1, @"NSDescription") && !CFEqual(cf1, @"NSLocalizedFailureReason")) {
    return 0;
  }
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    LODWORD(v4) = [a1 code];
  }
  else {
    uint64_t v4 = a1[2];
  }
  Class v5 = strerror(v4);
  if (!v5 || !*v5) {
    return 0;
  }
  CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, 0x8000100u);
  if (v6)
  {
    if (!CFEqual(cf1, @"NSDescription"))
    {
      unint64_t v7 = CFCopySearchPathForDirectoriesInDomains(5, 8, 0);
      if (v7)
      {
        CFArrayRef v8 = v7;
        if (CFArrayGetCount(v7) >= 1)
        {
          CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v8, 0);
          CFStringRef v10 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
          if (v10)
          {
            CFStringRef v11 = v10;
            CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@/CoreServices/CoreTypes.bundle", v10);
            CFURLRef v13 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, kCFURLPOSIXPathStyle, 0);
            CFRelease(v11);
            if (v13)
            {
              uint64_t v14 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
              if (v14)
              {
                CFTypeRef v15 = v14;
                CFStringRef v16 = (__CFString *)CFBundleCopyLocalizedString(v14, v6, @"%%NOTFOUND%%", @"ErrnoErrors");
                if (v16 == @"%%NOTFOUND%%")
                {
                  CFRelease(@"%%NOTFOUND%%");
                  CFStringRef v16 = 0;
                }
                CFRelease(v6);
                CFRelease(v15);
                CFStringRef v6 = v16;
              }
              CFRelease(v13);
            }
            CFRelease(v12);
          }
        }
        CFRelease(v8);
      }
    }
  }
  return v6;
}

CFStringRef __CFBundleCopyDescription(uint64_t a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  CFURLRef v2 = *(const __CFURL **)(a1 + 16);
  if (v2 && CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1026)) {
    CFStringRef v3 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)buffer);
  }
  else {
    CFStringRef v3 = 0;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 48) - 2;
  Class v5 = &stru_1ECE10768;
  CFStringRef v6 = &stru_1ECE10768;
  if (v4 <= 3) {
    CFStringRef v6 = off_1ECDABA58[v4];
  }
  if (!*(unsigned char *)(a1 + 52)) {
    Class v5 = @"not ";
  }
  if (*(unsigned char *)(a1 + 72)) {
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"CFBundle/CFPlugIn %p <%@> (%@%@loaded)", a1, v3, v6, v5);
  }
  else {
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"CFBundle %p <%@> (%@%@loaded)", a1, v3, v6, v5);
  }
  CFStringRef v8 = v7;
  if (v3) {
    CFRelease(v3);
  }
  return v8;
}

CFStringRef __CFBasicHashCopyDescription(const void *a1)
{
  CFURLRef v2 = CFBasicHashCopyDescription((uint64_t)a1, 0, (uint64_t)&stru_1ECE10768, @"\t", 1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFBasicHash %p [%p]>%@", a1, v3, v2);
  CFRelease(v2);
  return v4;
}

__CFString *CFBasicHashCopyDescription(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 0x40) != 0) {
    CFStringRef v12 = "immutable";
  }
  else {
    CFStringRef v12 = "mutable";
  }
  __int16 v13 = *(_WORD *)(a1 + 18);
  if ((v13 & 0x18) != 0) {
    uint64_t v14 = "multi";
  }
  else {
    uint64_t v14 = "";
  }
  if ((v13 & 4) != 0) {
    CFTypeRef v15 = "dict";
  }
  else {
    CFTypeRef v15 = "set";
  }
  uint64_t Count = CFBasicHashGetCount(a1);
  CFStringAppendFormat(Mutable, 0, @"%@{type = %s %s%s, size_t count = %ld,\n", a3, v12, v14, v15, Count);
  if (a2)
  {
    CFStringAppendFormat(Mutable, 0, @"%@hash cache = %s, strong values = %s, strong keys = %s, cb = %s,\n", a3, "no", "no", "no", "custom");
    CFStringAppendFormat(Mutable, 0, @"%@num bucket index = %d, num buckets = %ld, capacity = %ld, num buckets used = %u,\n", a3, BYTE2(*(void *)(a1 + 24)), __CFBasicHashTableSizes[BYTE2(*(void *)(a1 + 24))], __CFBasicHashTableCapacities[BYTE2(*(void *)(a1 + 24))], *(unsigned int *)(a1 + 20));
    unsigned int v17 = *(unsigned __int16 *)(a1 + 18);
    if ((v17 & 0x18) != 0) {
      uint64_t v18 = (1 << ((v17 >> 5) & 3));
    }
    else {
      uint64_t v18 = 0;
    }
    if ((*(void *)(a1 + 32) & 8) != 0) {
      int v19 = "yes";
    }
    else {
      int v19 = "no";
    }
    CFStringAppendFormat(Mutable, 0, @"%@counts width = %d, finalized = %s,\n", a3, v18, v19);
    uint64_t v20 = *(unsigned __int16 *)(a1 + 16);
    uint64_t v21 = *(unsigned __int16 *)(a1 + 24);
    __int16 v22 = *(_WORD *)(a1 + 18);
    uint64_t v23 = 56;
    if ((v22 & 4) == 0) {
      uint64_t v23 = 48;
    }
    if ((v22 & 0x18) != 0) {
      uint64_t v24 = v23 + 8;
    }
    else {
      uint64_t v24 = v23;
    }
    uint64_t Size = CFBasicHashGetSize(a1, 1);
    CFStringAppendFormat(Mutable, 0, @"%@num mutations = %ld, num deleted = %ld, size = %ld, total size = %ld,\n", a3, v20, v21, v24, Size);
    uint64_t v26 = 0;
    unint64_t v27 = *(unsigned __int16 *)(a1 + 18);
    if ((v27 & 4) != 0) {
      uint64_t v26 = *(void *)(a1 + 8 * ((v27 >> 2) & 1) + 40);
    }
    if ((v27 & 0x18) != 0) {
      uint64_t v28 = *(void *)(a1 + (v27 & 0x18) + 40);
    }
    else {
      uint64_t v28 = 0;
    }
    CFStringAppendFormat(Mutable, 0, @"%@values int8x16_t ptr = %p, keys int8x16_t ptr = %p, counts int8x16_t ptr = %p, hashes int8x16_t ptr = %p,\n", a3, *(void *)(a1 + 40), v26, v28, 0);
  }
  CFStringAppendFormat(Mutable, 0, @"%@entries =>\n", a3);
  v30[0] = off_1ECE0A5A0;
  v30[1] = 3221225472;
  void v30[2] = __CFBasicHashCopyDescription_block_invoke;
  v30[3] = &__block_descriptor_57_e15_C40__0___qQQQ_8l;
  char v31 = a5;
  v30[4] = a1;
  v30[5] = Mutable;
  v30[6] = a4;
  CFBasicHashApply(a1, (uint64_t)v30);
  CFStringAppendFormat(Mutable, 0, @"%@}\n", a3);
  return Mutable;
}

__CFString *__CFDataCopyDescription(unint64_t *cf)
{
  uint64_t v2 = cf[2];
  char v3 = atomic_load(cf + 1);
  if ((v3 & 4) != 0) {
    CFStringRef v4 = (unsigned __int8 *)(((unint64_t)cf + 63) & 0xFFFFFFFFFFFFFFF0);
  }
  else {
    CFStringRef v4 = (unsigned __int8 *)cf[5];
  }
  CFAllocatorRef v5 = CFGetAllocator(cf);
  CFDictionaryRef Mutable = CFStringCreateMutable(v5, 0);
  CFAllocatorRef v7 = CFGetAllocator(cf);
  CFStringAppendFormat(Mutable, 0, @"<CFData %p [%p]>{CFIndex length = %lu, capacity = %lu, bytes = 0x", cf, v7, v2, cf[3]);
  if (v2 < 25)
  {
    if (v2 >= 1)
    {
      do
      {
        unsigned int v11 = *v4++;
        CFStringAppendFormat(Mutable, 0, @"%02x", v11);
        --v2;
      }
      while (v2);
    }
  }
  else
  {
    unint64_t v8 = 0;
    do
    {
      CFStringAppendFormat(Mutable, 0, @"%02x%02x%02x%02x", v4[v8], v4[v8 + 1], v4[v8 + 2], v4[v8 + 3]);
      BOOL v9 = v8 >= 0xC;
      v8 += 4;
    }
    while (!v9);
    CFStringAppend(Mutable, @" ... ");
    uint64_t v10 = v2 - 8;
    do
    {
      CFStringAppendFormat(Mutable, 0, @"%02x%02x%02x%02x", v4[v10], v4[v10 + 1], v4[v10 + 2], v4[v10 + 3]);
      v10 += 4;
    }
    while (v10 < v2);
  }
  CFStringAppend(Mutable, @"}");
  return Mutable;
}

CFStringRef __CFBooleanCopyDescription(__objc2_class **a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  if (&__kCFBooleanTrue == a1) {
    char v3 = "true";
  }
  else {
    char v3 = "false";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFBoolean %p [%p]>{BOOL value = %s}", a1, v2, v3);
}

void sub_182C1490C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void __NSArrayEnumerate(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v45 = *(void *)off_1ECE0A5B0;
  if ([a1 count])
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      uint64_t v6 = [a4 firstIndex];
      unint64_t v30 = [a4 lastIndex];
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v30 = [a1 count] - 1;
    }
    if (v6 != 0x7FFFFFFFFFFFFFFFLL && v30 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (a3)
      {
        uint64_t v7 = __CFActiveProcessorCount();
        if (v7 < 2) {
          a3 &= ~1uLL;
        }
      }
      else
      {
        uint64_t v7 = 1;
      }
      if ((a3 & 3) != 0)
      {
        unint64_t v8 = (v30 - v6 + 1) / v7 / v7;
        if (v8 >= 0x10)
        {
          if (v8 <= 0x1000) {
            unint64_t v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0;
          }
          else {
            unint64_t v9 = 4096;
          }
        }
        else
        {
          unint64_t v9 = 16;
        }
        unint64_t v17 = v9 + v30 - v6;
        uint64_t v36 = 0;
        CFDataRef v37 = &v36;
        uint64_t v38 = 0x2020000000;
        uint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
        if (a3)
        {
          v34[0] = 0;
          v34[1] = v34;
          void v34[2] = 0x2020000000;
          char v35 = 0;
          block[0] = off_1ECE0A5A0;
          block[1] = 3221225472;
          void block[2] = ____NSArrayEnumerate_block_invoke;
          block[3] = &unk_1ECDB0760;
          void block[10] = v9;
          block[11] = v30;
          block[12] = a3;
          block[4] = a1;
          void block[5] = a4;
          block[7] = v34;
          void block[8] = &v36;
          block[6] = a2;
          block[9] = v6;
          dispatch_apply(v17 / v9, 0, block);
          _Block_object_dispose(v34, 8);
        }
        else
        {
          int v29 = a1;
          if (v9 <= v17)
          {
            uint64_t v18 = 0;
            unint64_t v19 = v9 - 1;
            unint64_t v20 = 1;
            unint64_t v21 = v6;
            unint64_t v22 = v30;
            unint64_t v23 = v17 / v9;
            do
            {
              if ((a3 & 2) != 0)
              {
                if (v19 >= v22 - v6) {
                  unint64_t v25 = v6;
                }
                else {
                  unint64_t v25 = 1 - v9 + v22;
                }
                unint64_t v24 = v22;
              }
              else
              {
                if (v19 >= v22 - v6) {
                  unint64_t v24 = v30;
                }
                else {
                  unint64_t v24 = v19 + v18 * v9 + v6;
                }
                unint64_t v25 = v21;
              }
              BOOL v26 = __NSArrayChunkIterate(v29, a3, v25, v24, a4, a2, (unint64_t *)v37 + 3, 0, 0);
              ++v18;
              char v27 = v20 >= v23 || v26;
              v22 -= v9;
              v21 += v9;
              ++v20;
            }
            while ((v27 & 1) == 0);
          }
        }
        _Block_object_dispose(&v36, 8);
      }
      else
      {
        unint64_t v28 = v6;
        uint64_t v10 = (void *)_CFAutoreleasePoolPush();
        LOBYTE(v34[0]) = 0;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
        if (v11)
        {
          unint64_t v12 = 0;
          uint64_t v13 = 0;
          uint64_t v14 = *(void *)v42;
          do
          {
            for (uint64_t i = 0; i != v11; ++i)
            {
              if (*(void *)v42 != v14) {
                objc_enumerationMutation(a1);
              }
              unint64_t v16 = v13 + i;
              if ((a3 & 0x1000000000000000) == 0
                || v28 <= v16 && v16 <= v30 && [a4 containsIndex:v13 + i])
              {
                __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(a2);
                if (v12 < 0x3FF)
                {
                  ++v12;
                }
                else
                {
                  _CFAutoreleasePoolPop(v10);
                  uint64_t v10 = (void *)_CFAutoreleasePoolPush();
                  unint64_t v12 = 0;
                }
              }
            }
            uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
            v13 += i;
          }
          while (v11);
        }
        _CFAutoreleasePoolPop(v10);
      }
    }
  }
}

void sub_182C14D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

unint64_t _CFArrayFastEnumeration(unint64_t *a1, void *a2)
{
  if (!a1[2]) {
    return 0;
  }
  char v2 = atomic_load(a1 + 1);
  int v3 = v2 & 3;
  if (v3 != 2)
  {
    if (!v3 && !*a2)
    {
      *a2 = 1;
      a2[2] = &_CFArrayFastEnumeration_const_mu;
      char v4 = atomic_load(a1 + 1);
      int v5 = v4 & 3;
      if (v5 != 2)
      {
        if (!v5)
        {
LABEL_7:
          char v6 = atomic_load(a1 + 1);
          BOOL v7 = (~v6 & 0xC) == 0;
          uint64_t v8 = 6;
          if (v7) {
            uint64_t v8 = 11;
          }
          uint64_t v9 = (uint64_t)&a1[v8];
          goto LABEL_16;
        }
        goto LABEL_14;
      }
LABEL_15:
      uint64_t v9 = a1[5] + 8 * *(void *)a1[5] + 16;
      goto LABEL_16;
    }
    return 0;
  }
  if (*a2) {
    return 0;
  }
  *a2 = 1;
  a2[2] = a1 + 3;
  char v11 = atomic_load(a1 + 1);
  int v12 = v11 & 3;
  if (v12 == 2) {
    goto LABEL_15;
  }
  if (!v12) {
    goto LABEL_7;
  }
LABEL_14:
  uint64_t v9 = 0;
LABEL_16:
  a2[1] = v9;
  return a1[2];
}

uint64_t _CFNonObjCArrayGetCount(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void _CFPreferencesSetAppValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

CFStringRef CFBundleCopyLocalizationForLocalizationInfo(unsigned int a1, unsigned int a2, int a3, int a4)
{
  CFStringRef result = _CFBundleCopyLocaleAbbreviationForRegionCode(a2);
  if (!result)
  {
    CFStringRef result = _CFBundleCopyLanguageAbbreviationForLanguageCode(a1);
    if (!result)
    {
      unint64_t v8 = 0;
      do
      {
        if (__CFBundleScriptCodesArray[v8] == a3)
        {
          if (__CFBundleStringEncodingsArray[v8] == a4) {
            unsigned int v9 = v8;
          }
          else {
            unsigned int v9 = -1;
          }
        }
        else
        {
          unsigned int v9 = -1;
        }
        if (v9 != -1) {
          break;
        }
        BOOL v10 = v8++ >= 0x97;
      }
      while (!v10);
      unint64_t v11 = 0;
      do
      {
        int v12 = __CFBundleScriptCodesArray[v11];
        int v13 = v11 + 1;
        if (v12 == a3) {
          break;
        }
        BOOL v10 = v11++ >= 0x97;
      }
      while (!v10);
      unint64_t v14 = 0;
      if (v12 == a3) {
        unsigned int v15 = v13 - 1;
      }
      else {
        unsigned int v15 = -1;
      }
      do
      {
        int v16 = __CFBundleStringEncodingsArray[v14];
        int v17 = v14 + 1;
        if (v16 == a4) {
          break;
        }
        BOOL v10 = v14++ >= 0x97;
      }
      while (!v10);
      CFStringRef result = _CFBundleCopyLanguageAbbreviationForLanguageCode(v9);
      if (!result)
      {
        unsigned int v18 = v16 == a4 ? v17 - 1 : -1;
        CFStringRef result = _CFBundleCopyLanguageAbbreviationForLanguageCode(v18);
        if (!result)
        {
          return _CFBundleCopyLanguageAbbreviationForLanguageCode(v15);
        }
      }
    }
  }
  return result;
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  uint64_t v5 = *(void *)&encoding;
  size_t v8 = strlen(cStr);

  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)cStr, v8, v5, 0x18u, (__objc2_class **)contentsDeallocator, 0);
}

CFStringRef _CFBundleCopyLocaleAbbreviationForRegionCode(unsigned int a1)
{
  if (a1 <= 0x6C
    && __CFBundleLocaleAbbreviationsArray
    && (uint64_t v1 = (const char *)(__CFBundleLocaleAbbreviationsArray + 6 * a1), *v1))
  {
    return CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
  }
  else
  {
    return 0;
  }
}

__CFArray *_CFBundleCopyLanguageSearchListInDirectory(const __CFURL *a1, unsigned __int8 *a2)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  unsigned __int8 v18 = 0;
  CFDictionaryRef v4 = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, &v18);
  CFDictionaryRef v5 = v4;
  if (!v4)
  {
    BOOL v7 = 0;
    BOOL v10 = 0;
    goto LABEL_11;
  }
  CFStringRef Value = (__CFString *)CFDictionaryGetValue(v4, @"CFBundleDevelopmentRegion");
  BOOL v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFStringGetTypeID() || !CFStringGetLength(v7)) {
      BOOL v7 = 0;
    }
  }
  unsigned int v9 = CFDictionaryGetValue(v5, @"CFBundleLocalizations");
  if (!v9) {
    goto LABEL_9;
  }
  BOOL v10 = v9;
  CFRetain(v9);
  CFTypeID v11 = CFGetTypeID(v10);
  if (v11 != CFArrayGetTypeID())
  {
    CFRelease(v10);
LABEL_9:
    BOOL v10 = (const void *)_copyAppleLocalizations(v5);
  }
LABEL_11:
  CFURLRef v12 = _CFBundleCopyResourcesDirectoryURLInDirectory(a1, v18);
  CFArrayRef v13 = (const __CFArray *)_CFBundleCopyLProjDirectoriesForURL((uint64_t)&__kCFAllocatorSystemDefault, v12);
  CFRelease(v12);
  if (v10 && v13)
  {
    MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFArrayRef)v10);
    v21.CFIndex length = CFArrayGetCount(v13);
    v21.CFIndex location = 0;
    CFArrayAppendArray(MutableCopy, v13, v21);
    CFRelease(v13);
    CFArrayRef v13 = MutableCopy;
LABEL_16:
    CFRelease(v10);
    goto LABEL_17;
  }
  if (v10)
  {
    CFArrayRef v13 = (const __CFArray *)CFRetain(v10);
    goto LABEL_16;
  }
  if (!v13) {
    CFArrayRef v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  }
LABEL_17:
  CFArrayRef v15 = (const __CFArray *)_CFBundleCopyUserLanguages();
  int v16 = _CFBundleCopyPreferredLanguagesInList(v13, v7, v15, 1, (unint64_t)a1, 0);
  if (v15) {
    CFRelease(v15);
  }
  CFRelease(v13);
  if (v7)
  {
    v20.CFIndex length = CFArrayGetCount(v16);
    v20.CFIndex location = 0;
    if (CFArrayGetFirstIndexOfValue(v16, v20, v7) < 0) {
      CFArrayAppendValue(v16, v7);
    }
  }
  if (!CFArrayGetCount(v16)) {
    CFArrayAppendValue(v16, @"en");
  }
  if (v5) {
    CFRelease(v5);
  }
  if (a2) {
    *a2 = v18;
  }
  return v16;
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInDirectory(const __CFAllocator *a1, CFURLRef url, unsigned char *a3)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
  {
    CFMutableDictionaryRef v11 = 0;
    char v10 = 0;
    if (!a3) {
      return v11;
    }
    goto LABEL_5;
  }
  size_t v6 = strlen((const char *)buffer);
  CFURLRef v8 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v6, 1u);
  if (!v8) {
    CFURLRef v8 = (const __CFURL *)CFRetain(url);
  }
  int BundleVersionForURL = _CFBundleGetBundleVersionForURL((uint64_t)v8, v7);
  char v10 = BundleVersionForURL;
  CFMutableDictionaryRef v11 = _CFBundleCopyInfoDictionaryInDirectoryWithVersion(a1, v8, 0, 0, 0, BundleVersionForURL);
  CFRelease(v8);
  if (a3) {
LABEL_5:
  }
    *a3 = v10;
  return v11;
}

BOOL _CFLocaleGetCalendarDirection()
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  Boolean keyExistsAndHasValidFormat = 0;
  AppBooleanCFStringRef Value = CFPreferencesGetAppBooleanValue(@"NSLocaleCalendarDirectionIsRightToLeft", @"kCFPreferencesAnyApplication", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    return AppBooleanValue != 0;
  }
  MainBundle = CFBundleGetMainBundle();
  CFArrayRef v3 = CFBundleCopyBundleLocalizations(MainBundle);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  CFArrayRef v5 = CFBundleCopyPreferredLocalizationsFromArray(v3);
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
  ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, ValueAtIndex);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, @"kCFLocaleLanguageCodeKey");
  if (Value) {
    BOOL v1 = CFLocaleGetLanguageCharacterDirection(Value) == kCFLocaleLanguageDirectionRightToLeft;
  }
  else {
    BOOL v1 = 0;
  }
  CFRelease(ComponentsFromLocaleIdentifier);
  CFRelease(v5);
  CFRelease(v4);
  return v1;
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  uint64_t v29 = *(void *)off_1ECE0A5B0;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 10, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v25 = 0;
  if (localeID)
  {
    usedBufLeuint64_t n = 0;
    v30.CFIndex length = CFStringGetLength(localeID);
    v30.CFIndex location = 0;
    CFStringGetBytes(localeID, v30, 0x600u, 0x3Fu, 1u, buffer, 256, &usedBufLen);
    buffer[usedBufLen] = 0;
    int Language = uloc_getLanguage();
    if (v25 <= 0 && Language >= 1)
    {
      CFStringRef v6 = CFStringCreateWithBytes(allocator, bytes, Language, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleLanguageCodeKey", v6);
      CFRelease(v6);
    }
    int v25 = 0;
    int Script = uloc_getScript();
    if (v25 <= 0 && Script >= 1)
    {
      CFStringRef v8 = CFStringCreateWithBytes(allocator, bytes, Script, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleScriptCodeKey", v8);
      CFRelease(v8);
    }
    int v25 = 0;
    int Country = uloc_getCountry();
    if (v25 <= 0 && Country >= 1)
    {
      CFStringRef v10 = CFStringCreateWithBytes(allocator, bytes, Country, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleCountryCodeKey", v10);
      CFRelease(v10);
    }
    int v25 = 0;
    int Variant = uloc_getVariant();
    if (v25 <= 0 && Variant >= 1)
    {
      CFStringRef v12 = CFStringCreateWithBytes(allocator, bytes, Variant, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleVariantCodeKey", v12);
      CFRelease(v12);
    }
    int v25 = 0;
    uloc_openKeywords();
    uint64_t v13 = uenum_next();
    if (v13 && v25 <= 0)
    {
      uint64_t v14 = (const char *)v13;
      while (1)
      {
        if ((int)uloc_getKeywordValue() < 1 || v25 > 0) {
          goto LABEL_29;
        }
        size_t v16 = strlen(v14);
        CFStringRef v17 = CFStringCreateWithBytes(allocator, (const UInt8 *)v14, v16, 0x600u, 1u);
        size_t v18 = strlen(__s);
        CFStringRef v19 = CFStringCreateWithBytes(allocator, (const UInt8 *)__s, v18, 0x600u, 1u);
        CFStringRef v20 = v19;
        if (v17 && v19)
        {
          CFDictionaryAddValue(Mutable, v17, v19);
        }
        else if (!v17)
        {
          goto LABEL_27;
        }
        CFRelease(v17);
LABEL_27:
        if (v20) {
          CFRelease(v20);
        }
LABEL_29:
        uint64_t v21 = uenum_next();
        if (v21)
        {
          uint64_t v14 = (const char *)v21;
          if (v25 < 1) {
            continue;
          }
        }
        break;
      }
    }
    uenum_close();
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(allocator, Mutable);
  CFRelease(Mutable);
  return Copy;
}

CFLocaleLanguageDirection CFLocaleGetLanguageCharacterDirection(CFStringRef isoLangCode)
{
  return +[NSLocale characterDirectionForLanguage:isoLangCode];
}

CFStringRef _CFCopyResolvedFormatStringWithConfiguration(__CFString *a1, CFDictionaryRef theDict, const void *a3)
{
  value[20] = *(void **)off_1ECE0A5B0;
  CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"NSStringFormatSpecTypeKey");
  if (!v6) {
    return v6;
  }
  uint64_t v7 = CFDictionaryGetValue(theDict, @"NSStringFormatLocaleKey");
  if (!v7)
  {
    uint64_t v7 = a3;
    if (!a3)
    {
      uint64_t v7 = (const void *)_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale;
      if (!_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale)
      {
        MainBundle = CFBundleGetMainBundle();
        CFArrayRef v9 = CFBundleCopyBundleLocalizations(MainBundle);
        if (v9)
        {
          CFArrayRef v10 = v9;
          CFArrayRef v11 = CFBundleCopyPreferredLocalizationsFromArray(v9);
          CFRelease(v10);
          if (v11)
          {
            if (CFArrayGetCount(v11) <= 0)
            {
              CFRelease(v11);
            }
            else
            {
              CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, 0);
              uint64_t v7 = CFLocaleCreate(0, ValueAtIndex);
              CFRelease(v11);
              if (v7) {
                goto LABEL_12;
              }
            }
          }
        }
        uint64_t v7 = CFLocaleCreate(0, @"en");
LABEL_12:
        uint64_t v13 = 0;
        atomic_compare_exchange_strong(&_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale, (unint64_t *)&v13, (unint64_t)v7);
        if (v13)
        {
          CFRelease(v7);
          uint64_t v7 = (const void *)_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale;
        }
      }
    }
  }
  if (v6 == @"NSStringPluralRuleType" || CFEqual(v6, @"NSStringPluralRuleType"))
  {
    CFTypeID v14 = CFGetTypeID(a1);
    if (v14 == CFNumberGetTypeID())
    {
      size_t v76 = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &v76))
      {
        size_t v15 = v76;
        if (v76)
        {
          CFStringRef v6 = 0;
        }
        else
        {
          if (CFNumberIsFloatType((CFNumberRef)a1)) {
            CFStringRef v6 = 0;
          }
          else {
            CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"zero");
          }
          size_t v15 = v76;
        }
        if (v15 == 0x7FFFFFFFFFFFFFFFLL) {
          CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"other");
        }
        if (v6) {
          return (const __CFString *)CFRetain(v6);
        }
      }
      else
      {
        size_t v76 = -1;
      }
      int v75 = 0;
      CFStringRef Identifier = CFLocaleGetIdentifier((CFLocaleRef)v7);
      if (!Identifier) {
        CFStringRef Identifier = @"en";
      }
      if (!CFStringGetCString(Identifier, (char *)value, 157, 0x8000100u)) {
        strcpy((char *)value, "en");
      }
      uplrules_open();
      int v75 = 0;
      uint64_t v74 = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &v74)) {
        int v24 = uplrules_select();
      }
      else {
        int v24 = 0;
      }
      uplrules_close();
      CFStringRef v6 = 0;
      if (v75 <= 0 && v24 >= 1)
      {
        CFStringRef v25 = CFStringCreateWithCharactersNoCopy(0, (const UniChar *)v77, v24, (CFAllocatorRef)&__kCFAllocatorNull);
        CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, v25);
        CFRelease(v25);
      }
      if (!v6 && v76 == 1)
      {
        if (CFNumberIsFloatType((CFNumberRef)a1))
        {
LABEL_63:
          CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"other");
          if (v6) {
            return (const __CFString *)CFRetain(v6);
          }
          return v6;
        }
        CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"one");
      }
      if (v6) {
        return (const __CFString *)CFRetain(v6);
      }
      goto LABEL_63;
    }
    return 0;
  }
  if (v6 == @"NSStringDirectRuleType" || CFEqual(v6, @"NSStringDirectRuleType"))
  {
    CFTypeID v16 = CFGetTypeID(a1);
    CFTypeID TypeID = CFStringGetTypeID();
    CFStringRef v6 = 0;
    if (!a1 || v16 != TypeID) {
      return v6;
    }
    size_t v18 = a1;
LABEL_25:
    return (const __CFString *)CFRetain(v18);
  }
  if (v6 == @"NSStringGenderRuleType" || CFEqual(v6, @"NSStringGenderRuleType"))
  {
    value[0] = 0;
    CFTypeID v20 = CFGetTypeID(a1);
    CFStringRef v6 = 0;
    if (v20 != CFNumberGetTypeID()) {
      return v6;
    }
    LODWORD(v76) = 0;
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &v76))
    {
      v77[0] = 0;
      v77[1] = 0;
      int v78 = 0;
      if ((v76 & 0x80000000) == 0 && snprintf((char *)v77, 0x14uLL, "%d", v76) >= 1)
      {
        if (LOBYTE(v77[0]))
        {
          CFStringRef v21 = CFStringCreateWithCStringNoCopy(0, (const char *)v77, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
          if (v21)
          {
            if (!CFDictionaryGetValueIfPresent(theDict, v21, (const void **)value)) {
              value[0] = (void *)CFDictionaryGetValue(theDict, @"0");
            }
            CFRelease(v21);
            if (value[0]) {
              return (const __CFString *)CFRetain(value[0]);
            }
          }
        }
      }
    }
    return 0;
  }
  if (v6 == @"NSStringEntityFormattingRuleType" || CFEqual(v6, @"NSStringEntityFormattingRuleType"))
  {
    CFDictionaryRef v26 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSStringFormatFamilyInfoKey");
    CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSStringFormatLocaleInfoKey");
    RelevantLocaleInfoFromLocaleSummary = _CFStringGetRelevantLocaleInfoFromLocaleSummary(v27, (const __CFLocale *)v7);
    CFDictionaryRef v29 = (const __CFDictionary *)CFRetain(RelevantLocaleInfoFromLocaleSummary);
    v77[0] = 0;
    if (CFDictionaryGetValueIfPresent(v29, @"NSStringFormatRuleStartEndInfoKey", v77))
    {
      CFTypeID v30 = CFGetTypeID(a1);
      if (v30 == CFStringGetTypeID())
      {
        v70[0] = off_1ECE0A5A0;
        v70[1] = 3221225472;
        __int16 v71 = ___CFCopyResolvedFormatStringWithConfiguration_block_invoke;
        uint64_t v72 = &__block_descriptor_40_e29__v20__0____CFDictionary__8S16l;
        CFDictionaryRef v73 = v26;
        CFDictionaryRef v31 = (const __CFDictionary *)v77[0];
        uint64_t CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
        CFDictionaryRef v33 = (const __CFDictionary *)v71((uint64_t)v70, v31, CharacterAtIndex);
        CFDictionaryRef v34 = v33;
        if (!v33) {
          goto LABEL_97;
        }
        CFTypeID v35 = CFGetTypeID(v33);
        if (v35 == CFDictionaryGetTypeID())
        {
          CFIndex Length = CFStringGetLength(a1);
          uint64_t v37 = CFStringGetCharacterAtIndex(a1, Length - 1);
          CFDictionaryRef v38 = (const __CFDictionary *)v71((uint64_t)v70, v34, v37);
          CFDictionaryRef v34 = v38;
          if (!v38) {
            goto LABEL_97;
          }
          CFTypeID v39 = CFGetTypeID(v38);
          CFTypeID v40 = CFStringGetTypeID();
          goto LABEL_82;
        }
      }
      else
      {
        CFDictionaryRef v44 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], @"default");
        CFDictionaryRef v34 = v44;
        if (!v44) {
          goto LABEL_97;
        }
        CFTypeID v45 = CFGetTypeID(v44);
        if (v45 == CFDictionaryGetTypeID())
        {
          CFDictionaryRef v46 = (const __CFDictionary *)CFDictionaryGetValue(v34, @"default");
          CFDictionaryRef v34 = v46;
          if (!v46) {
            goto LABEL_97;
          }
          CFTypeID v39 = CFGetTypeID(v46);
          CFTypeID v40 = CFStringGetTypeID();
LABEL_82:
          if (v39 != v40) {
            CFDictionaryRef v34 = 0;
          }
LABEL_97:
          CFTypeID v51 = CFGetTypeID(a1);
          if (v51 == CFStringGetTypeID() && !v34)
          {
            CFDictionaryRef v52 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSStringFormatClassInfoKey");
            value[0] = 0;
            if (CFDictionaryGetValueIfPresent(v29, @"NSStringFormatClassTypeKey", (const void **)value)) {
              unsigned int v53 = CFDictionaryGetValue(v52, value[0]);
            }
            else {
              unsigned int v53 = CFDictionaryGetValue(v29, @"NSStringFormatRuleInfoKey");
            }
            v77[0] = v53;
            unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)v53);
            unint64_t v56 = Count;
            if (Count >> 60)
            {
              CFStringRef v68 = CFStringCreateWithFormat(0, 0, @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt", Count);
              long long v69 = +[NSException exceptionWithName:@"NSGenericException" reason:v68 userInfo:0];
              CFRelease(v68);
              objc_exception_throw(v69);
            }
            if (Count <= 1) {
              unint64_t Count = 1;
            }
            unint64_t v57 = MEMORY[0x1F4188790](Count, v55);
            BOOL v59 = (const void **)((char *)v70 - v58);
            size_t v76 = 0;
            if (v56 >= 0x101)
            {
              BOOL v59 = (const void **)_CFCreateArrayStorage(v57, 0, &v76);
              uint64_t v60 = v59;
            }
            else
            {
              uint64_t v60 = 0;
            }
            CFDictionaryGetKeysAndValues((CFDictionaryRef)v77[0], v59, 0);
            if (v56)
            {
              while (1)
              {
                BOOL v61 = (__CFString *)*v59;
                if (CFStringCompare((CFStringRef)*v59, @"default", 0))
                {
                  CFCharacterSetRef v62 = (const __CFCharacterSet *)CFDictionaryGetValue(v26, v61);
                  if (_CFStringContentsInCharacterSet(a1, v62)) {
                    break;
                  }
                }
                ++v59;
                if (!--v56) {
                  goto LABEL_112;
                }
              }
            }
            else
            {
LABEL_112:
              BOOL v61 = 0;
            }
            if (v61) {
              CFErrorRef v63 = v61;
            }
            else {
              CFErrorRef v63 = @"default";
            }
            CFDictionaryRef v34 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], v63);
            free(v60);
          }
          if (v29) {
            CFRelease(v29);
          }
          if (v34) {
            return (const __CFString *)CFRetain(v34);
          }
          return 0;
        }
      }
    }
    else if (CFDictionaryGetValueIfPresent(v29, @"NSStringConditionalFormatRuleInfoKey", v77))
    {
      CFDictionaryRef v41 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], @"default");
      CFTypeID v42 = CFGetTypeID(a1);
      if (v42 == CFStringGetTypeID() && _CFStringConditionalFormattingMeetsCondition(a1, (CFLocaleRef)v7)) {
        CFDictionaryRef v43 = (const __CFDictionary *)CFDictionaryGetValue(v41, @"NSStringConditionalFormatKey");
      }
      else {
        CFDictionaryRef v43 = (const __CFDictionary *)CFDictionaryGetValue(v41, @"default");
      }
      CFDictionaryRef v34 = v43;
      goto LABEL_97;
    }
    CFDictionaryRef v34 = 0;
    goto LABEL_97;
  }
  if (v6 == @"NSStringAffixRuleType" || CFEqual(v6, @"NSStringAffixRuleType"))
  {
    uint64_t v47 = (__CFString *)CFLocaleGetValue((CFLocaleRef)v7, @"kCFLocaleLanguageCodeKey");
    CFTypeID v48 = CFGetTypeID(a1);
    if (v48 != CFStringGetTypeID()
      || (v47 ? (unint64_t v49 = v47) : (unint64_t v49 = @"en"),
          AffixRuleFormat = _CFStringFindAffixRuleFormat(v49, a1),
          (size_t v18 = CFDictionaryGetValue(theDict, AffixRuleFormat)) == 0))
    {
      size_t v18 = CFDictionaryGetValue(theDict, @"other");
      if (!v18) {
        return 0;
      }
    }
    goto LABEL_25;
  }
  if (v6 != @"NSStringVocativeNameFormattingRuleType"
    && !CFEqual(v6, @"NSStringVocativeNameFormattingRuleType"))
  {
    return 0;
  }
  CFTypeID v64 = CFGetTypeID(a1);
  CFStringRef v6 = a1;
  if (v64 != 7)
  {
    if (_CFCopyResolvedFormatStringWithConfiguration_onceToken != -1) {
      dispatch_once(&_CFCopyResolvedFormatStringWithConfiguration_onceToken, &__block_literal_global_39);
    }
    if (!__NSPersonNameComponentsClass) {
      return 0;
    }
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return 0;
    }
    CFStringRef v6 = (const __CFString *)[(__CFString *)a1 givenName];
    if (CFGetTypeID(v6) != 7) {
      return 0;
    }
  }
  if (!v6) {
    return v6;
  }
  CFStringRef v65 = (const __CFString *)_CFStringCopyVocativeCaseOfGivenName(v6, (CFLocaleRef)v7);
  CFStringRef v6 = v65;
  if (v64 == 7 || !v65) {
    return v6;
  }
  id v66 = (void *)[(__CFString *)a1 copy];
  [v66 setGivenName:v6];
  if (_CFCopyResolvedFormatStringWithConfiguration_onceToken_61 != -1) {
    dispatch_once(&_CFCopyResolvedFormatStringWithConfiguration_onceToken_61, &__block_literal_global_63_0);
  }
  CFRelease(v6);
  uint64_t v67 = objc_msgSend((id)objc_msgSend((id)_CFCopyResolvedFormatStringWithConfiguration_formatter, "stringFromPersonNameComponents:", v66), "copy");
  CFRelease(v66);
  return (const __CFString *)v67;
}

void sub_182C16998(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return (CFArrayRef)_CFBundleCopyBundleLocalizations((uint64_t)bundle, 0);
}

CFDateFormatterRef CFDateFormatterCreateISO8601Formatter(CFAllocatorRef allocator, CFISO8601DateFormatOptions formatOptions)
{
  CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, "en_US_POSIX", 0x8000100u);
  CFLocaleRef v5 = CFLocaleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
  CFDateFormatter = (__CFDateFormatter *)__CreateCFDateFormatter((__objc2_class **)allocator, v5, 0, 0, &__kCFBooleanTrue);
  if (!formatOptions) {
    goto LABEL_64;
  }
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 33);
  CFStringRef v8 = Mutable;
  if ((~(_WORD)formatOptions & 0x773) == 0)
  {
    if ((formatOptions & 0x100) != 0) {
      CFArrayRef v9 = "yyyy-MM-dd";
    }
    else {
      CFArrayRef v9 = "yyyyMMdd";
    }
    CFStringAppendCString(Mutable, v9, 0x8000100u);
    if ((formatOptions & 0x80) != 0) {
      CFArrayRef v10 = " ";
    }
    else {
      CFArrayRef v10 = "'T'";
    }
    CFStringAppendCString(v8, v10, 0x8000100u);
    if ((formatOptions & 0x200) != 0) {
      CFArrayRef v11 = "HH:mm:ss";
    }
    else {
      CFArrayRef v11 = "HHmmss";
    }
    CFStringAppendCString(v8, v11, 0x8000100u);
    if ((formatOptions & 0x800) != 0) {
      CFStringAppendCString(v8, ".SSS", 0x8000100u);
    }
    if ((formatOptions & 0x400) != 0) {
      CFStringRef v12 = "XXXXX";
    }
    else {
      CFStringRef v12 = "XXXX";
    }
    CFStringAppendCString(v8, v12, 0x8000100u);
    goto LABEL_62;
  }
  if (formatOptions)
  {
    int v13 = 0;
    int v14 = 0;
    if ((formatOptions & 0x400) != 0) {
      size_t v15 = "XXXXX";
    }
    else {
      size_t v15 = "XXXX";
    }
    if ((formatOptions & 0x80) != 0) {
      CFTypeID v16 = " ";
    }
    else {
      CFTypeID v16 = "'T'";
    }
    CFStringRef v17 = "HH:mm:ss";
    if ((formatOptions & 0x200) == 0) {
      CFStringRef v17 = "HHmmss";
    }
    cStr = (char *)v16;
    int v24 = (char *)v17;
    size_t v18 = "dd";
    if ((formatOptions & 2) == 0) {
      size_t v18 = "DDD";
    }
    if ((formatOptions & 4) != 0) {
      size_t v18 = "ee";
    }
    CFStringRef v25 = v18;
    if ((formatOptions & 4) != 0) {
      CFStringRef v19 = "YYYY";
    }
    else {
      CFStringRef v19 = "yyyy";
    }
    do
    {
      CFIndex Length = CFStringGetLength(v8);
      if (v14 > 15)
      {
        if (v14 != 16)
        {
          if (v14 == 32)
          {
            if ((formatOptions & 0x20) == 0) {
              goto LABEL_61;
            }
            if (Length >= 1) {
              CFStringAppendCString(v8, cStr, 0x8000100u);
            }
            CFStringAppendCString(v8, v24, 0x8000100u);
            CFStringRef v21 = ".SSS";
            if ((formatOptions & 0x800) == 0) {
              goto LABEL_61;
            }
          }
          else
          {
            if (v14 != 64) {
              goto LABEL_61;
            }
            CFStringRef v21 = v15;
            if ((formatOptions & 0x40) == 0) {
              goto LABEL_61;
            }
          }
          goto LABEL_60;
        }
        if ((formatOptions & 0x10) != 0)
        {
          CFStringRef v21 = v25;
          if ((formatOptions & 0x100) != 0)
          {
            CFStringRef v21 = v25;
            goto LABEL_54;
          }
          goto LABEL_60;
        }
      }
      else
      {
        if (v14 == 1)
        {
          CFStringRef v21 = v19;
          if ((formatOptions & 1) == 0) {
            goto LABEL_61;
          }
          goto LABEL_60;
        }
        if (v14 != 2)
        {
          if (v14 != 4 || (formatOptions & 4) == 0) {
            goto LABEL_61;
          }
          CFStringRef v21 = "'W'ww";
          if ((formatOptions & 0x100) == 0) {
            goto LABEL_60;
          }
LABEL_54:
          if (Length >= 1) {
            CFStringAppendCString(v8, "-", 0x8000100u);
          }
LABEL_60:
          CFStringAppendCString(v8, v21, 0x8000100u);
          goto LABEL_61;
        }
        if ((formatOptions & 2) != 0)
        {
          CFStringRef v21 = "MM";
          if ((formatOptions & 0x100) != 0) {
            goto LABEL_54;
          }
          goto LABEL_60;
        }
      }
LABEL_61:
      int v14 = 1 << v13++;
    }
    while (v14 < formatOptions);
  }
LABEL_62:
  if (v8)
  {
    CFDateFormatterSetFormat(CFDateFormatter, v8);
    CFRelease(v8);
  }
LABEL_64:
  CFRelease(v4);
  CFRelease(v5);
  return CFDateFormatter;
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  char v3 = atomic_load((unint64_t *)&theString->info);
  if (v3)
  {
    uint64_t v12 = *(void *)&encoding;
    size_t v15 = strlen(cStr);
    __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)cStr, v15, v12);
  }
  else
  {
    CFStringRef v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringAppendCString_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  if (localeIdentifier) {
    return (CFLocaleRef)+[NSLocale _newLocaleWithIdentifier:localeIdentifier];
  }
  else {
    return 0;
  }
}

uint64_t __CreateCFDateFormatter(__objc2_class **a1, const __CFLocale *a2, unint64_t a3, unint64_t a4, __objc2_class **a5)
{
  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1) {
      a1 = &__kCFAllocatorSystemDefault;
    }
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x38uLL, 512, 0);
  uint64_t v10 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 32) = a4;
    *(void *)(Instance + 40) = a3;
    if (a3 >= 5) {
      *(void *)(Instance + 40) = 2;
    }
    if (a4 >= 5) {
      *(void *)(Instance + 32) = 2;
    }
    if (a2) {
      Systeuint64_t m = a2;
    }
    else {
      Systeuint64_t m = CFLocaleGetSystem();
    }
    *(void *)(v10 + 24) = CFRetain(System);
    if (&__kCFBooleanTrue == a5)
    {
      uint64_t v12 = CFCalendarCreateWithIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"gregorian");
      CFCalendarSetFirstWeekday(v12, 2);
      CFCalendarSetMinimumDaysInFirstWeek(v12, 4);
      *(void *)(v10 + 96) = v12;
    }
    *(void *)(v10 + 88) = CFTimeZoneCopyDefault();
    CFTypeRef Value = CFLocaleGetValue(*(CFLocaleRef *)(v10 + 24), @"calendar");
    if (Value && CFEqual(Value, @"gregorian")) {
      *(void *)(v10 + 112) = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, -1609459200.0);
    }
    __ResetUDateFormat(v10, 0);
    if (!*(void *)(v10 + 16))
    {
      CFRelease((CFTypeRef)v10);
      return 0;
    }
  }
  return v10;
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)+[NSLocale _system];
}

CFTimeZoneRef CFTimeZoneCopyDefault(void)
{
  CFPropertyListRef v0 = (void *)_CFAutoreleasePoolPush();
  BOOL v1 = +[NSTimeZone defaultTimeZone];
  if (v1) {
    CFTimeZoneRef v2 = (const __CFTimeZone *)CFRetain(v1);
  }
  else {
    CFTimeZoneRef v2 = 0;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
  v14[1] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v4);
  }
  CFStringRef ForcedString = (const __CFString *)__CFDateFormatterCreateForcedString(formatter, formatString);
  CFIndex Length = CFStringGetLength(ForcedString);
  if (*((const __CFString **)formatter + 6) != ForcedString)
  {
    CFIndex v8 = Length;
    if (Length <= 1024)
    {
      if (*((__objc2_class ***)formatter + 10) != &__kCFBooleanTrue
        && *((__objc2_class ***)formatter + 9) == &__kCFBooleanTrue)
      {
        __ResetUDateFormat((uint64_t)formatter, 1);
      }
      unint64_t v9 = 2 * v8;
      if ((unint64_t)(2 * v8) < 0x101)
      {
        if (v8 < 1)
        {
          uint64_t v10 = 0;
        }
        else
        {
          MEMORY[0x1F4188790](Length, v7);
          uint64_t v10 = (char *)v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v10, 2 * v8);
        }
      }
      else
      {
        uint64_t v10 = (char *)malloc_type_malloc(2 * v8, 0x1000040BDFB0063uLL);
      }
      CFStringRef CharactersPtr = (UChar *)CFStringGetCharactersPtr(ForcedString);
      if (!CharactersPtr)
      {
        v15.CFIndex location = 0;
        v15.CFIndex length = v8;
        CFStringGetCharacters(ForcedString, v15, (UniChar *)v10);
        CFStringRef CharactersPtr = (UChar *)v10;
      }
      __cficu_udat_applyPattern(*((void *)formatter + 2), 0, CharactersPtr, v8);
      uint64_t v12 = (const void *)*((void *)formatter + 6);
      if (v12) {
        CFRelease(v12);
      }
      CFAllocatorRef v13 = CFGetAllocator(formatter);
      *((void *)formatter + 6) = CFStringCreateCopy(v13, ForcedString);
      *((void *)formatter + 10) = &__kCFBooleanTrue;
      if (v9 >= 0x101) {
        free(v10);
      }
    }
  }
  if (ForcedString) {
    CFRelease(ForcedString);
  }
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)+[NSCalendar _newCalendarWithIdentifier:identifier];
}

void CFCalendarSetMinimumDaysInFirstWeek(CFCalendarRef calendar, CFIndex mwd)
{
}

void CFCalendarSetFirstWeekday(CFCalendarRef calendar, CFIndex wkdy)
{
}

void __CFURLCopyParameterString_block_invoke_30(uint64_t a1)
{
  CFTimeZoneRef v2 = _CFOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
    __CFURLCopyParameterString_block_invoke_30_cold_1(a1, v2);
  }
}

uint64_t _CFOSLog()
{
  if (_CFOSLog_onceToken != -1) {
    dispatch_once(&_CFOSLog_onceToken, &__block_literal_global_24);
  }
  return _CFOSLog_logger;
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  if (prefArray)
  {
    return _CFBundleCopyLocalizationsForPreferences(locArray, prefArray, 0);
  }
  else
  {
    CFArrayRef v4 = (const __CFArray *)_CFBundleCopyUserLanguages();
    if (!v4) {
      CFArrayRef v4 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
    }
    uint64_t v5 = _CFBundleCopyLocalizationsForPreferences(locArray, v4, 0);
    CFRelease(v4);
    return v5;
  }
}

CFArrayRef CFBundleCopyPreferredLocalizationsFromArray(CFArrayRef locArray)
{
  CFArrayRef v2 = (const __CFArray *)_CFBundleCopyUserLanguages();
  if (!v2) {
    CFArrayRef v2 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  }
  char v3 = _CFBundleCopyLocalizationsForPreferences(locArray, v2, 1);
  CFRelease(v2);
  return v3;
}

CFTypeRef _CFBundleCopyUserLanguages()
{
  os_unfair_lock_lock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  CFPropertyListRef v0 = (const void *)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages) {
    goto LABEL_15;
  }
  CFPropertyListRef v1 = CFPreferencesCopyAppValue(@"AppleLanguages", @"kCFPreferencesCurrentApplication");
  if (!v1) {
    CFPropertyListRef v1 = CFPreferencesCopyAppValue(@"NSLanguages", @"kCFPreferencesCurrentApplication");
  }
  CFTypeRef v2 = (CFTypeRef)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = v1 == 0;
  }
  if (!v3)
  {
    CFTypeRef v2 = CFRetain(v1);
    _CFBundleUserLanguages = (uint64_t)v2;
  }
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
      CFRelease((CFTypeRef)_CFBundleUserLanguages);
      _CFBundleUserLanguages = 0;
    }
  }
  if (v1) {
    CFRelease(v1);
  }
  CFPropertyListRef v0 = (const void *)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages) {
LABEL_15:
  }
    CFTypeRef v5 = CFRetain(v0);
  else {
    CFTypeRef v5 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  return v5;
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)_CFPreferencesCopyAppValueWithContainerAndConfiguration((uint64_t)key, (uint64_t)applicationID, 0, 0);
}

uint64_t _CFURLFileCacheSetPropertyValueForKey()
{
  return MEMORY[0x1F4114FC8]();
}

uint64_t _CFBagFastEnumeration(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (CF_IS_OBJC(4uLL, a1)) {
    return 0;
  }

  return __CFBasicHashFastEnumeration(a1, a2, a3, a4);
}

void sub_182C17C2C(_Unwind_Exception *exception_object)
{
}

void sub_182C17FF0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C182DC(_Unwind_Exception *exception_object)
{
}

void sub_182C1859C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C18980(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

id __NSOrderedSetGetIndexesPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v53 = *(void *)off_1ECE0A5B0;
  if (![a1 count]
    || ((a3 & 0x1000000000000000) != 0
      ? (uint64_t v7 = [a4 firstIndex], v38 = objc_msgSend(a4, "lastIndex"))
      : (uint64_t v7 = 0, v38 = [a1 count] - 1),
        v7 == 0x7FFFFFFFFFFFFFFFLL || v38 == 0x7FFFFFFFFFFFFFFFLL))
  {
    __CFLookUpClass("NSIndexSet");
    unint64_t v9 = objc_opt_new();
    return v9;
  }
  else
  {
    if (a3)
    {
      uint64_t v8 = __CFActiveProcessorCount();
      if (v8 < 2) {
        a3 &= ~1uLL;
      }
    }
    else
    {
      uint64_t v8 = 1;
    }
    __CFLookUpClass("NSMutableIndexSet");
    uint64_t v37 = objc_opt_new();
    if ((a3 & 3) != 0)
    {
      unint64_t v11 = (v38 - v7 + 1) / v8 / v8;
      if (v11 >= 0x10)
      {
        if (v11 <= 0x1000) {
          unint64_t v12 = (v11 + 15) & 0xFFFFFFFFFFFFFFF0;
        }
        else {
          unint64_t v12 = 4096;
        }
      }
      else
      {
        unint64_t v12 = 16;
      }
      unint64_t v21 = v12 + v38 - v7;
      size_t v22 = v21 / v12;
      if (a3)
      {
        v41[0] = 0;
        v41[1] = v41;
        CFTypeRef v41[2] = 0x2020000000;
        char v42 = 0;
        long long v46 = 0u;
        long long v45 = 0u;
        long long v44 = 0u;
        uint64_t v47 = 0;
        uint64_t v43 = 850045857;
        block[0] = off_1ECE0A5A0;
        block[1] = 3221225472;
        void block[2] = ____NSOrderedSetGetIndexesPassingTest_block_invoke;
        block[3] = &unk_1ECDB0788;
        void block[8] = v41;
        block[9] = v7;
        void block[10] = v12;
        block[11] = v38;
        block[4] = a1;
        void block[5] = a4;
        block[6] = v37;
        block[7] = a2;
        block[12] = a3;
        void block[13] = &v43;
        dispatch_apply(v22, 0, block);
        _Block_object_dispose(v41, 8);
      }
      else
      {
        uint64_t v36 = a1;
        if (v12 <= v21)
        {
          unint64_t v23 = v7;
          uint64_t v24 = 0;
          unint64_t v25 = v12 - 1;
          if (v22 <= 1) {
            uint64_t v26 = 1;
          }
          else {
            uint64_t v26 = v21 / v12;
          }
          uint64_t v27 = v26 - 1;
          unint64_t v28 = v23;
          unint64_t v29 = v38;
          do
          {
            uint64_t v30 = v27;
            if ((a3 & 2) != 0)
            {
              if (v25 >= v29 - v23) {
                unint64_t v32 = v23;
              }
              else {
                unint64_t v32 = 1 - v12 + v29;
              }
              unint64_t v31 = v29;
            }
            else
            {
              if (v25 >= v29 - v23) {
                unint64_t v31 = v38;
              }
              else {
                unint64_t v31 = v25 + v24 * v12 + v23;
              }
              unint64_t v32 = v28;
            }
            if (__NSOrderedSetChunkIterate(v36, a3, v32, v31, a4, a2, 0, v37, 0)) {
              break;
            }
            ++v24;
            uint64_t v27 = v30 - 1;
            v29 -= v12;
            v28 += v12;
          }
          while (v30);
        }
      }
    }
    else
    {
      CFTypeRef context = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v43) = 0;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      uint64_t v13 = [a1 countByEnumeratingWithState:&v49 objects:v48 count:16];
      if (v13)
      {
        uint64_t v14 = v13;
        unint64_t v35 = v7;
        unint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = *(void *)v50;
        do
        {
          for (uint64_t i = 0; i != v14; ++i)
          {
            if (*(void *)v50 != v17) {
              objc_enumerationMutation(a1);
            }
            unint64_t v19 = v16 + i;
            uint64_t v20 = *(void *)(*((void *)&v49 + 1) + 8 * i);
            if ((a3 & 0x1000000000000000) == 0
              || v35 <= v19 && v19 <= v38 && [a4 containsIndex:v16 + i])
            {
              if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(a2 + 16))(a2, v20, v16 + i, &v43))
              {
                [v37 addIndex:v16 + i];
              }
              if ((_BYTE)v43) {
                goto LABEL_35;
              }
              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                CFTypeRef context = (void *)_CFAutoreleasePoolPush();
                unint64_t v15 = 0;
              }
              else
              {
                ++v15;
              }
            }
          }
          uint64_t v14 = [a1 countByEnumeratingWithState:&v49 objects:v48 count:16];
          v16 += i;
        }
        while (v14);
      }
LABEL_35:
      _CFAutoreleasePoolPop(context);
    }
    id v33 = (id)[v37 copy];

    return v33;
  }
}

uint64_t __CFActiveProcessorCount()
{
  return MEMORY[0xFFFFFC034];
}

unint64_t __NSArrayGetIndexPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v50 = *(void *)off_1ECE0A5B0;
  if (![a1 count]) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((a3 & 0x1000000000000000) != 0)
  {
    uint64_t v7 = [a4 firstIndex];
    unint64_t v36 = [a4 lastIndex];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v36 = [a1 count] - 1;
  }
  unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL && v36 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3)
    {
      uint64_t v9 = __CFActiveProcessorCount();
      if (v9 < 2) {
        a3 &= ~1uLL;
      }
    }
    else
    {
      uint64_t v9 = 1;
    }
    if ((a3 & 3) != 0)
    {
      unint64_t v10 = (v36 - v7 + 1) / v9 / v9;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000) {
          unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
        }
        else {
          unint64_t v11 = 4096;
        }
      }
      else
      {
        unint64_t v11 = 16;
      }
      unint64_t v20 = v11 + v36 - v7;
      if (a3)
      {
        unint64_t v41 = 0;
        char v42 = &v41;
        uint64_t v43 = 0x2020000000;
        uint64_t v44 = 0x7FFFFFFFFFFFFFFFLL;
        v39[0] = 0;
        v39[1] = v39;
        v39[2] = 0x2020000000;
        char v40 = 0;
        block[0] = off_1ECE0A5A0;
        block[1] = 3221225472;
        void block[2] = ____NSArrayGetIndexPassingTest_block_invoke;
        block[3] = &unk_1ECDB0760;
        void block[10] = v11;
        block[11] = v36;
        block[12] = a3;
        block[4] = a1;
        void block[5] = a4;
        block[7] = v39;
        void block[8] = &v41;
        block[6] = a2;
        block[9] = v7;
        dispatch_apply(v20 / v11, 0, block);
        unint64_t v8 = atomic_load(v42 + 3);
        _Block_object_dispose(v39, 8);
        _Block_object_dispose(&v41, 8);
      }
      else
      {
        contexta = a4;
        unint64_t v35 = a1;
        unint64_t v41 = 0x7FFFFFFFFFFFFFFFLL;
        if (v11 <= v20)
        {
          unint64_t v21 = v7;
          uint64_t v22 = 0;
          unint64_t v23 = v11 - 1;
          unint64_t v24 = 1;
          unint64_t v25 = v21;
          unint64_t v26 = v36;
          unint64_t v27 = v20 / v11;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v23 >= v26 - v21) {
                unint64_t v29 = v21;
              }
              else {
                unint64_t v29 = 1 - v11 + v26;
              }
              unint64_t v28 = v26;
            }
            else
            {
              if (v23 >= v26 - v21) {
                unint64_t v28 = v36;
              }
              else {
                unint64_t v28 = v23 + v22 * v11 + v21;
              }
              unint64_t v29 = v25;
            }
            BOOL v30 = __NSArrayChunkIterate(v35, a3, v29, v28, contexta, a2, &v41, 0, 0);
            if (v24 >= v27) {
              break;
            }
            ++v22;
            v26 -= v11;
            v25 += v11;
            ++v24;
          }
          while (!v30);
        }
        return atomic_load(&v41);
      }
    }
    else
    {
      unint64_t v12 = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v41) = 0;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      uint64_t v13 = [a1 countByEnumeratingWithState:&v46 objects:v45 count:16];
      if (v13)
      {
        uint64_t v14 = v13;
        CFTypeRef context = v12;
        unint64_t v34 = v7;
        unint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = *(void *)v47;
        while (2)
        {
          for (uint64_t i = 0; i != v14; ++i)
          {
            if (*(void *)v47 != v17) {
              objc_enumerationMutation(a1);
            }
            unint64_t v19 = v16 + i;
            if ((a3 & 0x1000000000000000) == 0
              || v34 <= v19 && v19 <= v36 && [a4 containsIndex:v16 + i])
            {
              if (__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(a2))
              {
                unint64_t v8 = v16 + i;
                goto LABEL_51;
              }
              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                CFTypeRef context = (void *)_CFAutoreleasePoolPush();
                unint64_t v15 = 0;
              }
              else
              {
                ++v15;
              }
            }
          }
          uint64_t v14 = [a1 countByEnumeratingWithState:&v46 objects:v45 count:16];
          v16 += i;
          if (v14) {
            continue;
          }
          break;
        }
        unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_51:
        unint64_t v12 = context;
      }
      _CFAutoreleasePoolPop(v12);
    }
  }
  return v8;
}

id __NSArrayGetIndexesPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v52 = *(void *)off_1ECE0A5B0;
  if (![a1 count]
    || ((a3 & 0x1000000000000000) != 0
      ? (unint64_t v7 = [a4 firstIndex], v37 = objc_msgSend(a4, "lastIndex"))
      : (unint64_t v7 = 0, v37 = [a1 count] - 1),
        v7 == 0x7FFFFFFFFFFFFFFFLL || v37 == 0x7FFFFFFFFFFFFFFFLL))
  {
    __CFLookUpClass("NSIndexSet");
    uint64_t v9 = objc_opt_new();
    return v9;
  }
  else
  {
    if (a3)
    {
      uint64_t v8 = __CFActiveProcessorCount();
      if (v8 < 2) {
        a3 &= ~1uLL;
      }
    }
    else
    {
      uint64_t v8 = 1;
    }
    __CFLookUpClass("NSMutableIndexSet");
    unint64_t v36 = objc_opt_new();
    if ((a3 & 3) != 0)
    {
      unint64_t v11 = (v37 - v7 + 1) / v8 / v8;
      if (v11 >= 0x10)
      {
        if (v11 <= 0x1000) {
          unint64_t v12 = (v11 + 15) & 0xFFFFFFFFFFFFFFF0;
        }
        else {
          unint64_t v12 = 4096;
        }
      }
      else
      {
        unint64_t v12 = 16;
      }
      unint64_t v20 = v12 + v37 - v7;
      if (a3)
      {
        long long v45 = 0u;
        long long v44 = 0u;
        long long v43 = 0u;
        uint64_t v46 = 0;
        uint64_t v42 = 850045857;
        v40[0] = 0;
        v40[1] = v40;
        v40[2] = 0x2020000000;
        char v41 = 0;
        block[0] = off_1ECE0A5A0;
        block[1] = 3221225472;
        void block[2] = ____NSArrayGetIndexesPassingTest_block_invoke;
        block[3] = &unk_1ECDB0788;
        void block[8] = v40;
        block[9] = v7;
        void block[10] = v12;
        block[11] = v37;
        block[4] = a1;
        void block[5] = a4;
        block[6] = v36;
        block[7] = a2;
        block[12] = a3;
        void block[13] = &v42;
        dispatch_apply(v20 / v12, 0, block);
        _Block_object_dispose(v40, 8);
      }
      else
      {
        contexta = a1;
        unint64_t v35 = a4;
        if (v12 <= v20)
        {
          unint64_t v21 = v7;
          uint64_t v22 = 0;
          unint64_t v23 = v12 - 1;
          unint64_t v24 = 1;
          uint64_t v25 = -(uint64_t)v7;
          unint64_t v26 = v37;
          unint64_t v27 = v20 / v12;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v23 >= v25 + v26) {
                unint64_t v29 = v21;
              }
              else {
                unint64_t v29 = 1 - v12 + v26;
              }
              unint64_t v28 = v26;
            }
            else
            {
              if (v23 >= v25 + v26) {
                unint64_t v28 = v37;
              }
              else {
                unint64_t v28 = v23 + v22 * v12 + v21;
              }
              unint64_t v29 = v7;
            }
            BOOL v30 = __NSArrayChunkIterate(contexta, a3, v29, v28, v35, a2, 0, v36, 0);
            if (v24 >= v27) {
              break;
            }
            ++v22;
            v26 -= v12;
            v7 += v12;
            ++v24;
          }
          while (!v30);
        }
      }
    }
    else
    {
      CFTypeRef context = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v42) = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      uint64_t v13 = [a1 countByEnumeratingWithState:&v48 objects:v47 count:16];
      if (v13)
      {
        uint64_t v14 = v13;
        unint64_t v34 = a4;
        unint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = *(void *)v49;
        do
        {
          for (uint64_t i = 0; i != v14; ++i)
          {
            if (*(void *)v49 != v17) {
              objc_enumerationMutation(a1);
            }
            unint64_t v19 = v16 + i;
            if ((a3 & 0x1000000000000000) == 0
              || v7 <= v19 && v19 <= v37 && [v34 containsIndex:v16 + i])
            {
              if (__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(a2)) {
                [v36 addIndex:v16 + i];
              }
              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                CFTypeRef context = (void *)_CFAutoreleasePoolPush();
                unint64_t v15 = 0;
              }
              else
              {
                ++v15;
              }
            }
          }
          uint64_t v14 = [a1 countByEnumeratingWithState:&v48 objects:v47 count:16];
          v16 += i;
        }
        while (v14);
      }
      _CFAutoreleasePoolPop(context);
    }
    id v31 = (id)[v36 copy];

    return v31;
  }
}

uint64_t __NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

Class __CFLookUpClass(const char *a1)
{
  Class result = objc_lookUpClass(a1);
  if (!result)
  {
    if (!dlopen("/System/Library/Frameworks/Foundation.framework/Foundation", 5))
    {
      dlerror();
      CFLog(3, @"*** Error: Could not load Foundation for class %s; error is '%s'; if this seems unreasonable, perhaps seatbelt has prevented the load due to file access limitations on the process");
    }
    Class result = objc_lookUpClass(a1);
    if (!result)
    {
      if (!strcmp(a1, "NSString") || !strcmp(a1, "NSMutableString"))
      {
        BOOL v3 = (objc_class *)self;
        ClassPair = objc_allocateClassPair(v3, "NSString", 0x20uLL);
        objc_registerClassPair(ClassPair);
        CFTypeRef v5 = objc_allocateClassPair(ClassPair, "NSMutableString", 0x20uLL);
        objc_registerClassPair(v5);
        return objc_lookUpClass(a1);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

BOOL __NSArrayChunkIterate(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, void *a5, uint64_t a6, unint64_t *a7, void *a8, pthread_mutex_t *a9)
{
  id v39 = a8;
  uint64_t v41 = a6;
  uint64_t v44 = *(void *)off_1ECE0A5B0;
  char v43 = 0;
  uint64_t v42 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v14 = (unint64_t *)&v42;
  if (a7) {
    uint64_t v14 = a7;
  }
  char v40 = v14;
  if ((a2 & 0x2000000000000000) != 0)
  {
    unint64_t v15 = atomic_load(v40);
    if (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v16 = v15 >= a3;
      BOOL v17 = v15 <= a4;
      if ((a2 & 2) != 0) {
        BOOL v16 = v17;
      }
      if (!v16) {
        return 0;
      }
    }
  }
  unint64_t v36 = (void *)_CFAutoreleasePoolPush();
  unint64_t v37 = &v35;
  uint64_t v19 = MEMORY[0x1F4188790](v36, v18);
  unint64_t v21 = (char *)&v35 - v20;
  MEMORY[0x1F4188790](v19, v22);
  unint64_t v24 = (char *)&v35 - v23;
  if ((a2 & 0x1000000000000000) != 0
    && !objc_msgSend(a5, "__getContainmentVector:inRange:", (char *)&v35 - v23, a3, a4 - a3 + 1))
  {
    goto LABEL_41;
  }
  objc_msgSend(a1, "getObjects:range:", v21, a3, a4 - a3 + 1);
  if (a4 - a3 == -1) {
    goto LABEL_41;
  }
  uint64_t v25 = 0;
  unint64_t v38 = a9;
  while (1)
  {
    uint64_t v26 = a4 - a3 - v25;
    if ((a2 & 2) == 0) {
      uint64_t v26 = v25;
    }
    if ((a2 & 0x1000000000000000) != 0 && !v24[v26]) {
      goto LABEL_32;
    }
    if ((a2 & 2) != 0) {
      unint64_t v27 = a4 - v25;
    }
    else {
      unint64_t v27 = v25 + a3;
    }
    if ((a2 & 0x6000000000000000) == 0)
    {
      __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(v41);
      goto LABEL_26;
    }
    if (__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(v41)) {
      break;
    }
LABEL_26:
    if (v43) {
      goto LABEL_41;
    }
    if ((a2 & 0x2000000000000000) != 0)
    {
      unint64_t v28 = atomic_load(v40);
      if (v28 != 0x7FFFFFFFFFFFFFFFLL)
      {
        BOOL v29 = v28 >= a3;
        BOOL v30 = v28 <= a4;
        if ((a2 & 2) == 0) {
          BOOL v30 = v29;
        }
        if (!v30) {
          goto LABEL_41;
        }
      }
    }
LABEL_32:
    if (++v25 >= a4 - a3 + 1) {
      goto LABEL_41;
    }
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((a2 & 0x4000000000000000) != 0)
    {
      if (v38)
      {
        pthread_mutex_lock(v38);
        [v39 addIndex:v27];
        pthread_mutex_unlock(v38);
      }
      else
      {
        [v39 addIndex:v27];
      }
    }
    goto LABEL_26;
  }
  do
  {
    unint64_t v32 = atomic_load(v40);
    if (v32 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v33 = v32 < v27;
      if ((a2 & 2) == 0) {
        BOOL v33 = v27 < v32;
      }
      if (!v33) {
        break;
      }
    }
    unint64_t v34 = v32;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v40, &v34, v27, memory_order_relaxed, memory_order_relaxed);
  }
  while (v34 != v32);
LABEL_41:
  _CFAutoreleasePoolPop(v36);
  return v43 != 0;
}

CFArrayRef _copyBundleLocalizationsFromResources(__CFBundle *a1, uint64_t a2)
{
  v50[1] = *(const void **)off_1ECE0A5B0;
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(a1);
  if (InfoDictionary)
  {
    CFDictionaryRef v5 = InfoDictionary;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, @"CFBundleLocalizations");
    if (Value && (CFArrayRef v7 = Value, v8 = CFGetTypeID(Value), v8 == CFArrayGetTypeID()))
    {
      CFAllocatorRef v9 = CFGetAllocator(a1);
      CFIndex Count = CFArrayGetCount(v7);
      CFDictionaryRef Mutable = CFArrayCreateMutable(v9, Count, &kCFTypeArrayCallBacks);
      if (CFArrayGetCount(v7) >= 1)
      {
        CFIndex v12 = 0;
        do
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v12);
          CFTypeID v14 = CFGetTypeID(ValueAtIndex);
          if (v14 == CFStringGetTypeID() && CFStringGetLength(ValueAtIndex) >= 1) {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          ++v12;
        }
        while (v12 < CFArrayGetCount(v7));
      }
      CFAllocatorRef v15 = CFGetAllocator(a1);
      CFArrayRef Copy = CFArrayCreateCopy(v15, Mutable);
      CFRelease(Mutable);
    }
    else
    {
      CFArrayRef Copy = (const __CFArray *)_copyAppleLocalizations(v5);
    }
  }
  else
  {
    CFArrayRef Copy = 0;
  }
  CFURLRef v17 = CFBundleCopyResourcesDirectoryURL(a1);
  if (v17)
  {
    CFURLRef v18 = v17;
    CFAllocatorRef v19 = CFGetAllocator(a1);
    uint64_t v20 = _CFBundleCopyLProjDirectoriesForURL((uint64_t)v19, v18);
    if (v20)
    {
      CFArrayRef v21 = (const __CFArray *)v20;
      if (Copy)
      {
        MutableCFArrayRef Copy = CFArrayCreateMutableCopy(0, 0, Copy);
        CFRelease(Copy);
        v59.CFIndex length = CFArrayGetCount(v21);
        v59.CFIndex location = 0;
        CFArrayAppendArray(MutableCopy, v21, v59);
        CFRelease(v21);
        CFArrayRef Copy = MutableCopy;
      }
      else
      {
        CFArrayRef Copy = (const __CFArray *)v20;
      }
    }
    CFRelease(v18);
  }
  DevelopmentRegiouint64_t n = CFBundleGetDevelopmentRegion(a1);
  CFStringRef v24 = DevelopmentRegion;
  v50[0] = DevelopmentRegion;
  if (Copy)
  {
    if (DevelopmentRegion)
    {
      CFIndex v25 = CFArrayGetCount(Copy);
      if (a2 != 1)
      {
        if (a2) {
          return Copy;
        }
        if (dyld_program_sdk_at_least()) {
          goto LABEL_25;
        }
      }
      v52.CFIndex location = 0;
      v52.CFIndex length = v25;
      if (CFArrayContainsValue(Copy, v52, @"Base"))
      {
LABEL_25:
        uint64_t v26 = CFArrayGetCount(Copy);
        v53.CFIndex location = 0;
        v53.CFIndex length = v26;
        if (CFArrayContainsValue(Copy, v53, v24))
        {
          CFStringRef v27 = v24;
        }
        else
        {
          AlternateNameForint Language = _CFBundleGetAlternateNameForLanguage(v24);
          if (AlternateNameForLanguage
            && (unint64_t v32 = AlternateNameForLanguage,
                v54.CFIndex location = 0,
                v54.CFIndex length = v26,
                CFArrayContainsValue(Copy, v54, AlternateNameForLanguage)))
          {
            CFStringRef v27 = v32;
          }
          else
          {
            CFIndex Length = CFStringGetLength(v24);
            if (Length >= 4)
            {
              CFIndex v34 = Length;
              int CharacterAtIndex = CFStringGetCharacterAtIndex(v24, 2);
              int v36 = CharacterAtIndex;
              if (CharacterAtIndex == 95 || CharacterAtIndex == 45)
              {
                unint64_t v37 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v24);
                CFTypeRef v28 = v37;
                CFStringRef v38 = v36 == 45 ? @"_" : @"-";
                v55.CFIndex location = 2;
                v55.CFIndex length = 1;
                CFStringReplace(v37, v55, v38);
                if (v28)
                {
                  v56.CFIndex location = 0;
                  v56.CFIndex length = v26;
                  if (CFArrayContainsValue(Copy, v56, v28)) {
                    goto LABEL_28;
                  }
                  CFRelease(v28);
                }
              }
            }
            if (CFArrayGetCount(Copy) < 1) {
              goto LABEL_56;
            }
            CFIndex v39 = 0;
            while (1)
            {
              CFStringRef v40 = (const __CFString *)CFArrayGetValueAtIndex(Copy, v39);
              uint64_t v41 = _CFBundleGetAlternateNameForLanguage(v24);
              uint64_t v42 = _CFBundleGetAlternateNameForLanguage(v40);
              if (_CFBundleIsLanguageDefaultLanguageOfOther(v24, v40)
                || _CFBundleIsLanguageDefaultLanguageOfOther(v41, v40)
                || _CFBundleIsLanguageDefaultLanguageOfOther(v24, v42))
              {
                break;
              }
              if (++v39 >= CFArrayGetCount(Copy)) {
                goto LABEL_56;
              }
            }
            if (v40 && (v57.location = 0, v57.CFIndex length = v26, CFArrayContainsValue(Copy, v57, v40)))
            {
              CFStringRef v27 = v40;
            }
            else
            {
LABEL_56:
              CFLocaleIdentifier CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v24);
              if (!CanonicalLanguageIdentifierFromString) {
                goto LABEL_64;
              }
              CFTypeRef v28 = CanonicalLanguageIdentifierFromString;
              v58.CFIndex location = 0;
              v58.CFIndex length = v26;
              if (CFArrayContainsValue(Copy, v58, CanonicalLanguageIdentifierFromString)) {
                goto LABEL_28;
              }
              if (v26 < 1)
              {
LABEL_63:
                CFRelease(v28);
                goto LABEL_64;
              }
              CFIndex v44 = 0;
              while (1)
              {
                CFStringRef v45 = (const __CFString *)CFArrayGetValueAtIndex(Copy, v44);
                CFLocaleIdentifier v46 = CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45);
                if (v46)
                {
                  CFLocaleIdentifier v47 = v46;
                  int v48 = CFEqual(v46, v28);
                  CFRelease(v47);
                  if (v48) {
                    break;
                  }
                }
                if (v26 == ++v44) {
                  goto LABEL_63;
                }
              }
              CFRelease(v28);
              CFStringRef v27 = v45;
            }
          }
        }
        CFTypeRef v28 = CFRetain(v27);
        if (v28)
        {
LABEL_28:
          CFRelease(v28);
          return Copy;
        }
LABEL_64:
        long long v49 = CFArrayCreateMutableCopy(0, 0, Copy);
        CFRelease(Copy);
        CFArrayAppendValue(v49, v24);
        return v49;
      }
    }
    return Copy;
  }
  CFAllocatorRef v29 = CFGetAllocator(a1);
  if (v24) {
    return CFArrayCreate(v29, v50, 1, &kCFTypeArrayCallBacks);
  }

  return CFArrayCreate(v29, 0, 0, &kCFTypeArrayCallBacks);
}

BOOL _CFBundleIsLanguageDefaultLanguageOfOther(const void *a1, const void *a2)
{
  BOOL v2 = 0;
  if (a1 && a2)
  {
    CFStringRef v4 = (const __CFString *)_CFBundleCopyDefaultLanguageForLanguage(a1);
    if (v4)
    {
      CFStringRef v5 = v4;
      CFStringRef v6 = (const __CFString *)_CFBundleCopyDefaultLanguageForLanguage(a2);
      if (v6)
      {
        CFStringRef v7 = v6;
        BOOL v2 = CFStringCompare(v5, v6, 1uLL) == kCFCompareEqualTo;
        CFRelease(v5);
        CFStringRef v5 = v7;
      }
      else
      {
        BOOL v2 = 0;
      }
      CFRelease(v5);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

const void *_CFBundleCopyDefaultLanguageForLanguage(const void *a1)
{
  os_unfair_lock_lock_with_options();
  CFDictionaryRef Mutable = (const __CFDictionary *)_CFBundleCopyDefaultLanguageForLanguage_cache;
  if (!_CFBundleCopyDefaultLanguageForLanguage_cache)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    _CFBundleCopyDefaultLanguageForLanguage_cache = (uint64_t)Mutable;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(Mutable, a1);
  if (Value)
  {
    CFArrayRef Copy = CFStringCreateCopy(0, Value);
LABEL_7:
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleCopyDefaultLanguageForLanguage_defaultLanguageLock);
    return Copy;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleCopyDefaultLanguageForLanguage_defaultLanguageLock);
  CFArrayRef Copy = _CFLocaleCopyLocaleIdentifierByAddingLikelySubtags((uint64_t)a1);
  if (Copy)
  {
    os_unfair_lock_lock_with_options();
    CFDictionarySetValue((CFMutableDictionaryRef)_CFBundleCopyDefaultLanguageForLanguage_cache, a1, Copy);
    goto LABEL_7;
  }
  return Copy;
}

__CFString *_CFBundleGetAlternateNameForLanguage(CFTypeRef cf1)
{
  uint64_t v2 = 0;
  while (1)
  {
    BOOL v3 = _CFBundleGetAlternateNameForLanguage___CFBundleCommonLanguageAbbreviationsArray[v2];
    int v4 = CFEqual(cf1, v3);
    CFStringRef v5 = _CFBundleGetAlternateNameForLanguage___CFBundleCommonLanguageNamesArray[v2];
    if (v4) {
      break;
    }
    if (CFEqual(cf1, v5)) {
      return v3;
    }
    if (++v2 == 7) {
      return 0;
    }
  }
  return v5;
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (!localeIdentifier || !CFStringGetCString(localeIdentifier, buffer, 257, 0x600u)) {
    return 0;
  }
  for (uint64_t i = buffer; ; ++i)
  {
    if (!*i)
    {
      v17[0] = 0;
      goto LABEL_14;
    }
    if (*i == 64) {
      break;
    }
  }
  v17[0] = 64;
  *uint64_t i = 0;
  CFStringRef v5 = v17;
  uint64_t v6 = 1;
  do
  {
    int v7 = i[v6];
    if (v7 != 32)
    {
      *++CFStringRef v5 = v7;
      int v7 = i[v6];
    }
    ++v6;
  }
  while (v7);
LABEL_14:
  __key[0] = buffer;
  __key[1] = 0;
  if (!bsearch(__key, oldAppleLocaleToCanonical, 0xB8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))
  {
    uint64_t v13 = 0;
    CFTypeID v14 = 0;
    _UpdateFullLocaleString(buffer, &v14, &v13, v16);
    CFTypeID v8 = v13;
    CFAllocatorRef v9 = v14;
    if (v14 && v13)
    {
      if (strncmp(v14 + 1, v13 + 1, 2uLL)) {
        goto LABEL_22;
      }
      do
      {
        int v10 = v9[3];
        *v9++ = v10;
      }
      while (v10);
      CFTypeID v8 = v13;
    }
    if (!v8)
    {
LABEL_24:
      __key[0] = buffer;
      CFIndex v12 = (char **)bsearch(__key, localeStringPrefixToDefaults, 0xB7uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryPrefixToTableEntryKey);
      if (v12) {
        _RemoveSubstringsIfPresent(buffer, v12[1]);
      }
      goto LABEL_26;
    }
LABEL_22:
    __key[0] = v8;
    unint64_t v11 = (char **)bsearch(__key, localeStringRegionToDefaults, 5uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey);
    if (v11) {
      _RemoveSubstringsIfPresent(buffer, v11[1]);
    }
    goto LABEL_24;
  }
  __strlcpy_chk();
  v16[0] = 0;
LABEL_26:
  _AppendKeyValueString((uint64_t)buffer, v16);
  _AppendKeyValueString((uint64_t)buffer, v17);
  return CFStringCreateWithCString(allocator, buffer, 0x600u);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  if (!localeIdentifier || !CFStringGetCString(localeIdentifier, (char *)&buffer, 257, 0x600u)) {
    return 0;
  }
  for (uint64_t i = &buffer; ; uint64_t i = (uint64_t *)((char *)i + 1))
  {
    if (!*(unsigned char *)i)
    {
      v25[0] = 0;
      goto LABEL_14;
    }
    if (*(unsigned char *)i == 64) {
      break;
    }
  }
  v25[0] = 64;
  *(unsigned char *)uint64_t i = 0;
  CFStringRef v5 = v25;
  uint64_t v6 = 1;
  do
  {
    int v7 = *((unsigned __int8 *)i + v6);
    if (v7 != 32)
    {
      *++CFStringRef v5 = v7;
      int v7 = *((unsigned __int8 *)i + v6);
    }
    ++v6;
  }
  while (v7);
LABEL_14:
  __key[0] = &buffer;
  __key[1] = 0;
  if (buffer == 0x4F484141535F6161
    || (buffer == 0x414D4B4F425F6F6ELL ? (BOOL v8 = v27 == 76) : (BOOL v8 = 0),
        v8
     || (buffer == 0x524F4E594E5F6F6ELL ? (BOOL v9 = v27 == 19283) : (BOOL v9 = 0),
         v9
      || bsearch(__key, oldAppleLocaleToCanonical, 0xB8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))))
  {
    __strlcpy_chk();
    v24[0] = 0;
  }
  else
  {
    CFArrayRef v21 = 0;
    uint64_t v22 = 0;
    _UpdateFullLocaleString((char *)&buffer, &v22, &v21, v24);
    if (v22 && v21) {
      *CFArrayRef v21 = 0;
    }
  }
  __key[0] = &buffer;
  int v10 = (char **)bsearch(__key, localeStringPrefixToDefaults, 0xB7uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryPrefixToTableEntryKey);
  if (v10) {
    _RemoveSubstringsIfPresent((char *)&buffer, v10[1]);
  }
  __key[0] = &buffer;
  if (bsearch(__key, appleLocaleToLanguageString, 6uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))
  {
    __strlcpy_chk();
  }
  else
  {
    p_uint64_t buffer = (char *)&buffer;
    for (uint64_t j = (char *)&buffer; *j; ++j)
    {
      if (*j == 95)
      {
        CFTypeID v14 = j + 1;
        unsigned int v13 = j[1];
        if ((v13 & 0x80000000) != 0)
        {
          if (__maskrune(j[1], 0x100uLL)) {
            goto LABEL_35;
          }
        }
        else if ((*((_DWORD *)off_1ECE0A578 + v13 + 15) & 0x100) != 0)
        {
LABEL_35:
          uint64_t v15 = 3;
          do
          {
            unsigned int v17 = *++v14;
            unsigned int v16 = v17;
            if ((v17 & 0x80000000) != 0) {
              int v18 = __maskrune(v16, 0x100uLL);
            }
            else {
              int v18 = *((_DWORD *)off_1ECE0A578 + v16 + 15) & 0x100;
            }
          }
          while (v18);
          goto LABEL_50;
        }
        if (v13 - 48 > 9)
        {
          uint64_t v15 = 0;
        }
        else
        {
          uint64_t v15 = 4;
          do
            int v19 = *++v14;
          while ((v19 - 48) < 0xA);
        }
LABEL_50:
        if (&v14[-v15] == p_buffer) {
          char v20 = 45;
        }
        else {
          char v20 = 0;
        }
        *uint64_t j = v20;
        uint64_t j = v14;
        break;
      }
      ++p_buffer;
    }
    *uint64_t j = 0;
  }
  _AppendKeyValueString((uint64_t)&buffer, v24);
  _AppendKeyValueString((uint64_t)&buffer, v25);
  return CFStringCreateWithCString(allocator, (const char *)&buffer, 0x600u);
}

void _AppendKeyValueString(uint64_t a1, unsigned char *a2)
{
  if (*a2 && uloc_openKeywords())
  {
    while (uenum_next())
    {
      uloc_getKeywordValue();
      uloc_setKeywordValue();
    }
    uenum_close();
  }
}

unint64_t _UpdateFullLocaleString(char *a1, char **a2, char **a3, unsigned char *a4)
{
  void __key[2] = *(void *)off_1ECE0A5B0;
  __key[0] = a1;
  __key[1] = 0;
  CFStringRef v5 = (const char **)bsearch(__key, localeStringPrefixToCanonical, 0x131uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareLowerTestEntryPrefixToTableEntryKey);
  if (!v5) {
    goto LABEL_15;
  }
  uint64_t v6 = v5;
  int v7 = strlen(*v5);
  BOOL v8 = v6[1];
  int v9 = strlen(v8);
  uint64_t v10 = (v9 - v7);
  if (v9 - v7 < 0)
  {
    unsigned int v13 = &a1[v9];
    do
    {
      int v14 = v13[v7 - v9];
      *v13++ = v14;
    }
    while (v14);
LABEL_11:
    if (v8)
    {
      char v15 = *v8;
      if (*v8)
      {
        unsigned int v16 = (unsigned __int8 *)(v8 + 1);
        unsigned int v17 = a1;
        do
        {
          *v17++ = v15;
          int v18 = *v16++;
          char v15 = v18;
        }
        while (v18);
      }
    }
    goto LABEL_15;
  }
  if (v9 == v7) {
    goto LABEL_11;
  }
  int v11 = strlen(a1);
  if ((int)v10 + v11 <= 256)
  {
    if (v11 >= (uint64_t)v7)
    {
      CFIndex v12 = &a1[v11];
      do
      {
        v12[v10] = *v12;
        --v12;
      }
      while (v12 >= &a1[v7]);
    }
    goto LABEL_11;
  }
LABEL_15:
  uint64_t v19 = 0;
  long long v69 = 0;
  long long v70 = 0;
  char v20 = 0;
  int v21 = 0;
  int v22 = 0;
  int v23 = 0;
  CFStringRef v24 = a1;
  while (1)
  {
    CFIndex v25 = &a1[v19];
    unsigned int v26 = a1[v19];
    if ((v26 & 0x80000000) != 0) {
      break;
    }
    if ((*((_DWORD *)off_1ECE0A578 + v26 + 15) & 0x100) == 0) {
      goto LABEL_21;
    }
LABEL_18:
    if (v23) {
      char v27 = __toupper(v26);
    }
    else {
      char v27 = __tolower(v26);
    }
    *CFIndex v25 = v27;
LABEL_25:
    ++v19;
  }
  if (__maskrune(a1[v19], 0x100uLL)) {
    goto LABEL_18;
  }
LABEL_21:
  if (v26 - 48 < 0xA)
  {
    int v21 = 1;
    goto LABEL_25;
  }
  if (v22)
  {
    if (v23)
    {
      int v23 = 1;
      char v20 = v24;
      goto LABEL_51;
    }
    int v28 = v24 - a1;
    if (v24 - a1 + 3 != v19 || v21)
    {
      if (v28 + 4 == v19 && v21)
      {
        if (*v24 == 95) {
          goto LABEL_38;
        }
        CFAllocatorRef v29 = v70;
        if (!v70) {
          CFAllocatorRef v29 = v24;
        }
        long long v70 = v29;
      }
      else if (v28 + 5 != v19 || v21)
      {
        if (v28 + 1 == v19 && *v24 == 95)
        {
          int v23 = 1;
          goto LABEL_51;
        }
      }
      else
      {
        v24[1] = __toupper(v24[1]);
      }
    }
    else
    {
      if (*v24 == 95)
      {
        v24[1] = __toupper(v24[1]);
        void v24[2] = __toupper(v24[2]);
LABEL_38:
        int v23 = 1;
        long long v69 = v24;
        goto LABEL_51;
      }
      if (!v70)
      {
        v24[1] = __toupper(v24[1]);
        void v24[2] = __toupper(v24[2]);
        long long v70 = v24;
      }
    }
    int v23 = 0;
    *CFStringRef v24 = 45;
    goto LABEL_51;
  }
  if (v21) {
    goto LABEL_53;
  }
LABEL_51:
  int v21 = 0;
  int v30 = *v25;
  int v22 = 1;
  CFStringRef v24 = &a1[v19];
  if (v30 == 95 || v30 == 45) {
    goto LABEL_25;
  }
LABEL_53:
  id v31 = a4;
  *a4 = 0;
  if (v20)
  {
    int v32 = uloc_canonicalize();
    if (v32 >= 256) {
      int v33 = 256;
    }
    else {
      int v33 = v32;
    }
    a4[v33] = 0;
    for (uint64_t i = a4 + 1; *(i - 1); ++i)
    {
      if (*(i - 1) == 64)
      {
        do
        {
          *char v20 = 0;
          int v35 = *--v20;
        }
        while (v35 == 95);
        LOBYTE(v36) = *(i - 1);
        if ((_BYTE)v36)
        {
          uint64_t v37 = 0;
          do
          {
            a4[v37] = v36;
            int v36 = i[v37++];
          }
          while (v36);
          id v31 = &a4[v37];
        }
        break;
      }
    }
    *id v31 = 0;
  }
  CFStringRef v38 = &specialCases;
  CFIndex v39 = "-UK";
  while (2)
  {
    if (*v38)
    {
      unint64_t result = _CheckForTag((uint64_t)a1, (const char *)*v38);
      if (!result) {
        goto LABEL_107;
      }
    }
    uint64_t v41 = (char *)v38[2];
    unsigned int v42 = *v41;
    if ((v42 & 0x80000000) != 0)
    {
      if (!__maskrune(v42, 0x8000uLL)) {
        goto LABEL_77;
      }
LABEL_72:
      unint64_t result = (unint64_t)strstr(a1, v39);
      if (!result) {
        goto LABEL_92;
      }
      char v43 = (char *)result;
      unsigned int v44 = *(char *)(result + 3);
      if ((v44 & 0x80000000) != 0)
      {
        unint64_t result = __maskrune(v44, 0x500uLL);
        if (!result) {
          goto LABEL_89;
        }
      }
      else
      {
        unint64_t result = *((_DWORD *)off_1ECE0A578 + v44 + 15) & 0x500;
        if (!result)
        {
LABEL_89:
          char v49 = *v41;
          if (*v41)
          {
            long long v50 = (unsigned __int8 *)(v41 + 1);
            long long v51 = v43 + 1;
            do
            {
              *v51++ = v49;
              int v52 = *v50++;
              char v49 = v52;
            }
            while (v52);
          }
        }
      }
LABEL_92:
      if (v69)
      {
        unint64_t result = _CheckForTag((uint64_t)(v69 + 1), v39 + 1);
        if (result)
        {
          char v53 = *v41;
          if (*v41)
          {
            CFRange v54 = (unsigned __int8 *)(v41 + 1);
            CFRange v55 = v69 + 1;
            do
            {
              *v55++ = v53;
              int v56 = *v54++;
              char v53 = v56;
            }
            while (v56);
          }
        }
      }
      goto LABEL_107;
    }
    if ((*((_DWORD *)off_1ECE0A578 + v42 + 15) & 0x8000) != 0) {
      goto LABEL_72;
    }
LABEL_77:
    if (v69)
    {
      unint64_t result = _CheckForTag((uint64_t)(v69 + 1), v39 + 1);
      if (result) {
        goto LABEL_99;
      }
    }
    CFStringRef v45 = strstr(a1, v39);
    if (v45)
    {
      unsigned int v46 = v45[3];
      if ((v46 & 0x80000000) != 0)
      {
        unint64_t result = __maskrune(v46, 0x500uLL);
        if (result) {
          goto LABEL_82;
        }
      }
      else
      {
        unint64_t result = *((_DWORD *)off_1ECE0A578 + v46 + 15) & 0x500;
        if (result) {
          goto LABEL_82;
        }
      }
LABEL_99:
      char v57 = *v41;
      if (*v41)
      {
        CFRange v58 = (unsigned __int8 *)(v41 + 1);
        CFRange v59 = a1;
        do
        {
          *v59++ = v57;
          int v60 = *v58++;
          char v57 = v60;
        }
        while (v60);
      }
    }
    else
    {
LABEL_82:
      CFLocaleIdentifier v47 = (const char *)v38[3];
      if (!v69 || (unint64_t result = _CheckForTag((uint64_t)(v69 + 1), v47 + 1), !result))
      {
        unint64_t result = (unint64_t)strstr(a1, v47);
        if (!result) {
          goto LABEL_107;
        }
        unsigned int v48 = *(char *)(result + 3);
        if ((v48 & 0x80000000) != 0)
        {
          unint64_t result = __maskrune(v48, 0x500uLL);
          if (result) {
            goto LABEL_107;
          }
        }
        else
        {
          unint64_t result = *((_DWORD *)off_1ECE0A578 + v48 + 15) & 0x500;
          if (result) {
            goto LABEL_107;
          }
        }
      }
      BOOL v61 = (unsigned char *)v38[4];
      char v62 = *v61;
      if (*v61)
      {
        CFErrorRef v63 = v61 + 1;
        CFTypeID v64 = a1;
        do
        {
          *v64++ = v62;
          int v65 = *v63++;
          char v62 = v65;
        }
        while (v65);
      }
    }
LABEL_107:
    CFIndex v39 = (const char *)v38[6];
    v38 += 5;
    if (v39) {
      continue;
    }
    break;
  }
  if (a2) {
    *a2 = v70;
  }
  if (a3) {
    *a3 = v69;
  }
  return result;
}

BOOL _CheckForTag(uint64_t a1, const char *a2)
{
  if (strncmp((const char *)a1, a2, 2uLL)) {
    return 0;
  }
  unsigned int v4 = *(char *)(a1 + 2);
  if ((v4 & 0x80000000) != 0) {
    int v5 = __maskrune(v4, 0x500uLL);
  }
  else {
    int v5 = *((_DWORD *)off_1ECE0A578 + v4 + 15) & 0x500;
  }
  return v5 == 0;
}

char *_RemoveSubstringsIfPresent(char *__s1, char *a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  char v2 = *a2;
  if (!*a2) {
    return __s1;
  }
  BOOL v3 = a2;
  unsigned int v4 = __s1;
  do
  {
    int v5 = 0;
    uint64_t v6 = 0;
    int v7 = v3 - 1;
    while ((v2 & 0x80) == 0)
    {
      if ((*((_DWORD *)off_1ECE0A578 + v2 + 15) & 0x800) == 0) {
        goto LABEL_9;
      }
LABEL_8:
      __s2[v6] = v2;
      BOOL v8 = &v3[v6++];
      char v2 = v8[1];
      ++v7;
      ++v5;
    }
    if (__maskrune(v2, 0x800uLL)) {
      goto LABEL_8;
    }
LABEL_9:
    BOOL v3 = v7;
    do
    {
      unsigned int v9 = v3[1];
      if ((v9 & 0x80000000) != 0) {
        __s1 = (char *)__maskrune(v9, 0x4000uLL);
      }
      else {
        __s1 = (char *)(*((_DWORD *)off_1ECE0A578 + v9 + 15) & 0x4000);
      }
      ++v3;
    }
    while (__s1);
    if (v6)
    {
      __s2[v6] = 0;
      __s1 = strstr(v4, __s2);
      if (__s1)
      {
        do
        {
          int v10 = __s1[v5];
          *__s1++ = v10;
        }
        while (v10);
      }
    }
    char v2 = *v3;
  }
  while (*v3);
  return __s1;
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_2;
  }
  if (__CFArrayGetCallBacks((uint64_t)theArray) != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    goto LABEL_6;
  }
  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present)
  {
LABEL_2:
    uint64_t v6 = [NSMutableArray alloc];
    return (CFMutableArrayRef)[(NSArray *)v6 initWithArray:theArray copyItems:0];
  }
  else
  {
LABEL_6:
    return __CFArrayCreateMutableCopy0((__objc2_class **)allocator, capacity, (unint64_t *)theArray);
  }
}

id _CFLocaleCopyLocaleIdentifierByAddingLikelySubtags(uint64_t a1)
{
  CFPropertyListRef v1 = (void *)+[NSLocale _localeIdentifierByAddingLikelySubtags:a1];

  return v1;
}

CFURLRef _CFBundleCopyResourcesDirectoryURLInDirectory(CFURLRef cf, int a2)
{
  if (cf)
  {
    if (a2 <= 1)
    {
      if (a2)
      {
        if (a2 != 1) {
          return (CFURLRef)CFRetain(cf);
        }
        CFStringRef v3 = @"Support%20Files/Resources/";
      }
      else
      {
        CFStringRef v3 = @"Resources/";
      }
    }
    else
    {
      if (a2 != 2)
      {
        if (a2 == 12)
        {
          CFStringRef v2 = @"WrappedBundle/Contents/Resources/";
          return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v2, cf);
        }
        if (a2 == 13)
        {
          CFStringRef v2 = @"WrappedBundle/";
          return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v2, cf);
        }
        return (CFURLRef)CFRetain(cf);
      }
      CFStringRef v3 = @"Contents/Resources/";
    }
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, cf);
  }
  return cf;
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFURLRef v3 = (const __CFURL *)*((void *)bundle + 2);
  int v4 = *((unsigned __int8 *)bundle + 53);

  return _CFBundleCopyResourcesDirectoryURLInDirectory(v3, v4);
}

uint64_t _copyAppleLocalizations(const __CFDictionary *a1)
{
  if (CFDictionaryGetValue(a1, @"_CFBundleUseAppleLocalizations") != &__kCFBooleanTrue) {
    return 0;
  }
  CFURLRef v2 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"/System/Library/Frameworks/CoreFoundation.framework", kCFURLPOSIXPathStyle, 1u);
  CFBundleRef v3 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
  uint64_t v4 = _copyBundleLocalizationsFromResources(v3, 0);
  CFRelease(v2);
  CFRelease(v3);
  return v4;
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_22;
  }
  if (__CFArrayGetCallBacks((uint64_t)theArray) != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    goto LABEL_7;
  }
  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present)
  {
LABEL_22:
    if (_CFArrayIsMutable((uint64_t)theArray))
    {
      uint64_t v4 = [NSArray alloc];
      return (CFArrayRef)[(NSArray *)v4 initWithArray:theArray copyItems:0];
    }
    else
    {
      return (CFArrayRef)[(__CFArray *)theArray copyWithZone:0];
    }
  }
  else
  {
LABEL_7:
    return (CFArrayRef)__CFArrayCreateCopy0((__objc2_class **)allocator, (unint64_t *)theArray);
  }
}

BOOL _CFArrayIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 3) != 0;
}

const CFArrayCallBacks *__CFArrayGetCallBacks(uint64_t a1)
{
  unsigned int v1 = atomic_load((unint64_t *)(a1 + 8));
  int v2 = (v1 >> 2) & 3;
  if (!v2) {
    return (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  if (v2 == 1) {
    return &kCFTypeArrayCallBacks;
  }
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  int v5 = v4 & 3;
  if (v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = a1 + 48;
  }
  if (v5 == 2) {
    return (const CFArrayCallBacks *)(a1 + 48);
  }
  else {
    return (const CFArrayCallBacks *)v6;
  }
}

uint64_t _CFURLFileCacheGetFinderInfo()
{
  return MEMORY[0x1F4114FA8]();
}

BOOL _CFPrefsEqualKeyOrSource(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1;
  }
  int v2 = a2;
  Class Class = (__objc2_class *)object_getClass(a1);
  int v5 = (__objc2_class *)object_getClass(v2);
  if (Class != CFPDSourceLookUpKey && v5 != CFPDSourceLookUpKey) {
    return 0;
  }
  if (Class == CFPDSourceLookUpKey) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = v2;
  }
  if (Class == CFPDSourceLookUpKey)
  {
    int v7 = v5;
  }
  else
  {
    int v2 = a1;
    int v7 = Class;
  }
  if (v7 == CFPDSourceLookUpKey)
  {
    int v10 = (const void *)v6[1];
    int v11 = (const void *)v2[1];
    if (v10 != v11)
    {
      BOOL v12 = !v10 || v11 == 0;
      if (v12 || !CFEqual(v10, v11)) {
        return 0;
      }
    }
    unsigned int v13 = (const void *)v6[2];
    int v14 = (const void *)v2[2];
    if (v13 != v14)
    {
      if (v13) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15) {
        return 0;
      }
      return CFEqual(v13, v14) != 0;
    }
    return 1;
  }
  BOOL v8 = (const void *)v6[2];
  if (v8)
  {
    if (v7 != CFPDCloudSource) {
      return 0;
    }
    unsigned int v9 = (const void *)v2[20];
    if (v8 != v9 && (!v9 || !CFEqual(v8, v9))) {
      return 0;
    }
  }
  else if (v7 == CFPDCloudSource)
  {
    return 0;
  }
  unsigned int v17 = (const void *)[v2 copyUncanonicalizedPath];
  int v18 = (const void *)v6[1];
  if (v18 == v17 || v17 == 0 || v18 == 0)
  {
    BOOL v16 = v18 == v17;
    if (!v17) {
      return v16;
    }
  }
  else
  {
    BOOL v16 = CFEqual(v18, v17) != 0;
  }
  CFRelease(v17);
  return v16;
}

uint64_t __CFDataMtbl(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return __NLStringTokenizerAdvanceToNextToken(*((void *)tokenizer + 2));
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppIntegerValueWithContainer((uint64_t)key, (uint64_t)applicationID, 0, (BOOL *)keyExistsAndHasValidFormat);
}

BOOL __NSOrderedSetChunkIterate(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, void *a5, uint64_t a6, unint64_t *a7, void *a8, pthread_mutex_t *a9)
{
  id v39 = a8;
  uint64_t v41 = a6;
  uint64_t v44 = *(void *)off_1ECE0A5B0;
  char v43 = 0;
  uint64_t v42 = 0x7FFFFFFFFFFFFFFFLL;
  int v14 = (unint64_t *)&v42;
  if (a7) {
    int v14 = a7;
  }
  CFStringRef v40 = v14;
  if ((a2 & 0x2000000000000000) != 0)
  {
    unint64_t v15 = atomic_load(v40);
    if (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v16 = v15 >= a3;
      BOOL v17 = v15 <= a4;
      if ((a2 & 2) != 0) {
        BOOL v16 = v17;
      }
      if (!v16) {
        return 0;
      }
    }
  }
  int v36 = (void *)_CFAutoreleasePoolPush();
  uint64_t v37 = &v35;
  uint64_t v19 = MEMORY[0x1F4188790](v36, v18);
  int v21 = (char *)&v35 - v20;
  MEMORY[0x1F4188790](v19, v22);
  CFStringRef v24 = (char *)&v35 - v23;
  if ((a2 & 0x1000000000000000) != 0
    && !objc_msgSend(a5, "__getContainmentVector:inRange:", (char *)&v35 - v23, a3, a4 - a3 + 1))
  {
    goto LABEL_41;
  }
  objc_msgSend(a1, "getObjects:range:", v21, a3, a4 - a3 + 1);
  if (a4 - a3 == -1) {
    goto LABEL_41;
  }
  uint64_t v25 = 0;
  CFStringRef v38 = a9;
  while (1)
  {
    uint64_t v26 = a4 - a3 - v25;
    if ((a2 & 2) == 0) {
      uint64_t v26 = v25;
    }
    if ((a2 & 0x1000000000000000) != 0 && !v24[v26]) {
      goto LABEL_32;
    }
    if ((a2 & 2) != 0) {
      unint64_t v27 = a4 - v25;
    }
    else {
      unint64_t v27 = v25 + a3;
    }
    if ((a2 & 0x6000000000000000) == 0)
    {
      __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(v41);
      goto LABEL_26;
    }
    if (__NSORDEREDSET_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(v41)) {
      break;
    }
LABEL_26:
    if (v43) {
      goto LABEL_41;
    }
    if ((a2 & 0x2000000000000000) != 0)
    {
      unint64_t v28 = atomic_load(v40);
      if (v28 != 0x7FFFFFFFFFFFFFFFLL)
      {
        BOOL v29 = v28 >= a3;
        BOOL v30 = v28 <= a4;
        if ((a2 & 2) == 0) {
          BOOL v30 = v29;
        }
        if (!v30) {
          goto LABEL_41;
        }
      }
    }
LABEL_32:
    if (++v25 >= a4 - a3 + 1) {
      goto LABEL_41;
    }
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((a2 & 0x4000000000000000) != 0)
    {
      if (v38)
      {
        pthread_mutex_lock(v38);
        [v39 addIndex:v27];
        pthread_mutex_unlock(v38);
      }
      else
      {
        [v39 addIndex:v27];
      }
    }
    goto LABEL_26;
  }
  do
  {
    unint64_t v32 = atomic_load(v40);
    if (v32 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v33 = v32 < v27;
      if ((a2 & 2) == 0) {
        BOOL v33 = v27 < v32;
      }
      if (!v33) {
        break;
      }
    }
    unint64_t v34 = v32;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v40, &v34, v27, memory_order_relaxed, memory_order_relaxed);
  }
  while (v34 != v32);
LABEL_41:
  _CFAutoreleasePoolPop(v36);
  return v43 != 0;
}

uint64_t __NSORDEREDSET_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex CurrentTokenRange = __NLStringTokenizerGetCurrentTokenRange(*((void *)tokenizer + 2));
  result.CFIndex length = v2;
  result.CFIndex location = CurrentTokenRange;
  return result;
}

uint64_t _CFIsDeallocating(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  unsigned int v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((*(void *)&v1 & 0x800000) != 0) {
    return 1;
  }
  else {
    return (v1 >> 22) & 1;
  }
}

CFCharacterSetRef CFCharacterSetCreateCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 0, 1);
}

uint64_t __CFStringGetExtendedPictographicSequenceComponent(UniChar *buffer, int64_t a2, int64_t a3, uint64_t *a4)
{
  uint64_t result = 0;
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  if (a3 < 0 || a3 >= a2) {
    return result;
  }
  int64_t v24 = a3;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  int64_t v9 = -1;
  uint64_t v25 = 0;
  int64_t v10 = -1;
  int64_t v11 = -1;
  uint64_t v12 = -1;
  while (1)
  {
    UChar32 LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, a2, a3, &v24);
    if (u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_EXTEND)
      || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EMOJI_MODIFIER))
    {
      uint64_t v14 = v7 + 1;
      if (v7 > 63) {
        goto LABEL_21;
      }
      uint64_t v12 = v24;
      int64_t v11 = v24;
      goto LABEL_8;
    }
    if (LongCharacterFromInlineBuffer == 8205)
    {
      if (v11 != -1 || v10 != -1) {
        break;
      }
      int64_t v11 = -1;
      uint64_t v12 = v24;
      int64_t v10 = v24;
      goto LABEL_19;
    }
    if (!u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EXTENDED_PICTOGRAPHIC)
      || v9 != -1
      || v10 != -1
      || v11 != -1)
    {
      break;
    }
    uint64_t v12 = v24;
    int64_t v10 = -1;
    int64_t v9 = v24;
LABEL_19:
    uint64_t v14 = v7;
LABEL_8:
    v8 += v25;
    uint64_t v7 = v14;
    a3 = v12 - 1;
    int64_t v24 = v12 - 1;
    if (v12 < 1) {
      goto LABEL_21;
    }
  }
  uint64_t v14 = v7;
LABEL_21:
  if (v9 != -1)
  {
    unint64_t v15 = a4;
    if (a4)
    {
      BOOL v16 = v11 != -1;
      BOOL v17 = v10 == -1;
      BOOL v18 = !v16 || !v17;
      if (v16 && v17) {
        int64_t v19 = v11 - v9;
      }
      else {
        int64_t v19 = 0;
      }
      v8 += v19;
      if (!v18) {
        uint64_t v12 = v9;
      }
LABEL_28:
      *unint64_t v15 = v12;
      v15[1] = v8;
      void v15[2] = v11;
      v15[3] = v10;
      uint64_t result = 1;
      v15[4] = v9;
      return result;
    }
    return 1;
  }
  if (v10 == -1 && v11 == -1) {
    return 0;
  }
  int64_t v20 = v8 + v12;
  int64_t v24 = v8 + v12;
  uint64_t v25 = 0;
  if (v8 + v12 >= a2) {
    return 0;
  }
  do
  {
    UChar32 v21 = __CFStringGetLongCharacterFromInlineBuffer(buffer, a2, v20, &v24);
    if (u_hasBinaryProperty(v21, UCHAR_GRAPHEME_EXTEND) || u_hasBinaryProperty(v21, UCHAR_EMOJI_MODIFIER))
    {
      uint64_t result = 0;
      if (v10 != -1 || v14 > 62) {
        return result;
      }
      ++v14;
      int64_t v10 = -1;
      int64_t v22 = v24;
      int64_t v9 = -1;
    }
    else if (v21 == 8205)
    {
      if (v10 != -1) {
        return 0;
      }
      int64_t v9 = -1;
      int64_t v22 = v24;
      int64_t v10 = v24;
    }
    else
    {
      uint64_t result = u_hasBinaryProperty(v21, UCHAR_EXTENDED_PICTOGRAPHIC);
      if (!result) {
        return result;
      }
      int64_t v22 = v24;
      int64_t v9 = v24;
    }
    v8 += v25;
    int64_t v20 = v22 + v25;
    int64_t v24 = v22 + v25;
    uint64_t v25 = 0;
  }
  while (v9 == -1 && v20 < a2);
  uint64_t result = 0;
  if (v9 != -1 && v14 <= 63)
  {
    unint64_t v15 = a4;
    if (a4) {
      goto LABEL_28;
    }
    return 1;
  }
  return result;
}

uint64_t CFStringGetRangeOfCharacterClusterAtIndex(const __CFString *a1, int64_t a2, uint64_t a3)
{
  uint64_t v189 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  if (a3 == 1) {
    unsigned int v7 = 110;
  }
  else {
    unsigned int v7 = 8;
  }
  if (Length <= a2) {
    return -1;
  }
  int64_t v8 = Length;
  uint64_t v188 = 0;
  long long v186 = 0u;
  long long v187 = 0u;
  long long v184 = 0u;
  *(_OWORD *)CFStringRef theString = 0u;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v180 = 0u;
  long long v181 = 0u;
  long long v178 = 0u;
  long long v179 = 0u;
  *(_OWORD *)uint64_t buffer = 0u;
  if (CF_IS_OBJC(7uLL, (unint64_t)a1)
    || (char v9 = atomic_load((unint64_t *)&a1->info), (v9 & 0x10) != 0))
  {
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(v7, 0);
    uint64_t v11 = CFUniCharGetBitmapPtrForPlane(5u, 0);
    if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP) {
      CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    }
    theString[0] = a1;
    *((void *)&v186 + 1) = 0;
    *(void *)&long long v187 = v8;
    CFStringRef CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(a1);
    uint64_t CStringPtrInternal = 0;
    theString[1] = CharactersPtr;
    if (!CharactersPtr) {
      uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal(a1, 1536, 1, 1);
    }
    *((void *)&v187 + 1) = 0;
    uint64_t v188 = 0;
    *(void *)&long long v186 = CStringPtrInternal;
    uint64_t v14 = BitmapPtrForPlane;
    uint64_t ComposedRange = _CFStringInlineBufferGetComposedRange(buffer, a2, a3, BitmapPtrForPlane, v7);
    unint64_t v17 = ComposedRange;
    uint64_t v18 = v16;
    unsigned int v165 = v7;
    uint64_t v166 = a3;
    if (a3 > 2)
    {
      a2 = ComposedRange;
      goto LABEL_208;
    }
    uint64_t v162 = v16;
    if (ComposedRange < 0 || (uint64_t v19 = v187, (uint64_t)v187 <= ComposedRange))
    {
      LOWORD(v23) = 0;
      uint64_t v24 = v11;
      goto LABEL_22;
    }
    int64_t v20 = (UniChar *)theString[1];
    if (theString[1])
    {
      uint64_t v21 = *((void *)&v186 + 1) + ComposedRange;
    }
    else
    {
      if ((void)v186)
      {
        UniChar v22 = *(char *)(v186 + *((void *)&v186 + 1) + ComposedRange);
        goto LABEL_27;
      }
      if (v188 <= ComposedRange || (uint64_t v133 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > ComposedRange))
      {
        uint64_t v134 = ComposedRange - 4;
        if ((unint64_t)ComposedRange < 4) {
          uint64_t v134 = 0;
        }
        if (v134 + 64 < (uint64_t)v187) {
          uint64_t v19 = v134 + 64;
        }
        *((void *)&v187 + 1) = v134;
        uint64_t v188 = v19;
        v199.CFIndex location = *((void *)&v186 + 1) + v134;
        v199.CFIndex length = v19 - v134;
        CFStringGetCharacters(theString[0], v199, buffer);
        uint64_t v133 = *((void *)&v187 + 1);
      }
      uint64_t v21 = v17 - v133;
      int64_t v20 = buffer;
    }
    UniChar v22 = v20[v21];
LABEL_27:
    unsigned int v23 = v22;
    if (v18 < 2 || (v22 & 0xFC00) != 0xD800 || (uint64_t v25 = v17 + 1, v26 = v187, (uint64_t)v187 <= (uint64_t)(v17 + 1)))
    {
      uint64_t v24 = v11;
      goto LABEL_34;
    }
    unint64_t v27 = (UniChar *)theString[1];
    if (theString[1])
    {
      uint64_t v28 = *((void *)&v186 + 1) + v25;
    }
    else
    {
      if ((void)v186)
      {
        UniChar v29 = *(char *)(v186 + *((void *)&v186 + 1) + v25);
LABEL_286:
        uint64_t v24 = v11;
        if (v29 >> 10 == 55)
        {
          unsigned int v23 = (v23 << 10) + v29 - 56613888;
          uint64_t v24 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v23));
        }
LABEL_34:
        if (v23 == 8205)
        {
LABEL_35:
          uint64_t v30 = v17;
          while (1)
          {
            a2 = v30;
            uint64_t v31 = v30 - 2;
            if (v30 < 2)
            {
LABEL_121:
              uint64_t v18 = v17 - a2 + v162;
              int64_t v64 = v162 + v17;
              if (v18 < 2 || v64 >= v8)
              {
LABEL_207:
                uint64_t v14 = BitmapPtrForPlane;
LABEL_208:
                uint64_t v91 = a2 + v18;
                if (a2 + v18 <= 5) {
                  uint64_t v92 = 5;
                }
                else {
                  uint64_t v92 = a2 + v18;
                }
                unint64_t v93 = v92 - 5;
                if (v92 - 5 <= a2)
                {
                  uint64_t v163 = v18;
                  int64_t v94 = a2 + 6;
                  CFIndex v95 = (char *)&v175 + 6;
                  uint64_t v96 = 5 - v92;
                  uint64_t v97 = v92 + 59;
                  uint64_t v98 = (unsigned __int8 *)&__CFTranscodingHintLength;
                  while (1)
                  {
                    uint64_t v99 = v92 - 5;
                    uint64_t v100 = v93 >= 4 ? 4 : v93;
                    uint64_t v101 = v187;
                    if ((uint64_t)v187 > v99)
                    {
                      if (theString[1])
                      {
                        unsigned __int16 v102 = *((_WORD *)theString[1] + v92 + *((void *)&v186 + 1) - 5);
                      }
                      else if ((void)v186)
                      {
                        unsigned __int16 v102 = *(char *)(v186 + *((void *)&v186 + 1) + v92 - 5);
                      }
                      else
                      {
                        if (v188 <= v99 || (uint64_t v103 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v99))
                        {
                          uint64_t v104 = -5 - v100;
                          uint64_t v159 = v95;
                          int64_t v160 = a2;
                          uint64_t v105 = v100 + v96;
                          uint64_t v106 = v97 - v100;
                          uint64_t v107 = v92 + v104;
                          uint64_t v108 = v107 + 64;
                          if (v107 + 64 >= (uint64_t)v187) {
                            uint64_t v108 = v187;
                          }
                          *((void *)&v187 + 1) = v107;
                          uint64_t v188 = v108;
                          if ((uint64_t)v187 >= v106) {
                            uint64_t v101 = v106;
                          }
                          v198.CFIndex length = v101 + v105;
                          uint64_t v109 = v98;
                          v198.CFIndex location = v107 + *((void *)&v186 + 1);
                          CFStringGetCharacters(theString[0], v198, buffer);
                          uint64_t v98 = v109;
                          CFIndex v95 = v159;
                          a2 = v160;
                          uint64_t v103 = *((void *)&v187 + 1);
                        }
                        unsigned __int16 v102 = *(_WORD *)&v95[2 * v92 + -2 * v103];
                      }
                      if ((v102 & 0xFFF0) == 0xF860)
                      {
                        uint64_t v110 = v98[v102 - 63584];
                        if (v92 + v110 - 4 >= v91) {
                          break;
                        }
                      }
                    }
                    ++v93;
                    ++v92;
                    --v96;
                    ++v97;
                    if (v94 == v92)
                    {
                      uint64_t v18 = v163;
                      uint64_t v14 = BitmapPtrForPlane;
                      goto LABEL_233;
                    }
                  }
                  uint64_t v115 = v110 + v92;
                  int64_t v116 = v115 - 5;
                  uint64_t v18 = v163;
                  uint64_t v14 = BitmapPtrForPlane;
                  if (v115 - 5 < v8)
                  {
                    a2 = v92 - 5;
                    int64_t v117 = v115 - 4;
                    int64_t v118 = v92 - 4;
                    while (v118 <= v116)
                    {
                      uint64_t v119 = _CFStringInlineBufferGetComposedRange(buffer, v118, v166, BitmapPtrForPlane, v165);
                      int64_t v118 = v119 + v120;
                      if (v118 > v117)
                      {
                        int64_t v117 = v119;
                        break;
                      }
                    }
                    uint64_t v18 = v117 - v92 + 5;
                  }
                }
LABEL_233:
                if (v18 == 2)
                {
                  if (!__CFStringIsRegionalIndicatorAtIndex(buffer, a2)) {
                    goto LABEL_242;
                  }
                  int64_t v111 = v8;
                  uint64_t v112 = 0;
                  do
                  {
                    uint64_t v113 = v112;
                    int64_t v114 = a2 + v112;
                    if (a2 + v112 < 2) {
                      break;
                    }
                    v112 -= 2;
                  }
                  while (__CFStringIsRegionalIndicatorAtIndex(buffer, v113 - 2 + a2));
                  if (a2 > v114 && (-(int)v113 & 3) != 0)
                  {
                    a2 -= 2;
                    uint64_t v18 = 4;
                    int64_t v8 = v111;
                    goto LABEL_252;
                  }
                  int64_t v8 = v111;
                  if (a2 + 4 > v111)
                  {
LABEL_242:
                    uint64_t v18 = 2;
                    goto LABEL_252;
                  }
                  if (__CFStringIsRegionalIndicatorAtIndex(buffer, a2 + 2)) {
                    uint64_t v18 = 4;
                  }
                  else {
                    uint64_t v18 = 2;
                  }
                }
LABEL_252:
                uint64_t v121 = v166;
                if ((a2 & 0x8000000000000000) == 0 && a2 < v8)
                {
                  uint64_t v122 = v18;
                  int64_t v175 = 0;
                  int64_t v176 = 0;
                  UChar32 LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, a2, &v175);
                  uint64_t v124 = 0;
                  int64_t v125 = v176;
                  while (LongCharacterFromInlineBuffer == 8205
                       || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_EXTEND)
                       || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EMOJI_MODIFIER)
                       || u_getIntPropertyValue(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_CLUSTER_BREAK) == 10)
                  {
                    int64_t v125 = v175;
                    if (!v175) {
                      goto LABEL_334;
                    }
                    v124 += v176;
                    if (v124 >= 64) {
                      goto LABEL_334;
                    }
                    UChar32 LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v175 - 1, &v175);
                  }
                  long long v171 = xmmword_182D9EC80;
                  uint64_t v172 = -1;
                  uint64_t v173 = -1;
                  uint64_t v174 = -1;
                  int64_t v126 = v175;
                  uint64_t v127 = 0;
                  if (__CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v175, (uint64_t *)&v171))
                  {
                    do
                    {
                      int64_t v126 = v171;
                      v127 += *((void *)&v171 + 1);
                      int64_t v175 = v171 - 1;
                      int64_t v176 = 0;
                    }
                    while (v173 != -1
                         && __CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v171 - 1, (uint64_t *)&v171));
                  }
                  if (v172 == -1 && v173 == -1)
                  {
                    BOOL v132 = v127 == 0;
                    if (v124 < 1 || v127)
                    {
                      int64_t v167 = v175;
                      UChar32 v135 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v175, &v175);
                      if (u_getIntPropertyValue(v135, UCHAR_GRAPHEME_CLUSTER_BREAK) == 11)
                      {
                        int64_t v130 = v175;
                        uint64_t v129 = v176;
                      }
                      else
                      {
                        uint64_t v129 = 0;
                        int64_t v130 = v167;
                      }
                      BOOL v131 = v124 > 0;
                      goto LABEL_298;
                    }
                  }
                  else
                  {
                    uint64_t v129 = 0;
                    int64_t v126 = v174;
                    v127 += v171 - v174;
                    int64_t v130 = v174 + 1;
                    BOOL v131 = v124 > 0;
                    BOOL v132 = v127 == 0;
                    if (v124 < 1 || v127)
                    {
LABEL_298:
                      if (v129 || !v132)
                      {
                        BOOL v170 = v131;
                        int64_t v168 = v130;
                        uint64_t v164 = v129;
                        int64_t v138 = v130 + v129;
                        if (v132) {
                          int64_t v139 = v138;
                        }
                        else {
                          int64_t v139 = v126 + v127;
                        }
                        if (v132)
                        {
                          uint64_t v127 = 0;
                          int64_t v140 = v138;
                        }
                        else
                        {
                          int64_t v140 = v126;
                        }
                        int64_t v175 = v139;
                        int64_t v176 = 0;
                        if (__CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v139, (uint64_t *)&v171))
                        {
                          do
                          {
                            if (v127 >= 1 && v173 == -1) {
                              break;
                            }
                            v127 += *((void *)&v171 + 1);
                            v175 += *((void *)&v171 + 1);
                          }
                          while ((__CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v175, (uint64_t *)&v171) & 1) != 0);
                        }
                        int64_t v161 = v140;
                        if (v170)
                        {
                          int64_t v141 = v127 + v140;
                          BOOL v142 = v127 + v140 < v125 + v124;
                          if (v127 + v140 >= v125 + v124) {
                            uint64_t v143 = 0;
                          }
                          else {
                            uint64_t v143 = v124;
                          }
                          if (v142) {
                            int64_t v141 = v125;
                          }
                          int64_t v144 = v141 + v143;
                          int64_t v175 = v141 + v143;
                          int64_t v176 = 0;
                        }
                        else
                        {
                          int64_t v144 = v175;
                          uint64_t v143 = v176;
                        }
                        if (v144 < v8)
                        {
                          UChar32 v145 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v144, &v175);
                          do
                          {
                            if (v145 != 8205
                              && !u_hasBinaryProperty(v145, UCHAR_GRAPHEME_EXTEND)
                              && !u_hasBinaryProperty(v145, UCHAR_EMOJI_MODIFIER)
                              && u_getIntPropertyValue(v145, UCHAR_GRAPHEME_CLUSTER_BREAK) != 10)
                            {
                              break;
                            }
                            v143 += v176;
                            v175 += v176;
                            UChar32 v145 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v175, &v175);
                          }
                          while (v143 < 64);
                        }
                        int64_t v146 = v168;
                        if (v127 >= 1)
                        {
                          if (v164 <= 0) {
                            int64_t v146 = v161;
                          }
                          BOOL v147 = a2 >= v146;
                          BOOL v148 = a2 + v122 <= v127 + (v164 & ~(v164 >> 63)) + (v143 & ~(v143 >> 63)) + v146;
                          if (v147 && v148) {
                            uint64_t v18 = v127 + (v164 & ~(v164 >> 63)) + (v143 & ~(v143 >> 63));
                          }
                          else {
                            uint64_t v18 = v122;
                          }
                          if (v147 && v148) {
                            a2 = v146;
                          }
                          goto LABEL_335;
                        }
                      }
                    }
                  }
LABEL_334:
                  uint64_t v18 = v122;
                }
LABEL_335:
                if (a2 >= 1 && v18 == 1)
                {
                  uint64_t v149 = v187;
                  if ((uint64_t)v187 <= a2) {
                    goto LABEL_348;
                  }
                  __int16 v150 = (UniChar *)theString[1];
                  if (theString[1])
                  {
                    int64_t v151 = *((void *)&v186 + 1) + a2;
                    goto LABEL_340;
                  }
                  if ((void)v186) {
                    goto LABEL_348;
                  }
                  if (v188 <= a2 || (uint64_t v157 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > a2))
                  {
                    int64_t v158 = a2 - 4;
                    if ((unint64_t)a2 < 4) {
                      int64_t v158 = 0;
                    }
                    if (v158 + 64 < (uint64_t)v187) {
                      uint64_t v149 = v158 + 64;
                    }
                    *((void *)&v187 + 1) = v158;
                    uint64_t v188 = v149;
                    v202.CFIndex location = *((void *)&v186 + 1) + v158;
                    v202.CFIndex length = v149 - v158;
                    CFStringGetCharacters(theString[0], v202, buffer);
                    uint64_t v157 = *((void *)&v187 + 1);
                  }
                  int64_t v151 = a2 - v157;
                  __int16 v150 = buffer;
LABEL_340:
                  if (v150[v151] != 8205)
                  {
LABEL_348:
                    uint64_t v18 = 1;
                  }
                  else
                  {
                    uint64_t v152 = _CFStringInlineBufferGetComposedRange(buffer, a2 - 1, v121, v14, v165);
                    if (a2 == v152 + v153) {
                      uint64_t v18 = v153 + 1;
                    }
                    else {
                      uint64_t v18 = 1;
                    }
                    if (a2 == v152 + v153) {
                      a2 = v152;
                    }
                  }
                }
                uint64_t v154 = a2 + v18;
                if (a2 + v18 < v8 && (v154 & 0x8000000000000000) == 0)
                {
                  uint64_t v155 = v187;
                  if ((uint64_t)v187 > v154
                    && !theString[1]
                    && !(void)v186
                    && (v188 <= v154 || *((uint64_t *)&v187 + 1) > v154))
                  {
                    uint64_t v156 = v154 - 4;
                    if ((unint64_t)v154 < 4) {
                      uint64_t v156 = 0;
                    }
                    if (v156 + 64 < (uint64_t)v187) {
                      uint64_t v155 = v156 + 64;
                    }
                    *((void *)&v187 + 1) = v156;
                    uint64_t v188 = v155;
                    v201.CFIndex location = *((void *)&v186 + 1) + v156;
                    v201.CFIndex length = v155 - v156;
                    CFStringGetCharacters(theString[0], v201, buffer);
                  }
                }
                return a2;
              }
              while (2)
              {
                int64_t v66 = v64 - 1;
                if (v64 < 1 || (uint64_t v67 = v187, (uint64_t)v187 < v64))
                {
                  LOWORD(v68) = 0;
                  goto LABEL_129;
                }
                if (theString[1])
                {
                  long long v69 = (UniChar *)theString[1] + *((void *)&v186 + 1) + v66;
                }
                else
                {
                  if ((void)v186)
                  {
                    LOWORD(v68) = *(char *)(v186 + *((void *)&v186 + 1) + v66);
                    goto LABEL_129;
                  }
                  if (v188 < v64 || (uint64_t v83 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) >= v64))
                  {
                    int64_t v84 = v64 - 5;
                    if ((unint64_t)v64 < 5) {
                      int64_t v84 = 0;
                    }
                    if (v84 + 64 < (uint64_t)v187) {
                      uint64_t v67 = v84 + 64;
                    }
                    *((void *)&v187 + 1) = v84;
                    uint64_t v188 = v67;
                    v195.CFIndex location = *((void *)&v186 + 1) + v84;
                    v195.CFIndex length = v67 - v84;
                    CFStringGetCharacters(theString[0], v195, buffer);
                    uint64_t v83 = *((void *)&v187 + 1);
                  }
                  long long v69 = &buffer[v66 - v83];
                }
                int v68 = *v69;
                if (v68 != 847 && v68 != 8205)
                {
LABEL_129:
                  if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                    || !*(unsigned char *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                 + ((unint64_t)(unsigned __int16)v68 >> 8))
                    || *(unsigned char *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                + (*(unsigned __int8 *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                                      + ((unint64_t)(unsigned __int16)v68 >> 8)) << 8)
                                - 256
                                + v68
                                + 256) != 9
                    || (unsigned __int16)v68 == 3021 && !_CFStringIsJoiningPulliAtIndex(buffer, v64 - 1, 0, v8))
                  {
LABEL_206:
                    uint64_t v18 = v64 - a2;
                    goto LABEL_207;
                  }
                  if (v64 < 0)
                  {
LABEL_150:
                    LOWORD(v76) = 0;
                    goto LABEL_183;
                  }
                }
                uint64_t v71 = v187;
                if ((uint64_t)v187 <= v64) {
                  goto LABEL_150;
                }
                if (theString[1])
                {
                  uint64_t v72 = (UniChar *)theString[1] + *((void *)&v186 + 1) + v64;
                  goto LABEL_146;
                }
                if ((void)v186)
                {
                  LOWORD(v73) = *(char *)(v186 + *((void *)&v186 + 1) + v64);
                  goto LABEL_153;
                }
                if (v188 <= v64 || (uint64_t v81 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v64))
                {
                  int64_t v82 = v64 - 4;
                  if ((unint64_t)v64 < 4) {
                    int64_t v82 = 0;
                  }
                  if (v82 + 64 < (uint64_t)v187) {
                    uint64_t v71 = v82 + 64;
                  }
                  *((void *)&v187 + 1) = v82;
                  uint64_t v188 = v71;
                  v194.CFIndex location = *((void *)&v186 + 1) + v82;
                  v194.CFIndex length = v71 - v82;
                  CFStringGetCharacters(theString[0], v194, buffer);
                  uint64_t v81 = *((void *)&v187 + 1);
                }
                uint64_t v72 = &buffer[v64 - v81];
LABEL_146:
                int v73 = *v72;
                if (v73 != 8205)
                {
LABEL_153:
                  uint64_t v74 = v64;
                  goto LABEL_154;
                }
                uint64_t v74 = v64 + 1;
                uint64_t v75 = v187;
                if ((uint64_t)v187 <= v64 + 1)
                {
                  LOWORD(v76) = 0;
                  goto LABEL_182;
                }
                if (theString[1])
                {
                  LOWORD(v73) = *((_WORD *)&theString[1]->isa + *((void *)&v186 + 1) + v74);
                }
                else if ((void)v186)
                {
                  LOWORD(v73) = *(char *)(v186 + *((void *)&v186 + 1) + v74);
                }
                else
                {
                  if (v188 <= v74 || (uint64_t v89 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v74))
                  {
                    int64_t v90 = v64 - 3;
                    if ((unint64_t)v64 < 3) {
                      int64_t v90 = 0;
                    }
                    if (v90 + 64 < (uint64_t)v187) {
                      uint64_t v75 = v90 + 64;
                    }
                    *((void *)&v187 + 1) = v90;
                    uint64_t v188 = v75;
                    v197.CFIndex location = *((void *)&v186 + 1) + v90;
                    v197.CFIndex length = v75 - v90;
                    CFStringGetCharacters(theString[0], v197, buffer);
                    uint64_t v89 = *((void *)&v187 + 1);
                  }
                  LOWORD(v73) = buffer[v74 - v89];
                }
LABEL_154:
                unsigned int v76 = (unsigned __int16)v73;
                if ((unsigned __int16)v73 >> 10 == 54)
                {
                  uint64_t v77 = v74 + 1;
                  uint64_t v78 = v187;
                  if ((uint64_t)v187 > v74 + 1)
                  {
                    if (theString[1])
                    {
                      UniChar v79 = *((_WORD *)&theString[1]->isa + *((void *)&v186 + 1) + v77);
                    }
                    else if ((void)v186)
                    {
                      UniChar v79 = *(char *)(v186 + *((void *)&v186 + 1) + v77);
                    }
                    else
                    {
                      if (v188 <= v77 || (uint64_t v87 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v77))
                      {
                        uint64_t v88 = v74 - 3;
                        if ((unint64_t)v74 < 3) {
                          uint64_t v88 = 0;
                        }
                        if (v88 + 64 < (uint64_t)v187) {
                          uint64_t v78 = v88 + 64;
                        }
                        *((void *)&v187 + 1) = v88;
                        uint64_t v188 = v78;
                        v196.CFIndex location = *((void *)&v186 + 1) + v88;
                        v196.CFIndex length = v78 - v88;
                        CFStringGetCharacters(theString[0], v196, buffer);
                        uint64_t v87 = *((void *)&v187 + 1);
                      }
                      UniChar v79 = buffer[v77 - v87];
                    }
                    if (v79 >> 10 == 55)
                    {
                      unsigned int v76 = (v76 << 10) + v79 - 56613888;
                      uint64_t v80 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v76));
                      int64_t v64 = v74;
                      goto LABEL_184;
                    }
                    goto LABEL_182;
                  }
                  int64_t v64 = v74;
                  uint64_t v80 = v11;
                }
                else
                {
LABEL_182:
                  int64_t v64 = v74;
LABEL_183:
                  uint64_t v80 = v11;
                }
LABEL_184:
                if (!v80) {
                  goto LABEL_206;
                }
                if (((*(unsigned __int8 *)(v80 + ((unsigned __int16)v76 >> 3)) >> (v76 & 7)) & 1) == 0) {
                  goto LABEL_206;
                }
                uint64_t v85 = _CFStringInlineBufferGetComposedRange(buffer, v64, v166, BitmapPtrForPlane, v7);
                int64_t v64 = v85 + v86;
                if (v85 + v86 >= v8) {
                  goto LABEL_206;
                }
                continue;
              }
            }
            uint64_t v32 = v30 - 1;
            uint64_t v33 = v187;
            if ((uint64_t)v187 >= a2)
            {
              uint64_t v35 = (UniChar *)theString[1];
              if (theString[1])
              {
                uint64_t v36 = *((void *)&v186 + 1) + v32;
              }
              else
              {
                if ((void)v186)
                {
                  LOWORD(v34) = *(char *)(v186 + *((void *)&v186 + 1) + v32);
                  goto LABEL_47;
                }
                if (v188 < a2 || (uint64_t v56 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) >= a2))
                {
                  int64_t v57 = a2 - 5;
                  if ((unint64_t)a2 < 5) {
                    int64_t v57 = 0;
                  }
                  if (v57 + 64 < (uint64_t)v187) {
                    uint64_t v33 = v57 + 64;
                  }
                  *((void *)&v187 + 1) = v57;
                  uint64_t v188 = v33;
                  v190.CFIndex location = *((void *)&v186 + 1) + v57;
                  v190.CFIndex length = v33 - v57;
                  CFStringGetCharacters(theString[0], v190, buffer);
                  uint64_t v56 = *((void *)&v187 + 1);
                }
                uint64_t v36 = v32 - v56;
                uint64_t v35 = buffer;
              }
              int v34 = v35[v36];
              if (v34 == 847) {
                goto LABEL_67;
              }
              if (v34 == 3021)
              {
                if (!_CFStringIsJoiningPulliAtIndex(buffer, a2 - 1, 0, v8)) {
                  goto LABEL_121;
                }
                LOWORD(v34) = 3021;
              }
            }
            else
            {
              LOWORD(v34) = 0;
            }
LABEL_47:
            unint64_t v37 = (unsigned __int16)v34;
            uint64_t v38 = CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP;
            if (CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
              && *(unsigned char *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP + (v37 >> 8))
              && *(unsigned char *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                          + (*(unsigned __int8 *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP + (v37 >> 8)) << 8)
                          - 256
                          + v37
                          + 256) == 9)
            {
              goto LABEL_67;
            }
            if (v37 != 8205) {
              goto LABEL_121;
            }
            uint64_t v39 = v187;
            if ((uint64_t)v187 <= v31)
            {
              unsigned int v43 = 0;
              if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP) {
                goto LABEL_64;
              }
              goto LABEL_61;
            }
            if (theString[1])
            {
              CFStringRef v40 = (UniChar *)theString[1] + *((void *)&v186 + 1) + v31;
            }
            else
            {
              if ((void)v186)
              {
                LOWORD(v41) = *(char *)(v186 + *((void *)&v186 + 1) + v31);
LABEL_60:
                unsigned int v43 = (unsigned __int16)v41;
                uint64_t v38 = CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP;
                if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP)
                {
LABEL_64:
                  BOOL v42 = v38 == 9;
                  goto LABEL_65;
                }
LABEL_61:
                if (*(unsigned char *)(v38 + ((unint64_t)v43 >> 8))) {
                  LODWORD(v38) = *(unsigned __int8 *)(v38
                }
                                                    + (*(unsigned __int8 *)(v38 + ((unint64_t)v43 >> 8)) << 8)
                                                    - 256
                                                    + v43
                                                    + 256);
                else {
                  LODWORD(v38) = 0;
                }
                goto LABEL_64;
              }
              if (v188 <= v31 || (uint64_t v58 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v31))
              {
                int64_t v59 = a2 - 6;
                if ((unint64_t)v31 < 4) {
                  int64_t v59 = 0;
                }
                if (v59 + 64 < (uint64_t)v187) {
                  uint64_t v39 = v59 + 64;
                }
                *((void *)&v187 + 1) = v59;
                uint64_t v188 = v39;
                v191.CFIndex location = *((void *)&v186 + 1) + v59;
                v191.CFIndex length = v39 - v59;
                CFStringGetCharacters(theString[0], v191, buffer);
                uint64_t v58 = *((void *)&v187 + 1);
              }
              CFStringRef v40 = &buffer[v31 - v58];
            }
            int v41 = *v40;
            if (v41 != 847) {
              goto LABEL_60;
            }
            BOOL v42 = 1;
LABEL_65:
            if ((unint64_t)a2 < 3) {
              goto LABEL_121;
            }
            uint64_t v32 = v31;
            if (!v42) {
              goto LABEL_121;
            }
LABEL_67:
            uint64_t v44 = _CFStringInlineBufferGetComposedRange(buffer, v32 - 1, v166, BitmapPtrForPlane, v7);
            uint64_t v30 = v44;
            if (v44 < 0 || (uint64_t v45 = v187, (uint64_t)v187 <= v44))
            {
              LOWORD(v49) = 0;
              goto LABEL_73;
            }
            unsigned int v46 = (UniChar *)theString[1];
            if (theString[1])
            {
              uint64_t v47 = *((void *)&v186 + 1) + v44;
            }
            else
            {
              if ((void)v186)
              {
                UniChar v48 = *(char *)(v186 + *((void *)&v186 + 1) + v44);
                goto LABEL_79;
              }
              if (v188 <= v44 || (uint64_t v60 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v44))
              {
                uint64_t v61 = v44 - 4;
                if ((unint64_t)v44 < 4) {
                  uint64_t v61 = 0;
                }
                if (v61 + 64 < (uint64_t)v187) {
                  uint64_t v45 = v61 + 64;
                }
                *((void *)&v187 + 1) = v61;
                uint64_t v188 = v45;
                v192.CFIndex location = *((void *)&v186 + 1) + v61;
                v192.CFIndex length = v45 - v61;
                CFStringGetCharacters(theString[0], v192, buffer);
                uint64_t v60 = *((void *)&v187 + 1);
              }
              uint64_t v47 = v30 - v60;
              unsigned int v46 = buffer;
            }
            UniChar v48 = v46[v47];
LABEL_79:
            unsigned int v49 = v48;
            if (v48 >> 10 == 55)
            {
              if (v30)
              {
                uint64_t v51 = v187;
                if ((uint64_t)v187 >= v30)
                {
                  uint64_t v52 = v30 - 1;
                  char v53 = (UniChar *)theString[1];
                  if (theString[1])
                  {
                    uint64_t v54 = *((void *)&v186 + 1) + v52;
                    goto LABEL_84;
                  }
                  if ((void)v186)
                  {
                    UniChar v55 = *(char *)(v186 + *((void *)&v186 + 1) + v52);
                  }
                  else
                  {
                    if (v188 < v30 || (uint64_t v62 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) >= v30))
                    {
                      uint64_t v63 = v30 - 5;
                      if ((unint64_t)v30 < 5) {
                        uint64_t v63 = 0;
                      }
                      if (v63 + 64 < (uint64_t)v187) {
                        uint64_t v51 = v63 + 64;
                      }
                      *((void *)&v187 + 1) = v63;
                      uint64_t v188 = v51;
                      v193.CFIndex location = *((void *)&v186 + 1) + v63;
                      v193.CFIndex length = v51 - v63;
                      CFStringGetCharacters(theString[0], v193, buffer);
                      uint64_t v62 = *((void *)&v187 + 1);
                    }
                    uint64_t v54 = v52 - v62;
                    char v53 = buffer;
LABEL_84:
                    UniChar v55 = v53[v54];
                  }
                  uint64_t v50 = v11;
                  if (v55 >> 10 == 54)
                  {
                    unsigned int v49 = (v49 << 10) + v55 - 56613888;
                    uint64_t v50 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v49));
                    --v30;
                  }
                  goto LABEL_74;
                }
              }
            }
LABEL_73:
            uint64_t v50 = v11;
LABEL_74:
            if (!v50 || ((*(unsigned __int8 *)(v50 + ((unsigned __int16)v49 >> 3)) >> (v49 & 7)) & 1) == 0) {
              goto LABEL_121;
            }
          }
        }
LABEL_22:
        if (!v24 || ((*(unsigned __int8 *)(v24 + ((unsigned __int16)v23 >> 3)) >> (v23 & 7)) & 1) == 0)
        {
          a2 = v17;
          uint64_t v18 = v162;
          goto LABEL_208;
        }
        goto LABEL_35;
      }
      if (v188 <= v25 || (uint64_t v136 = *((void *)&v187 + 1), *((uint64_t *)&v187 + 1) > v25))
      {
        unint64_t v137 = v17 - 3;
        if (v17 < 3) {
          unint64_t v137 = 0;
        }
        if ((uint64_t)(v137 + 64) < (uint64_t)v187) {
          uint64_t v26 = v137 + 64;
        }
        *((void *)&v187 + 1) = v137;
        uint64_t v188 = v26;
        v200.CFIndex location = *((void *)&v186 + 1) + v137;
        v200.CFIndex length = v26 - v137;
        CFStringGetCharacters(theString[0], v200, buffer);
        uint64_t v136 = *((void *)&v187 + 1);
      }
      uint64_t v28 = v25 - v136;
      unint64_t v27 = buffer;
    }
    UniChar v29 = v27[v28];
    goto LABEL_286;
  }
  return a2;
}

uint64_t __CFStringGetLongCharacterFromInlineBuffer(UniChar *buffer, int64_t a2, int64_t a3, int64_t *a4)
{
  if ((a3 & 0x8000000000000000) == 0)
  {
    int64_t v5 = a3;
    if (a3 < a2)
    {
      int64_t v8 = *((void *)buffer + 20);
      if (v8 <= a3)
      {
        uint64_t v11 = 0;
      }
      else
      {
        uint64_t v9 = *((void *)buffer + 17);
        if (v9)
        {
          UniChar v10 = *(_WORD *)(v9 + 2 * (*((void *)buffer + 19) + a3));
        }
        else
        {
          uint64_t v14 = *((void *)buffer + 18);
          if (v14)
          {
            UniChar v10 = *(char *)(v14 + *((void *)buffer + 19) + a3);
          }
          else
          {
            if (*((void *)buffer + 22) <= a3 || (int64_t v15 = *((void *)buffer + 21), v15 > a3))
            {
              int64_t v16 = a3 - 4;
              if ((unint64_t)a3 < 4) {
                int64_t v16 = 0;
              }
              if (v16 + 64 < v8) {
                int64_t v8 = v16 + 64;
              }
              *((void *)buffer + 21) = v16;
              *((void *)buffer + 22) = v8;
              v32.CFIndex location = *((void *)buffer + 19) + v16;
              v32.CFIndex length = v8 - v16;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              int64_t v15 = *((void *)buffer + 21);
            }
            UniChar v10 = buffer[v5 - v15];
          }
        }
        uint64_t v11 = v10;
        if ((v10 & 0xFC00) != 0xD800 || a2 - 1 <= v5)
        {
          uint64_t v12 = 1;
          if (v5 && (v10 & 0xFC00) == 0xDC00)
          {
            int64_t v18 = *((void *)buffer + 20);
            if (v18 < v5) {
              goto LABEL_9;
            }
            int64_t v19 = v5 - 1;
            uint64_t v20 = *((void *)buffer + 17);
            if (v20)
            {
              UniChar v21 = *(_WORD *)(v20 + 2 * (*((void *)buffer + 19) + v19));
            }
            else
            {
              uint64_t v27 = *((void *)buffer + 18);
              if (v27)
              {
                UniChar v21 = *(char *)(v27 + *((void *)buffer + 19) + v19);
              }
              else
              {
                if (*((void *)buffer + 22) < v5 || (int64_t v30 = *((void *)buffer + 21), v30 >= v5))
                {
                  int64_t v31 = v5 - 5;
                  if ((unint64_t)v5 < 5) {
                    int64_t v31 = 0;
                  }
                  if (v31 + 64 < v18) {
                    int64_t v18 = v31 + 64;
                  }
                  *((void *)buffer + 21) = v31;
                  *((void *)buffer + 22) = v18;
                  v34.CFIndex location = *((void *)buffer + 19) + v31;
                  v34.CFIndex length = v18 - v31;
                  CFStringGetCharacters(*((CFStringRef *)buffer + 16), v34, buffer);
                  int64_t v30 = *((void *)buffer + 21);
                }
                UniChar v21 = buffer[v19 - v30];
              }
            }
            if (v21 >> 10 != 54) {
              goto LABEL_9;
            }
            uint64_t v11 = v11 + (v21 << 10) - 56613888;
            uint64_t v12 = 2;
            --v5;
          }
LABEL_10:
          if (a4) {
            goto LABEL_11;
          }
          return v11;
        }
        int64_t v22 = v5 + 1;
        int64_t v23 = *((void *)buffer + 20);
        if (v23 > v5 + 1)
        {
          uint64_t v24 = *((void *)buffer + 17);
          if (v24)
          {
            UniChar v25 = *(_WORD *)(v24 + 2 * (*((void *)buffer + 19) + v22));
          }
          else
          {
            uint64_t v26 = *((void *)buffer + 18);
            if (v26)
            {
              UniChar v25 = *(char *)(v26 + *((void *)buffer + 19) + v22);
            }
            else
            {
              if (*((void *)buffer + 22) <= v22 || (int64_t v28 = *((void *)buffer + 21), v28 > v22))
              {
                int64_t v29 = v5 - 3;
                if ((unint64_t)v5 < 3) {
                  int64_t v29 = 0;
                }
                if (v29 + 64 < v23) {
                  int64_t v23 = v29 + 64;
                }
                *((void *)buffer + 21) = v29;
                *((void *)buffer + 22) = v23;
                v33.CFIndex location = *((void *)buffer + 19) + v29;
                v33.CFIndex length = v23 - v29;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v33, buffer);
                int64_t v28 = *((void *)buffer + 21);
              }
              UniChar v25 = buffer[v22 - v28];
            }
          }
          if (v25 >> 10 == 55)
          {
            uint64_t v11 = (v11 << 10) + v25 - 56613888;
            uint64_t v12 = 2;
            goto LABEL_10;
          }
        }
      }
LABEL_9:
      uint64_t v12 = 1;
      goto LABEL_10;
    }
  }
  uint64_t v11 = 0;
  if (a4)
  {
    uint64_t v12 = 0;
    int64_t v5 = -1;
LABEL_11:
    *a4 = v5;
    a4[1] = v12;
  }
  return v11;
}

uint64_t _CFStringInlineBufferGetComposedRange(UniChar *buffer, int64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v7 = a2;
  uint64_t v9 = a2 + 1;
  if (a2 < 0) {
    goto LABEL_160;
  }
  int64_t v10 = *((void *)buffer + 20);
  if (v10 <= a2)
  {
    unsigned int v13 = 0;
LABEL_6:
    uint64_t BitmapPtrForPlane = a4;
    goto LABEL_7;
  }
  uint64_t v11 = *((void *)buffer + 17);
  if (v11)
  {
    UniChar v12 = *(_WORD *)(v11 + 2 * (*((void *)buffer + 19) + a2));
  }
  else
  {
    uint64_t v30 = *((void *)buffer + 18);
    if (v30)
    {
      UniChar v12 = *(char *)(v30 + *((void *)buffer + 19) + a2);
    }
    else
    {
      if (*((void *)buffer + 22) <= a2 || (int64_t v31 = *((void *)buffer + 21), v31 > a2))
      {
        int64_t v32 = a2 - 4;
        if ((unint64_t)a2 < 4) {
          int64_t v32 = 0;
        }
        if (v32 + 64 < v10) {
          int64_t v10 = v32 + 64;
        }
        *((void *)buffer + 21) = v32;
        *((void *)buffer + 22) = v10;
        v98.CFIndex location = *((void *)buffer + 19) + v32;
        v98.CFIndex length = v10 - v32;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v98, buffer);
        int64_t v31 = *((void *)buffer + 21);
      }
      UniChar v12 = buffer[v7 - v31];
    }
  }
  unsigned int v13 = v12;
  if (a3 == 4 && v12 >= 0x530u && (unsigned __int16)(v12 >> 4) < 0x195u) {
    goto LABEL_69;
  }
  if (v12 >> 10 != 54) {
    goto LABEL_6;
  }
  uint64_t v35 = *((void *)buffer + 20);
  if (v35 <= v9) {
    goto LABEL_6;
  }
  uint64_t v36 = *((void *)buffer + 17);
  if (v36)
  {
    UniChar v37 = *(_WORD *)(v36 + 2 * (*((void *)buffer + 19) + v9));
  }
  else
  {
    uint64_t v92 = *((void *)buffer + 18);
    if (v92)
    {
      UniChar v37 = *(char *)(v92 + *((void *)buffer + 19) + v9);
    }
    else
    {
      if (*((void *)buffer + 22) <= v9 || (uint64_t v93 = *((void *)buffer + 21), v93 > v9))
      {
        uint64_t v94 = v7 - 3;
        if ((unint64_t)v9 < 4) {
          uint64_t v94 = 0;
        }
        if (v94 + 64 < v35) {
          uint64_t v35 = v94 + 64;
        }
        *((void *)buffer + 21) = v94;
        *((void *)buffer + 22) = v35;
        v103.CFIndex location = *((void *)buffer + 19) + v94;
        v103.CFIndex length = v35 - v94;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v103, buffer);
        uint64_t v93 = *((void *)buffer + 21);
      }
      UniChar v37 = buffer[v9 - v93];
    }
  }
  uint64_t BitmapPtrForPlane = a4;
  if (v37 >> 10 == 55)
  {
    uint64_t v9 = v7 + 2;
    unsigned int v13 = (v13 << 10) + v37 - 56613888;
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v13));
  }
LABEL_7:
  if (v7)
  {
    while (1)
    {
      if (a3 == 4 && v13 >= 0x530 && v13 >> 4 < 0x195) {
        goto LABEL_69;
      }
      if (HIWORD(v13)) {
        goto LABEL_31;
      }
      if ((v13 & 0xFC00) != 0xDC00) {
        break;
      }
      uint64_t v15 = *((void *)buffer + 20);
      if (v15 < v7) {
        break;
      }
      uint64_t v16 = v7 - 1;
      uint64_t v17 = *((void *)buffer + 17);
      if (v17)
      {
        UniChar v18 = *(_WORD *)(v17 + 2 * (*((void *)buffer + 19) + v16));
      }
      else
      {
        uint64_t v19 = *((void *)buffer + 18);
        if (v19)
        {
          UniChar v18 = *(char *)(v19 + *((void *)buffer + 19) + v16);
        }
        else
        {
          if (*((void *)buffer + 22) < v7 || (uint64_t v20 = *((void *)buffer + 21), v20 >= v7))
          {
            uint64_t v21 = v7 - 5;
            if ((unint64_t)v7 < 5) {
              uint64_t v21 = 0;
            }
            if (v21 + 64 < v15) {
              uint64_t v15 = v21 + 64;
            }
            *((void *)buffer + 21) = v21;
            *((void *)buffer + 22) = v15;
            v96.CFIndex location = *((void *)buffer + 19) + v21;
            v96.CFIndex length = v15 - v21;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v96, buffer);
            uint64_t v20 = *((void *)buffer + 21);
          }
          UniChar v18 = buffer[v16 - v20];
        }
      }
      if (v18 >> 10 != 54) {
        break;
      }
      unsigned int v13 = v13 + (v18 << 10) - 56613888;
      uint64_t v22 = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v13));
      if (v7 == 1)
      {
        uint64_t v7 = 0;
        goto LABEL_69;
      }
      uint64_t BitmapPtrForPlane = v22;
      if (v22)
      {
LABEL_32:
        int v23 = (*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v13 >> 3)) >> (v13 & 7)) & 1;
        goto LABEL_33;
      }
LABEL_29:
      LOBYTE(v23) = 0;
LABEL_33:
      if (v13 != 8205
        && (v13 & 0xFFFFFFFE) != 0xFF9E
        && (v13 & 0x1FFFF0) != 0xF870
        && v13 - 127995 >= 5
        && (v23 & 1) == 0
        && v13 - 917536 > 0x5F)
      {
        uint64_t v7 = v16;
        goto LABEL_69;
      }
      uint64_t v7 = v16 - 1;
      uint64_t v24 = *((void *)buffer + 20);
      if (v24 >= v16)
      {
        uint64_t v26 = *((void *)buffer + 17);
        if (v26)
        {
          UniChar v25 = *(_WORD *)(v26 + 2 * (*((void *)buffer + 19) + v7));
        }
        else
        {
          uint64_t v27 = *((void *)buffer + 18);
          if (v27)
          {
            UniChar v25 = *(char *)(v27 + *((void *)buffer + 19) + v7);
          }
          else
          {
            if (*((void *)buffer + 22) < v16 || (uint64_t v28 = *((void *)buffer + 21), v28 >= v16))
            {
              uint64_t v29 = v16 - 5;
              if ((unint64_t)v7 < 4) {
                uint64_t v29 = 0;
              }
              if (v29 + 64 < v24) {
                uint64_t v24 = v29 + 64;
              }
              *((void *)buffer + 21) = v29;
              *((void *)buffer + 22) = v24;
              v97.CFIndex location = *((void *)buffer + 19) + v29;
              v97.CFIndex length = v24 - v29;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v97, buffer);
              uint64_t v28 = *((void *)buffer + 21);
            }
            UniChar v25 = buffer[v7 - v28];
          }
        }
      }
      else
      {
        UniChar v25 = 0;
      }
      unsigned int v13 = v25;
      if (v16 <= 1) {
        goto LABEL_69;
      }
    }
    uint64_t BitmapPtrForPlane = a4;
LABEL_31:
    uint64_t v16 = v7;
    if (BitmapPtrForPlane) {
      goto LABEL_32;
    }
    goto LABEL_29;
  }
LABEL_69:
  unsigned int v33 = v13 - 44032;
  if (v13 - 4352 >= 0xFA && v33 >> 4 > 0x2BA) {
    goto LABEL_160;
  }
  if (v13 >> 5 >= 0x8B)
  {
    if (v13 >> 3 >= 0x235)
    {
      if (v13 >> 10 >= 0x2B)
      {
        HIDWORD(v38) = -1227133513 * v33;
        LODWORD(v38) = -1227133513 * v33;
        if ((v38 >> 2) < 0x924924A) {
          char v34 = 3;
        }
        else {
          char v34 = 4;
        }
      }
      else
      {
        char v34 = 2;
      }
    }
    else
    {
      char v34 = 1;
    }
  }
  else
  {
    char v34 = 0;
  }
  if (v7 >= 1)
  {
    uint64_t v39 = -v7;
    uint64_t v40 = v7 + 64;
    char v41 = v34;
    while (1)
    {
      if ((unint64_t)v7 >= 5) {
        uint64_t v42 = 5;
      }
      else {
        uint64_t v42 = v7;
      }
      uint64_t v43 = *((void *)buffer + 20);
      if (v43 < v7) {
        goto LABEL_123;
      }
      uint64_t v44 = *((void *)buffer + 17);
      if (v44)
      {
        UniChar v45 = *(_WORD *)(v44 + 2 * (v7 + *((void *)buffer + 19)) - 2);
      }
      else
      {
        uint64_t v46 = *((void *)buffer + 18);
        if (v46)
        {
          UniChar v45 = *(char *)(v46 + *((void *)buffer + 19) + v7 - 1);
        }
        else
        {
          if (*((void *)buffer + 22) < v7 || (uint64_t v47 = *((void *)buffer + 21), v47 >= v7))
          {
            uint64_t v48 = -v42;
            uint64_t v49 = v42 + v39;
            uint64_t v50 = v40 - v42;
            uint64_t v51 = v7 + v48;
            uint64_t v52 = v51 + 64;
            if (v51 + 64 >= v43) {
              uint64_t v52 = *((void *)buffer + 20);
            }
            *((void *)buffer + 21) = v51;
            *((void *)buffer + 22) = v52;
            if (v43 >= v50) {
              uint64_t v43 = v50;
            }
            v99.CFIndex length = v43 + v49;
            v99.CFIndex location = v51 + *((void *)buffer + 19);
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v99, buffer);
            uint64_t v47 = *((void *)buffer + 21);
          }
          UniChar v45 = buffer[v7 - 1 - v47];
        }
      }
      if ((unsigned __int16)((unsigned __int16)(v45 - 4352) >> 4) > 0xC6Au || (unsigned __int16)(v45 + 21504) > 0x65F9u) {
        goto LABEL_123;
      }
      if (v41 == 2) {
        break;
      }
      unsigned int v53 = v45 >> 5;
      if (v41 == 1)
      {
        if (v53 >= 0x8B)
        {
          if (v45 >> 10 >= 0x2Bu)
          {
            HIDWORD(v54) = -1840706560 - 1227133513 * v45;
            LODWORD(v54) = HIDWORD(v54);
            if ((v54 >> 2) >= 0x924924A) {
              goto LABEL_123;
            }
            char v41 = 3;
            goto LABEL_121;
          }
          if (v45 > 0x11A2u) {
            goto LABEL_123;
          }
          goto LABEL_118;
        }
      }
      else if (v53 > 0x8A)
      {
        goto LABEL_123;
      }
      char v41 = 0;
LABEL_121:
      --v7;
      ++v39;
      --v40;
      if ((unint64_t)(v7 + 1) <= 1)
      {
        uint64_t v7 = 0;
        goto LABEL_123;
      }
    }
    if (v45 - 4448 >= 0x43)
    {
      if (v45 >> 10 < 0x2Bu)
      {
        if (v45 >> 5 < 0x8Bu) {
          goto LABEL_123;
        }
        char v41 = 2;
      }
      else
      {
        HIDWORD(v55) = -1840706560 - 1227133513 * v45;
        LODWORD(v55) = HIDWORD(v55);
        if ((v55 >> 2) < 0x924924A) {
          char v41 = 3;
        }
        else {
          char v41 = 4;
        }
      }
      goto LABEL_121;
    }
LABEL_118:
    char v41 = 1;
    goto LABEL_121;
  }
LABEL_123:
  if ((v9 & 0x8000000000000000) == 0)
  {
    uint64_t v56 = *((void *)buffer + 20);
    if (v56 > v9)
    {
      uint64_t v57 = -v9;
      uint64_t v58 = v9 + 64;
      while (2)
      {
        uint64_t v59 = (unint64_t)v9 >= 4 ? 4 : v9;
        uint64_t v60 = *((void *)buffer + 17);
        if (v60)
        {
          UniChar v61 = *(_WORD *)(v60 + 2 * (v9 + *((void *)buffer + 19)));
        }
        else
        {
          uint64_t v62 = *((void *)buffer + 18);
          if (v62)
          {
            UniChar v61 = *(char *)(v62 + *((void *)buffer + 19) + v9);
          }
          else
          {
            if (*((void *)buffer + 22) <= v9 || (uint64_t v63 = *((void *)buffer + 21), v63 > v9))
            {
              uint64_t v64 = -v59;
              uint64_t v65 = v59 + v57;
              uint64_t v66 = v58 - v59;
              uint64_t v67 = v9 + v64;
              uint64_t v68 = v67 + 64;
              if (v67 + 64 >= v56) {
                uint64_t v68 = v56;
              }
              *((void *)buffer + 21) = v67;
              *((void *)buffer + 22) = v68;
              if (v56 >= v66) {
                uint64_t v56 = v66;
              }
              v100.CFIndex length = v56 + v65;
              v100.CFIndex location = v67 + *((void *)buffer + 19);
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v100, buffer);
              uint64_t v63 = *((void *)buffer + 21);
            }
            UniChar v61 = buffer[v9 - v63];
          }
        }
        if (v61
          && (v61 - 4352 < 0xFA || (unsigned __int16)((unsigned __int16)(v61 + 21504) >> 4) <= 0x2BAu))
        {
          switch(v34)
          {
            case 1:
            case 3:
              if (v61 - 4448 <= 0x99)
              {
                if (v61 >> 3 < 0x235u) {
                  char v34 = 1;
                }
                else {
                  char v34 = 2;
                }
                goto LABEL_159;
              }
              break;
            case 2:
            case 4:
              if (v61 - 4520 < 0x52)
              {
                char v34 = 2;
                goto LABEL_159;
              }
              break;
            default:
              if (v61 >> 5 >= 0x8Bu)
              {
                if (v61 >> 3 >= 0x235u)
                {
                  if (v61 >> 10 < 0x2Bu) {
                    break;
                  }
                  HIDWORD(v69) = -1227133513 * v61 - 1840706560;
                  LODWORD(v69) = HIDWORD(v69);
                  if ((v69 >> 2) < 0x924924A) {
                    char v34 = 3;
                  }
                  else {
                    char v34 = 4;
                  }
                }
                else
                {
                  char v34 = 1;
                }
              }
              else
              {
                char v34 = 0;
              }
LABEL_159:
              ++v9;
              uint64_t v56 = *((void *)buffer + 20);
              --v57;
              ++v58;
              if (v56 > v9) {
                continue;
              }
              break;
          }
        }
        break;
      }
    }
  }
LABEL_160:
  do
  {
    unint64_t v70 = v9;
    if (v9 < 0) {
      break;
    }
    uint64_t v71 = *((void *)buffer + 20);
    if (v71 <= v9) {
      break;
    }
    uint64_t v72 = *((void *)buffer + 17);
    if (v72)
    {
      UniChar v73 = *(_WORD *)(v72 + 2 * (*((void *)buffer + 19) + v9));
    }
    else
    {
      uint64_t v74 = *((void *)buffer + 18);
      if (v74)
      {
        UniChar v73 = *(char *)(v74 + *((void *)buffer + 19) + v9);
      }
      else
      {
        if (*((void *)buffer + 22) <= v9 || (uint64_t v75 = *((void *)buffer + 21), v75 > v9))
        {
          uint64_t v76 = v9 - 4;
          if ((unint64_t)v9 < 4) {
            uint64_t v76 = 0;
          }
          if (v76 + 64 < v71) {
            uint64_t v71 = v76 + 64;
          }
          *((void *)buffer + 21) = v76;
          *((void *)buffer + 22) = v71;
          v101.CFIndex location = *((void *)buffer + 19) + v76;
          v101.CFIndex length = v71 - v76;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v101, buffer);
          uint64_t v75 = *((void *)buffer + 21);
        }
        UniChar v73 = buffer[v9 - v75];
      }
    }
    unsigned int v77 = v73;
    if (!v73 || a3 == 4 && (unsigned __int16)((unsigned __int16)(v73 - 1328) >> 5) < 0xA1u) {
      break;
    }
    if (v73 >> 10 != 54) {
      goto LABEL_194;
    }
    uint64_t v78 = v9 + 1;
    int64_t v79 = *((void *)buffer + 20);
    if (v79 <= (uint64_t)(v70 + 1)) {
      goto LABEL_194;
    }
    uint64_t v80 = *((void *)buffer + 17);
    if (v80)
    {
      UniChar v81 = *(_WORD *)(v80 + 2 * (*((void *)buffer + 19) + v78));
    }
    else
    {
      uint64_t v82 = *((void *)buffer + 18);
      if (v82)
      {
        UniChar v81 = *(char *)(v82 + *((void *)buffer + 19) + v78);
      }
      else
      {
        if (*((void *)buffer + 22) <= v78 || (uint64_t v83 = *((void *)buffer + 21), v83 > v78))
        {
          unint64_t v84 = v70 - 3;
          if (v70 < 3) {
            unint64_t v84 = 0;
          }
          if ((uint64_t)(v84 + 64) < v79) {
            int64_t v79 = v84 + 64;
          }
          *((void *)buffer + 21) = v84;
          *((void *)buffer + 22) = v79;
          v102.CFIndex location = *((void *)buffer + 19) + v84;
          v102.CFIndex length = v79 - v84;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v102, buffer);
          uint64_t v83 = *((void *)buffer + 21);
        }
        UniChar v81 = buffer[v78 - v83];
      }
    }
    if (v81 >> 10 == 55)
    {
      unsigned int v77 = (v77 << 10) + v81 - 56613888;
      uint64_t v85 = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v77));
      uint64_t v86 = 2;
      if (v85) {
        goto LABEL_195;
      }
    }
    else
    {
LABEL_194:
      uint64_t v85 = a4;
      uint64_t v86 = 1;
      if (a4)
      {
LABEL_195:
        int v87 = (*(unsigned __int8 *)(v85 + ((unsigned __int16)v77 >> 3)) >> (v77 & 7)) & 1;
        goto LABEL_196;
      }
    }
    LOBYTE(v87) = 0;
LABEL_196:
    uint64_t v9 = v86 + v70;
    BOOL v90 = v77 != 8205 && (v77 & 0xFFFFFFFE) != 65438 && (v77 & 0x1FFFF0) != 63600 && v77 - 127995 >= 5;
  }
  while (!v90 || (v87 & 1) != 0 || v77 - 917536 < 0x60);
  return v7;
}

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
  CFMutableStringRef v2 = theString;
  __src[32] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)v2 _cfNormalize:theForm];
    return;
  }
  p_info = (unint64_t *)&v2->info;
  char v4 = atomic_load((unint64_t *)&v2->info);
  if ((v4 & 1) == 0)
  {
    int64_t v5 = _CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      CFStringNormalize_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    return;
  }
  char v13 = atomic_load(p_info);
  uint64_t v14 = v13 & 5;
  char v15 = atomic_load(p_info);
  uint64_t v16 = v15 & 0x60;
  if (v14 == 4)
  {
    p_data = &v2->data;
    if (v16)
    {
      UniChar v18 = (unsigned __int8 **)*p_data;
    }
    else
    {
      uint64_t v20 = atomic_load((unint64_t *)&v2->info);
      UniChar v18 = (unsigned __int8 **)&p_data[(v20 & 5) != 4];
    }
    uint64_t length = *(unsigned __int8 *)v18;
  }
  else if ((v15 & 0x60) != 0)
  {
    uint64_t length = v2->length;
  }
  else
  {
    uint64_t length = (uint64_t)v2->data;
  }
  char v21 = atomic_load((unint64_t *)&v2->info);
  if ((v21 & 0x10) != 0) {
    goto LABEL_27;
  }
  if (theForm == kCFStringNormalizationFormC) {
    return;
  }
  char v22 = atomic_load((unint64_t *)&v2->info);
  int v23 = &v2->data;
  if ((v22 & 0x60) != 0)
  {
    uint64_t v24 = (char **)*v23;
  }
  else
  {
    char v25 = atomic_load((unint64_t *)&v2->info);
    uint64_t v24 = &v23[(v25 & 5) != 4];
  }
  unint64_t v26 = atomic_load((unint64_t *)&v2->info);
  if (length < 1)
  {
LABEL_27:
    uint64_t v28 = 0;
    BOOL v137 = 1;
  }
  else
  {
    uint64_t v27 = (v26 >> 2) & 1;
    if (*((char *)v24 + v27) < 0)
    {
      BOOL v137 = 0;
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v28 = 0;
      uint64_t v29 = (uint64_t)v24 + v27 + 1;
      do
      {
        if (length - 1 == v28) {
          return;
        }
        int v30 = *(char *)(v29 + v28++);
      }
      while ((v30 & 0x80000000) == 0);
      BOOL v137 = v28 >= length;
    }
    __src[0] = 0;
    __src[1] = 0;
    __CFStringChangeSizeMultiple((uint64_t)v2, (uint64_t)__src, 1, 0, 1);
  }
  if (v28 < length)
  {
    char v31 = atomic_load((unint64_t *)&v2->info);
    int64_t v32 = &v2->data;
    if ((v31 & 0x60) != 0)
    {
      unsigned int v33 = *v32;
    }
    else
    {
      char v34 = atomic_load((unint64_t *)&v2->info);
      unsigned int v33 = (char *)&v32[(v34 & 5) != 4];
    }
    unint64_t v35 = (unint64_t)&v33[2 * length];
    char v36 = atomic_load((unint64_t *)&v2->info);
    int64_t v140 = &v2->data;
    if ((v36 & 0x60) != 0)
    {
      UniChar v37 = *v32;
    }
    else
    {
      char v38 = atomic_load((unint64_t *)&v2->info);
      UniChar v37 = (char *)&v32[(v38 & 5) != 4];
    }
    uint64_t v39 = (unsigned __int16 *)&v37[2 * v28];
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, 0);
    uint64_t v40 = CFUniCharGetBitmapPtrForPlane(8u, 0);
    uint64_t UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    if ((unint64_t)v39 < v35)
    {
      uint64_t v153 = v40;
      uint64_t v154 = UnicodePropertyDataForPlane;
      uint64_t v136 = UnicodePropertyDataForPlane + 256;
      uint64_t v42 = 64;
      uint64_t Typed = (unsigned int *)__src;
      int64_t v139 = v2;
      while (1)
      {
        unsigned int v44 = *v39;
        UniChar v45 = v39 + 1;
        BOOL v46 = (v44 & 0xFC00) != 0xD800 || (unint64_t)v45 >= v35;
        if (v46 || (int v52 = *v45, (v52 & 0xFC00) != 0xDC00))
        {
          char v47 = 1;
          unsigned int v48 = *v39;
          uint64_t v152 = 1;
          ++v39;
          uint64_t v49 = BitmapPtrForPlane;
          if (!BitmapPtrForPlane) {
            goto LABEL_54;
          }
        }
        else
        {
          unsigned int v48 = (v44 << 10) - 56613888 + v52;
          v39 += 2;
          unsigned int v44 = (unsigned __int16)(((_WORD)v44 << 10) + 9216 + v52);
          uint64_t v49 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v48));
          char v47 = 0;
          uint64_t v152 = 2;
          if (!v49) {
            goto LABEL_54;
          }
        }
        if (((*(unsigned __int8 *)(v49 + ((unint64_t)v44 >> 3)) >> (v44 & 7)) & 1) == 0) {
          goto LABEL_54;
        }
        uint64_t v50 = v154;
        if ((v47 & 1) == 0) {
          uint64_t v50 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v48));
        }
        if (v50
          && *(unsigned char *)(v50 + ((unint64_t)v44 >> 8))
          && *(unsigned char *)(v50
                      + (*(unsigned __int8 *)(v50 + ((unint64_t)v44 >> 8)) << 8)
                      - 256
                      + v44
                      + 256)
          || (theForm & 2) != 0 && v48 - 55205 > 0xFFFFD45A)
        {
LABEL_54:
          uint64_t v51 = 0;
          goto LABEL_55;
        }
        uint64_t v51 = CFUniCharDecomposeCharacter(v48, Typed, 64);
LABEL_55:
        unint64_t v151 = v35;
        if (!(((unint64_t)theForm >> 1) & 1 | v137) || (unint64_t)v39 >= v35 && v51) {
          goto LABEL_126;
        }
        if (v51 < 1)
        {
          unsigned int v53 = (unsigned __int16)v48;
          if (v48 < 0x10000)
          {
            int v55 = 1;
LABEL_66:
            uint64_t v56 = v154;
            if (v154) {
              goto LABEL_69;
            }
            goto LABEL_122;
          }
        }
        else
        {
          unsigned int v53 = *v39;
          if ((v53 & 0xFC00) != 0xD800
            || (unint64_t)(v39 + 1) >= v35
            || (int v54 = v39[1], (v54 & 0xFC00) != 0xDC00))
          {
            int v55 = 1;
            unsigned int v48 = *v39;
            goto LABEL_66;
          }
          unsigned int v48 = (v53 << 10) - 56613888 + v54;
          unsigned int v53 = (unsigned __int16)(((_WORD)v53 << 10) + 9216 + v54);
        }
        uint64_t v56 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v48));
        int v55 = 0;
        if (v56)
        {
LABEL_69:
          if (*(unsigned char *)(v56 + ((unint64_t)v53 >> 8))
            && *(unsigned char *)(v56
                        + (*(unsigned __int8 *)(v56 + ((unint64_t)v53 >> 8)) << 8)
                        - 256
                        + v53
                        + 256))
          {
            if (v51)
            {
              BOOL v148 = v39;
              uint64_t v57 = 1;
              if (!v55) {
                uint64_t v57 = 2;
              }
              v152 += v57;
            }
            else
            {
              uint64_t v58 = 0x7FFFFFFFFFFFFFFELL;
              if (v55) {
                uint64_t v58 = 0x7FFFFFFFFFFFFFFFLL;
              }
              uint64_t v59 = &v39[v58];
              BOOL v148 = v59;
              if (v28 < 1)
              {
                uint64_t v51 = 0;
              }
              else
              {
                unsigned int v60 = *(v59 - 1);
                if ((v60 & 0xFC00) == 0xDC00 && v28 != 1 && (int v61 = *(v59 - 2), (v61 & 0xFC00) == 0xD800))
                {
                  unsigned int *Typed = v60 - 56613888 + (v61 << 10);
                  v28 -= 2;
                  v152 += 2;
                  uint64_t v51 = 1;
                }
                else
                {
                  unsigned int *Typed = v60;
                  ++v152;
                  uint64_t v51 = 1;
                  --v28;
                }
              }
            }
            if (v55) {
              uint64_t v62 = 1;
            }
            else {
              uint64_t v62 = 2;
            }
            uint64_t v63 = BitmapPtrForPlane;
            if ((v55 & 1) == 0) {
              uint64_t v63 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v48));
            }
            if (v63 && ((*(unsigned __int8 *)(v63 + ((unint64_t)v53 >> 3)) >> (v53 & 7)) & 1) != 0)
            {
              uint64_t v64 = CFUniCharDecomposeCharacter(v48, &Typed[v51], 64 - v51);
            }
            else
            {
              Typed[v51] = v48;
              uint64_t v64 = 1;
            }
            uint64_t v39 = &v148[v62];
            for (v51 += v64; ; v51 += v73)
            {
              if ((unint64_t)v39 >= v35) {
                goto LABEL_122;
              }
              unsigned int v65 = *v39;
              uint64_t v149 = v39;
              uint64_t v66 = v39 + 1;
              BOOL v67 = (v65 & 0xFC00) != 0xD800 || (unint64_t)v66 >= v35;
              if (v67 || (int v71 = *v66, (v71 & 0xFC00) != 0xDC00))
              {
                int v68 = 1;
                unsigned int v48 = v65;
                uint64_t v69 = v154;
                if (!v154) {
                  goto LABEL_121;
                }
              }
              else
              {
                unsigned int v48 = (v65 << 10) - 56613888 + v71;
                unsigned int v65 = (unsigned __int16)(((_WORD)v65 << 10) + 9216 + v71);
                uint64_t v69 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v48));
                int v68 = 0;
                if (!v69) {
                  goto LABEL_121;
                }
              }
              if (!*(unsigned char *)(v69 + ((unint64_t)v65 >> 8))
                || !*(unsigned char *)(v69
                             + (*(unsigned __int8 *)(v69 + ((unint64_t)v65 >> 8)) << 8)
                             - 256
                             + v65
                             + 256))
              {
                break;
              }
              if (v68) {
                uint64_t v70 = 1;
              }
              else {
                uint64_t v70 = 2;
              }
              if (v51 == v42)
              {
                uint64_t v42 = v51 + 64;
                if (Typed == (unsigned int *)__src)
                {
                  uint64_t Typed = (unsigned int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4 * (v51 + 64), 0x100004052888210, 0);
                  memmove(Typed, __src, 0x100uLL);
                }
                else
                {
                  uint64_t Typed = (unsigned int *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, 4 * (v51 + 64), 0x100004052888210, 0, 0);
                }
              }
              uint64_t v72 = BitmapPtrForPlane;
              if ((v68 & 1) == 0) {
                uint64_t v72 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v48));
              }
              if (v72 && ((*(unsigned __int8 *)(v72 + ((unint64_t)v65 >> 3)) >> (v65 & 7)) & 1) != 0)
              {
                uint64_t v73 = CFUniCharDecomposeCharacter(v48, &Typed[v51], 64 - v51);
              }
              else
              {
                Typed[v51] = v48;
                uint64_t v73 = 1;
              }
              uint64_t v39 = &v149[v70];
              unint64_t v35 = v151;
              v152 += v70;
            }
            unint64_t v35 = v151;
LABEL_121:
            uint64_t v39 = v149;
          }
        }
LABEL_122:
        BOOL v74 = v137;
        if (v51 <= 1) {
          BOOL v74 = 0;
        }
        if (v74) {
          CFUniCharPrioritySort(Typed, v51);
        }
LABEL_126:
        if (theForm)
        {
          if (v51)
          {
            if (v51 >= 1) {
              goto LABEL_132;
            }
          }
          else if (CFUniCharIsMemberOf(v48, 0x64u))
          {
            unsigned int *Typed = v48;
            uint64_t v51 = 1;
LABEL_132:
            uint64_t v75 = v39;
            do
            {
              uint64_t v76 = CFUniCharCompatibilityDecompose((int *)Typed, v51, v42);
              if (!v76)
              {
                v42 += 64;
                if (Typed == (unsigned int *)__src)
                {
                  uint64_t Typed = (unsigned int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4 * v42, 0x100004052888210, 0);
                  memmove(Typed, __src, 0x100uLL);
                }
                else
                {
                  uint64_t Typed = (unsigned int *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, 4 * v42, 0x100004052888210, 0, 0);
                }
              }
            }
            while (v76 < v51);
            uint64_t v51 = v76;
            uint64_t v39 = v75;
            goto LABEL_140;
          }
          uint64_t v51 = 0;
        }
LABEL_140:
        if ((theForm & 2) == 0) {
          goto LABEL_230;
        }
        uint64_t v145 = v28;
        if (v51 >= 2)
        {
          char v138 = 0;
          unsigned int v77 = 0;
          uint64_t v78 = *Typed;
          uint64_t v143 = Typed - 1;
          int64_t v79 = Typed;
          uint64_t v80 = 1;
          __int16 v150 = v39;
          do
          {
            unsigned int v144 = v77;
            int64_t v141 = v79;
            uint64_t v147 = v80;
            uint64_t v81 = v80;
            unsigned int v142 = v78;
            uint64_t v82 = v78;
            uint64_t v83 = v51;
LABEL_144:
            unint64_t v84 = &v143[v81];
            while (1)
            {
              uint64_t v85 = v84[1];
              uint64_t v86 = v154;
              if (v85 >= 0x10000) {
                uint64_t v86 = CFUniCharGetUnicodePropertyDataForPlane(0, WORD1(v85));
              }
              unsigned int v77 = v86 && *(unsigned char *)(v86 + BYTE1(v85))
                  ? *(unsigned __int8 *)(v86
                                       + (*(unsigned __int8 *)(v86 + BYTE1(v85)) << 8)
                                       - 256
                                       + v85
                                       + 256)
                  : 0;
              if ((theForm & 1) == 0) {
                break;
              }
              if ((v82 - 4352) <= 0xFE
                && ((v82 << 24) | 0xFFFFFFu) < 0x14FFFFFF
                && ((v85 << 16) - 293011456) >= 0xFFE90001)
              {
                v84[1] = 65533;
                uint64_t v88 = v81 + 1;
                if (v81 + 1 < v83 && (int v89 = v84[2] - 4519, (v89 << 16) <= 0x1C0000))
                {
                  uint64_t v88 = v81 + 2;
                  v84[2] = 65533;
                }
                else
                {
                  LOWORD(v89) = 0;
                }
                *int64_t v79 = 28 * ((((v85 << 16) - 291569664) >> 16) + 21 * v82)
                     + (__int16)v89
                     + 44032;
                if (v83 < 2)
                {
                  uint64_t v93 = v88;
                }
                else
                {
                  unint64_t v90 = v83 + 1;
                  uint64_t v91 = &v143[v83];
                  uint64_t v92 = -v83;
                  uint64_t v93 = v88;
                  do
                  {
                    if (*v91 == 65533)
                    {
                      --v93;
                      memmove(v91, v91 + 1, 4 * (v83 + v92));
                      --v83;
                    }
                    --v90;
                    --v91;
                    ++v92;
                  }
                  while (v90 > 2);
                }
                uint64_t v94 = v93;
                int64_t v79 = &Typed[v93];
                uint64_t v82 = *v79;
                uint64_t v81 = v94 + 1;
                if (v94 + 1 >= v83)
                {
                  uint64_t v51 = v83;
                  LODWORD(v78) = *v79;
                  goto LABEL_193;
                }
                goto LABEL_144;
              }
              uint64_t v87 = v153;
              if (v85 >= 0x10000) {
                uint64_t v87 = CFUniCharGetBitmapPtrForPlane(8u, WORD1(v85));
              }
              if (v87 && ((*(unsigned __int8 *)(v87 + ((unsigned __int16)v85 >> 3)) >> (v85 & 7)) & 1) != 0)
              {
                uint64_t v51 = v83;
                uint64_t v147 = v81;
                uint64_t v78 = v82;
                goto LABEL_176;
              }
              *int64_t v79 = v82;
              int64_t v79 = &Typed[v81++];
              ++v84;
              uint64_t v82 = v85;
              if (v81 >= v83)
              {
                uint64_t v51 = v83;
                LODWORD(v78) = v85;
                int64_t v79 = v84;
LABEL_193:
                CFMutableStringRef v2 = v139;
                uint64_t v28 = v145;
                unint64_t v35 = v151;
                uint64_t v39 = v150;
                goto LABEL_194;
              }
            }
            uint64_t v78 = v142;
            int64_t v79 = v141;
LABEL_176:
            CFMutableStringRef v2 = v139;
            uint64_t v28 = v145;
            unint64_t v35 = v151;
            if (v144 && v77 <= v144)
            {
              unsigned int v77 = v144;
              uint64_t v39 = v150;
            }
            else
            {
              unsigned int v95 = v85;
              uint64_t v96 = v78;
              uint64_t v97 = CFUniCharPrecomposeCharacter(v78, v95);
              uint64_t v78 = v96;
              uint64_t v39 = v150;
              if (v97 != 65533)
              {
                Typed[v147] = 65533;
                char v138 = 1;
                uint64_t v78 = v97;
                unsigned int v77 = v144;
              }
            }
            uint64_t v80 = v147 + 1;
          }
          while (v147 + 1 < v51);
LABEL_194:
          *int64_t v79 = v78;
          if ((v138 & 1) != 0 && v51 > 1)
          {
            unint64_t v101 = v51 + 1;
            CFRange v102 = &Typed[v51 - 1];
            uint64_t v103 = -v51;
            do
            {
              if (*v102 == 65533)
              {
                memmove(v102, v102 + 1, 4 * (v51 + v103));
                --v51;
                unint64_t v35 = v151;
              }
              --v101;
              --v102;
              ++v103;
            }
            while (v101 > 2);
            uint64_t v39 = v150;
          }
          goto LABEL_230;
        }
        if (v48 - 4352 < 0xFF)
        {
          if ((unint64_t)v39 >= v35) {
            goto LABEL_230;
          }
          if (((v48 << 24) | 0xFFFFFF) >= 0x14FFFFFF) {
            goto LABEL_230;
          }
          unsigned int v98 = *v39 - 4449;
          if (v98 > 0x15) {
            goto LABEL_230;
          }
          uint64_t v99 = v152 + 1;
          if ((unint64_t)(v39 + 1) >= v35)
          {
            LOWORD(v100) = 0;
            ++v152;
          }
          else
          {
            int v100 = v39[1] - 4519;
            if ((v100 << 16) <= 0x1C0000) {
              uint64_t v99 = v152 + 2;
            }
            uint64_t v152 = v99;
            if ((v100 << 16) > 0x1C0000) {
              LOWORD(v100) = 0;
            }
          }
          unsigned int *Typed = 28 * ((__int16)v98 + 21 * (char)v48) + (__int16)v100 + 44032;
LABEL_227:
          int64_t v114 = Typed + 1;
LABEL_232:
          unsigned int v115 = 0;
          int64_t v116 = Typed;
          do
          {
            int64_t v117 = v116 + 1;
            if (*((_WORD *)v116 + 1)) {
              int v118 = 2;
            }
            else {
              int v118 = 1;
            }
            v115 += v118;
            int64_t v116 = v117;
          }
          while (v117 < v114);
          char v119 = 0;
          goto LABEL_239;
        }
        if ((unint64_t)v39 >= v35) {
          goto LABEL_230;
        }
        while (1)
        {
          uint64_t v104 = v39;
          unint64_t v105 = *v39;
          uint64_t v106 = v104;
          uint64_t v107 = v104 + 1;
          if ((v105 & 0xFC00) == 0xD800 && (unint64_t)v107 < v35)
          {
            int v111 = *v107;
            if ((v111 & 0xFC00) == 0xDC00) {
              break;
            }
          }
          if (!v153
            || ((*(unsigned __int8 *)(v153 + (v105 >> 3)) >> (v105 & 7)) & 1) == 0
            || v154
            && *(unsigned char *)(v154 + (v105 >> 8))
            && *(unsigned char *)(v136 + (*(unsigned __int8 *)(v154 + (v105 >> 8)) << 8) - 256 + v105))
          {
            goto LABEL_229;
          }
LABEL_212:
          unsigned int v109 = CFUniCharPrecomposeCharacter(v48, v105);
          if (v109 == 65533) {
            goto LABEL_229;
          }
          unsigned int v48 = v109;
          uint64_t v110 = 1;
          if (v105 >= 0x10000) {
            uint64_t v110 = 2;
          }
          uint64_t v39 = &v106[v110];
          v152 += v110;
          unsigned int *Typed = v109;
          uint64_t v51 = 1;
          if ((unint64_t)v39 >= v35) {
            goto LABEL_227;
          }
        }
        LODWORD(v105) = (v105 << 10) - 56613888 + v111;
        uint64_t v112 = CFUniCharGetBitmapPtrForPlane(8u, WORD1(v105));
        if (v112 && ((*(unsigned __int8 *)(v112 + ((unsigned __int16)v105 >> 3)) >> (v111 & 7)) & 1) != 0)
        {
          uint64_t v113 = CFUniCharGetUnicodePropertyDataForPlane(0, WORD1(v105));
          if (v113 && *(unsigned char *)(v113 + BYTE1(v105)))
          {
            uint64_t v28 = v145;
            if (*(unsigned char *)(v113 + (*(unsigned __int8 *)(v113 + BYTE1(v105)) << 8) - 256 + v111 + 256)) {
              goto LABEL_229;
            }
          }
          else
          {
            uint64_t v28 = v145;
          }
          goto LABEL_212;
        }
        uint64_t v28 = v145;
LABEL_229:
        uint64_t v39 = v106;
LABEL_230:
        if (v51 >= 1)
        {
          int64_t v114 = &Typed[v51];
          if (v51) {
            goto LABEL_232;
          }
          unsigned int v115 = 0;
          char v119 = 1;
LABEL_239:
          uint64_t v120 = v115;
          if (v152 != v115)
          {
            v156[0] = v28;
            v156[1] = v152;
            __CFStringChangeSizeMultiple((uint64_t)v2, (uint64_t)v156, 1, v115, 1);
            uint64_t v152 = v120;
          }
          char v121 = atomic_load((unint64_t *)&v2->info);
          if ((v121 & 0x60) != 0)
          {
            uint64_t v122 = *v140;
          }
          else
          {
            char v123 = atomic_load((unint64_t *)&v2->info);
            uint64_t v122 = (char *)&v140[(v123 & 5) != 4];
          }
          char v124 = atomic_load((unint64_t *)&v2->info);
          char v125 = atomic_load((unint64_t *)&v2->info);
          uint64_t v126 = v125 & 0x60;
          if ((v124 & 5) == 4)
          {
            if (v126)
            {
              uint64_t v127 = *v140;
            }
            else
            {
              char v129 = atomic_load((unint64_t *)&v2->info);
              uint64_t v127 = (char *)&v140[(v129 & 5) != 4];
            }
            uint64_t v128 = *v127;
          }
          else if (v126)
          {
            uint64_t v128 = v2->length;
          }
          else
          {
            uint64_t v128 = (uint64_t)*v140;
          }
          if ((v119 & 1) == 0)
          {
            int64_t v130 = Typed;
            BOOL v131 = &v122[2 * v28];
            do
            {
              unsigned int v133 = *v130++;
              unsigned int v132 = v133;
              if (v133 < 0x10000)
              {
                UChar32 v135 = v131 + 2;
                LOWORD(v134) = v132;
              }
              else
              {
                unsigned int v134 = ((v132 + 67043328) >> 10) - 10240;
                UChar32 v135 = v131 + 4;
                *((_WORD *)v131 + 1) = v132 & 0x3FF | 0xDC00;
              }
              *(_WORD *)BOOL v131 = v134;
              BOOL v131 = v135;
            }
            while (v130 < v114);
          }
          unint64_t v35 = (unint64_t)&v122[2 * v128];
          uint64_t v39 = (unsigned __int16 *)&v122[2 * v28 + 2 * v120];
        }
        v28 += v152;
        if ((unint64_t)v39 >= v35)
        {
          if (Typed != (unsigned int *)__src) {
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
          }
          return;
        }
      }
    }
  }
}

uint64_t CFUniCharGetUnicodePropertyDataForPlane(unsigned int a1, unsigned int a2)
{
  if (*((_DWORD *)&__CFUniCharUnicodePropertyTable + 4 * a1) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*((void *)&__CFUniCharUnicodePropertyTable + 2 * a1 + 1) + 8 * a2);
  }
}

unsigned int *__CFUniCharPrioritySort(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = (unint64_t)&result[a2];
  if (a2 >= 1)
  {
    do
    {
      unint64_t v3 = *result;
      if (!(v3 >> 17))
      {
        uint64_t v4 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v3 >> 13) & 0x7FFF8));
        if (*(unsigned char *)(v4 + BYTE1(v3)))
        {
          if (*(unsigned char *)(v4 + (*(unsigned __int8 *)(v4 + BYTE1(v3)) << 8) - 256 + v3 + 256)) {
            break;
          }
        }
      }
      ++result;
    }
    while ((unint64_t)result < v2);
  }
  if ((uint64_t)(v2 - (void)result) >= 5)
  {
    do
    {
      unint64_t v5 = *result;
      if (v5 >> 17)
      {
        unsigned int v7 = 0;
      }
      else
      {
        uint64_t v6 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v5 >> 13) & 0x7FFF8));
        unsigned int v7 = *(unsigned __int8 *)(v6 + BYTE1(v5));
        if (*(unsigned char *)(v6 + BYTE1(v5))) {
          unsigned int v7 = *(unsigned __int8 *)(v6 + (v7 << 8) - 256 + v5 + 256);
        }
      }
      if ((unint64_t)(result + 1) >= v2) {
        break;
      }
      char v8 = 0;
      uint64_t v9 = result + 1;
      do
      {
        unint64_t v10 = *v9;
        if (v10 >> 17
          || (uint64_t v11 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v10 >> 13) & 0x7FFF8)),
              !*(unsigned char *)(v11 + BYTE1(v10))))
        {
          unsigned int v12 = 0;
        }
        else
        {
          unsigned int v12 = *(unsigned __int8 *)(v11
                                   + (*(unsigned __int8 *)(v11 + BYTE1(v10)) << 8)
                                   - 256
                                   + v10
                                   + 256);
        }
        if (v7 > v12)
        {
          int v13 = *(v9 - 1);
          *(v9 - 1) = v10;
          *uint64_t v9 = v13;
          char v8 = 1;
        }
        ++v9;
        unsigned int v7 = v12;
      }
      while ((unint64_t)v9 < v2);
    }
    while ((v8 & 1) != 0);
  }
  return result;
}

uint64_t CFUniCharDecomposeCharacter(unsigned int a1, unsigned int *a2, uint64_t a3)
{
  if (a1 - 44032 > 0x2BA4) {
    return __CFUniCharRecursivelyDecomposeCharacter(a1, a2, a3);
  }
  uint64_t v3 = 2;
  if ((unsigned __int16)(a1 + 21504) % 0x1Cu) {
    uint64_t v3 = 3;
  }
  if (v3 > a3) {
    return 0;
  }
  *a2 = ((28533 * (unsigned __int16)(a1 + 21504)) >> 24) | 0x1100;
  a2[1] = (unsigned __int16)(a1 + 21504) % 0x24Cu / 0x1C + 4449;
  if (!((unsigned __int16)(a1 + 21504) % 0x1Cu)) {
    return 2;
  }
  a2[2] = (unsigned __int16)((unsigned __int16)(a1 + 21504) % 0x1Cu + 4519);
  return 3;
}

uint64_t __CFUniCharRecursivelyDecomposeCharacter(unsigned int a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (a1 - 195102 < 0xFFFD06A2)
  {
LABEL_8:
    unsigned int v8 = 0;
    goto LABEL_9;
  }
  unint64_t v5 = (char *)&__CFUniCharDecompositionTable;
  uint64_t v6 = (char *)&__CFUniCharDecompositionTable + 16480;
  while (1)
  {
    unsigned int v7 = &v5[8 * ((v6 - v5) >> 4)];
    if (*(_DWORD *)v7 <= a1) {
      break;
    }
    uint64_t v6 = v7 - 8;
LABEL_7:
    if (v5 > v6) {
      goto LABEL_8;
    }
  }
  if (*(_DWORD *)v7 < a1)
  {
    unint64_t v5 = v7 + 8;
    goto LABEL_7;
  }
  unsigned int v8 = *((_DWORD *)v7 + 1);
LABEL_9:
  uint64_t v9 = HIBYTE(v8) & 0x1F;
  int v18 = v8 & 0xFFFFFF;
  unint64_t v10 = (int *)((char *)&__CFUniCharMultipleDecompositionTable + 4 * (v8 & 0xFFFFFF));
  uint64_t v11 = &v18;
  if ((v8 & 0x1E000000) != 0) {
    uint64_t v11 = (int *)((char *)&__CFUniCharMultipleDecompositionTable + 4 * (v8 & 0xFFFFFF));
  }
  uint64_t v12 = a3 - v9;
  if (a3 < v9) {
    return 0;
  }
  if ((v8 & 0x40000000) == 0)
  {
    uint64_t v13 = 0;
    goto LABEL_23;
  }
  uint64_t v13 = __CFUniCharRecursivelyDecomposeCharacter(*v11, a2, v12);
  if (!v13 || v13 + v9 - 1 > a3) {
    return 0;
  }
  uint64_t v16 = &v18;
  if (v9 > 1) {
    uint64_t v16 = v10;
  }
  uint64_t v11 = v16 + 1;
  v4 += v13;
  --v9;
LABEL_23:
  for (uint64_t result = v13 + v9; v9; --v9)
  {
    int v17 = *v11++;
    *v4++ = v17;
  }
  return result;
}

uint64_t CFUniCharCompatibilityDecompose(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (a2 >= 1)
  {
    unint64_t v5 = a1;
    unint64_t v6 = (unint64_t)&a1[a2];
    do
    {
      unsigned int v7 = *v5;
      if (CFUniCharIsMemberOf(*v5, 0x64u))
      {
        uint64_t v8 = __CFUniCharRecursivelyCompatibilityDecomposeCharacter(v7, v15);
        uint64_t v3 = v3 + v8 - 1;
        if (v3 > a3) {
          return 0;
        }
        if (v8 > 1)
        {
          if ((uint64_t)(v6 - (void)v5) < 5) {
            goto LABEL_10;
          }
          unint64_t v9 = (v6 - (unint64_t)v5) >> 2;
          do
            v5[v8 - 2 + v9] = v5[v9 - 1];
          while (v9-- > 2);
        }
        if (v8 >= 1)
        {
LABEL_10:
          unint64_t v11 = v8 + 1;
          uint64_t v12 = v15;
          do
          {
            int v13 = *v12++;
            *v5++ = v13;
            --v11;
          }
          while (v11 > 1);
        }
      }
      else
      {
        ++v5;
      }
    }
    while ((unint64_t)v5 < v6);
  }
  return v3;
}

uint64_t __CFUniCharRecursivelyCompatibilityDecomposeCharacter(unsigned int a1, _DWORD *a2)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (a1 - 130042 >= 0xFFFE04A6)
  {
    uint64_t v3 = (char *)&__CFUniCharCompatibilityDecompositionTable;
    uint64_t v4 = (char *)&__CFUniCharCompatibilityDecompositionTable + 30360;
    while (1)
    {
      unint64_t v5 = &v3[8 * ((v4 - v3) >> 4)];
      if (*(_DWORD *)v5 <= a1) {
        break;
      }
      uint64_t v4 = v5 - 8;
LABEL_7:
      if (v3 > v4) {
        return 0;
      }
    }
    if (*(_DWORD *)v5 < a1)
    {
      uint64_t v3 = v5 + 8;
      goto LABEL_7;
    }
    unint64_t v8 = *((unsigned int *)v5 + 1);
    uint64_t v6 = (v8 >> 24) & 0x1F;
    uint64_t v9 = v8 & 0xFFFFFF;
    int v18 = v9;
    if (v6)
    {
      unint64_t v10 = (unsigned int *)((char *)&__CFUniCharCompatibilityMultipleDecompositionTable + 4 * v9);
      if (v6 == 1) {
        unint64_t v11 = (unsigned int *)&v18;
      }
      else {
        unint64_t v11 = v10;
      }
      uint64_t v12 = v6 + 1;
      for (uint64_t i = 33 - v6; ; ++i)
      {
        unsigned int v15 = *v11++;
        uint64_t v14 = v15;
        uint64_t BitmapPtrForPlane = (unsigned __int8 *)&__CFUniCharCanonicalDecomposableCharacterSetBitmapPlane0_0;
        if ((v15 < 0x10000
           || (uint64_t BitmapPtrForPlane = (unsigned __int8 *)CFUniCharGetBitmapPtrForPlane(9u, BYTE2(v14))) != 0)
          && ((BitmapPtrForPlane[(unsigned __int16)v14 >> 3] >> (v14 & 7)) & 1) != 0)
        {
          uint64_t v17 = __CFUniCharRecursivelyDecomposeCharacter(v14, a2, i);
        }
        else
        {
          if (!CFUniCharIsMemberOf(v14, 0x64u))
          {
            *a2++ = v14;
            goto LABEL_23;
          }
          uint64_t v17 = __CFUniCharRecursivelyCompatibilityDecomposeCharacter(v14, a2);
        }
        a2 += v17;
        uint64_t v6 = v6 + v17 - 1;
LABEL_23:
        if ((unint64_t)--v12 <= 1) {
          return v6;
        }
      }
    }
  }
  return 0;
}

uint64_t __forwarding_prep_b___@<X0>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X4>, void *a6@<X5>, void *a7@<X6>, void *a8@<X7>, void *a9@<X8>, __n128 a10@<Q0>, __n128 a11@<Q1>, __n128 a12@<Q2>, __n128 a13@<Q3>, __n128 a14@<Q4>, __n128 a15@<Q5>, __n128 a16@<Q6>, __n128 a17@<Q7>)
{
  __n128 v26 = a17;
  __n128 v25 = a16;
  __n128 v24 = a15;
  __n128 v23 = a14;
  __n128 v22 = a13;
  __n128 v21 = a12;
  __n128 v20 = a11;
  __n128 v19 = a10;
  v18[8] = a9;
  v18[7] = a8;
  v18[6] = a7;
  v18[5] = a6;
  v18[4] = a5;
  v18[3] = a4;
  v18[2] = a3;
  v18[1] = a2;
  v18[0] = a1;
  return __block_forwarding___(v18);
}

uint64_t __block_forwarding___(id *a1)
{
  unint64_t v2 = *a1;
  Class Class = object_getClass(*a1);
  uint64_t Name = class_getName(Class);
  if (!strncmp(Name, "_NSZombie_", 0xAuLL)) {
    __block_forwarding____cold_1((__int16)v2, v5, v6, v7, v8, v9, v10, v11);
  }
  uint64_t v12 = _Block_signature(v2);
  if (!v12) {
    __block_forwarding____cold_2((__int16)v2, v13, v14, v15, v16, v17, v18, v19);
  }
  __n128 v20 = +[NSInvocation _invocationWithMethodSignature:frame:](NSBlockInvocation, "_invocationWithMethodSignature:frame:", +[NSMethodSignature signatureWithObjCTypes:v12], a1);
  [v20 setTarget:0];
  uint64_t v21 = v2[4];
  [v20[3] numberOfArguments];
  objc_opt_class();
  uint64_t v22 = [v20[3] frameLength];
  if (v22)
  {
    if ((v22 & 7) != 0) {
      goto LABEL_14;
    }
    for (uint64_t i = 0; i != 64; i += 8)
      ;
  }
  v20[6] = v23;
  if (!v21)
  {
    __break(1u);
LABEL_14:
    __block_forwarding____cold_3();
  }
  __n128 v25 = *(uint64_t (**)(uint64_t, id *))(v21 + 16);

  return v25(v21, v20);
}

void sub_182C200B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    __NSMethodFrameArgInfoDestroy(*v14);
    __NSMethodFrameArgInfoDestroy(v14[1]);
    free(v14);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_182C20130(_Unwind_Exception *a1)
{
}

uint64_t __CFSearchSignatureROM(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 <= 1024)
  {
    __int16 v4 = __CFStrHashEightBit2(a1, a2);
    unint64_t v5 = MethodSignatureROMTableHashData[v4 & 0x3FFF];
    uint64_t v2 = (v5 >> 3) - 1;
    uint64_t v6 = v5 & 7;
    uint64_t v7 = (const char **)(&MethodSignatureROMTable + 3 * (MethodSignatureROMTableHashData[v4 & 0x3FFF] >> 3) + 1);
    while (v6)
    {
      uint64_t v8 = *v7;
      v7 += 3;
      ++v2;
      --v6;
      if (!strcmp((const char *)a1, v8)) {
        return v2;
      }
    }
  }
  return -1;
}

uint64_t *parseFrameArgumentInfo(uint64_t *a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  v176[1] = *(void *)off_1ECE0A5B0;
  if (a4 >= 0x401)
  {
    CFStringRef v148 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: exceeded maximum nesting depth %d", 1024);
    uint64_t v149 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v148) userInfo:0];
    objc_exception_throw(v149);
  }
  unint64_t v5 = a1;
  uint64_t v173 = 0;
  uint64_t v6 = __NSGetSizeAndAlignment((unsigned char *)*a1, &v173, 0, *a1, 0, 0, 1uLL);
  uint64_t v7 = &v6[-*v5];
  uint64_t v8 = (char *)malloc_type_calloc(1uLL, (size_t)(v7 + 42), 0xC8F86945uLL);
  uint64_t v9 = (uint64_t *)v8;
  if (!v8)
  {
    CFStringRef v150 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: memory error - offset: %lu", a2);
    unint64_t v151 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v150) userInfo:0];
    objc_exception_throw(v151);
  }
  uint64_t v10 = v8 + 37;
  *((_DWORD *)v8 + 4) = v173;
  *((_DWORD *)v8 + 5) = a2;
  uint64_t v11 = (char *)*v5;
  int v169 = v8 + 37;
  if (*v5 < (unint64_t)v6)
  {
    uint64_t v163 = v5;
    unint64_t v164 = a4;
    unint64_t v12 = (unint64_t)&v10[(void)v7 + 2];
    unint64_t v161 = a4 + 1;
    if (a3) {
      __int16 v13 = 2048;
    }
    else {
      __int16 v13 = 6144;
    }
    __int16 v162 = v13;
    unint64_t v167 = a4 + 2;
    CFStringRef v158 = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended block spec '%s'; exceeded maximum nesting depth %d";
    CFStringRef format = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended block spec '%s'";
    CFStringRef v160 = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed array spec '%s'";
    unsigned int v165 = v6;
    while (2)
    {
      uint64_t v14 = v11 + 1;
      uint64_t v15 = *v11;
      unint64_t v172 = (unint64_t)(v11 + 1);
      char v16 = v15;
      switch((int)v15)
      {
        case '#':
          *((_WORD *)v9 + 17) |= 0x2000u;
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case '*':
          *((_WORD *)v9 + 17) |= 0x4000u;
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case '+':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          goto LABEL_75;
        case ':':
        case 'B':
        case 'v':
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case '@':
          *((_WORD *)v9 + 17) |= 0x2000u;
          *((unsigned char *)v9 + 36) = v15;
          unint64_t v35 = v169;
          if ((unint64_t)v169 >= v12) {
            goto LABEL_241;
          }
          *int v169 = v15;
          char v36 = ++v169;
          int v37 = *v14;
          if (v37 == 34)
          {
            uint64_t v91 = (unsigned __int8 *)(v11 + 2);
            unint64_t v172 = (unint64_t)(v11 + 2);
            if ((unint64_t)v36 >= v12) {
              goto LABEL_241;
            }
            uint64_t v92 = v35 + 2;
            int v169 = v35 + 2;
            v35[1] = 34;
            if (v164 >= 0x400)
            {
              CFStringRef v158 = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended object spec '%s'; exceeded maximum nesting depth %d";
              char v38 = v11 + 1;
LABEL_268:
              CFStringRef v147 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v158, v38, 1024, v157);
            }
            else
            {
              int v93 = *v91;
              if (*v91)
              {
                uint64_t v94 = 0;
                int v95 = *v91;
                uint64_t v6 = v165;
                while (v95 != 34)
                {
                  int v95 = v11[v94++ + 3];
                  if (!v95) {
                    goto LABEL_255;
                  }
                }
                if (!v94) {
                  goto LABEL_75;
                }
                unint64_t v96 = (unint64_t)&v11[v94 + 2];
                if (v93 == 60)
                {
                  uint64_t v97 = 0;
                  goto LABEL_198;
                }
                int64_t v117 = v11 + 2;
                if ((unint64_t)(v94 + 2) >= 3)
                {
                  int v118 = (unsigned __int8 *)(v11 + 3);
                  do
                  {
                    if ((unint64_t)v92 >= v12) {
                      goto LABEL_241;
                    }
                    *v92++ = v93;
                    BOOL v119 = (unint64_t)v118 >= v96;
                    int v120 = *v118++;
                    int v93 = v120;
                  }
                  while (!v119 && v93 != 60);
                  int v169 = v92;
                  int64_t v117 = (char *)(v118 - 1);
                }
                char v121 = (char *)malloc_type_calloc(1uLL, v117 - (char *)v91 + 40, 0x21A5C7D9uLL);
                uint64_t v97 = v121;
                if (v121)
                {
                  *((_WORD *)v121 + 17) |= 0x2000u;
                  strncpy(v121 + 37, v11 + 2, v117 - (char *)v91)[v117 - (char *)v91] = 0;
                  *uint64_t v9 = (uint64_t)v97;
                  uint64_t v91 = (unsigned __int8 *)v117;
LABEL_198:
                  if ((unsigned __int8 *)v96 == v91)
                  {
                    uint64_t v91 = (unsigned __int8 *)&v11[v94 + 2];
                  }
                  else
                  {
                    if (v11 - (char *)v91 + v94 + 2 >= 3 && *v91 == 60)
                    {
                      uint64_t v122 = v169;
                      while ((unint64_t)v122 < v12)
                      {
                        char v123 = v91 + 1;
                        unsigned char *v122 = 60;
                        char v124 = v122 + 1;
                        long long v171 = v124;
                        char v125 = v91 + 1;
                        if ((unint64_t)(v91 + 1) < v96)
                        {
                          int v126 = *v123;
                          char v125 = v91 + 1;
                          if (v126 != 62)
                          {
                            uint64_t v127 = v91 + 2;
                            do
                            {
                              if ((unint64_t)v124 >= v12) {
                                goto LABEL_241;
                              }
                              long long v171 = v124 + 1;
                              unsigned __int8 *v124 = v126;
                              BOOL v119 = (unint64_t)v127 >= v96;
                              int v128 = *v127++;
                              int v126 = v128;
                              if (v119) {
                                break;
                              }
                              ++v124;
                            }
                            while (v126 != 62);
                            char v125 = v127 - 1;
                          }
                        }
                        char v129 = (char *)malloc_type_calloc(1uLL, v125 - v123 + 40, 0xF8BB8CC4uLL);
                        int64_t v130 = v129;
                        if (!v129) {
                          goto LABEL_260;
                        }
                        *((_WORD *)v129 + 17) &= ~0x2000u;
                        strncpy(v129 + 37, (const char *)v91 + 1, v125 - v123)[v125 - v123] = 0;
                        BOOL v131 = (uint64_t *)(v97 + 8);
                        if (!v97) {
                          BOOL v131 = v9;
                        }
                        *BOOL v131 = (uint64_t)v130;
                        if ((unint64_t)v171 >= v12) {
                          break;
                        }
                        *long long v171 = *v125;
                        uint64_t v122 = v171 + 1;
                        int v169 = v171 + 1;
                        uint64_t v91 = v125 + 1;
                        if (&v11[v94] - (char *)v125 + 1 >= 3)
                        {
                          uint64_t v97 = v130;
                          if (v125[1] == 60) {
                            continue;
                          }
                        }
                        goto LABEL_216;
                      }
LABEL_241:
                      int64_t v141 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0);
LABEL_242:
                      objc_exception_throw(v141);
                    }
LABEL_216:
                    if ((unint64_t)v91 > v96)
                    {
LABEL_222:
                      uint64_t v116 = (uint64_t)&v11[v94 + 3];
                      goto LABEL_223;
                    }
                  }
                  unsigned int v132 = v169;
                  while ((unint64_t)v132 < v12)
                  {
                    char v133 = *v91++;
                    *v132++ = v133;
                    int v169 = v132;
                    if ((unint64_t)v91 > v96) {
                      goto LABEL_222;
                    }
                  }
                  goto LABEL_241;
                }
LABEL_260:
                CFStringRef v147 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: memory error - offset: %lu", a2, v156, v157);
              }
              else
              {
LABEL_255:
                CFStringRef format = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended object spec '%s'";
                char v38 = v11 + 1;
LABEL_256:
                CFStringRef v147 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, v38, v156, v157);
              }
            }
            int64_t v141 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v147) userInfo:0];
            goto LABEL_242;
          }
          uint64_t v6 = v165;
          if (v37 != 63) {
            goto LABEL_75;
          }
          *((_WORD *)v9 + 17) |= 0x8000u;
          char v38 = v11 + 2;
          unint64_t v172 = (unint64_t)(v11 + 2);
          if ((unint64_t)v36 >= v12) {
            goto LABEL_241;
          }
          int v169 = v35 + 2;
          v35[1] = *v14;
          uint64_t v6 = v165;
          if (*v38 != 60) {
            goto LABEL_75;
          }
          uint64_t v39 = (unsigned __int8 *)(v11 + 3);
          unint64_t v172 = (unint64_t)(v11 + 3);
          if ((unint64_t)(v35 + 2) >= v12) {
            goto LABEL_241;
          }
          uint64_t v40 = v35 + 3;
          v35[2] = 60;
          if (v164 > 0x3FF) {
            goto LABEL_268;
          }
          int v41 = *v39;
          if (!*v39) {
            goto LABEL_256;
          }
          uint64_t v42 = 0;
          uint64_t v43 = 0;
          while (1)
          {
            if (v41 != 62)
            {
              uint64_t v44 = v41 == 60;
              goto LABEL_69;
            }
            if (!v43) {
              break;
            }
            uint64_t v44 = -1;
LABEL_69:
            v43 += v44;
            int v41 = v11[v42++ + 4];
            if (!v41) {
              goto LABEL_256;
            }
          }
          int v100 = v40;
          if ((unint64_t)(v42 + 3) >= 4)
          {
            uint64_t v101 = 0;
            unint64_t v102 = 0;
            int v100 = v40;
            do
            {
              unint64_t v175 = 0;
              v176[0] = 0;
              __NSGetSizeAndAlignment(v39, v176, (uint64_t *)&v175, (uint64_t)v39, 1, 0, 1uLL);
              unint64_t v103 = v175;
              if (!v175)
              {
                unint64_t v175 = 1;
                unint64_t v103 = 1;
              }
              unint64_t v104 = (v103 + v102 - 1) / v103 * v103;
              uint64_t v105 = parseFrameArgumentInfo(&v172, v104 + a2, 1, v167);
              uint64_t v112 = v105;
              if (!v105)
              {
                CFStringRef v136 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'", v172);
                BOOL v137 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v136) userInfo:0];
                objc_exception_throw(v137);
              }
              uint64_t v113 = v176[0];
              if (v176[0] != *(_DWORD *)(v105 + 16))
              {
                uint64_t v156 = v105 + 37;
                uint64_t v157 = *(unsigned int *)(v105 + 16);
                CFLog(4, @"*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)", v106, v107, v108, v109, v110, v111, v176[0]);
                uint64_t v113 = *(unsigned int *)(v112 + 16);
              }
              LOBYTE(v114) = *(unsigned char *)(v112 + 37);
              if ((_BYTE)v114)
              {
                uint64_t v115 = 0;
                do
                {
                  if ((unint64_t)&v100[v115] >= v12) {
                    objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
                  }
                  v100[v115] = v114;
                  int v114 = *(unsigned __int8 *)(v112 + v115++ + 38);
                }
                while (v114);
                v100 += v115;
              }
              if (!*v9) {
                *uint64_t v9 = v112;
              }
              if (v101) {
                *(void *)(v101 + 8) = v112;
              }
              unint64_t v102 = v113 + v104;
              uint64_t v39 = (unsigned __int8 *)v172;
              uint64_t v101 = v112;
            }
            while (v172 < (unint64_t)&v11[v42 + 3]);
          }
          if ((unint64_t)v100 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          int v169 = v100 + 1;
          *int v100 = 62;
          uint64_t v116 = (uint64_t)&v11[v42 + 4];
LABEL_223:
          unint64_t v172 = v116;
          uint64_t v6 = v165;
LABEL_75:
          uint64_t v11 = (char *)v172;
          if (v172 >= (unint64_t)v6)
          {
            uint64_t v10 = v169;
            unint64_t v5 = v163;
            break;
          }
          continue;
        case 'C':
        case 'I':
        case 'L':
        case 'Q':
        case 'S':
        case 'T':
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'D':
        case 'd':
        case 'f':
          *((_WORD *)v9 + 17) |= 0x200u;
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'N':
          *((_WORD *)v9 + 17) |= 3u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'O':
          *((_WORD *)v9 + 17) |= 4u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'R':
          *((_WORD *)v9 + 17) |= 8u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'V':
          *((_WORD *)v9 + 17) |= 0x20u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case '[':
          *((unsigned char *)v9 + 36) = v15;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          *int v169 = v15;
          uint64_t v21 = v169 + 1;
          *((_WORD *)v9 + 17) |= v162;
          if (v164 >= 0x400)
          {
            CFStringRef v144 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: malformed array spec '%s'; exceeded maximum nesting depth %d",
                     v11,
                     1024);
          }
          else
          {
            int v22 = *v14;
            if (*v14)
            {
              uint64_t v23 = 0;
              __n128 v24 = (unsigned __int8 *)(v11 + 2);
              int v25 = *v14;
              while (1)
              {
                if (v25 != 93)
                {
                  uint64_t v26 = v25 == 91;
                  goto LABEL_30;
                }
                if (!v23) {
                  break;
                }
                uint64_t v26 = -1;
LABEL_30:
                v23 += v26;
                int v27 = *v24++;
                int v25 = v27;
                if (!v27) {
                  goto LABEL_252;
                }
              }
              if ((v22 - 48) > 9)
              {
                unint64_t v172 = (unint64_t)(v11 + 1);
                goto LABEL_262;
              }
              uint64_t v45 = 0;
              unint64_t v46 = 0;
              do
              {
                if (v46 >= 0x19999999)
                {
                  unint64_t v172 = (unint64_t)&v11[v45 + 1];
                  uint64_t v143 = @"+[NSMethodSignature signatureWithObjCTypes:]: array too large in spec '%s'";
                  goto LABEL_251;
                }
                if ((unint64_t)&v21[v45] >= v12)
                {
                  unint64_t v172 = (unint64_t)&v11[v45 + 1];
                  goto LABEL_234;
                }
                unint64_t v46 = (v22 - 48) + 10 * v46;
                v21[v45] = v22;
                int v22 = v11[v45++ + 2];
              }
              while ((v22 - 48) < 0xA);
              char v47 = &v11[v45 + 1];
              unint64_t v172 = (unint64_t)v47;
              BOOL v170 = &v21[v45];
              if (v46 - 65537 >= 0xFFFFFFFFFFFF0000)
              {
                unint64_t v175 = 0;
                v176[0] = 0;
                __NSGetSizeAndAlignment(v47, v176, (uint64_t *)&v175, (uint64_t)v47, 1, 0, 1uLL);
                if (!v175) {
                  unint64_t v175 = 1;
                }
                uint64_t v48 = 0;
                unint64_t v49 = 0;
                uint64_t v50 = v170;
                while (1)
                {
                  unint64_t v51 = (v175 + v49 - 1) / v175 * v175;
                  uint64_t v174 = v47;
                  uint64_t v52 = parseFrameArgumentInfo(&v174, v51 + a2, a3, v167);
                  uint64_t v59 = v52;
                  if (!v52)
                  {
                    CFStringRef v145 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'", v11);
                    int64_t v146 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v145) userInfo:0];
                    objc_exception_throw(v146);
                  }
                  uint64_t v60 = v176[0];
                  if (v176[0] != *(_DWORD *)(v52 + 16))
                  {
                    uint64_t v156 = v52 + 37;
                    uint64_t v157 = *(unsigned int *)(v52 + 16);
                    CFLog(4, @"*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)", v53, v54, v55, v56, v57, v58, v176[0]);
                    uint64_t v60 = *(unsigned int *)(v59 + 16);
                  }
                  if (!*v9) {
                    break;
                  }
                  if (v48) {
                    goto LABEL_91;
                  }
LABEL_92:
                  unint64_t v49 = v60 + v51;
                  uint64_t v48 = v59;
                  if (!--v46)
                  {
                    if ((unint64_t)v50 >= v12) {
                      goto LABEL_234;
                    }
                    int v169 = v50 + 1;
                    *uint64_t v50 = 93;
                    unint64_t v172 = (unint64_t)v24;
                    int v66 = (v175 + v49 - 1) / v175 * v175;
LABEL_167:
                    *((_DWORD *)v9 + 4) = v66;
                    uint64_t v6 = v165;
                    if (v66) {
                      goto LABEL_75;
                    }
LABEL_168:
                    if (*v9)
                    {
                      __NSMethodFrameArgInfoDestroy((void *)*v9);
                      *uint64_t v9 = 0;
                    }
                    goto LABEL_75;
                  }
                }
                char v61 = *(unsigned char *)(v59 + 37);
                if (v61)
                {
                  uint64_t v62 = (unsigned __int8 *)(v59 + 38);
                  while ((unint64_t)v50 < v12)
                  {
                    *v50++ = v61;
                    int v63 = *v62++;
                    char v61 = v63;
                    if (!v63) {
                      goto LABEL_98;
                    }
                  }
LABEL_234:
                  int64_t v139 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0);
LABEL_235:
                  objc_exception_throw(v139);
                }
LABEL_98:
                *uint64_t v9 = v59;
                if (!v48) {
                  goto LABEL_92;
                }
LABEL_91:
                *(void *)(v48 + 8) = v59;
                goto LABEL_92;
              }
LABEL_262:
              uint64_t v143 = @"+[NSMethodSignature signatureWithObjCTypes:]: array too small or too large in spec '%s'";
LABEL_251:
              CFStringRef v160 = v143;
            }
LABEL_252:
            CFStringRef v144 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v160, v11, v156, v157);
          }
          int64_t v139 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v144) userInfo:0];
          goto LABEL_235;
        case '^':
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v18 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          *int v169 = v16;
          uint64_t v19 = v169 + 1;
          int v20 = *v14;
          if (v20 == 118 || v20 == 63)
          {
            unint64_t v172 = (unint64_t)(v11 + 2);
            if ((unint64_t)v19 >= v12) {
              objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
            }
            v169 += 2;
            v18[1] = v20;
          }
          else
          {
            uint64_t v88 = parseFrameArgumentInfo(&v172, 0, a3, v161);
            if (!v88)
            {
              CFStringRef v154 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'", *v163);
              uint64_t v155 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v154) userInfo:0];
              objc_exception_throw(v155);
            }
            LOBYTE(v89) = *(unsigned char *)(v88 + 37);
            if ((_BYTE)v89)
            {
              uint64_t v90 = 0;
              do
              {
                if ((unint64_t)&v19[v90] >= v12) {
                  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
                }
                v19[v90] = v89;
                int v89 = *(unsigned __int8 *)(v88 + v90++ + 38);
              }
              while (v89);
              v19 += v90;
            }
            int v169 = v19;
            if (*(_DWORD *)(v88 + 16))
            {
              *uint64_t v9 = v88;
              *((_WORD *)v9 + 17) |= 0x1000u;
            }
            else
            {
              __NSMethodFrameArgInfoDestroy((void *)v88);
            }
          }
          goto LABEL_75;
        case 'c':
        case 'i':
        case 'l':
        case 'q':
        case 's':
        case 't':
          *((_WORD *)v9 + 17) |= 0x100u;
          *((unsigned char *)v9 + 36) = v15;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'n':
          *((_WORD *)v9 + 17) |= 1u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'o':
          *((_WORD *)v9 + 17) |= 2u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          goto LABEL_74;
        case 'r':
          *((_WORD *)v9 + 17) |= 0x10u;
          uint64_t v17 = v169;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
LABEL_74:
          *uint64_t v17 = v15;
          int v169 = v17 + 1;
          goto LABEL_75;
        case '{':
          *((unsigned char *)v9 + 36) = v15;
          if ((unint64_t)v169 >= v12) {
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
          }
          *int v169 = v15;
          uint64_t v28 = v169 + 1;
          *((_WORD *)v9 + 17) |= 0x400u;
          if (v164 >= 0x400)
          {
            CFStringRef v142 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec '%s'; exceeded maximum nesting depth %d",
                     v11,
                     1024);
          }
          else
          {
            char v29 = *v14;
            if (*v14)
            {
              uint64_t v30 = 0;
              char v31 = (unsigned __int8 *)(v11 + 2);
              char v32 = *v14;
              do
              {
                if (v32 == 125)
                {
                  if (!v30)
                  {
                    unint64_t v64 = (unint64_t)(v31 - 1);
                    for (unint64_t i = 1; ; v29 = v11[i])
                    {
                      if (v29 > 60)
                      {
                        if (v29 == 61)
                        {
                          BOOL v67 = &v11[i];
                          if (i >= 2)
                          {
                            unsigned int v98 = v11 + 1;
                            while (1)
                            {
                              uint64_t v14 = v98 + 1;
                              if ((unint64_t)v28 >= v12) {
                                break;
                              }
                              *v28++ = *v98++;
                              if (v14 >= v67) {
                                goto LABEL_113;
                              }
                            }
                            unint64_t v172 = (unint64_t)(v98 + 1);
LABEL_239:
                            int64_t v140 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0);
LABEL_240:
                            objc_exception_throw(v140);
                          }
LABEL_113:
                          unint64_t v172 = (unint64_t)v14;
                          if (*v67 != 61)
                          {
                            if ((unint64_t)v28 < v12)
                            {
                              unsigned char *v28 = 125;
                              int v169 = v28 + 1;
                              unint64_t v172 = (unint64_t)v31;
                              uint64_t v87 = malloc_type_calloc(1uLL, 0x29uLL, 0xDD01A950uLL);
                              v87[37] = 0;
                              *((_DWORD *)v87 + 5) = a2;
                              *uint64_t v9 = (uint64_t)v87;
                              if (*((_DWORD *)v9 + 4)) {
                                goto LABEL_75;
                              }
                              goto LABEL_168;
                            }
                            goto LABEL_239;
                          }
                          if ((unint64_t)v28 >= v12) {
                            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
                          }
                          unsigned char *v28 = 61;
                          int v68 = v28 + 1;
                          uint64_t v69 = v67 + 1;
                          unint64_t v172 = (unint64_t)(v67 + 1);
                          if ((unint64_t)(v67 + 1) >= v64)
                          {
                            unint64_t v72 = 0;
                            unint64_t v71 = 0;
LABEL_162:
                            if ((unint64_t)v68 >= v12) {
                              objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
                            }
                            int v169 = v68 + 1;
                            *int v68 = 125;
                            unint64_t v172 = (unint64_t)v31;
                            if (v72 <= 1) {
                              unint64_t v99 = 1;
                            }
                            else {
                              unint64_t v99 = v72;
                            }
                            int v66 = (v71 + v99 - 1) / v99 * v99;
                            goto LABEL_167;
                          }
                          uint64_t v70 = 0;
                          unint64_t v71 = 0;
                          unint64_t v72 = 0;
                          while (2)
                          {
                            unint64_t v175 = 0;
                            v176[0] = 0;
                            __NSGetSizeAndAlignment(v69, v176, (uint64_t *)&v175, (uint64_t)v69, 1, 0, 1uLL);
                            unint64_t v73 = v175;
                            if (v72 <= v175) {
                              unint64_t v72 = v175;
                            }
                            if (!v175)
                            {
                              unint64_t v175 = 1;
                              unint64_t v73 = 1;
                            }
                            unint64_t v74 = (v73 + v71 - 1) / v73 * v73;
                            uint64_t v75 = parseFrameArgumentInfo(&v172, v74 + a2, 1, v167);
                            uint64_t v82 = v75;
                            if (!v75)
                            {
                              CFStringRef v134 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'", v172);
                              UChar32 v135 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v134) userInfo:0];
                              objc_exception_throw(v135);
                            }
                            uint64_t v83 = v176[0];
                            if (v176[0] != *(_DWORD *)(v75 + 16))
                            {
                              uint64_t v156 = v75 + 37;
                              uint64_t v157 = *(unsigned int *)(v75 + 16);
                              CFLog(4, @"*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)", v76, v77, v78, v79, v80, v81, v176[0]);
                              uint64_t v83 = *(unsigned int *)(v82 + 16);
                            }
                            char v84 = *(unsigned char *)(v82 + 37);
                            if (v84)
                            {
                              uint64_t v85 = (unsigned __int8 *)(v82 + 38);
                              do
                              {
                                if ((unint64_t)v68 >= v12) {
                                  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
                                }
                                *v68++ = v84;
                                int v86 = *v85++;
                                char v84 = v86;
                              }
                              while (v86);
                            }
                            if (*v9)
                            {
                              if (v70) {
                                goto LABEL_130;
                              }
                            }
                            else
                            {
                              *uint64_t v9 = v82;
                              if (v70) {
LABEL_130:
                              }
                                *(void *)(v70 + 8) = v82;
                            }
                            unint64_t v71 = v83 + v74;
                            uint64_t v69 = (unsigned char *)v172;
                            uint64_t v70 = v82;
                            if (v172 >= v64) {
                              goto LABEL_162;
                            }
                            continue;
                          }
                        }
                        if (v29 == 125) {
                          goto LABEL_112;
                        }
                      }
                      else if (!v29 || v29 == 41)
                      {
LABEL_112:
                        BOOL v67 = v11 + 1;
                        goto LABEL_113;
                      }
                      if (v29) {
                        ++i;
                      }
                    }
                  }
                  uint64_t v33 = -1;
                }
                else
                {
                  uint64_t v33 = v32 == 123;
                }
                v30 += v33;
                int v34 = *v31++;
                char v32 = v34;
              }
              while (v34);
            }
            CFStringRef v142 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec '%s'", v11, v156, v157);
          }
          int64_t v140 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v142) userInfo:0];
          goto LABEL_240;
        default:
          __NSMethodFrameArgInfoDestroy(v9);
          CFStringRef v152 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%c' in '%s'", v15, *v163);
          uint64_t v153 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v152) userInfo:0];
          objc_exception_throw(v153);
      }
      break;
    }
  }
  *uint64_t v10 = 0;
  *unint64_t v5 = (uint64_t)v6;
  if (!*((unsigned char *)v9 + 36))
  {
    __NSMethodFrameArgInfoDestroy(v9);
    return 0;
  }
  return v9;
}

void sub_182C21948(_Unwind_Exception *a1, int a2)
{
  objc_end_catch();
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    __NSMethodFrameArgInfoDestroy(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_182C21A6C(_Unwind_Exception *a1)
{
}

void sub_182C21A94(_Unwind_Exception *a1)
{
}

void sub_182C21AA0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  sub_182C21A6C(a1);
}

void sub_182C21AA8()
{
}

void sub_182C21AD0()
{
}

unsigned char *__NSGetSizeAndAlignment(unsigned char *result, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  uint64_t v9 = result;
  v71[1] = *(void *)off_1ECE0A5B0;
  if (a3) {
    *a3 = 0;
  }
  if (a2) {
    *a2 = 0;
  }
  while (2)
  {
    uint64_t v10 = result;
    unsigned int v12 = (char)*result++;
    uint64_t v11 = v12;
    switch(v12)
    {
      case '""':
        uint64_t result = v10 + 2;
LABEL_7:
        if (*(result - 1) == 34) {
          continue;
        }
        if (*(result - 1))
        {
          ++result;
          goto LABEL_7;
        }
        CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): unterminated ivar name spec at '%s' in '%s'", v9, a4);
        goto LABEL_159;
      case '#':
      case '*':
      case ':':
      case 'D':
      case 'Q':
      case 'd':
      case 'q':
        goto LABEL_41;
      case '$':
      case '%':
      case '&':
      case '\'':
      case ')':
      case ',':
      case '-':
      case '.':
      case '/':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case 'A':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'J':
      case 'K':
      case 'M':
      case 'P':
      case 'U':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '\\':
      case ']':
      case '_':
      case 'a':
      case 'b':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'p':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
        goto LABEL_160;
      case '(':
        uint64_t v21 = "union";
        int v22 = 41;
        goto LABEL_66;
      case '+':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'N':
      case 'O':
      case 'R':
      case 'V':
      case 'n':
      case 'o':
      case 'r':
        continue;
      case '@':
        if (a3) {
          *a3 = 8;
        }
        if (a2) {
          *a2 = 8;
        }
        int v23 = *result;
        if (v23 == 34)
        {
          int v44 = v10[2];
          if (v10[2])
          {
            uint64_t result = v10 + 3;
            while (v44 != 34)
            {
              int v45 = *result++;
              int v44 = v45;
              if (!v45) {
                goto LABEL_128;
              }
            }
            goto LABEL_46;
          }
LABEL_128:
          CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed extended class info spec at '%s' in '%s'", v9, a4);
        }
        else
        {
          if (v23 != 63) {
            goto LABEL_46;
          }
          uint64_t result = v10 + 2;
          if (v10[2] != 60) {
            goto LABEL_46;
          }
          int v24 = v10[3];
          if (v10[3])
          {
            uint64_t v25 = 0;
            uint64_t result = v10 + 4;
            do
            {
              if (v24 == 62)
              {
                if (!v25) {
                  goto LABEL_46;
                }
                uint64_t v26 = -1;
              }
              else
              {
                uint64_t v26 = v24 == 60;
              }
              v25 += v26;
              int v27 = *result++;
              int v24 = v27;
            }
            while (v27);
          }
          CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed extended block spec at '%s' in '%s'", v9, a4);
        }
        goto LABEL_159;
      case 'B':
      case 'C':
      case 'c':
        if (a3) {
          *a3 = 1;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 1;
        goto LABEL_45;
      case 'I':
      case 'L':
      case 'f':
      case 'i':
      case 'l':
        if (a3) {
          *a3 = 4;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 4;
        goto LABEL_45;
      case 'S':
      case 's':
        if (a3) {
          *a3 = 2;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 2;
        goto LABEL_45;
      case 'T':
      case 't':
        if (a3) {
          *a3 = 16;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 16;
        goto LABEL_45;
      case '[':
        if (a6 >= 0x200) {
          goto LABEL_162;
        }
        int v14 = *result;
        if (!*result) {
          goto LABEL_36;
        }
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        int v17 = *result;
        while (1)
        {
          if (v17 == 93)
          {
            if (!v16)
            {
              if ((v14 - 48) > 9)
              {
                if (v15)
                {
                  unint64_t v35 = 0;
                  goto LABEL_111;
                }
                goto LABEL_36;
              }
              unint64_t v35 = 0;
              uint64_t v36 = v15;
              while (v35 < 0x19999999)
              {
                unint64_t v35 = (v14 - 48) + 10 * v35;
                int v37 = *++result;
                int v14 = v37;
                --v36;
                if ((v37 - 48) >= 0xA)
                {
                  if (v36)
                  {
                    if (v35 && !is_mul_ok(v35, a7))
                    {
                      CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): cumulative nesting of arrays has reached ridiculous proportions at '%s' in '%s'", v9, a4);
                      goto LABEL_159;
                    }
LABEL_111:
                    unint64_t v38 = (unint64_t)&v10[v15 + 1];
                    unint64_t v39 = v35 * a7;
                    uint64_t v70 = 0;
                    v71[0] = 0;
                    uint64_t v40 = (unsigned char *)__NSGetSizeAndAlignment(result, v71, &v70, a4, a5, a6 + 1, v35 * a7);
                    uint64_t v41 = v71[0];
                    if (!v71[0])
                    {
                      CFStringRef v61 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed array spec or array too large at '%s' in '%s'", v9, a4);
                      uint64_t v62 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v61) userInfo:0];
                      objc_exception_throw(v62);
                    }
                    if (!v40 || (unint64_t)v40 > v38 || *v40 != 93)
                    {
                      CFStringRef v59 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s'", v9, a4);
                      uint64_t v60 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v59) userInfo:0];
                      objc_exception_throw(v60);
                    }
                    unint64_t v42 = v70;
                    if (a3) {
                      *a3 = v70;
                    }
                    uint64_t result = v40 + 1;
                    if (!v42)
                    {
                      unint64_t v42 = 1;
                      uint64_t v70 = 1;
                    }
                    if (a2)
                    {
                      if (__CFADD__(v42, v41))
                      {
                        CFStringRef v63 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): array too large at '%s' in '%s'", v9, a4);
                        unint64_t v64 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v63) userInfo:0];
                        objc_exception_throw(v64);
                      }
                      unint64_t v43 = (v42 + v41 - 1) / v42 * v42;
                      if (v35 > 0xFFFFFFFFFFFFFFFFLL / v43)
                      {
                        CFStringRef v65 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): array too large at '%s' in '%s'", v9, a4);
                        int v66 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v65) userInfo:0];
                        objc_exception_throw(v66);
                      }
                      if (v39 > 0xFFFFFFFFFFFFFFFFLL / v43)
                      {
                        CFStringRef v67 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): cumulative nested array has reached ridiculous size at '%s' in '%s'", v9, a4);
                        int v68 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v67) userInfo:0];
                        objc_exception_throw(v68);
                      }
                      uint64_t v13 = v43 * v35;
LABEL_45:
                      *a2 = v13;
                    }
                    goto LABEL_46;
                  }
LABEL_36:
                  CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s'", v9, a4);
                  goto LABEL_159;
                }
              }
              CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s' -- size is too large", v9, a4);
LABEL_159:
              uint64_t v58 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v19) userInfo:0];
              objc_exception_throw(v58);
            }
            uint64_t v18 = -1;
          }
          else
          {
            uint64_t v18 = v17 == 91;
          }
          v16 += v18;
          int v17 = v10[v15++ + 2];
          if (!v17) {
            goto LABEL_36;
          }
        }
      case '^':
        if (a6 >= 0x200) {
          goto LABEL_162;
        }
        int v20 = *result;
        if (v20 == 118 || v20 == 63)
        {
          uint64_t result = v10 + 2;
LABEL_41:
          if (a3) {
            *a3 = 8;
          }
          if (a2)
          {
            uint64_t v13 = 8;
            goto LABEL_45;
          }
LABEL_46:
          if (*result == 43) {
            ++result;
          }
          return result;
        }
        switch((char)v20)
        {
          case '(':
            int v54 = v10[2];
            if (v10[2])
            {
              uint64_t v55 = 0;
              uint64_t result = v10 + 3;
              do
              {
                if (v54 == 41)
                {
                  if (!v55) {
                    goto LABEL_41;
                  }
                  uint64_t v56 = -1;
                }
                else
                {
                  uint64_t v56 = v54 == 40;
                }
                v55 += v56;
                int v57 = *result++;
                int v54 = v57;
              }
              while (v57);
            }
            break;
          case '[':
            int v50 = v10[2];
            if (v10[2])
            {
              uint64_t v51 = 0;
              uint64_t result = v10 + 3;
              do
              {
                if (v50 == 93)
                {
                  if (!v51) {
                    goto LABEL_41;
                  }
                  uint64_t v52 = -1;
                }
                else
                {
                  uint64_t v52 = v50 == 91;
                }
                v51 += v52;
                int v53 = *result++;
                int v50 = v53;
              }
              while (v53);
            }
            break;
          case '{':
            int v46 = v10[2];
            if (v10[2])
            {
              uint64_t v47 = 0;
              uint64_t result = v10 + 3;
              do
              {
                if (v46 == 125)
                {
                  if (!v47) {
                    goto LABEL_41;
                  }
                  uint64_t v48 = -1;
                }
                else
                {
                  uint64_t v48 = v46 == 123;
                }
                v47 += v48;
                int v49 = *result++;
                int v46 = v49;
              }
              while (v49);
            }
            break;
          default:
            uint64_t result = (unsigned char *)((uint64_t (*)(void))__NSGetSizeAndAlignment)();
            if (result) {
              goto LABEL_41;
            }
            break;
        }
        CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed pointed-to-type spec at '%s' in '%s'", v9, a4);
        goto LABEL_159;
      case 'v':
        goto LABEL_46;
      case '{':
        uint64_t v21 = "struct";
        int v22 = 125;
LABEL_66:
        if (a6 >= 0x200)
        {
LABEL_162:
          CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): type encoding string '%s' contains too many nesting levels", a4);
          goto LABEL_159;
        }
        if (!*result) {
          goto LABEL_74;
        }
        uint64_t v28 = 0;
        unsigned __int8 v29 = *result;
        uint64_t v30 = result;
        while (2)
        {
          if (v22 != (char)v29)
          {
            uint64_t v31 = v29 == v11;
LABEL_73:
            v28 += v31;
            int v32 = *++v30;
            unsigned __int8 v29 = v32;
            if (!v32)
            {
LABEL_74:
              CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): malformed %s spec at '%s' in '%s'", v21, v9, a4);
              goto LABEL_159;
            }
            continue;
          }
          break;
        }
        if (v28)
        {
          uint64_t v31 = -1;
          goto LABEL_73;
        }
        char v33 = *result;
        int v34 = result;
        break;
      default:
        if (v11)
        {
LABEL_160:
          CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"NSGetSizeAndAlignment(): unsupported type encoding spec '%c' at '%s' in '%s'", v11, v9, a4);
          goto LABEL_159;
        }
        return v10;
    }
    break;
  }
  while (v33 <= 60)
  {
    if (!v33 || v33 == 41) {
      goto LABEL_85;
    }
LABEL_82:
    if (v33) {
      ++v34;
    }
    char v33 = *v34;
  }
  if (v33 == 61) {
    goto LABEL_86;
  }
  if (v33 != 125) {
    goto LABEL_82;
  }
LABEL_85:
  char v33 = *result;
  int v34 = result;
LABEL_86:
  if (v33 == 61) {
    uint64_t result = v34 + 1;
  }
  else {
    uint64_t result = v34;
  }
  for (; result < v30; uint64_t result = (unsigned char *)((uint64_t (*)(void))__NSGetSizeAndAlignment)())
    ;
  if (result && *result) {
    ++result;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a2) {
    *a2 = 0;
  }
  if (result < v30) {
    goto LABEL_46;
  }
  return result;
}

void sub_182C22540(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    if (!v2)
    {
      objc_end_catch();
      JUMPOUT(0x182C21F90);
    }
    objc_exception_rethrow();
  }
  _Unwind_Resume(exc_buf);
}

void sub_182C22578(_Unwind_Exception *a1)
{
}

unint64_t computeReturnFrameExtent(uint64_t *a1, uint64_t *a2)
{
  int v2 = a2;
  v32[1] = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *a1;
  uint64_t v6 = a2 + 2;
  uint64_t v5 = a2[2];
  if (!v5)
  {
    *(_OWORD *)a2 = xmmword_182EDD440;
    uint64_t v5 = 224;
    a2[2] = 224;
  }
  int v7 = *(unsigned __int8 *)(v4 + 36);
  uint64_t v8 = (v7 - 35);
  if (v8 <= 0x3B)
  {
    if (((1 << (v7 - 35)) & 0x8034241A0800081) != 0)
    {
LABEL_8:
      unint64_t v10 = *a2;
      uint64_t v11 = *(unsigned int *)(v4 + 16);
      if ((unint64_t)(*a2 + v11) > 0x40)
      {
        *a2 = 72;
        v32[0] = 0;
        __NSGetSizeAndAlignment((unsigned char *)(v4 + 37), 0, v32, 0, 1, 0, 1uLL);
        unint64_t v13 = v32[0];
        if (v32[0] <= 1uLL) {
          unint64_t v13 = 1;
        }
        unint64_t v10 = (v5 + v13 - 225) / v13 * v13 + 224;
        unsigned int v12 = *(_DWORD *)(v4 + 16);
        int v2 = v6;
        LOBYTE(v11) = v12;
      }
      else
      {
        unsigned int v12 = ((v11 - 1) & 0xFFFFFFF8) + 8;
      }
      *int v2 = v10 + v12;
LABEL_14:
      *(_DWORD *)(v4 + 24) = v12;
      *(_DWORD *)(v4 + 28) = v10;
      *(unsigned char *)(v4 + 33) = v11 - v12;
      return (*v6 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (v8 == 33)
    {
LABEL_17:
      unint64_t v10 = a2[1];
      if (v10 > 0xC0)
      {
        *a2 = 72;
        v32[0] = 0;
        __NSGetSizeAndAlignment((unsigned char *)(v4 + 37), 0, v32, 0, 1, 0, 1uLL);
        unint64_t v17 = v32[0];
        if (v32[0] <= 1uLL) {
          unint64_t v17 = 1;
        }
        unint64_t v10 = (v5 + v17 - 225) / v17 * v17 + 224;
        uint64_t v11 = *(unsigned int *)(v4 + 16);
        v2[2] = v10 + v11;
        unsigned int v12 = v11;
      }
      else
      {
        a2[1] = v10 + 16;
        LODWORD(v11) = *(_DWORD *)(v4 + 16);
        unsigned int v12 = 16;
      }
      goto LABEL_14;
    }
  }
  unsigned int v9 = v7 - 99;
  if (v9 <= 0x18)
  {
    if (((1 << v9) & 0x34241) != 0) {
      goto LABEL_8;
    }
    if (((1 << v9) & 0xA) != 0) {
      goto LABEL_17;
    }
    if (v9 == 24)
    {
      v32[0] = 0;
      char v31 = 0;
      if (__NSMFAIsHFA_arm64(v4, &v31, (unint64_t *)v32))
      {
        uint64_t v15 = v2[1];
        if (v15 + (unint64_t)*(unsigned int *)(v4 + 16) > 0xC0)
        {
          *(_OWORD *)int v2 = xmmword_182EDD470;
          unint64_t v24 = _NSMS3StackAlignedOffset_arm64(v4, v5 - 224);
          uint64_t v25 = *(unsigned int *)(v4 + 16);
          *(_DWORD *)(v4 + 24) = v25;
          *(_DWORD *)(v4 + 28) = v24 + 224;
          v2[2] = v24 + 224 + v25;
          __NSMFASetOffsetsForCompositeElements_arm64(*(void *)v4, (v24 + 224));
        }
        else
        {
          uint64_t v16 = v32[0];
          *(_DWORD *)(v4 + 24) = 16 * LODWORD(v32[0]);
          *(_DWORD *)(v4 + 28) = v15;
          v2[1] = v15 + 16 * v16;
          uint64_t v30 = 0;
          __NSMFASetRegisterOffsetsForHFA_arm64(*(void *)v4, v15, &v30);
        }
        *(unsigned char *)(v4 + 33) = 0;
      }
      else
      {
        uint64_t v18 = *(unsigned int *)(v4 + 16);
        if (v18 < 0x11)
        {
          uint64_t v26 = 8 * (((v18 - 1) >> 3) + 1);
          uint64_t v27 = *v2;
          if ((unint64_t)(*v2 + v18) > 0x40)
          {
            unint64_t v29 = _NSMS3StackAlignedOffset_arm64(v4, v5 - 224);
            LODWORD(v27) = v29 + 224;
            uint64_t *v6 = v29 + 224 + v26;
            uint64_t v28 = 72;
          }
          else
          {
            uint64_t v28 = v27 + v26;
          }
          *(_DWORD *)(v4 + 28) = v27;
          *int v2 = v28;
          *(_DWORD *)(v4 + 24) = v26;
          *(unsigned char *)(v4 + 33) = *(unsigned char *)(v4 + 16) - v26;
          uint64_t v22 = *(void *)v4;
          uint64_t v23 = *(unsigned int *)(v4 + 28);
        }
        else
        {
          size_t v19 = strlen((const char *)(v4 + 37));
          int v20 = malloc_type_calloc(1uLL, v19 + 42, 0x700DC4B9uLL);
          *int v20 = v4;
          v20[2] = 8;
          *((_DWORD *)v20 + 6) = 8;
          *((_WORD *)v20 + 17) |= 0x1082u;
          *((_WORD *)v20 + 18) = 24158;
          size_t v21 = strlen((const char *)(v4 + 37));
          memmove((char *)v20 + 38, (const void *)(v4 + 37), v21 + 1);
          *a1 = (uint64_t)v20;
          computeReturnFrameExtent(a1, v2);
          uint64_t v22 = *(void *)v4;
          uint64_t v23 = 0;
        }
        __NSMFASetOffsetsForCompositeElements_arm64(v22, v23);
      }
    }
  }
  return (*v6 + 7) & 0xFFFFFFFFFFFFFFF8;
}

void __NSMethodFrameArgInfoDestroy(void *a1)
{
  if (a1)
  {
    __NSMethodFrameArgInfoDestroy(*a1);
    __NSMethodFrameArgInfoDestroy(a1[1]);
    free(a1);
  }
}

uint64_t __NSMFAIsHFA_arm64(uint64_t a1, unsigned char *a2, unint64_t *a3)
{
  if (!a1) {
    return 1;
  }
  uint64_t v5 = a1;
  while (1)
  {
    uint64_t result = 0;
    int v7 = *(unsigned __int8 *)(v5 + 36);
    char v8 = v7 - 68;
    if ((v7 - 68) > 0x37) {
      break;
    }
    if (((1 << v8) & 0x500000001) != 0)
    {
      unint64_t v9 = *a3 + 1;
      *a3 = v9;
      if (v9 > 4) {
        return 0;
      }
      if (*a2)
      {
        if ((char)*a2 != v7) {
          return 0;
        }
      }
      else
      {
        *a2 = v7;
      }
    }
    else
    {
      if (((1 << v8) & 0x80000000800000) == 0) {
        return result;
      }
      if ((__NSMFAIsHFA_arm64(*(void *)v5, a2, a3) & 1) == 0) {
        return 0;
      }
    }
    uint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      return 1;
    }
  }
  return result;
}

uint64_t __NSMFASetOffsetsForCompositeElements_arm64(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    do
    {
      int v4 = *(_DWORD *)(v3 + 20) + a2;
      *(_DWORD *)(v3 + 24) = *(_DWORD *)(v3 + 16);
      *(_DWORD *)(v3 + 28) = v4;
      if ((*(unsigned char *)(v3 + 35) & 0xC) != 0) {
        uint64_t result = __NSMFASetOffsetsForCompositeElements_arm64(*(void *)v3, a2);
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3);
  }
  return result;
}

uint64_t __NSMFASetRegisterOffsetsForHFA_arm64(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v5 = a1;
  uint64_t v6 = 0;
  do
  {
    __int16 v7 = *(_WORD *)(v5 + 34);
    uint64_t v8 = *a3;
    *(_DWORD *)(v5 + 28) = a2 + 16 * *a3;
    if ((v7 & 0xC00) != 0)
    {
      uint64_t v9 = __NSMFASetRegisterOffsetsForHFA_arm64(*(void *)v5, a2, a3);
      char v10 = 0;
    }
    else
    {
      char v10 = *(unsigned char *)(v5 + 16) - 16;
      *a3 = v8 + 1;
      uint64_t v9 = 16;
    }
    *(_DWORD *)(v5 + 24) = v9;
    *(unsigned char *)(v5 + 33) = v10;
    v6 += v9;
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5);
  return v6;
}

uint64_t copyMemStateToFrameState(uint64_t result)
{
  if (result)
  {
    unsigned int v1 = (uint64_t *)result;
    do
    {
      v1[3] = v1[2];
      uint64_t result = *v1;
      if (*v1) {
        uint64_t result = copyMemStateToFrameState();
      }
      unsigned int v1 = (uint64_t *)v1[1];
    }
    while (v1);
  }
  return result;
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  if (dyld_program_sdk_at_least()) {
    CFStringRef v10 = _CFURLCreateURLStringWithBytes(allocator, (UInt8 *)URLBytes, length, encoding);
  }
  else {
    CFStringRef v10 = CFStringCreateWithBytes(allocator, URLBytes, length, encoding, 0);
  }
  CFStringRef v11 = v10;
  if (!v10) {
    return 0;
  }
  unsigned int v12 = _CFURLCreateWithURLString((__objc2_class **)allocator, v10, 0, baseURL);
  CFURLRef v13 = (const __CFURL *)v12;
  if (encoding != 134217984 && v12) {
    *((_DWORD *)v12 + 5) = encoding;
  }
  CFRelease(v11);
  return v13;
}

__CFArray *_copyResourceURLsFromBundle(uint64_t a1, const __CFURL *a2, const __CFArray *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, int a8, char a9, char a10, uint64_t a11)
{
  uint64_t v74 = *(void *)off_1ECE0A5B0;
  char v73 = 0;
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  CFTypeRef cf = 0;
  CFStringRef theString = a4;
  MutableCFArrayRef Copy = CFStringCreateMutableCopy(0, 0, a4);
  size_t v19 = (__CFString *)MutableCopy;
  CFURLRef v20 = a2;
  CFArrayRef v67 = a3;
  uint64_t v68 = a1;
  if (a10 == 1)
  {
    CFIndex Length = CFStringGetLength(MutableCopy);
    _CFAppendPathComponent2(v19, @"Non-localized Resources");
    CFDictionaryRef Table = _copyQueryTable(a1, a2, a3, v19, a5);
    CFDictionaryRef v23 = Table;
    CFStringRef v24 = a5;
    if (a11) {
      _CFBundleFindResourcesWithPredicate(Mutable, Table, a11, &v73);
    }
    else {
      CFTypeRef cf = CFDictionaryGetValue(Table, a6);
    }
    v75.uint64_t length = CFStringGetLength(v19) - Length;
    v75.CFIndex location = Length;
    CFStringDelete(v19, v75);
    if (cf || v73) {
      goto LABEL_12;
    }
    a1 = v68;
    if (v23) {
      CFRelease(v23);
    }
  }
  CFDictionaryRef v25 = _copyQueryTable(a1, v20, a3, v19, a5);
  CFDictionaryRef v23 = v25;
  CFStringRef v24 = a5;
  if (a11) {
    _CFBundleFindResourcesWithPredicate(Mutable, v25, a11, &v73);
  }
  else {
    CFTypeRef cf = CFDictionaryGetValue(v25, a6);
  }
LABEL_12:
  if (v24) {
    BOOL v26 = CFStringGetLength(v24) > 0;
  }
  else {
    BOOL v26 = 0;
  }
  CFURLRef v66 = v20;
  if (a7) {
    BOOL v27 = CFStringGetLength(a7) > 0;
  }
  else {
    BOOL v27 = 0;
  }
  if (!a9 || !cf)
  {
    if (cf)
    {
      CFTypeID v29 = CFGetTypeID(cf);
      if (v29 == CFArrayGetTypeID())
      {
        v76.uint64_t length = CFArrayGetCount((CFArrayRef)cf);
        v76.CFIndex location = 0;
        CFArrayAppendArray(Mutable, (CFArrayRef)cf, v76);
      }
      else
      {
        CFArrayAppendValue(Mutable, cf);
      }
    }
    goto LABEL_52;
  }
  CFTypeID v28 = CFGetTypeID(cf);
  if (v28 == CFStringGetTypeID()) {
    CFTypeRef cf = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, &cf, 1, &kCFTypeArrayCallBacks);
  }
  else {
    CFRetain(cf);
  }
  result.CFIndex location = 0;
  result.uint64_t length = 0;
  if (a8)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count <= 0)
    {
      CFRelease(cf);
LABEL_52:
      CFArrayRef v36 = v67;
      goto LABEL_53;
    }
  }
  else
  {
    CFIndex Count = 1;
  }
  unint64_t v64 = v19;
  for (CFIndex i = 0; Count != i; ++i)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
    CFIndex v33 = CFStringGetLength(ValueAtIndex);
    CFIndex v34 = v33;
    if (v26)
    {
      v77.CFIndex location = 0;
      v77.uint64_t length = v33;
      if (CFStringFindWithOptions(ValueAtIndex, v24, v77, 0, &result)) {
        BOOL v35 = result.location == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (v35) {
        goto LABEL_46;
      }
    }
    else
    {
      if (!v33) {
        goto LABEL_46;
      }
      v78.CFIndex location = 0;
      v78.uint64_t length = v33;
      if (!CFStringFindWithOptions(ValueAtIndex, @".lproj", v78, 0, &result) || result.location + 7 >= v34) {
        goto LABEL_46;
      }
    }
    if (!a7) {
      break;
    }
    if (CFStringGetLength(a7) < 1) {
      break;
    }
    v79.CFIndex location = 0;
    v79.uint64_t length = v34;
    if (!CFStringFindWithOptions(ValueAtIndex, a7, v79, 8uLL, &result)) {
      break;
    }
    v80.CFIndex location = result.length + result.location;
    v80.uint64_t length = 1;
    if (!CFStringFindWithOptions(ValueAtIndex, @".", v80, 0, &result)) {
      break;
    }
    BOOL v27 = 0;
LABEL_46:
    CFArrayAppendValue(Mutable, ValueAtIndex);
  }
  CFRelease(cf);
  CFArrayRef v36 = v67;
  if (!a8 && CFArrayGetCount(Mutable)) {
    BOOL v27 = 0;
  }
  size_t v19 = v64;
LABEL_53:
  CFTypeRef cf = 0;
  CFRelease(v23);
  if (v27)
  {
    CFMutableStringRef v37 = CFStringCreateMutableCopy(0, 0, a7);
    _CFAppendPathExtension2(v37, @"lproj");
    if (v24 && CFStringGetLength(v24) >= 1) {
      _CFAppendPathComponent2(v37, v24);
    }
    CFDictionaryRef v38 = _copyQueryTable(v68, v66, v36, v19, v37);
    CFRelease(v37);
    CFStringRef Value = CFDictionaryGetValue(v38, a6);
    CFTypeRef cf = Value;
    if (Value)
    {
      CFTypeID v40 = CFGetTypeID(Value);
      CFTypeID TypeID = CFStringGetTypeID();
      CFArrayRef v42 = (const __CFArray *)cf;
      if (v40 == TypeID)
      {
        CFArrayAppendValue(Mutable, cf);
      }
      else
      {
        v81.uint64_t length = CFArrayGetCount((CFArrayRef)cf);
        v81.CFIndex location = 0;
        CFArrayAppendArray(Mutable, v42, v81);
      }
    }
    CFRelease(v38);
  }
  if (CFArrayGetCount(Mutable) < 1)
  {
    if (a8) {
      int v45 = (__CFArray *)CFRetain(Mutable);
    }
    else {
      int v45 = 0;
    }
  }
  else
  {
    int v43 = _CFGetSlash();
    if (v68)
    {
      CFMutableStringRef v44 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, *(CFStringRef *)(v68 + 192));
    }
    else
    {
      CFURLRef v46 = CFURLCopyAbsoluteURL(v66);
      CFStringRef v47 = CFURLCopyFileSystemPath(v46, kCFURLPOSIXPathStyle);
      CFMutableStringRef v44 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v47);
      CFRelease(v46);
      CFRelease(v47);
    }
    if (theString && CFStringGetLength(theString)) {
      _CFAppendPathComponent2(v44, theString);
    }
    _CFAppendTrailingPathSlash2(v44);
    if (a8)
    {
      uint64_t v48 = v19;
      CFIndex v49 = CFArrayGetCount(Mutable);
      CFURLRef v50 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v44, kCFURLPOSIXPathStyle, 1u);
      int v45 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      if (v49 >= 1)
      {
        for (CFIndex j = 0; j != v49; ++j)
        {
          CFStringRef v52 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, j);
          int v53 = _CFGetSlashStr();
          CFURLRef RelativeURLFromBaseAndPath = _CFBundleCreateRelativeURLFromBaseAndPath(v52, v50, v43, v53);
          CFArrayAppendValue(v45, RelativeURLFromBaseAndPath);
          CFRelease(RelativeURLFromBaseAndPath);
        }
      }
      CFRelease(v50);
      size_t v19 = v48;
    }
    else
    {
      int HasPrefix = CFStringHasPrefix(a6, @"_CFBT_");
      int v56 = CFStringHasPrefix(a6, @"_CFBAF_") | HasPrefix;
      CFStringRef v57 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, 0);
      if (v56)
      {
        CFURLRef v58 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v44, kCFURLPOSIXPathStyle, 1u);
        CFStringRef v59 = _CFGetSlashStr();
        int v45 = _CFBundleCreateRelativeURLFromBaseAndPath(v57, v58, v43, v59);
        CFRelease(v58);
      }
      else
      {
        CFStringAppend(v44, v57);
        CFIndex v60 = CFStringGetLength(v57);
        if (CFStringGetCharacterAtIndex(v57, v60 - 1) == v43)
        {
          CFStringRef v61 = v44;
          Boolean v62 = 1;
        }
        else
        {
          CFStringRef v61 = v44;
          Boolean v62 = 0;
        }
        int v45 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v61, kCFURLPOSIXPathStyle, v62);
      }
    }
    CFRelease(v44);
  }
  if (v19) {
    CFRelease(v19);
  }
  CFRelease(Mutable);
  return v45;
}

unint64_t *__CFURLCreateCopyAppendingPathComponent(const __CFAllocator *a1, unint64_t a2, const __CFString *a3, int a4, const __CFString *a5)
{
  unint64_t v8 = a2;
  if (CF_IS_OBJC(0x1DuLL, a2)) {
    unint64_t v8 = [(id)v8 _cfurl];
  }
  if (CFURLIsFileReferenceURL((CFURLRef)v8))
  {
    CFURLRef v10 = CFURLCreateFilePathURL(a1, (CFURLRef)v8, 0);
    BOOL v11 = v10 != 0;
    if (v10) {
      unint64_t v8 = (unint64_t)v10;
    }
  }
  else
  {
    BOOL v11 = 0;
  }
  if ((*(unsigned char *)(v8 + 16) & 0x20) != 0)
  {
    CFStringRef v12 = (const __CFString *)atomic_load((unint64_t *)(v8 + 24));
    MutableCFArrayRef Copy = CFStringCreateMutableCopy(a1, 0, v12);
    if (MutableCopy)
    {
      int v14 = MutableCopy;
      if (_CFURLHasFileURLScheme(v8, 0)) {
        CFStringRef v15 = POSIXPathToURLPath(a3, 0, 0, 0);
      }
      else {
        CFStringRef v15 = CFURLCreateStringByAddingPercentEscapes(a1, a3, 0, a5, *(_DWORD *)(v8 + 20));
      }
      CFStringRef v18 = v15;
      if (!v15)
      {
        uint64_t v16 = 0;
        goto LABEL_30;
      }
      unsigned int v19 = *(_DWORD *)(v8 + 16);
      if ((v19 & 0x20) != 0)
      {
        unsigned int v22 = 0;
        unsigned int v23 = 32;
        do
        {
          char v24 = v23;
          v23 >>= 1;
          v22 += v19 & 1;
          v19 >>= 1;
        }
        while ((v24 & 2) == 0);
        CFDictionaryRef v25 = (uint64_t *)(v8 + 56 + 16 * v22);
        uint64_t v21 = *v25;
        uint64_t v20 = v25[1];
        if (v20)
        {
          CFStringRef v26 = (const __CFString *)atomic_load((unint64_t *)(v8 + 24));
          if (CFStringGetCharacterAtIndex(v26, v21 + v20 - 1) == 47)
          {
LABEL_27:
            CFIndex v27 = v20 + v21;
            CFStringInsert(v14, v27, v18);
            if (a4)
            {
              CFIndex Length = CFStringGetLength(v18);
              CFStringInsert(v14, Length + v27, @"/");
            }
            CFRelease(v18);
            uint64_t v16 = _CFURLCreateWithURLString((__objc2_class **)a1, v14, 0, *(const __CFURL **)(v8 + 32));
LABEL_30:
            CFRelease(v14);
            if (!v11) {
              return v16;
            }
            goto LABEL_13;
          }
        }
      }
      else
      {
        uint64_t v20 = 0;
        uint64_t v21 = -1;
      }
      if (!CFStringGetLength(v18) || CFStringGetCharacterAtIndex(v18, 0) != 47) {
        CFStringInsert(v14, v21 + v20++, @"/");
      }
      goto LABEL_27;
    }
  }
  uint64_t v16 = 0;
  if (v11) {
LABEL_13:
  }
    CFRelease((CFTypeRef)v8);
  return v16;
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  uint64_t v3 = (__CFString *)theString;
  void v24[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    return (CFMutableStringRef)[(__CFString *)v3 mutableCopy];
  }
  CFMutableStringRef Mutable = CFStringCreateMutable(alloc, maxLength);
  if (Mutable == v3)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3);
    uint64_t v3 = (__CFString *)Copy;
  }
  else
  {
    CFStringRef Copy = 0;
  }
  CFIndex Length = CFStringGetLength(v3);
  if (Length < 1)
  {
    BOOL v11 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (unint64_t)v3))
    {
      int v10 = [(__CFString *)v3 _encodingCantBeStoredInEightBitCFString];
    }
    else
    {
      unsigned int v12 = atomic_load((unint64_t *)&v3->info);
      int v10 = (v12 >> 4) & 1;
    }
    BOOL v11 = v10 != 0;
  }
  v24[0] = 0;
  v24[1] = 0;
  __CFStringChangeSizeMultiple((uint64_t)Mutable, (uint64_t)v24, 1, Length, v11);
  char v14 = atomic_load((unint64_t *)&Mutable->info);
  char v15 = atomic_load((unint64_t *)&Mutable->info);
  uint64_t v16 = v15 & 0x60;
  p_data = (UniChar **)&Mutable->data;
  if ((v14 & 0x10) == 0)
  {
    if (v16)
    {
      CFStringRef v18 = *p_data;
    }
    else
    {
      uint64_t v20 = atomic_load((unint64_t *)&Mutable->info);
      CFStringRef v18 = (UniChar *)&p_data[(v20 & 5) != 4];
    }
    CFStringEncoding v21 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v13);
      CFStringEncoding v21 = __CFDefaultEightBitStringEncoding;
    }
    unint64_t v22 = atomic_load((unint64_t *)&Mutable->info);
    v26.CFIndex location = 0;
    v26.uint64_t length = Length;
    CFStringGetBytes(v3, v26, v21, 0, 0, (UInt8 *)v18 + ((v22 >> 2) & 1), Length, 0);
    goto LABEL_26;
  }
  if (v16)
  {
    unsigned int v19 = *p_data;
    if (!*p_data) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  uint64_t v23 = atomic_load((unint64_t *)&Mutable->info);
  unsigned int v19 = (UniChar *)&p_data[(v23 & 5) != 4];
  if (v19)
  {
LABEL_25:
    v27.CFIndex location = 0;
    v27.uint64_t length = Length;
    CFStringGetCharacters(v3, v27, v19);
  }
LABEL_26:
  if (Copy) {
    CFRelease(Copy);
  }
  return Mutable;
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  v31[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)str))
  {
    [(__CFString *)str insertString:insertedStr atIndex:idx];
    return;
  }
  char v6 = atomic_load((unint64_t *)&str->info);
  if ((v6 & 1) == 0)
  {
    __int16 v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringInsert_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }
  if (insertedStr == str)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, str);
    insertedStr = Copy;
  }
  else
  {
    CFStringRef Copy = 0;
  }
  CFIndex Length = CFStringGetLength(insertedStr);
  if (Length < 1)
  {
    BOOL v18 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (unint64_t)insertedStr))
    {
      int v17 = [(__CFString *)(id)insertedStr _encodingCantBeStoredInEightBitCFString];
    }
    else
    {
      unsigned int v19 = atomic_load((unint64_t *)&insertedStr->info);
      int v17 = (v19 >> 4) & 1;
    }
    BOOL v18 = v17 != 0;
  }
  v31[0] = idx;
  v31[1] = 0;
  __CFStringChangeSizeMultiple((uint64_t)str, (uint64_t)v31, 1, Length, v18);
  char v21 = atomic_load((unint64_t *)&str->info);
  char v22 = atomic_load((unint64_t *)&str->info);
  uint64_t v23 = v22 & 0x60;
  p_data = &str->data;
  if ((v21 & 0x10) == 0)
  {
    if (v23)
    {
      CFDictionaryRef v25 = *p_data;
    }
    else
    {
      uint64_t v27 = atomic_load((unint64_t *)&str->info);
      CFDictionaryRef v25 = (char *)&p_data[(v27 & 5) != 4];
    }
    CFStringEncoding v28 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v20);
      CFStringEncoding v28 = __CFDefaultEightBitStringEncoding;
    }
    unint64_t v29 = atomic_load((unint64_t *)&str->info);
    v33.CFIndex location = 0;
    v33.uint64_t length = Length;
    CFStringGetBytes(insertedStr, v33, v28, 0, 0, (UInt8 *)&v25[idx + ((v29 >> 2) & 1)], Length, 0);
    goto LABEL_29;
  }
  if (!v23)
  {
    uint64_t v30 = atomic_load((unint64_t *)&str->info);
    CFRange v26 = (char *)&p_data[(v30 & 5) != 4];
    if (!v26) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  CFRange v26 = *p_data;
  if (v26)
  {
LABEL_28:
    v34.CFIndex location = 0;
    v34.uint64_t length = Length;
    CFStringGetCharacters(insertedStr, v34, (UniChar *)&v26[2 * idx]);
  }
LABEL_29:
  if (Copy)
  {
    CFRelease(Copy);
  }
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  uint64_t length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v70 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    return -[__CFString replaceOccurrencesOfString:withString:options:range:](theString, "replaceOccurrencesOfString:withString:options:range:", stringToFind, replacementString, compareOptions, location, length);
  }
  else
  {
    result.CFIndex location = 0;
    result.uint64_t length = 0;
    if (length < 1) {
      return 0;
    }
    CFStringRef theStringa = theString;
    CFStringRef v64 = replacementString;
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unsigned int v14 = compareOptions;
    uint64_t v15 = (location + length);
    CFStringCompareFlags v65 = compareOptions;
    uint64_t v16 = 62;
    int v17 = __src;
    while (1)
    {
      v74.CFIndex location = location;
      v74.uint64_t length = length;
      if (!CFStringFindWithOptionsAndLocale(theStringa, stringToFind, v74, compareOptions, 0, &result)) {
        break;
      }
      if ((v14 >> 2))
      {
        uint64_t length = result.location - location;
      }
      else
      {
        CFIndex location = result.length + result.location;
        uint64_t length = v15 - (result.length + result.location);
      }
      if ((uint64_t)v13 >= v16)
      {
        uint64_t v16 = 2 * v16 + 8;
        if (v17 == __src) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v17;
        }
        unsigned int v19 = (unsigned char *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v18, 16 * v16, 0x1000040451B5BE8, 0, 0);
        BOOL v20 = v17 == __src;
        int v17 = v19;
        if (v20) {
          memmove(v19, __src, 0x3E0uLL);
        }
        compareOptions = v65;
      }
      *(CFRange *)&v17[v12] = result;
      ++v13;
      v12 += 16;
      if (length <= 0) {
        goto LABEL_22;
      }
    }
    if (!v12) {
      return 0;
    }
LABEL_22:
    if ((v14 & 4) != 0)
    {
      uint64_t v21 = (v13 - 1);
      if ((int)v21 >= 1)
      {
        uint64_t v22 = 0;
        uint64_t v23 = v21 - 1;
        char v24 = (long long *)v17;
        CFDictionaryRef v25 = (long long *)&v17[16 * v21];
        do
        {
          long long v67 = *v24;
          *v24++ = *v25;
          *v25-- = v67;
        }
        while (++v22 < v23--);
      }
    }
    char v27 = atomic_load((unint64_t *)&theStringa->info);
    if (v27)
    {
      CFArrayRef v36 = (__CFString *)v64;
      if (v64 == theStringa)
      {
        CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theStringa);
        CFArrayRef v36 = (__CFString *)Copy;
      }
      else
      {
        CFStringRef Copy = 0;
      }
      CFIndex v38 = CFStringGetLength(v36);
      if (v38 < 1)
      {
        BOOL v40 = 0;
      }
      else
      {
        if (CF_IS_OBJC(7uLL, (unint64_t)v36))
        {
          int v39 = [(__CFString *)v36 _encodingCantBeStoredInEightBitCFString];
        }
        else
        {
          unsigned int v41 = atomic_load((unint64_t *)&v36->info);
          int v39 = (v41 >> 4) & 1;
        }
        BOOL v40 = v39 != 0;
      }
      __CFStringChangeSizeMultiple((uint64_t)theStringa, (uint64_t)v17, v13, v38, v40);
      char v43 = atomic_load((unint64_t *)&theStringa->info);
      char v44 = atomic_load((unint64_t *)&theStringa->info);
      uint64_t v45 = v44 & 0x60;
      p_data = &theStringa->data;
      if ((v43 & 0x10) != 0)
      {
        if (v45)
        {
          uint64_t v48 = *p_data;
        }
        else
        {
          uint64_t v59 = atomic_load((unint64_t *)&theStringa->info);
          uint64_t v48 = (char *)&p_data[(v59 & 5) != 4];
        }
        CFIndex v60 = (UniChar *)&v48[2 * *(void *)v17];
        v73.CFIndex location = 0;
        v73.uint64_t length = v38;
        CFStringGetCharacters(v36, v73, v60);
        if (v13 >= 2)
        {
          unint64_t v61 = v13 - 1;
          Boolean v62 = (uint64_t *)(v17 + 16);
          do
          {
            v48 += 2 * (v38 - *(v62 - 1));
            uint64_t v63 = *v62;
            v62 += 2;
            memmove(&v48[2 * v63], v60, 2 * v38);
            --v61;
          }
          while (v61);
        }
      }
      else
      {
        if (v45)
        {
          CFStringRef v47 = (char **)*p_data;
        }
        else
        {
          uint64_t v49 = atomic_load((unint64_t *)&theStringa->info);
          CFStringRef v47 = &p_data[(v49 & 5) != 4];
        }
        CFURLRef v50 = (char *)v47 + *(void *)v17;
        unint64_t v51 = atomic_load((unint64_t *)&theStringa->info);
        CFStringRef v52 = (UInt8 *)&v50[(v51 >> 2) & 1];
        CFStringEncoding v53 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding(v42);
          CFStringEncoding v53 = __CFDefaultEightBitStringEncoding;
        }
        v72.CFIndex location = 0;
        v72.uint64_t length = v38;
        CFStringGetBytes(v36, v72, v53, 0, 0, v52, v38, 0);
        unint64_t v54 = atomic_load((unint64_t *)&theStringa->info);
        if (v13 >= 2)
        {
          uint64_t v55 = (char *)v47 + ((v54 >> 2) & 1);
          unint64_t v56 = v13 - 1;
          CFStringRef v57 = (uint64_t *)(v17 + 16);
          do
          {
            v55 += v38 - *(v57 - 1);
            uint64_t v58 = *v57;
            v57 += 2;
            memmove(&v55[v58], v52, v38);
            --v56;
          }
          while (v56);
        }
      }
      if (Copy) {
        CFRelease(Copy);
      }
    }
    else
    {
      CFStringEncoding v28 = _CFOSLog();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
        CFStringFindAndReplace_cold_1(v28, v29, v30, v31, v32, v33, v34, v35);
      }
    }
    if (v17 != __src) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
    }
    return v13;
  }
}

void CFStringReplaceAll(CFMutableStringRef theString, CFStringRef replacement)
{
  v38[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString setString:replacement];
    return;
  }
  p_info = &theString->info;
  char v5 = atomic_load((unint64_t *)&theString->info);
  if ((v5 & 1) == 0)
  {
    char v6 = _CFOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      CFStringReplaceAll_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    return;
  }
  char v14 = atomic_load((unint64_t *)p_info);
  uint64_t v15 = v14 & 5;
  char v16 = atomic_load((unint64_t *)p_info);
  uint64_t v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_data = &theString->data;
    if (v17)
    {
      unsigned int v19 = *p_data;
    }
    else
    {
      uint64_t v21 = atomic_load((unint64_t *)&theString->info);
      unsigned int v19 = (char *)&p_data[(v21 & 5) != 4];
    }
    uint64_t length = *v19;
  }
  else if ((v16 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }
  else
  {
    uint64_t length = (uint64_t)theString->data;
  }
  if (replacement == theString)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    replacement = Copy;
  }
  else
  {
    CFStringRef Copy = 0;
  }
  CFIndex v23 = CFStringGetLength(replacement);
  if (v23 < 1)
  {
    BOOL v25 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (unint64_t)replacement))
    {
      int v24 = [(__CFString *)(id)replacement _encodingCantBeStoredInEightBitCFString];
    }
    else
    {
      unsigned int v26 = atomic_load((unint64_t *)&replacement->info);
      int v24 = (v26 >> 4) & 1;
    }
    BOOL v25 = v24 != 0;
  }
  v38[0] = 0;
  v38[1] = length;
  __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v38, 1, v23, v25);
  char v28 = atomic_load((unint64_t *)&theString->info);
  char v29 = atomic_load((unint64_t *)&theString->info);
  uint64_t v30 = v29 & 0x60;
  uint64_t v31 = &theString->data;
  if ((v28 & 0x10) == 0)
  {
    if (v30)
    {
      uint64_t v32 = *v31;
    }
    else
    {
      uint64_t v34 = atomic_load((unint64_t *)&theString->info);
      uint64_t v32 = (char *)&v31[(v34 & 5) != 4];
    }
    CFStringEncoding v35 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v27);
      CFStringEncoding v35 = __CFDefaultEightBitStringEncoding;
    }
    unint64_t v36 = atomic_load((unint64_t *)&theString->info);
    v40.CFIndex location = 0;
    v40.uint64_t length = v23;
    CFStringGetBytes(replacement, v40, v35, 0, 0, (UInt8 *)&v32[(v36 >> 2) & 1], v23, 0);
    goto LABEL_37;
  }
  if (!v30)
  {
    uint64_t v37 = atomic_load((unint64_t *)&theString->info);
    uint64_t v33 = (UniChar *)&v31[(v37 & 5) != 4];
    if (!v33) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  uint64_t v33 = (UniChar *)*v31;
  if (*v31)
  {
LABEL_36:
    v41.CFIndex location = 0;
    v41.uint64_t length = v23;
    CFStringGetCharacters(replacement, v41, v33);
  }
LABEL_37:
  if (Copy)
  {
    CFRelease(Copy);
  }
}

CFURLRef CFURLCreateAbsoluteURLWithBytes(CFAllocatorRef alloc, const UInt8 *relativeURLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL, Boolean useCompatibilityMode)
{
  v51[18] = *(void *)off_1ECE0A5B0;
  if (useCompatibilityMode)
  {
    unsigned int v49 = 0;
    char v48 = 0;
    if (dyld_program_sdk_at_least()) {
      CFStringRef v11 = _CFURLCreateURLStringWithBytes(alloc, (UInt8 *)relativeURLBytes, length, encoding);
    }
    else {
      CFStringRef v11 = CFStringCreateWithBytes(alloc, relativeURLBytes, length, encoding, 0);
    }
    uint64_t v12 = (__CFString *)v11;
    if (!v11) {
      return 0;
    }
    if (!baseURL)
    {
      int v19 = 0;
      goto LABEL_33;
    }
    if (CFStringGetLength(v11) >= 1)
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v12, 0);
      if (CharacterAtIndex == 63 || CharacterAtIndex == 35)
      {
        if (CF_IS_OBJC(0x1DuLL, (unint64_t)baseURL)) {
          CFStringRef v14 = CFURLGetString(baseURL);
        }
        else {
          CFStringRef v14 = (const __CFString *)atomic_load((unint64_t *)baseURL + 3);
        }
        CFIndex v31 = CFStringGetLength(v14);
        CFIndex v32 = CFStringGetLength(v12);
        CFMutableStringRef Mutable = CFStringCreateMutable(alloc, v32 + v31);
        CFStringAppend(Mutable, v14);
        CFStringAppend(Mutable, v12);
LABEL_28:
        int v19 = 1;
        goto LABEL_32;
      }
    }
    int v47 = 0;
    _parseComponents(v12, baseURL, (unsigned int *)&v47, v51, &v48);
    if ((v47 & 1) == 0)
    {
      CFRetain(v12);
      CFStringRef v20 = v12;
      goto LABEL_17;
    }
    CFStringRef v28 = CFURLCopyScheme(baseURL);
    if (v28)
    {
      CFStringRef v29 = v28;
      uint64_t v30 = v51[1];
      if (CFStringGetLength(v28) == v30 && CFStringHasPrefix(v12, v29))
      {
        v54.uint64_t length = CFStringGetLength(v12) + ~v30;
        v54.CFIndex location = v30 + 1;
        CFStringRef v20 = CFStringCreateWithSubstring(alloc, v12, v54);
        int v47 = 0;
        _parseComponents(v20, baseURL, (unsigned int *)&v47, v51, &v48);
        CFRelease(v29);
LABEL_17:
        if (CF_IS_OBJC(0x1DuLL, (unint64_t)baseURL))
        {
          unsigned int v46 = 0;
          CFStringRef v21 = CFURLGetString(baseURL);
          _parseComponents(v21, 0, &v46, v50, &v48);
          unsigned int v23 = v46;
          unsigned int v22 = v47;
          int v24 = v50;
          CFAllocatorRef v25 = alloc;
          CFStringRef v26 = v20;
          CFStringRef v27 = v21;
        }
        else
        {
          unsigned int v22 = v47;
          CFStringRef v27 = (const __CFString *)atomic_load((unint64_t *)baseURL + 3);
          unsigned int v23 = *((_DWORD *)baseURL + 4);
          int v24 = (CFIndex *)((char *)baseURL + 56);
          CFAllocatorRef v25 = alloc;
          CFStringRef v26 = v20;
        }
        CFMutableStringRef Mutable = (__CFString *)resolveAbsoluteURLString(v25, v26, v22, (uint64_t)v51, v27, v23, v24);
        if (v20) {
          CFRelease(v20);
        }
        goto LABEL_28;
      }
      CFRetain(v12);
      CFRelease(v29);
    }
    else
    {
      CFRetain(v12);
    }
    int v19 = 0;
    CFMutableStringRef Mutable = v12;
LABEL_32:
    CFRelease(v12);
    uint64_t v12 = Mutable;
    if (Mutable)
    {
LABEL_33:
      _parseComponents(v12, 0, &v49, v51, &v48);
      unsigned int v34 = v49;
      if ((v49 & 0x20) == 0) {
        goto LABEL_41;
      }
      unsigned int v35 = 0;
      unsigned int v36 = 32;
      do
      {
        char v37 = v36;
        v36 >>= 1;
        v35 += v34 & 1;
        v34 >>= 1;
      }
      while ((v37 & 2) == 0);
      CFIndex v38 = &v51[2 * v35];
      CFIndex v39 = *v38;
      CFIndex v40 = v38[1];
      uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(alloc, 2 * v40 + 2, 0x1000040BDFB0063, 0);
      v52.CFIndex location = v39;
      v52.uint64_t length = v40;
      CFStringGetCharacters(v12, v52, Typed);
      uint64_t v42 = &Typed[v40];
      *uint64_t v42 = 0;
      CFStringRef v43 = _resolvedPath((char *)Typed, (unint64_t)v42, 47, 1, 0, alloc);
      if (CFStringGetLength(v43) != v40)
      {
        if (!v19)
        {
          CFIndex v44 = CFStringGetLength(v12);
          MutableCFStringRef Copy = CFStringCreateMutableCopy(alloc, v44, v12);
          CFRelease(v12);
          uint64_t v12 = MutableCopy;
        }
        v53.CFIndex location = v39;
        v53.uint64_t length = v40;
        CFStringReplace(v12, v53, v43);
      }
      CFRelease(v43);
      if (v12)
      {
LABEL_41:
        char v16 = _CFURLCreateWithURLString((__objc2_class **)alloc, v12, 0, 0);
        CFRelease(v12);
        if (v16) {
          *((_DWORD *)v16 + 5) = encoding;
        }
        return (CFURLRef)v16;
      }
      CFRelease(0);
    }
    return 0;
  }
  CFURLRef v15 = CFURLCreateWithBytes(alloc, relativeURLBytes, length, encoding, baseURL);
  char v16 = (unint64_t *)v15;
  if (v15 && baseURL)
  {
    CFURLRef v17 = CFURLCopyAbsoluteURL(v15);
    CFRelease(v16);
    return v17;
  }
  return (CFURLRef)v16;
}

unint64_t *_CFURLCreateWithURLString(__objc2_class **a1, CFStringRef theString, int a3, const __CFURL *a4)
{
  char v6 = a1;
  uint64_t v93 = *(void *)off_1ECE0A5B0;
  if (a3)
  {
    if (!theString) {
      return 0;
    }
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    *(_OWORD *)uint64_t buffer = 0u;
    long long v82 = 0u;
    CFIndex Length = CFStringGetLength(theString);
    *(void *)&long long v89 = theString;
    *((void *)&v90 + 1) = 0;
    *(void *)&long long v91 = Length;
    CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
    CStringPtr = 0;
    *((void *)&v89 + 1) = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    }
    *(void *)&long long v90 = CStringPtr;
    *((void *)&v91 + 1) = 0;
    CFIndex v92 = 0;
    if (Length >= 1)
    {
      CFIndex v10 = 0;
      int v11 = 0;
      CFIndex v12 = 0;
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = v12 + 64;
        if (v12 + 64 <= Length) {
          uint64_t v15 = 64;
        }
        else {
          uint64_t v15 = Length - v12;
        }
        if (v12 < 0 || (CFIndex v16 = v91, v15 + v12 > (uint64_t)v91))
        {
          CFURLRef v17 = 0;
        }
        else if (*((void *)&v89 + 1))
        {
          CFURLRef v17 = (UniChar *)(*((void *)&v89 + 1) + 2 * *((void *)&v90 + 1) + 2 * v12);
        }
        else
        {
          if (v15 > 64)
          {
            CFURLRef v17 = 0;
LABEL_30:
            if (Length >= v14) {
              CFIndex v24 = v12 + 64;
            }
            else {
              CFIndex v24 = Length;
            }
            CFIndex v25 = v12;
            while (2)
            {
              uint64_t v26 = *v17;
              if (v13)
              {
                if (v26 > 0x7F || (sURLValidCharacters[v26] & 0x10) == 0) {
                  return 0;
                }
                --v13;
                goto LABEL_38;
              }
              if (*v17 > 0x5Au)
              {
                uint64_t v13 = 0;
                if (v26 == 91 || v26 == 93)
                {
LABEL_38:
                  ++v17;
                  if (v24 == ++v25) {
                    goto LABEL_52;
                  }
                  continue;
                }
              }
              else
              {
                if (v26 == 35)
                {
                  if (v11) {
                    return 0;
                  }
                  uint64_t v13 = 0;
                  int v11 = 1;
                  goto LABEL_38;
                }
                if (v26 == 37)
                {
                  if (v25 + 2 >= Length) {
                    return 0;
                  }
                  uint64_t v13 = 2;
                  goto LABEL_38;
                }
              }
              break;
            }
            if (v26 > 0x7F || (sURLValidCharacters[v26] & 1) == 0) {
              return 0;
            }
            uint64_t v13 = 0;
            goto LABEL_38;
          }
          if (v15 + v12 > v92 || v12 < v10)
          {
            if (v14 < (uint64_t)v91) {
              CFIndex v16 = v12 + 64;
            }
            *((void *)&v91 + 1) = v12;
            CFIndex v92 = v16;
            v18.CFIndex location = *((void *)&v90 + 1) + v12;
            v18.uint64_t length = v16 - v12;
            if ((void)v90)
            {
              if (v18.length)
              {
                int v19 = (char *)(v90 + v18.location);
                CFIndex v20 = v12 - v16;
                CFStringRef v21 = buffer;
                do
                {
                  UniChar v22 = *v19++;
                  *v21++ = v22;
                  BOOL v23 = __CFADD__(v20++, 1);
                }
                while (!v23);
              }
            }
            else
            {
              CFStringGetCharacters((CFStringRef)v89, v18, buffer);
            }
          }
          CFIndex v10 = *((void *)&v91 + 1);
          CFURLRef v17 = &buffer[v12 - *((void *)&v91 + 1)];
        }
        if (v15 >= 1) {
          goto LABEL_30;
        }
LABEL_52:
        v12 += v15;
      }
      while (v12 < Length);
    }
    char v6 = a1;
  }
  CFIndex v92 = 0;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  *(_OWORD *)uint64_t buffer = 0u;
  CFIndex v27 = CFStringGetLength(theString);
  *(void *)&long long v89 = theString;
  *((void *)&v90 + 1) = 0;
  *(void *)&long long v91 = v27;
  CFStringRef v28 = CFStringGetCharactersPtr(theString);
  CFStringRef v29 = 0;
  *((void *)&v89 + 1) = v28;
  if (!v28) {
    CFStringRef v29 = CFStringGetCStringPtr(theString, 0x600u);
  }
  *(void *)&long long v90 = v29;
  *((void *)&v91 + 1) = 0;
  CFIndex v92 = 0;
  if (v27 < 1) {
    goto LABEL_100;
  }
  if (*((void *)&v89 + 1))
  {
    CFIndex v30 = 0;
    UniChar v31 = *(_WORD *)(*((void *)&v89 + 1) + 2 * *((void *)&v90 + 1));
  }
  else if (v29)
  {
    CFIndex v30 = 0;
    UniChar v31 = v29[*((void *)&v90 + 1)];
  }
  else
  {
    v33.CFIndex location = *((void *)&v90 + 1);
    v33.uint64_t length = (uint64_t)v91 >= 64 ? 64 : v91;
    CFIndex v92 = v33.length;
    CFStringGetCharacters((CFStringRef)v89, v33, buffer);
    CFIndex v30 = *((void *)&v91 + 1);
    UniChar v31 = buffer[-*((void *)&v91 + 1)];
  }
  if (v31 > 0x7Fu || (sURLValidCharacters[v31] & 2) == 0) {
    goto LABEL_100;
  }
  CFIndex v34 = 0;
  while (1)
  {
    uint64_t v35 = v34 + 64;
    if (v34 + 64 <= v27) {
      uint64_t v36 = 64;
    }
    else {
      uint64_t v36 = v27 - v34;
    }
    if (v34 < 0 || v36 + v34 > (uint64_t)v91)
    {
      char v37 = 0;
      goto LABEL_91;
    }
    if (*((void *)&v89 + 1))
    {
      char v37 = (UniChar *)(*((void *)&v89 + 1) + 2 * *((void *)&v90 + 1) + 2 * v34);
      goto LABEL_91;
    }
    if (v36 > 64) {
      break;
    }
    if (v36 + v34 > v92 || v34 < v30)
    {
      if (v35 >= (uint64_t)v91) {
        uint64_t v35 = v91;
      }
      *((void *)&v91 + 1) = v34;
      CFIndex v92 = v35;
      v38.CFIndex location = *((void *)&v90 + 1) + v34;
      v38.uint64_t length = v35 - v34;
      if ((void)v90)
      {
        if (v38.length)
        {
          CFIndex v39 = (char *)(v90 + v38.location);
          CFIndex v40 = v34 - v35;
          CFRange v41 = buffer;
          do
          {
            UniChar v42 = *v39++;
            *v41++ = v42;
            BOOL v23 = __CFADD__(v40++, 1);
          }
          while (!v23);
        }
      }
      else
      {
        CFStringGetCharacters((CFStringRef)v89, v38, buffer);
      }
    }
    CFIndex v30 = *((void *)&v91 + 1);
    char v37 = &buffer[v34 - *((void *)&v91 + 1)];
LABEL_91:
    if (v36 >= 1) {
      goto LABEL_92;
    }
LABEL_97:
    v34 += v36;
    if (v34 >= v27) {
      goto LABEL_100;
    }
  }
  char v37 = 0;
LABEL_92:
  uint64_t v43 = 0;
  while (1)
  {
    uint64_t v44 = v37[v43];
    if (v44 == 58) {
      break;
    }
    if (v44 > 0x7F || (sURLValidCharacters[v44] & 8) == 0) {
      goto LABEL_100;
    }
    if (++v43 >= v36) {
      goto LABEL_97;
    }
  }
  a4 = 0;
LABEL_100:
  LOBYTE(v77) = 0;
  LODWORD(v78) = 0;
  _parseComponents(theString, a4, (unsigned int *)&v78, __src, (char *)&v77);
  size_t v45 = 16 * v77;
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(v6, 0x1DuLL, v45 + 40, 0);
  CFIndex v32 = Instance;
  if (Instance)
  {
    *((_DWORD *)Instance + 4) = v78;
    *((_DWORD *)Instance + 5) = 134217984;
    memcpy(Instance + 7, __src, v45);
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)v6, theString);
    char v48 = v32 + 3;
    atomic_store((unint64_t)Copy, v32 + 3);
    if (a4) {
      CFURLRef v49 = CFURLCopyAbsoluteURL(a4);
    }
    else {
      CFURLRef v49 = 0;
    }
    v32[4] = (unint64_t)v49;
    CFAllocatorRef v50 = CFGetAllocator(v32);
    CFStringRef v51 = (const __CFString *)atomic_load(v48);
    CFIndex v52 = CFStringGetLength(v51);
    __int16 v79 = 0;
    __src[0] = 0;
    uint64_t v77 = 0;
    uint64_t v78 = 0;
    CFMutableStringRef theStringa = 0;
    int v75 = 0;
    CFStringRef v53 = (const __CFString *)atomic_load(v48);
    constructBuffers(v53, (UInt8 *)buffer, __src, &v78, (char *)&v79 + 1, (char *)&v79);
    int v54 = *((_DWORD *)v32 + 4);
    if ((v54 & 0x4000) != 0)
    {
      uint64_t v77 = 0;
      uint64_t v56 = __src[0];
      uint64_t v57 = v78;
      uint64_t v58 = 2;
      int v59 = HIBYTE(v79);
      do
      {
        unsigned int v60 = *((_DWORD *)v32 + 4);
        if ((v60 & v58) != 0)
        {
          unsigned int v61 = 0;
          unsigned int v62 = v58;
          do
          {
            char v63 = v62;
            v62 >>= 1;
            v61 += v60 & 1;
            v60 >>= 1;
          }
          while ((v63 & 2) == 0);
          CFStringRef v64 = (uint64_t *)&v32[2 * v61 + 7];
          if (*v64 != -1) {
            scanCharacters(v50, &theStringa, &v75, v56, v57, v59, *v64, v64[1] + *v64, &v77, v58, *((_DWORD *)v32 + 5));
          }
        }
        v58 *= 2;
      }
      while (v58 < 512);
      CFStringCompareFlags v65 = (unint64_t *)theStringa;
      if (theStringa)
      {
LABEL_120:
        int v66 = v75;
        unint64_t v67 = v32[5];
        if (v75 && !v67)
        {
          _CFURLAllocateExtraDataspace(v32);
          unint64_t v67 = v32[5];
        }
        if (v67) {
          *(_DWORD *)(v67 + 16) = v66;
        }
        unint64_t v68 = v52 - v77;
        if (v52 > v77)
        {
          if (v59) {
            __CFStringAppendBytes(v65, (unsigned __int8 *)(v56 + v77), v68, 513);
          }
          else {
            CFStringAppendCharacters((CFMutableStringRef)v65, (const UniChar *)(v57 + 2 * v77), v68);
          }
        }
        unint64_t v69 = v32[5];
        if (v69 || (_CFURLAllocateExtraDataspace(v32), (unint64_t v69 = v32[5]) != 0))
        {
          uint64_t v70 = *(const void **)(v69 + 8);
          if (v70) {
            CFRelease(v70);
          }
          CFAllocatorRef v71 = CFGetAllocator(v32);
          *(void *)(v32[5] + 8) = CFStringCreateCopy(v71, (CFStringRef)v65);
        }
        CFRelease(v65);
      }
      else
      {
        *((_DWORD *)v32 + 4) |= 0x10000u;
      }
    }
    else
    {
      if (v54) {
        uint64_t v55 = v32[8] + 1;
      }
      else {
        uint64_t v55 = 1;
      }
      uint64_t v77 = 0;
      uint64_t v56 = __src[0];
      uint64_t v57 = v78;
      int v59 = HIBYTE(v79);
      if (!scanCharacters(v50, &theStringa, &v75, __src[0], v78, HIBYTE(v79), v55, v52, &v77, 0, *((_DWORD *)v32 + 5)))*((_DWORD *)v32 + 4) |= 0x10000u; {
      CFStringCompareFlags v65 = (unint64_t *)theStringa;
      }
      if (theStringa) {
        goto LABEL_120;
      }
    }
    if ((_BYTE)v79)
    {
      CFRange v72 = __src;
      if (!HIBYTE(v79)) {
        CFRange v72 = &v78;
      }
      free((void *)*v72);
    }
  }
  return v32;
}

uint64_t scanCharacters(const __CFAllocator *a1, __CFString **a2, _DWORD *a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, void *a9, int a10, int a11)
{
  uint64_t v52 = *(void *)off_1ECE0A5B0;
  if (!a6)
  {
    if (a7 >= a8) {
      return 0;
    }
    unsigned __int8 v15 = 0;
    uint64_t v46 = a8 - 1;
    if (a3) {
      BOOL v30 = a10 == 0;
    }
    else {
      BOOL v30 = 1;
    }
    int v31 = !v30;
    uint64_t v32 = a7;
    while (1)
    {
      unsigned __int16 v49 = *(_WORD *)(a5 + 2 * v32);
      if (v49 <= 0x7Fu)
      {
        if (sURLValidCharacters[v49])
        {
          if (a10 == 4 || a10 == 2)
          {
            unsigned int v37 = v49 - 47;
            BOOL v21 = v37 > 0x11;
            int v38 = (1 << v37) & 0x30001;
            if (!v21 && v38 != 0) {
              goto LABEL_81;
            }
          }
          goto LABEL_94;
        }
        uint64_t v34 = v32 + 2;
        if (v49 == 37 && v34 < a8)
        {
          unint64_t v42 = *(unsigned __int16 *)(a5 + 2 * v32 + 2);
          if (v42 <= 0x7F && (sURLValidCharacters[v42] & 0x10) != 0)
          {
            unint64_t v43 = *(unsigned __int16 *)(a5 + 2 * v34);
            if (v43 <= 0x7F && (sURLValidCharacters[v43] & 0x10) != 0) {
              goto LABEL_94;
            }
          }
        }
      }
      if (a10 != 8) {
        goto LABEL_81;
      }
      if (v32 != a7 || v49 != 91)
      {
        if (v32 == v46)
        {
          uint64_t v36 = v46;
          if (v49 == 93) {
            goto LABEL_95;
          }
        }
LABEL_81:
        if (v31) {
          *a3 |= a10;
        }
        CFMutableStringRef Mutable = *a2;
        if (!*a2)
        {
          CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
          *a2 = Mutable;
        }
        CFStringAppendCharacters(Mutable, (const UniChar *)(a5 + 2 * *a9), v32 - *a9);
        if (_appendPercentEscapesForCharacter(&v49, 0, a11, *a2))
        {
          *a9 = v32 + 1;
        }
        else if (a11 == 134217984)
        {
          uint64_t v36 = v32 + 1;
          if (v32 + 1 < a8 && (v49 & 0xFC00) == 0xD800)
          {
            unsigned __int16 v41 = *(_WORD *)(a5 + 2 * v36);
            if ((v41 & 0xFC00) == 0xDC00)
            {
              unsigned __int16 v50 = v49;
              unsigned __int16 v51 = v41;
              if (_appendPercentEscapesForCharacter(&v50, 1, 134217984, *a2)) {
                *a9 = v32 + 2;
              }
              else {
                uint64_t v36 = v32;
              }
              unsigned __int8 v15 = 1;
              goto LABEL_95;
            }
          }
        }
        unsigned __int8 v15 = 1;
LABEL_94:
        uint64_t v36 = v32;
        goto LABEL_95;
      }
      uint64_t v36 = a7;
LABEL_95:
      uint64_t v32 = v36 + 1;
      if (v36 + 1 >= a8) {
        return v15;
      }
    }
  }
  if (a7 < a8)
  {
    unsigned __int8 v15 = 0;
    uint64_t v45 = a8 - 1;
    if (a3) {
      BOOL v16 = a10 == 0;
    }
    else {
      BOOL v16 = 1;
    }
    int v17 = !v16;
    uint64_t v18 = a7;
    while (1)
    {
      int v19 = *(char *)(a4 + v18);
      unsigned __int16 v49 = *(char *)(a4 + v18);
      if ((v19 & 0x80000000) == 0)
      {
        if (sURLValidCharacters[(unsigned __int16)v19])
        {
          if (a10 == 4 || a10 == 2)
          {
            unsigned int v23 = (unsigned __int16)v19 - 47;
            BOOL v21 = v23 > 0x11;
            int v24 = (1 << v23) & 0x30001;
            if (!v21 && v24 != 0) {
              goto LABEL_30;
            }
          }
          goto LABEL_43;
        }
        uint64_t v20 = v18 + 2;
        BOOL v21 = v19 == 37 && v20 < a8;
        if (v21
          && (*(char *)(v18 + a4 + 1) & 0x80000000) == 0
          && (sURLValidCharacters[*(unsigned __int8 *)(v18 + a4 + 1)] & 0x10) != 0)
        {
          int v28 = *(char *)(a4 + v20);
          if ((v28 & 0x80000000) == 0 && (sURLValidCharacters[v28] & 0x10) != 0) {
            goto LABEL_43;
          }
        }
      }
      if (a10 != 8) {
        goto LABEL_30;
      }
      if (v18 != a7 || v19 != 91)
      {
        if (v18 == v45)
        {
          uint64_t v22 = v45;
          if (v19 == 93) {
            goto LABEL_44;
          }
        }
LABEL_30:
        if (v17) {
          *a3 |= a10;
        }
        if (!*a2) {
          *a2 = CFStringCreateMutable(a1, 0);
        }
        CFStringRef v26 = CFStringCreateWithBytes(a1, (const UInt8 *)(a4 + *a9), v18 - *a9, 0x201u, 0);
        CFStringAppend(*a2, v26);
        CFRelease(v26);
        if (_appendPercentEscapesForCharacter(&v49, 0, a11, *a2))
        {
          *a9 = v18 + 1;
        }
        else if (a11 == 134217984)
        {
          uint64_t v22 = v18 + 1;
          if (v18 + 1 < a8 && (v49 & 0xFC00) == 0xD800)
          {
            unsigned __int16 v27 = *(char *)(a4 + v22);
            if (v27 >> 10 == 55)
            {
              unsigned __int16 v50 = v49;
              unsigned __int16 v51 = v27;
              if (_appendPercentEscapesForCharacter(&v50, 1, 134217984, *a2)) {
                *a9 = v18 + 2;
              }
              else {
                uint64_t v22 = v18;
              }
              unsigned __int8 v15 = 1;
              goto LABEL_44;
            }
          }
        }
        unsigned __int8 v15 = 1;
LABEL_43:
        uint64_t v22 = v18;
        goto LABEL_44;
      }
      uint64_t v22 = a7;
LABEL_44:
      uint64_t v18 = v22 + 1;
      if (v22 + 1 >= a8) {
        return v15;
      }
    }
  }
  return 0;
}

void _parseComponents(const __CFString *a1, const __CFURL *a2, unsigned int *a3, void *a4, char *a5)
{
  uint64_t v113 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  __int16 v102 = 0;
  int v100 = 0;
  uint64_t v101 = 0;
  constructBuffers(a1, v103, &v101, &v100, (char *)&v102 + 1, (char *)&v102);
  int v11 = HIBYTE(v102);
  if (HIBYTE(v102))
  {
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    long long v104 = 0u;
    unsigned int v12 = *a3;
    if (Length < 1)
    {
      int v17 = 0;
      char v14 = 0;
      unsigned int v18 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      while (v101[v13] != 35)
      {
        if (Length == ++v13)
        {
          char v14 = 0;
          uint64_t v13 = Length;
          goto LABEL_14;
        }
      }
      v12 |= 0x100u;
      *(void *)&long long v112 = v13 + 1;
      *((void *)&v112 + 1) = ~v13 + Length;
      char v14 = 1;
LABEL_14:
      if (v13 < 1)
      {
        int v17 = 0;
        unsigned int v18 = 0;
      }
      else
      {
        unsigned int v18 = *v101;
        int v17 = 1;
        if ((v18 & 0x80000000) != 0)
        {
          int v19 = 0;
          goto LABEL_20;
        }
      }
      CFIndex Length = v13;
    }
    int v19 = (sURLValidCharacters[(unsigned __int16)v18] >> 3) & 1;
    uint64_t v13 = Length;
LABEL_20:
    uint64_t v20 = 0;
    BOOL v23 = v18 > 0x40 && v19 != 0 || v18 == 58;
    if (v17 && v23)
    {
      uint64_t v20 = 0;
      while (1)
      {
        uint64_t v24 = v101[v20];
        if (v24 == 58) {
          break;
        }
        if ((v24 & 0x80) == 0 && (sURLValidCharacters[v24] & 8) != 0 && ++v20 < v13) {
          continue;
        }
        uint64_t v20 = 0;
        uint64_t v25 = 0;
        goto LABEL_38;
      }
      v12 |= 1u;
      *(void *)&long long v104 = 0;
      *((void *)&v104 + 1) = v20;
      ++v14;
      switch(v20)
      {
        case 3:
          if (*v101 != 102 || v101[1] != 116)
          {
            uint64_t v25 = 4;
            uint64_t v20 = 3;
            goto LABEL_38;
          }
          uint64_t v60 = 4;
          uint64_t v61 = 3;
          BOOL v62 = v101[2] == 112;
          unsigned int v63 = v12 & 0x1FFFFFFF | 0xA0000000;
          uint64_t v64 = 4;
          uint64_t v20 = 3;
          break;
        case 4:
          int v65 = *v101;
          if (v65 == 100)
          {
            if (v101[1] != 97 || v101[2] != 116) {
              goto LABEL_256;
            }
            uint64_t v60 = 5;
            uint64_t v61 = 4;
            BOOL v62 = v101[3] == 97;
            unsigned int v90 = 0x80000000;
          }
          else
          {
            if (v65 != 102)
            {
              if (v65 == 104 && v101[1] == 116 && v101[2] == 116 && v101[3] == 112)
              {
                int v33 = v12 & 0x1FFFFFFF | 0x20000000;
                uint64_t v25 = 5;
                uint64_t v20 = 4;
LABEL_183:
                unsigned int v12 = v33;
                goto LABEL_38;
              }
LABEL_256:
              uint64_t v25 = 5;
              uint64_t v20 = 4;
              goto LABEL_38;
            }
            if (v101[1] != 105 || v101[2] != 108) {
              goto LABEL_256;
            }
            uint64_t v60 = 5;
            uint64_t v61 = 4;
            BOOL v62 = v101[3] == 101;
            unsigned int v90 = 1610612736;
          }
          unsigned int v63 = v90 & 0xE0000000 | v12 & 0x1FFFFFFF;
          uint64_t v64 = 5;
          uint64_t v20 = 4;
          break;
        case 5:
          if (*v101 != 104 || v101[1] != 116 || v101[2] != 116 || v101[3] != 112 || v101[4] != 115)
          {
            uint64_t v25 = 6;
            uint64_t v20 = 5;
            goto LABEL_38;
          }
          int v33 = v12 & 0x1FFFFFFF | 0x40000000;
          uint64_t v25 = 6;
          uint64_t v20 = 5;
          goto LABEL_183;
        default:
          uint64_t v25 = v20 + 1;
          goto LABEL_38;
      }
      if (v62) {
        unsigned int v12 = v63;
      }
      else {
        uint64_t v20 = v61;
      }
      if (v62) {
        uint64_t v25 = v64;
      }
      else {
        uint64_t v25 = v60;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
LABEL_38:
    if ((v12 & 1) != 0 && (v13 == v25 || v101[v25] != 47))
    {
LABEL_113:
      *a3 = v12 & 0xFFFFFEFF;
      *a4 = 0;
      a4[1] = v20;
      *a5 = 1;
      goto LABEL_215;
    }
    int v26 = v12 | 0x4000;
    if (v13 - v25 >= 2 && v101[v25] == 47 && v101[v25 + 1] == 47)
    {
      uint64_t v27 = v25 + 2;
      if (v25 + 2 >= v13) {
        goto LABEL_48;
      }
      uint64_t v28 = v25 + 2;
      while ((v101[v28] | 0x10) != 0x3F)
      {
        if (v13 == ++v28)
        {
          uint64_t v28 = v13;
          break;
        }
      }
      if (v28 == v27)
      {
LABEL_48:
        uint64_t v28 = v25 + 2;
      }
      else
      {
        if (v27 >= v28)
        {
LABEL_236:
          char v87 = v14;
        }
        else
        {
          uint64_t v86 = -1;
          while (v101[v27 + 1 + v86] != 64)
          {
            ++v86;
            if (v25 - v28 + 2 + v86 == -1) {
              goto LABEL_236;
            }
          }
          int v26 = v12 | 0x4002;
          char v87 = v14 + 1;
          *(void *)&long long v105 = v25 + 2;
          if (v27 < v25 + v86 + 3)
          {
            uint64_t v91 = 0;
            CFIndex v92 = &v101[v27];
            uint64_t v93 = v86;
            while (v92[v91] != 58)
            {
              ++v91;
              if (--v93 == -1) {
                goto LABEL_284;
              }
            }
            int v26 = v12 | 0x4006;
            char v87 = v14 + 2;
            *(void *)&long long v106 = v25 + v91 + 3;
            *((void *)&v106 + 1) = v93;
            *((void *)&v105 + 1) = v91;
          }
LABEL_284:
          if ((v26 & 4) == 0) {
            *((void *)&v105 + 1) = v86 + 1;
          }
          uint64_t v27 = v25 + v86 + 4;
        }
        v26 |= 8u;
        char v14 = v87 + 1;
        *(void *)&long long v107 = v27;
        if (v28 > v27)
        {
          for (uint64_t i = v27; i < v28; ++i)
          {
            int v97 = v101[i];
            if (v97 == 91)
            {
              if (i < v28)
              {
                while (v101[i] != 93)
                {
                  if (v28 == ++i)
                  {
                    uint64_t i = v28;
                    goto LABEL_297;
                  }
                }
                v26 |= 0x400u;
              }
            }
            else if (v97 == 58)
            {
              v26 |= 0x10u;
              char v14 = v87 + 2;
              *(void *)&long long v108 = i + 1;
              *((void *)&v108 + 1) = v28 - (i + 1);
              *((void *)&v107 + 1) = i - v27;
              break;
            }
LABEL_297:
            ;
          }
        }
        if ((v26 & 0x10) == 0) {
          *((void *)&v107 + 1) = v28 - v27;
        }
      }
    }
    else
    {
      uint64_t v28 = v25;
    }
    if (v28 >= v13)
    {
LABEL_54:
      uint64_t v29 = v13;
    }
    else
    {
      uint64_t v29 = v28;
      while (v101[v29] != 63)
      {
        if (v13 == ++v29) {
          goto LABEL_54;
        }
      }
      v26 |= 0x80u;
      ++v14;
      *(void *)&long long v111 = v29 + 1;
      *((void *)&v111 + 1) = ~v29 + v13;
    }
    uint64_t v34 = v29 - v28;
    if (v29 == v28 && (v26 & 0x1E) == 0) {
      goto LABEL_168;
    }
    int v35 = v26 | 0x20;
    ++v14;
    *(void *)&long long v109 = v28;
    *((void *)&v109 + 1) = v29 - v28;
    if (v34 < 1)
    {
      if (a2 && CFURLHasDirectoryPath(a2))
      {
LABEL_166:
        int v26 = v35 | 0x800;
        goto LABEL_168;
      }
    }
    else
    {
      if (v29 <= v28)
      {
        BOOL v36 = 0;
      }
      else if (v101[v28] == 37)
      {
        BOOL v36 = 1;
      }
      else
      {
        uint64_t v50 = v28 + 1;
        do
        {
          uint64_t v51 = v50;
          if (v29 == v50) {
            break;
          }
          int v52 = v101[v50++];
        }
        while (v52 != 37);
        BOOL v36 = v51 < v29;
      }
      if (v34 >= 7
        && v101[v28] == 47
        && v101[v28 + 1] == 46
        && v101[v28 + 2] == 102
        && v101[v28 + 3] == 105
        && v101[v28 + 4] == 108
        && (CFStringRef v53 = &v101[v28], v53[5] == 101)
        && v53[6] == 47)
      {
        int v35 = v26 | 0x2020;
      }
      else
      {
        int v54 = v26 | 0x8020;
        if (!v36) {
          int v35 = v54;
        }
      }
      int v55 = v101[v29 - 1];
      if (v55 == 47) {
        goto LABEL_166;
      }
      if ((unsigned __int16)v55 == 46)
      {
        if (v34 == 1) {
          goto LABEL_166;
        }
        int v56 = v101[v29 - 2];
        if (v56 == 47 || (unsigned __int16)v56 == 46 && (v34 == 2 || v101[v29 - 3] == 47)) {
          goto LABEL_166;
        }
      }
    }
    int v26 = v35;
LABEL_168:
    uint64_t v57 = 0;
    int v58 = 0;
    *a3 = v26;
    *a5 = v14;
    int v59 = 1;
    do
    {
      if ((*a3 & v59) != 0) {
        *(_OWORD *)&a4[2 * v58++] = *(long long *)((char *)&v104 + v57);
      }
      v59 *= 2;
      v57 += 16;
    }
    while (v57 != 144);
    goto LABEL_215;
  }
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v104 = 0u;
  unsigned int v12 = *a3;
  if (Length < 1)
  {
    int v30 = 0;
    char v16 = 0;
    unsigned int v31 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    while (v100[v15] != 35)
    {
      if (Length == ++v15)
      {
        char v16 = 0;
        uint64_t v15 = Length;
        goto LABEL_60;
      }
    }
    v12 |= 0x100u;
    *(void *)&long long v112 = v15 + 1;
    *((void *)&v112 + 1) = ~v15 + Length;
    char v16 = 1;
LABEL_60:
    if (v15 < 1)
    {
      int v30 = 0;
      unsigned int v31 = 0u;
    }
    else
    {
      unsigned int v31 = *v100;
      int v30 = 1;
      if (v31 > 0x7F)
      {
        int v32 = 0;
        goto LABEL_82;
      }
    }
    CFIndex Length = v15;
  }
  int v32 = (sURLValidCharacters[v31] >> 3) & 1;
  uint64_t v15 = Length;
LABEL_82:
  uint64_t v20 = 0;
  BOOL v39 = v31 > 0x40 && v32 != 0 || v31 == 58;
  if (!v30 || !v39)
  {
    uint64_t v41 = 0;
    goto LABEL_100;
  }
  uint64_t v20 = 0;
  while (1)
  {
    uint64_t v40 = v100[v20];
    if (v40 == 58) {
      break;
    }
    if (v40 <= 0x7F && (sURLValidCharacters[v40] & 8) != 0 && ++v20 < v15) {
      continue;
    }
    uint64_t v20 = 0;
    uint64_t v41 = 0;
    goto LABEL_100;
  }
  v12 |= 1u;
  *(void *)&long long v104 = 0;
  *((void *)&v104 + 1) = v20;
  ++v16;
  switch(v20)
  {
    case 3:
      if (*v100 != 102 || v100[1] != 116)
      {
        uint64_t v41 = 4;
        uint64_t v20 = 3;
        break;
      }
      uint64_t v79 = 4;
      uint64_t v80 = 3;
      BOOL v81 = v100[2] == 112;
      unsigned int v82 = v12 & 0x1FFFFFFF | 0xA0000000;
      uint64_t v83 = 4;
      uint64_t v20 = 3;
      goto LABEL_260;
    case 4:
      int v84 = *v100;
      if (v84 != 100)
      {
        if (v84 == 102)
        {
          if (v100[1] == 105 && v100[2] == 108 && v100[3] == 101)
          {
            int v85 = 1610612736;
            goto LABEL_270;
          }
        }
        else if (v84 == 104 && v100[1] == 116 && v100[2] == 116 && v100[3] == 112)
        {
          int v85 = 0x20000000;
LABEL_270:
          unsigned int v46 = v85 & 0xE0000000 | v12 & 0x1FFFFFFF;
          uint64_t v41 = 5;
          uint64_t v20 = 4;
          goto LABEL_271;
        }
LABEL_272:
        uint64_t v41 = 5;
        uint64_t v20 = 4;
        break;
      }
      if (v100[1] != 97 || v100[2] != 116) {
        goto LABEL_272;
      }
      uint64_t v79 = 5;
      uint64_t v80 = 4;
      BOOL v81 = v100[3] == 97;
      unsigned int v82 = v12 & 0x1FFFFFFF | 0x80000000;
      uint64_t v83 = 5;
      uint64_t v20 = 4;
LABEL_260:
      if (v81) {
        unsigned int v12 = v82;
      }
      else {
        uint64_t v20 = v80;
      }
      if (v81) {
        uint64_t v41 = v83;
      }
      else {
        uint64_t v41 = v79;
      }
      break;
    case 5:
      if (*v100 == 104 && v100[1] == 116 && v100[2] == 116 && v100[3] == 112 && v100[4] == 115)
      {
        unsigned int v46 = v12 & 0x1FFFFFFF | 0x40000000;
        uint64_t v41 = 6;
        uint64_t v20 = 5;
LABEL_271:
        unsigned int v12 = v46;
        break;
      }
      uint64_t v41 = 6;
      uint64_t v20 = 5;
      break;
    default:
      uint64_t v41 = v20 + 1;
      break;
  }
LABEL_100:
  if ((v12 & 1) != 0 && (v15 == v41 || v100[v41] != 47)) {
    goto LABEL_113;
  }
  int v42 = v12 | 0x4000;
  if (v15 - v41 >= 2 && v100[v41] == 47 && v100[v41 + 1] == 47)
  {
    uint64_t v43 = v41 + 2;
    if (v41 + 2 >= v15) {
      goto LABEL_112;
    }
    uint64_t v44 = v41 + 2;
    while ((v100[v44] | 0x10) != 0x3F)
    {
      if (v15 == ++v44)
      {
        uint64_t v44 = v15;
        break;
      }
    }
    if (v44 == v43)
    {
LABEL_112:
      uint64_t v44 = v41 + 2;
    }
    else
    {
      if (v43 >= v44)
      {
LABEL_242:
        char v89 = v16;
      }
      else
      {
        uint64_t v88 = 0;
        while (v100[v41 + 2 + v88] != 64)
        {
          ++v88;
          if (!(v41 - v44 + 2 + v88)) {
            goto LABEL_242;
          }
        }
        int v42 = v12 | 0x4002;
        char v89 = v16 + 1;
        *(void *)&long long v105 = v41 + 2;
        if (v43 < v41 + v88 + 2)
        {
          uint64_t v94 = 0;
          uint64_t v95 = v88 - 1;
          while (v100[v41 + 2 + v94] != 58)
          {
            ++v94;
            if (--v95 == -1) {
              goto LABEL_301;
            }
          }
          int v42 = v12 | 0x4006;
          char v89 = v16 + 2;
          *(void *)&long long v106 = v41 + v94 + 3;
          *((void *)&v106 + 1) = v95;
          *((void *)&v105 + 1) = v94;
        }
LABEL_301:
        if ((v42 & 4) == 0) {
          *((void *)&v105 + 1) = v88;
        }
        uint64_t v43 = v41 + v88 + 3;
      }
      v42 |= 8u;
      char v16 = v89 + 1;
      *(void *)&long long v107 = v43;
      if (v44 > v43)
      {
        for (uint64_t j = v43; j < v44; ++j)
        {
          int v99 = v100[j];
          if (v99 == 91)
          {
            if (j < v44)
            {
              while (v100[j] != 93)
              {
                if (v44 == ++j)
                {
                  uint64_t j = v44;
                  goto LABEL_314;
                }
              }
              v42 |= 0x400u;
            }
          }
          else if (v99 == 58)
          {
            v42 |= 0x10u;
            char v16 = v89 + 2;
            *(void *)&long long v108 = j + 1;
            *((void *)&v108 + 1) = v44 - (j + 1);
            *((void *)&v107 + 1) = j - v43;
            break;
          }
LABEL_314:
          ;
        }
      }
      if ((v42 & 0x10) == 0) {
        *((void *)&v107 + 1) = v44 - v43;
      }
    }
  }
  else
  {
    uint64_t v44 = v41;
  }
  if (v44 >= v15)
  {
LABEL_119:
    uint64_t v45 = v15;
  }
  else
  {
    uint64_t v45 = v44;
    while (v100[v45] != 63)
    {
      if (v15 == ++v45) {
        goto LABEL_119;
      }
    }
    v42 |= 0x80u;
    ++v16;
    *(void *)&long long v111 = v45 + 1;
    *((void *)&v111 + 1) = ~v45 + v15;
  }
  uint64_t v47 = v45 - v44;
  if (v45 == v44 && (v42 & 0x1E) == 0) {
    goto LABEL_211;
  }
  int v48 = v42 | 0x20;
  ++v16;
  *(void *)&long long v109 = v44;
  *((void *)&v109 + 1) = v45 - v44;
  if (v47 < 1)
  {
    if (a2 && CFURLHasDirectoryPath(a2))
    {
LABEL_209:
      int v42 = v48 | 0x800;
      goto LABEL_211;
    }
  }
  else
  {
    if (v45 <= v44)
    {
      BOOL v49 = 0;
    }
    else if (v100[v44] == 37)
    {
      BOOL v49 = 1;
    }
    else
    {
      uint64_t v66 = v44 + 1;
      do
      {
        uint64_t v67 = v66;
        if (v45 == v66) {
          break;
        }
        int v68 = v100[v66++];
      }
      while (v68 != 37);
      BOOL v49 = v67 < v45;
    }
    if (v47 >= 7
      && v100[v44] == 47
      && (unint64_t v69 = &v100[v44], v69[1] == 46)
      && v69[2] == 102
      && (uint64_t v70 = &v100[v44], v70[3] == 105)
      && v70[4] == 108
      && (CFAllocatorRef v71 = &v100[v44], v71[5] == 101)
      && v71[6] == 47)
    {
      int v48 = v42 | 0x2020;
    }
    else
    {
      int v72 = v42 | 0x8020;
      if (!v49) {
        int v48 = v72;
      }
    }
    int v73 = v100[v45 - 1];
    if (v73 == 47) {
      goto LABEL_209;
    }
    if (v73 == 46)
    {
      if (v47 == 1) {
        goto LABEL_209;
      }
      int v74 = v100[v45 - 2];
      if (v74 == 47 || v74 == 46 && (v47 == 2 || v100[v45 - 3] == 47)) {
        goto LABEL_209;
      }
    }
  }
  int v42 = v48;
LABEL_211:
  uint64_t v75 = 0;
  int v76 = 0;
  *a3 = v42;
  *a5 = v16;
  int v77 = 1;
  do
  {
    if ((*a3 & v77) != 0) {
      *(_OWORD *)&a4[2 * v76++] = *(long long *)((char *)&v104 + v75);
    }
    v77 *= 2;
    v75 += 16;
  }
  while (v75 != 144);
LABEL_215:
  if ((_BYTE)v102)
  {
    uint64_t v78 = (void **)&v101;
    if (!v11) {
      uint64_t v78 = (void **)&v100;
    }
    free(*v78);
  }
}

void constructBuffers(const __CFString *a1, UInt8 *a2, void *a3, void *a4, char *a5, char *a6)
{
  usedBufLen[1] = *(void *)off_1ECE0A5B0;
  CStringPtr = CFStringGetCStringPtr(a1, 0x201u);
  *a3 = CStringPtr;
  if (CStringPtr)
  {
    *a4 = 0;
    *a5 = 1;
LABEL_5:
    *a6 = 0;
    return;
  }
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(a1);
  *a4 = CharactersPtr;
  if (CharactersPtr)
  {
    *a5 = 0;
    goto LABEL_5;
  }
  usedBufLen[0] = 0;
  CFIndex Length = CFStringGetLength(a1);
  v20.CFIndex location = 0;
  v20.uint64_t length = Length;
  CFStringGetBytes(a1, v20, 0x201u, 0, 0, 0, 0x7FFFFFFFLL, usedBufLen);
  if (usedBufLen[0] == Length)
  {
    if (a2 && Length < 1025)
    {
      char v15 = 0;
    }
    else
    {
      a2 = (UInt8 *)malloc_type_malloc(Length, 0x2AEB48FuLL);
      char v15 = 1;
    }
    *a6 = v15;
    v21.CFIndex location = 0;
    v21.uint64_t length = Length;
    CFStringGetBytes(a1, v21, 0x201u, 0, 0, a2, Length, 0);
    *a3 = a2;
    char v18 = 1;
  }
  else
  {
    size_t v16 = 2 * Length;
    if (a2 && v16 < 0x401)
    {
      char v17 = 0;
    }
    else
    {
      a2 = (UInt8 *)malloc_type_malloc(v16, 0x1000040BDFB0063uLL);
      char v17 = 1;
    }
    *a6 = v17;
    v22.CFIndex location = 0;
    v22.uint64_t length = Length;
    CFStringGetCharacters(a1, v22, (UniChar *)a2);
    char v18 = 0;
    *a4 = a2;
  }
  *a5 = v18;
}

void CFDateComponentsSetCalendar(uint64_t a1, void *cf2)
{
  if (!a1) {
    CFDateComponentsSetCalendar_cold_1();
  }
  int v4 = *(const void **)(a1 + 16);
  if (cf2 && v4)
  {
    if (CFEqual(v4, cf2)) {
      return;
    }
    int v4 = *(const void **)(a1 + 16);
  }
  else if (!v4)
  {
    goto LABEL_8;
  }
  CFRelease(v4);
  *(void *)(a1 + 16) = 0;
LABEL_8:
  if (cf2)
  {
    CFStringRef Copy = (__CFCalendar *)_CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, cf2);
    char v6 = Copy;
    CFTimeZoneRef v7 = *(const __CFTimeZone **)(a1 + 24);
    if (v7) {
      CFCalendarSetTimeZone(Copy, v7);
    }
    *(void *)(a1 + 16) = v6;
  }
}

uint64_t _CFCalendarCreateCopy(uint64_t a1, void *a2)
{
  return [a2 copy];
}

CFStringRef _CFURLCreateURLStringWithBytes(const __CFAllocator *a1, UInt8 *bytes, size_t numBytes, CFStringEncoding encoding)
{
  usedBufLen[1] = *(void *)off_1ECE0A5B0;
  CFStringRef v7 = 0;
  switch(BYTE1(encoding))
  {
    case 0:
      CFStringRef v7 = 0;
      if ((encoding > 0x22 || ((1 << encoding) & 0x600000032) == 0) && encoding != 152) {
        goto LABEL_20;
      }
      return v7;
    case 1:
      if (encoding != 134217984) {
        return 0;
      }
      goto LABEL_20;
    case 2:
      if (encoding != 518) {
        goto LABEL_20;
      }
      return 0;
    case 6:
      if (encoding == 1536) {
        goto LABEL_20;
      }
      return 0;
    case 8:
    case 0xC:
      return v7;
    case 0xA:
      if (encoding - 2561 > 0xF) {
        goto LABEL_20;
      }
      int v8 = 1 << (encoding - 1);
      int v9 = 32785;
      break;
    case 0xB:
      if (encoding - 3059 > 0xC) {
        goto LABEL_20;
      }
      int v8 = 1 << (encoding + 13);
      int v9 = 4099;
      break;
    default:
      if ((encoding & 0xFF00) <= 0xC00) {
        goto LABEL_20;
      }
      return 0;
  }
  if ((v8 & v9) != 0) {
    return 0;
  }
LABEL_20:
  CFStringRef v10 = CFStringCreateWithBytes(a1, bytes, numBytes, encoding, 0);
  CFStringRef v7 = v10;
  if (!v10) {
    return v7;
  }
  CStringPtr = CFStringGetCStringPtr(v10, encoding);
  if (CStringPtr)
  {
    unsigned int v12 = (UInt8 *)CStringPtr;
    int v13 = 0;
    if (strlen(CStringPtr) != numBytes) {
      goto LABEL_31;
    }
  }
  else
  {
    CFIndex Length = CFStringGetLength(v7);
    CFIndex v15 = CFStringGetMaximumSizeForEncoding(Length, encoding) + 1;
    unsigned int v12 = (UInt8 *)malloc_type_malloc(v15, 0x9CDD8CAFuLL);
    if (!v12)
    {
      int v13 = 0;
      goto LABEL_32;
    }
    usedBufLen[0] = 0;
    v18.CFIndex location = 0;
    v18.uint64_t length = Length;
    CFStringGetBytes(v7, v18, encoding, 0, 0, v12, v15, usedBufLen);
    if (usedBufLen[0] != numBytes)
    {
      free(v12);
      int v13 = 0;
LABEL_31:
      unsigned int v12 = 0;
      goto LABEL_32;
    }
    int v13 = 1;
  }
  if (memcmp(bytes, v12, numBytes))
  {
LABEL_32:
    CFRelease(v7);
    CFStringRef v7 = 0;
  }
  if (v13) {
    free(v12);
  }
  return v7;
}

CFDictionaryRef _copyQueryTable(uint64_t a1, CFURLRef relativeURL, const __CFArray *cf, const __CFString *a4, const __CFString *a5)
{
  CFArrayRef v7 = cf;
  if (a1 && !cf)
  {
    CFArrayRef v7 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
    goto LABEL_7;
  }
  if (cf) {
    CFRetain(cf);
  }
  if (a1)
  {
LABEL_7:
    if (a5)
    {
      MutableCFStringRef Copy = CFStringCreateMutableCopy(0, 0, a4);
      _CFAppendPathComponent2(MutableCopy, a5);
    }
    else
    {
      MutableCFStringRef Copy = (__CFString *)CFRetain(a4);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 176));
    CFDictionaryRef v11 = *(const __CFDictionary **)(a1 + 184);
    if (v11)
    {
      CFStringRef Value = (__CFDictionary *)CFDictionaryGetValue(v11, MutableCopy);
      if (Value)
      {
        QueryTableAtPath = Value;
        CFRetain(Value);
LABEL_15:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 176));
        goto LABEL_17;
      }
    }
    else
    {
      *(void *)(a1 + 184) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    QueryTableAtPath = _createQueryTableAtPath(*(const __CFString **)(a1 + 192), v7, a4, a5, *(unsigned char *)(a1 + 55));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 184), MutableCopy, QueryTableAtPath);
    goto LABEL_15;
  }
  CFURLRef v14 = CFURLCopyAbsoluteURL(relativeURL);
  MutableCFStringRef Copy = (__CFString *)CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
  CFRelease(v14);
  QueryTableAtPath = _createQueryTableAtPath(MutableCopy, v7, a4, a5, 0);
LABEL_17:
  CFRelease(MutableCopy);
  if (v7) {
    CFRelease(v7);
  }
  if (QueryTableAtPath) {
    return QueryTableAtPath;
  }

  return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

CFTypeRef _CFBundleCopyLanguageSearchListInBundle(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v3 = *(__CFArray **)(a1 + 40);
  if (v3) {
    goto LABEL_33;
  }
  os_unfair_lock_unlock(v2);
  CFArrayRef v4 = (const __CFArray *)_CFBundleCopyBundleLocalizations(a1, 0);
  CFArrayRef v5 = (const __CFArray *)_CFBundleCopyUserLanguages();
  DevelopmentRegiouint64_t n = (__CFString *)CFBundleGetDevelopmentRegion((CFBundleRef)a1);
  uint64_t v3 = _CFBundleCopyPreferredLanguagesInList(v4, DevelopmentRegion, v5, 1, *(void *)(a1 + 16), (__CFBundle *)a1);
  if (!CFArrayGetCount(v3))
  {
    CFRelease(v3);
    uint64_t v3 = _CFBundleCopyPreferredLanguagesInList(v4, @"en_US", v5, 1, *(void *)(a1 + 16), (__CFBundle *)a1);
  }
  if (!CFArrayGetCount(v3) && v4 && CFArrayGetCount(v4) >= 1)
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v4, 0);
    CFRelease(v3);
    uint64_t v3 = _CFBundleCopyPreferredLanguagesInList(v4, ValueAtIndex, v5, 1, *(void *)(a1 + 16), (__CFBundle *)a1);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (DevelopmentRegion)
  {
    v14.uint64_t length = CFArrayGetCount(v3);
    v14.CFIndex location = 0;
    if (!CFArrayContainsValue(v3, v14, DevelopmentRegion)) {
      CFArrayAppendValue(v3, DevelopmentRegion);
    }
    if (!v4) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    v15.CFIndex location = 0;
    v15.uint64_t length = Count;
    if (CFArrayContainsValue(v4, v15, @"en"))
    {
      v9.uint64_t length = CFArrayGetCount(v3);
      CFStringRef v10 = @"en";
    }
    else
    {
      v16.CFIndex location = 0;
      v16.uint64_t length = Count;
      if (CFArrayContainsValue(v4, v16, @"English"))
      {
        v9.uint64_t length = CFArrayGetCount(v3);
        CFStringRef v10 = @"English";
      }
      else
      {
        v17.CFIndex location = 0;
        v17.uint64_t length = Count;
        if (!CFArrayContainsValue(v4, v17, @"en_US"))
        {
LABEL_24:
          CFRelease(v4);
          goto LABEL_25;
        }
        v9.uint64_t length = CFArrayGetCount(v3);
        CFStringRef v10 = @"en_US";
      }
    }
    v9.CFIndex location = 0;
    if (!CFArrayContainsValue(v3, v9, v10)) {
      CFArrayAppendValue(v3, v10);
    }
    goto LABEL_24;
  }
LABEL_25:
  if (!CFArrayGetCount(v3))
  {
    if (_defaultLocalization) {
      CFDictionaryRef v11 = (__CFString *)_defaultLocalization;
    }
    else {
      CFDictionaryRef v11 = @"en";
    }
    CFArrayAppendValue(v3, v11);
  }
  os_unfair_lock_lock_with_options();
  if (*(void *)(a1 + 40))
  {
    CFRelease(v3);
    uint64_t v3 = *(__CFArray **)(a1 + 40);
  }
  else
  {
    *(void *)(a1 + 40) = v3;
  }
LABEL_33:
  CFTypeRef v12 = CFRetain(v3);
  os_unfair_lock_unlock(v2);
  return v12;
}

const void *_CFBundleCopyBundleLocalizations(uint64_t a1, uint64_t a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  os_unfair_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 128))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    if (CFBundleGetMainBundle() != (CFBundleRef)a1) {
      goto LABEL_8;
    }
    if (CFBundleFollowParentLocalization_once != -1) {
      dispatch_once(&CFBundleFollowParentLocalization_once, &__block_literal_global_142);
    }
    if (CFBundleFollowParentLocalization_followParent != 1
      || (CFArrayRef v5 = _CFBundleCopyXPCBootstrapMainBundleLanguages()) == 0)
    {
LABEL_8:
      CFArrayRef v5 = _copyBundleLocalizationsFromResources((__CFBundle *)a1, a2);
    }
    os_unfair_lock_lock_with_options();
    if (!*(unsigned char *)(a1 + 128))
    {
      *(void *)(a1 + 120) = CFRetain(v5);
      *(unsigned char *)(a1 + 128) = 1;
      goto LABEL_12;
    }
    CFRelease(v5);
  }
  CFArrayRef v5 = CFRetain(*(CFTypeRef *)(a1 + 120));
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  return v5;
}

__CFString *_CFGetSlashStr()
{
  return @"/";
}

CFURLRef _CFBundleCreateRelativeURLFromBaseAndPath(const __CFString *a1, const __CFURL *a2, int a3, const __CFString *a4)
{
  CFStringRef v7 = a1;
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  result.CFIndex location = 0;
  result.uint64_t length = 0;
  v18.uint64_t length = CFStringGetLength(a1) - 1;
  v18.CFIndex location = 0;
  int v8 = CFStringFindWithOptions(v7, a4, v18, 4uLL, &result);
  if (v8)
  {
    v19.uint64_t length = result.location;
    v19.CFIndex location = 0;
    CFStringRef v9 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, v19);
    a2 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, v9, 1u);
    CFIndex v10 = result.location + 1;
    CFIndex Length = CFStringGetLength(v7);
    v20.uint64_t length = Length + ~result.location;
    v20.CFIndex location = v10;
    CFStringRef v7 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, v20);
    CFRelease(v9);
  }
  CFIndex v12 = CFStringGetLength(v7);
  Boolean v13 = CFStringGetCharacterAtIndex(v7, v12 - 1) == a3;
  CFURLRef v14 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, kCFURLPOSIXPathStyle, v13, a2);
  if (v8)
  {
    CFRelease(a2);
    CFRelease(v7);
  }
  return v14;
}

void *_CFURLAllocateExtraDataspace(void *result)
{
  if (!result[5])
  {
    unsigned int v1 = result;
    CFAllocatorRef v2 = CFGetAllocator(result);
    CFRange result = (void *)CFAllocatorAllocateTyped(v2, 24, 0x10E0040191BE475, 0);
    uint64_t v3 = v1[5];
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 8);
      *CFRange result = *(void *)v3;
      *((_DWORD *)result + 4) = *(_DWORD *)(v3 + 16);
    }
    else
    {
      uint64_t v4 = 0;
      *CFRange result = 0;
      *((_DWORD *)result + 4) = 0;
    }
    result[1] = v4;
    v1[5] = result;
  }
  return result;
}

__CFDictionary *_createQueryTableAtPath(const __CFString *a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, char a5)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFArrayRef theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  CFAllocatorRef v10 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  CFMutableDictionaryRef v30 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a1);
  CFIndex v12 = MutableCopy;
  if (a3) {
    _CFAppendPathComponent2(MutableCopy, a3);
  }
  CFIndex Length = CFStringGetLength(v12);
  if (a4) {
    _CFAppendPathComponent2(v12, a4);
  }
  _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, 0, (uint64_t)Mutable, (uint64_t)v30, 0, 0, 0);
  v32.uint64_t length = CFStringGetLength(v12) - Length;
  v32.CFIndex location = Length;
  CFStringDelete(v12, v32);
  CFIndex Count = CFArrayGetCount(theArray);
  if (!a2)
  {
    CFMutableDictionaryRef cf = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFIndex v14 = 0;
    goto LABEL_11;
  }
  CFIndex v14 = CFArrayGetCount(a2);
  CFMutableDictionaryRef cf = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v14 < 1)
  {
LABEL_11:
    BOOL v18 = 0;
    goto LABEL_12;
  }
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, 0);
  CFIndex v16 = CFStringGetLength(ValueAtIndex);
  uint64_t v17 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16 + 5, ValueAtIndex);
  CFStringAppend(v17, @".lproj");
  _CFAppendPathComponent2(v12, ValueAtIndex);
  _CFAppendPathExtension2(v12, @"lproj");
  if (a4) {
    _CFAppendPathComponent2(v12, a4);
  }
  _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, 0, (uint64_t)Mutable, (uint64_t)v30, (uint64_t)cf, 1, v17);
  CFRelease(v17);
  v33.uint64_t length = CFStringGetLength(v12) - Length;
  v33.CFIndex location = Length;
  CFStringDelete(v12, v33);
  BOOL v18 = Count < CFArrayGetCount(theArray);
LABEL_12:
  CFRange v19 = Mutable;
  _CFAppendPathComponent2(v12, @"Base");
  _CFAppendPathExtension2(v12, @"lproj");
  if (a4) {
    _CFAppendPathComponent2(v12, a4);
  }
  char v20 = 1;
  _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, v18, (uint64_t)v19, (uint64_t)v30, (uint64_t)cf, 1, @"Base.lproj");
  v34.uint64_t length = CFStringGetLength(v12) - Length;
  v34.CFIndex location = Length;
  CFStringDelete(v12, v34);
  if (!v18) {
    char v20 = Count < CFArrayGetCount(theArray);
  }
  if (v14 > 1 && CFArrayGetCount(a2) > 1)
  {
    CFIndex v21 = 1;
    do
    {
      CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(a2, v21);
      CFIndex v23 = CFStringGetLength(v22);
      CFAllocatorRef v24 = v10;
      uint64_t v25 = CFStringCreateMutableCopy(v10, v23 + 5, v22);
      CFStringAppend(v25, @".lproj");
      _CFAppendPathComponent2(v12, v22);
      _CFAppendPathExtension2(v12, @"lproj");
      if (a4) {
        _CFAppendPathComponent2(v12, a4);
      }
      _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, v20, (uint64_t)v19, (uint64_t)v30, (uint64_t)cf, 0, v25);
      CFRelease(v25);
      v35.uint64_t length = CFStringGetLength(v12) - Length;
      v35.CFIndex location = Length;
      CFStringDelete(v12, v35);
      if (v20) {
        char v20 = 1;
      }
      else {
        char v20 = Count < CFArrayGetCount(theArray);
      }
      CFAllocatorRef v10 = v24;
      ++v21;
    }
    while (v21 < CFArrayGetCount(a2));
  }
  CFRelease(cf);
  CFRelease(v12);
  if (CFArrayGetCount(theArray) >= 1) {
    CFDictionarySetValue(v19, @"_CFBAF_", theArray);
  }
  CFRelease(theArray);
  CFRelease(v30);
  return v19;
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  void v14[2] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    -[__CFString deleteCharactersInRange:](theString, "deleteCharactersInRange:", location, length);
  }
  else
  {
    char v5 = atomic_load((unint64_t *)&theString->info);
    if (v5)
    {
      v14[0] = location;
      v14[1] = length;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v14, 1, 0, 0);
    }
    else
    {
      char v6 = _CFOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        CFStringDelete_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
  }
}

void _CFAppendPathComponent2(__CFString *a1, const __CFString *a2)
{
  _CFAppendTrailingPathSlash2(a1);

  CFStringAppend(a1, a2);
}

void _CFAppendTrailingPathSlash2(__CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length)
  {
    if (Length == 2)
    {
      if (_hasDrive(a1) || _hasNet(a1)) {
        return;
      }
    }
    else if (Length == 1 && CFStringGetCharacterAtIndex(a1, 0) == 47)
    {
      return;
    }
    CFStringAppendCharacters(a1, &_CFAppendTrailingPathSlash2_slash, 1);
  }
}

void _CFBundleReadDirectory(const __CFString *a1, const __CFArray *a2, char a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, void *a10)
{
  CFArrayRef v15 = a2;
  CFIndex v16 = a10;
  values[2] = *(void **)off_1ECE0A5B0;
  int v26 = a2;
  uint64_t ProductNameSuffix = _CFBundleGetProductNameSuffix();
  PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
  if (v16) {
    BOOL v19 = v15 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19)
  {
    if (v16)
    {
      CFArrayRef v15 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&a10, 1, &kCFTypeArrayCallBacks);
      CFIndex v16 = a10;
    }
    else
    {
      if (v15) {
        CFArrayRef v15 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&v26, 1, &kCFTypeArrayCallBacks);
      }
      CFIndex v16 = 0;
    }
  }
  else
  {
    values[0] = v16;
    values[1] = v15;
    CFArrayRef v15 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
  }
  v22[0] = off_1ECE0A5A0;
  v22[1] = 0x40000000;
  void v22[2] = ___CFBundleReadDirectory_block_invoke;
  v22[3] = &__block_descriptor_tmp_75;
  char v23 = a3;
  v22[4] = ProductNameSuffix;
  v22[5] = PlatformNameSuffix;
  char v24 = a5;
  v22[6] = a4;
  v22[7] = a6;
  _OWORD v22[8] = a7;
  v22[9] = a8;
  char v25 = a9;
  v22[10] = v16;
  _CFIterateDirectory(a1, 1, v15, (uint64_t)v22);
  if (v15) {
    CFRelease(v15);
  }
}

uint64_t _CFBundleGetProductNameSuffix()
{
  if (_CFBundleGetProductNameSuffix_onceToken != -1) {
    dispatch_once(&_CFBundleGetProductNameSuffix_onceToken, &__block_literal_global_4_0);
  }
  return _CFBundleGetProductNameSuffix__cfBundlePlatformSuffix;
}

__CFString *_CFBundleGetPlatformNameSuffix()
{
  return @"-iphoneos";
}

CFDictionaryRef CFBundleGetLocalInfoDictionary(CFBundleRef bundle)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  os_unfair_lock_lock_with_options();
  ValueWithKeyPath = (void *)*((void *)bundle + 4);
  if (!ValueWithKeyPath)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
    uint64_t v18 = 0;
    long long v16 = 0u;
    *(_OWORD *)theCFDataRef Data = 0u;
    *(_OWORD *)CFIndex v14 = 0u;
    *(_OWORD *)data = 0u;
    _CFBundleGetStringsSources((uint64_t)bundle, 1, @"InfoPlist", 0, (uint64_t)v14);
    if (data[0])
    {
      ValueWithKeyPath = (void *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, data[0], 1uLL, 0, 0);
      if (!ValueWithKeyPath) {
        goto LABEL_20;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(ValueWithKeyPath))
      {
        CFMutableDictionaryRef v6 = 0;
LABEL_19:
        CFRelease(ValueWithKeyPath);
        ValueWithKeyPath = v6;
LABEL_20:
        long long v11 = v16;
        long long v12 = *(_OWORD *)theData;
        uint64_t v13 = v18;
        *(_OWORD *)CFMutableDictionaryRef cf = *(_OWORD *)v14;
        long long v10 = *(_OWORD *)data;
        _CFBundleReleaseStringsSources_0((uint64_t)cf);
        os_unfair_lock_lock_with_options();
        if (*((void *)bundle + 4))
        {
          if (ValueWithKeyPath) {
            CFRelease(ValueWithKeyPath);
          }
          ValueWithKeyPath = (void *)*((void *)bundle + 4);
        }
        else
        {
          *((void *)bundle + 4) = ValueWithKeyPath;
        }
        goto LABEL_3;
      }
    }
    else
    {
      ValueWithKeyPath = 0;
      if (!theData[1] || !v14[1]) {
        goto LABEL_20;
      }
      CFSetRef v7 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, &v14[1], 1, &kCFTypeSetCallBacks);
      cf[0] = 0;
      ValueWithKeyPath = 0;
      if (_CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, theData[1], 1, v7, cf, 0))
      {
        ValueWithKeyPath = (void *)_CFPropertyListGetValueWithKeyPath(cf[0], (const __CFString *)v14[1]);
        if (ValueWithKeyPath)
        {
          CFTypeID v8 = CFDictionaryGetTypeID();
          if (v8 == CFGetTypeID(ValueWithKeyPath)) {
            CFRetain(ValueWithKeyPath);
          }
          else {
            ValueWithKeyPath = 0;
          }
        }
      }
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      CFRelease(v7);
      if (!ValueWithKeyPath) {
        goto LABEL_20;
      }
    }
    _CFBundleInfoPlistProcessInfoDictionary(ValueWithKeyPath);
    CFMutableDictionaryRef v6 = _parseBundleStrings((uint64_t)bundle, (CFDictionaryRef)ValueWithKeyPath);
    if (!v6) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
LABEL_3:
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
  return (CFDictionaryRef)ValueWithKeyPath;
}

void _CFBundleReleaseStringsSources(uint64_t a1)
{
  unint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  char v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  CFMutableDictionaryRef v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  CFSetRef v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  CFTypeID v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 56);
  if (v9)
  {
    CFRelease(v9);
  }
}

__n128 _CFBundleGetStringsSources@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFArray *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v107 = *(void *)off_1ECE0A5B0;
  long long v10 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  *(void *)(a5 + 64) = 0;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  int v11 = 1;
  *(unsigned char *)(a5 + 67) = 1;
  CFDictionaryRef v12 = *(const __CFDictionary **)(a1 + 168);
  if (v12)
  {
    CFStringRef Value = CFDictionaryGetValue(v12, a3);
    if (Value)
    {
      *(_OWORD *)a5 = *Value;
      long long v14 = Value[1];
      long long v15 = Value[2];
      long long v16 = Value[3];
      *(void *)(a5 + 64) = *((void *)Value + 8);
      *(_OWORD *)(a5 + 32) = v15;
      *(_OWORD *)(a5 + 48) = v16;
      *(_OWORD *)(a5 + 16) = v14;
      *(_OWORD *)&v103[16] = Value[1];
      long long v104 = Value[2];
      long long v105 = Value[3];
      uint64_t v106 = *((void *)Value + 8);
      *(_OWORD *)unint64_t v103 = *Value;
      _CFBundleRetainStringsSources((uint64_t)v103);
      int v11 = 0;
    }
  }
  os_unfair_lock_unlock(v10);
  if (a4) {
    BOOL v17 = 0;
  }
  else {
    BOOL v17 = *(unsigned char *)(a1 + 54) == 0;
  }
  uint64_t v18 = v17;
  if (!*(void *)(a5 + 56))
  {
    if (v11)
    {
      CFURLRef v19 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, @"loctable", 0);
    }
    else
    {
      char v20 = *(const void **)(a5 + 48);
      if (!v20) {
        goto LABEL_27;
      }
      CFURLRef v19 = (const __CFURL *)CFRetain(v20);
    }
    CFURLRef v21 = v19;
    if (v19)
    {
      if (v18 | a2) {
        int v22 = v11;
      }
      else {
        int v22 = 0;
      }
      LOBYTE(v99) = 0;
      CFTypeRef cf = 0;
      MappedOrLoadedPlistCFDataRef Data = _CFBundleCreateMappedOrLoadedPlistData(v19, v22, v18, (BOOL *)&v99, (CFErrorRef *)&cf);
      *(void *)(a5 + 56) = MappedOrLoadedPlistData;
      if (MappedOrLoadedPlistData)
      {
        *(unsigned char *)(a5 + 66) = (_BYTE)v99;
      }
      else
      {
        UnlocalizedDebugDescriptiouint64_t n = (const void *)_CFErrorCreateUnlocalizedDebugDescription(cf);
        char v25 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t v103 = 138412802;
          *(void *)&v103[4] = a1;
          *(_WORD *)&v103[12] = 2112;
          *(void *)&v103[14] = a3;
          *(_WORD *)&v103[22] = 2112;
          *(void *)&v103[24] = UnlocalizedDebugDescription;
          _os_log_error_impl(&dword_182B90000, v25, OS_LOG_TYPE_ERROR, "loctable failed to load for bundle: %@, table: %@: %@", v103, 0x20u);
        }
        CFRelease(UnlocalizedDebugDescription);
        CFRelease(cf);
      }
      int v26 = *(const void **)(a5 + 48);
      if (v26) {
        CFRelease(v26);
      }
      *(void *)(a5 + 48) = v21;
    }
  }
LABEL_27:
  uint64_t v28 = (CFTypeRef *)(a5 + 8);
  unint64_t v27 = *(void *)(a5 + 8);
  if (a4)
  {
    if (v27)
    {
      CFRelease((CFTypeRef)v27);
      CFTypeRef *v28 = 0;
    }
    if (*(void *)a5)
    {
      CFRelease(*(CFTypeRef *)a5);
      *(void *)a5 = 0;
    }
    uint64_t v29 = *(const void **)(a5 + 16);
    if (v29)
    {
      CFRelease(v29);
      *(void *)(a5 + 16) = 0;
    }
    CFMutableDictionaryRef v30 = *(const void **)(a5 + 32);
    if (v30)
    {
      CFRelease(v30);
      *(void *)(a5 + 32) = 0;
    }
    CFIndex v92 = (CFTypeRef *)(a5 + 8);
    unsigned int v31 = *(const void **)(a5 + 24);
    if (v31)
    {
      CFRelease(v31);
      *(void *)(a5 + 24) = 0;
    }
    uint64_t v94 = (CFTypeRef *)(a5 + 24);
    CFArrayRef theArray = (CFTypeRef *)(a5 + 32);
    unsigned int v89 = a2;
    CFRange v32 = *(const void **)(a5 + 40);
    if (v32)
    {
      CFRelease(v32);
      *(void *)(a5 + 40) = 0;
    }
    if (CFArrayGetCount(a4) >= 1)
    {
      CFIndex v33 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a4, v33);
        CFURLRef v35 = CFBundleCopyResourceURLForLocalization((CFBundleRef)a1, a3, @"strings", 0, ValueAtIndex);
        CFURLRef v36 = CFBundleCopyResourceURLForLocalization((CFBundleRef)a1, a3, @"stringsdict", 0, ValueAtIndex);
        if ((unint64_t)v35 | (unint64_t)v36) {
          break;
        }
        if (++v33 >= CFArrayGetCount(a4)) {
          goto LABEL_51;
        }
      }
      CFURLRef v39 = v36;
      *(void *)a5 = v35;
      *(void *)(a5 + 8) = CFRetain(ValueAtIndex);
      *(void *)(a5 + 24) = v39;
      *(void *)(a5 + 32) = CFRetain(ValueAtIndex);
    }
LABEL_51:
    if (*v92) {
      goto LABEL_142;
    }
    if (*(void *)(a5 + 56))
    {
      if (CFArrayGetCount(a4) >= 2 && CFArrayGetCount(a4) >= 1)
      {
        CFIndex v40 = 0;
        while (1)
        {
          *(void *)unint64_t v103 = 0;
          CFTypeRef cf = 0;
          CFDataRef v41 = *(const __CFData **)(a5 + 56);
          CFStringRef v42 = (const __CFString *)CFArrayGetValueAtIndex(a4, v40);
          _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(v41, v42, v103, &v99, &cf, &v100);
          CFTypeRef v43 = cf;
          if (*(void *)v103 | (unint64_t)cf) {
            break;
          }
          if (++v40 >= CFArrayGetCount(a4)) {
            goto LABEL_140;
          }
        }
        *CFIndex v92 = *(CFTypeRef *)v103;
        *CFArrayRef theArray = v43;
      }
LABEL_140:
      if ((unint64_t)*v92 | (unint64_t)*theArray) {
        goto LABEL_142;
      }
    }
    else if (*theArray)
    {
LABEL_154:
      _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 0, v89);
      long long v79 = *(_OWORD *)(a5 + 48);
      long long v104 = *(_OWORD *)(a5 + 32);
      long long v105 = v79;
      uint64_t v106 = *(void *)(a5 + 64);
      long long v80 = *(_OWORD *)(a5 + 16);
      *(_OWORD *)unint64_t v103 = *(_OWORD *)a5;
      *(_OWORD *)&v103[16] = v80;
      _CFBundleIngestResultForBundleCache(a1, a3, 0, (uint64_t)v103);
      return result;
    }
    int v72 = CFArrayGetValueAtIndex(a4, 0);
    *CFIndex v92 = CFRetain(v72);
    int v73 = CFArrayGetValueAtIndex(a4, 0);
    *CFArrayRef theArray = CFRetain(v73);
LABEL_142:
    CFDataRef v74 = *(const __CFData **)(a5 + 56);
    if (v74)
    {
      CFTypeRef cf = 0;
      int v100 = 0;
      CFTypeRef v99 = 0;
      int v98 = 0;
      if (*(void *)(a5 + 8)) {
        CFStringRef v75 = *(const __CFString **)(a5 + 8);
      }
      else {
        CFStringRef v75 = *(const __CFString **)(a5 + 32);
      }
      _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(v74, v75, &cf, &v100, &v99, &v98);
      int v76 = _useLoctableInsteadOfFileBasedOnVersion((CFTypeRef *)a5, v92, v100, cf);
      int v77 = _useLoctableInsteadOfFileBasedOnVersion(v94, theArray, v98, v99);
      if (!(v76 | v77))
      {
        CFRelease(*(CFTypeRef *)(a5 + 56));
        *(void *)(a5 + 56) = 0;
      }
      if (!v76 && *(void *)a5 || *v94 && !v77)
      {
        uint64_t v78 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
        {
          CFTypeRef v81 = *v92;
          *(_DWORD *)unint64_t v103 = 138412802;
          *(void *)&v103[4] = a1;
          *(_WORD *)&v103[12] = 2112;
          *(void *)&v103[14] = a3;
          *(_WORD *)&v103[22] = 2112;
          *(void *)&v103[24] = v81;
          _os_log_debug_impl(&dword_182B90000, v78, OS_LOG_TYPE_DEBUG, "loctable overridden by installed files. Bundle: %@, table: %@, language: %@", v103, 0x20u);
        }
      }
    }
    goto LABEL_154;
  }
  if (v27 | *(void *)(a5 + 32))
  {
    if (*(unsigned char *)(a5 + 68))
    {
      unsigned int v37 = *(const void **)(a5 + 56);
      if (v37)
      {
        CFRelease(v37);
        *(void *)(a5 + 56) = 0;
      }
    }
    _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 0, a2);
    return result;
  }
  CFURLRef v44 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, @"strings", 0);
  CFURLRef v45 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, @"stringsdict", 0);
  theCFDataRef Data = *(const __CFData **)(a5 + 56);
  if (theData)
  {
    CFArrayRef theArraya = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
    CFIndex Count = CFArrayGetCount(theArraya);
    if (v44)
    {
      CFStringRef v47 = _CFBundleCopyLanguageForStringsResourceURL(v44);
      if (v45)
      {
LABEL_62:
        CFStringRef v48 = _CFBundleCopyLanguageForStringsResourceURL(v45);
LABEL_77:
        unsigned int FileVersionForStringsResourceURL = _CFBundleGetFileVersionForStringsResourceURL(v44);
        unsigned int v84 = _CFBundleGetFileVersionForStringsResourceURL(v45);
        LOBYTE(v98) = 0;
        BOOL v102 = 0;
        _CFBundleGetLocTableProvenanceForLanguage(theData, @"none", &v98, &v102);
        *(void *)uint64_t v95 = Count - 1;
        if (Count < 1) {
          goto LABEL_123;
        }
        CFURLRef v82 = v45;
        CFURLRef v83 = v44;
        unsigned int v90 = a2;
        CFIndex v54 = 0;
        int v86 = 0;
        CFStringRef v55 = v48;
        int v56 = 0;
        CFStringRef v57 = v47;
        int v58 = 0;
        int v59 = v98;
        BOOL v60 = v102;
        CFStringRef cf2 = v55;
        CFStringRef v88 = v57;
        if ((_BYTE)v98) {
          BOOL v61 = v57 == 0;
        }
        else {
          BOOL v61 = 0;
        }
        int v62 = v61;
        int v93 = v62;
        BOOL v64 = v102 && v55 == 0;
        while (1)
        {
          CFStringRef v65 = (const __CFString *)CFArrayGetValueAtIndex(theArraya, v54);
          *(void *)unint64_t v103 = 0;
          LODWORD(v99) = 0;
          CFTypeRef cf = 0;
          int v100 = 0;
          if (v58 | v59 && v56 | v60)
          {
            if (v56) {
              goto LABEL_102;
            }
          }
          else
          {
            _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(theData, v65, v103, &v99, &cf, &v100);
            if (v56) {
              goto LABEL_102;
            }
          }
          if (cf2 && CFEqual(v65, cf2) && v84 >= v100) {
            break;
          }
          if (cf)
          {
            CFTypeRef v66 = CFRetain(cf);
            int v86 = 1;
            goto LABEL_101;
          }
          int v56 = 0;
          if (v58) {
            goto LABEL_103;
          }
LABEL_113:
          if (v88 && CFEqual(v65, v88) && FileVersionForStringsResourceURL >= v99)
          {
            *(void *)a5 = CFRetain(v83);
            CFTypeRef v67 = CFRetain(v65);
          }
          else
          {
            if (!*(void *)v103)
            {
              int v58 = 0;
              goto LABEL_104;
            }
            CFTypeRef v67 = CFRetain(*(CFTypeRef *)v103);
            int v86 = 1;
          }
          *(void *)(a5 + 8) = v67;
          if ((v56 & 1) == 0) {
            *(unsigned char *)(a5 + 67) = 0;
          }
LABEL_103:
          int v58 = 1;
LABEL_104:
          if (cf) {
            CFRelease(cf);
          }
          if (*(void *)v103) {
            CFRelease(*(CFTypeRef *)v103);
          }
          if (((v58 | v93) & (v56 | v64) & 1) == 0)
          {
            BOOL v17 = *(void *)v95 == v54++;
            if (!v17) {
              continue;
            }
          }
          a2 = v90;
          CFURLRef v45 = v82;
          CFURLRef v44 = v83;
          CFStringRef v48 = cf2;
          CFStringRef v47 = v88;
          if (!v86)
          {
LABEL_123:
            int v68 = _CFBundleLocalizedStringLogger();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG)) {
              _CFBundleGetStringsSources_cold_1();
            }
            *(unsigned char *)(a5 + 68) = 1;
          }
          if (v47) {
            CFRelease(v47);
          }
          if (v48) {
            CFRelease(v48);
          }
          CFArrayRef v53 = theArraya;
LABEL_131:
          CFRelease(v53);
          goto LABEL_132;
        }
        *(void *)(a5 + 24) = CFRetain(v82);
        CFTypeRef v66 = CFRetain(v65);
LABEL_101:
        *(void *)(a5 + 32) = v66;
LABEL_102:
        int v56 = 1;
        if (v58) {
          goto LABEL_103;
        }
        goto LABEL_113;
      }
    }
    else
    {
      CFStringRef v47 = 0;
      if (v45) {
        goto LABEL_62;
      }
    }
    CFStringRef v48 = 0;
    goto LABEL_77;
  }
  if (v44)
  {
    *(void *)a5 = CFRetain(v44);
    *(void *)(a5 + 8) = _CFBundleCopyLanguageForStringsResourceURL(v44);
  }
  if (v45)
  {
    *(void *)(a5 + 24) = CFRetain(v45);
    *(void *)(a5 + 32) = _CFBundleCopyLanguageForStringsResourceURL(v45);
  }
  if (*v28)
  {
    BOOL v49 = *(const void **)(a5 + 32);
    if (v49)
    {
      if (!CFEqual(*v28, v49))
      {
        CFArrayRef v50 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
        CFIndex v51 = CFArrayGetCount(v50);
        v108.CFIndex location = 0;
        v108.CFIndex length = v51;
        FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v50, v108, *(const void **)(a5 + 8));
        v109.CFIndex location = 0;
        v109.CFIndex length = v51;
        if (FirstIndexOfValue < CFArrayGetFirstIndexOfValue(v50, v109, *(const void **)(a5 + 32))) {
          *(unsigned char *)(a5 + 67) = 0;
        }
        CFArrayRef v53 = v50;
        goto LABEL_131;
      }
    }
  }
LABEL_132:
  if (v44) {
    CFRelease(v44);
  }
  if (v45) {
    CFRelease(v45);
  }
  _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 1, a2);
  long long v69 = *(_OWORD *)(a5 + 48);
  long long v104 = *(_OWORD *)(a5 + 32);
  long long v105 = v69;
  uint64_t v106 = *(void *)(a5 + 64);
  long long v70 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)unint64_t v103 = *(_OWORD *)a5;
  *(_OWORD *)&v103[16] = v70;
  _CFBundleIngestResultForBundleCache(a1, a3, 1, (uint64_t)v103);
  if (*(unsigned char *)(a5 + 68))
  {
    CFAllocatorRef v71 = *(const void **)(a5 + 56);
    if (v71)
    {
      CFRelease(v71);
      *(void *)(a5 + 56) = 0;
    }
  }
  return result;
}

void _CFBundleLoadNonLocTableData(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (*(unsigned char *)(a1 + 54)) {
    a4 = 0;
  }
  CFTypeRef cf = 0;
  if (!*(void *)(a3 + 16))
  {
    if (*(void *)a3)
    {
      MappedOrLoadedPlistCFDataRef Data = _CFBundleCreateMappedOrLoadedPlistData(*(const __CFURL **)a3, a4, a5, (BOOL *)(a3 + 64), (CFErrorRef *)&cf);
      *(void *)(a3 + 16) = MappedOrLoadedPlistData;
      if (!MappedOrLoadedPlistData)
      {
        int v11 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412802;
          uint64_t v17 = a1;
          __int16 v18 = 2112;
          uint64_t v19 = a2;
          __int16 v20 = 2112;
          CFTypeRef v21 = cf;
          _os_log_error_impl(&dword_182B90000, v11, OS_LOG_TYPE_ERROR, "Unable to load .strings file: %@ / %@: %@", buf, 0x20u);
        }
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0;
      }
    }
  }
  if (!*(void *)(a3 + 40))
  {
    CFURLRef v12 = *(const __CFURL **)(a3 + 24);
    if (v12)
    {
      CFDataRef v13 = _CFBundleCreateMappedOrLoadedPlistData(v12, a4, a5, (BOOL *)(a3 + 65), (CFErrorRef *)&cf);
      *(void *)(a3 + 40) = v13;
      if (!v13)
      {
        long long v14 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412802;
          uint64_t v17 = a1;
          __int16 v18 = 2112;
          uint64_t v19 = a2;
          __int16 v20 = 2112;
          CFTypeRef v21 = cf;
          _os_log_error_impl(&dword_182B90000, v14, OS_LOG_TYPE_ERROR, "Unable to load .stringsdict file: %@ / %@: %@", buf, 0x20u);
        }
        if (cf) {
          CFRelease(cf);
        }
      }
    }
  }
}

CFTypeRef _CFBundleRetainStringsSources(uint64_t a1)
{
  unint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRetain(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRetain(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRetain(v4);
  }
  char v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRetain(v5);
  }
  CFMutableDictionaryRef v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRetain(v6);
  }
  CFSetRef v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRetain(v7);
  }
  CFTypeID v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRetain(v8);
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 56);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

CFStringRef CFDateFormatterCreateDateFormatFromTemplate(CFAllocatorRef allocator, CFStringRef tmplate, CFOptionFlags options, CFLocaleRef locale)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v9 = CFGetTypeID(tmplate);
  CFMutableArrayRef Mutable = 0;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  CFMutableArrayRef v21 = 0;
  BOOL v11 = TypeID == v9;
  if (!v11) {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
  }
  CFMutableArrayRef v21 = Mutable;
  v16[0] = off_1ECE0A5A0;
  v16[1] = 3221225472;
  void v16[2] = __CFDateFormatterCreateDateFormatFromTemplate_block_invoke;
  v16[3] = &unk_1ECDABC60;
  BOOL v17 = v11;
  v16[6] = locale;
  v16[7] = options;
  v16[8] = allocator;
  v16[4] = &v18;
  v16[5] = tmplate;
  int v12 = useTemplatePatternGenerator(locale, (uint64_t)v16);
  CFDataRef v13 = v19;
  CFStringRef v14 = (const __CFString *)v19[3];
  if (!v12)
  {
    if (v14)
    {
      CFRelease((CFTypeRef)v19[3]);
      CFDataRef v13 = v19;
    }
    CFStringRef v14 = 0;
    v13[3] = 0;
  }
  _Block_object_dispose(&v18, 8);
  return v14;
}

void sub_182C288E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
}

__CFArray *_CFBundleCopyLocalizationsForPreferences(const __CFArray *a1, const __CFArray *a2, int a3)
{
  if (!a1 || CFArrayGetCount(a1) < 1) {
    goto LABEL_10;
  }
  CFMutableArrayRef Mutable = _CFBundleCopyPreferredLanguagesInList(a1, 0, a2, a3, 0, 0);
  if (CFArrayGetCount(Mutable) || CFArrayGetCount(a1) < 1)
  {
    if (CFArrayGetCount(Mutable)) {
      goto LABEL_9;
    }
    CFStringRef ValueAtIndex = @"en";
  }
  else
  {
    CFStringRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a1, 0);
  }
  CFArrayAppendValue(Mutable, ValueAtIndex);
LABEL_9:
  if (!Mutable)
  {
LABEL_10:
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(Mutable, @"en");
  }
  return Mutable;
}

__CFArray *_CFBundleCopyPreferredLanguagesInList(const __CFArray *a1, void *a2, CFArrayRef theArray, int a4, unint64_t a5, __CFBundle *a6)
{
  uint64_t v48 = *(void *)off_1ECE0A5B0;
  values = a2;
  if (!a4) {
    goto LABEL_5;
  }
  if (CFBundleAllowMixedLocalizations_once != -1) {
    dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
  }
  if (CFBundleAllowMixedLocalizations_allowMixed)
  {
LABEL_5:
    CFArrayRef v11 = 0;
    goto LABEL_6;
  }
  if (CFBundleFollowParentLocalization_once != -1) {
    dispatch_once(&CFBundleFollowParentLocalization_once, &__block_literal_global_142);
  }
  if (CFBundleFollowParentLocalization_followParent == 1)
  {
    CFArrayRef v11 = (const __CFArray *)_CFBundleCopyXPCBootstrapMainBundleLanguages();
    if (!v11) {
      goto LABEL_6;
    }
LABEL_28:
    if (CFArrayGetCount(v11) >= 1)
    {
      MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v11);
      if (MutableArrayOfFallbackLanguages) {
        goto LABEL_30;
      }
    }
    goto LABEL_6;
  }
  MainBundle = CFBundleGetMainBundle();
  CFArrayRef v11 = MainBundle;
  if (!MainBundle) {
    goto LABEL_6;
  }
  CFURLRef v16 = CFBundleCopyBundleURL(MainBundle);
  if (!v16) {
    goto LABEL_5;
  }
  CFURLRef v17 = v16;
  if (a5 && CFEqual((CFTypeRef)a5, v16)) {
    CFArrayRef v11 = 0;
  }
  else {
    CFArrayRef v11 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(v11);
  }
  CFRelease(v17);
  if (v11) {
    goto LABEL_28;
  }
LABEL_6:
  if (!theArray || CFArrayGetCount(theArray) < 1)
  {
    MutableArrayOfFallbackLanguages = 0;
LABEL_11:
    if (a2)
    {
      CFArrayRef v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v13);
      CFRelease(v13);
    }
    goto LABEL_13;
  }
  MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)theArray);
  if (!MutableArrayOfFallbackLanguages) {
    goto LABEL_11;
  }
LABEL_13:
  if (!MutableArrayOfFallbackLanguages)
  {
    *(void *)buf = @"en_US";
    CFArrayRef v14 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v14);
    CFRelease(v14);
    if (!MutableArrayOfFallbackLanguages) {
      MutableArrayOfFallbackLanguages = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    }
  }
LABEL_30:
  uint64_t v18 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG) && a5 | (unint64_t)a6)
  {
    CFMutableDictionaryRef v30 = values;
    unint64_t v31 = a5;
    CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    uint64_t v20 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    CFMutableArrayRef v21 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    uint64_t v22 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    char v23 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    if (a6) {
      CFStringAppendFormat(Mutable, 0, @"%@", a6);
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"%@", v31);
    }
    _onelineFormatArray(v20, a1);
    _onelineFormatArray(v21, theArray);
    _onelineFormatArray(v22, v11);
    _onelineFormatArray(v23, MutableArrayOfFallbackLanguages);
    if (CFBundleAllowMixedLocalizations_once != -1) {
      dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
    }
    BOOL v24 = CFBundleAllowMixedLocalizations_allowMixed != 0;
    BOOL v26 = a6
       && (CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(a6)) != 0
       && CFDictionaryGetValue(InfoDictionary, @"_CFBundleUseAppleLocalizations") == &__kCFBooleanTrue;
    unint64_t v27 = _CFBundleResourceLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v29 = "";
      *(_DWORD *)buf = 138479619;
      *(void *)&uint8_t buf[4] = Mutable;
      __int16 v34 = 2114;
      if (v26) {
        uint64_t v29 = "(use Apple Locs)";
      }
      CFURLRef v35 = v20;
      __int16 v36 = 2114;
      unsigned int v37 = v30;
      __int16 v38 = 2114;
      CFURLRef v39 = v21;
      __int16 v40 = 2114;
      CFDataRef v41 = v22;
      __int16 v42 = 2050;
      BOOL v43 = v24;
      __int16 v44 = 2082;
      CFURLRef v45 = v29;
      __int16 v46 = 2114;
      CFStringRef v47 = v23;
      _os_log_debug_impl(&dword_182B90000, v27, OS_LOG_TYPE_DEBUG, "Language lookup at %{private}@\n\tLocalizations : %{public}@\n\tDev language  : %{public}@\n\tUser prefs    : %{public}@\n\tMain bundle   : %{public}@\n\tAllow mixed   : %{public}lu %{public}s\n\tResult        : %{public}@\n", buf, 0x52u);
    }
    CFRelease(Mutable);
    CFRelease(v20);
    CFRelease(v21);
    CFRelease(v23);
    CFRelease(v22);
  }
  if (v11) {
    CFRelease(v11);
  }
  return MutableArrayOfFallbackLanguages;
}

__CFArray *_CFBundleCreateMutableArrayOfFallbackLanguages(uint64_t a1, uint64_t a2)
{
  CFArrayRef v2 = (const __CFArray *)MEMORY[0x1F4188790](a1, a2);
  CFArrayRef v4 = v3;
  CFArrayRef v5 = v2;
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  CFIndex Count = CFArrayGetCount(v2);
  CFSetRef v7 = malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  CFTypeID v8 = ___CFBundleCreateMutableArrayOfFallbackLanguages_block_invoke((int)v7, v5, (uint64_t)v7);
  CFIndex v9 = CFArrayGetCount(v4);
  long long v10 = malloc_type_malloc(8 * v9, 0x10040436913F5uLL);
  CFArrayRef v11 = ___CFBundleCreateMutableArrayOfFallbackLanguages_block_invoke((int)v10, v4, (uint64_t)v10);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  if (v8)
  {
    if (v11)
    {
      memset(v19, 0, 512);
      int v13 = ualoc_localizationsToUse();
      if (v13 >= 1)
      {
        uint64_t v14 = v13;
        long long v15 = (const char **)v19;
        do
        {
          CFStringRef v16 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, *v15, 0x8000100u);
          if (v16)
          {
            CFStringRef v17 = v16;
            CFArrayAppendValue(Mutable, v16);
            CFRelease(v17);
          }
          ++v15;
          --v14;
        }
        while (v14);
      }
    }
  }
  if (v7) {
    free(v7);
  }
  if (v8) {
    free(v8);
  }
  if (v10) {
    free(v10);
  }
  if (v11) {
    free(v11);
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFTypeID CFStringGetTypeID(void)
{
  return 7;
}

CFURLRef CFBundleCopyResourceURL(CFURLRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  if (bundle) {
    return _CFBundleCopyFindResources((uint64_t)bundle, 0, (uint64_t)resourceType, resourceName, resourceType, subDirName, 0, 0, 0, 0);
  }
  return bundle;
}

CFMutableArrayRef _CFBundleCopyFindResources(uint64_t a1, const __CFURL *a2, uint64_t a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, int a8, char a9, uint64_t a10)
{
  uint64_t v15 = a1;
  uint64_t v114 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    __CFCheckCFInfoPACSignature(a1);
    unint64_t v16 = _CFGetNonObjCTypeID((unint64_t *)v15);
    if (v16 != 31) {
      _CFAssertMismatchedTypeID(0x1FuLL, v16);
    }
  }
  int v17 = dyld_program_sdk_at_least();
  int v105 = a8;
  if (!a6 || !v17)
  {
LABEL_16:
    if (!a4)
    {
LABEL_24:
      CFStringRef Copy = 0;
      CFStringRef v29 = 0;
      goto LABEL_42;
    }
LABEL_17:
    uint64_t range = -1;
    CFStringRef Copy = _CFCreateLastPathComponent((const __CFAllocator *)&__kCFAllocatorSystemDefault, a4, &range);
    v28.CFIndex length = range;
    if (range < 1)
    {
      CFStringRef v29 = 0;
    }
    else
    {
      v28.CFIndex location = 0;
      CFStringRef v29 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, v28);
      if (range >= 1 && !CFStringGetLength(Copy))
      {
        CFURLRef v96 = a2;
        CFStringRef v30 = v29;
        uint64_t v31 = range;
        if (v31 == CFStringGetLength(a4) - 1)
        {
          CFRelease(Copy);
          CFStringRef v29 = v30;
          CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v30);
        }
        else
        {
          CFStringRef v29 = v30;
        }
        a2 = v96;
      }
    }
    if (CFStringGetFileSystemRepresentation(Copy, buffer, 1026))
    {
      CFRelease(Copy);
      CFStringRef Copy = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
    }
    if (Copy)
    {
      CFIndex Length = CFStringGetLength(Copy);
      if (a5 && Length >= 1 && CFStringGetLength(a5) >= 1)
      {
        MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, Copy);
        if (CFStringGetCharacterAtIndex(a5, 0) != 46) {
          CFStringAppendCharacters(MutableCopy, _CFBundleCopyFindResources_extensionSep, 1);
        }
        CFStringAppend(MutableCopy, a5);
      }
      else
      {
        if (CFStringGetLength(Copy) < 1)
        {
          char v102 = 0;
          if (!a5) {
            goto LABEL_51;
          }
LABEL_43:
          if (CFStringGetLength(a5) >= 1)
          {
            MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"_CFBT_");
            if (CFStringGetCharacterAtIndex(a5, 0) != 46) {
              CFStringAppendCharacters(MutableCopy, _CFBundleCopyFindResources_extensionSep, 1);
            }
            CFStringAppend(MutableCopy, a5);
LABEL_52:
            long long v104 = MutableCopy;
            if (a6)
            {
              BOOL v36 = CFStringGetLength(a6) != 0;
              if (v29)
              {
LABEL_54:
                BOOL v37 = CFStringGetLength(v29) != 0;
LABEL_57:
                int v38 = !v36;
                if (!v36 || v37)
                {
                  int v40 = !v37;
                  if ((v36 | v40))
                  {
                    CFStringRef v41 = v104;
                    if ((v38 | v40))
                    {
                      __int16 v42 = 0;
                    }
                    else
                    {
                      __int16 v42 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a6);
                      _CFAppendPathComponent2(v42, v29);
                    }
                    goto LABEL_65;
                  }
                  CFStringRef v39 = v29;
                }
                else
                {
                  CFStringRef v39 = a6;
                }
                __int16 v42 = (__CFString *)CFRetain(v39);
                CFStringRef v41 = v104;
LABEL_65:
                LOBYTE(range) = 0;
                if (v15) {
                  int v43 = _CFBundleLayoutVersion(v15);
                }
                else {
                  int v43 = 0;
                }
                LOBYTE(range) = v43;
                if (a2)
                {
                  __int16 v44 = _CFBundleCopyLanguageSearchListInDirectory(a2, (unsigned __int8 *)&range);
                  int v43 = range;
                }
                else
                {
                  __int16 v44 = 0;
                }
                if (v43 <= 1)
                {
                  if (!v43)
                  {
                    CFStringRef v45 = @"Resources";
                    goto LABEL_83;
                  }
                  if (v43 == 1)
                  {
                    CFStringRef v45 = @"Support Files/Resources";
                    goto LABEL_83;
                  }
                }
                else
                {
                  switch(v43)
                  {
                    case 13:
                      CFStringRef v45 = @"WrappedBundle";
                      goto LABEL_83;
                    case 12:
                      CFStringRef v45 = @"WrappedBundle/Contents/Resources";
                      goto LABEL_83;
                    case 2:
                      CFStringRef v45 = @"Contents/Resources";
                      goto LABEL_83;
                  }
                }
                CFStringRef v45 = &stru_1ECE10768;
LABEL_83:
                CFTypeRef cf = v44;
                CFStringRef v97 = v45;
                __int16 v46 = _copyResourceURLsFromBundle(v15, a2, v44, v45, v42, v41, a7, v105, a9, v43, a10);
                CFIndex v33 = v46;
                if (v46)
                {
                  CFStringRef v47 = Copy;
                  CFURLRef v48 = a2;
                  CFStringRef v49 = v29;
                  CFStringRef v50 = a4;
                  CFTypeID v51 = CFGetTypeID(v46);
                  if (v51 != CFArrayGetTypeID())
                  {
                    a4 = v50;
                    CFStringRef v29 = v49;
                    a2 = v48;
                    CFStringRef Copy = v47;
                    goto LABEL_90;
                  }
                  a4 = v50;
                  CFStringRef v29 = v49;
                  a2 = v48;
                  CFStringRef Copy = v47;
                  if (CFArrayGetCount(v33)) {
                    goto LABEL_90;
                  }
                }
                if ((range & 0xFD) == 0)
                {
                  if (v15)
                  {
                    CFAllocatorRef allocator = *(CFAllocatorRef *)(v15 + 192);
                    CFRetain(allocator);
                  }
                  else
                  {
                    CFURLRef v62 = CFURLCopyAbsoluteURL(a2);
                    CFStringRef v63 = a5;
                    CFStringRef v64 = Copy;
                    CFURLRef v65 = a2;
                    CFStringRef v66 = v29;
                    CFStringRef v67 = a4;
                    CFURLRef v68 = v62;
                    CFAllocatorRef allocator = (CFAllocatorRef)CFURLCopyFileSystemPath(v62, kCFURLPOSIXPathStyle);
                    CFURLRef v69 = v68;
                    a4 = v67;
                    CFStringRef v29 = v66;
                    a2 = v65;
                    CFStringRef Copy = v64;
                    a5 = v63;
                    CFRelease(v69);
                  }
                  if ((_BYTE)range && !CFEqual(@"/Library/Spotlight", allocator))
                  {
LABEL_176:
                    CFRelease(allocator);
                    if (!v15) {
                      goto LABEL_122;
                    }
                    goto LABEL_91;
                  }
                  if (v33) {
                    CFRelease(v33);
                  }
                  int v70 = range;
                  if ((_BYTE)range)
                  {
                    CFStringRef v71 = v104;
                  }
                  else
                  {
                    CFStringRef v71 = v104;
                    if (v42)
                    {
                      if (CFEqual(v42, @"Resources"))
                      {
LABEL_159:
                        CFStringRef v82 = &stru_1ECE10768;
                        goto LABEL_172;
                      }
                      int v70 = range;
                    }
                  }
                  CFArrayRef v81 = cf;
                  if (v70 == 2 && v42)
                  {
                    if (CFEqual(v42, @"Contents/Resources")) {
                      goto LABEL_159;
                    }
                    int v70 = range;
                    CFArrayRef v81 = cf;
                  }
                  if (!v70
                    && v42
                    && (v83 = CFStringGetLength(v42), CFArrayRef v81 = cf, v83 >= 11)
                    && (HasPrefix = CFStringHasPrefix(v42, @"Resources/"), CFArrayRef v81 = cf, HasPrefix))
                  {
                    CFStringRef v93 = v29;
                    CFStringRef v100 = a4;
                    uint64_t v85 = -10;
                    CFIndex v86 = 10;
                  }
                  else
                  {
                    if (range != 2 || !v42)
                    {
                      CFStringRef v87 = &stru_1ECE10768;
                      goto LABEL_175;
                    }
                    if (CFStringGetLength(v42) < 20 || !CFStringHasPrefix(v42, @"Contents/Resources/"))
                    {
                      CFStringRef v87 = &stru_1ECE10768;
                      CFArrayRef v81 = cf;
                      goto LABEL_175;
                    }
                    CFStringRef v93 = v29;
                    CFStringRef v100 = a4;
                    uint64_t v85 = -19;
                    CFIndex v86 = 19;
                  }
                  v117.CFIndex length = CFStringGetLength(v42) + v85;
                  v117.CFIndex location = v86;
                  CFStringRef v82 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v42, v117);
                  a4 = v100;
                  CFStringRef v29 = v93;
LABEL_172:
                  CFRelease(v42);
                  __int16 v42 = (__CFString *)v82;
                  CFArrayRef v81 = cf;
                  CFStringRef v71 = v104;
                  CFStringRef v87 = v97;
LABEL_175:
                  CFIndex v33 = _copyResourceURLsFromBundle(v15, a2, v81, v87, v42, v71, a7, v105, a9, range, a10);
                  goto LABEL_176;
                }
LABEL_90:
                if (!v15)
                {
LABEL_122:
                  if ((v102 & 1) == 0) {
                    CFRelease(Copy);
                  }
                  if (v42) {
                    CFRelease(v42);
                  }
                  if (v29) {
                    CFRelease(v29);
                  }
                  if (cf) {
                    CFRelease(cf);
                  }
                  CFRelease(v104);
                  int v72 = _CFBundleResourceLogger();
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
                  {
                    CFURLRef v73 = a2;
                    CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                    CFStringRef v75 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                    int v76 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                    if (v15)
                    {
                      CFStringAppendFormat(Mutable, 0, @"%@", v15);
                    }
                    else if (v73)
                    {
                      CFStringAppendFormat(Mutable, 0, @"CFURL %@", v73);
                    }
                    if (a4) {
                      CFStringAppend(v75, a4);
                    }
                    if (a5) {
                      CFStringAppendFormat(v75, 0, @" type: %@", a5);
                    }
                    if (a6) {
                      CFStringAppendFormat(v75, 0, @" path: %@", a6);
                    }
                    if (a7) {
                      CFStringAppendFormat(v75, 0, @" localization: %@", a7);
                    }
                    if (v33)
                    {
                      CFTypeID v77 = CFGetTypeID(v33);
                      if (v77 == CFArrayGetTypeID())
                      {
                        if (CFArrayGetCount(v33) >= 1)
                        {
                          CFIndex v78 = 0;
                          do
                          {
                            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v33, v78);
                            CFStringAppendFormat(v76, 0, @"%@, ", ValueAtIndex);
                            ++v78;
                          }
                          while (v78 < CFArrayGetCount(v33));
                        }
                      }
                      else
                      {
                        CFStringAppendFormat(v76, 0, @"%@", v33);
                      }
                    }
                    else
                    {
                      CFStringAppendFormat(v76, 0, @"None", v88);
                    }
                    long long v80 = _CFBundleResourceLogger();
                    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)uint64_t buffer = 138478339;
                      CFRange v109 = Mutable;
                      __int16 v110 = 2114;
                      long long v111 = v75;
                      __int16 v112 = 2114;
                      uint64_t v113 = v76;
                      _os_log_debug_impl(&dword_182B90000, v80, OS_LOG_TYPE_DEBUG, "Resource lookup at %{private}@\n\tRequest       : %{public}@\n\tResult        : %{public}@\n", (uint8_t *)buffer, 0x20u);
                    }
                    CFRelease(Mutable);
                    CFRelease(v75);
                    CFRelease(v76);
                  }
                  return v33;
                }
LABEL_91:
                int v52 = (os_unfair_lock_s *)(v15 + 200);
                os_unfair_lock_lock((os_unfair_lock_t)(v15 + 200));
                CFDictionaryRef v53 = *(const __CFDictionary **)(v15 + 208);
                if (!v53 || !v105 && v33) {
                  goto LABEL_121;
                }
                CFStringRef v89 = Copy;
                CFStringRef v92 = v29;
                CFStringRef v54 = a5;
                CFIndex Count = CFDictionaryGetCount(v53);
                int v56 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
                CFStringRef v57 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
                uint64_t v91 = v56;
                CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v15 + 208), v56, v57);
                unsigned int v90 = v57;
                if (Count < 1)
                {
                  int v58 = v33;
                  a5 = v54;
                  CFStringRef v29 = v92;
                }
                else
                {
                  CFURLRef v98 = a2;
                  int v58 = 0;
                  do
                  {
                    LOBYTE(v88) = a9;
                    CFStringRef v59 = a7;
                    uint64_t Resources = _CFBundleCopyFindResources(*v57, 0);
                    if (Resources)
                    {
                      CFArrayRef v61 = (const __CFArray *)Resources;
                      if (!v105) {
                        goto LABEL_103;
                      }
                      if (!v58) {
                        int v58 = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v33);
                      }
                      v116.CFIndex length = CFArrayGetCount(v61);
                      v116.CFIndex location = 0;
                      CFArrayAppendArray(v58, v61, v116);
                      CFRelease(v61);
                    }
                    ++v57;
                    --Count;
                    a7 = v59;
                  }
                  while (Count);
                  CFArrayRef v61 = v33;
LABEL_103:
                  a5 = v54;
                  CFStringRef v29 = v92;
                  if (v58)
                  {
                    CFStringRef Copy = v89;
                    if (v61) {
                      CFRelease(v61);
                    }
                    a7 = v59;
                    a2 = v98;
                    goto LABEL_120;
                  }
                  int v58 = v61;
                  a7 = v59;
                  a2 = v98;
                }
                CFStringRef Copy = v89;
LABEL_120:
                free(v91);
                free(v90);
                CFIndex v33 = v58;
                int v52 = (os_unfair_lock_s *)(v15 + 200);
LABEL_121:
                os_unfair_lock_unlock(v52);
                goto LABEL_122;
              }
            }
            else
            {
              BOOL v36 = 0;
              if (v29) {
                goto LABEL_54;
              }
            }
            BOOL v37 = 0;
            goto LABEL_57;
          }
LABEL_51:
          MutableCFStringRef Copy = (__CFString *)CFRetain(@"_CFBAF_");
          goto LABEL_52;
        }
        MutableCFStringRef Copy = (__CFString *)CFRetain(Copy);
      }
      char v102 = 0;
      goto LABEL_52;
    }
LABEL_42:
    char v102 = 1;
    if (!a5) {
      goto LABEL_51;
    }
    goto LABEL_43;
  }
  CFStringRef v99 = a4;
  CFStringRef v18 = a5;
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, a6, @"/");
  CFIndex v20 = CFArrayGetCount(ArrayBySeparatingStrings);
  if (v20 < 1)
  {
    CFRelease(ArrayBySeparatingStrings);
    a5 = v18;
    if (!a4) {
      goto LABEL_24;
    }
    goto LABEL_17;
  }
  CFIndex v21 = v20;
  uint64_t v94 = v15;
  CFURLRef v95 = a2;
  CFIndex v22 = 0;
  int v23 = 0;
  do
  {
    CFStringRef v24 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v22);
    CFStringRef v25 = v24;
    if (v22 || CFStringCompare(v24, &stru_1ECE10768, 0))
    {
      if (CFStringCompare(v25, @".", 0))
      {
        if (CFStringCompare(v25, @"..", 0)) {
          ++v23;
        }
        else {
          --v23;
        }
        if (v23 < 0)
        {
          CFRelease(ArrayBySeparatingStrings);
          int v26 = v105;
          goto LABEL_26;
        }
      }
    }
    ++v22;
  }
  while (v21 != v22);
  CFRelease(ArrayBySeparatingStrings);
  a4 = v99;
  a5 = v18;
  uint64_t v15 = v94;
  a2 = v95;
  int v26 = v105;
  if ((v23 & 0x80000000) == 0) {
    goto LABEL_16;
  }
LABEL_26:
  if (!v26) {
    return 0;
  }

  return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
}