void sub_182CDB810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t comparisonUsingOrderingForNumericKeys(void **a1, void **a2)
{
  v2 = *a1;
  if (v2 == *a2) {
    return 0;
  }
  else {
    return objc_msgSend(v2, "compare:");
  }
}

uint64_t __CFURLComponentsEqual(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

id __CFURLComponentsCopyDescription(void *a1)
{
  v1 = (void *)[a1 debugDescription];

  return v1;
}

uint64_t _CFURLComponentsGetTypeID()
{
  return 30;
}

id _CFURLComponentsCreate()
{
  v0 = (void *)+[NSURLComponents _components];

  return v0;
}

id _CFURLComponentsCreateWithURL(uint64_t a1, uint64_t a2, int a3)
{
  v3 = (void *)+[NSURLComponents _componentsWithUrl:a2 resolvingAgainstBaseURL:a3 != 0];

  return v3;
}

id _CFURLComponentsCreateWithString(uint64_t a1, uint64_t a2)
{
  v2 = (void *)+[NSURLComponents _componentsWithString:a2 encodingInvalidCharacters:1];

  return v2;
}

uint64_t _CFURLComponentsCreateWithStringInternal()
{
  return 0;
}

uint64_t _CFURLComponentsCreateCopy(uint64_t a1, void *a2)
{
  return [a2 copy];
}

id _CFURLComponentsCopyURL(void *a1)
{
  v1 = (void *)[a1 URL];

  return v1;
}

id _CFURLComponentsCopyURLRelativeToURL(void *a1, uint64_t a2)
{
  v2 = (void *)[a1 URLRelativeToURL:a2];

  return v2;
}

id _CFURLComponentsCopyString(void *a1)
{
  v1 = (void *)[a1 string];

  return v1;
}

id _CFURLComponentsCopyScheme(void *a1)
{
  v1 = (void *)[a1 scheme];

  return v1;
}

id _CFURLComponentsCopyUser(void *a1)
{
  v1 = (void *)[a1 user];

  return v1;
}

id _CFURLComponentsCopyPassword(void *a1)
{
  v1 = (void *)[a1 password];

  return v1;
}

id _CFURLComponentsCopyHost(void *a1)
{
  v1 = (void *)[a1 host];

  return v1;
}

id _CFURLComponentsCopyPort(void *a1)
{
  v1 = (void *)[a1 port];

  return v1;
}

id _CFURLComponentsCopyPath(void *a1)
{
  v1 = (void *)[a1 path];

  return v1;
}

id _CFURLComponentsCopyQuery(void *a1)
{
  v1 = (void *)[a1 query];

  return v1;
}

id _CFURLComponentsCopyFragment(void *a1)
{
  v1 = (void *)[a1 fragment];

  return v1;
}

uint64_t _CFURLComponentsSetScheme(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC160(void *a1)
{
}

uint64_t _CFURLComponentsSetUser(void *a1, uint64_t a2)
{
  return 1;
}

uint64_t _CFURLComponentsSetPassword(void *a1, uint64_t a2)
{
  return 1;
}

uint64_t _CFURLComponentsSetHost(void *a1, uint64_t a2)
{
  return 1;
}

uint64_t _CFURLComponentsSetPort(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC1F0(void *a1)
{
}

uint64_t _CFURLComponentsSetPath(void *a1, uint64_t a2)
{
  return 1;
}

uint64_t _CFURLComponentsSetQuery(void *a1, uint64_t a2)
{
  return 1;
}

uint64_t _CFURLComponentsSetFragment(void *a1, uint64_t a2)
{
  return 1;
}

id _CFURLComponentsCopyPercentEncodedUser(void *a1)
{
  v1 = (void *)[a1 percentEncodedUser];

  return v1;
}

id _CFURLComponentsCopyPercentEncodedPassword(void *a1)
{
  v1 = (void *)[a1 percentEncodedPassword];

  return v1;
}

id _CFURLComponentsCopyPercentEncodedHost(void *a1)
{
  v1 = (void *)[a1 percentEncodedHost];

  return v1;
}

id _CFURLComponentsCopyPercentEncodedPath(void *a1)
{
  v1 = (void *)[a1 percentEncodedPath];

  return v1;
}

id _CFURLComponentsCopyPercentEncodedQuery(void *a1)
{
  v1 = (void *)[a1 percentEncodedQuery];

  return v1;
}

id _CFURLComponentsCopyPercentEncodedFragment(void *a1)
{
  v1 = (void *)[a1 percentEncodedFragment];

  return v1;
}

uint64_t _CFURLComponentsSchemeIsValid(const __CFString *a1)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  if (!a1) {
    return 1;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = Length - 1;
  if (Length < 1) {
    return 0;
  }
  uint64_t v4 = Length;
  long long v37 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  *(_OWORD *)buffer = 0u;
  theString[0] = a1;
  CFIndex v39 = 0;
  long long v38 = (unint64_t)Length;
  CFStringRef CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(a1);
  theString[1] = CharactersPtr;
  if (CharactersPtr)
  {
    *((void *)&v38 + 1) = 0;
    CFIndex v39 = 0;
    *(void *)&long long v37 = 0;
    UniChar isa = (UniChar)CharactersPtr->isa;
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
    *((void *)&v38 + 1) = 0;
    CFIndex v39 = 0;
    *(void *)&long long v37 = CStringPtr;
    if (CStringPtr)
    {
      UniChar isa = *CStringPtr;
    }
    else
    {
      v9.length = v4 >= 64 ? 64 : v4;
      CFIndex v39 = v9.length;
      v9.location = 0;
      CFStringGetCharacters(a1, v9, buffer);
      UniChar isa = buffer[-*((void *)&v38 + 1)];
    }
  }
  if ((unsigned __int16)((isa & 0xFFDF) - 91) < 0xFFE6u) {
    return 0;
  }
  if ((unint64_t)v4 >= 2)
  {
    uint64_t v11 = 0;
    BOOL v10 = 0;
    uint64_t v12 = -1;
    uint64_t v13 = 65;
    unint64_t v14 = 1;
    do
    {
      if (v14 >= 4) {
        uint64_t v15 = 4;
      }
      else {
        uint64_t v15 = v14;
      }
      if (theString[1])
      {
        UniChar v16 = *((_WORD *)&theString[1]->isa + v11 + *((void *)&v37 + 1) + 1);
      }
      else if ((void)v37)
      {
        UniChar v16 = *(char *)(v37 + *((void *)&v37 + 1) + v11 + 1);
      }
      else
      {
        if (v39 <= v11 + 1 || (uint64_t v17 = *((void *)&v38 + 1), *((uint64_t *)&v38 + 1) > v11 + 1))
        {
          uint64_t v18 = -v15;
          uint64_t v19 = v15 + v12;
          uint64_t v20 = v13 - v15;
          uint64_t v21 = v11 + v18;
          uint64_t v22 = v21 + 1;
          uint64_t v23 = v21 + 65;
          if (v23 >= (uint64_t)v38) {
            uint64_t v23 = v38;
          }
          *((void *)&v38 + 1) = v22;
          CFIndex v39 = v23;
          if ((uint64_t)v38 < v20) {
            uint64_t v20 = v38;
          }
          v41.length = v20 + v19;
          v41.location = v22 + *((void *)&v37 + 1);
          CFStringGetCharacters(theString[0], v41, buffer);
          uint64_t v17 = *((void *)&v38 + 1);
        }
        UniChar v16 = buffer[v11 + 1 - v17];
      }
      if (v16 > 0x7Fu) {
        break;
      }
      if ((unsigned __int16)(v16 - 48) >= 0xAu && (unsigned __int16)((v16 & 0xFFDF) - 65) >= 0x1Au)
      {
        unsigned int v25 = v16;
        uint64_t v26 = (1 << v16) & 0x680000000000;
        if (v25 > 0x2E || v26 == 0) {
          break;
        }
      }
      ++v14;
      BOOL v10 = v11 + 2 >= v4;
      ++v11;
      --v12;
      ++v13;
    }
    while (v3 != v11);
  }
  else
  {
    return 1;
  }
  return v10;
}

id _CFURLComponentsCopyEncodedHost(void *a1)
{
  v1 = (void *)[a1 encodedHost];

  return v1;
}

uint64_t _CFURLComponentsSetPercentEncodedUser(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC63C(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedPassword(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC66C(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedHost(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC69C(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedPath(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC6CC(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedQuery(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC6FC(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedFragment(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC72C(void *a1)
{
}

uint64_t _CFURLComponentsSetEncodedHost(void *a1, uint64_t a2)
{
  return 1;
}

void sub_182CDC75C(void *a1)
{
}

uint64_t _CFURLComponentsGetRangeOfScheme(void *a1)
{
  uint64_t result = [a1 rangeOfScheme];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfUser(void *a1)
{
  uint64_t result = [a1 rangeOfUser];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPassword(void *a1)
{
  uint64_t result = [a1 rangeOfPassword];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfHost(void *a1)
{
  uint64_t result = [a1 rangeOfHost];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPort(void *a1)
{
  uint64_t result = [a1 rangeOfPort];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPath(void *a1)
{
  uint64_t result = [a1 rangeOfPath];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfQuery(void *a1)
{
  uint64_t result = [a1 rangeOfQuery];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfFragment(void *a1)
{
  uint64_t result = [a1 rangeOfFragment];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

CFArrayRef _CFURLComponentsCopyQueryItems(void *a1)
{
  return __CFURLComponentsCopyQueryItems(a1, 0);
}

CFArrayRef __CFURLComponentsCopyQueryItems(void *a1, int a2)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  if (a2) {
    v2 = (void *)[a1 percentEncodedQueryItems];
  }
  else {
    v2 = (void *)[a1 queryItems];
  }
  CFIndex v3 = v2;
  if (!v2) {
    return 0;
  }
  if ([v2 count] != 1)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    uint64_t v6 = [v3 countByEnumeratingWithState:&v17 objects:v16 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v18;
      long long v13 = xmmword_1ECDB0EA0;
      do
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          if (*(void *)v18 != v8) {
            objc_enumerationMutation(v3);
          }
          BOOL v10 = *(void **)(*((void *)&v17 + 1) + 8 * i);
          values[0] = objc_msgSend(v10, "name", v13, 0, 0, v13);
          values[1] = (void *)[v10 value];
          if ([v10 value]) {
            CFIndex v11 = 2;
          }
          else {
            CFIndex v11 = 1;
          }
          CFDictionaryRef v12 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)keys, (const void **)values, v11, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFArrayAppendValue(Mutable, v12);
        }
        uint64_t v7 = [v3 countByEnumeratingWithState:&v17 objects:v16 count:16];
      }
      while (v7);
    }
    return Mutable;
  }

  return CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
}

CFArrayRef _CFURLComponentsCopyPercentEncodedQueryItems(void *a1)
{
  return __CFURLComponentsCopyQueryItems(a1, 1);
}

CFIndex __CFURLComponentsSetQueryItems(void *a1, CFArrayRef theArray, const __CFArray *a3)
{
  CFIndex v3 = a1;
  if (theArray)
  {
    if (CFArrayGetCount(theArray))
    {
      CFIndex Count = CFArrayGetCount(theArray);
      CFIndex result = CFArrayGetCount(a3);
      if (Count == result)
      {
        uint64_t v8 = +[NSArray array];
        if (CFArrayGetCount(theArray) >= 1)
        {
          CFIndex v9 = 0;
          do
          {
            ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(theArray, v9);
            CFIndex v11 = (__objc2_class **)CFArrayGetValueAtIndex(a3, v9);
            if (ValueAtIndex == (__CFString *)&__kCFNull)
            {
              ValueAtIndex = &stru_1ECE10768;
            }
            else
            {
              CFTypeID v12 = CFGetTypeID(ValueAtIndex);
              if (v12 != CFStringGetTypeID()) {
                ValueAtIndex = &stru_1ECE10768;
              }
            }
            if (v11 == &__kCFNull)
            {
              unint64_t v14 = 0;
            }
            else
            {
              CFTypeID v13 = CFGetTypeID(v11);
              if (v13 == CFStringGetTypeID()) {
                unint64_t v14 = v11;
              }
              else {
                unint64_t v14 = 0;
              }
            }
            [(NSArray *)v8 addObject:+[NSURLQueryItem queryItemWithName:ValueAtIndex value:v14]];
            ++v9;
          }
          while (CFArrayGetCount(theArray) > v9);
        }
        return [v3 setQueryItems:v8];
      }
      else
      {
        __break(1u);
      }
      return result;
    }
    uint64_t v15 = &stru_1ECE10768;
    a1 = v3;
  }
  else
  {
    uint64_t v15 = 0;
  }

  return [a1 setQuery:v15];
}

uint64_t _CFURLComponentsSetPercentEncodedQueryItems(void *a1, const __CFArray *a2, const __CFArray *a3)
{
  return 1;
}

uint64_t _CFURLComponentsMatchURLInString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = +[NSURLComponents _matchWithString:a1 requiredComponents:a2 defaultValues:a3 urlPtr:a4];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

unint64_t _CFSocketStreamSetAuthenticatesServerCertificateDefault(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog(3, @"_CFSocketStreamSetAuthenticatesServerCertificateDefault(): This call has been deprecated.  Use SetProperty(_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate, kCFBooleanTrue/False)\n", a3, a4, a5, a6, a7, a8, vars0);
}

uint64_t _CFSocketStreamGetAuthenticatesServerCertificateDefault(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFLog(3, @"_CFSocketStreamGetAuthenticatesServerCertificateDefault(): This call has been removed as a security risk.  Use security properties on individual streams instead.\n", a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _CFSocketStreamPairSetAuthenticatesServerCertificate(__CFReadStream *a1, CFWriteStreamRef stream, int a3)
{
  CFIndex v3 = &kCFBooleanFalse;
  if (a3) {
    CFIndex v3 = &kCFBooleanTrue;
  }
  CFBooleanRef v4 = *v3;
  if (a1) {
    return CFReadStreamSetProperty(a1, @"_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate", v4);
  }
  else {
    return CFWriteStreamSetProperty(stream, @"_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate", v4);
  }
}

void CFStreamCreatePairWithSocket(CFAllocatorRef alloc, CFSocketNativeHandle sock, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

uint64_t createPair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  if (a6) {
    *a6 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_1EC090F90 & 1) == 0) {
    initializeCFNetworkSupport();
  }
  pthread_mutex_unlock(&CFNetworkSupport);
  unint64_t v14 = off_1EC090F98;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *, void *))v14)(a1, a2, a3, a4, a5, a6, a7);
}

void CFStreamCreatePairWithSocketToHost(CFAllocatorRef alloc, CFStringRef host, UInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

void CFStreamCreatePairWithPeerSocketSignature(CFAllocatorRef alloc, const CFSocketSignature *signature, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

uint64_t _CFStreamErrorFromError(__CFError *a1)
{
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_1EC090F90 & 1) == 0) {
    initializeCFNetworkSupport();
  }
  v2 = off_1EC090FA8;
  pthread_mutex_unlock(&CFNetworkSupport);
  if (v2) {
    return off_1EC090FA8(a1);
  }
  CFErrorDomain Domain = CFErrorGetDomain(a1);
  if (CFEqual(Domain, @"NSPOSIXErrorDomain"))
  {
    uint64_t v3 = 1;
  }
  else if (CFEqual(Domain, @"NSOSStatusErrorDomain"))
  {
    uint64_t v3 = 2;
  }
  else if (CFEqual(Domain, @"NSMachErrorDomain"))
  {
    uint64_t v3 = 11;
  }
  else
  {
    uint64_t v3 = -1;
  }
  CFErrorGetCode(a1);
  return v3;
}

void *initializeCFNetworkSupport()
{
  dword_1EC090F90 |= 1u;
  off_1EC090F98 = __CFLookupCFNetworkFunction("_CFSocketStreamCreatePair");
  off_1EC090FA0 = __CFLookupCFNetworkFunction("_CFErrorCreateWithStreamError");
  uint64_t result = __CFLookupCFNetworkFunction("_CFStreamErrorFromCFError");
  off_1EC090FA8 = result;
  if (!off_1EC090F98) {
    uint64_t result = (void *)CFLog(3, @"CoreFoundation: failed to dynamically link symbol _CFSocketStreamCreatePair", v1, v2, v3, v4, v5, v6, v7);
  }
  if (!off_1EC090FA0) {
    uint64_t result = (void *)CFLog(3, @"CoreFoundation: failed to dynamically link symbol _CFErrorCreateWithStreamError", v1, v2, v3, v4, v5, v6, v7);
  }
  if (!off_1EC090FA8) {
    uint64_t result = (void *)CFLog(3, @"CoreFoundation: failed to dynamically link symbol _CFStreamErrorFromCFError", v1, v2, v3, v4, v5, v6, v7);
  }
  dword_1EC090F90 |= 2u;
  return result;
}

CFErrorRef _CFStreamCreateErrorFromStreamError(const __CFAllocator *a1, int *a2)
{
  keys[1] = *(void **)off_1ECE0A5B0;
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_1EC090F90 & 1) == 0) {
    initializeCFNetworkSupport();
  }
  uint64_t v4 = off_1EC090FA0;
  pthread_mutex_unlock(&CFNetworkSupport);
  if (v4)
  {
    uint64_t v5 = (uint64_t (*)(const __CFAllocator *, int *))off_1EC090FA0;
    return (CFErrorRef)v5(a1, a2);
  }
  else
  {
    if (*(void *)a2 == 2)
    {
      CFIndex v7 = a2[2];
      uint64_t v8 = &kCFErrorDomainOSStatus;
    }
    else
    {
      if (*(void *)a2 != 1)
      {
        keys[0] = @"CFStreamErrorDomainKey";
        values = CFNumberCreate(a1, kCFNumberCFIndexType, a2);
        CFDictionaryRef v10 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFErrorRef v11 = CFErrorCreate(a1, @"BogusCFStreamErrorCompatibilityDomain", a2[2], v10);
        CFRelease(values);
        CFRelease(v10);
        return v11;
      }
      CFIndex v7 = a2[2];
      uint64_t v8 = &kCFErrorDomainPOSIX;
    }
    CFStringRef v9 = *v8;
    return CFErrorCreate(a1, v9, v7, 0);
  }
}

void *__CFSortIndexes_block_invoke(void *result, uint64_t a2)
{
  uint64_t v2 = result[4];
  uint64_t v3 = v2 * a2;
  uint64_t v4 = v2 * a2 + v2;
  if (v4 >= result[5]) {
    uint64_t v4 = result[5];
  }
  if (v3 < v4)
  {
    uint64_t v5 = result[6];
    do
    {
      *(void *)(v5 + 8 * v3) = v3;
      ++v3;
    }
    while (v4 != v3);
  }
  return result;
}

void __CFSortIndexesN(char *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v31 = a4;
  block[10] = *(void *)off_1ECE0A5B0;
  uint64_t v5 = (a2 + a3 - 1) / a3;
  uint64_t v7 = v5 + 15;
  BOOL v6 = v5 < -15;
  uint64_t v8 = v5 + 30;
  if (!v6) {
    uint64_t v8 = v7;
  }
  uint64_t v9 = v8 >> 4;
  int64_t v10 = v8 & 0xFFFFFFFFFFFFFFF0;
  uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF0) + a2;
  int64_t v12 = (v11 - 1) / v10;
  uint64_t v13 = v11 - v10 * v12;
  MEMORY[0x1F4188790](a1, a2);
  UniChar v16 = (const void **)((char *)&v26 - v15);
  if (v14 >= 0x200) {
    size_t v17 = 512;
  }
  else {
    size_t v17 = v14;
  }
  bzero((char *)&v26 - v15, v17);
  size_t v18 = v9 << 7;
  if (v12 >= 1)
  {
    long long v19 = (void **)v16;
    int64_t v20 = v12;
    do
    {
      *v19++ = malloc_type_malloc(v18, 0x100004000313F17uLL);
      --v20;
    }
    while (v20);
  }
  block[0] = off_1ECE0A5A0;
  block[1] = 0x40000000;
  block[2] = ____CFSortIndexesN_block_invoke;
  block[3] = &unk_1ECDB0FA8;
  block[6] = v10;
  block[7] = v13;
  block[8] = a1;
  block[9] = v16;
  block[4] = v31;
  block[5] = v12;
  dispatch_apply(v12, 0, block);
  if (v12 >= 0) {
    int64_t v21 = v12;
  }
  else {
    int64_t v21 = v12 + 1;
  }
  if (v12 - 1 >= 0) {
    int64_t v22 = v12 - 1;
  }
  else {
    int64_t v22 = v12;
  }
  if (v12 >= 1)
  {
    size_t v29 = v21 & 0xFFFFFFFFFFFFFFFELL;
    size_t v28 = v22 & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v23 = (unint64_t)(v12 + 1) >> 1;
    v27 = off_1ECE0A5A0;
    uint64_t v26 = ____CFSortIndexesN_block_invoke_2;
    int64_t v30 = v12 - 1;
    v24 = &a1[8 * v10 * (v12 - 1)];
    do
    {
      v33[0] = v27;
      v33[1] = 0x40000000;
      v33[2] = v26;
      v33[3] = &unk_1ECDB0FD0;
      v33[6] = v10;
      v33[7] = v12;
      v33[8] = v13;
      v33[9] = v16;
      v33[4] = v31;
      v33[5] = a1;
      dispatch_apply(v29, 0, v33);
      if (v12) {
        memmove((void *)v16[v30], v24, 8 * v13);
      }
      v32[0] = off_1ECE0A5A0;
      v32[1] = 0x40000000;
      v32[2] = ____CFSortIndexesN_block_invoke_3;
      v32[3] = &unk_1ECDB0FF8;
      v32[6] = v12;
      v32[7] = v13;
      v32[8] = v10;
      v32[9] = a1;
      v32[5] = v16;
      v32[4] = v31;
      dispatch_apply(v28, 0, v32);
      memmove(a1, *v16, v18);
      if ((v12 & 1) == 0) {
        memmove(v24, v16[v30], 8 * v13);
      }
      --v23;
    }
    while (v23);
    do
    {
      unsigned int v25 = (void *)*v16++;
      free(v25);
      --v12;
    }
    while (v12);
  }
}

uint64_t *__CFSortIndexesNMerge(uint64_t *result, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a3;
  uint64_t v13 = result;
  if (a4 + a2 >= 17)
  {
    uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, result[a2 - 1], *a3);
    if ((uint64_t)result <= 0)
    {
      if (a6) {
        int64_t v30 = v11;
      }
      else {
        int64_t v30 = v13;
      }
      if (a6) {
        uint64_t v31 = a4;
      }
      else {
        uint64_t v31 = a2;
      }
      return (uint64_t *)memmove(a5, v30, 8 * v31);
    }
  }
  if (!a6)
  {
    if (a2 < 1) {
      return result;
    }
    int64_t v22 = &v13[a2];
    unint64_t v23 = &v11[a4];
    v24 = &a5[a2];
    while (1)
    {
      if (v23 <= v11)
      {
        uint64_t v28 = *v13++;
        uint64_t v27 = v28;
      }
      else
      {
        if (v22 > v13)
        {
          uint64_t v25 = *v13;
          uint64_t v26 = *v11;
          uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, *v13, *v11);
          if ((uint64_t)result <= 0)
          {
            *a5 = v25;
            ++v13;
          }
          else
          {
            *a5 = v26;
            ++v11;
          }
          goto LABEL_25;
        }
        uint64_t v29 = *v11++;
        uint64_t v27 = v29;
      }
      *a5 = v27;
LABEL_25:
      if (++a5 >= v24) {
        return result;
      }
    }
  }
  if (a4 >= 1)
  {
    unint64_t v14 = &a5[a4];
    uint64_t v15 = &v11[a4 - 1];
    UniChar v16 = &v13[a2 - 1];
    do
    {
      if (v15 >= v11)
      {
        if (v16 >= v13)
        {
          uint64_t v20 = *v16;
          uint64_t v21 = *v15;
          uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, *v16, *v15);
          if ((uint64_t)result <= 0)
          {
            *(v14 - 1) = v21;
            --v15;
          }
          else
          {
            *(v14 - 1) = v20;
            --v16;
          }
          goto LABEL_11;
        }
        uint64_t v19 = *--v15;
        uint64_t v17 = v19;
      }
      else
      {
        uint64_t v18 = *--v16;
        uint64_t v17 = v18;
      }
      *(v14 - 1) = v17;
LABEL_11:
      --v14;
    }
    while (v14 > a5);
  }
  return result;
}

uint64_t __CFStorageGetCapacity(uint64_t a1)
{
  uint64_t NodeCapacity = __CFStorageGetNodeCapacity(a1 + 144);
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 == -1) {
    return NodeCapacity / *(void *)(a1 + 16);
  }
  else {
    return NodeCapacity >> v3;
  }
}

uint64_t __CFStorageGetNodeCapacity(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = 0;
    while (!*(unsigned char *)(v1 + 13))
    {
      uint64_t NodeCapacity = __CFStorageGetNodeCapacity(*(void *)(v1 + 16));
      uint64_t v4 = __CFStorageGetNodeCapacity(*(void *)(v1 + 24));
      uint64_t v1 = *(void *)(v1 + 32);
      v2 += NodeCapacity + v4;
      if (!v1) {
        goto LABEL_7;
      }
    }
    uint64_t v5 = *(void *)(v1 + 16);
  }
  else
  {
    uint64_t v2 = 0;
LABEL_7:
    uint64_t v5 = 0;
  }
  return v5 + v2;
}

uint64_t __CFStorageGetValueSize(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t __CFStorageEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(void *)(a1 + 144);
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 == -1) {
    uint64_t v4 = v2 / *(void *)(a1 + 16);
  }
  else {
    uint64_t v4 = v2 >> v3;
  }
  uint64_t v5 = *(void *)(a2 + 144);
  int v6 = *(_DWORD *)(a2 + 24);
  if (v6 == -1) {
    uint64_t v7 = v5 / *(void *)(a2 + 16);
  }
  else {
    uint64_t v7 = v5 >> v6;
  }
  if (v4 != v7) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (v8 != *(void *)(a2 + 16)) {
    return 0;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  ValueAtIndex = 0;
  uint64_t v15 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  while (v13 < v4)
  {
    if (v13 >= v11 + v12)
    {
      ValueAtIndex = (char *)CFStorageGetValueAtIndex(a1, v13, &v25);
      uint64_t v10 = v23;
      uint64_t v9 = v24;
    }
    uint64_t v16 = v9 + v10;
    if (v13 >= v9 + v10)
    {
      uint64_t v15 = (char *)CFStorageGetValueAtIndex(a2, v13, &v23);
      uint64_t v10 = v23;
      uint64_t v9 = v24;
      uint64_t v16 = v24 + v23;
    }
    uint64_t v12 = v25;
    uint64_t v11 = v26;
    if (v16 >= v26 + v25) {
      uint64_t v17 = v26 + v25;
    }
    else {
      uint64_t v17 = v16;
    }
    size_t v18 = (v17 - v13) * v8;
    int v19 = memcmp(ValueAtIndex, v15, v18);
    ValueAtIndex += v18;
    v15 += v18;
    uint64_t v13 = v17;
    if (v19) {
      return 0;
    }
  }
  return 1;
}

uint64_t __CFStorageHash(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 == -1) {
    return v1 / *(void *)(a1 + 16);
  }
  else {
    return v1 >> v2;
  }
}

__CFString *__CFStorageCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  uint64_t v4 = *(void *)(a1 + 144);
  int v5 = *(_DWORD *)(a1 + 24);
  if (v5 == -1)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v6 = v4 / v8;
    uint64_t v7 = __CFStorageGetNodeCapacity(a1 + 144) / v8;
  }
  else
  {
    uint64_t v6 = v4 >> v5;
    uint64_t v7 = __CFStorageGetNodeCapacity(a1 + 144) >> v5;
  }
  CFStringAppendFormat(Mutable, 0, @"<CFStorage %p [%p]>[count = %lu, capacity = %lu]\n", a1, v2, v6, v7);
  __CFStorageDescribeNode((uint64_t *)(a1 + 144), Mutable, 0);
  return Mutable;
}

uint64_t CFStorageGetTypeID()
{
  return 26;
}

uint64_t CFStorageCreateWithSubrange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v49[3] = *(void *)off_1ECE0A5B0;
  uint64_t v6 = (__objc2_class **)CFGetAllocator((CFTypeRef)a1);
  uint64_t v7 = CFStorageCreate(v6, *(void *)(a1 + 16));
  if (a3 >= 1)
  {
    int v8 = *(_DWORD *)(a1 + 24);
    if (v8 == -1)
    {
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v9 = v11 * a2;
      uint64_t v10 = v11 * a3;
    }
    else
    {
      uint64_t v9 = a2 << v8;
      uint64_t v10 = a3 << v8;
    }
    uint64_t v12 = a1 + 144;
    if (*(unsigned char *)(a1 + 157))
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = v9;
      do
      {
        uint64_t v15 = *(uint64_t **)(v12 + 16);
        uint64_t v16 = *(void **)(v12 + 24);
        v49[0] = v15;
        v49[1] = v16;
        uint64_t v17 = *(void **)(v12 + 32);
        v49[2] = v17;
        if (v16) {
          uint64_t v16 = (void *)*v16;
        }
        if (v17) {
          uint64_t v17 = (void *)*v17;
        }
        uint64_t v18 = *v15;
        v48[0] = 0;
        v48[1] = v18;
        int v19 = (char *)v16 + v18;
        v48[2] = (char *)v16 + v18;
        uint64_t v20 = v14 & ~(v14 >> 63);
        uint64_t v21 = v14 + v10;
        if (v18 >= v14 + v10) {
          uint64_t v22 = v14 + v10;
        }
        else {
          uint64_t v22 = v18;
        }
        BOOL v23 = __OFSUB__(v22, v20);
        uint64_t v24 = v22 - v20;
        if ((v24 < 0) ^ v23 | (v24 == 0)) {
          uint64_t v24 = 0;
        }
        if (v18 <= v14) {
          uint64_t v25 = v14;
        }
        else {
          uint64_t v25 = v18;
        }
        if ((uint64_t)v19 >= v21) {
          uint64_t v26 = (char *)(v14 + v10);
        }
        else {
          uint64_t v26 = v19;
        }
        BOOL v23 = __OFSUB__(v26, v25);
        uint64_t v27 = (uint64_t)&v26[-v25];
        if ((v27 < 0) ^ v23 | (v27 == 0)) {
          uint64_t v27 = 0;
        }
        if ((uint64_t)v19 <= v14) {
          uint64_t v28 = v14;
        }
        else {
          uint64_t v28 = (uint64_t)v19;
        }
        uint64_t v29 = &v19[(void)v17];
        if ((uint64_t)v29 >= v21) {
          uint64_t v29 = (char *)(v14 + v10);
        }
        BOOL v30 = (uint64_t)v29 <= v28;
        uint64_t v31 = &v29[-v28];
        if (v30) {
          uint64_t v31 = 0;
        }
        uint64_t v32 = v27 != 0;
        if (v24) {
          ++v32;
        }
        if (v31) {
          uint64_t v33 = v32 + 1;
        }
        else {
          uint64_t v33 = v32;
        }
        if (v33 != 1) {
          break;
        }
        uint64_t v34 = v27 ? 1 : 2;
        uint64_t v35 = v24 ? 0 : v34;
        uint64_t v12 = v49[v35];
        uint64_t v36 = v48[v35];
        v14 -= v36;
        v13 += v36;
      }
      while (!*(unsigned char *)(v12 + 13));
    }
    if (*(unsigned char *)(v12 + 13))
    {
      CFStorageInsertValues(v7, 0, a3);
      uint64_t v37 = *(void *)(v12 + 24);
      if (v37) {
        CFStorageReplaceValues((char *)v7, 0, a3, (char *)(v37 + v9 - v13));
      }
    }
    else
    {
      uint64_t v38 = 0;
      uint64_t v39 = *(void *)v12;
      *(unsigned char *)(v7 + 157) = 0;
      *(void *)(v7 + 144) = v39;
      *(void *)(v7 + 168) = 0;
      *(void *)(v7 + 176) = 0;
      *(void *)(v7 + 160) = 0;
      do
      {
        uint64_t v40 = *(void *)(v12 + 16 + v38);
        if (!v40) {
          break;
        }
        *(unsigned char *)(v40 + 12) = 1;
        if (*(_DWORD *)(v40 + 8)) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v40 + 8), 1u, memory_order_relaxed);
        }
        *(void *)(v7 + v38 + 160) = v40;
        v38 += 8;
      }
      while (v38 != 24);
      int v41 = *(_DWORD *)(v7 + 24);
      if (v41 == -1)
      {
        uint64_t v44 = *(void *)(v7 + 16);
        uint64_t v42 = v13 / v44;
        uint64_t v43 = v39 / v44;
      }
      else
      {
        uint64_t v42 = v13 >> v41;
        uint64_t v43 = v39 >> v41;
      }
      uint64_t v45 = a2 - v42;
      uint64_t v46 = v42 - a2 - a3;
      if (v46 + v43 >= 1) {
        CFStorageDeleteValues(v7, -v46, v46 + v43);
      }
      if (v45 >= 1) {
        CFStorageDeleteValues(v7, 0, v45);
      }
    }
  }
  return v7;
}

char *CFStorageReplaceValues(char *result, uint64_t a2, uint64_t a3, char *a4)
{
  v42[1] = *(void *)off_1ECE0A5B0;
  if (a3 >= 1)
  {
    uint64_t v5 = a3;
    uint64_t v7 = result;
    int v8 = (os_unfair_lock_s *)(result + 128);
    uint64_t v38 = (pthread_mutex_t *)(result + 32);
    uint64_t v39 = (uint64_t)(result + 144);
    do
    {
      os_unfair_lock_lock_with_options();
      uint64_t v10 = *((void *)v7 + 13);
      uint64_t v9 = *((void *)v7 + 14);
      uint64_t v11 = *((void *)v7 + 15);
      os_unfair_lock_unlock(v8);
      if (!v10 || *(unsigned char *)(v10 + 12)) {
        goto LABEL_5;
      }
      if (!*(void *)(v10 + 24))
      {
        CFAllocatorRef v21 = CFGetAllocator(v7);
        uint64_t v22 = *(void *)v10;
        uint64_t v23 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v24 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v24 = v23 + 1;
        }
        if (v22 <= v24 >> 1)
        {
          uint64_t v33 = v22 + 63;
          BOOL v32 = v22 < -63;
          uint64_t v34 = v22 + 126;
          if (!v32) {
            uint64_t v34 = v33;
          }
          int64_t v26 = v34 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v25 = (v22 + v23 - 1) & -(int)v23;
          if (*((void *)v7 + 17) >= v25) {
            int64_t v26 = v25;
          }
          else {
            int64_t v26 = *((void *)v7 + 17);
          }
        }
        if (v26 > *(void *)(v10 + 16))
        {
          pthread_mutex_lock(v38);
          if (v26 > *(void *)(v10 + 16))
          {
            *(void *)(v10 + 24) = __CFSafelyReallocateWithAllocatorTyped(v21, *(void *)(v10 + 24), v26, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v10 + 16) = v26;
          }
          pthread_mutex_unlock(v38);
        }
      }
      if ((uint64_t v35 = a2 - v9, a2 >= v9)
        && v11 + v9 > a2
        && ((uint64_t v28 = *((unsigned int *)v7 + 6), v28 != -1)
          ? (uint64_t v36 = v35 << v28)
          : (uint64_t v36 = *((void *)v7 + 2) * v35),
            (uint64_t v37 = *(void *)(v10 + 24)) != 0))
      {
        Byte = (void *)(v37 + v36);
      }
      else
      {
LABEL_5:
        uint64_t v41 = 0;
        v42[0] = 0;
        uint64_t v40 = 0;
        int v12 = *((_DWORD *)v7 + 6);
        if (v12 == -1) {
          uint64_t v13 = *((void *)v7 + 2) * a2;
        }
        else {
          uint64_t v13 = a2 << v12;
        }
        Byte = (void *)__CFStorageFindByte(v7, v39, v13, 0, v42, &v40, 1);
        uint64_t v15 = v42[0];
        uint64_t v16 = v40;
        if (v42[0])
        {
          uint64_t v17 = *(void *)v42[0];
          int v18 = *((_DWORD *)v7 + 6);
          if (v18 == -1)
          {
            uint64_t v27 = *((void *)v7 + 2);
            uint64_t v19 = v40 / v27;
            uint64_t v20 = v17 / v27;
          }
          else
          {
            uint64_t v19 = v40 >> v18;
            uint64_t v20 = v17 >> v18;
          }
        }
        else
        {
          uint64_t v19 = 0;
          uint64_t v20 = 0;
        }
        os_unfair_lock_lock_with_options();
        *((void *)v7 + 13) = v15;
        *((void *)v7 + 14) = v19;
        *((void *)v7 + 15) = v20;
        os_unfair_lock_unlock(v8);
        uint64_t v28 = *((unsigned int *)v7 + 6);
        if (v28 == -1)
        {
          uint64_t v29 = *((void *)v7 + 2);
          uint64_t v9 = v16 / v29;
          uint64_t v11 = v41 / v29;
        }
        else
        {
          uint64_t v9 = v16 >> v28;
          uint64_t v11 = v41 >> v28;
        }
      }
      if (v5 >= v9 - a2 + v11) {
        uint64_t v30 = v9 - a2 + v11;
      }
      else {
        uint64_t v30 = v5;
      }
      if (v28 == 0xFFFFFFFFLL) {
        size_t v31 = *((void *)v7 + 2) * v30;
      }
      else {
        size_t v31 = v30 << v28;
      }
      uint64_t result = (char *)memmove(Byte, a4, v31);
      a4 += v31;
      a2 += v30;
      BOOL v32 = v5 <= v30;
      v5 -= v30;
    }
    while (!v32);
  }
  return result;
}

uint64_t CFStorageGetConstValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v40[1] = *(void *)off_1ECE0A5B0;
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 128);
  os_unfair_lock_lock_with_options();
  uint64_t v7 = *(uint64_t **)(a1 + 104);
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 120);
  os_unfair_lock_unlock(v6);
  if (!v7) {
    goto LABEL_29;
  }
  if (!v7[3])
  {
    CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v11 = *v7;
    uint64_t v12 = *(void *)off_1ECE0A708;
    if (*(uint64_t *)off_1ECE0A708 >= 0) {
      uint64_t v13 = *(void *)off_1ECE0A708;
    }
    else {
      uint64_t v13 = v12 + 1;
    }
    if (v11 <= v13 >> 1)
    {
      uint64_t v16 = v11 + 63;
      BOOL v19 = v11 < -63;
      uint64_t v17 = v11 + 126;
      if (!v19) {
        uint64_t v17 = v16;
      }
      int64_t v15 = v17 & 0xFFFFFFFFFFFFFFC0;
    }
    else
    {
      int v14 = (v11 + v12 - 1) & -(int)v12;
      if (*(void *)(a1 + 136) >= v14) {
        int64_t v15 = v14;
      }
      else {
        int64_t v15 = *(void *)(a1 + 136);
      }
    }
    if (v15 > v7[2])
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
      if (v15 > v7[2])
      {
        v7[3] = __CFSafelyReallocateWithAllocatorTyped(v10, v7[3], v15, 1893177561, 0, 0);
        if (__CFOASafe) {
          __CFSetLastAllocationEventName();
        }
        v7[2] = v15;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    }
  }
  uint64_t v18 = a2 - v8;
  BOOL v19 = a2 < v8 || v9 + v8 <= a2;
  if (v19) {
    goto LABEL_29;
  }
  if (a3)
  {
    *a3 = v8;
    a3[1] = v9;
  }
  uint64_t v20 = v7[3];
  int v21 = *(_DWORD *)(a1 + 24);
  if (v21 == -1)
  {
    uint64_t v22 = *(void *)(a1 + 16) * v18;
    if (v20) {
      return v20 + v22;
    }
LABEL_29:
    uint64_t v39 = 0;
    v40[0] = 0;
    uint64_t v38 = 0;
    int v24 = *(_DWORD *)(a1 + 24);
    if (v24 == -1) {
      uint64_t v25 = *(void *)(a1 + 16) * a2;
    }
    else {
      uint64_t v25 = a2 << v24;
    }
    uint64_t Byte = __CFStorageFindByte((char *)a1, a1 + 144, v25, 0, v40, &v38, 0);
    uint64_t v26 = v40[0];
    uint64_t v27 = v38;
    if (v40[0])
    {
      uint64_t v28 = *(void *)v40[0];
      int v29 = *(_DWORD *)(a1 + 24);
      if (v29 == -1)
      {
        uint64_t v32 = *(void *)(a1 + 16);
        uint64_t v30 = v38 / v32;
        uint64_t v31 = v28 / v32;
      }
      else
      {
        uint64_t v30 = v38 >> v29;
        uint64_t v31 = v28 >> v29;
      }
    }
    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = 0;
    }
    os_unfair_lock_lock_with_options();
    *(void *)(a1 + 104) = v26;
    *(void *)(a1 + 112) = v30;
    *(void *)(a1 + 120) = v31;
    os_unfair_lock_unlock(v6);
    int v33 = *(_DWORD *)(a1 + 24);
    if (v33 == -1)
    {
      uint64_t v37 = *(void *)(a1 + 16);
      uint64_t v34 = v27 / v37;
      uint64_t v35 = v39 / v37;
      if (!a3) {
        return Byte;
      }
    }
    else
    {
      uint64_t v34 = v27 >> v33;
      uint64_t v35 = v39 >> v33;
      if (!a3) {
        return Byte;
      }
    }
    *a3 = v34;
    a3[1] = v35;
    return Byte;
  }
  uint64_t v22 = v18 << v21;
  if (!v20) {
    goto LABEL_29;
  }
  return v20 + v22;
}

uint64_t __CFStorageCreateNode(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t Typed = CFAllocatorAllocateTyped(a1, 40, 0x1032040801AFE6DLL, 0);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  *(_DWORD *)(Typed + 8) = 1;
  *(unsigned char *)(Typed + 12) = *(unsigned char *)(a2 + 96);
  *(unsigned char *)(Typed + 13) = a3;
  *(void *)uint64_t Typed = a4;
  if ((a3 & 1) == 0) {
    *(void *)(Typed + 32) = 0;
  }
  *(void *)(Typed + 16) = 0;
  *(void *)(Typed + 24) = 0;
  return Typed;
}

uint64_t _CFStorageFastEnumeration(uint64_t a1, unint64_t *a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  unint64_t v3 = *a2;
  if (v3)
  {
    unint64_t v4 = a2[3];
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 144);
    int v6 = *(_DWORD *)(a1 + 24);
    if (v6 == -1) {
      unint64_t v4 = v5 / *(void *)(a1 + 16);
    }
    else {
      unint64_t v4 = v5 >> v6;
    }
    a2[3] = v4;
  }
  if (v3 >= v4) {
    return 0;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t ValueAtIndex = CFStorageGetValueAtIndex(a1, v3, &v9);
  uint64_t result = v10;
  *a2 += v10;
  a2[1] = ValueAtIndex;
  return result;
}

uint64_t CFStorageApplyFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[7] = *(void *)off_1ECE0A5B0;
  uint64_t v5 = *(void *)(a1 + 16);
  v7[0] = off_1ECE0A5A0;
  v7[1] = 0x40000000;
  v7[2] = __CFStorageApplyFunction_block_invoke;
  v7[3] = &__block_descriptor_tmp_10;
  v7[4] = a4;
  v7[5] = a5;
  v7[6] = v5;
  return CFStorageApplyBlock(a1, a2, a3, 0, (uint64_t)v7);
}

uint64_t CFStorageApplyBlock(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int8 a4, uint64_t a5)
{
  if (a3)
  {
    int v6 = *(_DWORD *)(result + 24);
    if (v6 == -1)
    {
      uint64_t v9 = *(void *)(result + 16);
      uint64_t v7 = v9 * a2;
      uint64_t v8 = v9 * a3;
    }
    else
    {
      uint64_t v7 = a2 << v6;
      uint64_t v8 = a3 << v6;
    }
    if (((a3 >= 0x100000) & a4) != 0) {
      uint64_t v10 = 3;
    }
    else {
      uint64_t v10 = 0;
    }
    return __CFStorageEnumerateNodesInByteRangeWithBlock(result, result + 144, 0, v7, v8, v10, a5);
  }
  return result;
}

uint64_t __CFStorageApplyFunction_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    uint64_t v6 = result;
    do
    {
      --v4;
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(v6 + 32))(a2, *(void *)(v6 + 40));
      a2 += *(void *)(v6 + 48);
    }
    while (v4);
  }
  return result;
}

BOOL __CFStorageEnumerateNodesInByteRangeWithBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v70[3] = *(void *)off_1ECE0A5B0;
  unsigned __int8 v67 = 0;
  if (*(unsigned char *)(a2 + 13))
  {
    if (a5 >= *(void *)a2 - a4) {
      uint64_t v12 = *(void *)a2 - a4;
    }
    else {
      uint64_t v12 = a5;
    }
    if (!*(void *)(a2 + 24))
    {
      CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v14 = *(void *)a2;
      uint64_t v15 = *(void *)off_1ECE0A708;
      if (*(uint64_t *)off_1ECE0A708 >= 0) {
        uint64_t v16 = *(void *)off_1ECE0A708;
      }
      else {
        uint64_t v16 = v15 + 1;
      }
      if (v14 <= v16 >> 1)
      {
        uint64_t v51 = v14 + 63;
        BOOL v29 = v14 < -63;
        uint64_t v52 = v14 + 126;
        if (!v29) {
          uint64_t v52 = v51;
        }
        int64_t v18 = v52 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        int v17 = (v14 + v15 - 1) & -(int)v15;
        if (*(void *)(a1 + 136) >= v17) {
          int64_t v18 = v17;
        }
        else {
          int64_t v18 = *(void *)(a1 + 136);
        }
      }
      if (v18 > *(void *)(a2 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
        if (v18 > *(void *)(a2 + 16))
        {
          *(void *)(a2 + 24) = __CFSafelyReallocateWithAllocatorTyped(v13, *(void *)(a2 + 24), v18, 1893177561, 0, 0);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *(void *)(a2 + 16) = v18;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
      }
    }
    uint64_t v53 = a4 + a3;
    int v54 = *(_DWORD *)(a1 + 24);
    if (v54 == -1)
    {
      uint64_t v57 = *(void *)(a1 + 16);
      uint64_t v55 = v53 / v57;
      uint64_t v56 = v12 / v57;
    }
    else
    {
      uint64_t v55 = v53 >> v54;
      uint64_t v56 = v12 >> v54;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int8 *))(a7 + 16))(a7, *(void *)(a2 + 24) + a4, v55, v56, &v67);
    int v49 = v67;
    return v49 != 0;
  }
  BOOL v19 = *(uint64_t **)(a2 + 16);
  uint64_t v20 = *(uint64_t **)(a2 + 24);
  v70[0] = v19;
  v70[1] = v20;
  int v21 = *(uint64_t **)(a2 + 32);
  v70[2] = v21;
  uint64_t v22 = *v19;
  if (v20) {
    uint64_t v23 = *v20;
  }
  else {
    uint64_t v23 = 0;
  }
  if (v21) {
    uint64_t v24 = *v21;
  }
  else {
    uint64_t v24 = 0;
  }
  v69[0] = 0;
  v69[1] = v22;
  uint64_t v25 = v23 + v22;
  v69[2] = v23 + v22;
  uint64_t v26 = a4 & ~(a4 >> 63);
  uint64_t v27 = a4 + a5;
  if (v22 >= a4 + a5) {
    uint64_t v28 = a4 + a5;
  }
  else {
    uint64_t v28 = v22;
  }
  BOOL v29 = v28 <= v26;
  uint64_t v30 = v28 - v26;
  if (v29) {
    uint64_t v31 = 0;
  }
  else {
    uint64_t v31 = v30;
  }
  if (v29) {
    uint64_t v32 = 0;
  }
  else {
    uint64_t v32 = a4 & ~(a4 >> 63);
  }
  v68[0] = v32;
  v68[1] = v31;
  if (v22 <= a4) {
    uint64_t v33 = a4;
  }
  else {
    uint64_t v33 = v22;
  }
  if (v25 >= v27) {
    uint64_t v34 = v27;
  }
  else {
    uint64_t v34 = v25;
  }
  BOOL v35 = v34 <= v33;
  uint64_t v36 = v34 - v33;
  if (v35) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = v36;
  }
  if (v35) {
    uint64_t v38 = 0;
  }
  else {
    uint64_t v38 = v33;
  }
  v68[2] = v38;
  v68[3] = v37;
  if (v25 <= a4) {
    uint64_t v39 = a4;
  }
  else {
    uint64_t v39 = v25;
  }
  uint64_t v40 = v25 + v24;
  if (v40 >= v27) {
    uint64_t v40 = v27;
  }
  BOOL v41 = v40 <= v39;
  uint64_t v42 = v40 - v39;
  if (v41) {
    uint64_t v43 = 0;
  }
  else {
    uint64_t v43 = v42;
  }
  if (v41) {
    uint64_t v44 = 0;
  }
  else {
    uint64_t v44 = v39;
  }
  v68[4] = v44;
  v68[5] = v43;
  unint64_t v45 = v37 != 0;
  if (v31) {
    ++v45;
  }
  if (v43) {
    ++v45;
  }
  uint64_t v46 = a6 - (v45 > 1);
  if (v45 < 2 || v46 < 0)
  {
    uint64_t v59 = v44;
    if (v31 < 1)
    {
      if (v37 < 1)
      {
        if (v43 <= 0)
        {
          int v49 = 0;
          return v49 != 0;
        }
        goto LABEL_90;
      }
    }
    else
    {
      int v50 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v19, a3, v32);
      if (v37 > 0) {
        int v49 = 1;
      }
      else {
        int v49 = v50;
      }
      if (v37 < 1 || (v50 & 1) != 0) {
        goto LABEL_86;
      }
    }
    int v49 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v20, v22 + a3, v38 - v22);
LABEL_86:
    if (v43 <= 0) {
      return v49 != 0;
    }
    if (v49)
    {
      int v49 = 1;
      return v49 != 0;
    }
LABEL_90:
    int v49 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v21, v25 + a3, v59 - v25);
    return v49 != 0;
  }
  uint64_t v47 = 1;
  if (v20) {
    uint64_t v47 = 2;
  }
  if (v21) {
    size_t v48 = v47 + 1;
  }
  else {
    size_t v48 = v47;
  }
  uint64_t v63 = 0;
  v64 = &v63;
  uint64_t v65 = 0x2000000000;
  char v66 = 0;
  block[0] = off_1ECE0A5A0;
  block[1] = 0x40000000;
  block[2] = ____CFStorageEnumerateNodesInByteRangeWithBlock_block_invoke;
  block[3] = &unk_1ECDB1040;
  block[5] = &v63;
  block[6] = v68;
  block[7] = a1;
  block[8] = v70;
  block[9] = a3;
  block[10] = v69;
  void block[11] = v46;
  block[4] = a7;
  dispatch_apply(v48, 0, block);
  int v49 = *((unsigned __int8 *)v64 + 24);
  _Block_object_dispose(&v63, 8);
  return v49 != 0;
}

uint64_t __CFStorageSetAlwaysFrozen(uint64_t result, char a2)
{
  *(unsigned char *)(result + 96) = a2;
  return result;
}

void __CFStorageDescribeNode(uint64_t *a1, __CFString *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v6 = a3;
    do
    {
      CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
      CFStringAppendCString(a2, "  ", SystemEncoding);
      --v6;
    }
    while (v6);
  }
  uint64_t v8 = *a1;
  if (*((unsigned char *)a1 + 13))
  {
    uint64_t v9 = "yes";
    if (!*((unsigned char *)a1 + 12)) {
      uint64_t v9 = "no";
    }
    CFStringAppendFormat(a2, 0, @"Leaf %ld/%ld (%p) refcount: %u frozen: %s\n", v8, a1[2], a1, *((unsigned int *)a1 + 2), v9);
  }
  else
  {
    uint64_t v10 = "yes";
    if (!*((unsigned char *)a1 + 12)) {
      uint64_t v10 = "no";
    }
    CFStringAppendFormat(a2, 0, @"Node %ld (%p) refcount: %u frozen: %s\n", v8, a1, *((unsigned int *)a1 + 2), v10);
    for (uint64_t i = 0; i != 3; ++i)
    {
      uint64_t v12 = a1[i + 2];
      if (v12) {
        __CFStorageDescribeNode(v12, a2, a3 + 1);
      }
    }
  }
}

void __CFStorageDeallocateNode(const void *a1, uint64_t a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFAllocatorRef v5 = v4;
  if (*(unsigned char *)(a2 + 13))
  {
    uint64_t v6 = *(void **)(a2 + 24);
    if (v6) {
      CFAllocatorDeallocate(v4, v6);
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7
      && *(_DWORD *)(v7 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode(a1);
    }
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8
      && *(_DWORD *)(v8 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode(a1);
    }
    uint64_t v9 = *(void *)(a2 + 32);
    if (v9
      && *(_DWORD *)(v9 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode(a1);
    }
  }

  CFAllocatorDeallocate(v5, (void *)a2);
}

uint64_t __CFStorageInsertFrozen(uint64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = (uint64_t *)a3;
  uint64_t v84 = *(void *)off_1ECE0A5B0;
  if (*(unsigned char *)(a3 + 13))
  {
    uint64_t v12 = *(void *)a3 + a5;
    uint64_t v13 = *(void *)(a2 + 136);
    uint64_t v14 = v12 - v13;
    if (v12 > v13)
    {
      if (*(void *)a3 == a4)
      {
        Node = (uint64_t *)__CFStorageCreateNode(a1, a2, 1, a5);
        uint64_t v16 = (uint64_t)Node;
        if (!Node)
        {
          uint64_t v19 = 0;
          uint64_t v20 = 0;
          goto LABEL_127;
        }
        uint64_t v17 = *Node;
        int v18 = *(_DWORD *)(a2 + 24);
        if (v18 != -1)
        {
          uint64_t v19 = a6 >> v18;
          uint64_t v20 = v17 >> v18;
LABEL_127:
          os_unfair_lock_lock_with_options();
          *(void *)(a2 + 104) = v16;
          *(void *)(a2 + 112) = v19;
          *(void *)(a2 + 120) = v20;
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
          return (uint64_t)v9;
        }
        uint64_t v76 = *(void *)(a2 + 16);
        uint64_t v19 = a6 / v76;
LABEL_126:
        uint64_t v20 = v17 / v76;
        goto LABEL_127;
      }
      if (a4)
      {
        uint64_t v16 = __CFStorageCreateNode(a1, a2, 1, v13);
        uint64_t v34 = __CFStorageCreateNode(a1, a2, 1, v12 - v13);
        uint64_t v35 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v36 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v36 = v35 + 1;
        }
        uint64_t v37 = v36 >> 1;
        if (v37 >= v13)
        {
          uint64_t v58 = v13 + 63;
          if (v13 < -63) {
            uint64_t v58 = v13 + 126;
          }
          int64_t v39 = v58 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v38 = (v13 + v35 - 1) & -(int)v35;
          if (*(void *)(a2 + 136) >= v38) {
            int64_t v39 = v38;
          }
          else {
            int64_t v39 = *(void *)(a2 + 136);
          }
        }
        if (v39 > *(void *)(v16 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v39 > *(void *)(v16 + 16))
          {
            *(void *)(v16 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(v16 + 24), v39, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v16 + 16) = v39;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          uint64_t v35 = *(void *)off_1ECE0A708;
          if (*(uint64_t *)off_1ECE0A708 >= 0) {
            uint64_t v59 = *(void *)off_1ECE0A708;
          }
          else {
            uint64_t v59 = v35 + 1;
          }
          uint64_t v37 = v59 >> 1;
        }
        if (v37 >= v14)
        {
          uint64_t v62 = v14 + 63;
          if (v14 < -63) {
            uint64_t v62 = v14 + 126;
          }
          int64_t v61 = v62 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v60 = (v14 + v35 - 1) & -(int)v35;
          if (*(void *)(a2 + 136) >= v60) {
            int64_t v61 = v60;
          }
          else {
            int64_t v61 = *(void *)(a2 + 136);
          }
        }
        if (v61 > *(void *)(v34 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v61 > *(void *)(v34 + 16))
          {
            *(void *)(v34 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(v34 + 24), v61, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v34 + 16) = v61;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
        memmove(*(void **)(v16 + 24), (const void *)v9[3], a4);
        uint64_t v63 = (a5 + a4) & ~((a5 + a4) >> 63);
        uint64_t v64 = *v9 + a5;
        if (v13 >= v64) {
          uint64_t v65 = *v9 + a5;
        }
        else {
          uint64_t v65 = v13;
        }
        BOOL v66 = v65 <= v63;
        int64_t v67 = v65 - v63;
        if (v66) {
          int64_t v68 = 0;
        }
        else {
          int64_t v68 = v67;
        }
        if (v66) {
          uint64_t v69 = 0;
        }
        else {
          uint64_t v69 = (a5 + a4) & ~((a5 + a4) >> 63);
        }
        if (v68 >= 1) {
          memmove((void *)(*(void *)(v16 + 24) + v69), (const void *)(v9[3] + v69 - a5), v68);
        }
        if (v13 <= a5 + a4) {
          uint64_t v70 = a5 + a4;
        }
        else {
          uint64_t v70 = v13;
        }
        if (v12 >= v64) {
          uint64_t v71 = v64;
        }
        else {
          uint64_t v71 = v12;
        }
        BOOL v72 = v71 <= v70;
        int64_t v73 = v71 - v70;
        if (v72) {
          int64_t v74 = 0;
        }
        else {
          int64_t v74 = v73;
        }
        if (v72) {
          uint64_t v70 = 0;
        }
        if (v74 >= 1) {
          memmove((void *)(*(void *)(v34 + 24) + v70 - v13), (const void *)(v9[3] + v70 - a5), v74);
        }
        uint64_t v41 = a6 - a4;
        uint64_t v42 = *(void *)v16;
        int v43 = *(_DWORD *)(a2 + 24);
        if (v43 != -1) {
          goto LABEL_119;
        }
        goto LABEL_121;
      }
      if (*(_DWORD *)(a3 + 8)) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a3 + 8), 1u, memory_order_relaxed);
      }
      uint64_t v56 = (uint64_t *)__CFStorageCreateNode(a1, a2, 1, a5);
      uint64_t v16 = (uint64_t)v56;
      if (v56)
      {
        uint64_t v17 = *v56;
        int v57 = *(_DWORD *)(a2 + 24);
        if (v57 == -1)
        {
          uint64_t v76 = *(void *)(a2 + 16);
          uint64_t v19 = a6 / v76;
          uint64_t v9 = v56;
          goto LABEL_126;
        }
        uint64_t v19 = a6 >> v57;
        uint64_t v20 = v17 >> v57;
LABEL_120:
        uint64_t v9 = (uint64_t *)v16;
        goto LABEL_127;
      }
      uint64_t v19 = 0;
      uint64_t v20 = 0;
LABEL_124:
      uint64_t v9 = 0;
      goto LABEL_127;
    }
    uint64_t v28 = __CFStorageCreateNode(a1, a2, 1, *(void *)a3 + a5);
    uint64_t v16 = v28;
    BOOL v29 = (const void *)v9[3];
    if (v29)
    {
      uint64_t v30 = *(void *)off_1ECE0A708;
      if (*(uint64_t *)off_1ECE0A708 >= 0) {
        uint64_t v31 = *(void *)off_1ECE0A708;
      }
      else {
        uint64_t v31 = v30 + 1;
      }
      if (v12 <= v31 >> 1)
      {
        uint64_t v40 = v12 + 63;
        if (v12 < -63) {
          uint64_t v40 = v12 + 126;
        }
        int64_t v33 = v40 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        int v32 = (v12 + v30 - 1) & -(int)v30;
        if (*(void *)(a2 + 136) >= v32) {
          int64_t v33 = v32;
        }
        else {
          int64_t v33 = *(void *)(a2 + 136);
        }
      }
      if (v33 > *(void *)(v28 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
        if (v33 > *(void *)(v16 + 16))
        {
          *(void *)(v16 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(v16 + 24), v33, 1893177561, 0, 0);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *(void *)(v16 + 16) = v33;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        BOOL v29 = (const void *)v9[3];
      }
      memmove(*(void **)(v16 + 24), v29, a4);
      memmove((void *)(*(void *)(v16 + 24) + a4 + a5), (const void *)(v9[3] + a4), *v9 - a4);
    }
    else if (!v28)
    {
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      goto LABEL_124;
    }
    uint64_t v41 = a6 - a4;
    uint64_t v42 = *(void *)v16;
    int v43 = *(_DWORD *)(a2 + 24);
    if (v43 != -1)
    {
LABEL_119:
      uint64_t v19 = v41 >> v43;
      uint64_t v20 = v42 >> v43;
      goto LABEL_120;
    }
LABEL_121:
    uint64_t v75 = *(void *)(a2 + 16);
    uint64_t v19 = v41 / v75;
    uint64_t v9 = (uint64_t *)v16;
    uint64_t v20 = v42 / v75;
    goto LABEL_127;
  }
  uint64_t v22 = __CFStorageCreateNode(a1, a2, 0, 0);
  int64_t v23 = a4 - 1;
  uint64_t v24 = (int64_t *)v9[2];
  int64_t v25 = *v24;
  if (*v24 >= a4)
  {
    uint64_t v27 = 0;
    int v78 = 1;
  }
  else
  {
    v23 -= v25;
    uint64_t v24 = (int64_t *)v9[3];
    int64_t v26 = v23 - *v24;
    if (v23 >= *v24)
    {
      int v78 = 0;
      uint64_t v24 = (int64_t *)v9[4];
      uint64_t v27 = 2;
      int64_t v23 = v26;
    }
    else
    {
      int v78 = 1;
      uint64_t v27 = 1;
    }
  }
  uint64_t v81 = a5;
  uint64_t inserted = __CFStorageInsertFrozen(a1, a2, v24, v23 + 1, a5, a6);
  uint64_t v45 = inserted;
  uint64_t v47 = v46;
  uint64_t v48 = 0;
  long long v82 = 0u;
  long long v83 = 0u;
  do
  {
    uint64_t v49 = v9[v48 + 2];
    if (v49)
    {
      if (*(_DWORD *)(v49 + 8)) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v49 + 8), 1u, memory_order_relaxed);
      }
      *(unsigned char *)(v49 + 12) = 1;
    }
    *(void *)((char *)&v82 + v48 * 8) = v49;
    ++v48;
  }
  while (v48 != 3);
  uint64_t v50 = *((void *)&v82 + v27);
  if (v50 != inserted)
  {
    if (*(_DWORD *)(v50 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v50 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode((const void *)a2, v50);
    }
    *((void *)&v82 + v27) = v45;
  }
  if (v47)
  {
    if (v78)
    {
      *((void *)&v83 + 1) = v83;
      if (v25 >= a4) {
        *(void *)&long long v83 = *((void *)&v82 + 1);
      }
    }
    *((void *)&v82 + v27 + 1) = v47;
  }
  long long v51 = v82;
  *(_OWORD *)(v22 + 16) = v82;
  uint64_t v52 = (uint64_t *)*((void *)&v83 + 1);
  if (*((void *)&v83 + 1))
  {
    uint64_t v53 = (void *)__CFStorageCreateNode(a1, a2, 0, 0);
    int v54 = (uint64_t *)v83;
    v53[2] = v83;
    v53[3] = v52;
    *(void *)uint64_t v22 = **((void **)&v51 + 1) + *(void *)v51;
    uint64_t v55 = *v54;
    uint64_t v9 = v52;
  }
  else
  {
    *(void *)(v22 + 32) = v83;
    uint64_t v53 = (void *)v22;
    uint64_t v55 = v81;
  }
  *uint64_t v53 = *v9 + v55;
  return v22;
}

uint64_t __CFStorageDeleteFrozen(uint64_t a1, uint64_t a2, uint64_t *a3, int64_t a4, uint64_t a5)
{
  v35[3] = *(void *)off_1ECE0A5B0;
  if (*((unsigned char *)a3 + 13))
  {
    uint64_t v10 = *a3 - a5;
    if (*a3 != a5)
    {
      uint64_t Node = __CFStorageCreateNode(a1, a2, 1, *a3 - a5);
      uint64_t v12 = Node;
      if (a3[3])
      {
        uint64_t v13 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v14 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v14 = v13 + 1;
        }
        if (v10 <= v14 >> 1)
        {
          uint64_t v31 = v10 + 63;
          if (v10 < -63) {
            uint64_t v31 = v10 + 126;
          }
          int64_t v16 = v31 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v15 = (v10 + v13 - 1) & -(int)v13;
          if (*(void *)(a2 + 136) >= v15) {
            int64_t v16 = v15;
          }
          else {
            int64_t v16 = *(void *)(a2 + 136);
          }
        }
        uint64_t v32 = a4 + a5;
        uint64_t v33 = *a3;
        if (v16 > *(void *)(Node + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v16 > *(void *)(v12 + 16))
          {
            *(void *)(v12 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(v12 + 24), v16, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v12 + 16) = v16;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
        if (a4 >= 1) {
          memmove(*(void **)(v12 + 24), (const void *)a3[3], a4);
        }
        if (v33 - v32 >= 1) {
          memmove((void *)(*(void *)(v12 + 24) + a4), (const void *)(a3[3] + v32), v33 - v32);
        }
      }
      return v12;
    }
    return 0;
  }
  if (a5 == *a3) {
    return 0;
  }
  uint64_t v18 = 0;
  int64_t v19 = 0;
  memset(v35, 0, 24);
  uint64_t v20 = a4 + a5;
  for (uint64_t i = 2; i != 5; ++i)
  {
    uint64_t v22 = (atomic_uint *)a3[i];
    if (!v22) {
      break;
    }
    uint64_t v23 = *(void *)v22;
    int64_t v24 = a4 <= v19 ? v19 : a4;
    int64_t v25 = v23 + v19;
    int64_t v26 = v20 >= v23 + v19 ? v23 + v19 : a4 + a5;
    BOOL v27 = v26 <= v24;
    int64_t v28 = v26 - v24;
    if (v27 ? 0 : v28)
    {
      uint64_t v30 = __CFStorageDeleteFrozen(a1, a2);
      if (v30) {
        v35[v18++] = v30;
      }
    }
    else
    {
      if (v22[2]) {
        atomic_fetch_add_explicit(v22 + 2, 1u, memory_order_relaxed);
      }
      v35[v18++] = v22;
      *((unsigned char *)v22 + 12) = 1;
    }
    int64_t v19 = v25;
  }
  if (v18 == 1) {
    return v35[0];
  }
  uint64_t v34 = __CFStorageCreateNode(a1, a2, 0, 0);
  uint64_t v12 = v34;
  if (v18) {
    memcpy((void *)(v34 + 16), v35, 8 * v18);
  }
  *(void *)uint64_t v12 = *a3 - a5;
  return v12;
}

uint64_t _CFStreamGetInfoPointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

CFStringRef __CFStreamCopyDescription(void *cf)
{
  CFAllocatorRef v2 = (void *)cf[6];
  unint64_t v3 = (uint64_t (*)(void))v2[3];
  if (v3)
  {
    if (*v2) {
      CFStringRef v4 = (CFStringRef)((uint64_t (*)(void *, void))v3)(cf, cf[5]);
    }
    else {
      CFStringRef v4 = (CFStringRef)v3(cf[5]);
    }
  }
  else
  {
    CFAllocatorRef v5 = CFGetAllocator(cf);
    CFStringRef v4 = CFStringCreateWithFormat(v5, 0, @"info = %p", cf[5]);
  }
  CFStringRef v6 = v4;
  CFTypeID v7 = CFGetTypeID(cf);
  CFAllocatorRef v8 = CFGetAllocator(cf);
  if (v7 == 38) {
    CFStringRef v9 = CFStringCreateWithFormat(v8, 0, @"<CFReadStream %p>{%@}", cf, v6);
  }
  else {
    CFStringRef v9 = CFStringCreateWithFormat(v8, 0, @"<CFWriteStream %p>{%@}", cf, v6);
  }
  CFStringRef v10 = v9;
  CFRelease(v6);
  return v10;
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    StreamError = (__CFError *)[(__CFReadStream *)stream _cfStreamError];
  }
  else
  {
    StreamError = _CFStreamGetStreamError((uint64_t)stream);
  }
  result.error = v3;
  result.domain = (CFIndex)StreamError;
  return result;
}

__CFError *_CFStreamGetStreamError(uint64_t a1)
{
  CFStreamError result = *(__CFError **)(a1 + 24);
  if (result)
  {
    if (**(uint64_t **)(a1 + 48) > 1) {
      return (__CFError *)_CFStreamErrorFromError(result);
    }
    else {
      return *(__CFError **)result;
    }
  }
  return result;
}

CFStreamError CFWriteStreamGetError(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    StreamError = (__CFError *)[(__CFWriteStream *)stream _cfStreamError];
  }
  else
  {
    StreamError = _CFStreamGetStreamError((uint64_t)stream);
  }
  result.error = v3;
  result.domain = (CFIndex)StreamError;
  return result;
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    CFAllocatorRef v2 = (void *)[(__CFReadStream *)stream streamError];
    return (CFErrorRef)v2;
  }
  else
  {
    return _CFStreamCopyError(stream);
  }
}

CFErrorRef _CFStreamCopyError(void *cf)
{
  CFErrorRef result = (CFErrorRef)cf[3];
  if (result)
  {
    if (*(uint64_t *)cf[6] > 1)
    {
      CFRetain(result);
      return (CFErrorRef)cf[3];
    }
    else
    {
      CFAllocatorRef v3 = CFGetAllocator(cf);
      CFStringRef v4 = (int *)cf[3];
      return _CFStreamCreateErrorFromStreamError(v3, v4);
    }
  }
  return result;
}

CFErrorRef CFWriteStreamCopyError(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    CFAllocatorRef v2 = (void *)[(__CFWriteStream *)stream streamError];
    return (CFErrorRef)v2;
  }
  else
  {
    return _CFStreamCopyError(stream);
  }
}

uint64_t waitForOpen(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  _CFStreamScheduleWithRunLoop((char *)a1, Current, @"_kCFStreamBlockingOpenMode");
  while ((*(void *)(a1 + 16) & 0x1FLL) == 1)
    CFRunLoopRunInMode(@"_kCFStreamBlockingOpenMode", 1.0e20, 1u);

  return _CFStreamUnscheduleFromRunLoop(a1, Current, @"_kCFStreamBlockingOpenMode");
}

const UInt8 *__cdecl CFReadStreamGetBuffer(CFReadStreamRef stream, CFIndex maxBytesToRead, CFIndex *numBytesRead)
{
  uint64_t v27 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    *(void *)&long long v25 = 0;
    if ([(__CFReadStream *)stream getBuffer:&v25 length:numBytesRead]) {
      return (const UInt8 *)v25;
    }
    else {
      return 0;
    }
  }
  uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  CFAllocatorRef v8 = (uint64_t *)*((void *)stream + 6);
  if (Status == 1)
  {
    *((void *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((void *)stream + 2) &= ~0x40uLL;
    uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  }
  if ((unint64_t)(Status - 2) >= 2)
  {
    if (Status != 5)
    {
      CFStringRef v6 = 0;
      *numBytesRead = -1;
      return v6;
    }
    goto LABEL_13;
  }
  CFStringRef v9 = (uint64_t (*)(CFReadStreamRef, CFIndex, CFIndex *, char *, char *, void))v8[7];
  if (!v9)
  {
LABEL_13:
    CFStringRef v6 = 0;
    *numBytesRead = 0;
    return v6;
  }
  char v26 = 0;
  uint64_t v10 = *((void *)stream + 4);
  if (v10)
  {
    uint64_t v11 = *(void *)(v10 + 72);
    uint64_t v12 = (uint64_t *)((char *)stream + 16);
    uint64_t v13 = *((void *)stream + 2) | 0x40;
    *((void *)stream + 2) = v13;
    if ((v11 & 2) != 0)
    {
      *(void *)(v10 + 72) = v11 & 0xFFFFFFFFFFFFFFFDLL;
      char v14 = 1;
    }
    else
    {
      char v14 = 0;
    }
  }
  else
  {
    char v14 = 0;
    uint64_t v12 = (uint64_t *)((char *)stream + 16);
    uint64_t v13 = *((void *)stream + 2) | 0x40;
    *((void *)stream + 2) = v13;
  }
  if ((v13 & 0x1E) != 6) {
    *uint64_t v12 = v13 & 0xFFFFFFE0 | 3;
  }
  if (*v8 > 1)
  {
    CFStringRef v6 = (const UInt8 *)v9(stream, maxBytesToRead, numBytesRead, (char *)stream + 24, &v26, *((void *)stream + 5));
  }
  else
  {
    long long v25 = 0uLL;
    CFStringRef v6 = (const UInt8 *)v9(stream, maxBytesToRead, numBytesRead, (char *)&v25, &v26, *((void *)stream + 5));
    if (DWORD2(v25))
    {
      uint64_t Typed = (_OWORD *)*((void *)stream + 3);
      if (!Typed)
      {
        CFAllocatorRef v16 = CFGetAllocator(stream);
        uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v16, 16, 0x1000040D9A13B51, 0);
        *((void *)stream + 3) = Typed;
      }
      *uint64_t Typed = v25;
    }
  }
  if (*((void *)stream + 3))
  {
    *numBytesRead = -1;
    if ((*v12 & 0x1F) != 7) {
      *uint64_t v12 = *v12 & 0xFFFFFFE0 | 7;
    }
    uint64_t v17 = *((void *)stream + 4);
    if (v17 && (*(unsigned char *)(v17 + 48) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v18 = *((void *)stream + 4);
      if (v18 && (int64_t v19 = *(__CFRunLoopSource **)(v18 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v18 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        *(void *)(*((void *)stream + 4) + 72) |= 8uLL;
        CFRunLoopSourceSignal(v19);
        CFRelease(v19);
        _wakeUpRunLoop((uint64_t)stream);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
      }
    }
    CFStringRef v6 = 0;
  }
  else if (v26)
  {
    if ((*v12 & 0x1E) != 6) {
      *uint64_t v12 = *v12 & 0xFFFFFFE0 | 5;
    }
    uint64_t v20 = *((void *)stream + 4);
    if (v20 && (*(unsigned char *)(v20 + 48) & 0x10) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v21 = *((void *)stream + 4);
      if (v21 && (uint64_t v22 = *(__CFRunLoopSource **)(v21 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v21 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        *(void *)(*((void *)stream + 4) + 72) |= 0x10uLL;
        CFRunLoopSourceSignal(v22);
        CFRelease(v22);
        _wakeUpRunLoop((uint64_t)stream);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
      }
    }
  }
  else
  {
    char v23 = v14 ^ 1;
    if (v6) {
      char v23 = 1;
    }
    if ((v23 & 1) == 0) {
      *(void *)(*((void *)stream + 4) + 72) |= 2uLL;
    }
    if ((*v12 & 0x1E) != 6) {
      *uint64_t v12 = *v12 & 0xFFFFFFE0 | 2;
    }
  }
  *v12 &= ~0x40uLL;
  return v6;
}

Boolean CFWriteStreamCanAcceptBytes(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream)) {
    return [(__CFWriteStream *)stream hasSpaceAvailable];
  }
  uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  if (Status != 4 && Status != 2) {
    return 0;
  }
  CFStringRef v4 = (uint64_t *)*((void *)stream + 6);
  CFAllocatorRef v5 = (uint64_t (*)(CFWriteStreamRef, char *, void))v4[10];
  if (!v5) {
    return 1;
  }
  *((void *)stream + 2) |= 0x40uLL;
  if (*v4 > 1)
  {
    Boolean v2 = v5(stream, (char *)stream + 24, *((void *)stream + 5));
    if (*((void *)stream + 3))
    {
      uint64_t v6 = *((void *)stream + 2);
      if ((v6 & 0x1F) != 7) {
        *((void *)stream + 2) = v6 & 0xFFFFFFE0 | 7;
      }
      uint64_t v7 = *((void *)stream + 4);
      if (v7 && (*(unsigned char *)(v7 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        uint64_t v8 = *((void *)stream + 4);
        if (v8 && (CFStringRef v9 = *(__CFRunLoopSource **)(v8 + 56)) != 0)
        {
          CFRetain(*(CFTypeRef *)(v8 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(void *)(*((void *)stream + 4) + 72) |= 8uLL;
          CFRunLoopSourceSignal(v9);
          CFRelease(v9);
          _wakeUpRunLoop((uint64_t)stream);
        }
        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
  }
  else
  {
    Boolean v2 = ((uint64_t (*)(CFWriteStreamRef, void))v5)(stream, *((void *)stream + 5));
  }
  *((void *)stream + 2) &= ~0x40uLL;
  return v2;
}

uint64_t _CFStreamCopyProperty(void *a1, uint64_t a2)
{
  Boolean v2 = *(uint64_t (**)(void *, uint64_t, void))(a1[6] + 96);
  if (!v2) {
    return 0;
  }
  a1[2] |= 0x40uLL;
  uint64_t result = v2(a1, a2, a1[5]);
  a1[2] &= ~0x40uLL;
  return result;
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    CFStringRef v4 = (void *)[(__CFReadStream *)stream propertyForKey:propertyName];
    return v4;
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(CFReadStreamRef, CFStreamPropertyKey, void))(*((void *)stream + 6) + 96);
    if (v6)
    {
      *((void *)stream + 2) |= 0x40uLL;
      CFTypeRef result = (CFTypeRef)v6(stream, propertyName, *((void *)stream + 5));
      *((void *)stream + 2) &= ~0x40uLL;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _CFStreamSetProperty(void *a1, uint64_t a2, uint64_t a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(void *, uint64_t, uint64_t, void))(a1[6] + 104);
  if (!v3) {
    return 0;
  }
  a1[2] |= 0x40uLL;
  uint64_t result = v3(a1, a2, a3, a1[5]);
  a1[2] &= ~0x40uLL;
  return result;
}

Boolean CFReadStreamSetProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream)) {
    return [(__CFReadStream *)stream setProperty:propertyValue forKey:propertyName];
  }
  uint64_t v7 = *(uint64_t (**)(CFReadStreamRef, CFStreamPropertyKey, CFTypeRef, void))(*((void *)stream + 6)
                                                                                         + 104);
  if (!v7) {
    return 0;
  }
  *((void *)stream + 2) |= 0x40uLL;
  Boolean result = v7(stream, propertyName, propertyValue, *((void *)stream + 5));
  *((void *)stream + 2) &= ~0x40uLL;
  return result;
}

Boolean CFWriteStreamSetProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream)) {
    return [(__CFWriteStream *)stream setProperty:propertyValue forKey:propertyName];
  }
  uint64_t v7 = *(uint64_t (**)(CFWriteStreamRef, CFStreamPropertyKey, CFTypeRef, void))(*((void *)stream + 6)
                                                                                          + 104);
  if (!v7) {
    return 0;
  }
  *((void *)stream + 2) |= 0x40uLL;
  Boolean result = v7(stream, propertyName, propertyValue, *((void *)stream + 5));
  *((void *)stream + 2) &= ~0x40uLL;
  return result;
}

double _CFReadStreamInitialize(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 56) = 850045857;
    double result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(void *)(a1 + 112) = 0;
  }
  return result;
}

double _CFWriteStreamInitialize(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 56) = 850045857;
    double result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(void *)(a1 + 112) = 0;
  }
  return result;
}

uint64_t _CFReadStreamGetClient(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    return *(void *)(v1 + 8);
  }
  else {
    return 0;
  }
}

uint64_t _CFWriteStreamGetClient(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    return *(void *)(v1 + 8);
  }
  else {
    return 0;
  }
}

void CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    if (objc_opt_respondsToSelector())
    {
      [(__CFWriteStream *)stream _scheduleInCFRunLoop:runLoop forMode:runLoopMode];
    }
    else
    {
      CFTypeRef v6 = _CFRunLoopGet2((uint64_t)runLoop);
      [(__CFWriteStream *)stream scheduleInRunLoop:v6 forMode:runLoopMode];
    }
  }
  else
  {
    _CFStreamScheduleWithRunLoop((char *)stream, runLoop, runLoopMode);
  }
}

void CFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    if (objc_opt_respondsToSelector())
    {
      [(__CFReadStream *)stream _unscheduleFromCFRunLoop:runLoop forMode:runLoopMode];
    }
    else
    {
      CFTypeRef v6 = _CFRunLoopGet2((uint64_t)runLoop);
      [(__CFReadStream *)stream removeFromRunLoop:v6 forMode:runLoopMode];
    }
  }
  else
  {
    _CFStreamUnscheduleFromRunLoop((uint64_t)stream, runLoop, runLoopMode);
  }
}

void CFWriteStreamUnscheduleFromRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    if (objc_opt_respondsToSelector())
    {
      [(__CFWriteStream *)stream _unscheduleFromCFRunLoop:runLoop forMode:runLoopMode];
    }
    else
    {
      CFTypeRef v6 = _CFRunLoopGet2((uint64_t)runLoop);
      [(__CFWriteStream *)stream removeFromRunLoop:v6 forMode:runLoopMode];
    }
  }
  else
  {
    _CFStreamUnscheduleFromRunLoop((uint64_t)stream, runLoop, runLoopMode);
  }
}

void _CFReadStreamSignalEventDelayed(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t _CFReadStreamClearEvent(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (v2) {
    *(void *)(v2 + 72) &= ~a2;
  }
  return result;
}

void _CFWriteStreamSignalEventDelayed(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t CFWriteStreamGetInfoPointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t _CFStreamInstanceSize()
{
  return 128;
}

void _perform()
{
}

uint64_t _CFStringGetInputIdentifierFormatterMappingFromDescriptor(uint64_t a1)
{
  v2[5] = *(void *)off_1ECE0A5B0;
  v2[0] = off_1ECE0A5A0;
  v2[1] = 3221225472;
  v2[2] = ___CFStringGetInputIdentifierFormatterMappingFromDescriptor_block_invoke;
  v2[3] = &__block_descriptor_40_e5_v8__0l;
  v2[4] = a1;
  if (_CFStringGetInputIdentifierFormatterMappingFromDescriptor_loc_formatting_family_info_init != -1) {
    dispatch_once(&_CFStringGetInputIdentifierFormatterMappingFromDescriptor_loc_formatting_family_info_init, v2);
  }
  return _CFStringGetInputIdentifierFormatterMappingFromDescriptor_localizedStringFormattingFamilyInfo;
}

void sub_182CE0988(_Unwind_Exception *exception_object)
{
}

BOOL __CFStringCopyCharSetWithPattern(const __CFString *a1, unint64_t **a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  HIDWORD(v10) = 0;
  CFIndex Length = CFStringGetLength(a1);
  if (CFStringGetCharactersPtr(a1))
  {
    uint64_t v7 = uset_openPattern();
  }
  else
  {
    MEMORY[0x1F4188790](0, v5);
    v12.location = 0;
    v12.length = Length;
    CFStringGetCharacters(a1, v12, (UniChar *)((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0)));
    uint64_t v7 = uset_openPattern();
  }
  if (SHIDWORD(v10) > 0) {
    return 0;
  }
  *a2 = _CFCreateCharacterSetFromUSet(v7, v6);
  uset_close();
  return *a2 != 0;
}

void *_CFStringGetRelevantLocaleInfoFromLocaleSummary(const __CFDictionary *a1, const __CFLocale *a2)
{
  values[1] = *(void **)off_1ECE0A5B0;
  value = 0;
  unint64_t Count = CFDictionaryGetCount(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return value;
  }
  if (Count >> 60)
  {
    CFStringRef v18 = CFStringCreateWithFormat(0, 0, @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt", Count);
    int64_t v19 = +[NSException exceptionWithName:@"NSGenericException" reason:v18 userInfo:0];
    CFRelease(v18);
    objc_exception_throw(v19);
  }
  uint64_t v7 = Mutable;
  if (Count <= 1) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = Count;
  }
  unint64_t v9 = MEMORY[0x1F4188790](v8, v6);
  uint64_t v11 = (const void **)((char *)&v20 - v10);
  size_t v20 = 0;
  if (Count >= 0x101)
  {
    uint64_t v11 = (const void **)_CFCreateArrayStorage(v9, 0, &v20);
    CFRange v12 = v11;
  }
  else
  {
    CFRange v12 = 0;
  }
  CFDictionaryGetKeysAndValues(a1, v11, 0);
  for (; Count; --Count)
    CFArrayAppendValue(v7, *v11++);
  values[0] = (void *)CFLocaleGetIdentifier(a2);
  CFArrayRef v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 1, &kCFTypeArrayCallBacks);
  CFArrayRef v14 = CFBundleCopyLocalizationsForPreferences(v7, v13);
  CFArrayRef v15 = CFBundleCopyPreferredLocalizationsFromArray(v14);
  if (CFArrayGetCount(v15) > 0)
  {
    uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v15, 0);
    free(v12);
    if (!CFDictionaryGetValueIfPresent(a1, ValueAtIndex, (const void **)&value)) {
      value = (void *)CFDictionaryGetValue(a1, @"default");
    }
    if (!v15) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  free(v12);
  if (v15) {
LABEL_17:
  }
    CFRelease(v15);
LABEL_18:
  if (v14) {
    CFRelease(v14);
  }
  CFRelease(v7);
  if (v13) {
    CFRelease(v13);
  }
  return value;
}

void sub_182CE0D34(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFStringContentsInCharacterSet(const __CFString *a1, const __CFCharacterSet *a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = 1;
  if (a1)
  {
    if (a2)
    {
      MutableCopy = CFCharacterSetCreateMutableCopy(0, a2);
      if (MutableCopy)
      {
        uint64_t v5 = MutableCopy;
        CFCharacterSetInvert(MutableCopy);
        CFCharacterSetRemoveCharactersInString(v5, @" ");
        CFRange v8 = (CFRange)xmmword_182D9EC80;
        v10.length = CFStringGetLength(a1);
        v10.location = 0;
        if (CFStringFindCharacterFromSet(a1, v5, v10, 0, &v8)) {
          BOOL v6 = 0;
        }
        else {
          BOOL v6 = v8.location == -1;
        }
        uint64_t v2 = v6;
        CFRelease(v5);
      }
    }
  }
  return v2;
}

uint64_t _CFStringConditionalFormattingMeetsCondition(const __CFString *a1, CFLocaleRef locale)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  uint64_t result = (uint64_t)CFLocaleGetValue(locale, @"kCFLocaleLanguageCodeKey");
  if (result)
  {
    uint64_t result = CFEqual((CFTypeRef)result, @"fi");
    if (result)
    {
      CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      CFRange v5 = (CFRange)xmmword_182D9EC80;
      v7.length = CFStringGetLength(a1);
      v7.location = 0;
      return CFStringFindCharacterFromSet(a1, Predefined, v7, 0, &v5) != 0;
    }
  }
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName(const __CFString *a1, CFLocaleRef locale)
{
  CFTypeRef Value = CFLocaleGetValue(locale, @"kCFLocaleLanguageCodeKey");
  if (!Value) {
    goto LABEL_18;
  }
  CFRange v5 = Value;
  if (CFEqual(Value, @"cs"))
  {
    return _CFStringCopyVocativeCaseOfGivenName_cs(a1, locale);
  }
  if (CFEqual(v5, @"el"))
  {
    return _CFStringCopyVocativeCaseOfGivenName_el(a1, locale);
  }
  if (CFEqual(v5, @"uk"))
  {
    return _CFStringCopyVocativeCaseOfGivenName_uk(a1, locale);
  }
  if (CFEqual(v5, @"lt"))
  {
    return _CFStringCopyVocativeCaseOfGivenName_lt(a1, locale);
  }
  else
  {
LABEL_18:
    return CFRetain(a1);
  }
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_cs(CFStringRef theString, const __CFLocale *a2)
{
  uint64_t v63 = *(void *)off_1ECE0A5B0;
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString);
  if (MutableCopy)
  {
    uint64_t v6 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    CFIndex Count = CFArrayGetCount((CFArrayRef)&off_1ECF55890);
    v64.location = 0;
    v64.length = Count;
    CFIndex v8 = CFArrayBSearchValues((CFArrayRef)&off_1ECF55890, v64, v6, (CFComparatorFunction)CFStringCompare, 0);
    if (v8 < Count)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)&off_1ECF55890, v8);
      if (CFEqual(v6, ValueAtIndex))
      {
        CFStringRef v25 = theString;
        goto LABEL_24;
      }
    }
    if (CFEqual(v6, @"seth"))
    {
      CFIndex Length = CFStringGetLength(v6);
      CFStringReplaceAll(v6, theString);
      CFIndex v23 = Length - 1;
      CFIndex v17 = CFStringGetLength(v6);
      v18.location = v17 - v23;
      if (v17 >= v23)
      {
        v18.length = v23;
        CFStringReplace(v6, v18, @"ethe");
LABEL_23:
        CFStringRef v25 = v6;
LABEL_24:
        CFTypeRef v26 = CFRetain(v25);
        CFRelease(v6);
        if (v26) {
          return v26;
        }
        return CFRetain(theString);
      }
      goto LABEL_57;
    }
    if (CFStringHasSuffix(v6, @"a"))
    {
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 0)
      {
        v19.location = v17 - 1;
        CFStringRef v20 = @"o";
LABEL_8:
        uint64_t v21 = v6;
        v19.length = 1;
LABEL_22:
        CFStringReplace(v21, v19, v20);
        goto LABEL_23;
      }
      goto LABEL_57;
    }
    int v57 = @"uk";
    uint64_t v58 = 0;
    uint64_t v55 = @"ík";
    uint64_t v56 = @"ck";
    uint64_t v53 = @"g";
    int v54 = @"ik";
    if (__CFStringHasOneOfSuffixes(v6, v10, v11, v12, v13, v14, v15, v16, @"h"))
    {
      CFStringReplaceAll(v6, theString);
      UniChar chars = 117;
      p_UniChar chars = &chars;
LABEL_13:
      CFStringAppendCharacters(v6, p_chars, 1);
      goto LABEL_23;
    }
    if (CFStringHasSuffix(v6, @"nec"))
    {
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.location = v17 - 2;
        CFStringRef v20 = @"če";
LABEL_21:
        uint64_t v21 = v6;
        v19.length = 2;
        goto LABEL_22;
      }
    }
    else if (CFStringHasSuffix(v6, @"ius"))
    {
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.location = v17 - 2;
        CFStringRef v20 = @"e";
        goto LABEL_21;
      }
    }
    else
    {
      if (CFStringHasSuffix(v6, @"uce"))
      {
        CFStringReplaceAll(v6, theString);
        CFIndex v17 = CFStringGetLength(v6);
        if (v17 > 0)
        {
          v19.location = v17 - 1;
          CFStringRef v20 = @"i";
          goto LABEL_8;
        }
        goto LABEL_57;
      }
      int v57 = @"xel";
      uint64_t v58 = 0;
      uint64_t v55 = @"rel";
      uint64_t v56 = @"bel";
      if (!__CFStringHasOneOfSuffixes(v6, v28, v29, v30, v31, v32, v33, v34, @"vel"))
      {
        if (CFStringHasSuffix(v6, @"les"))
        {
          CFStringReplaceAll(v6, theString);
          v65.location = CFStringGetLength(v6) - 1;
          v65.length = 1;
          CFStringDelete(v6, v65);
          goto LABEL_23;
        }
        int v57 = @"oř";
        uint64_t v58 = 0;
        uint64_t v55 = @"c";
        uint64_t v56 = @"lix";
        uint64_t v53 = @"j";
        int v54 = @"ex";
        long long v51 = @"ž";
        uint64_t v52 = @"el";
        uint64_t v50 = @"z";
        if (__CFStringHasOneOfSuffixes(v6, v35, v36, v37, v38, v39, v40, v41, @"s"))
        {
          CFStringReplaceAll(v6, theString);
          __int16 v61 = 105;
          p_UniChar chars = (UniChar *)&v61;
          goto LABEL_13;
        }
        if (CFStringHasSuffix(v6, @"děk"))
        {
          CFStringReplaceAll(v6, theString);
          CFIndex v17 = CFStringGetLength(v6);
          if (v17 <= 2) {
            goto LABEL_57;
          }
          v19.location = v17 - 3;
          CFStringRef v20 = @"ďku";
        }
        else
        {
          if (!CFStringHasSuffix(v6, @"něk"))
          {
            if (CFStringHasSuffix(v6, @"ek"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex v17 = CFStringGetLength(v6);
              if (v17 > 1)
              {
                v19.location = v17 - 2;
                CFStringRef v20 = @"ku";
                goto LABEL_21;
              }
            }
            else if (CFStringHasSuffix(v6, @"ter"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex v17 = CFStringGetLength(v6);
              if (v17 > 1)
              {
                v19.location = v17 - 2;
                CFStringRef v20 = @"ře";
                goto LABEL_21;
              }
            }
            else
            {
              if (!CFStringHasSuffix(v6, @"tr"))
              {
                uint64_t v58 = @"b";
                uint64_t v59 = 0;
                uint64_t v56 = @"p";
                int v57 = @"f";
                int v54 = @"m";
                uint64_t v55 = @"l";
                uint64_t v52 = @"n";
                uint64_t v53 = @"v";
                uint64_t v50 = @"d";
                long long v51 = @"t";
                if (!__CFStringHasOneOfSuffixes(v6, v42, v43, v44, v45, v46, v47, v48, @"h"))
                {
                  CFRelease(v6);
                  return CFRetain(theString);
                }
                CFStringReplaceAll(v6, theString);
                __int16 v60 = 101;
                p_UniChar chars = (UniChar *)&v60;
                goto LABEL_13;
              }
              CFStringReplaceAll(v6, theString);
              CFIndex v17 = CFStringGetLength(v6);
              if (v17 > 0)
              {
                v19.location = v17 - 1;
                CFStringRef v20 = @"ře";
                goto LABEL_8;
              }
            }
            goto LABEL_57;
          }
          CFStringReplaceAll(v6, theString);
          CFIndex v17 = CFStringGetLength(v6);
          if (v17 <= 2) {
            goto LABEL_57;
          }
          v19.location = v17 - 3;
          CFStringRef v20 = @"ňku";
        }
        uint64_t v21 = v6;
        v19.length = 3;
        goto LABEL_22;
      }
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.location = v17 - 2;
        CFStringRef v20 = @"le";
        goto LABEL_21;
      }
    }
LABEL_57:
    MEMORY[0x1F4188790](v17, v18.location);
    uint64_t v49 = &v50;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_58;
  }
  MEMORY[0x1F4188790](0, v5);
  uint64_t v49 = &v52;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_58:
  CFTypeRef result = (CFTypeRef)__strlcat_chk();
  qword_1EC093AA8 = (uint64_t)v49;
  __break(1u);
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_el(CFStringRef theString1, const __CFLocale *a2)
{
  uint64_t v4 = 0;
  uint64_t v35 = *(void *)off_1ECE0A5B0;
  do
  {
    if (CFEqual(theString1, _CFStringCopyVocativeCaseOfGivenName_el_keys[v4]))
    {
      theString1 = _CFStringCopyVocativeCaseOfGivenName_el_values[v4];
      goto LABEL_29;
    }
    ++v4;
  }
  while (v4 != 12);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString1);
  if (!MutableCopy)
  {
    MEMORY[0x1F4188790](0, v6);
    uint64_t v30 = v32;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_35;
  }
  CFRange v7 = MutableCopy;
  CFStringLowercase(MutableCopy, a2);
  uint64_t v33 = @"άς";
  uint64_t v34 = 0;
  v32[3] = @"ής";
  v32[4] = @"ας";
  if (__CFStringHasOneOfSuffixes(v7, v8, v9, v10, v11, v12, v13, v14, @"ης")) {
    goto LABEL_6;
  }
  if (CFStringHasSuffix(v7, @"ιος"))
  {
LABEL_10:
    CFStringReplaceAll(v7, theString1);
    CFIndex Length = CFStringGetLength(v7);
    if (Length > 1)
    {
      v17.location = Length - 2;
      CFStringRef v18 = @"ε";
      goto LABEL_15;
    }
LABEL_34:
    MEMORY[0x1F4188790](Length, v16);
    uint64_t v30 = &v31;
    __strlcpy_chk();
    __strlcat_chk();
LABEL_35:
    CFTypeRef result = (CFTypeRef)__strlcat_chk();
    qword_1EC093AA8 = (uint64_t)v30;
    __break(1u);
    return result;
  }
  if (CFStringHasSuffix(v7, @"ός"))
  {
    CFStringReplaceAll(v7, theString1);
    CFIndex Length = CFStringGetLength(v7);
    if (Length <= 1) {
      goto LABEL_34;
    }
    v17.location = Length - 2;
    CFStringRef v18 = @"έ";
LABEL_15:
    v17.length = 2;
    CFStringReplace(v7, v17, v18);
    goto LABEL_16;
  }
  if (CFStringHasSuffix(v7, @"ος"))
  {
    uint64_t v28 = __CFStringApproximateSyllableCount_el_GR(v7);
    if (v28 == 2)
    {
LABEL_6:
      CFStringReplaceAll(v7, theString1);
      CFIndex Length = CFStringGetLength(v7);
      if (Length <= 0) {
        goto LABEL_34;
      }
      v37.location = Length - 1;
      v37.length = 1;
      CFStringDelete(v7, v37);
      goto LABEL_16;
    }
    if (v28 >= 3) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v33 = @"ών";
    uint64_t v34 = 0;
    if (__CFStringHasOneOfSuffixes(v7, v21, v22, v23, v24, v25, v26, v27, @"ων"))
    {
      uint64_t v29 = __CFStringApproximateSyllableCount_el_GR(v7);
      switch(v29)
      {
        case 4:
          goto LABEL_26;
        case 3:
          CFStringReplaceAll(v7, theString1);
          CFStringAppend(v7, @"τα");
LABEL_16:
          CFTypeRef v19 = CFRetain(v7);
          CFRelease(v7);
          if (v19) {
            return v19;
          }
          goto LABEL_29;
        case 2:
LABEL_26:
          CFStringReplaceAll(v7, theString1);
          CFIndex Length = CFStringGetLength(v7);
          if (Length <= 1) {
            goto LABEL_34;
          }
          v17.location = Length - 2;
          CFStringRef v18 = @"ονα";
          goto LABEL_15;
      }
    }
  }
  CFRelease(v7);
LABEL_29:

  return CFRetain(theString1);
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_uk(CFStringRef theString, const __CFLocale *a2)
{
  uint64_t v77 = *(void *)off_1ECE0A5B0;
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString);
  if (MutableCopy)
  {
    uint64_t v6 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    if (CFStringCompare(v6, @"фредрік", 0))
    {
      if (CFStringCompare(v6, @"зорян", 0))
      {
        if (CFStringCompare(v6, @"зиновій", 0))
        {
          if (CFStringCompare(v6, @"младен", 0))
          {
            BOOL v72 = @"ма";
            uint64_t v73 = 0;
            uint64_t v71 = @"на";
            if (__CFStringHasOneOfSuffixes(v6, v7, v8, v9, v10, v11, v12, v13, @"ва")) {
              goto LABEL_7;
            }
            BOOL v72 = @"лля";
            uint64_t v73 = 0;
            uint64_t v71 = @"оя";
            if (__CFStringHasOneOfSuffixes(v6, v14, v15, v16, v17, v18, v19, v20, @"ія"))
            {
LABEL_22:
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                CFStringRef v24 = @"є";
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            BOOL v72 = @"по";
            uint64_t v73 = 0;
            uint64_t v70 = @"ро";
            uint64_t v71 = @"хіль";
            uint64_t v69 = @"ися";
            if (__CFStringHasOneOfSuffixes(v6, v33, v34, v35, v36, v37, v38, v39, @"ло"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                CFStringRef v24 = @"е";
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            uint64_t v71 = @"ся";
            BOOL v72 = 0;
            uint64_t v69 = @"ая";
            uint64_t v70 = @"тя";
            int64_t v67 = @"ль";
            int64_t v68 = @"ня";
            CFRange v65 = @"ь";
            BOOL v66 = @"ля";
            if (__CFStringHasOneOfSuffixes(v6, v40, v41, v42, v43, v44, v45, v46, @"й"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                CFStringRef v24 = @"ю";
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            if (CFStringHasSuffix(v6, @"я")) {
              goto LABEL_22;
            }
            uint64_t v71 = @"г";
            BOOL v72 = 0;
            if (__CFStringHasOneOfSuffixes(v6, v48, v49, v50, v51, v52, v53, v54, @"к"))
            {
              CFStringReplaceAll(v6, theString);
              UniChar chars = 1091;
              p_UniChar chars = &chars;
              goto LABEL_35;
            }
            if (CFStringHasSuffix(v6, @"ко"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                CFStringRef v24 = @"у";
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            if (CFStringHasSuffix(v6, @"ір"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 1)
              {
                v23.location = Length - 2;
                CFStringRef v24 = @"оре";
LABEL_45:
                uint64_t v47 = v6;
                v23.length = 2;
                goto LABEL_31;
              }
            }
            else
            {
              if (!CFStringHasSuffix(v6, @"ів"))
              {
                if (CFStringHasSuffix(v6, @"а"))
                {
LABEL_7:
                  CFStringReplaceAll(v6, theString);
                  CFIndex Length = CFStringGetLength(v6);
                  if (Length > 0)
                  {
                    v23.location = Length - 1;
                    CFStringRef v24 = @"о";
LABEL_30:
                    uint64_t v47 = v6;
                    v23.length = 1;
LABEL_31:
                    CFStringReplace(v47, v23, v24);
                    goto LABEL_18;
                  }
                  goto LABEL_53;
                }
                if (CFStringHasSuffix(v6, @"шан"))
                {
                  CFStringReplaceAll(v6, theString);
                  __int16 v75 = 1086;
                  p_UniChar chars = (UniChar *)&v75;
                }
                else
                {
                  uint64_t v71 = @"ц";
                  BOOL v72 = 0;
                  uint64_t v69 = @"б";
                  uint64_t v70 = @"ш";
                  int64_t v67 = @"д";
                  int64_t v68 = @"ф";
                  CFRange v65 = @"л";
                  BOOL v66 = @"п";
                  CFRange v64 = @"с";
                  if (!__CFStringHasOneOfSuffixes(v6, v56, v57, v58, v59, v60, v61, v62, @"н"))
                  {
                    CFRelease(v6);
                    return CFRetain(theString);
                  }
                  CFStringReplaceAll(v6, theString);
                  __int16 v74 = 1077;
                  p_UniChar chars = (UniChar *)&v74;
                }
LABEL_35:
                CFStringAppendCharacters(v6, p_chars, 1);
LABEL_18:
                CFTypeRef v31 = CFRetain(v6);
                CFRelease(v6);
                if (v31) {
                  return v31;
                }
                return CFRetain(theString);
              }
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 1)
              {
                v23.location = Length - 2;
                CFStringRef v24 = @"ове";
                goto LABEL_45;
              }
            }
LABEL_53:
            MEMORY[0x1F4188790](Length, v22.location);
            uint64_t v63 = &v64;
            __strlcpy_chk();
            __strlcat_chk();
            goto LABEL_54;
          }
          CFIndex v30 = CFStringGetLength(v6);
          CFStringReplaceAll(v6, theString);
          CFIndex v26 = v30 - 1;
          CFIndex Length = CFStringGetLength(v6);
          v22.location = Length - v26;
          if (Length < v26) {
            goto LABEL_53;
          }
          CFStringRef v27 = @"ладлене";
        }
        else
        {
          CFIndex v29 = CFStringGetLength(v6);
          CFStringReplaceAll(v6, theString);
          CFIndex v26 = v29 - 1;
          CFIndex Length = CFStringGetLength(v6);
          v22.location = Length - v26;
          if (Length < v26) {
            goto LABEL_53;
          }
          CFStringRef v27 = @"іновію";
        }
      }
      else
      {
        CFIndex v28 = CFStringGetLength(v6);
        CFStringReplaceAll(v6, theString);
        CFIndex v26 = v28 - 1;
        CFIndex Length = CFStringGetLength(v6);
        v22.location = Length - v26;
        if (Length < v26) {
          goto LABEL_53;
        }
        CFStringRef v27 = @"оране";
      }
    }
    else
    {
      CFIndex v25 = CFStringGetLength(v6);
      CFStringReplaceAll(v6, theString);
      CFIndex v26 = v25 - 1;
      CFIndex Length = CFStringGetLength(v6);
      v22.location = Length - v26;
      if (Length < v26) {
        goto LABEL_53;
      }
      CFStringRef v27 = @"редеріку";
    }
    v22.length = v26;
    CFStringReplace(v6, v22, v27);
    goto LABEL_18;
  }
  MEMORY[0x1F4188790](0, v5);
  uint64_t v63 = &v66;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_54:
  CFTypeRef result = (CFTypeRef)__strlcat_chk();
  qword_1EC093AA8 = (uint64_t)v63;
  __break(1u);
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_lt(CFStringRef theString, const __CFLocale *a2)
{
  v16[9] = *(void *)off_1ECE0A5B0;
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString);
  if (!MutableCopy)
  {
    MEMORY[0x1F4188790](0, v5);
    uint64_t v14 = v16;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_27;
  }
  uint64_t v6 = MutableCopy;
  CFStringLowercase(MutableCopy, a2);
  if (CFStringHasSuffix(v6, @"jas"))
  {
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.location = Length - 1;
      CFStringRef v10 = @"u";
LABEL_8:
      uint64_t v11 = v6;
      v9.length = 1;
LABEL_9:
      CFStringReplace(v11, v9, v10);
      goto LABEL_10;
    }
    goto LABEL_26;
  }
  if (CFStringHasSuffix(v6, @"as"))
  {
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.location = Length - 1;
      CFStringRef v10 = @"i";
      goto LABEL_8;
    }
    goto LABEL_26;
  }
  if (CFStringHasSuffix(v6, @"us"))
  {
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 1)
    {
      v9.location = Length - 2;
      CFStringRef v10 = @"au";
      uint64_t v11 = v6;
      v9.length = 2;
      goto LABEL_9;
    }
LABEL_26:
    MEMORY[0x1F4188790](Length, v8);
    uint64_t v14 = &v15;
    __strlcpy_chk();
    __strlcat_chk();
LABEL_27:
    __strlcat_chk();
    qword_1EC093AA8 = (uint64_t)v14;
    __break(1u);
  }
  if (!CFStringHasSuffix(v6, @"is") && !CFStringHasSuffix(v6, @"ys"))
  {
    if (!CFStringHasSuffix(v6, @"ė"))
    {
      CFRelease(v6);
      goto LABEL_22;
    }
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.location = Length - 1;
      CFStringRef v10 = @"e";
      goto LABEL_8;
    }
    goto LABEL_26;
  }
  CFStringReplaceAll(v6, theString);
  v18.location = CFStringGetLength(v6) - 1;
  v18.length = 1;
  CFStringDelete(v6, v18);
LABEL_10:
  CFTypeRef v12 = CFRetain(v6);
  CFRelease(v6);
  if (v12) {
    return v12;
  }
LABEL_22:

  return CFRetain(theString);
}

BOOL __CFStringHasOneOfSuffixes(CFStringRef theString, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13 = (CFStringRef *)&a9;
  do
  {
    CFStringRef v10 = v13++;
    CFStringRef v11 = *v10;
  }
  while (*v10 && !CFStringHasSuffix(theString, *v10));
  return v11 != 0;
}

uint64_t __CFStringApproximateSyllableCount_el_GR(const __CFString *a1)
{
  uint64_t v36 = *(void *)off_1ECE0A5B0;
  CFStringRef theString = a1;
  uint64_t v32 = 0;
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0;
  CFIndex v30 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  memset(v28, 0, sizeof(v28));
  unint64_t v34 = 0;
  int64_t v35 = 0;
  CFTypeRef v31 = CStringPtr;
  CFIndex v4 = Length;
  if (Length >= 1)
  {
    unint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    while (2)
    {
      if (v30)
      {
        UniChar v8 = v30[v32 + v5];
      }
      else if (v31)
      {
        UniChar v8 = v31[v32 + v5];
      }
      else
      {
        BOOL v9 = v35 > (uint64_t)v5 && v7 <= (uint64_t)v5;
        if (!v9)
        {
          unint64_t v10 = v5 - 4;
          if (v5 < 4) {
            unint64_t v10 = 0;
          }
          if ((uint64_t)(v10 + 64) < v4) {
            CFIndex v4 = v10 + 64;
          }
          unint64_t v34 = v10;
          int64_t v35 = v4;
          v37.location = v32 + v10;
          v37.length = v4 - v10;
          CFStringGetCharacters(theString, v37, (UniChar *)v28);
          uint64_t v7 = v34;
        }
        UniChar v8 = *((_WORD *)v28 + v5 - v7);
      }
      switch(v8)
      {
        case 0x3ACu:
        case 0x3ADu:
        case 0x3AEu:
        case 0x3AFu:
        case 0x3B7u:
        case 0x3C9u:
        case 0x3CCu:
        case 0x3CDu:
        case 0x3CEu:
          goto LABEL_20;
        case 0x3B0u:
        case 0x3B2u:
        case 0x3B3u:
        case 0x3B4u:
        case 0x3B6u:
        case 0x3B8u:
        case 0x3BAu:
        case 0x3BBu:
        case 0x3BCu:
        case 0x3BDu:
        case 0x3BEu:
        case 0x3C0u:
        case 0x3C1u:
        case 0x3C2u:
        case 0x3C3u:
        case 0x3C4u:
        case 0x3C6u:
        case 0x3C7u:
        case 0x3C8u:
        case 0x3CAu:
        case 0x3CBu:
          goto LABEL_21;
        case 0x3B1u:
        case 0x3B5u:
        case 0x3C5u:
          int64_t v11 = v5 + 1;
          CFIndex v12 = Length;
          if (Length <= (uint64_t)(v5 + 1)) {
            goto LABEL_20;
          }
          if (v30)
          {
            UniChar v13 = v30[v32 + v11];
          }
          else if (v31)
          {
            UniChar v13 = v31[v32 + v11];
          }
          else
          {
            if (v35 <= v11 || v7 > v11)
            {
              unint64_t v18 = v5 - 3;
              if (v5 < 3) {
                unint64_t v18 = 0;
              }
              if ((uint64_t)(v18 + 64) < Length) {
                CFIndex v12 = v18 + 64;
              }
              unint64_t v34 = v18;
              int64_t v35 = v12;
              v38.location = v32 + v18;
              v38.length = v12 - v18;
              CFStringGetCharacters(theString, v38, (UniChar *)v28);
              uint64_t v7 = v34;
            }
            UniChar v13 = *((_WORD *)v28 + v11 - v7);
          }
          if (v13 != 953 && v13 != 943) {
            goto LABEL_20;
          }
          goto LABEL_77;
        case 0x3B9u:
          int64_t v11 = v5 + 1;
          CFIndex v14 = Length;
          if (Length > (uint64_t)(v5 + 1))
          {
            if (v30)
            {
              UniChar v15 = v30[v32 + v11];
            }
            else if (v31)
            {
              UniChar v15 = v31[v32 + v11];
            }
            else
            {
              if (v35 <= v11 || v7 > v11)
              {
                unint64_t v19 = v5 - 3;
                if (v5 < 3) {
                  unint64_t v19 = 0;
                }
                if ((uint64_t)(v19 + 64) < Length) {
                  CFIndex v14 = v19 + 64;
                }
                unint64_t v34 = v19;
                int64_t v35 = v14;
                v39.location = v32 + v19;
                v39.length = v14 - v19;
                CFStringGetCharacters(theString, v39, (UniChar *)v28);
                uint64_t v7 = v34;
              }
              UniChar v15 = *((_WORD *)v28 + v11 - v7);
            }
            unsigned int v20 = v15 - 940;
            BOOL v9 = v20 > 0x22;
            uint64_t v21 = (1 << v20) & 0x420000021;
            if (!v9 && v21 != 0) {
              goto LABEL_77;
            }
          }
          goto LABEL_20;
        case 0x3BFu:
          int64_t v11 = v5 + 1;
          CFIndex v16 = Length;
          if (Length > (uint64_t)(v5 + 1))
          {
            if (v30)
            {
              UniChar v17 = v30[v32 + v11];
            }
            else if (v31)
            {
              UniChar v17 = v31[v32 + v11];
            }
            else
            {
              if (v35 <= v11 || v7 > v11)
              {
                unint64_t v23 = v5 - 3;
                if (v5 < 3) {
                  unint64_t v23 = 0;
                }
                if ((uint64_t)(v23 + 64) < Length) {
                  CFIndex v16 = v23 + 64;
                }
                unint64_t v34 = v23;
                int64_t v35 = v16;
                v40.location = v32 + v23;
                v40.length = v16 - v23;
                CFStringGetCharacters(theString, v40, (UniChar *)v28);
                uint64_t v7 = v34;
              }
              UniChar v17 = *((_WORD *)v28 + v11 - v7);
            }
            unsigned int v24 = v17 - 943;
            BOOL v9 = v24 > 0x1E;
            int v25 = (1 << v24) & 0x40400401;
            if (!v9 && v25 != 0) {
LABEL_77:
            }
              unint64_t v5 = v11;
          }
LABEL_20:
          ++v6;
          goto LABEL_21;
        default:
          if (!v8) {
            return v6;
          }
LABEL_21:
          ++v5;
          CFIndex v4 = Length;
          if (Length <= (uint64_t)v5) {
            return v6;
          }
          continue;
      }
    }
  }
  return 0;
}

uint64_t boundPairReadOpenComplete(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a3 + 4))
  {
    CFReadStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    if (boundPairReadCanRead(v10, a3)) {
      CFReadStreamSignalEvent(a1, 2uLL, 0, v11, v12, v13, v14, v15);
    }
    _wakeReadStreamScheduledRunLoops();
  }
  return 1;
}

const void *boundPairReadCopyProperty(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  CFAllocatorRef v3 = 0;
  if (a2 && a3)
  {
    if (*(void *)(a3 + 40) && CFStringCompare(@"_kCFStreamPropertyHTTPTrailer", a2, 1uLL) == kCFCompareEqualTo)
    {
      CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), a2);
      CFAllocatorRef v3 = Value;
      if (Value) {
        CFRetain(Value);
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

__CFDictionary *boundPairReadSetProperty(uint64_t a1, const __CFString *a2, const void *a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  CFComparisonResult v7 = CFStringCompare(@"_kCFStreamPropertyHTTPTrailer", a2, 1uLL);
  CFTypeRef result = 0;
  if (a4)
  {
    if (v7 == kCFCompareEqualTo)
    {
      CFTypeRef result = *(__CFDictionary **)(a4 + 40);
      if (result
        || (CFTypeRef result = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks), (*(void *)(a4 + 40) = result) != 0))
      {
        if (a3) {
          CFDictionarySetValue(result, a2, a3);
        }
        else {
          CFDictionaryRemoveValue(result, a2);
        }
        return (__CFDictionary *)1;
      }
    }
  }
  return result;
}

void boundPairReadUnschedule(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    int v4 = *(__int16 *)(a4 + 4);
    BOOL v5 = __OFSUB__(v4, 1);
    int v6 = v4 - 1;
    if (v6 < 0 == v5) {
      *(_WORD *)(a4 + 4) = v6;
    }
  }
}

void *setupScheduledStreamCloseBlock(void *result, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  CFComparisonResult v7 = result;
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  *CFComparisonResult v7 = cf;
  if (a3) {
    CFTypeRef result = CFRetain(a3);
  }
  v7[1] = a3;
  if (a4) {
    CFTypeRef result = CFRetain(a4);
  }
  v7[2] = a4;
  return result;
}

uint64_t boundPairWriteOpenComplete(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a3 + 52))
  {
    CFWriteStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    CFWriteStreamSignalEvent(a1, 4uLL, 0, v9, v10, v11, v12, v13);
    _wakeWriteStreamScheduledRunLoops();
  }
  return 1;
}

BOOL boundPairCanWrite(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (*(unsigned char *)(a2 + 48)) {
    return 0;
  }
  return _cbCanWrite(*(void *)(a2 + 96));
}

uint64_t (**__CFStringEncodingGetSimplifiedChineseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter)
  {
    __CFStringEncodingIsDecomposableCharacter = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter = (_UNKNOWN *)a2(2);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_1 = (_UNKNOWN *)a2(3);
    __CFStringEncodingPrecomposeLatinCharacter_3 = (_UNKNOWN *)a2(4);
  }
  int v4 = __CFConverterEUC_CN;
  BOOL v5 = __CFConverterMacSimplifiedChinese;
  if (a1 != 25) {
    BOOL v5 = 0;
  }
  if (a1 != 2352) {
    int v4 = v5;
  }
  if (a1 == 2565) {
    return __CFConverterGB_HZ;
  }
  else {
    return v4;
  }
}

uint64_t __CFToEUC_CN(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 < 0x80)
  {
    uint64_t result = 1;
    goto LABEL_3;
  }
  if ((unsigned __int16)(a2 + 15) < 0xB3u) {
    return 0;
  }
  int v4 = (unsigned __int16 *)&__CFToGB2312CharMap;
  BOOL v5 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (1)
  {
    uint64_t v6 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v5 - v4)) >> 1;
    CFComparisonResult v7 = &v4[17 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    BOOL v5 = v7 - 17;
LABEL_10:
    if (v4 > v5) {
      return 0;
    }
  }
  if (v8 + 16 <= a2)
  {
    int v4 = v7 + 17;
    goto LABEL_10;
  }
  unsigned __int16 v9 = v4[17 * v6 + 1 + (int)(a2 - v8)];
  if (!v9 || v9 == 65533) {
    return 0;
  }
  LOBYTE(a2) = v9 | 0x80;
  *a3++ = (unsigned __int16)(v9 | 0x8080) >> 8;
  uint64_t result = 2;
LABEL_3:
  *a3 = a2;
  return result;
}

uint64_t __CFFromEUC_CN(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4)
{
  unsigned __int16 v4 = *a2;
  if ((*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1;
  }
  uint64_t result = 0;
  if (a3 >= 2 && (v4 + 1) >= 0xA2u)
  {
    unsigned int v6 = a2[1] & 0x7F | ((v4 & 0x7F) << 8);
    if ((unsigned __int16)(v6 - 30594) < 0xA99Fu) {
      goto LABEL_12;
    }
    CFComparisonResult v7 = (unsigned __int16 *)&__CFFromGB2312CharMap;
    unsigned int v8 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + 15906);
    while (1)
    {
      uint64_t v9 = (0xF83E0F83E0F83E1 * (v8 - v7)) >> 1;
      uint64_t v10 = &v7[33 * v9];
      unsigned int v11 = *v10;
      if (v11 <= v6)
      {
        if (v11 + 32 > v6)
        {
          unsigned __int16 v12 = v7[33 * v9 + 1 + (int)(v6 - v11)];
          if (v12)
          {
            *a4 = v12;
            if (v12 != 65533) {
              return 2;
            }
            return 0;
          }
LABEL_12:
          *a4 = -3;
          return 0;
        }
        CFComparisonResult v7 = v10 + 33;
      }
      else
      {
        unsigned int v8 = v10 - 33;
      }
      if (v7 > v8) {
        goto LABEL_12;
      }
    }
  }
  return result;
}

uint64_t __CFToEUC_CNLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    unsigned int v4 = *a2++;
    if (v4 < 0x80) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = 2;
    }
    result += v5;
  }
  return result;
}

uint64_t __CFFromEUC_CNLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    BOOL v5 = a3 == 1 || *a2 >= 0;
    BOOL v6 = !v5;
    if (v5) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    a2 += v7;
    if (v6) {
      uint64_t v8 = -2;
    }
    else {
      uint64_t v8 = -1;
    }
    ++result;
    BOOL v9 = __OFADD__(v8, a3);
    a3 += v8;
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFToEUC_CNPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  unsigned int v9 = *a2;
  if (v9 > 0x7F)
  {
    int v11 = a2[1];
    if (v9 == 12454) {
      int v12 = 12532;
    }
    else {
      int v12 = v9 + 1;
    }
    int v13 = v9 + 2;
    if (v11 != 12442) {
      int v13 = 65533;
    }
    if (v11 == 12441) {
      unsigned int v14 = v12;
    }
    else {
      unsigned int v14 = v13;
    }
    if ((v9 & 0xFFFFFFDF) == 0x418) {
      int v15 = v9 + 1;
    }
    else {
      int v15 = -3;
    }
    if (v9 == 1077) {
      int v16 = 1105;
    }
    else {
      int v16 = -3;
    }
    if (v9 == 1045) {
      unsigned int v17 = 1025;
    }
    else {
      unsigned int v17 = v16;
    }
    if (v11 != 776) {
      unsigned int v17 = 65533;
    }
    if (v11 == 774) {
      unsigned int v17 = v15;
    }
    if (a2[1] <= 0x3098u) {
      uint64_t v10 = v17;
    }
    else {
      uint64_t v10 = v14;
    }
  }
  else
  {
    uint64_t v10 = __CFStringEncodingPrecomposeLatinCharacter_3(a2, a3, 0);
  }
  int v18 = __CFToEUC_CN(v10, (unsigned __int16)v10, v22);
  char v19 = v22[0];
  if (v18) {
    BOOL v20 = v22[0] == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    uint64_t result = 2;
    *a6 = 2;
    if (!a5) {
      return result;
    }
    if (a5 >= 2)
    {
      *a4 = v19;
      a4[1] = v22[1];
      return 2;
    }
  }
  return 0;
}

uint64_t __CFIsValidCombiningCharSimplifiedChinese(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1 << (a1 - 6)) & 0x4000000000005) != 0
    || (a1 - 12441) < 2)
  {
    return 1;
  }
  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_1();
  }
}

uint64_t __CFToMacSimplifiedChinese(char a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v58[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v19 = 0;
    uint64_t v12 = 0;
    goto LABEL_171;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v55 = a3 + 1;
  int v13 = (unsigned __int16 *)&__CFToMacSimplifiedChineseMap;
  while (1)
  {
    if (!a5 || v11 < a5) {
      goto LABEL_15;
    }
    if ((a1 & 0x10) == 0) {
      goto LABEL_170;
    }
    uint64_t v14 = *a2;
    if ((v14 - 774) <= 0x32 && ((1 << (v14 - 6)) & 0x4000000000005) != 0
      || (v14 - 12441) < 2)
    {
      goto LABEL_16;
    }
    unsigned int v17 = (char *)v13;
    char IsValidCombiningCharacterForLatin1_1 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(*a2, 1, 0x4000000000005);
    int v13 = (unsigned __int16 *)v17;
    if ((IsValidCombiningCharacterForLatin1_1 & 1) == 0)
    {
      uint64_t v14 = *a2;
      if ((v14 & 0xFFF0) != 0xF870) {
        goto LABEL_170;
      }
    }
    else
    {
LABEL_15:
      uint64_t v14 = *a2;
      if (v14 < 0x80) {
        goto LABEL_18;
      }
    }
LABEL_16:
    if (a1 < 0 && (unsigned __int16)(v14 - 131) <= 0x1Cu)
    {
LABEL_18:
      uint64_t v19 = v11 + 1;
      if (a5) {
        *a4++ = v14;
      }
      goto LABEL_55;
    }
    if (v12 + 1 < a3 && v14 == 252)
    {
      if ((__int16)a2[1] == -1921)
      {
        uint64_t v19 = v11 + 1;
        if (a5) {
          *a4++ = 0x80;
        }
        ++a2;
        ++v12;
        goto LABEL_55;
      }
      goto LABEL_27;
    }
    if ((unsigned __int16)(v14 + 443) < 0x25Bu) {
      break;
    }
LABEL_27:
    BOOL v20 = v13 + 78;
    uint64_t v21 = v13;
    while (1)
    {
      uint64_t v22 = ((char *)v20 - (char *)v21) >> 3;
      uint64_t v23 = &v21[2 * v22];
      unsigned int v24 = *v23;
      if (v24 <= v14) {
        break;
      }
      BOOL v20 = v23 - 2;
LABEL_32:
      if (v21 > v20) {
        goto LABEL_33;
      }
    }
    if (v24 < v14)
    {
      uint64_t v21 = v23 + 2;
      goto LABEL_32;
    }
    LODWORD(v21) = v21[2 * v22 + 1];
    if (v21 > 0xFF)
    {
      uint64_t v19 = v11 + 2;
      if (a5)
      {
        if (v19 > a5) {
          goto LABEL_170;
        }
        *a4 = BYTE1(v21);
        goto LABEL_127;
      }
    }
    else
    {
      uint64_t v19 = v11 + 1;
      if (a5) {
        *a4++ = (_BYTE)v21;
      }
    }
LABEL_55:
    ++a2;
    ++v12;
    uint64_t v11 = v19;
    if (v12 >= a3) {
      goto LABEL_171;
    }
  }
LABEL_33:
  if ((unsigned __int16)(v14 + 15) < 0xB3u) {
    goto LABEL_51;
  }
  uint64_t v21 = (unsigned __int16 *)&__CFToGB2312CharMap;
  int v25 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (2)
  {
    uint64_t v26 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v25 - v21)) >> 1;
    CFStringRef v27 = &v21[17 * v26];
    unsigned int v28 = *v27;
    if (v28 > v14)
    {
      int v25 = v27 - 17;
      goto LABEL_39;
    }
    if (v28 + 16 <= v14)
    {
      uint64_t v21 = v27 + 17;
LABEL_39:
      if (v21 > v25) {
        goto LABEL_51;
      }
      continue;
    }
    break;
  }
  LOWORD(v21) = v21[17 * v26 + 1 + (int)(v14 - v28)];
  if ((_WORD)v21) {
    BOOL v29 = (unsigned __int16)v21 == 65533;
  }
  else {
    BOOL v29 = 1;
  }
  if (!v29)
  {
    uint64_t v19 = v11 + 2;
    if (a5)
    {
      if (v19 > a5) {
        goto LABEL_170;
      }
      *a4 = BYTE1(v21) | 0x80;
      LOBYTE(v21) = v21 | 0x80;
LABEL_127:
      a4[1] = (_BYTE)v21;
      a4 += 2;
    }
    goto LABEL_55;
  }
LABEL_51:
  if ((a1 & 8) != 0 || v12 < 1) {
    goto LABEL_170;
  }
  if ((a1 & 0x10) == 0)
  {
LABEL_54:
    uint64_t v19 = v11;
    goto LABEL_55;
  }
  uint64_t v56 = a4;
  if ((int)v14 > 823)
  {
    if ((v14 - 12441) >= 2 && v14 != 824) {
      goto LABEL_71;
    }
  }
  else
  {
    if (v14 == 768)
    {
      if (*(a2 - 1) == 110)
      {
        uint64_t v19 = v11 + 1;
        if (a5) {
          *(_WORD *)(a4++ - 1) = -16472;
        }
        goto LABEL_55;
      }
      goto LABEL_71;
    }
    if (v14 != 774 && v14 != 776)
    {
LABEL_71:
      CFIndex v30 = (char *)v13;
      int v31 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v14, 1, 0x4000000000005);
      int v13 = (unsigned __int16 *)v30;
      a4 = v56;
      if (!v31)
      {
        if (v14 == 63615)
        {
          if (*(a2 - 1) != 252) {
            goto LABEL_170;
          }
          uint64_t v19 = v11 - 1;
          if (a5) {
            *(v56 - 2) = 0x80;
          }
          a4 = v56 - 1;
          goto LABEL_55;
        }
        if (v14 != 63614) {
          goto LABEL_170;
        }
        unsigned int v52 = *(a2 - 1);
        if (v52 > 0xFF00)
        {
          if (*(a2 - 1) <= 0xFF19u)
          {
            if (v52 == 65281)
            {
              char v53 = -34;
            }
            else
            {
              if (v52 != 65292) {
                goto LABEL_170;
              }
              char v53 = -39;
            }
          }
          else
          {
            switch(v52)
            {
              case 0xFF1Au:
                char v53 = -36;
                break;
              case 0xFF1Bu:
                char v53 = -35;
                break;
              case 0xFF1Fu:
                char v53 = -33;
                break;
              default:
                goto LABEL_170;
            }
          }
        }
        else if (*(a2 - 1) <= 0x3001u)
        {
          if (v52 == 8943)
          {
            char v53 = -13;
          }
          else
          {
            if (v52 != 12289) {
              goto LABEL_170;
            }
            char v53 = -37;
          }
        }
        else
        {
          switch(v52)
          {
            case 0x3002u:
              char v53 = -38;
              break;
            case 0x3016u:
              char v53 = -20;
              break;
            case 0x3017u:
              char v53 = -19;
              break;
            default:
              goto LABEL_170;
          }
        }
        if (a5)
        {
          *(v56 - 2) = -90;
          *(v56 - 1) = v53;
        }
        goto LABEL_54;
      }
    }
  }
  v58[0] = 2;
  uint64_t v33 = a2 - 1;
  unsigned int v32 = *(a2 - 1);
  if (v32 < 0x80)
  {
    unint64_t v34 = (char *)v13;
    unsigned __int16 v35 = __CFStringEncodingPrecomposeLatinCharacter_3(a2 - 1, v55 - v12, v58);
    int v13 = (unsigned __int16 *)v34;
    uint64_t v36 = v58[0] - 2;
    if (v58[0] <= 2) {
      uint64_t v37 = 0;
    }
    else {
      uint64_t v37 = v58[0] - 2;
    }
    goto LABEL_76;
  }
  unsigned int v38 = *a2;
  if (v38 > 0x3098)
  {
    if (v38 != 12441)
    {
      if (v38 == 12442)
      {
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        unsigned __int16 v35 = v32 + 2;
        goto LABEL_76;
      }
      goto LABEL_172;
    }
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    if (v32 == 12454) {
      unsigned __int16 v35 = 12532;
    }
    else {
      unsigned __int16 v35 = v32 + 1;
    }
LABEL_76:
    v12 += v37;
    if (v35 != 252)
    {
      a4 = v56;
      goto LABEL_95;
    }
    a4 = v56;
    if (v12 >= a3) {
      goto LABEL_95;
    }
    if ((__int16)a2[1] == -1921)
    {
      if (a5) {
        *(v56 - 1) = 0x80;
      }
      ++v12;
      goto LABEL_54;
    }
    unsigned __int16 v35 = 252;
LABEL_98:
    CFRange v40 = v13 + 78;
    uint64_t v41 = v13;
    while (1)
    {
      uint64_t v42 = ((char *)v40 - (char *)v41) >> 3;
      uint64_t v43 = &v41[2 * v42];
      unsigned int v44 = *v43;
      if (v44 <= v35)
      {
        if (v44 >= v35)
        {
          if (a5)
          {
            if (v11 >= a5) {
              goto LABEL_170;
            }
            *(_WORD *)(a4++ - 1) = __rev16(v41[2 * v42 + 1]);
          }
          uint64_t v19 = v11 + 1;
          goto LABEL_55;
        }
        uint64_t v41 = v43 + 2;
      }
      else
      {
        CFRange v40 = v43 - 2;
      }
      if (v41 > v40) {
        goto LABEL_104;
      }
    }
  }
  if (v38 == 774)
  {
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    if ((v32 & 0xFFFFFFDF) == 0x418) {
      unsigned __int16 v35 = v32 + 1;
    }
    else {
      unsigned __int16 v35 = -3;
    }
    goto LABEL_76;
  }
  if (v38 != 776)
  {
LABEL_172:
    uint64_t v36 = 0;
    goto LABEL_173;
  }
  uint64_t v36 = 0;
  if (v32 == 1077) {
    __int16 v39 = 1105;
  }
  else {
    __int16 v39 = -3;
  }
  if (v32 == 1045) {
    unsigned __int16 v35 = 1025;
  }
  else {
    unsigned __int16 v35 = v39;
  }
LABEL_95:
  if ((unsigned __int16)(v35 + 443) >= 0x25Bu) {
    goto LABEL_98;
  }
LABEL_104:
  if ((unsigned __int16)(v35 + 15) < 0xB3u) {
    goto LABEL_173;
  }
  uint64_t v45 = (unsigned __int16 *)&__CFToGB2312CharMap;
  uint64_t v46 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (1)
  {
    uint64_t v47 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v46 - v45)) >> 1;
    uint64_t v48 = &v45[17 * v47];
    unsigned int v49 = *v48;
    if (v49 <= v35) {
      break;
    }
    uint64_t v46 = v48 - 17;
LABEL_110:
    if (v45 > v46) {
      goto LABEL_173;
    }
  }
  if (v49 + 16 <= v35)
  {
    uint64_t v45 = v48 + 17;
    goto LABEL_110;
  }
  unsigned __int16 v50 = v45[17 * v47 + 1 + (int)(v35 - v49)];
  if (!v50 || v50 == 65533)
  {
LABEL_173:
    v12 -= v36;
    *a6 = v11;
    return v12;
  }
  if (!a5)
  {
LABEL_147:
    if (*v33 >= 0x80u) {
      uint64_t v19 = v11;
    }
    else {
      uint64_t v19 = v11 + 1;
    }
    goto LABEL_55;
  }
  if (*v33 > 0x7Fu)
  {
    *(a4 - 2) = HIBYTE(v50) | 0x80;
    *(a4 - 1) = v50 | 0x80;
    goto LABEL_147;
  }
  if (v11 < a5)
  {
    *(a4 - 1) = HIBYTE(v50) | 0x80;
    *a4 = v50 | 0x80;
    goto LABEL_147;
  }
LABEL_170:
  uint64_t v19 = v11;
LABEL_171:
  *a6 = v19;
  return v12;
}

uint64_t __CFFromMacSimplifiedChinese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v55 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = a1 & 0xC0;
  if ((a1 & 0x200) != 0) {
    uint64_t v15 = 2;
  }
  else {
    uint64_t v15 = 3;
  }
  if ((a1 & 0x200) != 0) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = 2;
  }
  p_superclass = &OBJC_METACLASS___CFPDCloudSource.superclass;
  while (2)
  {
    if (a5 && v12 >= a5) {
      return v13;
    }
    int v18 = (char)*a2;
    int v19 = *a2;
    if ((v18 & 0x80000000) == 0 || v18 == -96 || (a1 & 0x80) != 0 && (v19 + 125) <= 0x1Cu) {
      goto LABEL_15;
    }
    if (v19 == 128)
    {
      if (v14)
      {
        if (!a5)
        {
          uint64_t v22 = a4;
          uint64_t v23 = v15;
          goto LABEL_64;
        }
        if (v12 + v15 > a5) {
          return v13;
        }
        *(_DWORD *)a4 = 50856053;
        uint64_t v22 = a4 + 2;
        if ((a1 & 0x200) != 0)
        {
          uint64_t v23 = 2;
          goto LABEL_64;
        }
        uint64_t v23 = 3;
      }
      else
      {
        if (!a5)
        {
          uint64_t v22 = a4;
          uint64_t v23 = v16;
          goto LABEL_64;
        }
        if (v12 + v16 > a5) {
          return v13;
        }
        *a4 = 252;
        uint64_t v22 = a4 + 1;
        if ((a1 & 0x200) != 0)
        {
          uint64_t v23 = 1;
          goto LABEL_64;
        }
        uint64_t v23 = 2;
      }
      *uint64_t v22 = -1921;
      uint64_t v22 = &a4[v23];
LABEL_64:
      v12 += v23;
      a4 = v22;
LABEL_18:
      uint64_t v20 = 1;
      goto LABEL_19;
    }
    if ((v19 + 3) <= 0x85u)
    {
      if (*a2 > 0xFCu)
      {
        if (v19 == 253)
        {
          LOWORD(v19) = 169;
        }
        else if (v19 == 254)
        {
          LOWORD(v19) = 8482;
        }
        else
        {
          LOWORD(v19) = 8230;
        }
        goto LABEL_15;
      }
      if (v19 == 129)
      {
        if ((a1 & 0x200) == 0)
        {
          LOWORD(v19) = -1920;
          goto LABEL_15;
        }
      }
      else if (v19 == 130 && (a1 & 0x200) == 0)
      {
        LOWORD(v19) = -1919;
LABEL_15:
        if (a5) {
          *a4++ = v19;
        }
        ++v12;
        goto LABEL_18;
      }
      uint64_t v20 = 1;
      goto LABEL_20;
    }
    if (v9 < 2) {
      return v13;
    }
    if (v19 == 161)
    {
      int v24 = a2[1];
      __int16 v25 = 183;
      switch(a2[1])
      {
        case 0xA4u:
          goto LABEL_107;
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
          break;
        case 0xAAu:
          __int16 v25 = 8212;
          goto LABEL_107;
        case 0xABu:
          __int16 v25 = 12316;
          goto LABEL_107;
        case 0xACu:
          __int16 v25 = 8214;
          goto LABEL_107;
        case 0xADu:
          __int16 v25 = 8943;
          goto LABEL_107;
        default:
          if (v24 == 233)
          {
            __int16 v25 = 162;
            goto LABEL_107;
          }
          if (v24 == 234)
          {
            __int16 v25 = 163;
            goto LABEL_107;
          }
          break;
      }
    }
    else
    {
      if (v19 == 163)
      {
        int v24 = a2[1];
        if (v24 != 164)
        {
          if (v24 == 254)
          {
            __int16 v25 = 8254;
            goto LABEL_107;
          }
          goto LABEL_54;
        }
        __int16 v25 = 165;
LABEL_107:
        if (a5) {
          *a4++ = v25;
        }
        goto LABEL_109;
      }
      int v24 = a2[1];
    }
LABEL_54:
    unsigned int v26 = v24 & 0x7F | ((v19 & 0x7F) << 8);
    if ((unsigned __int16)((v24 & 0x7F | ((v19 & 0x7F) << 8)) - 30594) < 0xA99Fu) {
      break;
    }
    CFStringRef v27 = (unsigned __int16 *)&__CFFromGB2312CharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + 15906);
    while (1)
    {
      uint64_t v29 = (0xF83E0F83E0F83E1 * (v28 - v27)) >> 1;
      CFIndex v30 = &v27[33 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v26) {
        break;
      }
      unsigned int v28 = v30 - 33;
LABEL_60:
      if (v27 > v28) {
        goto LABEL_79;
      }
    }
    if (v31 + 32 <= v26)
    {
      CFStringRef v27 = v30 + 33;
      goto LABEL_60;
    }
    unsigned __int16 v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      if (v14)
      {
        uint64_t v51 = v15;
        uint64_t v53 = v16;
        int IsDecomposableCharacter = __CFStringEncodingIsDecomposableCharacter(v32, (a1 >> 7) & 1);
        uint64_t v15 = v51;
        uint64_t v16 = v53;
        if (IsDecomposableCharacter)
        {
          uint64_t v44 = __CFStringEncodingDecomposeCharacter(a1, v32, v54, v53);
          uint64_t v45 = *a6;
          uint64_t v12 = *a6 + v44;
          *a6 = v12;
          if (!a5)
          {
            uint64_t v20 = 2;
            uint64_t v15 = v51;
            uint64_t v16 = v53;
            p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
            goto LABEL_20;
          }
          if (v12 > a5)
          {
            *a6 = v45;
            return v13;
          }
          uint64_t v15 = v51;
          uint64_t v16 = v53;
          p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
          if (v44 >= 1)
          {
            unint64_t v46 = v44 + 1;
            uint64_t v47 = v54;
            do
            {
              __int16 v48 = *v47++;
              *a4++ = v48;
              --v46;
            }
            while (v46 > 1);
          }
          uint64_t v20 = 2;
LABEL_20:
          v13 += v20;
          a2 += v20;
          BOOL v21 = (uint64_t)v9 <= v20;
          v9 -= v20;
          if (v21) {
            return v13;
          }
          continue;
        }
      }
      if (a5) {
        *a4++ = v32;
      }
      p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
      uint64_t v12 = *a6;
LABEL_109:
      ++v12;
      uint64_t v20 = 2;
      goto LABEL_19;
    }
    break;
  }
LABEL_79:
  if (v19 == 168)
  {
    if ((v24 + 69) > 5u) {
      return v13;
    }
    int v40 = __CFFromMacSimplifiedChineseMapA8[v24 - 187];
    if (v14)
    {
      uint64_t v52 = v16;
      int v50 = v14;
      uint64_t v41 = v15;
      if (((uint64_t (*)(void, void))p_superclass[432])((unsigned __int16)__CFFromMacSimplifiedChineseMapA8[v24 - 187], (a1 >> 7) & 1))
      {
        __CFStringEncodingDecomposeCharacter(a1, (unsigned __int16)v40, v54, v42);
        uint64_t v12 = *a6 + 2;
        if (!a5)
        {
          uint64_t v20 = 2;
          uint64_t v15 = v41;
          int v14 = v50;
          uint64_t v16 = v52;
          p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
          goto LABEL_19;
        }
        uint64_t v16 = v52;
        p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
        if (v12 <= a5)
        {
          uint64_t v15 = v41;
          *a4 = v54[0];
          a4[1] = v54[1];
          a4 += 2;
          uint64_t v20 = 2;
          int v14 = v50;
          goto LABEL_19;
        }
        return v13;
      }
      uint64_t v12 = *a6;
      uint64_t v15 = v41;
      int v14 = v50;
      uint64_t v16 = v52;
      p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
    }
    if (!a5) {
      goto LABEL_109;
    }
    if (v12 < a5)
    {
      *a4++ = v40;
      goto LABEL_109;
    }
  }
  else if (v19 == 166 && (v24 + 39) <= 0x1Cu)
  {
    unsigned int v34 = v24 - 217;
    unint64_t v35 = 0x418007FuLL >> v34;
    int v36 = ((a1 & 0x200) == 0) & (0x418007FuLL >> v34);
    if (v36) {
      uint64_t v37 = 2;
    }
    else {
      uint64_t v37 = 1;
    }
    v12 += v37;
    if (!a5) {
      goto LABEL_102;
    }
    if (v12 <= a5)
    {
      unsigned int v38 = __CFFromMacSimplifiedChineseMapA6[v34];
      unsigned int v39 = HIWORD(v38);
      if ((v35 & 1) == 0) {
        LOWORD(v39) = v38;
      }
      *a4 = v39;
      if (v36)
      {
        a4[1] = v38;
        a4 += 2;
      }
      else
      {
        ++a4;
      }
LABEL_102:
      uint64_t v20 = 2;
LABEL_19:
      *a6 = v12;
      goto LABEL_20;
    }
  }
  return v13;
}

uint64_t __CFFromMacSimplifiedChineseLen(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if ((*a2 & 0x80) != 0
      && (*a2 - 129 <= 0x1F ? (BOOL v4 = ((1 << (*a2 + 127)) & 0x80000003) == 0) : (BOOL v4 = 1),
          v4 ? (BOOL v5 = (unint64_t)a3 >= 2) : (BOOL v5 = 0),
          v5 && *a2 < 0xFDu))
    {
      int v6 = *a2;
      uint64_t v7 = a3 - 1;
      if (v6 == 128) {
        uint64_t v8 = a2 + 1;
      }
      else {
        uint64_t v8 = a2 + 2;
      }
      if (v6 == 128)
      {
        uint64_t v9 = result + 1;
      }
      else
      {
        uint64_t v7 = a3 - 2;
        uint64_t v9 = result;
      }
      if (v6 == 161) {
        a2 += 2;
      }
      else {
        a2 = v8;
      }
      if (v6 == 161) {
        a3 -= 2;
      }
      else {
        a3 = v7;
      }
      if (v6 == 161) {
        ++result;
      }
      else {
        uint64_t result = v9;
      }
    }
    else
    {
      ++a2;
      --a3;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t __CFToGB_HZ(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  unint64_t v7 = (unint64_t)a2;
  v83[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v10 = 0;
    uint64_t v15 = a2;
    goto LABEL_138;
  }
  uint64_t v10 = 0;
  unint64_t v11 = (unint64_t)&a2[a3];
  if (a5) {
    uint64_t v12 = -1;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v76 = v12;
  uint64_t v13 = 0x8EA4u;
  uint64_t v14 = 1;
  uint64_t v15 = (unsigned __int16 *)v7;
  uint64_t v16 = "~{";
  while (2)
  {
    if (a5 && v10 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_114;
      }
      uint64_t v17 = *v15;
      if ((v17 - 774) <= 0x32 && ((1 << (v17 - 6)) & 0x4000000000005) != 0
        || (v17 - 12441) < 2)
      {
        goto LABEL_38;
      }
      unint64_t v20 = v11;
      unint64_t v77 = v7;
      uint64_t v80 = v10;
      BOOL v21 = v16;
      uint64_t v22 = a1;
      uint64_t v23 = a5;
      uint64_t v24 = v14;
      int IsValidCombiningCharacterForLatin1_1 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v17, v11, v13);
      uint64_t v14 = v24;
      a5 = v23;
      a1 = v22;
      uint64_t v16 = v21;
      unint64_t v7 = v77;
      uint64_t v10 = v80;
      uint64_t v13 = 36516;
      unint64_t v11 = v20;
      if (!IsValidCombiningCharacterForLatin1_1) {
        goto LABEL_114;
      }
    }
    uint64_t v17 = *v15;
    if (v17 <= 0x7F)
    {
      uint64_t v26 = v10 + 2;
      if (v14)
      {
        uint64_t v26 = v10;
        CFStringRef v27 = 0;
      }
      else
      {
        CFStringRef v27 = "~}";
      }
      unsigned int v28 = "~";
      if ((v14 & 1) == 0) {
        unsigned int v28 = "~}~";
      }
      if (v17 == 126) {
        uint64_t v29 = v26 + 1;
      }
      else {
        uint64_t v29 = v26;
      }
      if (v17 == 126) {
        CFIndex v30 = v28;
      }
      else {
        CFIndex v30 = v27;
      }
      uint64_t v10 = v29 + 1;
      if (a5)
      {
        if (v29 >= a5)
        {
          if (((v17 != 126) & v14) != 0) {
            size_t v74 = -1;
          }
          else {
            size_t v74 = ~strlen(v30);
          }
          v10 += v74;
          goto LABEL_138;
        }
        if (((v17 != 126) & v14) == 0)
        {
          char v31 = *v30;
          if (*v30)
          {
            unsigned __int16 v32 = (unsigned __int8 *)(v30 + 1);
            do
            {
              *a4++ = v31;
              int v33 = *v32++;
              char v31 = v33;
            }
            while (v33);
          }
        }
        *a4++ = v17;
      }
      uint64_t v14 = 1;
      goto LABEL_110;
    }
LABEL_38:
    if ((unsigned __int16)(v17 + 15) < 0xB3u) {
      break;
    }
    unsigned int v34 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + v13);
    unint64_t v35 = (unsigned __int16 *)&__CFToGB2312CharMap;
    while (1)
    {
      uint64_t v36 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v34 - v35)) >> 1;
      uint64_t v37 = &v35[17 * v36];
      unsigned int v38 = *v37;
      if (v38 <= v17) {
        break;
      }
      unsigned int v34 = v37 - 17;
LABEL_44:
      if (v35 > v34) {
        goto LABEL_51;
      }
    }
    if (v38 + 16 <= v17)
    {
      unint64_t v35 = v37 + 17;
      goto LABEL_44;
    }
    unsigned __int16 v39 = v35[17 * v36 + 1 + (int)(v17 - v38)];
    if (v39) {
      BOOL v40 = v39 == 65533;
    }
    else {
      BOOL v40 = 1;
    }
    if (!v40)
    {
      uint64_t v65 = v10 + 2;
      if ((v14 & 1) == 0) {
        uint64_t v65 = v10;
      }
      uint64_t v10 = v65 + 2;
      if (!a5)
      {
        uint64_t v14 = 0;
        goto LABEL_110;
      }
      if (v10 > a5)
      {
        uint64_t v75 = -2;
        if (v14) {
          uint64_t v75 = -4;
        }
        uint64_t v68 = v10 + v75;
        v10 += v75 + 2;
LABEL_116:
        if (v10 <= a5)
        {
          *(_WORD *)a4 = 32126;
        }
        else
        {
          if ((unint64_t)v15 > v7)
          {
            for (--v15; ; --v15)
            {
              uint64_t v69 = *v15;
              if (((v69 - 774) > 0x32 || ((1 << (v69 - 6)) & 0x4000000000005) == 0)
                && (v69 - 12441) >= 2)
              {
                if (__CFStringEncodingIsValidCombiningCharacterForLatin1_1(v69, v11, v13)) {
                  BOOL v72 = (unint64_t)v15 > v7;
                }
                else {
                  BOOL v72 = 0;
                }
                if (!v72) {
                  break;
                }
              }
              else if ((unint64_t)v15 <= v7)
              {
                break;
              }
            }
          }
          if ((unint64_t)v15 <= v7 || *(v15 - 1) > 0x7Fu)
          {
            *((_WORD *)a4 - 1) = 32126;
            uint64_t v10 = v68;
          }
          else
          {
            uint64_t v10 = v68 - 4;
          }
        }
        goto LABEL_138;
      }
      if (v14)
      {
        uint64_t v66 = 0;
        char v67 = 126;
        do
        {
          a4[v66] = v67;
          char v67 = v16[++v66];
        }
        while (v66 != 2);
        a4 += 2;
      }
      uint64_t v14 = 0;
      *a4 = HIBYTE(v39) & 0x7F;
      a4[1] = v39 & 0x7F;
      a4 += 2;
LABEL_110:
      if ((unint64_t)++v15 >= v11)
      {
LABEL_114:
        if (v14) {
          goto LABEL_138;
        }
        uint64_t v68 = v10;
        v10 += 2;
        if (!a5) {
          goto LABEL_138;
        }
        goto LABEL_116;
      }
      continue;
    }
    break;
  }
LABEL_51:
  if ((a1 & 8) != 0 || (unint64_t)v15 <= v7) {
    goto LABEL_114;
  }
  if ((a1 & 0x10) == 0) {
    goto LABEL_110;
  }
  v83[0] = 0;
  if (((v17 - 774) > 0x32 || ((1 << (v17 - 6)) & 0x4000000000005) == 0)
    && (v17 - 12441) >= 2)
  {
    unint64_t v41 = v11;
    unint64_t v78 = v7;
    uint64_t v81 = v10;
    uint64_t v42 = v16;
    uint64_t v43 = a1;
    uint64_t v44 = a5;
    uint64_t v45 = v14;
    int v46 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v17, v11, v13);
    uint64_t v14 = v45;
    a5 = v44;
    a1 = v43;
    uint64_t v16 = v42;
    unint64_t v7 = v78;
    uint64_t v10 = v81;
    uint64_t v13 = 36516;
    unint64_t v11 = v41;
    if (!v46) {
      goto LABEL_114;
    }
  }
  unsigned int v47 = *(v15 - 1);
  if (v47 <= 0x7F)
  {
    unint64_t v79 = v11;
    uint64_t v82 = v10;
    __int16 v48 = v16;
    unint64_t v49 = v7;
    uint64_t v50 = a1;
    uint64_t v51 = a5;
    uint64_t v52 = v14;
    unsigned __int16 v53 = __CFStringEncodingPrecomposeLatinCharacter_3(v15 - 1, (uint64_t)(v11 - (void)(v15 - 1)) >> 1, v83);
    uint64_t v14 = v52;
    a5 = v51;
    a1 = v50;
    unint64_t v7 = v49;
    uint64_t v16 = v48;
    unint64_t v11 = v79;
    uint64_t v10 = v82;
    uint64_t v13 = 0x8EA4u;
    goto LABEL_60;
  }
  unsigned int v60 = *v15;
  if (v60 <= 0x3098)
  {
    if (v60 == 774)
    {
      if ((v47 & 0xFFFFFFDF) != 0x418) {
        goto LABEL_114;
      }
      unsigned __int16 v53 = v47 + 1;
    }
    else
    {
      if (v60 != 776) {
        goto LABEL_114;
      }
      if (v47 == 1077) {
        __int16 v61 = 1105;
      }
      else {
        __int16 v61 = -3;
      }
      if (v47 == 1045) {
        unsigned __int16 v53 = 1025;
      }
      else {
        unsigned __int16 v53 = v61;
      }
    }
    goto LABEL_61;
  }
  if (v60 == 12441)
  {
    if (v47 != 12454)
    {
      unsigned __int16 v53 = v47 + 1;
      goto LABEL_60;
    }
    unsigned int v54 = 12532;
    unsigned __int16 v53 = 12532;
  }
  else
  {
    if (v60 != 12442) {
      goto LABEL_114;
    }
    unsigned __int16 v53 = v47 + 2;
LABEL_60:
    if (!v53) {
      goto LABEL_114;
    }
LABEL_61:
    if ((unsigned __int16)(v53 + 15) < 0xB3u) {
      goto LABEL_114;
    }
    unsigned int v54 = v53;
  }
  uint64_t v55 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + v13);
  uint64_t v56 = (unsigned __int16 *)&__CFToGB2312CharMap;
  while (2)
  {
    uint64_t v57 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v55 - v56)) >> 1;
    uint64_t v58 = &v56[17 * v57];
    unsigned int v59 = *v58;
    if (v59 > v53)
    {
      uint64_t v55 = v58 - 17;
      goto LABEL_68;
    }
    if (v59 + 16 <= v54)
    {
      uint64_t v56 = v58 + 17;
LABEL_68:
      if (v56 > v55) {
        goto LABEL_114;
      }
      continue;
    }
    break;
  }
  unsigned __int16 v62 = v56[17 * v57 + 1 + (int)(v54 - v59)];
  if (v62) {
    BOOL v63 = v62 == 65533;
  }
  else {
    BOOL v63 = 1;
  }
  if (v63) {
    goto LABEL_114;
  }
  if ((v14 & 1) == 0) {
    goto LABEL_87;
  }
  if ((unint64_t)(v15 - 2) >= v7 && *(v15 - 2) >= 0x80u)
  {
    --v10;
    a4 += v76;
LABEL_87:
    uint64_t v64 = v10;
    if (!a5)
    {
LABEL_109:
      uint64_t v10 = v64;
      goto LABEL_110;
    }
LABEL_108:
    *(a4 - 2) = HIBYTE(v62) & 0x7F;
    *(a4 - 1) = v62 & 0x7F;
    goto LABEL_109;
  }
  uint64_t v64 = v10 + 3;
  if (!a5) {
    goto LABEL_109;
  }
  if (v64 <= a5)
  {
    *(_WORD *)(a4 - 1) = 31614;
    a4 += 3;
    goto LABEL_108;
  }
LABEL_138:
  *a6 = v10;
  return (uint64_t)((uint64_t)v15 - v7) >> 1;
}

unsigned char *__CFFromGB_HZ(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, void *a6)
{
  uint64_t v42 = *(void *)off_1ECE0A5B0;
  unint64_t v9 = (unint64_t)&a2[a3];
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    char v14 = 1;
    uint64_t v22 = a2;
    if (a5) {
      goto LABEL_75;
    }
    goto LABEL_80;
  }
  uint64_t v12 = 0;
  int v13 = a1 & 0xC0;
  char v14 = 1;
  uint64_t v15 = 0x3E22u;
  p_superclass = &OBJC_METACLASS___CFPDCloudSource.superclass;
  uint64_t v17 = a2;
LABEL_3:
  char v18 = v14;
  if (a5) {
    BOOL v19 = v12 < a5;
  }
  else {
    BOOL v19 = 1;
  }
  int v20 = v19;
  BOOL v21 = v17;
  while (1)
  {
    if (!v20)
    {
      char v14 = v18;
      uint64_t v22 = v17;
      if (a5) {
        goto LABEL_75;
      }
      goto LABEL_80;
    }
    uint64_t v22 = v21 + 1;
    int v23 = *v21;
    if ((v14 & 1) == 0) {
      break;
    }
    if (v23 != 126)
    {
      ++v12;
      if (a5) {
        *a4++ = v23;
      }
LABEL_52:
      uint64_t v17 = v22;
      if ((unint64_t)v22 >= v9) {
        goto LABEL_74;
      }
      goto LABEL_3;
    }
    if ((unint64_t)v22 >= v9) {
      goto LABEL_71;
    }
    uint64_t v22 = v21 + 2;
    int v24 = v21[1];
    if (v24 == 10)
    {
      v21 += 2;
LABEL_25:
      char v14 = 1;
      goto LABEL_26;
    }
    if (v24 != 123)
    {
      if (v24 != 126)
      {
LABEL_71:
        char v14 = 1;
        goto LABEL_73;
      }
      if (a5) {
        *a4++ = 126;
      }
      ++v12;
      goto LABEL_52;
    }
    char v14 = 0;
    v21 += 2;
LABEL_26:
    if ((unint64_t)v21 >= v9) {
      goto LABEL_73;
    }
  }
  if (v23 == 126)
  {
    if ((unint64_t)v22 >= v9)
    {
      if ((a1 & 1) == 0) {
        goto LABEL_72;
      }
    }
    else if ((a1 & 1) == 0 && *v22 != 125)
    {
      goto LABEL_72;
    }
    v21 += 2;
    goto LABEL_25;
  }
  if ((unint64_t)v22 >= v9) {
    goto LABEL_48;
  }
  unsigned int v25 = *v22 & 0x7F | ((v23 & 0x7F) << 8);
  if ((unsigned __int16)(v25 - 30594) < 0xA99Fu) {
    goto LABEL_48;
  }
  uint64_t v26 = (unsigned __int16 *)&__CFFromGB2312CharMap;
  CFStringRef v27 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + v15);
  while (2)
  {
    uint64_t v28 = (0xF83E0F83E0F83E1 * (v27 - v26)) >> 1;
    uint64_t v29 = &v26[33 * v28];
    unsigned int v30 = *v29;
    if (v30 > v25)
    {
      CFStringRef v27 = v29 - 33;
      goto LABEL_37;
    }
    if (v30 + 32 <= v25)
    {
      uint64_t v26 = v29 + 33;
LABEL_37:
      if (v26 > v27) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
  unsigned __int16 v31 = v26[33 * v28 + 1 + (int)(v25 - v30)];
  if (v31) {
    BOOL v32 = v31 == 65533;
  }
  else {
    BOOL v32 = 1;
  }
  if (v32)
  {
LABEL_48:
    if ((a1 & 1) == 0)
    {
      char v14 = 0;
      if (a5) {
        goto LABEL_75;
      }
      goto LABEL_80;
    }
    if (a5) {
      *a4++ = 63;
    }
    ++v12;
    uint64_t v22 = v21 + 2;
    goto LABEL_52;
  }
  if (!v13
    || (unsigned int v39 = v31,
        unsigned __int16 v40 = v31,
        int v33 = ((uint64_t (*)(void))p_superclass[432])(),
        unsigned __int16 v31 = v40,
        p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8),
        uint64_t v15 = 15906,
        !v33))
  {
    if (a5) {
      *a4++ = v31;
    }
    uint64_t v35 = v12 + 1;
LABEL_65:
    uint64_t v22 = v21 + 2;
    uint64_t v12 = v35;
    goto LABEL_52;
  }
  int v34 = __CFStringEncodingDecomposeCharacter(a1, v39, v41, 15906);
  uint64_t v35 = v12 + (unsigned __int16)v34;
  if (!a5)
  {
    uint64_t v15 = 15906;
    p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
    goto LABEL_65;
  }
  if (v35 <= a5)
  {
    uint64_t v15 = 15906;
    p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
    if ((_WORD)v34)
    {
      uint64_t v36 = (__int16 *)v41;
      do
      {
        --v34;
        unsigned __int16 v37 = *v36++;
        *a4++ = v37;
      }
      while ((_WORD)v34);
    }
    goto LABEL_65;
  }
LABEL_72:
  char v14 = 0;
LABEL_73:
  uint64_t v22 = v21;
LABEL_74:
  if (a5)
  {
LABEL_75:
    if ((v14 & 1) == 0 && v12 == a5 && v9 - (void)v22 == 2 && *v22 == 126) {
      v22 += 2 * (v22[1] == 125);
    }
  }
LABEL_80:
  *a6 = v12;
  return (unsigned char *)(v22 - a2);
}

CFTypeRef __CFStringCreateImmutableFunnel2(__objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, char a9, __objc2_class **a10)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | (2 * (a6 != 0)) | (a7 != 0) | (8 * (a8 != 0)) | (16 * (a9 != 0)), a10, 0);
}

CFStringRef CFStringCreateWithPascalStringNoCopy(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)pStr, *pStr + 1, *(uint64_t *)&encoding, 0x14u, (__objc2_class **)contentsDeallocator, 0);
}

CFTypeRef _CFStringCreateWithBytesNoCopy(__objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, __objc2_class **a6)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | 0x12u, a6, 0);
}

CFStringRef __CFStringMakeConstantString(const char *cStr)
{
  uint64_t v39 = *(void *)off_1ECE0A5B0;
  if (!constantStringTable)
  {
    CFDictionaryKeyCallBacks keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1ECE0FFB8;
    *(_OWORD *)&valueCallBacks.version = *(_OWORD *)&kCFTypeDictionaryValueCallBacks.version;
    *(_OWORD *)&valueCallBacks.release = *(_OWORD *)&kCFTypeDictionaryValueCallBacks.release;
    valueCallBacks.equal = 0;
    CFMutableDictionaryRef v2 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &keyCallBacks, &valueCallBacks);
    _CFDictionarySetCapacity((unint64_t)v2, 2500);
    os_unfair_lock_lock_with_options();
    if (!constantStringTable) {
      constantStringTable = (uint64_t)v2;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
    if ((CFMutableDictionaryRef)constantStringTable != v2) {
      CFRelease(v2);
    }
  }
  os_unfair_lock_lock_with_options();
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)constantStringTable, cStr);
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
  if (!Value)
  {
    BOOL v4 = cStr;
    while (1)
    {
      int v5 = *v4;
      if (!*v4) {
        break;
      }
      ++v4;
      if (v5 < 0)
      {
        CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
        char v13 = *cStr;
        if (*cStr)
        {
          char v14 = cStr + 1;
          do
          {
            if (v13 < 0) {
              CFStringAppendFormat(Mutable, 0, @"\\%3o", v13);
            }
            else {
              CFStringAppendFormat(Mutable, 0, @"%1c", v13);
            }
            int v15 = *(unsigned __int8 *)v14++;
            char v13 = v15;
          }
          while (v15);
        }
        CFLog(4, @"WARNING: CFSTR(\"%@\") has non-7 bit chars, interpreting using MacOS Roman encoding for now, but this will change. Please eliminate usages of non-7 bit chars (including escaped characters above \\177 octal) in CFSTR().", v6, v7, v8, v9, v10, v11, (__int16)Mutable);
        CFRelease(Mutable);
        break;
      }
    }
    size_t v16 = strlen(cStr);
    ImmutableFunnel3 = (unint64_t *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, (int8x16_t *)cStr, v16, 0, 8u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
    if (!ImmutableFunnel3) {
      __CFStringMakeConstantString_cold_1(0, v18, v19, v20, v21, v22, v23, v24);
    }
    unsigned int v25 = ImmutableFunnel3;
    int v26 = CF_IS_OBJC(7uLL, (unint64_t)ImmutableFunnel3);
    if (v26) {
      goto LABEL_27;
    }
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    char v27 = atomic_load(v25 + 1);
    if ((v27 & 0x10) != 0
      || ((v28 = atomic_load(v25 + 1), uint64_t v29 = v25 + 2, (v28 & 0x60) == 0)
        ? (v31 = atomic_load(v25 + 1), unsigned int v30 = &v29[(v31 & 5) != 4])
        : (unsigned int v30 = (void *)*v29),
          unint64_t v32 = atomic_load(v25 + 1),
          !v30))
    {
LABEL_27:
      size_t v34 = strlen(cStr) + 1;
      uint64_t Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v34, 1041838444, 0);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      strlcpy(Typed, cStr, v34);
    }
    else
    {
      uint64_t Typed = (char *)v30 + ((v32 >> 2) & 1);
    }
    os_unfair_lock_lock_with_options();
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)constantStringTable);
    CFDictionaryAddValue((CFMutableDictionaryRef)constantStringTable, Typed, v25);
    if (CFDictionaryGetCount((CFDictionaryRef)constantStringTable) == Count)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)constantStringTable, Typed);
    }
    else
    {
      CFStringRef Value = (const __CFString *)v25;
      if (!v26)
      {
        CFStringRef Value = (const __CFString *)v25;
        if (!__CFRuntimeIsImmortal((uint64_t)v25))
        {
          __CFRuntimeSetImmortal((uint64_t)v25);
          CFStringRef Value = (const __CFString *)v25;
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
    CFRelease(v25);
  }
  return Value;
}

CFTypeRef __cStrCopyDescription(int8x16_t *__s)
{
  uint64_t v2 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    uint64_t v2 = __CFDefaultEightBitStringEncoding;
  }
  size_t v3 = strlen(__s->i8);

  return __CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, __s, v3, v2, 0x18u, &__kCFAllocatorNull, 0);
}

BOOL __cStrEqual(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t __cStrHash(const char *a1)
{
  uint64_t v1 = a1;
  int64_t v2 = strlen(a1);
  if (v2 > 4)
  {
    uint64_t v6 = v1[1] + (uint64_t)*v1 + ((uint64_t)*v1 << 8);
    uint64_t v7 = v6 + v1[v2 - 2] + (v6 << 8);
    uint64_t v4 = v7 + v1[v2 - 1] + (v7 << 8);
  }
  else if (v2)
  {
    int v3 = v2;
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *v1++;
      uint64_t v4 = 257 * v4 + v5;
      --v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v4 = 0;
  }
  return (v4 << (v2 & 0x1F)) + v4;
}

uint64_t _CFStrSetDesiredCapacity(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(result + 40) & 0xFLL | (16 * a2);
  return result;
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  v25[1] = *(void *)off_1ECE0A5B0;
  uint64_t v4 = bufferSize - 1;
  if (bufferSize < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)&encoding;
  v25[0] = 0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    CFIndex Length = CFStringGetLength(theString);
    if (Length <= 255)
    {
LABEL_41:
      v26.location = 0;
      v26.length = Length;
      CFIndex v24 = __CFStringEncodeByteStream(theString, v26, 0, v5, 0, (UniChar *)(buffer + 1), v4, v25);
      Boolean result = 0;
      BOOL v16 = v24 == Length;
      LOBYTE(Length) = 0;
      if (v16)
      {
        Boolean result = 1;
        LOBYTE(Length) = v25[0];
      }
      goto LABEL_44;
    }
    return 0;
  }
  char v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    uint64_t v12 = *p_data;
  }
  else
  {
    char v13 = atomic_load((unint64_t *)&theString->info);
    uint64_t v12 = (char *)&p_data[(v13 & 5) != 4];
  }
  char v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) == 4)
  {
    CFIndex Length = *v12;
  }
  else
  {
    char v15 = atomic_load((unint64_t *)&theString->info);
    BOOL v16 = (v15 & 0x60) == 0;
    uint64_t v17 = 24;
    if (v16) {
      uint64_t v17 = 16;
    }
    CFIndex Length = *(CFIndex *)((char *)&theString->isa + v17);
    if (Length > 255) {
      return 0;
    }
  }
  char v18 = atomic_load((unint64_t *)&theString->info);
  if ((v18 & 0x10) != 0) {
    goto LABEL_41;
  }
  int v19 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v19 = __CFDefaultEightBitStringEncoding;
  }
  if (v19 != v5)
  {
    if (v19 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v19 = __CFDefaultEightBitStringEncoding;
    }
    if (v19 != 1536) {
      goto LABEL_41;
    }
    switch(BYTE1(v5))
    {
      case 0:
        if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || v5 == 152) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 1:
        if (v5 != 134217984) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 2:
        if (v5 == 518) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 6:
        if (v5 != 1536) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 8:
      case 0xC:
        goto LABEL_41;
      case 0xA:
        if ((v5 - 2561) > 0xF) {
          goto LABEL_17;
        }
        int v22 = 1 << (v5 - 1);
        int v23 = 32785;
        break;
      case 0xB:
        if ((v5 - 3059) > 0xC) {
          goto LABEL_17;
        }
        int v22 = 1 << (v5 + 13);
        int v23 = 4099;
        break;
      default:
        if (((unsigned __int16)v5 & 0xFF00u) > 0xC00) {
          goto LABEL_41;
        }
        goto LABEL_17;
    }
    if ((v22 & v23) != 0) {
      goto LABEL_41;
    }
  }
LABEL_17:
  if (Length >= bufferSize) {
    return 0;
  }
  unint64_t v20 = atomic_load((unint64_t *)&theString->info);
  memmove(buffer + 1, &v12[(v20 >> 2) & 1], Length);
  Boolean result = 1;
LABEL_44:
  *buffer = Length;
  return result;
}

uint64_t _CFStringCompareForHFS(__CFString *a1, __CFString *a2, __int16 a3)
{
  uint64_t v138 = *(void *)off_1ECE0A5B0;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(a1);
  uint64_t v6 = CFStringGetCharactersPtr(a2);
  if (CharactersPtr)
  {
    uint64_t CStringPtrInternal = 0;
  }
  else
  {
    unsigned int v8 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unsigned int v8 = __CFDefaultEightBitStringEncoding;
    }
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)a1, v8, 1, 1);
  }
  uint64_t v105 = CStringPtrInternal;
  if (v6)
  {
    uint64_t v106 = 0;
  }
  else
  {
    unsigned int v9 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unsigned int v9 = __CFDefaultEightBitStringEncoding;
    }
    uint64_t v106 = _CFStringGetCStringPtrInternal((unint64_t *)a2, v9, 1, 1);
    uint64_t CStringPtrInternal = v105;
  }
  if ((a3 & 0x10) == 0 || CStringPtrInternal && v106)
  {
    uint64_t BitmapPtrForPlane = 0;
    uint64_t v101 = 0;
    int v10 = 1;
  }
  else
  {
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x65u, 0);
    if (BitmapPtrForPlane)
    {
      uint64_t v101 = CFUniCharGetBitmapPtrForPlane(8u, 0);
      int v10 = 0;
    }
    else
    {
      uint64_t BitmapPtrForPlane = 0;
      uint64_t v101 = 0;
      int v10 = 1;
    }
    uint64_t CStringPtrInternal = v105;
  }
  unint64_t v11 = (unint64_t)CharactersPtr | CStringPtrInternal;
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v12 = CFStringGetLength(a2);
  uint64_t v137 = 0;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  *(_OWORD *)CFStringRef theString = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v127 = 0u;
  long long v128 = 0u;
  *(_OWORD *)buffer = 0u;
  uint64_t v125 = 0;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v121 = 0u;
  *(_OWORD *)v122 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  *(_OWORD *)v114 = 0u;
  if (((v10 ^ 1) & 1) != 0 || !v11)
  {
    theString[0] = a1;
    *((void *)&v135 + 1) = 0;
    *(void *)&long long v136 = Length;
    CFStringRef v13 = (const __CFString *)CFStringGetCharactersPtr(a1);
    uint64_t v14 = 0;
    theString[1] = v13;
    if (!v13) {
      uint64_t v14 = _CFStringGetCStringPtrInternal((unint64_t *)a1, 0x600u, 1, 1);
    }
    uint64_t v137 = 0;
    *(void *)&long long v135 = v14;
    *((void *)&v136 + 1) = 0;
  }
  uint64_t v15 = v106;
  if ((unint64_t)v6 | v106) {
    int v16 = v10 ^ 1;
  }
  else {
    int v16 = 1;
  }
  if (v16 == 1)
  {
    v122[0] = a2;
    *((void *)&v123 + 1) = 0;
    *(void *)&long long v124 = v12;
    CFStringRef v17 = (const __CFString *)CFStringGetCharactersPtr(a2);
    uint64_t v18 = 0;
    v122[1] = v17;
    if (!v17) {
      uint64_t v18 = _CFStringGetCStringPtrInternal((unint64_t *)a2, 0x600u, 1, 1);
    }
    uint64_t v125 = 0;
    *(void *)&long long v123 = v18;
    *((void *)&v124 + 1) = 0;
    uint64_t v15 = v106;
  }
  CFIndex v19 = Length;
  BOOL v20 = Length > 0;
  BOOL v21 = v12 > 0;
  if (Length < 1)
  {
    uint64_t v22 = v105;
  }
  else
  {
    char v102 = v10;
    uint64_t v22 = v105;
    if (v12 >= 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      p_info = &OBJC_METACLASS_____NSCFAttributedString.info;
      do
      {
        uint64_t v26 = -v24;
        uint64_t v27 = v24 + 64;
        do
        {
          if ((unint64_t)v24 >= 4) {
            uint64_t v28 = 4;
          }
          else {
            uint64_t v28 = v24;
          }
          if (CharactersPtr)
          {
            UniChar v29 = CharactersPtr[v24];
          }
          else if (v22)
          {
            UniChar v29 = *((_WORD *)&p_info[479]->flags + *(unsigned __int8 *)(v22 + v24));
          }
          else if (v24 < 0 || (uint64_t v30 = v136, (uint64_t)v136 <= v24))
          {
            UniChar v29 = 0;
          }
          else if (theString[1])
          {
            UniChar v29 = *((_WORD *)&theString[1]->isa + v24 + *((void *)&v135 + 1));
          }
          else if ((void)v135)
          {
            UniChar v29 = *(char *)(v135 + *((void *)&v135 + 1) + v24);
          }
          else
          {
            if (v137 <= v24 || (uint64_t v32 = *((void *)&v136 + 1), *((uint64_t *)&v136 + 1) > v24))
            {
              uint64_t v33 = -v28;
              uint64_t v34 = v28 + v26;
              uint64_t v35 = v27 - v28;
              uint64_t v36 = v24 + v33;
              uint64_t v37 = v36 + 64;
              if (v36 + 64 >= (uint64_t)v136) {
                uint64_t v37 = v136;
              }
              *((void *)&v136 + 1) = v36;
              uint64_t v137 = v37;
              if ((uint64_t)v136 >= v35) {
                uint64_t v30 = v35;
              }
              v139.length = v30 + v34;
              v139.location = v36 + *((void *)&v135 + 1);
              CFStringGetCharacters(theString[0], v139, buffer);
              p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
              CFIndex v19 = Length;
              uint64_t v22 = v105;
              uint64_t v15 = v106;
              uint64_t v32 = *((void *)&v136 + 1);
            }
            UniChar v29 = buffer[v24 - v32];
          }
          unsigned int v31 = v29;
          if (__CFHFSLowerTable[HIBYTE(v29)]) {
            UniChar v29 = __CFHFSLowerTable[__CFHFSLowerTable[HIBYTE(v29)] + v29];
          }
          if (++v24 >= v19) {
            break;
          }
          --v26;
          ++v27;
        }
        while (!v29);
        unsigned int v38 = v29;
        uint64_t v39 = v24 - 1;
        uint64_t v40 = -v23;
        uint64_t v41 = v23 + 64;
        do
        {
          if ((unint64_t)v23 >= 4) {
            uint64_t v42 = 4;
          }
          else {
            uint64_t v42 = v23;
          }
          if (v6)
          {
            UniChar v43 = v6[v23];
          }
          else if (v15)
          {
            UniChar v43 = *((_WORD *)&p_info[479]->flags + *(unsigned __int8 *)(v15 + v23));
          }
          else if (v23 < 0 || (uint64_t v44 = v124, (uint64_t)v124 <= v23))
          {
            UniChar v43 = 0;
          }
          else if (v122[1])
          {
            UniChar v43 = *((_WORD *)&v122[1]->isa + v23 + *((void *)&v123 + 1));
          }
          else if ((void)v123)
          {
            UniChar v43 = *(char *)(v123 + *((void *)&v123 + 1) + v23);
          }
          else
          {
            if (v125 <= v23 || (uint64_t v46 = *((void *)&v124 + 1), *((uint64_t *)&v124 + 1) > v23))
            {
              uint64_t v47 = -v42;
              uint64_t v48 = v42 + v40;
              uint64_t v49 = v41 - v42;
              uint64_t v50 = v23 + v47;
              uint64_t v51 = v50 + 64;
              if (v50 + 64 >= (uint64_t)v124) {
                uint64_t v51 = v124;
              }
              *((void *)&v124 + 1) = v50;
              uint64_t v125 = v51;
              uint64_t v108 = v39;
              if ((uint64_t)v124 >= v49) {
                uint64_t v44 = v49;
              }
              v140.length = v44 + v48;
              unsigned int v100 = v38;
              v140.location = v50 + *((void *)&v123 + 1);
              CFStringGetCharacters(v122[0], v140, v114);
              unsigned int v38 = v100;
              uint64_t v39 = v108;
              p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
              CFIndex v19 = Length;
              uint64_t v22 = v105;
              uint64_t v15 = v106;
              uint64_t v46 = *((void *)&v124 + 1);
            }
            UniChar v43 = v114[v23 - v46];
          }
          unsigned int v45 = v43;
          if (__CFHFSLowerTable[HIBYTE(v43)]) {
            UniChar v43 = __CFHFSLowerTable[__CFHFSLowerTable[HIBYTE(v43)] + v43];
          }
          if (++v23 >= v12) {
            break;
          }
          --v40;
          ++v41;
        }
        while (!v43);
        if (a3) {
          unsigned int v52 = v38;
        }
        else {
          unsigned int v52 = v31;
        }
        if (a3) {
          unsigned int v53 = v43;
        }
        else {
          unsigned int v53 = v45;
        }
        if (v52 == v53) {
          goto LABEL_154;
        }
        char v54 = v102;
        if ((v53 | v52) < 0x80) {
          char v54 = 1;
        }
        if (v54) {
          goto LABEL_240;
        }
        if (v24 < v19 && (v52 & 0xFC00) == 0xD800)
        {
          if (CharactersPtr)
          {
            UniChar v55 = CharactersPtr[v24];
          }
          else if (v22)
          {
            UniChar v55 = *((_WORD *)&p_info[479]->flags + *(unsigned __int8 *)(v22 + v24));
          }
          else
          {
            if (v39 < -1) {
              goto LABEL_108;
            }
            uint64_t v71 = v136;
            if ((uint64_t)v136 <= v24) {
              goto LABEL_108;
            }
            if (theString[1])
            {
              UniChar v55 = *((_WORD *)&theString[1]->isa + *((void *)&v135 + 1) + v24);
            }
            else if ((void)v135)
            {
              UniChar v55 = *(char *)(v135 + *((void *)&v135 + 1) + v24);
            }
            else
            {
              if (v137 <= v24 || (uint64_t v73 = *((void *)&v136 + 1), *((uint64_t *)&v136 + 1) > v24))
              {
                uint64_t v74 = v24 - 4;
                if ((unint64_t)v24 < 4) {
                  uint64_t v74 = 0;
                }
                unsigned int v75 = v52;
                if (v74 + 64 < (uint64_t)v136) {
                  uint64_t v71 = v74 + 64;
                }
                *((void *)&v136 + 1) = v74;
                uint64_t v137 = v71;
                uint64_t v76 = v39;
                v141.location = *((void *)&v135 + 1) + v74;
                v141.length = v71 - v74;
                CFStringGetCharacters(theString[0], v141, buffer);
                unsigned int v52 = v75;
                uint64_t v39 = v76;
                p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
                uint64_t v15 = v106;
                uint64_t v73 = *((void *)&v136 + 1);
              }
              UniChar v55 = buffer[v24 - v73];
            }
          }
          if (v55 >> 10 == 55) {
            unsigned int v52 = (v52 << 10) - 56613888 + v55;
          }
        }
LABEL_108:
        unsigned int v109 = v52;
        if (v23 >= v12 || (v53 & 0xFC00) != 0xD800)
        {
          uint64_t v56 = v39;
          goto LABEL_117;
        }
        uint64_t v56 = v39;
        if (v6)
        {
          UniChar v57 = v6[v23];
        }
        else if (v15)
        {
          UniChar v57 = *((_WORD *)&p_info[479]->flags + *(unsigned __int8 *)(v15 + v23));
        }
        else
        {
          if (v23 - 1 < -1) {
            goto LABEL_117;
          }
          uint64_t v72 = v124;
          if ((uint64_t)v124 <= v23) {
            goto LABEL_117;
          }
          if (v122[1])
          {
            UniChar v57 = *((_WORD *)&v122[1]->isa + *((void *)&v123 + 1) + v23);
          }
          else if ((void)v123)
          {
            UniChar v57 = *(char *)(v123 + *((void *)&v123 + 1) + v23);
          }
          else
          {
            if (v125 <= v23 || (uint64_t v77 = *((void *)&v124 + 1), *((uint64_t *)&v124 + 1) > v23))
            {
              uint64_t v78 = v23 - 4;
              if ((unint64_t)v23 < 4) {
                uint64_t v78 = 0;
              }
              if (v78 + 64 < (uint64_t)v124) {
                uint64_t v72 = v78 + 64;
              }
              *((void *)&v124 + 1) = v78;
              uint64_t v125 = v72;
              v142.location = *((void *)&v123 + 1) + v78;
              v142.length = v72 - v78;
              CFStringGetCharacters(v122[0], v142, v114);
              unsigned int v52 = v109;
              uint64_t v77 = *((void *)&v124 + 1);
            }
            UniChar v57 = v114[v23 - v77];
          }
        }
        if (v57 >> 10 == 55) {
          unsigned int v53 = (v53 << 10) - 56613888 + v57;
        }
LABEL_117:
        uint64_t v58 = BitmapPtrForPlane;
        if (v52 >= 0x10000)
        {
          uint64_t v58 = CFUniCharGetBitmapPtrForPlane(0x65u, HIWORD(v52));
          unsigned int v52 = v109;
        }
        if (!v58 || ((*(unsigned __int8 *)(v58 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
        {
          uint64_t v59 = BitmapPtrForPlane;
          if (v53 >= 0x10000)
          {
            uint64_t v59 = CFUniCharGetBitmapPtrForPlane(0x65u, HIWORD(v53));
            unsigned int v52 = v109;
          }
          if (!v59 || ((*(unsigned __int8 *)(v59 + ((unsigned __int16)v53 >> 3)) >> (v53 & 7)) & 1) == 0)
          {
            uint64_t v60 = v101;
            if (v52 >= 0x10000)
            {
              uint64_t v60 = CFUniCharGetBitmapPtrForPlane(8u, HIWORD(v52));
              unsigned int v52 = v109;
            }
            if (!v60 || ((*(unsigned __int8 *)(v60 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0) {
              goto LABEL_240;
            }
            uint64_t v61 = v101;
            if (v53 >= 0x10000)
            {
              uint64_t v61 = CFUniCharGetBitmapPtrForPlane(8u, HIWORD(v53));
              unsigned int v52 = v109;
            }
            if (!v61 || ((*(unsigned __int8 *)(v61 + ((unsigned __int16)v53 >> 3)) >> (v53 & 7)) & 1) == 0) {
              goto LABEL_240;
            }
          }
        }
        uint64_t v110 = 0;
        uint64_t v111 = 0;
        uint64_t v62 = __CFStringFoldCharacterClusterAtIndex(v52, buffer, v56, 16, 0, __s1, &v111, 0);
        unsigned int v63 = v53;
        uint64_t v64 = v62;
        unsigned int v65 = v63;
        uint64_t v66 = __CFStringFoldCharacterClusterAtIndex(v63, v114, v23 - 1, 16, 0, __s2, &v110, 0);
        uint64_t v67 = v66;
        if (v64 && v64 == v66)
        {
          int v68 = memcmp(__s1, __s2, 4 * v64);
          unsigned int v52 = v109;
          if (v68) {
            goto LABEL_140;
          }
        }
        else
        {
          unsigned int v52 = v109;
          if (v64 || v66 != 1 || v109 != __s2[0])
          {
LABEL_140:
            if (v67 || v64 != 1 || v65 != __s1[0])
            {
              unsigned int v53 = v65;
LABEL_240:
              BOOL v93 = v52 >= v53;
LABEL_241:
              if (v93) {
                return 1;
              }
              else {
                return -1;
              }
            }
          }
        }
        if (v52 < 0x10000) {
          uint64_t v69 = 1;
        }
        else {
          uint64_t v69 = 2;
        }
        if (v64) {
          uint64_t v69 = v111;
        }
        uint64_t v24 = v69 + v24 - 1;
        if (v65 < 0x10000) {
          uint64_t v70 = 1;
        }
        else {
          uint64_t v70 = 2;
        }
        if (v67) {
          uint64_t v70 = v110;
        }
        uint64_t v23 = v70 + v23 - 1;
        uint64_t v22 = v105;
        uint64_t v15 = v106;
        CFIndex v19 = Length;
        p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFAttributedString + 32);
LABEL_154:
        BOOL v21 = v23 < v12;
        BOOL v20 = v24 < v19;
      }
      while (v24 < v19 && v23 < v12);
    }
  }
  if (v20 || v21)
  {
    if (v21) {
      return -1;
    }
    else {
      return 1;
    }
  }
  else
  {
    if ((a3 & 0x200) != 0)
    {
      uint64_t v80 = 0;
      uint64_t v81 = 0;
      if (v19 >= v12) {
        CFIndex v82 = v12;
      }
      else {
        CFIndex v82 = v19;
      }
      uint64_t v83 = 64;
      uint64_t v84 = &OBJC_METACLASS_____NSCFAttributedString.info;
      while (1)
      {
        uint64_t v85 = (unint64_t)v81 >= 4 ? 4 : v81;
        uint64_t v86 = -v85;
        uint64_t v87 = v85 + v80;
        uint64_t v88 = v83 - v85;
        if (CharactersPtr)
        {
          UniChar v89 = CharactersPtr[v81];
        }
        else if (v22)
        {
          UniChar v89 = *((_WORD *)&v84[479]->flags + *(unsigned __int8 *)(v22 + v81));
        }
        else
        {
          uint64_t v90 = v136;
          if ((uint64_t)v136 <= v81)
          {
            UniChar v89 = 0;
          }
          else if (theString[1])
          {
            UniChar v89 = *((_WORD *)&theString[1]->isa + v81 + *((void *)&v135 + 1));
          }
          else if ((void)v135)
          {
            UniChar v89 = *(char *)(v135 + *((void *)&v135 + 1) + v81);
          }
          else
          {
            if (v137 <= v81 || (uint64_t v94 = *((void *)&v136 + 1), *((uint64_t *)&v136 + 1) > v81))
            {
              uint64_t v95 = v81 + v86 + 64;
              if (v95 >= (uint64_t)v136) {
                uint64_t v95 = v136;
              }
              *((void *)&v136 + 1) = v81 + v86;
              uint64_t v137 = v95;
              if ((uint64_t)v136 >= v88) {
                uint64_t v90 = v88;
              }
              v143.length = v90 + v87;
              v96 = v84;
              v143.location = v81 + v86 + *((void *)&v135 + 1);
              CFStringGetCharacters(theString[0], v143, buffer);
              uint64_t v84 = v96;
              uint64_t v22 = v105;
              uint64_t v15 = v106;
              uint64_t v94 = *((void *)&v136 + 1);
            }
            UniChar v89 = buffer[v81 - v94];
          }
        }
        if (v6)
        {
          UniChar v91 = v6[v81];
        }
        else if (v15)
        {
          UniChar v91 = *((_WORD *)&v84[479]->flags + *(unsigned __int8 *)(v15 + v81));
        }
        else
        {
          uint64_t v92 = v124;
          if ((uint64_t)v124 <= v81)
          {
            UniChar v91 = 0;
          }
          else if (v122[1])
          {
            UniChar v91 = *((_WORD *)&v122[1]->isa + v81 + *((void *)&v123 + 1));
          }
          else if ((void)v123)
          {
            UniChar v91 = *(char *)(v123 + *((void *)&v123 + 1) + v81);
          }
          else
          {
            if (v125 <= v81 || (uint64_t v97 = *((void *)&v124 + 1), *((uint64_t *)&v124 + 1) > v81))
            {
              uint64_t v98 = v81 + v86 + 64;
              if (v98 >= (uint64_t)v124) {
                uint64_t v98 = v124;
              }
              *((void *)&v124 + 1) = v81 + v86;
              uint64_t v125 = v98;
              if ((uint64_t)v124 >= v88) {
                uint64_t v92 = v88;
              }
              v144.length = v92 + v87;
              v99 = v84;
              v144.location = v81 + v86 + *((void *)&v123 + 1);
              CFStringGetCharacters(v122[0], v144, v114);
              uint64_t v84 = v99;
              uint64_t v22 = v105;
              uint64_t v15 = v106;
              uint64_t v97 = *((void *)&v124 + 1);
            }
            UniChar v91 = v114[v81 - v97];
          }
        }
        BOOL v93 = v89 >= v91;
        if (v89 != v91) {
          break;
        }
        ++v81;
        --v80;
        ++v83;
        if (v81 >= v82) {
          return 0;
        }
      }
      goto LABEL_241;
    }
    return 0;
  }
}

CFStringRef __rangeCopyDescription(void *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"{%ld, %ld}", *a1, a1[1]);
}

BOOL __rangeEqual(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL _CFStringIsJoiningPulliAtIndex(void *__src, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[1] = *(void *)off_1ECE0A5B0;
  if (a3 >= a2 || a3 + a4 <= a2) {
    return 0;
  }
  uint64_t v5 = a2 - 1;
  if (a3 + a4 - (a2 - 1) >= 4) {
    CFIndex v6 = 4;
  }
  else {
    CFIndex v6 = a3 + a4 - (a2 - 1);
  }
  v21[0] = 0;
  if (*((void *)__src + 17))
  {
    __memmove_chk();
  }
  else
  {
    uint64_t v11 = *((void *)__src + 21);
    if (v11 < a2 && (uint64_t v12 = *((void *)__src + 22), v12 >= a2))
    {
      CFIndex v15 = v12 - v5;
      if (v6 >= v15) {
        CFIndex v16 = v15;
      }
      else {
        CFIndex v16 = v6;
      }
      __memmove_chk();
      uint64_t v14 = (UniChar *)v21 + v16;
      v5 += v16;
      v6 -= v16;
    }
    else
    {
      CFIndex v13 = v6 + v5 - v11;
      if (v6 + v5 <= v11)
      {
        uint64_t v14 = (UniChar *)v21;
      }
      else
      {
        uint64_t v14 = (UniChar *)v21;
        if (v6 + v5 < *((void *)__src + 22))
        {
          CFIndex v6 = v11 - v5;
          memmove((char *)v21 + 2 * (v11 - v5), __src, 2 * v13);
        }
      }
    }
    if (v6 >= 1)
    {
      uint64_t v17 = *((void *)__src + 18);
      v18.location = *((void *)__src + 19) + v5;
      if (v17)
      {
        CFIndex v19 = (char *)(v17 + v18.location);
        do
        {
          UniChar v20 = *v19++;
          *v14++ = v20;
          --v6;
        }
        while (v6);
      }
      else
      {
        v18.length = v6;
        CFStringGetCharacters(*((CFStringRef *)__src + 16), v18, v14);
      }
    }
  }
  return LODWORD(v21[0]) == 197987221 && WORD2(v21[0]) == 2999
      || v21[0] == 0xBC00BB00BCD0BB6
      || v21[0] == 0xBC00BB00BCD0BB8;
}

void CFStringGetParagraphBounds(CFStringRef string, CFRange range, CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (unint64_t)string))
  {
    -[__CFString getParagraphStart:end:contentsEnd:forRange:]((id)string, "getParagraphStart:end:contentsEnd:forRange:", parBeginIndex, parEndIndex, contentsEndIndex, location, length);
  }
  else
  {
    __CFStringGetLineOrParagraphBounds(string, location, length, parBeginIndex, (unint64_t)parEndIndex, contentsEndIndex, 0);
  }
}

CFStringEncoding CFStringGetSmallestEncoding(CFStringRef theString)
{
  if (!CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    p_info = &theString->info;
    char v4 = atomic_load((unint64_t *)&theString->info);
    if ((v4 & 0x10) == 0)
    {
      CFStringEncoding v5 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding != -1) {
        return v5;
      }
LABEL_7:
      __CFStringComputeEightBitStringEncoding();
      return __CFDefaultEightBitStringEncoding;
    }
    char v6 = atomic_load((unint64_t *)p_info);
    uint64_t v7 = v6 & 5;
    char v8 = atomic_load((unint64_t *)p_info);
    uint64_t v9 = v8 & 0x60;
    if (v7 == 4)
    {
      p_data = &theString->data;
      if (v9)
      {
        uint64_t v11 = *p_data;
      }
      else
      {
        uint64_t v13 = atomic_load((unint64_t *)&theString->info);
        uint64_t v11 = (char *)&p_data[(v13 & 5) != 4];
      }
      CFIndex length = *v11;
    }
    else if ((v8 & 0x60) != 0)
    {
      CFIndex length = theString->length;
    }
    else
    {
      CFIndex length = (CFIndex)theString->data;
    }
    uint64_t v14 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      uint64_t v14 = __CFDefaultEightBitStringEncoding;
    }
    v18.CFIndex location = 0;
    v18.CFIndex length = length;
    CFIndex v15 = __CFStringEncodeByteStream(theString, v18, 0, v14, 0, 0, 0x7FFFFFFFFFFFFFFFLL, 0);
    CFStringEncoding v5 = __CFDefaultEightBitStringEncoding;
    if (v15 == length)
    {
      if (__CFDefaultEightBitStringEncoding != -1) {
        return v5;
      }
      goto LABEL_7;
    }
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v5 = __CFDefaultEightBitStringEncoding;
    }
    if (__CFDefaultSystemEncoding)
    {
      if (!v5) {
        return 256;
      }
    }
    else
    {
      CFStringGetSystemEncoding();
      if (v5 == __CFDefaultSystemEncoding - 1) {
        return 256;
      }
      if ((__CFDefaultSystemEncoding & 1) == 0)
      {
        CFStringGetSystemEncoding();
        uint64_t v16 = __CFDefaultSystemEncoding - 1;
LABEL_30:
        v19.CFIndex location = 0;
        v19.CFIndex length = length;
        if (__CFStringEncodeByteStream(theString, v19, 0, v16, 0, 0, 0x7FFFFFFFFFFFFFFFLL, 0) == length)
        {
          if (__CFDefaultSystemEncoding) {
            return 0;
          }
          CFStringGetSystemEncoding();
          return __CFDefaultSystemEncoding - 1;
        }
        return 256;
      }
    }
    uint64_t v16 = 0;
    goto LABEL_30;
  }

  return [(__CFString *)(id)theString _smallestEncodingInCFStringEncoding];
}

void CFStringAppendPascalString(CFMutableStringRef theString, ConstStr255Param pStr, CFStringEncoding encoding)
{
  char v3 = atomic_load((unint64_t *)&theString->info);
  if (v3)
  {
    uint64_t v12 = *(void *)&encoding;
    unsigned int v15 = *pStr;
    uint64_t v13 = (unsigned __int8 *)(pStr + 1);
    unint64_t v14 = v15;
    __CFStringAppendBytes((unint64_t *)theString, v13, v14, v12);
  }
  else
  {
    char v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringAppendPascalString_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

uint64_t __CFStringNoteErrors()
{
  return 1;
}

void _CFStringAppendValidatedFormatAndArguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 *a6, CFErrorRef *a7)
{
}

void _CFStringAppendFormatAndArgumentsAux(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
}

BOOL _CFStringValidateFormat(uint64_t a1, uint64_t a2)
{
  return __CFStringValidateFormat(a2, a1) >= 0;
}

void CFShowStr(CFStringRef str)
{
  if (!str)
  {
    int64_t v2 = *(FILE **)off_1ECE0A5C0;
    char v3 = "(null)\n";
    size_t v4 = 7;
    goto LABEL_5;
  }
  if (CF_IS_OBJC(7uLL, (unint64_t)str))
  {
    int64_t v2 = *(FILE **)off_1ECE0A5C0;
    char v3 = "This is an NSString, not CFString\n";
    size_t v4 = 34;
LABEL_5:
    fwrite(v3, v4, 1uLL, v2);
    return;
  }
  CFAllocatorRef v5 = CFGetAllocator(str);
  char v6 = atomic_load((unint64_t *)&str->info);
  uint64_t v7 = v6 & 5;
  char v8 = atomic_load((unint64_t *)&str->info);
  uint64_t v9 = v8 & 0x60;
  if (v7 == 4)
  {
    p_data = &str->data;
    if (v9)
    {
      CFIndex length = (char **)*p_data;
    }
    else
    {
      uint64_t v12 = atomic_load((unint64_t *)&str->info);
      CFIndex length = &p_data[(v12 & 5) != 4];
    }
    LODWORD(length) = *(unsigned __int8 *)length;
  }
  else if ((v8 & 0x60) != 0)
  {
    CFIndex length = (char **)str->length;
  }
  else
  {
    CFIndex length = (char **)str->data;
  }
  unsigned int v13 = atomic_load((unint64_t *)&str->info);
  fprintf(*(FILE **)off_1ECE0A5C0, "\nLength %d\nIsEightBit %d\n", length, ((v13 >> 4) & 1) == 0);
  unint64_t v14 = *(FILE **)off_1ECE0A5C0;
  unsigned int v15 = atomic_load((unint64_t *)&str->info);
  unsigned int v16 = atomic_load((unint64_t *)&str->info);
  char v17 = atomic_load((unint64_t *)&str->info);
  fprintf(v14, "HasLengthByte %d\nHasNullByte %d\nInlineContents %d\n", (v15 >> 2) & 1, (v16 >> 3) & 1, (v17 & 0x60) == 0);
  fwrite("Allocator ", 0xAuLL, 1uLL, *(FILE **)off_1ECE0A5C0);
  CFRange v18 = *(FILE **)off_1ECE0A5C0;
  if (v5 == (CFAllocatorRef)&__kCFAllocatorSystemDefault) {
    fwrite("SystemDefault\n", 0xEuLL, 1uLL, v18);
  }
  else {
    fprintf(v18, "%p\n", v5);
  }
  CFRange v19 = *(FILE **)off_1ECE0A5C0;
  p_unint64_t info = &str->info;
  char v21 = atomic_load((unint64_t *)&str->info);
  fprintf(v19, "Mutable %d\n", v21 & 1);
  char v22 = atomic_load((unint64_t *)&str->info);
  if ((v22 & 1) != 0 || (char v23 = atomic_load((unint64_t *)p_info), (~v23 & 0x60) != 0))
  {
    char v28 = atomic_load((unint64_t *)p_info);
    if (v28)
    {
      char v29 = atomic_load((unint64_t *)&str->info);
      if ((~v29 & 0x60) == 0) {
        fprintf(*(FILE **)off_1ECE0A5C0, "ExternalContentsAllocator %p\n");
      }
    }
  }
  else
  {
    char v24 = atomic_load((unint64_t *)&str->info);
    BOOL v25 = (v24 & 5) == 4;
    uint64_t v26 = 32;
    if (v25) {
      uint64_t v26 = 24;
    }
    uint64_t v27 = *(FILE **)off_1ECE0A5C0;
    if (*(void **)((char *)&str->isa + v26))
    {
      atomic_load((unint64_t *)&str->info);
      fprintf(v27, "ContentsDeallocatorFunc %p\n");
    }
    else
    {
      fwrite("ContentsDeallocatorFunc None\n", 0x1DuLL, 1uLL, v27);
    }
  }
  char v30 = atomic_load((unint64_t *)&str->info);
  if (v30)
  {
    unsigned int v31 = "Fixed";
    unint64_t info = str[1].info;
    if ((info & 2) == 0) {
      unsigned int v31 = "Desired";
    }
    fprintf(*(FILE **)off_1ECE0A5C0, "CurrentCapacity %d\n%sCapacity %d\n", str[1].isa, v31, info >> 4);
  }
  char v33 = atomic_load((unint64_t *)&str->info);
  uint64_t v34 = &str->data;
  if ((v33 & 0x60) != 0)
  {
    uint64_t v35 = *v34;
  }
  else
  {
    char v36 = atomic_load((unint64_t *)&str->info);
    uint64_t v35 = (char *)&v34[(v36 & 5) != 4];
  }
  fprintf(*(FILE **)off_1ECE0A5C0, "Contents %p\n", v35);
}

void OUTLINED_FUNCTION_0_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

uint64_t (**__CFStringEncodingGetKoreanConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_0)
  {
    __CFStringEncodingIsDecomposableCharacter_0 = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter_0 = (_UNKNOWN *)a2(2);
  }
  if (a1 > 2111)
  {
    if (a1 != 2112)
    {
      if (a1 == 2368) {
        return __CFConverterEUC_KR;
      }
      return 0;
    }
    return &__CFConverterISO_2022_KR;
  }
  else
  {
    if (a1 != 3)
    {
      if (a1 == 1058) {
        return __CFConverterDOSKorean;
      }
      return 0;
    }
    return __CFConverterMacKorean;
  }
}

uint64_t __CFToDOSKorean(char a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
    goto LABEL_97;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0xF73Eu;
  int v50 = 1;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        break;
      }
      unsigned int v14 = *a2;
      BOOL v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
      if (v15 && v14 - 12441 >= 2) {
        break;
      }
    }
    else
    {
      unsigned int v14 = *a2;
      if (v14 <= 0x7F)
      {
        if (a5) {
          *a4++ = v14;
        }
        ++v11;
        ++a2;
        ++v12;
        int v50 = 1;
        continue;
      }
    }
    if (v14 - 4352 > 0xFE)
    {
LABEL_35:
      if (v14 < 0xA1) {
        goto LABEL_55;
      }
    }
    else if (a3 - v12 >= 2 && ((v14 << 24) | 0xFFFFFFu) <= 0x14FFFFFE)
    {
      unsigned int v17 = a2[1] - 4449;
      if (v17 <= 0x15)
      {
        if ((unint64_t)(a3 - v12) < 3)
        {
          unsigned __int16 v18 = 0;
        }
        else
        {
          unsigned __int16 v18 = a2[2] - 4519;
          if (v18 > 0x1Cu) {
            unsigned __int16 v18 = 0;
          }
        }
        unsigned int v19 = (unsigned __int16)(v18 + 28 * (v17 + 21 * (char)v14) - 21504);
        if (v19 >= 0xA1)
        {
          UniChar v20 = (unsigned __int16 *)&KSX1001_from_uni;
          char v21 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
          while (1)
          {
            uint64_t v22 = (0xF83E0F83E0F83E1 * (v21 - v20)) >> 1;
            char v23 = &v20[33 * v22];
            unsigned int v24 = *v23;
            if (v24 <= v19)
            {
              if (v24 + 32 > v19)
              {
                int v40 = v20[33 * v22 + 1 + (int)(v19 - v24)];
                if (v40)
                {
                  BOOL v47 = (__int16)v18 <= 0;
                  uint64_t v41 = 2;
                  if (!v47) {
                    uint64_t v41 = 3;
                  }
                  goto LABEL_72;
                }
                goto LABEL_35;
              }
              UniChar v20 = v23 + 33;
            }
            else
            {
              char v21 = v23 - 33;
            }
            if (v20 > v21) {
              goto LABEL_35;
            }
          }
        }
      }
    }
    BOOL v25 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v26 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
    while (1)
    {
      uint64_t v27 = (0xF83E0F83E0F83E1 * (v26 - v25)) >> 1;
      char v28 = &v25[33 * v27];
      unsigned int v29 = *v28;
      if (v29 <= v14) {
        break;
      }
      uint64_t v26 = v28 - 33;
LABEL_41:
      if (v25 > v26) {
        goto LABEL_42;
      }
    }
    if (v29 + 32 <= v14)
    {
      BOOL v25 = v28 + 33;
      goto LABEL_41;
    }
    uint64_t v39 = (uint64_t)&v25[33 * v27 + (int)(v14 - v29)];
    int v40 = *(unsigned __int16 *)(v39 + 2);
    if (*(_WORD *)(v39 + 2))
    {
      uint64_t v41 = 1;
LABEL_72:
      if (v40 != 65533)
      {
        if (a5)
        {
          if (v11 + 2 > a5) {
            break;
          }
          *a4 = BYTE1(v40);
          a4[1] = v40;
          a4 += 2;
        }
        int v50 = 0;
        v12 += v41;
        v11 += 2;
        a2 += v41;
        continue;
      }
    }
LABEL_42:
    if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
    {
      if (a5)
      {
        if (v11 + 2 > a5) {
          break;
        }
        if (v14 >= 0xE05E) {
          char v30 = -2;
        }
        else {
          char v30 = -55;
        }
        *a4 = v30;
        if (v14 >= 0xE05E) {
          char v31 = 67;
        }
        else {
          char v31 = -95;
        }
        a4[1] = v31 + v14;
        a4 += 2;
      }
      int v50 = 0;
      ++a2;
      ++v12;
      v11 += 2;
      continue;
    }
    if ((unsigned __int16)(v14 - 4447) <= 1u)
    {
      ++a2;
      ++v12;
      continue;
    }
LABEL_55:
    if ((a1 & 8) != 0 || v12 < 1) {
      break;
    }
    if ((a1 & 0x10) == 0) {
      continue;
    }
    if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2) {
      break;
    }
    uint64_t v32 = a6;
    unsigned int v33 = __CFPrecomposeCharKorean(a2 - 1);
    if (!v33)
    {
      a6 = v32;
      break;
    }
    a6 = v32;
    if (v33 < 0xA1) {
      break;
    }
    uint64_t v13 = 0xF73Eu;
    uint64_t v34 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v35 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
LABEL_64:
    uint64_t v36 = (0xF83E0F83E0F83E1 * (v35 - v34)) >> 1;
    uint64_t v37 = &v34[33 * v36];
    unsigned int v38 = *v37;
    if (v38 > v33)
    {
      uint64_t v35 = v37 - 33;
      goto LABEL_68;
    }
    if (v38 + 32 <= v33)
    {
      uint64_t v34 = v37 + 33;
LABEL_68:
      if (v34 > v35) {
        break;
      }
      goto LABEL_64;
    }
    unsigned int v42 = v34[33 * v36 + 1 + (int)(v33 - v38)];
    if (v42) {
      BOOL v43 = v42 == 65533;
    }
    else {
      BOOL v43 = 1;
    }
    if (v43) {
      break;
    }
    if (v50) {
      uint64_t v44 = v11 + 1;
    }
    else {
      uint64_t v44 = v11;
    }
    if (!a5) {
      goto LABEL_89;
    }
    if (v44 > a5)
    {
      uint64_t v49 = v44 - 1;
      if (v50) {
        uint64_t v11 = v49;
      }
      break;
    }
    uint64_t v45 = -2;
    if (v50) {
      uint64_t v45 = -1;
    }
    uint64_t v46 = &a4[v45];
    *(_WORD *)uint64_t v46 = __rev16(v42);
    a4 = v46 + 2;
LABEL_89:
    int v50 = 0;
    ++a2;
    ++v12;
    uint64_t v11 = v44;
  }
  while (v12 < a3);
LABEL_97:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromDOSKorean(unsigned int a1, char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v39 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  unint64_t v9 = a3;
  unsigned int v11 = a1;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = a1 & 0xC0;
  uint64_t v15 = 0x9F74u;
  unsigned int v16 = &unk_1EC093000;
LABEL_3:
  if (a5)
  {
    if (v12 >= a5) {
      return v13;
    }
    int v17 = *a2;
    if ((*a2 & 0x80000000) == 0)
    {
      *a4++ = v17;
LABEL_8:
      uint64_t v18 = 1;
LABEL_32:
      *a6 = ++v12;
      goto LABEL_33;
    }
  }
  else
  {
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    int v17 = *a2;
  }
  if (v9 < 2) {
    return v13;
  }
  unsigned int v19 = a2[1] | (v17 << 8);
  if ((unsigned __int16)(v19 + 478) >= 0x831Fu)
  {
    UniChar v20 = (unsigned __int16 *)((char *)&KSX1001_to_uni + v15);
    char v21 = (unsigned __int16 *)&KSX1001_to_uni;
    while (1)
    {
      uint64_t v22 = (0xFC0FC0FC0FC0FC1 * (v20 - v21)) >> 1;
      char v23 = &v21[65 * v22];
      unsigned int v24 = *v23;
      if (v24 <= v19)
      {
        if (v24 + 64 > v19)
        {
          unsigned __int16 v25 = v21[65 * v22 + 1 + (int)(v19 - v24)];
          if (v25) {
            BOOL v26 = v25 == 65533;
          }
          else {
            BOOL v26 = 1;
          }
          if (v26)
          {
LABEL_24:
            if ((unsigned __int16)(v19 + 13919) > 0x5Du) {
              break;
            }
            if (a5)
            {
              unsigned __int16 v27 = v19 + 5727;
              goto LABEL_30;
            }
            goto LABEL_31;
          }
          if (!v14
            || (int v36 = v14,
                unsigned int v37 = v11,
                v29 = (*((uint64_t (**)(void, void))v16 + 406))(v21[65 * v22 + 1 + (int)(v19 - v24)], (v11 >> 7) & 1), v16 = &unk_1EC093000, v15 = 40820, v14 = v36, unsigned int v11 = v37, !v29))
          {
            if (a5) {
              *a4++ = v25;
            }
            uint64_t v12 = *a6;
            goto LABEL_31;
          }
          uint64_t v30 = __CFStringEncodingDecomposeCharacter_0(v37, v25, v38, 13919, 5727, 65533, 0x1EC093000, &KSX1001_to_uni);
          uint64_t v31 = *a6;
          uint64_t v12 = *a6 + v30;
          *a6 = v12;
          if (!a5)
          {
            uint64_t v18 = 2;
            int v14 = v36;
            unsigned int v11 = v37;
            uint64_t v15 = 40820;
            unsigned int v16 = &unk_1EC093000;
            goto LABEL_33;
          }
          unsigned int v16 = &unk_1EC093000;
          if (v12 > a5)
          {
            *a6 = v31;
            return v13;
          }
          if (v30 < 1)
          {
            uint64_t v18 = 2;
            int v14 = v36;
            unsigned int v11 = v37;
            uint64_t v15 = 40820;
          }
          else
          {
            unint64_t v32 = v30 + 1;
            unsigned int v33 = (__int16 *)v38;
            int v14 = v36;
            unsigned int v11 = v37;
            uint64_t v15 = 40820;
            do
            {
              unsigned __int16 v34 = *v33++;
              *a4++ = v34;
              --v32;
            }
            while (v32 > 1);
            uint64_t v18 = 2;
          }
LABEL_33:
          v13 += v18;
          a2 += v18;
          BOOL v28 = (uint64_t)v9 <= v18;
          v9 -= v18;
          if (v28) {
            return v13;
          }
          goto LABEL_3;
        }
        char v21 = v23 + 65;
      }
      else
      {
        UniChar v20 = v23 - 65;
      }
      if (v21 > v20) {
        goto LABEL_24;
      }
    }
  }
  if ((unsigned __int16)(v19 + 351) <= 0x5Du)
  {
    if (a5)
    {
      unsigned __int16 v27 = v19 - 3907;
LABEL_30:
      *a4++ = v27;
    }
LABEL_31:
    uint64_t v18 = 2;
    goto LABEL_32;
  }
  return v13;
}

uint64_t __CFToDOSKoreanLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    unsigned int v4 = *a2++;
    if (v4 < 0x80) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = 2;
    }
    result += v5;
  }
  return result;
}

uint64_t __CFFromDOSKoreanLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    BOOL v5 = a3 == 1 || *a2 >= 0;
    BOOL v6 = !v5;
    if (v5) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    a2 += v7;
    if (v6) {
      uint64_t v8 = -2;
    }
    else {
      uint64_t v8 = -1;
    }
    ++result;
    BOOL v9 = __OFADD__(v8, a3);
    a3 += v8;
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFFromDOSKoreanFallback(char *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1;
  if (*a1 > -1 || a2 < 2) {
    return 1;
  }
  else {
    return 2;
  }
}

uint64_t __CFToKSX1001(unsigned __int16 *a1, uint64_t a2, uint64_t *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a1;
  if (v4 - 4352 > 0xFE) {
    goto LABEL_17;
  }
  if (a2 >= 2 && ((v4 << 24) | 0xFFFFFFu) <= 0x14FFFFFE)
  {
    unsigned int v5 = a1[1] - 4449;
    if (v5 <= 0x15)
    {
      if ((unint64_t)a2 < 3)
      {
        __int16 v6 = 0;
      }
      else
      {
        __int16 v6 = a1[2] - 4519;
        if ((unsigned __int16)v6 > 0x1Cu) {
          __int16 v6 = 0;
        }
      }
      unsigned __int16 v7 = v6 + 28 * (v5 + 21 * (char)v4) - 21504;
      if (v7 >= 0xA1u)
      {
        uint64_t v8 = (unsigned __int16 *)&KSX1001_from_uni;
        BOOL v9 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
        while (1)
        {
          uint64_t v10 = (0xF83E0F83E0F83E1 * (v9 - v8)) >> 1;
          unsigned int v11 = &v8[33 * v10];
          unsigned int v12 = *v11;
          if (v12 <= v7)
          {
            if (v12 + 32 > v7)
            {
              uint64_t v21 = (uint64_t)&v8[33 * v10 + (int)(v7 - v12)];
              uint64_t result = *(unsigned __int16 *)(v21 + 2);
              if (*(_WORD *)(v21 + 2))
              {
                if (a4) {
                  *a4 = v7;
                }
                uint64_t v20 = 2;
                if (v6 > 0) {
                  uint64_t v20 = 3;
                }
LABEL_27:
                *a3 = v20;
                return result;
              }
LABEL_17:
              if (v4 < 0xA1) {
                return 65533;
              }
              break;
            }
            uint64_t v8 = v11 + 33;
          }
          else
          {
            BOOL v9 = v11 - 33;
          }
          if (v8 > v9) {
            goto LABEL_17;
          }
        }
      }
    }
  }
  uint64_t v13 = (unsigned __int16 *)&KSX1001_from_uni;
  int v14 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
  while (1)
  {
    uint64_t v15 = (0xF83E0F83E0F83E1 * (v14 - v13)) >> 1;
    unsigned int v16 = &v13[33 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v4) {
      break;
    }
    int v14 = v16 - 33;
LABEL_23:
    if (v13 > v14) {
      return 65533;
    }
  }
  if (v17 + 32 <= v4)
  {
    uint64_t v13 = v16 + 33;
    goto LABEL_23;
  }
  uint64_t v19 = (uint64_t)&v13[33 * v15 + (int)(v4 - v17)];
  uint64_t result = *(unsigned __int16 *)(v19 + 2);
  if (*(_WORD *)(v19 + 2))
  {
    uint64_t v20 = 1;
    goto LABEL_27;
  }
  return 65533;
}

uint64_t __CFPrecomposeCharKorean(unsigned __int16 *a1)
{
  int v1 = *a1;
  unsigned int v2 = a1[1];
  if (v2 <= 0x337)
  {
    if (v2 != 774)
    {
      if (v2 != 776) {
        return 0;
      }
      if (v1 == 1077) {
        unsigned __int16 v3 = 1105;
      }
      else {
        unsigned __int16 v3 = 0;
      }
      if (v1 == 1045) {
        return 1025;
      }
      return v3;
    }
    if ((v1 & 0xFFFFFFDF) != 0x418) {
      return 0;
    }
    return (unsigned __int16)(v1 + 1);
  }
  if (v2 == 824)
  {
    unsigned __int16 v3 = 8800;
    if (*a1 > 0x2260u)
    {
      char v4 = v1 - 100;
      if ((v1 - 8804) <= 0x1F)
      {
        if (((1 << v4) & 0xC0080000) != 0) {
          return (unsigned __int16)(v1 + 2);
        }
        if (((1 << v4) & 3) != 0) {
          return (unsigned __int16)(v1 + 12);
        }
        if (((1 << v4) & 0xC00000) != 0) {
          return (unsigned __int16)(v1 + 6);
        }
      }
      if (v1 != 8801) {
        return 0;
      }
    }
    else
    {
      if (*a1 <= 0x2207u)
      {
        if (v1 == 60) {
          return 8814;
        }
        if (v1 != 61)
        {
          if (v1 == 62) {
            return 8815;
          }
          return 0;
        }
        return v3;
      }
      if ((v1 - 8712) > 0x1D || ((1 << (v1 - 8)) & 0x20000009) == 0) {
        return 0;
      }
    }
    return (unsigned __int16)(v1 + 1);
  }
  if (v2 != 12441)
  {
    if (v2 == 12442) {
      return (unsigned __int16)(v1 + 2);
    }
    return 0;
  }
  if (v1 == 12454) {
    return 12532;
  }
  else {
    return (unsigned __int16)(v1 + 1);
  }
}

uint64_t __CFFromKSX1001(unsigned int a1)
{
  if ((unsigned __int16)(a1 + 478) < 0x831Fu) {
    return (unsigned __int16)-3;
  }
  int v1 = (unsigned __int16 *)&KSX1001_to_uni;
  unsigned int v2 = (unsigned __int16 *)((char *)&KSX1001_to_uni + 40820);
  while (1)
  {
    uint64_t v3 = (0xFC0FC0FC0FC0FC1 * (v2 - v1)) >> 1;
    char v4 = &v1[65 * v3];
    unsigned int v5 = *v4;
    if (v5 <= a1) {
      break;
    }
    unsigned int v2 = v4 - 65;
LABEL_7:
    if (v1 > v2) {
      return (unsigned __int16)-3;
    }
  }
  if (v5 + 64 <= a1)
  {
    int v1 = v4 + 65;
    goto LABEL_7;
  }
  unsigned __int16 v6 = v1[65 * v3 + 1 + (int)(a1 - v5)];
  if (!v6) {
    return (unsigned __int16)-3;
  }
  return v6;
}

uint64_t __CFToEUC_KR(char a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
    goto LABEL_103;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0xF73Eu;
  int v48 = 1;
  while (2)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_103;
      }
      unsigned int v14 = *a2;
      BOOL v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
      if (v15 && v14 - 12441 >= 2) {
        goto LABEL_103;
      }
    }
    else
    {
      unsigned int v14 = *a2;
      if (v14 <= 0x7F)
      {
        if (a5) {
          *a4++ = v14;
        }
        ++v11;
        ++a2;
        ++v12;
        int v48 = 1;
        goto LABEL_58;
      }
    }
    if (v14 - 4352 > 0xFE) {
      goto LABEL_35;
    }
    if (a3 - v12 < 2) {
      goto LABEL_36;
    }
    if (((v14 << 24) | 0xFFFFFFu) > 0x14FFFFFE) {
      goto LABEL_36;
    }
    unsigned int v17 = a2[1] - 4449;
    if (v17 > 0x15) {
      goto LABEL_36;
    }
    if ((unint64_t)(a3 - v12) < 3)
    {
      unsigned __int16 v18 = 0;
    }
    else
    {
      unsigned __int16 v18 = a2[2] - 4519;
      if (v18 > 0x1Cu) {
        unsigned __int16 v18 = 0;
      }
    }
    unsigned int v19 = (unsigned __int16)(v18 + 28 * (v17 + 21 * (char)v14) - 21504);
    if (v19 < 0xA1) {
      goto LABEL_36;
    }
    uint64_t v20 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v21 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
    while (1)
    {
      uint64_t v22 = (0xF83E0F83E0F83E1 * (v21 - v20)) >> 1;
      char v23 = &v20[33 * v22];
      unsigned int v24 = *v23;
      if (v24 <= v19) {
        break;
      }
      uint64_t v21 = v23 - 33;
LABEL_34:
      if (v20 > v21) {
        goto LABEL_35;
      }
    }
    if (v24 + 32 <= v19)
    {
      uint64_t v20 = v23 + 33;
      goto LABEL_34;
    }
    unsigned int v33 = v20[33 * v22 + 1 + (int)(v19 - v24)];
    if (!v33)
    {
LABEL_35:
      if (v14 < 0xA1) {
        goto LABEL_55;
      }
LABEL_36:
      unsigned __int16 v25 = (unsigned __int16 *)&KSX1001_from_uni;
      BOOL v26 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
      while (1)
      {
        uint64_t v27 = (0xF83E0F83E0F83E1 * (v26 - v25)) >> 1;
        BOOL v28 = &v25[33 * v27];
        unsigned int v29 = *v28;
        if (v29 <= v14)
        {
          if (v29 + 32 > v14)
          {
            uint64_t v32 = (uint64_t)&v25[33 * v27 + (int)(v14 - v29)];
            unsigned int v33 = *(unsigned __int16 *)(v32 + 2);
            if (*(_WORD *)(v32 + 2))
            {
              uint64_t v34 = 1;
              goto LABEL_62;
            }
            goto LABEL_42;
          }
          unsigned __int16 v25 = v28 + 33;
        }
        else
        {
          BOOL v26 = v28 - 33;
        }
        if (v25 > v26) {
          goto LABEL_42;
        }
      }
    }
    BOOL v46 = (__int16)v18 <= 0;
    uint64_t v34 = 2;
    if (!v46) {
      uint64_t v34 = 3;
    }
LABEL_62:
    if (v33 != 65533
      && v33 >> 8 >= 0xA1
      && v33 >> 8 != 255
      && v33 >= 0xA1u
      && v33 != 255)
    {
      v11 += 2;
      if (a5)
      {
        if (v11 > a5) {
          goto LABEL_103;
        }
        *a4 = BYTE1(v33);
        a4[1] = v33;
        a4 += 2;
      }
      int v48 = 0;
      a2 += v34;
      v12 += v34;
      goto LABEL_58;
    }
LABEL_42:
    if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
    {
      v11 += 2;
      if (!a5) {
        goto LABEL_52;
      }
      if (v11 <= a5)
      {
        if (v14 >= 0xE05E) {
          char v30 = -2;
        }
        else {
          char v30 = -55;
        }
        *a4 = v30;
        if (v14 >= 0xE05E) {
          char v31 = 67;
        }
        else {
          char v31 = -95;
        }
        a4[1] = v31 + v14;
        a4 += 2;
        goto LABEL_52;
      }
      goto LABEL_103;
    }
    if ((unsigned __int16)(v14 - 4447) <= 1u)
    {
LABEL_54:
      ++a2;
      ++v12;
      goto LABEL_58;
    }
LABEL_55:
    if ((a1 & 8) != 0 || v12 < 1) {
      goto LABEL_103;
    }
    if ((a1 & 0x10) == 0)
    {
LABEL_58:
      if (v12 >= a3) {
        goto LABEL_103;
      }
      continue;
    }
    break;
  }
  if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2) {
    goto LABEL_103;
  }
  uint64_t v35 = a6;
  unsigned int v36 = __CFPrecomposeCharKorean(a2 - 1);
  if (v36 <= 0xA0)
  {
    a6 = v35;
    goto LABEL_103;
  }
  uint64_t v13 = 0xF73Eu;
  unsigned int v37 = (unsigned __int16 *)&KSX1001_from_uni;
  unsigned int v38 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
  a6 = v35;
  while (2)
  {
    uint64_t v39 = (0xF83E0F83E0F83E1 * (v38 - v37)) >> 1;
    int v40 = &v37[33 * v39];
    unsigned int v41 = *v40;
    if (v41 > v36)
    {
      unsigned int v38 = v40 - 33;
      goto LABEL_80;
    }
    if (v41 + 32 <= v36)
    {
      unsigned int v37 = v40 + 33;
LABEL_80:
      if (v37 > v38) {
        goto LABEL_103;
      }
      continue;
    }
    break;
  }
  unsigned int v42 = v37[33 * v39 + 1 + (int)(v36 - v41)];
  if (v37[33 * v39 + 1 + (int)(v36 - v41)]) {
    BOOL v43 = v42 == 65533;
  }
  else {
    BOOL v43 = 1;
  }
  if (v43
    || v42 >> 8 < 0xA1
    || v42 >> 8 == 255
    || v37[33 * v39 + 1 + (int)(v36 - v41)] < 0xA1u
    || v37[33 * v39 + 1 + (int)(v36 - v41)] == 255)
  {
    goto LABEL_103;
  }
  if (v48) {
    ++v11;
  }
  if (!a5)
  {
LABEL_52:
    int v48 = 0;
    goto LABEL_54;
  }
  if (v11 <= a5)
  {
    uint64_t v44 = -2;
    if (v48) {
      uint64_t v44 = -1;
    }
    uint64_t v45 = &a4[v44];
    *uint64_t v45 = BYTE1(v42);
    a4 = v45 + 2;
    v45[1] = v42;
    goto LABEL_52;
  }
LABEL_103:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromEUC_KR(unsigned int a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v41 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  unint64_t v9 = a3;
  unsigned int v11 = a1;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = a1 & 0xC0;
  uint64_t v15 = 0x9F74u;
  unsigned int v16 = &unk_1EC093000;
LABEL_3:
  if (a5)
  {
    if (v12 >= a5) {
      return v13;
    }
    int v17 = (char)*a2;
    int v18 = *a2;
    if ((v17 & 0x80000000) == 0)
    {
      *a4++ = v18;
LABEL_8:
      uint64_t v19 = 1;
LABEL_34:
      *a6 = ++v12;
      goto LABEL_35;
    }
  }
  else
  {
    int v17 = (char)*a2;
    if ((v17 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    int v18 = *a2;
  }
  if (v9 < 2) {
    return v13;
  }
  if ((v17 + 1) < 0xA2u) {
    return v13;
  }
  int v20 = a2[1];
  if ((v20 + 1) < 0xA2u) {
    return v13;
  }
  unsigned int v21 = v20 | (v18 << 8);
  if ((unsigned __int16)(v21 + 478) >= 0x831Fu)
  {
    uint64_t v22 = (unsigned __int16 *)((char *)&KSX1001_to_uni + v15);
    char v23 = (unsigned __int16 *)&KSX1001_to_uni;
    while (1)
    {
      uint64_t v24 = (0xFC0FC0FC0FC0FC1 * (v22 - v23)) >> 1;
      unsigned __int16 v25 = &v23[65 * v24];
      unsigned int v26 = *v25;
      if (v26 <= v21)
      {
        if (v26 + 64 > v21)
        {
          unsigned __int16 v27 = v23[65 * v24 + 1 + (int)(v21 - v26)];
          if (v27) {
            BOOL v28 = v27 == 65533;
          }
          else {
            BOOL v28 = 1;
          }
          if (v28)
          {
LABEL_26:
            if ((unsigned __int16)(v21 + 13919) > 0x5Du) {
              break;
            }
            if (a5)
            {
              unsigned __int16 v29 = v21 + 5727;
              goto LABEL_32;
            }
            goto LABEL_33;
          }
          if (!v14
            || (int v38 = v14,
                unsigned int v39 = v11,
                v31 = (*((uint64_t (**)(void, void))v16 + 406))(v23[65 * v24 + 1 + (int)(v21 - v26)], (v11 >> 7) & 1), v16 = &unk_1EC093000, v15 = 40820, v14 = v38, unsigned int v11 = v39, !v31))
          {
            if (a5) {
              *a4++ = v27;
            }
            uint64_t v12 = *a6;
            goto LABEL_33;
          }
          uint64_t v32 = __CFStringEncodingDecomposeCharacter_0(v39, v27, v40, 13919, 5727, 65533, 0x1EC093000, &KSX1001_to_uni);
          uint64_t v33 = *a6;
          uint64_t v12 = *a6 + v32;
          *a6 = v12;
          if (!a5)
          {
            uint64_t v19 = 2;
            int v14 = v38;
            unsigned int v11 = v39;
            uint64_t v15 = 40820;
            unsigned int v16 = &unk_1EC093000;
            goto LABEL_35;
          }
          unsigned int v16 = &unk_1EC093000;
          if (v12 > a5)
          {
            *a6 = v33;
            return v13;
          }
          if (v32 < 1)
          {
            uint64_t v19 = 2;
            int v14 = v38;
            unsigned int v11 = v39;
            uint64_t v15 = 40820;
          }
          else
          {
            unint64_t v34 = v32 + 1;
            uint64_t v35 = (__int16 *)v40;
            int v14 = v38;
            unsigned int v11 = v39;
            uint64_t v15 = 40820;
            do
            {
              unsigned __int16 v36 = *v35++;
              *a4++ = v36;
              --v34;
            }
            while (v34 > 1);
            uint64_t v19 = 2;
          }
LABEL_35:
          v13 += v19;
          a2 += v19;
          BOOL v30 = (uint64_t)v9 <= v19;
          v9 -= v19;
          if (v30) {
            return v13;
          }
          goto LABEL_3;
        }
        char v23 = v25 + 65;
      }
      else
      {
        uint64_t v22 = v25 - 65;
      }
      if (v23 > v22) {
        goto LABEL_26;
      }
    }
  }
  if ((unsigned __int16)(v21 + 351) <= 0x5Du)
  {
    if (a5)
    {
      unsigned __int16 v29 = v21 - 3907;
LABEL_32:
      *a4++ = v29;
    }
LABEL_33:
    uint64_t v19 = 2;
    goto LABEL_34;
  }
  return v13;
}

uint64_t __CFToISO_2022_KR(int a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, uint64_t *a6)
{
  if ((a1 & 0x100) != 0)
  {
    if (a5)
    {
      if (a5 < 4) {
        return 0;
      }
      *(_DWORD *)a4 = 1126769691;
      a4 += 4;
    }
    uint64_t v8 = 4;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (a3 < 1)
  {
    uint64_t v9 = 0;
    goto LABEL_134;
  }
  BOOL v10 = 0;
  uint64_t v9 = 0;
  uint64_t v11 = 0xF73Eu;
  int v12 = 1;
  uint64_t v13 = v8;
LABEL_10:
  if (a5 && v13 >= a5)
  {
    if ((a1 & 0x10) == 0) {
      goto LABEL_132;
    }
    unsigned int v14 = *a2;
    BOOL v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
    if (v15 && v14 - 12441 >= 2) {
      goto LABEL_132;
    }
    goto LABEL_32;
  }
  unsigned int v14 = *a2;
  if (v14 > 0x7F)
  {
LABEL_32:
    if ((unsigned __int16)(v14 - 4447) <= 1u) {
      goto LABEL_72;
    }
    if (v14 - 4352 > 0xFE)
    {
LABEL_49:
      if (v14 < 0xA1) {
        goto LABEL_75;
      }
LABEL_50:
      unsigned int v26 = (unsigned __int16 *)&KSX1001_from_uni;
      unsigned __int16 v27 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
      while (1)
      {
        uint64_t v28 = (0xF83E0F83E0F83E1 * (v27 - v26)) >> 1;
        unsigned __int16 v29 = &v26[33 * v28];
        unsigned int v30 = *v29;
        if (v30 <= v14)
        {
          if (v30 + 32 > v14)
          {
            uint64_t v45 = (uint64_t)&v26[33 * v28 + (int)(v14 - v30)];
            unsigned int v46 = *(unsigned __int16 *)(v45 + 2);
            if (*(_WORD *)(v45 + 2))
            {
              uint64_t v47 = 1;
              goto LABEL_92;
            }
            goto LABEL_56;
          }
          unsigned int v26 = v29 + 33;
        }
        else
        {
          unsigned __int16 v27 = v29 - 33;
        }
        if (v26 > v27) {
          goto LABEL_56;
        }
      }
    }
    if (a3 - v9 < 2) {
      goto LABEL_50;
    }
    if (((v14 << 24) | 0xFFFFFFu) > 0x14FFFFFE) {
      goto LABEL_50;
    }
    unsigned int v18 = a2[1] - 4449;
    if (v18 > 0x15) {
      goto LABEL_50;
    }
    if ((unint64_t)(a3 - v9) < 3)
    {
      unsigned __int16 v19 = 0;
    }
    else
    {
      unsigned __int16 v19 = a2[2] - 4519;
      if (v19 > 0x1Cu) {
        unsigned __int16 v19 = 0;
      }
    }
    unsigned int v20 = (unsigned __int16)(v19 + 28 * (v18 + 21 * (char)v14) - 21504);
    if (v20 < 0xA1) {
      goto LABEL_50;
    }
    unsigned int v21 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v22 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
    while (1)
    {
      uint64_t v23 = (0xF83E0F83E0F83E1 * (v22 - v21)) >> 1;
      uint64_t v24 = &v21[33 * v23];
      unsigned int v25 = *v24;
      if (v25 <= v20)
      {
        if (v25 + 32 > v20)
        {
          unsigned int v46 = v21[33 * v23 + 1 + (int)(v20 - v25)];
          if (!v46) {
            goto LABEL_49;
          }
          BOOL v64 = (__int16)v19 <= 0;
          uint64_t v47 = 2;
          if (!v64) {
            uint64_t v47 = 3;
          }
LABEL_92:
          if (v46 != 65533
            && v46 >> 8 >= 0xA1
            && v46 >> 8 != 255
            && v46 >= 0xA1u
            && v46 != 255)
          {
            BOOL v10 = v12 != 0;
            if (v12) {
              uint64_t v48 = v13 + 1;
            }
            else {
              uint64_t v48 = v13;
            }
            uint64_t v13 = v48 + 2;
            if (!a5)
            {
LABEL_105:
              int v12 = 0;
              a2 += v47;
              v9 += v47;
              goto LABEL_73;
            }
            if (v13 <= a5)
            {
              if (v12) {
                *a4++ = 14;
              }
              *a4 = BYTE1(v46) & 0x7F;
              a4[1] = v46 & 0x7F;
              a4 += 2;
              goto LABEL_105;
            }
LABEL_165:
            uint64_t v66 = -3;
            if (!v12) {
              uint64_t v66 = -2;
            }
            v13 += v66;
LABEL_168:
            uint64_t v8 = v13 + 1;
            goto LABEL_142;
          }
LABEL_56:
          if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
          {
            BOOL v10 = v12 != 0;
            if (v12) {
              uint64_t v31 = v13 + 1;
            }
            else {
              uint64_t v31 = v13;
            }
            uint64_t v13 = v31 + 2;
            if (!a5) {
              goto LABEL_71;
            }
            if (v13 <= a5)
            {
              if (v12) {
                *a4++ = 14;
              }
              if (v14 >= 0xE05E) {
                char v32 = 126;
              }
              else {
                char v32 = 73;
              }
              *a4 = v32;
              if (v14 >= 0xE05E) {
                char v33 = 67;
              }
              else {
                char v33 = 33;
              }
              a4[1] = (v33 + v14) & 0x7F;
              a4 += 2;
              goto LABEL_71;
            }
            goto LABEL_165;
          }
LABEL_75:
          if ((a1 & 8) != 0 || v9 < 1) {
            goto LABEL_132;
          }
          if ((a1 & 0x10) == 0) {
            goto LABEL_73;
          }
          if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2) {
            goto LABEL_132;
          }
          int v34 = v12;
          uint64_t v35 = v13;
          uint64_t v68 = a3;
          int v69 = a1;
          BOOL v36 = v10;
          unsigned int v37 = a4;
          int v38 = a6;
          unsigned int v39 = __CFPrecomposeCharKorean(a2 - 1);
          if (!v39)
          {
            a6 = v38;
            a4 = v37;
LABEL_140:
            BOOL v10 = v36;
            uint64_t v13 = v35;
            if (v34) {
              goto LABEL_133;
            }
            goto LABEL_141;
          }
          a6 = v38;
          a4 = v37;
          if (v39 < 0xA1) {
            goto LABEL_140;
          }
          uint64_t v11 = 0xF73Eu;
          int v40 = (unsigned __int16 *)&KSX1001_from_uni;
          uint64_t v41 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
          int v12 = v34;
          while (2)
          {
            uint64_t v42 = (0xF83E0F83E0F83E1 * (v41 - v40)) >> 1;
            BOOL v43 = &v40[33 * v42];
            unsigned int v44 = *v43;
            if (v44 > v39)
            {
              uint64_t v41 = v43 - 33;
              goto LABEL_88;
            }
            if (v44 + 32 <= v39)
            {
              int v40 = v43 + 33;
LABEL_88:
              if (v40 > v41) {
                goto LABEL_130;
              }
              continue;
            }
            break;
          }
          unsigned int v49 = v40[33 * v42 + 1 + (int)(v39 - v44)];
          if (v40[33 * v42 + 1 + (int)(v39 - v44)]) {
            BOOL v50 = v49 == 65533;
          }
          else {
            BOOL v50 = 1;
          }
          if (v50)
          {
LABEL_130:
            BOOL v10 = v36;
LABEL_131:
            uint64_t v13 = v35;
            goto LABEL_132;
          }
          BOOL v10 = v36;
          if (v49 >> 8 < 0xA1) {
            goto LABEL_131;
          }
          uint64_t v13 = v35;
          if (v49 >> 8 == 255
            || v40[33 * v42 + 1 + (int)(v39 - v44)] < 0xA1u
            || v40[33 * v42 + 1 + (int)(v39 - v44)] == 255)
          {
            goto LABEL_132;
          }
          BOOL v10 = v34 != 0;
          if (v34) {
            uint64_t v51 = v35 + 1;
          }
          else {
            uint64_t v51 = v35;
          }
          uint64_t v52 = -2;
          if (v34 != 0 && !v36) {
            uint64_t v52 = -1;
          }
          uint64_t v13 = v51 + ((v34 != 0) & !v36);
          if (!a5)
          {
            a1 = v69;
            a3 = v68;
            goto LABEL_71;
          }
          a1 = v69;
          if (v13 > a5)
          {
            if (v34) {
              uint64_t v67 = -1;
            }
            else {
              uint64_t v67 = 0;
            }
            v13 += v67 - ((v34 != 0) & !v36);
            goto LABEL_168;
          }
          unsigned int v53 = &a4[v52];
          if (v34) {
            *v53++ = 14;
          }
          a3 = v68;
          *unsigned int v53 = BYTE1(v49) & 0x7F;
          a4 = v53 + 2;
          v53[1] = v49 & 0x7F;
LABEL_71:
          int v12 = 0;
LABEL_72:
          ++a2;
          ++v9;
LABEL_73:
          if (v9 >= a3)
          {
LABEL_132:
            if (v12)
            {
LABEL_133:
              uint64_t v8 = v13;
              goto LABEL_134;
            }
LABEL_141:
            uint64_t v8 = v13 + 1;
            if (!a5) {
              goto LABEL_134;
            }
LABEL_142:
            if (v13 < a5)
            {
              *a4 = 15;
              goto LABEL_134;
            }
            uint64_t v56 = a2 - 1;
            while (1)
            {
              unsigned int v58 = *v56--;
              unsigned int v57 = v58;
              uint64_t v59 = (1 << (v58 - 6)) & 0x4000000000005;
              if ((v58 - 774 > 0x32 || v59 == 0) && v57 - 12441 >= 2)
              {
                unsigned int v62 = v57 >> 5;
                unsigned int v63 = v57 >> 9;
                BOOL v64 = v62 < 0x8B || v63 > 8;
                if (v64 || v9 < 2)
                {
LABEL_162:
                  --v9;
                  if (v10)
                  {
                    uint64_t v8 = v13 - 3;
                  }
                  else
                  {
                    *(a4 - 2) = 15;
                    uint64_t v8 = v13 - 1;
                  }
                  goto LABEL_134;
                }
              }
              else if (v9 <= 1)
              {
                goto LABEL_162;
              }
              --v9;
            }
          }
          goto LABEL_10;
        }
        unsigned int v21 = v24 + 33;
      }
      else
      {
        uint64_t v22 = v24 - 33;
      }
      if (v21 > v22) {
        goto LABEL_49;
      }
    }
  }
  BOOL v10 = v12 == 0;
  if (v12) {
    uint64_t v17 = v13;
  }
  else {
    uint64_t v17 = v13 + 1;
  }
  uint64_t v13 = v17 + 1;
  if (!a5)
  {
LABEL_31:
    ++a2;
    ++v9;
    int v12 = 1;
    goto LABEL_73;
  }
  if (v17 < a5)
  {
    if (!v12) {
      *a4++ = 15;
    }
    *a4++ = v14;
    goto LABEL_31;
  }
  uint64_t v55 = -2;
  if (v12) {
    uint64_t v55 = -1;
  }
  uint64_t v8 = v13 + v55;
LABEL_134:
  *a6 = v8;
  return v9;
}

uint64_t __CFFromISO_2022_KR(uint64_t a1, char *__s1, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v41 = a1 & 0xC0;
  int v14 = 1;
  while (2)
  {
    if (a5 && v12 >= a5) {
      goto LABEL_67;
    }
    int v15 = *__s1;
    if (v9 >= 4 && v15 == 27)
    {
      if (!strncmp(__s1, "\x1B$)C", 4uLL))
      {
        uint64_t v17 = 4;
        goto LABEL_36;
      }
      int v16 = 27;
    }
    else
    {
      if (v15 == 14)
      {
        int v14 = 0;
        uint64_t v17 = 1;
        goto LABEL_36;
      }
      int v16 = *__s1;
      if (v15 == 15) {
        goto LABEL_15;
      }
    }
    if (v14)
    {
      if (a5) {
        *a4++ = v15;
      }
      *a6 = ++v12;
LABEL_15:
      uint64_t v17 = 1;
      int v14 = 1;
      goto LABEL_36;
    }
    if (v9 < 2
      || (v16 | 0x80u) < 0xA1
      || (v16 | 0x80) == 0xFF
      || (int v18 = __s1[1], (v18 | 0x80u) < 0xA1)
      || (v18 | 0x80) == 0xFF)
    {
      if (a1)
      {
        if (a5) {
          *a4++ = 63;
        }
        int v14 = 0;
        *a6 = ++v12;
        uint64_t v17 = 1;
        if (v9 > 1) {
          uint64_t v17 = 2;
        }
        goto LABEL_36;
      }
      goto LABEL_66;
    }
    unsigned __int16 v19 = v18 | ((_WORD)v16 << 8) | 0x8080;
    unsigned int v20 = v19;
    if ((unsigned __int16)(v19 + 478) < 0x831Fu) {
      break;
    }
    unsigned int v21 = (unsigned __int16 *)&KSX1001_to_uni;
    uint64_t v22 = (unsigned __int16 *)((char *)&KSX1001_to_uni + 40820);
    while (1)
    {
      uint64_t v23 = (0xFC0FC0FC0FC0FC1 * (v22 - v21)) >> 1;
      uint64_t v24 = &v21[65 * v23];
      unsigned int v25 = *v24;
      if (v25 <= v20) {
        break;
      }
      uint64_t v22 = v24 - 65;
LABEL_28:
      if (v21 > v22) {
        goto LABEL_44;
      }
    }
    if (v25 + 64 <= v20)
    {
      unsigned int v21 = v24 + 65;
      goto LABEL_28;
    }
    unsigned __int16 v27 = v21[65 * v23 + 1 + (int)(v20 - v25)];
    if (v27) {
      BOOL v28 = v21[65 * v23 + 1 + (int)(v20 - v25)] == 65533;
    }
    else {
      BOOL v28 = 1;
    }
    if (!v28)
    {
      if (!v41
        || !__CFStringEncodingIsDecomposableCharacter_0(v21[65 * v23 + 1 + (int)(v20 - v25)], (a1 >> 7) & 1))
      {
        if (a5) {
          *a4++ = v27;
        }
        int v14 = 0;
        uint64_t v12 = *a6 + 1;
        goto LABEL_52;
      }
      uint64_t v35 = __CFStringEncodingDecomposeCharacter_0(a1, v27, v42, v30, v31, v32, v33, v34);
      uint64_t v36 = *a6;
      uint64_t v12 = *a6 + v35;
      *a6 = v12;
      if (!a5) {
        goto LABEL_61;
      }
      if (v12 > a5)
      {
        int v14 = 0;
        *a6 = v36;
        uint64_t v12 = v36;
        goto LABEL_68;
      }
      if (v35 >= 1)
      {
        unint64_t v37 = v35 + 1;
        int v38 = (__int16 *)v42;
        do
        {
          unsigned __int16 v39 = *v38++;
          *a4++ = v39;
          --v37;
        }
        while (v37 > 1);
      }
LABEL_61:
      int v14 = 0;
LABEL_53:
      uint64_t v17 = 2;
LABEL_36:
      v13 += v17;
      __s1 += v17;
      BOOL v26 = (uint64_t)v9 <= v17;
      v9 -= v17;
      if (v26) {
        return v13;
      }
      continue;
    }
    break;
  }
LABEL_44:
  if ((unsigned __int16)(v20 + 13919) <= 0x5Du)
  {
    if (a5)
    {
      unsigned __int16 v29 = v20 + 5727;
      goto LABEL_50;
    }
    goto LABEL_51;
  }
  if ((unsigned __int16)(v20 + 351) <= 0x5Du)
  {
    if (a5)
    {
      unsigned __int16 v29 = v20 - 3907;
LABEL_50:
      *a4++ = v29;
    }
LABEL_51:
    int v14 = 0;
    ++v12;
LABEL_52:
    *a6 = v12;
    goto LABEL_53;
  }
LABEL_66:
  int v14 = 0;
LABEL_67:
  if (a5)
  {
LABEL_68:
    if (v9 == 1 && !v14 && v12 == a5 && *__s1 == 15) {
      ++v13;
    }
  }
  return v13;
}

uint64_t __CFToISO_2022_KRLen(unsigned int a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3 = (a1 >> 6) & 4;
  if (a3)
  {
    BOOL v4 = 1;
    do
    {
      unsigned int v6 = *a2++;
      unsigned int v5 = v6;
      if (v4) {
        uint64_t v7 = 1;
      }
      else {
        uint64_t v7 = 2;
      }
      if (v4) {
        uint64_t v8 = 3;
      }
      else {
        uint64_t v8 = 2;
      }
      BOOL v4 = v5 < 0x80;
      if (v5 >= 0x80) {
        uint64_t v7 = v8;
      }
      v3 += v7;
      --a3;
    }
    while (a3);
    BOOL v9 = v5 > 0x7F;
  }
  else
  {
    BOOL v9 = 0;
  }
  return v3 + v9;
}

uint64_t __CFFromISO_2022_KRLen(int a1, char *__s1, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    uint64_t v5 = 0;
    char v6 = 1;
    while (1)
    {
      int v7 = *__s1;
      if ((unint64_t)v3 >= 4 && v7 == 27)
      {
        if (strncmp(__s1, "\x1B$)C", 4uLL)) {
          goto LABEL_10;
        }
        uint64_t v8 = -4;
        uint64_t v9 = 4;
      }
      else if (v7 == 14)
      {
        char v6 = 0;
        uint64_t v8 = -1;
        uint64_t v9 = 1;
      }
      else
      {
        if (v7 != 15)
        {
LABEL_10:
          if (v6) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = (unint64_t)v3 >= 2;
          }
          int v11 = !v10;
          ++v5;
          BOOL v12 = v11 == 0;
          if (v11) {
            uint64_t v9 = 1;
          }
          else {
            uint64_t v9 = 2;
          }
          if (v11) {
            uint64_t v8 = -1;
          }
          else {
            uint64_t v8 = -2;
          }
          if (v12) {
            char v6 = 0;
          }
          goto LABEL_26;
        }
        uint64_t v9 = 1;
        uint64_t v8 = -1;
        char v6 = 1;
      }
LABEL_26:
      __s1 += v9;
      BOOL v13 = __OFADD__(v3, v8);
      v3 += v8;
      if ((v3 < 0) ^ v13 | (v3 == 0)) {
        return v5;
      }
    }
  }
  return 0;
}

uint64_t __CFToMacKorean(int a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  v166[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    goto LABEL_452;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v163 = 0;
  v166[0] = 0;
  unsigned __int16 v165 = 0;
  BOOL v12 = 1;
LABEL_3:
  if (a5 && v10 >= a5)
  {
    if ((a1 & 0x10) == 0) {
      goto LABEL_452;
    }
    unsigned int v13 = *a2;
    if (v13 - 774 <= 0x32 && ((1 << (v13 - 6)) & 0x4000000000005) != 0 || v13 - 12441 < 2)
    {
LABEL_13:
      unsigned __int16 v165 = *a2;
      goto LABEL_16;
    }
    int v26 = v13 & 0xFFF0;
    if (v26 != 8400 && v26 != 8416 && v26 != 63600)
    {
      if (v13 != 839 && v13 != 822) {
        goto LABEL_452;
      }
      goto LABEL_13;
    }
  }
  else
  {
    unsigned int v13 = *a2;
  }
  unsigned __int16 v165 = v13;
  if (v13 < 0x80) {
    goto LABEL_18;
  }
LABEL_16:
  if ((a1 & 0x80) != 0 && (unsigned __int16)(v13 - 133) <= 0x1Au)
  {
LABEL_18:
    if (a5) {
      *a4++ = v13;
    }
    ++v10;
    ++a2;
    uint64_t v16 = v11 + 1;
    BOOL v12 = 1;
    goto LABEL_110;
  }
  uint64_t v16 = v11 + 1;
  if (v11 + 1 < a3 && (__int16)a2[1] == -1921 && (v13 == 8211 || v13 == 65343 || v13 == 8230))
  {
    if (a5)
    {
      if (v13 != 65343)
      {
        if (v13 != 8230) {
          *a4++ = -126;
        }
        *a4++ = -1;
      }
      *a4++ = -124;
    }
    BOOL v12 = 0;
    ++v10;
    uint64_t v16 = v11 + 2;
    a2 += 2;
    goto LABEL_110;
  }
  if ((unsigned __int16)(v13 + 418) < 0x242u) {
    goto LABEL_40;
  }
  uint64_t v17 = (unsigned __int16 *)&MacKorean_from_uni_one_char;
  int v18 = (unsigned __int16 *)&unk_182E0AD9A;
  while (1)
  {
    uint64_t v19 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v18 - v17)) >> 1;
    unsigned int v20 = &v17[5 * v19];
    unsigned int v21 = *v20;
    if (v21 <= v13) {
      break;
    }
    int v18 = v20 - 5;
LABEL_39:
    if (v17 > v18) {
      goto LABEL_40;
    }
  }
  if (v21 + 4 <= v13)
  {
    uint64_t v17 = v20 + 5;
    goto LABEL_39;
  }
  uint64_t v27 = (uint64_t)&v17[5 * v19 + (int)(v13 - v21)];
  unsigned int v28 = *(unsigned __int16 *)(v27 + 2);
  if (*(_WORD *)(v27 + 2))
  {
    BOOL v12 = v28 < 0x100;
    if (v28 < 0x100) {
      uint64_t v29 = 1;
    }
    else {
      uint64_t v29 = 2;
    }
    uint64_t v30 = v29 + v10;
    if (a5)
    {
      if (v30 > a5) {
        goto LABEL_452;
      }
      if (v28 >= 0x100) {
        *a4++ = BYTE1(v28);
      }
      *a4++ = v28;
    }
    goto LABEL_108;
  }
LABEL_40:
  BOOL v164 = v12;
  uint64_t v22 = a3 - v11;
  unsigned int v23 = *a2;
  if (v23 - 4352 > 0xFE) {
    goto LABEL_71;
  }
  if (v22 < 2) {
    goto LABEL_72;
  }
  if (((v23 << 24) | 0xFFFFFFu) > 0x14FFFFFE) {
    goto LABEL_72;
  }
  unsigned int v24 = a2[1] - 4449;
  if (v24 > 0x15) {
    goto LABEL_72;
  }
  if ((unint64_t)v22 < 3)
  {
    int v25 = 0;
  }
  else
  {
    int v25 = a2[2] - 4519;
    if ((unsigned __int16)(a2[2] - 4519) > 0x1Cu) {
      int v25 = 0;
    }
  }
  int v31 = v25 + 28 * (v24 + 21 * (char)v23) - 21504;
  if ((unsigned __int16)v31 < 0xA1u)
  {
LABEL_72:
    unint64_t v37 = (unsigned __int16 *)&KSX1001_from_uni;
    int v38 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
    while (1)
    {
      uint64_t v39 = (0xF83E0F83E0F83E1 * (v38 - v37)) >> 1;
      int v40 = &v37[33 * v39];
      unsigned int v41 = *v40;
      if (v41 <= v23)
      {
        if (v41 + 32 > v23)
        {
          uint64_t v46 = (uint64_t)&v37[33 * v39 + (int)(v23 - v41)];
          LODWORD(v43) = *(unsigned __int16 *)(v46 + 2);
          if (*(_WORD *)(v46 + 2))
          {
            uint64_t v47 = 1;
            goto LABEL_97;
          }
          goto LABEL_78;
        }
        unint64_t v37 = v40 + 33;
      }
      else
      {
        int v38 = v40 - 33;
      }
      if (v37 > v38) {
        goto LABEL_78;
      }
    }
  }
  uint64_t v32 = (unsigned __int16 *)&KSX1001_from_uni;
  uint64_t v33 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
  while (1)
  {
    uint64_t v34 = (0xF83E0F83E0F83E1 * (v33 - v32)) >> 1;
    uint64_t v35 = &v32[33 * v34];
    unsigned int v36 = *v35;
    if (v36 <= (unsigned __int16)v31) {
      break;
    }
    uint64_t v33 = v35 - 33;
LABEL_70:
    if (v32 > v33) {
      goto LABEL_71;
    }
  }
  if (v36 + 32 <= (unsigned __int16)v31)
  {
    uint64_t v32 = v35 + 33;
    goto LABEL_70;
  }
  uint64_t v57 = (uint64_t)&v32[33 * v34 + (int)((unsigned __int16)v31 - v36)];
  LODWORD(v43) = *(unsigned __int16 *)(v57 + 2);
  if (!*(_WORD *)(v57 + 2))
  {
LABEL_71:
    if (v23 < 0xA1) {
      goto LABEL_78;
    }
    goto LABEL_72;
  }
  if ((__int16)v25 <= 0) {
    uint64_t v47 = 2;
  }
  else {
    uint64_t v47 = 3;
  }
  int v163 = v31;
LABEL_97:
  v166[0] = v47;
  if (v43 == 65533)
  {
LABEL_78:
    LOBYTE(v42) = -1;
    LOBYTE(v43) = -3;
  }
  else
  {
    LODWORD(v42) = v43 >> 8;
    if (v43 >> 8 >= 0xA1
      && v42 != 255
      && v43 >= 0xA1u
      && v43 != 255)
    {
      if (a5)
      {
        if (v10 + 2 > a5) {
          goto LABEL_452;
        }
        *(_WORD *)a4 = __rev16(v43);
        a4 += 2;
        uint64_t v47 = v166[0];
      }
      BOOL v12 = 0;
      uint64_t v16 = v47 + v11;
      v10 += 2;
      goto LABEL_106;
    }
  }
  if ((unsigned __int16)(v13 + 0x2000) <= 0xBBu)
  {
    uint64_t v30 = v10 + 2;
    if (a5)
    {
      if (v30 > a5) {
        goto LABEL_452;
      }
      if (v13 >= 0xE05E) {
        char v44 = -2;
      }
      else {
        char v44 = -55;
      }
      *a4 = v44;
      if (v165 >= 0xE05Eu) {
        char v45 = 67;
      }
      else {
        char v45 = -95;
      }
      a4[1] = v45 + v165;
      a4 += 2;
    }
LABEL_107:
    BOOL v12 = 0;
LABEL_108:
    ++a2;
LABEL_109:
    uint64_t v10 = v30;
    goto LABEL_110;
  }
  if ((unsigned __int16)(v13 - 4447) <= 1u)
  {
    ++a2;
LABEL_94:
    BOOL v12 = v164;
    goto LABEL_110;
  }
  if ((a1 & 8) != 0) {
    goto LABEL_452;
  }
  if ((a1 & 0x10) == 0)
  {
    uint64_t v16 = v11;
    goto LABEL_94;
  }
  BOOL v49 = v13 == 63584 || (unsigned __int16)(v13 + 1945) < 3u;
  if (v22 < 3 || !v49)
  {
    if (v22 > 3 && v13 == 63585)
    {
      int v53 = a2[1];
      if (v53 == 40)
      {
        unsigned int v74 = a2[2];
        char v75 = v74 - 65;
        if (v74 - 65 > 0x19 || a2[3] != 41) {
          goto LABEL_452;
        }
        if (v74 >= 0x56) {
          char v76 = 108;
        }
        else {
          char v76 = 105;
        }
        char v55 = v75 + v76;
        char v54 = -93;
      }
      else
      {
        if (v53 != 8224 || a2[2] != 8224 || a2[3] != 8224) {
          goto LABEL_452;
        }
        char v54 = -90;
        char v55 = 70;
      }
      uint64_t v30 = v10 + 2;
      if (a5)
      {
        if (v30 > a5) {
          goto LABEL_452;
        }
        *a4 = v54;
        a4[1] = v55;
        a4 += 2;
      }
      BOOL v12 = 0;
      a2 += 4;
      uint64_t v16 = v11 + 4;
      goto LABEL_109;
    }
    if (v22 >= 5 && (unsigned __int16)(v13 + 1950) <= 4u)
    {
      int v56 = a2[1];
      if (v56 == 91)
      {
        int v77 = a2[2];
        if (v77 == 50)
        {
          if (a2[3] == 48 && a2[4] == 93)
          {
            char v79 = v13 - 98;
            if ((unsigned __int16)(v13 + 1950) < 5u)
            {
              unint64_t v43 = 0xF66854F954uLL >> (8 * v79);
              unint64_t v42 = 0xACA4A3A2A4uLL >> (8 * v79);
            }
            goto LABEL_399;
          }
        }
        else if (v77 == 49)
        {
          unsigned int v78 = a2[3];
          if (v78 - 48 <= 9 && a2[4] == 93)
          {
            switch(v13)
            {
              case 0xF862u:
                LOBYTE(v43) = v78 + 26;
                goto LABEL_394;
              case 0xF863u:
                LOBYTE(v43) = v78 - 65;
                LOBYTE(v42) = -94;
                break;
              case 0xF864u:
                LOBYTE(v43) = v78 + 26;
                LOBYTE(v42) = -93;
                break;
              case 0xF865u:
                LOBYTE(v43) = v78 + 46;
LABEL_394:
                LOBYTE(v42) = -92;
                break;
              case 0xF866u:
                if (v78 >= 0x36) {
                  char v137 = -20;
                }
                else {
                  char v137 = -53;
                }
                LOBYTE(v43) = v78 - 48 + v137;
                LOBYTE(v42) = -84;
                break;
              default:
                goto LABEL_399;
            }
            goto LABEL_399;
          }
        }
      }
      else if (v56 == 51452 && a2[2] == 49885 && a2[3] == 54924 && a2[4] == 49324)
      {
        if (v13 == 63587)
        {
          LOBYTE(v42) = -89;
          LOBYTE(v43) = -127;
        }
        else if (v13 == 63586)
        {
          LOBYTE(v42) = -89;
          LOBYTE(v43) = 125;
        }
        goto LABEL_399;
      }
      if (v13 > 0xF864) {
        goto LABEL_452;
      }
      if (v56 != 40)
      {
        if (v13 > 0xF863 || v56 != 91 || a2[4] != 93) {
          goto LABEL_452;
        }
        int v82 = a2[2];
        if (v82 == 21313)
        {
          unsigned int v87 = a2[3] | (v13 << 16);
          if (v87 + 127707428 < 0xFFFEF724) {
            goto LABEL_452;
          }
          uint64_t v88 = (unsigned int *)&MacKorean_from_uni_0xF862_3;
          UniChar v89 = (unsigned int *)&unk_182E0B570;
          while (1)
          {
            uint64_t v90 = ((char *)v89 - (char *)v88) >> 4;
            UniChar v91 = &v88[2 * v90];
            if (*v91 <= v87)
            {
              if (*v91 >= v87)
              {
                LODWORD(v43) = LOWORD(v88[2 * v90 + 1]);
                LODWORD(v42) = v43 >> 8;
                goto LABEL_399;
              }
              uint64_t v88 = v91 + 2;
            }
            else
            {
              UniChar v89 = v91 - 2;
            }
            if (v88 > v89) {
              goto LABEL_452;
            }
          }
        }
        if (v82 != 20108 || a2[3] != 21313) {
          goto LABEL_452;
        }
        if (v13 == 63586) {
          LOBYTE(v43) = 104;
        }
        else {
          LOBYTE(v43) = 84;
        }
        LOBYTE(v42) = -83;
        goto LABEL_399;
      }
      int v80 = a2[2];
      if (v80 != 50)
      {
        if (v80 != 51 || a2[3] != 48 || a2[4] != 41) {
          goto LABEL_452;
        }
        char v81 = v13 - 98;
        if ((unsigned __int16)(v13 + 1950) < 3u)
        {
          LODWORD(v43) = 0xFCFEFAu >> (8 * v81);
          LODWORD(v42) = 0xA5A7ABu >> (8 * v81);
        }
        goto LABEL_399;
      }
      unsigned int v83 = a2[3];
      __int16 v84 = v83 - 49;
      if (v83 - 49 > 8 || a2[4] != 41) {
        goto LABEL_452;
      }
      switch(v13)
      {
        case 0xF864u:
          BOOL v85 = v83 >= 0x37;
          LOWORD(v42) = -23053;
          __int16 v86 = -22791;
          break;
        case 0xF863u:
          LOBYTE(v43) = v83 - 60;
          LOBYTE(v42) = -89;
LABEL_399:
          if (a5)
          {
            if (v10 + 2 > a5) {
              goto LABEL_452;
            }
            *a4 = v42;
            a4[1] = v43;
            a4 += 2;
          }
          BOOL v12 = 0;
          a2 += 5;
          uint64_t v16 = v11 + 5;
          v10 += 2;
          goto LABEL_110;
        case 0xF862u:
          BOOL v85 = v83 >= 0x37;
          LOWORD(v42) = -21519;
          __int16 v86 = -21767;
          break;
        default:
          goto LABEL_399;
      }
      if (!v85) {
        LOWORD(v42) = v86;
      }
      LOBYTE(v43) = v84 + v42;
      LOBYTE(v42) = (unsigned __int16)(v84 + v42) >> 8;
      goto LABEL_399;
    }
    if (v22 > 1)
    {
      int v64 = a2[1];
      int v65 = v64 & 0xFFF0;
      unsigned int v66 = v64 | (v13 << 16);
      if (v65 == 63600 && v66 + 12584832 >= 0xE1FFF7)
      {
        uint64_t v67 = (unsigned int *)&MacKorean_from_uni_0xF870;
        uint64_t v68 = (unsigned int *)&unk_182E0C168;
        do
        {
          uint64_t v69 = ((char *)v68 - (char *)v67) >> 4;
          uint64_t v70 = &v67[2 * v69];
          if (*v70 <= v66)
          {
            if (*v70 >= v66)
            {
LABEL_247:
              uint64_t v30 = v10 + 2;
              if (a5)
              {
                if (v30 > a5) {
                  goto LABEL_452;
                }
                *(_WORD *)a4 = __rev16(LOWORD(v67[2 * v69 + 1]));
                a4 += 2;
              }
              BOOL v12 = 0;
              a2 += 2;
              uint64_t v16 = v11 + 2;
              goto LABEL_109;
            }
            uint64_t v67 = v70 + 2;
          }
          else
          {
            uint64_t v68 = v70 - 2;
          }
        }
        while (v67 <= v68);
      }
      if (v66 - 721224520 >= 0xFAB71D9C)
      {
        uint64_t v67 = (unsigned int *)&MacKorean_from_uni_other_two_char;
        uint64_t v71 = (unsigned int *)&unk_182E0C188;
        do
        {
          uint64_t v69 = ((char *)v71 - (char *)v67) >> 4;
          uint64_t v72 = &v67[2 * v69];
          if (*v72 <= v66)
          {
            if (*v72 >= v66) {
              goto LABEL_247;
            }
            uint64_t v67 = v72 + 2;
          }
          else
          {
            uint64_t v71 = v72 - 2;
          }
        }
        while (v67 <= v71);
      }
    }
    if (v11 < 1) {
      goto LABEL_452;
    }
    v162 = a6;
    if ((int)v13 > 823)
    {
      if (v13 - 12441 >= 2)
      {
        if (v13 != 824)
        {
          if (v13 == 839)
          {
            if (*(a2 - 1) != 8741) {
              goto LABEL_309;
            }
            if (a5)
            {
              __int16 v73 = -24924;
              goto LABEL_209;
            }
LABEL_210:
            BOOL v12 = 0;
            ++a2;
            goto LABEL_110;
          }
LABEL_282:
          switch(v13)
          {
            case 0x20DDu:
              int v95 = v163;
              if (*(a2 - 1) - 4352 >= 0xFF) {
                int v95 = *(a2 - 1);
              }
              if (v22 < 2
                || (__int16)a2[1] != -1926
                || (unsigned __int16)((unsigned __int16)v95 >> 10) < 0x2Bu
                || (unsigned __int16)v95 > 0xD574u)
              {
                goto LABEL_295;
              }
              v96 = (unsigned __int16 *)&MacKorean_from_uni_0x20DD_0xF87A;
              uint64_t v97 = (unsigned __int16 *)&unk_182E0AE30;
              while (1)
              {
                uint64_t v98 = ((char *)v97 - (char *)v96) >> 3;
                v99 = &v96[2 * v98];
                unsigned int v100 = *v99;
                if (v100 <= (unsigned __int16)v95)
                {
                  if (v100 >= (unsigned __int16)v95)
                  {
                    long long v130 = &v96[2 * v98 + 1];
                    uint64_t v131 = 2;
LABEL_404:
                    if (v164) {
                      uint64_t v138 = v10 + 1;
                    }
                    else {
                      uint64_t v138 = v10;
                    }
                    int v163 = v95;
                    if (!a5)
                    {
LABEL_412:
                      BOOL v12 = 0;
                      uint64_t v16 = v131 + v11;
                      uint64_t v10 = v138;
                      a2 += v131;
                      goto LABEL_110;
                    }
                    if (v138 <= a5)
                    {
                      unsigned int v139 = *v130;
                      uint64_t v140 = -2;
                      if (v164) {
                        uint64_t v140 = -1;
                      }
                      CFRange v141 = &a4[v140];
                      *(_WORD *)CFRange v141 = __rev16(v139);
                      a4 = v141 + 2;
                      goto LABEL_412;
                    }
                    uint64_t v158 = v138 - 1;
                    BOOL v159 = !v164;
LABEL_458:
                    if (!v159) {
                      uint64_t v10 = v158;
                    }
                    goto LABEL_452;
                  }
                  v96 = v99 + 2;
                }
                else
                {
                  uint64_t v97 = v99 - 2;
                }
                if (v96 > v97)
                {
LABEL_295:
                  if ((unsigned __int16)(v95 + 10443) < 0x29C2u) {
                    goto LABEL_452;
                  }
                  uint64_t v101 = (unsigned __int16 *)&MacKorean_from_uni_0x20DD;
                  char v102 = (unsigned __int16 *)&unk_182E0AFC4;
                  while (1)
                  {
                    uint64_t v103 = ((char *)v102 - (char *)v101) >> 3;
                    v104 = &v101[2 * v103];
                    unsigned int v105 = *v104;
                    if (v105 <= (unsigned __int16)v95)
                    {
                      if (v105 >= (unsigned __int16)v95)
                      {
                        long long v130 = &v101[2 * v103 + 1];
                        uint64_t v131 = 1;
                        goto LABEL_404;
                      }
                      uint64_t v101 = v104 + 2;
                    }
                    else
                    {
                      char v102 = v104 - 2;
                    }
                    if (v101 > v102) {
                      goto LABEL_452;
                    }
                  }
                }
              }
            case 0x20DEu:
              int v113 = v163;
              if (*(a2 - 1) - 4352 >= 0xFF) {
                int v113 = *(a2 - 1);
              }
              if (v22 < 2) {
                goto LABEL_426;
              }
              int v114 = a2[1];
              if ((v114 & 0xFFF0) == 0xF870)
              {
                unsigned __int16 v165 = v113;
                if ((unsigned __int16)(v113 - 49) <= 8u)
                {
                  uint64_t v47 = 2;
                  switch(v114)
                  {
                    case 63605:
                      LOBYTE(v43) = v113 - 111;
                      LOBYTE(v42) = -84;
                      goto LABEL_441;
                    case 63610:
                      LOBYTE(v43) = v113 + 36;
                      goto LABEL_440;
                    case 63611:
                      LOBYTE(v43) = v113 + 16;
                      LOBYTE(v42) = -93;
                      goto LABEL_441;
                    case 63612:
                      LOBYTE(v43) = v113 - 75;
                      LOBYTE(v42) = -94;
                      goto LABEL_441;
                    case 63615:
                      LOBYTE(v43) = v113 + 16;
LABEL_440:
                      LOBYTE(v42) = -92;
                      goto LABEL_441;
                    default:
                      goto LABEL_442;
                  }
                }
              }
              if (v114 != 63612)
              {
                if (v114 == 63610)
                {
                  if ((unsigned __int16)(v113 + 2042) < 0x82Au) {
                    goto LABEL_452;
                  }
                  uint64_t v125 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
                  v126 = (unsigned __int16 *)&unk_182E0B118;
                  while (1)
                  {
                    uint64_t v127 = ((char *)v126 - (char *)v125) >> 3;
                    long long v128 = &v125[2 * v127];
                    unsigned int v129 = *v128;
                    if (v129 <= (unsigned __int16)v113)
                    {
                      if (v129 >= (unsigned __int16)v113)
                      {
                        unsigned __int16 v142 = v125[2 * v127 + 1];
                        if ((unsigned __int16)(v142 + 21163) > 9u)
                        {
LABEL_415:
                          if ((unsigned __int16)(v113 + 10891) < 0xB4C6u) {
                            goto LABEL_452;
                          }
                          CFRange v143 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE_F87A;
                          CFRange v144 = (unsigned __int16 *)&unk_182E0B144;
                          while (1)
                          {
                            uint64_t v145 = ((char *)v144 - (char *)v143) >> 3;
                            v146 = &v143[2 * v145];
                            unsigned int v147 = *v146;
                            if (v147 <= (unsigned __int16)v113)
                            {
                              if (v147 >= (unsigned __int16)v113)
                              {
                                LODWORD(v43) = v143[2 * v145 + 1];
                                LODWORD(v42) = v43 >> 8;
                                goto LABEL_441;
                              }
                              CFRange v143 = v146 + 2;
                            }
                            else
                            {
                              CFRange v144 = v146 - 2;
                            }
                            if (v143 > v144) {
                              goto LABEL_452;
                            }
                          }
                        }
                        LOBYTE(v43) = v142 - 20;
LABEL_425:
                        LOBYTE(v42) = -83;
LABEL_441:
                        uint64_t v47 = 2;
LABEL_442:
                        if (v164) {
                          uint64_t v154 = v10 + 1;
                        }
                        else {
                          uint64_t v154 = v10;
                        }
                        int v163 = v113;
                        if (a5)
                        {
                          if (v154 > a5)
                          {
                            uint64_t v158 = v154 - 1;
                            BOOL v159 = !v164;
                            goto LABEL_458;
                          }
                          uint64_t v155 = -2;
                          if (v164) {
                            uint64_t v155 = -1;
                          }
                          v156 = &a4[v155];
                          char *v156 = v42;
                          a4 = v156 + 2;
                          v156[1] = v43;
                        }
                        BOOL v12 = 0;
                        uint64_t v16 = v47 + v11;
                        uint64_t v10 = v154;
LABEL_106:
                        a2 += v47;
                        goto LABEL_110;
                      }
                      uint64_t v125 = v128 + 2;
                    }
                    else
                    {
                      v126 = v128 - 2;
                    }
                    if (v125 > v126) {
                      goto LABEL_415;
                    }
                  }
                }
LABEL_426:
                if ((unsigned __int16)(v113 + 2042) < 0x82Au) {
                  goto LABEL_452;
                }
                v149 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
                v150 = (unsigned __int16 *)&unk_182E0B118;
                while (1)
                {
                  uint64_t v151 = ((char *)v150 - (char *)v149) >> 3;
                  v152 = &v149[2 * v151];
                  unsigned int v153 = *v152;
                  if (v153 <= (unsigned __int16)v113)
                  {
                    if (v153 >= (unsigned __int16)v113)
                    {
                      LODWORD(v43) = v149[2 * v151 + 1];
                      LODWORD(v42) = v43 >> 8;
                      uint64_t v47 = 1;
                      goto LABEL_442;
                    }
                    v149 = v152 + 2;
                  }
                  else
                  {
                    v150 = v152 - 2;
                  }
                  if (v149 > v150) {
                    goto LABEL_452;
                  }
                }
              }
              if ((unsigned __int16)(v113 + 2042) < 0x82Au) {
                goto LABEL_452;
              }
              long long v132 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
              long long v133 = (unsigned __int16 *)&unk_182E0B118;
              while (1)
              {
                uint64_t v134 = ((char *)v133 - (char *)v132) >> 3;
                long long v135 = &v132[2 * v134];
                unsigned int v136 = *v135;
                if (v136 <= (unsigned __int16)v113)
                {
                  if (v136 >= (unsigned __int16)v113)
                  {
                    unsigned __int16 v148 = v132[2 * v134 + 1];
                    if ((unsigned __int16)(v148 + 21143) <= 6u)
                    {
                      LOBYTE(v43) = v148 + 14;
                      goto LABEL_425;
                    }
                    goto LABEL_426;
                  }
                  long long v132 = v135 + 2;
                }
                else
                {
                  long long v133 = v135 - 2;
                }
                if (v132 > v133) {
                  goto LABEL_426;
                }
              }
            case 0x20DFu:
              unsigned int v115 = *(a2 - 1);
              if (v115 > 0x25C6)
              {
                if (v115 == 9671)
                {
                  if (v16 < a3 && a2[1] == 8415)
                  {
                    char v116 = 97;
                    ++a2;
                    ++v11;
                  }
                  else
                  {
                    char v116 = 87;
                  }
                }
                else
                {
                  if (v115 != 63494) {
                    goto LABEL_452;
                  }
                  char v116 = 96;
                }
              }
              else if (v115 == 9632)
              {
                char v116 = 86;
              }
              else
              {
                if (v115 != 9633) {
                  goto LABEL_452;
                }
                char v116 = 89;
              }
              if (a5)
              {
                *(a4 - 2) = -90;
                *(a4 - 1) = v116;
              }
              BOOL v12 = 0;
              ++a2;
              uint64_t v16 = v11 + 1;
              goto LABEL_110;
            case 0x20E0u:
            case 0x20E1u:
            case 0x20E2u:
            case 0x20E3u:
              goto LABEL_309;
            case 0x20E4u:
              if (*(a2 - 1) != 35036) {
                goto LABEL_452;
              }
              if (a5) {
                *((_WORD *)a4 - 1) = 31911;
              }
              goto LABEL_372;
            case 0x20E5u:
              int v117 = *(a2 - 1);
              if (v117 == 8801)
              {
                if (!a5) {
                  goto LABEL_368;
                }
                __int16 v124 = 25511;
                goto LABEL_367;
              }
              if (v117 != 61) {
                goto LABEL_452;
              }
              uint64_t v30 = v10 + 1;
              if (a5)
              {
                if (v10 >= a5) {
                  goto LABEL_452;
                }
                __int16 v107 = 25255;
                goto LABEL_337;
              }
              goto LABEL_107;
            default:
              if (v13 != 8402) {
                goto LABEL_309;
              }
              int v106 = *(a2 - 1);
              if (v106 == 8801)
              {
                if (a5)
                {
                  __int16 v124 = 28327;
LABEL_367:
                  *((_WORD *)a4 - 1) = v124;
                }
LABEL_368:
                uint64_t v30 = v10;
              }
              else
              {
                if (v106 != 61) {
                  goto LABEL_452;
                }
                uint64_t v30 = v10 + 1;
                if (a5)
                {
                  if (v10 >= a5) {
                    goto LABEL_452;
                  }
                  __int16 v107 = 26023;
LABEL_337:
                  *(_WORD *)(a4++ - 1) = v107;
                }
              }
              goto LABEL_107;
          }
        }
        if (*(a2 - 1) == 8869)
        {
          if (a5) {
            *((_WORD *)a4 - 1) = 28071;
          }
          BOOL v12 = 0;
          ++a2;
          goto LABEL_110;
        }
      }
    }
    else if (v13 != 774)
    {
      if (v13 != 776)
      {
        if (v13 == 822)
        {
          if (*(a2 - 1) != 8765)
          {
LABEL_309:
            if ((v13 & 0xFFF0) != 0xF870) {
              goto LABEL_452;
            }
            unsigned int v108 = v13 | (*(a2 - 1) << 16);
            if (v108 + 12584832 < 0xE1FFF7) {
              goto LABEL_452;
            }
            unsigned int v109 = (unsigned int *)&MacKorean_from_uni_0xF870;
            uint64_t v110 = (unsigned int *)&unk_182E0C168;
            while (1)
            {
              uint64_t v111 = ((char *)v110 - (char *)v109) >> 4;
              v112 = &v109[2 * v111];
              if (*v112 <= v108)
              {
                if (*v112 >= v108)
                {
                  unsigned int v118 = LOWORD(v109[2 * v111 + 1]);
                  if (v118 >= 0x100) {
                    uint64_t v119 = 0;
                  }
                  else {
                    uint64_t v119 = -1;
                  }
                  if (v164) {
                    uint64_t v119 = 1;
                  }
                  v10 += v119;
                  if (a5)
                  {
                    if (v10 <= a5)
                    {
                      uint64_t v120 = -2;
                      if (v164) {
                        uint64_t v120 = -1;
                      }
                      long long v121 = &a4[v120];
                      if (v118 < 0x100)
                      {
                        uint64_t v123 = 1;
                        v122 = v121;
                      }
                      else
                      {
                        *long long v121 = BYTE1(v118);
                        v122 = v121 + 1;
                        uint64_t v123 = 2;
                      }
                      a4 = &v121[v123];
                      char *v122 = v118;
                      goto LABEL_372;
                    }
                    if (v164)
                    {
                      --v10;
                    }
                    else if (v118 < 0x100)
                    {
                      ++v10;
                    }
LABEL_463:
                    a6 = v162;
                    goto LABEL_452;
                  }
LABEL_372:
                  BOOL v12 = 0;
LABEL_373:
                  ++a2;
LABEL_110:
                  uint64_t v11 = v16;
                  if (v16 >= a3) {
                    goto LABEL_452;
                  }
                  goto LABEL_3;
                }
                unsigned int v109 = v112 + 2;
              }
              else
              {
                uint64_t v110 = v112 - 2;
              }
              if (v109 > v110) {
                goto LABEL_452;
              }
            }
          }
          if (a5)
          {
            __int16 v73 = 31143;
LABEL_209:
            *((_WORD *)a4 - 1) = v73;
            goto LABEL_210;
          }
          goto LABEL_210;
        }
        goto LABEL_282;
      }
      if (*(a2 - 1) == 45)
      {
        if (a5)
        {
          if (v10 >= a5) {
            goto LABEL_452;
          }
          *(_WORD *)(a4++ - 1) = 26535;
        }
        BOOL v12 = 0;
        ++v10;
        goto LABEL_373;
      }
    }
    v160 = a4;
    int v161 = a1;
    unsigned int v92 = __CFPrecomposeCharKorean(a2 - 1);
    unsigned __int16 v165 = v92;
    if (!v92) {
      goto LABEL_463;
    }
    unsigned int v13 = v92;
    LODWORD(v43) = __CFToKSX1001(&v165, 1, v166, 0);
    LODWORD(v42) = v43 >> 8;
    if (v43 == 65533)
    {
      a6 = v162;
      a1 = v161;
      a4 = v160;
    }
    else
    {
      a6 = v162;
      a1 = v161;
      a4 = v160;
      if (v42 >= 0xA1
        && (v43 & 0xFF00) != 0xFF00
        && v43 >= 0xA1u
        && v43 != 255)
      {
        if (v164) {
          uint64_t v93 = v10 + 1;
        }
        else {
          uint64_t v93 = v10;
        }
        if (a5)
        {
          if (v93 > a5)
          {
            uint64_t v158 = v93 - 1;
            BOOL v159 = !v164;
            goto LABEL_458;
          }
          uint64_t v94 = -2;
          if (v164) {
            uint64_t v94 = -1;
          }
          *(_WORD *)&v160[v94] = __rev16(v43);
          a4 = &v160[v94 + 2];
        }
        BOOL v12 = 0;
        ++a2;
        uint64_t v10 = v93;
        goto LABEL_110;
      }
    }
    goto LABEL_282;
  }
  unsigned int v50 = a2[1];
  if (v50 == 8225)
  {
    if (a2[2] == 8225)
    {
      LOBYTE(v51) = -90;
      LOBYTE(v52) = 69;
      goto LABEL_199;
    }
    goto LABEL_452;
  }
  if (v50 == 8224)
  {
    if (a2[2] == 8224)
    {
      LOBYTE(v51) = -90;
      LOBYTE(v52) = 68;
      goto LABEL_199;
    }
    goto LABEL_452;
  }
  if (v50 > 0x7F) {
    goto LABEL_452;
  }
  unsigned int v58 = a2[2];
  if (v58 > 0x7F) {
    goto LABEL_452;
  }
  unsigned int v59 = (v50 << 8) | (v13 << 16) | v58;
  if (v59 + 127325910 < 0xFFF6F815) {
    goto LABEL_452;
  }
  uint64_t v60 = (unsigned int *)&MacKorean_from_uni_0xF860;
  uint64_t v61 = (unsigned int *)&unk_182E0B4E0;
  while (2)
  {
    uint64_t v62 = ((char *)v61 - (char *)v60) >> 4;
    unsigned int v63 = &v60[2 * v62];
    if (*v63 > v59)
    {
      uint64_t v61 = v63 - 2;
      goto LABEL_156;
    }
    if (*v63 < v59)
    {
      uint64_t v60 = v63 + 2;
LABEL_156:
      if (v60 > v61) {
        goto LABEL_452;
      }
      continue;
    }
    break;
  }
  unsigned int v52 = LOWORD(v60[2 * v62 + 1]);
  unsigned int v51 = v52 >> 8;
LABEL_199:
  if (!a5)
  {
LABEL_202:
    BOOL v12 = 0;
    a2 += 3;
    uint64_t v16 = v11 + 3;
    v10 += 2;
    goto LABEL_110;
  }
  if (v10 + 2 <= a5)
  {
    *a4 = v51;
    a4[1] = v52;
    a4 += 2;
    goto LABEL_202;
  }
LABEL_452:
  *a6 = v10;
  return v11;
}

uint64_t __CFFromMacKorean(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v116 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  BOOL v14 = (a1 & 0x200) == 0;
  if ((a1 & 0x200) != 0) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = 2;
  }
  unsigned int v16 = a1 & 0xC0;
  if ((a1 & 0x200) != 0) {
    uint64_t v17 = 3;
  }
  else {
    uint64_t v17 = 4;
  }
LABEL_8:
  if (a5 && v12 >= a5) {
    return v13;
  }
  int v18 = *a2;
  if ((*a2 & 0x80000000) == 0 || (a1 & 0x80) != 0 && (v18 + 123) <= 0x1Au)
  {
    if (a5) {
      *a4++ = v18;
    }
LABEL_15:
    ++v12;
    goto LABEL_16;
  }
  switch(*a2)
  {
    case -128:
      if (a5) {
        *a4++ = 160;
      }
      goto LABEL_15;
    case -127:
      if (a5) {
        *a4++ = 8361;
      }
      goto LABEL_15;
    case -126:
      v12 += v15;
      if (!a5) {
        goto LABEL_16;
      }
      if (v12 > a5) {
        return v13;
      }
      *a4 = 8211;
      unsigned int v21 = a4 + 1;
      if ((a1 & 0x200) != 0) {
        goto LABEL_34;
      }
      goto LABEL_41;
    case -125:
      if (a5) {
        *a4++ = 169;
      }
      goto LABEL_15;
    case -124:
      v12 += v15;
      if (!a5) {
        goto LABEL_16;
      }
      if (v12 > a5) {
        return v13;
      }
      *a4 = -193;
      unsigned int v21 = a4 + 1;
      if ((a1 & 0x200) == 0) {
        goto LABEL_41;
      }
      goto LABEL_34;
    default:
      if (v18 == 255)
      {
        v12 += v15;
        if (a5)
        {
          if (v12 > a5) {
            return v13;
          }
          *a4 = 8230;
          unsigned int v21 = a4 + 1;
          if ((a1 & 0x200) != 0)
          {
LABEL_34:
            a4 = v21;
          }
          else
          {
LABEL_41:
            a4[1] = -1921;
            a4 += 2;
          }
        }
LABEL_16:
        uint64_t v19 = 1;
        goto LABEL_17;
      }
      if (v9 < 2) {
        return v13;
      }
      int v22 = a2[1];
      unsigned int v23 = v22 | (v18 << 8);
      if ((unsigned __int16)((v22 | ((_WORD)v18 << 8)) + 21070) >= 0xF39Bu)
      {
        unsigned int v24 = (unsigned __int16 *)&MacKorean_to_uni_one_char;
        int v25 = (unsigned __int16 *)&unk_182E0C5E6;
        do
        {
          uint64_t v26 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v25 - v24)) >> 1;
          uint64_t v27 = &v24[5 * v26];
          unsigned int v28 = *v27;
          if (v28 <= v23)
          {
            if (v28 + 4 > v23)
            {
              uint64_t v53 = (uint64_t)&v24[5 * v26 + (int)(v23 - v28)];
              uint64_t v54 = *(unsigned __int16 *)(v53 + 2);
              if (!*(_WORD *)(v53 + 2)) {
                break;
              }
              if (!v16) {
                goto LABEL_121;
              }
              BOOL v112 = v14;
              uint64_t v109 = v15;
              unsigned int v106 = v16;
              uint64_t v55 = v17;
              int IsDecomposableCharacter_0 = __CFStringEncodingIsDecomposableCharacter_0(v54, (a1 >> 7) & 1);
              uint64_t v17 = v55;
              unsigned int v16 = v106;
              uint64_t v15 = v109;
              BOOL v14 = v112;
              if (!IsDecomposableCharacter_0)
              {
LABEL_121:
                if (a5) {
                  *a4++ = v54;
                }
                uint64_t v12 = *a6 + 1;
                uint64_t v19 = 2;
LABEL_17:
                *a6 = v12;
                goto LABEL_18;
              }
              uint64_t v57 = __CFStringEncodingDecomposeCharacter_0(a1, v54, v115, v109, v55, v112, 8230, v106);
              uint64_t v49 = *a6;
              uint64_t v12 = *a6 + v57;
              *a6 = v12;
              if (!a5) {
                goto LABEL_159;
              }
              if (v12 > a5) {
                goto LABEL_198;
              }
              if (v57 >= 1)
              {
                unint64_t v58 = v57 + 1;
                unsigned int v59 = (__int16 *)v115;
                BOOL v14 = v112;
                uint64_t v15 = v109;
                unsigned int v16 = v106;
                uint64_t v17 = v55;
                do
                {
                  __int16 v60 = *v59++;
                  *a4++ = v60;
                  --v58;
                }
                while (v58 > 1);
                uint64_t v19 = 2;
                goto LABEL_18;
              }
LABEL_159:
              uint64_t v19 = 2;
              BOOL v14 = v112;
              uint64_t v15 = v109;
              unsigned int v16 = v106;
              uint64_t v17 = v55;
LABEL_18:
              v13 += v19;
              a2 += v19;
              BOOL v20 = (uint64_t)v9 <= v19;
              v9 -= v19;
              if (v20) {
                return v13;
              }
              goto LABEL_8;
            }
            unsigned int v24 = v27 + 5;
          }
          else
          {
            int v25 = v27 - 5;
          }
        }
        while (v24 <= v25);
      }
      if ((unsigned __int16)(v23 + 21070) < 0xF38Fu) {
        goto LABEL_71;
      }
      uint64_t v29 = (unsigned __int16 *)&MacKorean_to_uni_two_char;
      uint64_t v30 = (unsigned __int16 *)&unk_182E0DF26;
      break;
  }
  while (1)
  {
    uint64_t v31 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v30 - v29)) >> 1;
    uint64_t v32 = &v29[17 * v31];
    unsigned int v33 = *v32;
    if (v33 <= v23) {
      break;
    }
    uint64_t v30 = v32 - 17;
LABEL_56:
    if (v29 > v30) {
      goto LABEL_57;
    }
  }
  if (v33 + 16 <= v23)
  {
    uint64_t v29 = v32 + 17;
    goto LABEL_56;
  }
  unsigned __int16 v61 = v29[17 * v31 + 1 + (int)(v23 - v33)];
  if (v61)
  {
    uint64_t v62 = (char *)&__CFTwoCharDecompSeqTable + 4 * (v61 & 0x7FFF);
    unsigned int v65 = *((unsigned __int16 *)v62 - 2);
    unsigned int v63 = v62 - 4;
    uint64_t v64 = v65;
    if (v16)
    {
      uint64_t v101 = v63;
      uint64_t v104 = v17;
      unsigned int v107 = v16;
      uint64_t v110 = v15;
      BOOL v113 = v14;
      if (__CFStringEncodingIsDecomposableCharacter_0(v64, (a1 >> 7) & 1))
      {
        uint64_t v71 = __CFStringEncodingDecomposeCharacter_0(a1, v64, v115, v66, v67, v68, v69, v70);
        uint64_t v12 = v71 + !(((v61 & 0x8000u) != 0) & (a1 >> 9)) + *a6;
        if (a5)
        {
          BOOL v14 = v113;
          uint64_t v15 = v110;
          unsigned int v16 = v107;
          uint64_t v17 = v104;
          if (v12 > a5) {
            return v13;
          }
          if (v71 >= 1)
          {
            unint64_t v72 = v71 + 1;
            __int16 v73 = (__int16 *)v115;
            do
            {
              __int16 v74 = *v73++;
              *a4++ = v74;
              --v72;
            }
            while (v72 > 1);
          }
          if ((((v61 & 0x8000u) != 0) & (a1 >> 9)) == 0) {
            *a4++ = *((_WORD *)v101 + 1);
          }
LABEL_195:
          uint64_t v19 = 2;
          goto LABEL_17;
        }
        uint64_t v19 = 2;
        BOOL v14 = v113;
LABEL_188:
        uint64_t v15 = v110;
        unsigned int v16 = v107;
        uint64_t v17 = v104;
        goto LABEL_17;
      }
      uint64_t v12 = *a6;
      BOOL v14 = v113;
      uint64_t v15 = v110;
      unsigned int v16 = v107;
      unsigned int v63 = v101;
      uint64_t v17 = v104;
    }
    if ((((v61 & 0x8000u) != 0) & (a1 >> 9)) != 0) {
      uint64_t v89 = 1;
    }
    else {
      uint64_t v89 = 2;
    }
    v12 += v89;
    if (a5)
    {
      if (v12 <= a5)
      {
        *a4 = v64;
        if ((((v61 & 0x8000u) != 0) & (a1 >> 9)) != 0)
        {
          ++a4;
        }
        else
        {
          a4[1] = *((_WORD *)v63 + 1);
          a4 += 2;
        }
        uint64_t v19 = 2;
        goto LABEL_17;
      }
      return v13;
    }
    goto LABEL_169;
  }
LABEL_57:
  if ((unsigned __int16)(v23 + 21112) < 0xF3C9u) {
    goto LABEL_71;
  }
  uint64_t v34 = (unsigned __int16 *)&MacKorean_to_uni_three_char;
  uint64_t v35 = (unsigned __int16 *)&unk_182E0E256;
  while (1)
  {
    uint64_t v36 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v35 - v34)) >> 1;
    unint64_t v37 = &v34[17 * v36];
    unsigned int v38 = *v37;
    if (v38 <= v23) {
      break;
    }
    uint64_t v35 = v37 - 17;
LABEL_63:
    if (v34 > v35) {
      goto LABEL_64;
    }
  }
  if (v38 + 16 <= v23)
  {
    uint64_t v34 = v37 + 17;
    goto LABEL_63;
  }
  unsigned __int16 v76 = v34[17 * v36 + 1 + (int)(v23 - v38)];
  if (v76)
  {
    int v77 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v34[17 * v36 + 1 + (int)(v23 - v38)] & 0x7FFF);
    uint64_t v78 = *(unsigned __int16 *)v77;
    if (v16)
    {
      char v102 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v76 & 0x7FFF);
      uint64_t v104 = v17;
      unsigned int v107 = v16;
      uint64_t v110 = v15;
      BOOL v114 = v14;
      if (__CFStringEncodingIsDecomposableCharacter_0(v78, (a1 >> 7) & 1))
      {
        uint64_t v84 = __CFStringEncodingDecomposeCharacter_0(a1, v78, v115, v79, v80, v81, v82, v83);
        if ((((v76 & 0x8000u) != 0) & (a1 >> 9)) != 0) {
          uint64_t v85 = 1;
        }
        else {
          uint64_t v85 = 2;
        }
        uint64_t v12 = v84 + v85 + *a6;
        if (a5)
        {
          BOOL v14 = v114;
          uint64_t v15 = v110;
          unsigned int v16 = v107;
          uint64_t v17 = v104;
          if (v12 > a5) {
            return v13;
          }
          if (v84 >= 1)
          {
            unint64_t v86 = v84 + 1;
            unsigned int v87 = (__int16 *)v115;
            do
            {
              __int16 v88 = *v87++;
              *a4++ = v88;
              --v86;
            }
            while (v86 > 1);
          }
          *a4 = *((_WORD *)v102 + 1);
          BOOL v99 = !v114;
          if ((v76 & 0x8000u) != 0) {
            BOOL v99 = 0;
          }
          if (v99)
          {
            ++a4;
          }
          else
          {
            a4[1] = *((_WORD *)v102 + 2);
            a4 += 2;
          }
          goto LABEL_195;
        }
        uint64_t v19 = 2;
        BOOL v14 = v114;
        goto LABEL_188;
      }
      uint64_t v12 = *a6;
      BOOL v14 = v114;
      uint64_t v15 = v110;
      unsigned int v16 = v107;
      int v77 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v76 & 0x7FFF);
      uint64_t v17 = v104;
    }
    uint64_t v93 = 2;
    if ((((v76 & 0x8000u) != 0) & (a1 >> 9)) == 0) {
      uint64_t v93 = 3;
    }
    v12 += v93;
    if (a5)
    {
      if (v12 > a5) {
        return v13;
      }
      if ((((v76 & 0x8000u) != 0) & (a1 >> 9)) != 0)
      {
        *a4 = *((_WORD *)v77 + 1);
        uint64_t v94 = a4 + 1;
        goto LABEL_175;
      }
      a4[1] = *((_WORD *)v77 + 1);
      int v95 = a4 + 1;
      *a4 = v78;
      a4 += 2;
      uint64_t v94 = a4;
      BOOL v96 = !v14;
      if ((v76 & 0x8000u) != 0) {
        BOOL v96 = 0;
      }
      if (!v96)
      {
        a4 = v95;
LABEL_175:
        a4 += 2;
        *uint64_t v94 = *((_WORD *)v77 + 2);
LABEL_176:
        uint64_t v19 = 2;
        goto LABEL_17;
      }
LABEL_117:
      uint64_t v19 = 2;
      goto LABEL_17;
    }
LABEL_169:
    uint64_t v19 = 2;
    goto LABEL_17;
  }
LABEL_64:
  if ((unsigned __int16)(v23 + 21136) < 0xF57Fu) {
    goto LABEL_71;
  }
  uint64_t v39 = (unsigned __int16 *)&MacKorean_to_uni_five_char;
  int v40 = (unsigned __int16 *)&unk_182E0E432;
  while (1)
  {
    uint64_t v41 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v40 - v39)) >> 1;
    unint64_t v42 = &v39[17 * v41];
    unsigned int v43 = *v42;
    if (v43 <= v23) {
      break;
    }
    int v40 = v42 - 17;
LABEL_70:
    if (v39 > v40) {
      goto LABEL_71;
    }
  }
  if (v43 + 16 <= v23)
  {
    uint64_t v39 = v42 + 17;
    goto LABEL_70;
  }
  unsigned __int16 v90 = v39[17 * v41 + 1 + (int)(v23 - v43)];
  if (!v90)
  {
LABEL_71:
    if ((v18 + 1) >= 0xA2u && (v22 + 1) >= 0xA2u)
    {
      BOOL v111 = v14;
      uint64_t v108 = v15;
      unsigned int v105 = v16;
      uint64_t v103 = v17;
      uint64_t v44 = __CFFromKSX1001(v23);
      uint64_t v17 = v103;
      unsigned int v16 = v105;
      uint64_t v15 = v108;
      BOOL v14 = v111;
      uint64_t v45 = v44;
      if (v44 != 65533)
      {
        if (!v105
          || (int v47 = __CFStringEncodingIsDecomposableCharacter_0(v44, (a1 >> 7) & 1),
              uint64_t v17 = v103,
              unsigned int v16 = v105,
              uint64_t v15 = v108,
              BOOL v14 = v111,
              !v47))
        {
          if (a5) {
            *a4++ = v45;
          }
          uint64_t v12 = *a6 + 1;
          goto LABEL_176;
        }
        uint64_t v48 = __CFStringEncodingDecomposeCharacter_0(a1, v45, v115, v108, v103, v111, 8230, v105);
        uint64_t v49 = *a6;
        uint64_t v12 = *a6 + v48;
        *a6 = v12;
        if (a5)
        {
          if (v12 > a5)
          {
LABEL_198:
            *a6 = v49;
            return v13;
          }
          if (v48 >= 1)
          {
            unint64_t v50 = v48 + 1;
            unsigned int v51 = (__int16 *)v115;
            BOOL v14 = v111;
            uint64_t v15 = v108;
            unsigned int v16 = v105;
            uint64_t v17 = v103;
            do
            {
              __int16 v52 = *v51++;
              *a4++ = v52;
              --v50;
            }
            while (v50 > 1);
            uint64_t v19 = 2;
            goto LABEL_18;
          }
        }
        uint64_t v19 = 2;
        BOOL v14 = v111;
        uint64_t v15 = v108;
        unsigned int v16 = v105;
        uint64_t v17 = v103;
        goto LABEL_18;
      }
    }
    if ((unsigned __int16)(v23 + 13919) > 0x5Du)
    {
      if ((unsigned __int16)(v23 + 351) > 0x5Du)
      {
        if ((unsigned __int16)(v23 + 23703) > 0x1Cu)
        {
          if (v23 != 42566) {
            return v13;
          }
          v12 += v17;
          if (a5)
          {
            if (v12 > a5) {
              return v13;
            }
            if ((a1 & 0x200) == 0) {
              *a4++ = -1951;
            }
            *(_DWORD *)a4 = 538976288;
            a4[2] = 8224;
            a4 += 3;
            goto LABEL_176;
          }
        }
        else
        {
          v12 += v17;
          if (a5)
          {
            if (v12 > a5) {
              return v13;
            }
            if ((a1 & 0x200) == 0) {
              *a4++ = -1951;
            }
            *a4 = 40;
            if (v23 >= 0xA381) {
              __int16 v75 = 62;
            }
            else {
              __int16 v75 = 65;
            }
            a4[1] = v75 + v23 + 23703;
            a4[2] = 41;
            a4 += 3;
            goto LABEL_117;
          }
        }
        uint64_t v19 = 2;
        goto LABEL_17;
      }
      if (a5)
      {
        __int16 v46 = v23 - 3907;
        goto LABEL_80;
      }
    }
    else if (a5)
    {
      __int16 v46 = v23 + 5727;
LABEL_80:
      *a4++ = v46;
    }
    ++v12;
    goto LABEL_176;
  }
  unsigned int v91 = ((v90 & 0x8000u) != 0) & (a1 >> 9);
  uint64_t v92 = 4;
  if (!v91) {
    uint64_t v92 = 5;
  }
  v12 += v92;
  if (!a5)
  {
    uint64_t v19 = 2;
    goto LABEL_17;
  }
  if (v12 <= a5)
  {
    if ((v91 & 1) == 0) {
      *a4++ = __CFFiveCharDecompSeqTable[5 * (v90 & 0x7FFF)];
    }
    uint64_t v97 = (char *)&__CFFiveCharDecompSeqTable[5 * (v90 & 0x7FFF)];
    *(_DWORD *)a4 = *(_DWORD *)(v97 + 2);
    a4[2] = *((_WORD *)v97 + 3);
    BOOL v98 = !v14;
    if ((v90 & 0x8000u) != 0) {
      BOOL v98 = 0;
    }
    if (v98)
    {
      a4 += 3;
    }
    else
    {
      a4[3] = *((_WORD *)v97 + 4);
      a4 += 4;
    }
    uint64_t v19 = 2;
    goto LABEL_17;
  }
  return v13;
}

uint64_t __CFFromMacKoreanLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    unsigned int v4 = *a2;
    BOOL v5 = v4 >= 0x85 && (unint64_t)a3 >= 2;
    if (!v5 || v4 == 255)
    {
      ++a2;
      --a3;
    }
    else
    {
      a2 += 2;
      a3 -= 2;
      if ((v4 + 95) < 0xDu) {
        result += 5;
      }
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t CFStringEncodingByteLengthForCharacters(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  int v7 = a1;
  v14[1] = *(void *)off_1ECE0A5B0;
  uint64_t v8 = __CFGetConverter(a1);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = *v8;
  int v10 = *(unsigned __int8 *)(*v8 + 20);
  if (v10 != 4)
  {
    if (v10 == 5)
    {
      uint64_t v11 = v8[1];
      return __CFStringEncodingICUByteLength(v11, a2, (unint64_t)a3, a4);
    }
    if (*(_WORD *)(v9 + 16) != 1)
    {
      uint64_t v13 = *(uint64_t (**)(uint64_t, unsigned __int16 *, uint64_t))(v9 + 24);
      if (v13)
      {
        return v13(a2, a3, a4);
      }
      v14[0] = 0;
      if (CFStringEncodingUnicodeToBytes(v7, a2, a3, a4, 0, 0, 0, v14)) {
        return 0;
      }
      else {
        return v14[0];
      }
    }
    return a4;
  }

  return __CFStringEncodingPlatformByteLengthForCharacters();
}

_OWORD *CFStringEncodingRegisterFallbackProcedures(uint64_t a1, uint64_t (*a2)(unsigned __int16 *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5), uint64_t (*a3)(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5))
{
  uint64_t result = __CFGetConverter(a1);
  if (result)
  {
    int v7 = result;
    uint64_t result = __CFGetConverter(a1);
    if (result)
    {
      uint64_t v8 = *(void *)result;
      if (!a2)
      {
        if (v8) {
          a2 = *(uint64_t (**)(unsigned __int16 *, uint64_t, char *, uint64_t, uint64_t *))(v8 + 40);
        }
        else {
          a2 = __CFDefaultToBytesFallbackProc;
        }
      }
    }
    else
    {
      uint64_t v8 = 0;
      if (!a2) {
        a2 = __CFDefaultToBytesFallbackProc;
      }
    }
    *((void *)v7 + 4) = a2;
    if (!a3)
    {
      if (v8) {
        a3 = *(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t, void *))(v8 + 48);
      }
      else {
        a3 = __CFDefaultToUnicodeFallbackProc;
      }
    }
    *((void *)v7 + 5) = a3;
  }
  return result;
}

uint64_t __CFDefaultToBytesFallbackProc(unsigned __int16 *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  unint64_t v8 = *a1;
  if (v8 <= 0x9F)
  {
    char v9 = v8 ^ 0x80;
LABEL_3:
    uint64_t result = 1;
LABEL_4:
    if (a4) {
      *a3 = v9;
    }
    uint64_t v11 = 1;
    goto LABEL_7;
  }
  if (v8 <= 0xFF)
  {
    if (a4 >= 4 || a4 == 0) {
      uint64_t v13 = 4;
    }
    else {
      uint64_t v13 = a4;
    }
    if (v13 < 1)
    {
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = (char *)&_toLossyASCIITable + 4 * v8 - 640;
      while (v15[v14])
      {
        if (a4) {
          a3[v14] = v15[v14];
        }
        if (v13 == ++v14)
        {
          uint64_t v14 = v13;
          break;
        }
      }
    }
    *a5 = v14;
    return 1;
  }
  if (v8 >> 11 == 27)
  {
    char v9 = 63;
    uint64_t result = 1;
    if (a2 >= 2 && v8 <= 0xDC00)
    {
      unsigned int v17 = a1[1];
      unsigned int v18 = v17 >> 10;
      BOOL v19 = v17 >= 0xE000;
      uint64_t v20 = 1;
      if (!v19) {
        uint64_t v20 = 2;
      }
      if (v18 >= 0x37) {
        uint64_t result = v20;
      }
      else {
        uint64_t result = 1;
      }
      char v9 = 63;
    }
    goto LABEL_4;
  }
  if (CFUniCharIsMemberOf(*a1, 2u))
  {
    char v9 = 32;
    goto LABEL_3;
  }
  if (CFUniCharIsMemberOf(*a1, 3u))
  {
    char v9 = 10;
    goto LABEL_3;
  }
  int v21 = *a1;
  if (v21 == 8230)
  {
    if (!a4)
    {
      uint64_t result = 1;
      uint64_t v11 = 3;
LABEL_7:
      *a5 = v11;
      return result;
    }
    if (a4 >= 3)
    {
      a3[2] = 46;
      *(_WORD *)a3 = 11822;
      *a5 = 3;
      return 1;
    }
LABEL_45:
    char v9 = 63;
    goto LABEL_3;
  }
  if (!CFUniCharIsMemberOf(v21, 9u)) {
    goto LABEL_45;
  }
  CFUniCharDecomposeCharacter(*a1, v23, 10);
  char v9 = v23[0];
  if (v23[0] <= 0x7F) {
    goto LABEL_3;
  }
  __int16 v22 = v23[0];
  return __CFDefaultToBytesFallbackProc(&v22, 1, a3, a4, a5);
}

uint64_t __CFDefaultToUnicodeFallbackProc(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1;
  return 1;
}

uint64_t CFStringEncodingListOfAvailableEncodings()
{
  v19[1] = *(void *)off_1ECE0A5B0;
  uint64_t result = CFStringEncodingListOfAvailableEncodings_encodings;
  if (!CFStringEncodingListOfAvailableEncodings_encodings)
  {
    uint64_t v18 = 0;
    v19[0] = 0;
    unint64_t ICUEncodings = (unint64_t)__CFStringEncodingCreateICUEncodings(0, v19);
    uint64_t v2 = __CFStringEncodingCreateListOfAvailablePlatformConverters(0, &v18);
    if (ICUEncodings | v2)
    {
      unsigned int v4 = (void *)v2;
      uint64_t v5 = v19[0] + v18 + 14;
      uint64_t Typed = CFAllocatorAllocateTyped(0, 4 * v5, 0x100004052888210, 0);
      int v10 = (long long *)Typed;
      *(void *)(Typed + 48) = -3825204992;
      *(_OWORD *)uint64_t Typed = __CFBuiltinEncodings;
      *(_OWORD *)(Typed + 16) = unk_182E0E464;
      *(_OWORD *)(Typed + 32) = xmmword_182E0E474;
      if (ICUEncodings)
      {
        memcpy((void *)(Typed + 56), (const void *)ICUEncodings, 4 * v19[0]);
        CFAllocatorDeallocate(0, (void *)ICUEncodings);
      }
      if (v4)
      {
        memcpy((char *)v10 + 4 * v19[0] + 56, v4, 4 * v18);
        CFAllocatorDeallocate(0, v4);
      }
      CFQSortArray(v10, v5, 4, (uint64_t)__CFStringEncodingComparator, 0, v7, v8, v9);
      if (v5 >= 1)
      {
        uint64_t v11 = (int *)v10 + v5;
        int v12 = -1;
        uint64_t v13 = (int *)v10;
        do
        {
          uint64_t v14 = v13 + 1;
          int v15 = *v13;
          if (v12 == *v13)
          {
            if (v14 < v11) {
              memmove(v13, v14, (char *)v11 - (char *)v13 - 4);
            }
            --v11;
          }
          else
          {
            ++v13;
            int v12 = v15;
          }
        }
        while (v13 < v11);
      }
      uint64_t v16 = 0;
      atomic_compare_exchange_strong(&CFStringEncodingListOfAvailableEncodings_encodings, (unint64_t *)&v16, (unint64_t)v10);
      BOOL v17 = v16 == 0;
      if (v10 != &__CFBuiltinEncodings && !v17) {
        CFAllocatorDeallocate(0, v10);
      }
    }
    else
    {
      unint64_t v3 = ICUEncodings | v2;
      atomic_compare_exchange_strong(&CFStringEncodingListOfAvailableEncodings_encodings, &v3, (unint64_t)&__CFBuiltinEncodings);
    }
    return CFStringEncodingListOfAvailableEncodings_encodings;
  }
  return result;
}

uint64_t __CFStringEncodingComparator(_DWORD *a1, _DWORD *a2)
{
  uint64_t v2 = (unsigned __int16)*a1;
  uint64_t v3 = *a2;
  uint64_t v4 = *a1 - v3;
  uint64_t v5 = v2 - (unsigned __int16)v3;
  if (v2 == (unsigned __int16)*a2) {
    return v4;
  }
  else {
    return v5;
  }
}

uint64_t __CFToUnicodeCheapEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (a6 >= a4 || a6 == 0) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = a6;
  }
  if (v9 < 1)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    __int16 v17 = 0;
    while ((*(unsigned int (**)(uint64_t, void, __int16 *))(*(void *)a1 + 8))(a2, *(unsigned __int8 *)(a3 + v15), &v17))
    {
      if (a6) {
        *(_WORD *)(a5 + 2 * v15) = v17;
      }
      if (v9 == ++v15)
      {
        uint64_t v15 = v9;
        break;
      }
    }
  }
  *a7 = v15;
  return v15;
}

uint64_t __CFToCanonicalUnicodeCheapEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, void *a7)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  if (a4 < 1)
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unsigned __int16 v21 = 0;
    while ((!a6 || v14 < a6)
         && (*(unsigned int (**)(uint64_t, void, unsigned __int16 *))(*(void *)a1 + 8))(a2, *(unsigned __int8 *)(a3 + v15), &v21))
    {
      if (v21 >= 0x80u && CFUniCharIsMemberOf(v21, 0x65u))
      {
        uint64_t v16 = CFUniCharDecomposeCharacter(v21, v22, 10);
        *a7 = v14;
        if (v16 >= 1)
        {
          __int16 v17 = v22;
          do
          {
            unsigned int v18 = *v17;
            unsigned int v19 = *v17 - 0x10000;
            if (*v17 < 0x10000)
            {
              if (v14 >= a6) {
                return v15;
              }
              ++v14;
              *a5++ = v18;
            }
            else
            {
              v14 += 2;
              if (v14 > a6) {
                return v15;
              }
              if (a6)
              {
                *__int16 v17 = v19;
                *a5 = (v19 >> 10) - 10240;
                a5[1] = v18 & 0x3FF | 0xDC00;
                a5 += 2;
              }
            }
            ++v17;
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        if (a6) {
          *a5++ = v21;
        }
        ++v14;
      }
      if (++v15 == a4)
      {
        uint64_t v15 = a4;
        break;
      }
    }
  }
  *a7 = v14;
  return v15;
}

uint64_t __CFToBytesStandardEightBitWrapper(uint64_t (***a1)(uint64_t, uint64_t, uint64_t, char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  char v18 = 0;
  *a7 = 0;
  if (!a4) {
    return 0;
  }
  uint64_t v10 = a4;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  do
  {
    if (a6 && v14 >= a6) {
      break;
    }
    unsigned int v16 = (**a1)(a2, a3, v10, &v18);
    if (!v16) {
      break;
    }
    if (a6) {
      *(unsigned char *)(a5 + *a7) = v18;
    }
    uint64_t v14 = *a7 + 1;
    *a7 = v14;
    a3 += 2 * v16;
    v15 += v16;
    v10 -= v16;
  }
  while (v10);
  return v15;
}

uint64_t __CFToUnicodeStandardEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  v18[5] = *(void *)off_1ECE0A5B0;
  *a7 = 0;
  if (a4 < 1) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  while (!a6 || v14 < a6)
  {
    unsigned int v16 = (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a1 + 8))(a2, *(unsigned __int8 *)(a3 + v15), v18);
    if (!v16) {
      break;
    }
    uint64_t v14 = *a7 + v16;
    if (a6)
    {
      if (v14 > a6) {
        return v15;
      }
      memcpy((void *)(a5 + 2 * *a7), v18, 2 * v16);
    }
    *a7 = v14;
    if (a4 == ++v15) {
      return a4;
    }
  }
  return v15;
}

uint64_t __CFToCanonicalUnicodeStandardEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _WORD *a5, uint64_t a6, void *a7)
{
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  if (a4 < 1)
  {
    uint64_t v13 = 0;
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v10 = a3;
    uint64_t v11 = a2;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unsigned int v23 = a2;
    while (!a6 || v12 < a6)
    {
      uint64_t v14 = a1;
      unsigned int v15 = (*(uint64_t (**)(uint64_t, void, _WORD *))(*(void *)a1 + 8))(v11, *(unsigned __int8 *)(v10 + v13), v26);
      if (!v15) {
        break;
      }
      uint64_t v16 = 0;
      uint64_t v17 = v15;
      do
      {
        unsigned int v18 = (unsigned __int16)v26[v16];
        if (v18 >= 0x80 && CFUniCharIsMemberOf(v18, 0x65u))
        {
          uint64_t v19 = CFUniCharDecomposeCharacter((unsigned __int16)v26[v16], v27, 10);
          *a7 = v12;
          if (v19 >= 1)
          {
            uint64_t v20 = v27;
            do
            {
              unsigned int v21 = *v20++;
              if (v21 < 0x10000)
              {
                if (v12 >= a6) {
                  return v13;
                }
                ++v12;
                *a5++ = v26[v16];
              }
              else
              {
                v12 += 2;
                if (v12 > a6) {
                  return v13;
                }
                if (a6)
                {
                  *a5 = (v26[v16] >> 10) | 0xD800;
                  a5[1] = v26[v16] & 0x3FF | 0xDC00;
                  a5 += 2;
                }
              }
              --v19;
            }
            while (v19);
          }
        }
        else
        {
          if (a6) {
            *a5++ = v26[v16];
          }
          ++v12;
        }
        ++v16;
      }
      while (v16 != v17);
      ++v13;
      uint64_t v10 = a3;
      uint64_t v11 = v23;
      a1 = v14;
      if (v13 == a4)
      {
        uint64_t v13 = a4;
        break;
      }
    }
  }
  *a7 = v12;
  return v13;
}

uint64_t __CFToBytesCheapMultiByteWrapper(uint64_t (***a1)(uint64_t, void, unsigned char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6, int64_t *a7)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  *a7 = 0;
  if (a4 < 1) {
    return 0;
  }
  int64_t v14 = 0;
  uint64_t v15 = 0;
  while (!a6 || v14 < a6)
  {
    unsigned int v16 = (**a1)(a2, *(unsigned __int16 *)(a3 + 2 * v15), v22);
    if (!v16) {
      break;
    }
    if (a6)
    {
      if (*a7 + v16 > a6) {
        return v15;
      }
      uint64_t v17 = v22;
      uint64_t v18 = a5;
      uint64_t v19 = v16;
      do
      {
        char v20 = *v17++;
        *(unsigned char *)(v18 + *a7) = v20;
        ++v18;
        --v19;
      }
      while (v19);
    }
    int64_t v14 = *a7 + v16;
    *a7 = v14;
    if (++v15 == a4) {
      return a4;
    }
  }
  return v15;
}

uint64_t __CFToUnicodeCheapMultiByteWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  __int16 v18 = 0;
  *a7 = 0;
  if (!a4) {
    return 0;
  }
  uint64_t v10 = a4;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  do
  {
    if (a6 && v14 >= a6) {
      break;
    }
    unsigned int v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)a1 + 8))(a2, a3, v10, &v18);
    if (!v16) {
      break;
    }
    if (a6) {
      *a5++ = v18;
    }
    uint64_t v14 = *a7 + 1;
    *a7 = v14;
    v15 += v16;
    a3 += v16;
    v10 -= v16;
  }
  while (v10);
  return v15;
}

uint64_t __CFToCanonicalUnicodeCheapMultiByteWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, void *a7)
{
  uint64_t v25 = *(void *)off_1ECE0A5B0;
  if (a4)
  {
    uint64_t v10 = a4;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unsigned __int16 v23 = 0;
    do
    {
      if (a6 && v14 >= a6) {
        break;
      }
      unsigned int v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*(void *)a1 + 8))(a2, a3, v10, &v23);
      if (!v16) {
        break;
      }
      unsigned int v17 = v16;
      if (v23 >= 0x80u && CFUniCharIsMemberOf(v23, 0x65u))
      {
        uint64_t v18 = CFUniCharDecomposeCharacter(v23, v24, 10);
        *a7 = v14;
        if (v18 >= 1)
        {
          uint64_t v19 = v24;
          do
          {
            unsigned int v20 = *v19;
            unsigned int v21 = *v19 - 0x10000;
            if (*v19 < 0x10000)
            {
              if (v14 >= a6) {
                return v15;
              }
              ++v14;
              *a5++ = v20;
            }
            else
            {
              v14 += 2;
              if (v14 > a6) {
                return v15;
              }
              if (a6)
              {
                *uint64_t v19 = v21;
                *a5 = (v21 >> 10) - 10240;
                a5[1] = v20 & 0x3FF | 0xDC00;
                a5 += 2;
              }
            }
            ++v19;
            --v18;
          }
          while (v18);
        }
      }
      else
      {
        if (a6) {
          *a5++ = v23;
        }
        ++v14;
      }
      v15 += v17;
      a3 += v17;
      v10 -= v17;
    }
    while (v10);
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0;
  }
  *a7 = v14;
  return v15;
}

uint64_t _CFStringEncodingSetForceASCIICompatibility(uint64_t result)
{
  __CFWantsToUseASCIICompatibleConversion = result != 0;
  return result;
}

uint64_t __CFStringDecodeByteStream2(char *a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, unsigned char *a6)
{
  return __CFStringDecodeByteStream3(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t _CFStringGetInstallationEncodingAndRegion(_DWORD *a1, _DWORD *a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  uint64_t v9 = 0;
  *a1 = 0;
  *a2 = 0;
  uint64_t result = (uint64_t)getpwuid(0);
  if (result)
  {
    __strlcpy_chk();
    __strlcat_chk();
    if (__CFProphylacticAutofsAccess) {
      int v5 = open("/dev/autofs_nowait", 0);
    }
    else {
      int v5 = -1;
    }
    uint64_t result = open(v10, 0, 0);
    if ((result & 0x80000000) != 0)
    {
      uint64_t v7 = 0;
    }
    else
    {
      int v6 = result;
      uint64_t v7 = v11;
      ssize_t v8 = read(result, v11, 0x3FuLL);
      v11[v8 & ~(v8 >> 63)] = 0;
      uint64_t result = close(v6);
      uint64_t v9 = v11;
    }
    if (v5 != -1) {
      uint64_t result = close(v5);
    }
    if (v7)
    {
      uint64_t result = strtol_l(v7, &v9, 0, 0);
      *a1 = result;
      if (result <= 9 && ((1 << result) & 0x230) != 0) {
        *a1 = 0;
      }
      if (*v9 == 58)
      {
        uint64_t result = strtol_l(++v9, 0, 0, 0);
        *a2 = result;
      }
    }
  }
  return result;
}

BOOL _CFStringSaveUserDefaultEncoding(int a1, int a2)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  uid_t v4 = getuid();
  if (!getpwuid(v4)) {
    return 0;
  }
  if (!issetugid()) {
    __CFgetenv("CFFIXED_USER_HOME");
  }
  __strlcpy_chk();
  __strlcat_chk();
  if (__CFProphylacticAutofsAccess) {
    int v5 = open("/dev/autofs_nowait", 0);
  }
  else {
    int v5 = -1;
  }
  unlink(v15);
  int v7 = open(v15, 513, 256);
  if (v7 < 0)
  {
    BOOL v6 = 0;
  }
  else
  {
    int v8 = v7;
    if ((a1 & 0xFFFFFFFE) == 4) {
      int v9 = 0;
    }
    else {
      int v9 = a1;
    }
    unsigned int v10 = snprintf(__str, 0x40uLL, "0x%X:0x%X", v9, a2);
    BOOL v6 = 0;
    if (v10 <= 0x40) {
      BOOL v6 = v10 <= (unint64_t)(int)write(v8, __str, v10);
    }
    int v11 = *__error();
    close(v8);
    *__error() = v11;
  }
  int v12 = *__error();
  if (v5 != -1) {
    close(v5);
  }
  *__error() = v12;
  return v6;
}

uint64_t __CFStringScanHex(UniChar *buffer, int *a2, unsigned int *a3)
{
  int v6 = *a2;
  if (*a2 < 0) {
    goto LABEL_5;
  }
LABEL_2:
  uint64_t v7 = v6;
  uint64_t v8 = *((void *)buffer + 20);
  if (v8 > v7)
  {
    uint64_t v9 = *((void *)buffer + 17);
    if (v9)
    {
      UniChar v10 = *(_WORD *)(v9 + 2 * (*((void *)buffer + 19) + v7));
    }
    else
    {
      uint64_t v11 = *((void *)buffer + 18);
      if (v11)
      {
        UniChar v10 = *(char *)(v11 + *((void *)buffer + 19) + v7);
      }
      else
      {
        if (*((void *)buffer + 22) <= v7 || (uint64_t v12 = *((void *)buffer + 21), v12 > v7))
        {
          uint64_t v13 = v7 - 4;
          if (v7 < 4) {
            uint64_t v13 = 0;
          }
          if (v13 + 64 < v8) {
            uint64_t v8 = v13 + 64;
          }
          *((void *)buffer + 21) = v13;
          *((void *)buffer + 22) = v8;
          v41.CFIndex location = *((void *)buffer + 19) + v13;
          v41.CFIndex length = v8 - v13;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v41, buffer);
          uint64_t v12 = *((void *)buffer + 21);
        }
        UniChar v10 = buffer[v7 - v12];
      }
    }
    goto LABEL_6;
  }
LABEL_5:
  while (1)
  {
    UniChar v10 = -1;
LABEL_6:
    if (v10 != 12288
      && (unsigned __int16)(v10 - 0x2000) >= 0xCu
      && v10 >= 0x21u
      && (unsigned __int16)(v10 - 127) > 0x21u)
    {
      break;
    }
    int v6 = *a2 + 1;
    *a2 = v6;
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_2;
    }
  }
  int v14 = v10 - 48;
  if (v10 != 48)
  {
    if ((unsigned __int16)(v10 - 48) > 9u)
    {
      if ((unsigned __int16)(v10 - 65) > 5u)
      {
        if ((unsigned __int16)(v10 - 97) > 5u) {
          return 0;
        }
        int v14 = v10 - 87;
      }
      else
      {
        int v14 = v10 - 55;
      }
    }
    if (v14 != -1) {
      goto LABEL_33;
    }
    return 0;
  }
  uint64_t v15 = *a2;
  uint64_t v16 = v15 + 1;
  *a2 = v15 + 1;
  if ((int)v15 >= -1)
  {
    uint64_t v17 = *((void *)buffer + 20);
    if (v17 > v16)
    {
      uint64_t v18 = *((void *)buffer + 17);
      if (v18)
      {
        UniChar v19 = *(_WORD *)(v18 + 2 * (*((void *)buffer + 19) + v16));
      }
      else
      {
        uint64_t v31 = *((void *)buffer + 18);
        if (v31)
        {
          UniChar v19 = *(char *)(v31 + *((void *)buffer + 19) + v16);
        }
        else
        {
          if (*((void *)buffer + 22) <= v16 || (uint64_t v32 = *((void *)buffer + 21), v32 > v16))
          {
            uint64_t v33 = v16 - 4;
            if (v16 < 4) {
              uint64_t v33 = 0;
            }
            if (v33 + 64 < v17) {
              uint64_t v17 = v33 + 64;
            }
            *((void *)buffer + 21) = v33;
            *((void *)buffer + 22) = v17;
            v43.CFIndex location = *((void *)buffer + 19) + v33;
            v43.CFIndex length = v17 - v33;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v43, buffer);
            uint64_t v32 = *((void *)buffer + 21);
          }
          UniChar v19 = buffer[v16 - v32];
        }
      }
      if ((v19 & 0xFFDF) == 0x58)
      {
        uint64_t v34 = *a2;
        uint64_t v35 = v34 + 1;
        *a2 = v34 + 1;
        if ((int)v34 < -1) {
          goto LABEL_93;
        }
        uint64_t v36 = *((void *)buffer + 20);
        if (v36 <= v35) {
          goto LABEL_93;
        }
        uint64_t v37 = *((void *)buffer + 17);
        if (v37)
        {
          UniChar v19 = *(_WORD *)(v37 + 2 * (*((void *)buffer + 19) + v35));
        }
        else
        {
          uint64_t v38 = *((void *)buffer + 18);
          if (v38)
          {
            UniChar v19 = *(char *)(v38 + *((void *)buffer + 19) + v35);
          }
          else
          {
            if (*((void *)buffer + 22) <= v35 || (uint64_t v39 = *((void *)buffer + 21), v39 > v35))
            {
              uint64_t v40 = v35 - 4;
              if (v35 < 4) {
                uint64_t v40 = 0;
              }
              if (v40 + 64 < v36) {
                uint64_t v36 = v40 + 64;
              }
              *((void *)buffer + 21) = v40;
              *((void *)buffer + 22) = v36;
              v44.CFIndex location = *((void *)buffer + 19) + v40;
              v44.CFIndex length = v36 - v40;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v44, buffer);
              uint64_t v39 = *((void *)buffer + 21);
            }
            UniChar v19 = buffer[v35 - v39];
          }
        }
      }
      if ((unsigned __int16)(v19 - 48) > 9u)
      {
        if (v19 - 65 > 5)
        {
          if (v19 - 97 > 5) {
            goto LABEL_93;
          }
          int v14 = v19 - 87;
        }
        else
        {
          int v14 = v19 - 55;
        }
      }
      else
      {
        int v14 = v19 - 48;
      }
      if (v14 != -1)
      {
LABEL_33:
        unsigned int v20 = 0;
        do
        {
          unsigned int v21 = v14 + 16 * v20;
          if (v20 >> 28) {
            unsigned int v20 = -1;
          }
          else {
            unsigned int v20 = v21;
          }
          uint64_t v22 = *a2;
          uint64_t v23 = v22 + 1;
          *a2 = v22 + 1;
          if ((int)v22 < -1) {
            break;
          }
          uint64_t v24 = *((void *)buffer + 20);
          if (v24 <= v23) {
            break;
          }
          uint64_t v25 = *((void *)buffer + 17);
          if (v25)
          {
            UniChar v26 = *(_WORD *)(v25 + 2 * (*((void *)buffer + 19) + v23));
          }
          else
          {
            uint64_t v27 = *((void *)buffer + 18);
            if (v27)
            {
              UniChar v26 = *(char *)(v27 + *((void *)buffer + 19) + v23);
            }
            else
            {
              if (*((void *)buffer + 22) <= v23 || (uint64_t v28 = *((void *)buffer + 21), v28 > v23))
              {
                uint64_t v29 = v23 - 4;
                if (v23 < 4) {
                  uint64_t v29 = 0;
                }
                if (v29 + 64 < v24) {
                  uint64_t v24 = v29 + 64;
                }
                *((void *)buffer + 21) = v29;
                *((void *)buffer + 22) = v24;
                v42.CFIndex location = *((void *)buffer + 19) + v29;
                v42.CFIndex length = v24 - v29;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v42, buffer);
                uint64_t v28 = *((void *)buffer + 21);
              }
              UniChar v26 = buffer[v23 - v28];
            }
          }
          if ((unsigned __int16)(v26 - 48) > 9u)
          {
            if (v26 - 65 > 5)
            {
              if (v26 - 97 > 5) {
                break;
              }
              int v14 = v26 - 87;
            }
            else
            {
              int v14 = v26 - 55;
            }
          }
          else
          {
            int v14 = v26 - 48;
          }
        }
        while (v14 != -1);
        if (!a3) {
          return 1;
        }
        goto LABEL_95;
      }
    }
  }
LABEL_93:
  --*a2;
  if (a3)
  {
    unsigned int v20 = 0;
LABEL_95:
    *a3 = v20;
  }
  return 1;
}

CFTypeID CFStringTokenizerGetTypeID(void)
{
  return 40;
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (!__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return 0;
  }
  int v5 = (uint64_t (*)(CFStringRef, CFIndex, CFIndex))__NLStringTokenizerCopyBestStringLanguage;

  return (CFStringRef)v5(string, location, length);
}

void CFStringTokenizerSetString(CFStringTokenizerRef tokenizer, CFStringRef string, CFRange range)
{
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return __NLStringTokenizerGoToTokenAtIndex(*((void *)tokenizer + 2), index);
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return (CFTypeRef)__NLStringTokenizerCopyCurrentTokenAttribute(*((void *)tokenizer + 2), attribute);
}

CFIndex CFStringTokenizerGetCurrentSubTokens(CFStringTokenizerRef tokenizer, CFRange *ranges, CFIndex maxRangeLength, CFMutableArrayRef derivedSubTokens)
{
  return __NLStringTokenizerGetCurrentSubTokens(*((void *)tokenizer + 2), ranges, maxRangeLength, derivedSubTokens);
}

uint64_t CFStringTokenizerCopyBestStringLanguageWithHints(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (!__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))__NLStringTokenizerCopyBestStringLanguageWithHints;

  return v8(a1, a2, a3, a4);
}

uint64_t _CFStringTokenizerCopyPossibleStringLanguages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (!__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return 0;
  }
  int v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))___NLStringTokenizerCopyPossibleStringLanguages;

  return v6(a1, a2, a3);
}

uint64_t _CFStringTokenizerTokenize(uint64_t a1)
{
  return ___NLStringTokenizerTokenize(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerTokenizeWithTranscriptions(uint64_t a1)
{
  return ___NLStringTokenizerTokenizeWithTranscriptions(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerTokenizeCompoundWord(uint64_t a1)
{
  return ___NLStringTokenizerTokenizeCompoundWord(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetDerivedTokens(uint64_t a1)
{
  return ___NLStringTokenizerGetDerivedTokens(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetNextBestTokens(uint64_t a1)
{
  return ___NLStringTokenizerGetNextBestTokens(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreateNamePartsArrayWithString(uint64_t a1)
{
  return ___NLStringTokenizerCreateNamePartsArrayWithString(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreateNamePartsArrayWithStringAsCompositeName(uint64_t a1)
{
  return ___NLStringTokenizerCreateNamePartsArrayWithStringAsCompositeName(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreatePossibleNamePartsArrayWithStringAsCompositeName(uint64_t a1)
{
  return ___NLStringTokenizerCreatePossibleNamePartsArrayWithStringAsCompositeName(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetCurrentTokenPartOfSpeech(uint64_t a1)
{
  return ___NLStringTokenizerGetCurrentTokenPartOfSpeech(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerSetLocale(uint64_t a1)
{
  return ___NLStringTokenizerSetLocale(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerSetTokenizerAttribute(uint64_t a1)
{
  return ___NLStringTokenizerSetTokenizerAttribute(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetTokenizerAttribute(uint64_t a1)
{
  return ___NLStringTokenizerGetTokenizerAttribute(*(void *)(a1 + 16));
}

uint64_t CFStringTokenizerSetStringWithOptions(uint64_t a1)
{
  return __NLStringTokenizerSetStringWithOptions(*(void *)(a1 + 16));
}

uint64_t (**__CFStringEncodingGetSymbolConverterDefinition(int a1))()
{
  int v1 = __CFConverterMacSymbol;
  if (a1 != 33) {
    int v1 = 0;
  }
  if (a1 == 34) {
    return __CFConverterMacDingbats;
  }
  else {
    return v1;
  }
}

uint64_t __CFToMacDingbats(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v4 = *a2;
  if (v4 > 0x1F)
  {
    if (v4 <= 0x3015)
    {
      int v6 = MacDingbats_from_uni;
      uint64_t v7 = (const __int16 *)&unk_182E0ED54;
      do
      {
        uint64_t v8 = ((char *)v7 - (char *)v6) >> 3;
        uint64_t v9 = &v6[2 * v8];
        unsigned int v10 = *(unsigned __int16 *)v9;
        if (v10 <= v4)
        {
          if (v10 >= v4)
          {
            LOBYTE(v4) = v6[2 * v8 + 1];
            goto LABEL_2;
          }
          int v6 = v9 + 2;
        }
        else
        {
          uint64_t v7 = v9 - 2;
        }
      }
      while (v6 <= v7);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a4 = v4;
    return 1;
  }
}

BOOL __CFFromMacDingbats(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0x1F)
  {
    if (a2 > 0x8F)
    {
      unsigned int v3 = a2 - 160;
      if (a2 < 0xA0) {
        return 0;
      }
      unsigned int v4 = (unsigned __int16 *)&MacDingbats_to_uni_FF;
    }
    else
    {
      unsigned int v3 = a2 - 32;
      unsigned int v4 = (unsigned __int16 *)&MacDingbats_to_uni_8F;
    }
    a2 = v4[v3];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacDingbatsLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    __int16 v4 = *a2++;
    if ((v4 & 0xFFF0) != 0xF870) {
      ++result;
    }
  }
  return result;
}

uint64_t __CFFromMacDingbatsLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  unint64_t v4 = a3 + 1;
  do
  {
    char v5 = *a2++;
    char v6 = v5 + 126;
    if ((v5 + 126) > 7u) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = qword_182E0F338[v6];
    }
    result += v7;
    --v4;
  }
  while (v4 > 1);
  return result;
}

uint64_t __CFToMacSymbol(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4)
{
  unsigned int v4 = *a2;
  if (v4 <= 0x1F)
  {
LABEL_2:
    *a4 = v4;
    return 1;
  }
  if (a3 < 2 || (int v6 = a2[1], (v6 & 0xFFF0) != 0xF870))
  {
LABEL_10:
    if (v4 >> 8 > 0xF8) {
      return 0;
    }
    goto LABEL_11;
  }
  if (v4 == 169)
  {
    if (v6 == 63615)
    {
      char v7 = -29;
      goto LABEL_23;
    }
LABEL_11:
    uint64_t v8 = MacSymbol_from_uni;
    uint64_t v9 = (const __int16 *)&unk_182E0F1E4;
    while (1)
    {
      uint64_t v10 = ((char *)v9 - (char *)v8) >> 3;
      uint64_t v11 = &v8[2 * v10];
      unsigned int v12 = *(unsigned __int16 *)v11;
      if (v12 <= v4)
      {
        if (v12 >= v4)
        {
          LOBYTE(v4) = v8[2 * v10 + 1];
          goto LABEL_2;
        }
        uint64_t v8 = v11 + 2;
      }
      else
      {
        uint64_t v9 = v11 - 2;
      }
      if (v8 > v9) {
        return 0;
      }
    }
  }
  if (v4 == 8482)
  {
    if (v6 == 63615)
    {
      char v7 = -28;
      goto LABEL_23;
    }
    goto LABEL_11;
  }
  if (v4 != 174) {
    goto LABEL_10;
  }
  if (v6 != 63615) {
    goto LABEL_11;
  }
  char v7 = -30;
LABEL_23:
  *a4 = v7;
  return 2;
}

uint64_t __CFFromMacSymbol(__int16 a1, unsigned int a2, __int16 *a3)
{
  if (a2 <= 0x3F)
  {
    switch(a2)
    {
      case '""':
        __int16 v3 = 8704;
        goto LABEL_15;
      case '$':
        __int16 v3 = 8707;
        goto LABEL_15;
      case '\'':
        __int16 v3 = 8717;
        goto LABEL_15;
      case '*':
        __int16 v3 = 8727;
        goto LABEL_15;
      case '-':
        __int16 v3 = 8722;
        goto LABEL_15;
      default:
        *a3 = a2;
        break;
    }
    return 1;
  }
  if (a2 <= 0x7E)
  {
    unsigned int v4 = a2 - 64;
    char v5 = &MacSymbol_to_uni_to7E;
    goto LABEL_9;
  }
  unsigned int v4 = a2 - 160;
  if (a2 < 0xA0) {
    return 0;
  }
  if (a2 <= 0xDF)
  {
    char v5 = &MacSymbol_to_uni_toDF;
LABEL_9:
    __int16 v3 = v5[v4];
LABEL_15:
    *a3 = v3;
    return 1;
  }
  uint64_t v8 = a2 - 224;
  uint64_t v9 = MacSymbol_to_uni_toFF[v8];
  *a3 = v9;
  if (a2 == 255) {
    return 0;
  }
  unint64_t v10 = v8 - 2;
  unsigned __int16 v6 = 1;
  if (v10 <= 2)
  {
    *(_DWORD *)a3 = __CFMacSymbolTwoCharDecompSeqTable[v9];
    if ((a1 & 0x200) != 0) {
      return 1;
    }
    else {
      return 2;
    }
  }
  return v6;
}

uint64_t __CFToMacSymbolLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    __int16 v4 = *a2++;
    if ((v4 & 0xFFF0) != 0xF870) {
      ++result;
    }
  }
  return result;
}

uint64_t __CFFromMacSymbolLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  unint64_t v4 = a3 + 1;
  do
  {
    unsigned int v5 = *a2++;
    if (v5 < 0xE0) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = 2;
    }
    result += v6;
    --v4;
  }
  while (v4 > 1);
  return result;
}

uint64_t __CFPrecomposeCharMacSymbol(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 2 || a2[1] != 824) {
    return 0;
  }
  if (a5)
  {
    int v6 = *a2;
    switch(v6)
    {
      case 61:
        char v7 = -71;
        goto LABEL_11;
      case 8834:
        char v7 = -53;
        goto LABEL_11;
      case 8712:
        char v7 = -49;
LABEL_11:
        *a4 = v7;
        break;
    }
  }
  *a6 = 1;
  return 2;
}

BOOL __CFIsValidCombiningCharMacSymbol(int a1)
{
  return a1 == 824;
}

BOOL CFDateComponentsIsLeapMonthSet(uint64_t a1)
{
  return *(void *)(a1 + 56) != 0x7FFFFFFFFFFFFFFFLL;
}

BOOL CFDateComponentsIsLeapMonth(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  return v1 != 0x7FFFFFFFFFFFFFFFLL && v1 != 0;
}

__CFString *_CFDateComponentsCopyDescriptionInner(void *a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFStringAppend(Mutable, @"{");
  if (a1[2]) {
    CFStringAppendFormat(Mutable, 0, @"\n    Calendar: %@", a1[2]);
  }
  if (a1[3]) {
    CFStringAppendFormat(Mutable, 0, @"\n    TimeZone: %@", a1[3]);
  }
  if (a1[4] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Era: %ld", a1[4]);
  }
  if (a1[5] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Calendar Year: %ld", a1[5]);
  }
  if (a1[20] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Day of Year: %ld", a1[20]);
  }
  if (a1[6] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Month: %ld", a1[6]);
  }
  if (a1[7] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Leap Month: %ld", a1[7]);
  }
  if (a1[8] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Day: %ld", a1[8]);
  }
  if (a1[9] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Hour: %ld", a1[9]);
  }
  if (a1[10] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Minute: %ld", a1[10]);
  }
  if (a1[11] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Second: %ld", a1[11]);
  }
  if (a1[19] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Nanosecond: %ld", a1[19]);
  }
  if (a1[15] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Quarter: %ld", a1[15]);
  }
  if (a1[18] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Year for Week of Year: %ld", a1[18]);
  }
  if (a1[17] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Week of Year: %ld", a1[17]);
  }
  if (a1[16] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Week of Month: %ld", a1[16]);
  }
  if (a1[12] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Week (obsolete): %ld", a1[12]);
  }
  if (a1[13] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Weekday: %ld", a1[13]);
  }
  if (a1[14] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0, @"\n    Weekday Ordinal: %ld", a1[14]);
  }
  return Mutable;
}

CFStringRef __CFDateComponentsCopyDescription(void *a1)
{
  if (!a1) {
    __CFDateComponentsCopyDescription_cold_1();
  }
  uint64_t v2 = _CFDateComponentsCopyDescriptionInner(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFDateComponents %p [%p]>%@", a1, v3, v2);
  CFRelease(v2);
  return v4;
}

uint64_t CFDateComponentsGetTypeID()
{
  return 66;
}

BOOL CFDateComponentsIsValidDate(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  return v1 && CFDateComponentsIsValidDateInCalendar(a1, v1);
}

uint64_t CFDateComponentsDateMatchesComponents()
{
  return 0;
}

uint64_t __CFStringReplaceableCharAt(uint64_t a1, signed int a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    return (unsigned __int16)-1;
  }
  else
  {
    if (a2 < 0) {
      return 0;
    }
    uint64_t v3 = a2;
    uint64_t v4 = *(void *)(a1 + 176);
    if (v4 <= a2)
    {
      return 0;
    }
    else
    {
      uint64_t v5 = *(void *)(a1 + 152);
      if (v5)
      {
        return *(unsigned __int16 *)(v5 + 2 * (*(void *)(a1 + 168) + a2));
      }
      else
      {
        uint64_t v8 = *(void *)(a1 + 160);
        if (v8)
        {
          return (unsigned __int16)*(char *)(v8 + *(void *)(a1 + 168) + a2);
        }
        else
        {
          if (*(void *)(a1 + 192) <= a2 || (uint64_t v9 = *(void *)(a1 + 184), v9 > a2))
          {
            uint64_t v10 = a2 - 4;
            if (a2 < 4) {
              uint64_t v10 = 0;
            }
            if (v10 + 64 < v4) {
              uint64_t v4 = v10 + 64;
            }
            *(void *)(a1 + 184) = v10;
            *(void *)(a1 + 192) = v4;
            v11.CFIndex location = *(void *)(a1 + 168) + v10;
            v11.CFIndex length = v4 - v10;
            CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v11, (UniChar *)(a1 + 16));
            uint64_t v9 = *(void *)(a1 + 184);
          }
          return *(unsigned __int16 *)(a1 + 16 + 2 * (v3 - v9));
        }
      }
    }
  }
}

void __CFStringReplaceableExtract(void *a1, int a2, int a3, UniChar *__dst)
{
  uint64_t v4 = __dst;
  uint64_t v6 = a2;
  CFIndex v7 = a3 - a2;
  uint64_t v8 = a1[19];
  if (v8)
  {
    uint64_t v9 = (const void *)(v8 + 2 * a1[21] + 2 * a2);
    memmove(__dst, v9, 2 * v7);
  }
  else
  {
    uint64_t v10 = (char *)(a1 + 2);
    uint64_t v11 = a1[23];
    CFIndex v12 = v11 - v6;
    if (v11 > v6 || (uint64_t v13 = a1[24], v14 = v13 <= v6, v15 = v13 - v6, v14))
    {
      BOOL v17 = __OFSUB__(v7 + v6, v11);
      uint64_t v18 = v7 + v6 - v11;
      if (!((v18 < 0) ^ v17 | (v18 == 0)) && v7 + v6 < a1[24])
      {
        memmove(&__dst[v12], v10, 2 * v18);
        CFIndex v7 = v12;
      }
    }
    else
    {
      if (v15 >= v7) {
        CFIndex v16 = v7;
      }
      else {
        CFIndex v16 = v15;
      }
      memmove(__dst, &v10[2 * (v6 - v11)], 2 * v16);
      v4 += v16;
      v6 += v16;
      v7 -= v16;
    }
    if (v7 >= 1)
    {
      uint64_t v19 = a1[20];
      v20.CFIndex location = a1[21] + v6;
      if (v19)
      {
        unsigned int v21 = (char *)(v19 + v20.location);
        do
        {
          UniChar v22 = *v21++;
          *v4++ = v22;
          --v7;
        }
        while (v7);
      }
      else
      {
        CFStringRef v23 = (const __CFString *)a1[18];
        v20.CFIndex length = v7;
        CFStringGetCharacters(v23, v20, v4);
      }
    }
  }
}

const char *__CFStringReplaceableCopy(uint64_t a1, int a2, int a3, int a4)
{
  v11.CFIndex length = a3 - a2;
  v11.CFIndex location = a2;
  CFStringRef v6 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)a1, v11);
  CFStringInsert(*(CFMutableStringRef *)a1, a4, v6);
  CFRelease(v6);
  CFIndex Length = CFStringGetLength(*(CFStringRef *)a1);
  *(void *)(a1 + 8) = Length;
  CFStringRef v8 = *(const __CFString **)a1;
  *(void *)(a1 + 144) = *(void *)a1;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = Length;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(v8);
  uint64_t result = 0;
  *(void *)(a1 + 152) = CharactersPtr;
  if (!CharactersPtr) {
    uint64_t result = CFStringGetCStringPtr(v8, 0x600u);
  }
  *(void *)(a1 + 160) = result;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  return result;
}

uint64_t (**__CFStringEncodingGetHebrewConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_4)
  {
    __CFStringEncodingPrecomposeLatinCharacter_4 = a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_2 = a2(3);
  }
  uint64_t v4 = __CFConverterISOLatinHebrew;
  uint64_t v5 = __CFConverterMacHebrew;
  if (a1 != 5) {
    uint64_t v5 = 0;
  }
  if (a1 != 520) {
    uint64_t v4 = v5;
  }
  if (a1 == 1285) {
    return __CFConverterWindowsHebrew;
  }
  else {
    return v4;
  }
}

uint64_t __CFToISOLatinHebrew(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  uint64_t result = 0;
  if (a2 != 161 && a2 <= 0x203E)
  {
    uint64_t v5 = (unsigned __int16 *)&ISOLatinHebrew_from_uni;
    CFStringRef v6 = (unsigned __int16 *)&unk_182E0F458;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      CFStringRef v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        uint64_t v5 = v8 + 2;
      }
      else
      {
        CFStringRef v6 = v8 - 2;
      }
      if (v5 > v6) {
        return 0;
      }
    }
  }
  return result;
}

BOOL __CFFromISOLatinHebrew(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
  {
    if (a2 <= 0xBE)
    {
      unsigned int v3 = a2 - 161;
      uint64_t v4 = (unsigned __int16 *)&ISOLatinHebrew_to_uni;
LABEL_7:
      a2 = v4[v3];
      goto LABEL_8;
    }
    if ((a2 + 5) >= 0xE4u)
    {
      unsigned int v3 = a2 - 223;
      uint64_t v4 = (unsigned __int16 *)&ISOLatinHebrew_to_uni2;
      goto LABEL_7;
    }
    a2 = 65533;
  }
LABEL_8:
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacHebrew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a5;
  }
  if (v7 < 1)
  {
    uint64_t result = 0;
    goto LABEL_24;
  }
  uint64_t result = 0;
  while (1)
  {
    unsigned int v9 = *(unsigned __int16 *)(a2 + 2 * result);
    if (v9 <= 0x7F) {
      goto LABEL_19;
    }
    if ((unsigned __int16)(v9 + 1204) < 0x554u) {
      break;
    }
    uint64_t v10 = (unsigned __int16 *)&unk_182E0F634;
    CFRange v11 = (unsigned __int16 *)&MacHebrew_from_uni;
    while (1)
    {
      uint64_t v12 = ((char *)v10 - (char *)v11) >> 3;
      uint64_t v13 = &v11[2 * v12];
      unsigned int v14 = *v13;
      if (v14 <= v9) {
        break;
      }
      uint64_t v10 = v13 - 2;
LABEL_16:
      if (v11 > v10) {
        goto LABEL_24;
      }
    }
    if (v14 < v9)
    {
      CFRange v11 = v13 + 2;
      goto LABEL_16;
    }
    LOBYTE(v9) = v11[2 * v12 + 1];
LABEL_19:
    if (a5) {
      *(unsigned char *)(a4 + result) = v9;
    }
    if (++result == v7)
    {
      uint64_t result = v7;
      break;
    }
  }
LABEL_24:
  *a6 = result;
  return result;
}

uint64_t __CFFromMacHebrew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a5;
  }
  if (v7 < 1)
  {
    uint64_t result = 0;
    goto LABEL_19;
  }
  for (uint64_t result = 0; result != v7; ++result)
  {
    unsigned int v9 = *(unsigned __int8 *)(a2 + result);
    if ((*(char *)(a2 + result) & 0x80000000) == 0)
    {
      if (!a5) {
        continue;
      }
LABEL_11:
      *(_WORD *)(a4 + 2 * result) = v9;
      continue;
    }
    v9 -= 128;
    if (v9 == 64 || v9 == 94) {
      goto LABEL_19;
    }
    LOWORD(v9) = MacHebrew_to_uni[v9];
    if (a5) {
      goto LABEL_11;
    }
  }
  uint64_t result = v7;
LABEL_19:
  *a6 = result;
  return result;
}

uint64_t __CFToWindowsHebrew(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA3)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  uint64_t result = 0;
  if (a2 != 164 && a2 <= 0x2122)
  {
    uint64_t v5 = (unsigned __int16 *)&WindowsHebrew_from_uni;
    CFStringRef v6 = (unsigned __int16 *)&unk_182E0F8C8;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      CFStringRef v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        uint64_t v5 = v8 + 2;
      }
      else
      {
        CFStringRef v6 = v8 - 2;
      }
      if (v5 > v6) {
        return 0;
      }
    }
  }
  return result;
}

BOOL __CFFromWindowsHebrew(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsHebrew_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

CFStringRef __CFUUIDCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFStringRef v3 = CFUUIDCreateString(v2, (CFUUIDRef)a1);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFUUID %p> %@", a1, v3);
  CFRelease(v3);
  return v4;
}

CFUUIDRef CFUUIDCreateWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, (byte6 << 48) | ((unint64_t)byte7 << 56) | (byte5 << 40) | (byte4 << 32) | ((unint64_t)byte3 << 24) | ((unint64_t)byte2 << 16) | ((unint64_t)byte1 << 8) | byte0, byte8 | ((unint64_t)byte9 << 8) | ((unint64_t)byte10 << 16) | ((unint64_t)byte11 << 24) | ((unint64_t)byte12 << 32) | ((unint64_t)byte13 << 40) | ((unint64_t)byte14 << 48) | ((unint64_t)byte15 << 56), 0);
}

UText *CFMutableStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 8, a2);
}

UText *CFAttributedStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 16, a2);
}

UText *CFMutableAttributedStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 24, a2);
}

CFIndex __CFAttributedStringLength(uint64_t a1)
{
  return CFAttributedStringGetLength(*(CFAttributedStringRef *)(a1 + 72));
}

uint64_t __CFAttributedStringAccess(uint64_t a1, uint64_t a2, int a3)
{
  CFStringRef String = CFAttributedStringGetString(*(CFAttributedStringRef *)(a1 + 72));

  return doAccess(a1, a2, a3, String);
}

uint64_t __CFAttributedStringExtract(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  CFStringRef String = CFAttributedStringGetString(*(CFAttributedStringRef *)(a1 + 72));

  return doExtract(a2, a3, a4, a5, a6, String);
}

CFIndex __CFAttributedStringReplace(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  CFAttributedStringRef v12 = *(const __CFAttributedString **)(a1 + 72);
  CFStringRef String = CFAttributedStringGetString(v12);
  CFIndex Length = CFAttributedStringGetLength(v12);
  if (*a6 > 0) {
    return 0;
  }
  CFIndex v16 = Length;
  if (!a4 && a5)
  {
    CFIndex v15 = 0;
    int v17 = 1;
LABEL_8:
    *a6 = v17;
    return v15;
  }
  if (a2 > a3)
  {
    CFIndex v15 = 0;
    int v17 = 8;
    goto LABEL_8;
  }
  CFIndex v18 = __pinIndex(a2, Length, String, 1, 1);
  CFIndex v19 = __pinIndex(a3, v16, String, 0, 1);
  CFStringRef MutableWithExternalCharactersNoCopy = *(const __CFString **)(a1 + 80);
  if (MutableWithExternalCharactersNoCopy)
  {
    CFStringSetExternalCharactersNoCopy(*(CFMutableStringRef *)(a1 + 80), a4, a5, a5);
  }
  else
  {
    CFStringRef MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, a5, a5, (CFAllocatorRef)&__kCFAllocatorNull);
    *(void *)(a1 + 80) = MutableWithExternalCharactersNoCopy;
  }
  v23.CFIndex length = v19 - v18;
  v23.CFIndex location = v18;
  CFAttributedStringReplaceString(v12, v23, MutableWithExternalCharactersNoCopy);
  if (*(void *)(a1 + 16) > v18 || *(void *)(a1 + 48) != *(void *)(a1 + 88))
  {
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 28) = 0;
    *(void *)(a1 + 44) = 0;
    *(void *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 52) = 0;
  }
  CFIndex v15 = CFAttributedStringGetLength(v12) - v16;
  CFStringRef v21 = CFAttributedStringGetString(v12);
  doAccess(a1, v15 + v19, 1, v21);
  return v15;
}

uint64_t __CFAttributedStringCopy(uint64_t a1, CFIndex a2, CFIndex a3, CFIndex a4, int a5, int *a6)
{
  CFAttributedStringRef v12 = *(const __CFAttributedString **)(a1 + 72);
  CFStringRef String = CFAttributedStringGetString(v12);
  uint64_t result = CFAttributedStringGetLength(v12);
  if (*a6 > 0) {
    return result;
  }
  if (a2 > a3 || (CFIndex v15 = result, a2 < a4) && a4 < a3)
  {
    *a6 = 8;
    return result;
  }
  CFIndex v16 = __pinIndex(a2, result, String, 1, 1);
  CFIndex v17 = __pinIndex(a3, v15, String, 0, 1);
  CFIndex v18 = v17 - v16;
  v27.CFIndex location = v16;
  v27.CFIndex length = v17 - v16;
  CFAttributedStringRef v19 = CFAttributedStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v27);
  CFAttributedStringBeginEditing(v12);
  v25.CFIndex location = a4;
  v25.CFIndex length = 0;
  CFAttributedStringReplaceAttributedString(v12, v25, v19);
  CFRelease(v19);
  if (a5)
  {
    if (v16 > a4) {
      CFIndex v16 = v17;
    }
    v26.CFIndex location = v16;
    v26.CFIndex length = v18;
    CFAttributedStringReplaceString(v12, v26, &stru_1ECE10768);
  }
  CFAttributedStringEndEditing(v12);
  if (v16 >= a4 || a5 == 0) {
    CFIndex v21 = a4;
  }
  else {
    CFIndex v21 = v16;
  }
  if (*(void *)(a1 + 48) == *(void *)(a1 + 88))
  {
    CFIndex v23 = *(void *)(a1 + 16);
    if (a5)
    {
      if (v23 <= v21) {
        goto LABEL_19;
      }
    }
    else if (v23 <= a4)
    {
      goto LABEL_19;
    }
  }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 28) = 0;
  *(void *)(a1 + 44) = 0;
  *(void *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 52) = 0;
LABEL_19:
  CFStringRef v22 = CFAttributedStringGetString(v12);

  return doAccess(a1, v18 + a4, 1, v22);
}

uint64_t doExtract(CFIndex a1, CFIndex a2, UniChar *a3, int a4, int *a5, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (*a5 > 0) {
    return 0;
  }
  if (a4 < 0 || (CFIndex v14 = Length, !a3) && a4)
  {
    uint64_t v13 = 0;
    int v15 = 1;
LABEL_7:
    *a5 = v15;
    return v13;
  }
  if (a1 < 0 || a2 < a1 || a2 - a1 >= 0x80000000)
  {
    uint64_t v13 = 0;
    int v15 = 8;
    goto LABEL_7;
  }
  CFIndex v17 = __pinIndex(a1, Length, theString, 1, 1);
  uint64_t v13 = __pinIndex(a2, v14, theString, 1, 1) - v17;
  if (a3 && a4)
  {
    if ((int)v13 >= a4) {
      int v18 = a4;
    }
    else {
      int v18 = v13;
    }
    v19.CFIndex length = v18;
    v19.CFIndex location = v17;
    CFStringGetCharacters(theString, v19, a3);
  }
  if (*a5 <= 0)
  {
    if (v13 < 1 || v13 >= a4)
    {
      if (v13 == a4) {
        int v15 = -124;
      }
      else {
        int v15 = 15;
      }
    }
    else
    {
      int v15 = 0;
      a3[v13] = 0;
      if (*a5 != -124) {
        return v13;
      }
    }
    goto LABEL_7;
  }
  return v13;
}

uint64_t __CFStringExtract(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  return doExtract(a2, a3, a4, a5, a6, *(CFStringRef *)(a1 + 72));
}

CFIndex __CFStringReplace(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  CFAttributedStringRef v12 = *(__CFString **)(a1 + 72);
  CFIndex Length = CFStringGetLength(v12);
  if (*a6 > 0) {
    return 0;
  }
  CFIndex v15 = Length;
  if (!a4 && a5)
  {
    CFIndex v14 = 0;
    int v16 = 1;
LABEL_8:
    *a6 = v16;
    return v14;
  }
  if (a2 > a3)
  {
    CFIndex v14 = 0;
    int v16 = 8;
    goto LABEL_8;
  }
  CFIndex v17 = __pinIndex(a2, Length, v12, 1, 1);
  CFIndex v18 = __pinIndex(a3, v15, v12, 0, 1);
  CFStringRef MutableWithExternalCharactersNoCopy = *(const __CFString **)(a1 + 80);
  if (MutableWithExternalCharactersNoCopy)
  {
    CFStringSetExternalCharactersNoCopy(*(CFMutableStringRef *)(a1 + 80), a4, a5, a5);
  }
  else
  {
    CFStringRef MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, a5, a5, (CFAllocatorRef)&__kCFAllocatorNull);
    *(void *)(a1 + 80) = MutableWithExternalCharactersNoCopy;
  }
  v21.CFIndex length = v18 - v17;
  v21.CFIndex location = v17;
  CFStringReplace(v12, v21, MutableWithExternalCharactersNoCopy);
  if (*(void *)(a1 + 16) > v17 || *(void *)(a1 + 48) != *(void *)(a1 + 88))
  {
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 28) = 0;
    *(void *)(a1 + 44) = 0;
    *(void *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 52) = 0;
  }
  CFIndex v14 = CFStringGetLength(v12) - v15;
  doAccess(a1, v14 + v18, 1, v12);
  return v14;
}

uint64_t __CFStringCopy(uint64_t a1, CFIndex a2, CFIndex a3, CFIndex a4, int a5, int *a6)
{
  CFAttributedStringRef v12 = *(__CFString **)(a1 + 72);
  uint64_t result = CFStringGetLength(v12);
  if (*a6 > 0) {
    return result;
  }
  if (a2 > a3 || (CFIndex v14 = result, a2 < a4) && a4 < a3)
  {
    *a6 = 8;
    return result;
  }
  CFIndex v15 = __pinIndex(a2, result, v12, 1, 1);
  CFIndex v16 = __pinIndex(a3, v14, v12, 0, 1);
  v22.CFIndex location = v15;
  v22.CFIndex length = v16 - v15;
  CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v22);
  CFStringInsert(v12, a4, v17);
  CFRelease(v17);
  if (a5)
  {
    if (v15 <= a4) {
      CFIndex v18 = v15;
    }
    else {
      CFIndex v18 = v16;
    }
    v21.CFIndex location = v18;
    v21.CFIndex length = v16 - v15;
    CFStringDelete(v12, v21);
    if (*(void *)(a1 + 48) == *(void *)(a1 + 88))
    {
      CFIndex v19 = v18 >= a4 ? a4 : v18;
      if (*(void *)(a1 + 16) <= v19) {
        goto LABEL_20;
      }
    }
    goto LABEL_19;
  }
  if (*(void *)(a1 + 48) != *(void *)(a1 + 88) || *(void *)(a1 + 16) > a4)
  {
LABEL_19:
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 36) = 0;
    *(void *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(void *)(a1 + 48) = 0;
  }
LABEL_20:

  return doAccess(a1, v16 - v15 + a4, 1, v12);
}

CFStringRef CFStringGetNameOfEncoding(CFStringEncoding encoding)
{
  LODWORD(v1) = encoding;
  os_unfair_lock_lock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
  if (CFStringGetNameOfEncoding_mappingTable)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFStringGetNameOfEncoding_mappingTable, (const void *)v1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
    if (Value) {
      return Value;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
  }
  Name = __CFStringEncodingGetName(v1);
  if (Name)
  {
    CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, Name, 0x600u);
    if (v4)
    {
      CFStringRef v5 = v4;
      os_unfair_lock_lock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
      if (CFStringGetNameOfEncoding_mappingTable)
      {
        unint64_t v1 = v1;
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFStringGetNameOfEncoding_mappingTable, (const void *)v1);
        if (Value)
        {
LABEL_13:
          os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
          CFRelease(v5);
          return Value;
        }
        CFMutableArrayRef Mutable = (__CFDictionary *)CFStringGetNameOfEncoding_mappingTable;
      }
      else
      {
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
        CFStringGetNameOfEncoding_mappingTable = (uint64_t)Mutable;
        unint64_t v1 = v1;
      }
      CFDictionaryAddValue(Mutable, (const void *)v1, v5);
      CFStringRef Value = v5;
      goto LABEL_13;
    }
  }
  return 0;
}

UInt32 CFStringConvertEncodingToWindowsCodepage(CFStringEncoding encoding)
{
  UInt32 result = __CFStringEncodingGetWindowsCodePage(encoding);
  if (!result) {
    return -1;
  }
  return result;
}

CFStringEncoding CFStringConvertWindowsCodepageToEncoding(UInt32 codepage)
{
  return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)codepage);
}

uint64_t __extendLocationForward(int64_t a1, UniChar *buffer, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6)
{
  while (1)
  {
    if (a1 < 0 || (int64_t v12 = *((void *)buffer + 20), v12 <= a1))
    {
      UniChar v14 = 0;
      goto LABEL_6;
    }
    uint64_t v13 = *((void *)buffer + 17);
    if (v13)
    {
      UniChar v14 = *(_WORD *)(v13 + 2 * (*((void *)buffer + 19) + a1));
    }
    else
    {
      uint64_t v15 = *((void *)buffer + 18);
      if (v15)
      {
        UniChar v14 = *(char *)(v15 + *((void *)buffer + 19) + a1);
      }
      else
      {
        if (*((void *)buffer + 22) <= a1 || (int64_t v16 = *((void *)buffer + 21), v16 > a1))
        {
          int64_t v17 = a1 - 4;
          if ((unint64_t)a1 < 4) {
            int64_t v17 = 0;
          }
          if (v17 + 64 < v12) {
            int64_t v12 = v17 + 64;
          }
          *((void *)buffer + 21) = v17;
          *((void *)buffer + 22) = v12;
          v31.CFIndex location = *((void *)buffer + 19) + v17;
          v31.CFIndex length = v12 - v17;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v31, buffer);
          int64_t v16 = *((void *)buffer + 21);
        }
        UniChar v14 = buffer[a1 - v16];
      }
    }
    if (v14 >> 10 == 54)
    {
      int64_t v18 = a1 + 1;
      int64_t v19 = *((void *)buffer + 20);
      if (v19 > a1 + 1)
      {
        uint64_t v20 = *((void *)buffer + 17);
        if (v20)
        {
          UniChar v21 = *(_WORD *)(v20 + 2 * (*((void *)buffer + 19) + v18));
        }
        else
        {
          uint64_t v22 = *((void *)buffer + 18);
          if (v22)
          {
            UniChar v21 = *(char *)(v22 + *((void *)buffer + 19) + v18);
          }
          else
          {
            if (*((void *)buffer + 22) <= v18 || (int64_t v23 = *((void *)buffer + 21), v23 > v18))
            {
              int64_t v24 = a1 - 3;
              if ((unint64_t)a1 < 3) {
                int64_t v24 = 0;
              }
              if (v24 + 64 < v19) {
                int64_t v19 = v24 + 64;
              }
              *((void *)buffer + 21) = v24;
              *((void *)buffer + 22) = v19;
              v32.CFIndex location = *((void *)buffer + 19) + v24;
              v32.CFIndex length = v19 - v24;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              int64_t v23 = *((void *)buffer + 21);
            }
            UniChar v21 = buffer[v18 - v23];
          }
        }
        if (v21 >> 10 == 55) {
          break;
        }
      }
    }
LABEL_6:
    ++a1;
    if (a3 && ((*(unsigned __int8 *)(a3 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0
      || a4 && ((*(unsigned __int8 *)(a4 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0)
    {
      if ((unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu) {
        return a1;
      }
    }
    else if (!a5 {
           || (unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu
    }
           || ((1 << (v14 & 7)) & *(unsigned __int8 *)(a5 + (v14 >> 3))) == 0)
    {
      return a1;
    }
LABEL_15:
    if (a1 >= a6) {
      return a1;
    }
  }
  char v25 = v21;
  unsigned int v26 = (v14 << 10) + v21 - 56613888;
  a1 += 2;
  uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0xAu, HIWORD(v26));
  if (BitmapPtrForPlane
    && ((*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v26 >> 3)) >> (v25 & 7)) & 1) != 0)
  {
    goto LABEL_15;
  }
  uint64_t v28 = CFUniCharGetBitmapPtrForPlane(0xBu, HIWORD(v26));
  if (v28)
  {
    if ((*(unsigned __int8 *)(v28 + ((unsigned __int16)v26 >> 3)) >> (v25 & 7))) {
      goto LABEL_15;
    }
  }
  uint64_t v29 = CFUniCharGetBitmapPtrForPlane(0x6Cu, HIWORD(v26));
  if (v29)
  {
    if ((*(unsigned __int8 *)(v29 + ((unsigned __int16)v26 >> 3)) >> (v25 & 7))) {
      goto LABEL_15;
    }
  }
  return a1;
}

CFURLRef _CFCreateContainerURLForSecurityApplicationGroupIdentifier(const void *a1)
{
  _CFGetEUID();

  return _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser(0, a1);
}

__n128 cow_copy_instance_0(uint64_t a1, int a2, uint64_t a3, int a4)
{
  CFStringRef v4 = &OBJC_IVAR_____NSFrozenOrderedSetM_cow;
  if (a2 == 1) {
    CFStringRef v5 = &OBJC_IVAR_____NSOrderedSetM_cow;
  }
  else {
    CFStringRef v5 = &OBJC_IVAR_____NSFrozenOrderedSetM_cow;
  }
  if (a2 == 1) {
    CFStringRef v6 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }
  else {
    CFStringRef v6 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + *v5));
  uint64_t v8 = *v6;
  if (a4 == 1)
  {
    CFStringRef v4 = &OBJC_IVAR_____NSOrderedSetM_cow;
    unsigned int v9 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }
  else
  {
    unsigned int v9 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  }
  atomic_store(v7, (unint64_t *)(a3 + *v4));
  __n128 result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v9) = result;
  return result;
}

uint64_t cow_copy_storage_0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = [*(id *)(a1 + 24) mutableCopyWithZone:0];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = CFBasicHashCreateCopy(0, v2);
    if (result)
    {
      *(void *)(a1 + 16) = result;
      *(void *)(a1 + 24) = v4;
      return 1;
    }
  }
  return result;
}

uint64_t cow_set_cow_0(uint64_t result, unint64_t a2)
{
  return result;
}

void __CFTreeDeallocate(unint64_t *cf)
{
  char v2 = atomic_load(cf + 1);
  int v3 = v2 & 3;
  if (v3)
  {
    if (v3 == 1) {
      uint64_t v4 = (long long *)&__kCFTypeTreeCallBacks;
    }
    else {
      uint64_t v4 = (long long *)cf[7];
    }
  }
  else
  {
    uint64_t v4 = &__kCFNullTreeCallBacks;
  }
  CFStringRef v5 = (void (*)(unint64_t))*((void *)v4 + 1);
  if (v5) {
    v5(cf[6]);
  }
  char v6 = atomic_load(cf + 1);
  if ((~v6 & 3) == 0)
  {
    CFAllocatorRef v7 = CFGetAllocator(cf);
    uint64_t v8 = (void *)cf[7];
    CFAllocatorDeallocate(v7, v8);
  }
}

__CFString *__CFTreeCopyDescription(unint64_t *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  char v4 = atomic_load(a1 + 1);
  int v5 = v4 & 3;
  if (v5)
  {
    if (v5 == 1) {
      char v6 = (long long *)&__kCFTypeTreeCallBacks;
    }
    else {
      char v6 = (long long *)a1[7];
    }
  }
  else
  {
    char v6 = &__kCFNullTreeCallBacks;
  }
  CFAllocatorRef v7 = (uint64_t (*)(unint64_t))*((void *)v6 + 2);
  if (!v7 || (CFStringRef v8 = (CFStringRef)v7(a1[6])) == 0) {
    CFStringRef v8 = CFStringCreateWithFormat(v2, 0, @"<CFTree context %p>", a1[6]);
  }
  ChildCFIndex Count = CFTreeGetChildCount((CFTreeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"<CFTree %p [%p]>{children = %lu, context = %@}", a1, v2, ChildCount, v8);
  if (v8) {
    CFRelease(v8);
  }
  return Mutable;
}

CFTypeID CFTreeGetTypeID(void)
{
  return 28;
}

CFTreeRef CFTreeCreate(CFAllocatorRef allocator, const CFTreeContext *context)
{
  Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x1CuLL, 48, 0);
  char v4 = (__CFTree *)Instance;
  if (Instance)
  {
    unint64_t v5 = atomic_load(Instance + 1);
    unint64_t v6 = v5;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v6, v5 & 0xFFFFFFFFFFFFFFFCLL);
      BOOL v7 = v6 == v5;
      unint64_t v5 = v6;
    }
    while (!v7);
    CFTreeSetContext((CFTreeRef)Instance, context);
  }
  return v4;
}

void CFTreeSetContext(CFTreeRef tree, const CFTreeContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  char v5 = atomic_load((unint64_t *)tree + 1);
  char v6 = atomic_load((unint64_t *)tree + 1);
  int v7 = v6 & 3;
  if (v7)
  {
    if (v7 == 1) {
      CFStringRef v8 = (long long *)&__kCFTypeTreeCallBacks;
    }
    else {
      CFStringRef v8 = (long long *)*((void *)tree + 7);
    }
  }
  else
  {
    CFStringRef v8 = &__kCFNullTreeCallBacks;
  }
  uint64_t v9 = *((void *)tree + 6);
  CFAllocatorRef v10 = CFGetAllocator(tree);
  CFAllocatorRef v11 = v10;
  if (!context)
  {
    uint64_t copyDescription = 0;
    goto LABEL_19;
  }
  retain = context->retain;
  if (retain)
  {
    if (retain == CFRetain && context->release == CFRelease && context->copyDescription == CFCopyDescription)
    {
      uint64_t copyDescription = 1;
      goto LABEL_19;
    }
  }
  else if (!context->release)
  {
    uint64_t copyDescription = (uint64_t)context->copyDescription;
    if (!copyDescription) {
      goto LABEL_19;
    }
  }
  uint64_t Typed = CFAllocatorAllocateTyped(v10, 24, 0x80040D6874129, 0);
  *((void *)tree + 7) = Typed;
  if (__CFOASafe)
  {
    __CFSetLastAllocationEventName();
    uint64_t Typed = *((void *)tree + 7);
  }
  *(_OWORD *)uint64_t Typed = *(_OWORD *)&context->retain;
  *(void *)(Typed + 16) = context->copyDescription;
  uint64_t copyDescription = 3;
LABEL_19:
  unint64_t v15 = atomic_load((unint64_t *)tree + 1);
  unint64_t v16 = v15;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)tree + 1, &v16, v15 & 0xFFFFFFFFFFFFFFFCLL | copyDescription);
    BOOL v17 = v16 == v15;
    unint64_t v15 = v16;
  }
  while (!v17);
  char v18 = atomic_load((unint64_t *)tree + 1);
  int v19 = v18 & 3;
  if (v19)
  {
    if (v19 == 1) {
      uint64_t v20 = (long long *)&__kCFTypeTreeCallBacks;
    }
    else {
      uint64_t v20 = (long long *)*((void *)tree + 7);
    }
  }
  else
  {
    uint64_t v20 = &__kCFNullTreeCallBacks;
  }
  UniChar v21 = *(uint64_t (**)(void *))v20;
  unint64_t info = context->info;
  if (v21) {
    unint64_t info = (void *)v21(info);
  }
  *((void *)tree + 6) = info;
  int64_t v23 = (void (*)(uint64_t))*((void *)v8 + 1);
  if (v23) {
    v23(v9);
  }
  if ((~v5 & 3) == 0)
  {
    CFAllocatorDeallocate(v11, v8);
  }
}

CFIndex CFTreeGetChildCount(CFTreeRef tree)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  uint64_t v3 = *((void *)tree + 4);
  if (!v3) {
    return 0;
  }
  CFIndex result = 0;
  do
  {
    uint64_t v3 = *(void *)(v3 + 24);
    ++result;
  }
  while (v3);
  return result;
}

CFTreeRef CFTreeGetParent(CFTreeRef tree)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  return (CFTreeRef)*((void *)tree + 2);
}

CFTreeRef CFTreeGetNextSibling(CFTreeRef tree)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  return (CFTreeRef)*((void *)tree + 3);
}

CFTreeRef CFTreeGetFirstChild(CFTreeRef tree)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  return (CFTreeRef)*((void *)tree + 4);
}

CFTreeRef CFTreeFindRoot(CFTreeRef tree)
{
  unint64_t v1 = (unint64_t *)tree;
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID(v1);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  do
  {
    CFTreeRef result = (CFTreeRef)v1;
    unint64_t v1 = (unint64_t *)v1[2];
  }
  while (v1);
  return result;
}

void CFTreeGetContext(CFTreeRef tree, CFTreeContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  char v5 = atomic_load((unint64_t *)tree + 1);
  int v6 = v5 & 3;
  if (v6)
  {
    if (v6 == 1) {
      int v7 = (long long *)&__kCFTypeTreeCallBacks;
    }
    else {
      int v7 = (long long *)*((void *)tree + 7);
    }
  }
  else
  {
    int v7 = &__kCFNullTreeCallBacks;
  }
  CFStringRef v8 = (void *)*((void *)tree + 6);
  context->version = 0;
  context->unint64_t info = v8;
  *(_OWORD *)&context->retain = *v7;
  context->uint64_t copyDescription = (CFTreeCopyDescriptionCallBack)*((void *)v7 + 2);
}

CFTreeRef CFTreeGetChildAtIndex(CFTreeRef tree, CFIndex idx)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  CFTreeRef result = (CFTreeRef)*((void *)tree + 4);
  if (result) {
    BOOL v6 = idx == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    CFIndex v7 = idx - 1;
    do
    {
      CFTreeRef result = (CFTreeRef)*((void *)result + 3);
      if (result) {
        BOOL v8 = v7 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      --v7;
    }
    while (!v8);
  }
  return result;
}

void CFTreeGetChildren(CFTreeRef tree, CFTreeRef *children)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  for (uint64_t i = (__CFTree *)*((void *)tree + 4); i; uint64_t i = (__CFTree *)*((void *)i + 3))
    *children++ = i;
}

void CFTreeApplyFunctionToChildren(CFTreeRef tree, CFTreeApplierFunction applier, void *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v6 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v6);
  }
  for (uint64_t i = *((void *)tree + 4); i; uint64_t i = *(void *)(i + 24))
    ((void (*)(uint64_t, void *))applier)(i, context);
}

void CFTreePrependChild(CFTreeRef tree, CFTreeRef newChild)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  CFRetain(newChild);
  *((void *)newChild + 2) = tree;
  *((void *)newChild + 3) = *((void *)tree + 4);
  if (!*((void *)tree + 4)) {
    *((void *)tree + 5) = newChild;
  }
  *((void *)tree + 4) = newChild;
}

void CFTreeAppendChild(CFTreeRef tree, CFTreeRef newChild)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28
    || (__CFCheckCFInfoPACSignature((uint64_t)newChild), unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)newChild), v4 != 28))
  {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  if (*((void *)newChild + 2))
  {
    __break(1u);
  }
  else
  {
    CFRetain(newChild);
    CFGetAllocator(tree);
    *((void *)newChild + 2) = tree;
    *((void *)newChild + 3) = 0;
    char v5 = (CFTreeRef *)((char *)tree + 32);
    if (*((void *)tree + 4)) {
      char v5 = (CFTreeRef *)(*((void *)tree + 5) + 24);
    }
    *char v5 = newChild;
    *((void *)tree + 5) = newChild;
  }
}

void CFTreeInsertSibling(CFTreeRef tree, CFTreeRef newSibling)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28
    || (__CFCheckCFInfoPACSignature((uint64_t)newSibling),
        unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)newSibling),
        v4 != 28))
  {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  CFRetain(newSibling);
  CFGetAllocator(tree);
  *((void *)newSibling + 2) = *((void *)tree + 2);
  *((void *)newSibling + 3) = *((void *)tree + 3);
  *((void *)tree + 3) = newSibling;
  uint64_t v5 = *((void *)tree + 2);
  if (v5)
  {
    if (*(CFTreeRef *)(v5 + 40) == tree) {
      *(void *)(v5 + 40) = newSibling;
    }
  }
}

void CFTreeRemove(CFTreeRef tree)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  uint64_t v3 = (char *)tree + 16;
  uint64_t v4 = *((void *)tree + 2);
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 32);
    if (v5 == (void *)tree)
    {
      *(void *)(v4 + 32) = *((void *)tree + 3);
      if (!*((void *)tree + 3)) {
        *(void *)(*(void *)v3 + 40) = 0;
      }
    }
    else
    {
      while (v5)
      {
        unint64_t v6 = v5;
        uint64_t v5 = (void *)v5[3];
        if (v5 == (void *)tree)
        {
          v6[3] = *((void *)tree + 3);
          uint64_t v7 = *((void *)tree + 2);
          if (*(CFTreeRef *)(v7 + 40) == tree) {
            *(void *)(v7 + 40) = v6;
          }
          break;
        }
      }
    }
    *(void *)uint64_t v3 = 0;
    *((void *)tree + 3) = 0;
    CFRelease(tree);
  }
}

void CFTreeRemoveAllChildren(CFTreeRef tree)
{
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  uint64_t v3 = (void *)*((void *)tree + 4);
  *((void *)tree + 4) = 0;
  *((void *)tree + 5) = 0;
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)v3[3];
      v3[2] = 0;
      v3[3] = 0;
      CFRelease(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
}

void CFTreeSortChildren(CFTreeRef tree, CFComparatorFunction comparator, void *context)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)tree);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v6 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v6);
  }
  ChildCFIndex Count = CFTreeGetChildCount(tree);
  if (ChildCount >= 2)
  {
    uint64_t v11 = ChildCount;
    memset(v18, 0, 512);
    if ((unint64_t)ChildCount >= 0x80)
    {
      uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * ChildCount, 0x2004093837F09, 0);
      BOOL v12 = Typed != v18;
      if (__CFOASafe && Typed != v18)
      {
        __CFSetLastAllocationEventName();
        BOOL v12 = 1;
      }
    }
    else
    {
      BOOL v12 = 0;
      uint64_t Typed = v18;
    }
    uint64_t v14 = *((void *)tree + 4);
    if (v14)
    {
      unint64_t v15 = Typed;
      do
      {
        *v15++ = v14;
        uint64_t v14 = *(void *)(v14 + 24);
      }
      while (v14);
    }
    v17[0] = comparator;
    v17[1] = context;
    CFQSortArray(Typed, v11, 8, (uint64_t)__CFTreeCompareValues, (uint64_t)v17, v8, v9, v10);
    uint64_t v16 = 0;
    *((void *)tree + 4) = *(void *)Typed;
    do
    {
      *(void *)(*((void *)Typed + v16) + 24) = *((void *)Typed + v16 + 1);
      ++v16;
    }
    while (v11 - 1 != v16);
    *(void *)(*((void *)Typed + v16) + 24) = 0;
    *((void *)tree + 5) = *((void *)Typed + v11 - 1);
    if (v12) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
}

uint64_t __CFTreeCompareValues(void *a1, void *a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, void))a3)(*a1, *a2, *(void *)(a3 + 8));
}

const char *_CFURLCStringIsPromiseName(const char *__s)
{
  if (__s)
  {
    unint64_t v1 = __s;
    if (*__s == 46 && (size_t v2 = strlen(__s), v2 >= 7)) {
      return (const char *)(*(_DWORD *)&v1[v2 - 7] == 1818454318 && *(_DWORD *)&v1[v2 - 4] == 1685417836);
    }
    else {
      return 0;
    }
  }
  return __s;
}

CFDictionaryRef _CFURLPromiseCreateProperties(void *a1, void *a2, int a3)
{
  keys[3] = *(void **)off_1ECE0A5B0;
  keys[0] = @"NSURLNameKey";
  keys[1] = @"NSURLFileSizeKey";
  keys[2] = @"NSURLFileResourceTypeKey";
  values[0] = a1;
  values[1] = a2;
  uint64_t v3 = &kCFURLFileResourceTypeRegular;
  if (a3) {
    uint64_t v3 = &kCFURLFileResourceTypeDirectory;
  }
  values[2] = *(void **)v3;
  return CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void *_CFURLCopyPropertiesOfPromiseAtURL(CFURLRef fileURL, __CFError **a2)
{
  error[1] = *(CFErrorRef *)off_1ECE0A5B0;
  uint64_t v3 = CFReadStreamCreateWithFile(0, fileURL);
  error[0] = 0;
  if (v3)
  {
    uint64_t v4 = v3;
    if (!CFReadStreamOpen(v3))
    {
      values = CFReadStreamCopyError(v4);
      CFDictionaryRef v10 = CFDictionaryCreate(0, (const void **)&kCFErrorUnderlyingErrorKey, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (values && (CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)values), CFEqual(Domain, @"NSPOSIXErrorDomain")))
      {
        if (CFErrorGetCode((CFErrorRef)values) == 2) {
          CFIndex v12 = 4;
        }
        else {
          CFIndex v12 = 256;
        }
      }
      else
      {
        CFIndex v12 = 256;
      }
      error[0] = CFErrorCreate(0, @"NSCocoaErrorDomain", v12, v10);
      if (values) {
        CFRelease(values);
      }
      if (v10) {
        CFRelease(v10);
      }
      uint64_t v5 = 0;
LABEL_29:
      uint64_t v13 = error[0];
      if (!error[0]) {
        goto LABEL_32;
      }
      goto LABEL_30;
    }
    uint64_t v5 = (void *)CFPropertyListCreateWithStream(0, v4, 0, 1uLL, 0, error);
    CFReadStreamClose(v4);
    if (v5)
    {
      if (CFGetTypeID(v5) != 18)
      {
        CFRelease(v5);
        uint64_t v13 = CFErrorCreate(0, @"NSCocoaErrorDomain", 259, 0);
        error[0] = v13;
        if (v13) {
          goto LABEL_25;
        }
        goto LABEL_21;
      }
      CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)v5, @"NSURLFileResourceTypeKey");
      if (Value)
      {
        uint64_t v7 = Value;
        CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsSymbolicLinkKey", &__kCFBooleanFalse);
        CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsAliasFileKey", &__kCFBooleanFalse);
        CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsVolumeKey", &__kCFBooleanFalse);
        if (CFEqual(v7, @"NSURLFileResourceTypeRegular"))
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsPackageKey", &__kCFBooleanFalse);
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsDirectoryKey", &__kCFBooleanFalse);
          uint64_t v8 = &__kCFBooleanTrue;
          uint64_t v9 = (__CFDictionary *)v5;
        }
        else
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsPackageKey", &__kCFBooleanTrue);
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsDirectoryKey", &__kCFBooleanTrue);
          uint64_t v9 = (__CFDictionary *)v5;
          uint64_t v8 = &__kCFBooleanFalse;
        }
        CFDictionarySetValue(v9, @"NSURLIsRegularFileKey", v8);
        goto LABEL_29;
      }
      CFRelease(v5);
    }
    uint64_t v13 = error[0];
    if (error[0])
    {
LABEL_25:
      uint64_t v5 = 0;
      if (a2)
      {
LABEL_31:
        *a2 = v13;
        goto LABEL_32;
      }
      goto LABEL_26;
    }
LABEL_21:
    uint64_t v13 = CFErrorCreate(0, @"NSCocoaErrorDomain", 256, 0);
    uint64_t v5 = 0;
    error[0] = v13;
    if (!v13) {
      goto LABEL_32;
    }
LABEL_30:
    if (a2) {
      goto LABEL_31;
    }
LABEL_26:
    CFRelease(v13);
LABEL_32:
    CFRelease(v4);
    return v5;
  }
  return 0;
}

CFStringRef _CFURLCopyLogicalNameOfPromiseAtURL(const __CFURL *a1, CFErrorRef *a2)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026)
    && (ssize_t v3 = getxattr((const char *)buffer, "com.apple.icloud.itemName", value, 0x2FCuLL, 0, 1), v3 >= 1))
  {
    CFIndex v4 = v3;
    CFStringEncoding v5 = CFStringFileSystemEncoding();
    CFStringRef v6 = CFStringCreateWithBytes(0, value, v4, v5, 0);
    if (!a2) {
      return v6;
    }
  }
  else
  {
    CFStringRef v6 = 0;
    if (!a2) {
      return v6;
    }
  }
  if (!v6) {
    *a2 = CFErrorCreate(0, @"NSCocoaErrorDomain", 256, 0);
  }
  return v6;
}

CFURLRef _CFURLCopyLogicalURLOfPromiseAtURL(const __CFURL *a1, CFErrorRef *a2)
{
  CFStringRef v4 = _CFURLCopyLogicalNameOfPromiseAtURL(a1, a2);
  if (!v4) {
    return 0;
  }
  CFStringRef v5 = v4;
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, a1);
  if (!PathComponent)
  {
    CFURLRef v8 = 0;
    if (!a2) {
      goto LABEL_9;
    }
LABEL_7:
    if (!v8)
    {
      *a2 = CFErrorCreate(0, @"NSCocoaErrorDomain", 256, 0);
      CFRelease(v5);
      return v8;
    }
    goto LABEL_9;
  }
  CFURLRef v7 = PathComponent;
  CFURLRef v8 = CFURLCreateCopyAppendingPathComponent(0, PathComponent, v5, 0);
  CFRelease(v7);
  if (a2) {
    goto LABEL_7;
  }
LABEL_9:
  CFRelease(v5);
  if (v8) {
    _CFURLPromiseSetPhysicalURL(v8, a1);
  }
  return v8;
}

CFStringRef _CFURLCopyPromiseNameOfLogicalURL(const __CFURL *a1)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  if (_CFURLIsFileURL((unint64_t)a1))
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(a1);
    if (PathComponent)
    {
      CFStringRef v3 = PathComponent;
      if (CFStringGetLength(PathComponent) < 1)
      {
        CFStringRef v7 = 0;
LABEL_27:
        CFRelease(v3);
        return v7;
      }
      range.uint64_t location = 0;
      range.CFIndex length = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      _CFGetPathExtensionRangesFromPathComponent(v3, &range.location, &v16);
      uint64_t location = range.location;
      if (range.location == -1 || (CFIndex v5 = range.length, range.length > 50))
      {
        CFIndex Length = CFStringGetLength(v3);
        CFIndex v5 = 0;
        uint64_t location = -1;
      }
      else
      {
        if (v16 != -1 && v17 + range.length <= 49)
        {
          uint64_t v6 = 0;
          while (CFStringCompareWithOptions(v3, _CFURLCopyPromiseNameOfLogicalURL_compressionExtensions[v6], range, 0))
          {
            if (++v6 == 4)
            {
              uint64_t location = range.location;
              CFIndex v5 = range.length;
              goto LABEL_16;
            }
          }
          uint64_t location = v16;
          CFIndex v5 = v17 + range.length + 1;
        }
LABEL_16:
        CFIndex Length = location - 1;
        if (v5 >= 1)
        {
          CFIndex usedBufLen = 0;
          v21.uint64_t location = location;
          v21.CFIndex length = v5;
          if (CFStringGetBytes(v3, v21, 0x8000100u, 0, 0, 0, 0, &usedBufLen) <= 0) {
            CFIndex v9 = 248;
          }
          else {
            CFIndex v9 = 247 - usedBufLen;
          }
LABEL_21:
          bytes[0] = 46;
          if (CFStringGetCharacterAtIndex(v3, 0) == 95)
          {
            bytes[1] = 46;
            uint64_t v10 = 2;
          }
          else
          {
            uint64_t v10 = 1;
          }
          CFIndex usedBufLen = 0;
          v22.uint64_t location = 0;
          v22.CFIndex length = Length;
          CFStringGetBytes(v3, v22, 0x8000100u, 0, 0, &bytes[v10], v9 - v10, &usedBufLen);
          CFIndex v11 = usedBufLen + v10;
          if (location != -1)
          {
            CFIndex v12 = v11 + 1;
            bytes[v11] = 46;
            v23.uint64_t location = location;
            v23.CFIndex length = v5;
            CFStringGetBytes(v3, v23, 0x8000100u, 0, 0, &bytes[v11 + 1], 254 - v11, &usedBufLen);
            CFIndex v11 = usedBufLen + v12;
          }
          uint64_t v13 = &bytes[v11];
          *(_DWORD *)(v13 + 3) = 1685417836;
          *(_DWORD *)uint64_t v13 = 1818454318;
          CFStringRef v7 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, v11 + 7, 0x8000100u, 0);
          goto LABEL_27;
        }
      }
      CFIndex v9 = 248;
      goto LABEL_21;
    }
  }
  return 0;
}

CFURLRef _CFURLCopyPromiseURLOfLogicalURL(const __CFURL *a1)
{
  CFURLRef v1 = a1;
  if (a1)
  {
    CFStringRef v2 = _CFURLCopyPromiseNameOfLogicalURL(a1);
    if (v2)
    {
      CFStringRef v3 = v2;
      CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
      if (PathComponent)
      {
        CFURLRef v5 = PathComponent;
        CFURLRef v1 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, PathComponent, v3, 0);
        CFRelease(v5);
      }
      else
      {
        CFURLRef v1 = 0;
      }
      CFRelease(v3);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t _CFURLPromiseCopyResourcePropertyForKey(const __CFURL *a1, CFTypeRef cf1, void *a3, CFErrorRef *a4)
{
  if (CFEqual(cf1, @"_NSURLPromiseLogicalNameKey")
    || CFEqual(cf1, @"_NSURLCloudDocsPlaceholderLogicalNameKey"))
  {
    if (_CFURLIsItemPromiseAtURL((unint64_t)a1))
    {
      uint64_t result = (uint64_t)_CFURLCopyLogicalNameOfPromiseAtURL(a1, a4);
      if (!result) {
        return result;
      }
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  if (!CFEqual(cf1, @"_NSURLPromisePropertiesKey")
    && !CFEqual(cf1, @"_NSURLCloudDocsPlaceholderDictionaryKey"))
  {
    return 1;
  }
  if (!_CFURLIsItemPromiseAtURL((unint64_t)a1))
  {
LABEL_11:
    uint64_t result = 0;
    goto LABEL_12;
  }
  uint64_t result = (uint64_t)_CFURLCopyPropertiesOfPromiseAtURL(a1, a4);
  if (result)
  {
LABEL_12:
    *a3 = result;
    return 1;
  }
  return result;
}

uint64_t _CFURLPromiseSetResourcePropertyForKey()
{
  return 1;
}

double _CFAuditTokenForSelf@<D0>(_OWORD *a1@<X8>)
{
  if (_CFAuditTokenForSelf_onceToken != -1) {
    dispatch_once(&_CFAuditTokenForSelf_onceToken, &__block_literal_global_21);
  }
  double result = *(double *)&_CFAuditTokenForSelf_auditToken;
  long long v3 = unk_1EB1DD678;
  *a1 = _CFAuditTokenForSelf_auditToken;
  a1[1] = v3;
  return result;
}

CFStringRef _CFPrefsCopyUserConstantForUserName(const __CFString *a1)
{
  if (CFEqual(a1, @"kCFPreferencesCurrentUser")) {
    return @"kCFPreferencesCurrentUser";
  }
  CFStringRef v2 = @"kCFPreferencesAnyUser";
  if (CFEqual(a1, @"kCFPreferencesAnyUser")) {
    return v2;
  }
  CFStringRef v3 = CFCopyUserName();
  int v4 = CFEqual(a1, v3);
  CFRelease(v3);
  BOOL v5 = !@"kCFPreferencesCurrentUser" || v4 == 0;
  CFStringRef v2 = @"kCFPreferencesCurrentUser";
  if (!v5) {
    return v2;
  }

  return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1);
}

void _CFPreferencesAlwaysUseVolatileUserDomains()
{
  __overrideUseVolatileDomainsForUser = 1;
}

uint64_t _CFPrefsValidateValueForKey(const void *a1, uint64_t a2)
{
  if (a1 && !CFPropertyListIsValid(a1, kCFPropertyListBinaryFormat_v1_0))
  {
    _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
    BOOL v5 = _CFPrefsClientLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      _CFPrefsValidateValueForKey_cold_2();
    }
    _CFSetTSD(0xFu, 0, 0);
    if (_CFPreferencesDoesNSUserDefaultsExist())
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
      _CFThrowFormattedException(@"NSInvalidArgumentException", @"Attempt to insert non-property list object %@ for key %@", a1, a2);
    }
    _CFPrefsValidateValueForKey_cold_1();
  }
  return 1;
}

void sub_182CF100C(void *a1)
{
}

void sub_182CF101C(void *a1)
{
}

void sub_182CF1038(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void sub_182CF184C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

CFStringRef __CFURLCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFStringRef v3 = CFURLCopyScheme((CFURLRef)a1);
  if (v3 && (CFStringRef v4 = v3, v5 = CFStringCompare(v3, @"data", 1uLL), CFRelease(v4), v5 == kCFCompareEqualTo))
  {
    CFStringRef v13 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    TruncatedURLCFStringRef String = CreateTruncatedURLString(v2, v13);
    uint64_t v14 = *(const void **)(a1 + 32);
    if (v14)
    {
      CFStringRef v15 = CFCopyDescription(v14);
      CFStringRef v10 = CFStringCreateWithFormat(v2, 0, @"<CFURL %p [%p]>{string = %@, encoding = %u\n\tbase = %@}", a1, v2, TruncatedURLString, *(unsigned int *)(a1 + 20), v15);
      CFRelease(v15);
      goto LABEL_9;
    }
    CFStringRef v9 = CFStringCreateWithFormat(v2, 0, @"<CFURL %p [%p]>{string = %@, encoding = %u, base = (null)}", a1, v2, TruncatedURLString, *(unsigned int *)(a1 + 20));
  }
  else
  {
    uint64_t v6 = *(const void **)(a1 + 32);
    if (!v6)
    {
      unint64_t v11 = atomic_load((unint64_t *)(a1 + 24));
      return CFStringCreateWithFormat(v2, 0, @"<CFURL %p [%p]>{string = %@, encoding = %u, base = (null)}", a1, v2, v11, *(unsigned int *)(a1 + 20));
    }
    TruncatedURLCFStringRef String = CFCopyDescription(v6);
    unint64_t v8 = atomic_load((unint64_t *)(a1 + 24));
    CFStringRef v9 = CFStringCreateWithFormat(v2, 0, @"<CFURL %p [%p]>{string = %@, encoding = %u\n\tbase = %@}", a1, v2, v8, *(unsigned int *)(a1 + 20), TruncatedURLString);
  }
  CFStringRef v10 = v9;
LABEL_9:
  CFRelease(TruncatedURLString);
  return v10;
}

size_t CFShowURL(unint64_t a1)
{
  uint64_t v1 = *(FILE **)off_1ECE0A5C0;
  if (!a1)
  {
    CFStringRef v4 = "(null)\n";
    size_t v5 = 7;
    goto LABEL_5;
  }
  fprintf(v1, "<CFURL %p>{", (const void *)a1);
  int v3 = CF_IS_OBJC(0x1DuLL, a1);
  uint64_t v1 = *(FILE **)off_1ECE0A5C0;
  if (v3)
  {
    CFStringRef v4 = "ObjC bridged object}\n";
    size_t v5 = 21;
LABEL_5:
    return fwrite(v4, v5, 1uLL, v1);
  }
  fwrite("\n\tRelative string: ", 0x13uLL, 1uLL, v1);
  CFStringRef v7 = (const void *)atomic_load((unint64_t *)(a1 + 24));
  CFShow(v7);
  fwrite("\tBase URL: ", 0xBuLL, 1uLL, *(FILE **)off_1ECE0A5C0);
  unint64_t v8 = *(FILE **)off_1ECE0A5C0;
  if (*(void *)(a1 + 32))
  {
    fprintf(v8, "<%p> ", *(const void **)(a1 + 32));
    CFShow(*(CFTypeRef *)(a1 + 32));
  }
  else
  {
    fwrite("(null)\n", 7uLL, 1uLL, v8);
  }
  return fprintf(*(FILE **)off_1ECE0A5C0, "\tFlags: 0x%x\n}\n", *(_DWORD *)(a1 + 16));
}

unint64_t *_CFURLCreateWithRangesAndFlags(CFStringRef theString, void *a2, unsigned int a3, unsigned int a4, const void *a5)
{
  unsigned int v6 = a4;
  if ((a4 & 1) == 0) {
    goto LABEL_14;
  }
  uint64_t v10 = a2[1];
  switch(v10)
  {
    case 5:
      int HasPrefix = CFStringHasPrefix(theString, @"https");
      unsigned int v12 = 0x40000000;
      break;
    case 4:
      if (CFStringHasPrefix(theString, @"http"))
      {
        int v14 = 0x20000000;
LABEL_13:
        unsigned int v6 = v14 & 0xE0000000 | v6 & 0x1FFFFFFF;
        goto LABEL_14;
      }
      if (CFStringHasPrefix(theString, @"file"))
      {
        int v14 = 1610612736;
        goto LABEL_13;
      }
      int HasPrefix = CFStringHasPrefix(theString, @"data");
      unsigned int v12 = 0x80000000;
      break;
    case 3:
      int HasPrefix = CFStringHasPrefix(theString, @"ftp");
      unsigned int v12 = -1610612736;
      break;
    default:
      goto LABEL_14;
  }
  unsigned int v13 = v12 & 0xE0000000 | v6 & 0x1FFFFFFF;
  if (HasPrefix) {
    unsigned int v6 = v13;
  }
LABEL_14:
  size_t v15 = 16 * a3;
  Instance = (unint64_t *)_CFRuntimeCreateInstance(0, 0x1DuLL, v15 + 40, 0);
  uint64_t v17 = Instance;
  if (Instance)
  {
    *((_DWORD *)Instance + 4) = v6;
    *((_DWORD *)Instance + 5) = 134217984;
    memcpy(Instance + 7, a2, v15);
    atomic_store((unint64_t)CFStringCreateCopy(0, theString), v17 + 3);
    if (a5) {
      CFTypeRef v18 = CFRetain(a5);
    }
    else {
      CFTypeRef v18 = 0;
    }
    v17[4] = (unint64_t)v18;
  }
  return v17;
}

unint64_t *_CFURLInitWithURLString(unint64_t *a1, const __CFString *a2, int a3, const __CFURL *a4)
{
  double result = _CFURLCreateWithURLString(&__kCFAllocatorSystemDefault, a2, a3, a4);
  if (result)
  {
    unsigned int v6 = result;
    a1[2] = result[2];
    unint64_t v7 = atomic_load(result + 3);
    atomic_store(v7, a1 + 3);
    a1[5] = result[5];
    unint64_t v8 = atomic_load(result + 6);
    atomic_store(v8, a1 + 6);
    a1[4] = result[4];
    LODWORD(v7) = *((_DWORD *)result + 4);
    unint64_t v9 = *(void *)&vshl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v7) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
    LOWORD(v9) = vaddv_s16((int16x4_t)v9);
    int v10 = v9
        + (v7 & 1)
        + ((v7 >> 5) & 1)
        + ((v7 >> 6) & 1)
        + ((v7 >> 8) & 1)
        + ((v7 & 0x80) >> 7);
    if ((_BYTE)v10) {
      memcpy(a1 + 7, result + 7, 16 * v10);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6);
    return (unint64_t *)1;
  }
  return result;
}

CFDataRef CFURLCreateData(CFAllocatorRef allocator, CFURLRef url, CFStringEncoding encoding, Boolean escapeWhitespace)
{
  if (!url) {
    return 0;
  }
  CFStringRef v6 = CFURLGetString(url);
  if (!v6) {
    return 0;
  }

  return CFStringCreateExternalRepresentation(allocator, v6, encoding, 0);
}

CFURLRef _CFURLInitAbsoluteURLWithBytes(unint64_t *a1, const UInt8 *a2, CFIndex a3, CFStringEncoding a4, const __CFURL *a5)
{
  CFURLRef result = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, a3, a4, a5, 0);
  if (result)
  {
    unint64_t v7 = result;
    a1[2] = *((void *)result + 2);
    unint64_t v8 = atomic_load((unint64_t *)result + 3);
    atomic_store(v8, a1 + 3);
    a1[5] = *((void *)result + 5);
    unint64_t v9 = atomic_load((unint64_t *)result + 6);
    atomic_store(v9, a1 + 6);
    a1[4] = *((void *)result + 4);
    LODWORD(v8) = *((_DWORD *)result + 4);
    unint64_t v10 = *(void *)&vshl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v8) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
    LOWORD(v1_CFSetTSD(0xFu, 0, 0) = vaddv_s16((int16x4_t)v10);
    int v11 = v10
        + (v8 & 1)
        + ((v8 >> 5) & 1)
        + ((v8 >> 6) & 1)
        + ((v8 >> 8) & 1)
        + ((v8 & 0x80) >> 7);
    if ((_BYTE)v11) {
      memcpy(a1 + 7, (char *)result + 56, 16 * v11);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
    return (CFURLRef)1;
  }
  return result;
}

CFIndex CFURLGetBytesUsingEncoding(unint64_t *a1, UInt8 *a2, CFIndex a3, CFStringEncoding a4)
{
  usedBufLen[1] = *(void *)off_1ECE0A5B0;
  usedBufLen[0] = 0;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)a1)) {
    CFStringRef v8 = CFURLGetString((CFURLRef)a1);
  }
  else {
    CFStringRef v8 = (const __CFString *)atomic_load(a1 + 3);
  }
  CFIndex Length = CFStringGetLength(v8);
  v12.uint64_t location = 0;
  v12.CFIndex length = Length;
  if (CFStringGetBytes(v8, v12, a4, 0, 0, a2, a3, usedBufLen) == Length) {
    return usedBufLen[0];
  }
  else {
    return -1;
  }
}

CFStringRef CFURLCopyStrictPath(CFURLRef anURL, Boolean *isAbsolute)
{
  CFStringRef v3 = CFURLCopyPath(anURL);
  if (!v3) {
    goto LABEL_8;
  }
  CFStringRef v4 = v3;
  if (!CFStringGetLength(v3))
  {
    CFRelease(v4);
LABEL_8:
    CFStringRef v4 = 0;
    goto LABEL_9;
  }
  if (CFStringGetCharacterAtIndex(v4, 0) == 47)
  {
    if (isAbsolute) {
      *isAbsolute = 1;
    }
    CFAllocatorRef v5 = CFGetAllocator(v4);
    v8.CFIndex length = CFStringGetLength(v4) - 1;
    v8.uint64_t location = 1;
    CFStringRef v6 = CFStringCreateWithSubstring(v5, v4, v8);
    CFRelease(v4);
    return v6;
  }
LABEL_9:
  if (isAbsolute) {
    *isAbsolute = 0;
  }
  return v4;
}

CFStringRef _CFURLCopyQueryString(const __CFURL *a1, int a2)
{
  if (a2) {
    return CFURLCopyQueryString(a1, &stru_1ECE10768);
  }
  else {
    return _unescapedQueryString((unint64_t)a1);
  }
}

CFStringRef _CFURLCopyFragment(const __CFURL *a1, int a2)
{
  if (a2) {
    return CFURLCopyFragment(a1, &stru_1ECE10768);
  }
  else {
    return _unescapedFragment(a1);
  }
}

void *__CFURLSetReservedPtr(void *result, uint64_t a2)
{
  if (result)
  {
    CFStringRef v3 = result;
    CFStringRef v4 = (void *)result[5];
    if (a2 && !v4)
    {
      CFURLRef result = _CFURLAllocateExtraDataspace(result);
      CFStringRef v4 = (void *)v3[5];
    }
    if (v4) {
      *CFStringRef v4 = a2;
    }
  }
  return result;
}

unint64_t *_CFURLCreateWithFileSystemPathCachingResourcePropertiesForKeys(const __CFAllocator *a1, const __CFString *a2, const __CFArray *a3, CFErrorRef *a4)
{
  error[1] = *(CFErrorRef *)off_1ECE0A5B0;
  error[0] = 0;
  CFRange v8 = (unint64_t *)_CFURLCreateWithFileSystemPath(a1, a2, 0, 0, 0);
  if (!v8)
  {
LABEL_21:
    CFErrorRef v17 = error[0];
    if (a4)
    {
      if (!error[0]) {
        CFErrorRef v17 = CFErrorCreate(0, @"NSPOSIXErrorDomain", 12, 0);
      }
      unint64_t v9 = 0;
      *a4 = v17;
    }
    else
    {
      if (error[0]) {
        CFRelease(error[0]);
      }
      return 0;
    }
    return v9;
  }
  unint64_t v9 = v8;
  if (!a3 || (CFIndex Count = CFArrayGetCount(a3)) == 0)
  {
    uint64_t IsDirectoryKeyArray = _CopyIsDirectoryKeyArray();
    goto LABEL_7;
  }
  CFIndex v11 = Count;
  v23.uint64_t location = 0;
  v23.CFIndex length = Count;
  if (CFArrayContainsValue(a3, v23, @"NSURLIsDirectoryKey"))
  {
    uint64_t IsDirectoryKeyArray = (uint64_t)CFRetain(a3);
LABEL_7:
    CFArrayRef Copy = (CFArrayRef)IsDirectoryKeyArray;
    goto LABEL_8;
  }
  MutableCFArrayRef Copy = CFArrayCreateMutableCopy(0, v11 + 1, a3);
  if (MutableCopy)
  {
    CFArrayRef v20 = MutableCopy;
    CFArrayAppendValue(MutableCopy, @"NSURLIsDirectoryKey");
    CFArrayRef Copy = CFArrayCreateCopy(0, v20);
    CFRelease(v20);
  }
  else
  {
    CFArrayRef Copy = 0;
  }
LABEL_8:
  if (_CFURLCacheResourcePropertiesForKeys((unint64_t)v9)
    && (CFBooleanRef propertyValueTypeRefPtr = 0,
        CFURLCopyResourcePropertyForKey((CFURLRef)v9, @"NSURLIsDirectoryKey", &propertyValueTypeRefPtr, error)))
  {
    if (propertyValueTypeRefPtr)
    {
      if (CFBooleanGetValue(propertyValueTypeRefPtr))
      {
        int v14 = (unint64_t *)_CFURLCreateWithFileSystemPath(a1, a2, 0, 1, 0);
        if (v14)
        {
          size_t v15 = v14;
          if (atomic_load(v9 + 6)) {
            atomic_store(_FileCacheCreateShallowCopy(), v15 + 6);
          }
          CFRelease(v9);
          unint64_t v9 = v15;
        }
      }
      CFRelease(propertyValueTypeRefPtr);
    }
  }
  else
  {
    CFRelease(v9);
    unint64_t v9 = 0;
  }
  if (Copy) {
    CFRelease(Copy);
  }
  if (!v9) {
    goto LABEL_21;
  }
  return v9;
}

uint64_t _CFURLCacheResourcePropertiesForKeys(unint64_t a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  char v10 = 0;
  if (_CFURLHasFileURLScheme(a1, &v10))
  {
    __CFURLResourceInfoPtr(a1);
    _FSURLCacheResourcePropertiesForKeys();
  }
  else if (!v10)
  {
    CFLog(4, @"_CFURLCacheResourcePropertiesForKeys failed because it was passed a URL which has no scheme", v2, v3, v4, v5, v6, v7, v9);
  }
  return 1;
}

void _CFURLInitWithFileSystemPathRelativeToBase(unint64_t *a1, const __CFString *a2, uint64_t a3, BOOL a4, const __CFURL *a5)
{
  uint64_t v6 = (unint64_t *)_CFURLCreateWithFileSystemPath((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, a3, a4, a5);
  if (v6)
  {
    uint64_t v7 = v6;
    a1[2] = v6[2];
    unint64_t v8 = atomic_load(v6 + 3);
    atomic_store(v8, a1 + 3);
    a1[5] = v6[5];
    unint64_t v9 = atomic_load(v6 + 6);
    atomic_store(v9, a1 + 6);
    a1[4] = v6[4];
    LODWORD(v8) = *((_DWORD *)v6 + 4);
    unint64_t v10 = *(void *)&vshl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v8) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
    LOWORD(v1_CFSetTSD(0xFu, 0, 0) = vaddv_s16((int16x4_t)v10);
    int v11 = v10
        + (v8 & 1)
        + ((v8 >> 5) & 1)
        + ((v8 >> 6) & 1)
        + ((v8 >> 8) & 1)
        + ((v8 & 0x80) >> 7);
    if ((_BYTE)v11) {
      memcpy(a1 + 7, v6 + 7, 16 * v11);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
  }
}

CFURLRef CFURLCreateFromFSRef(CFAllocatorRef allocator, const FSRef *fsRef)
{
  return 0;
}

Boolean CFURLGetFSRef(CFURLRef url, FSRef *fsRef)
{
  return 0;
}

uint64_t _CFURLCreateDisplayPathComponentsArray(unint64_t a1, CFErrorRef *a2)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (!_CFURLHasFileURLScheme(a1, &v13))
  {
    if (v13)
    {
      if (a2)
      {
LABEL_7:
        CFErrorRef v10 = CFErrorCreate(0, @"NSCocoaErrorDomain", 262, 0);
        uint64_t v9 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      CFLog(4, @"_CFURLCreateDisplayPathComponentsArray failed because it was passed a URL which has no scheme", v3, v4, v5, v6, v7, v8, v12);
      if (a2) {
        goto LABEL_7;
      }
    }
    return 0;
  }
  uint64_t v9 = _FileURLCreateDisplayPathComponentsArray();
  if (!v9 && a2)
  {
    CFErrorRef v10 = CFErrorCreate(0, @"NSCocoaErrorDomain", 4, 0);
LABEL_8:
    *a2 = v10;
  }
  return v9;
}

CFDictionaryRef _CFURLCopyResourcePropertiesForKeysFromCache(const void *a1)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  char v11 = 0;
  if (_CFURLHasFileURLScheme((unint64_t)a1, &v11))
  {
    __CFURLResourceInfoPtr((unint64_t)a1);
    return (CFDictionaryRef)_FSURLCopyResourcePropertiesForKeysFromCache();
  }
  else
  {
    if (!v11) {
      CFLog(4, @"_CFURLCopyResourcePropertiesForKeysFromCache failed because it was passed a URL which has no scheme", v2, v3, v4, v5, v6, v7, v10);
    }
    CFAllocatorRef v9 = CFGetAllocator(a1);
    return CFDictionaryCreate(v9, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

uint64_t _CFURLCacheResourcePropertyForKey(unint64_t a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  char v10 = 0;
  if (_CFURLHasFileURLScheme(a1, &v10))
  {
    __CFURLResourceInfoPtr(a1);
    _FSURLCacheResourcePropertyForKey();
  }
  else if (!v10)
  {
    CFLog(4, @"_CFURLCacheResourcePropertyForKey failed because it was passed a URL which has no scheme", v2, v3, v4, v5, v6, v7, v9);
  }
  return 1;
}

uint64_t _CFURLCacheGetAutoFlushingEnabled(unint64_t a1)
{
  unint64_t v2 = __CFURLResourceInfoPtr(a1);

  return MEMORY[0x1F4114F48](a1, v2);
}

uint64_t _CFURLGetCatalogInfo()
{
  return MEMORY[0x1F4114F50]();
}

uint64_t _CFURLReplaceObject()
{
  return MEMORY[0x1F4115040]();
}

uint64_t _CFURLCreateStandardError()
{
  return MEMORY[0x1F4114F38]();
}

uint64_t _CFURLNoteSecurityScopedResourceMoved(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (_CFURLNoteSecurityScopedResourceMoved_onceToken != -1) {
    dispatch_once(&_CFURLNoteSecurityScopedResourceMoved_onceToken, &__block_literal_global_22);
  }
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))_CFURLNoteSecurityScopedResourceMoved__NS_FSURLNoteSecurityScopedResourceMovedWithFileIdentifier;
  if (_CFURLNoteSecurityScopedResourceMoved__NS_FSURLNoteSecurityScopedResourceMovedWithFileIdentifier)
  {
    return v8(a1, a2, a3, a4);
  }
  else
  {
    return MEMORY[0x1F4114F68](a1, a2);
  }
}

CFStringRef CreateTruncatedURLString(const __CFAllocator *a1, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (Length > 128)
  {
    CFIndex v6 = Length;
    v11.uint64_t location = 0;
    v11.CFIndex length = 120;
    CFStringRef v7 = CFStringCreateWithSubstring(a1, theString, v11);
    v12.uint64_t location = v6 - 8;
    v12.CFIndex length = 8;
    CFStringRef v8 = CFStringCreateWithSubstring(a1, theString, v12);
    CFStringRef v9 = CFStringCreateWithFormat(a1, 0, @"%@ ... %@", v7, v8);
    if (v7) {
      CFRelease(v7);
    }
    if (v8) {
      CFRelease(v8);
    }
    return v9;
  }
  else
  {
    return CFStringCreateCopy(a1, theString);
  }
}

CFStringRef WindowsPathToURLPath(const __CFString *a1, const __CFAllocator *a2, int a3, int a4)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  if (CFStringGetLength(a1))
  {
    MutableCFArrayRef Copy = CFStringCreateMutableCopy(a2, 0, a1);
    v32.CFIndex length = CFStringGetLength(MutableCopy);
    v32.uint64_t location = 0;
    CFStringFindAndReplace(MutableCopy, @"/", @"\\"", v32, 0);
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a2, MutableCopy, @"\\"");
    CFRelease(MutableCopy);
    CFArrayRef v10 = CFArrayCreateMutableCopy(a2, 0, ArrayBySeparatingStrings);
    CFRelease(ArrayBySeparatingStrings);
    if (!a3)
    {
      CFIndex v11 = CFArrayGetCount(v10) - 1;
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v11);
      if (CFEqual(ValueAtIndex, &stru_1ECE10768)) {
        CFArrayRemoveValueAtIndex(v10, v11);
      }
    }
    CFStringRef v13 = (const __CFString *)CFArrayGetValueAtIndex(v10, 0);
    v15 = a4 && (CFStringRef v14 = v13, CFStringGetLength(v13) == 2) && CFStringGetCharacterAtIndex(v14, 1) == 58;
    CFIndex Count = CFArrayGetCount(v10);
    if (v15 >= Count)
    {
LABEL_25:
      if (a3)
      {
        CFIndex v25 = CFArrayGetCount(v10);
        CFStringRef v26 = (const __CFString *)CFArrayGetValueAtIndex(v10, v25 - 1);
        if (CFStringGetLength(v26)) {
          CFArrayAppendValue(v10, &stru_1ECE10768);
        }
      }
      if (a4) {
        CFArrayInsertValueAtIndex(v10, 0, @"file://");
      }
      if (v10)
      {
        CFStringRef v27 = CFStringCreateByCombiningStrings(a2, v10, @"/");
        CFRelease(v10);
        return v27;
      }
    }
    else
    {
      CFIndex v17 = Count;
      while (1)
      {
        CFStringRef v18 = (const __CFString *)CFArrayGetValueAtIndex(v10, v15);
        unint64_t Length = CFStringGetLength(v18);
        if (Length <= 1) {
          unint64_t Length = 1;
        }
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        CFIndex v21 = MaximumSizeForEncoding + 1;
        if (MaximumSizeForEncoding >= 1024) {
          CFRange v22 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xBB047E6uLL);
        }
        else {
          CFRange v22 = buffer;
        }
        if (CFStringGetCString(v18, v22, v21, 0x8000100u))
        {
          size_t v23 = strlen(v22);
          CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v22, v23, 0, 0, 1, 0);
        }
        else
        {
          CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
        }
        if (v22 != buffer) {
          free(v22);
        }
        if (!StringFromFileSystemRepresentationByAddingPercentEscapes) {
          break;
        }
        if (StringFromFileSystemRepresentationByAddingPercentEscapes != v18) {
          CFArraySetValueAtIndex(v10, v15, StringFromFileSystemRepresentationByAddingPercentEscapes);
        }
        CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
        if (v17 == ++v15) {
          goto LABEL_25;
        }
      }
      CFRelease(v10);
    }
    return CFStringCreateWithCString(a2, "", 0x600u);
  }

  return CFStringCreateWithCString(a2, "", 0x600u);
}

uint64_t _CopyIsDirectoryKeyArray()
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = off_1ECE0A5A0;
  v3[1] = 3221225472;
  v3[2] = ___CopyIsDirectoryKeyArray_block_invoke;
  v3[3] = &unk_1ECDB04F8;
  v3[4] = &v4;
  if (_CopyIsDirectoryKeyArray_onceToken != -1) {
    dispatch_once(&_CopyIsDirectoryKeyArray_onceToken, v3);
  }
  v0 = (const void *)v5[3];
  if (v0)
  {
    CFRetain(v0);
    uint64_t v1 = v5[3];
  }
  else
  {
    uint64_t v1 = 0;
  }
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_182CF2F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL _CFDataURLCreateDataAndPropertiesFromResource(const __CFAllocator *a1, CFTypeRef cf, __CFString *a3, const __CFArray *a4, CFDictionaryRef *a5, __CFString *a6)
{
  uint64_t v6 = a6;
  CFAllocatorRef v132 = a1;
  uint64_t v149 = *(void *)off_1ECE0A5B0;
  if (a6) {
    LODWORD(a6->isa) = 0;
  }
  CFAllocatorRef v11 = CFGetAllocator(cf);
  CFStringRef v12 = CFURLCopyResourceSpecifier((CFURLRef)cf);
  if (!v12) {
    goto LABEL_199;
  }
  CFStringRef v13 = v12;
  CFIndex location = CFStringFind(v12, @",", 0).location;
  if (location == -1)
  {
    CFRelease(v13);
    goto LABEL_199;
  }
  v155.CFIndex length = location;
  CFStringRef v130 = v6;
  CFStringRef v128 = v13;
  v155.CFIndex location = 0;
  CFStringRef v15 = CFStringCreateWithSubstring(v11, v13, v155);
  CFStringRef v16 = CFURLCreateStringByReplacingPercentEscapes(v11, v15, &stru_1ECE10768);
  if (v16)
  {
    CFStringRef v17 = v16;
    MutableCFStringRef Copy = CFStringCreateMutableCopy(v11, 0, v16);
    CFRelease(v17);
  }
  else
  {
    MutableCFStringRef Copy = CFStringCreateMutableCopy(v11, 0, v15);
  }
  CFRelease(v15);
  CFStringTrimWhitespace(MutableCopy);
  uint64_t Length = CFStringGetLength(MutableCopy);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFStringRef v142 = MutableCopy;
  uint64_t v145 = 0;
  uint64_t v146 = Length;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
  CStringPtr = 0;
  CFRange v143 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
  }
  CFStringRef v131 = MutableCopy;
  CFAllocatorRef v127 = v11;
  uint64_t v147 = 0;
  uint64_t v148 = 0;
  CFRange v144 = CStringPtr;
  unsigned int v129 = a5;
  if (Length < 1)
  {
    uint64_t v40 = 0;
    goto LABEL_52;
  }
  uint64_t v124 = Length - 1;
  CFArrayRef v125 = a4;
  v126 = a3;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  CFIndex v25 = -1;
  uint64_t v26 = 64;
  uint64_t v27 = -1;
  unsigned long long v134 = 0u;
  long long v135 = 0u;
  while (1)
  {
    uint64_t v28 = (unint64_t)v24 >= 4 ? 4 : v24;
    uint64_t v29 = v146;
    if (v146 > v24) {
      break;
    }
    UniChar v30 = 0;
LABEL_33:
    int IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v30);
    if (IsCharacterMember) {
      uint64_t v38 = v27;
    }
    else {
      uint64_t v38 = v24;
    }
    if (IsCharacterMember) {
      uint64_t v39 = -1;
    }
    else {
      uint64_t v39 = v24;
    }
    if (v25 == -1) {
      CFIndex v25 = v39;
    }
    else {
      uint64_t v27 = v38;
    }
    ++v24;
    --v23;
    ++v26;
    if (Length == v24) {
      goto LABEL_43;
    }
  }
  if (v143)
  {
    UniChar v30 = v143[v24 + v145];
  }
  else if (v144)
  {
    UniChar v30 = v144[v145 + v24];
  }
  else
  {
    uint64_t v31 = v147;
    if (v148 <= v24 || v147 > v24)
    {
      uint64_t v33 = v28 + v23;
      uint64_t v34 = v26 - v28;
      uint64_t v35 = v24 - v28;
      uint64_t v36 = v35 + 64;
      if (v35 + 64 >= v146) {
        uint64_t v36 = v146;
      }
      uint64_t v147 = v35;
      uint64_t v148 = v36;
      if (v146 >= v34) {
        uint64_t v29 = v34;
      }
      v150.CFIndex length = v29 + v33;
      v150.CFIndex location = v145 + v35;
      CFStringGetCharacters(v142, v150, (UniChar *)&v134);
      uint64_t v31 = v147;
    }
    UniChar v30 = *((_WORD *)&v134 + v24 - v31);
  }
  if (v30 != 59) {
    goto LABEL_33;
  }
LABEL_43:
  uint64_t v40 = 0;
  if (v25 == -1)
  {
    a4 = v125;
    a3 = v126;
  }
  else
  {
    a4 = v125;
    a3 = v126;
    if (v27 != -1)
    {
      CFAllocatorRef v41 = CFGetAllocator(v131);
      CFRange v42 = CFStringCreateMutableCopy(v41, Length, v131);
      uint64_t v40 = v42;
      if (v27 != v124)
      {
        v151.CFIndex location = v27 + 1;
        v151.CFIndex length = Length + ~v27;
        CFStringDelete(v42, v151);
      }
      if (v25 >= 1)
      {
        v152.CFIndex location = 0;
        v152.CFIndex length = v25;
        CFStringDelete(v40, v152);
      }
      CFStringLowercase(v40, 0);
    }
  }
LABEL_52:
  *(void *)&unsigned long long v134 = 0;
  *((void *)&v134 + 1) = 0;
  CFStringRef v43 = v131;
  CFIndex v44 = CFStringGetLength(v131);
  v156.CFIndex location = 0;
  v156.CFIndex length = v44;
  uint64_t v45 = 0;
  if (CFStringFindWithOptions(v131, @"charset=", v156, 1uLL, (CFRange *)&v134) && *((void *)&v134 + 1))
  {
    CFCharacterSetRef v46 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
    CFIndex v47 = *((void *)&v134 + 1) + v134;
    if (*((void *)&v134 + 1) + (void)v134 >= v44)
    {
      uint64_t v45 = 0;
    }
    else
    {
      CFCharacterSetRef v48 = v46;
      v126 = a3;
      CFIndex v49 = -1;
      uint64_t v50 = -1;
      do
      {
        int CharacterAtIndex = CFStringGetCharacterAtIndex(v131, v47);
        if (CharacterAtIndex == 44 || CharacterAtIndex == 59) {
          break;
        }
        if (CFCharacterSetIsCharacterMember(v48, CharacterAtIndex))
        {
          uint64_t v52 = -1;
        }
        else
        {
          uint64_t v50 = v47;
          uint64_t v52 = v47;
        }
        if (v49 == -1) {
          CFIndex v49 = v52;
        }
        ++v47;
      }
      while (v47 < v44);
      if (v49 != -1)
      {
        CFStringRef v43 = v131;
        CFAllocatorRef v53 = CFGetAllocator(v131);
        uint64_t v54 = CFStringCreateMutableCopy(v53, v44, v131);
        uint64_t v45 = v54;
        if (v50 != v44)
        {
          v153.CFIndex location = v50 + 1;
          v153.CFIndex length = v44 + ~v50;
          CFStringDelete(v54, v153);
        }
        v154.CFIndex location = 0;
        v154.CFIndex length = v49;
        CFStringDelete(v45, v154);
        CFStringLowercase(v45, 0);
        a3 = v126;
        goto LABEL_71;
      }
      uint64_t v45 = 0;
      a3 = v126;
    }
    CFStringRef v43 = v131;
  }
LABEL_71:
  v126 = v45;
  CFIndex v55 = CFStringFind(v43, @";base64", 1uLL).location;
  if (!v40) {
    uint64_t v40 = (__CFString *)CFRetain(@"text/plain");
  }
  CFIndex v56 = CFURLGetBytes((CFURLRef)cf, 0, 0);
  uint64_t v57 = (UInt8 *)malloc_type_malloc(v56, 0x42E57B1BuLL);
  CFURLGetBytes((CFURLRef)cf, v57, v56);
  CFRange v60 = CFURLGetByteRangeForComponent((CFURLRef)cf, kCFURLComponentResourceSpecifier, 0);
  CFIndex v59 = v60.length;
  CFIndex v58 = v60.location;
  CFAllocatorRef v61 = v127;
  if (v57[v60.location] == 44)
  {
    CFIndex v62 = v60.location;
    uint64_t v6 = (__CFString *)v130;
  }
  else
  {
    uint64_t v6 = (__CFString *)v130;
    do
    {
      CFIndex v62 = v58 + 1;
      --v59;
      int v63 = v57[++v58];
    }
    while (v63 != 44);
  }
  uint64_t v64 = v62 + 1;
  int64_t v65 = v59 - 1;
  if (v55 == -1)
  {
    CFDataRef v71 = percentEscapeDecodeBuffer(v127, (uint64_t)v57, v64, v65, 0);
    if (v71) {
      goto LABEL_185;
    }
    goto LABEL_83;
  }
  int v66 = 1;
  CFDataRef v67 = percentEscapeDecodeBuffer(v127, (uint64_t)v57, v64, v65, 1);
  if (!v67)
  {
    CFDataRef v71 = 0;
    CFStringRef v130 = 0;
    CFStringRef v73 = 0;
    goto LABEL_85;
  }
  CFDataRef v68 = v67;
  BytePtr = CFDataGetBytePtr(v67);
  CFStringRef v130 = (CFStringRef)v68;
  int64_t v70 = CFDataGetLength(v68);
  if ((v70 & 3) != 0)
  {
    CFDataRef v71 = 0;
    unint64_t v72 = 0;
LABEL_81:
    free(v72);
  }
  else
  {
    if (v70 < 1025)
    {
      if (v70 <= 0)
      {
        CFDataRef v71 = CFDataCreate(v127, (const UInt8 *)&v134, 0);
        goto LABEL_184;
      }
      unint64_t v72 = (CFRange *)&v134;
    }
    else
    {
      CFArrayRef v75 = a4;
      int64_t v76 = v70;
      unint64_t v72 = (CFRange *)malloc_type_malloc(v70, 0xBEBC29B3uLL);
      int64_t v70 = v76;
      a4 = v75;
    }
    CFIndex v77 = 0;
    for (int64_t i = 0; i < v70; i += 4)
    {
      int v79 = BytePtr[i];
      if (((v79 & 0xDF) - 65) >= 0x1Au && v79 != 43 && (v79 - 47) > 0xAu) {
        goto LABEL_180;
      }
      uint64_t v81 = &BytePtr[i];
      int v82 = BytePtr[i + 1];
      if (((v82 & 0xDF) - 65) >= 0x1Au && v82 != 43 && (v82 - 47) > 0xAu) {
        goto LABEL_180;
      }
      UInt8 v84 = v81[2];
      BOOL v85 = (v84 - 47) >= 0xBu && ((v84 & 0xDF) - 65) >= 0x1Au;
      if (v85 && (int v86 = v81[2], v86 != 61) && v86 != 43
        || (UInt8 v87 = BytePtr[i + 3], (v87 - 47) >= 0xBu)
        && ((v87 & 0xDF) - 65) >= 0x1Au
        && (int v88 = BytePtr[i + 3], v88 != 43)
        && v88 != 61)
      {
LABEL_180:
        if (v72 != (CFRange *)&v134) {
          free(v72);
        }
        CFDataRef v71 = 0;
        goto LABEL_184;
      }
      char v89 = v79 - 65;
      if ((v79 - 65) >= 0x1A)
      {
        if ((v79 - 97) > 0x19)
        {
          if ((v79 - 48) > 9)
          {
            if (v79 == 47) {
              char v89 = 63;
            }
            else {
              char v89 = 0;
            }
            if (v79 == 43) {
              char v89 = 62;
            }
          }
          else
          {
            char v89 = v79 + 4;
          }
        }
        else
        {
          char v89 = v79 - 71;
        }
      }
      char v90 = v82 - 65;
      if ((v82 - 65) >= 0x1A)
      {
        if ((v82 - 97) > 0x19)
        {
          if ((v82 - 48) > 9)
          {
            if (v82 == 47) {
              char v90 = 63;
            }
            else {
              char v90 = 0;
            }
            if (v82 == 43) {
              char v90 = 62;
            }
          }
          else
          {
            char v90 = v82 + 4;
          }
        }
        else
        {
          char v90 = v82 - 71;
        }
      }
      CFIndex v91 = v77 + 1;
      *((unsigned char *)&v72->location + v77) = (4 * v89) | ((v90 & 0xF0) >> 4);
      int v92 = v81[2];
      if (v92 != 61)
      {
        int v93 = v81[1];
        char v94 = v93 - 65;
        if ((v93 - 65) >= 0x1A)
        {
          if ((v93 - 97) > 0x19)
          {
            if ((v93 - 48) > 9)
            {
              if (v93 == 47) {
                char v94 = 63;
              }
              else {
                char v94 = 0;
              }
              if (v93 == 43) {
                char v94 = 62;
              }
            }
            else
            {
              char v94 = v93 + 4;
            }
          }
          else
          {
            char v94 = v93 - 71;
          }
        }
        char v95 = v92 - 65;
        if ((v92 - 65) >= 0x1A)
        {
          if ((v92 - 97) > 0x19)
          {
            if ((v92 - 48) > 9)
            {
              if (v92 == 47) {
                char v95 = 63;
              }
              else {
                char v95 = 0;
              }
              if (v92 == 43) {
                char v95 = 62;
              }
            }
            else
            {
              char v95 = v92 + 4;
            }
          }
          else
          {
            char v95 = v92 - 71;
          }
        }
        *((unsigned char *)&v72->location + v91) = (16 * v94) | ((v95 & 0xFC) >> 2);
        CFIndex v91 = v77 + 2;
      }
      int v96 = BytePtr[i + 3];
      if (v96 == 61)
      {
        CFIndex v77 = v91;
      }
      else
      {
        int v97 = v81[2];
        char v98 = v97 - 65;
        if ((v97 - 65) >= 0x1A)
        {
          if ((v97 - 97) > 0x19)
          {
            if ((v97 - 48) > 9)
            {
              if (v97 == 47) {
                char v98 = 63;
              }
              else {
                char v98 = 0;
              }
              if (v97 == 43) {
                char v98 = 62;
              }
            }
            else
            {
              char v98 = v97 + 4;
            }
          }
          else
          {
            char v98 = v97 - 71;
          }
        }
        char v99 = v96 - 65;
        if ((v96 - 65) >= 0x1A)
        {
          if ((v96 - 97) > 0x19)
          {
            if ((v96 - 48) > 9)
            {
              if (v96 == 47) {
                char v99 = 63;
              }
              else {
                char v99 = 0;
              }
              if (v96 == 43) {
                char v99 = 62;
              }
            }
            else
            {
              char v99 = v96 + 4;
            }
          }
          else
          {
            char v99 = v96 - 71;
          }
        }
        CFIndex v77 = v91 + 1;
        *((unsigned char *)&v72->location + v91) = v99 | (v98 << 6);
      }
    }
    CFDataRef v71 = CFDataCreate(v61, (const UInt8 *)v72, v77);
    if (v72 != (CFRange *)&v134) {
      goto LABEL_81;
    }
  }
LABEL_184:
  CFRelease(v130);
  if (!v71)
  {
LABEL_83:
    CFStringRef v130 = 0;
    CFStringRef v73 = 0;
    int v66 = 1;
LABEL_85:
    CFStringRef v74 = v126;
    goto LABEL_192;
  }
LABEL_185:
  if (v40) {
    CFStringRef Copy = CFStringCreateCopy(v61, v40);
  }
  else {
    CFStringRef Copy = 0;
  }
  CFStringRef v130 = Copy;
  CFStringRef v74 = v126;
  if (v126) {
    CFStringRef v73 = CFStringCreateCopy(v61, v126);
  }
  else {
    CFStringRef v73 = 0;
  }
  int v66 = 0;
LABEL_192:
  free(v57);
  uint64_t v101 = v129;
  if (v131) {
    CFRelease(v131);
  }
  if (v40) {
    CFRelease(v40);
  }
  if (v74) {
    CFRelease(v74);
  }
  CFRelease(v128);
  if (v66)
  {
LABEL_199:
    if (v6) {
      LODWORD(v6->isa) = -10;
    }
    BOOL v104 = 0;
    if (a3) {
      a3->UniChar isa = 0;
    }
    return v104;
  }
  if (a3)
  {
    CFDataRef v102 = CFDataCreateCopy(v132, v71);
    a3->UniChar isa = v102;
  }
  if (v101)
  {
    CFStringRef v131 = v73;
    unsigned long long v134 = xmmword_1ECDFD528;
    *(void *)&long long v135 = @"kCFDataURLTextEncodingName";
    if (!a4)
    {
      a4 = (const __CFArray *)_CFDataURLCreateDataAndPropertiesFromResource_sAllProps;
      if (!_CFDataURLCreateDataAndPropertiesFromResource_sAllProps)
      {
        CFDataRef v102 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&v134, 3, &kCFTypeArrayCallBacks);
        a4 = v102;
        _CFDataURLCreateDataAndPropertiesFromResource_sAllProps = (uint64_t)v102;
      }
    }
    CFStringRef v128 = (const __CFString *)&v124;
    uint64_t v106 = MEMORY[0x1F4188790](v102, v103);
    unsigned int v107 = v123;
    memset(v123, 0, 24);
    MEMORY[0x1F4188790](v106, v108);
    memset(v122, 0, 24);
    CFIndex Count = CFArrayGetCount(a4);
    if (Count >= 1)
    {
      CFIndex v110 = Count;
      CFArrayRef v111 = a4;
      CFIndex v112 = 0;
      int v113 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v111, v112);
        if (CFEqual(ValueAtIndex, @"kCFDataURLDataLength"))
        {
          CFIndex v133 = 0;
          CFIndex v133 = CFDataGetLength(v71);
          v122[v113] = ValueAtIndex;
          unsigned int v115 = CFNumberCreate(v132, kCFNumberCFIndexType, &v133);
        }
        else
        {
          if (CFEqual(ValueAtIndex, @"kCFDataURLMimeType"))
          {
            CFStringRef v116 = v130;
            if (!v130) {
              goto LABEL_221;
            }
          }
          else
          {
            if (!CFEqual(ValueAtIndex, @"kCFDataURLTextEncodingName")) {
              goto LABEL_221;
            }
            CFStringRef v116 = v131;
            if (!v131) {
              goto LABEL_221;
            }
          }
          v122[v113] = ValueAtIndex;
          unsigned int v115 = CFStringCreateCopy(v132, v116);
        }
        v123[v113++] = v115;
LABEL_221:
        if (v110 == ++v112) {
          goto LABEL_225;
        }
      }
    }
    int v113 = 0;
LABEL_225:
    uint64_t v117 = v113;
    CFDictionaryRef v118 = CFDictionaryCreate(v132, v122, v123, v113, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v119 = v129;
    *unsigned int v129 = v118;
    if (v113 < 1)
    {
      CFStringRef v73 = v131;
    }
    else
    {
      CFStringRef v73 = v131;
      do
      {
        uint64_t v120 = *v107++;
        CFRelease(v120);
        --v117;
      }
      while (v117);
      CFDictionaryRef v118 = *v119;
    }
    BOOL v104 = v118 != 0;
  }
  else
  {
    BOOL v104 = 1;
  }
  CFStringRef v121 = v130;
  if (v71)
  {
    CFRelease(v71);
    CFStringRef v121 = v130;
  }
  if (v121) {
    CFRelease(v121);
  }
  if (v73) {
    CFRelease(v73);
  }
  return v104;
}

CFTypeRef CFURLCreatePropertyFromResource(CFAllocatorRef alloc, CFURLRef url, CFStringRef property, SInt32 *errorCode)
{
  values[1] = *(void **)off_1ECE0A5B0;
  values[0] = (void *)property;
  CFArrayRef v7 = CFArrayCreate(alloc, (const void **)values, 1, &kCFTypeArrayCallBacks);
  CFDictionaryRef properties = 0;
  if (CFURLCreateDataAndPropertiesFromResource(alloc, url, 0, &properties, v7, errorCode))
  {
    CFStringRef Value = CFDictionaryGetValue(properties, values[0]);
    CFStringRef v9 = Value;
    if (Value) {
      CFRetain(Value);
    }
    CFRelease(v7);
    CFArrayRef v7 = properties;
  }
  else
  {
    if (properties) {
      CFRelease(properties);
    }
    CFStringRef v9 = 0;
  }
  CFRelease(v7);
  return v9;
}

Boolean CFURLWriteDataAndPropertiesToResource(CFURLRef url, CFDataRef dataToWrite, CFDictionaryRef propertiesToWrite, SInt32 *errorCode)
{
  v36[9] = *(const void **)off_1ECE0A5B0;
  CFStringRef v8 = CFURLCopyScheme(url);
  if (!v8)
  {
    if (errorCode)
    {
      LOBYTE(v11) = 0;
      SInt32 v12 = -15;
LABEL_22:
      *errorCode = v12;
      return v11;
    }
    goto LABEL_61;
  }
  CFStringRef v9 = v8;
  CFComparisonResult v10 = CFStringCompare(v8, @"file", 0);
  CFRelease(v9);
  if (v10 == kCFCompareEqualTo)
  {
    if (errorCode) {
      *errorCode = 0;
    }
    if (!dataToWrite)
    {
      LOBYTE(v11) = 1;
      if (!propertiesToWrite) {
        return v11;
      }
      goto LABEL_36;
    }
    if (CFURLHasDirectoryPath(url))
    {
      if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
      {
        if (!errorCode)
        {
          LOBYTE(v11) = 0;
          if (!propertiesToWrite) {
            return v11;
          }
          goto LABEL_36;
        }
        SInt32 v14 = -15;
        goto LABEL_29;
      }
      BOOL v13 = _CFCreateDirectory((char *)buffer);
      LOBYTE(v11) = v13;
      if (errorCode && !v13)
      {
        SInt32 v14 = -10;
LABEL_29:
        LOBYTE(v11) = 0;
LABEL_34:
        *errorCode = v14;
      }
    }
    else
    {
      int Length = CFDataGetLength(dataToWrite);
      if (Length) {
        BytePtr = CFDataGetBytePtr(dataToWrite);
      }
      else {
        BytePtr = (const UInt8 *)"";
      }
      int v17 = _CFWriteBytesToFile(url, BytePtr, Length);
      LOBYTE(v11) = v17;
      if (errorCode && !v17)
      {
        SInt32 v14 = -10;
        goto LABEL_34;
      }
    }
    if (!propertiesToWrite) {
      return v11;
    }
LABEL_36:
    memset(v36, 0, 64);
    memset(keys, 0, sizeof(keys));
    if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
    {
      if (!errorCode) {
        goto LABEL_61;
      }
      char v22 = 0;
      SInt32 v23 = -15;
      goto LABEL_59;
    }
    int Count = CFDictionaryGetCount(propertiesToWrite);
    if (Count >= 8)
    {
      CFURLRef cf = url;
      CFAllocatorRef v24 = CFGetAllocator(url);
      uint64_t v20 = Count;
      uint64_t Typed = (const void **)CFAllocatorAllocateTyped(v24, 16 * Count, 1644699173, 0);
      uint64_t v19 = &Typed[Count];
      CFDictionaryGetKeysAndValues(propertiesToWrite, Typed, v19);
    }
    else
    {
      uint64_t v19 = v36;
      CFDictionaryGetKeysAndValues(propertiesToWrite, (const void **)keys, v36);
      if (Count < 1)
      {
        char v22 = 1;
        if (errorCode)
        {
LABEL_56:
          if (v22) {
            SInt32 v23 = 0;
          }
          else {
            SInt32 v23 = -10;
          }
LABEL_59:
          *errorCode = v23;
        }
LABEL_60:
        if (v22) {
          return v11;
        }
        goto LABEL_61;
      }
      CFURLRef cf = url;
      uint64_t v20 = Count;
      uint64_t Typed = (const void **)keys;
    }
    uint64_t v25 = 0;
    char v22 = 1;
    do
    {
      uint64_t v26 = (__CFString *)Typed[v25];
      CFNumberRef v27 = (const __CFNumber *)v19[v25];
      if (v26 == @"kCFURLFilePOSIXMode" || CFEqual(@"kCFURLFilePOSIXMode", v26))
      {
        int valuePtr = 0;
        CFTypeID TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID(v27))
        {
          CFNumberGetValue(v27, kCFNumberSInt32Type, &valuePtr);
          mode_t v29 = valuePtr;
        }
        else
        {
          mode_t v29 = *(_WORD *)CFDataGetBytePtr(v27);
          int valuePtr = v29;
        }
        if (chmod((const char *)buffer, v29)) {
          char v22 = 0;
        }
      }
      else
      {
        char v22 = 0;
      }
      ++v25;
    }
    while (v20 != v25);
    if (Typed != (const void **)keys)
    {
      CFAllocatorRef v30 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v30, Typed);
    }
    if (errorCode) {
      goto LABEL_56;
    }
    goto LABEL_60;
  }
  if (__CFNetwork__CFURLWriteDataAndPropertiesToResource_onceToken != -1) {
    dispatch_once(&__CFNetwork__CFURLWriteDataAndPropertiesToResource_onceToken, &__block_literal_global_57);
  }
  if (!__CFNetwork__CFURLWriteDataAndPropertiesToResource_dyfunc)
  {
    if (errorCode)
    {
      int v11 = 0;
      *errorCode = -15;
      goto LABEL_20;
    }
LABEL_61:
    LOBYTE(v11) = 0;
    return v11;
  }
  int v11 = __CFNetwork__CFURLWriteDataAndPropertiesToResource_dyfunc(url, dataToWrite, propertiesToWrite, errorCode);
  if (!errorCode) {
    return v11;
  }
LABEL_20:
  if (!v11)
  {
    SInt32 v12 = -11;
    goto LABEL_22;
  }
  return v11;
}

Boolean CFURLDestroyResource(CFURLRef url, SInt32 *errorCode)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  CFStringRef v4 = CFURLCopyScheme(url);
  if (!v4)
  {
LABEL_11:
    if (errorCode)
    {
      SInt32 v7 = -15;
LABEL_22:
      *errorCode = v7;
      return v4;
    }
    return v4;
  }
  CFStringRef v5 = v4;
  CFComparisonResult v6 = CFStringCompare(v4, @"file", 0);
  CFRelease(v5);
  if (v6 == kCFCompareEqualTo)
  {
    LODWORD(v4) = CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026);
    if (v4)
    {
      if (CFURLHasDirectoryPath(url)) {
        LODWORD(v4) = _CFRemoveDirectory((char *)buffer);
      }
      else {
        LODWORD(v4) = _CFDeleteFile((char *)buffer);
      }
      BOOL v8 = v4 == 0;
      LOBYTE(v4) = v4 != 0;
      if (v8) {
        SInt32 v7 = -10;
      }
      else {
        SInt32 v7 = 0;
      }
      if (errorCode) {
        goto LABEL_22;
      }
      return v4;
    }
    goto LABEL_11;
  }
  if (__CFNetwork__CFURLDestroyResource_onceToken != -1) {
    dispatch_once(&__CFNetwork__CFURLDestroyResource_onceToken, &__block_literal_global_61);
  }
  if (__CFNetwork__CFURLDestroyResource_dyfunc)
  {
    LODWORD(v4) = __CFNetwork__CFURLDestroyResource_dyfunc(url, errorCode);
    if (!errorCode) {
      return v4;
    }
  }
  else
  {
    LODWORD(v4) = 0;
    if (!errorCode) {
      return v4;
    }
    *errorCode = -15;
  }
  if (!v4)
  {
    SInt32 v7 = -11;
    goto LABEL_22;
  }
  return v4;
}

CFDataRef percentEscapeDecodeBuffer(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int64_t size, int a5)
{
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  if (size < 1025)
  {
    if (size <= 0) {
      return CFDataCreate(a1, bytes, 0);
    }
    CFAllocatorRef allocator = a1;
    CFStringRef v9 = bytes;
  }
  else
  {
    CFAllocatorRef allocator = a1;
    CFStringRef v9 = (UInt8 *)malloc_type_malloc(size, 0x350685CAuLL);
  }
  CFIndex v10 = 0;
  uint64_t v11 = a3 + size;
  do
  {
    int v12 = *(unsigned __int8 *)(a2 + a3);
    if (v12 != 37) {
      goto LABEL_36;
    }
    uint64_t v13 = a3 + 2;
    if (v11 <= a3 + 2
      || (char v14 = *(unsigned char *)(a3 + a2 + 1), v15 = v14 - 48, (v14 - 48) >= 0xAu)
      && (*(unsigned __int8 *)(a3 + a2 + 1) - 65 <= 0x25
        ? (BOOL v16 = ((1 << (v14 - 65)) & 0x3F0000003FLL) == 0)
        : (BOOL v16 = 1),
          v16)
      || (char v17 = *(unsigned char *)(a2 + v13), v18 = v17 - 48, v19 = (v17 - 48), v19 >= 0xA)
      && (*(unsigned __int8 *)(a2 + v13) - 65 <= 0x25
        ? (BOOL v20 = ((1 << (v17 - 65)) & 0x3F0000003FLL) == 0)
        : (BOOL v20 = 1),
          v20))
    {
      LOBYTE(v12) = 37;
LABEL_36:
      uint64_t v13 = a3;
      if (!a5) {
        goto LABEL_39;
      }
      goto LABEL_37;
    }
    unsigned __int8 v21 = v17 - 65;
    unsigned int v22 = (v14 - 65);
    if ((v14 - 97) >= 6u) {
      unsigned __int8 v23 = 0;
    }
    else {
      unsigned __int8 v23 = v14 - 87;
    }
    unsigned __int8 v24 = v14 - 55;
    if (v22 > 5) {
      unsigned __int8 v24 = v23;
    }
    if (v15 >= 0xAu) {
      unsigned __int8 v15 = v24;
    }
    char v25 = 16 * v15;
    if ((v17 - 97) >= 6u) {
      char v26 = 0;
    }
    else {
      char v26 = v17 - 87;
    }
    char v27 = v17 - 55;
    if (v21 <= 5u) {
      char v28 = v27;
    }
    else {
      char v28 = v26;
    }
    if (v19 < 0xA) {
      char v28 = v18;
    }
    LOBYTE(v12) = v28 | v25;
    if (!a5) {
      goto LABEL_39;
    }
LABEL_37:
    if ((v12 & 0x80) == 0)
    {
      if ((*((_DWORD *)off_1ECE0A578 + (char)v12 + 15) & 0x4000) != 0) {
        goto LABEL_40;
      }
LABEL_39:
      v9[v10++] = v12;
      goto LABEL_40;
    }
    if (!__maskrune((char)v12, 0x4000uLL)) {
      goto LABEL_39;
    }
LABEL_40:
    a3 = v13 + 1;
  }
  while (v13 + 1 < v11);
  CFDataRef v29 = CFDataCreate(allocator, v9, v10);
  if (v9 != bytes) {
    free(v9);
  }
  return v29;
}

uint64_t CFUniCharGetMappingData(unsigned int a1)
{
  return (uint64_t)*(&__CFUniCharMappingTables + a1);
}

uint64_t CFUniCharMapTo(unsigned int a1, __int16 *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  CFStringRef v5 = a2;
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (a4 == 4)
  {
    if (a1 >= 0x80 && CFUniCharIsMemberOf(a1, 0x65u))
    {
      uint64_t result = CFUniCharDecomposeCharacter(a1, v11, 10);
      if (result >= 1)
      {
        BOOL v8 = v11;
        uint64_t v9 = result;
        do
        {
          int v10 = *v8++;
          *v5++ = v10;
          --v9;
        }
        while (v9);
      }
    }
    else
    {
      *CFStringRef v5 = a1;
      return 1;
    }
  }
  else
  {
    return CFUniCharMapCaseTo(a1, a2, a3, a4, a5, 0);
  }
  return result;
}

uint64_t CFUniCharGetConditionalCaseMappingFlags(unsigned int a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned __int16 *a6, unsigned int a7)
{
  uint64_t v8 = a3;
  *(void *)&v62[36] = *(void *)off_1ECE0A5B0;
  if (a1 == 931)
  {
    if (a3 >= 1 && !a5)
    {
      unint64_t v10 = a2 + 2 * a4;
      uint64_t v11 = (unsigned __int16 *)(a2 + 2 * a3 - 2);
      while ((unint64_t)v11 >= a2)
      {
        uint64_t v13 = v11 - 1;
        int v12 = *v11;
        if ((v12 & 0xFC00) == 0xDC00 && (unint64_t)v13 >= a2)
        {
          int v15 = *v13;
          int v16 = v15 & 0xFC00;
          char v17 = v11 - 2;
          int v18 = v12 - 56613888 + (v15 << 10);
          if (v16 == 55296)
          {
            uint64_t v13 = v17;
            int v12 = v18;
          }
        }
        char IsMemberOf = CFUniCharIsMemberOf(v12, 0x6Du);
        uint64_t v11 = v13;
        if ((IsMemberOf & 1) == 0)
        {
          if ((CFUniCharIsMemberOf(v12, 7u) & 1) == 0)
          {
            uint64_t result = CFUniCharIsMemberOf(v12, 6u);
            if (!result) {
              return result;
            }
          }
          break;
        }
      }
      unsigned __int8 v21 = (unsigned __int16 *)(a2 + 2 * v8 + 2);
      do
      {
        if ((unint64_t)v21 >= v10) {
          return 1;
        }
        unsigned __int8 v23 = v21 + 1;
        int v22 = *v21;
        if ((v22 & 0xFC00) == 0xD800 && (unint64_t)v23 < v10)
        {
          int v25 = *v23;
          BOOL v26 = (v25 & 0xFC00) == 56320;
          char v27 = v21 + 2;
          int v28 = (v22 << 10) - 56613888 + v25;
          if (v26) {
            unsigned __int8 v23 = v27;
          }
          if (v26) {
            int v22 = v28;
          }
        }
        char v29 = CFUniCharIsMemberOf(v22, 0x6Du);
        unsigned __int8 v21 = v23;
      }
      while ((v29 & 1) != 0);
      if ((CFUniCharIsMemberOf(v22, 7u) & 1) == 0 && (CFUniCharIsMemberOf(v22, 6u) & 1) == 0) {
        return 1;
      }
    }
    return 0;
  }
  if (!a6) {
    return 0;
  }
  unsigned int v31 = *a6;
  if (v31 > 0x746B)
  {
    if (v31 == 31329) {
      goto LABEL_44;
    }
    if (v31 != 29804) {
      goto LABEL_45;
    }
    if (a1 == 775 && (a7 & 6) == 6)
    {
      uint64_t v32 = a3 - 1;
      if (a3 >= 1)
      {
        unint64_t v33 = a2 + 2 * a3;
        if (a3 == 1)
        {
LABEL_43:
          unsigned int v34 = *(unsigned __int16 *)(v33 - 2);
        }
        else
        {
          do
          {
            unint64_t v48 = v33 - 2;
            unsigned int v34 = *(unsigned __int16 *)(v33 - 2);
            if ((v34 & 0xFC00) == 0xDC00)
            {
              if (v8 < 3) {
                goto LABEL_113;
              }
              int v50 = *(unsigned __int16 *)(v33 - 4);
              v33 -= 4;
              int v49 = v50;
              if ((v50 & 0xFC00) != 0xD800) {
                goto LABEL_113;
              }
              unsigned int v34 = v34 - 56613888 + (v49 << 10);
              v8 -= 2;
            }
            else
            {
              v33 -= 2;
              uint64_t v8 = v32;
            }
            if (!CFUniCharIsMemberOf(v34, 8u))
            {
              unint64_t v48 = v33;
              goto LABEL_113;
            }
            if (!(v34 >> 17))
            {
              uint64_t v51 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + HIWORD(v34));
              if (v51)
              {
                if (*(unsigned char *)(v51 + BYTE1(v34))
                  && *(unsigned __int8 *)(v51
                                        + (*(unsigned __int8 *)(v51 + BYTE1(v34)) << 8)
                                        - 256
                                        + v34
                                        + 256) == 230)
                {
                  return 0;
                }
              }
            }
            uint64_t v32 = v8 - 1;
          }
          while ((unint64_t)v8 >= 2);
          unint64_t v48 = v33;
          if (v8 == 1) {
            goto LABEL_43;
          }
LABEL_113:
          if ((v34 & 0xFC00) == 0xDC00)
          {
            int v52 = *(unsigned __int16 *)(v48 - 2);
            BOOL v26 = (v52 & 0xFC00) == 55296;
            int v53 = (unsigned __int16)v34 - 56613888 + (v52 << 10);
            if (v26) {
              unsigned int v34 = v53;
            }
          }
        }
        uint64_t v54 = CFUniCharDecomposeCharacter(v34, &v61, 10);
        if (v54 < 2) {
          return 2;
        }
        CFIndex v55 = (int *)v62;
        uint64_t v56 = v54 - 1;
        while (1)
        {
          int v58 = *v55++;
          __int16 v57 = v58;
          uint64_t v59 = BYTE2(v58);
          if (BYTE2(v58) <= 1u)
          {
            uint64_t v60 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + v59);
            if (v60)
            {
              if (*(unsigned char *)(v60 + HIBYTE(v57))
                && *(unsigned __int8 *)(v60
                                      + (*(unsigned __int8 *)(v60 + HIBYTE(v57)) << 8)
                                      - 256
                                      + v57
                                      + 256) == 230)
              {
                break;
              }
            }
          }
          if (!--v56) {
            return 2;
          }
        }
      }
      return 0;
    }
    if (a5)
    {
      if (a1 - 105 > 1) {
        goto LABEL_45;
      }
      uint64_t v36 = (unsigned __int16 *)(a2 + 2 * (a3 + 1));
      uint64_t v37 = a4 - (a3 + 1);
      while (1)
      {
        if (v37 < 1) {
          return 0;
        }
        uint64_t v38 = v36 + 1;
        int v39 = *v36;
        if (v37 != 1 && (v39 & 0xFC00) == 0xD800 && (unsigned __int16 v40 = v36[2], v36 += 2, (v40 & 0xFC00) == 0xDC00))
        {
          int v39 = (v39 << 10) - 56613888 + *v38;
          v37 -= 2;
        }
        else
        {
          uint64_t v36 = v38;
          --v37;
        }
        uint64_t result = CFUniCharIsMemberOf(v39, 8u);
        if (!result) {
          return result;
        }
        if (BYTE2(v39) > 1u) {
          break;
        }
        uint64_t v41 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(v39));
        if (v41)
        {
          if (!*(unsigned char *)(v41 + BYTE1(v39))) {
            break;
          }
          LODWORD(v41) = *(unsigned __int8 *)(v41
                                            + (*(unsigned __int8 *)(v41 + BYTE1(v39)) << 8)
                                            - 256
                                            + v39
                                            + 256);
        }
LABEL_77:
        uint64_t result = 6;
        if (v41 == 230) {
          return result;
        }
      }
      LODWORD(v41) = 0;
      goto LABEL_77;
    }
    if (a1 - 73 >= 2 && a1 != 302) {
      goto LABEL_45;
    }
    CFRange v42 = (unsigned __int16 *)(a2 + 2 * (a3 + 1));
    uint64_t v43 = a4 - (a3 + 1);
    while (1)
    {
      if (v43 < 1) {
        return 0;
      }
      CFIndex v44 = v42 + 1;
      int v45 = *v42;
      if (v43 != 1 && (v45 & 0xFC00) == 0xD800 && (unsigned __int16 v46 = v42[2], v42 += 2, (v46 & 0xFC00) == 0xDC00))
      {
        int v45 = (v45 << 10) - 56613888 + *v44;
        v43 -= 2;
      }
      else
      {
        CFRange v42 = v44;
        --v43;
      }
      uint64_t result = CFUniCharIsMemberOf(v45, 8u);
      if (!result) {
        return result;
      }
      if (BYTE2(v45) > 1u) {
        break;
      }
      uint64_t v47 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(v45));
      if (v47)
      {
        if (!*(unsigned char *)(v47 + BYTE1(v45))) {
          break;
        }
        LODWORD(v47) = *(unsigned __int8 *)(v47
                                          + (*(unsigned __int8 *)(v47 + BYTE1(v45)) << 8)
                                          - 256
                                          + v45
                                          + 256);
      }
LABEL_97:
      uint64_t result = 4;
      if (v47 == 230) {
        return result;
      }
    }
    LODWORD(v47) = 0;
    goto LABEL_97;
  }
  if (v31 != 27758)
  {
    if (v31 != 29300)
    {
LABEL_45:
      if ((a7 & 0x10) != 0 && (CFUniCharIsMemberOf(a1, 8u) & 1) != 0
        || (a1 - 880 < 0x90 || a1 >> 8 == 31) && a5 == 1 && (CFUniCharIsMemberOf(a1, 5u) & 1) != 0)
      {
        return 16;
      }
      return 0;
    }
LABEL_44:
    if (!a5)
    {
      if (a1 == 73)
      {
        if (a3 + 1 < a4) {
          return 4 * (*(_WORD *)(a2 + 2 * (a3 + 1)) == 775);
        }
        return 0;
      }
      if (a1 == 775) {
        return (a7 >> 1) & 2;
      }
    }
    goto LABEL_45;
  }
  if ((a7 & 8) != 0) {
    return 8 * ((a1 & 0xFFFFFFDF) == 74);
  }
  if ((a1 & 0xFFFFFFDF) != 0x49 || a5 != 2) {
    goto LABEL_45;
  }
  if (a3 + 1 >= a4) {
    return 0;
  }
  int v35 = *(unsigned __int16 *)(a2 + 2 * (a3 + 1));
  if (v35 == 106) {
    return 8;
  }
  else {
    return 8 * (v35 == 74);
  }
}

uint64_t CFUniCharGetNumberOfPlanesForUnicodePropertyData(int a1)
{
  return __CFUniCharUnicodePropertyTable[4 * a1];
}

uint64_t CFUniCharGetUnicodeProperty(int a1, int a2)
{
  if (a2 == 1)
  {
    if (BYTE2(a1) > 0xEu) {
      return 1;
    }
    uint64_t v2 = (uint64_t)*(&__CFUniCharBidiProperty + BYTE2(a1));
    if (!v2) {
      return 1;
    }
    uint64_t v3 = *(unsigned __int8 *)(v2 + BYTE1(a1));
    if (v3 >= 0x13)
    {
      int v4 = -4864;
      return *(unsigned __int8 *)(v2 + ((v4 + (v3 << 8)) & 0xFFFFFF00) + a1 + 256);
    }
  }
  else
  {
    if (a2) {
      return 0;
    }
    if (BYTE2(a1) > 1u) {
      return 0;
    }
    uint64_t v2 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(a1));
    if (!v2)
    {
      return 0;
    }
    else
    {
      uint64_t v3 = *(unsigned __int8 *)(v2 + BYTE1(a1));
      if (*(unsigned char *)(v2 + BYTE1(a1)))
      {
        int v4 = -256;
        return *(unsigned __int8 *)(v2 + ((v4 + (v3 << 8)) & 0xFFFFFF00) + a1 + 256);
      }
    }
  }
  return v3;
}

uint64_t CFUniCharFillDestinationBuffer(unsigned int *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, int a6)
{
  uint64_t v6 = *a5;
  if (a6 != 2)
  {
    if (a6)
    {
      uint64_t v7 = *a3;
      if (a2 >= 1)
      {
        uint64_t v11 = v6 + a2;
        unint64_t v20 = a2 + 1;
        do
        {
          int v22 = *a1++;
          int v21 = v22;
          if (a4)
          {
            if (v6 >= a4) {
              return 0;
            }
            *(_DWORD *)uint64_t v7 = v21;
            v7 += 4;
          }
          --v20;
          ++v6;
        }
        while (v20 > 1);
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v7 = *a3;
      if (a2 >= 1)
      {
        unint64_t v8 = a2 + 1;
        do
        {
          unsigned int v10 = *a1++;
          unsigned int v9 = v10;
          if (v10 < 0x10000)
          {
            uint64_t v11 = v6 + 1;
            if (a4)
            {
              if (v6 >= a4) {
                return 0;
              }
              *(_WORD *)uint64_t v7 = v9;
              v7 += 2;
            }
          }
          else
          {
            uint64_t v11 = v6 + 2;
            if (a4)
            {
              if (v11 > a4) {
                return 0;
              }
              *(_WORD *)uint64_t v7 = ((v9 + 67043328) >> 10) - 10240;
              *(_WORD *)(v7 + 2) = v9 & 0x3FF | 0xDC00;
              v7 += 4;
            }
          }
          --v8;
          uint64_t v6 = v11;
        }
        while (v8 >= 2);
        goto LABEL_50;
      }
    }
LABEL_49:
    uint64_t v11 = *a5;
LABEL_50:
    *a3 = v7;
    *a5 = v11;
    return 1;
  }
  uint64_t v7 = *a3;
  if (a2 < 1) {
    goto LABEL_49;
  }
  uint64_t v12 = a2 + 1;
  uint64_t v11 = *a5;
  while (1)
  {
    unsigned int v14 = *a1++;
    unsigned int v13 = v14;
    BOOL v15 = v14 >= 0x200000;
    if (v14 >= 0x200000) {
      int v16 = 65533;
    }
    else {
      int v16 = v13;
    }
    if (v15) {
      LODWORD(v17) = 2;
    }
    else {
      LODWORD(v17) = 4;
    }
    if (v13 < 0x10000)
    {
      int v16 = v13;
      LODWORD(v17) = 3;
    }
    if (v13 < 0x800)
    {
      int v16 = v13;
      LODWORD(v17) = 2;
    }
    if (v13 >= 0x80) {
      unsigned int v18 = v16;
    }
    else {
      unsigned int v18 = v13;
    }
    if (v13 >= 0x80) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = 1;
    }
    v11 += v17;
    if (!a4) {
      goto LABEL_40;
    }
    if (v11 > a4) {
      return 0;
    }
    uint64_t v19 = v7 + v17;
    switch((int)v17)
    {
      case 1:
        goto LABEL_38;
      case 2:
        goto LABEL_37;
      case 3:
        goto LABEL_36;
      case 4:
        *(unsigned char *)--uint64_t v19 = v18 & 0x3F | 0x80;
        v18 >>= 6;
LABEL_36:
        *(unsigned char *)--uint64_t v19 = v18 & 0x3F | 0x80;
        v18 >>= 6;
LABEL_37:
        *(unsigned char *)--uint64_t v19 = v18 & 0x3F | 0x80;
        v18 >>= 6;
LABEL_38:
        *(unsigned char *)--uint64_t v19 = CFUniCharFillDestinationBuffer_firstByteMark[v17] | v18;
        break;
      default:
        break;
    }
    uint64_t v7 = v19 + v17;
LABEL_40:
    if ((unint64_t)--v12 < 2) {
      goto LABEL_50;
    }
  }
}

BOOL CFUniCharDecomposeWithErrorLocation(unsigned __int16 *a1, uint64_t a2, void *a3, unsigned int *a4, uint64_t a5, void *a6, int a7, int a8, char a9, uint64_t *a10)
{
  uint64_t v12 = a6;
  uint64_t v13 = a5;
  unsigned int v14 = a3;
  uint64_t v15 = a2;
  uint64_t v54 = *(void *)off_1ECE0A5B0;
  uint64_t v51 = 0;
  int v52 = a4;
  if (a10) {
    *a10 = -1;
  }
  uint64_t v16 = a2;
  if (a2 < 1) {
    goto LABEL_90;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  if (a9) {
    uint64_t v19 = &__CFUniCharHfsPlusDecomposableCharacterSetBitmapPlane0_0;
  }
  else {
    uint64_t v19 = &__CFUniCharCanonicalDecomposableCharacterSetBitmapPlane0_0;
  }
  uint64_t v49 = (uint64_t)v19;
  uint64_t v43 = 32;
  unint64_t v20 = a2;
  int v21 = (unsigned int *)v53;
  int v22 = a1;
  uint64_t v16 = a2;
LABEL_8:
  unsigned __int8 v23 = v22;
  while (1)
  {
    unsigned int v25 = *v22++;
    unsigned int v24 = v25;
    if (v25 <= 0x7F)
    {
      if (v18 < 1)
      {
        unint64_t v20 = v16;
      }
      else
      {
        if (v18 != 1) {
          __CFUniCharPrioritySort(v21, v18);
        }
        if (!CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, v13, &v51, a8))
        {
LABEL_74:
          unsigned int v14 = a3;
          uint64_t v12 = a6;
          uint64_t v15 = a2;
          goto LABEL_80;
        }
        uint64_t v18 = 0;
        uint64_t v17 = 0;
      }
      uint64_t v33 = v51;
      if (v13 < 1) {
        goto LABEL_65;
      }
      if (v51 >= v13)
      {
        uint64_t v16 = v20;
LABEL_87:
        unsigned int v14 = a3;
        uint64_t v12 = a6;
        uint64_t v15 = a2;
        goto LABEL_88;
      }
      if (a8)
      {
        if (a8 != 3)
        {
          if (a8 == 2)
          {
            *(unsigned char *)int v52 = v24;
            int v52 = (unsigned int *)((char *)v52 + 1);
            uint64_t v33 = v51;
          }
          goto LABEL_65;
        }
        int v39 = v52;
        *int v52 = v24;
        uint64_t v38 = v39 + 1;
      }
      else
      {
        uint64_t v37 = v52;
        *(_WORD *)int v52 = v24;
        uint64_t v38 = (unsigned int *)((char *)v37 + 2);
      }
      int v52 = v38;
LABEL_65:
      uint64_t v16 = v20 - 1;
      uint64_t v51 = v33 + 1;
      goto LABEL_71;
    }
    if ((v24 & 0xFC00) == 0xD800) {
      break;
    }
    if ((v24 & 0xFC00) == 0xDC00 && a8 != 0) {
      goto LABEL_76;
    }
LABEL_20:
    if (a7)
    {
      if (!(v24 >> 17))
      {
        uint64_t v28 = (uint64_t)*(&__CFUniCharCombiningPriorityTable_0 + HIWORD(v24));
        if (*(unsigned char *)(v28 + BYTE1(v24)))
        {
          if (*(unsigned char *)(v28 + (*(unsigned __int8 *)(v28 + BYTE1(v24)) << 8) - 256 + v24 + 256))
          {
            uint64_t v32 = v43;
            if (v18 + 1 >= v43)
            {
              uint64_t v32 = v43 + 32;
              uint64_t Typed = (unsigned int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4 * (v43 + 32), 0x100004052888210, 0);
              size_t v35 = 4 * v43;
              CFIndex v44 = Typed;
              memmove(Typed, v21, v35);
              if (v21 != (unsigned int *)v53) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21);
              }
              int v21 = v44;
            }
            uint64_t BitmapPtrForPlane = v49;
            if ((v24 < 0x10000 || (uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v24))) != 0)
              && ((*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v24 >> 3)) >> (v24 & 7)) & 1) != 0)
            {
              v18 += CFUniCharDecomposeCharacter(v24, &v21[v18], v32 - v18);
            }
            else
            {
              v21[v18++] = v24;
            }
            uint64_t v13 = a5;
LABEL_68:
            uint64_t v40 = 1;
            if (HIWORD(v24)) {
              uint64_t v40 = 2;
            }
            v17 += v40;
            uint64_t v43 = v32;
LABEL_71:
            unint64_t v20 = v16 - v17;
            if (v16 > v17) {
              goto LABEL_8;
            }
            goto LABEL_79;
          }
        }
      }
    }
    if (v18 < 1)
    {
      unint64_t v20 = v16;
      uint64_t v13 = a5;
    }
    else
    {
      uint64_t v13 = a5;
      if (v18 != 1) {
        __CFUniCharPrioritySort(v21, v18);
      }
      if (!CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, a5, &v51, a8)) {
        goto LABEL_74;
      }
      uint64_t v17 = 0;
    }
    uint64_t v29 = v49;
    if ((v24 < 0x10000 || (uint64_t v29 = CFUniCharGetBitmapPtrForPlane(9u, BYTE2(v24))) != 0)
      && ((*(unsigned __int8 *)(v29 + ((unsigned __int16)v24 >> 3)) >> (v24 & 7)) & 1) != 0)
    {
      uint64_t v30 = CFUniCharDecomposeCharacter(v24, v21, 32);
      uint64_t v18 = v30;
      if (a7 && v30 != 1)
      {
        uint64_t v16 = v20;
        uint64_t v32 = v43;
        goto LABEL_68;
      }
    }
    else
    {
      *int v21 = v24;
      uint64_t v18 = 1;
    }
    if (!CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, v13, &v51, a8))
    {
      uint64_t v16 = v20;
      goto LABEL_79;
    }
    uint64_t v18 = 0;
    uint64_t v31 = -2;
    if (!HIWORD(v24)) {
      uint64_t v31 = -1;
    }
    uint64_t v16 = v20 + v31;
    unsigned __int8 v23 = v22;
    unint64_t v20 = v16 - v17;
    if (v16 <= v17) {
      goto LABEL_87;
    }
  }
  if (v20 >= 2)
  {
    int v27 = *v22;
    if ((v27 & 0xFC00) == 0xDC00)
    {
      int v22 = v23 + 2;
      unsigned int v24 = v27 + (v24 << 10) - 56613888;
      goto LABEL_20;
    }
  }
  if (!a8) {
    goto LABEL_20;
  }
  unsigned __int8 v23 = v22;
LABEL_76:
  if (a10) {
    *a10 = v23 - a1;
  }
  uint64_t v13 = a5;
LABEL_79:
  unsigned int v14 = a3;
  uint64_t v12 = a6;
  uint64_t v15 = a2;
  if (v18 < 1) {
    goto LABEL_88;
  }
LABEL_80:
  if ((unint64_t)v18 >= 2) {
    __CFUniCharPrioritySort(v21, v18);
  }
  if (CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, v13, &v51, a8)) {
    uint64_t v41 = v17;
  }
  else {
    uint64_t v41 = 0;
  }
  v16 -= v41;
LABEL_88:
  if (v21 != (unsigned int *)v53) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21);
  }
LABEL_90:
  if (v14) {
    *unsigned int v14 = v15 - v16;
  }
  if (v12) {
    *uint64_t v12 = v51;
  }
  return v16 < 1;
}

BOOL CFUniCharDecompose(unsigned __int16 *a1, uint64_t a2, void *a3, unsigned int *a4, uint64_t a5, void *a6, int a7, int a8, char a9)
{
  return CFUniCharDecomposeWithErrorLocation(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0);
}

uint64_t (**__CFStringEncodingGetTraditionalChineseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_1)
  {
    __CFStringEncodingIsDecomposableCharacter_1 = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter_1 = (_UNKNOWN *)a2(2);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_3 = (_UNKNOWN *)a2(3);
    __CFStringEncodingPrecomposeLatinCharacter_5 = (_UNKNOWN *)a2(4);
  }
  int v4 = __CFConverterMacTraditionalChinese;
  if (a1 != 2) {
    int v4 = 0;
  }
  if (a1 == 2563) {
    return __CFConverterBig5;
  }
  else {
    return v4;
  }
}

uint64_t __CFToBig5(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 < 0x80)
  {
    uint64_t result = 1;
    goto LABEL_3;
  }
  if (a2 < 0xA2) {
    return 0;
  }
  int v4 = (unsigned __int16 *)&__CFToBig5CharMap;
  CFStringRef v5 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + 42642);
  while (1)
  {
    uint64_t v6 = (uint64_t)(0x8E38E38E38E38E39 * (v5 - v4)) >> 1;
    uint64_t v7 = &v4[9 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    CFStringRef v5 = v7 - 9;
LABEL_10:
    if (v4 > v5) {
      return 0;
    }
  }
  if (v8 + 8 <= a2)
  {
    int v4 = v7 + 9;
    goto LABEL_10;
  }
  LOWORD(a2) = v4[9 * v6 + 1 + (int)(a2 - v8)];
  if (!(_WORD)a2 || (unsigned __int16)a2 == 65533) {
    return 0;
  }
  *a3++ = BYTE1(a2);
  uint64_t result = 2;
LABEL_3:
  *a3 = a2;
  return result;
}

uint64_t __CFFromBig5(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4)
{
  int v4 = *a2;
  if ((*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1;
  }
  if (a3 < 2) {
    return 0;
  }
  unsigned int v6 = a2[1] | (v4 << 8);
  if ((unsigned __int16)(v6 + 1566) < 0xA75Eu) {
    goto LABEL_11;
  }
  uint64_t v7 = (unsigned __int16 *)&__CFFromBig5CharMap;
  unsigned int v8 = (unsigned __int16 *)((char *)&__CFFromBig5CharMap + 28248);
  while (1)
  {
    uint64_t v9 = (0xF83E0F83E0F83E1 * (v8 - v7)) >> 1;
    unsigned int v10 = &v7[33 * v9];
    unsigned int v11 = *v10;
    if (v11 <= v6) {
      break;
    }
    unsigned int v8 = v10 - 33;
LABEL_10:
    if (v7 > v8) {
      goto LABEL_11;
    }
  }
  if (v11 + 32 <= v6)
  {
    uint64_t v7 = v10 + 33;
    goto LABEL_10;
  }
  unsigned __int16 v12 = v7[33 * v9 + 1 + (int)(v6 - v11)];
  if (!v12)
  {
LABEL_11:
    *a4 = -3;
    return 0;
  }
  *a4 = v12;
  if (v12 == 65533) {
    return 0;
  }
  return 2;
}

uint64_t __CFToBig5Len(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    unsigned int v4 = *a2++;
    if (v4 < 0x80) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = 2;
    }
    result += v5;
  }
  return result;
}

uint64_t __CFFromBig5Len(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    BOOL v5 = a3 == 1 || *a2 >= 0;
    BOOL v6 = !v5;
    if (v5) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    a2 += v7;
    if (v6) {
      uint64_t v8 = -2;
    }
    else {
      uint64_t v8 = -1;
    }
    ++result;
    BOOL v9 = __OFADD__(v8, a3);
    a3 += v8;
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFToBig5Precompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  unsigned int v9 = *a2;
  if (v9 > 0x7F)
  {
    int v11 = a2[1];
    if (v9 == 12454) {
      int v12 = 12532;
    }
    else {
      int v12 = v9 + 1;
    }
    int v13 = v9 + 2;
    if (v11 != 12442) {
      int v13 = 65533;
    }
    if (v11 == 12441) {
      unsigned int v14 = v12;
    }
    else {
      unsigned int v14 = v13;
    }
    if ((v9 & 0xFFFFFFDF) == 0x418) {
      int v15 = v9 + 1;
    }
    else {
      int v15 = -3;
    }
    if (v9 == 1077) {
      int v16 = 1105;
    }
    else {
      int v16 = -3;
    }
    if (v9 == 1045) {
      unsigned int v17 = 1025;
    }
    else {
      unsigned int v17 = v16;
    }
    if (v11 != 776) {
      unsigned int v17 = 65533;
    }
    if (v11 == 774) {
      unsigned int v17 = v15;
    }
    if (a2[1] <= 0x3098u) {
      uint64_t v10 = v17;
    }
    else {
      uint64_t v10 = v14;
    }
  }
  else
  {
    uint64_t v10 = __CFStringEncodingPrecomposeLatinCharacter_5(a2, a3, 0);
  }
  int v18 = __CFToBig5(v10, (unsigned __int16)v10, v22);
  char v19 = v22[0];
  if (v18) {
    BOOL v20 = v22[0] == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    uint64_t result = 2;
    *a6 = 2;
    if (!a5) {
      return result;
    }
    if (a5 >= 2)
    {
      *a4 = v19;
      a4[1] = v22[1];
      return 2;
    }
  }
  return 0;
}

uint64_t __CFIsValidCombiningCharTraditionalChinese(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1 << (a1 - 6)) & 0x4000000000005) != 0
    || (a1 - 12441) < 2)
  {
    return 1;
  }
  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_3();
  }
}

uint64_t __CFToMacTraditionalChinese(char a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
    goto LABEL_157;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
  uint64_t v14 = 0xA692u;
  while (1)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_157;
      }
      uint64_t v15 = *a2;
      if ((v15 & 0xFFF0) != 0xF870) {
        goto LABEL_157;
      }
    }
    else
    {
      uint64_t v15 = *a2;
    }
    if (v15 < 0x80 || v15 == 160 || a1 < 0 && (unsigned __int16)(v15 - 131) <= 0x1Cu)
    {
      ++v11;
      if (a5) {
        *a4++ = v15;
      }
      goto LABEL_41;
    }
    if ((unsigned __int16)(v15 + 1918) < 0x827u) {
      break;
    }
    int v16 = (unsigned __int16 *)&__CFToMacTraditionalChineseMap;
    unsigned int v17 = (unsigned __int16 *)&unk_182EC39A2;
    while (1)
    {
      uint64_t v18 = ((char *)v17 - (char *)v16) >> 3;
      char v19 = &v16[2 * v18];
      unsigned int v20 = *v19;
      if (v20 <= v15) {
        break;
      }
      unsigned int v17 = v19 - 2;
LABEL_21:
      if (v16 > v17) {
        goto LABEL_22;
      }
    }
    if (v20 < v15)
    {
      int v16 = v19 + 2;
      goto LABEL_21;
    }
    unsigned int v26 = v16[2 * v18 + 1];
    if (v26 > 0xFF)
    {
      if (a5)
      {
        if (v11 + 2 > a5) {
          goto LABEL_157;
        }
        *a4 = BYTE1(v26);
        a4[1] = v26;
        a4 += 2;
      }
      v11 += 2;
      goto LABEL_41;
    }
    ++v11;
    if (a5) {
      *a4++ = v26;
    }
LABEL_41:
    ++a2;
    if (++v12 == a3)
    {
      uint64_t v12 = a3;
      goto LABEL_157;
    }
  }
LABEL_22:
  if (v15 < 0xA2) {
    goto LABEL_38;
  }
  int v21 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + v14);
  int v22 = (unsigned __int16 *)&__CFToBig5CharMap;
  while (2)
  {
    uint64_t v23 = (uint64_t)(0x8E38E38E38E38E39 * (v21 - v22)) >> 1;
    unsigned int v24 = &v22[9 * v23];
    unsigned int v25 = *v24;
    if (v25 > v15)
    {
      int v21 = v24 - 9;
      goto LABEL_28;
    }
    if (v25 + 8 <= v15)
    {
      int v22 = v24 + 9;
LABEL_28:
      if (v22 > v21) {
        goto LABEL_38;
      }
      continue;
    }
    break;
  }
  unsigned int v27 = v22[9 * v23 + 1 + (int)(v15 - v25)];
  if ((_WORD)v27) {
    BOOL v28 = (unsigned __int16)v27 == 65533;
  }
  else {
    BOOL v28 = 1;
  }
  if (!v28)
  {
    if (a5)
    {
      if (v11 + 2 > a5) {
        goto LABEL_157;
      }
      *(_WORD *)a4 = bswap32(v27) >> 16;
      a4 += 2;
    }
    v11 += 2;
    goto LABEL_41;
  }
LABEL_38:
  if ((a1 & 8) != 0 || !v12) {
    goto LABEL_157;
  }
  if ((a1 & 0x10) == 0) {
    goto LABEL_41;
  }
  if (((v15 - 774) > 0x32 || ((1 << (v15 - 6)) & 0x4000000000005) == 0)
    && (v15 - 12441) >= 2)
  {
    unsigned __int16 v46 = a6;
    if (v13[426](v15, 1025, &__CFToBig5CharMap))
    {
      LODWORD(v15) = *a2;
      a6 = v46;
      int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
      uint64_t v14 = 0xA692u;
      goto LABEL_48;
    }
    switch((int)v15)
    {
      case 63612:
        int v32 = *(a2 - 1);
        uint64_t v14 = 42642;
        if (v32 == 8254)
        {
          char v33 = -61;
          a6 = v46;
          int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
          goto LABEL_140;
        }
        a6 = v46;
        int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
        if (v32 == 65343)
        {
          char v33 = -59;
          goto LABEL_140;
        }
        if (v32 == 65099)
        {
          char v33 = -53;
          goto LABEL_140;
        }
        goto LABEL_157;
      case 63613:
        unsigned int v41 = *(a2 - 1);
        uint64_t v14 = 42642;
        if (v41 <= 0xFF0D)
        {
          a6 = v46;
          if (v41 == 12289)
          {
            char v33 = 78;
            int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
          }
          else
          {
            int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
            if (v41 == 65281)
            {
              char v33 = 84;
            }
            else
            {
              if (v41 != 65292) {
                goto LABEL_157;
              }
              char v33 = 77;
            }
          }
        }
        else
        {
          a6 = v46;
          if (*(a2 - 1) > 0xFF1Au)
          {
            int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
            if (v41 == 65307)
            {
              char v33 = 81;
            }
            else
            {
              if (v41 != 65311) {
                goto LABEL_157;
              }
              char v33 = 83;
            }
          }
          else
          {
            int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
            if (v41 == 65294)
            {
              char v33 = 79;
            }
            else
            {
              if (v41 != 65306) {
                goto LABEL_157;
              }
              char v33 = 82;
            }
          }
        }
LABEL_140:
        if (a5)
        {
          *(a4 - 2) = -95;
          *(a4 - 1) = v33;
        }
        goto LABEL_41;
      case 63614:
        a6 = v46;
        uint64_t v14 = 42642;
        if ((__int16)*(a2 - 1) != -242) {
          goto LABEL_157;
        }
        if (a5) {
          *((_WORD *)a4 - 1) = 20641;
        }
        int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
        goto LABEL_41;
      case 63615:
        unsigned int v42 = *(a2 - 1);
        uint64_t v14 = 42642;
        if (v42 > 0xFF07)
        {
          a6 = v46;
          if (*(a2 - 1) > 0xFF3Bu)
          {
            int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
            if (*(a2 - 1) > 0xFF5Au)
            {
              if (v42 == 65371)
              {
                char v44 = -95;
                char v43 = -95;
              }
              else
              {
                if (v42 != 65373) {
                  goto LABEL_157;
                }
                char v43 = -94;
                char v44 = -95;
              }
              goto LABEL_153;
            }
            if (v42 != 65340)
            {
              if (v42 != 65343) {
                goto LABEL_157;
              }
              char v43 = 90;
              goto LABEL_149;
            }
            char v43 = 64;
            char v44 = -94;
LABEL_153:
            if (!a5) {
              goto LABEL_41;
            }
            *(a4 - 2) = v44;
            goto LABEL_155;
          }
          int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
          switch(v42)
          {
            case 0xFF08u:
              char v43 = 125;
              char v44 = -95;
              goto LABEL_153;
            case 0xFF09u:
              char v43 = 126;
              break;
            case 0xFF0Fu:
              char v43 = -2;
              break;
            default:
              goto LABEL_157;
          }
LABEL_149:
          char v44 = -95;
          goto LABEL_153;
        }
        a6 = v46;
        int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_1EC093000;
        if (*(a2 - 1) > 0x3014u)
        {
          switch(v42)
          {
            case 0x3015u:
              char v43 = -92;
              goto LABEL_149;
            case 0x5341u:
              char v43 = -52;
              break;
            case 0x5345u:
              char v43 = -50;
              break;
            default:
              goto LABEL_157;
          }
        }
        else
        {
          if (v42 == 92)
          {
            if (!a5) {
              goto LABEL_41;
            }
            char v43 = 0x80;
LABEL_155:
            *(a4 - 1) = v43;
            goto LABEL_41;
          }
          if (v42 != 9474)
          {
            if (v42 != 12308) {
              goto LABEL_157;
            }
            char v43 = -93;
            goto LABEL_149;
          }
          char v43 = 121;
        }
        char v44 = -94;
        goto LABEL_153;
      default:
        a6 = v46;
        goto LABEL_157;
    }
  }
LABEL_48:
  int v29 = *(a2 - 1);
  if ((int)v15 <= 823)
  {
    if (v15 != 774)
    {
      if (v15 == 776)
      {
        if (v29 == 1077) {
          __int16 v31 = 1105;
        }
        else {
          __int16 v31 = -3;
        }
        if (v29 == 1045) {
          unsigned __int16 v30 = 1025;
        }
        else {
          unsigned __int16 v30 = v31;
        }
        goto LABEL_83;
      }
      goto LABEL_71;
    }
    if ((v29 & 0xFFFFFFDF) == 0x418)
    {
      unsigned __int16 v30 = v29 + 1;
      goto LABEL_83;
    }
    goto LABEL_71;
  }
  if (v15 == 824)
  {
    if (v29 == 61)
    {
      unsigned __int16 v30 = 8800;
      goto LABEL_83;
    }
LABEL_71:
    unsigned __int16 v30 = -3;
    goto LABEL_83;
  }
  if (v15 != 12441)
  {
    if (v15 == 12442)
    {
      unsigned __int16 v30 = v29 + 2;
      goto LABEL_82;
    }
    goto LABEL_71;
  }
  if (v29 != 12454)
  {
    unsigned __int16 v30 = v29 + 1;
LABEL_82:
    if (v30 < 0xA2u) {
      goto LABEL_157;
    }
    goto LABEL_83;
  }
  unsigned __int16 v30 = 12532;
LABEL_83:
  unsigned int v34 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + v14);
  size_t v35 = (unsigned __int16 *)&__CFToBig5CharMap;
  while (1)
  {
    uint64_t v36 = (uint64_t)(0x8E38E38E38E38E39 * (v34 - v35)) >> 1;
    uint64_t v37 = &v35[9 * v36];
    unsigned int v38 = *v37;
    if (v38 <= v30) {
      break;
    }
    unsigned int v34 = v37 - 9;
LABEL_88:
    if (v35 > v34) {
      goto LABEL_157;
    }
  }
  if (v38 + 8 <= v30)
  {
    size_t v35 = v37 + 9;
    goto LABEL_88;
  }
  unsigned int v39 = v35[9 * v36 + 1 + (int)(v30 - v38)];
  if ((_WORD)v39) {
    BOOL v40 = (unsigned __int16)v39 == 65533;
  }
  else {
    BOOL v40 = 1;
  }
  if (!v40)
  {
    if (a5) {
      *((_WORD *)a4 - 1) = bswap32(v39) >> 16;
    }
    goto LABEL_41;
  }
LABEL_157:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromMacTraditionalChinese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v45 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = a1 & 0xC0;
  if ((a1 & 0x200) != 0) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = 2;
  }
  uint64_t v16 = 0x6E58u;
  unsigned int v17 = &unk_1EC093000;
LABEL_6:
  if (a5 && v12 >= a5) {
    return v13;
  }
  int v18 = (char)*a2;
  int v19 = *a2;
  if ((v18 & 0x80000000) == 0 || v18 == -96 || (a1 & 0x80) != 0 && (v19 + 125) <= 0x1Cu) {
    goto LABEL_12;
  }
  if (v19 != 128)
  {
    if ((v19 + 3) > 0x85u)
    {
      if (v9 < 2) {
        return v13;
      }
      if (v19 == 161)
      {
        unsigned int v22 = a2[1];
        if (v22 <= 0x7D)
        {
          __int16 v24 = 183;
          switch(a2[1])
          {
            case 'E':
              goto LABEL_157;
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'L':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
              goto LABEL_47;
            case 'K':
              __int16 v24 = 8943;
              goto LABEL_157;
            case 'M':
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -244;
                goto LABEL_157;
              }
              int v23 = -15927171;
              goto LABEL_93;
            case 'N':
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = 12289;
                goto LABEL_157;
              }
              int v23 = 805435517;
              goto LABEL_93;
            case 'O':
              if ((a1 & 0x200) != 0) {
                goto LABEL_141;
              }
              int v23 = -15796099;
              goto LABEL_93;
            case 'P':
              if ((a1 & 0x200) != 0)
              {
LABEL_141:
                __int16 v24 = -242;
                goto LABEL_157;
              }
              int v23 = -15796098;
              goto LABEL_93;
            case 'Q':
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -229;
                goto LABEL_157;
              }
              int v23 = -14944131;
              goto LABEL_93;
            case 'R':
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -230;
                goto LABEL_157;
              }
              int v23 = -15009667;
              goto LABEL_93;
            case 'S':
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -225;
                goto LABEL_157;
              }
              int v23 = -14681987;
              goto LABEL_93;
            case 'T':
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -255;
                goto LABEL_157;
              }
              int v23 = -16648067;
              goto LABEL_93;
            case 'Z':
              if ((a1 & 0x200) != 0) {
                goto LABEL_140;
              }
              int v23 = -12584833;
              goto LABEL_93;
            default:
              if (v22 != 125) {
                goto LABEL_47;
              }
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -248;
                goto LABEL_157;
              }
              int v23 = -16189313;
              break;
          }
          goto LABEL_93;
        }
        if (a2[1] <= 0xC2u)
        {
          switch(a2[1])
          {
            case 0xA1u:
              if ((a1 & 0x200) == 0)
              {
                int v23 = -10749825;
                break;
              }
              __int16 v24 = -165;
              goto LABEL_157;
            case 0xA2u:
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -163;
                goto LABEL_157;
              }
              int v23 = -10618753;
              break;
            case 0xA3u:
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = 12308;
                goto LABEL_157;
              }
              int v23 = 806680703;
              break;
            case 0xA4u:
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = 12309;
                goto LABEL_157;
              }
              int v23 = 806746239;
              break;
            default:
              if (v22 != 126) {
                goto LABEL_47;
              }
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -247;
                goto LABEL_157;
              }
              int v23 = -16123777;
              break;
          }
LABEL_93:
          v12 += 2;
          if (!a5) {
            goto LABEL_160;
          }
          if (v12 <= a5)
          {
            HIDWORD(v4_CFSetTSD(0xFu, 0, 0) = v23;
            LODWORD(v4_CFSetTSD(0xFu, 0, 0) = v23;
            *(_DWORD *)a4 = v40 >> 16;
            a4 += 4;
            goto LABEL_160;
          }
          return v13;
        }
        if (a2[1] <= 0xCAu)
        {
          if (v22 == 195)
          {
            if ((a1 & 0x200) != 0)
            {
              __int16 v24 = 8254;
              goto LABEL_157;
            }
            int v23 = 540997756;
            goto LABEL_93;
          }
          if (v22 == 197)
          {
            if ((a1 & 0x200) == 0)
            {
              int v23 = -12584836;
              goto LABEL_93;
            }
LABEL_140:
            __int16 v24 = -193;
LABEL_157:
            if (a5)
            {
              *(_WORD *)a4 = v24;
              a4 += 2;
            }
            ++v12;
LABEL_160:
            uint64_t v20 = 2;
LABEL_16:
            *a6 = v12;
            goto LABEL_17;
          }
        }
        else
        {
          switch(v22)
          {
            case 0xCBu:
              if ((a1 & 0x200) != 0)
              {
                __int16 v24 = -437;
                goto LABEL_157;
              }
              int v23 = -28575620;
              goto LABEL_93;
            case 0xF2u:
              __int16 v24 = 8853;
              goto LABEL_157;
            case 0xFEu:
              if ((a1 & 0x200) == 0)
              {
                int v23 = -15730561;
                goto LABEL_93;
              }
              __int16 v24 = -241;
              goto LABEL_157;
          }
        }
      }
      else if (v19 == 162)
      {
        unsigned int v22 = a2[1];
        if (v22 > 0xCB)
        {
          if (v22 == 204)
          {
            if ((a1 & 0x200) == 0)
            {
              int v23 = 1396832383;
              goto LABEL_93;
            }
            __int16 v24 = 21313;
            goto LABEL_157;
          }
          if (v22 == 206)
          {
            if ((a1 & 0x200) == 0)
            {
              int v23 = 1397094527;
              goto LABEL_93;
            }
            __int16 v24 = 21317;
            goto LABEL_157;
          }
        }
        else
        {
          if (v22 == 64)
          {
            if ((a1 & 0x200) == 0)
            {
              int v23 = -12781441;
              goto LABEL_93;
            }
            __int16 v24 = -196;
            goto LABEL_157;
          }
          if (v22 == 121)
          {
            if ((a1 & 0x200) == 0)
            {
              int v23 = 620951679;
              goto LABEL_93;
            }
            __int16 v24 = 9474;
            goto LABEL_157;
          }
        }
      }
      else
      {
        unsigned int v22 = a2[1];
      }
LABEL_47:
      unsigned int v25 = v22 | (v19 << 8);
      if ((unsigned __int16)(v25 + 1566) < 0xA75Eu) {
        return v13;
      }
      unsigned int v26 = (unsigned __int16 *)&__CFFromBig5CharMap;
      unsigned int v27 = (unsigned __int16 *)((char *)&__CFFromBig5CharMap + v16);
      while (1)
      {
        uint64_t v28 = (0xF83E0F83E0F83E1 * (v27 - v26)) >> 1;
        int v29 = &v26[33 * v28];
        unsigned int v30 = *v29;
        if (v30 <= v25)
        {
          if (v30 + 32 > v25)
          {
            __int16 v31 = v17;
            unsigned __int16 v32 = v26[33 * v28 + 1 + (int)(v25 - v30)];
            if (v32) {
              BOOL v33 = v32 == 65533;
            }
            else {
              BOOL v33 = 1;
            }
            if (v33) {
              return v13;
            }
            if (v14 != 64
              || (unsigned int v42 = v32,
                  uint64_t v43 = v15,
                  int IsDecomposableCharacter_1 = __CFStringEncodingIsDecomposableCharacter_1(),
                  uint64_t v15 = v43,
                  int v14 = 64,
                  !IsDecomposableCharacter_1))
            {
              if (a5)
              {
                *(_WORD *)a4 = v32;
                a4 += 2;
              }
              uint64_t v16 = 28248;
              uint64_t v12 = *a6 + 1;
              uint64_t v20 = 2;
              unsigned int v17 = v31;
              goto LABEL_16;
            }
            unsigned int v17 = v31;
            uint64_t v35 = (*((uint64_t (**)(uint64_t, void, unsigned char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v31
                   + 425))(a1, v42, v44, 4279040125, 4279957629, 327680, 4282382460, 4278777983);
            uint64_t v36 = *a6;
            uint64_t v12 = *a6 + v35;
            *a6 = v12;
            if (!a5) {
              goto LABEL_107;
            }
            if (v12 > a5)
            {
              *a6 = v36;
              return v13;
            }
            if (v35 < 1)
            {
LABEL_107:
              uint64_t v20 = 2;
              int v14 = 64;
              uint64_t v15 = v43;
              uint64_t v16 = 28248;
              goto LABEL_17;
            }
            unint64_t v37 = v35 + 1;
            unsigned int v38 = (__int16 *)v44;
            int v14 = 64;
            uint64_t v15 = v43;
            do
            {
              __int16 v39 = *v38++;
              *(_WORD *)a4 = v39;
              a4 += 2;
              --v37;
            }
            while (v37 > 1);
            uint64_t v20 = 2;
            uint64_t v16 = 28248;
LABEL_17:
            v13 += v20;
            a2 += v20;
            BOOL v21 = (uint64_t)v9 <= v20;
            v9 -= v20;
            if (v21) {
              return v13;
            }
            goto LABEL_6;
          }
          unsigned int v26 = v29 + 33;
        }
        else
        {
          unsigned int v27 = v29 - 33;
        }
        if (v26 > v27) {
          return v13;
        }
      }
    }
    if (*a2 > 0xFCu)
    {
      if (v19 == 253)
      {
        LOWORD(v19) = 169;
      }
      else if (v19 == 254)
      {
        LOWORD(v19) = 8482;
      }
      else
      {
        LOWORD(v19) = 8230;
      }
      goto LABEL_12;
    }
    if (v19 == 129)
    {
      if ((a1 & 0x200) == 0)
      {
        LOWORD(v19) = -1920;
        goto LABEL_12;
      }
    }
    else if (v19 == 130 && (a1 & 0x200) == 0)
    {
      LOWORD(v19) = -1919;
LABEL_12:
      if (a5)
      {
        *(_WORD *)a4 = v19;
        a4 += 2;
      }
      ++v12;
      goto LABEL_15;
    }
    uint64_t v20 = 1;
    goto LABEL_17;
  }
  v12 += v15;
  if (!a5)
  {
LABEL_15:
    uint64_t v20 = 1;
    goto LABEL_16;
  }
  if (v12 <= a5)
  {
    *(_WORD *)a4 = 92;
    if ((a1 & 0x200) != 0)
    {
      a4 += 2;
    }
    else
    {
      *(_WORD *)(a4 + 2) = -1921;
      a4 += 4;
    }
    goto LABEL_15;
  }
  return v13;
}

uint64_t __CFFromMacTraditionalChineseLen(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if ((*a2 & 0x80) != 0
      && (*a2 - 129 <= 0x1F ? (BOOL v4 = ((1 << (*a2 + 127)) & 0x80000003) == 0) : (BOOL v4 = 1),
          v4 ? (BOOL v5 = (unint64_t)a3 >= 2) : (BOOL v5 = 0),
          v5 && *a2 < 0xFDu))
    {
      int v6 = *a2;
      uint64_t v7 = a3 - 1;
      if (v6 == 128) {
        uint64_t v8 = a2 + 1;
      }
      else {
        uint64_t v8 = a2 + 2;
      }
      if (v6 == 128)
      {
        uint64_t v9 = result + 1;
      }
      else
      {
        uint64_t v7 = a3 - 2;
        uint64_t v9 = result;
      }
      if (v6 == 161) {
        a2 += 2;
      }
      else {
        a2 = v8;
      }
      if (v6 == 161) {
        a3 -= 2;
      }
      else {
        a3 = v7;
      }
      if (v6 == 161) {
        ++result;
      }
      else {
        uint64_t result = v9;
      }
    }
    else
    {
      ++a2;
      --a3;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t CFUniCharPrecomposeCharacter(unsigned int a1, unsigned int a2)
{
  if (a2 - 71985 < 0xFFFEE9CF) {
    return 65533;
  }
  uint64_t v2 = (unsigned int *)&__CFUniCharPrecompSourceTable;
  uint64_t v3 = (unsigned int *)&unk_182D60C38;
  while (1)
  {
    uint64_t v4 = ((char *)v3 - (char *)v2) >> 4;
    BOOL v5 = &v2[2 * v4];
    if (*v5 <= a2) {
      break;
    }
    uint64_t v3 = v5 - 2;
LABEL_7:
    if (v2 > v3) {
      return 65533;
    }
  }
  if (*v5 < a2)
  {
    uint64_t v2 = v5 + 2;
    goto LABEL_7;
  }
  unsigned int v7 = v2[2 * v4 + 1];
  if (!v7) {
    return 65533;
  }
  uint64_t v8 = (unsigned __int16)v2[2 * v4 + 1];
  if ((v7 & 0x80000000) != 0)
  {
    int v14 = (char *)&__CFUniCharNonBMPPrecompDestinationTable + 4 * v8;
    if (*(_DWORD *)v14 > a1) {
      return 65533;
    }
    uint64_t v15 = &v14[8 * (HIWORD(v7) & 0x7FFF) - 8];
    if (*(_DWORD *)v15 < a1) {
      return 65533;
    }
    while (1)
    {
      uint64_t v16 = (v15 - v14) >> 4;
      unsigned int v17 = &v14[8 * v16];
      if (*(_DWORD *)v17 <= a1)
      {
        if (*(_DWORD *)v17 >= a1)
        {
          uint64_t result = *(unsigned int *)&v14[8 * v16 + 4];
LABEL_30:
          if (!result) {
            return 65533;
          }
          return result;
        }
        int v14 = v17 + 8;
      }
      else
      {
        uint64_t v15 = v17 - 8;
      }
      if (v14 > v15) {
        return 65533;
      }
    }
  }
  uint64_t v9 = (char *)&__CFUniCharBMPPrecompDestinationTable + 4 * v8;
  if (*(unsigned __int16 *)v9 <= (unsigned __int16)a1)
  {
    uint64_t v10 = (unsigned __int16 *)&v9[4 * HIWORD(v7) - 4];
    if (*v10 >= (unsigned __int16)a1)
    {
      do
      {
        uint64_t v11 = ((char *)v10 - v9) >> 3;
        uint64_t v12 = (unsigned __int16 *)&v9[4 * v11];
        unsigned int v13 = *v12;
        if (v13 <= (unsigned __int16)a1)
        {
          if (v13 >= (unsigned __int16)a1)
          {
            uint64_t result = *(unsigned __int16 *)&v9[4 * v11 + 2];
            goto LABEL_30;
          }
          uint64_t v9 = (char *)(v12 + 2);
        }
        else
        {
          uint64_t v10 = v12 - 2;
        }
      }
      while (v9 <= (char *)v10);
    }
  }
  return 65533;
}

uint64_t CFUniCharPrecompose(unsigned __int16 *a1, uint64_t a2, void *a3, char *a4, uint64_t a5, void *a6)
{
  int v6 = a6;
  unsigned int v7 = a3;
  if (a2 < 1)
  {
    uint64_t v28 = 0;
    uint64_t v13 = a2;
    if (a3) {
LABEL_103:
    }
      *unsigned int v7 = a2 - v13;
    goto LABEL_104;
  }
  unsigned int v9 = 0;
  uint64_t v49 = a4;
  uint64_t v50 = 0;
  unsigned int v10 = 0;
  char v47 = 1;
  int v11 = 65533;
  uint64_t v12 = a4;
  uint64_t v13 = a2;
  while (1)
  {
    while (1)
    {
      unsigned int v14 = *a1;
      if (v13 != 1 && (v14 & 0xFC00) == 0xD800) {
        break;
      }
      --v13;
      ++a1;
      if (v10) {
        goto LABEL_16;
      }
LABEL_32:
      int v22 = v14 << 24;
      BOOL v25 = v14 - 4352 <= 0xFE && v13 != 0 && v22 >= -16777215 && v22 <= 335544319;
      if (v25 && (unsigned int v30 = *a1 - 4449, v30 <= 0x15))
      {
        __int16 v31 = a1 + 1;
        if ((unint64_t)v13 < 2)
        {
          uint64_t v13 = 0;
          __int16 v33 = 0;
        }
        else
        {
          int v32 = *v31 - 4519;
          if ((v32 << 16) <= 0x1C0000) {
            v13 -= 2;
          }
          else {
            --v13;
          }
          if ((v32 << 16) > 0x1C0000)
          {
            __int16 v33 = 0;
          }
          else
          {
            __int16 v31 = a1 + 2;
            __int16 v33 = v32;
          }
        }
        unsigned int v26 = 28 * ((__int16)v30 + 21 * (char)v14) + v33 + 44032;
        a1 = v31;
      }
      else
      {
        unsigned int v26 = v14;
      }
      if (v11 == 65533)
      {
        uint64_t v27 = v50;
      }
      else if (v47)
      {
        if (v10 < 0x10000)
        {
          uint64_t v27 = v50;
        }
        else
        {
          uint64_t v27 = v50 - 1;
          memmove(v49 + 2, v49 + 4, v12 - (v49 + 4));
        }
        *(_WORD *)uint64_t v49 = v11;
      }
      else
      {
        if (HIWORD(v10))
        {
          uint64_t v27 = v50;
        }
        else
        {
          if (v50 >= a5)
          {
            int v21 = v11;
            ++v50;
            unsigned int v14 = v26;
LABEL_90:
            unsigned int v7 = a3;
            int v6 = a6;
            goto LABEL_91;
          }
          uint64_t v34 = v12 - v49 - 2;
          if (v34 >= 1)
          {
            unint64_t v35 = (unint64_t)v34 >> 1;
            do
            {
              *(_WORD *)&v49[2 * v35 + 2] = *(_WORD *)&v49[2 * v35];
              unint64_t v36 = v35-- + 1;
            }
            while (v36 > 2);
          }
          uint64_t v27 = v50 + 1;
        }
        *(_WORD *)uint64_t v49 = ((v11 + 67043328) >> 10) - 10240;
        *((_WORD *)v49 + 1) = v11 & 0x3FF | 0xDC00;
      }
      unsigned int v14 = v26 - 0x10000;
      if (v26 < 0x10000)
      {
        uint64_t v28 = v27 + 1;
        if (v27 >= a5)
        {
LABEL_84:
          unsigned int v7 = a3;
          int v6 = a6;
          if (a3) {
            goto LABEL_103;
          }
          goto LABEL_104;
        }
        unsigned int v9 = 0;
        *(_WORD *)uint64_t v12 = v26;
        int v29 = v12 + 2;
        char v47 = 1;
        int v11 = 65533;
        unsigned int v14 = v26;
      }
      else
      {
        uint64_t v28 = v27 + 2;
        if (v27 + 2 > a5) {
          goto LABEL_84;
        }
        unsigned int v9 = 0;
        char v47 = 0;
        *(_WORD *)uint64_t v12 = (v14 >> 10) - 10240;
        int v29 = v12 + 4;
        *((_WORD *)v12 + 1) = v26 & 0x3FF | 0xDC00;
        int v11 = 65533;
      }
      unsigned int v10 = v26;
      uint64_t v49 = v12;
LABEL_78:
      uint64_t v50 = v28;
      uint64_t v12 = v29;
      if (v13 <= 0) {
        goto LABEL_87;
      }
    }
    int v15 = a1[1];
    int v16 = v15 & 0xFC00;
    int v17 = v15 + (v14 << 10) - 56613888;
    if (v16 == 56320) {
      v13 -= 2;
    }
    else {
      --v13;
    }
    if (v16 == 56320) {
      a1 += 2;
    }
    else {
      ++a1;
    }
    if (v16 == 56320) {
      unsigned int v14 = v17;
    }
    if (!v10) {
      goto LABEL_32;
    }
LABEL_16:
    uint64_t BitmapPtrForPlane = (unsigned __int8 *)&__CFUniCharNonBaseCharacterSetBitmapPlane0_0;
    if (v14 >= 0x10000)
    {
      uint64_t BitmapPtrForPlane = (unsigned __int8 *)CFUniCharGetBitmapPtrForPlane(8u, BYTE2(v14));
      if (!BitmapPtrForPlane) {
        goto LABEL_32;
      }
    }
    if (((BitmapPtrForPlane[(unsigned __int16)v14 >> 3] >> (v14 & 7)) & 1) == 0) {
      goto LABEL_32;
    }
    if (v11 != 65533) {
      unsigned int v10 = v11;
    }
    if (v14 < 0x10000)
    {
      if (__CFUniCharCombiningPriorityTablePlane0_1[(unint64_t)v14 >> 8])
      {
        unsigned __int8 UnicodeProperty = __CFUniCharCombiningPriorityTablePlane0_1[256
                                                                  * __CFUniCharCombiningPriorityTablePlane0_1[(unint64_t)v14 >> 8]
                                                                  + v14];
        if (!v9) {
          goto LABEL_29;
        }
      }
      else
      {
        unsigned __int8 UnicodeProperty = 0;
        if (!v9) {
          goto LABEL_29;
        }
      }
    }
    else
    {
      unsigned __int8 UnicodeProperty = CFUniCharGetUnicodeProperty(v14, 0);
      if (!v9) {
        goto LABEL_29;
      }
    }
    if (UnicodeProperty <= v9) {
      goto LABEL_49;
    }
LABEL_29:
    int v20 = CFUniCharPrecomposeCharacter(v10, v14);
    if (v20 == 65533) {
      break;
    }
    int v21 = v20;
    int v11 = v20;
    if (v13 < 1) {
      goto LABEL_90;
    }
  }
  unsigned int v9 = UnicodeProperty;
LABEL_49:
  if (v14 >= 0x10000)
  {
    uint64_t v28 = v50 + 2;
    if (v50 + 2 > a5) {
      goto LABEL_86;
    }
    *(_WORD *)uint64_t v12 = ((v14 - 0x10000) >> 10) - 10240;
    int v29 = v12 + 4;
    *((_WORD *)v12 + 1) = v14 & 0x3FF | 0xDC00;
    v14 -= 0x10000;
    goto LABEL_78;
  }
  uint64_t v28 = v50 + 1;
  if (v50 < a5)
  {
    *(_WORD *)uint64_t v12 = v14;
    int v29 = v12 + 2;
    goto LABEL_78;
  }
LABEL_86:
  int v29 = v12;
LABEL_87:
  uint64_t v12 = v29;
  int v21 = v11;
  uint64_t v50 = v28;
  unsigned int v7 = a3;
  int v6 = a6;
  if (v11 == 65533)
  {
LABEL_102:
    if (!v7) {
      goto LABEL_104;
    }
    goto LABEL_103;
  }
LABEL_91:
  if (v14 < 0x10000)
  {
    if (v10 < 0x10000)
    {
      uint64_t v41 = v50;
    }
    else
    {
      uint64_t v41 = v50 - 1;
      memmove(v49 + 2, v49 + 4, v12 - (v49 + 4));
    }
    *(_WORD *)uint64_t v49 = v21;
    uint64_t v28 = v41;
    if (v7) {
      goto LABEL_103;
    }
LABEL_104:
    uint64_t v42 = 1;
    uint64_t result = 1;
    if (v6)
    {
LABEL_105:
      *int v6 = v28;
      return v42;
    }
    return result;
  }
  if (HIWORD(v10))
  {
    uint64_t v40 = v50;
LABEL_101:
    *(_WORD *)uint64_t v49 = ((v21 + 67043328) >> 10) - 10240;
    *((_WORD *)v49 + 1) = v21 & 0x3FF | 0xDC00;
    uint64_t v28 = v40;
    goto LABEL_102;
  }
  uint64_t v28 = v50 + 1;
  if (v50 < a5)
  {
    uint64_t v37 = v12 - v49 - 2;
    if (v37 >= 1)
    {
      unint64_t v38 = (unint64_t)v37 >> 1;
      do
      {
        *(_WORD *)&v49[2 * v38 + 2] = *(_WORD *)&v49[2 * v38];
        unint64_t v39 = v38-- + 1;
      }
      while (v39 > 2);
    }
    uint64_t v40 = v50 + 1;
    goto LABEL_101;
  }
  if (v7) {
    *unsigned int v7 = a2 - v13;
  }
  uint64_t v42 = 0;
  uint64_t result = 0;
  if (v6) {
    goto LABEL_105;
  }
  return result;
}

void __CFUserNotificationDeallocate(uint64_t a1)
{
  uint64_t v2 = (__CFMachPort *)atomic_exchange((atomic_ullong *volatile)(a1 + 64), 0);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    CFRelease(v2);
  }
  else
  {
    mach_port_name_t v3 = *(_DWORD *)(a1 + 16);
    if (v3) {
      mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, v3, 1u, -1);
    }
  }
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
  BOOL v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    CFRelease(v5);
  }
}

__CFString *__CFUserNotificationCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<CFUserNotification %p>", a1);
  return Mutable;
}

CFTypeID CFUserNotificationGetTypeID(void)
{
  return 54;
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  uint64_t v29 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pid_t v10 = getpid();
  int v11 = (unsigned __int16)_getNextToken_tokenCounter++;
  if (dictionary) {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(dictionary, @"SessionID");
  }
  else {
    CFStringRef Value = 0;
  }
  mach_port_name_t name = 0;
  if (!allocator)
  {
    CFAllocatorRef v13 = (const __CFAllocator *)_CFGetTSD(1u);
    if (v13) {
      CFAllocatorRef allocator = v13;
    }
    else {
      CFAllocatorRef allocator = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }
  int v14 = v11 | (v10 << 16);
  options.reserved[1] = 0;
  *(_OWORD *)&options.flags = xmmword_182EC7BA8;
  SInt32 v15 = mach_port_construct(*(_DWORD *)off_1ECE0A6C8, &options, 0, &name);
  if (v15) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = name == 0;
  }
  if (!v16) {
    SInt32 v15 = _CFUserNotificationSendRequest(allocator, Value, name, v14, flags, dictionary, timeout);
  }
  if (v15)
  {
    if (dictionary)
    {
      __int16 v17 = (unsigned __int16)CFDictionaryGetValue(dictionary, @"AlertHeader");
      CFDictionaryGetValue(dictionary, @"AlertMessage");
      CFLog(3, @"%@:  %@", v18, v19, v20, v21, v22, v23, v17);
    }
  }
  else
  {
    uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)allocator, 0x36uLL, 64, 0);
    if (Instance)
    {
      BOOL v25 = (__CFUserNotification *)Instance;
      *(_DWORD *)(Instance + 16) = name;
      *(_DWORD *)(Instance + 2_CFSetTSD(0xFu, 0, 0) = v14;
      *(CFTimeInterval *)(Instance + 24) = timeout;
      *(void *)(Instance + 32) = flags;
      if (Value)
      {
        SInt32 v15 = 0;
        *(void *)(Instance + 48) = CFStringCreateCopy(allocator, Value);
        if (!error) {
          return v25;
        }
      }
      else
      {
        SInt32 v15 = 0;
        if (!error) {
          return v25;
        }
      }
      goto LABEL_28;
    }
    SInt32 v15 = 49164;
  }
  if (name) {
    mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, name, 1u, -1);
  }
  BOOL v25 = 0;
  if (error) {
LABEL_28:
  }
    *error = v15;
  return v25;
}

uint64_t _CFUserNotificationSendRequest(const __CFAllocator *a1, const __CFString *a2, int a3, int a4, int a5, const __CFDictionary *a6, double a7)
{
  uint64_t v53 = *(void *)off_1ECE0A5B0;
  int v48 = 0;
  mach_port_t special_port = 0;
  if (a7 >= 2147483650.0 || a7 <= 0.0) {
    int v14 = 0;
  }
  else {
    int v14 = (int)a7;
  }
  CFIndex usedBufLen = 0;
  __strlcpy_chk();
  if (a2)
  {
    v54.CFIndex length = CFStringGetLength(a2);
    v54.CFIndex location = 0;
    CFStringGetBytes(a2, v54, 0x8000100u, 0, 0, buffer, 24, &usedBufLen);
    char v52 = 0;
    __strlcat_chk();
    __strlcat_chk();
  }
  uint64_t v15 = task_get_special_port(*(_DWORD *)off_1ECE0A6C8, 4, &special_port);
  if (v15) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = special_port == 0;
  }
  if (!v16)
  {
    uint64_t v15 = bootstrap_look_up2();
    if (!v15)
    {
      if (v48)
      {
        __int16 v17 = (const void *)_CFProcessNameString();
        int valuePtr = v14;
        *(_DWORD *)buffer = a4;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFNumberRef v19 = CFNumberCreate(a1, kCFNumberSInt32Type, buffer);
        CFNumberRef v20 = CFNumberCreate(a1, kCFNumberSInt32Type, &valuePtr);
        if (a6) {
          CFDictionaryApplyFunction(a6, (CFDictionaryApplierFunction)_CFUserNotificationAddToDictionary, Mutable);
        }
        if (v17) {
          CFDictionaryAddValue(Mutable, @"AlertSource", v17);
        }
        if (v19)
        {
          CFDictionaryAddValue(Mutable, @"Token", v19);
          CFRelease(v19);
        }
        if (v20)
        {
          CFDictionaryAddValue(Mutable, @"Timeout", v20);
          CFRelease(v20);
        }
        CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(Mutable, @"IconURL");
        if (Value)
        {
          CFURLRef v22 = Value;
          CFTypeID v23 = CFGetTypeID(Value);
          if (v23 == CFURLGetTypeID())
          {
            CFURLRef v24 = CFURLCopyAbsoluteURL(v22);
            CFDictionaryRemoveValue(Mutable, @"IconURL");
            CFStringRef v25 = CFURLCopyFileSystemPath(v24, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"IconPath", v25);
            CFRelease(v24);
            CFRelease(v25);
          }
        }
        CFURLRef v26 = (const __CFURL *)CFDictionaryGetValue(Mutable, @"SoundURL");
        if (v26)
        {
          CFURLRef v27 = v26;
          CFTypeID v28 = CFGetTypeID(v26);
          if (v28 == CFURLGetTypeID())
          {
            CFURLRef v29 = CFURLCopyAbsoluteURL(v27);
            CFDictionaryRemoveValue(Mutable, @"SoundURL");
            CFStringRef v30 = CFURLCopyFileSystemPath(v29, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"SoundPath", v30);
            CFRelease(v29);
            CFRelease(v30);
          }
        }
        CFURLRef v31 = (const __CFURL *)CFDictionaryGetValue(Mutable, @"LocalizationURL");
        if (v31)
        {
          CFURLRef v32 = v31;
          CFTypeID v33 = CFGetTypeID(v31);
          if (v33 == CFURLGetTypeID())
          {
            CFURLRef v34 = CFURLCopyAbsoluteURL(v32);
            CFDictionaryRemoveValue(Mutable, @"LocalizationURL");
            CFStringRef v35 = CFURLCopyFileSystemPath(v34, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"LocalizationPath", v35);
            CFRelease(v34);
            CFRelease(v35);
          }
        }
        CFURLRef v36 = (const __CFURL *)CFDictionaryGetValue(Mutable, @"HelpBundleURL");
        if (v36)
        {
          CFURLRef v37 = v36;
          CFTypeID v38 = CFGetTypeID(v36);
          if (v38 == CFURLGetTypeID())
          {
            CFURLRef v39 = CFURLCopyAbsoluteURL(v37);
            CFDictionaryRemoveValue(Mutable, @"HelpBundleURL");
            CFStringRef v40 = CFURLCopyFileSystemPath(v39, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"HelpBundlePath", v40);
            CFRelease(v39);
            CFRelease(v40);
          }
        }
        if (Mutable)
        {
          CFDataRef Data = CFPropertyListCreateData(a1, Mutable, kCFPropertyListXMLFormat_v1_0, 0, 0);
          if (Data)
          {
            CFDataRef v42 = Data;
            CFIndex usedBufLen = ((CFDataGetLength(Data) + 3) & 0xFFFFFFFFFFFFFFFCLL) + 28;
            uint64_t Typed = (int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, usedBufLen, 2858208393, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            if (Typed)
            {
              bzero(Typed, usedBufLen);
              if (a3) {
                int v44 = 5395;
              }
              else {
                int v44 = 19;
              }
              *uint64_t Typed = v44;
              int v45 = v48;
              Typed[1] = usedBufLen;
              Typed[2] = v45;
              Typed[3] = a3;
              Typed[5] = a5;
              Typed[6] = 0;
              v55.CFIndex length = CFDataGetLength(v42);
              v55.CFIndex location = 0;
              CFDataGetBytes(v42, v55, (UInt8 *)Typed + 28);
              uint64_t v15 = mach_msg((mach_msg_header_t *)Typed, 17, usedBufLen, 0, 0, 0x64u, 0);
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
            }
            else
            {
              uint64_t v15 = 49164;
            }
            CFRelease(v42);
          }
          else
          {
            uint64_t v15 = 49164;
          }
          CFRelease(Mutable);
        }
        else
        {
          return 49164;
        }
      }
    }
  }
  return v15;
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  mach_msg_return_t v11;
  uint64_t v12;
  CFDataRef v13;
  CFDataRef v14;
  __CFMachPort *v15;

  if (userNotification)
  {
    __CFCheckCFInfoPACSignature((uint64_t)userNotification);
    unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v6 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v6);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (timeout <= 0.0 || timeout * 1000.0 >= 2147483650.0)
  {
    unsigned int v7 = 0;
    if (!userNotification) {
      return 0;
    }
  }
  else
  {
    unsigned int v7 = (timeout * 1000.0);
    if (!userNotification) {
      return 0;
    }
  }
  if (!*((_DWORD *)userNotification + 4)) {
    return 0;
  }
  uint64_t Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 0x4000, 4098098314, 0);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  if (!Typed) {
    return 49164;
  }
  bzero((void *)Typed, 0x4000uLL);
  *(_DWORD *)(Typed + 4) = 0x4000;
  if (v7)
  {
    mach_msg_option_t v9 = 258;
    mach_msg_timeout_t v10 = v7;
  }
  else
  {
    mach_msg_option_t v9 = 2;
    mach_msg_timeout_t v10 = 0;
  }
  int v11 = mach_msg((mach_msg_header_t *)Typed, v9, 0, 0x4000u, *((_DWORD *)userNotification + 4), v10, 0);
  if (!v11)
  {
    if (responseFlags) {
      *responseFlags = *(int *)(Typed + 20);
    }
    uint64_t v12 = *(unsigned int *)(Typed + 4);
    if (v12 >= 0x1D)
    {
      CFAllocatorRef v13 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)(Typed + 28), v12 - 28);
      if (v13)
      {
        int v14 = v13;
        *((void *)userNotification + 7) = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, 0, 0, 0);
        CFRelease(v14);
      }
    }
    uint64_t v15 = (__CFMachPort *)atomic_exchange((atomic_ullong *volatile)userNotification + 8, 0);
    if (v15)
    {
      CFMachPortInvalidate(v15);
      CFRelease(v15);
    }
    mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, *((_DWORD *)userNotification + 4), 1u, -1);
    *((_DWORD *)userNotification + 4) = 0;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (void *)Typed);
  return v11;
}

CFStringRef CFUserNotificationGetResponseValue(CFUserNotificationRef userNotification, CFStringRef key, CFIndex idx)
{
  if (userNotification)
  {
    __CFCheckCFInfoPACSignature((uint64_t)userNotification);
    unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v6 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v6);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!userNotification) {
    return 0;
  }
  CFStringRef result = (CFStringRef)*((void *)userNotification + 7);
  if (result)
  {
    CFStringRef result = (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, key);
    if (result)
    {
      CFStringRef v8 = result;
      CFTypeID v9 = CFGetTypeID(result);
      if (v9 == CFStringGetTypeID())
      {
        if (idx) {
          return 0;
        }
        else {
          return v8;
        }
      }
      CFTypeID v10 = CFGetTypeID(v8);
      CFTypeID TypeID = CFArrayGetTypeID();
      CFStringRef result = 0;
      if ((idx & 0x8000000000000000) == 0 && v10 == TypeID)
      {
        if (CFArrayGetCount((CFArrayRef)v8) > idx)
        {
          return (CFStringRef)CFArrayGetValueAtIndex((CFArrayRef)v8, idx);
        }
        return 0;
      }
    }
  }
  return result;
}

CFDictionaryRef CFUserNotificationGetResponseDictionary(CFUserNotificationRef userNotification)
{
  if (userNotification)
  {
    __CFCheckCFInfoPACSignature((uint64_t)userNotification);
    unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v2 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v2);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (userNotification) {
    return (CFDictionaryRef)*((void *)userNotification + 7);
  }
  else {
    return 0;
  }
}

SInt32 CFUserNotificationUpdate(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags flags, CFDictionaryRef dictionary)
{
  int v5 = flags;
  if (userNotification)
  {
    __CFCheckCFInfoPACSignature((uint64_t)userNotification);
    unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v8 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v8);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!userNotification || !*((_DWORD *)userNotification + 4)) {
    return 0;
  }
  CFAllocatorRef v9 = CFGetAllocator(userNotification);
  CFStringRef v10 = (const __CFString *)*((void *)userNotification + 6);
  int v11 = *((_DWORD *)userNotification + 5);

  return _CFUserNotificationSendRequest(v9, v10, 0, v11, v5 | 0x10u, dictionary, timeout);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  if (userNotification)
  {
    __CFCheckCFInfoPACSignature((uint64_t)userNotification);
    unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v2 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v2);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!userNotification || !*((_DWORD *)userNotification + 4)) {
    return 0;
  }
  CFAllocatorRef v3 = CFGetAllocator(userNotification);
  CFStringRef v4 = (const __CFString *)*((void *)userNotification + 6);
  int v5 = *((_DWORD *)userNotification + 5);

  return _CFUserNotificationSendRequest(v3, v4, 0, v5, 8, 0, 0.0);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (userNotification)
  {
    __CFCheckCFInfoPACSignature((uint64_t)userNotification);
    unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v8 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v8);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (userNotification && callout)
  {
    if (!atomic_load((unint64_t *)userNotification + 8))
    {
      if (*((_DWORD *)userNotification + 4))
      {
        v14.version = 0;
        memset(&v14.retain, 0, 24);
        v14.unint64_t info = userNotification;
        CFAllocatorRef v10 = CFGetAllocator(userNotification);
        atomic_store((unint64_t)CFMachPortCreateWithPort(v10, *((_DWORD *)userNotification + 4), (CFMachPortCallBack)_CFUserNotificationMachPortCallBack, &v14, 0), (unint64_t *)userNotification + 8);
      }
    }
  }
  else if (!userNotification)
  {
    return 0;
  }
  if (atomic_load((unint64_t *)userNotification + 8))
  {
    uint64_t v12 = (__CFMachPort *)atomic_load((unint64_t *)userNotification + 8);
    CFRunLoopSourceRef result = CFMachPortCreateRunLoopSource(allocator, v12, order);
    *((void *)userNotification + 9) = callout;
    return result;
  }
  return 0;
}

uint64_t _CFUserNotificationMachPortCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(int *)(a2 + 20);
  uint64_t v6 = *(unsigned int *)(a2 + 4);
  if (v6 >= 0x1D)
  {
    CFDataRef v7 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)(a2 + 28), v6 - 28);
    if (v7)
    {
      CFDataRef v8 = v7;
      *(void *)(a4 + 56) = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, 0, 0, 0);
      CFRelease(v8);
    }
  }
  CFAllocatorRef v9 = (__CFMachPort *)atomic_exchange((atomic_ullong *volatile)(a4 + 64), 0);
  if (v9)
  {
    CFMachPortInvalidate(v9);
    CFRelease(v9);
  }
  mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, *(_DWORD *)(a4 + 16), 1u, -1);
  *(_DWORD *)(a4 + 16) = 0;
  CFAllocatorRef v10 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 72);

  return v10(a4, v5);
}

SInt32 CFUserNotificationDisplayNotice(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle)
{
  int v14 = flags;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  __int16 v17 = Mutable;
  if (iconURL) {
    CFDictionaryAddValue(Mutable, @"IconURL", iconURL);
  }
  if (soundURL) {
    CFDictionaryAddValue(v17, @"SoundURL", soundURL);
  }
  if (localizationURL) {
    CFDictionaryAddValue(v17, @"LocalizationURL", localizationURL);
  }
  if (alertHeader) {
    CFDictionaryAddValue(v17, @"AlertHeader", alertHeader);
  }
  if (alertMessage) {
    CFDictionaryAddValue(v17, @"AlertMessage", alertMessage);
  }
  if (defaultButtonTitle) {
    CFDictionaryAddValue(v17, @"DefaultButtonTitle", defaultButtonTitle);
  }
  uint64_t v18 = _CFGetTSD(1u);
  if (v18) {
    CFAllocatorRef v19 = (const __CFAllocator *)v18;
  }
  else {
    CFAllocatorRef v19 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  pid_t v20 = getpid();
  int v21 = (unsigned __int16)_getNextToken_tokenCounter++;
  SInt32 v28 = _CFUserNotificationSendRequest(v19, 0, 0, v21 | (v20 << 16), v14, v17, timeout);
  if (v28) {
    CFLog(3, @"%@:  %@", v22, v23, v24, v25, v26, v27, (__int16)alertHeader);
  }
  CFRelease(v17);
  return v28;
}

uint64_t _CFUserNotificationSetWarningThread(uint64_t result)
{
  __CFUserNotificationWarningThread = result;
  return result;
}

SInt32 CFUserNotificationDisplayAlert(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags)
{
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  SInt32 error = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v21 = Mutable;
  if (iconURL) {
    CFDictionaryAddValue(Mutable, @"IconURL", iconURL);
  }
  if (soundURL) {
    CFDictionaryAddValue(v21, @"SoundURL", soundURL);
  }
  if (localizationURL) {
    CFDictionaryAddValue(v21, @"LocalizationURL", localizationURL);
  }
  if (alertHeader) {
    CFDictionaryAddValue(v21, @"AlertHeader", alertHeader);
  }
  if (alertMessage) {
    CFDictionaryAddValue(v21, @"AlertMessage", alertMessage);
  }
  if (defaultButtonTitle) {
    CFDictionaryAddValue(v21, @"DefaultButtonTitle", defaultButtonTitle);
  }
  if (alternateButtonTitle) {
    CFDictionaryAddValue(v21, @"AlternateButtonTitle", alternateButtonTitle);
  }
  if (otherButtonTitle) {
    CFDictionaryAddValue(v21, @"OtherButtonTitle", otherButtonTitle);
  }
  CFUserNotificationRef v22 = CFUserNotificationCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, timeout, flags, &error, v21);
  if (v22)
  {
    uint64_t v23 = v22;
    uint64_t v24 = pthread_self();
    if (pthread_equal(v24, (pthread_t)__CFUserNotificationWarningThread)) {
      CFLog(3, @"%@:  %@", v25, v26, v27, v28, v29, v30, (__int16)@"CFUserNotificationDisplayAlert");
    }
    SInt32 error = CFUserNotificationReceiveResponse(v23, timeout, responseFlags);
    if (error == 268451843)
    {
      SInt32 error = CFUserNotificationCancel(v23);
      if (responseFlags) {
        *responseFlags = 3;
      }
    }
    CFRelease(v23);
  }
  CFRelease(v21);
  return error;
}

void _CFUserNotificationAddToDictionary(const void *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    CFDictionarySetValue(a3, a1, a2);
  }
}

uint64_t _CFMethodSignatureROMLog()
{
  if (_CFMethodSignatureROMLog_onceToken != -1) {
    dispatch_once(&_CFMethodSignatureROMLog_onceToken, &__block_literal_global_5);
  }
  return _CFMethodSignatureROMLog_logger;
}

uint64_t _CFRuntimeIssuesLog()
{
  if (_CFRuntimeIssuesLog_onceToken != -1) {
    dispatch_once(&_CFRuntimeIssuesLog_onceToken, &__block_literal_global_9);
  }
  return _CFRuntimeIssuesLog_logger;
}

uint64_t _CFFoundationRuntimeIssuesLog()
{
  if (_CFFoundationRuntimeIssuesLog_onceToken != -1) {
    dispatch_once(&_CFFoundationRuntimeIssuesLog_onceToken, &__block_literal_global_14);
  }
  return _CFFoundationRuntimeIssuesLog_logger;
}

uint64_t CFBSearch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, unint64_t, uint64_t), uint64_t a6)
{
  uint64_t v8 = a3;
  if (a4 >= 1)
  {
    unint64_t v11 = a4;
    uint64_t v8 = a3;
    while (1)
    {
      unint64_t v13 = v11 >> 1;
      uint64_t v14 = a5(a1, v8 + (v11 >> 1) * a2, a6);
      if (!v14) {
        break;
      }
      if (v14 < 0)
      {
        uint64_t v15 = 0;
      }
      else
      {
        v8 += (v11 >> 1) * a2 + a2;
        uint64_t v15 = (v11 & 1) - 1;
      }
      unint64_t v11 = v13 + v15;
      if (((uint64_t)(v13 + v15) < 0) ^ __OFADD__(v13, v15) | (v13 + v15 == 0)) {
        return (v8 - a3) / a2;
      }
    }
    v8 += (v11 >> 1) * a2;
  }
  return (v8 - a3) / a2;
}

mach_vm_address_t __CFFindPointer(uint64_t a1, mach_vm_address_t a2)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  vm_map_read_t v4 = *(_DWORD *)off_1ECE0A6C8;
  mach_vm_size_t size = 0;
  mach_vm_address_t address = a2;
  int v14 = 0;
  *(_OWORD *)unint64_t info = 0u;
  for (long long i = 0u; ; long long i = 0u)
  {
    object_mach_port_name_t name = 0;
    mach_msg_type_number_t infoCnt = 9;
    if (mach_vm_region(v4, &address, &size, 9, info, &infoCnt, &object_name)) {
      return 0;
    }
    mach_vm_address_t result = address;
    if ((info[0] & 2) == 0)
    {
      mach_vm_address_t v6 = address + size;
      goto LABEL_10;
    }
    mach_vm_address_t v6 = size + address;
    if (address < size + address) {
      break;
    }
LABEL_10:
    mach_vm_size_t size = 0;
    mach_vm_address_t address = v6;
    int v14 = 0;
    *(_OWORD *)unint64_t info = 0u;
  }
  CFDataRef v7 = (void *)address;
  while ((unint64_t)v7 < a2 || *v7 != a1)
  {
    ++v7;
    result += 8;
    if ((unint64_t)v7 >= v6) {
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t __CFDumpAllPointerLocations(uint64_t a1)
{
  unint64_t v2 = 0;
  do
  {
    unint64_t v2 = (const void *)__CFFindPointer(a1, (mach_vm_address_t)v2 + 8);
    uint64_t result = printf("%p\n", v2);
  }
  while (v2);
  return result;
}

double _CFOperatingSystemVersionGetCurrent@<D0>(uint64_t a1@<X8>)
{
  if (_CFOperatingSystemVersionGetCurrent_onceToken != -1) {
    dispatch_once(&_CFOperatingSystemVersionGetCurrent_onceToken, &__block_literal_global_44);
  }
  double result = *(double *)&_CFOperatingSystemVersionGetCurrent_version;
  *(_OWORD *)a1 = _CFOperatingSystemVersionGetCurrent_version;
  *(void *)(a1 + 16) = qword_1EB1DD4D8;
  return result;
}

void *__CFLookupCFNetworkFunction(char *__symbol)
{
  if (__CFLookupCFNetworkFunction_onceToken != -1) {
    dispatch_once(&__CFLookupCFNetworkFunction_onceToken, &__block_literal_global_76);
  }
  double result = (void *)__CFLookupCFNetworkFunction_image;
  if (__CFLookupCFNetworkFunction_image)
  {
    return dlsym(result, __symbol);
  }
  return result;
}

uint64_t __CFProcessorCount()
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  int v4 = 0;
  *(void *)uint64_t v5 = 0x300000006;
  size_t v3 = 4;
  int v0 = sysctl(v5, 2u, &v4, &v3, 0, 0);
  int v1 = v4;
  if (v0) {
    return 0;
  }
  return v1;
}

uint64_t __CFMemorySize()
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = 0;
  *(void *)size_t v3 = 0x1800000006;
  size_t v1 = 8;
  if (sysctl(v3, 2u, &v2, &v1, 0, 0)) {
    return 0;
  }
  else {
    return v2;
  }
}

uint64_t _CFGetEGID()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  unsigned int v1 = 0;
  __CFGetUGIDs(0, &v1);
  return v1;
}

unsigned char *_CFPrintForDebugger(const void *a1)
{
  maxBufLen[1] = *(void *)off_1ECE0A5B0;
  maxBufLen[0] = 0;
  free((void *)_CFPrintForDebugger_result);
  _CFPrintForDebugger_double result = 0;
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == CFStringGetTypeID())
    {
      CFStringRef v3 = (const __CFString *)__CFCopyFormattingDescription((unint64_t)a1, 0);
      if (v3) {
        goto LABEL_7;
      }
    }
    CFStringRef v4 = CFCopyDescription(a1);
  }
  else
  {
    CFStringRef v4 = (const __CFString *)CFRetain(@"(null)");
  }
  CFStringRef v3 = v4;
  if (v4)
  {
LABEL_7:
    v7.CFIndex length = CFStringGetLength(v3);
    v7.CFIndex location = 0;
    CFStringGetBytes(v3, v7, 0x8000100u, 0, 0, 0, 0, maxBufLen);
    _CFPrintForDebugger_double result = (uint64_t)malloc_type_malloc(maxBufLen[0] + 2, 0x9A99521CuLL);
    v8.CFIndex length = CFStringGetLength(v3);
    v8.CFIndex location = 0;
    CFStringGetBytes(v3, v8, 0x8000100u, 0, 0, (UInt8 *)_CFPrintForDebugger_result, maxBufLen[0], maxBufLen);
    *(unsigned char *)(_CFPrintForDebugger_result + maxBufLen[0]) = 0;
    CFRelease(v3);
    return (unsigned char *)_CFPrintForDebugger_result;
  }
  double result = malloc_type_malloc(2uLL, 0x9A99521CuLL);
  _CFPrintForDebugger_double result = (uint64_t)result;
  *double result = 0;
  return result;
}

void CFShow(CFTypeRef obj)
{
}

void _CFShowToFile(FILE *a1, CFTypeRef cf)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  if (!cf)
  {
    CFStringRef v6 = (const __CFString *)CFRetain(@"(null)");
    goto LABEL_6;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()
    || (CFStringRef v5 = (const __CFString *)__CFCopyFormattingDescription((unint64_t)cf, 0)) == 0)
  {
    CFStringRef v6 = CFCopyDescription(cf);
LABEL_6:
    CFStringRef v5 = v6;
  }
  CFIndex Length = CFStringGetLength(v5);
  CFStringRef theString = v5;
  uint64_t v36 = 0;
  CFIndex v37 = Length;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(v5);
  CStringPtr = 0;
  CFURLRef v34 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v5, 0x600u);
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v26 = 0u;
  int64_t v38 = 0;
  int64_t v39 = 0;
  CFStringRef v35 = CStringPtr;
  if (Length < 1) {
    goto LABEL_33;
  }
  CFStringRef cfa = v5;
  uint64_t v10 = 0;
  int64_t v11 = 0;
  BOOL v12 = 0;
  uint64_t v13 = 64;
  do
  {
    if ((unint64_t)v11 >= 4) {
      uint64_t v14 = 4;
    }
    else {
      uint64_t v14 = v11;
    }
    if (v34)
    {
      UniChar v15 = v34[v11 + v36];
    }
    else if (v35)
    {
      UniChar v15 = v35[v36 + v11];
    }
    else
    {
      int64_t v16 = v38;
      if (v39 <= v11 || v38 > v11)
      {
        uint64_t v18 = -v14;
        uint64_t v19 = v14 + v10;
        uint64_t v20 = v13 - v14;
        int64_t v21 = v11 + v18;
        CFIndex v22 = v21 + 64;
        if (v21 + 64 >= v37) {
          CFIndex v22 = v37;
        }
        int64_t v38 = v21;
        int64_t v39 = v22;
        if (v37 < v20) {
          uint64_t v20 = v37;
        }
        v41.CFIndex length = v20 + v19;
        v41.CFIndex location = v21 + v36;
        CFStringGetCharacters(theString, v41, buffer);
        int64_t v16 = v38;
      }
      UniChar v15 = buffer[v11 - v16];
    }
    int v23 = v15;
    if (v15 > 0x7Fu)
    {
      fprintf_l(a1, 0, "\\u%04x", v15);
    }
    else
    {
      fprintf_l(a1, 0, "%c", v15);
      BOOL v12 = v23 == 10;
    }
    ++v11;
    --v10;
    ++v13;
  }
  while (Length != v11);
  CFStringRef v5 = cfa;
  if (!v12)
  {
LABEL_33:
    fprintf_l(a1, 0, "\n");
    fflush(a1);
  }
  if (v5) {
    CFRelease(v5);
  }
}

unint64_t _CFLogvEx2(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 1);
}

unint64_t _CFLogvEx(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 *a6)
{
  return _CFLogvEx2Predicate(a1, a2, 0, a3, a4, a5, a6, 1);
}

void _CFLogSimple(int a1, char *__format, ...)
{
  va_start(va, __format);
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  int v3 = vsnprintf(__str, 0x400uLL, __format, va);
  if (v3 >= 1) {
    __CFLogCStringLegacy(a1, __str, v3, 0);
  }
}

void __CFLogCStringLegacy(int a1, const char *a2, uint64_t a3, int a4)
{
  __s[1] = *(char **)off_1ECE0A5B0;
  value = 0;
  __s[0] = 0;
  int64_t v11 = 0;
  BOOL v12 = 0;
  if (a4) {
    _populateBanner(__s, &value, &v11);
  }
  int v10 = 0;
  __CFGetUGIDs(&v10, 0);
  asprintf(&v12, "%d", v10);
  CFRange v7 = "com.apple.console";
  if (__CFBundleMainID && *(unsigned char *)__CFBundleMainID) {
    CFRange v7 = (const char *)__CFBundleMainID;
  }
  CFRange v8 = asl_open(0, v7, 2u);
  CFAllocatorRef v9 = asl_new(0);
  asl_set(v9, "CFLog Local Time", value);
  asl_set(v9, "CFLog Thread", v11);
  asl_set(v9, "ReadUID", v12);
  asl_set(v9, "Level", __CFLogCStringLegacy_levstr[a1]);
  asl_set(v9, "Message", a2);
  asl_send(v8, v9);
  MEMORY[0x185310CE0](v9);
  MEMORY[0x185310CD0](v8);
  if (also_do_stderr(1)) {
    _logToStderr(__s[0], (uint64_t)a2, a3);
  }
  if (v11) {
    free(v11);
  }
  if (value) {
    free(value);
  }
  if (__s[0]) {
    free(__s[0]);
  }
  if (v12) {
    free(v12);
  }
}

void _CFLogSimpleCString(int a1, const char *a2, uint64_t a3)
{
}

void CFLogTest(char a1, CFStringRef format, ...)
{
  va_start(va, format);
  *(void *)&v21[6] = *(void *)off_1ECE0A5B0;
  uint64_t v3 = CFLogTest_file;
  if (CFLogTest_file) {
    goto LABEL_14;
  }
  if ((a1 & 1) == 0)
  {
    CFTypeID v4 = CFCopySearchPathForDirectoriesInDomains(5, 1, 1);
    if (!v4) {
      goto LABEL_13;
    }
    CFArrayRef v5 = v4;
    if (CFArrayGetCount(v4) >= 1
      && (CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v5, 0),
          CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, (UInt8 *)buffer, 1026)))
    {
      uint64_t v7 = (uint64_t)buffer + strlen((const char *)buffer);
    }
    else
    {
      uint64_t v7 = 0;
    }
    CFRelease(v5);
    if (!v7) {
      goto LABEL_13;
    }
    goto LABEL_11;
  }
  uint64_t v7 = __stpcpy_chk();
  if (v7)
  {
LABEL_11:
    snprintf((char *)v7, (size_t)&v21[-v7], "/Logs");
    mkdir((const char *)buffer, 0x1FFu);
    CFRange v8 = (char *)(v7 + strlen((const char *)v7));
    CFAllocatorRef v9 = (const char *)*_CFGetProgname();
    pid_t v10 = getpid();
    snprintf(v8, v21 - v8, "/%s_%d.selftest.txt", v9, v10);
    CFLogTest_file = (uint64_t)fopen((const char *)buffer, "w");
    if (!CFLogTest_file)
    {
      CFLog(3, @"Couldn't write to self test log file %s", v11, v12, v13, v14, v15, v16, (__int16)buffer);
      CFLogTest_file = -1;
    }
  }
LABEL_13:
  uint64_t v3 = CFLogTest_file;
LABEL_14:
  if (v3 != -1)
  {
    va_copy(v19, va);
    CFStringRef v17 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
    v18.tv_sec = 0;
    *(void *)&v18.tv_usec = 0;
    memset(buffer, 0, 56);
    gettimeofday(&v18, 0);
    gmtime_r(&v18.tv_sec, buffer);
    fprintf_l((FILE *)CFLogTest_file, 0, "%04d-%02d-%02d %02d:%02d:%02d ", buffer[0].tm_year + 1900, buffer[0].tm_mon + 1, buffer[0].tm_mday, buffer[0].tm_hour, buffer[0].tm_min, buffer[0].tm_sec);
    _CFShowToFile((FILE *)CFLogTest_file, v17);
    CFRelease(v17);
  }
}

uint64_t _CFReadMappedFromFile(__CFString *a1, int a2, int a3, void *a4, off_t *a5, CFErrorRef *a6)
{
  uint64_t v29 = *(void *)off_1ECE0A5B0;
  if (!CFStringGetFileSystemRepresentation(a1, buffer, 1026))
  {
    if (!a6) {
      return 0;
    }
    CFStringRef v17 = @"NSCocoaErrorDomain";
    CFIndex v18 = -1;
LABEL_33:
    CFErrorRef v25 = _CFErrorWithFilePathCodeDomain(v17, v18, a1);
    uint64_t result = 0;
    *a6 = v25;
    return result;
  }
  memset(&v27, 0, sizeof(v27));
  int v12 = open(buffer, 0, 438);
  if (v12 < 0)
  {
    if (!a6) {
      return 0;
    }
    CFIndex v18 = *__error();
    CFStringRef v17 = @"NSPOSIXErrorDomain";
    goto LABEL_33;
  }
  int v13 = v12;
  if (a3) {
    fcntl(v12, 48, 1);
  }
  if (fstat(v13, &v27) < 0) {
    goto LABEL_16;
  }
  if ((v27.st_mode & 0xF000) != 0x8000)
  {
    close(v13);
    if (a6)
    {
      CFStringRef v17 = @"NSPOSIXErrorDomain";
      CFIndex v18 = 13;
      goto LABEL_33;
    }
    return 0;
  }
  if (v27.st_size < 0)
  {
LABEL_31:
    close(v13);
    if (a6)
    {
      CFStringRef v17 = @"NSPOSIXErrorDomain";
      CFIndex v18 = 12;
      goto LABEL_33;
    }
    return 0;
  }
  if (!v27.st_size)
  {
    uint64_t v15 = malloc_type_malloc(8uLL, 0x4B594D95uLL);
    off_t v16 = 0;
    goto LABEL_37;
  }
  if (!a2)
  {
    uint64_t v20 = (char *)malloc_type_malloc(v27.st_size, 0x9DEC06C6uLL);
    if (v20)
    {
      uint64_t v15 = v20;
      st_mach_vm_size_t size = v27.st_size;
      if (!v27.st_size) {
        goto LABEL_36;
      }
      CFIndex v22 = v20;
      while (1)
      {
        size_t v23 = st_size >= 0x7FFFFFFF ? 0x7FFFFFFFLL : st_size;
        ssize_t v24 = read(v13, v22, v23);
        if (v24 <= 0) {
          break;
        }
        v22 += v24;
        st_size -= v24;
        if (!st_size) {
          goto LABEL_36;
        }
      }
      if ((v24 & 0x8000000000000000) == 0)
      {
LABEL_36:
        off_t v16 = v27.st_size - st_size;
        goto LABEL_37;
      }
      CFIndex v19 = *__error();
      free(v15);
LABEL_17:
      close(v13);
      if (a6)
      {
        CFStringRef v17 = @"NSPOSIXErrorDomain";
        CFIndex v18 = v19;
        goto LABEL_33;
      }
      return 0;
    }
    goto LABEL_31;
  }
  uint64_t v14 = mmap(0, v27.st_size, 1, 2, v13, 0);
  if (v14 == (void *)-1)
  {
LABEL_16:
    CFIndex v19 = *__error();
    goto LABEL_17;
  }
  uint64_t v15 = v14;
  off_t v16 = v27.st_size;
LABEL_37:
  close(v13);
  *a4 = v15;
  *a5 = v16;
  return 1;
}

CFErrorRef _CFErrorWithFilePathCodeDomain(const __CFString *a1, CFIndex a2, void *a3)
{
  values[1] = *(void **)off_1ECE0A5B0;
  keys = @"NSFilePath";
  values[0] = a3;
  CFDictionaryRef v5 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&keys, (const void **)values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFErrorRef v6 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, a2, v5);
  CFRelease(v5);
  return v6;
}

BOOL _CFOperatingSystemVersionIsAtLeastVersion(void *a1)
{
  if (_CFOperatingSystemVersionGetCurrent_onceToken != -1) {
    dispatch_once(&_CFOperatingSystemVersionGetCurrent_onceToken, &__block_literal_global_44);
  }
  if ((uint64_t)_CFOperatingSystemVersionGetCurrent_version < *a1) {
    return 0;
  }
  if ((uint64_t)_CFOperatingSystemVersionGetCurrent_version > *a1) {
    return 1;
  }
  uint64_t v3 = a1[1];
  if (*((uint64_t *)&_CFOperatingSystemVersionGetCurrent_version + 1) < v3) {
    return 0;
  }
  if (*((uint64_t *)&_CFOperatingSystemVersionGetCurrent_version + 1) > v3) {
    return 1;
  }
  return qword_1EB1DD4D8 >= a1[2];
}

uint64_t _CFSuddenTerminationDisablingCount()
{
  return 1;
}

uint64_t _CFAppVersionLessThan(CFTypeRef cf2, double a2)
{
  if (_bundleInfo_onceToken != -1) {
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  }
  uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if (result) {
    return *(double *)&_bundleInfo_info_2 < a2 || a2 < 0.0;
  }
  return result;
}

const char *_CFGetExecutableLinkedLibraryVersion@<X0>(const char *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(_OWORD *)a2 = xmmword_182EC7C40;
  if (result)
  {
    uint64_t result = (const char *)NSVersionOfLinkTimeLibrary(result);
    if (result != -1)
    {
      *(void *)a2 = result >> 16;
      *(void *)(a2 + 8) = BYTE1(result);
      *(void *)(a2 + 16) = result;
    }
  }
  return result;
}

uint64_t _CFLibraryVersionCompare(void *a1, void *a2)
{
  BOOL v2 = (*a1 & 0x8000000000000000) == 0 && (a1[1] & 0x8000000000000000) == 0 && a1[2] >= 0;
  if ((*a2 & 0x8000000000000000) != 0
    || (a2[1] & 0x8000000000000000) != 0
    || ((uint64_t)a2[2] >= 0 ? (BOOL v3 = v2) : (BOOL v3 = 0), !v3))
  {
    if (v2) {
      return -1;
    }
    else {
      return 1;
    }
  }
  else
  {
    unsigned int v4 = (*a1 << 16) | (*((_DWORD *)a1 + 2) << 8) | *((unsigned __int8 *)a1 + 16);
    unsigned int v5 = (*a2 << 16) | (a2[1] << 8) | a2[2];
    BOOL v6 = v4 == v5;
    BOOL v7 = v4 > v5;
    uint64_t v8 = 1;
    if (!v7) {
      uint64_t v8 = -1;
    }
    if (v6) {
      return 0;
    }
    else {
      return v8;
    }
  }
}

BOOL _CFLinkedOnOrAfter(long long *a1, uint64_t a2)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  long long v4 = *a1;
  uint64_t v5 = *((void *)a1 + 2);
  v3[1] = 0;
  int v3[2] = 0;
  v3[0] = a2;
  return _CFLibraryVersionCompare(&v4, v3) != -1;
}

uint64_t _CFBundleGrokObjCImageInfoFromMainExecutable(_DWORD *a1, _DWORD *a2)
{
  v8[1] = *(void *)off_1ECE0A5B0;
  v8[0] = 0;
  uint64_t result = (uint64_t)getsegbyname("__DATA");
  if (!result)
  {
    int v6 = 0;
    int v7 = 0;
    goto LABEL_7;
  }
  SectCFDataRef Data = _CFBundleGetSectData("__DATA", "__objc_imageinfo", v8);
  uint64_t result = 0;
  if (SectData)
  {
    int v6 = 0;
    int v7 = 0;
    if (v8[0] >= 8)
    {
      int v6 = *(_DWORD *)SectData->sectname;
      int v7 = *(_DWORD *)&SectData->sectname[4];
      uint64_t result = 1;
      if (!a1) {
        goto LABEL_9;
      }
LABEL_8:
      *a1 = v6;
      goto LABEL_9;
    }
LABEL_7:
    if (!a1) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  int v6 = 0;
  int v7 = 0;
  if (a1) {
    goto LABEL_8;
  }
LABEL_9:
  if (a2) {
    *a2 = v7;
  }
  return result;
}

CFStringRef _CFBundleCopyFileTypeForFileURL(const __CFURL *a1, int32x4_t a2)
{
  v3[1] = *(CFStringRef *)off_1ECE0A5B0;
  v3[0] = 0;
  _CFBundleGrokFileType(a1, 0, v3, 0, 0, 0, 0, 0, a2, 0);
  return v3[0];
}

CFStringRef _CFBundleCopyFileTypeForFileData(const __CFData *a1, int32x4_t a2)
{
  v3[1] = *(CFStringRef *)off_1ECE0A5B0;
  v3[0] = 0;
  _CFBundleGrokFileType(0, a1, v3, 0, 0, 0, 0, 0, a2, 0);
  return v3[0];
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryForExecutableFileData(const __CFData *a1, BOOL *a2, int32x4_t a3)
{
  v6[1] = *(CFMutableDictionaryRef *)off_1ECE0A5B0;
  v6[0] = 0;
  int v5 = 0;
  _CFBundleGrokFileType(0, a1, 0, &v5, 0, v6, 0, 0, a3, 0);
  if (a2) {
    *a2 = (v5 & 0xFFFFFFFB) == 2;
  }
  return v6[0];
}

CFArrayRef _CFBundleCopyArchitecturesForExecutable(const __CFURL *a1, int32x4_t a2)
{
  v3[1] = *(const __CFArray **)off_1ECE0A5B0;
  v3[0] = 0;
  _CFBundleGrokFileType(a1, 0, 0, 0, v3, 0, 0, 0, a2, 0);
  return v3[0];
}

uint64_t _CFBundleGetObjCImageInfo(__CFBundle *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  unsigned int v10 = 0;
  unsigned int v11 = 0;
  CFURLRef v5 = CFBundleCopyExecutableURL(a1);
  if (v5)
  {
    CFURLRef v7 = v5;
    unsigned __int8 v12 = 0;
    _CFBundleGrokFileType(v5, 0, 0, 0, 0, 0, (char *)&v12, &v11, v6, &v10);
    uint64_t v8 = v12;
    CFRelease(v7);
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v8 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v11;
LABEL_4:
  if (a3) {
    *a3 = v10;
  }
  return v8;
}

const char *_CFBundleGrokFileTypeForZipFile(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = a1;
  if (a3 < 31)
  {
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    long long v56 = 0uLL;
    uint64_t v59 = 0;
    int v33 = 0;
    CFAllocatorRef v9 = "zip";
    goto LABEL_125;
  }
  int v55 = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  long long v56 = 0uLL;
  uint64_t v59 = 0;
  uint64_t v8 = 0;
  unint64_t v53 = a2 + a3;
  CFAllocatorRef v9 = "zip";
  while (1)
  {
    unsigned int v10 = (const char *)(a2 + v8);
    if (*(unsigned char *)(a2 + v8) != 80 || *(unsigned char *)(v8 + a2 + 1) != 75) {
      goto LABEL_12;
    }
    int v11 = *(unsigned __int8 *)(v8 + a2 + 2);
    if (v11 != 3) {
      break;
    }
    if (*(unsigned char *)(v8 + a2 + 3) == 4)
    {
      unsigned int v13 = 30;
      char v12 = 1;
      uint64_t v14 = 26;
      goto LABEL_11;
    }
LABEL_12:
    BOOL v16 = 0;
LABEL_13:
    uint64_t v17 = v8 + 31;
    ++v8;
    if (v17 >= a3) {
      goto LABEL_124;
    }
  }
  if (v11 != 1 || *(unsigned char *)(v8 + a2 + 3) != 2) {
    goto LABEL_12;
  }
  char v12 = 0;
  unsigned int v13 = 46;
  uint64_t v14 = 28;
LABEL_11:
  uint64_t v15 = *(unsigned __int16 *)&v10[v14];
  if (v8 + v13 + v15 > a3) {
    goto LABEL_12;
  }
  uint64_t v18 = v13;
  char v19 = v12 ^ 1;
  if (v15 != 8) {
    char v19 = 1;
  }
  if (v19)
  {
    if (*(unsigned __int16 *)&v10[v14] <= 0x12u)
    {
      if (v15 == 9)
      {
        if (!strncasecmp_l(&v10[v13], "META-INF/", 9uLL, 0))
        {
          BOOL v16 = 0;
          LODWORD(v56) = 1;
          goto LABEL_78;
        }
        goto LABEL_19;
      }
      if (v15 == 11)
      {
        if (!strncasecmp_l(&v10[v13], "content.xml", 0xBuLL, 0))
        {
          BOOL v16 = 0;
          DWORD1(v56) = 1;
          goto LABEL_78;
        }
        if (!strncasecmp_l(&v10[v18], "_rels/.rels", 0xBuLL, 0))
        {
          BOOL v16 = 0;
          LODWORD(v59) = 1;
          goto LABEL_78;
        }
        goto LABEL_19;
      }
    }
    else
    {
      switch(v15)
      {
        case 0x13:
          if (!strncasecmp_l(&v10[v13], "[Content_Types].xml", 0x13uLL, 0))
          {
            BOOL v16 = 0;
            HIDWORD(v59) = 1;
            goto LABEL_78;
          }
          goto LABEL_19;
        case 0x14:
          if (!strncasecmp_l(&v10[v13], "META-INF/MANIFEST.MF", 0x14uLL, 0))
          {
            BOOL v16 = 0;
            int v55 = 1;
            goto LABEL_78;
          }
          goto LABEL_19;
        case 0x15:
          if (!strncasecmp_l(&v10[v13], "META-INF/manifest.xml", 0x15uLL, 0))
          {
            BOOL v16 = 0;
            DWORD2(v56) = 1;
            goto LABEL_78;
          }
LABEL_19:
          uint64_t v20 = &v10[v18];
          int64_t v21 = &v10[v18 + v15];
          if (!strncasecmp_l(v21 - 4, ".opf", 4uLL, 0))
          {
            BOOL v16 = 0;
            HIDWORD(v58) = 1;
            goto LABEL_78;
          }
          if (!strncasecmp_l(v21 - 4, ".sml", 4uLL, 0)) {
            goto LABEL_60;
          }
          if (v15 < 6) {
            goto LABEL_75;
          }
          if (!strncasecmp_l(v21 - 5, ".smil", 5uLL, 0))
          {
LABEL_60:
            BOOL v16 = 0;
            HIDWORD(v57) = 1;
            goto LABEL_78;
          }
          if (v15 < 8) {
            goto LABEL_75;
          }
          if (strncasecmp_l(v20, "xl/", 3uLL, 0) || strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
          {
            if (v15 < 9) {
              goto LABEL_75;
            }
            if (!strncasecmp_l(v20, "ppt/", 4uLL, 0) && !strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
            {
              BOOL v16 = 0;
              int v23 = 1;
LABEL_107:
              HIDWORD(v56) = v23;
              goto LABEL_78;
            }
            if (v15 < 0xA) {
              goto LABEL_75;
            }
            if (!strncasecmp_l(v20, "word/", 5uLL, 0) && !strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
            {
              BOOL v16 = 0;
              LODWORD(v58) = 1;
              goto LABEL_78;
            }
            if (v15 < 0xB)
            {
LABEL_75:
              BOOL v16 = 0;
              goto LABEL_78;
            }
            if (strncasecmp_l(v20, "excel/", 6uLL, 0) || strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
            {
              if (v15 >= 0x10 && !strncasecmp_l(v20, "powerpoint/", 0xBuLL, 0))
              {
                int v22 = strncasecmp_l(v21 - 4, ".xml", 4uLL, 0);
                BOOL v16 = 0;
                int v23 = HIDWORD(v56);
                if (!v22) {
                  int v23 = 1;
                }
                goto LABEL_107;
              }
              goto LABEL_75;
            }
          }
          BOOL v16 = 0;
          LODWORD(v57) = 1;
          goto LABEL_78;
      }
    }
    if (v15 < 5) {
      goto LABEL_75;
    }
    goto LABEL_19;
  }
  if (strncasecmp_l(&v10[v13], "mimetype", 8uLL, 0)) {
    goto LABEL_19;
  }
  ssize_t v24 = &v10[*((unsigned __int16 *)v10 + 13) + *((unsigned __int16 *)v10 + 14)];
  unint64_t v25 = (unint64_t)(v24 + 30);
  if (v24 + 30 <= v10
    || (unint64_t)(v24 + 86) > v53
    || *((_WORD *)v10 + 4)
    || strncasecmp_l((const char *)v25, "application/vnd.", 0x10uLL, 0)
    && strncasecmp_l((const char *)v25, "application/x-vnd.", 0x12uLL, 0))
  {
    if (v25 > (unint64_t)v10
      && v25 + 41 <= v53
      && *((_WORD *)v10 + 4) == 8
      && *(_DWORD *)v25 == -936891317
      && *(_DWORD *)(v25 + 4) == 743328969)
    {
      int v26 = -1;
      CFAllocatorRef v9 = "odt";
      goto LABEL_77;
    }
    if (v25 <= (unint64_t)v10
      || v25 + 29 > v53
      || strncasecmp_l((const char *)v25, "application/oebps-package+xml", 0x1DuLL, 0))
    {
      int v26 = -1;
      if (v25 <= (unint64_t)v10 || v25 + 20 > v53) {
        goto LABEL_77;
      }
      if (strncasecmp_l((const char *)v25, "application/epub+zip", 0x14uLL, 0)) {
        goto LABEL_67;
      }
    }
    int v26 = 0;
    CFAllocatorRef v9 = "epub";
    goto LABEL_77;
  }
  uint64_t v27 = 16;
  if (*(unsigned char *)(v25 + 15) != 46) {
    uint64_t v27 = 18;
  }
  long long v28 = (const char *)(v25 + v27);
  if (!strncasecmp_l(v28, "sun.xml.", 8uLL, 0))
  {
    long long v30 = v28 + 8;
    if (strncasecmp_l(v30, "calc", 4uLL, 0))
    {
      if (strncasecmp_l(v30, "draw", 4uLL, 0))
      {
        if (strncasecmp_l(v30, "writer.global", 0xDuLL, 0))
        {
          if (strncasecmp_l(v30, "impress", 7uLL, 0))
          {
            int v26 = 4;
            if (strncasecmp_l(v30, "math", 4uLL, 0))
            {
              if (strncasecmp_l(v30, "writer", 6uLL, 0)) {
                goto LABEL_67;
              }
              int v26 = 5;
            }
          }
          else
          {
            int v26 = 3;
          }
        }
        else
        {
          int v26 = 2;
        }
      }
      else
      {
        int v26 = 1;
      }
    }
    else
    {
      int v26 = 0;
    }
    uint64_t v31 = (5 * v26);
    long long v32 = "sxc";
    goto LABEL_122;
  }
  if (strncasecmp_l(v28, "oasis.opendocument.", 0x13uLL, 0)) {
    goto LABEL_67;
  }
  uint64_t v29 = v28 + 19;
  if (!strncasecmp_l(v29, "chart", 5uLL, 0))
  {
    int v26 = 0;
LABEL_121:
    uint64_t v31 = (5 * v26);
    long long v32 = (const char *)&unk_182EC7EE4;
LABEL_122:
    CFAllocatorRef v9 = &v32[v31];
    goto LABEL_77;
  }
  if (!strncasecmp_l(v29, "formula", 7uLL, 0))
  {
    int v26 = 1;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "graphics", 8uLL, 0))
  {
    int v26 = 2;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "text-web", 8uLL, 0))
  {
    int v26 = 3;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "image", 5uLL, 0))
  {
    int v26 = 4;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "text-master", 0xBuLL, 0))
  {
    int v26 = 5;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "presentation", 0xCuLL, 0))
  {
    int v26 = 6;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "spreadsheet", 0xBuLL, 0))
  {
    int v26 = 7;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "text", 4uLL, 0))
  {
    int v26 = 8;
    goto LABEL_121;
  }
LABEL_67:
  int v26 = -1;
LABEL_77:
  BOOL v16 = v26 >= 0;
LABEL_78:
  v8 += (v18 + v15 - 1);
  if (!v16) {
    goto LABEL_13;
  }
LABEL_124:
  int v7 = a1;
  int v33 = v55;
  if (!v16)
  {
LABEL_125:
    BOOL v34 = a4 < 1024;
    off_t v35 = a4 - 1024;
    if (!v34)
    {
      if (v7 < 0 || lseek(v7, v35, 0) != v35)
      {
        if (a3 >= 1024)
        {
          int64_t v39 = 0;
          uint64_t v37 = a2 + a3 - 1024;
          goto LABEL_133;
        }
      }
      else
      {
        uint64_t v36 = malloc_type_malloc(0x400uLL, 0x2B428188uLL);
        if (v36)
        {
          uint64_t v37 = (uint64_t)v36;
          ssize_t v38 = read(v7, v36, 0x400uLL);
          int64_t v39 = (void *)v37;
          if (v38 <= 1023)
          {
            int64_t v39 = (void *)v37;
            goto LABEL_192;
          }
LABEL_133:
          uint64_t v40 = 0;
          while (2)
          {
            uint64_t v41 = v37 + v40;
            if (*(unsigned char *)(v37 + v40) != 80 || *(unsigned char *)(v40 + v37 + 1) != 75) {
              goto LABEL_185;
            }
            int v42 = *(unsigned __int8 *)(v40 + v37 + 2);
            if (v42 != 3)
            {
              if (v42 == 1 && *(unsigned char *)(v40 + v37 + 3) == 2)
              {
                unsigned int v43 = 46;
                uint64_t v44 = 28;
                goto LABEL_142;
              }
              goto LABEL_185;
            }
            if (*(unsigned char *)(v40 + v37 + 3) != 4) {
              goto LABEL_185;
            }
            unsigned int v43 = 30;
            uint64_t v44 = 26;
LABEL_142:
            uint64_t v45 = *(unsigned __int16 *)(v41 + v44);
            if (v40 + v43 + v45 > 1024)
            {
LABEL_185:
              BOOL v34 = v40++ < 993;
              if (!v34) {
                goto LABEL_192;
              }
              continue;
            }
            break;
          }
          uint64_t v46 = v43;
          if (*(unsigned __int16 *)(v41 + v44) <= 0x12u)
          {
            if (v45 == 9)
            {
              if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/", 9uLL, 0))
              {
                LODWORD(v56) = 1;
                goto LABEL_184;
              }
              goto LABEL_161;
            }
            if (v45 == 11)
            {
              if (!strncasecmp_l((const char *)(v41 + v43), "content.xml", 0xBuLL, 0))
              {
                DWORD1(v56) = 1;
                goto LABEL_184;
              }
              if (!strncasecmp_l((const char *)(v41 + v46), "_rels/.rels", 0xBuLL, 0))
              {
                LODWORD(v59) = 1;
                goto LABEL_184;
              }
              goto LABEL_161;
            }
          }
          else
          {
            switch(v45)
            {
              case 0x13:
                if (!strncasecmp_l((const char *)(v41 + v43), "[Content_Types].xml", 0x13uLL, 0))
                {
                  HIDWORD(v59) = 1;
                  goto LABEL_184;
                }
                goto LABEL_161;
              case 0x14:
                if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/MANIFEST.MF", 0x14uLL, 0))
                {
                  int v33 = 1;
                  goto LABEL_184;
                }
                goto LABEL_161;
              case 0x15:
                if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/manifest.xml", 0x15uLL, 0))
                {
                  DWORD2(v56) = 1;
                  goto LABEL_184;
                }
LABEL_161:
                char v47 = (const char *)(v41 + v46);
                if (!strncasecmp_l(&v47[v45 - 4], ".opf", 4uLL, 0))
                {
                  HIDWORD(v58) = 1;
                  goto LABEL_184;
                }
                if (!strncasecmp_l(&v47[v45 - 4], ".sml", 4uLL, 0)) {
                  goto LABEL_182;
                }
                if (v45 < 6) {
                  goto LABEL_184;
                }
                if (!strncasecmp_l(&v47[v45 - 5], ".smil", 5uLL, 0))
                {
LABEL_182:
                  HIDWORD(v57) = 1;
                  goto LABEL_184;
                }
                if (v45 < 8) {
                  goto LABEL_184;
                }
                if (strncasecmp_l(v47, "xl/", 3uLL, 0) || strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                {
                  if (v45 < 9) {
                    goto LABEL_184;
                  }
                  if (!strncasecmp_l(v47, "ppt/", 4uLL, 0) && !strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                  {
                    int v49 = 1;
LABEL_189:
                    HIDWORD(v56) = v49;
                    goto LABEL_184;
                  }
                  if (v45 < 0xA) {
                    goto LABEL_184;
                  }
                  if (!strncasecmp_l(v47, "word/", 5uLL, 0) && !strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                  {
                    LODWORD(v58) = 1;
                    goto LABEL_184;
                  }
                  if (v45 < 0xB)
                  {
LABEL_184:
                    v40 += (v46 + v45 - 1);
                    goto LABEL_185;
                  }
                  if (strncasecmp_l(v47, "excel/", 6uLL, 0) || strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                  {
                    if (v45 < 0x10 || strncasecmp_l(v47, "powerpoint/", 0xBuLL, 0)) {
                      goto LABEL_184;
                    }
                    int v48 = strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0);
                    int v49 = HIDWORD(v56);
                    if (!v48) {
                      int v49 = 1;
                    }
                    goto LABEL_189;
                  }
                }
                LODWORD(v57) = 1;
                goto LABEL_184;
            }
          }
          if (v45 < 5) {
            goto LABEL_184;
          }
          goto LABEL_161;
        }
      }
    }
    int64_t v39 = 0;
LABEL_192:
    if (v33)
    {
LABEL_193:
      CFAllocatorRef v9 = "jar";
    }
    else
    {
      BOOL v50 = v59 != 0;
      if (v59 && v58)
      {
        CFAllocatorRef v9 = "docx";
      }
      else
      {
        if (v57) {
          BOOL v51 = v59 != 0;
        }
        else {
          BOOL v51 = 0;
        }
        if (v51)
        {
          CFAllocatorRef v9 = "xlsx";
        }
        else
        {
          if (!BYTE12(v56)) {
            BOOL v50 = 0;
          }
          if (v50)
          {
            CFAllocatorRef v9 = "pptx";
          }
          else if (*(void *)((char *)&v56 + 4))
          {
            CFAllocatorRef v9 = "odt";
          }
          else
          {
            if (v56) {
              goto LABEL_193;
            }
            if (HIDWORD(v58) && HIDWORD(v57))
            {
              CFAllocatorRef v9 = "dtb";
            }
            else if (HIDWORD(v58))
            {
              CFAllocatorRef v9 = "oeb";
            }
          }
        }
      }
    }
    if (v39) {
      free(v39);
    }
  }
  return v9;
}

const char *_CFBundleGrokFileTypeForOLEFile(int a1, uint64_t a2, off_t a3, off_t a4)
{
  if (a1 < 0 || lseek(a1, a4, 0) != a4)
  {
    int v11 = "ole";
    if (a4 + 512 > a3 || !a2) {
      return v11;
    }
    CFAllocatorRef v9 = 0;
    unsigned int v10 = (unsigned __int8 *)(a2 + a4);
  }
  else
  {
    uint64_t v8 = (unsigned __int8 *)malloc_type_malloc(0x200uLL, 0x5D77337uLL);
    if (!v8) {
      return "ole";
    }
    CFAllocatorRef v9 = v8;
    if (read(a1, v8, 0x200uLL) <= 511)
    {
      int v11 = "ole";
      goto LABEL_60;
    }
    unsigned int v10 = v9;
  }
  unint64_t v12 = 0;
  int v11 = "xls";
  while (1)
  {
    unint64_t v13 = v12 << 7;
    unsigned int v14 = v10[128 * v12 + 64];
    int v15 = (int)((v14 + (v14 >> 7)) << 24) >> 25;
    int v16 = v14 & 0xFE;
    if (v16 <= 25)
    {
      if (v16 == 10)
      {
        unint64_t v29 = (v15 - 1);
        if (v15 == 1) {
          goto LABEL_56;
        }
        uint64_t v30 = 0;
        unint64_t v31 = 0;
        long long v32 = &v10[v13];
        do
        {
          int v33 = v32[v30 & 0xFFFFFFFE];
          int v34 = aBook[v31++];
          v30 += 2;
        }
        while (v33 == v34 && v31 < v29);
        if (v33 == v34) {
          goto LABEL_56;
        }
      }
      else if (v16 == 18)
      {
        unint64_t v17 = (v15 - 1);
        if (!v17) {
          goto LABEL_56;
        }
        uint64_t v18 = 0;
        unint64_t v19 = 0;
        do
        {
          int v20 = v10[v13 + (v18 & 0xFFFFFFFE)];
          int v21 = aWorkbook[v19++];
          v18 += 2;
          BOOL v22 = v20 != v21 || v19 >= v17;
        }
        while (!v22);
        if (v20 == v21) {
          goto LABEL_56;
        }
      }
      goto LABEL_50;
    }
    if (v16 != 40) {
      break;
    }
    unsigned int v36 = v15 - 1;
    if (!v36) {
      goto LABEL_55;
    }
    uint64_t v37 = 0;
    unint64_t v38 = 0;
    int64_t v39 = &v10[v13];
    do
    {
      int v40 = v39[v37 & 0xFFFFFFFE];
      int v41 = aPowerpointDocu[v38++];
      v37 += 2;
    }
    while (v40 == v41 && v38 < v36);
    if (v40 == v41)
    {
LABEL_55:
      int v11 = "ppt";
LABEL_56:
      if (v9) {
        goto LABEL_60;
      }
      return v11;
    }
LABEL_50:
    BOOL v22 = v12++ >= 3;
    if (v22)
    {
      int v11 = "ole";
      if (v9) {
        goto LABEL_60;
      }
      return v11;
    }
  }
  if (v16 != 26) {
    goto LABEL_50;
  }
  unsigned int v23 = v15 - 1;
  if (v23)
  {
    uint64_t v24 = 0;
    unint64_t v25 = 0;
    do
    {
      int v26 = v10[v13 + (v24 & 0xFFFFFFFE)];
      int v27 = aWorddocument[v25++];
      v24 += 2;
    }
    while (v26 == v27 && v25 < v23);
    if (v26 != v27) {
      goto LABEL_50;
    }
  }
  int v11 = "doc";
  if (!v9) {
    return v11;
  }
LABEL_60:
  free(v9);
  return v11;
}

BOOL _CFBundleGrokX11FromFile(int a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v11 = a4;
  if ((a1 & 0x80000000) == 0 && lseek(a1, a4, 0) == a4)
  {
    unint64_t v13 = malloc_type_malloc(0x1000uLL, 0xD7DD8ABDuLL);
    if (v13)
    {
      unsigned int v14 = v13;
      if (read(a1, v13, 0x1000uLL) <= 4095)
      {
        BOOL v19 = 0;
LABEL_51:
        free(v14);
        return v19;
      }
      int v40 = v14;
      int v15 = (unsigned int *)v14;
      if (!a6) {
        goto LABEL_6;
      }
      goto LABEL_15;
    }
    return 0;
  }
  int v15 = (unsigned int *)(a2 + v11);
  if (a4 + 4096 > a3 || v15 == 0) {
    return 0;
  }
  int v40 = 0;
  if (!a6)
  {
LABEL_6:
    unsigned int v16 = v15[4];
    if (a5)
    {
      unsigned int v16 = bswap32(v16);
      unsigned int v17 = bswap32(v15[5]);
    }
    else
    {
      unsigned int v17 = v15[5];
    }
    if (v17 <= 0xFE4) {
      unint64_t v30 = v17 + 28;
    }
    else {
      unint64_t v30 = 4096;
    }
    if (v16) {
      BOOL v31 = v30 >= 0x1D;
    }
    else {
      BOOL v31 = 0;
    }
    if (!v31)
    {
      BOOL v19 = 0;
      goto LABEL_50;
    }
    int v33 = (int *)(v15 + 7);
    unsigned int v34 = 1;
    unint64_t v35 = 28;
    while (1)
    {
      int v36 = *v33;
      if (a5) {
        break;
      }
      if (v36 == 12)
      {
        unsigned int v37 = v33[2];
LABEL_59:
        unint64_t v38 = (char *)v15 + v35 + v37;
        BOOL v19 = v38 + 20 <= (const char *)v15 + v30 && strncmp(v38, "/usr/X11R6/lib/libX", 0x13uLL) == 0;
        unsigned int v39 = v33[1];
        if (a5) {
          goto LABEL_64;
        }
        goto LABEL_65;
      }
      BOOL v19 = 0;
      unsigned int v39 = v33[1];
LABEL_66:
      if (v34 < v16)
      {
        v35 += v39;
        int v33 = (int *)((char *)v15 + v35);
        ++v34;
        if (v35 < v30) {
          continue;
        }
      }
      goto LABEL_50;
    }
    if (v36 == 201326592)
    {
      unsigned int v37 = bswap32(v33[2]);
      goto LABEL_59;
    }
    BOOL v19 = 0;
    unsigned int v39 = v33[1];
LABEL_64:
    unsigned int v39 = bswap32(v39);
LABEL_65:
    if (v19) {
      goto LABEL_50;
    }
    goto LABEL_66;
  }
LABEL_15:
  unsigned int v20 = v15[4];
  if (a5)
  {
    unsigned int v20 = bswap32(v20);
    unsigned int v21 = bswap32(v15[5]);
  }
  else
  {
    unsigned int v21 = v15[5];
  }
  BOOL v19 = 0;
  if (v21 <= 0xFE0) {
    unint64_t v22 = v21 + 32;
  }
  else {
    unint64_t v22 = 4096;
  }
  if (v20 && v22 >= 0x21)
  {
    unsigned int v23 = (int *)(v15 + 8);
    unsigned int v24 = 1;
    unint64_t v25 = 32;
    while (1)
    {
      int v26 = *v23;
      if (a5) {
        break;
      }
      if (v26 == 12)
      {
        unsigned int v27 = v23[2];
LABEL_29:
        long long v28 = (char *)v15 + v25 + v27;
        BOOL v19 = v28 + 20 <= (const char *)v15 + v22 && strncmp(v28, "/usr/X11R6/lib/libX", 0x13uLL) == 0;
        unsigned int v29 = v23[1];
        if (a5) {
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      BOOL v19 = 0;
      unsigned int v29 = v23[1];
LABEL_36:
      if (v24 < v20)
      {
        v25 += v29;
        unsigned int v23 = (int *)((char *)v15 + v25);
        ++v24;
        if (v25 < v22) {
          continue;
        }
      }
      goto LABEL_50;
    }
    if (v26 == 201326592)
    {
      unsigned int v27 = bswap32(v23[2]);
      goto LABEL_29;
    }
    BOOL v19 = 0;
    unsigned int v29 = v23[1];
LABEL_34:
    unsigned int v29 = bswap32(v29);
LABEL_35:
    if (v19) {
      goto LABEL_50;
    }
    goto LABEL_36;
  }
LABEL_50:
  unsigned int v14 = v40;
  if (v40) {
    goto LABEL_51;
  }
  return v19;
}

void _CFBundleGrokObjcImageInfoFromFile(int a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, char *a7, unsigned int *a8, unsigned int *a9)
{
  uint64_t v84 = *(void *)off_1ECE0A5B0;
  uint64_t v17 = a4;
  if (a1 < 0 || lseek(a1, a4, 0) != a4)
  {
    unsigned int v20 = (unsigned int *)(a2 + v17);
    if (a4 + 4096 <= a3 && v20 != 0)
    {
      BOOL v19 = 0;
      goto LABEL_12;
    }
LABEL_11:
    unsigned int v22 = 0;
    char v23 = 0;
    unsigned int v24 = 0;
    goto LABEL_114;
  }
  uint64_t v18 = (unsigned int *)malloc_type_malloc(0x1000uLL, 0xEF974ABDuLL);
  if (!v18) {
    goto LABEL_11;
  }
  BOOL v19 = v18;
  if (read(a1, v18, 0x1000uLL) <= 4095)
  {
    unsigned int v22 = 0;
    char v23 = 0;
    unsigned int v24 = 0;
    goto LABEL_113;
  }
  unsigned int v20 = v19;
LABEL_12:
  int v78 = a5;
  uint64_t v81 = v20;
  if (!a6)
  {
    unsigned int v27 = v20[4];
    if (a5)
    {
      unsigned int v27 = bswap32(v27);
      unsigned int v28 = bswap32(v20[5]);
    }
    else
    {
      unsigned int v28 = v20[5];
    }
    uint64_t v45 = v28 + 28;
    BOOL v46 = v28 > 0xFE4;
    unint64_t v47 = 4096;
    if (!v46) {
      unint64_t v47 = v45;
    }
    unint64_t v80 = v47;
    if (v27) {
      BOOL v48 = v47 >= 0x1D;
    }
    else {
      BOOL v48 = 0;
    }
    if (!v48)
    {
      char v23 = 0;
      goto LABEL_106;
    }
    int v73 = a1;
    unsigned int v74 = 0;
    unsigned int v69 = a4;
    uint64_t v67 = a3;
    uint64_t v68 = v17;
    uint64_t v66 = a2;
    int64_t v70 = v19;
    CFDataRef v71 = a7;
    unint64_t v72 = a8;
    LODWORD(v75) = 0;
    char v23 = 0;
    int v49 = 0;
    BOOL v50 = (int *)(v20 + 7);
    unint64_t v51 = 28;
    unsigned int v77 = v27;
    while (1)
    {
      int v52 = *v50;
      if (a5) {
        break;
      }
      if (v52 == 1)
      {
        unsigned int v53 = v50[12];
        if (!v53) {
          goto LABEL_87;
        }
        goto LABEL_73;
      }
      unsigned int v61 = v50[1];
LABEL_90:
      if (++v49 < v27)
      {
        v51 += v61;
        BOOL v50 = (int *)((char *)v20 + v51);
        if (v51 >= 0x1C && v51 < v80) {
          continue;
        }
      }
      goto LABEL_98;
    }
    if (v52 == 0x1000000)
    {
      unsigned int v53 = bswap32(v50[12]);
      if (!v53)
      {
LABEL_87:
        int v60 = 0;
        int v62 = 0;
        unsigned int v61 = v50[1];
        unsigned int v27 = v77;
        a5 = v78;
        if (!v78) {
          goto LABEL_89;
        }
        goto LABEL_88;
      }
LABEL_73:
      if (v51 + 56 >= v80) {
        goto LABEL_87;
      }
      unsigned int v54 = 1;
      unint64_t v55 = v51;
      while (1)
      {
        long long v56 = (char *)v20 + v55;
        uint64_t v57 = (char *)v20 + v55 + 56;
        int v58 = strncmp((const char *)v20 + v55 + 72, "__OBJC", 0x10uLL);
        if (!v58) {
          char v23 = 1;
        }
        if (!(strncmp(v57, "__image_info", 0x10uLL) | v58)) {
          break;
        }
        if (v54 >= v53)
        {
          unsigned int v20 = v81;
          goto LABEL_87;
        }
        unint64_t v59 = v55 + 124;
        v55 += 68;
        ++v54;
        unsigned int v20 = v81;
        if (v59 >= v80) {
          goto LABEL_87;
        }
      }
      a5 = v78;
      if (!v78)
      {
        LODWORD(v75) = *((_DWORD *)v56 + 23);
        unsigned int v74 = *(unsigned int *)((char *)v81 + v55 + 96);
        goto LABEL_98;
      }
      LODWORD(v75) = bswap32(*((_DWORD *)v56 + 23));
      unsigned int v20 = v81;
      unsigned int v74 = bswap32(*(unsigned int *)((char *)v81 + v55 + 96));
      int v60 = 1;
      unsigned int v27 = v77;
    }
    else
    {
      int v60 = 0;
    }
    unsigned int v61 = v50[1];
LABEL_88:
    unsigned int v61 = bswap32(v61);
    int v62 = v60;
LABEL_89:
    if (v62) {
      goto LABEL_98;
    }
    goto LABEL_90;
  }
  unsigned int v25 = v20[4];
  int v73 = a1;
  if (a5)
  {
    unsigned int v25 = bswap32(v25);
    unsigned int v26 = bswap32(v20[5]);
  }
  else
  {
    unsigned int v26 = v20[5];
  }
  char v23 = 0;
  if (v26 <= 0xFE0) {
    unint64_t v29 = v26 + 32;
  }
  else {
    unint64_t v29 = 4096;
  }
  if (!v25)
  {
    unsigned int v24 = 0;
    unsigned int v22 = 0;
    goto LABEL_112;
  }
  unsigned int v69 = a4;
  uint64_t v68 = v17;
  unsigned int v24 = 0;
  unsigned int v22 = 0;
  if (v29 < 0x21) {
    goto LABEL_112;
  }
  uint64_t v66 = a2;
  uint64_t v67 = a3;
  int64_t v70 = v19;
  CFDataRef v71 = a7;
  unint64_t v72 = a8;
  LODWORD(v75) = 0;
  unsigned int v74 = 0;
  char v23 = 0;
  int v30 = 0;
  BOOL v31 = (int *)(v20 + 8);
  unint64_t v32 = 32;
  unsigned int v76 = v25;
  while (1)
  {
    int v33 = *v31;
    if (a5) {
      break;
    }
    if (v33 == 25)
    {
      unsigned int v34 = v31[16];
      goto LABEL_29;
    }
    unsigned int v42 = v31[1];
LABEL_48:
    if (++v30 < v25)
    {
      v32 += v42;
      BOOL v31 = (int *)((char *)v20 + v32);
      BOOL v44 = v32 < 0x20 || v32 >= v29;
      if (!v44) {
        continue;
      }
    }
    goto LABEL_98;
  }
  if (v33 != 419430400)
  {
    int v41 = 0;
LABEL_43:
    unsigned int v42 = v31[1];
LABEL_46:
    unsigned int v42 = bswap32(v42);
    int v43 = v41;
LABEL_47:
    if (v43) {
      goto LABEL_98;
    }
    goto LABEL_48;
  }
  unsigned int v34 = bswap32(v31[16]);
LABEL_29:
  int v79 = v30;
  if (!v34 || v32 + 72 >= v29)
  {
LABEL_45:
    int v41 = 0;
    int v43 = 0;
    unsigned int v42 = v31[1];
    unsigned int v25 = v76;
    a5 = v78;
    int v30 = v79;
    if (!v78) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }
  unint64_t v35 = v32 + 152;
  unsigned int v36 = 1;
  while (1)
  {
    unint64_t v37 = v29;
    unint64_t v38 = (char *)v20 + v35;
    unsigned int v39 = (char *)v20 + v35 - 80;
    int v40 = strncmp((const char *)v20 + v35 - 64, "__DATA", 0x10uLL);
    if (!v40) {
      char v23 = 1;
    }
    if (!(strncmp(v39, "__objc_imageinfo", 0x10uLL) | v40)) {
      break;
    }
    if (v36 >= v34)
    {
      unsigned int v20 = v81;
      unint64_t v29 = v37;
      goto LABEL_45;
    }
    ++v36;
    unint64_t v29 = v37;
    BOOL v44 = v35 >= v37;
    v35 += 80;
    unsigned int v20 = v81;
    if (v44) {
      goto LABEL_45;
    }
  }
  a5 = v78;
  if (v78)
  {
    LODWORD(v75) = bswap64(*((void *)v38 - 5));
    unsigned int v20 = v81;
    unsigned int v74 = bswap32(*(unsigned int *)((char *)v81 + v35 - 32));
    int v41 = 1;
    unsigned int v25 = v76;
    unint64_t v29 = v37;
    int v30 = v79;
    goto LABEL_43;
  }
  unsigned int v74 = *(unsigned int *)((char *)v81 + v35 - 32);
  uint64_t v75 = *((void *)v38 - 5);
LABEL_98:
  if (v75 < 8)
  {
    unsigned int v24 = 0;
    unsigned int v22 = 0;
    a7 = v71;
    a8 = v72;
    BOOL v19 = v70;
    goto LABEL_112;
  }
  if (v73 < 0 || lseek(v73, v74 + v69, 0) != v74 + v69 || read(v73, &v82, 8uLL) < 8)
  {
    a7 = v71;
    a8 = v72;
    BOOL v19 = v70;
    if (v69 + v74 + 8 <= v67)
    {
      int64_t v65 = (unsigned int *)(v66 + v68 + v74);
      unsigned int v22 = *v65;
      if (a5)
      {
        unsigned int v22 = bswap32(v22);
        unsigned int v64 = v65[1];
LABEL_109:
        unsigned int v24 = bswap32(v64);
      }
      else
      {
        unsigned int v24 = v65[1];
      }
      goto LABEL_112;
    }
LABEL_106:
    unsigned int v24 = 0;
    unsigned int v22 = 0;
    goto LABEL_112;
  }
  unsigned int v22 = v82;
  a7 = v71;
  a8 = v72;
  BOOL v19 = v70;
  if (a5)
  {
    unsigned int v22 = bswap32(v82);
    unsigned int v64 = v83;
    goto LABEL_109;
  }
  unsigned int v24 = v83;
LABEL_112:
  if (v19) {
LABEL_113:
  }
    free(v19);
LABEL_114:
  if (a7) {
    *a7 = v23;
  }
  if (a8) {
    *a8 = v22;
  }
  if (a9) {
    *a9 = v24;
  }
}

uint64_t _CFBundleGrokMachTypeForFatFile(int a1, UInt8 *a2, uint64_t a3, int a4, BOOL *a5, const __CFArray **a6, CFMutableDictionaryRef *a7, char *a8, unsigned int *a9, unsigned int *a10)
{
  uint64_t v68 = *(void *)off_1ECE0A5B0;
  uint64_t v18 = NXGetLocalArchInfo();
  cpu_type_t v19 = _CFBundleCurrentArchitecture();
  if (a5) {
    *a5 = 0;
  }
  int v63 = a5;
  if (a6) {
    *a6 = 0;
  }
  unsigned int v20 = a9;
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a9) {
    *a9 = 0;
  }
  int v62 = a7;
  if (a10) {
    *a10 = 0;
  }
  if (a3 >= 512) {
    uint64_t v21 = 512;
  }
  else {
    uint64_t v21 = a3;
  }
  __memmove_chk();
  if (a4 && a3 >= 1)
  {
    uint64_t v22 = 0;
    do
    {
      *(_DWORD *)&v65[v22 + 32] = bswap32(*(_DWORD *)&v65[v22 + 32]);
      v22 += 4;
    }
    while (v21 > v22);
  }
  if (v66 >= ((v21 - 8) / 0x14uLL)) {
    uint32_t v23 = (v21 - 8) / 0x14uLL;
  }
  else {
    uint32_t v23 = v66;
  }
  if (!v23) {
    return 0;
  }
  if (v18) {
    unsigned int v24 = NXFindBestFatArch(v18->cputype, v18->cpusubtype, v67, v23);
  }
  else {
    unsigned int v24 = 0;
  }
  int v25 = a1;
  unsigned int v26 = a2;
  if (!v24 && v19) {
    unsigned int v24 = NXFindBestFatArch(v19, 0, v67, v23);
  }
  unsigned int v64 = v24;
  if (a6)
  {
    unsigned int v27 = v67;
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    uint64_t v29 = -(uint64_t)v23;
    do
    {
      CFNumberRef v30 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, v27);
      v69.CFIndex length = CFArrayGetCount(Mutable);
      v69.CFIndex location = 0;
      if (CFArrayGetFirstIndexOfValue(Mutable, v69, v30) < 0) {
        CFArrayAppendValue(Mutable, v30);
      }
      CFRelease(v30);
      ++v27;
    }
    while (!__CFADD__(v29++, 1));
    *a6 = Mutable;
    unsigned int v20 = a9;
    unsigned int v24 = v64;
  }
  if (v25 < 0
    || (v24 ? (unint64_t v32 = &v24->offset) : (unint64_t v32 = &v67[0].offset),
        (BOOL v37 = lseek(v25, *v32, 0) == *v32, v24 = v64, !v37)
     || (int v33 = (int *)v65, v34 = read(v25, v65, 0x20uLL) <= 31, v24 = v64, v34)))
  {
    p_offset = &v67[0].offset;
    if (v24) {
      p_offset = &v24->offset;
    }
    uint64_t v36 = *p_offset;
    int v33 = (int *)&v26[v36];
    BOOL v37 = v36 + 32 > (unint64_t)a3 || v33 == 0;
    if (v37) {
      return 0;
    }
  }
  uint64_t v38 = 0;
  int v40 = *v33;
  if (*v33 <= -17958195)
  {
    if (v40 != -822415874)
    {
      if (v40 == -805638658)
      {
        unsigned int v41 = v33[3];
        if (v63 && v41 == 0x2000000)
        {
          unsigned int v42 = &v67[0].offset;
          if (v24) {
            unsigned int v42 = &v24->offset;
          }
          *int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v42, 1, 1);
          unsigned int v24 = v64;
        }
        uint64_t v38 = bswap32(v41);
        if (v62)
        {
          int v43 = (int *)&v67[0].offset;
          if (v24) {
            int v43 = (int *)&v24->offset;
          }
          *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v43, 1, 1);
          unsigned int v24 = v64;
        }
        if (a8 || v20 || a10)
        {
          BOOL v44 = &v67[0].offset;
          if (v24) {
            BOOL v44 = &v24->offset;
          }
          unsigned int v45 = *v44;
          unsigned int v61 = a10;
          int v46 = v25;
          uint64_t v47 = (uint64_t)v26;
          uint64_t v48 = a3;
          int v49 = 1;
LABEL_120:
          int v57 = 1;
          goto LABEL_121;
        }
      }
      return v38;
    }
    unsigned int v53 = v33[3];
    if (v63 && v53 == 0x2000000)
    {
      unsigned int v54 = &v67[0].offset;
      if (v24) {
        unsigned int v54 = &v24->offset;
      }
      *int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v54, 1, 0);
      unsigned int v24 = v64;
    }
    uint64_t v38 = bswap32(v53);
    if (v62)
    {
      unint64_t v55 = (int *)&v67[0].offset;
      if (v24) {
        unint64_t v55 = (int *)&v24->offset;
      }
      *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v55, 1, 0);
      unsigned int v24 = v64;
    }
    if (!a8 && !v20 && !a10) {
      return v38;
    }
    long long v56 = &v67[0].offset;
    if (v24) {
      long long v56 = &v24->offset;
    }
    unsigned int v45 = *v56;
    unsigned int v61 = a10;
    int v46 = v25;
    uint64_t v47 = (uint64_t)v26;
    uint64_t v48 = a3;
    int v49 = 1;
LABEL_104:
    int v57 = 0;
LABEL_121:
    _CFBundleGrokObjcImageInfoFromFile(v46, v47, v48, v45, v49, v57, a8, v20, v61);
    return v38;
  }
  if (v40 != -17958193)
  {
    if (v40 != -17958194) {
      return v38;
    }
    uint64_t v38 = v33[3];
    if (v63 && v38 == 2)
    {
      BOOL v50 = &v67[0].offset;
      if (v24) {
        BOOL v50 = &v24->offset;
      }
      *int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v50, 0, 0);
      unsigned int v24 = v64;
    }
    if (v62)
    {
      unint64_t v51 = (int *)&v67[0].offset;
      if (v24) {
        unint64_t v51 = (int *)&v24->offset;
      }
      *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v51, 0, 0);
      unsigned int v24 = v64;
    }
    if (!a8 && !v20 && !a10) {
      return v38;
    }
    int v52 = &v67[0].offset;
    if (v24) {
      int v52 = &v24->offset;
    }
    unsigned int v45 = *v52;
    unsigned int v61 = a10;
    int v46 = v25;
    uint64_t v47 = (uint64_t)v26;
    uint64_t v48 = a3;
    int v49 = 0;
    goto LABEL_104;
  }
  uint64_t v38 = v33[3];
  if (v63 && v38 == 2)
  {
    int v58 = &v67[0].offset;
    if (v24) {
      int v58 = &v24->offset;
    }
    *int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v58, 0, 1);
    unsigned int v24 = v64;
  }
  if (v62)
  {
    unint64_t v59 = (int *)&v67[0].offset;
    if (v24) {
      unint64_t v59 = (int *)&v24->offset;
    }
    *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v59, 0, 1);
    unsigned int v24 = v64;
  }
  if (a8 || v20 || a10)
  {
    int v60 = &v67[0].offset;
    if (v24) {
      int v60 = &v24->offset;
    }
    unsigned int v45 = *v60;
    unsigned int v61 = a10;
    int v46 = v25;
    uint64_t v47 = (uint64_t)v26;
    uint64_t v48 = a3;
    int v49 = 0;
    goto LABEL_120;
  }
  return v38;
}

uint64_t _CFURLComponentsGetURLUserAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)sURLAllowedCharacterSets;
}

uint64_t _CFURLComponentsGetURLPasswordAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 8);
}

uint64_t _CFURLComponentsGetURLPortAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 48);
}

uint64_t (**__CFStringEncodingGetJapaneseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_2)
  {
    __CFStringEncodingIsDecomposableCharacter_2 = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter_2 = (_UNKNOWN *)a2(2);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_4 = (_UNKNOWN *)a2(3);
    __CFStringEncodingPrecomposeLatinCharacter_6 = (_UNKNOWN *)a2(4);
  }
  if (a1 > 2560)
  {
    switch(a1)
    {
      case 3056:
        return __CFConverterShiftJIS_NTT_Docomo;
      case 3057:
        return __CFConverterShiftJIS_KDDI;
      case 3058:
        return __CFConverterShiftJIS_SoftBank;
      case 3059:
        return 0;
      case 3060:
        return __CFConverterISO_2022_JP_KDDI;
      default:
        if (a1 == 2561)
        {
          uint64_t result = __CFConverterShiftJIS;
        }
        else
        {
          if (a1 != 2814) {
            return 0;
          }
          uint64_t result = __CFConverterAutoDetect_JP;
        }
        break;
    }
  }
  else
  {
    if (a1 > 2079)
    {
      if (a1 == 2080) {
        return __CFConverterISO_2022_JP;
      }
      if (a1 == 2336) {
        return __CFConverterEUC_JP;
      }
    }
    else
    {
      if (a1 == 1) {
        return __CFConverterMacJapanese;
      }
      if (a1 == 1056) {
        return __CFConverterDOSJapanese;
      }
    }
    return 0;
  }
  return result;
}

uint64_t __CFToDOSJapanese(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F) {
    goto LABEL_4;
  }
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    LOBYTE(a2) = a2 + 64;
LABEL_4:
    *a3 = a2;
    return 1;
  }
  if ((unsigned __int16)((unsigned __int16)(a2 + 23) >> 2) < 0x80Bu) {
    goto LABEL_12;
  }
  long long v4 = (unsigned __int16 *)&DOSJapanese_from_uni;
  CFURLRef v5 = (unsigned __int16 *)&unk_182EC8EDC;
  while (1)
  {
    uint64_t v6 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v5 - v4)) >> 1;
    int v7 = &v4[5 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    CFURLRef v5 = v7 - 5;
LABEL_11:
    if (v4 > v5) {
      goto LABEL_12;
    }
  }
  if (v8 + 4 <= a2)
  {
    long long v4 = v7 + 5;
    goto LABEL_11;
  }
  unsigned int v15 = v4[5 * v6 + 1 + (int)(a2 - v8)];
  if (v15)
  {
    unsigned int v16 = v15 >> 8;
LABEL_37:
    *a3 = v16;
    a3[1] = v15;
    return 2;
  }
LABEL_12:
  if ((unsigned __int16)(a2 + 12) < 0xACu) {
    return 0;
  }
  CFAllocatorRef v9 = (unsigned __int16 *)&__CFToJISCharMap;
  unsigned int v10 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (2)
  {
    uint64_t v11 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v10 - v9)) >> 1;
    unint64_t v12 = &v9[17 * v11];
    unsigned int v13 = *v12;
    if (v13 > a2)
    {
      unsigned int v10 = v12 - 17;
      goto LABEL_18;
    }
    if (v13 + 16 <= a2)
    {
      CFAllocatorRef v9 = v12 + 17;
LABEL_18:
      if (v9 > v10) {
        goto LABEL_19;
      }
      continue;
    }
    break;
  }
  unsigned int v17 = v9[17 * v11 + 1 + (int)(a2 - v13)];
  if (v17 && (unsigned __int16)(v17 - 256) <= 0x7431u && (unsigned __int16)(v17 - 12111) <= 0xF9D1u)
  {
    unsigned int v18 = v17 >> 8;
    int v19 = v17 & 0x7F;
    if ((v17 & 0x100) != 0) {
      int v20 = 31;
    }
    else {
      int v20 = 125;
    }
    unsigned int v15 = v20 + v19;
    unsigned int v16 = (v18 + 479) >> 1;
    char v21 = v16 - 127;
    unsigned int v22 = (v16 - 127);
    if (v15 > 0x7E) {
      LOBYTE(v15) = v15 + 1;
    }
    LOBYTE(v16) = v16 - 63;
    if (v22 <= 0x9F) {
      LOBYTE(v16) = v21;
    }
    goto LABEL_37;
  }
LABEL_19:
  if ((unsigned __int16)(a2 + 0x2000) > 0x757u) {
    return 0;
  }
  if ((a2 - 57344) % 0xBC <= 0x3E) {
    unsigned int v14 = a2 + 68 * ((a2 - 57344) / 0xBC);
  }
  else {
    unsigned int v14 = a2 + 68 * ((a2 - 57344) / 0xBC) + 1;
  }
  *(_WORD *)a3 = bswap32(v14 + 4160) >> 16;
  return 2;
}

uint64_t __CFFromDOSJapanese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  int v5 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    *a4 = v5;
    return 1;
  }
  if ((v5 + 95) <= 0x3Eu)
  {
    *a4 = v5 - 320;
    return 1;
  }
  if (a3 < 2) {
    return 0;
  }
  int v7 = a2[1];
  unsigned int v8 = v7 | (v5 << 8);
  if ((int)v8 <= 33147)
  {
    switch(v8)
    {
      case 0x815Cu:
        __int16 v9 = 8213;
        goto LABEL_29;
      case 0x815Du:
      case 0x815Eu:
      case 0x815Fu:
      case 0x8162u:
        goto LABEL_20;
      case 0x8160u:
        __int16 v9 = -162;
        goto LABEL_29;
      case 0x8161u:
        __int16 v9 = 8741;
        goto LABEL_29;
      case 0x8163u:
        __int16 v9 = 8230;
        goto LABEL_29;
      default:
        if (v8 != 33104) {
          goto LABEL_20;
        }
        __int16 v9 = -29;
        break;
    }
    goto LABEL_29;
  }
  if ((int)v8 > 33169)
  {
    if (v8 == 33170)
    {
      __int16 v9 = -31;
      goto LABEL_29;
    }
    if (v8 == 33226)
    {
      __int16 v9 = -30;
      goto LABEL_29;
    }
  }
  else
  {
    if (v8 == 33148)
    {
      __int16 v9 = -243;
      goto LABEL_29;
    }
    if (v8 == 33169)
    {
      __int16 v9 = -32;
LABEL_29:
      *a4 = v9;
      return 2;
    }
  }
LABEL_20:
  if (v7 != 127 && (v5 + 6) >= 0xF6u && (v7 + 3) >= 0x43u)
  {
    __int16 v9 = v8 - 68 * (v5 & 0xF) + ((char)v7 >> 7) - 4160;
    goto LABEL_29;
  }
  if (v8 >> 6 <= 0x3B4 && v8 - 34624 > 0x5C)
  {
    unsigned int v10 = ShiftJISToJIS0208(a2);
    int v11 = __CFFromJIS0208(v10);
    *a4 = v11;
    return 2 * (v11 != 65533);
  }
  if (v8 > 0xFC60 || v8 >> 6 < 0x21D)
  {
LABEL_42:
    *a4 = 0;
    return 0;
  }
  unint64_t v12 = (unsigned __int16 *)&DOSJapanese_to_uni;
  unsigned int v13 = (unsigned __int16 *)&unk_182ED3294;
  while (1)
  {
    uint64_t v14 = (0xF83E0F83E0F83E1 * (v13 - v12)) >> 1;
    unsigned int v15 = &v12[33 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v8) {
      break;
    }
    unsigned int v13 = v15 - 33;
LABEL_41:
    if (v12 > v13) {
      goto LABEL_42;
    }
  }
  if (v16 + 32 <= v8)
  {
    unint64_t v12 = v15 + 33;
    goto LABEL_41;
  }
  __int16 v17 = v12[33 * v14 + 1 + (int)(v8 - v16)];
  *a4 = v17;
  if (!v17) {
    return 0;
  }
  return 2;
}

uint64_t __CFToShiftJISLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    unsigned int v5 = *a2++;
    unsigned int v4 = v5;
    if ((unsigned __int16)(v5 + 159) >= 0x3Fu && v4 >= 0xA5) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = 1;
    }
    result += v7;
  }
  return result;
}

uint64_t __CFFromShiftJISLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t result = 0;
    while (1)
    {
      if (((char)*a2 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      if (*a2 < 0xA1u) {
        break;
      }
      uint64_t v4 = -1;
      if ((unint64_t)a3 >= 2)
      {
        uint64_t v5 = 1;
        if (*a2 < 0xE0u) {
          goto LABEL_6;
        }
LABEL_14:
        uint64_t v4 = -2;
        uint64_t v5 = 2;
        goto LABEL_6;
      }
LABEL_5:
      uint64_t v5 = 1;
LABEL_6:
      a2 += v5;
      ++result;
      BOOL v6 = __OFADD__(a3, v4);
      a3 += v4;
      if ((a3 < 0) ^ v6 | (a3 == 0)) {
        return result;
      }
    }
    if ((unint64_t)a3 >= 2) {
      goto LABEL_14;
    }
LABEL_4:
    uint64_t v4 = -1;
    goto LABEL_5;
  }
  return 0;
}

uint64_t __CFFromShiftJISFallback(char *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1;
  if (*a1 > -1 || a2 < 2) {
    return 1;
  }
  else {
    return 2;
  }
}

uint64_t __CFToShiftJISPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  uint64_t v9 = __CFPrecomposeCharJapanese(a2, 0);
  int v10 = __CFToShiftJIS(v9, v9, v13);
  uint64_t result = 0;
  if (v10)
  {
    char v12 = v13[0];
    if (v13[0])
    {
      uint64_t result = 2;
      *a6 = 2;
      if (a5)
      {
        if (a5 >= 2)
        {
          *a4 = v12;
          a4[1] = v13[1];
          return 2;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL __CFIsValidCombiningCharJapanese(int a1)
{
  BOOL result = 1;
  if ((a1 - 774) > 0x32 || ((1 << (a1 - 6)) & 0x4000000000005) == 0) {
    return (a1 - 12441) < 2;
  }
  return result;
}

uint64_t __CFToJIS(unsigned int a1, int a2)
{
  if ((unsigned __int16)(a1 + 12) < 0xACu) {
    return 65533;
  }
  BOOL v2 = (unsigned __int16 *)&__CFToJISCharMap;
  BOOL v3 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    uint64_t v4 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v3 - v2)) >> 1;
    uint64_t v5 = &v2[17 * v4];
    unsigned int v6 = *v5;
    if (v6 <= a1) {
      break;
    }
    BOOL v3 = v5 - 17;
LABEL_7:
    if (v2 > v3) {
      return 65533;
    }
  }
  if (v6 + 16 <= a1)
  {
    BOOL v2 = v5 + 17;
    goto LABEL_7;
  }
  uint64_t v8 = v2[17 * v4 + 1 + (int)(a1 - v6)];
  if (!v8) {
    return 65533;
  }
  if (!a2) {
    return v8;
  }
  uint64_t result = 65533;
  if (v8 <= 0x7531 && (v8 - 10529) >= 0x62E) {
    return v8;
  }
  return result;
}

uint64_t JIS0208ToShiftJIS(uint64_t result, unsigned char *a2)
{
  if ((result & 0x100) != 0) {
    int v2 = 31;
  }
  else {
    int v2 = 125;
  }
  unsigned int v3 = v2 + (result & 0x7F);
  unsigned int v4 = ((result >> 8) + 479) >> 1;
  char v5 = v4 - 127;
  unsigned int v6 = (v4 - 127);
  if (v3 > 0x7E) {
    LOBYTE(v3) = v3 + 1;
  }
  char v7 = v4 - 63;
  if (v6 <= 0x9F) {
    char v7 = v5;
  }
  *a2 = v7;
  a2[1] = v3;
  return result;
}

uint64_t __CFFromJIS0208(unsigned int a1)
{
  if (a1 - 30067 < 0xFFFFABAE) {
    return (unsigned __int16)-3;
  }
  unsigned int v1 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
  int v2 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
  while (1)
  {
    uint64_t v3 = (0xF83E0F83E0F83E1 * (v2 - v1)) >> 1;
    unsigned int v4 = &v1[33 * v3];
    unsigned int v5 = *v4;
    if (v5 <= a1) {
      break;
    }
    int v2 = v4 - 33;
LABEL_7:
    if (v1 > v2) {
      return (unsigned __int16)-3;
    }
  }
  if (v5 + 32 <= a1)
  {
    unsigned int v1 = v4 + 33;
    goto LABEL_7;
  }
  unsigned __int16 v6 = v1[33 * v3 + 1 + (int)(a1 - v5)];
  if (!v6) {
    return (unsigned __int16)-3;
  }
  return v6;
}

uint64_t ShiftJISToJIS0208(unsigned __int8 *a1)
{
  unsigned int v1 = *a1;
  if (v1 >= 0xA0) {
    __int16 v2 = 79;
  }
  else {
    __int16 v2 = 15;
  }
  __int16 v3 = v2 + v1;
  unsigned int v4 = (a1[1] + ((char)a1[1] >> 7));
  BOOL v5 = v4 > 0x9D;
  if (v4 <= 0x9D) {
    __int16 v6 = (2 * (v3 & 0x1FF)) | 1;
  }
  else {
    __int16 v6 = 2 * v3 + 2;
  }
  if (v5) {
    char v7 = -125;
  }
  else {
    char v7 = -31;
  }
  return (unsigned __int16)((v7 + a1[1] + ((char)a1[1] >> 7)) | (unsigned __int16)((v6 & 0x7FF) << 8));
}

uint64_t __CFToShiftJIS(uint64_t a1, unsigned int a2, char *a3)
{
  if ((int)a2 <= 164)
  {
    if (a2 == 92)
    {
      LOWORD(v5) = 24449;
      goto LABEL_11;
    }
    if (a2 == 126) {
      return 0;
    }
    goto LABEL_8;
  }
  if (a2 == 165)
  {
    char v4 = 92;
    goto LABEL_16;
  }
  if (a2 == 8254)
  {
    char v4 = 126;
LABEL_16:
    *a3 = v4;
    return 1;
  }
LABEL_8:
  if (a2 <= 0x7F)
  {
    *a3 = a2;
    return 1;
  }
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    char v4 = a2 + 64;
    goto LABEL_16;
  }
  if ((unsigned __int16)(a2 + 12) < 0xACu) {
    return 0;
  }
  __int16 v6 = (unsigned __int16 *)&__CFToJISCharMap;
  char v7 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    uint64_t v8 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v7 - v6)) >> 1;
    uint64_t v9 = &v6[17 * v8];
    unsigned int v10 = *v9;
    if (v10 <= a2) {
      break;
    }
    char v7 = v9 - 17;
LABEL_24:
    if (v6 > v7) {
      goto LABEL_33;
    }
  }
  if (v10 + 16 <= a2)
  {
    __int16 v6 = v9 + 17;
    goto LABEL_24;
  }
  uint64_t v11 = v6[17 * v8 + 1 + (int)(a2 - v10)];
  if (v6[17 * v8 + 1 + (int)(a2 - v10)]) {
    BOOL v12 = v11 > 0x7531;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12 && (unsigned __int16)(v11 - 10529) >= 0x62Eu)
  {
    if (v11 < 0x100) {
      return 0;
    }
    JIS0208ToShiftJIS(v11, a3);
    return 2;
  }
LABEL_33:
  if ((unsigned __int16)(a2 + 0x2000) > 0x98Bu) {
    return 0;
  }
  if ((a2 - 57344) % 0xBC <= 0x3E) {
    unsigned int v13 = a2 + 68 * ((a2 - 57344) / 0xBC);
  }
  else {
    unsigned int v13 = a2 + 68 * ((a2 - 57344) / 0xBC) + 1;
  }
  unsigned int v5 = bswap32(v13 + 4160) >> 16;
LABEL_11:
  *(_WORD *)a3 = v5;
  return 2;
}

uint64_t __CFPrecomposeCharJapanese(unsigned __int16 *a1, int a2)
{
  int v2 = *a1;
  unsigned int v3 = a1[1];
  if (v3 > 0x337)
  {
    if (v3 == 824)
    {
      if (v2 == 61) {
        return 8800;
      }
    }
    else
    {
      if (v3 != 12441)
      {
        if (v3 == 12442
          && ((v2 - 12399) <= 0xC && ((1 << (v2 - 111)) & 0x1249) != 0
           || (v2 - 12495) <= 0xC && ((1 << (v2 + 49)) & 0x1249) != 0))
        {
          return (unsigned __int16)(v2 + 2);
        }
        return (unsigned __int16)-3;
      }
      if (*a1 > 0x309Cu)
      {
        uint64_t v6 = (v2 - 12445);
        if (v6 > 0x3E) {
          goto LABEL_32;
        }
        if (((1 << (v2 + 99)) & 0x49240A9555554001) == 0)
        {
          if (v6 == 9)
          {
            BOOL v7 = a2 == 0;
            unsigned __int16 v8 = 12532;
            goto LABEL_41;
          }
LABEL_32:
          switch(*a1)
          {
            case 0x30EFu:
              BOOL v7 = a2 == 0;
              unsigned __int16 v8 = 12535;
              goto LABEL_41;
            case 0x30F0u:
              BOOL v7 = a2 == 0;
              unsigned __int16 v8 = 12536;
              goto LABEL_41;
            case 0x30F1u:
              BOOL v7 = a2 == 0;
              unsigned __int16 v8 = 12537;
              goto LABEL_41;
            case 0x30F2u:
              BOOL v7 = a2 == 0;
              unsigned __int16 v8 = 12538;
              goto LABEL_41;
            default:
              if (v2 != 12541) {
                return (unsigned __int16)-3;
              }
              BOOL v7 = a2 == 0;
              unsigned __int16 v8 = 12542;
              break;
          }
          goto LABEL_41;
        }
        return (unsigned __int16)(v2 + 1);
      }
      if ((v2 - 12358) <= 0x35)
      {
        if (((1 << (v2 - 70)) & 0x2492054AAAAAA0) != 0) {
          return (unsigned __int16)(v2 + 1);
        }
        if (v2 == 12358)
        {
          BOOL v7 = a2 == 0;
          unsigned __int16 v8 = 12436;
LABEL_41:
          if (v7) {
            return (unsigned __int16)-3;
          }
          else {
            return v8;
          }
        }
      }
    }
    return (unsigned __int16)-3;
  }
  if (v3 == 774)
  {
    if ((v2 & 0xFFFFFFDF) == 0x418) {
      return (unsigned __int16)(v2 + 1);
    }
    return (unsigned __int16)-3;
  }
  if (v3 != 776) {
    return (unsigned __int16)-3;
  }
  if (v2 == 1077) {
    unsigned __int16 v4 = 1105;
  }
  else {
    unsigned __int16 v4 = -3;
  }
  if (v2 == 1045) {
    return 1025;
  }
  else {
    return v4;
  }
}

uint64_t __CFToEUC_JP(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    *a3 = a2;
    return 1;
  }
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    *a3 = -114;
    LOBYTE(v4) = a2 + 64;
    goto LABEL_5;
  }
  if ((unsigned __int16)(a2 + 12) < 0xACu) {
    return 0;
  }
  unsigned int v5 = (unsigned __int16 *)&__CFToJISCharMap;
  uint64_t v6 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    uint64_t v7 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v6 - v5)) >> 1;
    unsigned __int16 v8 = &v5[17 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 17;
LABEL_13:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 + 16 <= a2)
  {
    unsigned int v5 = v8 + 17;
    goto LABEL_13;
  }
  int v10 = v5[17 * v7 + 1 + (int)(a2 - v9)];
  if (!v10) {
    return 0;
  }
  uint64_t result = 0;
  if ((v10 - 30002) >= 0xFFFF8BCE && (v10 - 10529) >= 0x62E)
  {
    __int16 v4 = v10 | 0x8080;
    *a3 = HIBYTE(v4);
LABEL_5:
    a3[1] = v4;
    return 2;
  }
  return result;
}

uint64_t __CFFromEUC_JP(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  int v4 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1;
  }
  switch(v4)
  {
    case 160:
      if (a3 < 2) {
        return 0;
      }
      __int16 v6 = 169;
      goto LABEL_10;
    case 143:
      if (a3 < 3) {
        return 0;
      }
      unsigned int v7 = *(unsigned __int16 *)(a2 + 1);
      if ((unsigned __int16)((bswap32(v7) >> 16) + 4638) >= 0xB4CDu)
      {
        unsigned int v8 = __rev16(v7);
        unsigned int v9 = (unsigned __int16 *)&__CFFromJIS0212CharMap;
        int v10 = (unsigned __int16 *)((char *)&__CFFromJIS0212CharMap + 13002);
        do
        {
          uint64_t v11 = (0xF83E0F83E0F83E1 * (v10 - v9)) >> 1;
          BOOL v12 = &v9[33 * v11];
          unsigned int v13 = *v12;
          if (v13 <= v8)
          {
            if (v13 + 32 > v8)
            {
              uint64_t v20 = (uint64_t)&v9[33 * v11 + (int)(v8 - v13)];
              goto LABEL_32;
            }
            unsigned int v9 = v12 + 33;
          }
          else
          {
            int v10 = v12 - 33;
          }
        }
        while (v9 <= v10);
      }
      goto LABEL_35;
    case 142:
      if (a3 < 2) {
        return 0;
      }
      __int16 v6 = a2[1] - 320;
LABEL_10:
      *a4 = v6;
      return 2;
  }
  if (a3 < 2) {
    return 0;
  }
  unsigned int v14 = a2[1] & 0x7F | ((v4 & 0x7F) << 8);
  if ((unsigned __int16)(v14 - 30067) < 0xABAEu) {
    goto LABEL_35;
  }
  unsigned int v15 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
  unsigned int v16 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
  while (1)
  {
    uint64_t v17 = (0xF83E0F83E0F83E1 * (v16 - v15)) >> 1;
    unsigned int v18 = &v15[33 * v17];
    unsigned int v19 = *v18;
    if (v19 <= v14) {
      break;
    }
    unsigned int v16 = v18 - 33;
LABEL_28:
    if (v15 > v16) {
      goto LABEL_35;
    }
  }
  if (v19 + 32 <= v14)
  {
    unsigned int v15 = v18 + 33;
    goto LABEL_28;
  }
  uint64_t v20 = (uint64_t)&v15[33 * v17 + (int)(v14 - v19)];
LABEL_32:
  unsigned __int16 v21 = *(_WORD *)(v20 + 2);
  if (!v21)
  {
LABEL_35:
    *a4 = -3;
    return 0;
  }
  *a4 = v21;
  if (v21 != 65533) {
    return 2;
  }
  return 0;
}

unint64_t __CFToEUC_JPLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3)
  {
    unint64_t v7 = 0;
    unint64_t v3 = 0;
    unint64_t v4 = 0;
LABEL_13:
    unint64_t v9 = v3 - v7;
    unint64_t v8 = 3 * v7 + v4;
    return v8 + 2 * v9;
  }
  unint64_t v3 = 0;
  unint64_t v4 = 0;
  do
  {
    unsigned int v6 = *a2++;
    unsigned int v5 = v6;
    if (v6 < 0x80) {
      ++v4;
    }
    if (v5 > 0x7F) {
      ++v3;
    }
    --a3;
  }
  while (a3);
  unint64_t v7 = v3 / 3;
  if (v4 <= v3 / 3) {
    goto LABEL_13;
  }
  unint64_t v8 = v4 - v7;
  if (v3 < 3) {
    unint64_t v7 = 1;
  }
  unint64_t v9 = v7 + v3;
  return v8 + 2 * v9;
}

uint64_t __CFFromEUC_JPLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    uint64_t v4 = -1;
    if (a3 == 1)
    {
      uint64_t v12 = 1;
    }
    else
    {
      int v5 = *a2;
      BOOL v6 = v5 == -113;
      BOOL v7 = (unint64_t)a3 > 2;
      BOOL v8 = !v7 || !v6;
      if (v7 && v6) {
        uint64_t v9 = 3;
      }
      else {
        uint64_t v9 = 2;
      }
      if (v8) {
        uint64_t v10 = -2;
      }
      else {
        uint64_t v10 = -3;
      }
      BOOL v11 = v5 >= 0;
      if (v5 < 0) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 1;
      }
      if (!v11) {
        uint64_t v4 = v10;
      }
    }
    a2 += v12;
    ++result;
    BOOL v13 = __OFADD__(a3, v4);
    a3 += v4;
  }
  while (!((a3 < 0) ^ v13 | (a3 == 0)));
  return result;
}

uint64_t __CFFromEUC_JPFallback(unsigned __int8 *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1;
  int v5 = *a1;
  int v6 = (char)v5;
  BOOL v7 = v5 != 143 || a2 <= 2;
  uint64_t v8 = 2;
  if (!v7) {
    uint64_t v8 = 3;
  }
  if (v6 > -1 || a2 < 2) {
    return 1;
  }
  else {
    return v8;
  }
}

uint64_t __CFToEUC_JPPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  if (*a2 > 0x7Fu) {
    uint64_t v9 = __CFPrecomposeCharJapanese(a2, 0);
  }
  else {
    uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_6(a2, a3, 0);
  }
  int v10 = __CFToEUC_JP(v9, v9, v13);
  uint64_t result = 0;
  if (v10)
  {
    char v12 = v13[0];
    if (v13[0])
    {
      uint64_t result = 2;
      *a6 = 2;
      if (a5)
      {
        if (a5 >= 2)
        {
          *a4 = v12;
          a4[1] = v13[1];
          return 2;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t __CFIsValidCombiningCharJapaneseWithJIS212(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1 << (a1 - 6)) & 0x4000000000005) != 0
    || (a1 - 12441) < 2)
  {
    return 1;
  }
  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_4();
  }
}

uint64_t __CFToISO_2022_JP(char a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v8 = 0;
    uint64_t v46 = 0;
    goto LABEL_142;
  }
  uint64_t v8 = a3;
  unsigned int v53 = a6;
  uint64_t v9 = a2 - 2;
  uint64_t v54 = a2;
  while (2)
  {
    BOOL v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    while (2)
    {
      if (a5 && a5 <= v11)
      {
        if ((a1 & 0x10) == 0) {
          goto LABEL_116;
        }
        unsigned int v14 = *(unsigned __int16 *)(a2 + 2 * v12);
        BOOL v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
        if (v15 && v14 - 12441 >= 2) {
          goto LABEL_116;
        }
      }
      else
      {
        unsigned int v14 = *(unsigned __int16 *)(a2 + 2 * v12);
        if (v14 <= 0x7F)
        {
          BOOL v10 = v13 != 0;
          if (v13) {
            uint64_t v17 = 4;
          }
          else {
            uint64_t v17 = 1;
          }
          if (!a5)
          {
            unsigned int v13 = 0;
            goto LABEL_114;
          }
          if (a5 - v11 >= v17)
          {
            if (v13)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16936;
              a4 += 3;
            }
            unsigned int v13 = 0;
            *a4++ = v14;
            goto LABEL_114;
          }
          goto LABEL_116;
        }
      }
      if ((unsigned __int16)(v14 + 159) <= 0x3Eu)
      {
        BOOL v10 = v13 != 3;
        if (v13 == 3) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = 4;
        }
        if (a5)
        {
          if (a5 - v11 < v17) {
            goto LABEL_116;
          }
          if (v13 != 3)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18728;
            a4 += 3;
          }
          *a4++ = v14 - 64;
        }
        unsigned int v13 = 3;
        goto LABEL_114;
      }
      if (v14 == 8254 || v14 == 165)
      {
        BOOL v10 = v13 != 2;
        if (v13 == 2) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = 4;
        }
        if (a5)
        {
          if (a5 - v11 < v17) {
            goto LABEL_116;
          }
          if (v13 != 2)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18984;
            a4 += 3;
          }
          if (v14 == 165) {
            char v18 = 92;
          }
          else {
            char v18 = 126;
          }
          *a4++ = v18;
        }
        unsigned int v13 = 2;
        goto LABEL_114;
      }
      if ((unsigned __int16)(v14 + 12) < 0xACu) {
        break;
      }
      unsigned int v19 = (unsigned __int16 *)&__CFToJISCharMap;
      uint64_t v20 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
      while (1)
      {
        uint64_t v21 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v20 - v19)) >> 1;
        unsigned int v22 = &v19[17 * v21];
        unsigned int v23 = *v22;
        if (v23 <= v14) {
          break;
        }
        uint64_t v20 = v22 - 17;
LABEL_55:
        if (v19 > v20) {
          goto LABEL_72;
        }
      }
      if (v23 + 16 <= v14)
      {
        unsigned int v19 = v22 + 17;
        goto LABEL_55;
      }
      unsigned int v24 = v19[17 * v21 + 1 + (int)(v14 - v23)];
      if (v19[17 * v21 + 1 + (int)(v14 - v23)]) {
        BOOL v25 = v24 > 0x7531;
      }
      else {
        BOOL v25 = 1;
      }
      if (!v25 && v24 - 10529 >= 0x62E)
      {
        if (v24 < 0x100) {
          goto LABEL_116;
        }
        BOOL v10 = v13 != 1;
        if (v13 == 1) {
          uint64_t v17 = 2;
        }
        else {
          uint64_t v17 = 5;
        }
        if (!a5) {
          goto LABEL_102;
        }
        if (a5 - v11 < v17) {
          goto LABEL_116;
        }
        if (v13 != 1)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 16932;
          a4 += 3;
        }
        *a4 = BYTE1(v24);
        a4[1] = v24 & 0x7F;
        a4 += 2;
LABEL_102:
        unsigned int v13 = 1;
LABEL_114:
        v11 += v17;
        if (++v12 == v8)
        {
LABEL_117:
          unsigned int v45 = (uint64_t (**)(void))&unk_1EC093000;
          if (v13) {
            goto LABEL_118;
          }
LABEL_139:
          uint64_t v46 = v11;
          goto LABEL_141;
        }
        continue;
      }
      break;
    }
LABEL_72:
    if ((a1 & 8) != 0) {
      goto LABEL_116;
    }
    if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2)
    {
      int IsValidCombiningCharacterForLatin1_4 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4();
      a2 = v54;
      if (!IsValidCombiningCharacterForLatin1_4) {
        goto LABEL_116;
      }
    }
    if ((a1 & 0x10) == 0)
    {
      uint64_t v17 = 0;
      goto LABEL_114;
    }
    if (!v12)
    {
      uint64_t v8 = 0;
      goto LABEL_117;
    }
    uint64_t v27 = a2 + 2 * v12;
    unsigned int v29 = *(unsigned __int16 *)(v27 - 2);
    unsigned int v28 = (unsigned __int16 *)(v27 - 2);
    if (v29 > 0x7F) {
      unsigned int v30 = __CFPrecomposeCharJapanese(v28, 0);
    }
    else {
      unsigned int v30 = __CFStringEncodingPrecomposeLatinCharacter_6(v28, v8 + 1 - v12, 0);
    }
    int v31 = __CFToJIS(v30, 1);
    if (v31 && v31 != 65533)
    {
      __int16 v32 = v31;
      a2 = v54;
      if (((__int16)v31 & 0x80000000) == 0)
      {
        if (v13 == 1)
        {
          uint64_t v17 = 0;
          int v33 = 0;
          BOOL v10 = 0;
          uint64_t v34 = 2;
          if (!a5) {
            goto LABEL_102;
          }
        }
        else
        {
          if (v13) {
            uint64_t v34 = 2;
          }
          else {
            uint64_t v34 = 1;
          }
          if (v10) {
            v34 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1;
          }
          uint64_t v17 = 5 - v34;
          BOOL v10 = 1;
          int v33 = &off_1ECDFDDD8;
          if (!a5) {
            goto LABEL_102;
          }
        }
        if (a5 - v11 >= v17)
        {
          BOOL v37 = &a4[-v34];
          if (v13 != 1)
          {
            *BOOL v37 = 27;
            __int16 v38 = v32;
            unsigned int v39 = v33;
            int v40 = strncpy(v37 + 1, *v33, *((unsigned __int8 *)v33 + 8));
            __int16 v32 = v38;
            a2 = v54;
            BOOL v37 = &v40[*((unsigned __int8 *)v39 + 8)];
          }
          *BOOL v37 = HIBYTE(v32);
          a4 = v37 + 2;
          v37[1] = v32 & 0x7F;
          goto LABEL_102;
        }
        goto LABEL_116;
      }
      if (v13 == 4)
      {
        uint64_t v17 = 0;
        unint64_t v35 = 0;
        BOOL v10 = 0;
        uint64_t v36 = 2;
        if (!a5)
        {
LABEL_113:
          unsigned int v13 = 4;
          goto LABEL_114;
        }
      }
      else
      {
        if (v13) {
          uint64_t v36 = 2;
        }
        else {
          uint64_t v36 = 1;
        }
        if (v10) {
          v36 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1;
        }
        uint64_t v17 = 6 - v36;
        BOOL v10 = 1;
        unint64_t v35 = &off_1ECDFDE08;
        if (!a5) {
          goto LABEL_113;
        }
      }
      if (a5 - v11 >= v17)
      {
        unsigned int v41 = &a4[-v36];
        if (v13 != 4)
        {
          *unsigned int v41 = 27;
          __int16 v42 = v32;
          int v43 = v35;
          BOOL v44 = strncpy(v41 + 1, *v35, *((unsigned __int8 *)v35 + 8));
          __int16 v32 = v42;
          a2 = v54;
          unsigned int v41 = &v44[*((unsigned __int8 *)v43 + 8)];
        }
        *unsigned int v41 = HIBYTE(v32) & 0x7F;
        a4 = v41 + 2;
        v41[1] = v32 & 0x7F;
        goto LABEL_113;
      }
LABEL_116:
      uint64_t v8 = v12;
      goto LABEL_117;
    }
    uint64_t v8 = v12;
    a2 = v54;
    unsigned int v45 = (uint64_t (**)(void))&unk_1EC093000;
    if (!v13) {
      goto LABEL_139;
    }
LABEL_118:
    uint64_t v46 = v11 + 3;
    if (a5)
    {
      if (v46 <= a5)
      {
        *a4 = 27;
        *(_WORD *)(a4 + 1) = 16936;
        break;
      }
      do
      {
        uint64_t v47 = v8;
        int v48 = *(unsigned __int16 *)(v9 + 2 * v8);
        if (((v48 - 774) > 0x32 || ((1 << (v48 - 6)) & 0x4000000000005) == 0)
          && (v48 - 12441) >= 2)
        {
          char v51 = v45[439]();
          a2 = v54;
        }
        else
        {
          char v51 = 1;
        }
        --v8;
      }
      while (v47 >= 2 && (v51 & 1) != 0);
      if (v47 < 2)
      {
        uint64_t v46 = 0;
        break;
      }
      a4 -= v11;
      continue;
    }
    break;
  }
LABEL_141:
  a6 = v53;
LABEL_142:
  *a6 = v46;
  return v8;
}

uint64_t __CFFromISO_2022_JP(unsigned int a1, const char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, void *a6)
{
  int v6 = a6;
  unint64_t v7 = (unint64_t)&a2[a3];
  if (__CFADD__(a2, a3))
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    if (a6) {
      goto LABEL_101;
    }
    return v9;
  }
  unint64_t v10 = a3;
  if (a3 < 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_101;
  }
  unsigned int v13 = a2;
  uint64_t v14 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v44 = a1 & 0xC0;
  while (2)
  {
    if (a5 && v8 >= a5) {
      goto LABEL_93;
    }
    int v15 = *(unsigned __int8 *)v13;
    if (v15 == 27)
    {
      uint64_t v46 = a4;
      unint64_t v47 = v10;
      uint64_t v16 = v9;
      uint64_t v17 = a5;
      uint64_t v18 = v8;
      uint64_t v19 = v14;
      for (uint64_t i = 0; i != 18; i += 2)
      {
        uint64_t v21 = LOBYTE((&__CFISO2022JPSequences)[i + 1]);
        if (v7 >= (unint64_t)&v13[v21 + 1]
          && !strncmp((&__CFISO2022JPSequences)[i], v13 + 1, LOBYTE((&__CFISO2022JPSequences)[i + 1])))
        {
          uint64_t v14 = *((unsigned __int8 *)&__CFISO2022JPSequences + 8 * i + 9);
          uint64_t v23 = v21 + 1;
          uint64_t v8 = v18;
          a5 = v17;
          uint64_t v9 = v16;
          a4 = v46;
          unint64_t v10 = v47;
          goto LABEL_85;
        }
      }
      uint64_t v14 = v19;
      if ((v19 & 0xFD) == 0)
      {
        uint64_t v22 = v18;
        a5 = v17;
        if (v17)
        {
          *uint64_t v46 = 27;
          a4 = v46 + 1;
          uint64_t v9 = v16;
        }
        else
        {
          uint64_t v9 = v16;
          a4 = v46;
        }
        unint64_t v10 = v47;
        uint64_t v8 = v22 + 1;
        uint64_t v23 = 1;
        goto LABEL_85;
      }
      uint64_t v8 = v18;
      a5 = v17;
      uint64_t v9 = v16;
      unint64_t v10 = v47;
      goto LABEL_93;
    }
    switch((int)v14)
    {
      case 0:
        if (!a5) {
          goto LABEL_43;
        }
        goto LABEL_42;
      case 1:
        if (v10 < 2) {
          goto LABEL_92;
        }
        unsigned int v24 = *((unsigned __int8 *)v13 + 1) | (v15 << 8);
        if (v24 - 30067 < 0xFFFFABAE) {
          goto LABEL_58;
        }
        BOOL v25 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
        unsigned int v26 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
        while (2)
        {
          uint64_t v27 = (0xF83E0F83E0F83E1 * (v26 - v25)) >> 1;
          unsigned int v28 = &v25[33 * v27];
          unsigned int v29 = *v28;
          if (v29 <= v24)
          {
            if (v29 + 32 > v24)
            {
              unsigned __int16 v37 = v25[33 * v27 + 1 + (int)(v24 - v29)];
              if (v37 == 65533 || v37 == 0)
              {
LABEL_58:
                if ((a1 & 1) == 0) {
                  goto LABEL_91;
                }
                unsigned __int16 v37 = 63;
              }
              if (!v44 || !__CFStringEncodingIsDecomposableCharacter_2(v37, (a1 >> 7) & 1))
              {
                if (a5) {
                  *a4++ = v37;
                }
                uint64_t v23 = 2;
                goto LABEL_84;
              }
              if (!a5)
              {
                ++v8;
                uint64_t v23 = 2;
                goto LABEL_84;
              }
              if (v8 + 2 <= a5)
              {
                __CFStringEncodingDecomposeCharacter_2(a1, v37, a4);
                ++v8;
                uint64_t v23 = 2;
                a4 += 2;
                goto LABEL_84;
              }
              return v9;
            }
            BOOL v25 = v28 + 33;
          }
          else
          {
            unsigned int v26 = v28 - 33;
          }
          if (v25 > v26) {
            goto LABEL_58;
          }
          continue;
        }
      case 2:
        if (!a5) {
          goto LABEL_43;
        }
        if (v15 == 126) {
          __int16 v30 = 8254;
        }
        else {
          __int16 v30 = *(unsigned __int8 *)v13;
        }
        if (v15 == 92) {
          LOWORD(v15) = 165;
        }
        else {
          LOWORD(v15) = v30;
        }
        goto LABEL_42;
      case 3:
        if ((v15 - 96) < 0xFFFFFFC1) {
          goto LABEL_91;
        }
        if (!a5) {
          goto LABEL_43;
        }
        LOWORD(v15) = v15 - 192;
LABEL_42:
        *a4++ = v15;
LABEL_43:
        uint64_t v23 = 1;
        goto LABEL_84;
      case 4:
        if (v10 < 2)
        {
LABEL_92:
          LODWORD(v14) = 4;
          unint64_t v10 = 1;
          goto LABEL_93;
        }
        unsigned int v31 = *((unsigned __int8 *)v13 + 1) | (v15 << 8);
        if ((unsigned __int16)(v31 + 4638) < 0xB4CDu) {
          goto LABEL_73;
        }
        __int16 v32 = (unsigned __int16 *)&__CFFromJIS0212CharMap;
        int v33 = (unsigned __int16 *)((char *)&__CFFromJIS0212CharMap + 13002);
        while (2)
        {
          uint64_t v34 = (0xF83E0F83E0F83E1 * (v33 - v32)) >> 1;
          unint64_t v35 = &v32[33 * v34];
          unsigned int v36 = *v35;
          if (v36 > v31)
          {
            int v33 = v35 - 33;
            goto LABEL_51;
          }
          if (v36 + 32 <= v31)
          {
            __int16 v32 = v35 + 33;
LABEL_51:
            if (v32 > v33) {
              goto LABEL_73;
            }
            continue;
          }
          break;
        }
        unsigned __int16 v39 = v32[33 * v34 + 1 + (int)(v31 - v36)];
        if (v39 != 65533 && v39 != 0)
        {
LABEL_75:
          if (!v44 || !__CFStringEncodingIsDecomposableCharacter_2(v39, (a1 >> 7) & 1))
          {
            if (a5) {
              *a4++ = v39;
            }
            goto LABEL_83;
          }
          if (!a5) {
            goto LABEL_80;
          }
          if (v8 >= a5) {
            return v9;
          }
          __CFStringEncodingDecomposeCharacter_2(a1, v39, a4);
          a4 += 2;
LABEL_80:
          ++v8;
LABEL_83:
          uint64_t v23 = 2;
LABEL_84:
          ++v8;
LABEL_85:
          v9 += v23;
          v13 += v23;
          BOOL v41 = (uint64_t)v10 <= v23;
          v10 -= v23;
          if (v41) {
            goto LABEL_93;
          }
          continue;
        }
LABEL_73:
        if (a1)
        {
          unsigned __int16 v39 = 63;
          goto LABEL_75;
        }
LABEL_91:
        LODWORD(v14) = 4;
LABEL_93:
        int v6 = a6;
        if (a5 {
          && v14
        }
          && v10 == 3
          && v8 == a5
          && *v13 == 27
          && v7 >= (unint64_t)(v13 + 3)
          && !strncmp("(B", v13 + 1, 2uLL))
        {
          v9 += 3;
        }
LABEL_101:
        *int v6 = v8;
        return v9;
      default:
        goto LABEL_93;
    }
  }
}

uint64_t __CFToMacJapanese(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    goto LABEL_238;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  int v67 = a1 & 0x480;
  uint64_t v9 = (unsigned __int16 *)&__CFToJISCharMap;
  uint64_t v10 = 0x4E4Bu;
LABEL_3:
  uint64_t v11 = v7;
  uint64_t v12 = v8;
  unsigned int v13 = a2;
  while (1)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_238;
      }
      unsigned int v14 = *v13;
      if (v14 - 774 <= 0x32 && ((1 << (v14 - 6)) & 0x4000000000005) != 0 || v14 - 12441 < 2) {
        goto LABEL_20;
      }
      if (v14 != 8413 && (v14 & 0xFFF0) != 0xF870) {
        goto LABEL_238;
      }
    }
    else
    {
      unsigned int v14 = *v13;
    }
    if (v14 <= 0x7F)
    {
      uint64_t v7 = v11 + 1;
      if (!a5) {
        goto LABEL_232;
      }
      if (v14 != 92 || v67 == 1024) {
        char v40 = v14;
      }
      else {
        char v40 = 0x80;
      }
      goto LABEL_114;
    }
LABEL_20:
    if ((unsigned __int16)(v14 + 159) <= 0x3Eu)
    {
      uint64_t v7 = v11 + 1;
      if (!a5) {
        goto LABEL_232;
      }
      char v40 = v14 + 64;
LABEL_114:
      *a4++ = v40;
      goto LABEL_232;
    }
    uint64_t v17 = v12 + 1;
    if (v12 + 1 < a3 && v14 == 8230) {
      break;
    }
    if ((unsigned __int16)(v14 + 12) >= 0xACu) {
      goto LABEL_26;
    }
LABEL_33:
    BOOL v24 = v12 > 0 || (v14 & 0xFFF0) == 63584;
    if ((a1 & 8) != 0 || !v24) {
      goto LABEL_238;
    }
    if ((a1 & 0x10) == 0)
    {
      unsigned int v13 = a2;
      uint64_t v12 = v8;
      goto LABEL_232;
    }
    if (v14 != 63615)
    {
      if ((int)v14 <= 12440)
      {
        if (v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0)
        {
          if (v14 == 8413)
          {
            int v28 = *(v13 - 1);
            switch(v28)
            {
              case 22823:
                LOBYTE(v29) = -111;
                break;
              case 25511:
                LOBYTE(v29) = -99;
                break;
              case 23567:
                LOBYTE(v29) = -110;
                break;
              default:
                goto LABEL_238;
            }
            if (a5)
            {
              char v50 = -121;
LABEL_126:
              *(a4 - 2) = v50;
              *(a4 - 1) = v29;
            }
LABEL_231:
            uint64_t v7 = v11;
LABEL_232:
            a2 = v13 + 1;
            uint64_t v8 = v12 + 1;
            uint64_t v11 = v7;
            uint64_t v12 = v8;
            if (v8 >= a3) {
              goto LABEL_238;
            }
            goto LABEL_3;
          }
LABEL_92:
          uint64_t v7 = v11 + 2;
          if (a5 && v7 > a5) {
            goto LABEL_238;
          }
          if (v14 == 63586)
          {
            if (v12 + 5 > a3) {
              goto LABEL_238;
            }
            int v52 = 34219;
            unsigned int v53 = (unsigned __int16 *)&__CFF862SeqTable;
LABEL_129:
            uint64_t v54 = 1;
            do
            {
              if (v13[v54] != v53[v54])
              {
                int v55 = v53[5];
                v53 += 5;
                int v52 = v55;
                if (v55) {
                  goto LABEL_129;
                }
                goto LABEL_238;
              }
              ++v54;
            }
            while ((v54 * 2) != 10);
            if (!v52) {
              goto LABEL_238;
            }
            if (a5)
            {
              *a4 = BYTE1(v52);
              a4[1] = v52;
              a4 += 2;
            }
            v13 += 4;
            v12 += 4;
          }
          else if (v14 == 63585)
          {
            if (v12 + 4 > a3) {
              goto LABEL_238;
            }
            int v56 = 34220;
            int v57 = (unsigned __int16 *)&__CFF861SeqTable;
LABEL_137:
            uint64_t v58 = 1;
            do
            {
              if (v13[v58] != v57[v58])
              {
                int v59 = v57[5];
                v57 += 5;
                int v56 = v59;
                if (v59) {
                  goto LABEL_137;
                }
                goto LABEL_238;
              }
              ++v58;
            }
            while ((v58 * 2) != 8);
            if (!v56) {
              goto LABEL_238;
            }
            if (a5)
            {
              *a4 = BYTE1(v56);
              a4[1] = v56;
              a4 += 2;
            }
            v13 += 3;
            v12 += 3;
          }
          else
          {
            if (v14 != 63584 || v12 + 3 > a3) {
              goto LABEL_238;
            }
            int v46 = 34193;
            unint64_t v47 = (unsigned __int16 *)&__CFF860SeqTable;
LABEL_99:
            uint64_t v48 = 1;
            do
            {
              if (v13[v48] != v47[v48])
              {
                int v49 = v47[5];
                v47 += 5;
                int v46 = v49;
                if (v49) {
                  goto LABEL_99;
                }
                goto LABEL_238;
              }
              ++v48;
            }
            while ((v48 * 2) != 6);
            if (!v46) {
              goto LABEL_238;
            }
            if (a5)
            {
              *a4 = BYTE1(v46);
              a4[1] = v46;
              a4 += 2;
            }
            v13 += 2;
            v12 += 2;
          }
          goto LABEL_232;
        }
LABEL_70:
        uint64_t v68 = v12;
        uint64_t v32 = a5;
        uint64_t v33 = a1;
        uint64_t v34 = a3;
        unint64_t v35 = (char *)v9;
        unsigned int v36 = a6;
        unsigned int v37 = __CFPrecomposeCharJapanese(v13 - 1, 1);
        unsigned __int16 v38 = __CFToJIS(v37, 0);
        if ((v38 & 0x8000) != 0)
        {
          a6 = v36;
          uint64_t v12 = v68;
          goto LABEL_238;
        }
        if (v32)
        {
          uint64_t v39 = -2;
          if (*(a4 - 1) == 61) {
            uint64_t v39 = -1;
          }
          JIS0208ToShiftJIS(v38, &a4[v39]);
        }
        a5 = v32;
        uint64_t v7 = v11;
        a6 = v36;
        uint64_t v9 = (unsigned __int16 *)v35;
        a3 = v34;
        a1 = v33;
        uint64_t v12 = v68;
        uint64_t v10 = 20043;
        goto LABEL_232;
      }
      if (v14 - 12441 < 2) {
        goto LABEL_70;
      }
      if (v14 != 63610)
      {
        if (v14 == 63614)
        {
          unsigned int v30 = *(v13 - 1);
          if (v30 <= 0x30A0)
          {
            if (*(v13 - 1) <= 0x3040u)
            {
              if (*(v13 - 1) > 0x3000u)
              {
                switch(v30)
                {
                  case 0x3001u:
                    unsigned int v31 = 60225;
                    break;
                  case 0x3002u:
                    unsigned int v31 = 60226;
                    break;
                  case 0x301Cu:
                    unsigned int v31 = 60256;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
              else
              {
                switch(v30)
                {
                  case 0x2010u:
                    unsigned int v31 = 60253;
                    break;
                  case 0x2016u:
                    unsigned int v31 = 60257;
                    break;
                  case 0x2026u:
                    unsigned int v31 = 60259;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
            }
            else
            {
              if (*(v13 - 1) <= 0x3062u)
              {
                switch(*(v13 - 1))
                {
                  case 0x3041u:
                    unsigned int v31 = 60575;
                    goto LABEL_229;
                  case 0x3043u:
                    unsigned int v31 = 60577;
                    goto LABEL_229;
                  case 0x3045u:
                    unsigned int v31 = 60579;
                    goto LABEL_229;
                  case 0x3047u:
                    unsigned int v31 = 60581;
                    goto LABEL_229;
                  case 0x3049u:
                    unsigned int v31 = 60583;
                    goto LABEL_229;
                  default:
                    goto LABEL_238;
                }
                goto LABEL_238;
              }
              if (*(v13 - 1) <= 0x3084u)
              {
                if (v30 == 12387)
                {
                  unsigned int v31 = 60609;
                }
                else
                {
                  if (v30 != 12419) {
                    goto LABEL_238;
                  }
                  unsigned int v31 = 60641;
                }
              }
              else
              {
                switch(v30)
                {
                  case 0x3085u:
                    unsigned int v31 = 60643;
                    break;
                  case 0x3087u:
                    unsigned int v31 = 60645;
                    break;
                  case 0x308Eu:
                    unsigned int v31 = 60652;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
            }
          }
          else if (*(v13 - 1) > 0x30EDu)
          {
            if (*(v13 - 1) <= 0xFF1Cu)
            {
              if (*(v13 - 1) > 0x30F5u)
              {
                if (v30 == 12534)
                {
                  unsigned int v31 = 60822;
                }
                else
                {
                  if (v30 != 12540) {
                    goto LABEL_238;
                  }
                  unsigned int v31 = 60251;
                }
              }
              else if (v30 == 12526)
              {
                unsigned int v31 = 60814;
              }
              else
              {
                if (v30 != 12533) {
                  goto LABEL_238;
                }
                unsigned int v31 = 60821;
              }
            }
            else if (*(v13 - 1) <= 0xFF3Cu)
            {
              if (v30 == 65309)
              {
                unsigned int v31 = 60289;
              }
              else
              {
                if (v30 != 65339) {
                  goto LABEL_238;
                }
                unsigned int v31 = 60269;
              }
            }
            else
            {
              switch(v30)
              {
                case 0xFF3Du:
                  unsigned int v31 = 60270;
                  break;
                case 0xFF5Cu:
                  unsigned int v31 = 60258;
                  break;
                case 0xFFE3u:
                  unsigned int v31 = 60240;
                  break;
                default:
                  goto LABEL_238;
              }
            }
          }
          else
          {
            if (*(v13 - 1) <= 0x30C2u)
            {
              switch(*(v13 - 1))
              {
                case 0x30A1u:
                  unsigned int v31 = 60736;
                  goto LABEL_229;
                case 0x30A3u:
                  unsigned int v31 = 60738;
                  goto LABEL_229;
                case 0x30A5u:
                  unsigned int v31 = 60740;
                  goto LABEL_229;
                case 0x30A7u:
                  unsigned int v31 = 60742;
                  goto LABEL_229;
                case 0x30A9u:
                  unsigned int v31 = 60744;
                  goto LABEL_229;
                default:
                  goto LABEL_238;
              }
              goto LABEL_238;
            }
            if (*(v13 - 1) > 0x30E4u)
            {
              if (v30 == 12517)
              {
                unsigned int v31 = 60805;
              }
              else
              {
                if (v30 != 12519) {
                  goto LABEL_238;
                }
                unsigned int v31 = 60807;
              }
            }
            else if (v30 == 12483)
            {
              unsigned int v31 = 60770;
            }
            else
            {
              if (v30 != 12515) {
                goto LABEL_238;
              }
              unsigned int v31 = 60803;
            }
          }
LABEL_229:
          if (a5) {
            *((_WORD *)a4 - 1) = __rev16(v31);
          }
          goto LABEL_231;
        }
        goto LABEL_92;
      }
      unsigned __int16 v45 = *(v13 - 1) - 8678;
      if (v45 > 3u) {
        goto LABEL_238;
      }
      if (!a5) {
        goto LABEL_231;
      }
      unsigned int v29 = 0xD6D3D5D4 >> (8 * v45);
LABEL_106:
      char v50 = -122;
      goto LABEL_126;
    }
    int v25 = *(v13 - 1);
    if (v25 != 8230)
    {
      if (v25 == 65351)
      {
        LOBYTE(v29) = 75;
        if (!a5) {
          goto LABEL_231;
        }
      }
      else
      {
        if (v25 != 65357) {
          goto LABEL_238;
        }
        LOBYTE(v29) = 69;
        if (!a5) {
          goto LABEL_231;
        }
      }
      goto LABEL_106;
    }
    if (a5) {
      *(a4 - 2) = -1;
    }
    --v11;
    ++v13;
    ++v12;
    if (v17 >= a3)
    {
      if (a3 <= v8 + 1) {
        uint64_t v12 = v8 + 1;
      }
      else {
        uint64_t v12 = a3;
      }
      goto LABEL_238;
    }
  }
  if ((__int16)v13[1] == -1921)
  {
    ++v13;
    uint64_t v7 = v11 + 1;
    if (a5) {
      *a4++ = -1;
    }
    ++v12;
    goto LABEL_232;
  }
LABEL_26:
  uint64_t v18 = &v9[v10];
  uint64_t v19 = v9;
  while (2)
  {
    uint64_t v20 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v18 - v19)) >> 1;
    uint64_t v21 = &v19[17 * v20];
    unsigned int v22 = *v21;
    if (v22 > v14)
    {
      uint64_t v18 = v21 - 17;
      goto LABEL_31;
    }
    if (v22 + 16 <= v14)
    {
      uint64_t v19 = v21 + 17;
LABEL_31:
      if (v19 > v18) {
        goto LABEL_32;
      }
      continue;
    }
    break;
  }
  unsigned int v26 = &v19[17 * v20];
  unsigned int v27 = v26[v14 - v22 + 1];
  if (!v26[v14 - v22 + 1])
  {
LABEL_32:
    if ((unsigned __int16)(v14 + 0x2000) > 0x98Bu) {
      goto LABEL_33;
    }
LABEL_83:
    unsigned int v41 = v14 - 57344;
    unsigned int v42 = (v14 - 57344) / 0xBC;
    unsigned int v43 = v14 + 68 * v42;
    if (v41 - 188 * v42 <= 0x3E) {
      unsigned int v44 = v43;
    }
    else {
      unsigned int v44 = v43 + 1;
    }
    uint64_t v7 = v11 + 2;
    if (a5)
    {
      if (v7 > a5) {
        goto LABEL_238;
      }
      *(_WORD *)a4 = bswap32(v44 + 4160) >> 16;
      a4 += 2;
    }
    goto LABEL_232;
  }
  if (v27 <= 0xFF)
  {
    uint64_t v7 = v11 + 1;
    if (a5) {
      *a4++ = v27;
    }
    goto LABEL_232;
  }
  if ((v27 & 0x8000) != 0)
  {
    if ((unsigned __int16)(v14 + 0x2000) >= 0x98Cu)
    {
      if (v27 == 65533) {
        goto LABEL_33;
      }
      goto LABEL_238;
    }
    goto LABEL_83;
  }
  uint64_t v7 = v11 + 2;
  if (!a5) {
    goto LABEL_232;
  }
  if (v7 <= a5)
  {
    if ((v27 & 0x100) != 0) {
      int v60 = 31;
    }
    else {
      int v60 = 125;
    }
    unsigned int v61 = v60 + (v27 & 0x7F);
    unsigned int v62 = ((v27 >> 8) + 479) >> 1;
    char v63 = v62 - 127;
    unsigned int v64 = (v62 - 127);
    if (v61 > 0x7E) {
      LOBYTE(v61) = v61 + 1;
    }
    char v65 = v62 - 63;
    if (v64 <= 0x9F) {
      char v65 = v63;
    }
    *a4 = v65;
    a4[1] = v61;
    a4 += 2;
    goto LABEL_232;
  }
LABEL_238:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromMacJapanese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v54 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  uint64_t v9 = a3;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unsigned int v50 = a1 & 0x200;
  int v51 = a1 & 0x480;
  int v52 = a1 & 0xC0;
  while (1)
  {
    if (a5 && v12 >= a5) {
      return v13;
    }
    unsigned int v14 = *a2;
    if (v14 < 0x81 || v14 == 160)
    {
      if (v14 == 128) {
        __int16 v16 = 92;
      }
      else {
        __int16 v16 = *a2;
      }
      if (v14 == 92) {
        __int16 v16 = 165;
      }
      if (v51 == 1024) {
        unsigned __int16 v15 = *a2;
      }
      else {
        unsigned __int16 v15 = v16;
      }
      uint64_t v17 = 1;
      goto LABEL_23;
    }
    if ((v14 + 95) <= 0x3Eu)
    {
      unsigned __int16 v15 = v14 - 320;
LABEL_22:
      uint64_t v17 = 1;
LABEL_23:
      if (v52 && __CFStringEncodingIsDecomposableCharacter_2(v15, (a1 >> 7) & 1))
      {
        unsigned int v18 = __CFStringEncodingDecomposeCharacter_2(a1, v15, v53);
        uint64_t v19 = *a6;
        uint64_t v12 = *a6 + v18;
        *a6 = v12;
        if (a5)
        {
          if (v12 > a5)
          {
            *a6 = v19;
            return v13;
          }
          if (v18)
          {
            unint64_t v20 = v18 + 1;
            uint64_t v21 = (unsigned __int16 *)v53;
            do
            {
              unsigned __int16 v22 = *v21++;
              *a4++ = v22;
              --v20;
            }
            while (v20 > 1);
          }
        }
      }
      else
      {
        if (a5) {
          *a4++ = v15;
        }
        uint64_t v12 = *a6 + 1;
        *a6 = v12;
      }
      v13 += v17;
      a2 += v17;
      v9 -= v17;
      goto LABEL_35;
    }
    if (v14 == 253)
    {
      unsigned __int16 v15 = 169;
      goto LABEL_22;
    }
    if (v14 == 254)
    {
      unsigned __int16 v15 = 8482;
      goto LABEL_22;
    }
    if ((unint64_t)v9 >= 2)
    {
      int v23 = a2[1];
      if (v14 >= 0xA0) {
        __int16 v24 = 79;
      }
      else {
        __int16 v24 = 15;
      }
      __int16 v25 = v24 + v14;
      if ((v23 + ((char)v23 >> 7)) <= 0x9Du) {
        __int16 v26 = (2 * (v25 & 0x1FF)) | 1;
      }
      else {
        __int16 v26 = 2 * v25 + 2;
      }
      if ((v23 + ((char)v23 >> 7)) <= 0x9Du) {
        char v27 = -31;
      }
      else {
        char v27 = -125;
      }
      if ((unsigned __int16)(((v27 + v23 + ((char)v23 >> 7)) | (unsigned __int16)(v26 << 8)) - 30067) < 0xABAEu) {
        goto LABEL_60;
      }
      unsigned int v28 = (unsigned __int16)((v27 + v23 + ((char)v23 >> 7)) | (unsigned __int16)(v26 << 8));
      unsigned int v29 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
      unsigned int v30 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
      while (1)
      {
        uint64_t v31 = (0xF83E0F83E0F83E1 * (v30 - v29)) >> 1;
        uint64_t v32 = &v29[33 * v31];
        unsigned int v33 = *v32;
        if (v33 <= v28) {
          break;
        }
        unsigned int v30 = v32 - 33;
LABEL_53:
        if (v29 > v30) {
          goto LABEL_60;
        }
      }
      if (v33 + 32 <= v28)
      {
        unsigned int v29 = v32 + 33;
        goto LABEL_53;
      }
      unsigned __int16 v15 = v29[33 * v31 + 1 + (int)(v28 - v33)];
      if (v15 != 65533 && v15 != 0)
      {
LABEL_64:
        uint64_t v17 = 2;
        goto LABEL_23;
      }
LABEL_60:
      if ((v14 + 16) <= 0xCu) {
        break;
      }
    }
    if (v14 != 255) {
      goto LABEL_66;
    }
    v12 += 2;
    if (a5)
    {
      if (v12 > a5) {
        return v13;
      }
      *(_DWORD *)a4 = -125886426;
      a4 += 2;
    }
    *a6 = v12;
    ++v13;
    ++a2;
    --v9;
LABEL_35:
    if (v9 <= 0) {
      return v13;
    }
  }
  if (v23 != 127 && (v23 + 3) >= 0x43u)
  {
    unsigned __int16 v15 = (v23 | ((_WORD)v14 << 8)) - 68 * (v14 & 0xF) + ((char)v23 >> 7) - 4160;
    goto LABEL_64;
  }
LABEL_66:
  BOOL v35 = v9 < 2;
  v9 -= 2;
  if (v35) {
    return v13;
  }
  unsigned int v36 = a2[1] | (v14 << 8);
  if ((unsigned __int16)(v36 + 4713) < 0x97FAu) {
    return v13;
  }
  unsigned int v37 = (unsigned __int16 *)&macjapanese_to_uni_decomp;
  unsigned __int16 v38 = (unsigned __int16 *)&unk_182EDA71A;
  while (2)
  {
    uint64_t v39 = ((char *)v38 - (char *)v37) >> 3;
    char v40 = &v37[2 * v39];
    unsigned int v41 = *v40;
    if (v41 > v36)
    {
      unsigned __int16 v38 = v40 - 2;
      goto LABEL_73;
    }
    if (v41 < v36)
    {
      unsigned int v37 = v40 + 2;
LABEL_73:
      if (v37 > v38) {
        return v13;
      }
      continue;
    }
    break;
  }
  uint64_t v42 = LOBYTE(v37[2 * v39 + 1]);
  unsigned int v43 = (v42 >> 6) + 2;
  if (v50)
  {
    if ((unint64_t)(v42 - 7) >= 3 || v42 >= 0x40) {
      unsigned int v43 = (v42 >> 6) + 1;
    }
  }
  v12 += v43;
  if (!a5)
  {
LABEL_94:
    *a6 = v12;
    v13 += 2;
    a2 += 2;
    goto LABEL_35;
  }
  if (v12 <= a5)
  {
    if (v42 >= 0x40) {
      unsigned __int16 v45 = (char *)&__CFF86XCharDecompSeqTable + 10 * (v42 & 0x3F) + 2 * (v50 >> 9) - 10;
    }
    else {
      unsigned __int16 v45 = (char *)&__CFTwoCharDecompSeqTable_0 + 4 * v42 - 4;
    }
    uint64_t v46 = v43;
    unint64_t v47 = a4;
    do
    {
      unsigned __int16 v48 = *(_WORD *)v45;
      v45 += 2;
      *v47++ = v48;
      --v46;
    }
    while (v46);
    a4 += v43;
    goto LABEL_94;
  }
  return v13;
}

uint64_t __CFFromMacJapaneseLen(__int16 a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t result = 0;
  int v5 = a1 & 0x480;
  do
  {
    unsigned int v6 = *a2;
    if (v6 == 255)
    {
      ++a2;
      --a3;
      ++result;
    }
    else if ((v6 & 0x80) == 0 {
           || (v6 + 95) < 0x3Fu
    }
           || (v5 != 1024 ? (BOOL v7 = v6 == 128) : (BOOL v7 = 0),
               !v7 ? (int v8 = 0) : (int v8 = 1),
               (unint64_t)a3 < 2 || v6 > 0xFC || v8))
    {
      ++a2;
      --a3;
    }
    else
    {
      if (v6 - 235 >= 3 && v6 - 133 > 2)
      {
        a2 += 2;
      }
      else
      {
        a2 += 2;
        result += 5;
      }
      a3 -= 2;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t __CFFromShiftJIS(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  unsigned int v5 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    if (v5 == 126) {
      __int16 v6 = 8254;
    }
    else {
      __int16 v6 = *a2;
    }
    if (v5 == 92) {
      __int16 v7 = 165;
    }
    else {
      __int16 v7 = v6;
    }
    goto LABEL_10;
  }
  if ((v5 + 95) <= 0x3Eu)
  {
    __int16 v7 = v5 - 320;
LABEL_10:
    *a4 = v7;
    return 1;
  }
  if (a3 < 2) {
    return 0;
  }
  if ((v5 + 16) <= 0xCu)
  {
    uint64_t result = 0;
    int v9 = a2[1];
    if (v9 != 127 && (v9 + 3) >= 0x43u)
    {
      *a4 = (v9 | ((_WORD)v5 << 8)) - 68 * (v5 & 0xF) + ((char)v9 >> 7) - 4160;
      return 2;
    }
    return result;
  }
  if (v5 == 128) {
    return 0;
  }
  uint64_t result = 0;
  if (v5 <= 0xEA && (v5 + 123) >= 3u)
  {
    unsigned int v10 = ShiftJISToJIS0208(a2);
    int v11 = __CFFromJIS0208(v10);
    *a4 = v11;
    return 2 * (v11 != 65533);
  }
  return result;
}

uint64_t __CFToAutoDetect_JP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  *a6 = 0;
  return 0;
}

uint64_t __CFFromAutoDetect_JP(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  int v8 = a4;
  uint64_t v9 = a3;
  unsigned int v10 = (unsigned __int8 *)a2;
  uint64_t v11 = a1;
  uint64_t v60 = *(void *)off_1ECE0A5B0;
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  do
  {
    BOOL v14 = v13-- < 1;
    if (v14)
    {
      if (a3 < 1)
      {
LABEL_41:
        if (a5 >= a3 || a5 == 0) {
          uint64_t v30 = a3;
        }
        else {
          uint64_t v30 = a5;
        }
        *a6 = v30;
        if (v30 && a5)
        {
          for (uint64_t i = 0; i != v30; ++i)
            a4[i] = a2[i];
        }
        return v30;
      }
      unsigned __int16 v22 = (unsigned __int8 *)(a2 + 1);
      unint64_t v23 = a3;
      while (1)
      {
        if (*(v22 - 1) == 27)
        {
          if (v23 < 5)
          {
            if (v23 == 4)
            {
              unsigned int v26 = *v22 - 96;
              BOOL v14 = v26 > 0x1E;
              int v27 = (1 << v26) & 0x7000C00F;
              if (!v14 && v27 != 0)
              {
LABEL_52:
                return __CFFromISO_2022_JP(a1, a2, a3, a4, a5, a6);
              }
            }
          }
          else
          {
            unsigned int v24 = *v22;
            BOOL v25 = v24 - 96 > 0x1E || ((1 << (v24 - 96)) & 0x7000C00F) == 0;
            if (!v25 || v24 <= 0x28 && ((1 << v24) & 0x11600000000) != 0) {
              goto LABEL_52;
            }
          }
        }
        --v23;
        ++v22;
        if (v23 + 1 <= 1) {
          goto LABEL_41;
        }
      }
    }
    int v15 = *v12++;
  }
  while ((v15 & 0x80000000) == 0);
  if (a3 < 1) {
    goto LABEL_94;
  }
  uint64_t v16 = a3;
  uint64_t v17 = a2;
  while (1)
  {
    if ((*v17 & 0x80000000) == 0)
    {
      --v16;
      goto LABEL_8;
    }
    unsigned int v18 = *v17;
    if (v18 == 142)
    {
      char v20 = *++v17;
      if ((v20 + 32) < 0xC1u) {
        goto LABEL_55;
      }
      v16 -= 2;
      goto LABEL_8;
    }
    if (v18 != 143) {
      break;
    }
    if ((v17[1] + 32) < 0xC1u) {
      goto LABEL_55;
    }
    char v21 = v17[2];
    v17 += 2;
    if ((v21 + 32) < 0xC1u) {
      goto LABEL_55;
    }
    v16 -= 3;
LABEL_8:
    ++v17;
    if (v16 <= 0)
    {
      char v33 = 1;
      goto LABEL_56;
    }
  }
  if (v18 != 255)
  {
    char v33 = 0;
    v16 -= 2;
    if (!v16 || v18 < 0xA0) {
      goto LABEL_56;
    }
    char v19 = *++v17;
    if ((v19 + 1) >= 0xA1u) {
      goto LABEL_8;
    }
  }
LABEL_55:
  char v33 = 0;
LABEL_56:
  uint64_t v34 = a3;
  BOOL v35 = a2;
  while (2)
  {
    uint64_t v36 = v34 - 1;
    int v37 = *v35;
    if ((v37 & 0x80000000) == 0 || (v37 + 32) > 0xC0u)
    {
LABEL_71:
      ++v35;
      uint64_t v34 = v36;
      if (v36 <= 0)
      {
        if ((v33 & 1) == 0)
        {
          uint64_t v30 = 0;
          *a6 = 0;
          unsigned __int16 v59 = 0;
          uint64_t v46 = 1;
          while (1)
          {
            if (a5)
            {
              if (v46 - 1 >= a5) {
                return v30;
              }
              a1 = __CFFromShiftJIS(a1, v10, v9, (__int16 *)&v59);
              if (!a1) {
                return v30;
              }
              uint64_t v47 = a1;
              *v8++ = v59;
            }
            else
            {
              a1 = __CFFromShiftJIS(a1, v10, v9, (__int16 *)&v59);
              if (!a1) {
                return v30;
              }
              uint64_t v47 = a1;
            }
            *a6 = v46;
            v30 += v47;
            v10 += v47;
            ++v46;
            BOOL v14 = v9 <= v47;
            v9 -= v47;
            if (v14) {
              return v30;
            }
          }
        }
        goto LABEL_94;
      }
      continue;
    }
    break;
  }
  if (*v35 >= 0xA0u) {
    __int16 v38 = 79;
  }
  else {
    __int16 v38 = 15;
  }
  __int16 v39 = v38 + *v35;
  char v40 = 2 * v39;
  a1 = (2 * (v39 & 0x1FF)) | 1u;
  int v41 = *++v35;
  int v42 = v41 + ((char)(2 * v39) >> 7);
  char v43 = v40 + 2;
  if (v42 <= 0x9Du) {
    char v44 = a1;
  }
  else {
    char v44 = v43;
  }
  if (v42 <= 0x9Du) {
    char v45 = -31;
  }
  else {
    char v45 = -125;
  }
  if ((v44 - 127) >= 0xA1u && (v42 + v45 - 127) >= 0xA1u)
  {
    uint64_t v36 = v34 - 2;
    goto LABEL_71;
  }
  if (v33)
  {
    uint64_t v30 = 0;
    *a6 = 0;
    unsigned __int16 v59 = 0;
    uint64_t v48 = 1;
    while (1)
    {
      if (a5)
      {
        if (v48 - 1 >= a5) {
          return v30;
        }
        a1 = __CFFromEUC_JP(a1, v10, v9, (__int16 *)&v59);
        if (!a1) {
          return v30;
        }
        uint64_t v49 = a1;
        *v8++ = v59;
      }
      else
      {
        a1 = __CFFromEUC_JP(a1, v10, v9, (__int16 *)&v59);
        if (!a1) {
          return v30;
        }
        uint64_t v49 = a1;
      }
      *a6 = v48;
      v30 += v49;
      v10 += v49;
      ++v48;
      BOOL v14 = v9 <= v49;
      v9 -= v49;
      if (v14) {
        return v30;
      }
    }
  }
LABEL_94:
  uint64_t v50 = __CFFromMacJapanese(0, (unsigned __int8 *)a2, a3, 0, 0, a6);
  unsigned int v51 = v50;
  if (v9 > v50)
  {
    *a6 = 0;
    if (v9 >= 1)
    {
      unsigned int v58 = v11;
      unsigned int v52 = 0;
      uint64_t v53 = 1;
      uint64_t v54 = v10;
      uint64_t v55 = v9;
      do
      {
        uint64_t v50 = __CFFromDOSJapanese(v50, v54, v55, (__int16 *)&v59);
        if (!v50) {
          break;
        }
        *a6 = v53;
        v52 += v50;
        v54 += v50;
        v55 -= v50;
        ++v53;
      }
      while (v55 > 0);
      uint64_t v11 = v58;
      if (v52 > v51)
      {
        *a6 = 0;
        uint64_t v30 = 0;
        unsigned __int16 v59 = 0;
        uint64_t v56 = 1;
        while (1)
        {
          if (a5)
          {
            if (v56 - 1 >= a5) {
              return v30;
            }
            uint64_t v50 = __CFFromDOSJapanese(v50, v10, v9, (__int16 *)&v59);
            if (!v50) {
              return v30;
            }
            uint64_t v57 = v50;
            *v8++ = v59;
          }
          else
          {
            uint64_t v50 = __CFFromDOSJapanese(v50, v10, v9, (__int16 *)&v59);
            if (!v50) {
              return v30;
            }
            uint64_t v57 = v50;
          }
          *a6 = v56;
          v30 += v57;
          v10 += v57;
          ++v56;
          BOOL v14 = v9 <= v57;
          v9 -= v57;
          if (v14) {
            return v30;
          }
        }
      }
    }
  }

  return __CFFromMacJapanese(v11, v10, v9, v8, a5, a6);
}

uint64_t __CFToNTTDocomoSJIS(char a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v58[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v20 = 0;
    goto LABEL_85;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v58[0] = 0;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_83;
      }
      int v13 = *a2;
      BOOL v14 = (v13 - 774) > 0x32 || ((1 << (v13 - 6)) & 0x4000000000005) == 0;
      unsigned int v15 = v13 - 12441;
      if (v14 && v15 >= 2) {
        goto LABEL_83;
      }
    }
    uint64_t v17 = __CFToEmojiIndex(a2, a3 - v12, v58);
    if (v17 != -1)
    {
      if (v17 == 312 || v17 == 69)
      {
        unsigned int v18 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFNTTDocomoTable[v17] - 6;
        size_t v19 = strlen(v18);
        uint64_t v20 = v19 + v11;
        if (a5)
        {
          if (v20 > a5) {
            goto LABEL_83;
          }
          size_t v21 = v19;
          memcpy(a4, v18, v19);
          a4 += v21;
        }
      }
      else
      {
        uint64_t v20 = v11 + 2;
        if (a5)
        {
          if (v20 > a5) {
            goto LABEL_83;
          }
          *(_WORD *)a4 = __rev16(__CFNTTDocomoTable[v17]);
          a4 += 2;
        }
      }
      uint64_t v23 = v58[0];
      goto LABEL_32;
    }
    unsigned int v22 = *a2;
    if (v22 <= 0x7F)
    {
      uint64_t v20 = v11 + 1;
      if (!a5) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
    if ((unsigned __int16)(v22 + 159) <= 0x3Eu)
    {
      uint64_t v20 = v11 + 1;
      if (!a5) {
        goto LABEL_31;
      }
      LOBYTE(v22) = v22 + 64;
LABEL_30:
      *a4++ = v22;
      goto LABEL_31;
    }
    if ((unsigned __int16)(v22 + 12) < 0xACu)
    {
      LOWORD(v24) = -3;
      goto LABEL_43;
    }
    BOOL v25 = (unsigned __int16 *)&__CFToJISCharMap;
    unsigned int v26 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v27 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v26 - v25)) >> 1;
      unsigned int v28 = &v25[17 * v27];
      unsigned int v29 = *v28;
      if (v29 <= v22) {
        break;
      }
      unsigned int v26 = v28 - 17;
LABEL_41:
      if (v25 > v26) {
        goto LABEL_42;
      }
    }
    if (v29 + 16 <= v22)
    {
      BOOL v25 = v28 + 17;
      goto LABEL_41;
    }
    uint64_t v36 = (char *)&v25[17 * v27];
    int v24 = *(__int16 *)&v36[2 * (v22 - v29) + 2];
    if (*(_WORD *)&v36[2 * (v22 - v29) + 2])
    {
      if (v24 >= 256)
      {
        uint64_t v20 = v11 + 2;
        if (a5)
        {
          if (v20 <= a5)
          {
            int v37 = BYTE1(v24);
            int v38 = v24 & 0x7F;
            if ((v24 & 0x100) != 0) {
              int v39 = 31;
            }
            else {
              int v39 = 125;
            }
            unsigned int v40 = v39 + v38;
            unsigned int v41 = (v37 + 479) >> 1;
            char v42 = v41 - 127;
            unsigned int v43 = (v41 - 127);
            if (v40 > 0x7E) {
              LOBYTE(v4_CFSetTSD(0xFu, 0, 0) = v40 + 1;
            }
            char v44 = v41 - 63;
            if (v43 <= 0x9F) {
              char v44 = v42;
            }
            *a4 = v44;
            a4[1] = v40;
            a4 += 2;
            goto LABEL_31;
          }
LABEL_83:
          uint64_t v20 = v11;
          break;
        }
LABEL_31:
        uint64_t v23 = 1;
        goto LABEL_32;
      }
    }
    else
    {
LABEL_42:
      LOWORD(v24) = -3;
    }
LABEL_43:
    if ((a1 & 8) != 0 || v12 < 1 || (unsigned __int16)v24 != 65533) {
      goto LABEL_83;
    }
    if ((a1 & 0x10) == 0) {
      goto LABEL_47;
    }
    if ((v22 - 774 > 0x32 || ((1 << (v22 - 6)) & 0x4000000000005) == 0) && v22 - 12441 >= 2) {
      goto LABEL_83;
    }
    unsigned int v30 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    if ((unsigned __int16)(v30 + 12) < 0xACu) {
      goto LABEL_83;
    }
    uint64_t v31 = (unsigned __int16 *)&__CFToJISCharMap;
    uint64_t v32 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      uint64_t v33 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v32 - v31)) >> 1;
      uint64_t v34 = &v31[17 * v33];
      unsigned int v35 = *v34;
      if (v35 > v30)
      {
        uint64_t v32 = v34 - 17;
        goto LABEL_57;
      }
      if (v35 + 16 <= v30)
      {
        uint64_t v31 = v34 + 17;
LABEL_57:
        if (v31 > v32) {
          goto LABEL_83;
        }
        continue;
      }
      break;
    }
    int v45 = (__int16)v31[17 * v33 + 1 + (int)(v30 - v35)];
    if (v45 < 1) {
      goto LABEL_83;
    }
    if (a5)
    {
      uint64_t v46 = -2;
      if (*(a4 - 1) == 61) {
        uint64_t v46 = -1;
      }
      uint64_t v47 = &a4[v46];
      int v48 = BYTE1(v45);
      int v49 = v45 & 0x7F;
      if ((v45 & 0x100) != 0) {
        int v50 = 31;
      }
      else {
        int v50 = 125;
      }
      unsigned int v51 = v50 + v49;
      unsigned int v52 = (v48 + 479) >> 1;
      char v53 = v52 - 127;
      unsigned int v54 = (v52 - 127);
      if (v51 > 0x7E) {
        LOBYTE(v51) = v51 + 1;
      }
      char v55 = v52 - 63;
      if (v54 <= 0x9F) {
        char v55 = v53;
      }
      *uint64_t v47 = v55;
      v47[1] = v51;
    }
LABEL_47:
    uint64_t v23 = 1;
    uint64_t v20 = v11;
LABEL_32:
    a2 += v23;
    v12 += v23;
    uint64_t v11 = v20;
  }
  while (v12 < a3);
LABEL_85:
  *a6 = v20;
  return v12;
}

uint64_t __CFFromNTTDocomoSJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v48 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  uint64_t v9 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v44 = (a1 >> 7) & 1;
  int v45 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11) {
      return v12;
    }
    unsigned int v13 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      uint64_t v14 = 1;
LABEL_9:
      if (v45 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v44))
      {
        unsigned int v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v47);
        uint64_t v16 = *a6;
        uint64_t v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }
          if (v15)
          {
            unint64_t v17 = v15 + 1;
            unsigned int v18 = (__int16 *)v47;
            do
            {
              __int16 v19 = *v18++;
              *a4++ = v19;
              --v17;
            }
            while (v17 > 1);
          }
        }
      }
      else
      {
        if (a5) {
          *a4++ = v13;
        }
        uint64_t v11 = *a6 + 1;
        *a6 = v11;
      }
      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }
    uint64_t v20 = v9 - 2;
    if ((unint64_t)v9 < 2) {
      return v12;
    }
    int v21 = a2[1];
    if (v13 >= 0xA0) {
      __int16 v22 = 79;
    }
    else {
      __int16 v22 = 15;
    }
    __int16 v23 = v22 + v13;
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du) {
      __int16 v24 = (2 * (v23 & 0x1FF)) | 1;
    }
    else {
      __int16 v24 = 2 * v23 + 2;
    }
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du) {
      char v25 = -31;
    }
    else {
      char v25 = -125;
    }
    if ((unsigned __int16)(((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8)) - 30067) < 0xABAEu) {
      goto LABEL_46;
    }
    unsigned int v26 = (unsigned __int16)((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8));
    uint64_t v27 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      uint64_t v29 = (0xF83E0F83E0F83E1 * (v28 - v27)) >> 1;
      unsigned int v30 = &v27[33 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v26) {
        break;
      }
      unsigned int v28 = v30 - 33;
LABEL_36:
      if (v27 > v28) {
        goto LABEL_46;
      }
    }
    if (v31 + 32 <= v26)
    {
      uint64_t v27 = v30 + 33;
      goto LABEL_36;
    }
    unsigned __int16 v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      LOWORD(v13) = v32;
      uint64_t v14 = 2;
      goto LABEL_9;
    }
LABEL_46:
    unsigned int v34 = v21 | (v13 << 8);
    if ((unsigned __int16)(v34 + 1539) < 0xFEA2u) {
      return v12;
    }
    unsigned int v35 = (unsigned __int16 *)&__CFEmojiIndexFromNTTDocomoSJIS;
    uint64_t v36 = (unsigned __int16 *)&unk_182EDB734;
    while (2)
    {
      uint64_t v37 = ((char *)v36 - (char *)v35) >> 3;
      int v38 = &v35[2 * v37];
      unsigned int v39 = *v38;
      if (v39 > v34)
      {
        uint64_t v36 = v38 - 2;
        goto LABEL_52;
      }
      if (v39 < v34)
      {
        unsigned int v35 = v38 + 2;
LABEL_52:
        if (v35 > v36) {
          return v12;
        }
        continue;
      }
      break;
    }
    uint64_t v40 = __CFFromEmojiIndex(v35[2 * v37 + 1], __src);
    uint64_t v41 = v40;
    if (!a5) {
      goto LABEL_57;
    }
    if (a5 - v11 < v40) {
      break;
    }
    memcpy(a4, __src, 2 * v40);
    a4 += v41;
    uint64_t v11 = *a6;
LABEL_57:
    v11 += v41;
    *a6 = v11;
    v12 += 2;
    a2 += 2;
    uint64_t v9 = v20;
  }
  while (v9 > 0);
  return v12;
}

uint64_t __CFToEmojiIndex(unsigned __int16 *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *a1;
  if (v4 <= 0x7F)
  {
    if (a2 >= 2 && a1[1] == 8419)
    {
      *a3 = 2;
      if ((v4 - 48) >= 0xA) {
        uint64_t v5 = -1;
      }
      else {
        uint64_t v5 = v4 + 654;
      }
      if (v4 == 35) {
        return 701;
      }
      else {
        return v5;
      }
    }
    return -1;
  }
  if ((v4 & 0xFFFE) != 0xD83C)
  {
    uint64_t v11 = (unsigned __int16 *)&unk_182EDB35E;
    uint64_t v12 = __CFBMPEmojiList;
    while (1)
    {
      unsigned int v13 = (char *)&v12[((char *)v11 - (char *)v12) >> 2];
      unsigned int v14 = *(unsigned __int16 *)v13;
      if (v14 == v4) {
        break;
      }
      unsigned int v15 = (unsigned __int16 *)(v13 - 2);
      uint64_t v16 = (unsigned __int16 *)(v13 + 2);
      if (v14 > v4) {
        uint64_t v11 = v15;
      }
      else {
        uint64_t v12 = v16;
      }
      if (v12 > v11) {
        goto LABEL_29;
      }
    }
    if (v13 - (char *)__CFBMPEmojiList == -2)
    {
LABEL_29:
      unint64_t v17 = (__int16 *)&unk_182EDB362;
      unsigned int v18 = __CFCompatibilityEmojiList;
      while (1)
      {
        __int16 v19 = (char *)&v18[((char *)v17 - (char *)v18) >> 2];
        unsigned int v20 = *(unsigned __int16 *)v19;
        if (v20 == v4) {
          break;
        }
        int v21 = (unsigned __int16 *)(v19 - 2);
        __int16 v22 = (__int16 *)(v19 + 2);
        if (v20 > v4) {
          unint64_t v17 = (__int16 *)v21;
        }
        else {
          unsigned int v18 = v22;
        }
        if (v18 > v17) {
          return -1;
        }
      }
      if (v19 - (char *)__CFCompatibilityEmojiList == -2) {
        return -1;
      }
      uint64_t result = ((v19 - (char *)__CFCompatibilityEmojiList) >> 1) + 722;
    }
    else
    {
      uint64_t result = (v13 - (char *)__CFBMPEmojiList) >> 1;
    }
    uint64_t v23 = 1;
    goto LABEL_41;
  }
  if (a2 < 2) {
    return -1;
  }
  unsigned int v7 = a1[1];
  if (v7 >> 10 != 55) {
    return -1;
  }
  unsigned int v8 = v7 + (v4 << 10);
  if (v8 - 56741350 > 0x19)
  {
    __int16 v24 = (unsigned __int16 *)&unk_182EDB176;
    unsigned int v25 = ((_WORD)v8 + 1024) & 0xFFF;
    unsigned int v26 = __CFSMPEmojiList;
    while (1)
    {
      uint64_t v27 = (char *)&v26[((char *)v24 - (char *)v26) >> 2];
      unsigned int v28 = *(unsigned __int16 *)v27;
      if (v28 == v25) {
        break;
      }
      uint64_t v29 = (unsigned __int16 *)(v27 - 2);
      unsigned int v30 = (unsigned __int16 *)(v27 + 2);
      if (v28 > v25) {
        __int16 v24 = v29;
      }
      else {
        unsigned int v26 = v30;
      }
      if (v26 > v24) {
        goto LABEL_50;
      }
    }
    if (v27 - (char *)__CFSMPEmojiList != -2)
    {
      uint64_t result = ((v27 - (char *)__CFSMPEmojiList) >> 1) + 119;
      uint64_t v23 = 2;
      goto LABEL_41;
    }
LABEL_50:
    unsigned int v31 = (unsigned __int16 *)&unk_182EDB270;
    unsigned __int16 v32 = (unsigned __int16 *)&__CFSMPUnicodeOnlyEmojiList;
    uint64_t result = -1;
    while (1)
    {
      uint64_t v33 = (char *)&v32[((char *)v31 - (char *)v32) >> 2];
      unsigned int v34 = *(unsigned __int16 *)v33;
      if (v34 == v25) {
        break;
      }
      unsigned int v35 = (unsigned __int16 *)(v33 - 2);
      uint64_t v36 = (unsigned __int16 *)(v33 + 2);
      if (v34 > v25) {
        unsigned int v31 = v35;
      }
      else {
        unsigned __int16 v32 = v36;
      }
      if (v32 > v31) {
        return result;
      }
    }
    if (v33 - (char *)&__CFSMPUnicodeOnlyEmojiList != -2)
    {
      *a3 = 2;
      return 724;
    }
    return -1;
  }
  if ((unint64_t)a2 < 4) {
    return -1;
  }
  if ((a1[2] & 0xFC00) != 0xD800) {
    return -1;
  }
  unsigned int v9 = a1[3];
  if (v9 >> 10 != 55) {
    return -1;
  }
  uint64_t v10 = 0;
  __s1[0] = v7 + 91;
  __s1[1] = v9 + 91;
  while (strncmp(__s1, __CFRegionSequences[v10], 2uLL))
  {
    if (++v10 == 10) {
      return -1;
    }
  }
  uint64_t result = v10 + 712;
  uint64_t v23 = 4;
LABEL_41:
  *a3 = v23;
  return result;
}

uint64_t __CFFromEmojiIndex(unint64_t a1, __int16 *a2)
{
  if ((uint64_t)a1 <= 118)
  {
    __int16 v2 = __CFBMPEmojiList[a1];
LABEL_3:
    *a2 = v2;
    return 1;
  }
  if (a1 <= 0x2BC)
  {
    if (a2)
    {
      int v4 = __CFSMPEmojiList[a1 - 119];
      *a2 = ((v4 + 61440) >> 10) | 0xD800;
      a2[1] = v4 & 0x3FF | 0xDC00;
    }
    return 2;
  }
  if (a1 <= 0x2C7)
  {
    __int16 v5 = a1 - 654;
    if (a1 == 701) {
      __int16 v5 = 35;
    }
    *a2 = v5;
    a2[1] = 8419;
    return 2;
  }
  if (a1 > 0x2D1)
  {
    if (a1 <= 0x2D3)
    {
      __int16 v2 = __CFCompatibilityEmojiList[a1 - 722];
      goto LABEL_3;
    }
    return 0;
  }
  else
  {
    __int16 v6 = __CFRegionSequences[a1 - 712];
    if (a2)
    {
      __int16 v7 = *v6;
      *a2 = -10180;
      a2[1] = (v7 + 421) | 0xDC00;
    }
    __int16 v8 = v6[1];
    a2[2] = -10180;
    a2[3] = (v8 + 421) | 0xDC00;
    return 4;
  }
}

uint64_t __CFToKDDISJIS(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v60[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v21 = 0;
    goto LABEL_84;
  }
  uint64_t v8 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v60[0] = 0;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_82;
      }
      int v13 = *a2;
      BOOL v14 = (v13 - 774) > 0x32 || ((1 << (v13 - 6)) & 0x4000000000005) == 0;
      unsigned int v15 = v13 - 12441;
      if (v14 && v15 >= 2) {
        goto LABEL_82;
      }
    }
    uint64_t v17 = __CFToEmojiIndex(a2, v8 - v12, v60);
    if (v17 != -1)
    {
      if (v17 == 613)
      {
        uint64_t v18 = a1;
        __int16 v19 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFKDDITable[613] - 6;
        size_t v20 = strlen(v19);
        uint64_t v21 = v20 + v11;
        if (a5)
        {
          if (v21 > a5) {
            goto LABEL_82;
          }
          size_t v22 = v20;
          memcpy(a4, v19, v20);
          a4 += v22;
          a1 = v18;
          uint64_t v8 = a3;
        }
        else
        {
          a1 = v18;
          uint64_t v8 = a3;
        }
      }
      else
      {
        uint64_t v21 = v11 + 2;
        if (a5)
        {
          if (v21 > a5) {
            goto LABEL_82;
          }
          *(_WORD *)a4 = __rev16(__CFKDDITable[v17]);
          a4 += 2;
        }
      }
      uint64_t v24 = v60[0];
      goto LABEL_31;
    }
    unsigned int v23 = *a2;
    if (v23 <= 0x7F)
    {
      uint64_t v21 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    if ((unsigned __int16)(v23 + 159) <= 0x3Eu)
    {
      uint64_t v21 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      LOBYTE(v23) = v23 + 64;
LABEL_27:
      *a4++ = v23;
      goto LABEL_28;
    }
    if ((unsigned __int16)(v23 + 12) < 0xACu)
    {
      LOWORD(v25) = -3;
      goto LABEL_42;
    }
    unsigned int v26 = (unsigned __int16 *)&__CFToJISCharMap;
    uint64_t v27 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v28 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v27 - v26)) >> 1;
      uint64_t v29 = &v26[17 * v28];
      unsigned int v30 = *v29;
      if (v30 <= v23) {
        break;
      }
      uint64_t v27 = v29 - 17;
LABEL_40:
      if (v26 > v27) {
        goto LABEL_41;
      }
    }
    if (v30 + 16 <= v23)
    {
      unsigned int v26 = v29 + 17;
      goto LABEL_40;
    }
    uint64_t v37 = (char *)&v26[17 * v28];
    int v25 = *(__int16 *)&v37[2 * (v23 - v30) + 2];
    if (*(_WORD *)&v37[2 * (v23 - v30) + 2])
    {
      if (v25 >= 256)
      {
        uint64_t v21 = v11 + 2;
        if (a5)
        {
          if (v21 <= a5)
          {
            int v38 = BYTE1(v25);
            int v39 = v25 & 0x7F;
            if ((v25 & 0x100) != 0) {
              int v40 = 31;
            }
            else {
              int v40 = 125;
            }
            unsigned int v41 = v40 + v39;
            unsigned int v42 = (v38 + 479) >> 1;
            char v43 = v42 - 127;
            unsigned int v44 = (v42 - 127);
            if (v41 > 0x7E) {
              LOBYTE(v41) = v41 + 1;
            }
            char v45 = v42 - 63;
            if (v44 <= 0x9F) {
              char v45 = v43;
            }
            *a4 = v45;
            a4[1] = v41;
            a4 += 2;
            goto LABEL_28;
          }
LABEL_82:
          uint64_t v21 = v11;
          break;
        }
LABEL_28:
        uint64_t v24 = 1;
        goto LABEL_31;
      }
    }
    else
    {
LABEL_41:
      LOWORD(v25) = -3;
    }
LABEL_42:
    if ((a1 & 8) != 0 || v12 < 1 || (unsigned __int16)v25 != 65533) {
      goto LABEL_82;
    }
    if ((a1 & 0x10) == 0) {
      goto LABEL_46;
    }
    if ((v23 - 774 > 0x32 || ((1 << (v23 - 6)) & 0x4000000000005) == 0) && v23 - 12441 >= 2) {
      goto LABEL_82;
    }
    unsigned int v31 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    if ((unsigned __int16)(v31 + 12) < 0xACu) {
      goto LABEL_82;
    }
    unsigned __int16 v32 = (unsigned __int16 *)&__CFToJISCharMap;
    uint64_t v33 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      uint64_t v34 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v33 - v32)) >> 1;
      unsigned int v35 = &v32[17 * v34];
      unsigned int v36 = *v35;
      if (v36 > v31)
      {
        uint64_t v33 = v35 - 17;
        goto LABEL_56;
      }
      if (v36 + 16 <= v31)
      {
        unsigned __int16 v32 = v35 + 17;
LABEL_56:
        if (v32 > v33) {
          goto LABEL_82;
        }
        continue;
      }
      break;
    }
    int v46 = (__int16)v32[17 * v34 + 1 + (int)(v31 - v36)];
    if (v46 < 1) {
      goto LABEL_82;
    }
    if (a5)
    {
      uint64_t v47 = -2;
      if (*(a4 - 1) == 61) {
        uint64_t v47 = -1;
      }
      uint64_t v48 = &a4[v47];
      int v49 = BYTE1(v46);
      int v50 = v46 & 0x7F;
      if ((v46 & 0x100) != 0) {
        int v51 = 31;
      }
      else {
        int v51 = 125;
      }
      unsigned int v52 = v51 + v50;
      unsigned int v53 = (v49 + 479) >> 1;
      char v54 = v53 - 127;
      unsigned int v55 = (v53 - 127);
      if (v52 > 0x7E) {
        LOBYTE(v52) = v52 + 1;
      }
      char v56 = v53 - 63;
      if (v55 <= 0x9F) {
        char v56 = v54;
      }
      *uint64_t v48 = v56;
      v48[1] = v52;
    }
LABEL_46:
    uint64_t v24 = 1;
    uint64_t v21 = v11;
LABEL_31:
    a2 += v24;
    v12 += v24;
    uint64_t v11 = v21;
  }
  while (v12 < v8);
LABEL_84:
  *a6 = v21;
  return v12;
}

uint64_t __CFFromKDDISJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v51 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  uint64_t v9 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v47 = (a1 >> 7) & 1;
  int v48 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11) {
      return v12;
    }
    unsigned int v13 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      uint64_t v14 = 1;
      goto LABEL_9;
    }
    uint64_t v20 = v9 - 2;
    if ((unint64_t)v9 < 2) {
      return v12;
    }
    int v21 = a2[1];
    unsigned int v22 = v21 | (v13 << 8);
    if (v13 >= 0xA0) {
      __int16 v23 = 79;
    }
    else {
      __int16 v23 = 15;
    }
    __int16 v24 = v23 + v13;
    __int16 v25 = (2 * (v24 & 0x1FF)) | 1;
    int v26 = v21 + ((char)v21 >> 7);
    __int16 v27 = 2 * v24 + 2;
    if (v26 <= 0x9Du) {
      __int16 v28 = v25;
    }
    else {
      __int16 v28 = v27;
    }
    if (v26 <= 0x9Du) {
      char v29 = -31;
    }
    else {
      char v29 = -125;
    }
    unsigned __int16 v30 = (v29 + v26) | (unsigned __int16)(v28 << 8);
    if ((unsigned __int16)(v30 - 30067) < 0xABAEu) {
      goto LABEL_37;
    }
    unsigned int v31 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    unsigned __int16 v32 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      uint64_t v33 = (0xF83E0F83E0F83E1 * (v32 - v31)) >> 1;
      uint64_t v34 = &v31[33 * v33];
      unsigned int v35 = *v34;
      if (v35 <= v30) {
        break;
      }
      unsigned __int16 v32 = v34 - 33;
LABEL_36:
      if (v31 > v32) {
        goto LABEL_37;
      }
    }
    if (v35 + 32 <= v30)
    {
      unsigned int v31 = v34 + 33;
      goto LABEL_36;
    }
    LOWORD(v13) = v31[33 * v33 + 1 + (int)(v30 - v35)];
    if ((_WORD)v13)
    {
      unsigned int v36 = (unsigned __int16)(v22 + 31054);
      if ((unsigned __int16)v13 == 65533 || v36 <= 3)
      {
        if (v36 > 3) {
          goto LABEL_48;
        }
LABEL_38:
        LOWORD(v22) = __CFFromKDDISJIS_KDDI_old_2_new_table[v22 - 34482] - 2128;
        goto LABEL_49;
      }
      uint64_t v14 = 2;
LABEL_9:
      if (v48 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v47))
      {
        unsigned int v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v50);
        uint64_t v16 = *a6;
        uint64_t v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }
          if (v15)
          {
            unint64_t v17 = v15 + 1;
            uint64_t v18 = (__int16 *)v50;
            do
            {
              __int16 v19 = *v18++;
              *a4++ = v19;
              --v17;
            }
            while (v17 > 1);
          }
        }
      }
      else
      {
        if (a5) {
          *a4++ = v13;
        }
        uint64_t v11 = *a6 + 1;
        *a6 = v11;
      }
      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }
LABEL_37:
    if ((unsigned __int16)(v22 + 31054) < 4u) {
      goto LABEL_38;
    }
LABEL_48:
    if (v22 >> 6 < 0x3CD) {
      return v12;
    }
LABEL_49:
    if ((unsigned __int16)v22 > 0xF7FCu) {
      return v12;
    }
    int v38 = (unsigned __int16 *)&__CFEmojiIndexFromKDDI_SJIS;
    int v39 = (unsigned __int16 *)&unk_182EDC6C6;
    while (2)
    {
      uint64_t v40 = ((char *)v39 - (char *)v38) >> 3;
      unsigned int v41 = &v38[2 * v40];
      unsigned int v42 = *v41;
      if (v42 > (unsigned __int16)v22)
      {
        int v39 = v41 - 2;
        goto LABEL_55;
      }
      if (v42 < (unsigned __int16)v22)
      {
        int v38 = v41 + 2;
LABEL_55:
        if (v38 > v39) {
          return v12;
        }
        continue;
      }
      break;
    }
    uint64_t v43 = __CFFromEmojiIndex(v38[2 * v40 + 1], __src);
    uint64_t v44 = v43;
    if (!a5) {
      goto LABEL_60;
    }
    if (a5 - v11 < v43) {
      break;
    }
    memcpy(a4, __src, 2 * v43);
    a4 += v44;
    uint64_t v11 = *a6;
LABEL_60:
    v11 += v44;
    *a6 = v11;
    v12 += 2;
    a2 += 2;
    uint64_t v9 = v20;
  }
  while (v9 > 0);
  return v12;
}

uint64_t __CFToISO_2022_JP_KDDI(char a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  v78[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v67 = 0;
    goto LABEL_172;
  }
  uint64_t v8 = a3;
  unsigned int v74 = a6;
  uint64_t v9 = a2 - 2;
  uint64_t v76 = a2;
LABEL_3:
  BOOL v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v13 = 0;
  do
  {
    if (a5 && a5 <= v11)
    {
      if ((a1 & 0x10) == 0) {
        break;
      }
      uint64_t v14 = (unsigned __int16 *)(a2 + 2 * v12);
      uint64_t v15 = *v14;
      BOOL v16 = (v15 - 774) > 0x32 || ((1 << (v15 - 6)) & 0x4000000000005) == 0;
      if (v16 && (v15 - 12441) >= 2) {
        break;
      }
    }
    else
    {
      uint64_t v14 = (unsigned __int16 *)(a2 + 2 * v12);
      uint64_t v15 = *v14;
      if (v15 <= 0x7F)
      {
        if (v12 + 1 >= v8 || *(_WORD *)(a2 + 2 * (v12 + 1)) != 8419)
        {
          BOOL v10 = v13 != 0;
          if (v13) {
            uint64_t v18 = 4;
          }
          else {
            uint64_t v18 = 1;
          }
          if (!a5)
          {
            unsigned int v13 = 0;
            goto LABEL_147;
          }
          if (a5 - v11 >= v18)
          {
            if (v13)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16936;
              a4 += 3;
            }
            unsigned int v13 = 0;
            *a4++ = v15;
            goto LABEL_147;
          }
          break;
        }
        goto LABEL_37;
      }
    }
    if ((unsigned __int16)(v15 + 159) <= 0x3Eu)
    {
      BOOL v10 = v13 != 3;
      if (v13 == 3) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = 4;
      }
      if (a5)
      {
        if (a5 - v11 < v18) {
          break;
        }
        if (v13 != 3)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 18728;
          a4 += 3;
        }
        *a4++ = v15 - 64;
      }
      unsigned int v13 = 3;
      goto LABEL_147;
    }
LABEL_37:
    if (v15 == 8254 || v15 == 165)
    {
      BOOL v10 = v13 != 2;
      if (v13 == 2) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = 4;
      }
      if (a5)
      {
        if (a5 - v11 < v18) {
          break;
        }
        if (v13 != 2)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 18984;
          a4 += 3;
        }
        if (v15 == 165) {
          char v19 = 92;
        }
        else {
          char v19 = 126;
        }
        *a4++ = v19;
      }
      unsigned int v13 = 2;
      goto LABEL_147;
    }
    BOOL v75 = v10;
    v78[0] = 0;
    uint64_t v20 = __CFToEmojiIndex(v14, v8 - v12, v78);
    if (v20 != -1)
    {
      unsigned int v21 = __CFKDDITable[v20];
      BOOL v10 = v13 != 1;
      if (v13 == 1) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = 3;
      }
      if (v20 == 613)
      {
        __int16 v23 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFKDDITable[613] - 6;
        int64_t v24 = strlen(v23);
        uint64_t v18 = v24 + v22;
        if (!a5)
        {
          BOOL v10 = v13 != 1;
LABEL_106:
          v12 += v78[0];
          unsigned int v13 = 1;
          a2 = v76;
          goto LABEL_148;
        }
        BOOL v10 = v13 != 1;
        if (a5 - v11 >= v18)
        {
          if (v13 != 1)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 16932;
            a4 += 3;
          }
          if (v24 >= 1)
          {
            __int16 v25 = (unsigned __int8 *)&v23[v24];
            do
            {
              unsigned int v26 = *(unsigned __int8 *)v23;
              int v27 = *((unsigned __int8 *)v23 + 1);
              int v28 = v27 | (v26 << 8);
              unsigned int v29 = (unsigned __int16)((v27 | ((_WORD)v26 << 8)) + 3264);
              if ((unsigned __int16)((v27 | ((_WORD)v26 << 8)) + 2496) <= 0x1BCu) {
                unsigned int v26 = (v28 - 2816) >> 8;
              }
              unsigned int v30 = (v28 - 1536) >> 8;
              if (v29 <= 0x14D) {
                LOBYTE(v26) = v30;
              }
              if ((v26 & 0xE0) >= 0xA0) {
                char v31 = 79;
              }
              else {
                char v31 = 15;
              }
              char v32 = 2 * (v31 + v26);
              char v33 = v32 | 1;
              int v34 = v27 + ((char)v27 >> 7);
              unsigned int v35 = (v27 + ((char)v27 >> 7));
              char v36 = v32 + 2;
              BOOL v37 = v35 > 0x9D;
              if (v35 <= 0x9D) {
                char v38 = v33;
              }
              else {
                char v38 = v36;
              }
              if (v37) {
                char v39 = 3;
              }
              else {
                char v39 = 97;
              }
              *a4 = v38 & 0x7F;
              a4[1] = (v39 + v34) & 0x7F;
              a4 += 2;
              v23 += 2;
            }
            while (v23 < (const char *)v25);
          }
          goto LABEL_106;
        }
      }
      else
      {
        unsigned int v45 = v21 >> 8;
        if ((unsigned __int16)(v21 + 2496) <= 0x1BCu) {
          unsigned int v45 = (v21 - 2816) >> 8;
        }
        if ((unsigned __int16)(v21 + 3264) <= 0x14Du) {
          unsigned int v46 = (v21 - 1536) >> 8;
        }
        else {
          LOBYTE(v46) = v45;
        }
        if ((v46 & 0xE0) >= 0xA0) {
          char v47 = 79;
        }
        else {
          char v47 = 15;
        }
        char v48 = v47 + v46;
        unsigned int v49 = v21 + ((char)v21 >> 7);
        if (v49 <= 0x9Du) {
          char v50 = (2 * v48) | 1;
        }
        else {
          char v50 = 2 * v48 + 2;
        }
        if (v49 <= 0x9Du) {
          char v51 = 97;
        }
        else {
          char v51 = 3;
        }
        uint64_t v18 = v22 + 2;
        if (!a5) {
          goto LABEL_106;
        }
        if (a5 - v11 >= v18)
        {
          if (v13 != 1)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 16932;
            a4 += 3;
          }
          *a4 = v50 & 0x7F;
          a4[1] = (v51 + v49) & 0x7F;
          a4 += 2;
          goto LABEL_106;
        }
      }
LABEL_166:
      a2 = v76;
      if (!v13) {
        goto LABEL_167;
      }
LABEL_150:
      uint64_t v67 = v11 + 3;
      if (!a5) {
        goto LABEL_171;
      }
      if (v67 <= a5)
      {
        *a4 = 27;
        *(_WORD *)(a4 + 1) = 16936;
        goto LABEL_171;
      }
      do
      {
        uint64_t v68 = v12;
        uint64_t v69 = *(unsigned __int16 *)(v9 + 2 * v12);
        if (((v69 - 774) > 0x32 || ((1 << (v69 - 6)) & 0x4000000000005) == 0)
          && (v69 - 12441) >= 2)
        {
          char IsValidCombiningCharacterForLatin1_4 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4(v69);
          a2 = v76;
        }
        else
        {
          char IsValidCombiningCharacterForLatin1_4 = 1;
        }
        --v12;
      }
      while (v68 >= 2 && (IsValidCombiningCharacterForLatin1_4 & 1) != 0);
      if (v68 < 2)
      {
        uint64_t v67 = 0;
        goto LABEL_171;
      }
      a4 -= v11;
      uint64_t v8 = v68 - 1;
      goto LABEL_3;
    }
    BOOL v10 = v75;
    if ((unsigned __int16)(v15 + 12) < 0xACu) {
      goto LABEL_120;
    }
    uint64_t v40 = (unsigned __int16 *)&__CFToJISCharMap;
    unsigned int v41 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v42 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v41 - v40)) >> 1;
      uint64_t v43 = &v40[17 * v42];
      unsigned int v44 = *v43;
      if (v44 <= v15) {
        break;
      }
      unsigned int v41 = v43 - 17;
LABEL_84:
      if (v40 > v41) {
        goto LABEL_120;
      }
    }
    if (v44 + 16 <= v15)
    {
      uint64_t v40 = v43 + 17;
      goto LABEL_84;
    }
    unsigned int v52 = v40[17 * v42 + 1 + (int)(v15 - v44)];
    if (v40[17 * v42 + 1 + (int)(v15 - v44)]) {
      BOOL v53 = v52 > 0x7531;
    }
    else {
      BOOL v53 = 1;
    }
    if (v53 || v52 - 10529 < 0x62E)
    {
LABEL_120:
      if ((a1 & 8) == 0)
      {
        if ((v15 - 774) <= 0x32 && ((1 << (v15 - 6)) & 0x4000000000005) != 0
          || (v15 - 12441) < 2
          || (v56 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4(v15), BOOL v10 = v75, v56))
        {
          if ((a1 & 0x10) != 0)
          {
            uint64_t v57 = v76 + 2 * v12;
            unsigned int v59 = *(unsigned __int16 *)(v57 - 2);
            unsigned int v58 = (unsigned __int16 *)(v57 - 2);
            if (v59 > 0x7F) {
              unsigned int v60 = __CFPrecomposeCharJapanese(v58, 0);
            }
            else {
              unsigned int v60 = __CFStringEncodingPrecomposeLatinCharacter_6(v58, v8 - v12 + 1, 0);
            }
            unsigned int v61 = __CFToJIS(v60, 1);
            if (!v61 || v61 == 65533 || (v61 & 0x8000) != 0) {
              goto LABEL_166;
            }
            if (v13 == 1)
            {
              uint64_t v18 = 0;
              unsigned int v62 = 0;
              BOOL v10 = 0;
              uint64_t v63 = 2;
              if (!a5) {
                goto LABEL_145;
              }
LABEL_135:
              if (a5 - v11 >= v18)
              {
                a4 -= v63;
                char v54 = v61;
                unsigned int v55 = v61 >> 8;
                if (v13 != 1)
                {
                  *a4 = 27;
                  unsigned int v64 = a4 + 1;
                  BOOL v65 = v10;
                  __int16 v66 = v61;
                  strncpy(v64, *v62, *((unsigned __int8 *)v62 + 8));
                  LOBYTE(v55) = HIBYTE(v66);
                  char v54 = v66;
                  BOOL v10 = v65;
                  a4 = &v64[*((unsigned __int8 *)v62 + 8)];
                }
                goto LABEL_138;
              }
              goto LABEL_166;
            }
            if (v13) {
              uint64_t v63 = 2;
            }
            else {
              uint64_t v63 = 1;
            }
            if (v75) {
              v63 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1;
            }
            uint64_t v18 = 5 - v63;
            BOOL v10 = 1;
            unsigned int v62 = &off_1ECDFDDD8;
            if (a5) {
              goto LABEL_135;
            }
LABEL_145:
            unsigned int v13 = 1;
          }
          else
          {
            uint64_t v18 = 0;
          }
          a2 = v76;
          goto LABEL_147;
        }
      }
      goto LABEL_166;
    }
    if (v52 < 0x100) {
      goto LABEL_166;
    }
    BOOL v10 = v13 != 1;
    if (v13 == 1) {
      uint64_t v18 = 2;
    }
    else {
      uint64_t v18 = 5;
    }
    if (!a5) {
      goto LABEL_145;
    }
    if (a5 - v11 < v18) {
      goto LABEL_166;
    }
    char v54 = v40[17 * v42 + 1 + (int)(v15 - v44)];
    unsigned int v55 = v52 >> 8;
    if (v13 != 1)
    {
      *a4 = 27;
      *(_WORD *)(a4 + 1) = 16932;
      a4 += 3;
    }
LABEL_138:
    a2 = v76;
    *a4 = v55;
    a4[1] = v54 & 0x7F;
    a4 += 2;
    unsigned int v13 = 1;
LABEL_147:
    ++v12;
LABEL_148:
    v11 += v18;
  }
  while (v12 < v8);
  if (v13) {
    goto LABEL_150;
  }
LABEL_167:
  uint64_t v67 = v11;
LABEL_171:
  a6 = v74;
LABEL_172:
  *a6 = v67;
  return v12;
}

uint64_t __CFFromISO_2022_JP_KDDI(unsigned int a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, void *a6)
{
  __int16 v6 = a6;
  uint64_t v64 = *(void *)off_1ECE0A5B0;
  if (__CFADD__(a2, a3))
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    if (a6) {
      goto LABEL_104;
    }
  }
  else
  {
    uint64_t v10 = a3;
    if (a3 < 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      goto LABEL_104;
    }
    uint64_t v11 = a4;
    uint64_t v12 = a2;
    unint64_t v56 = (unint64_t)&a2[a3];
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v8 = 0;
    int v59 = a1 & 0xC0;
    unsigned int v60 = a1;
    uint64_t v7 = 0;
    BOOL v16 = a4;
    uint64_t v62 = a5;
    while (2)
    {
      uint64_t v9 = v8;
      unint64_t v17 = (const char *)v12;
      uint64_t v18 = v10;
LABEL_8:
      if (a5 && a5 <= v7) {
        goto LABEL_93;
      }
      int v19 = *(unsigned __int8 *)v17;
      if (v19 != 27)
      {
        switch(v14)
        {
          case 1:
            if ((unint64_t)v18 < 2) {
              goto LABEL_92;
            }
            int v20 = *((unsigned __int8 *)v17 + 1);
            if (v19) {
              int v21 = 31;
            }
            else {
              int v21 = 125;
            }
            unsigned int v22 = (v20 & 0x7F) + v21;
            unsigned int v23 = (v19 + 479) >> 1;
            __int16 v24 = v23 - 127;
            unsigned int v25 = (v23 - 127);
            if (v22 > 0x7E) {
              LOBYTE(v22) = v22 + 1;
            }
            __int16 v26 = v23 - 63;
            if (v25 <= 0x9F) {
              __int16 v26 = v24;
            }
            unsigned __int16 v27 = v22 | (unsigned __int16)(v26 << 8);
            unsigned int v28 = (unsigned __int16)(v27 + 4800);
            if ((unsigned __int16)(v27 + 5312) >= 0x1BDu) {
              unsigned __int16 v29 = v27;
            }
            else {
              unsigned __int16 v29 = v27 + 2816;
            }
            unsigned __int16 v30 = v27 + 1536;
            if (v28 > 0x14D) {
              unsigned __int16 v30 = v29;
            }
            if ((unsigned __int16)(v30 + 2051) < 0xFB43u)
            {
LABEL_39:
              if (a1)
              {
                unsigned __int16 v45 = 63;
                uint64_t v11 = v16;
                goto LABEL_58;
              }
              unsigned int v39 = v20 | (v19 << 8);
              if ((unsigned __int16)(v39 - 30067) < 0xABAEu)
              {
LABEL_92:
                LODWORD(v14) = 1;
LABEL_93:
                uint64_t v10 = v18;
                uint64_t v12 = (unsigned __int8 *)v17;
                uint64_t v8 = v9;
                goto LABEL_94;
              }
              uint64_t v11 = v16;
              uint64_t v40 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
              unsigned int v41 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
              while (2)
              {
                uint64_t v42 = (0xF83E0F83E0F83E1 * (v41 - v40)) >> 1;
                uint64_t v43 = &v40[33 * v42];
                unsigned int v44 = *v43;
                if (v44 > v39)
                {
                  unsigned int v41 = v43 - 33;
                  goto LABEL_46;
                }
                if (v44 + 32 <= v39)
                {
                  uint64_t v40 = v43 + 33;
LABEL_46:
                  if (v40 > v41) {
                    goto LABEL_92;
                  }
                  continue;
                }
                break;
              }
              unsigned __int16 v45 = v40[33 * v42 + 1 + (int)(v39 - v44)];
              if (v45) {
                BOOL v46 = v45 == 65533;
              }
              else {
                BOOL v46 = 1;
              }
              if (v46) {
                goto LABEL_92;
              }
LABEL_58:
              uint64_t v47 = v14;
              if (!v59
                || (int IsDecomposableCharacter_2 = __CFStringEncodingIsDecomposableCharacter_2(v45, (a1 >> 7) & 1),
                    a1 = v60,
                    a5 = v62,
                    !IsDecomposableCharacter_2))
              {
                if (a5) {
                  *v11++ = v45;
                }
                uint64_t v8 = v9;
                uint64_t v12 = (unsigned __int8 *)v17;
                uint64_t v10 = v18;
                uint64_t v15 = v7;
                goto LABEL_67;
              }
              uint64_t v15 = v7 + 1;
              if (!v62) {
                goto LABEL_63;
              }
              if (v7 + 2 > v62) {
                return v9;
              }
              __CFStringEncodingDecomposeCharacter_2(v60, v45, v11);
              uint64_t v15 = v7 + 1;
              a1 = v60;
              a5 = v62;
              v11 += 2;
LABEL_63:
              uint64_t v8 = v9;
              uint64_t v12 = (unsigned __int8 *)v17;
              uint64_t v10 = v18;
LABEL_67:
              uint64_t v49 = 2;
              uint64_t v14 = v47;
              __int16 v6 = a6;
LABEL_68:
              uint64_t v7 = v15 + 1;
              uint64_t v9 = v8;
              unint64_t v17 = (const char *)v12;
              uint64_t v18 = v10;
LABEL_69:
              uint64_t v8 = v49 + v9;
              uint64_t v12 = (unsigned __int8 *)&v17[v49];
              uint64_t v10 = v18 - v49;
              uint64_t v15 = v7;
              BOOL v16 = v11;
              if (v18 - v49 < 1) {
                goto LABEL_94;
              }
              continue;
            }
            char v31 = (unsigned __int16 *)&__CFEmojiIndexFromKDDI_SJIS;
            char v32 = (unsigned __int16 *)&unk_182EDC6C6;
            while (1)
            {
              uint64_t v33 = ((char *)v32 - (char *)v31) >> 3;
              int v34 = &v31[2 * v33];
              unsigned int v35 = *v34;
              if (v35 <= v30)
              {
                if (v35 >= v30)
                {
                  uint64_t v57 = v15;
                  uint64_t v36 = __CFFromEmojiIndex(v31[2 * v33 + 1], __src);
                  a5 = v62;
                  uint64_t v37 = v36;
                  if (v62)
                  {
                    if (v62 - v7 < v36)
                    {
                      LODWORD(v14) = 1;
                      uint64_t v10 = v18;
                      uint64_t v12 = (unsigned __int8 *)v17;
                      uint64_t v8 = v9;
                      __int16 v6 = a6;
                      goto LABEL_94;
                    }
                    memcpy(v16, __src, 2 * v36);
                    a5 = v62;
                    v16 += v37;
                  }
                  a1 = v60;
                  v7 += v37;
                  v9 += 2;
                  v17 += 2;
                  BOOL v38 = v18 <= 2;
                  v18 -= 2;
                  __int16 v6 = a6;
                  uint64_t v14 = 1;
                  uint64_t v15 = v57;
                  if (v38) {
                    goto LABEL_92;
                  }
                  goto LABEL_8;
                }
                char v31 = v34 + 2;
              }
              else
              {
                char v32 = v34 - 2;
              }
              if (v31 > v32) {
                goto LABEL_39;
              }
            }
          case 3:
            if ((v19 - 96) < 0xFFFFFFC1)
            {
              LODWORD(v14) = 1;
              goto LABEL_108;
            }
            if (a5)
            {
              LOWORD(v19) = v19 - 192;
LABEL_89:
              *v11++ = v19;
            }
            break;
          case 2:
            if (a5)
            {
              if (v19 == 126) {
                __int16 v54 = 8254;
              }
              else {
                __int16 v54 = *(unsigned __int8 *)v17;
              }
              if (v19 == 92) {
                LOWORD(v19) = 165;
              }
              else {
                LOWORD(v19) = v54;
              }
              goto LABEL_89;
            }
            break;
          case 0:
            if (!a5) {
              break;
            }
            goto LABEL_89;
          default:
LABEL_108:
            uint64_t v7 = v15;
            goto LABEL_94;
        }
        uint64_t v49 = 1;
        goto LABEL_68;
      }
      break;
    }
    uint64_t v58 = v7;
    uint64_t v50 = v14;
    for (uint64_t i = 0; i != 18; i += 2)
    {
      uint64_t v52 = LOBYTE((&__CFISO2022JPSequences)[i + 1]);
      if (v56 >= (unint64_t)&v17[v52 + 1])
      {
        int v53 = strncmp((&__CFISO2022JPSequences)[i], v17 + 1, LOBYTE((&__CFISO2022JPSequences)[i + 1]));
        a5 = v62;
        if (!v53)
        {
          uint64_t v14 = *((unsigned __int8 *)&__CFISO2022JPSequences + 8 * i + 9);
          uint64_t v49 = v52 + 1;
          __int16 v6 = a6;
          a1 = v60;
          uint64_t v11 = v16;
          uint64_t v7 = v58;
          goto LABEL_69;
        }
      }
    }
    uint64_t v14 = v50;
    if ((v50 & 0xFD) == 0)
    {
      uint64_t v11 = v16;
      __int16 v6 = a6;
      if (a5)
      {
        *BOOL v16 = 27;
        uint64_t v11 = v16 + 1;
      }
      a1 = v60;
      uint64_t v7 = v58 + 1;
      uint64_t v49 = 1;
      goto LABEL_69;
    }
    uint64_t v10 = v18;
    uint64_t v12 = (unsigned __int8 *)v17;
    uint64_t v8 = v9;
    __int16 v6 = a6;
    uint64_t v7 = v58;
LABEL_94:
    if (a5 {
      && v14
    }
      && v10 == 3
      && v7 == a5
      && *v12 == 27
      && v56 >= (unint64_t)(v12 + 3)
      && !strncmp("(B", (const char *)v12 + 1, 2uLL))
    {
      v8 += 3;
    }
LABEL_104:
    *__int16 v6 = v7;
    return v8;
  }
  return v9;
}

uint64_t __CFToSoftBankSJIS(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v61[1] = *(void *)off_1ECE0A5B0;
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v22 = 0;
    goto LABEL_84;
  }
  uint64_t v8 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v61[0] = 0;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_82;
      }
      int v13 = *a2;
      BOOL v14 = (v13 - 774) > 0x32 || ((1 << (v13 - 6)) & 0x4000000000005) == 0;
      unsigned int v15 = v13 - 12441;
      if (v14 && v15 >= 2) {
        goto LABEL_82;
      }
    }
    uint64_t v17 = __CFToEmojiIndex(a2, v8 - v12, v61);
    if (v17 != -1)
    {
      unsigned int v18 = __CFSoftBankTable[v17];
      if (v18 > 6)
      {
        uint64_t v22 = v11 + 2;
        if (a5)
        {
          if (v22 > a5) {
            goto LABEL_82;
          }
          *a4 = BYTE1(v18);
          a4[1] = v18;
          a4 += 2;
        }
      }
      else
      {
        uint64_t v19 = a1;
        int v20 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFSoftBankTable[v17] - 6;
        size_t v21 = strlen(v20);
        uint64_t v22 = v21 + v11;
        if (a5)
        {
          if (v22 > a5) {
            goto LABEL_82;
          }
          size_t v23 = v21;
          memcpy(a4, v20, v21);
          a4 += v23;
          a1 = v19;
          uint64_t v8 = a3;
        }
        else
        {
          a1 = v19;
          uint64_t v8 = a3;
        }
      }
      uint64_t v25 = v61[0];
      goto LABEL_31;
    }
    unsigned int v24 = *a2;
    if (v24 <= 0x7F)
    {
      uint64_t v22 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    if ((unsigned __int16)(v24 + 159) <= 0x3Eu)
    {
      uint64_t v22 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      LOBYTE(v24) = v24 + 64;
LABEL_27:
      *a4++ = v24;
      goto LABEL_28;
    }
    if ((unsigned __int16)(v24 + 12) < 0xACu)
    {
      LOWORD(v26) = -3;
      goto LABEL_42;
    }
    unsigned __int16 v27 = (unsigned __int16 *)&__CFToJISCharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v29 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v28 - v27)) >> 1;
      unsigned __int16 v30 = &v27[17 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v24) {
        break;
      }
      unsigned int v28 = v30 - 17;
LABEL_40:
      if (v27 > v28) {
        goto LABEL_41;
      }
    }
    if (v31 + 16 <= v24)
    {
      unsigned __int16 v27 = v30 + 17;
      goto LABEL_40;
    }
    BOOL v38 = (char *)&v27[17 * v29];
    int v26 = *(__int16 *)&v38[2 * (v24 - v31) + 2];
    if (*(_WORD *)&v38[2 * (v24 - v31) + 2])
    {
      if (v26 >= 256)
      {
        uint64_t v22 = v11 + 2;
        if (a5)
        {
          if (v22 <= a5)
          {
            int v39 = BYTE1(v26);
            int v40 = v26 & 0x7F;
            if ((v26 & 0x100) != 0) {
              int v41 = 31;
            }
            else {
              int v41 = 125;
            }
            unsigned int v42 = v41 + v40;
            unsigned int v43 = (v39 + 479) >> 1;
            char v44 = v43 - 127;
            unsigned int v45 = (v43 - 127);
            if (v42 > 0x7E) {
              LOBYTE(v42) = v42 + 1;
            }
            char v46 = v43 - 63;
            if (v45 <= 0x9F) {
              char v46 = v44;
            }
            *a4 = v46;
            a4[1] = v42;
            a4 += 2;
            goto LABEL_28;
          }
LABEL_82:
          uint64_t v22 = v11;
          break;
        }
LABEL_28:
        uint64_t v25 = 1;
        goto LABEL_31;
      }
    }
    else
    {
LABEL_41:
      LOWORD(v26) = -3;
    }
LABEL_42:
    if ((a1 & 8) != 0 || v12 < 1 || (unsigned __int16)v26 != 65533) {
      goto LABEL_82;
    }
    if ((a1 & 0x10) == 0) {
      goto LABEL_46;
    }
    if ((v24 - 774 > 0x32 || ((1 << (v24 - 6)) & 0x4000000000005) == 0) && v24 - 12441 >= 2) {
      goto LABEL_82;
    }
    unsigned int v32 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    if ((unsigned __int16)(v32 + 12) < 0xACu) {
      goto LABEL_82;
    }
    uint64_t v33 = (unsigned __int16 *)&__CFToJISCharMap;
    int v34 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      uint64_t v35 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v34 - v33)) >> 1;
      uint64_t v36 = &v33[17 * v35];
      unsigned int v37 = *v36;
      if (v37 > v32)
      {
        int v34 = v36 - 17;
        goto LABEL_56;
      }
      if (v37 + 16 <= v32)
      {
        uint64_t v33 = v36 + 17;
LABEL_56:
        if (v33 > v34) {
          goto LABEL_82;
        }
        continue;
      }
      break;
    }
    int v47 = (__int16)v33[17 * v35 + 1 + (int)(v32 - v37)];
    if (v47 < 1) {
      goto LABEL_82;
    }
    if (a5)
    {
      uint64_t v48 = -2;
      if (*(a4 - 1) == 61) {
        uint64_t v48 = -1;
      }
      uint64_t v49 = &a4[v48];
      int v50 = BYTE1(v47);
      int v51 = v47 & 0x7F;
      if ((v47 & 0x100) != 0) {
        int v52 = 31;
      }
      else {
        int v52 = 125;
      }
      unsigned int v53 = v52 + v51;
      unsigned int v54 = (v50 + 479) >> 1;
      char v55 = v54 - 127;
      unsigned int v56 = (v54 - 127);
      if (v53 > 0x7E) {
        LOBYTE(v53) = v53 + 1;
      }
      char v57 = v54 - 63;
      if (v56 <= 0x9F) {
        char v57 = v55;
      }
      *uint64_t v49 = v57;
      v49[1] = v53;
    }
LABEL_46:
    uint64_t v25 = 1;
    uint64_t v22 = v11;
LABEL_31:
    a2 += v25;
    v12 += v25;
    uint64_t v11 = v22;
  }
  while (v12 < v8);
LABEL_84:
  *a6 = v22;
  return v12;
}

uint64_t __CFFromSoftBankSJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v48 = *(void *)off_1ECE0A5B0;
  *a6 = 0;
  if (a3 < 1) {
    return 0;
  }
  uint64_t v9 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v44 = (a1 >> 7) & 1;
  int v45 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11) {
      return v12;
    }
    unsigned int v13 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      uint64_t v14 = 1;
LABEL_9:
      if (v45 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v44))
      {
        unsigned int v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v47);
        uint64_t v16 = *a6;
        uint64_t v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }
          if (v15)
          {
            unint64_t v17 = v15 + 1;
            unsigned int v18 = (__int16 *)v47;
            do
            {
              __int16 v19 = *v18++;
              *a4++ = v19;
              --v17;
            }
            while (v17 > 1);
          }
        }
      }
      else
      {
        if (a5) {
          *a4++ = v13;
        }
        uint64_t v11 = *a6 + 1;
        *a6 = v11;
      }
      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }
    uint64_t v20 = v9 - 2;
    if ((unint64_t)v9 < 2) {
      return v12;
    }
    int v21 = a2[1];
    if (v13 >= 0xA0) {
      __int16 v22 = 79;
    }
    else {
      __int16 v22 = 15;
    }
    __int16 v23 = v22 + v13;
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du) {
      __int16 v24 = (2 * (v23 & 0x1FF)) | 1;
    }
    else {
      __int16 v24 = 2 * v23 + 2;
    }
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du) {
      char v25 = -31;
    }
    else {
      char v25 = -125;
    }
    if ((unsigned __int16)(((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8)) - 30067) < 0xABAEu) {
      goto LABEL_46;
    }
    unsigned int v26 = (unsigned __int16)((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8));
    unsigned __int16 v27 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      uint64_t v29 = (0xF83E0F83E0F83E1 * (v28 - v27)) >> 1;
      unsigned __int16 v30 = &v27[33 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v26) {
        break;
      }
      unsigned int v28 = v30 - 33;
LABEL_36:
      if (v27 > v28) {
        goto LABEL_46;
      }
    }
    if (v31 + 32 <= v26)
    {
      unsigned __int16 v27 = v30 + 33;
      goto LABEL_36;
    }
    unsigned __int16 v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      LOWORD(v13) = v32;
      uint64_t v14 = 2;
      goto LABEL_9;
    }
LABEL_46:
    unsigned int v34 = v21 | (v13 << 8);
    if ((unsigned __int16)(v34 + 1064) < 0xFB69u) {
      return v12;
    }
    uint64_t v35 = (unsigned __int16 *)&__CFEmojiIndexFromSoftBankSJIS;
    uint64_t v36 = (unsigned __int16 *)&unk_182EDD3CC;
    while (2)
    {
      uint64_t v37 = ((char *)v36 - (char *)v35) >> 3;
      BOOL v38 = &v35[2 * v37];
      unsigned int v39 = *v38;
      if (v39 > v34)
      {
        uint64_t v36 = v38 - 2;
        goto LABEL_52;
      }
      if (v39 < v34)
      {
        uint64_t v35 = v38 + 2;
LABEL_52:
        if (v35 > v36) {
          return v12;
        }
        continue;
      }
      break;
    }
    uint64_t v40 = __CFFromEmojiIndex(v35[2 * v37 + 1], __src);
    uint64_t v41 = v40;
    if (!a5) {
      goto LABEL_57;
    }
    if (a5 - v11 < v40) {
      break;
    }
    memcpy(a4, __src, 2 * v40);
    a4 += v41;
    uint64_t v11 = *a6;
LABEL_57:
    v11 += v41;
    *a6 = v11;
    v12 += 2;
    a2 += 2;
    uint64_t v9 = v20;
  }
  while (v9 > 0);
  return v12;
}

void sub_182D01D44(_Unwind_Exception *exception_object)
{
}

void sub_182D04714(_Unwind_Exception *a1)
{
}

void sub_182D04C00(_Unwind_Exception *a1)
{
}

void _systemClockChangedNotification()
{
  LocalCenter = CFNotificationCenterGetLocalCenter();

  CFNotificationCenterPostNotification(LocalCenter, @"NSSystemClockDidChangeNotification", 0, 0, 1u);
}

double CFGetSystemUptime()
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
  }
  return *(double *)&__CF1_TSRRate * (double)mach_absolute_time();
}

const void *__CFDateCopyDescription(void *a1)
{
  __int16 v2 = (void *)_CFAutoreleasePoolPush();
  unint64_t v3 = (const void *)[a1 description];
  int v4 = v3;
  if (v3) {
    CFRetain(v3);
  }
  _CFAutoreleasePoolPop(v2);
  return v4;
}

uint64_t _NSCFCalendarLogger()
{
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  return _NSCFCalendarLogger__logger;
}

void _CFICULog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  _CFLogvEx3(0, 0, 0, 0, 7, a1, &a9);
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    if (a1)
    {
      CFStringRef v10 = _CFStringCreateWithFormatAndArgumentsAux2((const __CFAllocator *)&__kCFAllocatorSystemDefault, 0, 0, 0, 0, a1, &a9);
      if (v10)
      {
        CFStringRef v11 = v10;
        CFIndex Length = CFStringGetLength(v10);
        CFIndex v13 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 16;
        uint64_t v14 = (char *)malloc_type_malloc(v13, 0xD17E509DuLL);
        if (!v14)
        {
LABEL_17:
          CFRelease(v11);
          return;
        }
        unsigned int v15 = v14;
        CCFStringRef String = CFStringGetCString(v11, v14, v13, 0x8000100u);
        size_t v17 = strlen(v15);
        os_unfair_lock_lock((os_unfair_lock_t)&__CFICULogLock);
        fputs("// ", (FILE *)___CFICULoggingFD);
        unsigned int v18 = (FILE *)___CFICULoggingFD;
        if (CString) {
          BOOL v19 = v17 == 0;
        }
        else {
          BOOL v19 = 1;
        }
        if (v19 || v17 > 0x10000)
        {
          uint64_t v20 = "<unloggable message>\n";
        }
        else
        {
          fputs(v15, (FILE *)___CFICULoggingFD);
          if (v15[v17 - 1] == 10)
          {
LABEL_16:
            os_unfair_lock_unlock((os_unfair_lock_t)&__CFICULogLock);
            free(v15);
            goto LABEL_17;
          }
          unsigned int v18 = (FILE *)___CFICULoggingFD;
          uint64_t v20 = "\n";
        }
        fputs(v20, v18);
        goto LABEL_16;
      }
    }
  }
}

uint64_t ___CFICUCreateVariableNameForStatus(uint64_t a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = 0;
  __int16 v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = off_1ECE0A5A0;
  v3[1] = 0x40000000;
  CFStringRef v3[2] = _____CFICUCreateVariableNameForStackPointer_block_invoke;
  void v3[3] = &unk_1ECDFDFE8;
  v3[4] = &v4;
  void v3[5] = "status";
  v3[6] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableNameForStackPointer_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  ___CFICULogWithArguments(1, &stru_1ECE10768);
  ___CFICULogWithArguments(1, @"UErrorCode %@ = U_ZERO_ERROR;", v1);
  return v1;
}

void sub_182D05C94(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

CFStringRef ___CFICUCreateErrorStringWithComment(int *a1, int a2)
{
  CFTypeRef v4 = CFRetain(&stru_1ECE10768);
  if (*a1 < 1) {
    return (CFStringRef)v4;
  }
  __int16 v5 = u_errorName((UErrorCode)*a1);
  if (a2) {
    return CFStringCreateWithFormat(0, 0, @"// ERROR: %s", v5);
  }
  else {
    return CFStringCreateWithFormat(0, 0, @"(ERROR: %s)", v5);
  }
}

CFStringRef ___CFICUCreateArgumentForUCharInput(UChar *s, int32_t a2, uint64_t a3)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (s)
  {
    int32_t v4 = a2;
    if (a2 == -1) {
      int32_t v4 = u_strlen(s);
    }
    CFStringRef v10 = off_1ECE0A5A0;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = _____CFICUCreateArgumentForUCharInput_block_invoke;
    CFIndex v13 = &__block_descriptor_tmp_263;
    int v14 = a3;
    os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
    _____CFICUCreateArgumentForUCharInput_block_invoke((uint64_t)&v10);
    os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
    uint64_t v6 = (const void *)___CFICUCreateVariableName((uint64_t)"temp");
    CFStringRef v7 = CFStringCreateWithCharacters(0, s, v4);
    CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"TEMP_UCHAR%d(\"%@\")", a3, v7, v10, v11);
    CFRelease(v7);
    CFRelease(v6);
    return v8;
  }
  else
  {
    return (CFStringRef)CFRetain(@"NULL");
  }
}

uint64_t ___CFICUCreateVariableNameForStatusIfNeeded(uint64_t a1)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  char v3 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  v4[0] = off_1ECE0A5A0;
  v4[1] = 0x40000000;
  __int16 v5 = _____CFICUCreateVariableNameForStackPointerIfNeeded_block_invoke;
  uint64_t v6 = &unk_1ECDFE078;
  CFStringRef v7 = &v11;
  CFStringRef v8 = "status";
  uint64_t v9 = a1;
  CFStringRef v10 = &v3;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  v5((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v1 = v12[3];
  _Block_object_dispose(&v11, 8);
  if (v3)
  {
    ___CFICULogWithArguments(1, &stru_1ECE10768);
    ___CFICULogWithArguments(1, @"UErrorCode %@ = U_ZERO_ERROR;", v1);
  }
  return v1;
}

void sub_182D05FE8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t __cficu_ucal_getAttribute(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  uint64_t Attribute = ucal_getAttribute();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      uint64_t v6 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4) {
          CFStringRef v8 = "<unknown UCalendarAttribute>";
        }
        else {
          CFStringRef v8 = off_1ECDFE0C0[a2];
        }
        int v9 = 138412802;
        CFStringRef v10 = v5;
        __int16 v11 = 2080;
        uint64_t v12 = v8;
        __int16 v13 = 1024;
        int v14 = Attribute;
        _os_log_debug_impl(&dword_182B90000, v6, OS_LOG_TYPE_DEBUG, "ucal_getAttribute(%@, %s); // %d",
          (uint8_t *)&v9,
          0x1Cu);
      }
      CFRelease(v5);
    }
  }
  return Attribute;
}

CFStringRef ___CFICUCreateArgumentForDouble(double a1)
{
  if (fabs(a1) != INFINITY) {
    return CFStringCreateWithFormat(0, 0, @"%f", *(void *)&a1);
  }
  if (a1 <= 0.0)
  {
    char v3 = @"-INFINITY";
  }
  else
  {
    char v3 = @"INFINITY";
  }
  return (CFStringRef)CFRetain(v3);
}

void __cficu_ucal_setMillis(uint64_t a1, int *a2, double a3)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  ucal_setMillis();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateArgumentForDouble(a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v8;
        __int16 v15 = 2112;
        uint64_t v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v9;
        _os_log_debug_impl(&dword_182B90000, v10, OS_LOG_TYPE_DEBUG, "ucal_setMillis(%@, %@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
}

const char *___CFICUGetEnumStringForUCalendarDateFields(unsigned int a1)
{
  if (a1 > 0x18) {
    return "<unknown UCalendarDateFields>";
  }
  else {
    return off_1ECDFE0E8[a1];
  }
}

uint64_t __cficu_ucal_getDayOfWeekType(uint64_t a1, int a2, int *a3)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  uint64_t DayOfWeekType = ucal_getDayOfWeekType();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if ((a2 - 1) > 6) {
          CFStringRef v12 = "<unknown UCalendarDaysOfWeek>";
        }
        else {
          CFStringRef v12 = off_1ECDFE1C8[a2 - 1];
        }
        if ((DayOfWeekType - 1) > 2) {
          __int16 v13 = "UCAL_WEEKDAY";
        }
        else {
          __int16 v13 = off_1ECDFE1B0[(int)DayOfWeekType - 1];
        }
        int v14 = 138413314;
        CFStringRef v15 = v7;
        __int16 v16 = 2080;
        __int16 v17 = v12;
        __int16 v18 = 2112;
        uint64_t v19 = v8;
        __int16 v20 = 2080;
        int v21 = v13;
        __int16 v22 = 2112;
        CFStringRef v23 = v9;
        _os_log_debug_impl(&dword_182B90000, v10, OS_LOG_TYPE_DEBUG, "ucal_getDayOfWeekType(%@, %s, &%@); // %s %@",
          (uint8_t *)&v14,
          0x34u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
  return DayOfWeekType;
}

uint64_t __cficu_ucal_getWeekendTransition(uint64_t a1, int a2, int *a3)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  uint64_t WeekendTransition = ucal_getWeekendTransition();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if ((a2 - 1) > 6) {
          CFStringRef v12 = "<unknown UCalendarDaysOfWeek>";
        }
        else {
          CFStringRef v12 = off_1ECDFE1C8[a2 - 1];
        }
        int v13 = 138413314;
        CFStringRef v14 = v7;
        __int16 v15 = 2080;
        __int16 v16 = v12;
        __int16 v17 = 2112;
        __int16 v18 = v8;
        __int16 v19 = 1024;
        int v20 = WeekendTransition;
        __int16 v21 = 2112;
        CFStringRef v22 = v9;
        _os_log_debug_impl(&dword_182B90000, v10, OS_LOG_TYPE_DEBUG, "ucal_getWeekendTransition(%@, %s, &%@); // %d %@",
          (uint8_t *)&v13,
          0x30u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
  return WeekendTransition;
}

uint64_t __cficu_ucal_isWeekend(uint64_t a1, int *a2, double a3)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  uint64_t isWeekend = ucal_isWeekend();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v9 = ___CFICUCreateArgumentForDouble(a3);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      int v11 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 138413314;
        CFStringRef v14 = v7;
        __int16 v15 = 2112;
        CFStringRef v16 = v9;
        __int16 v17 = 2112;
        __int16 v18 = v8;
        __int16 v19 = 1024;
        int v20 = isWeekend;
        __int16 v21 = 2112;
        CFStringRef v22 = v10;
        _os_log_debug_impl(&dword_182B90000, v11, OS_LOG_TYPE_DEBUG, "ucal_isWeekend(%@, %@, &%@); // %d %@",
          (uint8_t *)&v13,
          0x30u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v10);
      CFRelease(v9);
    }
  }
  return isWeekend;
}

uint64_t __cficu_ucal_getLimit(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  uint64_t Limit = ucal_getLimit();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v11 = ___CFICUCreateErrorStringWithComment(a4, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v12 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v14 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        if (a3 > 5) {
          __int16 v15 = "<unknown UCalendarLimitType>";
        }
        else {
          __int16 v15 = off_1ECDFE200[a3];
        }
        int v16 = 138413570;
        CFStringRef v17 = v9;
        __int16 v18 = 2080;
        __int16 v19 = v14;
        __int16 v20 = 2080;
        __int16 v21 = v15;
        __int16 v22 = 2112;
        uint64_t v23 = v10;
        __int16 v24 = 1024;
        int v25 = Limit;
        __int16 v26 = 2112;
        CFStringRef v27 = v11;
        _os_log_debug_impl(&dword_182B90000, v12, OS_LOG_TYPE_DEBUG, "ucal_getLimit(%@, %s, %s, &%@); // %d %@",
          (uint8_t *)&v16,
          0x3Au);
      }
      CFRelease(v9);
      CFRelease(v10);
      CFRelease(v11);
    }
  }
  return Limit;
}

void __cficu_ucal_add(uint64_t a1, unsigned int a2, int a3, int *a4)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  ucal_add();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v11 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 138413314;
        CFStringRef v13 = v8;
        __int16 v14 = 2080;
        __int16 v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v16 = 1024;
        int v17 = a3;
        __int16 v18 = 2112;
        __int16 v19 = v9;
        __int16 v20 = 2112;
        CFStringRef v21 = v10;
        _os_log_debug_impl(&dword_182B90000, v11, OS_LOG_TYPE_DEBUG, "ucal_add(%@, %s, %d, &%@); %@",
          (uint8_t *)&v12,
          0x30u);
      }
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }
}

void __cficu_ucal_roll(uint64_t a1, unsigned int a2, int a3, int *a4)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  ucal_roll();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v11 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 138413314;
        CFStringRef v13 = v8;
        __int16 v14 = 2080;
        __int16 v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v16 = 1024;
        int v17 = a3;
        __int16 v18 = 2112;
        __int16 v19 = v9;
        __int16 v20 = 2112;
        CFStringRef v21 = v10;
        _os_log_debug_impl(&dword_182B90000, v11, OS_LOG_TYPE_DEBUG, "ucal_roll(%@, %s, %d, &%@); %@",
          (uint8_t *)&v12,
          0x30u);
      }
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }
}

uint64_t __cficu_ucal_getFieldDifference(uint64_t a1, unsigned int a2, int *a3, double a4)
{
  uint64_t v27 = *(void *)off_1ECE0A5B0;
  uint64_t FieldDifference = ucal_getFieldDifference();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v11 = ___CFICUCreateArgumentForDouble(a4);
      CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v13 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v15 = 138413570;
        CFStringRef v16 = v9;
        __int16 v17 = 2112;
        CFStringRef v18 = v11;
        __int16 v19 = 2080;
        __int16 v20 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v21 = 2112;
        uint64_t v22 = v10;
        __int16 v23 = 1024;
        int v24 = FieldDifference;
        __int16 v25 = 2112;
        CFStringRef v26 = v12;
        _os_log_debug_impl(&dword_182B90000, v13, OS_LOG_TYPE_DEBUG, "ucal_getFieldDifference(%@, %@, %s, &%@); // %d %@",
          (uint8_t *)&v15,
          0x3Au);
      }
      CFRelease(v9);
      CFRelease(v10);
      CFRelease(v11);
      CFRelease(v12);
    }
  }
  return FieldDifference;
}

double __cficu_ucal_getNow()
{
  double v0 = MEMORY[0x185312860]();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  uint64_t v1 = _NSCFCalendarLogger__logger;
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG)) {
    __cficu_ucal_getNow_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  return v0;
}

void ___CFICULogWithArguments(int a1, CFStringRef format, ...)
{
  va_start(va, format);
  CFStringRef v3 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (CFStringGetCStringPtr(v3, 0x8000100u))
  {
    uint64_t v4 = 0;
  }
  else
  {
    CFIndex Length = CFStringGetLength(v3);
    CFIndex v6 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    uint64_t v4 = (char *)malloc_type_malloc(v6, 0x100004077774924uLL);
    CFStringGetCString(v3, v4, v6, 0x8000100u);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFICULogLock);
  if (a1) {
    fprintf((FILE *)___CFICULoggingFD, "\t%s\n");
  }
  else {
    fprintf((FILE *)___CFICULoggingFD, "%s\n");
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFICULogLock);
  if (v4) {
    free(v4);
  }
  CFRelease(v3);
}

void __cficu_udatpg_close(uint64_t a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    udatpg_close();
    ___CFICULogWithArguments(1, @"udatpg_close(%@);", v2);
    CFRelease(v2);
  }
  else
  {
    udatpg_close();
  }
}

CFTypeRef ___CFICUCreateVariableNameForUCharOutput(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = ___CFICUCreateVariableName(a1);
    ___CFICULogWithArguments(1, @"UChar %@[%d];", v5, a3);
    return (CFTypeRef)v5;
  }
  else
  {
    return CFRetain(@"NULL");
  }
}

const char *___CFICUGetEnumStringForUDateFormatSymbolType(unsigned int a1)
{
  if (a1 > 0x15) {
    return "<unknown UDateFormatSymbolType>";
  }
  else {
    return off_1ECDFE230[a1];
  }
}

double __cficu_udat_get2DigitYearStart(uint64_t a1, int *a2)
{
  udat_get2DigitYearStart();
  double v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
    ___CFICULogWithArguments(1, CFSTR(""udat_get2DigitYearStart(%@, &%@);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v8);
  }
  return v5;
}

uint64_t __cficu_udat_isLenient(uint64_t a1)
{
  uint64_t isLenient = udat_isLenient();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v3 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, CFSTR(""udat_isLenient(%@);
    CFRelease(v3);
  }
  return isLenient;
}

uint64_t ___CFICUCreateVariableName(uint64_t a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = 0;
  double v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = off_1ECE0A5A0;
  v3[1] = 0x40000000;
  CFStringRef v3[2] = _____CFICUCreateVariableName_block_invoke;
  void v3[3] = &unk_1ECDFE0A0;
  v3[4] = &v4;
  void v3[5] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableName_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_182D077AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const char *___CFICUGetEnumStringForUDateFormatStyle(int a1)
{
  int v1 = a1 + 2;
  uint64_t result = "UDAT_FULL";
  switch(v1)
  {
    case 0:
      uint64_t result = "UDAT_IGNORE";
      break;
    case 1:
      uint64_t result = "UDAT_NONE";
      break;
    case 2:
      return result;
    case 3:
      uint64_t result = "UDAT_LONG";
      break;
    case 4:
      uint64_t result = "UDAT_MEDIUM";
      break;
    case 5:
      uint64_t result = "UDAT_SHORT";
      break;
    default:
      switch("UDAT_FULL")
      {
        case 0x80u:
          uint64_t result = "UDAT_RELATIVE";
          break;
        case 0x81u:
          uint64_t result = "UDAT_LONG_RELATIVE";
          break;
        case 0x82u:
          uint64_t result = "UDAT_MEDIUM_RELATIVE";
          break;
        case 0x83u:
          uint64_t result = "UDAT_SHORT_RELATIVE";
          break;
        default:
          uint64_t result = "<unknown UDateFormatStyle>";
          break;
      }
      break;
  }
  return result;
}

CFStringRef ___CFICUCreateArgumentForParsePosition(unsigned int *a1)
{
  if (a1)
  {
    CFStringRef v3 = (const void *)___CFICUCreateVariableName((uint64_t)"parsePos");
    CFStringRef v4 = CFStringCreateWithFormat(0, 0, @"&%@", v3);
    ___CFICULogWithArguments(1, @"int32_t %@ = %d;", v3, *a1);
    CFRelease(v3);
    return v4;
  }
  else
  {
    return (CFStringRef)CFRetain(@"NULL");
  }
}

void __cficu_udat_setSymbols(uint64_t a1, unsigned int a2, uint64_t a3, UChar *a4, uint64_t a5, int *a6)
{
  udat_setSymbols();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v15 = ___CFICUCreateArgumentForUCharInput(a4, a5, 0);
    CFStringRef v16 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, @"udat_setSymbols(%@, %s, %d, %@, %d, &%@); %@", v12, v16, a3, v15, a5, v13, v14);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v15);
    CFRelease(v14);
  }
}

const char *___CFICUGetEnumStringForUNumberFormatAttribute(int a1)
{
  uint64_t result = "UNUM_PARSE_INT_ONLY";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = "UNUM_GROUPING_USED";
      break;
    case 2:
      uint64_t result = "UNUM_DECIMAL_ALWAYS_SHOWN";
      break;
    case 3:
      uint64_t result = "UNUM_MAX_INTEGER_DIGITS";
      break;
    case 4:
      uint64_t result = "UNUM_MIN_INTEGER_DIGITS";
      break;
    case 5:
      uint64_t result = "UNUM_INTEGER_DIGITS";
      break;
    case 6:
      uint64_t result = "UNUM_MAX_FRACTION_DIGITS";
      break;
    case 7:
      uint64_t result = "UNUM_MIN_FRACTION_DIGITS";
      break;
    case 8:
      uint64_t result = "UNUM_FRACTION_DIGITS";
      break;
    case 9:
      uint64_t result = "UNUM_MULTIPLIER";
      break;
    case 10:
      uint64_t result = "UNUM_GROUPING_SIZE";
      break;
    case 11:
      uint64_t result = "UNUM_ROUNDING_MODE";
      break;
    case 12:
      uint64_t result = "UNUM_ROUNDING_INCREMENT";
      break;
    case 13:
      uint64_t result = "UNUM_FORMAT_WIDTH";
      break;
    case 14:
      uint64_t result = "UNUM_PADDING_POSITION";
      break;
    case 15:
      uint64_t result = "UNUM_SECONDARY_GROUPING_SIZE";
      break;
    case 16:
      uint64_t result = "UNUM_SIGNIFICANT_DIGITS_USED";
      break;
    case 17:
      uint64_t result = "UNUM_MIN_SIGNIFICANT_DIGITS";
      break;
    case 18:
      uint64_t result = "UNUM_MAX_SIGNIFICANT_DIGITS";
      break;
    case 19:
      uint64_t result = "UNUM_LENIENT_PARSE";
      break;
    case 20:
      uint64_t result = "UNUM_PARSE_ALL_INPUT";
      break;
    default:
      switch(a1)
      {
        case 4095:
          uint64_t result = "UNUM_MAX_NONBOOLEAN_ATTRIBUTE";
          break;
        case 4096:
          uint64_t result = "UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS";
          break;
        case 4097:
          uint64_t result = "UNUM_PARSE_NO_EXPONENT";
          break;
        case 4101:
          uint64_t result = "UNUM_LIMIT_BOOLEAN_ATTRIBUTE";
          break;
        default:
          uint64_t result = "<unknown UNumberFormatAttribute>";
          break;
      }
      break;
  }
  return result;
}

double __cficu_unum_getDoubleAttribute(uint64_t a1, int a2)
{
  unum_getDoubleAttribute();
  double v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v7 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, CFSTR(""unum_getAttribute(%@, %s);
    CFRelease(v6);
  }
  return v5;
}

const char *___CFICUGetEnumStringForUNumberFormatSymbol(unsigned int a1)
{
  if (a1 > 0x1D) {
    return "<unknown UNumberFormatSymbol>";
  }
  else {
    return off_1ECDFE2E0[a1];
  }
}

uint64_t __cficu_unum_getTextAttribute(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  Textuint64_t Attribute = unum_getTextAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFTypeRef v12 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a3, a4);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0) {
      CFStringRef v15 = CFStringCreateWithCharacters(0, a3, (int)TextAttribute);
    }
    else {
      CFStringRef v15 = 0;
    }
    if (a2 > 7) {
      CFStringRef v16 = "<unknown UNumberFormatTextAttribute>";
    }
    else {
      CFStringRef v16 = off_1ECDFE460[a2];
    }
    ___CFICULogWithArguments(1, @"unum_getTextAttribute(%@, %s, %@, %d, &%@); // %d %@ %@",
      v11,
      v16,
      v12,
      a4,
      v13,
      TextAttribute,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(v14);
  }
  return TextAttribute;
}

uint64_t __cficu_unum_parse(uint64_t a1, UChar *a2, uint64_t a3, unsigned int *a4, int *a5)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v10 = ___CFICUCreateArgumentForParsePosition(a4);
    uint64_t v11 = unum_parse();
    CFStringRef v12 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v15 = ___CFICUCreateErrorStringWithComment(a5, 0);
    ___CFICULogWithArguments(1, CFSTR(""unum_parse(%@, %@, %d, %@, &%@);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v12);
    CFRelease(v10);
    CFRelease(v15);
    return v11;
  }
  else
  {
    return unum_parse();
  }
}

uint64_t __cficu_ulistfmt_open(uint64_t a1, int *a2)
{
  uint64_t v4 = ulistfmt_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    double v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"listFmt", v4);
    CFStringRef v6 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a2);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"UListFormatter *%@ = ulistfmt_open(\"%s\", &%@); %@", v5, a1, v6, v7);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
  }
  return v4;
}

uint64_t __cficu_ulistfmt_format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const UniChar *a5, uint64_t a6, int *a7)
{
  uint64_t v14 = ulistfmt_format();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v28 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"listFmt", a1);
    CFArrayRef Mutable = CFArrayCreateMutable(0, (int)a4, &kCFTypeArrayCallBacks);
    if ((int)a4 >= 1)
    {
      uint64_t v16 = 0;
      do
      {
        CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(*(UChar **)(a2 + 8 * v16), *(_DWORD *)(a3 + 4 * v16), v16);
        CFArrayAppendValue(Mutable, v17);
        CFRelease(v17);
        ++v16;
      }
      while (a4 != v16);
    }
    uint64_t v27 = (const void *)___CFICUCreateVariableName((uint64_t)"strings");
    ___CFICULogWithArguments(1, @"UChar* const %@[%d] = {", v27, a4);
    if ((int)a4 >= 1)
    {
      unint64_t v18 = 0;
      do
      {
        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v18);
        if (v18 >= (a4 - 1)) {
          ___CFICULogWithArguments(1, @"%@", ValueAtIndex);
        }
        else {
          ___CFICULogWithArguments(1, @"%@,", ValueAtIndex);
        }
        ++v18;
      }
      while (a4 != v18);
    }
    ___CFICULogWithArguments(1, @"};\n");
    CFRelease(Mutable);
    __int16 v20 = (const void *)___CFICUCreateVariableName((uint64_t)"stringLengths");
    ___CFICULogWithArguments(1, @"int32_t %@[%d] = {", v20, a4);
    if ((int)a4 >= 1)
    {
      unint64_t v21 = 0;
      do
      {
        if (v21 >= (a4 - 1)) {
          ___CFICULogWithArguments(1, @"%d", *(unsigned int *)(a3 + 4 * v21));
        }
        else {
          ___CFICULogWithArguments(1, @"%d,", *(unsigned int *)(a3 + 4 * v21));
        }
        ++v21;
      }
      while (a4 != v21);
    }
    ___CFICULogWithArguments(1, @"};\n");
    uint64_t v22 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    CFTypeRef v23 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a5, a6);
    CFStringRef v24 = ___CFICUCreateErrorStringWithComment(a7, 0);
    if (*a7 <= 0) {
      CFStringRef v25 = CFStringCreateWithCharacters(0, a5, (int)v14);
    }
    else {
      CFStringRef v25 = 0;
    }
    ___CFICULogWithArguments(1, @"ulistfmt_format(%@, %@, %@, %d, %@, %d, &%@); // %d %@  %@",
      v28,
      v27,
      v20,
      a4,
      v23,
      a6,
      v22,
      v14,
      v25,
      v24);
    CFRelease(v28);
    CFRelease(v27);
    CFRelease(v20);
    CFRelease(v22);
    CFRelease(v23);
    CFRelease(v24);
    if (v25) {
      CFRelease(v25);
    }
  }
  return v14;
}

void __cficu_ulistfmt_close(uint64_t a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"listFmt", a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    ulistfmt_close();
    ___CFICULogWithArguments(1, @"ulistfmt_close(%@);", v2);
    CFRelease(v2);
  }
  else
  {
    ulistfmt_close();
  }
}

uint64_t __cficu_ucurr_getDefaultFractionDigits(UChar *a1, int *a2)
{
  uint64_t DefaultFractionDigits = ucurr_getDefaultFractionDigits();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    double v5 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v6 = ___CFICUCreateErrorStringWithComment(a2, 0);
    int32_t v7 = u_strlen(a1);
    CFStringRef v8 = ___CFICUCreateArgumentForUCharInput(a1, v7, 0);
    ___CFICULogWithArguments(1, @"ucurr_getDefaultFractionDigits(%@, &%@); // %d %@",
      v8,
      v5,
      DefaultFractionDigits,
      v6);
    CFRelease(v5);
    CFRelease(v8);
    CFRelease(v6);
  }
  return DefaultFractionDigits;
}

double __cficu_ucurr_getRoundingIncrement(UChar *a1, int *a2)
{
  ucurr_getRoundingIncrement();
  double v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a2, 0);
    int32_t v8 = u_strlen(a1);
    CFStringRef v9 = ___CFICUCreateArgumentForUCharInput(a1, v8, 0);
    ___CFICULogWithArguments(1, @"ucurr_getRoundingIncrement(%@, &%@); // %d %@",
      v9,
      v6,
      (int)v5,
      v7);
    CFRelease(v6);
    CFRelease(v9);
    CFRelease(v7);
  }
  return (double)(int)v5;
}

uint64_t __cficu_ureldatefmt_open(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int *a5)
{
  uint64_t v10 = ureldatefmt_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v11 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"relDateFmt", v10);
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a2);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a5);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 1);
    CFStringRef v15 = v14;
    if (a3 > 2) {
      uint64_t v16 = "<unknown UDateRelativeDateTimeFormatterStyle>";
    }
    else {
      uint64_t v16 = off_1ECDFE4A0[a3];
    }
    if ((a4 - 256) > 4) {
      CFStringRef v17 = "<unknown UDisplayContext>";
    }
    else {
      CFStringRef v17 = off_1ECDFE4B8[a4 - 256];
    }
    ___CFICULogWithArguments(1, @"URelativeDateTimeFormatter *%@ = ureldatefmt_open(\"%s\", %@, %s, %s, &%@); %@",
      v11,
      a1,
      v12,
      v16,
      v17,
      v13,
      v14);
    CFRelease(v11);
    CFRelease(v13);
    CFRelease(v15);
    CFRelease(v12);
  }
  return v10;
}

uint64_t __cficu_ureldatefmt_formatNumeric(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = ureldatefmt_formatNumeric();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    CFTypeRef v14 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a3, a4);
    CFStringRef v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (*a5 <= 0) {
      CFStringRef v17 = CFStringCreateWithCharacters(0, a3, (int)v12);
    }
    else {
      CFStringRef v17 = 0;
    }
    if (a2 > 7) {
      unint64_t v18 = "<unknown URelativeDateTimeUnit>";
    }
    else {
      unint64_t v18 = off_1ECDFE4E0[a2];
    }
    ___CFICULogWithArguments(1, @"ureldatefmt_formatNumeric(%@, %lf, %s, %@, %d, &%@); // %d, %@, %@",
      v13,
      *(void *)&a6,
      v18,
      v14,
      a4,
      v15,
      v12,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }
  return v12;
}

uint64_t __cficu_ureldatefmt_format(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = ureldatefmt_format();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    CFTypeRef v14 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a3, a4);
    CFStringRef v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (*a5 <= 0) {
      CFStringRef v17 = CFStringCreateWithCharacters(0, a3, (int)v12);
    }
    else {
      CFStringRef v17 = 0;
    }
    if (a2 > 7) {
      unint64_t v18 = "<unknown URelativeDateTimeUnit>";
    }
    else {
      unint64_t v18 = off_1ECDFE4E0[a2];
    }
    ___CFICULogWithArguments(1, @"ureldatefmt_formatNumeric(%@, %lf, %s, %@, %d, &%@); // %d, %@, %@",
      v13,
      *(void *)&a6,
      v18,
      v14,
      a4,
      v15,
      v12,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }
  return v12;
}

void __cficu_ureldatefmt_close(uint64_t a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    ureldatefmt_close();
    ___CFICULogWithArguments(1, @"ureldatefmt_close(%@);", v2);
    CFRelease(v2);
  }
  else
  {
    ureldatefmt_close();
  }
}

void ___CFICUEmitPostamble()
{
  ___CFICULogWithArguments(1, &stru_1ECE10768);
  ___CFICULogWithArguments(1, @"return 0;");

  ___CFICULogWithArguments(0, @"}");
}

uint64_t ___CFICUCreateVariableNameForHeapPointer(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uint64_t v5 = 0;
  CFStringRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = off_1ECE0A5A0;
  v4[1] = 0x40000000;
  void v4[2] = _____CFICUCreateVariableNameForHeapPointer_block_invoke;
  v4[3] = &unk_1ECDFDFC0;
  v4[4] = &v5;
  v4[5] = a1;
  v4[6] = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableNameForHeapPointer_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182D08D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef ___CFICUCreateVariableNameLocked(char *cStr)
{
  valuePtr[1] = *(void *)off_1ECE0A5B0;
  if (!generationByPrefix) {
    generationByPrefix = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  CFStringRef v2 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  valuePtr[0] = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)generationByPrefix, v2);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberCFIndexType, valuePtr);
    uint64_t v4 = valuePtr[0];
  }
  else
  {
    uint64_t v4 = 0;
  }
  CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"%@%ld", v2, v4);
  uint64_t v8 = valuePtr[0] + 1;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberCFIndexType, &v8);
  CFDictionarySetValue((CFMutableDictionaryRef)generationByPrefix, v2, v6);
  CFRelease(v6);
  CFRelease(v2);
  return v5;
}

CFStringRef ___CFICUCreateVariableNameForStackPointerLocked(char *a1, const void *a2)
{
  CFStringRef v4 = ___CFICUCreateVariableNameLocked(a1);
  if (!stackPointersByPrefix) {
    stackPointersByPrefix = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
  }
  if (!lastStackPointerVariableNamesByPrefix) {
    lastStackPointerVariableNamesByPrefix = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  CFStringRef v5 = CFStringCreateWithCString(0, a1, 0x8000100u);
  CFDictionarySetValue((CFMutableDictionaryRef)stackPointersByPrefix, v5, a2);
  CFDictionarySetValue((CFMutableDictionaryRef)lastStackPointerVariableNamesByPrefix, v5, v4);
  CFRelease(v5);
  return v4;
}

CFStringRef ___CFICUCopyVariableNameForHeapPointer(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  v5[0] = off_1ECE0A5A0;
  v5[1] = 0x40000000;
  int v5[2] = _____CFICUCopyVariableNameForHeapPointer_block_invoke;
  v5[3] = &unk_1ECDFE030;
  v5[4] = &v6;
  v5[5] = a2;
  v5[6] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCopyVariableNameForHeapPointer_block_invoke((uint64_t)v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  CFStringRef v3 = (CFStringRef)v7[3];
  if (!v3)
  {
    CFStringRef v3 = CFStringCreateWithFormat(0, 0, @"<unknown variable for %s>", a1);
    v7[3] = (uint64_t)v3;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_182D091D8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

void ___CFICURemoveVariableNameForHeapPointer(uint64_t a1)
{
  v1[5] = *(void *)off_1ECE0A5B0;
  v1[0] = off_1ECE0A5A0;
  v1[1] = 0x40000000;
  v1[2] = _____CFICURemoveVariableNameForHeapPointer_block_invoke;
  v1[3] = &__block_descriptor_tmp_275;
  v1[4] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICURemoveVariableNameForHeapPointer_block_invoke((uint64_t)v1);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
}

void OUTLINED_FUNCTION_0_9(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_182D09788(_Unwind_Exception *exception_object)
{
}

void OUTLINED_FUNCTION_0_10(objc_class *a1)
{
  __CFRequireConcreteImplementation(a1, v2, v1);
}

SInt32 CFBundleOpenBundleResourceFiles(CFBundleRef bundle, CFBundleRefNum *refNum, CFBundleRefNum *localizedRefNum)
{
  return -1;
}

CFBundleRefNum CFBundleOpenBundleResourceMap(CFBundleRef bundle)
{
  return -1;
}

uint64_t _CFBundleCopyInfoDictionaryInResourceFork()
{
  return 0;
}

uint64_t _CFBundleOpenBundleResourceFork()
{
  return 0xFFFFFFFFLL;
}

uint64_t __NSFastEnumerationShouldThrowExceptionOnMutation()
{
  return 1;
}

void __NSFastEnumerationMutationHandler(uint64_t a1)
{
  CFStringRef v2 = (objc_class *)objc_opt_class();
  Name = class_getName(v2);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** Collection <%s: %p> was mutated while being enumerated.", Name, a1);
  CFStringRef v5 = +[NSException exceptionWithName:@"NSGenericException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v4) userInfo:0];
  objc_exception_throw(v5);
}

void __handleUncaughtException(uint64_t a1)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (objectIsKindOfClass((void *)a1, (objc_class *)NSException))
  {
    uint64_t v2 = [(id)a1 name];
    uint64_t v3 = [(id)a1 reason];
    CFStringRef v4 = (void *)[*(id *)(a1 + 32) objectForKey:@"callStackReturnAddresses"];
    os_unfair_lock_lock((os_unfair_lock_t)&__last_exception_backtrace_lock__);
    if (v4)
    {
      uint64_t v5 = [v4 count];
      __strlcpy_chk();
      if (v5)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          snprintf(__str, 0x44uLL, "%p ", (const void *)objc_msgSend((id)objc_msgSend(v4, "objectAtIndex:", i), "unsignedIntegerValue"));
          __strlcat_chk();
        }
      }
      uint64_t v7 = strrchr(__last_exception_backtrace__, 32);
      if (v7) {
        *(_WORD *)uint64_t v7 = 41;
      }
      else {
        __strlcat_chk();
      }
    }
    else
    {
      __strlcpy_chk();
    }
    __last_exception_class_name__ = (uint64_t)object_getClassName((id)a1);
    CFStringRef v9 = *(const __CFString **)(a1 + 8);
    if (_NSIsNSCFConstantString((uint64_t)v9))
    {
      CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
      CStringPtr = CFStringGetCStringPtr(v9, SystemEncoding);
    }
    else
    {
      CStringPtr = 0;
    }
    __last_exception_name__ = (uint64_t)CStringPtr;
    bzero(&__last_exception_os_log_pack__, 0x400uLL);
    uint64_t v12 = (void *)[*(id *)(a1 + 32) objectForKey:@"osLogPack"];
    if (v12) {
      [v12 getBytes:&__last_exception_os_log_pack__ length:1024];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__last_exception_backtrace_lock__);
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** Terminating app due to uncaught exception '%@', reason: '%@'\n*** First throw call stack:\n%@\n", v2, v3, [v4 description]);
  }
  else
  {
    ClassName = object_getClassName((id)a1);
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** Terminating app due to uncaught exception of class '%s'", ClassName);
  }
  qword_1EC093AA8 = objc_msgSend((id)_CFAutoreleasePoolAddObject(0, (uint64_t)v8), "UTF8String");
  size_t v13 = strlen((const char *)qword_1EC093AA8);
  _CFLogSimpleCString(3, (const char *)qword_1EC093AA8, v13);
  if (__uncaughtExceptionHandler)
  {
    if (objectIsKindOfClass((void *)a1, (objc_class *)NSException)) {
      __uncaughtExceptionHandler(a1);
    }
  }
}

void typeStringRelease(int a1, char *__s)
{
  strlen(__s);
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    free(__s);
  }
}

CFStringRef copyTypeStringDesc(char *cStr)
{
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr, 0x600u);
}

void *__NSMS5(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = __NSMS5(*result);
    uint64_t v3 = __NSMS5(v1[1]) + v2;
    uint64_t v1 = (void *)((char *)v1 + 37);
    size_t v4 = strlen((const char *)v1);
    return (void *)(v3 + CFStringHashCString((unsigned __int8 *)v1, v4));
  }
  return result;
}

void __NSMS7(__CFString *a1, uint64_t *a2, uint64_t a3)
{
  if (!a3)
  {
    if (*((unsigned char *)a2 + 36))
    {
      CFStringAppendFormat(a1, 0, @"type encoding (%c) '%s'\n", *((unsigned __int8 *)a2 + 36), (char *)a2 + 37);
      goto LABEL_11;
    }
LABEL_81:
    if ((*((_WORD *)a2 + 17) & 0x2000) != 0) {
      CFStringAppendFormat(a1, 0, @"class '%s'\n", (char *)a2 + 37);
    }
    else {
      CFStringAppendFormat(a1, 0, @"conforms to protocol '%s'\n", (char *)a2 + 37);
    }
    goto LABEL_112;
  }
  uint64_t v6 = a3;
  do
  {
    CFStringAppendFormat(a1, 0, @"    ");
    --v6;
  }
  while (v6);
  if (!*((unsigned char *)a2 + 36)) {
    goto LABEL_81;
  }
  CFStringAppendFormat(a1, 0, @"type encoding (%c) '%s'\n", *((unsigned __int8 *)a2 + 36), (char *)a2 + 37);
  if (a3)
  {
    uint64_t v7 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, @"    ");
      --v7;
    }
    while (v7);
  }
LABEL_11:
  __int16 v8 = *((_WORD *)a2 + 17);
  CFStringRef v9 = "isSigned";
  if ((v8 & 0x100) == 0) {
    CFStringRef v9 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7E00) == 0 || (v8 & 0x100) == 0) {
    uint64_t v11 = "";
  }
  else {
    uint64_t v11 = ", ";
  }
  uint64_t v12 = "isFloat";
  if ((*((_WORD *)a2 + 17) & 0x200) == 0) {
    uint64_t v12 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7C00) == 0 || (v8 & 0x200) == 0) {
    CFTypeRef v14 = "";
  }
  else {
    CFTypeRef v14 = ", ";
  }
  CFStringRef v15 = "isStruct";
  if ((*((_WORD *)a2 + 17) & 0x400) == 0) {
    CFStringRef v15 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7800) == 0 || (v8 & 0x400) == 0) {
    CFStringRef v17 = "";
  }
  else {
    CFStringRef v17 = ", ";
  }
  unint64_t v18 = "isArray";
  if ((*((_WORD *)a2 + 17) & 0x800) == 0) {
    unint64_t v18 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7000) == 0 || (v8 & 0x800) == 0) {
    __int16 v20 = "";
  }
  else {
    __int16 v20 = ", ";
  }
  unint64_t v21 = "isPointer";
  if ((*((_WORD *)a2 + 17) & 0x1000) == 0) {
    unint64_t v21 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x6000) == 0 || (v8 & 0x1000) == 0) {
    CFTypeRef v23 = "";
  }
  else {
    CFTypeRef v23 = ", ";
  }
  if (v8 < 0) {
    CFStringRef v24 = "isObject, isBlock";
  }
  else {
    CFStringRef v24 = "isObject";
  }
  if ((*((_WORD *)a2 + 17) & 0x2000) == 0) {
    CFStringRef v24 = "";
  }
  if ((v8 & 0x6000) == 0x6000) {
    CFStringRef v25 = ", ";
  }
  else {
    CFStringRef v25 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x4000) != 0) {
    CFStringRef v26 = "isCString";
  }
  else {
    CFStringRef v26 = "";
  }
  CFStringAppendFormat(a1, 0, @"flags {%s%s%s%s%s%s%s%s%s%s%s%s%s}\n", v9, v11, v12, v14, v15, v17, v18, v20, v21, v23, v24, v25, v26);
  uint64_t v27 = "out";
  int v28 = *((unsigned __int16 *)a2 + 17);
  if ((v28 & 2) == 0) {
    uint64_t v27 = 0;
  }
  if (v28) {
    uint64_t v27 = "in";
  }
  if ((~v28 & 3) != 0) {
    uint64_t v29 = v27;
  }
  else {
    uint64_t v29 = "inout";
  }
  if (a3)
  {
    uint64_t v30 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, @"    ");
      --v30;
    }
    while (v30);
    int v28 = *((unsigned __int16 *)a2 + 17);
  }
  if (v29) {
    unsigned int v31 = v29;
  }
  else {
    unsigned int v31 = "";
  }
  if (v29)
  {
    unsigned __int16 v32 = ", ";
    if ((v28 & 0x1C) == 0 && (v28 & 0x20) == 0) {
      unsigned __int16 v32 = "";
    }
  }
  else
  {
    unsigned __int16 v32 = "";
  }
  uint64_t v33 = "bycopy";
  if ((v28 & 4) == 0) {
    uint64_t v33 = "";
  }
  unsigned int v34 = "";
  if ((v28 & 4) != 0)
  {
    unsigned int v34 = ", ";
    if ((v28 & 0x18) == 0 && (v28 & 0x20) == 0) {
      unsigned int v34 = "";
    }
  }
  uint64_t v35 = "byref";
  if ((v28 & 8) != 0)
  {
    uint64_t v36 = ", ";
    if ((v28 & 0x10) != 0)
    {
LABEL_97:
      uint64_t v37 = "const";
      goto LABEL_98;
    }
    if ((v28 & 0x20) == 0) {
      uint64_t v36 = "";
    }
  }
  else
  {
    uint64_t v35 = "";
    uint64_t v36 = "";
    if ((v28 & 0x10) != 0) {
      goto LABEL_97;
    }
  }
  uint64_t v37 = "";
LABEL_98:
  if ((~v28 & 0x30) != 0) {
    BOOL v38 = "";
  }
  else {
    BOOL v38 = ", ";
  }
  if ((v28 & 0x20) != 0) {
    unsigned int v39 = "oneway";
  }
  else {
    unsigned int v39 = "";
  }
  CFStringAppendFormat(a1, 0, @"modifiers {%s%s%s%s%s%s%s%s%s}\n", v31, v32, v33, v34, v35, v36, v37, v38, v39);
  if (a3)
  {
    uint64_t v40 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, @"    ");
      --v40;
    }
    while (v40);
  }
  CFStringAppendFormat(a1, 0, @"frame {offset = %d, offset adjust = %d, mach_vm_size_t size = %d, size adjust = %d}\n", *((unsigned int *)a2 + 7), *((unsigned __int8 *)a2 + 32), *((unsigned int *)a2 + 6), *((char *)a2 + 33));
  if (a3)
  {
    uint64_t v41 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, @"    ");
      --v41;
    }
    while (v41);
  }
  CFStringAppendFormat(a1, 0, @"memory {offset = %d, mach_vm_size_t size = %d}\n", *((unsigned int *)a2 + 5), *((unsigned int *)a2 + 4));
LABEL_112:
  uint64_t v42 = *a2;
  if (v42)
  {
    uint64_t v43 = a3 + 1;
    do
    {
      __NSMS7(a1, v42, v43);
      uint64_t v42 = *(void *)(v42 + 8);
    }
    while (v42);
  }
}

void *_NSMessageBuilder(uint64_t a1, uint64_t a2)
{
  size_t v4 = __CFLookUpClass("__NSMessageBuilder");
  uint64_t result = class_createInstance(v4, 0);
  result[1] = a1;
  result[2] = a2;
  return result;
}

void _NSIPoisoned()
{
  qword_1EC093AA8 = (uint64_t)"Corrupt NSInvocation detected. Pointer authentication.";
  __break(1u);
}

void copyBlock(uint64_t a1, uint64_t a2)
{
}

unsigned char **setAndAdvance(unsigned char **result, unint64_t a2, char a3)
{
  uint64_t v3 = *result;
  if ((unint64_t)*result >= a2) {
    objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", @"NSInvalidArgumentException", @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec", 0));
  }
  *uint64_t result = v3 + 1;
  unsigned char *v3 = a3;
  return result;
}

unint64_t _NSMS3StackAlignedOffset_arm64(uint64_t a1, uint64_t a2)
{
  v5[1] = *(void *)off_1ECE0A5B0;
  v5[0] = 0;
  __NSGetSizeAndAlignment((unsigned char *)(a1 + 37), 0, v5, 0, 1, 0, 1uLL);
  unint64_t v3 = v5[0];
  if (v5[0] <= 1uLL) {
    unint64_t v3 = 1;
  }
  return (a2 + v3 - 1) / v3 * v3;
}

uint64_t OUTLINED_FUNCTION_0_11()
{
  return __CFRecordAllocationEvent();
}

void __CFDateIntervalDeallocate(uint64_t a1)
{
}

BOOL __CFDateIntervalEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (*(double *)(a1 + 24) == *(double *)(a2 + 24)) {
    return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
  }
  return 0;
}

uint64_t __CFDateIntervalHash(uint64_t a1)
{
  uint64_t v5[2] = *(void *)off_1ECE0A5B0;
  CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  CFAbsoluteTime v3 = AbsoluteTime + *(double *)(a1 + 24);
  *(CFAbsoluteTime *)uint64_t v5 = AbsoluteTime;
  *(CFAbsoluteTime *)&v5[1] = v3;
  return CFHashBytes((uint64_t)v5, 16);
}

CFStringRef __CFDateIntervalCopyDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFDateInterval %p [%p]> %@ %f", a1, v2, a1[2], a1[3]);
}

uint64_t CFDateIntervalGetTypeID()
{
  return 71;
}

uint64_t CFDateIntervalCreate(__objc2_class **Default, const void *a2, double a3)
{
  if (!Default) {
    Default = (__objc2_class **)CFAllocatorGetDefault();
  }
  uint64_t result = _CFRuntimeCreateInstance(Default, 0x47uLL, 16, 0);
  if (result)
  {
    uint64_t v6 = result;
    *(void *)(result + 16) = CFRetain(a2);
    *(double *)(v6 + 24) = a3;
    return v6;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t CFDateIntervalCreateWithEndDate(__objc2_class **a1, const __CFDate *a2, CFDateRef theDate)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  double v6 = AbsoluteTime - CFDateGetAbsoluteTime(a2);

  return CFDateIntervalCreate(a1, a2, v6);
}

double CFDateIntervalGetDuration(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

CFTypeRef CFDateIntervalCopyStartDate(uint64_t a1)
{
  return CFRetain(*(CFTypeRef *)(a1 + 16));
}

CFDateRef CFDateIntervalCopyEndDate(uint64_t a1)
{
  double v1 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)) + *(double *)(a1 + 24);

  return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
}

CFComparisonResult CFDateIntervalCompare(uint64_t a1, uint64_t a2)
{
  CFComparisonResult result = CFDateCompare(*(CFDateRef *)(a1 + 16), *(CFDateRef *)(a2 + 16), 0);
  if (result == kCFCompareEqualTo)
  {
    double v5 = *(double *)(a1 + 24);
    double v6 = *(double *)(a2 + 24);
    if (v5 >= v6) {
      return (unint64_t)(v5 > v6);
    }
    else {
      return -1;
    }
  }
  return result;
}

BOOL CFDateIntervalIntersectsDateInterval(uint64_t a1, uint64_t a2)
{
  CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
  CFDateRef v5 = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, AbsoluteTime + *(double *)(a2 + 24));
  CFAbsoluteTime v6 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  CFDateRef v7 = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6 + *(double *)(a1 + 24));
  double v8 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
  double v9 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  BOOL v10 = v8 < v9 || v8 > v9 + *(double *)(a1 + 24);
  if (v10
    && ((double v11 = CFDateGetAbsoluteTime(v5), v12 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)), v11 >= v12)
      ? (BOOL v13 = v11 > v12 + *(double *)(a1 + 24))
      : (BOOL v13 = 1),
        v13
     && ((double v14 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)),
          double v15 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16)),
          v14 < v15)
      || v14 > v15 + *(double *)(a2 + 24))))
  {
    double v18 = CFDateGetAbsoluteTime(v7);
    double v19 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
    BOOL v16 = v18 <= v19 + *(double *)(a2 + 24) && v18 >= v19;
  }
  else
  {
    BOOL v16 = 1;
  }
  CFRelease(v5);
  CFRelease(v7);
  return v16;
}

BOOL CFDateIntervalContainsDate(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  double v4 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  return AbsoluteTime <= v4 + *(double *)(a1 + 24) && AbsoluteTime >= v4;
}

CFTypeRef CFDateIntervalCreateIntersectionWithDateInterval(__objc2_class **a1, CFDateRef *cf1, CFDateRef *cf2)
{
  if (CFEqual(cf1, cf2))
  {
    return CFRetain(cf1);
  }
  else if (CFDateIntervalIntersectsDateInterval((uint64_t)cf1, (uint64_t)cf2))
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(cf1[2]);
    double v8 = AbsoluteTime + *((double *)cf1 + 3);
    double v9 = CFDateGetAbsoluteTime(cf2[2]);
    if (v9 >= AbsoluteTime) {
      BOOL v10 = cf2;
    }
    else {
      BOOL v10 = cf1;
    }
    CFDateRef v11 = v10[2];
    if (v9 + *((double *)cf2 + 3) < v8) {
      double v12 = v9 + *((double *)cf2 + 3);
    }
    else {
      double v12 = v8;
    }
    double v13 = v12 - CFDateGetAbsoluteTime(v10[2]);
    return (CFTypeRef)CFDateIntervalCreate(a1, v11, v13);
  }
  else
  {
    return 0;
  }
}

void sub_182D0CC9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state)
{
}

size_t _CFPrefsCreatePreferencesDirectory(const char *a1)
{
  size_t result = strlen(a1);
  if (!result) {
    return result;
  }
  CFAbsoluteTime v3 = (char *)&a1[result];
  uint64_t v4 = 0xFFFFFFFFLL;
  do
  {
    while (1)
    {
      if (*v3 != 47) {
        goto LABEL_6;
      }
      char *v3 = 0;
      uint64_t v5 = open(a1, 1074790400);
      uint64_t v4 = v5;
      char *v3 = 47;
      if (v5 != -1) {
        break;
      }
      --v3;
      if (*__error() != 2 || v3 == a1) {
        return 0;
      }
    }
    if ((v5 & 0x80000000) == 0)
    {
      uint64_t v7 = (uint64_t)(v3 + 1);
      goto LABEL_18;
    }
LABEL_6:
    --v3;
  }
  while (v3 != a1);
  if ((v4 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v7 = 0;
LABEL_18:
  int v8 = _safe_recursive_mkdir_chown(v7, v4);
  int v9 = *__error();
  close(v4);
  *__error() = v9;
  return v8 == 0;
}

uint64_t _safe_recursive_mkdir_chown(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v2 = (const char *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v9 = v8;
  uint64_t v11 = v10;
  int v12 = v3;
  double v13 = v2;
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  for (uint64_t i = (char *)v2; ; ++i)
  {
    int v15 = *i;
    if (!*i || v15 == 47) {
      break;
    }
  }
  *uint64_t i = 0;
  uint64_t v16 = openat(v3, v2, 0x100000);
  uint64_t v17 = v16;
  if ((v16 & 0x80000000) != 0)
  {
    if (v16 == -1)
    {
      if (*__error() != 2) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_26;
    }
  }
  else
  {
    memset(&v27, 0, 512);
    if (fstatfs(v16, &v27) != -1 && (v27.f_flags & 1) != 0)
    {
      memset(&v26, 0, 512);
      if (fstatfs(v12, &v26) != -1 && (v26.f_flags & 0x20) != 0)
      {
        close(v17);
LABEL_26:
        if (mkdirat(v12, v13, v11) != -1)
        {
          uint64_t v23 = openat(v12, v13, 1048832);
          if (v23 != -1)
          {
            uint64_t v17 = v23;
            if (fchown(v23, v9, v7) != -1
              || (int v24 = *__error(), memset(&v27, 0, 144), !fstat(v17, (stat *)&v27))
              && v27.f_bfree == __PAIR64__(v7, v9))
            {
              char v18 = 1;
              goto LABEL_13;
            }
            close(v17);
            unlinkat(v12, v13, 128);
            *__error() = v24;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  char v18 = 0;
LABEL_13:
  *uint64_t i = v15;
  while (v15 == 47)
  {
    char v19 = *++i;
    LOBYTE(v15) = v19;
  }
  if ((_BYTE)v15)
  {
    uint64_t v20 = _safe_recursive_mkdir_chown(i, v17, v11, v9, v7, v5);
    int v21 = *__error();
    close(v17);
    char v22 = v18 ^ 1;
    if (v20 != -1) {
      char v22 = 1;
    }
    if ((v22 & 1) == 0) {
      unlinkat(v12, v13, 128);
    }
    *__error() = v21;
  }
  else if (v5)
  {
    uint64_t v20 = 0;
    *uint64_t v5 = v17;
  }
  else
  {
    close(v17);
    return 0;
  }
  return v20;
}

CFURLRef _CFPrefsCopyDirectoryURLForTriplet_testing(uint64_t a1, const __CFString *a2, int a3, const void *a4)
{
  return _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, a4);
}

__CFArray *_CFPreferencesCopyApplicationList(const __CFString *a1, int a2)
{
  char v2 = a2;
  CFURLRef PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a1, a2, 0);
  if (!PreferencesDirectoryURLForTriplet) {
    return 0;
  }
  CFURLRef v4 = PreferencesDirectoryURLForTriplet;
  CFURLRef v5 = CFURLCopyAbsoluteURL(PreferencesDirectoryURLForTriplet);
  CFRelease(v4);
  if (v2)
  {
    uint64_t v6 = _CFXPreferencesGetByHostIdentifierString();
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @".%@.plist", v6);
  }
  else
  {
    CFStringRef v7 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, ".plist", 0x600u);
  }
  CFStringRef v9 = v7;
  CFIndex Length = CFStringGetLength(v7);
  uint64_t v11 = _CFCreateContentsOfDirectory((uint64_t)&__kCFAllocatorSystemDefault, 0);
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  CFURLRef cf = v5;
  if (v11)
  {
    MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v11);
    CFRelease(v11);
  }
  else
  {
    MutableCFStringRef Copy = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  }
  CFIndex Count = CFArrayGetCount(MutableCopy);
  if (Count >= 1)
  {
    unint64_t v14 = Count + 1;
    do
    {
      CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(MutableCopy, v14 - 2);
      CFStringRef v16 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
      if (CFStringHasSuffix(v16, v9))
      {
        v21.CFIndex length = CFStringGetLength(v16) - Length;
        v21.CFIndex location = 0;
        CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, v21);
        if (CFEqual(v17, @".GlobalPreferences")) {
          char v18 = @"kCFPreferencesAnyApplication";
        }
        else {
          char v18 = (__CFString *)v17;
        }
        CFArrayAppendValue(Mutable, v18);
        CFRelease(v17);
      }
      CFRelease(v16);
      --v14;
    }
    while (v14 > 1);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  CFRelease(cf);
  CFRelease(v9);
  return Mutable;
}

uint64_t _CFPreferencesCopyApplicationMap()
{
  return 0;
}

uint64_t _CFPreferencesCopyInUseContainerURLMatchingApplication()
{
  return 0;
}

CFURLRef _CFPreferencesCopyManagedPreferencesContainerURL()
{
  v15[1] = *(void *)off_1ECE0A5B0;
  v15[0] = 1;
  uint64_t v0 = (const char *)container_system_group_path_for_identifier();
  if (v0)
  {
    double v1 = (UInt8 *)v0;
    size_t v2 = strlen(v0);
    CFURLRef v3 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, v2, 1u);
    if (v3)
    {
      CFURLRef v4 = v3;
      CFURLRef v5 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Library/Managed Preferences/", kCFURLPOSIXPathStyle, 1u, v3);
      CFRelease(v4);
      if (v5)
      {
LABEL_7:
        free(v1);
        return v5;
      }
      uint64_t v6 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        _CFPreferencesCopyManagedPreferencesContainerURL_cold_2();
      }
    }
    CFURLRef v5 = 0;
    goto LABEL_7;
  }
  CFStringRef v7 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
    _CFPreferencesCopyManagedPreferencesContainerURL_cold_1((uint64_t)v15, v7, v8, v9, v10, v11, v12, v13);
  }
  return 0;
}

CFStringRef _CFPreferencesCopyPathForManagedDomain(__CFString *a1, __CFString *a2, int a3)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  bzero(buffer, 0x402uLL);
  if (!_CFPrefsGetPathForManagedBundleID(a1, a2, a3 != 0, (UInt8 *)buffer)) {
    return 0;
  }
  CFStringRef result = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
  if (!result) {
    return 0;
  }
  return result;
}

CFIndex _CFPreferencesGetUserIdentifierForUID(uid_t a1)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uid_t key = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfprefsUsernameLock);
  CFDictionaryRef Mutable = (const __CFDictionary *)_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername;
  if (!_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
    _CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsermach_port_name_t name = (uint64_t)Mutable;
  }
  if (!_cfprefsUsernameToUid)
  {
    memset(&keyCallBacks, 0, 24);
    keyCallBacks.uint64_t copyDescription = kCFCopyStringDictionaryKeyCallBacks.copyDescription;
    *(_OWORD *)&keyCallBacks.equal = *(_OWORD *)&kCFCopyStringDictionaryKeyCallBacks.equal;
    _cfprefsUsernameToUid = (uint64_t)CFDictionaryCreateMutable(0, 0, &keyCallBacks, 0);
    CFDictionaryRef Mutable = (const __CFDictionary *)_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername;
  }
  keyCallBacks.CFIndex version = 0;
  if (CFDictionaryGetValueIfPresent(Mutable, &key, (const void **)&keyCallBacks))
  {
    CFIndex version = (CFIndex)CFRetain((CFTypeRef)keyCallBacks.version);
  }
  else
  {
    *__error() = 0;
    CFURLRef v3 = getpwuid(key);
    if (v3)
    {
      keyCallBacks.CFIndex version = (CFIndex)CFStringCreateWithFormat(0, 0, @"%s", v3->pw_name);
      CFDictionarySetValue((CFMutableDictionaryRef)_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername, (const void *)key, (const void *)keyCallBacks.version);
      CFDictionarySetValue((CFMutableDictionaryRef)_cfprefsUsernameToUid, (const void *)keyCallBacks.version, (const void *)key);
      CFIndex version = keyCallBacks.version;
    }
    else
    {
      int v4 = *__error();
      CFURLRef v5 = _CFPrefsClientLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        _CFPreferencesGetUserIdentifierForUID_cold_1((int *)&key, v4, v5);
      }
      CFIndex version = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfprefsUsernameLock);
  return version;
}

uint64_t _CFPreferencesUIDForUsername(const void *a1)
{
  v3[1] = *(const void **)off_1ECE0A5B0;
  v3[0] = (const void *)4294967195;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfprefsUsernameLock);
  if (!_cfprefsUsernameToUid || !CFDictionaryGetValueIfPresent((CFDictionaryRef)_cfprefsUsernameToUid, a1, v3)) {
    v3[0] = (const void *)4294967195;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfprefsUsernameLock);
  return LODWORD(v3[0]);
}

void OUTLINED_FUNCTION_0_12(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x12u);
}

void OUTLINED_FUNCTION_1_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void sub_182D0F5C0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D0FC1C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D10094(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D10508(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D10C98(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D1444C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D148DC(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D14D68(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D153E4(_Unwind_Exception *exception_object)
{
}

void sub_182D1568C(_Unwind_Exception *exception_object)
{
}

void __CFZombifyNSObject()
{
  uint64_t v0 = objc_lookUpClass("NSObject");
  InstanceMethod = class_getInstanceMethod(v0, sel_dealloc);
  size_t v2 = class_getInstanceMethod(v0, sel___dealloc_zombie);

  method_exchangeImplementations(InstanceMethod, v2);
}

void __CFOAInitializeNSObject()
{
  uint64_t v0 = objc_lookUpClass("NSObject");
  InstanceMethod = class_getInstanceMethod(v0, sel_retain);
  size_t v2 = class_getInstanceMethod(v0, sel___retain_OA);
  method_exchangeImplementations(InstanceMethod, v2);
  CFURLRef v3 = class_getInstanceMethod(v0, sel_release);
  uint64_t v4 = class_getInstanceMethod(v0, sel___release_OA);
  method_exchangeImplementations(v3, v4);
  CFURLRef v5 = class_getInstanceMethod(v0, sel_autorelease);
  uint64_t v6 = class_getInstanceMethod(v0, sel___autorelease_OA);
  method_exchangeImplementations(v5, v6);
  CFStringRef v7 = class_getInstanceMethod(v0, sel__tryRetain);
  uint64_t v8 = class_getInstanceMethod(v0, sel____tryRetain_OA);
  method_exchangeImplementations(v7, v8);
  Class = object_getClass(v0);
  uint64_t v10 = class_getInstanceMethod(Class, sel_allocWithZone_);
  uint64_t v11 = class_getInstanceMethod(Class, sel___allocWithZone_OA_);

  method_exchangeImplementations(v10, v11);
}

void couldNotInstantiate(objc_class *a1)
{
  Name = class_getName(a1);
  CFStringRef v2 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** -[NSObject allocWithZone:]: attempt to allocate object of class '%s' failed", Name);
  CFURLRef v3 = +[NSException exceptionWithName:@"NSMallocException" reason:_CFAutoreleasePoolAddObject((uint64_t)v2, (uint64_t)v2) userInfo:0];
  objc_exception_throw(v3);
}

uint64_t _objc_getTaggedPointerTag_0(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  uint64_t v3 = v2 ^ a1;
  do
  {
    if ((v3 & 7) == *((unsigned char *)off_1ECE0A6E0 + v1)) {
      break;
    }
    ++v1;
  }
  while (v1 != 7);
  unint64_t v4 = v1 | v3;
  uint64_t v5 = v1 & 7;
  unsigned int v6 = (v4 >> 55) + 8;
  if (v5 == 7) {
    return v6;
  }
  else {
    return v5;
  }
}

uint64_t _NSIsNSAttributedString()
{
  if (_NSAttributedStringClass
    || (Class Class = objc_getClass("NSAttributedString"), (_NSAttributedStringClass Class = (uint64_t)Class) != 0))
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
  }
  return Class & 1;
}

unint64_t makeAtom(unint64_t a1)
{
  if ((dyld_program_sdk_at_least() & 1) != 0 || !*(void *)off_1ECE0A6E8) {
    return 0;
  }
  if ((a1 & 0x8000000000000000) != 0 && !_objc_getTaggedPointerTag_0(a1)) {
    return a1;
  }
  uint64_t v3 = 0;
  while (2)
  {
    unint64_t v4 = (void *)__atom_buckets[v3];
    if (v4)
    {
      unsigned int v5 = 16 << v3;
      if ((16 << v3) <= 1) {
        uint64_t v6 = 1;
      }
      else {
        uint64_t v6 = v5;
      }
      signed int v7 = v5 - 16;
      do
      {
        if (*v4 == a1)
        {
          a1 = ((uint64_t)v7 << 7) | 0x8000000000000000;
          unint64_t v17 = *(void *)off_1ECE0A6F0 ^ a1;
          if ((~v17 & 0xC000000000000007) != 0) {
            return v17 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)off_1ECE0A6E0 + (*(void *)off_1ECE0A6F0 & 7));
          }
          return a1;
        }
        ++v7;
        ++v4;
        --v6;
      }
      while (v6);
      if (++v3 != 24) {
        continue;
      }
    }
    break;
  }
  unsigned int add_explicit = atomic_fetch_add_explicit(&__natoms, 1u, memory_order_relaxed);
  unsigned int v9 = add_explicit + 1;
  id v10 = (id)a1;
  unint64_t result = flsl(((add_explicit + 1) >> 4) + 1);
  if ((int)result < 25)
  {
    int v11 = 1 << (result + 3);
    int v12 = add_explicit - v11 + 17;
    uint64_t v13 = (int)result - 1;
    unint64_t v14 = (void *)__atom_buckets[v13];
    if (!v14)
    {
      unint64_t v14 = malloc_type_calloc(8uLL, v11, 0xF3174764uLL);
      uint64_t v15 = 0;
      atomic_compare_exchange_strong(&__atom_buckets[v13], (unint64_t *)&v15, (unint64_t)v14);
      if (v15)
      {
        free(v14);
        unint64_t v14 = (void *)__atom_buckets[v13];
      }
    }
    *((void *)v14 + v12) = a1;
    __dmb(0xBu);
    a1 = ((((unint64_t)(16 * v9) >> 4) & 0xFFFFFFF) << 7) | 0x8000000000000000;
    unint64_t v16 = *(void *)off_1ECE0A6F0 ^ a1;
    if ((~v16 & 0xC000000000000007) != 0) {
      return v16 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)off_1ECE0A6E0 + (*(void *)off_1ECE0A6F0 & 7));
    }
    return a1;
  }
  __break(1u);
  return result;
}

uint64_t getAtomTarget(uint64_t a1)
{
  uint64_t result = dyld_program_sdk_at_least();
  if (result) {
    return 0;
  }
  uint64_t v3 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v3 = 0;
  }
  unint64_t v4 = v3 ^ a1;
  uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  if ((~(_BYTE)v4 & 7) == 0) {
    uint64_t v5 = 0xFFFFFFFFFFFFFLL;
  }
  unint64_t v6 = v5 & (v4 >> 3);
  if (__natoms < v6 >> 4)
  {
    __break(1u);
  }
  else
  {
    unint64_t v7 = v6 >> 4;
    int v8 = flsl((v6 >> 8) + 1);
    return *((void *)*(&__atom_buckets + v8 - 1) + (int)v7 + (-1 << (v8 + 3)) + 16);
  }
  return result;
}

void _NSSetDeallocHandler()
{
  qword_1EC093AA8 = (uint64_t)"Unsupported functionality";
  __break(1u);
}

uint64_t __CFFullMethodName(objc_class *a1, objc_class *a2, const char *a3)
{
  cStr[1] = *(char **)off_1ECE0A5B0;
  cStr[0] = 0;
  if (a2 == a1) {
    uint64_t v4 = 43;
  }
  else {
    uint64_t v4 = 45;
  }
  if (a1)
  {
    Name = class_getName(a1);
    if (a3)
    {
LABEL_6:
      unint64_t v6 = sel_getName(a3);
      goto LABEL_9;
    }
  }
  else
  {
    Name = "(null class)";
    if (a3) {
      goto LABEL_6;
    }
  }
  unint64_t v6 = "(null selector)";
LABEL_9:
  asprintf(cStr, "%c[%s %s]", v4, Name, v6);
  if (!cStr[0]) {
    return 0;
  }
  CFStringRef v7 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr[0], 0x8000100u);
  uint64_t v8 = _CFAutoreleasePoolAddObject((uint64_t)v7, (uint64_t)v7);
  free(cStr[0]);
  return v8;
}

uint64_t __CFExceptionProem(objc_class *a1, const char *a2)
{
  uint64_t v4 = (objc_class *)objc_opt_class();

  return __CFFullMethodName(v4, a1, a2);
}

void sub_182D173BC(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D17E70(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_14(objc_class *a1)
{
  __CFRequireConcreteImplementation(a1, v2, v1);
}

void sub_182D1848C(_Unwind_Exception *exception_object)
{
}

void sub_182D1877C(_Unwind_Exception *exception_object)
{
}

__n128 cow_copy_instance_1(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = &OBJC_IVAR_____NSFrozenSetM_storage;
  if (a2 == 1) {
    uint64_t v5 = &OBJC_IVAR_____NSSetM_storage;
  }
  else {
    uint64_t v5 = &OBJC_IVAR_____NSFrozenSetM_storage;
  }
  unint64_t v6 = &OBJC_IVAR_____NSFrozenSetM_cow;
  if (a2 == 1) {
    CFStringRef v7 = &OBJC_IVAR_____NSSetM_cow;
  }
  else {
    CFStringRef v7 = &OBJC_IVAR_____NSFrozenSetM_cow;
  }
  uint64_t v8 = *v5;
  unint64_t v9 = atomic_load((unint64_t *)(a1 + *v7));
  if (a4 == 1)
  {
    unint64_t v6 = &OBJC_IVAR_____NSSetM_cow;
    uint64_t v4 = &OBJC_IVAR_____NSSetM_storage;
  }
  atomic_store(v9, (unint64_t *)(a3 + *v6));
  __n128 result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v4) = result;
  return result;
}

uint64_t cow_copy_storage_1(uint64_t a1)
{
  unint64_t v2 = *(unsigned int *)(a1 + 28);
  if ((v2 & 0x3FFFFFF) == 0)
  {
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 28) = 0;
LABEL_16:
    uint64_t result = 1;
    goto LABEL_17;
  }
  unint64_t v3 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v2 >> 23) & 0x1F8));
  uint64_t result = (uint64_t)malloc_type_malloc(8 * v3, 0x80040B8603338uLL);
  uint64_t v5 = result;
  if (result)
  {
    if (v2 >> 26)
    {
      uint64_t v6 = 0;
      uint64_t v7 = *(void *)(a1 + 16);
      if (v3 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v3;
      }
      uint64_t v9 = 8 * v8;
      do
      {
        uint64_t v10 = *(void *)(v7 + v6);
        if (v10 >= 1 && v10 != (void)&___NSSetM_DeletedMarker) {
          id v12 = (id)v10;
        }
        *(void *)(v5 + v6) = v10;
        v6 += 8;
      }
      while (v9 != v6);
    }
    goto LABEL_16;
  }
LABEL_17:
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t cow_set_cow_1(uint64_t result, unint64_t a2)
{
  return result;
}

uint64_t _compare_clumpiness_1(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void *__mset_enumerateObjectsWithOptionsUsingBlock_block_invoke(void *result, uint64_t a2)
{
  unint64_t v2 = *(void **)(result[5] + 8 * a2);
  if (v2) {
    BOOL v3 = v2 == &___NSSetM_DeletedMarker;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)_CFAutoreleasePoolPush();
    __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(v4[4]);
    return _CFAutoreleasePoolPop(v5);
  }
  return result;
}

uint64_t _CFListFormatterGetTypeID()
{
  return 68;
}

void __CFListFormatterDeallocate(uint64_t a1)
{
  if (!a1) {
    __CFListFormatterDeallocate_cold_1();
  }
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1)
  {
    CFRelease(v1);
  }
}

CFStringRef __CFListFormatterCopyDescription(const void *a1)
{
  if (!a1) {
    __CFListFormatterCopyDescription_cold_1();
  }
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFListFormatter %p>[%p]", a1, v3);
}

uint64_t _CFListFormatterCreate(__objc2_class **a1, const void *a2)
{
  if (!a1) {
    _CFListFormatterCreate_cold_1();
  }
  if (!a2) {
    _CFListFormatterCreate_cold_2();
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x44uLL, 8, 0);
  if (Instance) {
    *(void *)(Instance + 16) = CFRetain(a2);
  }
  return Instance;
}

__CFString *_CFListFormatterCreateStringByJoiningStrings(const __CFAllocator *a1, unint64_t *a2, const __CFArray *a3)
{
  uint64_t v39 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)a2);
  unint64_t v6 = _CFGetNonObjCTypeID(a2);
  if (v6 != 68) {
    _CFAssertMismatchedTypeID(0x44uLL, v6);
  }
  if (!a3) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(a3);
  if (!Count) {
    return &stru_1ECE10768;
  }
  uint64_t v8 = Count;
  CFAllocatorRef alloc = a1;
  CFLocaleRef locale = (const __CFLocale *)a2[2];
  uint64_t v9 = malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  uint64_t v10 = malloc_type_malloc(4 * v8, 0x100004052888210uLL);
  int v11 = malloc_type_calloc(v8, 1uLL, 0x100004077774924uLL);
  if (v8 >= 1)
  {
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, i);
      CFIndex Length = CFStringGetLength(ValueAtIndex);
      CFStringRef CharactersPtr = (UniChar *)CFStringGetCharactersPtr(ValueAtIndex);
      if (!CharactersPtr)
      {
        CFStringRef CharactersPtr = (UniChar *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
        v40.CFIndex location = 0;
        v40.CFIndex length = Length;
        CFStringGetCharacters(ValueAtIndex, v40, CharactersPtr);
        v11[i] = 1;
      }
      v10[i] = Length;
      v9[i] = CharactersPtr;
    }
  }
  int v36 = 0;
  CFStringRef Identifier = CFLocaleGetIdentifier(locale);
  CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    if (CFStringGetCString(Identifier, buffer, 256, 0x600u)) {
      CStringPtr = buffer;
    }
    else {
      CStringPtr = 0;
    }
  }
  uint64_t v18 = __cficu_ulistfmt_open((uint64_t)CStringPtr, &v36);
  v28[0] = off_1ECE0A5A0;
  v28[1] = 0x40000000;
  uint64_t v29 = ___CFListFormatterCreateStringByJoiningStrings_block_invoke;
  uint64_t v30 = &__block_descriptor_tmp_20;
  uint64_t v31 = v18;
  uint64_t v32 = v8;
  uint64_t v33 = v9;
  unsigned int v34 = v11;
  uint64_t v35 = v10;
  if (v36 >= 1)
  {
    ___CFListFormatterCreateStringByJoiningStrings_block_invoke((uint64_t)v28);
    return 0;
  }
  uint64_t v20 = v18;
  int v36 = 0;
  int v21 = __cficu_ulistfmt_format(v18, (uint64_t)v9, (uint64_t)v10, v8, chars, 768, &v36);
  if (v36 <= 0)
  {
    CFStringRef v19 = CFStringCreateWithCharacters(alloc, chars, v21);
  }
  else if (v36 == 15 || v8 < v21)
  {
    int v36 = 0;
    uint64_t v22 = (v21 + 1);
    uint64_t v23 = (UniChar *)malloc_type_malloc(2 * (int)v22, 0x1000040BDFB0063uLL);
    int v24 = __cficu_ulistfmt_format(v20, (uint64_t)v9, (uint64_t)v10, v8, v23, v22, &v36);
    if (v36 <= 0) {
      CFStringRef v19 = CFStringCreateWithCharacters(alloc, v23, v24);
    }
    else {
      CFStringRef v19 = 0;
    }
    free(v23);
  }
  else
  {
    CFStringRef v19 = 0;
  }
  v29((uint64_t)v28);
  return (__CFString *)v19;
}

uint64_t _CFCalendarResetCurrent()
{
  return +[NSCalendar _resetCurrent];
}

void ____initDayChangedNotification_block_invoke_2()
{
}

void _dayChangedNotification(int a1, int a2, CFTypeRef cf2)
{
  int v3 = CFEqual(@"com.apple.system.timezone", cf2);

  __postAndResetMidnight(1, v3);
}

void sub_182D1A39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void sub_182D1A770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFCalendarGetUnitsFromDateFormat(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length < 1) {
    return 0;
  }
  CFIndex v3 = Length;
  uint64_t v4 = 0;
  for (CFIndex i = 0; i != v3; ++i)
  {
    CFStringGetCharacterAtIndex(a1, i);
    udat_patternCharToDateFormatField();
    unsigned int v6 = udat_toCalendarDateField();
    if (v6 > 0x16) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = qword_182EDD810[v6];
    }
    v4 |= v7;
  }
  return v4;
}

void OUTLINED_FUNCTION_1_9(objc_class *a1)
{
  __CFRequireConcreteImplementation(a1, v2, v1);
}

void _systemTimeZoneChangedNotification()
{
  ++__noteCount_0;
  uint64_t v0 = (const void *)+[NSTimeZone _resetSystemTimeZone];
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kCFTimeZoneSystemTimeZoneDidChangeNotification-4", v0, 0, 1u);
  CFNotificationCenterPostNotification(LocalCenter, @"kCFTimeZoneSystemTimeZoneDidChangeNotification-2", v0, 0, 1u);

  CFNotificationCenterPostNotification(LocalCenter, @"kCFTimeZoneSystemTimeZoneDidChangeNotification", v0, 0, 1u);
}

void OUTLINED_FUNCTION_0_16(objc_class *a1)
{
  __CFRequireConcreteImplementation(a1, v2, v1);
}

BOOL _CFIsMatchingLibrary(char *a1, const char *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = strrchr(a1, 47);
  if (v4) {
    uint64_t v3 = v4 + 1;
  }
  size_t v5 = strlen(a2);
  return strncmp(v3, a2, v5) == 0;
}

void *_CFGetHandleForLoadedLibrary(const char *a1)
{
  uint32_t v2 = _dyld_image_count();
  if (!v2) {
    return 0;
  }
  uint32_t v3 = v2;
  uint32_t v4 = 0;
  while (1)
  {
    image_mach_port_name_t name = (char *)_dyld_get_image_name(v4);
    if (_CFIsMatchingLibrary(image_name, a1)) {
      break;
    }
    if (v3 == ++v4) {
      return 0;
    }
  }
  if (!image_name) {
    return 0;
  }
  uint64_t result = dlopen(image_name, 21);
  if (!result) {
    _CFGetHandleForLoadedLibrary_cold_1();
  }
  return result;
}

CFTypeID CFTimeZoneGetTypeID(void)
{
  return 48;
}

void CFTimeZoneSetDefault(CFTimeZoneRef tz)
{
  uint32_t v2 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone setDefaultTimeZone:tz];

  _CFAutoreleasePoolPop(v2);
}

CFArrayRef CFTimeZoneCopyKnownNames(void)
{
  uint64_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone knownTimeZoneNames];
  if (v1) {
    CFArrayRef v2 = (const __CFArray *)CFRetain(v1);
  }
  else {
    CFArrayRef v2 = 0;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

CFDictionaryRef CFTimeZoneCopyAbbreviationDictionary(void)
{
  uint64_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone abbreviationDictionary];
  if (v1) {
    CFDictionaryRef v2 = (const __CFDictionary *)CFRetain(v1);
  }
  else {
    CFDictionaryRef v2 = 0;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFTimeZoneSetAbbreviationDictionary(CFDictionaryRef dict)
{
  CFDictionaryRef v2 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone setAbbreviationDictionary:dict];

  _CFAutoreleasePoolPop(v2);
}

CFTimeZoneRef CFTimeZoneCreate(CFAllocatorRef allocator, CFStringRef name, CFDataRef data)
{
  size_t v5 = (void *)_CFAutoreleasePoolPush();
  unsigned int v6 = [[NSTimeZone alloc] initWithName:name data:data];
  _CFAutoreleasePoolPop(v5);
  return (CFTimeZoneRef)v6;
}

CFStringRef CFTimeZoneCopyAbbreviation(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  size_t v5 = (const void *)[(__CFTimeZone *)tz abbreviationForDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  if (v5) {
    CFStringRef v6 = (const __CFString *)CFRetain(v5);
  }
  else {
    CFStringRef v6 = 0;
  }
  _CFAutoreleasePoolPop(v4);
  return v6;
}

Boolean CFTimeZoneIsDaylightSavingTime(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  LOBYTE(tz) = [(__CFTimeZone *)tz isDaylightSavingTimeForDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  _CFAutoreleasePoolPop(v4);
  return tz;
}

CFTimeInterval CFTimeZoneGetDaylightSavingTimeOffset(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  [(__CFTimeZone *)tz daylightSavingTimeOffsetForDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  double v6 = v5;
  _CFAutoreleasePoolPop(v4);
  return v6;
}

CFAbsoluteTime CFTimeZoneGetNextDaylightSavingTimeTransition(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  double v5 = (void *)[(__CFTimeZone *)tz nextDaylightSavingTimeTransitionAfterDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  if (v5)
  {
    [v5 timeIntervalSinceReferenceDate];
    double v7 = v6;
  }
  else
  {
    double v7 = 0.0;
  }
  _CFAutoreleasePoolPop(v4);
  return v7;
}

CFStringRef CFTimeZoneCopyLocalizedName(CFTimeZoneRef tz, CFTimeZoneNameStyle style, CFLocaleRef locale)
{
  double v6 = (void *)_CFAutoreleasePoolPush();
  double v7 = (const void *)[(__CFTimeZone *)tz localizedName:style locale:locale];
  if (v7) {
    CFStringRef v8 = (const __CFString *)CFRetain(v7);
  }
  else {
    CFStringRef v8 = 0;
  }
  _CFAutoreleasePoolPop(v6);
  return v8;
}

const char *__CFStringEncodingGetICUName(int a1)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  if (a1 == 2576) {
    return "IMAP-mailbox-name";
  }
  if ((a1 & 0xF00) == 0x100
    || (int WindowsCodePage = __CFStringEncodingGetWindowsCodePage(a1)) == 0
    || snprintf(__str, 0x3CuLL, "windows-%d", WindowsCodePage) > 59
    || (uint64_t result = (const char *)ucnv_getAlias()) == 0)
  {
    if (__CFStringEncodingGetCanonicalName(a1, __str, 60)) {
      return (const char *)ucnv_getAlias();
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t __CFStringEncodingGetFromICUName(const char *a1)
{
  __endptr[1] = *(char **)off_1ECE0A5B0;
  __endptr[0] = 0;
  if (!strncasecmp_l(a1, "windows-", 8uLL, 0))
  {
    int v12 = strtol(a1 + 8, __endptr, 10);
    if (v12)
    {
      if (!*__endptr[0])
      {
        return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)v12);
      }
    }
  }
  if (!ucnv_countAliases()) {
    return 0xFFFFFFFFLL;
  }
  StandardName = (const char *)ucnv_getStandardName();
  if (!StandardName) {
    goto LABEL_25;
  }
  uint32_t v3 = StandardName;
  if (!strncasecmp_l(StandardName, "windows-", 8uLL, 0))
  {
    int v12 = strtol(v3 + 8, __endptr, 10);
    if (v12)
    {
      if (!*__endptr[0]) {
        return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)v12);
      }
    }
  }
  size_t v4 = strlen(v3);
  if (!strncasecmp_l(a1, v3, v4, 0) || (uint64_t result = __CFStringEncodingGetFromCanonicalName(v3), result == -1))
  {
LABEL_25:
    double v6 = (const char *)ucnv_getStandardName();
    if (!v6
      || (double v7 = v6, v8 = strlen(v6), !strncasecmp_l(a1, v7, v8, 0))
      || (uint64_t result = __CFStringEncodingGetFromCanonicalName(v7), result == -1))
    {
      uint64_t v9 = (const char *)ucnv_getStandardName();
      if (v9)
      {
        uint64_t v10 = v9;
        size_t v11 = strlen(v9);
        if (strncasecmp_l(a1, v10, v11, 0)) {
          return __CFStringEncodingGetFromCanonicalName(v10);
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t __CFStringEncodingICUToBytes(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, void *a8)
{
  if ((a2 & 0xFF0000) == 0) {
    goto LABEL_6;
  }
  uint64_t Typed = (void *)_CFGetTSD(7u);
  if (!Typed)
  {
    uint64_t Typed = (void *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
    *uint64_t Typed = 0;
    Typed[1] = 0;
    _CFSetTSD(7u, (uint64_t)Typed, (uint64_t)__CFICUThreadDataDestructor);
  }
  if (*(unsigned __int8 *)Typed <= (BYTE2(a2) - 1)
    || (uint64_t v16 = *(void *)(Typed[1] + 8 * (BYTE2(a2) - 1))) == 0)
  {
LABEL_6:
    uint64_t v17 = ucnv_open();
    if (!v17) {
      return 3;
    }
    uint64_t v16 = v17;
    int v18 = HIBYTE(a2);
    if ((a2 & 0xFF000001) == 1) {
      int v18 = 63;
    }
    if (v18) {
      ucnv_setSubstChars();
    }
    else {
      ucnv_setFromUCallBack();
    }
  }
  unint64_t v20 = a3 + 2 * a4;
  if (a7)
  {
    ucnv_fromUnicode();
    if (a8) {
      *a8 = a6 - a6;
    }
  }
  else
  {
    while (a3 < v20)
      ucnv_fromUnicode();
    if (a8) {
      *a8 = 0;
    }
  }
  if (a5) {
    *a5 = (uint64_t)(a3 - a3) >> 1;
  }
  return __CFStringEncodingConverterReleaseICUConverter(v16, a2, 0);
}

uint64_t __CFStringEncodingConverterReleaseICUConverter(uint64_t a1, unsigned int a2, uint64_t a3)
{
  LODWORD(v4) = HIWORD(a2);
  if (a3 != 1 && ((a2 & 0x1000) != 0 || a3 == 2 && (a2 & 0x2000) != 0))
  {
    if ((a2 & 0xFF0000) != 0) {
      return v4 << 16;
    }
    uint64_t Typed = (unsigned __int8 *)_CFGetTSD(7u);
    if (!Typed)
    {
      uint64_t Typed = (unsigned __int8 *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
      *(void *)uint64_t Typed = 0;
      *((void *)Typed + __postAndResetMidnight(1, 1) = 0;
      _CFSetTSD(7u, (uint64_t)Typed, (uint64_t)__CFICUThreadDataDestructor);
    }
    size_t v4 = (void *)*((void *)Typed + 1);
    if (!v4)
    {
      size_t v11 = (_OWORD *)CFAllocatorAllocateTyped(0, 80, 0x2004093837F09, 0);
      LOBYTE(v9) = 0;
      *((void *)Typed + __postAndResetMidnight(1, 1) = v11;
      *size_t v11 = 0u;
      v11[1] = 0u;
      v11[2] = 0u;
      v11[3] = 0u;
      v11[4] = 0u;
      LOBYTE(v1_CFSetTSD(0xFu, 0, 0) = 10;
      *uint64_t Typed = 10;
      size_t v4 = (void *)*((void *)Typed + 1);
      goto LABEL_29;
    }
    uint64_t v9 = Typed[1];
    uint64_t v10 = *Typed;
    if (v9 >= v10)
    {
      if (!*Typed)
      {
        uint64_t v10 = 0;
LABEL_28:
        unsigned __int8 v13 = v10 + 10;
        size_t v14 = 8 * (v10 + 10);
        size_t v4 = (void *)CFAllocatorAllocateTyped(0, v14, 0x2004093837F09, 0);
        bzero(v4, v14);
        memcpy(v4, *((const void **)Typed + 1), 8 * *Typed);
        CFAllocatorDeallocate(0, *((void **)Typed + 1));
        *((void *)Typed + __postAndResetMidnight(1, 1) = v4;
        LOBYTE(v9) = *Typed;
        LOBYTE(v1_CFSetTSD(0xFu, 0, 0) = v13;
        *uint64_t Typed = v13;
        goto LABEL_29;
      }
    }
    else if (!*((void *)v4 + v9))
    {
      goto LABEL_29;
    }
    uint64_t v9 = 0;
    while (*((void *)v4 + v9))
    {
      if (v10 == ++v9)
      {
        if (v10 <= 0xF5) {
          goto LABEL_28;
        }
        CFLog(3, @"Per-thread streaming ID for ICU converters exhausted. Ignoring...");
        goto LABEL_26;
      }
    }
LABEL_29:
    *((void *)v4 + v9) = a1;
    LOBYTE(v4) = v9 + 1;
    unsigned __int8 v15 = v9 + 1;
    Typed[1] = v15;
    if (v15 >= v10)
    {
      if (!(_BYTE)v10)
      {
        LOBYTE(v1_CFSetTSD(0xFu, 0, 0) = 0;
LABEL_39:
        Typed[1] = v10;
        return v4 << 16;
      }
    }
    else if (!*(void *)(*((void *)Typed + 1) + 8 * v15))
    {
      return v4 << 16;
    }
    uint64_t v16 = 0;
    while (*(void *)(*((void *)Typed + 1) + 8 * v16))
    {
      if (v10 == ++v16) {
        goto LABEL_39;
      }
    }
    LOBYTE(v1_CFSetTSD(0xFu, 0, 0) = v16;
    goto LABEL_39;
  }
  if ((a2 & 0xFF0000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)_CFGetTSD(7u);
    if (!v5)
    {
      uint64_t v5 = (unsigned __int8 *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + __postAndResetMidnight(1, 1) = 0;
      _CFSetTSD(7u, (uint64_t)v5, (uint64_t)__CFICUThreadDataDestructor);
    }
    unsigned __int8 v6 = (_BYTE)v4 - 1;
    if (*v5 > ((_BYTE)v4 - 1))
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (*(void *)(v7 + 8 * ((_BYTE)v4 - 1)) == a1)
      {
        *(void *)(v7 + 8 * ((_BYTE)v4 - 1)) = 0;
        if (v5[1] > v6) {
          v5[1] = v6;
        }
      }
    }
  }
LABEL_26:
  ucnv_close();
  return 0;
}

uint64_t __CFStringEncodingICUByteLength(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  v5[1] = *(void *)off_1ECE0A5B0;
  v5[0] = 0;
  if (__CFStringEncodingICUToBytes(a1, a2, a3, a4, 0, 0, 0, v5)) {
    return 0;
  }
  else {
    return v5[0];
  }
}

_DWORD *__CFStringEncodingCreateICUEncodings(const __CFAllocator *a1, void *a2)
{
  int v4 = ucnv_countAvailable();
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t Typed = (_DWORD *)CFAllocatorAllocateTyped(0, 4 * v4, 0x100004052888210, 0);
  if ((int)v5 < 1) {
    goto LABEL_8;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  do
  {
    AvailableName = (const char *)ucnv_getAvailableName();
    int v10 = __CFStringEncodingGetFromICUName(AvailableName);
    if (v10 != -1) {
      Typed[v8++] = v10;
    }
    ++v7;
  }
  while (v5 != v7);
  if (!v8)
  {
LABEL_8:
    CFAllocatorDeallocate(a1, Typed);
    uint64_t v8 = 0;
    uint64_t Typed = 0;
  }
  *a2 = v8;
  return Typed;
}

void __CFICUThreadDataDestructor(void *ptr)
{
  CFDictionaryRef v2 = (char *)ptr[1];
  if (v2)
  {
    if (*(unsigned char *)ptr)
    {
      uint32_t v3 = &v2[8 * *(unsigned __int8 *)ptr];
      do
      {
        v2 += 8;
        ucnv_close();
      }
      while (v2 < v3);
      CFDictionaryRef v2 = (char *)ptr[1];
    }
    CFAllocatorDeallocate(0, v2);
  }

  CFAllocatorDeallocate(0, ptr);
}

uint64_t __CFStringEncodingGetWindowsCodePage(int a1)
{
  if ((a1 & 0xF00) == 0x200) {
    return a1 + 28590;
  }
  if ((a1 & 0xF00) == 0x100)
  {
    HIDWORD(v2) = a1 - 256;
    LODWORD(v2) = a1 - 256;
    unsigned int v1 = v2 >> 26;
    if (v1 < 7) {
      return word_182EDDA68[v1];
    }
    return 0;
  }
  int v4 = (__int16 *)&unk_182EDDA66;
  unsigned int v5 = a1 & 0xFFF;
  unsigned __int8 v6 = &__CFKnownEncodingList;
  while (1)
  {
    uint64_t v7 = (char *)&v6[((char *)v4 - (char *)v6) >> 2];
    unsigned int v8 = *(unsigned __int16 *)v7;
    if (v5 == v8) {
      break;
    }
    uint64_t v9 = (unsigned __int16 *)(v7 - 2);
    int v10 = (__int16 *)(v7 + 2);
    if (v5 < v8) {
      int v4 = (__int16 *)v9;
    }
    else {
      unsigned __int8 v6 = v10;
    }
    if (v6 > v4) {
      return 0;
    }
  }
  if (v7 - (char *)&__CFKnownEncodingList == -2) {
    return 0;
  }
  return *(unsigned __int16 *)((char *)&__CFWindowsCPList + v7 - (char *)&__CFKnownEncodingList);
}

uint64_t __CFStringEncodingGetFromWindowsCodePage(int a1)
{
  v5[1] = *(const void **)off_1ECE0A5B0;
  if (a1 <= 64999)
  {
    if (a1)
    {
      if (a1 == 1200)
      {
        return 256;
      }
      else if (a1 == 1201)
      {
        return 268435712;
      }
      else
      {
LABEL_12:
        if ((a1 - 28591) > 0xF)
        {
          v5[0] = 0;
          os_unfair_lock_lock_with_options();
          if (!__CFStringEncodingGetFromWindowsCodePage_mappingTable)
          {
            uint64_t v4 = 0;
            __CFStringEncodingGetFromWindowsCodePage_mappingTable = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, 0);
            do
            {
              if (__CFWindowsCPList[v4]) {
                CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromWindowsCodePage_mappingTable, (const void *)(unsigned __int16)__CFWindowsCPList[v4], (const void *)(unsigned __int16)__CFKnownEncodingList[v4]);
              }
              ++v4;
            }
            while (v4 != 98);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringEncodingGetFromWindowsCodePage_lock);
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFStringEncodingGetFromWindowsCodePage_mappingTable, (const void *)a1, v5))
          {
            return LODWORD(v5[0]);
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          return (a1 - 28078);
        }
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    int v2 = a1 - 65000;
    uint64_t result = 134217984;
    switch(v2)
    {
      case 0:
        uint64_t result = 67109120;
        break;
      case 1:
        return result;
      case 5:
        uint64_t result = 201326848;
        break;
      case 6:
        uint64_t result = 402653440;
        break;
      default:
        goto LABEL_12;
    }
  }
  return result;
}

uint64_t __CFStringEncodingGetMostCompatibleMacScript()
{
  return 0xFFFFFFFFLL;
}

const char *__CFStringEncodingGetName(int a1)
{
  if (a1 > 67109119)
  {
    if (a1 <= 268435711)
    {
      switch(a1)
      {
        case 67109120:
          return "Unicode (UTF-7)";
        case 134217984:
          return "Unicode (UTF-8)";
        case 201326848:
          return "Unicode (UTF-32)";
      }
    }
    else if (a1 > 402653439)
    {
      if (a1 == 402653440) {
        return "Unicode (UTF-32BE)";
      }
      if (a1 == 469762304) {
        return "Unicode (UTF-32LE)";
      }
    }
    else
    {
      if (a1 == 268435712) {
        return "Unicode (UTF-16BE)";
      }
      if (a1 == 335544576) {
        return "Unicode (UTF-16LE)";
      }
    }
    return 0;
  }
  else
  {
    switch(a1)
    {
      case 3056:
        uint64_t result = "Japanese (NTT Docomo Shift JIS)";
        break;
      case 3057:
        uint64_t result = "Japanese (KDDI Shift JIS)";
        break;
      case 3058:
        uint64_t result = "Japanese (SoftBank Shift JIS)";
        break;
      case 3059:
        uint64_t result = "Japanese (NTT Docomo ISO 2022-JP)";
        break;
      case 3060:
        uint64_t result = "Japanese (KDDI ISO 2022-JP)";
        break;
      default:
        if (a1 == 256)
        {
          uint64_t result = "Unicode (UTF-16)";
        }
        else
        {
          if (a1 != 3071) {
            return 0;
          }
          uint64_t result = "Non-lossy ASCII";
        }
        break;
    }
  }
  return result;
}

__CFString *_CFPrefsCopyDescriptionOfAllSearchLists()
{
  return @"Obsolete";
}

void _CFPrefsDumpDescriptionOfAllSearchLists(const char *a1)
{
  id v2 = +[_CFXPreferences copyDefaultPreferences];
  CFStringRef v3 = -[_CFXPreferences copyDescriptionOfSearchLists]((uint64_t)v2);

  if (!v3) {
    return;
  }
  if (a1)
  {
    size_t v4 = strlen(a1);
    CFURLRef v5 = CFURLCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)a1, v4, 0x8000100u, 0);
    if (!v5) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v6 = _CFProcessNameString();
  uint64_t v7 = getpid();
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"/tmp/%@-preferences-search-lists(%d:%f).txt", v6, v7, *(void *)&Current);
  if (v9)
  {
    CFStringRef v10 = v9;
    CFURLRef v5 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 0);
    CFRelease(v10);
    if (v5)
    {
LABEL_8:
      CFIndex Length = CFStringGetLength(v3);
      CFIndex v12 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
      unsigned __int8 v13 = (char *)malloc_type_calloc(v12, 1uLL, 0x100004077774924uLL);
      CFStringGetCString(v3, v13, v12, 0x8000100u);
      size_t v14 = strlen(v13);
      _CFWriteBytesToFile(v5, v13, v14);
      CFRelease(v5);
      free(v13);
    }
  }
LABEL_9:

  CFRelease(v3);
}

uint64_t _CFPrefsSetEphemeralMultiUserEnabled(uint64_t result)
{
  eduModeOverride = result;
  return result;
}

CFStringRef _CFPrefsCreateConfigurationFileNameFromIdentifier(const __CFString *a1)
{
  CFStringRef v1 = a1;
  if (a1)
  {
    BOOL v2 = eduModeEnabled();
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v1);
    CFStringRef v1 = MutableCopy;
    if (v2) {
      CFStringRef v4 = @"-cloud-users.defaults";
    }
    else {
      CFStringRef v4 = @".defaults";
    }
    CFStringAppend(MutableCopy, v4);
  }
  return v1;
}

CFURLRef _CFPrefsCopyCloudConfigurationURLFromBundle(__CFBundle *a1, const __CFString *Identifier)
{
  CFURLRef v4 = CFBundleCopyResourcesDirectoryURL(a1);
  if (!v4) {
    return 0;
  }
  CFURLRef v5 = v4;
  if (!Identifier) {
    CFStringRef Identifier = CFBundleGetIdentifier(a1);
  }
  ConfigurationFileNameFromCFStringRef Identifier = _CFPrefsCreateConfigurationFileNameFromIdentifier(Identifier);
  if (ConfigurationFileNameFromIdentifier)
  {
    CFStringRef v7 = ConfigurationFileNameFromIdentifier;
    CFURLRef v8 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, ConfigurationFileNameFromIdentifier, 0);
    CFRelease(v7);
  }
  else
  {
    CFURLRef v8 = 0;
  }
  CFRelease(v5);
  return v8;
}

void _CFPrefsEnableWritingToExternalAppCloudPreferences()
{
  _CFPrefsOverrideEnableWritingToExternalAppCloudPreferences = 1;
}

CFURLRef _CFPrefsCopyCloudConfigurationURLForIdentifier(const void *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMappingLock);
  CFDictionaryRef Mutable = (const __CFDictionary *)_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping;
  if (!_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    _CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping = (uint64_t)Mutable;
  }
  CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(Mutable, a1);
  if (Value)
  {
    CFURLRef v4 = Value;
    CFRetain(Value);
    goto LABEL_12;
  }
  CFURLRef v5 = (void *)MEMORY[0x185311AE0]();
  uint64_t v6 = sel_registerName("applicationProxyForIdentifier:");
  id v7 = objc_msgSend((void *)getLSApplicationProxyClass[0](), v6, a1);
  if (!v7 || (CFURLRef v8 = (const __CFURL *)objc_msgSend(v7, sel_registerName("bundleURL"))) == 0)
  {
    goto LABEL_11;
  }
  CFURLRef v9 = v8;
  CFRetain(v8);
  Unique = (__CFBundle *)_CFBundleCreateUnique((const __CFAllocator *)&__kCFAllocatorSystemDefault, v9);
  CFRelease(v9);
  if (!Unique)
  {
LABEL_11:
    CFURLRef v4 = 0;
    goto LABEL_12;
  }
  CFURLRef v4 = _CFPrefsCopyCloudConfigurationURLFromBundle(Unique, 0);
  CFRelease(Unique);
  if (v4) {
    CFDictionarySetValue((CFMutableDictionaryRef)_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping, a1, v4);
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMappingLock);
  return v4;
}

void sub_182D1E1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D1E358(_Unwind_Exception *exception_object)
{
}

void pendingKVODestructor()
{
  qword_1EC093AA8 = (uint64_t)"Unexpected pending notifications upon thread exit";
  abort();
}

void sub_182D1E9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void sub_182D1EEE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *copyDescriptionApplier(uint64_t a1, void *a2, __CFString *a3)
{
  CFURLRef v5 = (void *)_CFAutoreleasePoolPush();
  CFStringAppend(a3, @"\n*********\n");
  CFStringRef v6 = (const __CFString *)[a2 description];
  if (v6) {
    CFStringAppend(a3, v6);
  }

  return _CFAutoreleasePoolPop(v5);
}

BOOL _CFPrefsWritingToExternalAppCloudPreferencesEnabled()
{
  if (_CFPrefsOverrideEnableWritingToExternalAppCloudPreferences) {
    return 1;
  }
  if (_CFPrefsWritingToExternalAppCloudPreferencesEnabled_onceToken != -1) {
    dispatch_once(&_CFPrefsWritingToExternalAppCloudPreferencesEnabled_onceToken, &__block_literal_global_157);
  }
  return _CFPrefsOverrideEnableWritingToExternalAppCloudPreferences != 0;
}

void *initLSApplicationProxy()
{
  if (MobileCoreServicesLibrary_frameworkLibrary
    || (uint64_t result = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", 2),
        (MobileCoreServicesLibrary_frameworkLibrary = (uint64_t)result) != 0))
  {
    uint64_t result = objc_getClass("LSApplicationProxy");
    classLSApplicationProxy = (uint64_t)result;
    getLSApplicationProxyClass[0] = LSApplicationProxyFunction;
  }
  return result;
}

uint64_t LSApplicationProxyFunction()
{
  return classLSApplicationProxy;
}

__CFBundle *__appIsInternal_block_invoke()
{
  uint64_t v0 = _CFProcessPath();
  if (strncmp(v0, "/private/var/", 0xDuLL))
  {
    uint64_t result = (__CFBundle *)strncmp(v0, "/var/", 5uLL);
    if (result)
    {
      BOOL v2 = 1;
LABEL_7:
      appIsInternal_isInternal = v2;
      return result;
    }
  }
  uint64_t result = CFBundleGetMainBundle();
  if (result)
  {
    uint64_t result = (__CFBundle *)CFBundleGetIdentifier(result);
    if (result)
    {
      uint64_t result = (__CFBundle *)CFStringHasPrefix((CFStringRef)result, @"com.apple.");
      BOOL v2 = result != 0;
      goto LABEL_7;
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_17(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

uint64_t OUTLINED_FUNCTION_0_18(objc_class *a1)
{
  return __CFFullMethodName(a1, v2, v1);
}

void NSMoribundCache_invalidAccess()
{
  if (NSMoribundCache_invalidAccess_oGuard != -1) {
    dispatch_once(&NSMoribundCache_invalidAccess_oGuard, &__block_literal_global_34);
  }
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void __NSCacheApplicationDidEnterBackgroundCallBack(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = a2;
  if (a2[24] != 255) {
    cache_remove_with_block();
  }
}

void sub_182D1FBB8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x182D1FB7CLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFURLCreateByResolvingAliasFile()
{
  return MEMORY[0x1F4114FF8]();
}

uint64_t _CFURLBookmarkCopyDescription()
{
  return MEMORY[0x1F4114E98]();
}

CFTypeID CFURLEnumeratorGetTypeID(void)
{
  return MEMORY[0x1F4115028]();
}

uint64_t _CFURLEnumeratorGetURLsBulk()
{
  return MEMORY[0x1F4115030]();
}

void CFURLEnumeratorSkipDescendents(CFURLEnumeratorRef enumerator)
{
}

CFIndex CFURLEnumeratorGetDescendentLevel(CFURLEnumeratorRef enumerator)
{
  return MEMORY[0x1F4115010](enumerator);
}

Boolean CFURLEnumeratorGetSourceDidChange(CFURLEnumeratorRef enumerator)
{
  return MEMORY[0x1F4115020](enumerator);
}

uint64_t CFBasicHashHasStrongValues()
{
  return 0;
}

uint64_t CFBasicHashHasStrongKeys()
{
  return 0;
}

uint64_t CFBasicHashGetNumBuckets(uint64_t a1)
{
  return __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
}

uint64_t CFBasicHashGetCapacity(uint64_t a1)
{
  return __CFBasicHashTableCapacities[*(unsigned __int8 *)(a1 + 26)];
}

unint64_t CFBasicHashGetFlags(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 18);
  if ((v1 & 0x18) != 0) {
    return (unsigned __int16)(*(long long *)(a1 + 24) >> 51) & 0x8000 | (unint64_t)(((v1 & 3) << 13) | (v1 >> 2) & 1) | 2;
  }
  else {
    return (unsigned __int16)(*(long long *)(a1 + 24) >> 51) & 0x8000 | (unint64_t)(((v1 & 3) << 13) | (v1 >> 2) & 1);
  }
}

uint64_t __CFBasicHashGetCountOfValue_block_invoke(void *a1, uint64_t a2)
{
  if (a1[5] == *(void *)(a2 + 16)
    || (uint64_t v4 = *(unsigned int (**)(void))(CFBasicHashCallBackPtrs[((*(void *)(a1[6] + 32) >> 34) >> 5) & 0x1F]
                                      + 8 * ((*(void *)(a1[6] + 32) >> 34) & 0x1FLL))) != 0
    && v4())
  {
    *(void *)(*(void *)(a1[4] + 8) + 24) += *(void *)(a2 + 24);
  }
  return 1;
}

uint64_t CFBasicHashApplyIndexed(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (a3 < 0) {
    goto LABEL_8;
  }
  uint64_t v4 = a3;
  if (!a3) {
    return result;
  }
  uint64_t v5 = a2;
  uint64_t v6 = result;
  if (__CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)] < a2 + a3) {
LABEL_8:
  }
    __break(1u);
  do
  {
    long long v10 = 0u;
    long long v11 = 0u;
    uint64_t result = CFBasicHashGetBucket(v6, v5, &v10);
    if (*((void *)&v11 + 1))
    {
      CFURLRef v8 = *(uint64_t (**)(uint64_t, _OWORD *))(a4 + 16);
      v9[0] = v10;
      v9[1] = v11;
      uint64_t result = v8(a4, v9);
      if (!result) {
        break;
      }
    }
    ++v5;
    --v4;
  }
  while (v4);
  return result;
}

unint64_t CFBasicHashRemoveValueAtIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0) {
    __break(1u);
  }
  long long v9 = 0u;
  long long v10 = 0u;
  CFBasicHashGetBucket(a1, a2, &v9);
  unint64_t v4 = *((void *)&v10 + 1);
  if (*((void *)&v10 + 1) < 2uLL)
  {
    if (*((void *)&v10 + 1) == 1) {
      __CFBasicHashRemoveValue(a1, v9);
    }
  }
  else
  {
    ++*(_WORD *)(a1 + 16);
    unsigned int v5 = *(unsigned __int16 *)(a1 + 18);
    if (v4 <= 0x7FFFFFFFFFFFFFFELL && (v5 & 0x18) != 0)
    {
      uint64_t v7 = *(void *)(a1 + (v5 & 0x18) + 40);
      switch((v5 >> 5) & 3)
      {
        case 1u:
          --*(_WORD *)(v7 + 2 * v9);
          break;
        case 2u:
          --*(_DWORD *)(v7 + 4 * v9);
          break;
        case 3u:
          --*(void *)(v7 + 8 * v9);
          break;
        default:
          --*(unsigned char *)(v7 + v9);
          break;
      }
    }
  }
  return v4;
}

uint64_t CFBasicHashAddIntValueAndInc(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233) {
    goto LABEL_57;
  }
  long long v18 = 0u;
  long long v19 = 0u;
  if (*(unsigned char *)(a1 + 26))
  {
    int v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        default:
          goto LABEL_57;
      }
    }
    else
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v18);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v18);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v18);
          break;
        default:
          goto LABEL_57;
      }
    }
  }
  else
  {
    long long v18 = xmmword_182EDDE80;
    long long v19 = *(_OWORD *)algn_182EDDE90;
  }
  if (*((void *)&v19 + 1))
  {
    uint64_t result = 0;
    ++*(_WORD *)(a1 + 16);
    return result;
  }
  uint64_t v9 = *(unsigned __int8 *)(a1 + 26);
  if (__CFBasicHashTableCapacities[v9] < (uint64_t)(*(_DWORD *)(a1 + 20) + 1))
  {
    __CFBasicHashRehash(a1, 1);
    if (!*(unsigned char *)(a1 + 26))
    {
      uint64_t Bucket_Exponential_Indirect_NoCollision = -1;
      goto LABEL_39;
    }
    int v10 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v10)
      {
        case 3:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
        case 2:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
        case 1:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
      }
    }
    else
    {
      switch(v10)
      {
        case 3:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(a1, a2);
          goto LABEL_39;
        case 2:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(a1, a2);
          goto LABEL_39;
        case 1:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(a1, a2);
LABEL_39:
          *(void *)&long long v18 = Bucket_Exponential_Indirect_NoCollision;
          uint64_t v9 = *(unsigned __int8 *)(a1 + 26);
          goto LABEL_40;
      }
    }
LABEL_57:
    __break(1u);
  }
LABEL_40:
  uint64_t v12 = __CFBasicHashTableSizes[v9];
  if (v12 >= 1)
  {
    for (uint64_t i = 0; v12 != i; ++i)
    {
      uint64_t v14 = *(void *)(a1 + 40);
      unint64_t v15 = *(void *)(v14 + 8 * i);
      if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v15 == 2780474809)
        {
          unint64_t v15 = -1;
        }
        else
        {
          if (v15 == 2814029233) {
            unint64_t v15 = 0;
          }
          if (v15 < a3) {
            continue;
          }
        }
        BOOL v16 = __CFADD__(v15, 1);
        uint64_t v17 = v15 + 1;
        if (v16) {
          uint64_t v17 = 2814029233;
        }
        if (v17 == -1) {
          uint64_t v17 = 2780474809;
        }
        *(void *)(v14 + 8 * i) = v17;
        ++*(_WORD *)(a1 + 16);
      }
    }
  }
  __CFBasicHashAddValue(a1, v18, a2, a3);
  return 1;
}

void CFBasicHashRemoveIntValueAndDec(uint64_t a1, unint64_t a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233)
  {
    __break(1u);
  }
  else
  {
    uint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = -1;
      while (1)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        unint64_t v7 = *(void *)(v6 + 8 * v4);
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          if (v7 == 2780474809)
          {
            unint64_t v7 = -1;
LABEL_13:
            if (v7 == a2) {
              uint64_t v5 = v4;
            }
            if (v7 > a2)
            {
              uint64_t v8 = v7 - 1;
              if (!v8) {
                uint64_t v8 = 2814029233;
              }
              *(void *)(v6 + 8 * v4) = v8;
              ++*(_WORD *)(a1 + 16);
            }
            goto LABEL_19;
          }
          if (v7 != 2814029233) {
            goto LABEL_13;
          }
          if (!a2) {
            uint64_t v5 = v4;
          }
        }
LABEL_19:
        if (v3 == ++v4) {
          goto LABEL_22;
        }
      }
    }
    uint64_t v5 = -1;
LABEL_22:
    __CFBasicHashRemoveValue(a1, v5);
  }
}

uint64_t CFBasicHashGetSize(uint64_t a1, int a2)
{
  __int16 v2 = *(_WORD *)(a1 + 18);
  uint64_t v3 = 56;
  if ((v2 & 4) == 0) {
    uint64_t v3 = 48;
  }
  if ((v2 & 0x18) != 0) {
    uint64_t v4 = v3 + 8;
  }
  else {
    uint64_t v4 = v3;
  }
  if (a2 && (uint64_t)__CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)] >= 1)
  {
    v4 += malloc_size(*(const void **)(a1 + 40));
    unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
    if ((v6 & 4) != 0)
    {
      v4 += malloc_size(*(const void **)(a1 + 8 * ((v6 >> 2) & 1) + 40));
      LODWORD(v6) = *(unsigned __int16 *)(a1 + 18);
    }
    if ((v6 & 0x18) != 0) {
      v4 += malloc_size(*(const void **)(a1 + 8 * ((v6 >> 3) & 3) + 40));
    }
  }
  return v4;
}

void CFBasicHashShow(uint64_t a1)
{
  unsigned int v1 = CFBasicHashCopyDescription(a1, 1, (uint64_t)&stru_1ECE10768, @"\t", 0);
  CFShow(v1);

  CFRelease(v1);
}

uint64_t CFBasicHashGetTypeID()
{
  return 3;
}

unint64_t ___CFBasicHashFindBucket_Linear_Indirect@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  unint64_t v9 = *(unsigned __int16 *)(a1 + 18);
  if ((v9 & 4) != 0) {
    int v10 = (uint64_t *)(a1 + 40 + 8 * ((v9 >> 2) & 1));
  }
  else {
    int v10 = (uint64_t *)(a1 + 40);
  }
  CFStringRef v25 = a3;
  if (!v6)
  {
    uint64_t v13 = -1;
LABEL_29:
    uint64_t v15 = 0;
    uint64_t v20 = v25;
    v25[1] = 0;
    int64_t v25[2] = 0;
    *CFStringRef v25 = v13;
    goto LABEL_30;
  }
  unint64_t v11 = result % v6;
  uint64_t v12 = *v10;
  uint64_t v13 = -1;
  unint64_t v14 = v6;
  while (1)
  {
    uint64_t v15 = *(void *)(v12 + 8 * v11);
    switch(v15)
    {
      case -1:
        if (v13 == -1) {
          uint64_t v13 = v11;
        }
        goto LABEL_23;
      case 0:
        uint64_t v20 = v25;
        v25[1] = 0;
        int64_t v25[2] = 0;
        if (v13 == -1) {
          uint64_t v21 = v11;
        }
        else {
          uint64_t v21 = v13;
        }
        *CFStringRef v25 = v21;
        goto LABEL_30;
      case 2814029233:
        uint64_t v15 = 0;
        break;
    }
    if (v15 == 2780474809) {
      uint64_t v16 = -1;
    }
    else {
      uint64_t v16 = v15;
    }
    uint64_t v17 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
    if (v17)
    {
      unint64_t result = v17(v16);
      uint64_t v16 = result;
    }
    if (v16 == a2) {
      break;
    }
    long long v18 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v18)
    {
      unint64_t result = v18(v16, a2);
      if (result) {
        goto LABEL_36;
      }
    }
LABEL_23:
    if (v6 <= v11 + 1) {
      unint64_t v19 = v6;
    }
    else {
      unint64_t v19 = 0;
    }
    unint64_t v11 = v11 + 1 - v19;
    if (!--v14) {
      goto LABEL_29;
    }
  }
  uint64_t v16 = a2;
LABEL_36:
  uint64_t v20 = v25;
  *CFStringRef v25 = v11;
  uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8 * v11);
  if (v22 == 2814029233)
  {
    uint64_t v22 = 0;
  }
  else if (v22 == 2780474809)
  {
    uint64_t v22 = -1;
  }
  v25[1] = v16;
  int64_t v25[2] = v22;
  unsigned int v23 = *(unsigned __int16 *)(a1 + 18);
  if ((v23 & 0x18) != 0)
  {
    uint64_t v24 = *(void *)(a1 + (v23 & 0x18) + 40);
    switch((v23 >> 5) & 3)
    {
      case 1u:
        uint64_t v15 = *(unsigned __int16 *)(v24 + 2 * v11);
        break;
      case 2u:
        uint64_t v15 = *(unsigned int *)(v24 + 4 * v11);
        break;
      case 3u:
        uint64_t v15 = *(void *)(v24 + 8 * v11);
        break;
      default:
        uint64_t v15 = *(unsigned __int8 *)(v24 + v11);
        break;
    }
  }
  else
  {
    uint64_t v15 = 1;
  }
LABEL_30:
  v20[3] = v15;
  return result;
}

unint64_t ___CFBasicHashFindBucket_Double_Indirect@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  if (result / v6 % v6) {
    unint64_t v9 = result / v6 % v6;
  }
  else {
    unint64_t v9 = v6 - 1;
  }
  unint64_t v10 = *(unsigned __int16 *)(a1 + 18);
  if ((v10 & 4) != 0) {
    unint64_t v11 = (uint64_t *)(a1 + 40 + 8 * ((v10 >> 2) & 1));
  }
  else {
    unint64_t v11 = (uint64_t *)(a1 + 40);
  }
  statfs v26 = a3;
  if (!v6)
  {
    uint64_t v14 = -1;
LABEL_32:
    uint64_t v16 = 0;
    uint64_t v21 = v26;
    v26[1] = 0;
    v26[2] = 0;
    *statfs v26 = v14;
    goto LABEL_33;
  }
  unint64_t v12 = result % v6;
  uint64_t v13 = *v11;
  uint64_t v14 = -1;
  unint64_t v15 = v6;
  while (1)
  {
    uint64_t v16 = *(void *)(v13 + 8 * v12);
    switch(v16)
    {
      case -1:
        if (v14 == -1) {
          uint64_t v14 = v12;
        }
        goto LABEL_26;
      case 0:
        uint64_t v21 = v26;
        v26[1] = 0;
        v26[2] = 0;
        if (v14 == -1) {
          uint64_t v22 = v12;
        }
        else {
          uint64_t v22 = v14;
        }
        *statfs v26 = v22;
        goto LABEL_33;
      case 2814029233:
        uint64_t v16 = 0;
        break;
    }
    if (v16 == 2780474809) {
      uint64_t v17 = -1;
    }
    else {
      uint64_t v17 = v16;
    }
    long long v18 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
    if (v18)
    {
      unint64_t result = v18(v17);
      uint64_t v17 = result;
    }
    if (v17 == a2) {
      break;
    }
    unint64_t v19 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v19)
    {
      unint64_t result = v19(v17, a2);
      if (result) {
        goto LABEL_39;
      }
    }
LABEL_26:
    if (v6 <= v12 + v9) {
      unint64_t v20 = v6;
    }
    else {
      unint64_t v20 = 0;
    }
    unint64_t v12 = v12 + v9 - v20;
    if (!--v15) {
      goto LABEL_32;
    }
  }
  uint64_t v17 = a2;
LABEL_39:
  uint64_t v21 = v26;
  *statfs v26 = v12;
  uint64_t v23 = *(void *)(*(void *)(a1 + 40) + 8 * v12);
  if (v23 == 2814029233)
  {
    uint64_t v23 = 0;
  }
  else if (v23 == 2780474809)
  {
    uint64_t v23 = -1;
  }
  v26[1] = v17;
  v26[2] = v23;
  unsigned int v24 = *(unsigned __int16 *)(a1 + 18);
  if ((v24 & 0x18) != 0)
  {
    uint64_t v25 = *(void *)(a1 + (v24 & 0x18) + 40);
    switch((v24 >> 5) & 3)
    {
      case 1u:
        uint64_t v16 = *(unsigned __int16 *)(v25 + 2 * v12);
        break;
      case 2u:
        uint64_t v16 = *(unsigned int *)(v25 + 4 * v12);
        break;
      case 3u:
        uint64_t v16 = *(void *)(v25 + 8 * v12);
        break;
      default:
        uint64_t v16 = *(unsigned __int8 *)(v25 + v12);
        break;
    }
  }
  else
  {
    uint64_t v16 = 1;
  }
LABEL_33:
  v21[3] = v16;
  return result;
}

unint64_t ___CFBasicHashFindBucket_Double@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  if (result / v6 % v6) {
    unint64_t v9 = result / v6 % v6;
  }
  else {
    unint64_t v9 = v6 - 1;
  }
  unint64_t v10 = *(unsigned __int16 *)(a1 + 18);
  unint64_t v11 = (void *)(a1 + 40);
  if ((v10 & 4) != 0) {
    unint64_t v12 = (uint64_t *)(a1 + 40 + 8 * ((v10 >> 2) & 1));
  }
  else {
    unint64_t v12 = (uint64_t *)(a1 + 40);
  }
  uint64_t v28 = a3;
  if (!v6)
  {
    uint64_t v15 = -1;
LABEL_30:
    uint64_t v17 = 0;
    uint64_t v21 = v28;
    v28[1] = 0;
    void v28[2] = 0;
    *uint64_t v28 = v15;
    goto LABEL_31;
  }
  unint64_t v13 = result % v6;
  uint64_t v14 = *v12;
  uint64_t v15 = -1;
  unint64_t v16 = v6;
  while (1)
  {
    uint64_t v17 = *(void *)(v14 + 8 * v13);
    switch(v17)
    {
      case -1:
        if (v15 == -1) {
          uint64_t v15 = v13;
        }
        goto LABEL_24;
      case 0:
        uint64_t v21 = v28;
        v28[1] = 0;
        void v28[2] = 0;
        if (v15 == -1) {
          uint64_t v22 = v13;
        }
        else {
          uint64_t v22 = v15;
        }
        *uint64_t v28 = v22;
        goto LABEL_31;
      case 2814029233:
        uint64_t v17 = 0;
        break;
    }
    uint64_t v18 = v17 == 2780474809 ? -1 : v17;
    if (v18 == a2) {
      break;
    }
    unint64_t v19 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v19)
    {
      unint64_t result = v19(v18, a2);
      if (result) {
        goto LABEL_37;
      }
    }
LABEL_24:
    if (v6 <= v13 + v9) {
      unint64_t v20 = v6;
    }
    else {
      unint64_t v20 = 0;
    }
    unint64_t v13 = v13 + v9 - v20;
    if (!--v16) {
      goto LABEL_30;
    }
  }
  uint64_t v18 = a2;
LABEL_37:
  uint64_t v23 = *(void *)(*v11 + 8 * v13);
  uint64_t v24 = -1;
  if (v23 != 2780474809) {
    uint64_t v24 = *(void *)(*v11 + 8 * v13);
  }
  if (v23 == 2814029233) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = v24;
  }
  uint64_t v21 = v28;
  v28[1] = v18;
  void v28[2] = v25;
  *uint64_t v28 = v13;
  unsigned int v26 = *(unsigned __int16 *)(a1 + 18);
  if ((v26 & 0x18) != 0)
  {
    uint64_t v27 = *(void *)(a1 + (v26 & 0x18) + 40);
    switch((v26 >> 5) & 3)
    {
      case 1u:
        uint64_t v17 = *(unsigned __int16 *)(v27 + 2 * v13);
        break;
      case 2u:
        uint64_t v17 = *(unsigned int *)(v27 + 4 * v13);
        break;
      case 3u:
        uint64_t v17 = *(void *)(v27 + 8 * v13);
        break;
      default:
        uint64_t v17 = *(unsigned __int8 *)(v27 + v13);
        break;
    }
  }
  else
  {
    uint64_t v17 = 1;
  }
LABEL_31:
  v21[3] = v17;
  return result;
}

unint64_t ___CFBasicHashFindBucket_Exponential@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = a1;
  uint64_t v5 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v6 = __CFBasicHashTableSizes[v5];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  uint64_t v31 = v3;
  unint64_t v32 = a2;
  if (v7)
  {
    unint64_t result = v7(a2);
    uint64_t v3 = v31;
    a2 = v32;
  }
  if (result / v6 % v6) {
    unint64_t v9 = result / v6 % v6;
  }
  else {
    unint64_t v9 = v6 - 1;
  }
  unint64_t v10 = *(unsigned __int16 *)(v3 + 18);
  if ((v10 & 4) != 0) {
    unint64_t v11 = (uint64_t *)(v3 + 40 + 8 * ((v10 >> 2) & 1));
  }
  else {
    unint64_t v11 = (uint64_t *)(v3 + 40);
  }
  uint64_t v30 = a3;
  if (!v6)
  {
    uint64_t v15 = -1;
LABEL_31:
    uint64_t v19 = 0;
    uint64_t v22 = v30;
    v30[1] = 0;
    v30[2] = 0;
    *uint64_t v30 = v15;
    goto LABEL_32;
  }
  uint64_t v29 = (void *)(v3 + 40);
  unint64_t v12 = result % v6;
  unint64_t v13 = __CFBasicHashPrimitiveRoots[v5];
  uint64_t v14 = *v11;
  uint64_t v15 = -1;
  unint64_t v16 = v6;
  unint64_t v17 = v13;
  unint64_t v18 = result % v6;
  while (1)
  {
    uint64_t v19 = *(void *)(v14 + 8 * v18);
    switch(v19)
    {
      case -1:
        if (v15 == -1) {
          uint64_t v15 = v18;
        }
        goto LABEL_24;
      case 0:
        uint64_t v22 = v30;
        v30[1] = 0;
        v30[2] = 0;
        if (v15 == -1) {
          uint64_t v23 = v18;
        }
        else {
          uint64_t v23 = v15;
        }
        *uint64_t v30 = v23;
        goto LABEL_32;
      case 2814029233:
        uint64_t v19 = 0;
        break;
    }
    uint64_t v20 = v19 == 2780474809 ? -1 : v19;
    if (v20 == a2) {
      break;
    }
    uint64_t v21 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v3 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(v3 + 35) & 0x1F));
    if (v21)
    {
      unint64_t result = v21(v20, v32);
      uint64_t v3 = v31;
      a2 = v32;
      if (result) {
        goto LABEL_38;
      }
    }
LABEL_24:
    unint64_t v18 = v12 + v17 * v9;
    if (v6 <= v18) {
      v18 %= v6;
    }
    v17 *= v13;
    if (v6 <= v17) {
      v17 %= v6;
    }
    if (!--v16) {
      goto LABEL_31;
    }
  }
  uint64_t v20 = a2;
LABEL_38:
  uint64_t v24 = *(void *)(*v29 + 8 * v18);
  uint64_t v25 = -1;
  if (v24 != 2780474809) {
    uint64_t v25 = *(void *)(*v29 + 8 * v18);
  }
  if (v24 == 2814029233) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = v25;
  }
  uint64_t v22 = v30;
  v30[1] = v20;
  v30[2] = v26;
  *uint64_t v30 = v18;
  unsigned int v27 = *(unsigned __int16 *)(v3 + 18);
  if ((v27 & 0x18) != 0)
  {
    uint64_t v28 = *(void *)(v3 + (v27 & 0x18) + 40);
    switch((v27 >> 5) & 3)
    {
      case 1u:
        uint64_t v19 = *(unsigned __int16 *)(v28 + 2 * v18);
        break;
      case 2u:
        uint64_t v19 = *(unsigned int *)(v28 + 4 * v18);
        break;
      case 3u:
        uint64_t v19 = *(void *)(v28 + 8 * v18);
        break;
      default:
        uint64_t v19 = *(unsigned __int8 *)(v28 + v18);
        break;
    }
  }
  else
  {
    uint64_t v19 = 1;
  }
LABEL_32:
  v22[3] = v19;
  return result;
}

uint64_t ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = *(unsigned __int16 *)(a1 + 18);
  if ((v5 & 4) != 0) {
    unint64_t v6 = (uint64_t *)(a1 + 40 + 8 * ((v5 >> 2) & 1));
  }
  else {
    unint64_t v6 = (uint64_t *)(a1 + 40);
  }
  if (!v3) {
    return -1;
  }
  uint64_t v7 = *v6;
  uint64_t result = a2 % v3;
  unint64_t v9 = v3;
  while (*(void *)(v7 + 8 * result))
  {
    if (v3 <= result + 1) {
      unint64_t v10 = v3;
    }
    else {
      unint64_t v10 = 0;
    }
    uint64_t result = result + 1 - v10;
    if (!--v9) {
      return -1;
    }
  }
  return result;
}

uint64_t ___CFBasicHashFindBucket_Double_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = a2 / v3 % v3;
  if (!v5) {
    unint64_t v5 = v3 - 1;
  }
  unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 4) != 0) {
    uint64_t v7 = (uint64_t *)(a1 + 40 + 8 * ((v6 >> 2) & 1));
  }
  else {
    uint64_t v7 = (uint64_t *)(a1 + 40);
  }
  uint64_t v8 = *v7;
  uint64_t result = a2 % v3;
  unint64_t v10 = v3;
  while (*(void *)(v8 + 8 * result))
  {
    if (v3 <= result + v5) {
      unint64_t v11 = v3;
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t result = result + v5 - v11;
    if (!--v10) {
      return -1;
    }
  }
  return result;
}

uint64_t ___CFBasicHashFindBucket_Double_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = a2 / v3 % v3;
  if (!v5) {
    unint64_t v5 = v3 - 1;
  }
  unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 4) != 0) {
    uint64_t v7 = (uint64_t *)(a1 + 40 + 8 * ((v6 >> 2) & 1));
  }
  else {
    uint64_t v7 = (uint64_t *)(a1 + 40);
  }
  uint64_t v8 = *v7;
  uint64_t result = a2 % v3;
  unint64_t v10 = v3;
  while (*(void *)(v8 + 8 * result))
  {
    if (v3 <= result + v5) {
      unint64_t v11 = v3;
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t result = result + v5 - v11;
    if (!--v10) {
      return -1;
    }
  }
  return result;
}

unint64_t ___CFBasicHashFindBucket_Exponential_NoCollision(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v4 = __CFBasicHashTableSizes[v3];
  unint64_t v5 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v5) {
    a2 = v5(a2);
  }
  unint64_t v6 = a2 / v4 % v4;
  if (!v6) {
    unint64_t v6 = v4 - 1;
  }
  unint64_t v7 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v8 = (uint64_t *)(a1 + 40 + 8 * ((v7 >> 2) & 1));
  if ((v7 & 4) == 0) {
    uint64_t v8 = (uint64_t *)(a1 + 40);
  }
  uint64_t v9 = *v8;
  unint64_t v10 = v4;
  unint64_t v11 = __CFBasicHashPrimitiveRoots[v3];
  unint64_t result = a2 % v4;
  while (*(void *)(v9 + 8 * result))
  {
    unint64_t result = a2 % v4 + v11 * v6;
    if (v4 <= result) {
      result %= v4;
    }
    v11 *= __CFBasicHashPrimitiveRoots[v3];
    if (v4 <= v11) {
      v11 %= v4;
    }
    if (!--v10) {
      return -1;
    }
  }
  return result;
}

uint64_t CFXNotificationRegistrarGetTypeID()
{
  return 70;
}

uint64_t CFXNotificationRegistrarGetOptions(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void CFXNotificationRegistrarEnumerate(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v4 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[8], 0, a2);
  _CFXNotificationRegistrarEnumerateObjectTable((uint64_t)a1, (uint64_t)&a1[12], @"kCFNotificationAnyName", a2);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[16], 1, a2);
  _CFXNotificationRegistrarEnumerateObserverTable((uint64_t)a1, &a1[20]._os_unfair_lock_opaque, @"kCFNotificationAnyName", @"kCFNotificationAnyObject", a2);

  os_unfair_lock_unlock(v4);
}

void _CFXNotificationRegistrarEnumerateNameTable(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4)
  {
    unint64_t v8 = 0;
    uint64_t v13 = a2;
    do
    {
      uint64_t v9 = *(unsigned int *)(*(void *)a2 + 4 * v8);
      if (v9 != -1)
      {
        do
        {
          uint64_t v10 = *(void *)(a1 + 96) + 40 * v9;
          uint64_t v9 = *(unsigned int *)(v10 + 4);
          CFTypeRef v11 = CFCachedStringCopyString((CFTypeRef *)(v10 + 8));
          unint64_t v12 = (unsigned int *)(v10 + 24);
          if (a3 == 1) {
            _CFXNotificationRegistrarEnumerateObserverTable(a1, v12, (uint64_t)v11, @"kCFNotificationAnyObject", a4);
          }
          else {
            _CFXNotificationRegistrarEnumerateObjectTable(a1, (uint64_t)v12, (uint64_t)v11, a4);
          }
          CFRelease(v11);
        }
        while (v9 != 0xFFFFFFFFLL);
        a2 = v13;
        unint64_t v4 = *(unsigned int *)(v13 + 8);
      }
      ++v8;
    }
    while (v8 < v4);
  }
}

uint64_t _CFXNotificationRegistrarEnumerateObjectTable(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4)
  {
    uint64_t v8 = result;
    for (unint64_t i = 0; i < v4; ++i)
    {
      uint64_t v10 = *(unsigned int *)(*(void *)a2 + 4 * i);
      if (v10 != -1)
      {
        do
        {
          uint64_t v11 = *(void *)(v8 + 120) + 32 * v10;
          uint64_t v10 = *(unsigned int *)(v11 + 4);
          unint64_t result = _CFXNotificationRegistrarEnumerateObserverTable(v8, (unsigned int *)(v11 + 16), a3, *(void *)(v11 + 8), a4);
        }
        while (v10 != -1);
        unint64_t v4 = *(unsigned int *)(a2 + 8);
      }
    }
  }
  return result;
}

uint64_t _CFXNotificationRegistrarEnumerateObserverTable(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  uint64_t v5 = *a2;
  if (v5 != -1)
  {
    uint64_t v9 = result;
    do
    {
      uint64_t v10 = *(void *)(v9 + 144) + 56 * v5;
      uint64_t v11 = *(unsigned int *)(v10 + 4);
      long long v14 = 0u;
      long long v15 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      *(void *)&long long v13 = *(void *)(v10 + 8);
      long long v14 = *(_OWORD *)(v10 + 16);
      *(void *)&long long v12 = a3;
      *((void *)&v12 + __postAndResetMidnight(1, 1) = a4;
      *((void *)&v13 + __postAndResetMidnight(1, 1) = *(unsigned int *)(v10 + 44);
      *(void *)&long long v15 = v5 | ((unint64_t)*(unsigned int *)(v10 + 40) << 32);
      *((void *)&v15 + __postAndResetMidnight(1, 1) = *(void *)(v10 + 32);
      unint64_t result = (*(uint64_t (**)(uint64_t, long long *))(a5 + 16))(a5, &v12);
      uint64_t v5 = v11;
    }
    while (v11 != -1);
  }
  return result;
}

void CFXNotificationRegistrarUpdateDistributedConnections(os_unfair_lock_s *a1, uint64_t a2, uint64_t a3)
{
  void v5[7] = *(void *)off_1ECE0A5B0;
  v5[0] = off_1ECE0A5A0;
  v5[1] = 0x40000000;
  void v5[2] = __CFXNotificationRegistrarUpdateDistributedConnections_block_invoke;
  void v5[3] = &unk_1ECDFFAB0;
  v5[5] = a1;
  v5[6] = a2;
  v5[4] = a3;
  unint64_t v4 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[8], 0, (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateObjectTable((uint64_t)a1, (uint64_t)&a1[12], @"kCFNotificationAnyName", (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[16], 1, (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateObserverTable((uint64_t)a1, &a1[20]._os_unfair_lock_opaque, @"kCFNotificationAnyName", @"kCFNotificationAnyObject", (uint64_t)v5);
  os_unfair_lock_unlock(v4);
}

uint64_t __CFXNotificationRegistrarUpdateDistributedConnections_block_invoke(uint64_t a1, uint64_t a2)
{
  _CFXNotificationRegisteredObserverSetDistributedConnection(*(void **)(a1 + 40), *(_DWORD *)(a2 + 52), *(_DWORD *)(a2 + 48), *(void **)(a1 + 48));
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v3();
}

BOOL CFXNotificationRegistrarIsEmpty(os_unfair_lock_s *a1)
{
  __int16 v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  BOOL v3 = a1[15]._os_unfair_lock_opaque
     + a1[11]._os_unfair_lock_opaque
     + a1[19]._os_unfair_lock_opaque
     + a1[21]._os_unfair_lock_opaque == 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t _CFBundleSearchForLocalizedString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  uint64_t v13 = 0;
  long long v14 = &v13;
  uint64_t v15 = 0x2020000000;
  char v16 = 0;
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  uint64_t v9 = *(void **)(a1 + 144);
  if (v9)
  {
    v12[0] = off_1ECE0A5A0;
    v12[1] = 3221225472;
    v12[2] = ___CFBundleSearchForLocalizedString_block_invoke;
    v12[3] = &unk_1ECDFFB20;
    v12[6] = a3;
    v12[7] = a4;
    v12[4] = &v13;
    v12[5] = a2;
    CFDictionaryApply(v9, (uint64_t)v12);
  }
  os_unfair_lock_unlock(v8);
  uint64_t v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_182D21DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFBundleFlushStringSourceCache(uint64_t a1)
{
  __int16 v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  BOOL v3 = *(const void **)(a1 + 168);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 168) = 0;
  }

  os_unfair_lock_unlock(v2);
}

CFMutableDictionaryRef _CFBundleCopyFilteredLocalizedStringsForAllLocalizations(__CFBundle *a1, __CFString *a2, uint64_t a3)
{
  v10[8] = *(void *)off_1ECE0A5B0;
  CFBundleAllowMixedLocalizations();
  if (!a2 || CFEqual(a2, &stru_1ECE10768)) {
    a2 = @"Localizable";
  }
  CFArrayRef v6 = CFBundleCopyBundleLocalizations(a1);
  CFIndex Count = CFArrayGetCount(v6);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10[0] = off_1ECE0A5A0;
  v10[1] = 3221225472;
  v10[2] = ___CFBundleCopyFilteredLocalizedStringsForAllLocalizations_block_invoke;
  v10[3] = &__block_descriptor_64_e13_v24__0r_v8_16l;
  v10[4] = a1;
  v10[5] = a2;
  v10[6] = a3;
  v10[7] = Mutable;
  CFArrayApply((uint64_t)v6, 0, Count, (uint64_t)v10);
  CFRelease(v6);
  return Mutable;
}

CFSetRef _CFBundleCopyLocalizationInfoDictionaryKeys()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  v1[0] = xmmword_1ECDFFBA0;
  v1[1] = *(_OWORD *)off_1ECDFFBB0;
  return CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)v1, 4, &kCFTypeSetCallBacks);
}

CFDictionaryRef _CFBundleCopyFilteredLocalizedStringsForAllLocalizationsForURL(const __CFURL *a1, __CFString *a2, uint64_t a3, char a4)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  if (_CFBundleCouldBeBundle(a1))
  {
    v12[0] = xmmword_1ECDFFBA0;
    v12[1] = *(_OWORD *)off_1ECDFFBB0;
    CFSetRef v8 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)v12, 4, &kCFTypeSetCallBacks);
    UniqueWithOptions = (__CFBundle *)_CFBundleCreateUniqueWithOptions((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, v8, a4);
    CFRelease(v8);
    if (!UniqueWithOptions) {
      return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    CFMutableDictionaryRef v10 = _CFBundleCopyFilteredLocalizedStringsForAllLocalizations(UniqueWithOptions, a2, a3);
    CFRelease(UniqueWithOptions);
    return v10;
  }
  else
  {
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

const void *___postProcessStringsDict_block_invoke(uint64_t a1, const void *a2)
{
  v11[1] = *(const void **)off_1ECE0A5B0;
  v11[0] = a2;
  unint64_t result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (!result)
  {
    unint64_t result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
    if (!result)
    {
      uint64_t v5 = [[NSSet alloc] initWithObjects:v11 count:1];
      _loadStringsInOrder(*(const void **)(a1 + 48), *(void **)(a1 + 56), v5, *(CFDictionaryRef *)(a1 + 40), *(void *)(a1 + 64), 0);

      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v11[0]))
      {
        uint64_t v10 = 0;
        uint64_t v6 = *(void *)(a1 + 64);
        CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 40);
        uint64_t v8 = *(void *)(a1 + 48);
        v9[0] = *(void *)(v6 + 88);
        v9[1] = v7;
        _OWORD v9[2] = 0;
        v9[3] = v8;
        v9[4] = *(void *)(v6 + 24);
        LOBYTE(v1_CFSetTSD(0xFu, 0, 0) = *(unsigned char *)(a1 + 72);
        CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)__CFPlatformSpecificStringDictionaryApplyFunction, v9);
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 40), (CFDictionaryApplierFunction)__CFLocalizedFormatStringApplyFunction, v9);
      }
      return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v11[0]);
    }
  }
  return result;
}

void __CFVariableWidthStringApplyFunction(const void *a1, const void *a2, void *a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v7 = CFGetTypeID(a2);
  if (a3)
  {
    if (TypeID == v7)
    {
      if (a3[1])
      {
        if (*a3)
        {
          uint64_t v8 = (*(uint64_t (**)(void, const void *))(*a3 + 16))(*a3, a2);
          if (v8)
          {
            uint64_t v9 = (const void *)v8;
            CFTypeID v10 = CFStringGetTypeID();
            if (v10 == CFGetTypeID(v9))
            {
              uint64_t v11 = (__CFDictionary *)a3[1];
              CFDictionarySetValue(v11, a1, v9);
            }
          }
        }
      }
    }
  }
}

uint64_t (**__CFStringEncodingGetCyrillicConverterDefinition(int a1))()
{
  if (a1 > 1050)
  {
    switch(a1)
    {
      case 1051:
        return __CFConverterDOSRussian;
      case 2562:
        return __CFConverterKOI8R;
      case 1282:
        return __CFConverterWinCyrillic;
    }
    return 0;
  }
  unint64_t result = __CFConverterMacCyrillic;
  if (a1 != 7 && a1 != 152)
  {
    if (a1 == 517) {
      return __CFConverterISOCyrillic;
    }
    return 0;
  }
  return result;
}

uint64_t __CFToMacCyrillic(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8806 < 0xFFFFDE3A) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&maccyrillic_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182EDE2AC;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromMacCyrillic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = maccyrillic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacCyrillicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFPrecomposeCyrillicCharacter(a2);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8806) >= 0xDE3Au)
    {
      uint64_t v11 = (unsigned __int16 *)&maccyrillic_from_uni;
      long long v12 = (unsigned __int16 *)&unk_182EDE2AC;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        long long v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          long long v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

BOOL __CFIsValidCombiningCharacterForCyrillic(int a1)
{
  if ((a1 - 768) > 0xE) {
    return a1 == 824;
  }
  uint64_t v1 = 1;
  if (((1 << ~(_BYTE)a1) & 0xCA800000) == 0) {
    return a1 == 824;
  }
  return v1;
}

uint64_t __CFPrecomposeCyrillicCharacter(unsigned __int16 *a1)
{
  unsigned int v1 = a1[1] | (*a1 << 16);
  if (v1 - 82379529 < 0xFB54002F) {
    return 65533;
  }
  uint64_t v2 = (unsigned int *)&__CFCyrillicPrecompMap;
  char v3 = (unsigned int *)&unk_182EDE550;
  while (1)
  {
    uint64_t v4 = ((char *)v3 - (char *)v2) >> 4;
    uint64_t v5 = &v2[2 * v4];
    if (*v5 <= v1) {
      break;
    }
    char v3 = v5 - 2;
LABEL_7:
    if (v2 > v3) {
      return 65533;
    }
  }
  if (*v5 < v1)
  {
    uint64_t v2 = v5 + 2;
    goto LABEL_7;
  }
  return LOWORD(v2[2 * v4 + 1]);
}

uint64_t __CFToWinCyrillic(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 < 0x80)
  {
LABEL_4:
    *a3 = a2;
    return 1;
  }
  else
  {
    if ((unsigned __int16)(a2 - 1040) <= 0x3Fu)
    {
      LOBYTE(a2) = a2 - 80;
      goto LABEL_4;
    }
    if ((unsigned __int16)(a2 - 8483) >= 0xDF7Du)
    {
      uint64_t v4 = (unsigned __int16 *)&cp1251_from_uni;
      uint64_t v5 = (unsigned __int16 *)&unk_182EDE650;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_4;
          }
          uint64_t v4 = v7 + 2;
        }
        else
        {
          uint64_t v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
}

BOOL __CFFromWinCyrillic(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    if (a2 < 0xC0) {
      a2 = cp1251_to_uni[a2 - 128];
    }
    else {
      a2 += 848;
    }
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinCyrillicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  char v12 = 0;
  uint64_t v9 = __CFPrecomposeCyrillicCharacter(a2);
  int v10 = __CFToWinCyrillic(v9, v9, &v12);
  uint64_t result = 0;
  if (v10 && v12)
  {
    if (a5) {
      *a4 = v12;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToISOCyrillic(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 < 0xA1) {
    goto LABEL_12;
  }
  switch(a2)
  {
    case 0xA7u:
      LOBYTE(a2) = -3;
      goto LABEL_12;
    case 0x2116u:
      LOBYTE(a2) = -16;
      goto LABEL_12;
    case 0xADu:
LABEL_12:
      *a3 = a2;
      return 1;
  }
  if (a2 - 1025 > 0x5E) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 != 1037 && a2 != 1104 && a2 != 1117)
  {
    LOBYTE(a2) = a2 - 96;
    goto LABEL_12;
  }
  return result;
}

uint64_t __CFFromISOCyrillic(uint64_t a1, unsigned int a2, __int16 *a3)
{
  __int16 v3 = a2 + 864;
  if (a2 == 253) {
    __int16 v3 = 167;
  }
  if (a2 == 240) {
    __int16 v4 = 8470;
  }
  else {
    __int16 v4 = v3;
  }
  if (a2 == 173) {
    __int16 v4 = 173;
  }
  if (a2 < 0xA1) {
    __int16 v4 = a2;
  }
  *a3 = v4;
  return 1;
}

uint64_t __CFToISOCyrillicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  char v12 = 0;
  uint64_t v9 = __CFPrecomposeCyrillicCharacter(a2);
  int v10 = __CFToISOCyrillic(v9, v9, &v12);
  uint64_t result = 0;
  if (v10 && v12)
  {
    if (a5) {
      *a4 = v12;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToKOI8R(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&koi8r_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182EDE8D0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromKOI8R(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = koi8r_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToDOSRussian(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&DOSRussian_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182EDEBD0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSRussian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSRussian_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSRussianPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFPrecomposeCyrillicCharacter(a2);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSRussian_from_uni;
      char v12 = (unsigned __int16 *)&unk_182EDEBD0;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        long long v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          char v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

void sub_182D22F84(_Unwind_Exception *exception_object)
{
}

void sub_182D25B74(_Unwind_Exception *a1)
{
  free(v2);
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D26508(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D2675C(_Unwind_Exception *exception_object)
{
}

void OUTLINED_FUNCTION_0_20(objc_class *a1)
{
  __CFRequireConcreteImplementation(a1, v2, v1);
}

objc_class *_CFStringCreateWithWidthContexts(uint64_t a1)
{
  uint64_t result = (objc_class *)__NSVariableWidthStringClass;
  if (__NSVariableWidthStringClass
    || (uint64_t result = __CFLookUpClass("__NSVariableWidthString"), (__NSVariableWidthStringClass = (uint64_t)result) != 0))
  {
    id v3 = [result alloc];
    return (objc_class *)[v3 initWithWidthContexts:a1];
  }
  return result;
}

__CFString *_CFStringFindAffixRuleFormat(const void *a1, CFStringRef theString)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (CFStringGetLength(theString) < 2) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(theString);
  unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, Length - 1);
  if (CFEqual(a1, @"fi"))
  {
    CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(0, @"aeiouyåäö");
    CFCharacterSetRef v8 = CFCharacterSetCreateWithCharactersInString(0, @"bcdfghjklmnpqrstvwxzšž");
    if (CFCharacterSetIsCharacterMember(v7, CharacterAtIndex))
    {
      __int16 v4 = @"vowel";
LABEL_16:
      CFRelease(v7);
      CFRelease(v8);
      return v4;
    }
    int IsCharacterMember = CFCharacterSetIsCharacterMember(v8, CharacterAtIndex);
    int v10 = @"consonant";
    uint64_t v11 = @"other";
    goto LABEL_13;
  }
  if (CFEqual(a1, @"ru"))
  {
    CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(0, @"ое");
    CFCharacterSetRef v8 = CFCharacterSetCreateWithCharactersInString(0, @"аяую");
    __int16 v4 = @"other";
    if ((unsigned __int16)((unsigned __int16)(CharacterAtIndex - 1104) >> 6) < 0x3FFu
      || CharacterAtIndex == 1068
      || CharacterAtIndex == 1100)
    {
      goto LABEL_16;
    }
    if (CFCharacterSetIsCharacterMember(v7, CharacterAtIndex))
    {
      __int16 v4 = @"neuter";
      goto LABEL_16;
    }
    int IsCharacterMember = CFCharacterSetIsCharacterMember(v8, CharacterAtIndex);
    int v10 = @"feminine";
    uint64_t v11 = @"masculine";
LABEL_13:
    if (IsCharacterMember) {
      __int16 v4 = v10;
    }
    else {
      __int16 v4 = v11;
    }
    goto LABEL_16;
  }
  if (!CFEqual(a1, @"ko")) {
    return 0;
  }
  uint64_t v13 = CFUniCharDecomposeCharacter(CharacterAtIndex, v17, 10);
  if (v13 < 1)
  {
    unsigned int v15 = 0;
  }
  else
  {
    int v14 = LOWORD(v17[v13 - 1]);
    if ((v14 - 4449) >= 0x47)
    {
      BOOL v16 = (v14 - 4520) >= 0x58 && (v14 - 4352) >= 0x5F;
      unsigned int v15 = @"consonant";
      if (v16) {
        unsigned int v15 = 0;
      }
    }
    else
    {
      unsigned int v15 = @"vowel";
    }
  }
  if (v15) {
    return v15;
  }
  else {
    return @"other";
  }
}

uint64_t _CFStringCreateWithMarkdownAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (__NSGetCFLocalizedAttributedStringClass_onceToken != -1) {
    dispatch_once(&__NSGetCFLocalizedAttributedStringClass_onceToken, &__block_literal_global_140);
  }
  CFCharacterSetRef v8 = (void *)__NSCFLocalizedAttributedStringClass;

  return [v8 copyStringWithMarkdown:a1 formatConfiguration:a2 bundle:a3 tableURL:a4];
}

uint64_t _CFStringCreateFormatWithInflectionAndArguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [(id)__NSCFLocalizedAttributedStringClass createStringRequiringInflectionWithFormat:a3 formatOptions:a2 arguments:a4];
}

xpc_object_t _CFXPCCreateXPCObjectFromOutOfRangeCFTimeInterval(double a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  xpc_object_t v1 = xpc_double_create(a1);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  memset(uu, 0, sizeof(uu));
  if (uuid_parse("C119A421-DF31-48EF-843D-21B4030D1621", uu) || (xpc_object_t v6 = xpc_uuid_create(uu)) == 0)
  {
    id v3 = v2;
LABEL_4:
    xpc_release(v3);
    return 0;
  }
  CFCharacterSetRef v7 = v6;
  keys[0] = "com.apple.CFDate.magic";
  keys[1] = "com.apple.CFDate.ti";
  values[0] = v6;
  values[1] = v2;
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)keys, values, 2uLL);
  xpc_release(v2);
  xpc_release(v7);
  if (v4 && xpc_dictionary_get_count(v4) != 2)
  {
    id v3 = v4;
    goto LABEL_4;
  }
  return v4;
}

CFTypeID CFFileSecurityGetTypeID(void)
{
  return 64;
}

CFFileSecurityRef CFFileSecurityCreate(CFAllocatorRef allocator)
{
  CFFileSecurityRef result = filesec_init();
  if (result)
  {
    uint64_t v2 = result;
    CFFileSecurityRef result = [[NSFileSecurity alloc] initWithFileSec:result];
    if (!result)
    {
      filesec_free(v2);
      return 0;
    }
  }
  return result;
}

Boolean CFFileSecurityCopyOwnerUUID(CFFileSecurityRef fileSec, CFUUIDRef *ownerUUID)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  *(void *)&v7.byte0 = 0;
  *(void *)&v7.byte8 = 0;
  LODWORD(v4) = [(__CFFileSecurity *)fileSec getOwnerUUID:&v7];
  if (v4)
  {
    CFAllocatorRef v5 = CFGetAllocator(fileSec);
    CFUUIDRef v4 = CFUUIDCreateFromUUIDBytes(v5, v7);
    if (v4)
    {
      *ownerUUID = v4;
      LOBYTE(v4) = 1;
    }
  }
  return v4;
}

Boolean CFFileSecuritySetOwnerUUID(CFFileSecurityRef fileSec, CFUUIDRef ownerUUID)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  CFUUIDBytes v4 = CFUUIDGetUUIDBytes(ownerUUID);
  return [(__CFFileSecurity *)fileSec setOwnerUUID:&v4];
}

Boolean CFFileSecurityCopyGroupUUID(CFFileSecurityRef fileSec, CFUUIDRef *groupUUID)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  *(void *)&v7.byte0 = 0;
  *(void *)&v7.byte8 = 0;
  LODWORD(v4) = [(__CFFileSecurity *)fileSec getGroupUUID:&v7];
  if (v4)
  {
    CFAllocatorRef v5 = CFGetAllocator(fileSec);
    CFUUIDRef v4 = CFUUIDCreateFromUUIDBytes(v5, v7);
    if (v4)
    {
      *groupUUID = v4;
      LOBYTE(v4) = 1;
    }
  }
  return v4;
}

Boolean CFFileSecuritySetGroupUUID(CFFileSecurityRef fileSec, CFUUIDRef groupUUID)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  CFUUIDBytes v4 = CFUUIDGetUUIDBytes(groupUUID);
  return [(__CFFileSecurity *)fileSec setGroupUUID:&v4];
}

Boolean CFFileSecurityCopyAccessControlList(CFFileSecurityRef fileSec, acl_t *accessControlList)
{
  return [(__CFFileSecurity *)fileSec copyAccessControlList:accessControlList];
}

Boolean CFFileSecuritySetAccessControlList(CFFileSecurityRef fileSec, acl_t accessControlList)
{
  return [(__CFFileSecurity *)fileSec setAccessControlList:accessControlList];
}

Boolean CFFileSecuritySetOwner(CFFileSecurityRef fileSec, uid_t owner)
{
  return [(__CFFileSecurity *)fileSec setOwner:*(void *)&owner];
}

Boolean CFFileSecuritySetGroup(CFFileSecurityRef fileSec, gid_t group)
{
  return [(__CFFileSecurity *)fileSec setGroup:*(void *)&group];
}

Boolean CFFileSecuritySetMode(CFFileSecurityRef fileSec, mode_t mode)
{
  return [(__CFFileSecurity *)fileSec setMode:mode];
}

Boolean CFFileSecurityClearProperties(CFFileSecurityRef fileSec, CFFileSecurityClearOptions clearPropertyMask)
{
  return [(__CFFileSecurity *)fileSec clearProperties:clearPropertyMask];
}

uint64_t CFBurstTrieInsert(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5)
{
  return CFBurstTrieAddWithWeight(a1, a2, a3, a4, 1, a5);
}

uint64_t CFBurstTrieAddWithWeight(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5, int a6)
{
  uint64_t v6 = 0;
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (a6 && !*(void *)(a1 + 2056) && a4 <= 1023)
  {
    CFIndex usedBufLen = 0;
    if (a4 < 86)
    {
      CFIndex v13 = 342;
      int v14 = v18;
    }
    else
    {
      CFIndex v13 = 4 * a4;
      int v14 = (UInt8 *)malloc_type_malloc((4 * a4) | 1, 0xCB444817uLL);
    }
    v20.CFIndex location = a3;
    v20.CFIndex length = a4;
    CFStringGetBytes(a2, v20, 0x8000100u, 0x2Du, 0, v14, v13, &usedBufLen);
    CFIndex v15 = usedBufLen;
    v14[usedBufLen] = 0;
    uint64_t v6 = CFBurstTrieAddUTF8StringWithWeight(a1, (uint64_t)v14, v15, a5, a6);
    if (v18 != v14) {
      free(v14);
    }
  }
  return v6;
}

uint64_t CFBurstTrieAdd(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5)
{
  return CFBurstTrieAddWithWeight(a1, a2, a3, a4, 1, a5);
}

uint64_t CFBurstTrieInsertCharacters(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddCharactersWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieAddCharactersWithWeight(unint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5 = 0;
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (a5 && a3 <= 1023 && !*(void *)(a1 + 2056))
  {
    uint64_t v11 = v14;
    if (a3 >= 86) {
      uint64_t v11 = malloc_type_malloc((4 * a3) | 1, 0xD5BE4744uLL);
    }
    uint64_t v12 = burstTrieConvertCharactersToUTF8(a2, a3, (uint64_t)v11);
    v11[v12] = 0;
    uint64_t v5 = CFBurstTrieAddUTF8StringWithWeight(a1, (uint64_t)v11, v12, a4, a5);
    if (v14 != v11) {
      free(v11);
    }
  }
  return v5;
}

uint64_t CFBurstTrieAddCharacters(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddCharactersWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieInsertUTF8String(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddUTF8StringWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieFind(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, void *a5)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  unsigned int v7 = 0;
  uint64_t result = CFBurstTrieContains(a1, a2, a3, a4, &v7);
  if (result)
  {
    if (a5) {
      *a5 = v7;
    }
    return 1;
  }
  return result;
}

uint64_t CFBurstTrieFindCharacters(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  unsigned int v6 = 0;
  uint64_t result = CFBurstTrieContainsCharacters(a1, a2, a3, &v6);
  if (result)
  {
    if (a4) {
      *a4 = v6;
    }
    return 1;
  }
  return result;
}

uint64_t CFBurstTrieFindUTF8String(uint64_t a1, unsigned __int8 *a2, uint64_t a3, void *a4)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  unsigned int v6 = 0;
  uint64_t result = CFBurstTrieContainsUTF8String(a1, a2, a3, &v6);
  if (result)
  {
    if (a4) {
      *a4 = v6;
    }
    return 1;
  }
  return result;
}

uint64_t burstTrieMappedFind(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, char a6)
{
  if (a4)
  {
    int v6 = 1 - a4;
    uint64_t v7 = (char *)(a3 + 1);
    while (1)
    {
      int v8 = *(_DWORD *)(a1 + 4 * *(v7 - 1));
      int v9 = v8 & 3;
      if (v9 != 1) {
        break;
      }
      a1 = (v8 & 0xFFFFFFFC) + a2;
      ++v6;
      ++v7;
      if (v6 == 1) {
        goto LABEL_5;
      }
    }
    if (v9 != 2)
    {
      if (v9 == 3) {
        return burstTrieCompactTrieMappedFind((int8x8_t *)((v8 & 0xFFFFFFFC) + a2), a2, v7, -v6, a5, a6);
      }
      return 0;
    }
    return burstTrieMappedPageFind((unsigned int *)((v8 & 0xFFFFFFFC) + a2), v7, -v6, a5, a6);
  }
  else
  {
LABEL_5:
    if (!*(_DWORD *)(a1 + 1024)) {
      return 0;
    }
    if (a5) {
      *a5 = *(_DWORD *)(a1 + 1028);
    }
    return 1;
  }
}

uint64_t CFBurstTrieSerialize(uint64_t a1, CFStringRef theString, int a3)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  if (*(void *)(a1 + 2056)) {
    return 0;
  }
  if (!CFStringGetCString(theString, buffer, 1024, 0x8000100u)) {
    return 0;
  }
  uint64_t v7 = open(buffer, 1538, 384);
  if ((v7 & 0x80000000) != 0) {
    return 0;
  }
  int v8 = v7;
  uint64_t v3 = CFBurstTrieSerializeWithFileDescriptor(a1, v7, a3);
  close(v8);
  return v3;
}

uint64_t CFBurstTrieSerializeWithFileDescriptor(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  if ((a2 & 0x80000000) == 0 && !*(void *)(a1 + 2056))
  {
    off_t v7 = lseek(a2, 0, 2);
    *(_DWORD *)(a1 + 2072) = a3;
    uint64_t v23 = 0;
    long long v22 = 0u;
    long long v21 = 0u;
    long long v20 = 0u;
    long long v19 = 0u;
    long long v18 = 0u;
    long long v17 = 0u;
    long long v16 = 0u;
    uint64_t __buf = 14531089;
    int v12 = *(_DWORD *)(a1 + 2076);
    int v13 = 0;
    int v14 = a3;
    uint64_t v15 = 0;
    lseek(a2, v7, 0);
    write(a2, &__buf, 0x94uLL);
    serializeCFBurstTrieLists(a1, a1, v7, a2);
    uint64_t v3 = 1;
    int v10 = lseek(a2, 0, 1) - v7;
    pwrite(a2, &v10, 4uLL, v7 + 4);
    serializeCFBurstTrieLevels(a1, (_DWORD *)a1, &v10, v7, 0, 1, a2);
    pwrite(a2, &v10, 4uLL, v7 + 12);
    int v8 = lseek(a2, 0, 2);
    *(_DWORD *)(a1 + 2064) = v8 - v7;
    *(void *)(a1 + 2056) = mmap(0, (v8 - v7), 1, 1, a2, v7);
  }
  return v3;
}

uint64_t CFBurstTrieTraverse(uint64_t result)
{
  xpc_object_t v1 = *(int **)(result + 2056);
  if (!v1) {
    return traverseCFBurstTrieWithCursor(result, (uint64_t)"");
  }
  int v2 = *v1;
  if (v2 == 14531089 || v2 == -889275714) {
    return traverseCFBurstTrieWithCursor(result, (uint64_t)"");
  }
  return result;
}

uint64_t foundKey(void *a1)
{
  if (a1)
  {
    if (*a1)
    {
      xpc_object_t v1 = (void (*)(void))a1[1];
      if (v1) {
        v1();
      }
    }
  }
  return 0;
}

size_t CFBurstTrieTraverseWithCursor(uint64_t a1, uint64_t a2)
{
  return traverseCFBurstTrieWithCursor(a1, a2);
}

uint64_t CFBurstTrieGetCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 2076);
}

char *CFBurstTrieCursorCreateByCopy(char *result)
{
  if (result)
  {
    xpc_object_t v1 = result;
    uint64_t result = (char *)malloc_type_calloc(0x21uLL, 1uLL, 0xDCBD4FD0uLL);
    uint64_t v2 = *(void *)(v1 + 17);
    if (v2 == 1)
    {
      result[16] = v1[16];
      *(_OWORD *)uint64_t result = *(_OWORD *)v1;
    }
    else if (!v2)
    {
      CFBurstTrieCursorCreateByCopy_cold_1();
    }
    *(void *)(result + 17) = v2;
    *(void *)(result + 25) = *(void *)(v1 + 25);
  }
  return result;
}

BOOL CFBurstTrieCursorIsEqual(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 25) == *(void *)(a2 + 25)
    && (*(void *)(a1 + 17) == 1 ? (BOOL v2 = *(void *)(a2 + 17) == 1) : (BOOL v2 = 0),
        v2
     && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
     && *(unsigned __int8 *)(a1 + 16) == *(unsigned __int8 *)(a2 + 16)
     && *(_DWORD *)a1 == *(_DWORD *)a2))
  {
    return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
  }
  else
  {
    return 0;
  }
}

void CFBurstTrieTraverseFromCursor(long long *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *))
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    int v6 = malloc_type_calloc(1uLL, 0x1000uLL, 0x48558A54uLL);
    char v9 = 0;
    if (*(void *)((char *)a1 + 17) == 1)
    {
      char v8 = *((unsigned char *)a1 + 16);
      long long v7 = *a1;
      traverseFromMapCursor(*(void *)((char *)a1 + 25), (uint64_t)&v7, (uint64_t)v6, 0x1000u, 0, &v9, a2, a3);
    }
    free(v6);
  }
}

uint64_t traverseFromMapCursor(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned char *a6, uint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *))
{
  int v8 = *(_DWORD *)a2;
  unsigned int v9 = a5;
  uint64_t v13 = result;
  switch(*(_DWORD *)a2 & 3)
  {
    case 1:
      goto LABEL_3;
    case 2:
      int v14 = (_DWORD *)(*(void *)(result + 2056) + (v8 & 0xFFFFFFFC));
      int v15 = *(_DWORD *)(result + 2072);
      unsigned int v61 = v14;
      if ((v15 & 8) != 0)
      {
        int v23 = *v14;
        uint64_t v24 = *(unsigned int *)(a2 + 4);
        if (*(unsigned char *)(a2 + 16))
        {
          uint64_t v25 = (unsigned __int8 *)v14 + v24 + 4;
          int v26 = *(unsigned __int16 *)((char *)v14 + v24 + 5);
          uint64_t v27 = *(unsigned int *)(a2 + 8);
          size_t v28 = (v26 - v27);
          if (v26 - (int)v27 >= 0 && v28 <= a4)
          {
            memcpy((void *)(a3 + a5), &v25[v27 + 7], v28);
            uint64_t result = a8(a7, a3, v28 + v9, *(unsigned int *)(v25 + 3), a6);
            int v14 = v61;
            if (*a6) {
              return result;
            }
            LODWORD(v27) = *(_DWORD *)(a2 + 8);
            int v26 = *(unsigned __int16 *)(v25 + 1);
          }
          unsigned int v29 = v27 + *v25;
          LODWORD(v24) = v24 + v26 + 7;
        }
        else
        {
          unsigned int v29 = 0;
        }
        unsigned int v39 = v23 - 4;
        if (v24 < v39)
        {
          CFRange v40 = 0;
          while (1)
          {
            uint64_t v41 = (char *)v14 + v24;
            unsigned int v44 = v41[4];
            uint64_t v43 = (unsigned __int8 *)(v41 + 4);
            unsigned int v42 = v44;
            if (v29 > v44) {
              return result;
            }
            size_t v45 = *(unsigned __int16 *)(v43 + 1);
            if (*(_DWORD *)(v43 + 3)) {
              BOOL v46 = v45 > a4;
            }
            else {
              BOOL v46 = 1;
            }
            if (!v46)
            {
              if (v40)
              {
                unsigned int v47 = *v40 - v42 + *(unsigned __int16 *)(v40 + 1);
                if (v47 > v9) {
                  unsigned int v47 = 0;
                }
                v9 -= v47;
              }
              memcpy((void *)(a3 + v9), v43 + 7, v45);
              uint64_t result = a8(a7, a3, v9 + *(unsigned __int16 *)(v43 + 1), *(unsigned int *)(v43 + 3), a6);
              int v14 = v61;
              if (*a6) {
                return result;
              }
              LODWORD(v45) = *(unsigned __int16 *)(v43 + 1);
              v9 += v45;
            }
            LODWORD(v24) = v24 + v45 + 7;
            CFRange v40 = v43;
            if (v24 >= v39) {
              return result;
            }
          }
        }
      }
      else
      {
        if ((v15 & 0x10) == 0) {
          return result;
        }
        int v16 = *v14;
        uint64_t v17 = *(unsigned int *)(a2 + 4);
        if (*(unsigned char *)(a2 + 16))
        {
          long long v19 = (unsigned __int16 *)((char *)v14 + v17 + 4);
          int v18 = *v19;
          size_t __n = *(unsigned int *)(a2 + 8);
          size_t v20 = (v18 - __n);
          if (v18 - (int)__n >= 0 && v20 <= a4)
          {
            memcpy((void *)(a3 + a5), (char *)v19 + __n + 6, v20);
            uint64_t result = a8(a7, a3, v20 + v9, *(unsigned int *)(v19 + 1), a6);
            int v14 = v61;
            if (*a6) {
              return result;
            }
            LODWORD(__n) = *(_DWORD *)(a2 + 8);
            int v18 = *v19;
          }
          __s2 = v19 + 3;
          LODWORD(v17) = v17 + v18 + 6;
        }
        else
        {
          __s2 = 0;
          LODWORD(__n) = 0;
        }
        unsigned int v48 = v16 - 4;
        if (v17 < v48)
        {
          int v49 = v9 - __n;
          __dst = (void *)(a3 + v9);
          while (1)
          {
            int v50 = (char *)v14 + v17;
            unsigned int v53 = *((unsigned __int16 *)v50 + 2);
            int v51 = (unsigned __int16 *)(v50 + 4);
            unsigned int v52 = v53;
            size_t v54 = v53 - __n;
            if (v53 < __n) {
              return result;
            }
            uint64_t result = memcmp(v51 + 3, __s2, __n);
            int v14 = v61;
            if ((int)result > 0) {
              return result;
            }
            uint64_t v55 = *(unsigned int *)(v51 + 1);
            if (v52 <= a4 && v55 != 0)
            {
              if (v52)
              {
                memcpy(__dst, (char *)v51 + __n + 6, v54);
                int v57 = *v51;
                uint64_t v55 = *(unsigned int *)(v51 + 1);
              }
              else
              {
                int v57 = 0;
              }
              uint64_t result = a8(a7, a3, (v49 + v57), v55, a6);
              int v14 = v61;
              if (*a6) {
                return result;
              }
              unsigned int v52 = *v51;
            }
            LODWORD(v17) = v17 + v52 + 6;
            if (v17 >= v48) {
              return result;
            }
          }
        }
      }
      return result;
    case 3:
      long long v21 = (int8x8_t *)(*(void *)(result + 2056) + (v8 & 0xFFFFFFFC));
      uint64_t v22 = v21[4].u32[0];
      if (v22)
      {
        uint64_t result = a8(a7, a3, a5, v22, a6);
        if (v9 >= a4 || *a6) {
          return result;
        }
      }
      else if (a5 >= a4)
      {
        return result;
      }
      unint64_t v30 = 0;
      uint64_t v31 = a4 - 1;
      break;
    default:
      if (v8 == *(_DWORD *)(*(void *)(result + 2056) + 4))
      {
LABEL_3:
        return traverseFromMapCursorMappedLevel(result, a2, a3, a4, a5, a6, a7, (uint64_t (*)(void, void, void, void, void))a8);
      }
      return result;
  }
  while (1)
  {
    *(unsigned char *)(a3 + v9) = v30;
    uint64_t v32 = v30 >> 6 <= 1 ? 1 : v30 >> 6;
    int8x8_t v33 = v21[v30 >> 6];
    if ((*(void *)&v33 & (1 << v30)) != 0) {
      break;
    }
    if (v30 > 0xFE) {
      return result;
    }
LABEL_38:
    ++v30;
  }
  if (v30 >= 0x40)
  {
    int v34 = 0;
    uint64_t v35 = v21;
    do
    {
      int8x8_t v36 = *v35++;
      uint8x8_t v37 = (uint8x8_t)vcnt_s8(v36);
      v37.i16[0] = vaddlv_u8(v37);
      v34 += v37.i32[0];
      --v32;
    }
    while (v32);
  }
  else
  {
    int v34 = 0;
  }
  uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v33 & ((1 << v30) - 1)));
  v38.i16[0] = vaddlv_u8(v38);
  *(_DWORD *)a2 = v21[4].i32[v34 + v38.i32[0] + 1];
  *(void *)(a2 + 4) = 0;
  *(void *)(a2 + 9) = 0;
  uint64_t result = traverseFromMapCursor(v13, a2, a3, v31, v9 + 1, a6, a7, a8);
  if (!*a6 && v30 < 0xFF) {
    goto LABEL_38;
  }
  return result;
}

uint64_t traverseCFBurstTrieMappedLevel(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v11 = result;
  uint64_t v12 = 0;
  uint64_t v13 = a3[6];
  int v14 = (char *)a3 + v13 + 36;
  *int v14 = 0;
  uint64_t v15 = (v13 + 1);
  uint64_t v22 = (char *)a3 + v15 + 36;
  int v23 = a3 + 9;
  while (1)
  {
    int v16 = *(_DWORD *)(a2 + 4 * v12);
    a3[6] = v15;
    *int v14 = v12;
    int v17 = v16 & 3;
    if (v17 == 3) {
      break;
    }
    if (v17 == 2)
    {
      a3[4] = v16;
      *uint64_t v22 = 0;
      uint64_t result = findCFBurstTrieMappedPage(v11, (uint64_t)a3, a5, a6);
    }
    else if (v17 == 1)
    {
      uint64_t v18 = *(void *)(v11 + 2056) + (v16 & 0xFFFFFFFC);
      int v19 = v15;
      if (*(_DWORD *)(v18 + 1024))
      {
        uint64_t result = a6(a5, (uint64_t)v23);
        if (result) {
          return result;
        }
        int v19 = a3[6];
      }
      if (v19 == a3[5] && (a4 & 1) != 0) {
        return result;
      }
      uint64_t result = traverseCFBurstTrieMappedLevel(v11, v18, a3, a4, a5, a6);
    }
LABEL_18:
    if (++v12 == 256) {
      return result;
    }
  }
  uint64_t v20 = *(void *)(v11 + 2056) + (v16 & 0xFFFFFFFC);
  int v21 = v15;
  if (*(_DWORD *)(v20 + 32))
  {
    uint64_t result = a6(a5, (uint64_t)v23);
    if (result) {
      return result;
    }
    int v21 = a3[6];
  }
  if (v21 != a3[5] || (a4 & 1) == 0)
  {
    uint64_t result = traverseCFBurstTrieCompactMappedLevel(v11, v20, a3, a4, a5, a6);
    goto LABEL_18;
  }
  return result;
}

uint64_t traverseCFBurstTrieCompactMappedLevel(uint64_t result, int8x8_t *a2, _DWORD *a3, unsigned int a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v10 = result;
  unint64_t v11 = 0;
  uint64_t v12 = a3[6];
  uint64_t v13 = (char *)a3 + v12 + 36;
  *uint64_t v13 = 0;
  uint64_t v14 = (v12 + 1);
  int v26 = a3 + 9;
  uint64_t v27 = (char *)a3 + v14 + 36;
  while (1)
  {
    if (v11 >> 6 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v11 >> 6;
    }
    int8x8_t v16 = a2[v11 >> 6];
    a3[6] = v12;
    if ((*(void *)&v16 & (1 << v11)) == 0) {
      goto LABEL_21;
    }
    if (v11 >= 0x40)
    {
      int v17 = 0;
      uint64_t v18 = a2;
      do
      {
        int8x8_t v19 = *v18++;
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(v19);
        v20.i16[0] = vaddlv_u8(v20);
        v17 += v20.i32[0];
        --v15;
      }
      while (v15);
    }
    else
    {
      int v17 = 0;
    }
    uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v16 & ((1 << v11) - 1)));
    v21.i16[0] = vaddlv_u8(v21);
    __int32 v22 = a2[4].i32[v17 + v21.i32[0] + 1];
    a3[6] = v14;
    *uint64_t v13 = v11;
    int v23 = v22 & 3;
    if (v23 == 1)
    {
      uint64_t result = traverseCFBurstTrieMappedLevel(v10, *(void *)(v10 + 2056) + (v22 & 0xFFFFFFFC), a3, a4, a5, a6);
      goto LABEL_21;
    }
    if (v23 == 2)
    {
      a3[4] = v22;
      unsigned char *v27 = 0;
      uint64_t result = findCFBurstTrieMappedPage(v10, (uint64_t)a3, a5, a6);
      goto LABEL_21;
    }
    if (v23 == 3) {
      break;
    }
LABEL_21:
    if (++v11 == 256) {
      return result;
    }
  }
  uint64_t v24 = *(void *)(v10 + 2056) + (v22 & 0xFFFFFFFC);
  int v25 = v12 + 1;
  if (*(_DWORD *)(v24 + 32))
  {
    uint64_t result = a6(a5, (uint64_t)v26);
    if (result) {
      return result;
    }
    int v25 = a3[6];
  }
  if (v25 != a3[5] || (a4 & 1) == 0)
  {
    uint64_t result = traverseCFBurstTrieCompactMappedLevel(v10, v24, a3, a4, a5, a6);
    goto LABEL_21;
  }
  return result;
}

uint64_t traverseCFBurstTrieLevel(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9 = result;
  uint64_t v10 = 0;
  uint64_t v11 = *(unsigned int *)(a2 + 24);
  uint64_t v12 = (unsigned char *)(a2 + 40 + v11);
  *uint64_t v12 = 0;
  uint64_t v13 = (v11 + 1);
  uint64_t v19 = a2 + 40;
  uint64_t v14 = (unsigned char *)(a2 + 40 + v13);
  while (1)
  {
    uint64_t v15 = *(void *)(v9 + 8 * v10);
    *(_DWORD *)(a2 + 24) = v13;
    *uint64_t v12 = v10;
    if ((v15 & 3) == 2)
    {
      *(void *)(a2 + 16) = v15;
      *uint64_t v14 = 0;
      uint64_t result = findCFBurstTrieList(a2, a4, a5);
      goto LABEL_11;
    }
    if ((v15 & 3) == 1) {
      break;
    }
LABEL_11:
    if (++v10 == 256) {
      return result;
    }
  }
  unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFCLL;
  int v17 = *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFFCLL) + 2052);
  int v18 = v13;
  if (v17)
  {
    uint64_t result = a5(a4, v19);
    if (result) {
      return result;
    }
    int v18 = *(_DWORD *)(a2 + 24);
  }
  if (v18 != *(_DWORD *)(a2 + 28) || (a3 & 1) == 0)
  {
    uint64_t result = traverseCFBurstTrieLevel(v16, a2, a3, a4, a5);
    goto LABEL_11;
  }
  return result;
}

uint64_t traverseFromMapCursorMappedLevel(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned char *a6, uint64_t a7, uint64_t (*a8)(void, void, void, void, void))
{
  uint64_t v21 = (*(_DWORD *)a2 & 0xFFFFFFFC) + *(void *)(result + 2056);
  uint64_t v22 = result;
  uint64_t v12 = *(unsigned int *)(v21 + 1024);
  unsigned int v13 = a5;
  if (v12)
  {
    uint64_t v14 = a7;
    uint64_t v15 = a8;
    uint64_t result = a8(a7, a3, a5, v12, a6);
    if (v13 >= a4) {
      return result;
    }
    LODWORD(a5) = v13;
    unsigned int v16 = a4;
    if (*a6) {
      return result;
    }
  }
  else
  {
    uint64_t v14 = a7;
    uint64_t v15 = a8;
    unsigned int v16 = a4;
    if (a5 >= a4) {
      return result;
    }
  }
  uint64_t v17 = 0;
  uint64_t v18 = a5;
  do
  {
    *(unsigned char *)(a3 + v18) = v17;
    *(_DWORD *)a2 = *(_DWORD *)(v21 + 4 * v17);
    if (v17) {
      uint64_t v19 = v13 + 1;
    }
    else {
      uint64_t v19 = v13;
    }
    *(void *)(a2 + 4) = 0;
    *(void *)(a2 + 9) = 0;
    uint64_t result = traverseFromMapCursor(v22, a2, a3, v16 - (v17 != 0), v19, a6, v14, v15);
    if (*a6) {
      break;
    }
  }
  while (v17++ != 255);
  return result;
}

uint64_t burstTrieCompactTrieMappedFind(int8x8_t *a1, uint64_t a2, char *a3, int a4, _DWORD *a5, char a6)
{
  if (a4)
  {
    do
    {
      unint64_t v6 = *a3;
      uint64_t v7 = v6 >> 6;
      int8x8_t v8 = a1[v6 >> 6];
      uint64_t v9 = 1 << v6;
      if (((1 << v6) & *(void *)&v8) == 0) {
        return 0;
      }
      if (v6 >= 0x40)
      {
        int v10 = 0;
        if (v7 <= 1) {
          uint64_t v7 = 1;
        }
        else {
          uint64_t v7 = v7;
        }
        uint64_t v11 = a1;
        do
        {
          int8x8_t v12 = *v11++;
          uint8x8_t v13 = (uint8x8_t)vcnt_s8(v12);
          v13.i16[0] = vaddlv_u8(v13);
          v10 += v13.i32[0];
          --v7;
        }
        while (v7);
      }
      else
      {
        int v10 = 0;
      }
      uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)((v9 - 1) & *(void *)&v8));
      v14.i16[0] = vaddlv_u8(v14);
      __int32 v15 = a1[5].i32[v10 + v14.i32[0]];
      int v16 = v15 & 3;
      if (v16 != 3)
      {
        if (v16 == 1) {
          return burstTrieMappedFind((v15 & 0xFFFFFFFC) + a2, a2, a3 + 1, (a4 - 1));
        }
        if (v16 != 2) {
          return 0;
        }
        return burstTrieMappedPageFind((unsigned int *)((v15 & 0xFFFFFFFC) + a2), a3 + 1, (a4 - 1), a5, a6);
      }
      a1 = (int8x8_t *)((v15 & 0xFFFFFFFC) + a2);
      ++a3;
    }
    while (--a4);
  }
  if (!a1[4].i32[0]) {
    return 0;
  }
  if (a5) {
    *a5 = a1[4].i32[1];
  }
  return 1;
}

uint64_t burstTrieMappedPageFind(unsigned int *a1, char *__s2, size_t __n, _DWORD *a4, char a5)
{
  unsigned int v6 = __n;
  uint64_t v25 = *(void *)off_1ECE0A5B0;
  unsigned int v9 = *a1;
  if (a5)
  {
    if (v9)
    {
      unsigned int v10 = 0;
      while (1)
      {
        uint64_t v11 = (char *)a1 + v10;
        unsigned int v14 = v11[4];
        uint8x8_t v13 = v11 + 4;
        size_t v12 = v14;
        int v15 = (unsigned __int16)(*(_WORD *)(v13 + 1) + v14);
        if (v15 == v6 && !memcmp(v24, __s2, v12) && !memcmp(v13 + 7, &__s2[v12], v6 - v12)) {
          break;
        }
        if ((v12 ^ 0xFF) >= v6 - v12) {
          size_t v16 = v6 - v12;
        }
        else {
          size_t v16 = v12 ^ 0xFF;
        }
        memcpy(&v24[v12], v13 + 7, v16);
        unsigned int v10 = v10 - v12 + v15 + 7;
        if (v10 >= v9) {
          return 0;
        }
      }
      if (!a4) {
        return 1;
      }
      int v23 = *(_DWORD *)(v13 + 3);
LABEL_23:
      *a4 = v23;
      return 1;
    }
  }
  else if (v9)
  {
    unsigned int v17 = 0;
    while (1)
    {
      uint64_t v18 = (char *)a1 + v17;
      int v21 = *((unsigned __int16 *)v18 + 2);
      uint64_t v19 = v18 + 4;
      int v20 = v21;
      if (v21 == v6 && !memcmp(v19 + 6, __s2, v6)) {
        break;
      }
      v17 += v20 + 6;
      if (v17 >= v9) {
        return 0;
      }
    }
    if (!a4) {
      return 1;
    }
    int v23 = *(_DWORD *)(v19 + 2);
    goto LABEL_23;
  }
  return 0;
}

void serializeCFBurstTrieLists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v9 = *(void *)(a2 + 8 * i);
    if ((v9 & 3) == 2)
    {
      unsigned int v10 = (void *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
      int v11 = lseek(a4, 0, 1);
      serializeCFBurstTrieList(a1, (uint64_t)v10);
      do
      {
        size_t v12 = (void *)*v10;
        free(v10);
        unsigned int v10 = v12;
      }
      while (v12);
      *(void *)(a2 + 8 * i) = (v11 - a3) | 2;
    }
    else if ((v9 & 3) == 1)
    {
      serializeCFBurstTrieLists(a1, v9 & 0xFFFFFFFFFFFFFFFCLL, a3, a4);
    }
  }
}

uint64_t serializeCFBurstTrieLevels(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  uint64_t v13 = 0;
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  int32x4_t v14 = 0uLL;
  do
  {
    int32x4_t v14 = vsubq_s32(v14, (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&a2[v13]), (int32x4_t)vceqzq_s64(*(int64x2_t *)&a2[v13 + 4]))));
    v13 += 8;
  }
  while (v13 != 512);
  unsigned int v15 = vaddvq_s32(v14);
  uint64_t v16 = *a3;
  if ((*(unsigned char *)(a1 + 2072) & 4) == 0 || v15 > 0xC7) {
    a6 = 1;
  }
  unsigned int v38 = a6;
  uint64_t v39 = v16;
  if (a6)
  {
    uint64_t v19 = 0;
    memset(&v42[8], 0, 480);
    *a3 = v16 + 1028;
    memset(v42, 0, 32);
    do
    {
      uint64_t v20 = *(void *)&a2[2 * v19];
      if ((v20 & 3) == 1)
      {
        int v21 = *a3;
        if (serializeCFBurstTrieLevels(a1, v20 & 0xFFFFFFFFFFFFFFFCLL, a3, a4, 1, 0, a7)) {
          int v22 = v21 | 1;
        }
        else {
          int v22 = v21 | 3;
        }
        v42[v19] = v22;
      }
      else
      {
        v42[v19] = v20;
      }
      ++v19;
    }
    while (v19 != 256);
    v42[256] = a2[513];
    pwrite(a7, v42, 0x404uLL, v39 + a4);
    if (a5) {
LABEL_19:
    }
      free(a2);
  }
  else
  {
    uint64_t v40 = a4;
    unsigned int v41 = a7;
    int v36 = a5;
    uint64_t v37 = v15;
    size_t v24 = 4 * v15 + 36;
    MEMORY[0x1F4188790](a1, a2);
    int v26 = (int8x16_t *)((char *)&v34 - v25);
    bzero((char *)&v34 - v25, v24);
    bzero(v26, v24);
    int v27 = v16;
    uint64_t v28 = 0;
    int v29 = 0;
    size_t v35 = v24;
    *a3 = v27 + v24;
    do
    {
      uint64_t v30 = *(void *)&a2[2 * v28];
      if (v30)
      {
        v26->i64[v28 >> 6] |= 1 << v28;
        uint64_t v31 = &v26->i8[4 * v29];
        if ((v30 & 3) == 1)
        {
          int v32 = *a3;
          if (serializeCFBurstTrieLevels(a1, v30 & 0xFFFFFFFFFFFFFFFCLL, a3, v40, 1, 0, v41)) {
            int v33 = v32 | 1;
          }
          else {
            int v33 = v32 | 3;
          }
          *((_DWORD *)v31 + 9) = v33;
        }
        else
        {
          *((_DWORD *)v31 + 9) = v30;
        }
        ++v29;
      }
      ++v28;
    }
    while (v28 != 256);
    v26[2].i32[0] = a2[513];
    if (vaddvq_s32(vuzp1q_s32((int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v26)))), (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(v26[1])))))) != v37)serializeCFBurstTrieLevels_cold_1(); {
    pwrite(v41, v26, v35, v39 + v40);
    }
    if (v36) {
      goto LABEL_19;
    }
  }
  return v38;
}

void serializeCFBurstTrieList(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  int v4 = v3;
  unsigned int v6 = v5;
  uint64_t v7 = v2;
  uint64_t v27 = *(void *)off_1ECE0A5B0;
  unint64_t v8 = *(unsigned int *)(v2 + 2080);
  uint64_t v9 = malloc_type_malloc(8 * v8, 0x2004093837F09uLL);
  for (unsigned int i = 0; v6; ++i)
  {
    if (v8 <= i)
    {
      uint64_t v9 = (void *)__CFSafelyReallocateTyped(v9, 16 * v8, 0x2004093837F09, 0);
      v8 *= 2;
    }
    v9[i] = v6;
    unsigned int v6 = (void *)*v6;
  }
  if (v8 >= 0x10) {
    int v11 = malloc_type_malloc(1031 * v8 + 4, 0x1B8E6C21uLL);
  }
  else {
    int v11 = v26;
  }
  int v12 = *(_DWORD *)(v7 + 2072);
  if ((v12 & 8) != 0)
  {
    uint64_t v19 = i;
    qsort(v9, i, 8uLL, (int (__cdecl *)(const void *, const void *))nodeStringCompare);
    if (i)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      unsigned int i = 0;
      uint64_t v15 = 10;
      do
      {
        uint64_t v22 = v21;
        uint64_t v21 = v9[v20];
        unsigned __int16 v23 = 0;
        if (v22)
        {
          unsigned int v24 = *(unsigned __int16 *)(v21 + 16);
          while (v24 > v23
               && *(unsigned __int16 *)(v22 + 16) > v23
               && *(unsigned __int8 *)(v21 + v23 + 18) == *(unsigned __int8 *)(v22 + v23 + 18))
          {
            if (++v23 == 255)
            {
              unsigned __int16 v23 = 255;
              break;
            }
          }
        }
        else
        {
          LOWORD(v24) = *(_WORD *)(v21 + 16);
        }
        uint64_t v25 = (char *)v11 + i;
        *(_WORD *)(v25 + 5) = v24 - v23;
        *(_DWORD *)(v25 + 7) = *(_DWORD *)(v21 + 12);
        v25[4] = v23;
        memcpy(v25 + 11, (const void *)(v21 + v23 + 18), *(unsigned __int16 *)(v21 + 16) - (unint64_t)v23);
        unsigned int i = i - v23 + *(unsigned __int16 *)(v21 + 16) + 7;
        ++v20;
      }
      while (v20 != v19);
    }
    else
    {
      uint64_t v15 = 10;
    }
  }
  else
  {
    uint64_t v13 = i;
    if ((v12 & 0x10) != 0) {
      int32x4_t v14 = (int (__cdecl *)(const void *, const void *))nodeStringCompare;
    }
    else {
      int32x4_t v14 = (int (__cdecl *)(const void *, const void *))nodeWeightCompare;
    }
    qsort(v9, i, 8uLL, v14);
    if (i)
    {
      unsigned int i = 0;
      uint64_t v15 = 7;
      uint64_t v16 = v9;
      do
      {
        uint64_t v17 = *v16++;
        uint64_t v18 = (char *)v11 + i;
        *((_WORD *)v18 + 2) = *(_WORD *)(v17 + 16);
        *(_DWORD *)(v18 + 6) = *(_DWORD *)(v17 + 12);
        memcpy(v18 + 10, (const void *)(v17 + 18), *(unsigned __int16 *)(v17 + 16));
        i += *(unsigned __int16 *)(v17 + 16) + 6;
        --v13;
      }
      while (v13);
    }
    else
    {
      uint64_t v15 = 7;
    }
  }
  *int v11 = i;
  write(v4, v11, (v15 + i) & 0x1FFFFFFFCLL);
  free(v9);
  if (v11 != (_DWORD *)v26) {
    free(v11);
  }
}

uint64_t nodeStringCompare(void *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  int v4 = (const void *)(*a1 + 18);
  uint64_t v5 = (const void *)(*a2 + 18);
  unsigned int v6 = *(unsigned __int16 *)(v2 + 16);
  unsigned int v7 = *(unsigned __int16 *)(v3 + 16);
  unsigned int v8 = v6 - v7;
  if (v6 >= v7) {
    size_t v9 = v7;
  }
  else {
    size_t v9 = v6;
  }
  LODWORD(result) = memcmp(v4, v5, v9);
  if (result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t nodeWeightCompare(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(*(void *)a2 + 8) - *(_DWORD *)(*(void *)a1 + 8));
}

void _CFFileCoordinateReadingItemAtURL2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[5] = *(void *)off_1ECE0A5B0;
  unsigned int v8 = objc_lookUpClass("NSFileCoordinator");
  if (v8)
  {
    id v9 = objc_alloc_init(v8);
    v11[0] = off_1ECE0A5A0;
    v11[1] = 3221225472;
    v11[2] = ___CFFileCoordinateReadingItemAtURL2_block_invoke_2;
    v11[3] = &unk_1ECDFFE80;
    v11[4] = a4;
    objc_msgSend(v9, "__coordinateReadingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, v11);
  }
  else
  {
    CFErrorRef v10 = CFErrorCreate(0, @"NSCocoaErrorDomain", 3328, 0);
    (*(void (**)(uint64_t, void, CFErrorRef, void *))(a4 + 16))(a4, 0, v10, &__block_literal_global_40);
    CFRelease(v10);
  }
}

void _CFFileCoordinateWritingItemAtURL2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[5] = *(void *)off_1ECE0A5B0;
  unsigned int v8 = objc_lookUpClass("NSFileCoordinator");
  if (v8)
  {
    id v9 = objc_alloc_init(v8);
    v11[0] = off_1ECE0A5A0;
    v11[1] = 3221225472;
    v11[2] = ___CFFileCoordinateWritingItemAtURL2_block_invoke_2;
    v11[3] = &unk_1ECDFFE80;
    v11[4] = a4;
    objc_msgSend(v9, "__coordinateWritingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, v11);
  }
  else
  {
    CFErrorRef v10 = CFErrorCreate(0, @"NSCocoaErrorDomain", 3328, 0);
    (*(void (**)(uint64_t, void, CFErrorRef, void *))(a4 + 16))(a4, 0, v10, &__block_literal_global_4);
    CFRelease(v10);
  }
}

void _CFFileCoordinateReadingWritingItemsAtURLs2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v15[5] = *(void *)off_1ECE0A5B0;
  int v12 = objc_lookUpClass("NSFileCoordinator");
  if (v12)
  {
    id v13 = objc_alloc_init(v12);
    v15[0] = off_1ECE0A5A0;
    v15[1] = 3221225472;
    void v15[2] = ___CFFileCoordinateReadingWritingItemsAtURLs2_block_invoke_2;
    v15[3] = &unk_1ECDFFEA8;
    v15[4] = a6;
    objc_msgSend(v13, "__coordinateReadingItemAtURL:options:writingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, a4, a5, v15);
  }
  else
  {
    CFErrorRef v14 = CFErrorCreate(0, @"NSCocoaErrorDomain", 3328, 0);
    (*(void (**)(uint64_t, void, void, CFErrorRef, void *))(a6 + 16))(a6, 0, 0, v14, &__block_literal_global_6);
    CFRelease(v14);
  }
}

void _CFFileCoordinateWritingItemsAtURLs2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v15[5] = *(void *)off_1ECE0A5B0;
  int v12 = objc_lookUpClass("NSFileCoordinator");
  if (v12)
  {
    id v13 = objc_alloc_init(v12);
    v15[0] = off_1ECE0A5A0;
    v15[1] = 3221225472;
    void v15[2] = ___CFFileCoordinateWritingItemsAtURLs2_block_invoke_2;
    v15[3] = &unk_1ECDFFEA8;
    v15[4] = a6;
    objc_msgSend(v13, "__coordinateWritingItemAtURL:options:writingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, a4, a5, v15);
  }
  else
  {
    CFErrorRef v14 = CFErrorCreate(0, @"NSCocoaErrorDomain", 3328, 0);
    (*(void (**)(uint64_t, void, void, CFErrorRef, void *))(a6 + 16))(a6, 0, 0, v14, &__block_literal_global_9_0);
    CFRelease(v14);
  }
}

uint64_t _CFFileDidMove2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Class v6 = objc_lookUpClass("NSFileCoordinator");

  return [(objc_class *)v6 __itemAtURL:a1 didMoveToURL:a2 purposeID:a3];
}

uint64_t _CFFileDidDisconnect2(uint64_t a1, uint64_t a2)
{
  Class v4 = objc_lookUpClass("NSFileCoordinator");

  return [(objc_class *)v4 __itemAtURL:a1 didDisconnectWithPurposeID:a2];
}

uint64_t _CFFileDidReconnect2(uint64_t a1, uint64_t a2)
{
  Class v4 = objc_lookUpClass("NSFileCoordinator");

  return [(objc_class *)v4 __itemAtURL:a1 didReconnectWithPurposeID:a2];
}

uint64_t _CFFileDidGainVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Class v8 = objc_lookUpClass("NSFileCoordinator");

  return [(objc_class *)v8 __itemAtURL:a1 didGainVersionWithClientID:a2 name:a3 purposeID:a4];
}

uint64_t _CFFileDidLoseVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Class v8 = objc_lookUpClass("NSFileCoordinator");

  return [(objc_class *)v8 __itemAtURL:a1 didLoseVersionWithClientID:a2 name:a3 purposeID:a4];
}

uint64_t _CFFileDidResolveConflictVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Class v8 = objc_lookUpClass("NSFileCoordinator");

  return [(objc_class *)v8 __itemAtURL:a1 didResolveConflictVersionWithClientID:a2 name:a3 purposeID:a4];
}

void _CFFileCoordinateReadingItemAtURL(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void _CFFileCoordinateWritingItemAtURL(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void _CFFileCoordinateReadWriteItemsAtURLs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void _CFHyphenationSetLinguisticDataPath(const void *a1)
{
  if (_CFCustomHyphenationLinguisticDataPath) {
    CFRelease((CFTypeRef)_CFCustomHyphenationLinguisticDataPath);
  }
  _CFCustomHyphenationLinguisticDataPath = (uint64_t)a1;
}

uint64_t _CFHyphenationGetAllPossibleHyphenationLocations(const __CFString *a1, CFIndex a2, CFIndex a3, int a4, CFLocaleRef locale, uint64_t a6, uint64_t a7)
{
  return _CFHyphenationGetHyphenationLocations(a1, a2, a3, a4, 0, locale, a6, a7);
}

uint64_t _CFStringHyphenationCompileHyphenatorData(const char *a1)
{
  uint64_t v51 = *(void *)off_1ECE0A5B0;
  snprintf(__str, 0x400uLL, "%s%c%s", a1, 47, "patterns.txt");
  snprintf(v49, 0x400uLL, "%s%c%s", a1, 47, "exceptions.txt");
  snprintf(cStr, 0x400uLL, "%s%c%s", a1, 47, "hyphenation.dat");
  int v45 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int valuePtr = 64;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, @"ContainerSize", v3);
  Class v4 = CFBurstTrieCreateWithOptions(Mutable);
  CFRelease(Mutable);
  CFRelease(v3);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  Class v6 = __CFHyphenationMapFileContents(__str, &v45);
  if (v45)
  {
    if (v4) {
      CFBurstTrieRelease(v4);
    }
    uint64_t v7 = 1;
    fwrite("error: failed to map patterns file\n", 0x23uLL, 1uLL, *(FILE **)off_1ECE0A5B8);
    return v7;
  }
  uint64_t v43 = v6;
  CFStringRef v8 = CFStringCreateWithBytes(0, *(const UInt8 **)v6, *((void *)v6 + 1), 0x8000100u, 1u);
  CFIndex Length = CFStringGetLength(v8);
  CFErrorRef v10 = (UniChar *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
  v52.CFIndex location = 0;
  v52.CFIndex length = Length;
  CFStringGetCharacters(v8, v52, v10);
  CFStringRef cf = v8;
  CFIndex v11 = CFStringGetLength(v8);
  unsigned int v41 = v10;
  uint64_t v7 = 0;
  if (v11 >= 1)
  {
    unsigned int v12 = 0;
    int v13 = 0;
    CFErrorRef v14 = v10;
    uint64_t v15 = &v10[v11];
    do
    {
      unsigned int v16 = *v14;
      int IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, *v14);
      if (v16 != 46 && IsCharacterMember == 0)
      {
        if (v16 - 48 > 9)
        {
          unint64_t v19 = (0x100002400uLL >> v16) & 1;
          if (v16 > 0x20) {
            LODWORD(v19) = 0;
          }
          goto LABEL_19;
        }
        v13 |= v16 - 48;
      }
      else
      {
        if (v12 > 7)
        {
          LODWORD(v19) = 0;
LABEL_19:
          while (v14 < v15)
          {
            unsigned int v20 = *v14;
            BOOL v21 = v20 > 0x20;
            uint64_t v22 = (1 << v20) & 0x100002400;
            if (!v21 && v22 != 0) {
              break;
            }
            ++v14;
          }
          while (v14 < v15)
          {
            unsigned int v24 = *v14;
            BOOL v21 = v24 > 0x20;
            uint64_t v25 = (1 << v24) & 0x100002400;
            if (v21 || v25 == 0) {
              break;
            }
            ++v14;
          }
          if (v19)
          {
            v47[v12] = 0;
            CFBurstTrieAddCharacters((unint64_t)v4, (uint64_t)v47, v12, v13);
            int v13 = 0;
            unsigned int v12 = 0;
          }
          else
          {
            int v13 = 0;
            unsigned int v12 = 0;
            uint64_t v7 = (v7 + 1);
          }
          continue;
        }
        v47[v12++] = v16;
        v13 *= 8;
      }
      ++v14;
    }
    while (v14 < v15);
  }
  __CFHyphenationDestroyMMapType(v43);
  CFRelease(cf);
  free(v41);
  uint64_t v27 = __CFHyphenationMapFileContents(v49, &v45);
  if (v45)
  {
    fwrite("warning: failed to map exceptions file\n", 0x27uLL, 1uLL, *(FILE **)off_1ECE0A5B8);
  }
  else
  {
    uint64_t v28 = v27;
    CFStringRef v29 = CFStringCreateWithBytes(0, *(const UInt8 **)v27, *((void *)v27 + 1), 0x8000100u, 1u);
    CFIndex v30 = CFStringGetLength(v29);
    uint64_t v31 = (UniChar *)malloc_type_malloc(2 * v30, 0x1000040BDFB0063uLL);
    v53.CFIndex location = 0;
    v53.CFIndex length = v30;
    CFStringGetCharacters(v29, v53, v31);
    CFIndex v32 = CFStringGetLength(v29);
    if (v32 >= 1)
    {
      unsigned int v33 = 0;
      int v34 = -1;
      size_t v35 = v31;
      int v36 = &v31[v32];
      do
      {
        int v37 = *v35;
        if (v37 == 10 || v37 == 13)
        {
          v46[v33] = 0;
          CFBurstTrieAddCharacters((unint64_t)v4, (uint64_t)v46, v33, v34);
          unsigned int v33 = 0;
          int v34 = -1;
        }
        else if (v37 == 45)
        {
          if (v33) {
            v34 &= ~(1 << (v33 - 1));
          }
          else {
            unsigned int v33 = 0;
          }
        }
        else
        {
          if (v33 > 0x1B) {
            break;
          }
          v46[v33++] = v37;
        }
        ++v35;
      }
      while (v35 < v36);
    }
    __CFHyphenationDestroyMMapType(v28);
    CFRelease(v29);
    free(v31);
  }
  fprintf(*(FILE **)off_1ECE0A5B8, "writing trie to %s...\n", cStr);
  CFStringRef v39 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  CFBurstTrieSerialize((uint64_t)v4, v39, 6);
  CFRelease(v39);
  CFBurstTrieRelease(v4);
  return v7;
}

_DWORD *__CFHyphenationMapFileContents(const char *a1, int *a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  Class v4 = malloc_type_malloc(0x18uLL, 0x1010040E2407E0AuLL);
  uint64_t v5 = v4;
  if (!v4)
  {
    int v8 = 1;
    goto LABEL_11;
  }
  memset(&v10, 0, sizeof(v10));
  v4[4] = -1;
  *(void *)Class v4 = 0;
  *((void *)v4 + __postAndResetMidnight(1, 1) = 0;
  if (stat(a1, &v10) == -1)
  {
    int v8 = 2;
LABEL_10:
    __CFHyphenationDestroyMMapType(v5);
    uint64_t v5 = 0;
    goto LABEL_11;
  }
  *((void *)v5 + __postAndResetMidnight(1, 1) = v10.st_size;
  int v6 = open(a1, 0);
  v5[4] = v6;
  if (v6 < 0)
  {
    int v8 = 3;
    goto LABEL_10;
  }
  uint64_t v7 = mmap(0, *((void *)v5 + 1), 1, 1, v6, 0);
  *(void *)uint64_t v5 = v7;
  if (v7 == (void *)-1)
  {
    int v8 = 4;
    goto LABEL_10;
  }
  int v8 = 0;
LABEL_11:
  *a2 = v8;
  return v5;
}

void __CFHyphenationDestroyMMapType(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)*a1;
    if (v2)
    {
      munmap(v2, a1[1]);
      *a1 = 0;
    }
    int v3 = *((_DWORD *)a1 + 4);
    if ((v3 & 0x80000000) == 0) {
      close(v3);
    }
    free(a1);
  }
}

void _CFBurstTrieReleaseWrapper(int a1, unsigned int *a2)
{
}

uint64_t _CFPropertyListMissingSemicolon()
{
  return CFLog(4, @"CFPropertyListCreateFromXMLData(): Old-style plist parser: missing semicolon in dictionary on line %d. Parsing will be abandoned. Break on _CFPropertyListMissingSemicolon to debug.");
}

uint64_t _CFPropertyListMissingSemicolonOrValue()
{
  return CFLog(4, @"CFPropertyListCreateFromXMLData(): Old-style plist parser: missing semicolon or value in dictionary on line %d. Parsing will be abandoned. Break on _CFPropertyListMissingSemicolonOrValue to debug.");
}

__CFDictionary *parsePlistDictContent(uint64_t a1, int a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    uint64_t v14 = lineNumberStrings((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate dictionary while parsing plist at line %d", v14);
    unsigned int v16 = *(const void **)(a1 + 24);
    if (v16) {
      CFRelease(v16);
    }
    uint64_t v5 = 0;
    *(void *)(a1 + 24) = Error;
    return v5;
  }
  uint64_t v5 = Mutable;
  int v6 = parsePlistString(a1);
  if (!v6)
  {
LABEL_14:
    int v13 = *(const void **)(a1 + 24);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 24) = 0;
    }
    return v5;
  }
  uint64_t v7 = v6;
  uint64_t v8 = (a2 + 1);
  while (1)
  {
    if (!advanceToNonSpace(a1))
    {
      uint64_t v20 = lineNumberStrings((unint64_t *)a1);
      _CFPropertyListMissingSemicolonOrValue();
      CFErrorRef v21 = __CFPropertyListCreateError(3840, @"Missing ';' on line %d", v20);
      goto LABEL_24;
    }
    id v9 = *(unsigned __int16 **)(a1 + 8);
    int v10 = *v9;
    if (v10 != 61)
    {
      if (v10 == 59)
      {
        CFTypeRef v11 = CFRetain(v7);
        goto LABEL_9;
      }
      uint64_t v25 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef v21 = __CFPropertyListCreateError(3840, @"Expected ';' or '=' after key at line %d", v25);
LABEL_24:
      CFErrorRef v22 = v21;
      unsigned __int16 v23 = *(const void **)(a1 + 24);
      if (v23) {
        CFRelease(v23);
      }
      *(void *)(a1 + 24) = v22;
LABEL_27:
      CFRelease(v7);
      goto LABEL_28;
    }
    *(void *)(a1 + 8) = v9 + 1;
    CFTypeRef v11 = (CFTypeRef)parsePlistObject(a1, 1, v8);
    if (!v11) {
      goto LABEL_27;
    }
LABEL_9:
    CFDictionarySetValue(v5, v7, v11);
    CFRelease(v7);
    if (v11) {
      CFRelease(v11);
    }
    if (!advanceToNonSpace(a1)) {
      break;
    }
    unsigned int v12 = *(_WORD **)(a1 + 8);
    if (*v12 != 59) {
      break;
    }
    *(void *)(a1 + 8) = v12 + 1;
    uint64_t v7 = parsePlistString(a1);
    if (!v7) {
      goto LABEL_14;
    }
  }
  uint64_t v17 = lineNumberStrings((unint64_t *)a1);
  _CFPropertyListMissingSemicolon();
  CFErrorRef v18 = __CFPropertyListCreateError(3840, @"Missing ';' on line %d", v17);
  unint64_t v19 = *(const void **)(a1 + 24);
  if (v19) {
    CFRelease(v19);
  }
  *(void *)(a1 + 24) = v18;
LABEL_28:
  CFRelease(v5);
  return 0;
}

__CFString *parseQuotedPlistString(uint64_t a1, int a2)
{
  uint64_t v39 = *(void *)off_1ECE0A5B0;
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16);
  if (v4 >= v3)
  {
LABEL_65:
    *(void *)(a1 + 8) = v4;
    uint64_t v33 = lineNumberStrings((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unterminated quoted string starting on line %d", v33);
    goto LABEL_66;
  }
  int v6 = 0;
  uint64_t v7 = *(UniChar **)(a1 + 8);
  uint64_t v8 = v7;
  do
  {
    UniChar chars = 0;
    UniChar chars = *v7;
    if (chars == a2) {
      break;
    }
    if (chars == 92)
    {
      if (!v6)
      {
        CFMutableStringRef Mutable = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
        if (!Mutable)
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate quoted string while parsing plist");
          goto LABEL_66;
        }
        int v6 = Mutable;
        uint64_t v7 = *(UniChar **)(a1 + 8);
      }
      CFStringAppendCharacters(v6, v8, v7 - v8);
      uint64_t v11 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(a1 + 16);
      *(void *)(a1 + 8) = v11 + 2;
      if (v11 + 2 == v10)
      {
        CFRelease(v6);
        uint64_t v34 = lineNumberStrings((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unterminated backslash sequence on line %d", v34);
        goto LABEL_66;
      }
      int v12 = *(unsigned __int16 *)(v11 + 2);
      int v13 = (_WORD *)(v11 + 4);
      *(void *)(a1 + 8) = v13;
      if (v12 > 84)
      {
        if (v12 > 101)
        {
          switch(v12)
          {
            case 'n':
              LOWORD(v12) = 10;
              break;
            case 'o':
            case 'p':
            case 'q':
            case 's':
            case 'u':
              break;
            case 'r':
              LOWORD(v12) = 13;
              break;
            case 't':
              LOWORD(v12) = 9;
              break;
            case 'v':
              LOWORD(v12) = 11;
              break;
            default:
              if (v12 == 102) {
                LOWORD(v12) = 12;
              }
              break;
          }
        }
        else
        {
          switch(v12)
          {
            case 'U':
              if ((unint64_t)v13 >= v10)
              {
                LOWORD(v12) = 0;
              }
              else
              {
                LOWORD(v12) = 0;
                int v18 = -5;
                do
                {
                  if (__CFADD__(v18++, 1)) {
                    break;
                  }
                  uint64_t v20 = (unsigned __int16)*v13;
                  if (v20 <= 0x7F && (*((_DWORD *)off_1ECE0A578 + v20 + 15) & 0x10000) != 0)
                  {
                    *(void *)(a1 + 8) = ++v13;
                    if (v20 >= 0x47) {
                      __int16 v21 = -87;
                    }
                    else {
                      __int16 v21 = -55;
                    }
                    if (v20 < 0x3A) {
                      __int16 v21 = -48;
                    }
                    LOWORD(v12) = v20 + 16 * v12 + v21;
                  }
                }
                while ((unint64_t)v13 < v10);
              }
              break;
            case 'a':
              LOWORD(v12) = 7;
              break;
            case 'b':
              LOWORD(v12) = 8;
              break;
          }
        }
      }
      else
      {
        char v14 = v12 - 48;
        if ((v12 - 48) < 8)
        {
          LOBYTE(v15) = 0;
          __int16 v37 = 0;
          uint64_t v36 = 0;
          do
          {
            if ((unint64_t)v13 >= v10) {
              break;
            }
            if ((*v13 & 0xFFF8) != 0x30) {
              break;
            }
            char v14 = *v13++ + 8 * v14 - 48;
            *(void *)(a1 + 8) = v13;
            unsigned int v15 = (v15 + 1);
          }
          while (v15 < 2);
          char v38 = v14;
          if (CFStringEncodingBytesToUnicode(2817, 0, (unint64_t)&v38, 1, 0, (uint64_t)&v37, 1, &v36))
          {
            CFErrorRef v16 = __CFPropertyListCreateError(3840, @"Unable to convert octet-stream while parsing plist");
            uint64_t v17 = *(const void **)(a1 + 24);
            if (v17) {
              CFRelease(v17);
            }
            LOWORD(v12) = 0;
            *(void *)(a1 + 24) = v16;
          }
          else if (v36 == 1)
          {
            LOWORD(v12) = v37;
          }
          else
          {
            LOWORD(v12) = 0;
          }
        }
      }
      UniChar chars = v12;
      CFStringAppendCharacters(v6, &chars, 1);
      uint64_t v7 = *(UniChar **)(a1 + 8);
      unint64_t v3 = *(void *)(a1 + 16);
      uint64_t v8 = v7;
    }
    else
    {
      *(void *)(a1 + 8) = ++v7;
    }
  }
  while ((unint64_t)v7 < v3);
  if (v3 <= (unint64_t)v7)
  {
    if (v6) {
      CFRelease(v6);
    }
    goto LABEL_65;
  }
  if (v6)
  {
    if (v8 != v7) {
      CFStringAppendCharacters(v6, v8, v7 - v8);
    }
    if (*(_DWORD *)(a1 + 40) == 2) {
      goto LABEL_76;
    }
    CFURLRef Value = (__CFString *)CFSetGetValue(*(CFSetRef *)(a1 + 48), v6);
    if (!Value)
    {
      CFStringRef v23 = __CFStringCollectionCopy(*(const __CFAllocator **)(a1 + 32), v6);
      if (!v23)
      {
        CFErrorRef v31 = __CFPropertyListCreateError(3840, @"Unable to copy string while parsing plist");
        CFIndex v32 = *(const void **)(a1 + 24);
        if (v32) {
          CFRelease(v32);
        }
        CFURLRef Value = 0;
        *(void *)(a1 + 24) = v31;
        goto LABEL_62;
      }
      CFURLRef Value = (__CFString *)v23;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v23);
      __CFTypeCollectionRelease(*(void *)(a1 + 32), Value);
    }
    CFRetain(Value);
LABEL_62:
    CFRelease(v6);
    int v6 = Value;
    goto LABEL_76;
  }
  if (*(_DWORD *)(a1 + 40) != 2)
  {
    int v6 = (__CFString *)_uniqueStringForCharacters(a1, v8, v7 - v8);
LABEL_76:
    *(void *)(a1 + 8) += 2;
    CFIndex v30 = *(const void **)(a1 + 24);
    if (v30)
    {
      CFRelease(v30);
      *(void *)(a1 + 24) = 0;
    }
    return v6;
  }
  uint64_t v28 = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
  if (v28)
  {
    int v6 = v28;
    CFStringRef v29 = *(const UniChar **)(a1 + 8);
    if (v8 != v29) {
      CFStringAppendCharacters(v28, v8, v29 - v8);
    }
    goto LABEL_76;
  }
  CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate mutable string while parsing plist");
LABEL_66:
  CFErrorRef v25 = Error;
  int v26 = *(const void **)(a1 + 24);
  if (v26) {
    CFRelease(v26);
  }
  int v6 = 0;
  *(void *)(a1 + 24) = v25;
  return v6;
}

__CFString *parseUnquotedPlistString(uint64_t a1)
{
  unint64_t v3 = *(const UniChar **)(a1 + 8);
  unint64_t v2 = *(void *)(a1 + 16);
  if ((unint64_t)v3 >= v2) {
    goto LABEL_17;
  }
  unint64_t v4 = *(const UniChar **)(a1 + 8);
  do
  {
    if ((unsigned __int16)(*v4 - 48) >= 0xAu && (unsigned __int16)((*v4 & 0xFFDF) - 65) >= 0x1Au)
    {
      unsigned int v6 = *v4 - 36;
      BOOL v7 = v6 > 0x3B;
      uint64_t v8 = (1 << v6) & 0x800000000400E01;
      if (v7 || v8 == 0) {
        break;
      }
    }
    *(void *)(a1 + 8) = ++v4;
  }
  while ((unint64_t)v4 < v2);
  if (v4 == v3)
  {
LABEL_17:
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unexpected EOF");
    goto LABEL_18;
  }
  if (*(_DWORD *)(a1 + 40) == 2)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
    if (Mutable)
    {
      uint64_t v11 = Mutable;
      CFStringAppendCharacters(Mutable, v3, (uint64_t)(*(void *)(a1 + 8) - (void)v3) >> 1);
      return v11;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate unquoted string while parsing plist");
LABEL_18:
    CFErrorRef v13 = Error;
    char v14 = *(const void **)(a1 + 24);
    if (v14) {
      CFRelease(v14);
    }
    uint64_t v11 = 0;
    *(void *)(a1 + 24) = v13;
    return v11;
  }

  return (__CFString *)_uniqueStringForCharacters(a1, v3, v4 - v3);
}

CFTypeRef _uniqueStringForCharacters(uint64_t a1, const UniChar *a2, CFIndex a3)
{
  v18[1] = *(void *)off_1ECE0A5B0;
  if (a3)
  {
    MEMORY[0x1F4188790](a1, a2);
    BOOL v7 = (UInt8 *)v18 - v6;
    if (v8 >= 2048)
    {
      uint64_t Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, a3 + 1, 2505277932, 0);
      if (!Typed)
      {
        CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate string while parsing plist");
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t Typed = (UInt8 *)v18 - v6;
      if (a3 < 1)
      {
LABEL_12:
        Typed[a3] = 0;
        CFStringRef v13 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), Typed, a3, 0x600u, 0);
        if (!v13)
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate ascii string while parsing plist");
LABEL_22:
          CFErrorRef v16 = Error;
          uint64_t v17 = *(const void **)(a1 + 24);
          if (v17) {
            CFRelease(v17);
          }
          CFURLRef Value = 0;
          *(void *)(a1 + 24) = v16;
          return Value;
        }
LABEL_15:
        if (Typed != v7) {
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
        }
        CFURLRef Value = CFSetGetValue(*(CFSetRef *)(a1 + 48), v13);
        if (!Value)
        {
          CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v13);
          CFURLRef Value = v13;
        }
        CFRelease(v13);
        CFRetain(Value);
        return Value;
      }
    }
    uint64_t v11 = 0;
    while (1)
    {
      unsigned int v12 = a2[v11];
      if (v12 >= 0x80) {
        break;
      }
      Typed[v11++] = v12;
      if (a3 == v11) {
        goto LABEL_12;
      }
    }
    CFStringRef v13 = CFStringCreateWithCharacters(*(CFAllocatorRef *)(a1 + 32), a2, a3);
    if (!v13)
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840, @"Unable to allocate pre-unique string while parsing plist");
      goto LABEL_22;
    }
    goto LABEL_15;
  }

  return CFRetain(&stru_1ECE10768);
}

__CFString *parsePlistString(uint64_t a1)
{
  if (!advanceToNonSpace(a1)) {
    return 0;
  }
  unint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  int v3 = *v2;
  if (v3 == 39 || v3 == 34)
  {
    *(void *)(a1 + 8) = v2 + 1;
    return parseQuotedPlistString(a1, v3);
  }
  if ((v3 - 48) >= 0xA
    && (unsigned __int16)((v3 & 0xFFDF) - 65) >= 0x1Au
    && ((v3 - 36) > 0x3B || ((1 << (v3 - 36)) & 0x800000000400E01) == 0))
  {
    return 0;
  }

  return parseUnquotedPlistString(a1);
}

void sub_182D2C3E8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182D2C7F4(_Unwind_Exception *a1)
{
}

void sub_182D2CAB8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_182D2DE28(_Unwind_Exception *a1, int a2)
{
  *(void *)(v4 - 224) = v3;
  free(*(void **)(v4 - 224));
  if (a2 == 1)
  {
    id v7 = objc_begin_catch(a1);

    objc_exception_throw(v7);
  }
  cleanup_sentinel_pair(v4 - 144);
  cleanup_sentinel_pair(v4 - 120);
  _Unwind_Resume(a1);
}

CFErrorRef __archiveIsCorrupt(uint64_t a1)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  unint64_t v2 = @"NSLocalizedDescription";
  v3[0] = a1;
  return CFErrorCreate(0, @"NSCocoaErrorDomain", 4864, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:v3 forKeys:&v2 count:1]);
}

void cleanup_sentinel_pair(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  unint64_t v2 = (void *)(a1 + 8);
  if (*(void *)(a1 + 8)) {
    BOOL v3 = v1 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    objc_msgSend(*(id *)a1, "replaceObject:withObject:", v1);
  }

  void *v2 = 0;
  v2[1] = 0;
}

void sub_182D2EA04()
{
}

void sub_182D2EA44(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    if (!v2) {
      JUMPOUT(0x182D2E69CLL);
    }
    JUMPOUT(0x182D2E688);
  }
  _Unwind_Resume(a1);
}

void sub_182D2EA68(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x182D2EA74);
}

CFErrorRef __archiveIsCorrupt_0(uint64_t a1)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  uint64_t v2 = @"NSLocalizedDescription";
  v3[0] = a1;
  return CFErrorCreate(0, @"NSCocoaErrorDomain", 4864, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:v3 forKeys:&v2 count:1]);
}

uint64_t _CFPrefsSynchronizeDirtySourceForDaemonTermination(void *a1)
{
  v2[5] = *(void *)off_1ECE0A5B0;
  v2[0] = off_1ECE0A5A0;
  v2[1] = 3221225472;
  v2[2] = ___CFPrefsSynchronizeDirtySourceForDaemonTermination_block_invoke;
  v2[3] = &unk_1ECDB0298;
  v2[4] = a1;
  return [a1 lockedSync:v2];
}

void _CFPrefsSynchronizeForDaemonTermination()
{
  CFSetRef v0 = (const __CFSet *)+[_CFPrefsSynchronizer sharedInstance]();

  -[_CFPrefsSynchronizer synchronizeForDaemonTermination](v0);
}

void sub_182D2FABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

void sub_182D2FFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

__CFString *_CFPrefsDCopyCurrentUserName()
{
  uid_t v0 = cfprefsdEuid();

  return _CFPrefsCopyUserNameForUID(v0);
}

uint64_t __cfprefsdEuid_block_invoke()
{
  if (xpc_user_sessions_enabled()) {
    uint64_t result = xpc_user_sessions_get_session_uid();
  }
  else {
    uint64_t result = geteuid();
  }
  cfprefsdEuid_euid = result;
  return result;
}

BOOL isSpecialKey(char *__s2)
{
  return __s2
      && (!strcmp("AppleLanguages", __s2)
       || !strcmp("AppleLocale", __s2)
       || !strcmp("AppleKeyboards", __s2)
       || !strcmp("AppleKeyboardsExpanded", __s2)
       || !strcmp("AppleLanguagesDidMigrate", __s2)
       || !strcmp("ApplePasscodeKeyboards", __s2)
       || !strcmp("AddingEmojiKeyboardHandled", __s2));
}

void DEBUG_READ_EMPTY(void *a1, void *a2, uint64_t a3)
{
  v7[5] = *(void *)off_1ECE0A5B0;
  uint64_t v6 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = off_1ECE0A5A0;
    v7[1] = 3221225472;
    v7[2] = __DEBUG_READ_EMPTY_block_invoke;
    v7[3] = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
    v7[4] = a3;
    _extractCFPDBits(a1, 0, a2, (uint64_t)v7);
  }
}

void sub_182D31A44(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 48));
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__364(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__365(uint64_t a1)
{
}

void _extractCFPDBits(void *a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    size_t length = 0;
    long long buffer = 0u;
    *(_OWORD *)pid = 0u;
    data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
    if (data && length == 32)
    {
      long long v8 = data[1];
      long long buffer = *data;
      *(_OWORD *)pid = v8;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        xpc_object_t value = xpc_dictionary_get_value(a1, "connection");
        if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
          _extractCFPDBits_cold_1();
        }
      }
      xpc_connection_get_audit_token();
    }
    uint64_t v10 = pid[1];
    long long v36 = 0u;
    long long v37 = 0u;
    long long buffer = 0u;
    *(_OWORD *)pid = 0u;
    BOOL v9 = v10 != -1 && proc_name(v10, &buffer, 0x40u) >= 0;
  }
  else
  {
    BOOL v9 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long buffer = 0u;
    *(_OWORD *)pid = 0u;
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  __int16 v33 = 0;
  char v32 = 0;
  unsigned int v12 = toCString((const __CFString *)[a3 domain], (char *)&v33 + 1, "no domain");
  CFStringRef v13 = toCString((const __CFString *)[a3 user], (char *)&v33, "no user");
  if (!a2) {
    goto LABEL_16;
  }
  Class Class = object_getClass(a2);
  if (Class == (Class)off_1ECE0A6B8)
  {
    string_ptr = (char *)xpc_string_get_string_ptr(a2);
    int v15 = 0;
  }
  else
  {
    if (Class != (Class)off_1ECE0A690)
    {
LABEL_16:
      int v15 = 0;
      string_ptr = "no key";
      goto LABEL_19;
    }
    size_t length = 0;
    p_size_t length = &length;
    uint64_t v30 = 0x2020000000;
    uint64_t v31 = 0;
    applier[0] = off_1ECE0A5A0;
    applier[1] = 3221225472;
    applier[2] = ___extractCFPDBits_block_invoke;
    applier[3] = &unk_1ECDABE88;
    applier[4] = &length;
    xpc_dictionary_apply(a2, applier);
    string_ptr = (char *)malloc_type_calloc(1uLL, p_length[3] + 3, 0x358531DDuLL);
    char *string_ptr = 91;
    uint64_t v23 = 0;
    unsigned int v24 = &v23;
    uint64_t v25 = 0x2020000000;
    int v26 = 1;
    v22[0] = off_1ECE0A5A0;
    v22[1] = 3221225472;
    unsigned char v22[2] = ___extractCFPDBits_block_invoke_2;
    v22[3] = &unk_1ECE00408;
    v22[4] = &v23;
    v22[5] = string_ptr;
    xpc_dictionary_apply(a2, v22);
    string_ptr[*((int *)v24 + 6)] = 93;
    _Block_object_dispose(&v23, 8);
    _Block_object_dispose(&length, 8);
    int v15 = 1;
  }
LABEL_19:
  if ([a3 byHost]) {
    uint64_t v17 = "kCFPreferencesCurrentHost";
  }
  else {
    uint64_t v17 = "kCFPreferencesAnyHost";
  }
  CFStringRef v18 = (const __CFString *)[a3 copyUncanonicalizedPath];
  unint64_t v19 = toCString(v18, &v32, "no uncanonicalized path");
  if (v9) {
    p_long long buffer = (const char *)&buffer;
  }
  else {
    p_long long buffer = "unknown process name";
  }
  (*(void (**)(uint64_t, uint64_t, const char *, void *, char *, void *, const char *, void *, _BYTE))(a4 + 16))(a4, v10, p_buffer, v12, string_ptr, v13, v17, v19, [a3 managed]);
  if (v18) {
    CFRelease(v18);
  }
  if (HIBYTE(v33)) {
    free(v12);
  }
  if ((_BYTE)v33) {
    free(v13);
  }
  if (v32) {
    free(v19);
  }
  if (v15) {
    free(string_ptr);
  }
}

void sub_182D328B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void *toCString(const __CFString *a1, char *a2, void *a3)
{
  if (!a1) {
    goto LABEL_10;
  }
  CFStringRef v5 = a1;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID())
  {
    CFStringRef v7 = CFCopyDescription(v5);
    if (!v7) {
      goto LABEL_10;
    }
    CFStringRef v5 = v7;
    CFAutorelease(v7);
  }
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CStringPtr = CFStringGetCStringPtr(v5, SystemEncoding);
  if (!CStringPtr)
  {
    CFIndex Length = CFStringGetLength(v5);
    CFIndex v12 = CFStringGetMaximumSizeForEncoding(Length, SystemEncoding) + 1;
    char v10 = 1;
    CFStringRef v13 = (char *)malloc_type_calloc(v12, 1uLL, 0x100004077774924uLL);
    if (CFStringGetCString(v5, v13, v12, SystemEncoding))
    {
      a3 = v13;
      goto LABEL_11;
    }
    free(v13);
LABEL_10:
    char v10 = 0;
    goto LABEL_11;
  }
  char v10 = 0;
  a3 = (void *)CStringPtr;
LABEL_11:
  *a2 = v10;
  return a3;
}

uint64_t ___extractCFPDBits_block_invoke(uint64_t a1, char *__s)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += strlen(__s) + 2;
  return 1;
}

uint64_t ___extractCFPDBits_block_invoke_2(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  int v5 = v4;
  strncpy((char *)(*(void *)(a1 + 40) + *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)), __s, v4);
  uint64_t v6 = *(void *)(a1 + 40);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
  *(_WORD *)(v6 + *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) = 8236;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += 2;
  return 1;
}

void *__initializeFSEvents_block_invoke()
{
  uid_t v0 = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", 256);
  fsEventStreamCreate = dlsym(v0, "FSEventStreamCreate");
  fsEventStreamInvalidate = dlsym(v0, "FSEventStreamInvalidate");
  fsEventStreamRelease = dlsym(v0, "FSEventStreamRelease");
  fsEventStreamSetDispatchQueue = dlsym(v0, "FSEventStreamSetDispatchQueue");
  fsEventStreamStart = dlsym(v0, "FSEventStreamStart");
  fsEventStreamStop = dlsym(v0, "FSEventStreamStop");
  uint64_t result = dlsym(v0, "FSEventStreamGetLatestEventId");
  fsEventStreamGetLatestEventId = (uint64_t)result;
  return result;
}

uint64_t _onqueue_locked_CFPrefsRecreateFileWatcher()
{
  if (dirWatcher)
  {
    fsEventStreamStop();
    fsEventStreamInvalidate(dirWatcher);
    fsEventStreamRelease(dirWatcher);
    dirWatcher = 0;
  }
  dirWatcher = fsEventStreamCreate(&__kCFAllocatorSystemDefault, deletionStreamCallback, 0, watchedDirs, -1, 25, 0.0);
  fsEventStreamSetDispatchQueue();
  return dirWatcher;
}

void deletionStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, const __CFArray *a4, uint64_t a5)
{
  v24[5] = *(void *)off_1ECE0A5B0;
  dispatch_assert_queue_V2((dispatch_queue_t)fseventsQueue);
  os_unfair_lock_lock((os_unfair_lock_t)&dirWatcherLock);
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  if (a3)
  {
    CFIndex v8 = 0;
    char v9 = 0;
    p_superclass = &OBJC_METACLASS___CFPDCloudSource.superclass;
    do
    {
      if ((~*(_DWORD *)(a5 + 4 * v8) & 0x20200) == 0)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a4, v8);
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)dirWatcherTargets, ValueAtIndex);
        if (Value)
        {
          CFArrayRef v13 = Value;
          char v14 = p_superclass;
          uint64_t Count = CFArrayGetCount(Value);
          if (Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
              *((unsigned char *)CFArrayGetValueAtIndex(v13, i) + 14__postAndResetMidnight(1, 1) = 0;
            char v9 = 1;
          }
          v26.CFIndex location = 0;
          v26.size_t length = Count;
          CFArrayAppendArray(Mutable, v13, v26);
          p_superclass = v14;
        }
        CFDictionaryRemoveValue((CFMutableDictionaryRef)dirWatcherTargets, ValueAtIndex);
        CFArrayRef v17 = (const __CFArray *)p_superclass[396];
        v25.size_t length = CFArrayGetCount(v17);
        v25.CFIndex location = 0;
        FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v17, v25, ValueAtIndex);
        if (FirstIndexOfValue != -1) {
          CFArrayRemoveValueAtIndex((CFMutableArrayRef)p_superclass[396], FirstIndexOfValue);
        }
      }
      ++v8;
    }
    while (v8 != a3);
    if (v9) {
      _onqueue_locked_CFPrefsRecreateFileWatcher();
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dirWatcherLock);
  CFIndex v19 = CFArrayGetCount(Mutable);
  if (v19 >= 1)
  {
    CFIndex v20 = v19;
    for (CFIndex j = 0; j != v20; ++j)
    {
      CFErrorRef v22 = (void *)CFArrayGetValueAtIndex(Mutable, j);
      v24[0] = off_1ECE0A5A0;
      v24[1] = 3221225472;
      v24[2] = __deletionStreamCallback_block_invoke;
      v24[3] = &unk_1ECDB0298;
      v24[4] = v22;
      [v22 lockedSync:v24];
    }
  }
  CFRelease(Mutable);
}

uint64_t __deletionStreamCallback_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) clearCacheForReason:@"directory was deleted"];
}

void OUTLINED_FUNCTION_2_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

void OUTLINED_FUNCTION_4_2(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_5_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_8(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

uint64_t _CFBigNumInitWithInt8(uint64_t result, int a2)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (a2 < 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }
  *(_DWORD *)uint64_t result = a2;
  return result;
}

uint64_t _CFBigNumInitWithInt16(uint64_t result, int a2)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (a2 < 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }
  *(_DWORD *)uint64_t result = (unsigned __int16)a2;
  return result;
}

void *_CFBigNumInitWithUInt8(void *result, int a2)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  *(_DWORD *)uint64_t result = a2;
  return result;
}

void *_CFBigNumInitWithUInt16(void *result, int a2)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  *(_DWORD *)uint64_t result = a2;
  return result;
}

uint64_t _CFBigNumInitWithUInt32(uint64_t result, unsigned int a2)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(_DWORD *)uint64_t result = a2 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 / 0x3B9ACA00;
  return result;
}

uint64_t _CFBigNumInitWithUInt64(uint64_t result, unint64_t a2)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(_DWORD *)uint64_t result = a2 % 0xDE0B6B3A7640000 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 % 0xDE0B6B3A7640000 / 0x3B9ACA00;
  *(_DWORD *)(result + 8) = a2 / 0xDE0B6B3A7640000;
  return result;
}

__n128 _CFBigNumInitWithUInt128(void *a1, int a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v4 = __udivti3();
  unsigned int v5 = __udivti3();
  unsigned int v6 = __udivti3();
  unsigned __int32 v7 = __udivti3();
  result.n128_u32[0] = 1486618624 * v6 + 402653184 * v5 + a2 - 1000000000 * v7;
  result.n128_u32[1] = v7;
  result.n128_u64[1] = __PAIR64__(v5, v6);
  *(__n128 *)a1 = result;
  *((_DWORD *)a1 + 4) = v4;
  return result;
}

uint64_t _CFBigNumGetInt8(uint64_t a1)
{
  int v1 = *(_DWORD *)a1;
  if ((*(unsigned char *)(a1 + 20) & 0x80) != 0) {
    int v1 = -v1;
  }
  return (char)v1;
}

uint64_t _CFBigNumGetInt16(uint64_t a1)
{
  int v1 = *(_DWORD *)a1;
  if ((*(unsigned char *)(a1 + 20) & 0x80) != 0) {
    int v1 = -v1;
  }
  return (__int16)v1;
}

uint64_t _CFBigNumGetInt32(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)a1 + 1000000000 * *(_DWORD *)(a1 + 4);
  if ((*(unsigned char *)(a1 + 20) & 0x80) != 0) {
    return -v1;
  }
  else {
    return v1;
  }
}

uint64_t _CFBigNumGetInt64(unsigned int *a1)
{
  if ((a1[5] & 0x80) != 0) {
    return -(*a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2]);
  }
  else {
    return *a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2];
  }
}

uint64_t _CFBigNumGetInt128(unsigned int *a1)
{
  if ((a1[5] & 0x80) != 0) {
    return 0x4CB460F000000000 * a1[4]
  }
         - (*a1
          + 1000000000 * a1[1]
          + 1000000000000000000 * a1[2]
          - 0x602F7FC318000000 * a1[3]);
  else {
    return *a1
  }
         + 1000000000 * a1[1]
         + 1000000000000000000 * a1[2]
         - 0x602F7FC318000000 * a1[3]
         - 0x4CB460F000000000 * a1[4];
}

uint64_t _CFBigNumGetUInt8(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t _CFBigNumGetUInt16(unsigned __int16 *a1)
{
  return *a1;
}

uint64_t _CFBigNumGetUInt32(_DWORD *a1)
{
  return (*a1 + 1000000000 * a1[1]);
}

uint64_t _CFBigNumGetUInt64(unsigned int *a1)
{
  return *a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2];
}

uint64_t _CFBigNumGetUInt128(unsigned int *a1)
{
  return *a1
       + 1000000000 * a1[1]
       + 1000000000000000000 * a1[2]
       - 0x602F7FC318000000 * a1[3]
       - 0x4CB460F000000000 * a1[4];
}

double _CFBigNumInitWithCFNumber(uint64_t a1, unint64_t *a2)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  memset(v6, 0, sizeof(v6));
  CFNumberType Type2 = _CFNumberGetType2(a2);
  CFNumberGetValue((CFNumberRef)a2, Type2, v6);
  return _CFBigNumInitWithBytes(a1, (char *)v6, Type2);
}

double _CFBigNumInitWithBytes(uint64_t a1, char *a2, uint64_t a3)
{
  switch(a3)
  {
    case 1:
    case 7:
      _CFBigNumInitWithInt8(a1, *a2);
      break;
    case 2:
    case 8:
      _CFBigNumInitWithInt16(a1, *(__int16 *)a2);
      break;
    case 3:
    case 9:
      _CFBigNumInitWithInt32(a1, *(_DWORD *)a2);
      break;
    case 4:
    case 10:
    case 11:
    case 14:
    case 15:
      _CFBigNumInitWithInt64(a1, *(void *)a2);
      break;
    case 17:
      *(void *)&double result = _CFBigNumInitWithInt128(a1, *((void *)a2 + 1), *(void *)a2).n128_u64[0];
      break;
    default:
      return result;
  }
  return result;
}

CFNumberRef _CFNumberCreateWithBigNum(unsigned int *a1)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  unint64_t v2 = a1[4];
  if (!v2)
  {
    if (!a1[3])
    {
      if (!a1[2] && !a1[1])
      {
        unsigned int v22 = *a1;
        if (*a1 <= 0x7F)
        {
          if ((a1[5] & 0x80) != 0) {
            unsigned int v22 = -v22;
          }
          v25[0] = v22;
          char v14 = v25;
          CFNumberType v15 = kCFNumberSInt8Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
        }
        if (!(v22 >> 15))
        {
          if ((a1[5] & 0x80) != 0) {
            unsigned int v22 = -v22;
          }
          *(_WORD *)CFRange v25 = v22;
          char v14 = v25;
          CFNumberType v15 = kCFNumberSInt16Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
        }
      }
      if (!a1[2])
      {
        *(void *)&v25[16] = 0;
        *(_OWORD *)CFRange v25 = 0x208CA6BFFuLL;
        *(void *)&v24[16] = 0xFF00000000;
        *(_OWORD *)unsigned int v24 = 0x208CA6C00uLL;
        uint64_t v19 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
        uint64_t v20 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
        if ((unint64_t)(v19 - 1) >= 0xFFFFFFFFFFFFFFFELL && v20 != -1)
        {
          int v21 = *a1 + 1000000000 * a1[1];
          if ((a1[5] & 0x80) != 0) {
            int v21 = -v21;
          }
          LODWORD(v23[0]) = v21;
          char v14 = v23;
          CFNumberType v15 = kCFNumberSInt32Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
        }
      }
    }
    if (!a1[3])
    {
      *(_DWORD *)&v25[20] = 0;
      *(void *)&v25[12] = 0;
      *(void *)CFRange v25 = 0xD50630432F2D7FFLL;
      *(_DWORD *)&v25[8] = 9;
      *(void *)&v24[12] = 0;
      *(_DWORD *)&v24[20] = 255;
      *(void *)unsigned int v24 = 0xD50630432F2D800;
      *(_DWORD *)&v24[8] = 9;
      uint64_t v16 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
      uint64_t v17 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
      if ((unint64_t)(v16 - 1) >= 0xFFFFFFFFFFFFFFFELL && v17 != -1)
      {
        uint64_t v18 = *a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2];
        if ((a1[5] & 0x80) != 0) {
          uint64_t v18 = -v18;
        }
        v23[0] = v18;
        char v14 = v23;
        CFNumberType v15 = kCFNumberSInt64Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
      }
    }
  }
  *(_OWORD *)CFRange v25 = xmmword_182EDF1D0;
  *(void *)&v25[16] = 170;
  *(_OWORD *)unsigned int v24 = xmmword_182EDF1E0;
  *(void *)&v24[16] = 0xFF000000AALL;
  uint64_t v3 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
  uint64_t v4 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
  CFNumberRef result = 0;
  if ((unint64_t)(v3 + 1) <= 1 && v4 != -1)
  {
    uint64_t v6 = *a1 + 1000000000 * a1[1];
    uint64_t v7 = 1000000000000000000 * a1[2];
    BOOL v8 = __CFADD__(v6, v7);
    uint64_t v9 = v6 + v7;
    if (v8) {
      unint64_t v10 = ((a1[2] * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64) + 1;
    }
    else {
      unint64_t v10 = (a1[2] * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64;
    }
    unsigned long long v13 = __PAIR128__(v10, v9)
        + __PAIR128__(((a1[3] * (unsigned __int128)0x9FD0803CE8000000) >> 64) + 54210108 * a1[3], 0x9FD0803CE8000000 * a1[3])+ __PAIR128__(0xC097CE7BC90715, 0xB34B9F1000000000) * v2;
    uint64_t v12 = *((void *)&v13 + 1);
    uint64_t v11 = v13;
    if ((a1[5] & 0x80) != 0)
    {
      uint64_t v12 = (unsigned __int128)-(__int128)__PAIR128__((v2 * (unsigned __int128)0xB34B9F1000000000) >> 64, v13) >> 64;
      uint64_t v11 = -(uint64_t)v13;
    }
    v23[0] = v11;
    v23[1] = v12;
    char v14 = v23;
    CFNumberType v15 = kCFNumberMaxType|kCFNumberSInt8Type;
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
  }
  return result;
}

uint64_t _CFBigNumCompare(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  int v3 = *(char *)(a2 + 20);
  if ((char)v2 == v3)
  {
    int v4 = v2 << 24;
    uint64_t v5 = 16;
    while (1)
    {
      if (v5 == -4) {
        return 0;
      }
      unsigned int v6 = *(_DWORD *)(a1 + v5);
      unsigned int v7 = *(_DWORD *)(a2 + v5);
      if (v6 < v7) {
        break;
      }
      v5 -= 4;
      if (v6 > v7)
      {
        BOOL v8 = v4 < 0;
        uint64_t v9 = 1;
        goto LABEL_12;
      }
    }
    BOOL v8 = v4 < 0;
    uint64_t v9 = -1;
LABEL_12:
    if (v8) {
      return -v9;
    }
    else {
      return v9;
    }
  }
  else if ((char)v2 < v3)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

uint64_t _CFBigNumNeg(uint64_t result, long long *a2)
{
  uint64_t v2 = 0;
  long long v3 = *a2;
  *(void *)(result + 16) = *((void *)a2 + 2);
  *(_OWORD *)CFNumberRef result = v3;
  while (!*(_DWORD *)((char *)a2 + v2))
  {
    v2 += 4;
    if (v2 == 20) {
      return result;
    }
  }
  *(unsigned char *)(result + 2_CFSetTSD(0xFu, 0, 0) = *(unsigned char *)(result + 20) * *(unsigned char *)(result + 20) - 1;
  return result;
}

unint64_t _CFBigNumAdd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v3) = *(unsigned __int8 *)(a3 + 20) ^ *(unsigned __int8 *)(a2 + 20);
  if (v3)
  {
    uint64_t v4 = 16;
    while (1)
    {
      if (v4 == -4)
      {
LABEL_6:
        uint64_t v7 = a2;
        goto LABEL_13;
      }
      unsigned int v5 = *(_DWORD *)(a2 + v4);
      unsigned int v6 = *(_DWORD *)(a3 + v4);
      if (v5 < v6) {
        break;
      }
      v4 -= 4;
      if (v5 > v6) {
        goto LABEL_6;
      }
    }
    uint64_t v7 = a3;
    a3 = a2;
LABEL_13:
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(unsigned int *)(a3 + v10);
      uint64_t v13 = v11 + *(unsigned int *)(v7 + v10);
      uint64_t v15 = v13 - v12;
      BOOL v14 = v13 < v12;
      int v16 = v13 - v12 + 1000000000;
      uint64_t v11 = v15 >> 63;
      if (!v14) {
        int v16 = v15;
      }
      *(_DWORD *)(a1 + v1_CFSetTSD(0xFu, 0, 0) = v16;
      v10 += 4;
    }
    while (v10 != 20);
    unint64_t v3 = (unint64_t)v15 >> 63;
    int v17 = *(_DWORD *)(a1 + 20);
    if ((*(unsigned char *)(v7 + 20) & 0x80) != 0) {
      unsigned int v18 = v17 | 0xFF;
    }
    else {
      unsigned int v18 = v17 & 0xFFFFFF00;
    }
    *(_DWORD *)(a1 + 2_CFSetTSD(0xFu, 0, 0) = v18;
  }
  else
  {
    for (uint64_t i = 0; i != 20; i += 4)
    {
      unsigned int v9 = *(_DWORD *)(a2 + i) + v3 + *(_DWORD *)(a3 + i);
      unint64_t v3 = v9 > 0x3B9ACA00;
      if (v9 > 0x3B9ACA00) {
        v9 -= 1000000000;
      }
      *(_DWORD *)(a1 + i) = v9;
    }
    *(unsigned char *)(a1 + 2_CFSetTSD(0xFu, 0, 0) = *(_DWORD *)(a2 + 20);
  }
  return v3;
}

unint64_t _CFBigNumSub(uint64_t a1, uint64_t a2, long long *a3)
{
  v6[3] = *(void *)off_1ECE0A5B0;
  memset(v6, 0, 24);
  _CFBigNumNeg((uint64_t)v6, a3);
  return _CFBigNumAdd(a1, a2, (uint64_t)v6);
}

void _CFBigNumFromCString(uint64_t a1, char *__s)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  size_t v4 = strlen(__s);
  unsigned int v5 = (unsigned __int8 *)malloc_type_calloc(v4 + 1, 1uLL, 0x100004077774924uLL);
  size_t v6 = strlen(__s);
  memcpy(v5, __s, v6 + 1);
  int v7 = *v5;
  if (v7 == 43) {
    goto LABEL_4;
  }
  BOOL v8 = v5;
  if (v7 == 45)
  {
    *(_DWORD *)(a1 + 20) |= 0xFFu;
LABEL_4:
    BOOL v8 = v5 + 1;
  }
  unsigned int v9 = (const char *)(v8 - 1);
  do
    int v10 = *(unsigned __int8 *)++v9;
  while (v10 == 48);
  size_t v11 = strlen(v9);
  if (v11)
  {
    if (v11 < 0xA)
    {
      unint64_t v13 = 0;
    }
    else
    {
      unint64_t v12 = (v11 - 10) / 9;
      if (v12 >= 3) {
        unint64_t v12 = 3;
      }
      unint64_t v13 = v12 + 1;
      BOOL v14 = &v9[v11 - 9];
      uint64_t v15 = (_DWORD *)a1;
      unint64_t v16 = v12 + 1;
      do
      {
        *v15++ = atol(v14);
        *BOOL v14 = 0;
        v14 -= 9;
        --v16;
      }
      while (v16);
    }
    *(_DWORD *)(a1 + 4 * v13) = atol(v9);
  }

  free(v5);
}

char *_CFBigNumCopyDescription(_DWORD *a1)
{
  uint64_t v2 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
  unint64_t v3 = v2;
  size_t v4 = "-";
  if ((a1[5] & 0x80) == 0) {
    size_t v4 = "+";
  }
  snprintf(v2, 0x400uLL, "sign:%s 1st:%u 2nd:%u 3rd:%u 4th:%u 5th:%u", v4, *a1, a1[1], a1[2], a1[3], a1[4]);
  return v3;
}

uint64_t _CFPrefsPIDForMessage(void *a1)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  size_t length = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    long long v3 = data[1];
    long long v7 = *data;
    long long v8 = v3;
  }
  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      xpc_object_t value = xpc_dictionary_get_value(a1, "connection");
      if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
        _CFPrefsPIDForMessage_cold_1();
      }
    }
    xpc_connection_get_audit_token();
  }
  return DWORD1(v8);
}

uint64_t _CFPrefsSandboxCheckForMessage_0(void *a1)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  size_t length = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    long long v3 = data[1];
    long long v7 = *data;
    long long v8 = v3;
  }
  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      xpc_object_t value = xpc_dictionary_get_value(a1, "connection");
      if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
        _CFPrefsSandboxCheckForMessage_cold_1_0();
      }
    }
    xpc_connection_get_audit_token();
  }
  return sandbox_check_by_audit_token();
}

void sub_182D35394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t indexSearchCallback(void *a1, uint64_t a2)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t result = [a1 shmemIndex];
    if (*(_DWORD *)a2 == result) {
      **(void **)(a2 + 8) = a1;
    }
  }
  return result;
}

uint64_t _CFPrefsBooleanEntitlementValueForMessage(void *a1, uint64_t a2)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  uint64_t v9 = 0;
  int v10 = &v9;
  uint64_t v11 = 0x2020000000;
  char v12 = 0;
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    xpc_object_t value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    remote_connection = value;
    if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
      __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
    }
  }
  v8[0] = off_1ECE0A5A0;
  v8[1] = 3221225472;
  uint64_t v8[2] = ___CFPrefsBooleanEntitlementValueForMessage_block_invoke;
  v8[3] = &unk_1ECE00820;
  v8[4] = a1;
  v8[5] = &v9;
  v8[6] = a2;
  withClientContext(remote_connection, (uint64_t)v8);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182D3588C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

uint64_t _CFPrefsCopyEntitlementForMessage(void *a1, uint64_t a2)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  uint64_t v9 = 0;
  int v10 = &v9;
  uint64_t v11 = 0x3052000000;
  char v12 = __Block_byref_object_copy__5;
  uint64_t v13 = __Block_byref_object_dispose__5;
  uint64_t v14 = 0;
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    xpc_object_t value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    remote_connection = value;
    if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
      __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
    }
  }
  v8[0] = off_1ECE0A5A0;
  v8[1] = 3221225472;
  uint64_t v8[2] = ___CFPrefsCopyEntitlementForMessage_block_invoke;
  v8[3] = &unk_1ECE00870;
  v8[4] = a1;
  v8[5] = &v9;
  v8[6] = a2;
  withClientContext(remote_connection, (uint64_t)v8);
  uint64_t v6 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182D35A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void log_client_activity(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    size_t v16 = 0;
    long long buffer = 0u;
    *(_OWORD *)pid = 0u;
    data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &v16);
    if (data && v16 == 32)
    {
      long long v8 = data[1];
      long long buffer = *data;
      *(_OWORD *)pid = v8;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        xpc_object_t value = xpc_dictionary_get_value(a1, "connection");
        if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
          log_client_activity_cold_1();
        }
      }
      xpc_connection_get_audit_token();
    }
    int v10 = pid[1];
    long long v25 = 0u;
    long long v26 = 0u;
    long long buffer = 0u;
    *(_OWORD *)pid = 0u;
    if (v10 != -1 && (proc_name(v10, &buffer, 0x40u) & 0x80000000) == 0)
    {
      uint64_t v11 = _CFPrefsDaemonLog();
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
      if (a3)
      {
        if (v12)
        {
          LODWORD(v16) = 67240962;
          HIDWORD(v16) = v10;
          __int16 v17 = 2082;
          p_long long buffer = &buffer;
          __int16 v19 = 2082;
          uint64_t v20 = a2;
          __int16 v21 = 2082;
          uint64_t v22 = a3;
          uint64_t v13 = "Process %{public}d (%{public}s) %{public}s for domain %{public}s";
          uint64_t v14 = v11;
          uint32_t v15 = 38;
LABEL_17:
          _os_log_debug_impl(&dword_182B90000, v14, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&v16, v15);
        }
      }
      else if (v12)
      {
        LODWORD(v16) = 67240706;
        HIDWORD(v16) = v10;
        __int16 v17 = 2082;
        p_long long buffer = &buffer;
        __int16 v19 = 2082;
        uint64_t v20 = a2;
        uint64_t v13 = "Process %{public}d (%{public}s) %{public}s";
        uint64_t v14 = v11;
        uint32_t v15 = 28;
        goto LABEL_17;
      }
    }
  }
}

void __CFXPreferencesDaemon_main(int a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if (a1 >= 1)
  {
    isCFPrefsD = 1;
    if (setiopolicy_np(9, 0, 1) < 0)
    {
      unsigned int v1 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      {
        int v2 = *__error();
        v7[0] = 67109120;
        v7[1] = v2;
        _os_log_error_impl(&dword_182B90000, v1, OS_LOG_TYPE_ERROR, "An error occurred while setting iopolicy: %{darwin.errno}d", (uint8_t *)v7, 8u);
      }
    }
    long long v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    size_t v4 = dispatch_queue_create("com.apple.cfprefsd", v3);
    signal(15, (void (__cdecl *)(int))1);
    signal(30, (void (__cdecl *)(int))1);
    __CFXPreferencesDaemon_main_sigtermHandler = (uint64_t)dispatch_source_create((dispatch_source_type_t)off_1ECE0A618, 0xFuLL, 0, v4);
    dispatch_source_set_event_handler((dispatch_source_t)__CFXPreferencesDaemon_main_sigtermHandler, &__block_literal_global_149);
    dispatch_resume((dispatch_object_t)__CFXPreferencesDaemon_main_sigtermHandler);
    unsigned int v5 = [CFPrefsDaemon alloc];
    if (__CFProcessIsRestricted()) {
      BOOL v6 = 0;
    }
    else {
      BOOL v6 = getenv("__CFPreferencesTestDaemon") != 0;
    }
    cfprefsd = (uint64_t)-[CFPrefsDaemon initWithRole:testMode:](v5, 0, v6);
    [(id)cfprefsd enterSandbox];
    __CFXPreferencesDaemon_main_sigusrHandler = (uint64_t)dispatch_source_create((dispatch_source_type_t)off_1ECE0A618, 0x1EuLL, 0, v4);
    dispatch_source_set_event_handler((dispatch_source_t)__CFXPreferencesDaemon_main_sigusrHandler, &__block_literal_global_152);
    dispatch_resume((dispatch_object_t)__CFXPreferencesDaemon_main_sigusrHandler);
    dispatch_main();
  }
  printf("cfprefsd is not intended to be used directly");
  exit(0);
}

passwd *___isRootOrRoleAccountUserName_block_invoke(passwd *result, char *a2)
{
  if (a2)
  {
    int v2 = result;
    uint64_t result = getpwnam(a2);
    if (result) {
      BOOL v3 = result->pw_uid < 0x1F5;
    }
    else {
      BOOL v3 = 0;
    }
    *(unsigned char *)(*((void *)v2->pw_class + 1) + 24) = v3;
  }
  return result;
}

void __dumpDebugInfoCallback_block_invoke(uint64_t a1)
{
  CFStringRef v2 = (const __CFString *)[*(id *)(a1 + 32) debugDump];
  CFStringAppend(*(CFMutableStringRef *)(a1 + 40), v2);
  CFRelease(v2);
  BOOL v3 = (const void *)[*(id *)(a1 + 32) copyUncanonicalizedPath];
  if (v3)
  {
    size_t v4 = v3;
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 48), v3)) {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @"\nPATH COLLISION: %@\n", v4);
    }
    else {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v4);
    }
    CFRelease(v4);
  }
}

void sub_182D36C14(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 56));
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void _CFPrefsResetManagedPreferencesStateCache()
{
  os_unfair_lock_lock((os_unfair_lock_t)&managedPreferencesLock);
  CFMutableStringRef Mutable = (__CFDictionary *)locked_getManagedStateCache_knownContainerizedManagedPrefsStates;
  if (!locked_getManagedStateCache_knownContainerizedManagedPrefsStates)
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    locked_getManagedStateCache_knownContainerizedManagedPrefsStates = (uint64_t)Mutable;
  }
  CFDictionaryRemoveAllValues(Mutable);
  uint64_t v1 = (__CFDictionary *)locked_getManagedStateCache_knownManagedPrefsStates;
  if (!locked_getManagedStateCache_knownManagedPrefsStates)
  {
    uint64_t v1 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    locked_getManagedStateCache_knownManagedPrefsStates = (uint64_t)v1;
  }
  CFDictionaryRemoveAllValues(v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&managedPreferencesLock);
}

void sub_182D36E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D36F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D373F8(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 72));
  _Unwind_Resume(a1);
}

void sub_182D37694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D3792C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D38048(_Unwind_Exception *exception_object)
{
}

void sub_182D381FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D38730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D388C8(_Unwind_Exception *exception_object)
{
}

void sub_182D389BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFPrefsSetDirectModeConnection(void *a1)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v2 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v3 = (id)v2;
  -[_CFXPreferences _replaceDirectConnection:](v2, a1);
}

_xpc_connection_s *_CFPrefsCopyDirectModeConnection()
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uid_t v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uid_t v0 = (_xpc_connection_s **)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v1 = -[_CFXPreferences _copyDaemonConnectionSettingUpIfNecessaryForRole:andUserIdentifier:](v0, 3, 0);

  return v1;
}

void sub_182D390E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

void sub_182D39114(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (!v2) {
      JUMPOUT(0x182D390A8);
    }
    JUMPOUT(0x182D390A0);
  }
  JUMPOUT(0x182D39108);
}

void _CFPrefsResetUserSessionPreferences()
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  uid_t v0 = _os_activity_create(&dword_182B90000, "Resetting CFPreferences/NSUserDefaults", (os_activity_t)off_1ECE0A638, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v0, &state);
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    char v1 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    char v1 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  -[_CFXPreferences resetUserPreferences]((uint64_t)v1);

  os_activity_scope_leave(&state);
}

void sub_182D398C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
}

uint64_t _CFPreferencesDoesNSUserDefaultsExist()
{
  return _NSUserDefaultsRegisteredAtLeastOnce;
}

id _CFPreferencesCopyStandardUserDefaults()
{
  if (_NSUserDefaultsRegisteredAtLeastOnce != 1) {
    return 0;
  }
  uid_t v0 = objc_opt_class();
  char v1 = sel_registerName("_copyStandardUserDefaultsIfPresent");

  return [v0 v1];
}

void _CFPrefsUnregisterUserDefaultsInstance(uint64_t a1)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    int v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    int v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v3 = v2;
  [v2 unregisterUserDefaultsInstance:a1];
}

__CFString *_CFXPreferencesGetByHostIdentifierString()
{
  return &stru_1ECE10768;
}

uint64_t _CFPreferencesCopyValueNoCache(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _CFPreferencesCopyValueWithContainer(a1, a2, a3, a4, 0);
}

CFDictionaryRef __CFXPreferencesCopyCurrentApplicationState()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  return __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(&v1);
}

uint64_t _CFXPreferencesCopyVolatileSourceNames()
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uid_t v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uid_t v0 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v1 = -[_CFXPreferences volatileSourceNames]((uint64_t)v0);

  return v1;
}

void _CFXPreferencesRemoveNamedVolatileSource(__CFString *a1)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v2 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v3 = (id)v2;
  -[_CFXPreferences removeVolatileSourceForName:](v2, a1);
}

CFMutableDictionaryRef _CFPrefsCopyAppDictionary(__CFString *a1)
{
  return _CFPrefsCopyAppDictionaryWithContainer(a1, 0);
}

CFMutableDictionaryRef _CFXPreferencesCopyDictionaryForApplicationPreferences()
{
  return _CFPrefsCopyAppDictionaryWithContainer(@"kCFPreferencesCurrentApplication", 0);
}

void _CFXPreferencesReplaceValuesInSourceWithBundleIDWithContainer(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v11 = (id)v10;
  -[_CFXPreferences replaceValuesInSourceForIdentifier:user:host:container:withValues:](v10, a1, a3, a4, a5, a2);
}

void _CFXPreferencesReplaceValuesInSourceWithBundleID(uint64_t a1, const __CFDictionary *a2)
{
}

void _CFPreferencesSetAppCloudSyncEnabled(uint64_t a1, int a2, __CFString *a3, const __CFString *a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v9 = (id)v8;
  -[_CFXPreferences setCloudSyncEnabled:forKey:appIdentifier:container:](v8, a2 != 0, a1, a3, a4);
}

void _CFPreferencesAppFullCloudSynchronizeWithConfiguration(__CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v9 = (id)v8;
  -[_CFXPreferences fullCloudSynchronizeForAppIdentifier:container:configurationURL:completionHandler:](v8, a1, a2, a3, a4);
}

void _CFPreferencesAppFullCloudSynchronize(__CFString *a1, const __CFString *a2, uint64_t a3)
{
}

BOOL _CFPreferencesHasAppCloudValue(uint64_t a1, __CFString *a2, const __CFString *a3, uint64_t a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  BOOL v9 = -[_CFXPreferences hasCloudValueForKey:appIdentifier:container:configurationURL:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

BOOL _CFPreferencesHasAppValue(uint64_t a1, __CFString *a2, const __CFString *a3, uint64_t a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  BOOL v9 = -[_CFXPreferences hasNonRegisteredValueForKey:appIdentifier:container:configurationURL:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void CFPreferencesAddSuitePreferencesToApp(CFStringRef applicationID, CFStringRef suiteID)
{
}

void _CFPreferencesRemoveSuitePreferencesFromAppWithContainer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    BOOL v6 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    BOOL v6 = (const os_unfair_lock *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  long long v7 = (os_unfair_lock *)v6;
  -[_CFXPreferences removeSuite:fromApp:withContainer:](v6, a2, a1, a3);
}

void CFPreferencesRemoveSuitePreferencesFromApp(CFStringRef applicationID, CFStringRef suiteID)
{
}

void _CFPreferencesAppPreload(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    if (v8)
    {
      id v9 = v8;
      +[CFPrefsSearchListSource preloadDomainsForIdentifiers:containers:cloudConfigurationURLs:count:containingPreferences:](CFPrefsSearchListSource, a1, a2, a3, a4, v8);
      uint64_t v8 = v9;
    }
  }
}

void CFPreferencesSetMultiple(CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = (const os_unfair_lock *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v11 = (os_unfair_lock *)v10;
  -[_CFXPreferences setValuesForKeys:removingValuesForKeys:identifier:user:host:container:](v10, (uint64_t)keysToSet, (uint64_t)keysToRemove, (__CFString *)applicationID, (__CFString *)userName, hostName, 0);
}

void _CFPreferencesSetAccessRestricted(__CFString *a1, int a2)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v4 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v5 = (id)v4;
  -[_CFXPreferences setAccessRestricted:forAppIdentifier:](v4, a2 != 0, a1);
}

void _CFPreferencesFlushCachesForIdentifier(__CFString *a1, const void *a2)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v4 = (_xpc_connection_s **)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v5 = v4;
  -[_CFXPreferences flushCachesForAppIdentifier:user:](v4, a1, a2);
}

void _CFPreferencesNotifyOfImpendingUserDeletion()
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uid_t v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uid_t v0 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
}

void _CFPreferencesSetFileProtectionClass(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v11 = (id)v10;
  -[_CFXPreferences setFileProtectionClass:identifier:user:host:container:](v10, a5, a1, a2, a3, a4);
}

uint64_t _CFPreferencesGetFileProtectionClass(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v9 = -[_CFXPreferences fileProtectionClassForIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void _CFPreferencesSetDaemonCacheEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v11 = v10;
  [v10 setDaemonCacheEnabled:a5 != 0 identifier:a1 user:a2 host:a3 container:a4];
}

CFArrayRef CFPreferencesCopyApplicationList(CFStringRef userName, CFStringRef hostName)
{
  BOOL v3 = CFEqual(hostName, @"kCFPreferencesCurrentHost") != 0;

  return _CFPreferencesCopyApplicationList(userName, v3);
}

CFMutableDictionaryRef _CFPreferencesCopyMultipleManaged(uint64_t a1, __CFString *a2, int a3)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    BOOL v6 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    BOOL v6 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  CFMutableDictionaryRef v7 = -[_CFXPreferences copyManagedValuesForKeys:identifier:useSystemContainer:]((uint64_t)v6, a1, a2, a3 != 0);

  return v7;
}

BOOL _CFPreferencesIsManaged()
{
  CFStringRef v0 = CFCopyUserName();
  if (_CFGetEUID()) {
    uint64_t v1 = (__CFString *)v0;
  }
  else {
    uint64_t v1 = @"kCFPreferencesAnyUser";
  }
  BOOL IsManaged = CFPreferencesIsManaged(v1, 0);
  CFRelease(v0);
  return IsManaged;
}

unint64_t _CFPreferencesWriteDomainDictionaryToPath(unint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3 = a1;
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  values = a3;
  if (a1)
  {
    SInt32 errorCode = 0;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@/%@%@", a2, a3, @".plist");
    if (!v4)
    {
      unint64_t v3 = 0;
LABEL_17:
      CFArrayRef v11 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      _CFPreferencesManagementStatusChangedForDomains();
      CFRelease(v11);
      return v3;
    }
    CFStringRef v5 = v4;
    CFURLRef v6 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, kCFURLPOSIXPathStyle, 0);
    if (!v6)
    {
      unint64_t v3 = 0;
LABEL_16:
      CFRelease(v5);
      goto LABEL_17;
    }
    CFURLRef v7 = v6;
    if (CFDictionaryGetCount((CFDictionaryRef)v3))
    {
      uint64_t v8 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFAllocatorRef)&__kCFAllocatorSystemDefault);
      CFWriteStreamOpen(v8);
      CFPropertyListWrite((CFPropertyListRef)v3, v8, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      CFWriteStreamClose(v8);
      CFDataRef v9 = (const __CFData *)CFWriteStreamCopyProperty(v8, @"kCFStreamPropertyDataWritten");
      CFRelease(v8);
      if (v9)
      {
        unint64_t v3 = CFURLWriteDataAndPropertiesToResource(v7, v9, 0, &errorCode);
        goto LABEL_7;
      }
    }
    else
    {
      bzero(buffer, 0x402uLL);
      if (CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1024))
      {
        unint64_t v3 = unlink((const char *)buffer) == 0;
        CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        if (!PathComponent) {
          goto LABEL_15;
        }
        CFDataRef v9 = PathComponent;
        bzero(buffer, 0x402uLL);
        if (CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1024)) {
          rmdir((const char *)buffer);
        }
LABEL_7:
        CFRelease(v9);
LABEL_15:
        CFRelease(v7);
        goto LABEL_16;
      }
    }
    unint64_t v3 = 0;
    goto LABEL_15;
  }
  return v3;
}

uint64_t _CFPreferencesManagementStatusChangedForDomains()
{
  _handleExternalNotification(@"com.apple.MCX._managementStatusChangedForDomains");
  notify_post("com.apple.MCX._managementStatusChangedForDomains");
  _handleExternalNotification(&stru_1ECE10768);

  return notify_post("com.apple.CFPreferences._domainsChangedExternally");
}

unint64_t _CFPreferencesWriteManagedDomain(unint64_t a1, __CFString *a2, int a3, void *a4)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  BOOL v7 = a3 != 0;
  bzero(__s, 0x400uLL);
  if (!_CFPrefsGetPathForManagedBundleID(0, a2, v7, (UInt8 *)__s)) {
    return 0;
  }
  size_t v8 = strlen(__s);
  CFURLRef v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)__s, v8, 1u);
  if (!v9) {
    return 0;
  }
  CFURLRef v10 = v9;
  CFStringRef v11 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  CFRelease(v10);
  if (!v11) {
    return 0;
  }
  unint64_t v12 = _CFPreferencesWriteDomainDictionaryToPath(a1, (uint64_t)v11, a4);
  CFRelease(v11);
  return v12;
}

unint64_t _CFPreferencesWriteManagedDomainForUser(unint64_t a1, __CFString *a2, void *a3)
{
  return _CFPreferencesWriteManagedDomain(a1, a2, 0, a3);
}

uint64_t _CFPrefsDirectModeEnabledForDomain(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  char v16 = 0;
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    size_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    size_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  BOOL v9 = CFEqual(a3, @"kCFPreferencesCurrentHost") != 0;
  v12[0] = off_1ECE0A5A0;
  v12[1] = 3221225472;
  _OWORD v12[2] = ___CFPrefsDirectModeEnabledForDomain_block_invoke;
  v12[3] = &unk_1ECE00958;
  v12[4] = &v13;
  -[_CFXPreferences withSourceForIdentifier:user:byHost:container:cloud:perform:]((uint64_t)v8, a1, a2, v9, a4, 0, (uint64_t)v12);

  uint64_t v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_182D3AB08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _handleExternalNotification(const __CFString *a1)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (_CFPrefsCurrentProcessIsCFPrefsD())
    {
      uint64_t v2 = 0;
    }
    else
    {
      if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
        dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
      }
      uint64_t v2 = (_xpc_connection_s **)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    }
    -[_CFXPreferences flushManagedSources](v2);

    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotificationWithOptions(DarwinNotifyCenter, a1, 0, 0, 0);
  }
}

uint64_t _CFPreferencesPostValuesChangedInDomains()
{
  _handleExternalNotification(&stru_1ECE10768);

  return notify_post("com.apple.CFPreferences._domainsChangedExternally");
}

uint64_t (**__CFStringEncodingGetLatin2ConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_7) {
    __CFStringEncodingPrecomposeLatinCharacter_7 = (_UNKNOWN *)a2(4);
  }
  if (a1 > 513)
  {
    switch(a1)
    {
      case 514:
        return __CFConverterISOLatin2;
      case 1042:
        return __CFConverterDOSLatin2;
      case 1281:
        return __CFConverterWinLatin2;
    }
  }
  else
  {
    switch(a1)
    {
      case 29:
        return __CFConverterMacCentEuro;
      case 36:
        return __CFConverterMacCroatian;
      case 38:
        return __CFConverterMacRomanian;
    }
  }
  return 0;
}

uint64_t __CFToMacCentEuro(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9675 < 0xFFFFDAD5) {
    return 0;
  }
  CFStringRef v5 = (unsigned __int16 *)&maccenteuro_from_uni;
  CFURLRef v6 = (unsigned __int16 *)&unk_182EDF40C;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    size_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFURLRef v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    CFStringRef v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromMacCentEuro(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = maccenteuro_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacCentEuroPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9675) >= 0xDAD5u)
    {
      CFStringRef v11 = (unsigned __int16 *)&maccenteuro_from_uni;
      unint64_t v12 = (unsigned __int16 *)&unk_182EDF40C;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          CFStringRef v11 = v14 + 2;
        }
        else
        {
          unint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFIsValidCombiningCharacterForLatin2(int a1)
{
  if ((a1 - 768) > 0x5F) {
    return 0;
  }
  else {
    return (__CFLatin2CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t __CFToMacCroatian(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      CFStringRef v4 = (unsigned __int16 *)&maccroatian_from_uni;
      CFStringRef v5 = (unsigned __int16 *)&unk_182EDF718;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          CFStringRef v4 = v7 + 2;
        }
        else
        {
          CFStringRef v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

uint64_t __CFFromMacCroatian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = maccroatian_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacCroatianPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFPreferencesRemoveSuitePreferencesFromAppWithContainer((uint64_t)applicationID, (uint64_t)suiteID, 0) = v9;
    if (!(_BYTE)v9) {
      return 0;
    }
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1792) < 0x7A0u) {
    return 0;
  }
  unint64_t v12 = (unsigned __int16 *)&maccroatian_from_uni;
  uint64_t v13 = (unsigned __int16 *)&unk_182EDF718;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    uint64_t v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0;
    }
  }
  if (v16 < v9)
  {
    unint64_t v12 = v15 + 2;
    goto LABEL_12;
  }
  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToMacRomanian(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v4 = *a2;
  if (v4 > 0x7F)
  {
    if ((unsigned __int16)(v4 + 1792) >= 0x7A0u)
    {
      uint64_t v6 = (unsigned __int16 *)&macromanian_from_uni;
      uint64_t v7 = (unsigned __int16 *)&unk_182EDFA18;
      do
      {
        uint64_t v8 = ((char *)v7 - (char *)v6) >> 3;
        unsigned int v9 = &v6[2 * v8];
        unsigned int v10 = *v9;
        if (v10 <= v4)
        {
          if (v10 >= v4)
          {
            LOBYTE(v4) = v6[2 * v8 + 1];
            goto LABEL_2;
          }
          uint64_t v6 = v9 + 2;
        }
        else
        {
          uint64_t v7 = v9 - 2;
        }
      }
      while (v6 <= v7);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a4 = v4;
    return 1;
  }
}

BOOL __CFFromMacRomanian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = macromanian_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacRomanianLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    int v4 = *a2++;
    if (v4 != 806) {
      ++result;
    }
  }
  return result;
}

uint64_t __CFFromMacRomanianLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    int v4 = *a2++;
    uint64_t v5 = (1 << (v4 + 81)) & 0x1800000010001;
    if ((v4 - 175) > 0x30 || v5 == 0) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    result += v7;
  }
  return result;
}

uint64_t __CFToMacRomanianPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  if (a3 < 2 || a2[1] != 806)
  {
    unsigned int v12 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
    if (v12 <= 0x7F)
    {
      LOBYTE(v1__postAndResetMidnight(1, 1) = v12;
      if (!(_BYTE)v12) {
        return 0;
      }
      goto LABEL_10;
    }
    if ((unsigned __int16)(v12 + 1792) < 0x7A0u) {
      return 0;
    }
    uint64_t v13 = (unsigned __int16 *)&macromanian_from_uni;
    uint64_t v14 = (unsigned __int16 *)&unk_182EDFA18;
    while (1)
    {
      uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
      unsigned int v16 = &v13[2 * v15];
      unsigned int v17 = *v16;
      if (v17 <= v12)
      {
        if (v17 >= v12)
        {
          int v11 = LOBYTE(v13[2 * v15 + 1]);
          if (!v11) {
            return 0;
          }
LABEL_10:
          if (a5) {
LABEL_11:
          }
            *a4 = v11;
LABEL_12:
          *a6 = 1;
          return 2;
        }
        uint64_t v13 = v16 + 2;
      }
      else
      {
        uint64_t v14 = v16 - 2;
      }
      if (v13 > v14) {
        return 0;
      }
    }
  }
  uint64_t result = 0;
  unsigned int v10 = *a2;
  if (v10 <= 0x72)
  {
    if (v10 == 83)
    {
      if (a5)
      {
        LOBYTE(v1__postAndResetMidnight(1, 1) = -81;
        goto LABEL_11;
      }
    }
    else
    {
      if (v10 != 84) {
        return result;
      }
      if (a5)
      {
        LOBYTE(v1__postAndResetMidnight(1, 1) = -34;
        goto LABEL_11;
      }
    }
    goto LABEL_12;
  }
  if (v10 == 115)
  {
    if (a5)
    {
      LOBYTE(v1__postAndResetMidnight(1, 1) = -65;
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  if (v10 == 116)
  {
    if (a5)
    {
      LOBYTE(v1__postAndResetMidnight(1, 1) = -33;
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  return result;
}

uint64_t __CFToDOSLatin2(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if (a2 - 9633 >= 0xFFFFDAFF)
    {
      uint64_t v5 = (unsigned __int16 *)&cp852_from_uni;
      uint64_t v6 = (unsigned __int16 *)&unk_182EDFD18;
      do
      {
        uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
        uint64_t v8 = &v5[2 * v7];
        unsigned int v9 = *v8;
        if (v9 <= a2)
        {
          if (v9 >= a2)
          {
LABEL_19:
            char v3 = v5[2 * v7 + 1];
            goto LABEL_3;
          }
          uint64_t v5 = v8 + 2;
        }
        else
        {
          uint64_t v6 = v8 - 2;
        }
      }
      while (v5 <= v6);
      if (a2 - 734 >= 0xFFFFFDC2)
      {
        uint64_t v5 = (unsigned __int16 *)&latin2_from_uni;
        unsigned int v10 = (unsigned __int16 *)&unk_182EDFE98;
        do
        {
          uint64_t v7 = ((char *)v10 - (char *)v5) >> 3;
          int v11 = &v5[2 * v7];
          unsigned int v12 = *v11;
          if (v12 <= a2)
          {
            if (v12 >= a2) {
              goto LABEL_19;
            }
            uint64_t v5 = v11 + 2;
          }
          else
          {
            unsigned int v10 = v11 - 2;
          }
        }
        while (v5 <= v10);
      }
    }
    return 0;
  }
  else
  {
    char v3 = a2;
LABEL_3:
    *a3 = v3;
    return 1;
  }
}

BOOL __CFFromDOSLatin2(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = cp852_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  int v10 = __CFToDOSLatin2(v9, v9, &v13);
  uint64_t result = 0;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToWinLatin2(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_19;
  }
  if (a2 - 8483 < 0xFFFFDF83)
  {
LABEL_10:
    if (a2 - 734 >= 0xFFFFFDC2)
    {
      int v4 = (unsigned __int16 *)&latin2_from_uni;
      uint64_t v9 = (unsigned __int16 *)&unk_182EDFE98;
      do
      {
        uint64_t v6 = ((char *)v9 - (char *)v4) >> 3;
        int v10 = &v4[2 * v6];
        unsigned int v11 = *v10;
        if (v11 <= a2)
        {
          if (v11 >= a2) {
            goto LABEL_18;
          }
          int v4 = v10 + 2;
        }
        else
        {
          uint64_t v9 = v10 - 2;
        }
      }
      while (v4 <= v9);
    }
    return 0;
  }
  int v4 = (unsigned __int16 *)&cp1250_from_uni;
  uint64_t v5 = (unsigned __int16 *)&unk_182EE0040;
  while (1)
  {
    uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
    uint64_t v7 = &v4[2 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    uint64_t v5 = v7 - 2;
LABEL_9:
    if (v4 > v5) {
      goto LABEL_10;
    }
  }
  if (v8 < a2)
  {
    int v4 = v7 + 2;
    goto LABEL_9;
  }
LABEL_18:
  char v3 = v4[2 * v6 + 1];
LABEL_19:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWinLatin2(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = cp1250_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  int v10 = __CFToWinLatin2(v9, v9, &v13);
  uint64_t result = 0;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToISOLatin2(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 734 < 0xFFFFFDC2) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&latin2_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182EDFE98;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromISOLatin2(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0x9F) {
    LOWORD(a2) = latin2_to_uni[a2 - 160];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 734) >= 0xFDC2u)
    {
      unsigned int v11 = (unsigned __int16 *)&latin2_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182EDFE98;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          unsigned int v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t (**__CFStringEncodingGetThaiConverterDefinition(int a1))()
{
  uint64_t v1 = __CFConverterDOSThai;
  uint64_t v2 = __CFConverterISOLatinThai;
  if (a1 != 523) {
    uint64_t v2 = 0;
  }
  if (a1 != 1053) {
    uint64_t v1 = v2;
  }
  if (a1 == 21) {
    return __CFConverterMacThai;
  }
  else {
    return v1;
  }
}

uint64_t __CFToDOSThai(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8365 < 0xFFFFDFF3) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&DOSThai_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182EE0388;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSThai(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSThai_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToThaiPrecompose(uint64_t a1, _WORD *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  if (*a2 != 3661 || a2[1] != 3634) {
    return 0;
  }
  if (a5) {
    *a4 = -45;
  }
  *a6 = 1;
  return 2;
}

BOOL __CFIsValidCombiningCharacterForThai(int a1)
{
  return a1 == 3634;
}

uint64_t __CFToISOLatinThai(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 3676 < 0xFFFFFFA5) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&ISOLatinThai_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182EE05E4;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromISOLatinThai(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    a2 = ISOLatinThai_to_uni[a2 - 161];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacThai(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v4 = *a2;
  if (v4 <= 0x7F) {
    goto LABEL_2;
  }
  if (a3 < 2 || (unsigned __int16 v6 = a2[1] + 1933, v6 > 2u))
  {
    if (v4 - 8483 >= 0xFFFFDF7D)
    {
      uint64_t v13 = (unsigned __int16 *)&MacThai_from_uni;
      uint64_t v14 = (unsigned __int16 *)&unk_182EE088A;
      do
      {
        uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
        unsigned int v16 = &v13[2 * v15];
        unsigned int v17 = *v16;
        if (v17 <= v4)
        {
          if (v17 >= v4)
          {
            LOBYTE(v4) = v13[2 * v15 + 1];
LABEL_2:
            *a4 = v4;
            return 1;
          }
          uint64_t v13 = v16 + 2;
        }
        else
        {
          uint64_t v14 = v16 - 2;
        }
      }
      while (v13 <= v14);
    }
    return 0;
  }
  uint64_t v7 = (__int16)v6;
  unsigned int v8 = (char *)*(&off_1ECE00F40 + (__int16)v6);
  if (*(unsigned __int16 *)v8 > v4) {
    return 0;
  }
  unsigned int v9 = (unsigned __int16 *)&v8[4 * qword_182EE0990[v7]];
  if (*v9 < v4) {
    return 0;
  }
  while (1)
  {
    uint64_t v10 = ((char *)v9 - v8) >> 3;
    unsigned int v11 = (unsigned __int16 *)&v8[4 * v10];
    unsigned int v12 = *v11;
    if (v12 <= v4) {
      break;
    }
    unsigned int v9 = v11 - 2;
LABEL_11:
    uint64_t result = 0;
    if (v8 > (char *)v9) {
      return result;
    }
  }
  if (v12 < v4)
  {
    unsigned int v8 = (char *)(v11 + 2);
    goto LABEL_11;
  }
  *a4 = v8[4 * v10 + 2];
  return 2;
}

BOOL __CFFromMacThai(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    a2 = MacThai_to_uni[a2 - 128];
    BOOL result = a2 != 65533;
  }
  else
  {
    BOOL result = 1;
  }
  *a3 = a2;
  return result;
}

uint64_t __CFToMacThaiLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0; a3; --a3)
  {
    __int16 v4 = *a2++;
    if ((unsigned __int16)(v4 + 1930) < 0xFFFDu) {
      ++result;
    }
  }
  return result;
}

uint64_t __CFFromMacThaiLen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 & ~(a3 >> 63);
}

void *__mdict_keysOfEntriesWithOptionsPassingTest_block_invoke(void *result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result[6] + 8 * a2);
  if (v2) {
    BOOL v3 = v2 == &___NSDictionaryM_DeletedMarker;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    __int16 v4 = result;
    uint64_t v5 = (void *)_CFAutoreleasePoolPush();
    if ((*(unsigned int (**)(void))(v4[5] + 16))())
    {
      os_unfair_lock_lock((os_unfair_lock_t)v4[8]);
      [(id)v4[4] addObject:v2];
      os_unfair_lock_unlock((os_unfair_lock_t)v4[8]);
    }
    return _CFAutoreleasePoolPop(v5);
  }
  return result;
}

void sub_182D3C300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182D3C6E8(_Unwind_Exception *exception_object)
{
}

void sub_182D3C920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 cow_copy_instance_2(uint64_t a1, int a2, uint64_t a3, int a4)
{
  __int16 v4 = &OBJC_IVAR_____NSFrozenDictionaryM_cow;
  if (a2 == 1) {
    uint64_t v5 = &OBJC_IVAR_____NSDictionaryM_cow;
  }
  else {
    uint64_t v5 = &OBJC_IVAR_____NSFrozenDictionaryM_cow;
  }
  if (a2 == 1) {
    unsigned __int16 v6 = &OBJC_IVAR_____NSDictionaryM_storage;
  }
  else {
    unsigned __int16 v6 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + *v5));
  uint64_t v8 = *v6;
  if (a4 == 1)
  {
    __int16 v4 = &OBJC_IVAR_____NSDictionaryM_cow;
    unsigned int v9 = &OBJC_IVAR_____NSDictionaryM_storage;
  }
  else
  {
    unsigned int v9 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  }
  atomic_store(v7, (unint64_t *)(a3 + *v4));
  __n128 result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v9) = result;
  return result;
}

uint64_t cow_copy_storage_2(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if ((v2 & 0x1FFFFFF00000000) == 0)
  {
    uint64_t v5 = 0;
    *(void *)(a1 + 16) = v2 & 0x3FFFFFFFFFFFFFFLL;
LABEL_18:
    uint64_t result = 1;
    goto LABEL_19;
  }
  uint64_t v3 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((v2 >> 55) & 0x1F8));
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 16 * v3, 0xEEB3C61BuLL);
  uint64_t v5 = result;
  if (result)
  {
    if (v2 >> 58)
    {
      uint64_t v6 = 0;
      uint64_t v7 = *(void *)(a1 + 8);
      do
      {
        unint64_t v8 = *(void *)(v7 + 8 * v6);
        if (v8)
        {
          *(void *)(v5 + 8 * v6) = v8;
          if ((_UNKNOWN *)v8 != &___NSDictionaryM_DeletedMarker && (v8 & 0x8000000000000000) == 0) {
            id v9 = (id)v8;
          }
        }
        ++v6;
      }
      while (v3 != v6);
      uint64_t v10 = 8 * v3;
      do
      {
        unint64_t v11 = *(void *)(v7 + v10);
        if (v11)
        {
          if ((v11 & 0x8000000000000000) == 0) {
            id v12 = (id)v11;
          }
          *(void *)(v5 + v1_CFPreferencesRemoveSuitePreferencesFromAppWithContainer((uint64_t)applicationID, (uint64_t)suiteID, 0) = v11;
        }
        v10 += 8;
        --v3;
      }
      while (v3);
    }
    goto LABEL_18;
  }
LABEL_19:
  *(void *)(a1 + 8) = v5;
  return result;
}

uint64_t cow_set_cow_2(uint64_t result, unint64_t a2)
{
  return result;
}

void *__mdict_enumerateKeysAndObjectsWithOptionsUsingBlock_block_invoke(void *result, uint64_t a2)
{
  unint64_t v2 = *(void **)(result[5] + 8 * a2);
  if (v2) {
    BOOL v3 = v2 == &___NSDictionaryM_DeletedMarker;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    __int16 v4 = result;
    uint64_t v5 = (void *)_CFAutoreleasePoolPush();
    __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(v4[4]);
    return _CFAutoreleasePoolPop(v5);
  }
  return result;
}

void *__mdict_keyOfEntryWithOptionsPassingTest_block_invoke(void *result, uint64_t a2, unsigned char *a3)
{
  BOOL v3 = *(void **)(result[6] + 8 * a2);
  if (v3) {
    BOOL v4 = v3 == &___NSDictionaryM_DeletedMarker;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v6 = result;
    uint64_t v7 = (void *)_CFAutoreleasePoolPush();
    if ((*(unsigned int (**)(void))(v6[4] + 16))())
    {
      atomic_store((unint64_t)v3, (unint64_t *)(*(void *)(v6[5] + 8) + 24));
      *a3 = 1;
    }
    return _CFAutoreleasePoolPop(v7);
  }
  return result;
}

uint64_t _compare_clumpiness_2(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void *__CFGenerateReport()
{
  uint64_t v66 = *(void *)off_1ECE0A5B0;
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2020000000;
  uint64_t v33 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000;
  uint64_t v29 = 1;
  v21[0] = off_1ECE0A5A0;
  v21[1] = 3221225472;
  uint64_t v22 = ____CFGenerateReport_block_invoke;
  uint64_t v23 = &unk_1ECE00FD8;
  unsigned int v24 = &v30;
  long long v25 = &v26;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v34 = 0u;
  long long v35 = 0u;
  int v0 = backtrace(v34, 128);
  uint64_t v1 = backtrace_symbols(v34, v0);
  unint64_t v2 = 0;
  if (v0 > 0xFFFFFFFA)
  {
    BOOL v4 = 0;
    goto LABEL_14;
  }
  unint64_t v3 = v0 + 5;
  BOOL v4 = 0;
  if (v3 >> 61) {
    goto LABEL_14;
  }
  uint64_t v5 = (char *)malloc_type_malloc(8 * v3, 0x10040436913F5uLL);
  BOOL v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  v31[3] = (uint64_t)v5;
  time_t v20 = time(0);
  if (v20 == -1) {
    goto LABEL_12;
  }
  int v6 = asprintf((char **)v31[3], "%s%25s", "Date/Time:     ", "");
  if (v22((uint64_t)v21, v6)) {
    goto LABEL_12;
  }
  ctime_r(&v20, (char *)(*(void *)(v31[3] - 8) + 15));
  size_t v19 = 0;
  if (sysctlbyname("kern.osversion", 0, &v19, 0, 0)
    || (int v7 = asprintf((char **)v31[3], "%s%*s", "OS Version:    ", v19, ""), v22((uint64_t)v21, v7))
    || sysctlbyname("kern.osversion", (void *)(*(void *)(v31[3] - 8) + 15), &v19, 0, 0)
    || (*(unsigned char *)(*(void *)(v31[3] - 8) + v19 + 14) = 10,
        unint64_t v8 = (char **)v31[3],
        id v9 = getprogname(),
        int v10 = asprintf(v8, "%s%s\n", "Application:   ", v9),
        v22((uint64_t)v21, v10))
    || (int v11 = asprintf((char **)v31[3], "\n"), v22((uint64_t)v21, v11))
    || (int v12 = asprintf((char **)v31[3], "Backtrace:\n"), v22((uint64_t)v21, v12)))
  {
LABEL_12:
    unint64_t v2 = 0;
    goto LABEL_14;
  }
  if (v0 < 1)
  {
LABEL_25:
    unint64_t v2 = malloc_type_malloc(v27[3], 0xB346118AuLL);
    if (v2 && (unint64_t)v4 < v31[3])
    {
      unsigned int v18 = v4;
      do
      {
        v18 += 8;
        __stpcpy_chk();
      }
      while ((unint64_t)v18 < v31[3]);
    }
LABEL_14:
    if (!v1) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v15 = v0;
  unsigned int v16 = (const char **)v1;
  while (1)
  {
    int v17 = asprintf((char **)v31[3], "%s\n", *v16);
    if (v22((uint64_t)v21, v17)) {
      break;
    }
    ++v16;
    if (!--v15) {
      goto LABEL_25;
    }
  }
  unint64_t v2 = 0;
LABEL_15:
  free(v1);
LABEL_16:
  if (v4)
  {
    while (1)
    {
      unint64_t v13 = v31[3];
      if ((unint64_t)v4 >= v13) {
        break;
      }
      v31[3] = v13 - 8;
      free(*(void **)(v13 - 8));
    }
    free(v4);
  }
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v2;
}

void sub_182D3D06C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void bufferWrite_0(uint64_t a1, unsigned char *__src, uint64_t a3)
{
  if (a3)
  {
    size_t v3 = a3;
    if (a3 < 8144)
    {
      int v6 = *(_DWORD *)(a1 + 40);
      if (8144 - v6 >= a3) {
        size_t v7 = a3;
      }
      else {
        size_t v7 = 8144 - v6;
      }
      if (*(void *)a1 || *(void *)(a1 + 8))
      {
        uint64_t v8 = v6;
        switch(v7)
        {
          case 1uLL:
            goto LABEL_15;
          case 2uLL:
            goto LABEL_14;
          case 3uLL:
            goto LABEL_13;
          case 4uLL:
            *(unsigned char *)(v6 + a1 + 47) = __src[3];
            int v6 = *(_DWORD *)(a1 + 40);
LABEL_13:
            *(unsigned char *)(a1 + v6 + 46) = __src[2];
            int v6 = *(_DWORD *)(a1 + 40);
LABEL_14:
            *(unsigned char *)(a1 + v6 + 45) = __src[1];
            uint64_t v8 = *(int *)(a1 + 40);
LABEL_15:
            *(unsigned char *)(a1 + v8 + 44) = *__src;
            break;
          default:
            memmove((void *)(a1 + v6 + 44), __src, v7);
            break;
        }
      }
      int v9 = *(_DWORD *)(a1 + 40) + v7;
      *(_DWORD *)(a1 + 4_CFPreferencesRemoveSuitePreferencesFromAppWithContainer((uint64_t)applicationID, (uint64_t)suiteID, 0) = v9;
      if (v9 == 8144)
      {
        writeBytes_0(a1, (void *)(a1 + 44), 8144);
        if (*(void *)a1 || *(void *)(a1 + 8))
        {
          v3 -= v7;
          memmove((void *)(a1 + 44), &__src[v7], v3);
        }
        else
        {
          LODWORD(v3) = v3 - v7;
        }
        *(_DWORD *)(a1 + 4_CFPreferencesRemoveSuitePreferencesFromAppWithContainer((uint64_t)applicationID, (uint64_t)suiteID, 0) = v3;
      }
    }
    else
    {
      writeBytes_0(a1, (void *)(a1 + 44), *(int *)(a1 + 40));
      *(_DWORD *)(a1 + 4_CFPreferencesRemoveSuitePreferencesFromAppWithContainer((uint64_t)applicationID, (uint64_t)suiteID, 0) = 0;
      writeBytes_0(a1, __src, v3);
    }
  }
}

void writeBytes_0(uint64_t a1, void *__src, uint64_t __len)
{
  if (__len >= 1)
  {
    uint64_t v14 = v5;
    uint64_t v15 = v4;
    uint64_t v16 = v3;
    if (!*(void *)(a1 + 24))
    {
      uint64_t v12 = *(void *)(a1 + 8);
      if (v12)
      {
        uint64_t v13 = *(void *)(a1 + 32);
        if (__CFADD__(__len, v13) || *(void *)(a1 + 16) < (unint64_t)(v13 + __len))
        {
          *(void *)(a1 + 24) = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because databytes is full.", v6, v14, v15, v16, v7, v8);
          return;
        }
        memmove((void *)(v12 + v13), __src, __len);
      }
      if (*(void *)a1) {
        CFDataAppendBytes(*(CFMutableDataRef *)a1, (const UInt8 *)__src, __len);
      }
      *(void *)(a1 + 32) += __len;
    }
  }
}

__CFString *_CFGetPlatformName()
{
  return @"iphoneos";
}

__CFString *_CFGetAlternatePlatformName()
{
  return @"macos";
}

uint64_t _CFBundleSupportedPlatformName(const __CFString *a1, CFRange rangeToSearch)
{
  return CFStringFindWithOptions(a1, @"iphoneos", rangeToSearch, 8uLL, 0);
}

CFMutableDictionaryRef _CFBundleLoadLimitedInfoDictionary(uint64_t a1, const __CFSet *a2)
{
  v4[1] = *(CFTypeRef *)off_1ECE0A5B0;
  if (*(void *)(a1 + 24)) {
    _CFBundleLoadLimitedInfoDictionary_cold_2();
  }
  v4[0] = 0;
  CFMutableDictionaryRef result = _CFBundleCopyInfoDictionaryInDirectoryWithVersion((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFURLRef *)(a1 + 16), v4, a2, *(unsigned __int8 *)(a1 + 55), *(unsigned __int8 *)(a1 + 53));
  *(void *)(a1 + 24) = result;
  if (*(void *)(a1 + 216)) {
    _CFBundleLoadLimitedInfoDictionary_cold_1();
  }
  *(CFTypeRef *)(a1 + 216) = v4[0];
  return result;
}

uint64_t _CFBundleGetPackageInfoInDirectory(int a1, CFURLRef baseURL, int *a3, _DWORD *a4)
{
  return _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(baseURL, 0, a3, a4);
}

Boolean CFBundleGetPackageInfoInDirectory(CFURLRef url, UInt32 *packageType, UInt32 *packageCreator)
{
  return _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(url, 0, (int *)packageType, packageCreator);
}

void _CFBundleReleaseStringsSources_0(uint64_t a1)
{
  unint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  int v9 = *(const void **)(a1 + 56);
  if (v9)
  {
    CFRelease(v9);
  }
}

CFDictionaryRef _CFBundleCreateFilteredInfoPlist(uint64_t a1, void *a2, char a3)
{
  v17[1] = *(void **)off_1ECE0A5B0;
  CFURLRef v6 = (const __CFURL *)_CFBundleCopyInfoPlistURL(a1);
  if (v6)
  {
    CFURLRef v7 = v6;
    uint64_t v8 = *(unsigned __int8 *)(a1 + 55);
    CFURLRef v9 = CFURLCopyAbsoluteURL(v6);
    int v10 = (__CFString *)CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
    CFRelease(v9);
    if (v10
      && (size_t v16 = 0,
          v17[0] = 0,
          int v11 = a3 & 1,
          int v12 = _CFReadMappedFromFile(v10, v11, 0, v17, (off_t *)&v16, 0),
          CFRelease(v10),
          v12))
    {
      CFDataRef v13 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v17[0], v16, (CFAllocatorRef)&__kCFAllocatorNull);
      FilteredInfoPlistWithCFDataRef Data = (void *)_CFBundleCreateFilteredInfoPlistWithData(v13, a2, v8, 0, (uint64_t)v7);
      CFRelease(v13);
      if (v11) {
        munmap(v17[0], v16);
      }
      else {
        free(v17[0]);
      }
    }
    else
    {
      FilteredInfoPlistWithCFDataRef Data = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    CFRelease(v7);
    return (CFDictionaryRef)FilteredInfoPlistWithData;
  }
  else
  {
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

CFDictionaryRef _CFBundleCreateFilteredLocalizedInfoPlist(uint64_t a1, void *a2, void *a3, char a4)
{
  values[1] = *(void **)off_1ECE0A5B0;
  values[0] = a3;
  if (a1)
  {
    if (a3) {
      CFArrayRef v7 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
    }
    else {
      CFArrayRef v7 = 0;
    }
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    _CFBundleGetStringsSources(a1, a4 & 1, @"InfoPlist", v7, (uint64_t)&v18);
    if (v7) {
      CFRelease(v7);
    }
    CFDataRef v9 = (const __CFData *)v19;
    if ((void)v19)
    {
      uint64_t v10 = *(unsigned __int8 *)(a1 + 55);
      uint64_t v11 = v18;
      int v12 = a2;
      CFDataRef v13 = 0;
    }
    else
    {
      CFDataRef v9 = (const __CFData *)*((void *)&v21 + 1);
      uint64_t v10 = *(unsigned __int8 *)(a1 + 55);
      CFDataRef v13 = values[0];
      int v12 = a2;
      uint64_t v11 = 0;
    }
    FilteredInfoPlistWithCFDataRef Data = (const __CFDictionary *)_CFBundleCreateFilteredInfoPlistWithData(v9, v12, v10, v13, v11);
    v16[2] = v20;
    v16[3] = v21;
    uint64_t v17 = v22;
    v16[0] = v18;
    v16[1] = v19;
    _CFBundleReleaseStringsSources_0((uint64_t)v16);
    if (!FilteredInfoPlistWithData) {
      return 0;
    }
    CFMutableDictionaryRef v15 = _parseBundleStrings(a1, FilteredInfoPlistWithData);
    CFRelease(FilteredInfoPlistWithData);
    return v15;
  }
  else
  {
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

CFTypeRef _CFBundleCreateFilteredInfoPlistWithData(const __CFData *a1, void *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  v23[5] = *(void *)off_1ECE0A5B0;
  CFSetApply(a2, (uint64_t)&__block_literal_global_165);
  CFIndex Count = CFSetGetCount((CFSetRef)a2);
  CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
  v23[0] = off_1ECE0A5A0;
  v23[1] = 0x40000000;
  void v23[2] = ___CFBundleCreateFilteredInfoPlistWithData_block_invoke_2;
  v23[3] = &__block_descriptor_tmp_185;
  v23[4] = Mutable;
  CFSetApply(a2, (uint64_t)v23);
  if (a4)
  {
    CFIndex v11 = CFSetGetCount(Mutable);
    CFMutableSetRef v12 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, &kCFTypeSetCallBacks);
    v22[0] = off_1ECE0A5A0;
    v22[1] = 0x40000000;
    unsigned char v22[2] = ___CFBundleCreateFilteredInfoPlistWithData_block_invoke_3;
    v22[3] = &__block_descriptor_tmp_189;
    v22[4] = a4;
    v22[5] = v12;
    CFSetApply(Mutable, (uint64_t)v22);
    CFRelease(Mutable);
    CFSetRef Mutable = v12;
  }
  CFTypeRef cf = 0;
  if (_CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, 1, Mutable, &cf, 0))BOOL v13 = cf == 0; {
  else
  }
    BOOL v13 = 1;
  if (v13) {
    goto LABEL_14;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFTypeID v15 = CFGetTypeID(cf);
  size_t v16 = (void *)cf;
  if (TypeID != v15)
  {
    CFRelease(cf);
    long long v19 = _CFBundleResourceLogger();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      _CFBundleCreateFilteredInfoPlistWithData_cold_1(a5, (uint64_t)a2, v19);
    }
LABEL_14:
    CFTypeRef cf = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    goto LABEL_18;
  }
  if (a4)
  {
    CFArrayRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)cf, a4);
    if (Value && (size_t v16 = Value, v18 = CFDictionaryGetTypeID(), v18 == CFGetTypeID(v16)))
    {
      CFRetain(v16);
      CFRelease(cf);
    }
    else
    {
      CFRelease(cf);
      size_t v16 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    CFTypeRef cf = v16;
  }
  _CFBundleInfoPlistProcessInfoDictionary(v16);
LABEL_18:
  CFRelease(Mutable);
  return cf;
}

void _CFBundleLogLoadingInfoPlistError(uint64_t a1, CFErrorRef err)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  CFErrorDomain Domain = CFErrorGetDomain(err);
  CFIndex Code = CFErrorGetCode(err);
  CFURLRef v6 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    int v7 = 134349570;
    uint64_t v8 = a1;
    __int16 v9 = 2114;
    CFErrorDomain v10 = Domain;
    __int16 v11 = 2050;
    CFIndex v12 = Code;
    _os_log_error_impl(&dword_182B90000, v6, OS_LOG_TYPE_ERROR, "There was an error parsing the Info.plist for the bundle at URL <%{public}p>: %{public}@ - %{public}ld", (uint8_t *)&v7, 0x20u);
  }
}

void OUTLINED_FUNCTION_0_22(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

uint64_t _CFPrefsSetSynchronizeIsSynchronous(uint64_t result)
{
  _CFPrefsSynchronizeIsSynchronous = result != 0;
  return result;
}

void _CFPrefsImpersonateApplicationWithIdentifierAndPID()
{
  int v0 = _CFOSLog();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_FAULT)) {
    _CFPrefsImpersonateApplicationWithIdentifierAndPID_cold_1();
  }
}

uint64_t _CFPrefsImpersonateApplicationWithIdentifierAndAuditToken(uint64_t a1, long long *a2)
{
  long long v2 = a2[1];
  _CFPrefsAuditTokenToImpersonate = *a2;
  *(_OWORD *)&qword_1EC094024 = v2;
  return _CFPrefsImpersonateApplicationWithIdentifierAndContainerDataPath(a1, 0);
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

uint64_t _CFPrefSetInvalidPropertyListDeletionEnabled(uint64_t result)
{
  atomic_store(result != 0, requestInvalidPropertyListDeletion);
  return result;
}

void sub_182D3EB5C(_Unwind_Exception *a1)
{
}

void sub_182D3F3EC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 104), 8);
  _Unwind_Resume(a1);
}

uint64_t _approximateSizeOfPlistValue(__CFString *cf, void *a2, CFIndex *a3)
{
  uint64_t v29 = *(void *)off_1ECE0A5B0;
  if (a2 && a3) {
    _approximateSizeOfPlistValue_cold_1();
  }
  if (!cf) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000;
  uint64_t v28 = 0;
  switch(v6)
  {
    case 7uLL:
      CFIndex Length = CFStringGetLength(cf);
      CFIndex usedBufLen = 0;
      v30.CFIndex location = 0;
      v30.size_t length = Length;
      if (CFStringGetBytes(cf, v30, 0x600u, 0, 0, 0, 0, &usedBufLen)) {
        BOOL v8 = usedBufLen == Length;
      }
      else {
        BOOL v8 = 0;
      }
      char v9 = !v8;
      CFIndex v10 = Length << v9;
      v26[3] = v10;
      if (a2)
      {
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"string value, approximate encoded size: %ld", v10);
        goto LABEL_31;
      }
      break;
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
      break;
    case 0x10uLL:
      if (a2)
      {
        uint64_t v13 = @"deleted value";
        goto LABEL_34;
      }
      break;
    case 0x12uLL:
      CFIndex usedBufLen = 0;
      p_CFIndex usedBufLen = &usedBufLen;
      if (a3) {
        p_CFIndex usedBufLen = a3;
      }
      v23[0] = off_1ECE0A5A0;
      v23[1] = 3221225472;
      void v23[2] = ___approximateSizeOfPlistValue_block_invoke;
      v23[3] = &unk_1ECE01340;
      v23[4] = &v25;
      v23[5] = p_usedBufLen;
      CFDictionaryApply(cf, (uint64_t)v23);
      if (a2)
      {
        CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)cf);
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"dictionary value, count: %ld, total nested objects: %ld, approximate encoded size: %ld", Count, usedBufLen, v26[3]);
        goto LABEL_31;
      }
      break;
    case 0x13uLL:
      CFIndex usedBufLen = 0;
      CFIndex v17 = CFArrayGetCount((CFArrayRef)cf);
      CFTypeID v18 = &usedBufLen;
      if (a3) {
        CFTypeID v18 = a3;
      }
      v22[0] = off_1ECE0A5A0;
      v22[1] = 3221225472;
      unsigned char v22[2] = ___approximateSizeOfPlistValue_block_invoke_2;
      v22[3] = &unk_1ECDFFC80;
      v22[4] = &v25;
      v22[5] = v18;
      CFArrayApply((uint64_t)cf, 0, v17, (uint64_t)v22);
      if (a2)
      {
        CFIndex v19 = CFArrayGetCount((CFArrayRef)cf);
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"array value, count: %ld, tested nested objects: %ld, approximate encoded size: %ld", v19, usedBufLen, v26[3]);
        goto LABEL_31;
      }
      break;
    case 0x14uLL:
      CFIndex v20 = CFDataGetLength((CFDataRef)cf);
      v26[3] = v20;
      if (a2)
      {
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"data value, size: %ld", v20);
LABEL_31:
        *a2 = v11;
      }
      break;
    case 0x15uLL:
      uint64_t v28 = 1;
      if (a2)
      {
        uint64_t v13 = @"BOOLean value";
        goto LABEL_34;
      }
      break;
    case 0x16uLL:
      CFIndex ByteSize = CFNumberGetByteSize((CFNumberRef)cf);
      v26[3] = ByteSize;
      if (a2)
      {
        uint64_t v13 = @"number value";
        goto LABEL_34;
      }
      break;
    default:
      if (v6 == 42)
      {
        uint64_t v28 = 8;
        if (a2)
        {
          uint64_t v13 = @"date value";
LABEL_34:
          *a2 = v13;
        }
      }
      break;
  }
  if (a3) {
    ++*a3;
  }
  uint64_t v12 = v26[3];
  _Block_object_dispose(&v25, 8);
  return v12;
}

void sub_182D3F98C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 72), 8);
  _Unwind_Resume(a1);
}

uint64_t _compareSizes(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = 1;
  if (a1 >= a2) {
    uint64_t v2 = -1;
  }
  if (a1 == a2) {
    return 0;
  }
  else {
    return v2;
  }
}

void *_CFPrefsTestOversizeWarning(const void *a1, const void **a2, const void **a3, CFIndex a4)
{
  uint64_t v4 = -[_CFPrefsOversizedPlistDescription initWithDict:setKeys:andValues:count:]([_CFPrefsOversizedPlistDescription alloc], a1, a2, a3, a4);

  return v4;
}

uint64_t ___approximateSizeOfPlistValue_block_invoke(uint64_t a1, CFTypeRef cf, const void *a3)
{
  uint64_t v5 = _approximateSizeOfPlistValue(cf);
  uint64_t result = _approximateSizeOfPlistValue(a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += result + v5;
  return result;
}

uint64_t ___approximateSizeOfPlistValue_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  uint64_t result = _approximateSizeOfPlistValue(cf);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += result;
  return result;
}

void OUTLINED_FUNCTION_0_23(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_3_3(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_7_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

uint64_t (**__CFStringEncodingGetGreekConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_8)
  {
    __CFStringEncodingPrecomposeLatinCharacter_8 = (_UNKNOWN *)a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_5 = (_UNKNOWN *)a2(3);
  }
  if (a1 > 1028)
  {
    if (a1 != 1029)
    {
      if (a1 == 1283) {
        return __CFConverterWindowsGreek;
      }
      return 0;
    }
    return __CFConverterDOSGreek;
  }
  else
  {
    if (a1 != 6)
    {
      if (a1 == 519) {
        return __CFConverterISOLatinGreek;
      }
      return 0;
    }
    return __CFConverterMacGreek;
  }
}

uint64_t __CFToISOLatinGreek(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8218 < 0xFFFFE089) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)&ISOLatinGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_182EE0E08;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    BOOL v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromISOLatinGreek(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    a2 = ISOLatinGreek_to_uni[a2 - 161];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToISOLatinGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  v16[0] = 0;
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 8218) >= 0xE089u)
    {
      CFStringRef v11 = (unsigned __int16 *)&ISOLatinGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182EE0E08;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          CFStringRef v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return v16[0];
}

uint64_t __CFIsValidCombiningCharacterForGreek()
{
  return __CFStringEncodingIsValidCombiningCharacterForLatin1_5();
}

uint64_t __CFPrecomposeGreekCharacter(unsigned __int16 *a1, uint64_t a2, void *a3)
{
  *a3 = 2;
  unsigned int v3 = *a1;
  if (v3 <= 0x7F) {
    return __CFStringEncodingPrecomposeLatinCharacter_8();
  }
  unsigned int v5 = a1[1] | (v3 << 16);
  if (v5 > 0x3D20308) {
    return 65533;
  }
  CFTypeID v6 = (unsigned int *)&__CFGreekPrecompMap;
  uint64_t v7 = (unsigned int *)&unk_182EE0F8C;
  while (1)
  {
    uint64_t v8 = ((char *)v7 - (char *)v6) >> 4;
    unsigned int v9 = &v6[2 * v8];
    if (*v9 <= v5) {
      break;
    }
    uint64_t v7 = v9 - 2;
LABEL_9:
    if (v6 > v7) {
      return 65533;
    }
  }
  if (*v9 < v5)
  {
    CFTypeID v6 = v9 + 2;
    goto LABEL_9;
  }
  uint64_t v10 = LOWORD(v6[2 * v8 + 1]);
  if (a2 >= 3 && a1[2] == 769)
  {
    if (v10 == 971)
    {
      *a3 = 3;
      return 944;
    }
    else if (v10 == 970)
    {
      *a3 = 3;
      return 912;
    }
  }
  return v10;
}

uint64_t __CFToMacGreek(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8806 < 0xFFFFDE3A) {
    return 0;
  }
  unsigned int v5 = (unsigned __int16 *)&MacGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_182EE1190;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    unsigned int v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromMacGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = MacGreek_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  v16[0] = 0;
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8806) >= 0xDE3Au)
    {
      CFStringRef v11 = (unsigned __int16 *)&MacGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182EE1190;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          CFStringRef v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return v16[0];
}

uint64_t __CFToDOSGreek(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  unsigned int v5 = (unsigned __int16 *)&DOSGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_182EE1490;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    unsigned int v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSGreek_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  v16[0] = 0;
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      CFStringRef v11 = (unsigned __int16 *)&DOSGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182EE1490;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          CFStringRef v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return v16[0];
}

uint64_t __CFToWindowsGreek(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0;
  }
  unsigned int v5 = (unsigned __int16 *)&WindowsGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_182EE174C;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    unsigned int v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWindowsGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsGreek_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  v16[0] = 0;
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      CFStringRef v11 = (unsigned __int16 *)&WindowsGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182EE174C;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          CFStringRef v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return v16[0];
}

void __CFArrayHandleOutOfMemory(uint64_t a1)
{
  CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"Attempt to allocate %ld bytes for CFArray failed", a1);
  _CFRaiseMemoryException((uint64_t)v1);
}

#error "182D4060C: call analysis failed (funcsize=5)"

void __CFAttributedStringCopyDescription_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Ridiculous size count";
  __break(1u);
}

void CFAttributedStringSetAttributes_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Ridiculous size count";
  __break(1u);
}

uint64_t __CFReallocationFailed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  char v7 = 0;
  if (!a3 || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a3 + 16))(a3, a1, &v7), !v7))
  {
    bzero(__str, 0x100uLL);
    int v5 = snprintf(__str, 0x100uLL, "Failed to grow buffer to %ld", a2);
    CFStringRef v6 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)__str, v5, 0x600u, 0, 0);
    if (!v6) {
      _CFRaiseMemoryException(@"Failed to grow buffer - malloc failure");
    }
    _CFRaiseMemoryException((uint64_t)v6);
  }
  return result;
}

void sub_182D4071C()
{
  CFRelease(v0);
  JUMPOUT(0x182D40724);
}

uint64_t sub_182D407F8()
{
  return 0;
}

void __CFGetSignatureROMEntryAtIndex_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to access an invalid NSMethodSignature index";
  __break(1u);
}

void __CFRelativeDateTimeFormatterDeallocate_cold_1()
{
  __assert_rtn("__CFRelativeDateTimeFormatterDeallocate", "CFRelativeDateTimeFormatter.c", 80, "cf != NULL");
}

void __CFRelativeDateTimeFormatterCopyDescription_cold_1()
{
  __assert_rtn("__CFRelativeDateTimeFormatterCopyDescription", "CFRelativeDateTimeFormatter.c", 86, "cf != NULL");
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Invalid CFRelativeDateTimeFormatterStyle";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Invalid CFCalendarUnit";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Invalid CFRelativeDateTimeFormatterStyle";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"Invalid CFRelativeDateTimeFormattingContext";
  __break(1u);
}

void _CFCreateArrayStorage_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"failed to create array buffer";
  __break(1u);
}

void _CFCreateArrayStorage_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"size unreasonably big";
  __break(1u);
}

void __NSArrayM_new_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"size unreasonably big";
  __break(1u);
}

void __CFBinaryPlistCreateObjectFiltered_cold_1(os_log_t log)
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  *(_WORD *)CFStringRef v1 = 0;
  _os_log_fault_impl(&dword_182B90000, log, OS_LOG_TYPE_FAULT, "Too many nested arrays or dictionaries", v1, 2u);
}

void _CFURLCreateResolvedDirectoryWithString_cold_1(NSObject *a1)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  int v2 = *__error();
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl(&dword_182B90000, a1, OS_LOG_TYPE_ERROR, "Unable to resolve directory (%d)", (uint8_t *)v3, 8u);
}

void _CFBundleCreate_cold_1()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_182B90000, v0, v1, "Unable to create bundle at URL (%@): normalized URL null", v2, v3, v4, v5, v6);
}

void _CFBundleCreate_cold_3()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_182B90000, v0, v1, "Unable to create bundle at URL (%@): malloc failure", v2, v3, v4, v5, v6);
}

void _CFBundleCreate_cold_4()
{
}

void _CFBundleCreate_cold_5()
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_0();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl(&dword_182B90000, v1, OS_LOG_TYPE_ERROR, "Unable to create bundle at URL (%@): unable to create file system representation of URL (%d)", v2, 0x12u);
}

void _CFBundleLoadExecutableAndReturnError_cold_1()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_182B90000, v0, v1, "Cannot recognize type of executable for %{public}@", v2, v3, v4, v5, v6);
}

void _CFBundleLoadExecutableAndReturnError_cold_2()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_182B90000, v0, v1, "Attempt to load executable of a type that cannot be dynamically loaded for %{public}@", v2, v3, v4, v5, v6);
}

void _CFBundleLoadExecutableAndReturnError_cold_3()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_182B90000, v0, v1, "Cannot find executable for %{public}@", v2, v3, v4, v5, v6);
}

void _CFBundleEnsureBundleExistsForImagePath_cold_1()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2(&dword_182B90000, v0, v1, "Ensure bundle exists failed for path %{private}@", v2, v3, v4, v5, v6);
}

void _CFBundleEnsureBundleExistsForImagePath_cold_2()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2(&dword_182B90000, v0, v1, "Ensure bundle %{private}@ set loaded fallback", v2, v3, v4, v5, v6);
}

void _CFBundleAddToTablesLocked_cold_1()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2(&dword_182B90000, v0, v1, "More than one bundle with the same identifier has been added: %{public}@", v2, v3, v4, v5, v6);
}

void _CFBundleGetBundleVersionForURL_cold_1()
{
  OUTLINED_FUNCTION_1_0();
}

void _CFBundleGetBundleVersionForURL_cold_2()
{
  OUTLINED_FUNCTION_1_0();
}

void _CFBundleGetBundleVersionForURL_cold_3()
{
  OUTLINED_FUNCTION_1_0();
  OUTLINED_FUNCTION_0_0(&dword_182B90000, v0, v1, "Extensions of wrapped bundles did not match at %{public}@", v2, v3, v4, v5, v6);
}

void _CFBundleGetBundleVersionForURL_cold_4()
{
  OUTLINED_FUNCTION_1_0();
  OUTLINED_FUNCTION_0_0(&dword_182B90000, v0, v1, "Extensions of wrapped bundles did not match (one missing) at %{public}@", v2, v3, v4, v5, v6);
}

void CFCharacterSetGetPredefined_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Unknown builtin CFCharacterSet type";
  __break(1u);
}

void CFCharacterSetAddCharactersInString_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetInvert_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetIntersect_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetAddCharactersInRange_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetRemoveCharactersInRange_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetRemoveCharactersInString_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetUnion_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

uint64_t sub_182D412B0()
{
  return 0;
}

void __CFDataHandleOutOfMemory(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0x3FFFFFFFFFELL) {
    CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"Attempt to allocate %ld bytes for NS/CFData failed. Maximum size: %lld", a1, 0x3FFFFFFFFFFLL);
  }
  else {
    CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"Attempt to allocate %ld bytes for NS/CFData failed", a1);
  }
  _CFRaiseMemoryException((uint64_t)v1);
}

#error "182D41334: call analysis failed (funcsize=5)"

void CFDataReplaceBytes_cold_1()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 219, "range.location <= dataLength");
}

void CFDataReplaceBytes_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Negative buffer length passed to CFDataReplaceBytes";
  __break(1u);
}

void CFDataReplaceBytes_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Invalid range passed to CFDataReplaceBytes";
  __break(1u);
}

void CFDataReplaceBytes_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"Invalid length passed to CFDataReplaceBytes when newBytes == NULL";
  __break(1u);
}

void CFDataReplaceBytes_cold_5()
{
  qword_1EC093AA8 = (uint64_t)"fixed-capacity CFMutableData is full";
  __break(1u);
}

void CFDataReplaceBytes_cold_6()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "range.location out of range (>len)", v2, v3, v4, v5, v6);
}

void CFDataReplaceBytes_cold_7()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 221, "range.location + range.length <= dataLength");
}

void CFDataReplaceBytes_cold_8()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "ending index out of bounds", v2, v3, v4, v5, v6);
}

void CFDataReplaceBytes_cold_9()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 220, "range.length >= 0");
}

void CFDataReplaceBytes_cold_10()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "length cannot be less than zero", v2, v3, v4, v5, v6);
}

void CFDataReplaceBytes_cold_11()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 218, "range.location >= 0");
}

void CFDataReplaceBytes_cold_12()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "range.location out of range (<0)", v2, v3, v4, v5, v6);
}

void CFDataGetBytes_cold_1()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 219, "range.location <= dataLength");
}

void CFDataGetBytes_cold_2()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "range.location out of range (>len)", v2, v3, v4, v5, v6);
}

void CFDataGetBytes_cold_3()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 221, "range.location + range.length <= dataLength");
}

void CFDataGetBytes_cold_4()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "ending index out of bounds", v2, v3, v4, v5, v6);
}

void CFDataGetBytes_cold_5()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 220, "range.length >= 0");
}

void CFDataGetBytes_cold_6()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "length cannot be less than zero", v2, v3, v4, v5, v6);
}

void CFDataGetBytes_cold_7()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 218, "range.location >= 0");
}

void CFDataGetBytes_cold_8()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "range.location out of range (<0)", v2, v3, v4, v5, v6);
}

void CFDataSetLength_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"fixed-capacity CFMutableData is full";
  __break(1u);
}

void CFDataFind_cold_1()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 219, "range.location <= dataLength");
}

void CFDataFind_cold_2()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "range.location out of range (>len)", v2, v3, v4, v5, v6);
}

void CFDataFind_cold_3()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 221, "range.location + range.length <= dataLength");
}

void CFDataFind_cold_4()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "ending index out of bounds", v2, v3, v4, v5, v6);
}

void CFDataFind_cold_5()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 220, "range.length >= 0");
}

void CFDataFind_cold_6()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "length cannot be less than zero", v2, v3, v4, v5, v6);
}

void CFDataFind_cold_7()
{
  __assert_rtn("__CFDataValidateRange", "CFData.c", 218, "range.location >= 0");
}

void CFDataFind_cold_8()
{
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2(&dword_182B90000, v0, v1, "range.location out of range (<0)", v2, v3, v4, v5, v6);
}

void CFGregorianDateIsValid_cold_1(int a1)
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_error_impl(&dword_182B90000, (os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR, "Month %d is out of bounds", (uint8_t *)v1, 8u);
}

void __ResetUDateFormat_cold_1(uint64_t *a1, NSObject *a2)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *a1;
  int v3 = 138412290;
  uint64_t v4 = v2;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "Error: CFDateFormatter time zone has an empty name: %@", (uint8_t *)&v3, 0xCu);
}

void _cow_failure(const __CFString *a1)
{
  qword_1EC093AA8 = (uint64_t)CFStringGetCStringPtr(a1, 0x600u);
  __break(1u);
}

void _cow_create_cold_1()
{
}

void _cow_copy_cold_1()
{
}

void _cow_mutate_slow_cold_1()
{
}

uint64_t _CFErrorSetCallStackCaptureEnabled(int a1)
{
  return atomic_exchange(_CFErrorCallStackCaptureEnabled, a1 != 0) & 1;
}

void userInfoKeyValueShow_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** userInfoKeyValueShow() called with NULL context ***";
  __break(1u);
}

void _CFPrefsEncodeKeyValuePairsIntoMessage_cold_1()
{
}

void deallocatePurgeable_cold_1(int a1, NSObject *a2)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  v2[0] = 67240192;
  v2[1] = a1;
  _os_log_fault_impl(&dword_182B90000, a2, OS_LOG_TYPE_FAULT, "couldn't deallocate purgable buffer. Leaking it to avoid crashing. Error was %{public}d", (uint8_t *)v2, 8u);
}

void _cfmp_record_intent_to_invalidate_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Unable to allocate mach_port deallocation record";
  __break(1u);
}

void _cfmp_log_failure_cold_1(uint64_t a1, unsigned __int8 a2, int a3)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  int v3 = 136446722;
  uint64_t v4 = a1;
  __int16 v5 = 1024;
  int v6 = a2;
  __int16 v7 = 1024;
  int v8 = a3;
  _os_log_error_impl(&dword_182B90000, (os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR, "*** %{public}s, break on '_CFMachPortDeallocationFailure' to debug: {null - ic:%d,ip:%d}", (uint8_t *)&v3, 0x18u);
}

void _cfmp_deallocation_record_retain_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"refcnt overflow";
  __break(1u);
}

void _CFBundleDlfcnLoadBundle_cold_1()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_5();
  _os_log_error_impl(&dword_182B90000, v0, OS_LOG_TYPE_ERROR, "Cannot find executable for bundle %{public}@", v1, 0xCu);
}

void _CFBundleDlfcnLoadBundle_cold_2()
{
  OUTLINED_FUNCTION_4();
  strlen(v0);
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2_0(&dword_182B90000, v1, v2, "Error loading %{public}s (%lu):  %{public}s", v3, v4, v5, v6, 2u);
}

void _CFBundleDlfcnLoadBundle_cold_3()
{
  OUTLINED_FUNCTION_1_3();
  OUTLINED_FUNCTION_0_3(&dword_182B90000, v0, v1, "dlfcn load bundle %{public}@ closing existing reference to handle %p");
}

void _CFBundleDlfcnLoadFramework_cold_1()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_5();
  _os_log_error_impl(&dword_182B90000, v0, OS_LOG_TYPE_ERROR, "Cannot find executable for bundle %{public}@", v1, 0xCu);
}

void _CFBundleDlfcnLoadFramework_cold_2()
{
  OUTLINED_FUNCTION_4();
  strlen(v0);
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2_0(&dword_182B90000, v1, v2, "Error loading %{public}s (%lu):  %{public}s", v3, v4, v5, v6, 2u);
}

void _CFBundleDlfcnLoadFramework_cold_3()
{
  OUTLINED_FUNCTION_1_3();
  OUTLINED_FUNCTION_0_3(&dword_182B90000, v0, v1, "dlfcn load framework %{public}@ closing existing reference to handle %p");
}

void _CFBundleDlfcnUnload_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  int v3 = 138543618;
  uint64_t v4 = a1;
  __int16 v5 = 2080;
  uint64_t v6 = dlerror();
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "Internal error unloading bundle %{public}@ : %s", (uint8_t *)&v3, 0x16u);
}

void _CFBundleDlfcnUnload_cold_2()
{
  OUTLINED_FUNCTION_1_3();
  OUTLINED_FUNCTION_0_3(&dword_182B90000, v0, v1, "dlfcn unload bundle %{public}@, handle %p");
}

void _NSDictionaryRaiseInsertNilKeyException(objc_class *a1, const char *a2)
{
  uint64_t v2 = __CFExceptionProem(a1, a2);
  _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: attempt to insert nil key", v2);
}

void _NSDictionaryRaiseInsertNilValueException(objc_class *a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = __CFExceptionProem(a1, a2);
  _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: attempt to insert nil value (key: %@)", v4, a3);
}

void _NSDictionaryRaiseRemoveNilKeyException(objc_class *a1, const char *a2)
{
  uint64_t v2 = __CFExceptionProem(a1, a2);
  _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: attempt to remove nil key", v2);
}

void _CFMachPortCreateWithPort4_cold_1(int a1, uint64_t a2, NSObject *a3)
{
  LODWORD(v3) = 134218240;
  HIDWORD(v3) = a1;
  OUTLINED_FUNCTION_0_4(&dword_182B90000, a2, a3, "*** CFMachPortCreateWithPort(): mach_port_type for 0x%lx failed with %d", v3, 0);
}

void _CFMachPortCreateWithPort4_cold_2(os_log_t log)
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  *(_WORD *)os_log_t v1 = 0;
  _os_log_error_impl(&dword_182B90000, log, OS_LOG_TYPE_ERROR, "*** CFMachPortCreateWithPort(): allocation failure", v1, 2u);
}

void _CFMachPortCreateWithPort4_cold_3(uint64_t a1, uint64_t a2, NSObject *a3)
{
  LODWORD(v3) = 134218240;
  HIDWORD(v3) = a1;
  OUTLINED_FUNCTION_0_4(&dword_182B90000, a2, a3, "*** CFMachPortCreateWithPort(): invalid mach port %p (from cache: %d)", v3, HIDWORD(a1));
}

void _CFMachPortCreateReply_cold_1(int a1, NSObject *a2)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "*** _CFMachPortCreateReply failed. mach_port_construct() returned %d", (uint8_t *)v2, 8u);
}

void _CFMachPortCreate4_cold_1(int a1, NSObject *a2)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "*** CFMachPortCreate failed. mach_port_allocate() returned %d", (uint8_t *)v2, 8u);
}

void _CFMachPortCreate4_cold_2(int *a1, int a2, os_log_t log)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  int v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  __int16 v5 = 1024;
  int v6 = v3;
  _os_log_error_impl(&dword_182B90000, log, OS_LOG_TYPE_ERROR, "*** CFMachPortCreate failed. mach_port_insert_right() returned %d for port %d", (uint8_t *)v4, 0xEu);
}

void __CFMessagePortCreateLocal_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __CFMessagePortCreateLocal_cold_2(int *a1, NSObject *a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  int v2 = *a1;
  v3[0] = 67240192;
  v3[1] = v2;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "*** CFMessagePortCreateLocal(): CFMachPortCreateWithPort() failed, port = %{public}d", (uint8_t *)v3, 8u);
}

void __CFMessagePortCreateLocal_cold_3(int *a1, int a2, os_log_t log)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  int v3 = *a1;
  v4[0] = 67240448;
  v4[1] = a2;
  __int16 v5 = 1026;
  int v6 = v3;
  _os_log_error_impl(&dword_182B90000, log, OS_LOG_TYPE_ERROR, "*** CFMessagePortCreateLocal(): mach_port_insert_right(MACH_MSG_TYPE_MAKE_SEND) returned %{public}d, port = %{public}d", (uint8_t *)v4, 0xEu);
}

void __CFMessagePortCreateLocal_cold_4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __CFMessagePortCreateLocal_cold_5(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFMessagePortSetName_cold_1()
{
  __assert_rtn("CFMessagePortSetName", "CFMessagePort.c", 729, "ms->_dispatchSource == NULL");
}

void _CFNotificationCenterRegisterDependentNotificationList_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Too many invocations of _CFNotificationCenterRegisterDependentNotifications.";
  __break(1u);
}

void _CFXNotificationPost_cold_1(double a1)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  int v1 = 134217984;
  double v2 = a1;
  _os_log_error_impl(&dword_182B90000, (os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR, "Detected potentially harmful notification post rate of %g notifications per second", (uint8_t *)&v1, 0xCu);
}

void _CFThrowFormattedException(uint64_t a1, CFStringRef format, ...)
{
  va_start(va, format);
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  CFStringRef v4 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
  CFAutorelease(v4);
  if (v4) {
    CFStringRef v5 = v4;
  }
  else {
    CFStringRef v5 = format;
  }
  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", a1, v5, 0, va, v6));
}

void __remoteStoreChanged_block_invoke_cold_1(id *a1, NSObject *a2)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  uint64_t v3 = [*a1 domain];
  int v4 = 138543362;
  uint64_t v5 = v3;
  _os_log_debug_impl(&dword_182B90000, a2, OS_LOG_TYPE_DEBUG, "cloud preferences changed for %{public}@", (uint8_t *)&v4, 0xCu);
}

void visit_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"unable to allocate memory";
  __break(1u);
}

void _NSArrayRaiseBoundException(uint64_t a1, const char *a2, unint64_t a3, uint64_t a4)
{
  v18[1] = *(void *)off_1ECE0A5B0;
  uint64_t v7 = _os_log_pack_size();
  uint64_t v9 = (char *)v18 - ((MEMORY[0x1F4188790](v7, v8) + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = _os_log_pack_fill();
  CFStringRef v11 = PROEM_CLS();
  uint64_t v12 = PROEM_SEL(a2);
  if (a3 >> 62) {
    uint64_t v13 = " (or possibly larger)";
  }
  else {
    uint64_t v13 = "";
  }
  __os_log_helper_1_2_5_8_32_8_32_8_0_8_32_8_0(v10, (uint64_t)v11, (uint64_t)v12, a3, (uint64_t)v13, a4);
  uint64_t v14 = PROEM_CLS();
  unsigned int v15 = PROEM_SEL(a2);
  CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"-[%s %s]: index (%ld%s) beyond bounds (%ld)", v14, v15, a3, v13, a4);
  CFIndex v17 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v16) userInfo:0 osLogPack:v9 size:v7];
  objc_exception_throw(v17);
}

void _NSArrayRaiseInsertNilException(uint64_t a1, const char *a2)
{
  v13[1] = *(void *)off_1ECE0A5B0;
  uint64_t v3 = _os_log_pack_size();
  uint64_t v5 = (char *)v13 - ((MEMORY[0x1F4188790](v3, v4) + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = _os_log_pack_fill();
  uint64_t v7 = PROEM_CLS();
  uint64_t v8 = PROEM_SEL(a2);
  *(_DWORD *)uint64_t v6 = 136315394;
  *(void *)(v6 + 4) = v7;
  *(_WORD *)(v6 + 12) = 2080;
  *(void *)(v6 + 14) = v8;
  uint64_t v9 = PROEM_CLS();
  uint64_t v10 = PROEM_SEL(a2);
  CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"-[%s %s]: attempt to insert nil", v9, v10);
  uint64_t v12 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v11) userInfo:0 osLogPack:v5 size:v3];
  objc_exception_throw(v12);
}

void _CFCopyHomeDirURLForUser_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(void *)(*(void *)a1 + 24);
  int v3 = 138543362;
  uint64_t v4 = v2;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "_CFCopyHomeDirURLForUser failed to create a proper home directory. Falling back to /var/empty. Error(s):\n%{public}@", (uint8_t *)&v3, 0xCu);
}

void _CFGetTSDCreateIfNeeded_cold_1(int a1)
{
}

void _CFSetTSD_cold_1(int a1)
{
}

void CFPlugInInstanceCreate_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_3_0(&dword_182B90000, v0, v1, "Cannot find factory %{public}@", v2, v3, v4, v5, v6);
}

void CFPlugInInstanceCreate_cold_2(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFPlugInInstanceCreate_cold_3()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "Created instance of plugin for factory %{public}@ type %{public}@");
}

void CFPlugInInstanceCreate_cold_4()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_6(&dword_182B90000, v0, v1, "Factory %{public}@ does not support type %{public}@");
}

void _CFPFactoryCommonCreateLocked_cold_1()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "Registered factory %{public}@ (%{public}@)");
}

void CFPlugInUnregisterFactory_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_3_0(&dword_182B90000, v0, v1, "UnregisterFactory: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
}

void _CFPFactoryDisableLocked_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPlugInRegisterPlugInTypeLocked_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_3_0(&dword_182B90000, v0, v1, "RegisterPlugInType: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
}

void _CFPlugInRegisterPlugInTypeLocked_cold_2()
{
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "Type %{public}@ added to factory %{public}@");
}

void CFPlugInUnregisterPlugInType_cold_1()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_6(&dword_182B90000, v0, v1, "UnregisterPlugInType: No factory registered for id %{public}@ type %{public}@");
}

void _CFPFactoryRemoveTypeLocked_cold_1()
{
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "Type %{public}@ removed from factory %{public}@");
}

void CFPlugInAddInstanceForFactory_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_3_0(&dword_182B90000, v0, v1, "AddInstanceForFactory: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
}

void CFPlugInAddInstanceForFactory_cold_2()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "AddInstanceForFactory: Added instance on %p for %{public}@");
}

void CFPlugInRemoveInstanceForFactory_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_3_0(&dword_182B90000, v0, v1, "RemoveInstanceForFactory: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
}

void CFPlugInRemoveInstanceForFactory_cold_2()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "RemoveInstanceForFactory: Removed instance on %p for %{public}@");
}

void _CFPFactoryRemoveInstanceLocked_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_2_1(&dword_182B90000, v0, v1, "PlugIn %{public}@ is now scheduled for unloading", v2, v3, v4, v5, v6);
}

void _CFBundleInitPlugIn_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_2_1(&dword_182B90000, v0, v1, "Bundle %{public}@ contains a factory UUID of 00000000-0000-0000-0000-000000000000 with function 'MyFactoryFunction'. This bundle is not a valid plugin.", v2, v3, v4, v5, v6);
}

void _registerTypeLocked_cold_1()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "Registering factory %{public}@ type %{public}@");
}

void _CFBundleDeallocatePlugIn_cold_1(uint64_t a1)
{
  __CFBundleGetPlugInData(a1);
  OUTLINED_FUNCTION_7(&dword_182B90000, v1, v2, "Disabling factories in array %{public}p for bundle %{public}p", v3, v4, v5, v6, 0);
}

void _CFPFactoryDeallocate_cold_1()
{
  OUTLINED_FUNCTION_0_6();
  OUTLINED_FUNCTION_1_4(&dword_182B90000, v0, v1, "Unregistered factory %{public}@ (%{public}@)");
}

void CFPlugInFindFactoriesForPlugInType_cold_1(const __CFArray *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    CFArrayGetCount(a1);
  }
  OUTLINED_FUNCTION_7(&dword_182B90000, a2, a3, "%{public}ld factories found for requested plugin type %{public}@", a5, a6, a7, a8, 2u);
}

void __CFPropertyListCreateTopLevelKeyPaths_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateTopLevelKeyPaths_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void CFPropertyListCreateDeepCopy_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void CFPropertyListCreateDeepCopy_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _arrayDeepImmutableCopy_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _arrayDeepImmutableCopy_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _CFAppendXML0_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFRunLoopDeallocate_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to deallocate CFRunLoop outside of thread destructor -- this is likely an over-r"
                             "elease of the run loop";
  __break(1u);
}

void _CFRunLoopGet2_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Foundation-only CFRunLoop function called without Foundation present";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** Unable to create run loop mode queue port. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"*** Unable to create timer Port ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"*** Unable to insert wake up port into port set. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"*** Unable to insert timer port into port set. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_5()
{
  qword_1EC093AA8 = (uint64_t)"*** Unable to insert timer port into port set. ***";
  __break(1u);
}

void CFRunLoopRunSpecific_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Too many nested CFRunLoopRuns";
  __break(1u);
}

void CFRunLoopRunSpecific_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"CFRunLoopRun underflow";
  __break(1u);
}

void CFRunLoopWakeUp_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** Unable to send message to wake up port. ***";
  __break(1u);
}

void CFRunLoopSourceCreate_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** NULL context value passed to CFRunLoopSourceCreate(). ***";
  __break(1u);
}

void CFRunLoopTimerCreate_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"NaN was used as an interval for a CFRunLoopTimer";
  __break(1u);
}

void __CFRunLoopServiceMachPort_cold_1(char *a1)
{
  if ((~a1 & 0x1000400B) != 0 && (a1 & 0x1000400C) != 0x1000400C)
  {
    a1 = mach_error_string((mach_error_t)a1);
LABEL_4:
    qword_1EC093AA8 = (uint64_t)a1;
LABEL_5:
    __break(1u);
  }
  HIDWORD(v__postAndResetMidnight(1, 1) = (unsigned __int16)a1 & 0x3E00;
  LODWORD(v__postAndResetMidnight(1, 1) = HIDWORD(v1) - 1024;
  a1 = "Out of IPC space";
  switch((v1 >> 10))
  {
    case 0u:
      a1 = "Kernel resource shortage handling out-of-line memory";
      goto LABEL_4;
    case 1u:
      a1 = "Kernel resource shortage handling IPC";
      goto LABEL_4;
    case 3u:
      a1 = "Out of VM address space";
      goto LABEL_4;
    case 7u:
      goto LABEL_4;
    default:
      goto LABEL_5;
  }
}

void __CFRunLoopDoTimer_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"A CFRunLoopTimer with an interval of 0 is set to repeat";
  __break(1u);
}

void _CFAssertMismatchedTypeID(unint64_t a1, unint64_t a2)
{
  uint64_t v4 = _CFGetTypeIDDescription(a1);
  if (v4) {
    uint64_t v5 = (const char *)v4;
  }
  else {
    uint64_t v5 = "<unknown>";
  }
  uint64_t v6 = _CFGetTypeIDDescription(a2);
  if (v6) {
    uint64_t v7 = (const char *)v6;
  }
  else {
    uint64_t v7 = "<unknown>";
  }
  snprintf(__str, 0xFFuLL, "Expected typeID %lu (%s) does not match actual typeID %lu (%s)", a1, v5, a2, v7);
  qword_1EC093AA8 = (uint64_t)__str;
  __break(1u);
}

void _CFRuntimeRegisterClass_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Unable to allocate memory for CF runtime type registration";
  __break(1u);
}

void _CFRuntimeUnregisterClassWithTypeID_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Built-in CFTypes cannot be unregistered";
  __break(1u);
}

void __CFGenericTypeID_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFGetTypeID_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFGetNonObjCTypeID_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFRetain_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRetain_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void CFAutorelease_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFAutorelease() called with NULL ***";
  __break(1u);
}

void _CFRelease_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRelease_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRelease_cold_3(char *__str, uint64_t a2)
{
  if (a2) {
    snprintf(__str, 0x100uLL, "Detected over-release of a CFTypeRef %p (%lu / %s)");
  }
  else {
    snprintf(__str, 0x100uLL, "Detected over-release of a CFTypeRef %p (unknown type)");
  }
  qword_1EC093AA8 = (uint64_t)__str;
  __break(1u);
}

void __CFStringCollectionCopy_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** __CFStringCollectionCopy() called with NULL ***";
  __break(1u);
}

void __CFTypeCollectionRetain_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** __CFTypeCollectionRetain() called with NULL; likely a collection has been corrupted ***";
  __break(1u);
}

void __CFTypeCollectionRelease_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** __CFTypeCollectionRelease() called with NULL; likely a collection has been corrupted ***";
  __break(1u);
}

void CFGetRetainCount_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFNonObjCEqual_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFEqual() called with NULL second argument ***";
  __break(1u);
}

void _CFNonObjCEqual_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_5()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFEqual() called with NULL first argument ***";
  __break(1u);
}

void CFEqual_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"*** CFEqual() called with NULL second argument ***";
  __break(1u);
}

void CFEqual_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_5()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_6()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_7()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCHash_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFHash() called with NULL ***";
  __break(1u);
}

void CFHash_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

uint64_t sub_182D44384()
{
  return 0;
}

void CFSortIndexes_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Size of array to be sorted is too big";
  __break(1u);
}

void CFQSortArray_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFLog(3, @"unable to qsort array - malloc failed", a3, a4, a5, a6, a7, a8, vars0);
  qword_1EC093AA8 = (uint64_t)"qsort - malloc failed";
  __break(1u);
}

void CFMergeSortArray_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFLog(3, @"unable to mergesort array - malloc failed", a3, a4, a5, a6, a7, a8, vars0);
  qword_1EC093AA8 = (uint64_t)"merge sort - malloc failure";
  __break(1u);
}

void __CFStringHandleOutOfMemory()
{
}

unint64_t sub_182D4442C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog(2, @"%@", a3, a4, a5, a6, a7, a8, v8);
}

void __CFStringCreateImmutableFunnel3_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"CFString cannot be created from a negative number of bytes";
  __break(1u);
}

void __CFStringMakeConstantString_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFLog(3, @"Can't interpret CFSTR() as MacOS Roman, crashing", a3, a4, a5, a6, a7, a8, vars0);
  __break(1u);
}

void CFStringAppendFormat_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringSetExternalCharactersNoCopy_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringInsert_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringDelete_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringReplace_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringReplaceAll_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppend_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendCharacters_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendPascalString_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendCString_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendFormatAndArguments_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringFindAndReplace_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringPad_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringTrim_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringTrimWhitespace_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringLowercase_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringUppercase_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringCapitalize_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringNormalize_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringFold_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __CFStringChangeSizeMultiple_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"String had a capacity but NULL buffer pointer";
  __break(1u);
}

void __CFStringFormatLocalizedNumber_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Unexpected formatter style";
  __break(1u);
}

void _CFStringFormatAppendMetadata_cold_1()
{
}

void __CFDateComponentsDeallocate_cold_1()
{
  __assert_rtn("__CFDateComponentsDeallocate", "CFDateComponents.c", 139, "NULL != cf");
}

void __CFDateComponentsEqual_cold_1()
{
  __assert_rtn("__CFDateComponentsEqual", "CFDateComponents.c", 20, "NULL != cf1");
}

void __CFDateComponentsEqual_cold_2()
{
  __assert_rtn("__CFDateComponentsEqual", "CFDateComponents.c", 21, "NULL != cf2");
}

void __CFDateComponentsHash_cold_1()
{
  __assert_rtn("__CFDateComponentsHash", "CFDateComponents.c", 56, "NULL != cf");
}

void __CFDateComponentsCopyDescription_cold_1()
{
  __assert_rtn("__CFDateComponentsCopyDescription", "CFDateComponents.c", 130, "NULL != cf");
}

void CFDateComponentsCreateCopy_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Out of memory";
  __break(1u);
}

void CFDateComponentsCopyCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsCopyCalendar", "CFDateComponents.c", 356, "NULL != dateComp");
}

void CFDateComponentsSetCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsSetCalendar", "CFDateComponents.c", 365, "NULL != dateComp");
}

void CFDateComponentsCopyTimeZone_cold_1()
{
  __assert_rtn("CFDateComponentsCopyTimeZone", "CFDateComponents.c", 386, "NULL != dateComp");
}

void CFDateComponentsSetTimeZone_cold_1()
{
  __assert_rtn("CFDateComponentsSetTimeZone", "CFDateComponents.c", 395, "NULL != dateComp");
}

void CFDateComponentsGetValue_cold_1()
{
  __assert_rtn("CFDateComponentsGetValue", "CFDateComponents.c", 228, "NULL != dateComp");
}

void CFDateComponentsSetValue_cold_1()
{
  __assert_rtn("CFDateComponentsSetValue", "CFDateComponents.c", 293, "NULL != dateComp");
}

void CFDateComponentsIsValidDateInCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsIsValidDateInCalendar", "CFDateComponents.c", 424, "NULL != dateComp");
}

void CFDateComponentsIsValidDateInCalendar_cold_2()
{
  __assert_rtn("CFDateComponentsIsValidDateInCalendar", "CFDateComponents.c", 425, "NULL != inCalendar");
}

void _CFCompareStringsWithLocale_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Invalid string range produced for character buffer in _CFCompareStringsWithLocale.";
  __break(1u);
}

void _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser_cold_1(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  int v3 = 136315394;
  uint64_t v4 = a1;
  __int16 v5 = 2080;
  uint64_t v6 = a2;
  _os_log_error_impl(&dword_182B90000, log, OS_LOG_TYPE_ERROR, "Error getting app group containers for %s: %s", (uint8_t *)&v3, 0x16u);
}

void _CFPrefsExtractQuadrupleFromPathIfPossible_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Mismatched string find result";
  __break(1u);
}

void _CFPrefsValidateValueForKey_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempt to set a non-property-list object as an NSUserDefaults/CFPreferences value";
  abort();
}

void _CFPrefsValidateValueForKey_cold_2()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_0_8();
  _os_log_fault_impl(&dword_182B90000, v0, OS_LOG_TYPE_FAULT, "Attempt to set a non-property-list object %{public}@ as an NSUserDefaults/CFPreferences value for key %{public}@", v1, 0x16u);
}

void _CFURLCopyHostName_cold_1()
{
}

void _CFURLCopyUserName_cold_1()
{
}

void _CFURLCopyPassword_cold_1()
{
}

void __CFURLCopyParameterString_block_invoke_30_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = 138477827;
  uint64_t v4 = v2;
  _os_log_debug_impl(&dword_182B90000, a2, OS_LOG_TYPE_DEBUG, "CFURLCopyParameterString is deprecated and now always returns NULL. The path component now includes the part of the URL string which CFURLCopyParameterString used to return.\nURL = %{private}@", (uint8_t *)&v3, 0xCu);
}

void _unescapedQueryString_cold_1()
{
}

void _CFAppVersionCheckLessThan_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"invalid bundleID provided, must be non-null";
  __break(1u);
}

void _CFAppVersionCheckLessThan_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"version check: bundle ID corrupted";
  __break(1u);
}

uint64_t sub_182D45604()
{
  return 0;
}

uint64_t sub_182D45644()
{
  return 0;
}

uint64_t sub_182D45684()
{
  return 0;
}

double sub_182D456C4()
{
  return 0.0;
}

uint64_t sub_182D45704()
{
  return v0;
}

void decodeTaggedTimeInterval_cold_1()
{
  __assert_rtn("decodeTaggedTimeInterval", "NSDate.m", 244, "encodedBits.unused == 0");
}

void __cficu_ucal_close_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __cficu_ucal_clear_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __cficu_ucal_getNow_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_182D459E0()
{
  return 0;
}

void _CFRaiseMemoryException(uint64_t a1)
{
}

void __NSICreateBackingForArgumentIfNeeded_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Out of memory";
  __break(1u);
}

void __NSICreateBackingForArgumentIfNeeded_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"Out of memory";
  __break(1u);
}

void ___forwarding____cold_1()
{
  qword_1EC093AA8 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void ___forwarding____cold_2(int a1, __int16 a2, SEL sel)
{
  if (__CFOASafe) {
    OUTLINED_FUNCTION_0_11();
  }
  sel_getName(sel);
  CFLog(3, @"*** -[%s %s]: message sent to deallocated instance %p", v5, v6, v7, v8, v9, v10, a2 + 10);
  __break(1u);
}

void ___forwarding____cold_3(void *a1)
{
  __int16 v1 = (__int16)a1;
  object_getClassName(a1);
  CFLog(4, @"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort", v2, v3, v4, v5, v6, v7, v1);
  __break(1u);
}

void ___forwarding____cold_4()
{
  qword_1EC093AA8 = (uint64_t)"Corrupt NSInvocation detected. Contract violation. frameLength not a multiple of uintptr_t.";
  __break(1u);
}

void ___forwarding____cold_5()
{
  qword_1EC093AA8 = (uint64_t)"Corrupt NSInvocation detected. Contract violation. frameLength not a multiple of uintptr_t.";
  __break(1u);
}

void ___forwarding____cold_6(char *a1, id a2)
{
  ClassName = object_getClassName(a2);
  snprintf(a1, 0x100uLL, "*** NSForwarding: object %p of class '%s' does not implement forwardInvocation:", a2, ClassName);
  qword_1EC093AA8 = (uint64_t)a1;
  __break(1u);
}

void __block_forwarding____cold_1(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (__CFOASafe) {
    OUTLINED_FUNCTION_0_11();
  }
  CFLog(3, @"*** NSBlockInvocation: invocation of deallocated Block instance %p", a3, a4, a5, a6, a7, a8, a1);
  __break(1u);
}

void __block_forwarding____cold_2(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __block_forwarding____cold_3()
{
  qword_1EC093AA8 = (uint64_t)"Corrupt NSInvocation detected. Contract violation. frameLength not a multiple of uintptr_t.";
  __break(1u);
}

void _CFPreferencesCopyManagedPreferencesContainerURL_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPreferencesCopyManagedPreferencesContainerURL_cold_2()
{
  OUTLINED_FUNCTION_3_1();
  _os_log_fault_impl(&dword_182B90000, v0, OS_LOG_TYPE_FAULT, "Couldn't create URL for managed preferences container", v1, 2u);
}

void _CFPreferencesGetUserIdentifierForUID_cold_1(int *a1, int a2, os_log_t log)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  int v3 = *a1;
  v4[0] = 67109376;
  v4[1] = v3;
  __int16 v5 = 1024;
  int v6 = a2;
  _os_log_error_impl(&dword_182B90000, log, OS_LOG_TYPE_ERROR, "_CFPreferencesGetUserIdentifierForUID(): Could not resolve user with UID %i: %{darwin.errno}d", (uint8_t *)v4, 0xEu);
}

void _CFPrefsTemporaryFDToWriteTo_cold_1()
{
  OUTLINED_FUNCTION_3_1();
  _os_log_error_impl(&dword_182B90000, v0, OS_LOG_TYPE_ERROR, "Simulating out of disk space on creation", v1, 2u);
}

void _CFPrefsTemporaryFDToWriteTo_cold_2()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_4_1();
  _os_log_error_impl(&dword_182B90000, v0, OS_LOG_TYPE_ERROR, "failed to get file system representation for url: %{private}@", v1, 0xCu);
}

void _CFPrefsTemporaryFDToWriteTo_cold_3()
{
  OUTLINED_FUNCTION_3_1();
  _os_log_error_impl(&dword_182B90000, v0, OS_LOG_TYPE_ERROR, "failed to get file system representation for temporary file path appropriate", v1, 2u);
}

void _CFPrefsTemporaryFDToWriteTo_cold_4(int a1, uint64_t a2, NSObject *a3)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  strerror(a1);
  OUTLINED_FUNCTION_4_1();
  __int16 v6 = 2081;
  uint64_t v7 = a2;
  _os_log_fault_impl(&dword_182B90000, a3, OS_LOG_TYPE_FAULT, "error \"%{public}s\" creating file %{private}s", v5, 0x16u);
}

void _CFPrefsWritePlistToFDThenClose_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPrefsWritePlistToFDThenClose_cold_2(int a1, NSObject *a2)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl(&dword_182B90000, a2, OS_LOG_TYPE_FAULT, "Couldn't get path for fd %d", (uint8_t *)v2, 8u);
}

void _CFPrefsWritePlistToFDThenClose_cold_3()
{
  OUTLINED_FUNCTION_3_1();
  _os_log_fault_impl(&dword_182B90000, v0, OS_LOG_TYPE_FAULT, "Simulating out of disk space on write", v1, 2u);
}

void _CFPrefsWritePlistToFDThenClose_cold_4()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_4_1();
  _os_log_debug_impl(&dword_182B90000, v0, OS_LOG_TYPE_DEBUG, "wrote file %{public}s", v1, 0xCu);
}

void _CFPrefsWritePlistToFDThenClose_cold_5(uint64_t a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 2080;
  *(void *)((char *)&v3 + 2) = a1;
  OUTLINED_FUNCTION_0_12(&dword_182B90000, a2, a3, "error %d setting do-not-back-up attribute on file %s", 67109378, (const char *)v3);
}

void _CFPrefsWritePlistToFDThenClose_cold_6()
{
  OUTLINED_FUNCTION_4_1();
  OUTLINED_FUNCTION_1_6(&dword_182B90000, v0, v1, "Invalid data written from preferences to path %s", v2, v3, v4, v5, v6);
}

void _CFPrefsWritePlistToFDThenClose_cold_7()
{
  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_12(&dword_182B90000, v0, v1, "CFPreferences: error fsyncing file %s: %{darwin.errno}d\n");
}

void _CFPrefsWritePlistToFDThenClose_cold_8()
{
  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_12(&dword_182B90000, v0, v1, "CFPreferences: error writing file %s: %{darwin.errno}d\n");
}

uint64_t sub_182D464A0()
{
  return 0;
}

void __CFRequireConcreteImplementation(objc_class *a1, objc_class *a2, const char *a3)
{
  uint8_t v6 = (objc_class *)objc_opt_class();
  uint64_t v7 = __CFFullMethodName(a1, a2, a3);
  if (v6 == a1)
  {
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** %@: method sent to an instance (%p) of an abstract class.  Create a concrete instance!", v7, a2);
  }
  else
  {
    uint64_t v9 = __CFFullMethodName(v6, a2, a3);
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** %@: method only defined for abstract class.  Define %@!", v7, v9);
  }
  uint64_t v10 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject((uint64_t)v8, (uint64_t)v8) userInfo:0];
  objc_exception_throw(v10);
}

void __CFListFormatterDeallocate_cold_1()
{
  __assert_rtn("__CFListFormatterDeallocate", "CFListFormatter.c", 26, "cf != NULL");
}

void __CFListFormatterCopyDescription_cold_1()
{
  __assert_rtn("__CFListFormatterCopyDescription", "CFListFormatter.c", 32, "cf != NULL");
}

void _CFListFormatterCreate_cold_1()
{
  __assert_rtn("_CFListFormatterCreate", "CFListFormatter.c", 54, "allocator != NULL");
}

void _CFListFormatterCreate_cold_2()
{
  __assert_rtn("_CFListFormatterCreate", "CFListFormatter.c", 57, "locale != NULL");
}

void cbRead_cold_1()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 188, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_2()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 195, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_3()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 173, "pCircBuf->available == 0");
}

void cbRead_cold_4()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 221, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_5()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 228, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_6()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 204, "pCircBuf->available == (pCircBuf->pDataBegin - pCircBuf->pDataEnd)");
}

void cbRead_cold_7()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 256, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_8()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 247, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_9()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 245, "pCircBuf->pDataBegin == pCircBuf->pDataEnd");
}

void cbRead_cold_10()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 237, "pCircBuf->available == ((pCircBuf->pDataBegin - pCircBuf->pData) + (pCircBuf->pBufferEnd - pCircBuf->pDataEnd))");
}

void __cbRead_cold_1()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 124, "pDestination != NULL");
}

void __cbRead_cold_2()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 125, "pSource != NULL");
}

void __cbRead_cold_3()
{
}

void cbWrite_cold_1()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 338, "pCircBuf->available == pCircBuf->length");
}

void cbWrite_cold_2()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 371, "pCircBuf->available == (pCircBuf->pDataBegin - pCircBuf->pDataEnd)");
}

void cbWrite_cold_3()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 391, "pCircBuf->available == ((pCircBuf->pDataBegin - pCircBuf->pData) + (pCircBuf->pBufferEnd - pCircBuf->pDataEnd))");
}

void __cbWrite_cold_1()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 295, "pDestination != NULL");
}

void __cbWrite_cold_2()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 296, "pSource != NULL");
}

void __cbWrite_cold_3()
{
}

void __boundsFail(uint64_t a1, uint64_t a2)
{
  v16[1] = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    uint64_t v10 = a2;
    uint64_t v3 = _os_log_pack_size();
    uint64_t v12 = (char *)v16 - ((MEMORY[0x1F4188790](v3, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v13 = _os_log_pack_fill();
    double v14 = __os_log_helper_1_2_3_8_32_8_0_8_0(v13, (uint64_t)"__boundsFail", a1, --v10);
    CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** %s: index %lu beyond bounds [0 .. %lu]", v14, "__boundsFail", a1, v10);
    uint64_t v8 = _CFAutoreleasePoolAddObject(0, (uint64_t)v15);
    uint64_t v9 = v12;
  }
  else
  {
    uint64_t v3 = _os_log_pack_size();
    uint64_t v5 = (char *)v16 - ((MEMORY[0x1F4188790](v3, v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v6 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)(v6 + 4) = "__boundsFail";
    *(_WORD *)(v6 + 12) = 2048;
    *(void *)(v6 + 14) = a1;
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** %s: index %lu beyond bounds for empty array", "__boundsFail", a1);
    uint64_t v8 = _CFAutoreleasePoolAddObject(0, (uint64_t)v7);
    uint64_t v9 = v5;
  }
  objc_exception_throw(+[NSException exceptionWithName:@"NSRangeException" reason:v8 userInfo:0 osLogPack:v9 size:v3]);
}

void _CFGetHandleForLoadedLibrary_cold_1()
{
}

void _CFGetHandleForInsertedOrInterposingLibrary_cold_1()
{
}

uint64_t sub_182D472F0()
{
  return 0;
}

uint64_t sub_182D47330()
{
  return 0;
}

void normalizeQuintuplet_cold_1()
{
}

void __CFBasicHashRehash_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_2()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_3()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_4()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_5()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_6()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_7()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_8()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_9()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_10()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_11()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_12()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void CFBasicHashCreateCopy_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void _CFXNotificationRegistrarAddObserver_cold_1()
{
  __assert_rtn("_CFXNotificationRegistrarAddObserver", "CFXNotificationRegistrar.c", 2222, "(options & kCFXNotificationValidHandlers) != 0");
}

void _CFXNotificationRegistrarAddObserver_cold_2()
{
  __assert_rtn("_CFXNotificationRegistrarGrowObserverPool", "CFXNotificationRegistrar.c", 1120, "registrar->observerPool.capacity == newCapacity");
}

void _CFXNotificationRegistrarAddObject_cold_1()
{
  __assert_rtn("_CFXNotificationObjectTableRehash", "CFXNotificationRegistrar.c", 2035, "newBucketCount != 0");
}

void _CFXNotificationRegistrarAddName_cold_1()
{
  __assert_rtn("_CFXNotificationNameTableRehash", "CFXNotificationRegistrar.c", 1966, "newBucketCount != 0");
}

void _CFBundleGetStringsSources_cold_1()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_0_19();
  _os_log_debug_impl(&dword_182B90000, v0, OS_LOG_TYPE_DEBUG, "loctable overridden by installed files. Bundle: %@, table: %@", v1, 0x16u);
}

void _CFBundleIngestResultForBundleCache_cold_1()
{
}

void _CFBundleIngestResultForBundleCache_cold_2()
{
}

void _CFBundleIngestResultForBundleCache_cold_3()
{
}

void _CFBundleIngestResultForBundleCache_cold_4()
{
}

void __CFBundleCreateStringsFromPlistData_cold_1()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_0_19();
  _os_log_error_impl(&dword_182B90000, v0, OS_LOG_TYPE_ERROR, "Unable to load .strings file: %@ / %@: Top-level object was not a dictionary", v1, 0x16u);
}

void CFBurstTrieAddUTF8StringWithWeight_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"list is NULL";
  __break(1u);
}

void CFBurstTrieCursorCreateByCopy_cold_1()
{
}

void serializeCFBurstTrieLevels_cold_1()
{
  __assert_rtn("serializeCFBurstTrieLevels", "CFBurstTrie.c", 1849, "bitcount == count");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_1()
{
}

void _CFPrefsApplyChangesQueueToDictionary_cold_2()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_6_0();
  _os_log_fault_impl(&dword_182B90000, v0, OS_LOG_TYPE_FAULT, "Couldn't apply changes: %{private}@", v1, 0xCu);
}

void _CFPrefsApplyChangesQueueToDictionary_cold_3()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1603, "count % CHANGE_QUEUE_TUPLE_COUNT == 0");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_4()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1601, "xpc_get_type(queue) == XPC_TYPE_ARRAY");
}

void _CFPrefsMessageSenderIsSandboxed_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsSandboxCheckForMessage_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _calculateUserNameForUID_cold_1(int a1, NSObject *a2)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  v2[0] = 67240192;
  v2[1] = a1;
  _os_log_fault_impl(&dword_182B90000, a2, OS_LOG_TYPE_FAULT, "Could not look up the username for %{public}d after three tries", (uint8_t *)v2, 8u);
}

void _extractCFPDBits_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void populateErrorReply_cold_1()
{
}

void withClientContext_cold_1()
{
}

void _CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_1()
{
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_2()
{
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_3()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsPIDForMessage_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsGetFixedUpDomainForMessage_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "invalid argument (path instead of domain/application identifier) %{public}s", (uint8_t *)&v2, 0xCu);
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_1()
{
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_2()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_3(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_182B90000, a2, OS_LOG_TYPE_ERROR, "attempt to write to a container %{public}s that does not yet exist. Using client-provided container path without resolving symlinks.", (uint8_t *)&v2, 0xCu);
}

void _CFPrefsSandboxCheckForMessage_cold_1_0()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpUserForMessage_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void log_client_activity_cold_1()
{
  __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void client_context_finalizer_cold_1()
{
}

void _CFPrefsIsUserManaged_cold_1(int a1, uint64_t a2, os_log_t log)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t v3 = "enabled";
  if (a1 != 1) {
    uint64_t v3 = "disabled";
  }
  int v4 = 136446467;
  uint64_t v5 = v3;
  __int16 v6 = 2113;
  uint64_t v7 = a2;
  _os_log_debug_impl(&dword_182B90000, log, OS_LOG_TYPE_DEBUG, "Managed preferences are %{public}s for %{private}@", (uint8_t *)&v4, 0x16u);
}

void _CFBundleLoadLimitedInfoDictionary_cold_1()
{
}

void _CFBundleLoadLimitedInfoDictionary_cold_2()
{
  __assert_rtn("_CFBundleLoadLimitedInfoDictionary", "CFBundle_InfoPlist.c", 1151, "bundle->_infoDict == NULL");
}

void _CFBundleCreateFilteredInfoPlistWithData_cold_1(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)uint64_t v3 = 138478083;
  *(void *)&v3[4] = a1;
  *(_WORD *)&v3[12] = 2114;
  *(void *)&v3[14] = a2;
  OUTLINED_FUNCTION_0_22(&dword_182B90000, a2, a3, "A filtered Info.plist result was not a dictionary at URL %{private}@ (for key paths %{public}@)", *(void *)v3, *(void *)&v3[8], *(void *)&v3[16], *(void *)off_1ECE0A5B0);
}

void ___parseBundleStrings_block_invoke_cold_1(uint64_t a1, void *a2, NSObject *a3)
{
  *(_DWORD *)uint64_t v3 = 138543618;
  *(void *)&v3[4] = a1;
  *(_WORD *)&v3[12] = 2114;
  *(void *)&v3[14] = *a2;
  OUTLINED_FUNCTION_0_22(&dword_182B90000, (uint64_t)a2, a3, "Could not parse markdown while retrieving localized string for key %{public}@ in bundle %{public}@", *(void *)v3, *(void *)&v3[8], *(void *)&v3[16], *(void *)off_1ECE0A5B0);
}

void __CFPREFERENCES_HAS_DETECTED_THIS_APP_TRYING_TO_STORE_TOO_MUCH_DATA__(void *a1, const void **a2, const void **a3, CFIndex a4)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  uint64_t v8 = _CFPrefsClientLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v9 = (void *)MEMORY[0x185311AE0]();
    uint64_t v10 = (const void *)[a1 copyOSLogDescription];
    uint64_t v11 = (const void *)objc_msgSend(a1, "alreadylocked_copyDictionary");
    uint64_t v12 = -[_CFPrefsOversizedPlistDescription initWithDict:setKeys:andValues:count:]([_CFPrefsOversizedPlistDescription alloc], v11, a2, a3, a4);
    uint64_t v13 = _CFPrefsClientLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      _CFProcessNameString();
      int v15 = 138544130;
      CFStringRef v16 = v10;
      OUTLINED_FUNCTION_5_2();
      __int16 v17 = 2114;
      uint64_t v18 = v14;
      __int16 v19 = 2112;
      CFIndex v20 = v12;
      _os_log_fault_impl(&dword_182B90000, v13, OS_LOG_TYPE_FAULT, "%{public}@: Attempting to store >= %d bytes of data in CFPreferences/NSUserDefaults on this platform is invalid. This is a bug in %{public}@ or a library it uses.\n%@", (uint8_t *)&v15, 0x26u);
    }

    CFRelease(v10);
    if (v11) {
      CFRelease(v11);
    }
  }
}

void _CFPrefsImpersonateApplicationWithIdentifierAndPID_cold_1()
{
  OUTLINED_FUNCTION_6_1();
  _os_log_fault_impl(&dword_182B90000, v0, OS_LOG_TYPE_FAULT, "_CFPrefsImpersonateApplicationWithIdentifierAndPID is deprecated and does nothing. Use _CFPrefsImpersonateApplicationWithIdentifierAndAuditToken instead", v1, 2u);
}

void _copyValueForKey_cold_1()
{
  OUTLINED_FUNCTION_4_3();
  OUTLINED_FUNCTION_7_1(&dword_182B90000, v0, v1, "found no value for key %{public}@ in %{public}@");
}

void _plistSizeIsAppropriateToRead_cold_1()
{
  OUTLINED_FUNCTION_1_14();
  OUTLINED_FUNCTION_0_23(&dword_182B90000, v0, v1, "plist had invalid size: %zu.", v2, v3, v4, v5, v6);
}

void _plistSizeIsAppropriateToRead_cold_2()
{
  OUTLINED_FUNCTION_1_14();
  OUTLINED_FUNCTION_0_23(&dword_182B90000, v0, v1, "plist is too large to deserialize in this process: %zu.", v2, v3, v4, v5, v6);
}

void _approximateSizeOfPlistValue_cold_1()
{
  __assert_rtn("_approximateSizeOfPlistValue", "CFPrefsPlistSource.m", 1901, "outObjectCounter == NULL");
}

int32_t NSVersionOfLinkTimeLibrary(const char *libraryName)
{
  return MEMORY[0x1F40C99B0](libraryName);
}

fat_arch *__cdecl NXFindBestFatArch(cpu_type_t cputype, cpu_subtype_t cpusubtype, fat_arch *fat_archs, uint32_t nfat_archs)
{
  return (fat_arch *)MEMORY[0x1F40C99C0](*(void *)&cputype, *(void *)&cpusubtype, fat_archs, *(void *)&nfat_archs);
}

const NXArchInfo *NXGetLocalArchInfo(void)
{
  return (const NXArchInfo *)MEMORY[0x1F40C99D8]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

BOOL _Block_isDeallocating(const void *aBlock)
{
  return MEMORY[0x1F40C9A88](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

const char *__cdecl _Block_signature(void *aBlock)
{
  return (const char *)MEMORY[0x1F40C9AB0](aBlock);
}

BOOL _Block_tryRetain(const void *aBlock)
{
  return MEMORY[0x1F40C9AB8](aBlock);
}

void _Block_use_RR2(const Block_callbacks_RR *callbacks)
{
}

uint64_t _CFURLCreateBookmarkData()
{
  return MEMORY[0x1F4114EA0]();
}

uint64_t _CFURLCreateBookmarkDataFromFile()
{
  return MEMORY[0x1F4114EA8]();
}

uint64_t _CFURLCreateByResolvingBookmarkData()
{
  return MEMORY[0x1F4114EB0]();
}

uint64_t _CFURLCreateResourcePropertiesForKeysFromBookmarkData()
{
  return MEMORY[0x1F4114EB8]();
}

uint64_t _CFURLCreateResourcePropertyForKeyFromBookmarkData()
{
  return MEMORY[0x1F4114EC0]();
}

uint64_t _CFURLStartAccessingSecurityScopedResource()
{
  return MEMORY[0x1F4114EC8]();
}

uint64_t _CFURLStopAccessingSecurityScopedResource()
{
  return MEMORY[0x1F4114ED0]();
}

uint64_t _CFURLWriteBookmarkDataToFile()
{
  return MEMORY[0x1F4114ED8]();
}

uint64_t _FSCreatePathForFileID()
{
  return MEMORY[0x1F4114EE0]();
}

uint64_t _FSGetFileSystemRepresentationForFileID()
{
  return MEMORY[0x1F4114EE8]();
}

uint64_t _FSURLCacheResourcePropertiesForKeys()
{
  return MEMORY[0x1F4114EF8]();
}

uint64_t _FSURLCacheResourcePropertyForKey()
{
  return MEMORY[0x1F4114F00]();
}

uint64_t _FSURLCopyResourcePropertiesForKeys()
{
  return MEMORY[0x1F4114F10]();
}

uint64_t _FSURLCopyResourcePropertiesForKeysFromCache()
{
  return MEMORY[0x1F4114F18]();
}

uint64_t _FSURLCopyResourcePropertyForKey()
{
  return MEMORY[0x1F4114F20]();
}

uint64_t _FSURLCopyResourcePropertyForKeyFromCache()
{
  return MEMORY[0x1F4114F28]();
}

uint64_t _FSURLCopyResourcePropertyValuesAndFlags()
{
  return MEMORY[0x1F4114F30]();
}

uint64_t _FSURLGetResourcePropertyFlags()
{
  return MEMORY[0x1F4114F58]();
}

uint64_t _FSURLGetVolumePropertyFlags()
{
  return MEMORY[0x1F4114F60]();
}

uint64_t _FSURLResourceIsReachable()
{
  return MEMORY[0x1F4114F70]();
}

uint64_t _FSURLSetResourcePropertiesForKeys()
{
  return MEMORY[0x1F4114F88]();
}

uint64_t _FSURLSetResourcePropertyForKey()
{
  return MEMORY[0x1F4114F90]();
}

uint64_t _FileCacheCreateShallowCopy()
{
  return MEMORY[0x1F4114FA0]();
}

uint64_t _FileURLCreateDisplayPathComponentsArray()
{
  return MEMORY[0x1F4114FD0]();
}

int *_NSGetArgc(void)
{
  return (int *)MEMORY[0x1F40C9AD0]();
}

char ***_NSGetArgv(void)
{
  return (char ***)MEMORY[0x1F40C9AD8]();
}

int _NSGetExecutablePath(char *buf, uint32_t *bufsize)
{
  return MEMORY[0x1F40C9AE8](buf, bufsize);
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)MEMORY[0x1F40C9AF0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t __NSCreateBPlistMappedDataFromURL()
{
  return MEMORY[0x1F40E73B8]();
}

uint64_t __NSCreateBPlistMappedString()
{
  return MEMORY[0x1F40E73C0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1F40C9B68](*(void *)&a1, a2, *(void *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

uint64_t __memmove_chk()
{
  return MEMORY[0x1F40C9C30]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1F40C9C38]();
}

uint64_t __stpcpy_chk()
{
  return MEMORY[0x1F40C9CB8]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1F40C9CD0]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1F40C9CE0]();
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x1F40C9CE8]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9D00](*(void *)&a1);
}

uint64_t __udivti3()
{
  return MEMORY[0x1F40C9D08]();
}

uint64_t _dispatch_get_main_queue_port_4CF()
{
  return MEMORY[0x1F40C9D60]();
}

uint64_t _dispatch_main_queue_callback_4CF()
{
  return MEMORY[0x1F40C9D78]();
}

uint64_t _dispatch_runloop_root_queue_create_4CF()
{
  return MEMORY[0x1F40C9D88]();
}

uint64_t _dispatch_runloop_root_queue_get_port_4CF()
{
  return MEMORY[0x1F40C9D90]();
}

uint64_t _dispatch_runloop_root_queue_perform_4CF()
{
  return MEMORY[0x1F40C9D98]();
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1F40C9E08](*(void *)&image_index);
}

const char *__cdecl _dyld_get_image_name(uint32_t image_index)
{
  return (const char *)MEMORY[0x1F40C9E10](*(void *)&image_index);
}

intptr_t _dyld_get_image_vmaddr_slide(uint32_t image_index)
{
  return MEMORY[0x1F40C9E28](*(void *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1F40C9E60]();
}

uint64_t _dyld_is_memory_immutable()
{
  return MEMORY[0x1F40C9E70]();
}

BOOL _dyld_shared_cache_contains_path(const char *path)
{
  return MEMORY[0x1F40C9F10](path);
}

uint64_t _objc_autoreleasePoolPrint()
{
  return MEMORY[0x1F41813E0]();
}

uint64_t _objc_getFreedObjectClass()
{
  return MEMORY[0x1F4181420]();
}

uint64_t _objc_registerTaggedPointerClass()
{
  return MEMORY[0x1F4181438]();
}

uint64_t _objc_rootAllocWithZone()
{
  return MEMORY[0x1F4181448]();
}

uint64_t _objc_rootRetain()
{
  return MEMORY[0x1F4181488]();
}

uint64_t _objc_rootTryRetain()
{
  return MEMORY[0x1F4181498]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1F40C9F70](dso, description, activity, *(void *)&flags);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_pack_fill()
{
  return MEMORY[0x1F40C9FE8]();
}

uint64_t _os_log_pack_size()
{
  return MEMORY[0x1F40C9FF0]();
}

uint64_t _os_log_set_nscf_formatter()
{
  return MEMORY[0x1F40CA000]();
}

void abort(void)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CA200](*(void *)&a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1F40CA210](a1, *(void *)&a2);
}

acl_t acl_dup(acl_t acl)
{
  return (acl_t)MEMORY[0x1F40CA268](acl);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1F40CA270](obj_p);
}

acl_t acl_from_text(const char *buf_p)
{
  return (acl_t)MEMORY[0x1F40CA278](buf_p);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1F40CA328](acl, len_p);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1F40CA3A8]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

void asl_close(asl_object_t obj)
{
}

void asl_free(asl_object_t obj)
{
}

asl_object_t asl_new(uint32_t type)
{
  return (asl_object_t)MEMORY[0x1F40CA410](*(void *)&type);
}

asl_object_t asl_open(const char *ident, const char *facility, uint32_t opts)
{
  return (asl_object_t)MEMORY[0x1F40CA418](ident, facility, *(void *)&opts);
}

int asl_send(asl_object_t obj, asl_object_t msg)
{
  return MEMORY[0x1F40CA420](obj, msg);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return MEMORY[0x1F40CA428](obj, key, value);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

int atexit(void (*a1)(void))
{
  return MEMORY[0x1F40CA488](a1);
}

uint64_t atol(const char *a1)
{
  return MEMORY[0x1F40CA4B8](a1);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1F40CA508](a1, *(void *)&a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CA520](a1, a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1F40CA530](*(void *)&a1, a2, *(void *)&a3);
}

kern_return_t bootstrap_check_in(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1F40CA538](*(void *)&bp, service_name, sp);
}

uint64_t bootstrap_look_up2()
{
  return MEMORY[0x1F40CA550]();
}

uint64_t bootstrap_register2()
{
  return MEMORY[0x1F40CA560]();
}

const char *__cdecl bootstrap_strerror(kern_return_t r)
{
  return (const char *)MEMORY[0x1F40CA568](*(void *)&r);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1F40CA570](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

int cache_create(const char *name, const cache_attributes_t *attrs, cache_t **cache_out)
{
  return MEMORY[0x1F40CA5A8](name, attrs, cache_out);
}

int cache_destroy(cache_t *cache)
{
  return MEMORY[0x1F40CA5B0](cache);
}

uint64_t cache_get()
{
  return MEMORY[0x1F40CA5B8]();
}

uint64_t cache_get_name()
{
  return MEMORY[0x1F40CA5F0]();
}

uint64_t cache_invoke()
{
  return MEMORY[0x1F40CA600]();
}

int cache_release_value(cache_t *cache, void *value)
{
  return MEMORY[0x1F40CA610](cache, value);
}

int cache_remove(cache_t *cache, void *key)
{
  return MEMORY[0x1F40CA618](cache, key);
}

int cache_remove_all(cache_t *cache)
{
  return MEMORY[0x1F40CA620](cache);
}

uint64_t cache_remove_with_block()
{
  return MEMORY[0x1F40CA628]();
}

int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost)
{
  return MEMORY[0x1F40CA630](cache, key, value, cost);
}

uint64_t cache_set_name()
{
  return MEMORY[0x1F40CA650]();
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CB3A0](a1, a2);
}

Protocol **__cdecl class_copyProtocolList(Class cls, unsigned int *outCount)
{
  return (Protocol **)MEMORY[0x1F4181508](cls, outCount);
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return (id)MEMORY[0x1F4181510](cls, extraBytes);
}

Method class_getInstanceMethod(Class cls, SEL name)
{
  return (Method)MEMORY[0x1F4181528](cls, name);
}

size_t class_getInstanceSize(Class cls)
{
  return MEMORY[0x1F4181530](cls);
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  return (IMP)MEMORY[0x1F4181540](cls, name);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1F4181548](cls);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1F4181558](cls);
}

BOOL class_isMetaClass(Class cls)
{
  return MEMORY[0x1F4181568](cls);
}

BOOL class_respondsToSelector(Class cls, SEL sel)
{
  return MEMORY[0x1F4181580](cls, sel);
}

Class class_setSuperclass(Class cls, Class newSuper)
{
  return (Class)MEMORY[0x1F4181588](cls, newSuper);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1F40CB3D0](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1F40CB400](a1);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1F40CB440](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t container_create_or_lookup_app_group_path_by_app_group_identifier()
{
  return MEMORY[0x1F40CB560]();
}

uint64_t container_error_copy_unlocalized_description()
{
  return MEMORY[0x1F40CB5D0]();
}

uint64_t container_get_error_description()
{
  return MEMORY[0x1F40CB638]();
}

uint64_t container_get_identifier()
{
  return MEMORY[0x1F40CB640]();
}

uint64_t container_get_path()
{
  return MEMORY[0x1F40CB650]();
}

uint64_t container_query_create()
{
  return MEMORY[0x1F40CB720]();
}

uint64_t container_query_free()
{
  return MEMORY[0x1F40CB730]();
}

uint64_t container_query_get_last_error()
{
  return MEMORY[0x1F40CB738]();
}

uint64_t container_query_iterate_results_sync()
{
  return MEMORY[0x1F40CB748]();
}

uint64_t container_query_operation_set_flags()
{
  return MEMORY[0x1F40CB750]();
}

uint64_t container_query_set_class()
{
  return MEMORY[0x1F40CB760]();
}

uint64_t container_query_set_identifiers()
{
  return MEMORY[0x1F40CB770]();
}

uint64_t container_query_set_persona_unique_string()
{
  return MEMORY[0x1F40CB780]();
}

uint64_t container_query_set_uid()
{
  return MEMORY[0x1F40CB790]();
}

uint64_t container_system_group_path_for_identifier()
{
  return MEMORY[0x1F40CB7F8]();
}

uint64_t csops()
{
  return MEMORY[0x1F40CB8C8]();
}

uint64_t csops_audittoken()
{
  return MEMORY[0x1F40CB8D0]();
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CB8E8](a1, a2);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CB910](a1, a2);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C0](flags, block);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1F40CBA10](buffer, size, queue, destructor);
}

uint64_t dispatch_data_create_alloc()
{
  return MEMORY[0x1F40CBA18]();
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

uint64_t dispatch_queue_attr_make_with_overcommit()
{
  return MEMORY[0x1F40CBBB0]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1F40CBD40](when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1F40CBDA0](a1, a2);
}

int dlclose(void *__handle)
{
  return MEMORY[0x1F40CBDA8](__handle);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

BOOL dlopen_preflight(const char *__path)
{
  return MEMORY[0x1F40CBDC0](__path);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

int dup(int a1)
{
  return MEMORY[0x1F40CBDF8](*(void *)&a1);
}

int dup2(int a1, int a2)
{
  return MEMORY[0x1F40CBE00](*(void *)&a1, *(void *)&a2);
}

uint64_t dyld_get_active_platform()
{
  return MEMORY[0x1F40CBE10]();
}

uint64_t dyld_has_inserted_or_interposing_libraries()
{
  return MEMORY[0x1F40CBE38]();
}

uint64_t dyld_image_path_containing_address()
{
  return MEMORY[0x1F40CBE70]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1F40CBEC8]();
}

void exit(int a1)
{
}

int fchmod(int a1, mode_t a2)
{
  return MEMORY[0x1F40CC028](*(void *)&a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1F40CC038](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

filesec_t filesec_dup(filesec_t a1)
{
  return (filesec_t)MEMORY[0x1F40CC128](a1);
}

void filesec_free(filesec_t a1)
{
}

int filesec_get_property(filesec_t a1, filesec_property_t a2, void *a3)
{
  return MEMORY[0x1F40CC138](a1, *(void *)&a2, a3);
}

filesec_t filesec_init(void)
{
  return (filesec_t)MEMORY[0x1F40CC140]();
}

int filesec_set_property(filesec_t a1, filesec_property_t a2, const void *a3)
{
  return MEMORY[0x1F40CC148](a1, *(void *)&a2, a3);
}

int filesec_unset_property(filesec_t a1, filesec_property_t a2)
{
  return MEMORY[0x1F40CC150](a1, *(void *)&a2);
}

int flsl(uint64_t a1)
{
  return MEMORY[0x1F40CC180](a1);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x1F40CC1E0](a1, a2, a3);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

void free(void *a1)
{
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CC2A8](*(void *)&fd, name, value, size, *(void *)&position, *(void *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

int fstatat(int a1, const char *a2, stat *a3, int a4)
{
  return MEMORY[0x1F40CC2C8](*(void *)&a1, a2, a3, *(void *)&a4);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1F40CC2D0](*(void *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1F40CC2D8](*(void *)&a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x1F40CC398](a1, a2);
}

gid_t getegid(void)
{
  return MEMORY[0x1F40CC3A8]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1F40CC3B8]();
}

int gethostname(char *a1, size_t a2)
{
  return MEMORY[0x1F40CC400](a1, a2);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CC488](*(void *)&a1, a2, a3);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1F40CC4C0]();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return (passwd *)MEMORY[0x1F40CC4D8](a1);
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x1F40CC4E8](*(void *)&a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x1F40CC500](*(void *)&a1, a2);
}

const section_64 *__cdecl getsectbynamefromheader_64(const mach_header_64 *mhp, const char *segname, const char *sectname)
{
  return (const section_64 *)MEMORY[0x1F40CC510](mhp, segname, sectname);
}

const segment_command_64 *__cdecl getsegbyname(const char *segname)
{
  return (const segment_command_64 *)MEMORY[0x1F40CC530](segname);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CC558](*(void *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x1F40CC560](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1F40CC568](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CC590](path, name, value, size, *(void *)&position, *(void *)&options);
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1F40CC5B0](a1, a2);
}

kern_return_t host_check_multiuser_mode(host_t host, uint32_t *multiuser_mode)
{
  return MEMORY[0x1F40CC5E8](*(void *)&host, multiuser_mode);
}

uint64_t instrumentObjcMessageSends()
{
  return MEMORY[0x1F41815B0]();
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1F40CC690](*(void *)&a1, a2);
}

int issetugid(void)
{
  return MEMORY[0x1F40CC6C0]();
}

uint64_t kdebug_is_enabled()
{
  return MEMORY[0x1F40CC6F0]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

uint64_t kdebug_trace_string()
{
  return MEMORY[0x1F40CC708]();
}

uint64_t kpersona_info()
{
  return MEMORY[0x1F40CC740]();
}

int listen(int a1, int a2)
{
  return MEMORY[0x1F40CC840](*(void *)&a1, *(void *)&a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1F40CC870](a1, a2);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CC900](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1F40CC940](*(void *)&error_value);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1F40CC970](msg, *(void *)&option, *(void *)&send_size, *(void *)&rcv_size, *(void *)&rcv_name, *(void *)&timeout, *(void *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1F40CC9A0](*(void *)&task, *(void *)&right, name);
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  return MEMORY[0x1F40CC9A8](*(void *)&task, options, context, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1F40CC9B8](*(void *)&task, *(void *)&name);
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return MEMORY[0x1F40CC9C8](*(void *)&task, *(void *)&name, *(void *)&srdelta, guard);
}

kern_return_t mach_port_extract_member(ipc_space_t task, mach_port_name_t name, mach_port_name_t pset)
{
  return MEMORY[0x1F40CC9D0](*(void *)&task, *(void *)&name, *(void *)&pset);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1F40CC9E0](*(void *)&task, *(void *)&name, *(void *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_member(ipc_space_t task, mach_port_name_t name, mach_port_name_t pset)
{
  return MEMORY[0x1F40CCA00](*(void *)&task, *(void *)&name, *(void *)&pset);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1F40CCA08](*(void *)&task, *(void *)&name, *(void *)&poly, *(void *)&polyPoly);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x1F40CCA10](*(void *)&task, *(void *)&name, *(void *)&right, *(void *)&delta);
}

kern_return_t mach_port_type(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return MEMORY[0x1F40CCA40](*(void *)&task, *(void *)&name, ptype);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
  return MEMORY[0x1F40CCA68](*(void *)&target, address, size, *(void *)&flags);
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return MEMORY[0x1F40CCA78](*(void *)&target, address, size);
}

kern_return_t mach_vm_region(vm_map_read_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name)
{
  return MEMORY[0x1F40CCAA8](*(void *)&target_task, address, size, *(void *)&flavor, info, infoCnt, object_name);
}

malloc_zone_t *malloc_default_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB30]();
}

size_t malloc_good_size(size_t size)
{
  return MEMORY[0x1F40CCB58](size);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1F40CCB80](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBB8](zone, count, size, type_id);
}

void *__cdecl malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBC0](zone, size, type_id);
}

void *__cdecl malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBD0](zone, alignment, size, type_id);
}

void *__cdecl malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBD8](zone, ptr, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void method_exchangeImplementations(Method m1, Method m2)
{
}

SEL method_getName(Method m)
{
  return (SEL)MEMORY[0x1F4181600](m);
}

const char *__cdecl method_getTypeEncoding(Method m)
{
  return (const char *)MEMORY[0x1F4181618](m);
}

uint64_t mk_timer_arm()
{
  return MEMORY[0x1F40CCDA8]();
}

uint64_t mk_timer_cancel()
{
  return MEMORY[0x1F40CCDB8]();
}

uint64_t mk_timer_create()
{
  return MEMORY[0x1F40CCDC0]();
}

uint64_t mk_timer_destroy()
{
  return MEMORY[0x1F40CCDC8]();
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CCDD0](a1, a2);
}

int mkdirat(int a1, const char *a2, mode_t a3)
{
  return MEMORY[0x1F40CCDD8](*(void *)&a1, a2, a3);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1F40CCE08](a1);
}

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
{
  return MEMORY[0x1F40CCE10](path, *(void *)&dpclass, *(void *)&dpflags);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

long double modf(long double __x, long double *__y)
{
  MEMORY[0x1F40CCE48](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1F40CD050](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x1F4181640](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1F4181650](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

id objc_constructInstance(Class cls, void *bytes)
{
  return (id)MEMORY[0x1F4181690](cls, bytes);
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void *__cdecl objc_destructInstance(id obj)
{
  return (void *)MEMORY[0x1F41816D8](obj);
}

Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1F41816E8](original, name, extraBytes);
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

Class objc_getFutureClass(const char *name)
{
  return (Class)MEMORY[0x1F4181738](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

Protocol *__cdecl objc_getProtocol(const char *name)
{
  return (Protocol *)MEMORY[0x1F4181750](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

uint64_t objc_initializeClassPair()
{
  return MEMORY[0x1F4181768]();
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1F4181778](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

Class objc_lookUpClass(const char *name)
{
  return (Class)MEMORY[0x1F4181788](name);
}

void objc_moveWeak(id *to, id *from)
{
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

void objc_registerClassPair(Class cls)
{
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

void objc_setEnumerationMutationHandler(void (__cdecl *handler)(id))
{
}

objc_exception_matcher objc_setExceptionMatcher(objc_exception_matcher fn)
{
  return (objc_exception_matcher)MEMORY[0x1F41819B8](fn);
}

objc_exception_preprocessor objc_setExceptionPreprocessor(objc_exception_preprocessor fn)
{
  return (objc_exception_preprocessor)MEMORY[0x1F41819C0](fn);
}

void objc_setForwardHandler(void *fwd, void *fwd_stret)
{
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)
{
  return (objc_uncaught_exception_handler)MEMORY[0x1F4181A08](fn);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

id objc_storeWeakOrNil(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A20](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

void objc_terminate(void)
{
}

id object_dispose(id a1)
{
  return (id)MEMORY[0x1F4181A50](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1F4181A58](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x1F4181A60](a1);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  return (void *)MEMORY[0x1F4181A68](a1);
}

uint64_t object_getMethodImplementation()
{
  return MEMORY[0x1F4181A80]();
}

Class object_setClass(id a1, Class a2)
{
  return (Class)MEMORY[0x1F4181A90](a1, a2);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1F40CD0F0](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

int openat(int a1, const char *a2, int a3, ...)
{
  return MEMORY[0x1F40CD100](*(void *)&a1, a2, *(void *)&a3);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1F40CD120](a1);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

uint64_t os_log_shim_enabled()
{
  return MEMORY[0x1F40CD398]();
}

uint64_t os_log_shim_with_CFString()
{
  return MEMORY[0x1F40CD3A8]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1F40CD5A0]();
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1F40CD5E8]();
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1F40CD5F0](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1F40CD610]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1F40CD628]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1F40CD888](*(void *)&pid, buffer, *(void *)&buffersize);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1F40CD8A8](*(void *)&pid, *(void *)&flavor, arg, buffer, *(void *)&buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1F40CD8B8](*(void *)&pid, buffer, *(void *)&buffersize);
}

objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  uint64_t v4 = (const char *)MEMORY[0x1F4181B08](p, aSel, isRequiredMethod, isInstanceMethod);
  result.types = v5;
  result.mach_port_name_t name = v4;
  return result;
}

uint64_t pselect_DARWIN_EXTSN()
{
  return MEMORY[0x1F40CD8F8]();
}

int pthread_atfork(void (*a1)(void), void (*a2)(void), void (*a3)(void))
{
  return MEMORY[0x1F40CD910](a1, a2, a3);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD918](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD930](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x1F40CD938](__attr, *(void *)&__qos_class, *(void *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD940](a1, *(void *)&a2);
}

int pthread_attr_setscope(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD960](a1, *(void *)&a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

int pthread_equal(pthread_t a1, pthread_t a2)
{
  return MEMORY[0x1F40CD9E0](a1, a2);
}

int pthread_getugid_np(uid_t *a1, gid_t *a2)
{
  return MEMORY[0x1F40CDA28](a1, a2);
}

int pthread_is_threaded_np(void)
{
  return MEMORY[0x1F40CDA30]();
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1F40CDA40](a1, a2);
}

uint64_t pthread_key_init_np()
{
  return MEMORY[0x1F40CDA50]();
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1F40CDA60](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x1F40CDA68]();
}

uint64_t pthread_main_thread_np()
{
  return MEMORY[0x1F40CDA70]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA0](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA8](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1F40CDAC0](a1, *(void *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1F40CDB60](a1);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1F40CDB90](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1F40CDBB8](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CDBC0](*(void *)&__fd, __buf, __nbyte, a4);
}

qos_class_t qos_class_main(void)
{
  return MEMORY[0x1F40CDBD0]();
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1F40CDBD8]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1F40CDC60](a1);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x1F40CDC68](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CDC70](a1, a2, a3);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x1F40CDCB8](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t recvfrom(int a1, void *a2, size_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  return MEMORY[0x1F40CDCC0](*(void *)&a1, a2, a3, *(void *)&a4, a5, a6);
}

int renameat(int a1, const char *a2, int a3, const char *a4)
{
  return MEMORY[0x1F40CDD60](*(void *)&a1, a2, *(void *)&a3, a4);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1F40CDD90](a1);
}

uint64_t sandbox_check()
{
  return MEMORY[0x1F40CDDD0]();
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1F40CDDD8]();
}

uint64_t sandbox_container_path_for_audit_token()
{
  return MEMORY[0x1F40CDDE0]();
}

uint64_t sandbox_passthrough_access()
{
  return MEMORY[0x1F40CDE78]();
}

long double scalbn(long double __x, int __y)
{
  MEMORY[0x1F40CDE98](*(void *)&__y, __x);
  return result;
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x1F4181B28](sel);
}

SEL sel_getUid(const char *str)
{
  return (SEL)MEMORY[0x1F4181B30](str);
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1F4181B48](str);
}

uint64_t select_DARWIN_EXTSN()
{
  return MEMORY[0x1F40CDEE0]();
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x1F40CDF30](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  return MEMORY[0x1F40CDF48](*(void *)&a1, a2, a3, *(void *)&a4, a5, *(void *)&a6);
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1F40CDF60](__name, __value, *(void *)&__overwrite);
}

int setiopolicy_np(int a1, int a2, int a3)
{
  return MEMORY[0x1F40CDF78](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x1F40CDFB8](*(void *)&a1, a2);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1F40CDFC0](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int shm_open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CDFE0](a1, *(void *)&a2);
}

int shutdown(int a1, int a2)
{
  return MEMORY[0x1F40CDFF8](*(void *)&a1, *(void *)&a2);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1F40CE030](*(void *)&a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x1F40CE088](a1, a2, a3, a4);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1F40CE090](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return MEMORY[0x1F40CE098](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1F40CE118](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE150](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1A8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1F40CE1D8](a1, a2, a3);
}

int strncasecmp_l(const char *a1, const char *a2, size_t a3, locale_t a4)
{
  return MEMORY[0x1F40CE1E0](a1, a2, a3, a4);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1E8](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1F40CE208](__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x1F40CE210](__big, __little, __len);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE230](__s, *(void *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  MEMORY[0x1F40CE268](a1, a2, a3);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1F40CE2A8](a1, a2, *(void *)&a3, a4);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2C0](__str, __endptr, *(void *)&__base);
}

uint64_t strtoll_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1F40CE2C8](a1, a2, *(void *)&a3, a4);
}

unint64_t strtoul_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1F40CE2E8](a1, a2, *(void *)&a3, a4);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1F40CE3D0](a1, a2, a3, a4, a5);
}

sysdir_search_path_enumeration_state sysdir_get_next_search_path_enumeration(sysdir_search_path_enumeration_state state, char *path)
{
  return MEMORY[0x1F40CE3E8](*(void *)&state, path);
}

uint64_t sysdir_start_search_path_enumeration_private()
{
  return MEMORY[0x1F40CE3F8]();
}

kern_return_t task_get_special_port(task_inspect_t task, int which_port, mach_port_t *special_port)
{
  return MEMORY[0x1F40CE460](*(void *)&task, *(void *)&which_port, special_port);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1F40CE470](*(void *)&target_task, *(void *)&flavor, task_info_out, task_info_outCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

const char *__cdecl u_errorName(UErrorCode code)
{
  return (const char *)MEMORY[0x1F417F728](*(void *)&code);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x1F417F760](*(void *)&c, *(void *)&which);
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  return MEMORY[0x1F417F780](*(void *)&c, *(void *)&which);
}

UBool u_isdigit(UChar32 c)
{
  return MEMORY[0x1F417F7C8](*(void *)&c);
}

int32_t u_strlen(const UChar *s)
{
  return MEMORY[0x1F417F890](s);
}

uint64_t uadatpg_remapPatternWithOptions()
{
  return MEMORY[0x1F417F8E8]();
}

uint64_t ualoc_localizationsToUse()
{
  return MEMORY[0x1F417F910]();
}

uint64_t ubidi_close()
{
  return MEMORY[0x1F417F970]();
}

uint64_t ubidi_getLevels()
{
  return MEMORY[0x1F417F990]();
}

uint64_t ubidi_getParaLevel()
{
  return MEMORY[0x1F417F9A8]();
}

uint64_t ubidi_open()
{
  return MEMORY[0x1F417F9D0]();
}

uint64_t ubidi_setContext()
{
  return MEMORY[0x1F417F9E8]();
}

uint64_t ubidi_setParaWithControls()
{
  return MEMORY[0x1F417FA00]();
}

uint64_t ubrk_close()
{
  return MEMORY[0x1F417FA30]();
}

uint64_t ubrk_last()
{
  return MEMORY[0x1F417FA70]();
}

uint64_t ubrk_open()
{
  return MEMORY[0x1F417FA80]();
}

uint64_t ubrk_preceding()
{
  return MEMORY[0x1F417FA88]();
}

uint64_t ubrk_setText()
{
  return MEMORY[0x1F417FAA0]();
}

uint64_t ucal_add()
{
  return MEMORY[0x1F417FAB0]();
}

uint64_t ucal_clear()
{
  return MEMORY[0x1F417FAB8]();
}

uint64_t ucal_clone()
{
  return MEMORY[0x1F417FAC0]();
}

uint64_t ucal_close()
{
  return MEMORY[0x1F417FAC8]();
}

uint64_t ucal_get()
{
  return MEMORY[0x1F417FAD0]();
}

uint64_t ucal_getAttribute()
{
  return MEMORY[0x1F417FAD8]();
}

uint64_t ucal_getDayOfWeekType()
{
  return MEMORY[0x1F417FAF0]();
}

uint64_t ucal_getFieldDifference()
{
  return MEMORY[0x1F417FAF8]();
}

uint64_t ucal_getGregorianChange()
{
  return MEMORY[0x1F417FB00]();
}

uint64_t ucal_getLimit()
{
  return MEMORY[0x1F417FB18]();
}

uint64_t ucal_getMillis()
{
  return MEMORY[0x1F417FB20]();
}

uint64_t ucal_getNow()
{
  return MEMORY[0x1F417FB28]();
}

uint64_t ucal_getWeekendTransition()
{
  return MEMORY[0x1F417FB58]();
}

uint64_t ucal_isWeekend()
{
  return MEMORY[0x1F417FB68]();
}

uint64_t ucal_open()
{
  return MEMORY[0x1F417FB70]();
}

uint64_t ucal_roll()
{
  return MEMORY[0x1F417FB88]();
}

uint64_t ucal_set()
{
  return MEMORY[0x1F417FB90]();
}

uint64_t ucal_setAttribute()
{
  return MEMORY[0x1F417FB98]();
}

uint64_t ucal_setGregorianChange()
{
  return MEMORY[0x1F417FBB0]();
}

uint64_t ucal_setMillis()
{
  return MEMORY[0x1F417FBB8]();
}

uint64_t ucal_setTimeZone()
{
  return MEMORY[0x1F417FBC0]();
}

uint64_t ucnv_close()
{
  return MEMORY[0x1F417FC30]();
}

uint64_t ucnv_countAliases()
{
  return MEMORY[0x1F417FC48]();
}

uint64_t ucnv_countAvailable()
{
  return MEMORY[0x1F417FC50]();
}

uint64_t ucnv_fromUnicode()
{
  return MEMORY[0x1F417FC60]();
}

uint64_t ucnv_getAlias()
{
  return MEMORY[0x1F417FC68]();
}

uint64_t ucnv_getAvailableName()
{
  return MEMORY[0x1F417FC78]();
}

uint64_t ucnv_getInvalidChars()
{
  return MEMORY[0x1F417FC88]();
}

uint64_t ucnv_getInvalidUChars()
{
  return MEMORY[0x1F417FC90]();
}

uint64_t ucnv_getStandardName()
{
  return MEMORY[0x1F417FCB0]();
}

uint64_t ucnv_open()
{
  return MEMORY[0x1F417FCB8]();
}

uint64_t ucnv_resetFromUnicode()
{
  return MEMORY[0x1F417FCC8]();
}

uint64_t ucnv_setFromUCallBack()
{
  return MEMORY[0x1F417FCE0]();
}

uint64_t ucnv_setSubstChars()
{
  return MEMORY[0x1F417FCE8]();
}

uint64_t ucnv_setToUCallBack()
{
  return MEMORY[0x1F417FCF0]();
}

uint64_t ucnv_toUnicode()
{
  return MEMORY[0x1F417FD00]();
}

uint64_t ucol_close()
{
  return MEMORY[0x1F417FD08]();
}

uint64_t ucol_closeElements()
{
  return MEMORY[0x1F417FD10]();
}

uint64_t ucol_getOffset()
{
  return MEMORY[0x1F417FD50]();
}

uint64_t ucol_next()
{
  return MEMORY[0x1F417FD90]();
}

uint64_t ucol_open()
{
  return MEMORY[0x1F417FDA0]();
}

uint64_t ucol_openElements()
{
  return MEMORY[0x1F417FDB0]();
}

uint64_t ucol_setAttribute()
{
  return MEMORY[0x1F417FDC8]();
}

uint64_t ucol_setStrength()
{
  return MEMORY[0x1F417FDD0]();
}

uint64_t ucol_strcoll()
{
  return MEMORY[0x1F417FDD8]();
}

uint64_t ucurr_getDefaultFractionDigits()
{
  return MEMORY[0x1F417FE40]();
}

uint64_t ucurr_getRoundingIncrement()
{
  return MEMORY[0x1F417FE60]();
}

uint64_t udat_applyPattern()
{
  return MEMORY[0x1F417FE78]();
}

uint64_t udat_applyPatternRelative()
{
  return MEMORY[0x1F417FE80]();
}

uint64_t udat_clone()
{
  return MEMORY[0x1F417FE88]();
}

uint64_t udat_close()
{
  return MEMORY[0x1F417FE90]();
}

uint64_t udat_countSymbols()
{
  return MEMORY[0x1F417FE98]();
}

uint64_t udat_format()
{
  return MEMORY[0x1F417FEA0]();
}

uint64_t udat_formatForFields()
{
  return MEMORY[0x1F417FEA8]();
}

uint64_t udat_get2DigitYearStart()
{
  return MEMORY[0x1F417FEB0]();
}

uint64_t udat_getCalendar()
{
  return MEMORY[0x1F417FEB8]();
}

uint64_t udat_getContext()
{
  return MEMORY[0x1F417FEC0]();
}

uint64_t udat_getSymbols()
{
  return MEMORY[0x1F417FEC8]();
}

uint64_t udat_isLenient()
{
  return MEMORY[0x1F417FED0]();
}

uint64_t udat_open()
{
  return MEMORY[0x1F417FED8]();
}

uint64_t udat_parseCalendar()
{
  return MEMORY[0x1F417FEE0]();
}

uint64_t udat_patternCharToDateFormatField()
{
  return MEMORY[0x1F417FEE8]();
}

uint64_t udat_set2DigitYearStart()
{
  return MEMORY[0x1F417FEF0]();
}

uint64_t udat_setCalendar()
{
  return MEMORY[0x1F417FF00]();
}

uint64_t udat_setContext()
{
  return MEMORY[0x1F417FF08]();
}

uint64_t udat_setLenient()
{
  return MEMORY[0x1F417FF10]();
}

uint64_t udat_setSymbols()
{
  return MEMORY[0x1F417FF18]();
}

uint64_t udat_toCalendarDateField()
{
  return MEMORY[0x1F417FF20]();
}

uint64_t udat_toPattern()
{
  return MEMORY[0x1F417FF28]();
}

uint64_t udat_toPatternRelativeDate()
{
  return MEMORY[0x1F417FF30]();
}

uint64_t udat_toPatternRelativeTime()
{
  return MEMORY[0x1F417FF38]();
}

uint64_t udatpg_close()
{
  return MEMORY[0x1F417FF48]();
}

uint64_t udatpg_getBestPattern()
{
  return MEMORY[0x1F417FF58]();
}

uint64_t udatpg_getSkeleton()
{
  return MEMORY[0x1F417FF78]();
}

uint64_t udatpg_open()
{
  return MEMORY[0x1F417FF80]();
}

uint64_t udtitvfmt_close()
{
  return MEMORY[0x1F417FF88]();
}

uint64_t udtitvfmt_format()
{
  return MEMORY[0x1F417FF98]();
}

uint64_t udtitvfmt_open()
{
  return MEMORY[0x1F417FFB0]();
}

uint64_t udtitvfmt_setAttribute()
{
  return MEMORY[0x1F417FFC8]();
}

uint64_t uenum_close()
{
  return MEMORY[0x1F417FFD8]();
}

uint64_t uenum_next()
{
  return MEMORY[0x1F417FFE8]();
}

uint64_t ufieldpositer_close()
{
  return MEMORY[0x1F417FFF8]();
}

uint64_t ufieldpositer_next()
{
  return MEMORY[0x1F4180000]();
}

uint64_t ufieldpositer_open()
{
  return MEMORY[0x1F4180008]();
}

uint64_t ulistfmt_close()
{
  return MEMORY[0x1F41800C8]();
}

uint64_t ulistfmt_format()
{
  return MEMORY[0x1F41800D8]();
}

uint64_t ulistfmt_open()
{
  return MEMORY[0x1F41800E8]();
}

uint64_t uloc_canonicalize()
{
  return MEMORY[0x1F4180110]();
}

uint64_t uloc_getCountry()
{
  return MEMORY[0x1F4180140]();
}

uint64_t uloc_getKeywordValue()
{
  return MEMORY[0x1F4180188]();
}

uint64_t uloc_getLanguage()
{
  return MEMORY[0x1F4180198]();
}

uint64_t uloc_getScript()
{
  return MEMORY[0x1F41801A8]();
}

uint64_t uloc_getVariant()
{
  return MEMORY[0x1F41801B0]();
}

uint64_t uloc_openKeywords()
{
  return MEMORY[0x1F41801C0]();
}

uint64_t uloc_setKeywordValue()
{
  return MEMORY[0x1F41801C8]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

int unlinkat(int a1, const char *a2, int a3)
{
  return MEMORY[0x1F40CE5E8](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t unum_applyPattern()
{
  return MEMORY[0x1F4180280]();
}

uint64_t unum_close()
{
  return MEMORY[0x1F4180290]();
}

uint64_t unum_formatDecimal()
{
  return MEMORY[0x1F41802A0]();
}

uint64_t unum_formatDouble()
{
  return MEMORY[0x1F41802A8]();
}

uint64_t unum_getAttribute()
{
  return MEMORY[0x1F41802C0]();
}

uint64_t unum_getContext()
{
  return MEMORY[0x1F41802D0]();
}

uint64_t unum_getDoubleAttribute()
{
  return MEMORY[0x1F41802D8]();
}

uint64_t unum_getSymbol()
{
  return MEMORY[0x1F41802E0]();
}

uint64_t unum_getTextAttribute()
{
  return MEMORY[0x1F41802E8]();
}

uint64_t unum_open()
{
  return MEMORY[0x1F41802F0]();
}

uint64_t unum_parse()
{
  return MEMORY[0x1F41802F8]();
}

uint64_t unum_parseDecimal()
{
  return MEMORY[0x1F4180300]();
}

uint64_t unum_setAttribute()
{
  return MEMORY[0x1F4180320]();
}

uint64_t unum_setContext()
{
  return MEMORY[0x1F4180328]();
}

uint64_t unum_setDoubleAttribute()
{
  return MEMORY[0x1F4180330]();
}

uint64_t unum_setSymbol()
{
  return MEMORY[0x1F4180338]();
}

uint64_t unum_setTextAttribute()
{
  return MEMORY[0x1F4180340]();
}

uint64_t unum_toPattern()
{
  return MEMORY[0x1F4180348]();
}

uint64_t uplrules_close()
{
  return MEMORY[0x1F4180410]();
}

uint64_t uplrules_open()
{
  return MEMORY[0x1F4180420]();
}

uint64_t uplrules_select()
{
  return MEMORY[0x1F4180430]();
}

uint64_t ureldatefmt_close()
{
  return MEMORY[0x1F4180560]();
}

uint64_t ureldatefmt_format()
{
  return MEMORY[0x1F4180568]();
}

uint64_t ureldatefmt_formatNumeric()
{
  return MEMORY[0x1F4180570]();
}

uint64_t ureldatefmt_open()
{
  return MEMORY[0x1F4180578]();
}

uint64_t uscript_getScript()
{
  return MEMORY[0x1F41805E0]();
}

uint64_t usearch_close()
{
  return MEMORY[0x1F4180610]();
}

uint64_t usearch_first()
{
  return MEMORY[0x1F4180618]();
}

uint64_t usearch_getMatchedLength()
{
  return MEMORY[0x1F4180628]();
}

uint64_t usearch_last()
{
  return MEMORY[0x1F4180630]();
}

uint64_t usearch_openFromCollator()
{
  return MEMORY[0x1F4180648]();
}

uint64_t uset_close()
{
  return MEMORY[0x1F41806D0]();
}

uint64_t uset_getItem()
{
  return MEMORY[0x1F41806F8]();
}

uint64_t uset_getItemCount()
{
  return MEMORY[0x1F4180700]();
}

uint64_t uset_openPattern()
{
  return MEMORY[0x1F4180720]();
}

UText *__cdecl utext_setup(UText *ut, int32_t extraSpace, UErrorCode *status)
{
  return (UText *)MEMORY[0x1F41807E0](ut, *(void *)&extraSpace, status);
}

uint64_t utrans_close()
{
  return MEMORY[0x1F41807F0]();
}

uint64_t utrans_openU()
{
  return MEMORY[0x1F41807F8]();
}

uint64_t utrans_trans()
{
  return MEMORY[0x1F4180800]();
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1F40CE630](uu1, uu2);
}

void uuid_generate_random(uuid_t out)
{
}

void uuid_generate_time(uuid_t out)
{
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x1F40CE660](in, uu);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1F40CE6A8](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1F40CE6C0](*(void *)&target_task, address, size);
}

kern_return_t vm_purgable_control(vm_map_t target_task, vm_address_t address, vm_purgable_t control, int *state)
{
  return MEMORY[0x1F40CE6E0](*(void *)&target_task, address, *(void *)&control, state);
}

uint64_t voucher_copy()
{
  return MEMORY[0x1F40CE710]();
}

uint64_t voucher_get_current_persona()
{
  return MEMORY[0x1F40CE728]();
}

voucher_mach_msg_state_t voucher_mach_msg_adopt(mach_msg_header_t *msg)
{
  return (voucher_mach_msg_state_t)MEMORY[0x1F40CE740](msg);
}

void voucher_mach_msg_revert(voucher_mach_msg_state_t state)
{
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}

ssize_t writev(int a1, const iovec *a2, int a3)
{
  return MEMORY[0x1F40CE938](*(void *)&a1, a2, *(void *)&a3);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x1F40CEA18](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEA30](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1F40CEA58](xarray);
}

const char *__cdecl xpc_array_get_string(xpc_object_t xarray, size_t index)
{
  return (const char *)MEMORY[0x1F40CEA90](xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1F40CEAA8](xarray, index);
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return (xpc_object_t)MEMORY[0x1F40CEB10](value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x1F40CEB18](xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_bundle_id()
{
  return MEMORY[0x1F40CEB88]();
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBA8](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBC0](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBD0](name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return MEMORY[0x1F40CEBE8]();
}

void *__cdecl xpc_connection_get_context(xpc_connection_t connection)
{
  return (void *)MEMORY[0x1F40CEBF8](connection);
}

gid_t xpc_connection_get_egid(xpc_connection_t connection)
{
  return MEMORY[0x1F40CEC00](connection);
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return MEMORY[0x1F40CEC08](connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return MEMORY[0x1F40CEC20](connection);
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1F40CEC68](connection, message);
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

uint64_t xpc_connection_set_target_user_session_uid()
{
  return MEMORY[0x1F40CECF0]();
}

xpc_object_t xpc_copy(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1F40CED00](object);
}

uint64_t xpc_copy_bootstrap()
{
  return MEMORY[0x1F40CED08]();
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return (char *)MEMORY[0x1F40CED28](object);
}

uint64_t xpc_copy_entitlement_for_self()
{
  return MEMORY[0x1F40CED30]();
}

uint64_t xpc_copy_entitlement_for_token()
{
  return MEMORY[0x1F40CED38]();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1F40CED90](bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return (xpc_object_t)MEMORY[0x1F40CEDA0](ddata);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1F40CEDB0](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1F40CEDC0](xdata);
}

xpc_object_t xpc_date_create(int64_t interval)
{
  return (xpc_object_t)MEMORY[0x1F40CEDD8](interval);
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return MEMORY[0x1F40CEDF0](xdate);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1F40CEE08](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1F40CEE40](original);
}

int xpc_dictionary_dup_fd(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE50](xdict, key);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEE68](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE80](xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1F40CEE88](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1F40CEE98](xdict, key, length);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  MEMORY[0x1F40CEEB8](xdict, key);
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return (xpc_connection_t)MEMORY[0x1F40CEEE0](xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1F40CEEF0](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEF8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEF10](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_object_t xpc_double_create(double value)
{
  return (xpc_object_t)MEMORY[0x1F40CEFE8](value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  MEMORY[0x1F40CEFF8](xdouble);
  return result;
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1F40CF018](connection);
}

BOOL xpc_equal(xpc_object_t object1, xpc_object_t object2)
{
  return MEMORY[0x1F40CF040](object1, object2);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return (xpc_object_t)MEMORY[0x1F40CF188](value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1F40CF190](xint);
}

xpc_object_t xpc_null_create(void)
{
  return (xpc_object_t)MEMORY[0x1F40CF208]();
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1F40CF248](object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x1F40CF290](string);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return MEMORY[0x1F40CF2B8](xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1F40CF2C8](xstring);
}

uint64_t xpc_user_sessions_enabled()
{
  return MEMORY[0x1F40CF340]();
}

uint64_t xpc_user_sessions_get_foreground_uid()
{
  return MEMORY[0x1F40CF348]();
}

uint64_t xpc_user_sessions_get_session_uid()
{
  return MEMORY[0x1F40CF350]();
}

xpc_object_t xpc_uuid_create(const unsigned __int8 *uuid)
{
  return (xpc_object_t)MEMORY[0x1F40CF360](uuid);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return (const uint8_t *)MEMORY[0x1F40CF368](xuuid);
}