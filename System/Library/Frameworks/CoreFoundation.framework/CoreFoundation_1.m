CFTypeID CFArrayGetTypeID(void)
{
  return 19;
}

uint64_t _CFBundleResourceLogger()
{
  if (_CFBundleResourceLogger_onceToken != -1) {
    dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
  }
  return _CFBundleResourceLogger__log;
}

uint64_t _CFBundleLayoutVersion(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 53);
}

CFStringRef _CFCreateLastPathComponent(const __CFAllocator *a1, CFStringRef theString, void *a3)
{
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v7 = Length - 2;
  if (Length >= 2)
  {
    uint64_t v9 = Length;
    uint64_t v10 = 0;
    while (v9 + v10 >= 1)
    {
      if (CFStringGetCharacterAtIndex(theString, --v10 + v9) == 47)
      {
        v11.location = v9 + v10 + 1;
        if (a3) {
          *a3 = v9 + v10;
        }
        v11.length = ~v10;
        CFAllocatorRef v12 = a1;
        CFStringRef v13 = theString;
        goto LABEL_18;
      }
    }
    if (v9 < 3 || !_hasDrive(theString)) {
      goto LABEL_2;
    }
    if (a3) {
      *a3 = -1;
    }
    CFAllocatorRef v12 = a1;
    CFStringRef v13 = theString;
    v11.location = 2;
    v11.length = v7;
LABEL_18:
    return CFStringCreateWithSubstring(v12, v13, v11);
  }
  else
  {
LABEL_2:
    if (a3) {
      *a3 = -1;
    }
    return (CFStringRef)CFRetain(theString);
  }
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFURLRef result = (CFURLRef)*((void *)bundle + 2);
  if (result)
  {
    CFRetain(result);
    return (CFURLRef)*((void *)bundle + 2);
  }
  return result;
}

uint64_t _CFAppendPathExtension2(__CFString *a1, CFStringRef theString)
{
  if (!a1
    || CFStringGetLength(theString) >= 1 && CFStringGetCharacterAtIndex(theString, 0) == 47
    || CFStringGetLength(theString) > 1 && _hasDrive(theString))
  {
    return 0;
  }
  BOOL v4 = CFStringGetLength(a1) >= 2 && _hasDrive(a1);
  while (1)
  {
    CFIndex Length = CFStringGetLength(a1);
    if (v4)
    {
      if (Length <= 3) {
        break;
      }
    }
    else if (Length < 2)
    {
      break;
    }
    CFIndex v6 = CFStringGetLength(a1);
    if (CFStringGetCharacterAtIndex(a1, v6 - 1) != 47) {
      break;
    }
    v11.location = CFStringGetLength(a1) - 1;
    v11.length = 1;
    CFStringDelete(a1, v11);
  }
  if (!CFStringGetLength(a1)) {
    return 0;
  }
  int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
  CFIndex v8 = CFStringGetLength(a1);
  uint64_t v9 = 0;
  switch(v8)
  {
    case 0:
      return v9;
    case 1:
      uint64_t v9 = 0;
      if (CharacterAtIndex != 47 && CharacterAtIndex != 126) {
        goto LABEL_25;
      }
      return v9;
    case 2:
      if (_hasDrive(a1) || _hasNet(a1)) {
        return 0;
      }
      goto LABEL_25;
    case 3:
      if (CFStringGetCharacterAtIndex(a1, 2) == 47 && _hasDrive(a1)) {
        return 0;
      }
      goto LABEL_25;
    default:
LABEL_25:
      if (v8 >= 1 && CharacterAtIndex == 126)
      {
        v12.location = 1;
        v12.length = v8 - 1;
        if (!CFStringFindWithOptions(a1, @"/", v12, 0, 0)) {
          return 0;
        }
      }
      uint64_t v9 = 1;
      CFStringAppendCharacters(a1, _CFAppendPathExtension2_dotChar, 1);
      CFStringAppend(a1, theString);
      break;
  }
  return v9;
}

BOOL _hasDrive(const __CFString *a1)
{
  BOOL result = 0;
  if (CFStringGetLength(a1) >= 2)
  {
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
    if (CFStringGetCharacterAtIndex(a1, 1) == 58 && (CharacterAtIndex & 0xFFFFFFDF) - 65 < 0x1A) {
      return 1;
    }
  }
  return result;
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  if (!bundleURL) {
    return 0;
  }
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFBundleRef v5 = MainBundle;
    CFIndex v6 = (const void *)*((void *)MainBundle + 2);
    if (v6)
    {
      if (CFEqual(v6, bundleURL))
      {
        CFRetain(v5);
        return v5;
      }
    }
  }

  return (CFBundleRef)_CFBundleCreate(allocator, bundleURL, 0, 0);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  v31[129] = *(void *)off_1ECE0A5B0;
  os_unfair_lock_lock((os_unfair_lock_t)&_mainBundleLock);
  if ((_initedMainBundle & 1) == 0)
  {
    _initedCFBundleRef MainBundle = 1;
    v0 = _CFProcessPath();
    if (v0)
    {
      CFStringRef v1 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v0);
      CFURLRef v2 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, kCFURLPOSIXPathStyle, 0);
      if (!v2)
      {
        if (!v1) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
      CFURLRef v3 = v2;
      CFURLRef v4 = _CFBundleCopyBundleURLForExecutableURL(v2);
      if (!v4)
      {
LABEL_54:
        if (v1) {
          CFRelease(v1);
        }
        CFStringRef v1 = (const __CFString *)v3;
LABEL_57:
        CFRelease(v1);
        goto LABEL_58;
      }
      CFURLRef v5 = v4;
      Main = _CFBundleCreateMain((const __CFAllocator *)&__kCFAllocatorSystemDefault, v4);
      _mainBundle = (uint64_t)Main;
      if (!Main)
      {
LABEL_53:
        CFRelease(v5);
        goto LABEL_54;
      }
      *((unsigned char *)Main + 52) = 1;
      if (!*((_DWORD *)Main + 12))
      {
        int v8 = _CFBundleGrokBinaryType(v3, v7);
        Main = (void *)_mainBundle;
        *(_DWORD *)(_mainBundle + 48) = v8;
        if (v8 != 1 && v8 != 6) {
          *((unsigned char *)Main + 64) = 1;
        }
      }
      if (!Main[7])
      {
        Main[7] = -5;
        uint64_t v10 = _CFBundleLoadingLogger();
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        Main = (void *)_mainBundle;
        if (v11)
        {
          CFBundleGetMainBundle_cold_1(_mainBundle, v10, v31);
          Main = (void *)v31[0];
        }
      }
      CFBundleGetInfoDictionary((CFBundleRef)Main);
      uint64_t v12 = _mainBundle;
      if (*(void *)(_mainBundle + 24))
      {
        CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_mainBundle + 24));
        uint64_t v12 = _mainBundle;
        if (Count)
        {
          if (*(_DWORD *)(_mainBundle + 48) == 2)
          {
            CFStringRef v14 = _CFBundleCopyExecutableName((CFBundleRef)_mainBundle, 0, 0);
            CFStringRef v15 = v14;
            if (v1)
            {
              if (v14 && CFStringHasSuffix(v1, v14)) {
                goto LABEL_43;
              }
            }
            CFDictionaryRef InfoDictFromMainExecutable = _CFBundleCreateInfoDictFromMainExecutable();
            if (InfoDictFromMainExecutable)
            {
              CFDictionaryRef v17 = InfoDictFromMainExecutable;
              if (CFDictionaryGetCount(InfoDictFromMainExecutable) < 1)
              {
                CFRelease(v17);
              }
              else
              {
                uint64_t v18 = _mainBundle;
                v19 = *(const void **)(_mainBundle + 24);
                if (v19)
                {
                  CFRelease(v19);
                  uint64_t v18 = _mainBundle;
                }
                *(void *)(v18 + 24) = v17;
              }
            }
            if (v15) {
LABEL_43:
            }
              CFRelease(v15);
          }
LABEL_44:
          uint64_t v23 = _mainBundle;
          if (!*(void *)(_mainBundle + 24))
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            uint64_t v23 = _mainBundle;
            *(void *)(_mainBundle + 24) = Mutable;
          }
          if (v1 && !*(void *)(v23 + 104))
          {
            CFTypeRef v25 = CFRetain(v1);
            uint64_t v23 = _mainBundle;
            *(void *)(_mainBundle + 104) = v25;
          }
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v23 + 24), @"CFBundleIdentifier");
          if (Value)
          {
            CFStringRef v27 = Value;
            bzero(v31, 0x402uLL);
            if (!CFStringGetCString(v27, (char *)v31, 1024, 0x8000100u))
            {
              LOBYTE(v31[0]) = 0;
              __CFBundleMainID = (uint64_t)strdup((const char *)v31);
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&_mainBundleLock);
          CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)_mainBundle);
          _CFBundleInitPlugIn((void *)_mainBundle, InfoDictionary, 0);
          _CFPlugInHandleDynamicRegistration((__CFBundle *)_mainBundle);
          os_unfair_lock_lock((os_unfair_lock_t)&_mainBundleLock);
          goto LABEL_53;
        }
      }
      if (*(unsigned char *)(v12 + 53))
      {
        if (*(unsigned char *)(v12 + 53) == 3) {
          *(unsigned char *)(v12 + 53) = 4;
        }
        goto LABEL_37;
      }
      CFStringRef v20 = _CFBundleCopyExecutableName((CFBundleRef)v12, 0, 0);
      CFStringRef v21 = v20;
      if (v1 && v20)
      {
        if (!CFStringHasSuffix(v1, v20)) {
          *(unsigned char *)(_mainBundle + 53) = 4;
        }
      }
      else
      {
        uint64_t v12 = _mainBundle;
        *(unsigned char *)(_mainBundle + 53) = 4;
        if (!v21) {
          goto LABEL_37;
        }
      }
      CFRelease(v21);
      uint64_t v12 = _mainBundle;
LABEL_37:
      if ((*(_DWORD *)(v12 + 48) | 4) == 6)
      {
        v22 = *(const void **)(v12 + 24);
        if (v22) {
          CFRelease(v22);
        }
        *(void *)(_mainBundle + 24) = _CFBundleCreateInfoDictFromMainExecutable();
      }
      goto LABEL_44;
    }
  }
LABEL_58:
  v29 = (__CFBundle *)_mainBundle;
  os_unfair_lock_unlock((os_unfair_lock_t)&_mainBundleLock);
  return v29;
}

void _CFBundleIngestResultForBundleCache(uint64_t a1, const void *a2, int a3, uint64_t a4)
{
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  int v8 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 168);
  if (v9)
  {
    CFStringRef Value = (CFTypeRef *)CFDictionaryGetValue(v9, a2);
    BOOL v11 = Value;
    BOOL v12 = a3 != 0;
    if (a3 && Value)
    {
      CFStringRef v13 = *(const void **)(a4 + 8);
      CFStringRef v15 = *(const void **)(a4 + 24);
      CFStringRef v14 = *(const void **)(a4 + 32);
      v16 = *(const void **)(a4 + 40);
      int v17 = *(unsigned __int8 *)(a4 + 65);
      if (Value[1]) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v13 == 0;
      }
      if (!v18)
      {
        if (*Value) {
          _CFBundleIngestResultForBundleCache_cold_4();
        }
        if (Value[2]) {
          _CFBundleIngestResultForBundleCache_cold_3();
        }
        v19 = *(const void **)a4;
        CFStringRef v20 = *(const void **)(a4 + 16);
        if (v20 && *(unsigned char *)(a4 + 64))
        {
          v11[2] = CFRetain(v20);
          *((unsigned char *)v11 + 64) = 1;
        }
        if (v19) {
          *BOOL v11 = CFRetain(v19);
        }
        v11[1] = CFRetain(v13);
      }
      if (v11[4]) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = v14 == 0;
      }
      if (!v21)
      {
        if (v11[3]) {
          _CFBundleIngestResultForBundleCache_cold_2();
        }
        if (v11[5]) {
          _CFBundleIngestResultForBundleCache_cold_1();
        }
        if (v16 && v17)
        {
          v11[5] = CFRetain(v16);
          *((unsigned char *)v11 + 65) = 1;
        }
        if (v15) {
          v11[3] = CFRetain(v15);
        }
        v11[4] = CFRetain(v14);
      }
      goto LABEL_44;
    }
    if (Value) {
      goto LABEL_44;
    }
  }
  else
  {
    long long v28 = xmmword_1ECE10448;
    long long v29 = *(_OWORD *)&off_1ECE10458;
    *(void *)&long long v30 = qword_1ECE10468;
    *(void *)(a1 + 168) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, (const CFDictionaryValueCallBacks *)&v28);
    BOOL v12 = a3 != 0;
  }
  v22 = malloc_type_malloc(0x48uLL, 0x1060040C3D82AC4uLL);
  if (!v22) {
    goto LABEL_44;
  }
  uint64_t v23 = v22;
  _OWORD *v22 = *(_OWORD *)a4;
  long long v24 = *(_OWORD *)(a4 + 16);
  long long v25 = *(_OWORD *)(a4 + 32);
  long long v26 = *(_OWORD *)(a4 + 48);
  *((void *)v22 + 8) = *(void *)(a4 + 64);
  v22[2] = v25;
  v22[3] = v26;
  v22[1] = v24;
  if (!v12)
  {
    *((_WORD *)v22 + 32) = 0;
    *(void *)v22 = 0;
    *((void *)v22 + 1) = 0;
    *((void *)v22 + 3) = 0;
    *((void *)v22 + 4) = 0;
LABEL_35:
    *((void *)v22 + 2) = 0;
    goto LABEL_36;
  }
  if (!*(unsigned char *)(a4 + 64)) {
    goto LABEL_35;
  }
LABEL_36:
  if (*(unsigned char *)(a4 + 65)) {
    BOOL v27 = v12;
  }
  else {
    BOOL v27 = 0;
  }
  if (!v27) {
    *((void *)v22 + 5) = 0;
  }
  if (!*(unsigned char *)(a4 + 66)) {
    *((void *)v22 + 7) = 0;
  }
  long long v29 = v22[1];
  long long v30 = v22[2];
  long long v31 = v22[3];
  uint64_t v32 = *((void *)v22 + 8);
  long long v28 = *v22;
  _CFBundleRetainStringsSources((uint64_t)&v28);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 168), a2, v23);
LABEL_44:
  os_unfair_lock_unlock(v8);
}

CFURLRef _CFBundleGetFileVersionForStringsResourceURL(const __CFURL *result)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  if (result)
  {
    unsigned int v5 = 0;
    BOOL result = (const __CFURL *)CFURLCopyLastPathComponent(result);
    if (result)
    {
      CFStringRef v1 = (const __CFString *)result;
      CFTypeRef cf = 0;
      CFStringRef ProductNameSuffix = (const __CFString *)_CFBundleGetProductNameSuffix();
      PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
      _CFBundleSplitFileName(v1, (__CFString **)&cf, 0, 0, ProductNameSuffix, PlatformNameSuffix, 2, (int *)&v5);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v1);
      return (const __CFURL *)v5;
    }
  }
  return result;
}

CFURLRef CFBundleCopyResourceURLForLocalization(CFURLRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  if (bundle) {
    return _CFBundleCopyFindResources((uint64_t)bundle, 0, (uint64_t)resourceType, resourceName, resourceType, subDirName, localizationName, 0, 1, 0);
  }
  return bundle;
}

uint64_t _hasNet(const __CFString *a1)
{
  if (CFStringGetLength(a1) < 2) {
    return 0;
  }
  int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
  uint64_t v3 = 1;
  int v4 = CFStringGetCharacterAtIndex(a1, 1);
  if (CharacterAtIndex != 92 || v4 != 92) {
    return 0;
  }
  return v3;
}

uint64_t _useLoctableInsteadOfFileBasedOnVersion(CFTypeRef *a1, CFTypeRef *a2, unsigned int a3, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  CFURLRef v7 = (const __CFURL *)*a1;
  if (v7)
  {
    if (_CFBundleGetFileVersionForStringsResourceURL(v7) >= a3) {
      return 0;
    }
    if (*a1) {
      CFRelease(*a1);
    }
  }
  *a1 = 0;
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = CFRetain(cf);
  return 1;
}

CFMutableDictionaryRef _parseBundleStrings(uint64_t a1, CFDictionaryRef theDict)
{
  v7[6] = *(void *)off_1ECE0A5B0;
  CFIndex Count = CFDictionaryGetCount(theDict);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7[0] = off_1ECE0A5A0;
  v7[1] = 0x40000000;
  v7[2] = ___parseBundleStrings_block_invoke;
  v7[3] = &__block_descriptor_tmp_162;
  v7[4] = a1;
  v7[5] = Mutable;
  CFDictionaryApply(theDict, (uint64_t)v7);
  return Mutable;
}

CFDataRef _CFDataCreateFromURL(CFURLRef url, CFErrorRef *a2)
{
  resourceData[1] = *(CFDataRef *)off_1ECE0A5B0;
  resourceData[0] = 0;
  SInt32 errorCode = 0;
  int v3 = CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, url, resourceData, 0, 0, &errorCode);
  if (!a2 || v3) {
    return resourceData[0];
  }
  CFErrorRef v4 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSOSStatusErrorDomain", errorCode, 0);
  CFDataRef result = 0;
  *a2 = v4;
  return result;
}

void _onelineFormatArray(__CFString *a1, const __CFArray *a2)
{
  CFStringAppend(a1, @"[");
  if (a2)
  {
    v5.length = CFArrayGetCount(a2);
    v5.location = 0;
    CFArrayApplyFunction(a2, v5, (CFArrayApplierFunction)_onelineFormatArrayApply, a1);
    if (CFArrayGetCount(a2) >= 1)
    {
      v6.location = CFStringGetLength(a1) - 2;
      v6.length = 2;
      CFStringDelete(a1, v6);
    }
  }
  else
  {
    CFStringAppend(a1, @"<null>");
  }

  CFStringAppend(a1, @"]");
}

void *_CFBundleCreateMain(const __CFAllocator *a1, const __CFURL *a2)
{
  return _CFBundleCreate(a1, a2, 3, 0);
}

CFStringRef _CFBundleCopyLanguageForStringsResourceURL(const __CFURL *a1)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  CFStringRef v1 = CFURLCopyPath(a1);
  v7.length = CFStringGetLength(v1);
  result.location = 0;
  result.length = 0;
  v4.location = 0;
  v4.length = 0;
  v7.location = 0;
  if (CFStringFindWithOptions(v1, @".lproj", v7, 4uLL, &result)
    && (v8.length = result.location, v8.location = 0, CFStringFindWithOptions(v1, @"/", v8, 4uLL, &v4)))
  {
    v9.location = v4.length + v4.location;
    v9.length = result.location - (v4.length + v4.location);
    CFStringRef v2 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, v9);
  }
  else
  {
    CFStringRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

CFTypeRef _CFBundleCopyXPCBootstrapMainBundleLanguages()
{
  if (_CFBundleCopyXPCBootstrapMainBundleLanguages_onceToken != -1) {
    dispatch_once(&_CFBundleCopyXPCBootstrapMainBundleLanguages_onceToken, &__block_literal_global_151);
  }
  CFTypeRef result = (CFTypeRef)_CFBundleCopyXPCBootstrapMainBundleLanguages_result;
  if (_CFBundleCopyXPCBootstrapMainBundleLanguages_result)
  {
    return CFRetain(result);
  }
  return result;
}

void CFBundleGetMainBundle_cold_1(uint64_t a1, NSObject *a2, void *a3)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *(void *)(a1 + 56);
  int v5 = 138543618;
  uint64_t v6 = a1;
  __int16 v7 = 2048;
  uint64_t v8 = v4;
  _os_log_debug_impl(&dword_182B90000, a2, OS_LOG_TYPE_DEBUG, "main bundle %{public}@ getting handle %p", (uint8_t *)&v5, 0x16u);
  *a3 = _mainBundle;
}

void _CFSetSetCapacity(unint64_t a1, uint64_t a2)
{
  if (!CF_IS_OBJC(0x11uLL, a1))
  {
    CFBasicHashSetCapacity(a1, a2);
  }
}

uint64_t _CFAttributedStringCheckAndSetAttributes(uint64_t a1, CFIndex a2, CFIndex a3, const __CFDictionary *a4, Boolean a5)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3;
  }
  char v13 = atomic_load((unint64_t *)(a1 + 8));
  if (v13) {
    return 1;
  }
  v14.location = a2;
  v14.length = a3;
  CFAttributedStringSetAttributes((CFMutableAttributedStringRef)a1, v14, a4, a5);
  return 0;
}

CFAttributedStringRef CFAttributedStringCreateWithSubstring(CFAllocatorRef alloc, CFAttributedStringRef aStr, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return (CFAttributedStringRef)-[__CFAttributedString _createAttributedSubstringWithRange:](aStr, "_createAttributedSubstringWithRange:", location, length);
  }
  else
  {
    CFIndex v8 = CFAttributedStringGetLength(aStr);
    if (location || length != v8)
    {
      CFAttributedStringRef result = __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)aStr, location, length);
      unint64_t v9 = atomic_load((unint64_t *)result + 1);
      unint64_t v10 = v9;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v10, v9 | 1);
        BOOL v11 = v10 == v9;
        unint64_t v9 = v10;
      }
      while (!v11);
    }
    else
    {
      return CFAttributedStringCreateCopy(alloc, aStr);
    }
  }
  return result;
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)alloc, 0x3EuLL, 16, 0);
  if (Instance)
  {
    *(void *)(Instance + 16) = CFStringCreateCopy(alloc, str);
    *(void *)(Instance + 24) = CFRunArrayCreate((__objc2_class **)alloc);
    CFIndex Length = CFStringGetLength(*(CFStringRef *)(Instance + 16));
    if (Length)
    {
      uint64_t v8 = Length;
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(alloc, attributes);
      CFRunArrayInsert(*(CFTypeRef *)(Instance + 24), 0, v8, AttributesDictionary);
      CFRelease(AttributesDictionary);
    }
    unint64_t v10 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v11 = v10;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v11, v10 | 1);
      BOOL v12 = v11 == v10;
      unint64_t v10 = v11;
    }
    while (!v12);
  }
  return (CFAttributedStringRef)Instance;
}

CFMutableDictionaryRef _CFPrefsCopyAppDictionaryWithContainer(__CFString *a1, const __CFString *a2)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  CFMutableDictionaryRef v5 = -[_CFXPreferences copyDictionaryForApp:withContainer:]((uint64_t)v4, a1, a2);

  return v5;
}

CFDictionaryRef __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(unsigned char *a1)
{
  uint64_t v2 = _CFGetTSD(0xFu);
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    int v3 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v4 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    int v3 = (void *)v4;
    if (!v2 && v4)
    {
      *a1 = 0;
      CFMutableDictionaryRef v5 = -[_CFXPreferences copyDictionaryForApp:withContainer:](v4, @"kCFPreferencesCurrentApplication", 0);

      return v5;
    }
  }
  *a1 = 1;

  return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void sub_182C2BD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFAttributedStringRef CFAttributedStringCreateCopy(CFAllocatorRef alloc, CFAttributedStringRef aStr)
{
  uint64_t v2 = (unint64_t *)aStr;
  if (!CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    char v5 = atomic_load(v2 + 1);
    if ((v5 & 1) == 0) {
      goto LABEL_16;
    }
    CFAllocatorRef v6 = alloc;
    if (alloc)
    {
      if (((unint64_t)v2 & 0x8000000000000000) != 0)
      {
LABEL_8:
        __int16 v7 = &kCFAllocatorSystemDefault;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v8 = _CFGetTSD(1u);
      CFAllocatorRef v6 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
      if (v8) {
        CFAllocatorRef v6 = (CFAllocatorRef)v8;
      }
      if (((unint64_t)v2 & 0x8000000000000000) != 0) {
        goto LABEL_8;
      }
    }
    char v9 = atomic_load(v2 + 1);
    if (v9 < 0) {
      __int16 v7 = &kCFAllocatorSystemDefault;
    }
    else {
      __int16 v7 = (const CFAllocatorRef *)(v2 - 2);
    }
LABEL_15:
    if (v6 == *v7)
    {
      CFRetain(v2);
      return (CFAttributedStringRef)v2;
    }
LABEL_16:
    CFIndex Length = CFAttributedStringGetLength((CFAttributedStringRef)v2);
    MutableWithSubstring = __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)v2, 0, Length);
    uint64_t v2 = (unint64_t *)MutableWithSubstring;
    unint64_t v12 = atomic_load((unint64_t *)MutableWithSubstring + 1);
    unint64_t v13 = v12;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)MutableWithSubstring + 1, &v13, v12 | 1);
      BOOL v14 = v13 == v12;
      unint64_t v12 = v13;
    }
    while (!v14);
    return (CFAttributedStringRef)v2;
  }

  return (CFAttributedStringRef)[v2 copy];
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return [(__CFAttributedString *)aStr length];
  }
  else
  {
    CFStringRef v3 = (const __CFString *)*((void *)aStr + 2);
    return CFStringGetLength(v3);
  }
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  CFIndex length = inRange.length;
  CFIndex location = inRange.location;
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return (CFTypeRef)-[__CFAttributedString attribute:atIndex:longestEffectiveRange:inRange:](aStr, "attribute:atIndex:longestEffectiveRange:inRange:", attrName, loc, longestEffectiveRange, location, length);
  }
  else
  {
    CFTypeRef Attribute = CFAttributedStringGetAttribute(aStr, loc, attrName, longestEffectiveRange);
    if (longestEffectiveRange)
    {
      CFRange v20 = *longestEffectiveRange;
      CFIndex v13 = location + length;
      do
      {
        CFIndex v14 = v20.length + v20.location;
        if (v20.length + v20.location >= v13) {
          break;
        }
        CFTypeRef v15 = CFAttributedStringGetAttribute(aStr, v20.length + v20.location, attrName, &v20);
      }
      while (v15 == Attribute || v15 && Attribute && CFEqual(v15, Attribute));
      CFRange v20 = *longestEffectiveRange;
      do
      {
        CFIndex v16 = v20.location;
        if (v20.location <= location) {
          break;
        }
        CFTypeRef v17 = CFAttributedStringGetAttribute(aStr, v20.location - 1, attrName, &v20);
      }
      while (v17 == Attribute || v17 && Attribute && CFEqual(v17, Attribute));
      if (v16 <= location) {
        CFIndex v18 = location;
      }
      else {
        CFIndex v18 = v16;
      }
      if (v13 >= v14) {
        CFIndex v19 = v14;
      }
      else {
        CFIndex v19 = v13;
      }
      longestEffectiveRange->CFIndex location = v18;
      longestEffectiveRange->CFIndex length = v19 - v18;
    }
    return Attribute;
  }
}

CFTypeRef CFAttributedStringGetAttribute(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return (CFTypeRef)[(__CFAttributedString *)aStr attribute:attrName atIndex:loc effectiveRange:effectiveRange];
  }
  else
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), loc, &effectiveRange->location, 0);
    return CFDictionaryGetValue(ValueAtIndex, attrName);
  }
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  if (!CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    if (!length) {
      return;
    }
    while (1)
    {
      CFIndex v18 = 0;
      CFIndex v19 = 0;
      CFDictionaryRef ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), location, &v18, 0);
      unint64_t v10 = ValueAtIndex;
      uint64_t v12 = v18;
      uint64_t v11 = v19;
      BOOL v13 = v18 == location && v19 <= length;
      if (!v13) {
        goto LABEL_14;
      }
      if (CFGetRetainCount(ValueAtIndex) != 1) {
        break;
      }
      CFDictionarySetValue(v10, attrName, value);
LABEL_22:
      location += v19;
      length -= v19;
      if (!length) {
        return;
      }
    }
    uint64_t v12 = v18;
    uint64_t v11 = v19;
LABEL_14:
    BOOL v13 = v12 < location;
    uint64_t v14 = v12 - location;
    if (v13)
    {
      v11 += v14;
      CFIndex v18 = location;
      CFIndex v19 = v11;
    }
    if (v11 > length) {
      CFIndex v19 = length;
    }
    CFTypeRef v15 = CFDictionaryGetValue(v10, attrName);
    if (!v15 || !CFEqual(v15, value))
    {
      CFAllocatorRef v16 = CFGetAllocator(aStr);
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v16, v10);
      CFDictionarySetValue(AttributesDictionary, attrName, value);
      CFRunArrayReplace(*((void **)aStr + 3), v18, v19, AttributesDictionary, v19);
      CFRelease(AttributesDictionary);
    }
    goto LABEL_22;
  }

  -[__CFAttributedString addAttribute:value:range:](aStr, "addAttribute:value:range:", attrName, value, location, length);
}

__CFAttributedString *__CFAttributedStringCreateMutableWithSubstring(const __CFAllocator *a1, CFStringRef *a2, CFIndex a3, CFIndex a4)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  CFMutableDictionaryRef Mutable = CFAttributedStringCreateMutable(a1, 0);
  v19.CFIndex location = a3;
  v19.CFIndex length = a4;
  CFStringRef v9 = CFStringCreateWithSubstring(a1, a2[2], v19);
  v18.CFIndex location = 0;
  v18.CFIndex length = 0;
  CFAttributedStringReplaceString(Mutable, v18, v9);
  CFRelease(v9);
  if (a4 >= 1)
  {
    CFIndex v10 = a3 + a4;
    CFIndex v11 = a3;
    do
    {
      effectiveRange.CFIndex location = 0;
      effectiveRange.CFIndex length = 0;
      CFDictionaryRef Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)a2, v11, &effectiveRange);
      if (effectiveRange.location + effectiveRange.length <= v10) {
        v13.CFIndex length = effectiveRange.location - v11 + effectiveRange.length;
      }
      else {
        v13.CFIndex length = v10 - v11;
      }
      if (effectiveRange.location != v11 || effectiveRange.location + effectiveRange.length > v10) {
        effectiveRange.CFIndex length = v13.length;
      }
      v13.CFIndex location = v11 - a3;
      CFAttributedStringSetAttributes(Mutable, v13, Attributes, 1u);
      v11 += effectiveRange.length;
    }
    while (v11 < v10);
  }
  return Mutable;
}

CFDictionaryRef CFAttributedStringGetAttributesAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFRange inRange, CFRange *longestEffectiveRange)
{
  CFIndex length = inRange.length;
  CFIndex location = inRange.location;
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return (CFDictionaryRef)-[__CFAttributedString attributesAtIndex:longestEffectiveRange:inRange:](aStr, "attributesAtIndex:longestEffectiveRange:inRange:", loc, longestEffectiveRange, location, length);
  }
  else
  {
    CFDictionaryRef Attributes = CFAttributedStringGetAttributes(aStr, loc, longestEffectiveRange);
    if (longestEffectiveRange)
    {
      CFRange v18 = *longestEffectiveRange;
      CFIndex v11 = location + length;
      do
      {
        CFIndex v12 = v18.length + v18.location;
        if (v18.length + v18.location >= v11) {
          break;
        }
        CFDictionaryRef v13 = CFAttributedStringGetAttributes(aStr, v18.length + v18.location, &v18);
      }
      while (CFEqual(v13, Attributes));
      CFRange v18 = *longestEffectiveRange;
      do
      {
        CFIndex v14 = v18.location;
        if (v18.location <= location) {
          break;
        }
        CFDictionaryRef v15 = CFAttributedStringGetAttributes(aStr, v18.location - 1, &v18);
      }
      while (CFEqual(v15, Attributes));
      if (v14 <= location) {
        CFIndex v16 = location;
      }
      else {
        CFIndex v16 = v14;
      }
      if (v11 >= v12) {
        CFIndex v17 = v12;
      }
      else {
        CFIndex v17 = v11;
      }
      longestEffectiveRange->CFIndex location = v16;
      longestEffectiveRange->CFIndex length = v17 - v16;
    }
    return Attributes;
  }
}

CFDictionaryRef CFAttributedStringGetAttributes(CFAttributedStringRef aStr, CFIndex loc, CFRange *effectiveRange)
{
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return (CFDictionaryRef)[(__CFAttributedString *)aStr attributesAtIndex:loc effectiveRange:effectiveRange];
  }
  else
  {
    uint64_t v7 = *((void *)aStr + 3);
    return (CFDictionaryRef)CFRunArrayGetValueAtIndex(v7, loc, &effectiveRange->location, 0);
  }
}

uint64_t CFRunArrayGetValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = blockForLocation(*(void *)(a1 + 16), a2, a3);
  if (a4) {
    *a4 = v6;
  }
  return *(void *)(*(void *)(a1 + 16) + 16 * v6 + 56);
}

uint64_t blockForLocation(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 >= 0) {
    uint64_t v4 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v4 = v3 + 1;
  }
  if (a2 <= v4 >> 1)
  {
    uint64_t v3 = 0;
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
  }
  uint64_t v6 = a1 + 16 * v5;
  if (v3 <= a2)
  {
    --v5;
    CFIndex v11 = (uint64_t *)(v6 + 48);
    do
    {
      uint64_t v12 = v3;
      uint64_t v13 = *v11;
      v11 += 2;
      uint64_t v9 = v13;
      v3 += v13;
      ++v5;
    }
    while (v3 <= a2);
    uint64_t v3 = v12;
  }
  else
  {
    uint64_t v7 = (uint64_t *)(v6 + 32);
    do
    {
      uint64_t v8 = v5--;
      uint64_t v10 = *v7;
      v7 -= 2;
      uint64_t v9 = v10;
      v3 -= v10;
    }
    while (v8 >= 2 && v3 > a2);
  }
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = v3;
  if (a3)
  {
    *a3 = v3;
    a3[1] = v9;
  }
  return v5;
}

void CFAttributedStringSetAttributes(CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
  unint64_t v4 = MEMORY[0x1F4188790](aStr, range.location);
  int v6 = v5;
  CFDictionaryRef v8 = v7;
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  uint64_t v13 = (uint64_t *)v4;
  uint64_t v107 = *(void *)off_1ECE0A5B0;
  int v14 = CF_IS_OBJC(0x3EuLL, v4);
  if (v6)
  {
    if (v14)
    {
      objc_msgSend(v13, "setAttributes:range:", v8, v12, v10);
    }
    else if (v10)
    {
      CFAllocatorRef v15 = CFGetAllocator(v13);
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v15, v8);
      CFRunArrayReplace((void *)v13[3], v12, v10, AttributesDictionary, v10);
      CFRelease(AttributesDictionary);
    }
    return;
  }
  if (v14)
  {
    objc_msgSend(v13, "addAttributes:range:", v8, v12, v10);
    return;
  }
  unint64_t Count = CFDictionaryGetCount(v8);
  if (!Count) {
    return;
  }
  unint64_t v18 = Count;
  long long v106 = 0u;
  long long v105 = 0u;
  long long v104 = 0u;
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  long long v99 = 0u;
  long long v98 = 0u;
  long long v97 = 0u;
  long long v96 = 0u;
  long long v95 = 0u;
  long long v94 = 0u;
  long long v93 = 0u;
  long long v92 = 0u;
  long long v91 = 0u;
  long long v90 = 0u;
  long long v89 = 0u;
  long long v88 = 0u;
  long long v87 = 0u;
  long long v86 = 0u;
  long long v85 = 0u;
  long long v84 = 0u;
  long long v83 = 0u;
  long long v82 = 0u;
  long long v81 = 0u;
  long long v80 = 0u;
  long long v79 = 0u;
  long long v78 = 0u;
  long long v77 = 0u;
  long long v76 = 0u;
  *(_OWORD *)keys = 0u;
  if (Count >= 0xFFFFFFFFFFFFFFFLL) {
    CFAttributedStringSetAttributes_cold_1();
  }
  if (Count > 0x100)
  {
    uint64_t v20 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    *(_OWORD *)values = 0u;
    long long v44 = 0u;
    uint64_t v19 = (const void **)malloc_type_malloc(8 * v18, 0xC0040B8AA526DuLL);
  }
  else
  {
    long long v73 = 0uLL;
    long long v74 = 0uLL;
    long long v71 = 0uLL;
    long long v72 = 0uLL;
    long long v69 = 0uLL;
    long long v70 = 0uLL;
    long long v67 = 0uLL;
    long long v68 = 0uLL;
    long long v65 = 0uLL;
    long long v66 = 0uLL;
    long long v63 = 0uLL;
    long long v64 = 0uLL;
    long long v61 = 0uLL;
    long long v62 = 0uLL;
    long long v59 = 0uLL;
    long long v60 = 0uLL;
    long long v57 = 0uLL;
    long long v58 = 0uLL;
    long long v55 = 0uLL;
    long long v56 = 0uLL;
    long long v53 = 0uLL;
    long long v54 = 0uLL;
    long long v51 = 0uLL;
    long long v52 = 0uLL;
    long long v49 = 0uLL;
    long long v50 = 0uLL;
    long long v47 = 0uLL;
    long long v48 = 0uLL;
    long long v45 = 0uLL;
    long long v46 = 0uLL;
    uint64_t v19 = (const void **)values;
    uint64_t v20 = (const void **)keys;
    *(_OWORD *)values = 0uLL;
    long long v44 = 0uLL;
  }
  CFDictionaryGetKeysAndValues(v8, v20, v19);
  if (v10)
  {
    while (1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      CFDictionaryRef ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(v13[3], v12, &v41, 0);
      v22 = ValueAtIndex;
      uint64_t v24 = v41;
      uint64_t v23 = v42;
      BOOL v25 = v41 == v12 && v42 <= v10;
      if (!v25) {
        goto LABEL_29;
      }
      long long v26 = v20;
      BOOL v27 = v19;
      unint64_t v28 = v18;
      if (CFGetRetainCount(ValueAtIndex) != 1) {
        break;
      }
      do
      {
        long long v30 = *v26++;
        long long v29 = v30;
        long long v31 = *v27++;
        CFDictionarySetValue(v22, v29, v31);
        --v28;
      }
      while (v28);
LABEL_37:
      v12 += v42;
      v10 -= v42;
      if (!v10) {
        goto LABEL_38;
      }
    }
    uint64_t v24 = v41;
    uint64_t v23 = v42;
LABEL_29:
    BOOL v25 = v24 < v12;
    uint64_t v32 = v24 - v12;
    if (v25)
    {
      v23 += v32;
      uint64_t v41 = v12;
      uint64_t v42 = v23;
    }
    if (v23 > v10) {
      uint64_t v42 = v10;
    }
    CFAllocatorRef v33 = CFGetAllocator(v13);
    v34 = __CFAttributedStringCreateAttributesDictionary(v33, v22);
    v35 = v20;
    v36 = v19;
    unint64_t v37 = v18;
    do
    {
      v39 = *v35++;
      v38 = v39;
      v40 = *v36++;
      CFDictionarySetValue(v34, v38, v40);
      --v37;
    }
    while (v37);
    CFRunArrayReplace((void *)v13[3], v41, v42, v34, v42);
    CFRelease(v34);
    goto LABEL_37;
  }
LABEL_38:
  if (v20 != (const void **)keys) {
    free(v20);
  }
  if (v19 != (const void **)values) {
    free(v19);
  }
}

__CFString *_internString(__CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef Value = @"kCFPreferencesAnyApplication";
  if (!CFEqual(a1, @"kCFPreferencesAnyApplication"))
  {
    if (((unint64_t)a1 & 0x8000000000000000) != 0 || CFGetRetainCount(a1) == 0xFFFFFFFFFFFFFFFLL)
    {
      return a1;
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)&_internString_lock);
      CFSetRef Mutable = (const __CFSet *)_internString_table;
      if (!_internString_table)
      {
        CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        _internString_table = (uint64_t)Mutable;
      }
      CFStringRef Value = (__CFString *)CFSetGetValue(Mutable, a1);
      if (!Value)
      {
        CFSetAddValue((CFMutableSetRef)_internString_table, a1);
        CFStringRef Value = a1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&_internString_lock);
      CFRetain(Value);
    }
  }
  return Value;
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  if (!cf) {
    CFGetRetainCount_cold_1();
  }
  if (((unint64_t)cf & 0x8000000000000000) != 0) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v3 = atomic_load((unint64_t *)cf + 1);
  if (CF_IS_OBJC((v3 >> 8) & 0x3FF, (unint64_t)cf))
  {
    return [(id)cf retainCount];
  }
  else
  {
    unint64_t v4 = atomic_load((unint64_t *)cf + 1);
    if ((v4 & 0x800000) != 0)
    {
      __CFCheckCFInfoPACSignature_Bridged((uint64_t)cf);
      unint64_t v7 = (v4 >> 8) & 0x3FF;
      if (v7 > 0x47) {
        CFDictionaryRef v8 = (_UNKNOWN **)(__CFRuntimeClassTables[(v7 - 72) >> 6] + 8 * ((v7 - 72) & 0x3F));
      }
      else {
        CFDictionaryRef v8 = &__CFRuntimeBuiltinClassTable + v7;
      }
      uint64_t v9 = *v8;
      uint64_t v10 = (unsigned int (*)(void, CFTypeRef))*((void *)*v8 + 10);
      if (v10 && (*v9 & 8) != 0)
      {
        if (v4 > 0xFFFEFFFFFFFFFFFFLL) {
          return v10(0, cf);
        }
      }
      else
      {
        __break(1u);
      }
      CFGetRetainCount_cold_2();
    }
    unint64_t v5 = atomic_load((unint64_t *)cf + 1);
    CFIndex v6 = HIWORD(v5);
    if (v6) {
      return v6;
    }
    else {
      return 0xFFFFFFFFFFFFFFFLL;
    }
  }
}

CFMutableDictionaryRef __CFAttributedStringCreateAttributesDictionary(const __CFAllocator *a1, CFDictionaryRef theDict)
{
  if (theDict) {
    return CFDictionaryCreateMutableCopy(a1, 0, theDict);
  }
  else {
    return CFDictionaryCreateMutable(a1, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

void CFRunArrayReplace(void *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5)
{
  uint64_t v44 = *(void *)off_1ECE0A5B0;
  if (a3)
  {
    CFIndex v6 = a4;
    uint64_t v10 = (uint64_t *)a1[2];
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    if (a5) {
      uint64_t v11 = a4;
    }
    else {
      uint64_t v11 = 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
    if (*v10 >= 2)
    {
      __CFRunArrayMakeNewList(a1, v10);
      uint64_t v10 = (uint64_t *)a1[2];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    uint64_t v12 = blockForLocation((uint64_t)v10, a2, &v42);
    uint64_t v13 = v12;
    v10[1] -= a3;
    uint64_t v41 = a2;
    if (v43 - a2 + v42 >= a3) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = v43 - a2 + v42;
    }
    CFAllocatorRef v15 = &v10[2 * v12];
    uint64_t v17 = v15[6];
    CFIndex v16 = v15 + 6;
    uint64_t v18 = v17 - v14;
    uint64_t *v16 = v17 - v14;
    if (v17 == v14)
    {
      CFRelease((CFTypeRef)v10[2 * v12 + 7]);
      uint64_t v18 = *v16;
    }
    if (v18) {
      uint64_t v19 = v13 + 1;
    }
    else {
      uint64_t v19 = v13;
    }
    uint64_t v20 = a3 - v14;
    if (v20)
    {
      uint64_t v21 = (uint64_t)&v10[2 * v13 + 8];
      do
      {
        uint64_t v22 = *(void *)v21;
        if (v20 >= *(void *)v21) {
          uint64_t v23 = *(void *)v21;
        }
        else {
          uint64_t v23 = v20;
        }
        *(void *)uint64_t v21 = v22 - v23;
        if (v22 <= v20) {
          CFRelease(*(CFTypeRef *)(v21 + 8));
        }
        v21 += 16;
        ++v13;
        v20 -= v23;
      }
      while (v20);
    }
    if (v13) {
      v13 -= v10[2 * v13 + 6] != 0;
    }
    if (v19 > v13)
    {
      CFIndex v6 = v11;
LABEL_47:
      if (v6) {
        CFRunArrayInsert(a1, v41, a5, v6);
      }
      return;
    }
    uint64_t v24 = v19 - 1;
    if (v19 < 1)
    {
      if (!v11) {
        goto LABEL_40;
      }
    }
    else
    {
      if (v19 == v10[4])
      {
        uint64_t v25 = v10[5] - v10[2 * v24 + 6];
        v10[4] = v24;
        v10[5] = v25;
      }
      if (!v11)
      {
LABEL_37:
        uint64_t v29 = v13 + 1;
        if (v13 + 1 < v10[2])
        {
          uint64_t v30 = (uint64_t)&v10[2 * v29 + 6];
          uint64_t v32 = *(const void **)(v30 + 8);
          long long v31 = (CFTypeRef *)(v30 + 8);
          if (CFEqual((CFTypeRef)v10[2 * v24 + 7], v32))
          {
            v10[2 * v24 + 6] += v10[2 * v29 + 6];
            CFRelease(*v31);
            CFIndex v6 = 0;
            ++v13;
            goto LABEL_41;
          }
        }
LABEL_40:
        CFIndex v6 = 0;
LABEL_41:
        if (v19 <= v13)
        {
          uint64_t v33 = v10[2];
          uint64_t v34 = v33 + ~v13;
          if (v34 >= 1)
          {
            v35 = &v10[2 * v13 + 8];
            v36 = &v10[2 * v19 + 6];
            do
            {
              long long v37 = *(_OWORD *)v35;
              v35 += 2;
              *(_OWORD *)v36 = v37;
              v36 += 2;
              --v34;
            }
            while (v34);
            uint64_t v33 = v10[2];
          }
          uint64_t v38 = v33 + v19 - (v13 + 1);
          v10[2] = v38;
          __CFRunArraySetBlockCapacity(a1, v38);
        }
        goto LABEL_47;
      }
      long long v26 = &v10[2 * v24];
      if (CFEqual((CFTypeRef)v26[7], v11))
      {
        v26[6] += a5;
        v10[1] += a5;
        goto LABEL_37;
      }
    }
    uint64_t v27 = v10[2];
    if (v13 + 1 < v27)
    {
      unint64_t v28 = &v10[2 * v13 + 2];
      if (CFEqual((CFTypeRef)v28[7], v11))
      {
        v28[6] += a5;
        v10[1] += a5;
        if (v19 < 1) {
          goto LABEL_40;
        }
        goto LABEL_37;
      }
      uint64_t v27 = v10[2];
    }
    if (v19 < v27)
    {
      CFTypeRef v39 = CFRetain(v6);
      CFIndex v6 = 0;
      v40 = &v10[2 * v19];
      v40[6] = a5;
      v40[7] = (uint64_t)v39;
      v10[1] += a5;
      ++v19;
    }
    goto LABEL_41;
  }
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    -[__CFAttributedString replaceCharactersInRange:withString:](aStr, "replaceCharactersInRange:withString:", location, length, replacement);
    return;
  }
  CFIndex v7 = CFStringGetLength(replacement);
  uint64_t v8 = v7;
  if (v7 >= 1)
  {
    if (length >= 1)
    {
      CFDictionaryRef ValueAtIndex = (const void *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), location, 0, 0);
      CFRetain(ValueAtIndex);
      goto LABEL_10;
    }
    uint64_t v10 = location - 1;
    if (location < 1)
    {
      if (CFStringGetLength(*((CFStringRef *)aStr + 2)) < 1)
      {
        CFAllocatorRef v14 = CFGetAllocator(aStr);
        CFDictionaryRef ValueAtIndex = CFDictionaryCreateMutable(v14, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
LABEL_19:
        CFRunArrayInsert(*((CFTypeRef *)aStr + 3), location, v8, ValueAtIndex);
        if (ValueAtIndex)
        {
LABEL_20:
          CFRelease(ValueAtIndex);
          goto LABEL_21;
        }
        goto LABEL_21;
      }
      uint64_t v11 = *((void *)aStr + 3);
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v11 = *((void *)aStr + 3);
    }
    CFDictionaryRef ValueAtIndex = (const void *)CFRunArrayGetValueAtIndex(v11, v10, 0, 0);
    CFRetain(ValueAtIndex);
    goto LABEL_19;
  }
  if (length >= 1)
  {
    CFDictionaryRef ValueAtIndex = 0;
LABEL_10:
    CFRunArrayReplace(*((void **)aStr + 3), location, length, ValueAtIndex, v8);
    if (!ValueAtIndex) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (v7)
  {
    CFDictionaryRef ValueAtIndex = 0;
    goto LABEL_19;
  }
LABEL_21:
  uint64_t v12 = (__CFString *)*((void *)aStr + 2);
  v13.CFIndex location = location;
  v13.CFIndex length = length;

  CFStringReplace(v12, v13, replacement);
}

CFTypeRef CFRunArrayInsert(CFTypeRef result, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t v31 = *(void *)off_1ECE0A5B0;
  if (a3)
  {
    CFIndex v7 = result;
    uint64_t v8 = (uint64_t *)*((void *)result + 2);
    os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
    if (*v8 >= 2)
    {
      __CFRunArrayMakeNewList(v7, v8);
      uint64_t v8 = (uint64_t *)v7[2];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    if (a2 == v8[1])
    {
      if (a2 < 1)
      {
        __CFRunArraySetBlockCapacity(v7, 1);
        uint64_t v8 = (uint64_t *)v7[2];
        CFAttributedStringRef result = CFRetain(a4);
        v8[6] = a3;
        v8[7] = (uint64_t)result;
        uint64_t v14 = v8[2];
      }
      else
      {
        CFAttributedStringRef result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v8[2 * v8[2] + 5]);
        uint64_t v9 = v8[2];
        if (result)
        {
          v8[2 * v9 + 4] += a3;
          if (v8[4] >= v9) {
            v8[5] += a3;
          }
          goto LABEL_21;
        }
        __CFRunArraySetBlockCapacity(v7, v9 + 1);
        uint64_t v8 = (uint64_t *)v7[2];
        CFAttributedStringRef result = CFRetain(a4);
        uint64_t v14 = v8[2];
        uint64_t v17 = &v8[2 * v14];
        v17[6] = a3;
        v17[7] = (uint64_t)result;
      }
      v8[2] = v14 + 1;
LABEL_21:
      v8[1] += a3;
      return result;
    }
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v10 = blockForLocation((uint64_t)v8, a2, &v29);
    uint64_t v11 = &v8[2 * v10];
    CFAttributedStringRef result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v11[7]);
    if (result)
    {
      uint64_t v12 = v11 + 6;
LABEL_11:
      uint64_t v13 = a3;
LABEL_12:
      *v12 += v13;
      goto LABEL_21;
    }
    uint64_t v15 = v29;
    if (v10 >= 1 && v29 == a2)
    {
      CFIndex v16 = &v8[2 * v10 - 2];
      CFAttributedStringRef result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v16[7]);
      if (result)
      {
        v16[6] += a3;
        if (v8[4] < v10) {
          goto LABEL_21;
        }
        uint64_t v12 = v8 + 5;
        goto LABEL_11;
      }
      uint64_t v15 = v29;
    }
    uint64_t v18 = v8[2];
    if (v15 == a2)
    {
      __CFRunArraySetBlockCapacity(v7, v18 + 1);
      uint64_t v8 = (uint64_t *)v7[2];
      uint64_t v12 = v8 + 2;
      uint64_t v19 = v8[2];
      if (v19 > v10)
      {
        uint64_t v20 = &v8[2 * v19 + 6];
        do
        {
          --v19;
          *(_OWORD *)uint64_t v20 = *((_OWORD *)v20 - 1);
          v20 -= 2;
        }
        while (v19 > v10);
      }
      CFAttributedStringRef result = CFRetain(a4);
      uint64_t v21 = &v8[2 * v10];
      v21[6] = a3;
      v21[7] = (uint64_t)result;
      uint64_t v13 = 1;
    }
    else
    {
      __CFRunArraySetBlockCapacity(v7, v18 + 2);
      uint64_t v8 = (uint64_t *)v7[2];
      uint64_t v12 = v8 + 2;
      uint64_t v22 = v8[2];
      uint64_t v23 = v10 + 2;
      if (v22 + 1 >= v10 + 2)
      {
        uint64_t v24 = v22 + 2;
        uint64_t v25 = &v8[2 * v22 + 8];
        do
        {
          *(_OWORD *)uint64_t v25 = *((_OWORD *)v25 - 2);
          v25 -= 2;
          --v24;
        }
        while (v24 > v23);
      }
      CFTypeRef v26 = CFRetain(a4);
      uint64_t v27 = (uint64_t)&v8[2 * v10 + 6];
      *(void *)(v27 + 16) = a3;
      *(void *)(v27 + 24) = v26;
      *(void *)uint64_t v27 = a2 - v29;
      CFAttributedStringRef result = CFRetain(*(CFTypeRef *)(v27 + 8));
      unint64_t v28 = &v8[2 * v23 + 6];
      v28[1] = (uint64_t)result;
      *unint64_t v28 = v30 - a2 + v29;
      uint64_t v13 = 2;
    }
    goto LABEL_12;
  }
  return result;
}

void *__CFRunArraySetBlockCapacity(void *result, uint64_t a2)
{
  if (a2 <= 1) {
    uint64_t v2 = 1;
  }
  else {
    uint64_t v2 = a2;
  }
  uint64_t v3 = *(void *)(result[2] + 24);
  if (v3 >= 0) {
    uint64_t v4 = *(void *)(result[2] + 24);
  }
  else {
    uint64_t v4 = v3 + 1;
  }
  uint64_t v5 = v4 >> 1;
  if (v3 < v2 || v5 > v2)
  {
    CFIndex v7 = result;
    unint64_t v8 = v2 + 3;
    CFAllocatorRef v9 = CFGetAllocator(result);
    CFAttributedStringRef result = (void *)__CFSafelyReallocateWithAllocatorTyped(v9, v7[2], ((v8 / 3) << 6) | 0x30, 1344524507, 0, 0);
    v7[2] = result;
    result[3] = 4 * (v8 / 3);
  }
  return result;
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  uint64_t Instance = (__CFAttributedString *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x3EuLL, 16, 0);
  if (Instance)
  {
    *((void *)Instance + 2) = CFStringCreateMutable(alloc, maxLength);
    *((void *)Instance + 3) = CFRunArrayCreate((__objc2_class **)alloc);
  }
  return Instance;
}

void *_CFRunArrayCreateWithGuts(__objc2_class **a1, uint64_t a2)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance(a1, 0x3FuLL, 8, 0);
  uint64_t v4 = Instance;
  if (Instance)
  {
    if (a2)
    {
      Instance[2] = a2;
      os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
      ++*(void *)v4[2];
      os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    }
    else
    {
      CFAllocatorRef v5 = CFGetAllocator(Instance);
      Typed = (void *)CFAllocatorAllocateTyped(v5, 80, 1930815021, 0);
      Typed[2] = 0;
      Typed[3] = 2;
      Typed[4] = 0;
      Typed[5] = 0;
      void *Typed = 1;
      Typed[1] = 0;
      v4[2] = Typed;
    }
  }
  return v4;
}

void *CFRunArrayCreate(__objc2_class **a1)
{
  return _CFRunArrayCreateWithGuts(a1, 0);
}

CFMutableDictionaryRef _CFXPreferencesCopyDictionaryForSourceWithBundleID(__CFString *a1)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  CFMutableDictionaryRef v3 = -[_CFXPreferences copyDictionaryForSourceWithIdentifier:]((uint64_t)v2, a1);

  return v3;
}

void sub_182C2D978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C2DE90(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  uint64_t v3 = MEMORY[0x1F4188790](allocator, capacity);
  CFDictionaryRef v5 = (const __CFDictionary *)v4;
  CFIndex v6 = (__objc2_class **)v3;
  uint64_t v47 = *(void *)off_1ECE0A5B0;
  if (!CF_IS_OBJC(0x12uLL, v4))
  {
    Copy = (__CFDictionary *)CFBasicHashCreateCopy(v6, (uint64_t)v5);
LABEL_21:
    if (Copy)
    {
      _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x12uLL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
    return Copy;
  }
  if (&__kCFAllocatorSystemDefault != v6
    && (v6 || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    CFIndex Count = CFDictionaryGetCount(v5);
    long long v46 = 0u;
    long long v45 = 0u;
    long long v44 = 0u;
    long long v43 = 0u;
    long long v42 = 0u;
    long long v41 = 0u;
    long long v40 = 0u;
    long long v39 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    long long v33 = 0u;
    long long v32 = 0u;
    long long v31 = 0u;
    long long v30 = 0u;
    long long v29 = 0u;
    long long v28 = 0u;
    long long v27 = 0u;
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    long long v21 = 0u;
    long long v20 = 0u;
    long long v19 = 0u;
    long long v18 = 0u;
    long long v17 = 0u;
    long long v16 = 0u;
    *(_OWORD *)values = 0u;
    memset(v14, 0, 512);
    if (Count >= 257)
    {
      Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
      unint64_t v8 = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    }
    else
    {
      unint64_t v8 = (const void **)v14;
      Typed = values;
    }
    CFDictionaryGetKeysAndValues(v5, v8, (const void **)Typed);
    uint64_t Generic = __CFDictionaryCreateGeneric(v6, (uint64_t)&kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    Copy = (__CFDictionary *)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (CFIndex i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, (unint64_t)v8[i], (uint64_t)Typed[i]);
    }
    if (v8 != (const void **)v14 && v8 != (const void **)Typed) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
    }
    if (Typed != values) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    goto LABEL_21;
  }

  return (CFMutableDictionaryRef)[(__CFDictionary *)v5 _cfMutableCopy];
}

_DWORD *_NSDictionaryI_mutableCopyWithZone(void *a1, uint64_t a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  unint64_t v3 = a1[1] & 0x1FFFFFFFFFFFFFFLL;
  if (v3) {
    uint64_t v4 = 2 * v3;
  }
  else {
    uint64_t v4 = 1;
  }
  unint64_t v5 = MEMORY[0x1F4188790](v4, a2);
  CFIndex v7 = (char *)&v11 - v6;
  size_t v11 = 0;
  if (v3 >= 0x81)
  {
    CFIndex v7 = (char *)_CFCreateArrayStorage(v5, 0, &v11);
    unint64_t v8 = v7;
  }
  else
  {
    unint64_t v8 = 0;
  }
  objc_msgSend(a1, "getObjects:andKeys:count:", &v7[8 * v3], v7, v3, v11, v12);
  CFAllocatorRef v9 = __NSDictionaryM_new((uint64_t)v7, (uint64_t)&v7[8 * v3], v3, 2uLL);
  free(v8);
  return v9;
}

void sub_182C2E894(_Unwind_Exception *exception_object)
{
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    return (CFSetRef)[(__CFSet *)theSet copyWithZone:0];
  }
  else
  {
    Copy = (unint64_t *)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theSet);
    CFSetRef v6 = (const __CFSet *)Copy;
    if (Copy)
    {
      unint64_t v7 = atomic_load(Copy + 1);
      unint64_t v8 = v7;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)Copy + 1, &v8, v7 | 0x40);
        BOOL v9 = v8 == v7;
        unint64_t v7 = v8;
      }
      while (!v9);
      _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x11uLL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
    return v6;
  }
}

uint64_t CFBasicHashCreateCopy(__objc2_class **a1, uint64_t a2)
{
  __int16 v4 = *(_WORD *)(a2 + 18);
  uint64_t v5 = 56;
  if ((v4 & 4) == 0) {
    uint64_t v5 = 48;
  }
  if ((v4 & 0x18) != 0) {
    uint64_t v6 = v5 + 8;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a2 + 26)];
  if (v7 < 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    goto LABEL_21;
  }
  if ((unint64_t)(v7 - 0x1000000000000000) >> 61 != 7) {
    goto LABEL_82;
  }
  uint64_t Typed = CFAllocatorAllocateTyped(a1, 8 * v7, 1211813924, 0);
  if (!Typed) {
    return 0;
  }
  uint64_t v9 = Typed;
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  if ((*(_WORD *)(a2 + 18) & 4) != 0)
  {
    uint64_t v11 = CFAllocatorAllocateTyped(a1, 8 * v7, 1211813924, 0);
    if (!v11) {
      return 0;
    }
    uint64_t v10 = v11;
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  unint64_t v12 = *(unsigned __int16 *)(a2 + 18);
  if ((v12 & 0x18) == 0)
  {
LABEL_21:
    uint64_t v14 = 0;
    goto LABEL_22;
  }
  uint64_t v13 = CFAllocatorAllocateTyped(a1, v7 << ((v12 >> 5) & 3), 1211813924, 0);
  if (!v13) {
    return 0;
  }
  uint64_t v14 = (void *)v13;
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
LABEL_22:
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 3uLL, v6 - 16, 0);
  uint64_t v16 = Instance;
  if (Instance)
  {
    uint64_t v17 = *(void *)(a2 + 32);
    *(_OWORD *)(Instance + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(Instance + 32) = v17 & 0xFFFFFFFFFFFFFFF7;
    *(_WORD *)(Instance + 16) = 1;
    if (v7)
    {
      unint64_t v18 = *(unsigned __int16 *)(a2 + 18);
      if ((v18 & 4) != 0) {
        uint64_t v19 = *(void *)(a2 + 8 * ((v18 >> 2) & 1) + 40);
      }
      else {
        uint64_t v19 = 0;
      }
      if ((v18 & 0x18) != 0) {
        long long v20 = *(void **)(a2 + (v18 & 0x18) + 40);
      }
      else {
        long long v20 = 0;
      }
      uint64_t v21 = *(void *)(a2 + 40);
      *(void *)(Instance + 40) = v9;
      if (v10) {
        *(void *)(Instance + 8 * (((unint64_t)*(unsigned __int16 *)(Instance + 18) >> 2) & 1) + 40) = v10;
      }
      __src = v20;
      if (v14) {
        *(void *)(Instance + (*(_WORD *)(Instance + 18) & 0x18) + 40) = v14;
      }
      if (v7 >= 1)
      {
        uint64_t v22 = 0;
        long long v41 = (const CFAllocatorRef *)(Instance - 16);
        do
        {
          uint64_t v23 = *(void *)(v21 + 8 * v22);
          if ((unint64_t)(v23 - 1) > 0xFFFFFFFFFFFFFFFDLL)
          {
            *(void *)(*(void *)(v16 + 40) + 8 * v22) = v23;
            if (v10)
            {
              unint64_t v38 = *(unsigned __int16 *)(v16 + 18);
              if ((v38 & 4) == 0) {
                goto LABEL_81;
              }
              *(void *)(*(void *)(v16 + 8 * ((v38 >> 2) & 1) + 40) + 8 * v22) = v23;
            }
          }
          else
          {
            if (v23 == 2814029233) {
              uint64_t v23 = 0;
            }
            if (v23 == 2780474809) {
              uint64_t v24 = -1;
            }
            else {
              uint64_t v24 = v23;
            }
            if ((*(void *)(v16 + 32) & 2) == 0)
            {
              long long v25 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(v16 + 24) >> 39) & 0x1FLL]
                                                                            + 8
                                                                            * ((*(void *)(v16 + 24) >> 34) & 0x1FLL));
              if (v25)
              {
                long long v26 = &kCFAllocatorSystemDefault;
                if ((v16 & 0x8000000000000000) == 0)
                {
                  char v27 = atomic_load((unint64_t *)(v16 + 8));
                  BOOL v28 = (v27 & 0x80) == 0;
                  long long v26 = v41;
                  if (!v28) {
                    long long v26 = &kCFAllocatorSystemDefault;
                  }
                }
                uint64_t v24 = v25(*v26, v24);
              }
            }
            if (v24) {
              uint64_t v29 = v24;
            }
            else {
              uint64_t v29 = 2814029233;
            }
            if (v29 == -1) {
              uint64_t v29 = 2780474809;
            }
            *(void *)(*(void *)(v16 + 40) + 8 * v22) = v29;
            if (v10)
            {
              uint64_t v30 = *(void *)(v19 + 8 * v22);
              if (v30 == 2814029233) {
                uint64_t v30 = 0;
              }
              if (v30 == 2780474809) {
                uint64_t v31 = -1;
              }
              else {
                uint64_t v31 = v30;
              }
              if ((*(void *)(v16 + 32) & 2) == 0)
              {
                long long v32 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v16 + 27) >> 5) & 0x1F]
                                                                              + 8 * (*(_DWORD *)(v16 + 27) & 0x1FLL));
                if (v32)
                {
                  long long v33 = &kCFAllocatorSystemDefault;
                  if ((v16 & 0x8000000000000000) == 0)
                  {
                    char v34 = atomic_load((unint64_t *)(v16 + 8));
                    BOOL v28 = (v34 & 0x80) == 0;
                    long long v33 = v41;
                    if (!v28) {
                      long long v33 = &kCFAllocatorSystemDefault;
                    }
                  }
                  uint64_t v31 = v32(*v33, v31);
                }
              }
              unint64_t v35 = *(unsigned __int16 *)(v16 + 18);
              if ((v35 & 4) == 0)
              {
LABEL_81:
                __break(1u);
LABEL_82:
                CFBasicHashCreateCopy_cold_1();
              }
              uint64_t v36 = *(void *)(v16 + 8 * ((v35 >> 2) & 1) + 40);
              if (v31) {
                uint64_t v37 = v31;
              }
              else {
                uint64_t v37 = 2814029233;
              }
              if (v37 == -1) {
                uint64_t v37 = 2780474809;
              }
              *(void *)(v36 + 8 * v22) = v37;
            }
          }
          ++v22;
        }
        while (v7 != v22);
      }
      if (v14 && __src) {
        memmove(v14, __src, v7 << (((unint64_t)*(unsigned __int16 *)(v16 + 18) >> 5) & 3));
      }
    }
  }
  return v16;
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict replaceObject:value forKey:key];
  }
  else
  {
    char v12 = atomic_load((unint64_t *)theDict + 1);
    if ((v12 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function", v6, v7, v8, v9, v10, v11, (__int16)"void CFDictionaryReplaceValue(CFMutableDictionaryRef, const void *, const void *)");
    }
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if (v13)
    {
      uint64_t v14 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        uint64_t v14 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v14;
      }
      objc_msgSend(theDict, v14, key);
    }
    CFBasicHashReplaceValue((unint64_t)theDict, (unint64_t)key, (uint64_t)value);
    char v15 = atomic_load((unint64_t *)theDict + 1);
    if (v15)
    {
      uint64_t v16 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        uint64_t v16 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v16;
      }
      objc_msgSend(theDict, v16, key);
    }
  }
}

uint64_t __CFBasicHashReplaceValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v7 = result;
  ++*(_WORD *)(result + 16);
  if ((*(void *)(result + 32) & 2) == 0)
  {
    uint64_t v8 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(result + 24) >> 39) & 0x1FLL]
                                                                 + 8 * ((*(void *)(result + 24) >> 34) & 0x1FLL));
    if (v8)
    {
      if (result < 0)
      {
        uint64_t v9 = &kCFAllocatorSystemDefault;
      }
      else
      {
        char v10 = atomic_load((unint64_t *)(result + 8));
        if (v10 < 0) {
          uint64_t v9 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v9 = (const CFAllocatorRef *)(result - 16);
        }
      }
      CFAttributedStringRef result = v8(*v9, a4);
      uint64_t v4 = result;
    }
  }
  if ((*(_WORD *)(v7 + 18) & 4) != 0 && (*(void *)(v7 + 32) & 2) == 0)
  {
    uint64_t v11 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v7 + 27) >> 5) & 0x1F]
                                                                  + 8 * (*(_DWORD *)(v7 + 27) & 0x1FLL));
    if (v11)
    {
      if (v7 < 0)
      {
        char v12 = &kCFAllocatorSystemDefault;
      }
      else
      {
        char v13 = atomic_load((unint64_t *)(v7 + 8));
        if (v13 < 0) {
          char v12 = &kCFAllocatorSystemDefault;
        }
        else {
          char v12 = (const CFAllocatorRef *)(v7 - 16);
        }
      }
      CFAttributedStringRef result = v11(*v12, a3);
      a3 = result;
    }
  }
  uint64_t v14 = *(void *)(v7 + 40);
  uint64_t v15 = *(void *)(v14 + 8 * a2);
  if (v4) {
    uint64_t v16 = v4;
  }
  else {
    uint64_t v16 = 2814029233;
  }
  if (v16 == -1) {
    uint64_t v16 = 2780474809;
  }
  *(void *)(v14 + 8 * a2) = v16;
  if ((unint64_t)(v15 + 1) >= 2)
  {
    if (v15 == 2814029233) {
      uint64_t v15 = 0;
    }
    if (v15 == 2780474809) {
      uint64_t v17 = -1;
    }
    else {
      uint64_t v17 = v15;
    }
    if ((*(void *)(v7 + 32) & 2) == 0)
    {
      unint64_t v18 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                                 + (HIBYTE(*(void *)(v7 + 24)) & 0xF8))
                                                                    + 8 * ((*(void *)(v7 + 24) >> 54) & 0x1FLL));
      if (v18)
      {
        if (v7 < 0)
        {
          uint64_t v19 = &kCFAllocatorSystemDefault;
        }
        else
        {
          char v20 = atomic_load((unint64_t *)(v7 + 8));
          if (v20 < 0) {
            uint64_t v19 = &kCFAllocatorSystemDefault;
          }
          else {
            uint64_t v19 = (const CFAllocatorRef *)(v7 - 16);
          }
        }
        CFAttributedStringRef result = v18(*v19, v17);
      }
    }
  }
  unint64_t v21 = *(unsigned __int16 *)(v7 + 18);
  if ((v21 & 4) != 0)
  {
    uint64_t v22 = *(void *)(v7 + 8 * ((v21 >> 2) & 1) + 40);
    uint64_t v23 = *(void *)(v22 + 8 * a2);
    if (a3) {
      uint64_t v24 = a3;
    }
    else {
      uint64_t v24 = 2814029233;
    }
    if (v24 == -1) {
      uint64_t v24 = 2780474809;
    }
    *(void *)(v22 + 8 * a2) = v24;
    if ((unint64_t)(v23 + 1) >= 2)
    {
      if (v23 == 2814029233) {
        uint64_t v23 = 0;
      }
      if (v23 == 2780474809) {
        uint64_t v25 = -1;
      }
      else {
        uint64_t v25 = v23;
      }
      if ((*(void *)(v7 + 32) & 2) == 0)
      {
        long long v26 = *(uint64_t (**)(CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(v7 + 24) >> 49) & 0x1FLL]
                                                                + 8 * ((*(void *)(v7 + 24) >> 44) & 0x1FLL));
        if (v26)
        {
          if (v7 < 0 || (char v27 = atomic_load((unint64_t *)(v7 + 8)), v27 < 0)) {
            BOOL v28 = &kCFAllocatorSystemDefault;
          }
          else {
            BOOL v28 = (const CFAllocatorRef *)(v7 - 16);
          }
          CFAllocatorRef v29 = *v28;
          return v26(v29, v25);
        }
      }
    }
  }
  return result;
}

CFStringRef __CFStringCollectionCopy(const __CFAllocator *a1, const __CFString *a2)
{
  if (!a2) {
    __CFStringCollectionCopy_cold_1();
  }
  return CFStringCreateCopy(a1, a2);
}

unint64_t CFBasicHashReplaceValue(unint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  char v3 = atomic_load((unint64_t *)(result + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233) {
    goto LABEL_26;
  }
  uint64_t v6 = result;
  long long v9 = 0u;
  long long v10 = 0u;
  if (*(unsigned char *)(result + 26))
  {
    int v7 = *(_WORD *)(result + 18) & 3;
    if ((*(_WORD *)(result + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          CFAttributedStringRef result = ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v9);
          break;
        case 2:
          CFAttributedStringRef result = ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v9);
          break;
        case 1:
          CFAttributedStringRef result = ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v9);
          break;
        default:
          goto LABEL_26;
      }
    }
    else if (v7 == 3)
    {
      CFAttributedStringRef result = ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v9);
    }
    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          CFAttributedStringRef result = ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v9);
          goto LABEL_21;
        }
LABEL_26:
        __break(1u);
      }
      CFAttributedStringRef result = ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v9);
    }
  }
  else
  {
    long long v9 = xmmword_182EDDE80;
    long long v10 = *(_OWORD *)algn_182EDDE90;
  }
LABEL_21:
  if (*((void *)&v10 + 1))
  {
    uint64_t v8 = v9;
    return __CFBasicHashReplaceValue(v6, v8, a2, a3);
  }
  return result;
}

CFURLEnumeratorRef CFURLEnumeratorCreateForDirectoryURL(CFAllocatorRef alloc, CFURLRef directoryURL, CFURLEnumeratorOptions option, CFArrayRef propertyKeys)
{
  return (CFURLEnumeratorRef)MEMORY[0x1F4115000](alloc, directoryURL, option, propertyKeys);
}

uint64_t _CFURLFileCacheGetName()
{
  return MEMORY[0x1F4114FB8]();
}

uint64_t CompareLocaleToLegacyCodesEntries(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t _CFAppVersionCheck(CFTypeRef cf2, const void *a2)
{
  if (_bundleInfo_onceToken != -1) {
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  }
  uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if (result)
  {
    if (!a2) {
      return 1;
    }
    uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_1, a2);
    if (result) {
      return 1;
    }
  }
  return result;
}

id _NSObjectLoadWeak(id *a1, unsigned char *a2)
{
  if (*a2) {
    id WeakRetained = *a1;
  }
  else {
    id WeakRetained = objc_loadWeakRetained(a1);
  }

  return WeakRetained;
}

CFURLRef _CFURLExists(const __CFURL *url)
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  char v1 = 0;
  if (url)
  {
    if (_CFGetFileProperties((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, &v1, 0, 0, 0, 0, 0))return 0; {
    else
    }
      return (const __CFURL *)(v1 != 0);
  }
  return url;
}

uint64_t _CFBundleCopyLProjDirectoriesForURL(uint64_t a1, CFURLRef relativeURL)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  uint64_t v8 = 0;
  long long v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  CFURLRef v3 = CFURLCopyAbsoluteURL(relativeURL);
  CFStringRef v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  v7[0] = off_1ECE0A5A0;
  v7[1] = 0x40000000;
  v7[2] = ___CFBundleCopyLProjDirectoriesForURL_block_invoke;
  v7[3] = &unk_1ECDB0E70;
  v7[4] = &v8;
  v7[5] = CFStringGetLength(@".lproj");
  v7[6] = @".lproj";
  void v7[7] = a1;
  _CFIterateDirectory(v4, 0, 0, (uint64_t)v7);
  CFRelease(v4);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_182C2FBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const UInt8 *_CFCopyHomeDirURLForUser(const char *a1, int a2)
{
  v30[3] = *(void *)off_1ECE0A5B0;
  if (issetugid()) {
    CFStringRef v4 = 0;
  }
  else {
    CFStringRef v4 = __CFgetenv("CFFIXED_USER_HOME");
  }
  uint64_t v29 = 0;
  v30[0] = &v29;
  v30[1] = 0x2000000000;
  v30[2] = 0;
  v25[0] = off_1ECE0A5A0;
  v25[1] = 0x40000000;
  long long v26 = ___CFCopyHomeDirURLForUser_block_invoke;
  char v27 = &unk_1ECDB03A0;
  BOOL v28 = &v29;
  if (!issetugid() && v4)
  {
    size_t v5 = strlen(v4);
    pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v4, v5, 1u);
    if (pw_dir) {
      goto LABEL_35;
    }
    v26((uint64_t)v25);
    int has_internal_diagnostics = os_variant_has_internal_diagnostics();
    uint64_t v8 = *(__CFString **)(v30[0] + 24);
    if (has_internal_diagnostics) {
      CFStringAppendFormat(v8, 0, @"CFURLCreateFromFileSystemRepresentation failed to create URL for CFFIXED_USER_HOME value: %s", v4);
    }
    else {
      CFStringAppend(v8, @"CFURLCreateFromFileSystemRepresentation failed to create URL for CFFIXED_USER_HOME value");
    }
  }
  if (a1)
  {
    *__error() = 0;
    long long v9 = getpwnam(a1);
    if (!v9) {
      goto LABEL_26;
    }
  }
  else
  {
    uid_t v24 = 0;
    __CFGetUGIDs(&v24, 0);
    *__error() = 0;
    uid_t v10 = v24;
    if (!v24) {
      uid_t v10 = getuid();
    }
    long long v9 = getpwuid(v10);
    if (!v9)
    {
      uint64_t v14 = *__error();
      v26((uint64_t)v25);
      CFStringAppendFormat(*(CFMutableStringRef *)(v30[0] + 24), 0, @"getpwuid failed with code: %d", v14);
      pw_dir = 0;
      goto LABEL_27;
    }
  }
  pw_dir = (const UInt8 *)v9->pw_dir;
  if (pw_dir)
  {
    size_t v11 = strlen(v9->pw_dir);
    pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_dir, v11, 1u);
  }
  if (!((unint64_t)a1 | (unint64_t)pw_dir))
  {
    v26((uint64_t)v25);
    if (v9->pw_dir)
    {
      int v12 = os_variant_has_internal_diagnostics();
      char v13 = *(__CFString **)(v30[0] + 24);
      if (v12)
      {
        CFStringAppendFormat(v13, 0, @"CFURLCreateFromFileSystemRepresentation failed to create URL for upwd->pw_dir value: %s", v9->pw_dir);
        pw_dir = 0;
        goto LABEL_27;
      }
      CFStringRef v15 = @"CFURLCreateFromFileSystemRepresentation failed to create URL for upwd->pw_dir value";
    }
    else
    {
      char v13 = *(__CFString **)(v30[0] + 24);
      CFStringRef v15 = @"upwd->pw_dir is NULL";
    }
    CFStringAppend(v13, v15);
LABEL_26:
    pw_dir = 0;
  }
LABEL_27:
  if (!pw_dir && a2)
  {
    uint64_t v16 = __CFgetenv("HOME");
    uint64_t v17 = (const UInt8 *)v16;
    if (v16)
    {
      size_t v18 = strlen(v16);
      pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17, v18, 1u);
      if (pw_dir) {
        goto LABEL_35;
      }
      v26((uint64_t)v25);
      int v19 = os_variant_has_internal_diagnostics();
      char v20 = *(__CFString **)(v30[0] + 24);
      if (v19)
      {
        CFStringAppendFormat(v20, 0, @"CFURLCreateFromFileSystemRepresentation failed to create URL for HOME value: %s", v17);
        pw_dir = 0;
        goto LABEL_35;
      }
      CFStringAppend(v20, @"CFURLCreateFromFileSystemRepresentation failed to create URL for HOME value");
    }
    pw_dir = 0;
  }
LABEL_35:
  unint64_t v21 = *(const void **)(v30[0] + 24);
  if (v21)
  {
    if (!pw_dir)
    {
      uint64_t v22 = _CFOSLog();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        _CFCopyHomeDirURLForUser_cold_1((uint64_t)v30, v22);
      }
      pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)"/var/empty", 10, 1u);
      unint64_t v21 = *(const void **)(v30[0] + 24);
    }
    CFRelease(v21);
  }
  _Block_object_dispose(&v29, 8);
  return pw_dir;
}

void sub_182C2FFA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

__CFBundle *_CFBundleGetBundleWithIdentifier(__CFString *a1, uint64_t a2)
{
  if (a1)
  {
    CFBundleRef MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      size_t v5 = MainBundle;
      CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
      if (InfoDictionary)
      {
        CFStringRef Value = CFDictionaryGetValue(InfoDictionary, @"CFBundleIdentifier");
        if (Value)
        {
          uint64_t v8 = Value;
          CFTypeID v9 = CFGetTypeID(Value);
          if (v9 == CFStringGetTypeID())
          {
            if (CFEqual(v8, a1)) {
              return v5;
            }
          }
        }
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    size_t v5 = _CFBundleGetFromTablesLocked(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (a2 && !v5)
    {
      CFStringRef v10 = _CFBundleCopyLoadedImagePathForPointer();
      if (v10)
      {
        CFStringRef v11 = v10;
        _CFBundleEnsureBundleExistsForImagePath((uint64_t)v10, 0);
        CFRelease(v11);
      }
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      size_t v5 = _CFBundleGetFromTablesLocked(a1);
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    }
    if (v5) {
      return v5;
    }
    _CFBundleEnsureBundlesUpToDateWithHint(a1);
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    size_t v5 = _CFBundleGetFromTablesLocked(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (v5) {
      return v5;
    }
  }
  _CFBundleEnsureAllBundlesUpToDate();
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  char v13 = _CFBundleGetFromTablesLocked(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v13;
}

__CFBundle *_CFBundleGetFromTablesLocked(void *key)
{
  CFDictionaryRef ValueAtIndex = 0;
  if (!key || !_bundlesByIdentifier) {
    return ValueAtIndex;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_bundlesByIdentifier, key);
  if (!Value) {
    return 0;
  }
  CFArrayRef v3 = Value;
  CFIndex Count = CFArrayGetCount(Value);
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  do
  {
    CFDictionaryRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v3, v6++);
    if (CFBundleIsExecutableLoaded(ValueAtIndex)) {
      BOOL v7 = ValueAtIndex == 0;
    }
    else {
      BOOL v7 = 1;
    }
    int v8 = v7;
  }
  while (v8 == 1 && v6 < v5);
  if (!v8) {
    return ValueAtIndex;
  }

  return (__CFBundle *)CFArrayGetValueAtIndex(v3, 0);
}

CFURLRef _CFBundleCopyExecutableURLInDirectory2(CFBundleRef bundle, CFURLRef url, const __CFString *a3, int a4)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  char v23 = 0;
  if (bundle)
  {
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(bundle);
    char v23 = *((unsigned char *)bundle + 53);
    if (!a3 && !a4)
    {
      os_unfair_lock_lock_with_options();
      CFStringRef v9 = (const __CFString *)*((void *)bundle + 13);
      if (v9)
      {
        CFRetain(*((CFTypeRef *)bundle + 13));
        os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
        CFURLRef v10 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 0);
        CFRelease(v9);
        if (v10) {
          return v10;
        }
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
      }
      int v11 = 1;
LABEL_13:
      CFStringRef v13 = _CFBundleCopyExecutableName(bundle, url, InfoDictionary);
      if (!v13)
      {
        CFURLRef v10 = 0;
        goto LABEL_36;
      }
      CFStringRef v12 = v13;
      if (!url) {
        goto LABEL_31;
      }
      goto LABEL_15;
    }
  }
  else
  {
    CFDictionaryRef InfoDictionary = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, &v23);
  }
  int v11 = 0;
  CFStringRef v12 = a3;
  if (!a3) {
    goto LABEL_13;
  }
  if (!url) {
    goto LABEL_31;
  }
LABEL_15:
  uint64_t v14 = __CFgetenvIfNotRestricted("DYLD_IMAGE_SUFFIX");
  if (v14)
  {
    CFStringRef v15 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, 0x8000100u);
    if (CFStringHasSuffix(v12, @".dylib"))
    {
      v25.CFIndex length = CFStringGetLength(v12) - 6;
      v25.CFIndex location = 0;
      CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v25);
      CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@%@.dylib", v12, v15);
      CFRelease(v16);
    }
    else
    {
      CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@%@", v12, v15);
    }
    CFURLRef v18 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17, kCFURLPOSIXPathStyle, 0, url);
    CFURLRef v10 = v18;
    if (v18 && !_binaryLoadable(v18))
    {
      CFRelease(v10);
      CFURLRef v10 = 0;
    }
    CFRelease(v17);
    CFRelease(v15);
    if (v10) {
      goto LABEL_26;
    }
  }
  CFURLRef v19 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, kCFURLPOSIXPathStyle, 0, url);
  if (!v19)
  {
LABEL_31:
    CFURLRef v10 = 0;
    if (bundle && !a3)
    {
      CFURLRef v10 = 0;
      *((_DWORD *)bundle + 12) = 7;
LABEL_35:
      CFRelease(v12);
      goto LABEL_36;
    }
    goto LABEL_34;
  }
  CFURLRef v10 = v19;
  if (!_binaryLoadable(v19))
  {
    CFRelease(v10);
    goto LABEL_31;
  }
LABEL_26:
  if (v11)
  {
    CFURLRef v20 = CFURLCopyAbsoluteURL(v10);
    CFStringRef v21 = CFURLCopyFileSystemPath(v20, kCFURLPOSIXPathStyle);
    CFRelease(v20);
    os_unfair_lock_lock_with_options();
    if (!*((void *)bundle + 13)) {
      *((void *)bundle + 13) = CFRetain(v21);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
    CFRelease(v21);
  }
LABEL_34:
  if (!a3) {
    goto LABEL_35;
  }
LABEL_36:
  if (!bundle && InfoDictionary) {
    CFRelease(InfoDictionary);
  }
  return v10;
}

CFStringRef CFBundleGetDevelopmentRegion(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (!InfoDictionary) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleDevelopmentRegion");
  CFStringRef v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 != CFStringGetTypeID() || !CFStringGetLength(v5)) {
      return 0;
    }
  }
  return v5;
}

void *_CFBundleCreate(const __CFAllocator *a1, const __CFURL *a2, int a3, const __CFSet *a4)
{
  uint64_t v52 = *(void *)off_1ECE0A5B0;
  CFURLRef NormalizedURL = _CFBundleCreateNormalizedURL(a1, a2);
  if (!NormalizedURL)
  {
    if (_CFBundleResourceLogger_onceToken != -1) {
      dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_ERROR)) {
      _CFBundleCreate_cold_1();
    }
    return 0;
  }
  CFURLRef v9 = NormalizedURL;
  char v10 = 0;
  char v11 = 1;
  char v12 = 0;
  char v13 = 0;
  char v14 = 1;
  char v15 = 1;
  switch(a3)
  {
    case 0:
      goto LABEL_11;
    case 1:
      char v10 = 0;
      char v14 = 0;
      char v15 = 0;
      goto LABEL_9;
    case 2:
      char v14 = 0;
      char v15 = 0;
      char v10 = 1;
LABEL_9:
      char v13 = 1;
      goto LABEL_15;
    case 3:
      goto LABEL_15;
    case 4:
      char v12 = 1;
LABEL_11:
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      CFStringRef v16 = _CFBundleCopyFromTablesForURLLocked(v9);
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      if (v16)
      {
        CFRelease(v9);
        return v16;
      }
      char v10 = 0;
      char v11 = 0;
      char v13 = 0;
      char v15 = v12;
LABEL_15:
      char v42 = v15;
      char v17 = v11;
      int BundleVersionForURL = _CFBundleGetBundleVersionForURL((uint64_t)v9, v8);
      char v19 = BundleVersionForURL;
      if (BundleVersionForURL != 3) {
        goto LABEL_23;
      }
      v45[0] = 0;
      *(_DWORD *)buffer = 0;
      if (_CFGetFileProperties(a1, v9, v45, buffer, 0, 0, 0, 0))
      {
        CFRelease(v9);
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR)) {
          _CFBundleCreate_cold_5();
        }
        return 0;
      }
      if (!v45[0] || (*(_WORD *)buffer & 0xF000) != 0x4000)
      {
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG)) {
          _CFBundleCreate_cold_2();
        }
        CFURLRef v27 = v9;
        goto LABEL_40;
      }
LABEL_23:
      uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)a1, 0x1FuLL, 208, 0);
      if (!Instance)
      {
        CFRelease(v9);
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR)) {
          _CFBundleCreate_cold_3();
        }
        return 0;
      }
      CFStringRef v16 = (void *)Instance;
      *(void *)(Instance + 16) = v9;
      *(unsigned char *)(Instance + 53) = v19;
      *(_DWORD *)(Instance + 48) = 0;
      *(unsigned char *)(Instance + 54) = v13;
      *(unsigned char *)(Instance + 55) = v10;
      *(_DWORD *)(Instance + 96) = 0;
      *(_DWORD *)(Instance + 112) = 0;
      *(_DWORD *)(Instance + 176) = 0;
      CFURLRef v21 = CFURLCopyAbsoluteURL(v9);
      v16[24] = CFURLCopyFileSystemPath(v21, kCFURLPOSIXPathStyle);
      CFRelease(v21);
      *((_DWORD *)v16 + 50) = 0;
      if (a4) {
        _CFBundleLoadLimitedInfoDictionary((uint64_t)v16, a4);
      }
      CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v16);
      CFStringRef Identifier = CFBundleGetIdentifier((CFBundleRef)v16);
      __dmb(0xBu);
      if (v14)
      {
        uint64_t v24 = (__CFString *)Identifier;
        os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
        CFRange v25 = _CFBundleCopyFromTablesForURLLocked((void *)v16[2]);
        if (v25)
        {
          long long v26 = v25;
          os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
          CFRelease(v16);
          return v26;
        }
        uint64_t v29 = _CFBundleGetFromTablesLocked(v24);
        if (!v29
          || (uint64_t v30 = v29,
              CFStringRef v31 = (const __CFString *)*((void *)v29 + 24),
              !CFStringGetFileSystemRepresentation((CFStringRef)v16[24], buffer, 1024))
          || !CFStringGetFileSystemRepresentation(v31, v45, 1024))
        {
LABEL_60:
          if ((v42 & 1) != 0 || (*(void *)long long v45 = 0, _CFBundleInitPlugIn(v16, InfoDictionary, v45)))
          {
            if ((v17 & 1) == 0) {
              _CFBundleAddToTablesLocked((const void **)v16, v24);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
            if ((v42 & 1) == 0) {
              _CFPlugInHandleDynamicRegistration((__CFBundle *)v16);
            }
            return v16;
          }
          CFStringRef Value = CFDictionaryGetValue(InfoDictionary, @"CFPlugInFactories");
          if (Value)
          {
            unint64_t v38 = Value;
            CFTypeID v39 = CFGetTypeID(Value);
            if (v39 == CFDictionaryGetTypeID()) {
              long long v40 = v38;
            }
            else {
              long long v40 = 0;
            }
          }
          else
          {
            long long v40 = 0;
          }
          if (_CFBundleLoadingLogger_onceToken != -1) {
            dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
          }
          long long v41 = _CFBundleLoadingLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buffer = 138543874;
            uint64_t v47 = v40;
            __int16 v48 = 2114;
            long long v49 = v16;
            __int16 v50 = 2114;
            CFURLRef v51 = *(CFURLRef *)v45;
            _os_log_error_impl(&dword_182B90000, v41, OS_LOG_TYPE_ERROR, "More than one bundle with the same factory UUID detected: %{public}@ in %{public}@ and %{public}@", (uint8_t *)buffer, 0x20u);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
          CFRelease(v16);
          CFURLRef v27 = *(CFURLRef *)v45;
          if (!*(void *)v45) {
            return 0;
          }
LABEL_40:
          CFRelease(v27);
          return 0;
        }
        int v32 = open(buffer, 0);
        int v33 = open(v45, 0);
        int v34 = v33;
        if (v32 < 1 || v33 < 1)
        {
          BOOL v35 = 0;
          BOOL v36 = 0;
          if (v32 < 1)
          {
LABEL_56:
            if (v34 >= 1) {
              close(v34);
            }
            if (v36)
            {
              os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
              CFRelease(v16);
              return CFRetain(v30);
            }
            goto LABEL_60;
          }
        }
        else
        {
          memset(&v44, 0, sizeof(v44));
          memset(&v43, 0, sizeof(v43));
          BOOL v35 = !fstat(v32, &v44) && !fstat(v34, &v43) && v44.st_dev == v43.st_dev && v44.st_ino == v43.st_ino;
        }
        close(v32);
        BOOL v36 = v35;
        goto LABEL_56;
      }
      if ((v17 & 1) == 0) {
        _CFBundleCreate_cold_4();
      }
      return v16;
    default:
      char v13 = 0;
      char v14 = 1;
      char v15 = 1;
      goto LABEL_15;
  }
}

uint64_t _CFStringCreateByParsingMarkdownAndInflectingIfNeeded(__CFString *a1, __CFBundle *a2, uint64_t a3)
{
  if (_CFStringNeedsMarkdownParsing(a1, a2))
  {
    uint64_t FormatSpecifierConfiguration = _CFStringGetFormatSpecifierConfiguration(a1);
    return _CFStringCreateWithMarkdownAndConfiguration((uint64_t)a1, FormatSpecifierConfiguration, (uint64_t)a2, a3);
  }
  else
  {
    CFRetain(a1);
    return (uint64_t)a1;
  }
}

CFStringRef _CFStringNeedsMarkdownParsing(const __CFString *a1, CFBundleRef bundle)
{
  if (!bundle) {
    return 0;
  }
  CFStringRef result = CFBundleGetIdentifier(bundle);
  if (result)
  {
    CFStringRef v4 = result;
    v5.CFIndex length = CFStringGetLength(result);
    v5.CFIndex location = 0;
    CFStringRef result = (const __CFString *)CFStringFindWithOptionsAndLocale(v4, @"com.apple.", v5, 8uLL, 0, 0);
    if (result) {
      return (const __CFString *)(CFStringFind(a1, @"^[", 0).location != -1);
    }
  }
  return result;
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  CFStringRef result = (CFStringRef)CFBundleGetInfoDictionary(bundle);
  if (result)
  {
    return (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, @"CFBundleIdentifier");
  }
  return result;
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)bundle + 28);
  _CFBundleRefreshInfoDictionaryAlreadyLocked((uint64_t)bundle);
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
  return (CFDictionaryRef)*((void *)bundle + 3);
}

void _CFBundleRefreshInfoDictionaryAlreadyLocked(uint64_t a1)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  if (!*(void *)(a1 + 24))
  {
    CFTypeRef v29 = 0;
    CFDictionaryRef v2 = _CFBundleCopyInfoDictionaryInDirectoryWithVersion((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFURLRef *)(a1 + 16), &v29, 0, *(unsigned __int8 *)(a1 + 55), *(unsigned __int8 *)(a1 + 53));
    *(void *)(a1 + 24) = v2;
    CFArrayRef v3 = *(const void **)(a1 + 216);
    if (v3)
    {
      CFRelease(v3);
      CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 24);
    }
    *(void *)(a1 + 216) = v29;
    if (v2)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v2, @"CFBundleNumericVersion");
      if (Value || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v2, @"CFBundleVersion")) != 0)
      {
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          CFIndex Length = CFStringGetLength(Value);
          if ((unint64_t)(Length - 11) < 0xFFFFFFFFFFFFFFF6)
          {
LABEL_10:
            int v7 = 0;
LABEL_54:
            *(_DWORD *)buffer = v7;
            CFAllocatorRef v24 = CFGetAllocator((CFTypeRef)a1);
            CFNumberRef v25 = CFNumberCreate(v24, kCFNumberSInt32Type, buffer);
            CFDictionarySetValue(v2, @"CFBundleNumericVersion", v25);
            CFRelease(v25);
            return;
          }
          unint64_t v9 = Length;
          v33.CFIndex location = 0;
          v33.CFIndex length = Length;
          CFStringGetCharacters(Value, v33, buffer);
          int v10 = buffer[0];
          if ((unsigned __int16)(buffer[0] - 58) >= 0xFFF6u)
          {
            int v15 = buffer[0] - 48;
            if (v9 < 2)
            {
              int v17 = 0;
              int v11 = 0;
              unsigned int v19 = 0;
              BOOL v20 = 0;
              int v21 = 0x8000;
              int v14 = buffer[0] - 48;
              int v15 = 0;
LABEL_50:
              int v7 = v21 + (v17 << 20) + (v14 << 24) + (v15 << 28) + v11 + v19;
              if (v20) {
                int v7 = 0;
              }
              if (v19 > 0xFF) {
                int v7 = 0;
              }
              goto LABEL_54;
            }
            int v10 = buffer[1];
            if ((unsigned __int16)(buffer[1] - 58) >= 0xFFF6u)
            {
              int v14 = buffer[1] - 48;
              if (v9 < 3) {
                goto LABEL_30;
              }
              int v10 = v31;
              if (v31 != 46)
              {
                int v11 = 0;
                int v17 = 0;
                CFStringRef v16 = &v31;
                v9 -= 2;
                goto LABEL_41;
              }
              uint64_t v12 = -3;
              uint64_t v13 = 3;
LABEL_17:
              v9 += v12;
              if (v9)
              {
                CFStringRef v16 = &buffer[v13];
                int v10 = *v16;
                if ((unsigned __int16)(v10 - 58) < 0xFFF6u)
                {
                  int v11 = 0;
                  int v17 = 0;
LABEL_41:
                  int v18 = v15;
                  goto LABEL_42;
                }
                int v17 = v10 - 48;
                if (v9 >= 2)
                {
                  int v10 = v16[1];
                  if (v10 != 46)
                  {
                    int v11 = 0;
                    --v9;
                    ++v16;
                    goto LABEL_41;
                  }
                  if (v9 != 2)
                  {
                    int v10 = v16[2];
                    if ((unsigned __int16)(v10 - 58) < 0xFFF6u)
                    {
                      int v11 = 0;
                      v9 -= 2;
                      v16 += 2;
                      goto LABEL_41;
                    }
                    int v11 = (v10 << 16) - 3145728;
                    v9 -= 3;
                    if (v9)
                    {
                      int v28 = v16[3];
                      v16 += 3;
                      int v10 = v28;
                      goto LABEL_41;
                    }
                    goto LABEL_37;
                  }
                }
LABEL_36:
                int v11 = 0;
LABEL_37:
                unsigned int v19 = 0;
                BOOL v20 = 0;
                int v21 = 0x8000;
                goto LABEL_50;
              }
LABEL_30:
              int v17 = 0;
              goto LABEL_36;
            }
            int v11 = 0;
            if (buffer[1] == 46)
            {
              uint64_t v12 = -2;
              uint64_t v13 = 2;
              int v14 = buffer[0] - 48;
              goto LABEL_16;
            }
            CFStringRef v16 = &buffer[1];
            --v9;
            int v18 = 0;
            int v14 = buffer[0] - 48;
          }
          else
          {
            int v11 = 0;
            if (buffer[0] == 46)
            {
              uint64_t v12 = -1;
              uint64_t v13 = 1;
              int v14 = 0;
LABEL_16:
              int v15 = 0;
              goto LABEL_17;
            }
            CFStringRef v16 = buffer;
            int v18 = 0;
            int v14 = 0;
          }
          int v17 = 0;
LABEL_42:
          __int16 v22 = v10 - 97;
          if ((v10 - 97) > 5 || ((0x2Bu >> v22) & 1) == 0) {
            goto LABEL_10;
          }
          int v21 = dword_182EE0C78[v22];
          if (v9 == 1)
          {
            unsigned int v19 = 0;
          }
          else
          {
            int v23 = v16[1];
            if ((v23 - 58) < 0xFFFFFFF6) {
              goto LABEL_10;
            }
            unsigned int v19 = v23 - 48;
            if (v9 != 2)
            {
              int v26 = v16[2];
              if ((v26 - 58) < 0xFFFFFFF6) {
                goto LABEL_10;
              }
              unsigned int v19 = v26 + 10 * v19 - 48;
              if (v9 != 3)
              {
                int v27 = v16[3];
                if ((v27 - 58) < 0xFFFFFFF6) {
                  goto LABEL_10;
                }
                unsigned int v19 = v27 + 10 * v19 - 48;
                BOOL v20 = v9 - 3 > 1;
                goto LABEL_49;
              }
            }
          }
          BOOL v20 = 0;
LABEL_49:
          int v15 = v18;
          goto LABEL_50;
        }
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 != CFNumberGetTypeID()) {
          CFDictionaryRemoveValue(v2, @"CFBundleNumericVersion");
        }
      }
    }
  }
}

void *_CFBundleCopyFromTablesForURLLocked(void *key)
{
  if (!_bundlesByURL) {
    return 0;
  }
  CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)_bundlesByURL, key);
  CFArrayRef v3 = Value;
  if (Value)
  {
    if (Value[2])
    {
      CFRetain(Value);
      return v3;
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_bundlesByURL, key);
    return 0;
  }
  return v3;
}

uint64_t _CFGetFileProperties(const __CFAllocator *a1, CFURLRef url, char *a3, _DWORD *a4, off_t *a5, CFDateRef *a6, uid_t *a7, __CFArray **a8)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024)) {
    return 0xFFFFFFFFLL;
  }
  if (!a3 && !a4 && !a5 && !a6 && !a7 && !a8) {
    return 0;
  }
  memset(&v22, 0, sizeof(v22));
  int v15 = stat((const char *)buffer, &v22);
  if (!v15)
  {
    BOOL v17 = (v22.st_mode & 0xF000) == 0x4000;
    char v16 = 1;
    if (!a3) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (*__error() != 2) {
    return *__error();
  }
  char v16 = 0;
  BOOL v17 = 0;
  if (a3) {
LABEL_14:
  }
    *a3 = v16;
LABEL_15:
  if (!a4)
  {
    if (!a5) {
      goto LABEL_26;
    }
    if (v15) {
      goto LABEL_22;
    }
LABEL_24:
    off_t st_size = v22.st_size;
    goto LABEL_25;
  }
  if (!v15)
  {
    *a4 = v22.st_mode;
    if (!a5) {
      goto LABEL_26;
    }
    goto LABEL_24;
  }
  *a4 = 0;
  if (a5)
  {
LABEL_22:
    off_t st_size = 0;
LABEL_25:
    *a5 = st_size;
  }
LABEL_26:
  if (!a6)
  {
    if (!a7) {
      goto LABEL_36;
    }
    if (v15) {
      goto LABEL_32;
    }
LABEL_34:
    uid_t st_uid = v22.st_uid;
    goto LABEL_35;
  }
  if (!v15)
  {
    *a6 = CFDateCreate(a1, (double)v22.st_mtimespec.tv_sec - 978307200.0 + (double)v22.st_mtimespec.tv_nsec * 0.000000001);
    if (!a7) {
      goto LABEL_36;
    }
    goto LABEL_34;
  }
  *a6 = 0;
  if (a7)
  {
LABEL_32:
    uid_t st_uid = -1;
LABEL_35:
    *a7 = st_uid;
  }
LABEL_36:
  if (!a8) {
    return 0;
  }
  if (v15 || !v17)
  {
    uint64_t result = 0;
    *a8 = 0;
  }
  else
  {
    int v21 = _CFCreateContentsOfDirectory((uint64_t)a1, (uint64_t)buffer);
    uint64_t result = 0;
    *a8 = v21;
  }
  return result;
}

CFURLRef _CFBundleCreateNormalizedURL(const __CFAllocator *a1, CFURLRef url)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026)) {
    return 0;
  }
  CFArrayRef v3 = _CFBundleNormalizedPath((const char *)buffer);
  size_t v4 = strlen(v3);
  return CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)v3, v4, 1u);
}

CFURLRef _CFPrefsCreatePreferencesDirectoryURLForTriplet(const __CFString *a1, int a2, const void *a3)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  if (!CFEqual(a1, @"kCFPreferencesAnyUser"))
  {
    if (a3)
    {
      CFURLRef v7 = (const __CFURL *)CFRetain(a3);
    }
    else
    {
      if (CFEqual(a1, @"kCFPreferencesCurrentUser"))
      {
        uid_t v8 = geteuid();
        unint64_t v9 = getpwuid(v8);
      }
      else
      {
        CFIndex Length = CFStringGetLength(a1);
        unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        CFIndex v12 = MaximumSizeForEncoding;
        if (MaximumSizeForEncoding >= 0x7F) {
          uint64_t v13 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x4525BEE4uLL);
        }
        else {
          uint64_t v13 = buffer;
        }
        if (CFStringGetCString(a1, v13, v12, 0x8000100u)) {
          unint64_t v9 = getpwnam(v13);
        }
        else {
          unint64_t v9 = 0;
        }
        if (buffer != v13) {
          free(v13);
        }
      }
      if (v9 && (pw_dir = v9->pw_dir) != 0)
      {
        size_t v15 = strlen(pw_dir);
        CFURLRef v7 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)pw_dir, v15, 1u);
      }
      else
      {
        CFURLRef v7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"/var/empty", kCFURLPOSIXPathStyle, 1u);
      }
    }
    CFURLRef v16 = v7;
    if (v7)
    {
      if (a2) {
        CFStringRef v17 = @"Library/Preferences/ByHost/";
      }
      else {
        CFStringRef v17 = @"Library/Preferences/";
      }
      CFURLRef v18 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17, kCFURLPOSIXPathStyle, 1u, v7);
      CFRelease(v16);
      return v18;
    }
    return 0;
  }
  if (_CFPrefsCurrentProcessIsCFPrefsD() && geteuid()) {
    return 0;
  }
  if (a3)
  {
    return CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Library/Preferences/", kCFURLPOSIXPathStyle, 1u, (CFURLRef)a3);
  }
  else
  {
    return CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"/private/var/preferences", kCFURLPOSIXPathStyle, 1u);
  }
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)_CFURLCreateWithFileSystemRepresentation(allocator, (char *)buffer, bufLen, isDirectory, 0);
}

uint64_t _CFBundleGetBundleVersionForURL(uint64_t a1, uint64_t a2)
{
  CFURLRef v2 = (const __CFURL *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v71 = *(void *)off_1ECE0A5B0;
  CFURLRef v3 = CFURLCopyAbsoluteURL(v2);
  CFStringRef v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFStringRef v5 = CFURLGetString(v2);
  int HasSuffix = CFStringHasSuffix(v5, @".framework/");
  CFIndex Length = CFStringGetLength(@"Resources");
  CFIndex v8 = CFStringGetLength(@"Contents");
  CFIndex v9 = CFStringGetLength(@"Support Files");
  CFIndex v10 = CFStringGetLength(@"WrappedBundle");
  uint64_t v62 = 0;
  long long v63 = &v62;
  uint64_t v64 = 0x2000000000;
  char v65 = 0;
  uint64_t v58 = 0;
  long long v59 = &v58;
  uint64_t v60 = 0x2000000000;
  char v61 = 0;
  uint64_t v54 = 0;
  long long v55 = &v54;
  uint64_t v56 = 0x2000000000;
  char v57 = 0;
  uint64_t v50 = 0;
  CFURLRef v51 = &v50;
  uint64_t v52 = 0x2000000000;
  char v53 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = &v46;
  uint64_t v48 = 0x2000000000;
  char v49 = 0;
  uint64_t v42 = 0;
  stat v43 = &v42;
  uint64_t v44 = 0x2000000000;
  char v45 = 0;
  v41[0] = off_1ECE0A5A0;
  v41[1] = 0x40000000;
  v41[2] = ___CFBundleGetBundleVersionForURL_block_invoke;
  v41[3] = &unk_1ECDABAF0;
  v41[10] = Length;
  v41[11] = v8;
  v41[4] = &v62;
  v41[5] = &v58;
  v41[12] = v9;
  v41[13] = CFStringGetLength(@"Wrapper");
  v41[6] = &v54;
  v41[7] = &v46;
  v41[14] = v10;
  v41[8] = &v50;
  v41[9] = &v42;
  CFStringRef string = v4;
  _CFIterateDirectory(v4, 0, 0, (uint64_t)v41);
  if (*((unsigned char *)v43 + 24))
  {
    v70[0] = 0;
    CFURLRef v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Wrapper", v2);
    CFURLRef v12 = v11;
    if (v11)
    {
      BOOL v13 = _CFIsResourceAtURL(v11, v70);
      int v14 = v70[0];
      CFRelease(v12);
      if (v13)
      {
        if (v14)
        {
          *((unsigned char *)v47 + 24) = 1;
          CFURLRef v15 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"WrappedBundle", v2);
          v70[0] = 0;
          if (_CFIsResourceAtURL(v15, v70) && v70[0]) {
            *((unsigned char *)v51 + 24) = 1;
          }
          CFRelease(v15);
          if (*((unsigned char *)v47 + 24) && *((unsigned char *)v51 + 24)) {
            *((unsigned char *)v43 + 24) = 0;
          }
        }
      }
    }
  }
  if (!*((unsigned char *)v47 + 24) || !*((unsigned char *)v51 + 24))
  {
    if (HasSuffix)
    {
      if (*((unsigned char *)v63 + 24))
      {
LABEL_24:
        unsigned __int8 v22 = 0;
        goto LABEL_45;
      }
      if (*((unsigned char *)v59 + 24))
      {
LABEL_29:
        unsigned __int8 v22 = 2;
        goto LABEL_45;
      }
    }
    else
    {
      if (*((unsigned char *)v59 + 24)) {
        goto LABEL_29;
      }
      if (*((unsigned char *)v63 + 24)) {
        goto LABEL_24;
      }
    }
    if (*((unsigned char *)v55 + 24)) {
      unsigned __int8 v22 = 1;
    }
    else {
      unsigned __int8 v22 = 3;
    }
    goto LABEL_45;
  }
  CFURLRef v16 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, @"WrappedBundle", 1u);
  CFStringRef v17 = CFURLCopyFileSystemPath(v16, kCFURLPOSIXPathStyle);
  CFRelease(v16);
  uint64_t v37 = 0;
  unint64_t v38 = &v37;
  uint64_t v39 = 0x2000000000;
  char v40 = 0;
  v36[0] = off_1ECE0A5A0;
  v36[1] = 0x40000000;
  v36[2] = ___CFBundleGetBundleVersionForURL_block_invoke_2;
  v36[3] = &unk_1ECDABB18;
  v36[4] = &v37;
  v36[5] = v8;
  _CFIterateDirectory(v17, 0, 0, (uint64_t)v36);
  if (!CFStringGetFileSystemRepresentation(v17, v70, 1024)
    || !CFStringGetFileSystemRepresentation(string, buffer, 1024))
  {
LABEL_35:
    int v24 = 0;
    goto LABEL_36;
  }
  ssize_t v18 = readlink(v70, __s, 0x3FFuLL);
  if (v18 < 2 || __s[0] == 47)
  {
    int v23 = _CFBundleResourceLogger();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      _CFBundleGetBundleVersionForURL_cold_1();
    }
    goto LABEL_35;
  }
  __s[v18] = 0;
  unsigned int v19 = strrchr(__s, 46);
  uint64_t v20 = strrchr(buffer, 46);
  if (!v20 || !v19)
  {
    if ((unint64_t)v20 | (unint64_t)v19)
    {
      int v28 = _CFBundleResourceLogger();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        _CFBundleGetBundleVersionForURL_cold_4();
      }
      goto LABEL_49;
    }
LABEL_50:
    int v24 = 1;
    goto LABEL_51;
  }
  if (!strcmp(v19 + 1, v20 + 1)) {
    goto LABEL_50;
  }
  int v21 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
    _CFBundleGetBundleVersionForURL_cold_3();
  }
LABEL_49:
  int v24 = 0;
LABEL_51:
  int v29 = open(v70, 0);
  int v30 = open(buffer, 0);
  int v31 = v30;
  if (v29 < 1 || v30 < 1)
  {
    BOOL v32 = 0;
    BOOL v33 = 0;
    if (v29 < 1) {
      goto LABEL_61;
    }
  }
  else
  {
    BOOL v32 = fcntl(v29, 50, __s1) != -1
       && fcntl(v31, 50, __s2) != -1
       && strncmp(__s1, __s2, 0x400uLL)
       && strnstr(__s1, __s2, 0x400uLL) == __s1;
  }
  close(v29);
  BOOL v33 = v32;
LABEL_61:
  if (v31 >= 1) {
    close(v31);
  }
  if (v33)
  {
    char v25 = 1;
    goto LABEL_37;
  }
  int v34 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
    _CFBundleGetBundleVersionForURL_cold_2();
  }
LABEL_36:
  char v25 = 0;
LABEL_37:
  CFRelease(v17);
  char v26 = v25 ^ 1;
  if (!v24) {
    char v26 = 1;
  }
  if (v26)
  {
    unsigned __int8 v22 = 3;
  }
  else if (*((unsigned char *)v38 + 24))
  {
    unsigned __int8 v22 = 12;
  }
  else
  {
    unsigned __int8 v22 = 13;
  }
  _Block_object_dispose(&v37, 8);
LABEL_45:
  CFRelease(v3);
  CFRelease(string);
  _Block_object_dispose(&v42, 8);
  _Block_object_dispose(&v46, 8);
  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v58, 8);
  _Block_object_dispose(&v62, 8);
  return v22;
}

void sub_182C31E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInDirectoryWithVersion(CFAllocatorRef allocator, CFURLRef anURL, CFTypeRef *a3, const __CFSet *a4, uint64_t a5, int a6)
{
  uint64_t v65 = *(void *)off_1ECE0A5B0;
  if (!anURL) {
    return 0;
  }
  switch(a6)
  {
    case 0:
      CFURLRef v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Resources/", anURL);
      CFURLRef v11 = @"Resources/Info.plist";
      CFURLRef v12 = @"Resources/Info-iphoneos.plist";
      if (v10) {
        goto LABEL_20;
      }
      return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    case 1:
      CFURLRef v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Support%20Files/", anURL);
      CFURLRef v11 = @"Support%20Files/Info.plist";
      CFURLRef v12 = @"Support%20Files/Info-iphoneos.plist";
      if (!v10) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 2:
      CFURLRef v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Contents/", anURL);
      CFURLRef v11 = @"Contents/Info.plist";
      CFURLRef v12 = @"Contents/Info-iphoneos.plist";
      if (!v10) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 3:
      CFStringRef v14 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
      if (!v14) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      CFStringRef v15 = v14;
      if (CFStringHasSuffix(v14, @"Support Files")
        || CFStringHasSuffix(v15, @"Contents")
        || CFStringHasSuffix(v15, @"Resources"))
      {
        CFURLRef v10 = 0;
        CFURLRef v11 = @"Resources/Info.plist";
        CFURLRef v12 = @"Resources/Info-iphoneos.plist";
      }
      else
      {
        CFURLRef v10 = (const __CFURL *)CFRetain(anURL);
        CFURLRef v11 = @"Info.plist";
        CFURLRef v12 = @"Info-iphoneos.plist";
      }
      CFRelease(v15);
      if (!v10) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 12:
      CFURLRef v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"WrappedBundle/Contents/", anURL);
      CFURLRef v11 = @"WrappedBundle/Contents/Info.plist";
      CFURLRef v12 = @"WrappedBundle/Contents/Info-iphoneos.plist";
      if (!v10) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 13:
      CFURLRef v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"WrappedBundle/", anURL);
      CFURLRef v11 = @"WrappedBundle/Info.plist";
      CFURLRef v12 = @"WrappedBundle/Info-iphoneos.plist";
      if (!v10) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
LABEL_20:
      CFURLRef v16 = CFURLCopyAbsoluteURL(v10);
      CFStringRef v17 = CFURLCopyFileSystemPath(v16, kCFURLPOSIXPathStyle);
      CFRelease(v16);
      uint64_t v50 = 0;
      CFURLRef v51 = &v50;
      uint64_t v52 = 0x2000000000;
      uint64_t v53 = 0;
      uint64_t v46 = 0;
      uint64_t v47 = &v46;
      uint64_t v48 = 0x2000000000;
      uint64_t v49 = 0;
      if (v17)
      {
        CFIndex Length = CFStringGetLength(@"Info.plist");
        v45[0] = off_1ECE0A5A0;
        v45[1] = 0x40000000;
        v45[2] = ___CFBundleCopyInfoDictionaryInDirectoryWithVersion_block_invoke;
        v45[3] = &unk_1ECE010D8;
        v45[6] = CFStringGetLength(@"Info-iphoneos.plist");
        v45[7] = v12;
        v45[4] = &v46;
        v45[5] = &v50;
        v45[8] = anURL;
        v45[9] = Length;
        v45[10] = v11;
        _CFIterateDirectory(v17, 0, 0, (uint64_t)v45);
        CFRelease(v17);
      }
      CFRelease(v10);
      CFTypeRef v44 = 0;
      if (!a4) {
        goto LABEL_47;
      }
      CFURLRef v19 = (const __CFURL *)v51[3];
      CFURLRef v20 = (const __CFURL *)v47[3];
      CFURLRef v58 = v20;
      CFURLRef v59 = v19;
      if (v20)
      {
        LOBYTE(resourceData[0]) = 0;
        *(void *)buf = 0;
        CFDataRef MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(v20, 1, 0, (BOOL *)resourceData, (CFErrorRef *)buf);
        if (MappedOrLoadedPlistData)
        {
          CFTypeRef v44 = v20;
        }
        else if (*(void *)buf)
        {
          _CFBundleLogLoadingInfoPlistError((uint64_t)&v58, *(CFErrorRef *)buf);
          CFRelease(*(CFTypeRef *)buf);
        }
      }
      else
      {
        CFDataRef MappedOrLoadedPlistData = 0;
      }
      if (v19 && !MappedOrLoadedPlistData)
      {
        LOBYTE(resourceData[0]) = 0;
        *(void *)buf = 0;
        CFDataRef MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(v19, 1, 0, (BOOL *)resourceData, (CFErrorRef *)buf);
        if (MappedOrLoadedPlistData)
        {
          CFTypeRef v44 = v19;
        }
        else if (*(void *)buf)
        {
          _CFBundleLogLoadingInfoPlistError((uint64_t)&v59, *(CFErrorRef *)buf);
          CFRelease(*(CFTypeRef *)buf);
        }
      }
      if (!MappedOrLoadedPlistData)
      {
LABEL_47:
        resourceData[0] = 0;
        CFURLRef v33 = (const __CFURL *)v47[3];
        if (v33
          && (CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v33, resourceData, 0, 0, 0), (CFDataRef v34 = resourceData[0]) != 0))
        {
          BOOL v35 = v47;
        }
        else
        {
          CFURLRef v36 = (const __CFURL *)v51[3];
          if (!v36
            || (CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v36, resourceData, 0, 0, 0), (CFDataRef v34 = resourceData[0]) == 0))
          {
            CFSetRef Mutable = 0;
            goto LABEL_64;
          }
          BOOL v35 = v51;
        }
        CFTypeRef v44 = (CFTypeRef)v35[3];
        error[0] = 0;
        CFSetRef Mutable = (void *)CFPropertyListCreateWithData(allocator, v34, 1uLL, 0, error);
        if (Mutable)
        {
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID == CFGetTypeID(Mutable))
          {
            _CFBundleInfoPlistProcessInfoDictionary(Mutable);
LABEL_63:
            CFRelease(resourceData[0]);
            goto LABEL_64;
          }
          CFRelease(Mutable);
        }
        else if (error[0])
        {
          CFErrorDomain Domain = CFErrorGetDomain(error[0]);
          CFIndex Code = CFErrorGetCode(error[0]);
          char v40 = _CFBundleResourceLogger();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134349570;
            *(void *)&buf[4] = v44;
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = Domain;
            *(_WORD *)&buf[22] = 2050;
            char v61 = (void *)Code;
            _os_log_error_impl(&dword_182B90000, v40, OS_LOG_TYPE_ERROR, "There was an error parsing the Info.plist for the bundle at URL <%{public}p>: %{public}@ - %{public}ld", buf, 0x20u);
          }
          CFRelease(error[0]);
        }
        CFSetRef Mutable = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        goto LABEL_63;
      }
      CFErrorRef v57 = 0;
      CFSetRef v22 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, MappedOrLoadedPlistData, 0, &v57);
      CFSetRef v23 = v22;
      if (v22)
      {
        CFIndex Count = CFSetGetCount(v22);
        char v25 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, 0, 0);
        error[0] = (CFErrorRef)off_1ECE0A5A0;
        error[1] = (CFErrorRef)0x40000000;
        error[2] = (CFErrorRef)___CFBundleCopyLimitedInfoPlistKeys_block_invoke;
        error[3] = (CFErrorRef)&__block_descriptor_tmp_150;
        error[4] = v25;
        CFSetApply(v23, (uint64_t)error);
        _CFBundleInfoPlistProcessInfoDictionary(v25);
        CFSetRef TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, a4);
        CFIndex v27 = CFSetGetCount(a4);
        CFDataRef v28 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v27, &kCFTypeSetCallBacks);
        CFIndex v29 = CFSetGetCount(a4);
        CFDataRef v30 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v29, &kCFTypeSetCallBacks);
        resourceData[0] = (CFDataRef)off_1ECE0A5A0;
        resourceData[1] = (CFDataRef)0x40000000;
        CFDataRef resourceData[2] = (CFDataRef)___CFBundleCopyLimitedInfoPlistKeys_block_invoke_2;
        resourceData[3] = (CFDataRef)&__block_descriptor_tmp_151;
        resourceData[4] = v25;
        resourceData[5] = v28;
        resourceData[6] = v30;
        CFSetApply(TopLevelKeyPaths, (uint64_t)resourceData);
        CFRelease(TopLevelKeyPaths);
        CFTypeRef cf = 0;
        if (_CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, MappedOrLoadedPlistData, 0, v28, &cf, &v57))
        {
          CFTypeRef v31 = cf;
          CFIndex v32 = CFSetGetCount(v30);
          CFSetRef Mutable = CFDictionaryCreateMutable(allocator, v32, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          *(void *)buf = off_1ECE0A5A0;
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___CFCopyLogicalKeysMappedToProcessedValues_block_invoke;
          char v61 = &__block_descriptor_tmp_152;
          uint64_t v62 = v25;
          CFTypeRef v63 = v31;
          uint64_t v64 = Mutable;
          CFSetApply(v30, (uint64_t)buf);
          CFRelease(cf);
        }
        else
        {
          CFSetRef Mutable = 0;
        }
        CFRelease(v28);
        CFRelease(v23);
        CFRelease(v25);
        CFRelease(v30);
      }
      else
      {
        CFSetRef Mutable = 0;
      }
      if (!Mutable && v57)
      {
        _CFBundleLogLoadingInfoPlistError((uint64_t)&v44, v57);
        CFRelease(v57);
      }
      CFRelease(MappedOrLoadedPlistData);
LABEL_64:
      if (a3 && v44)
      {
        CFRetain(v44);
        *a3 = v44;
      }
      long long v41 = (const void *)v47[3];
      if (v41) {
        CFRelease(v41);
      }
      uint64_t v42 = (const void *)v51[3];
      if (v42) {
        CFRelease(v42);
      }
      _Block_object_dispose(&v46, 8);
      _Block_object_dispose(&v50, 8);
      if (!Mutable) {
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      return (CFMutableDictionaryRef)Mutable;
    default:
      return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

void sub_182C32730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return 18;
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  CFAllocatorRef v4 = CFGetAllocator(anURL);
  if (pathStyle) {
    return CFURLCreateStringWithFileSystemPath(v4, (unint64_t)anURL, pathStyle, 0);
  }
  if (!CF_IS_OBJC(0x1DuLL, (unint64_t)anURL))
  {
    if (!*((void *)anURL + 4)) {
      goto LABEL_6;
    }
    return CFURLCreateStringWithFileSystemPath(v4, (unint64_t)anURL, pathStyle, 0);
  }
  if ([(__CFURL *)anURL baseURL]) {
    return CFURLCreateStringWithFileSystemPath(v4, (unint64_t)anURL, pathStyle, 0);
  }
LABEL_6:
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL) || (*((unsigned char *)anURL + 17) & 0x10) == 0) {
    return CFURLCreateStringWithFileSystemPath(v4, (unint64_t)anURL, pathStyle, 0);
  }
  CFStringRef v5 = CFURLGetString(anURL);
  unint64_t Length = CFStringGetLength(v5);
  if (Length <= 1) {
    unint64_t Length = 1;
  }
  int64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v8 = MaximumSizeForEncoding;
  CFIndex v9 = MaximumSizeForEncoding >= 1025 ? (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xA2D6A293uLL) : v14;
  CFStringRef v10 = (const __CFString *)atomic_load((unint64_t *)anURL + 3);
  if (CanonicalFileURLStringToFileSystemRepresentation(v10, v9, v8))
  {
    size_t v11 = strlen(v9);
    CFStringRef v12 = CFStringCreateWithBytes(v4, (const UInt8 *)v9, v11, 0x8000100u, 0);
  }
  else
  {
    CFStringRef v12 = 0;
  }
  if (v9 != v14) {
    free(v9);
  }
  if (!v12) {
    return CFURLCreateStringWithFileSystemPath(v4, (unint64_t)anURL, pathStyle, 0);
  }
  return v12;
}

uint64_t CanonicalFileURLStringToFileSystemRepresentation(const __CFString *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  if (a2 && a3)
  {
    CFStringRef v5 = a2;
    CFIndex Length = CFStringGetLength(a1);
    CFIndex v8 = Length - 7;
    if (Length == 7)
    {
      *CFStringRef v5 = 0;
      return 1;
    }
    else
    {
      CFIndex usedBufLen = 0;
      if (v8 >= 1025)
      {
        CFIndex v9 = (UInt8 *)malloc_type_malloc(3 * v8, 0xF61F24DDuLL);
        if (!v9) {
          return 0;
        }
      }
      else
      {
        CFIndex v9 = buffer;
      }
      v24.CFIndex location = 7;
      v24.CFIndex length = v8;
      if (CFStringGetBytes(a1, v24, 0x8000100u, 0, 0, v9, 3 * v8, &usedBufLen))
      {
        CFIndex v10 = usedBufLen;
        if (usedBufLen >= 1)
        {
          BOOL v11 = 0;
          CFIndex v12 = 0;
          uint64_t v13 = 0;
          uint64_t v14 = v9;
          while (1)
          {
            if (a3 == v13)
            {
              uint64_t v3 = 0;
              goto LABEL_28;
            }
            LODWORD(v15) = *v14;
            if (v15 != 37) {
              break;
            }
            v12 += 2;
            if (v12 < v10)
            {
              char v16 = CanonicalFileURLStringToFileSystemRepresentation_hexvalues[v14[1]];
              v5[v13] = 16 * v16;
              uint64_t v15 = v14[2];
              v14 += 3;
              LOBYTE(v15) = CanonicalFileURLStringToFileSystemRepresentation_hexvalues[v15] + 16 * v16;
LABEL_16:
              v5[v13] = v15;
              BOOL v11 = v15 == 47;
            }
            ++v13;
            if (++v12 >= v10)
            {
              LODWORD(v17) = v13 != 1;
              uint64_t v18 = &v5[v13];
              goto LABEL_21;
            }
          }
          ++v14;
          goto LABEL_16;
        }
        LODWORD(v17) = 0;
        BOOL v11 = 0;
        uint64_t v18 = v5;
LABEL_21:
        CFURLRef v19 = &v5[a3];
        if (v11) {
          uint64_t v17 = v17;
        }
        else {
          uint64_t v17 = 0;
        }
        CFStringRef v5 = &v18[-v17];
        uint64_t v3 = 1;
        if (&v18[-v17] < v19) {
LABEL_28:
        }
          *CFStringRef v5 = 0;
      }
      else
      {
        uint64_t v3 = 0;
      }
      if (v9 != buffer) {
        free(v9);
      }
    }
  }
  return v3;
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  v6[1] = *(void *)off_1ECE0A5B0;
  v6[0] = 0;
  _CFPropertyListCreateWithData((__objc2_class **)allocator, data, options, error, 1, format, 0, v6);
  return (CFPropertyListRef)v6[0];
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  bytes[9] = *(UInt8 **)off_1ECE0A5B0;
  CFStringRef v12 = CFURLCopyScheme(url);
  if (v12)
  {
    CFStringRef v13 = v12;
    if (CFStringCompare(v12, @"file", 1uLL))
    {
      if (CFStringCompare(v13, @"data", 1uLL) == kCFCompareEqualTo)
      {
        char v14 = _CFDataURLCreateDataAndPropertiesFromResource(alloc, url, (__CFString *)resourceData, desiredProperties, properties, (__CFString *)errorCode);
        goto LABEL_24;
      }
      if (__CFNetwork__CFURLCreateDataAndPropertiesFromResource_onceToken != -1) {
        dispatch_once(&__CFNetwork__CFURLCreateDataAndPropertiesFromResource_onceToken, &__block_literal_global_23);
      }
      if (__CFNetwork__CFURLCreateDataAndPropertiesFromResource_dyfunc)
      {
        char v14 = __CFNetwork__CFURLCreateDataAndPropertiesFromResource_dyfunc(alloc, url, resourceData, properties, desiredProperties, errorCode);
LABEL_24:
        LOBYTE(v15) = v14;
LABEL_106:
        CFRelease(v13);
        return v15;
      }
      if (resourceData) {
        *resourceData = 0;
      }
      if (properties) {
        *properties = 0;
      }
      if (errorCode)
      {
        LOBYTE(v15) = 0;
        *SInt32 errorCode = -15;
        goto LABEL_106;
      }
LABEL_105:
      LOBYTE(v15) = 0;
      goto LABEL_106;
    }
    if (errorCode) {
      *SInt32 errorCode = 0;
    }
    if (resourceData)
    {
      bytes[0] = 0;
      CFIndex length = 0;
      CFAllocatorRef v16 = alloc;
      if (!alloc)
      {
        uint64_t v17 = (__objc2_class **)_CFGetTSD(1u);
        if (!v17) {
          uint64_t v17 = &__kCFAllocatorSystemDefault;
        }
        CFAllocatorRef v16 = (const __CFAllocator *)CFRetain(v17);
      }
      if (_CFReadBytesFromFile(v16, url, (void **)bytes, &length, 0, 0))
      {
        CFDataRef v18 = CFDataCreateWithBytesNoCopy(v16, bytes[0], length, v16);
        int v15 = 1;
      }
      else
      {
        CFDataRef v18 = 0;
        int v15 = 0;
        if (errorCode) {
          *SInt32 errorCode = -10;
        }
      }
      *resourceData = v18;
      if (!alloc) {
        CFRelease(v16);
      }
    }
    else
    {
      int v15 = 1;
      CFAllocatorRef v16 = alloc;
    }
    if (!properties)
    {
LABEL_101:
      if (!resourceData || v15) {
        goto LABEL_106;
      }
      if (*resourceData)
      {
        CFRelease(*resourceData);
        LOBYTE(v15) = 0;
        *resourceData = 0;
        goto LABEL_106;
      }
      goto LABEL_105;
    }
    CFAllocatorRef allocator = v16;
    value = 0;
    CFTypeRef cf = 0;
    if (errorCode) {
      *SInt32 errorCode = 0;
    }
    char v45 = 0;
    int valuePtr = 0;
    CFIndex length = 0;
    uid_t v40 = 0;
    if (!desiredProperties)
    {
      desiredProperties = (CFArrayRef)_CFFileURLCreatePropertiesFromResource__allProps;
      if (!_CFFileURLCreatePropertiesFromResource__allProps)
      {
        memset(&bytes[6], 0, 24);
        bytes[0] = (UInt8 *)@"kCFURLFileExists";
        bytes[1] = (UInt8 *)@"kCFURLFilePOSIXMode";
        bytes[2] = (UInt8 *)@"kCFURLFileDirectoryContents";
        bytes[3] = (UInt8 *)@"kCFURLFileLength";
        bytes[4] = (UInt8 *)@"kCFURLFileLastModificationTime";
        bytes[5] = (UInt8 *)@"kCFURLFileOwnerID";
        desiredProperties = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)bytes, 6, &kCFTypeArrayCallBacks);
        _CFFileURLCreatePropertiesFromResource__allProps = (uint64_t)desiredProperties;
      }
    }
    uint64_t Count = CFArrayGetCount(desiredProperties);
    CFDictionaryRef theDict = CFDictionaryCreateMutable(v16, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Count)
    {
LABEL_99:
      *properties = theDict;
      if (!theDict) {
        int v15 = 0;
      }
      goto LABEL_101;
    }
    v47.CFIndex location = 0;
    v47.CFIndex length = Count;
    if (CFArrayContainsValue(desiredProperties, v47, @"kCFURLFileDirectoryContents")) {
      p_value = &value;
    }
    else {
      p_value = 0;
    }
    v48.CFIndex location = 0;
    v48.CFIndex length = Count;
    if (CFArrayContainsValue(desiredProperties, v48, @"kCFURLFileLastModificationTime")) {
      p_CFTypeRef cf = (CFDateRef *)&cf;
    }
    else {
      p_CFTypeRef cf = 0;
    }
    if (_CFGetFileProperties(allocator, url, &v45, &valuePtr, &length, p_cf, &v40, (__CFArray **)p_value))
    {
      if (Count == 1
        && (v49.location = 0, v49.CFIndex length = 1,
                                CFArrayContainsValue(desiredProperties, v49, @"kCFURLFileExists")))
      {
        CFDictionarySetValue(theDict, @"kCFURLFileExists", &__kCFBooleanFalse);
      }
      else if (errorCode)
      {
        *SInt32 errorCode = -10;
      }
      goto LABEL_99;
    }
    if (Count < 1)
    {
LABEL_95:
      if (cf) {
        CFRelease(cf);
      }
      if (value) {
        CFRelease(value);
      }
      goto LABEL_99;
    }
    CFIndex v22 = 0;
    uint64_t v23 = @"kCFURLFileLength";
    while (1)
    {
      CFRange v24 = v23;
      CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(desiredProperties, v22);
      if (ValueAtIndex == @"kCFURLFilePOSIXMode" || CFEqual(@"kCFURLFilePOSIXMode", ValueAtIndex)) {
        break;
      }
      CFIndex v29 = @"kCFURLFileDirectoryContents";
      if (ValueAtIndex == @"kCFURLFileDirectoryContents"
        || (int v30 = CFEqual(@"kCFURLFileDirectoryContents", ValueAtIndex),
            CFIndex v29 = @"kCFURLFileDirectoryContents",
            v30))
      {
        if (v45)
        {
          if ((valuePtr & 0xF000) == 0x4000)
          {
            CFTypeRef v31 = (__objc2_class **)value;
            if (value) {
              goto LABEL_68;
            }
          }
        }
LABEL_78:
        uint64_t v23 = v24;
        goto LABEL_79;
      }
      uint64_t v23 = v24;
      if (ValueAtIndex != v24)
      {
        int v33 = CFEqual(v24, ValueAtIndex);
        uint64_t v23 = v24;
        if (!v33)
        {
          CFIndex v29 = @"kCFURLFileLastModificationTime";
          if (ValueAtIndex == @"kCFURLFileLastModificationTime"
            || (int v34 = CFEqual(@"kCFURLFileLastModificationTime", ValueAtIndex),
                CFIndex v29 = @"kCFURLFileLastModificationTime",
                v34))
          {
            if (v45)
            {
              CFTypeRef v31 = (__objc2_class **)cf;
              if (cf)
              {
LABEL_68:
                CFIndex v32 = theDict;
LABEL_69:
                CFDictionarySetValue(v32, v29, v31);
                goto LABEL_62;
              }
            }
          }
          else
          {
            CFIndex v29 = @"kCFURLFileExists";
            if (ValueAtIndex == @"kCFURLFileExists"
              || (v36 = CFEqual(@"kCFURLFileExists", ValueAtIndex), CFIndex v29 = @"kCFURLFileExists", v36))
            {
              CFIndex v32 = theDict;
              if (v45) {
                CFTypeRef v31 = &__kCFBooleanTrue;
              }
              else {
                CFTypeRef v31 = &__kCFBooleanFalse;
              }
              goto LABEL_69;
            }
            if (ValueAtIndex != @"kCFURLFileOwnerID" && !CFEqual(@"kCFURLFileOwnerID", ValueAtIndex))
            {
              uint64_t v23 = v24;
              if (!errorCode) {
                goto LABEL_82;
              }
              SInt32 v35 = -16;
              goto LABEL_81;
            }
            if (v45)
            {
              CFNumberRef v26 = CFNumberCreate(allocator, kCFNumberSInt32Type, &v40);
              CFIndex v27 = theDict;
              CFDataRef v28 = @"kCFURLFileOwnerID";
LABEL_61:
              CFDictionarySetValue(v27, v28, v26);
              CFRelease(v26);
LABEL_62:
              uint64_t v23 = v24;
              goto LABEL_82;
            }
          }
          goto LABEL_78;
        }
      }
      if (v45)
      {
        CFNumberRef v26 = CFNumberCreate(allocator, kCFNumberSInt64Type, &length);
        CFIndex v27 = theDict;
        CFDataRef v28 = v24;
        goto LABEL_61;
      }
LABEL_79:
      if (errorCode)
      {
        SInt32 v35 = -10;
LABEL_81:
        *SInt32 errorCode = v35;
      }
LABEL_82:
      if (Count == ++v22) {
        goto LABEL_95;
      }
    }
    if (v45)
    {
      CFNumberRef v26 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
      CFIndex v27 = theDict;
      CFDataRef v28 = @"kCFURLFilePOSIXMode";
      goto LABEL_61;
    }
    goto LABEL_78;
  }
  if (errorCode) {
    *SInt32 errorCode = -15;
  }
  if (resourceData) {
    *resourceData = 0;
  }
  LOBYTE(v15) = 0;
  if (properties) {
    *properties = 0;
  }
  return v15;
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  while (1)
  {
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL))
    {
      CFStringRef v7 = (const __CFString *)[(__CFURL *)anURL scheme];
      CFStringRef v5 = v7;
      if (v7) {
        CFRetain(v7);
      }
      return v5;
    }
    if (!(!v3 & v2)) {
      break;
    }
    CFStringRef v4 = _retainedComponentString((uint64_t)anURL, 1, 1, 0);
    if (v4) {
      return v4;
    }
    anURL = (CFURLRef)*((void *)anURL + 4);
    if (!anURL) {
      return 0;
    }
  }
  switch(*((_DWORD *)anURL + 4) >> 29)
  {
    case 1:
      CFTypeID v6 = @"http";
      break;
    case 2:
      CFTypeID v6 = @"https";
      break;
    case 3:
      CFTypeID v6 = @"file";
      break;
    case 4:
      CFTypeID v6 = @"data";
      break;
    case 5:
      CFTypeID v6 = @"ftp";
      break;
    default:
      JUMPOUT(0);
  }

  return (CFStringRef)CFRetain(v6);
}

uint64_t _CFReadBytesFromFile(const __CFAllocator *a1, CFURLRef url, void **a3, int64_t *a4, int64_t st_size, int a6)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  uint64_t result = CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026);
  if (result)
  {
    *a3 = 0;
    if (__CFProphylacticAutofsAccess)
    {
      int v12 = open("/dev/autofs_nowait", 0);
      int v13 = open((const char *)buffer, a6, 438);
      if (v13 < 0) {
        goto LABEL_21;
      }
      int v14 = v13;
    }
    else
    {
      int v15 = open((const char *)buffer, a6, 438);
      if (v15 < 0) {
        return 0;
      }
      int v14 = v15;
      int v12 = -1;
    }
    memset(&v21, 0, sizeof(v21));
    if (fstat(v14, &v21) < 0)
    {
      int v19 = *__error();
      close(v14);
      if (v12 != -1) {
        close(v12);
      }
      *__error() = v19;
      return 0;
    }
    if ((v21.st_mode & 0xF000) != 0x8000)
    {
      close(v14);
      if (v12 != -1) {
        close(v12);
      }
      *__error() = 13;
      return 0;
    }
    if (v21.st_size)
    {
      if (v21.st_size <= st_size || st_size == 0) {
        off_t st_size = v21.st_size;
      }
      uint64_t Typed = CFAllocatorAllocateTyped(a1, st_size, 920877487, 0);
      *a3 = (void *)Typed;
      if (!Typed) {
        goto LABEL_20;
      }
      CFDataRef v18 = (void *)Typed;
      if (__CFOASafe)
      {
        __CFSetLastAllocationEventName();
        CFDataRef v18 = *a3;
      }
      if (read(v14, v18, st_size) < 0)
      {
        CFAllocatorDeallocate(a1, *a3);
LABEL_20:
        close(v14);
LABEL_21:
        if (v12 != -1) {
          close(v12);
        }
        return 0;
      }
    }
    else
    {
      *a3 = (void *)CFAllocatorAllocateTyped(a1, 4, 1113882534, 0);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      off_t st_size = 0;
    }
    *a4 = st_size;
    if (v12 != -1) {
      close(v12);
    }
    close(v14);
    return 1;
  }
  return result;
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  char v3 = (os_unfair_lock_s *)((char *)bundle + 96);
  os_unfair_lock_lock_with_options();
  Boolean v4 = *((unsigned char *)bundle + 52);
  os_unfair_lock_unlock(v3);
  return v4;
}

uint64_t _CFPlugInHandleDynamicRegistration(__CFBundle *a1)
{
  uint64_t result = __CFBundleGetPlugInData((uint64_t)a1);
  if (*(unsigned char *)result)
  {
    uint64_t v3 = result;
    uint64_t result = CFBundleIsExecutableLoaded(a1);
    if (result)
    {
      if (*(unsigned char *)(v3 + 3))
      {
        os_unfair_recursive_lock_lock_with_options();
        if (!*(unsigned char *)(v3 + 2))
        {
          *(unsigned char *)(v3 + 3) = 0;
          CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(a1);
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFPlugInDynamicRegisterFunction");
          if (!Value || (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 != CFStringGetTypeID()) || CFStringGetLength(v6) <= 0) {
            CFStringRef v6 = @"CFPlugInDynamicRegister";
          }
          *(_WORD *)(v3 + 1) = 256;
          FunctionPointerForName = (uint64_t (*)(uint64_t))CFBundleGetFunctionPointerForName(a1, v6);
          if (FunctionPointerForName) {
            __CFPLUGIN_IS_CALLING_OUT_TO_A_DYNAMIC_REGISTRATION_FUNCTION__(FunctionPointerForName, (uint64_t)a1);
          }
          *(unsigned char *)(v3 + 2) = 0;
          if (*(unsigned char *)(v3 + 1) && !*(_DWORD *)(v3 + 8)) {
            CFBundleUnloadExecutable(a1);
          }
        }
        return os_unfair_recursive_lock_unlock();
      }
    }
  }
  return result;
}

uint64_t __CFBundleGetPlugInData(uint64_t a1)
{
  return a1 + 72;
}

void _CFBundleAddToTablesLocked(const void **value, const void *a2)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  if (!*((unsigned char *)value + 54))
  {
    Boolean v4 = (__CFArray *)_allBundles;
    if (!_allBundles)
    {
      *(_OWORD *)&callBacks.version = *(_OWORD *)&kCFTypeArrayCallBacks.version;
      *(_OWORD *)&callBacks.release = *(_OWORD *)&kCFTypeArrayCallBacks.release;
      callBacks.equal = CFEqual;
      Boolean v4 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
      _allBundles = (uint64_t)v4;
    }
    CFArrayAppendValue(v4, value);
    CFSetRef Mutable = (__CFDictionary *)_bundlesByURL;
    if (!_bundlesByURL)
    {
      memset(&callBacks, 0, 24);
      callBacks.copyDescription = kCFTypeDictionaryValueCallBacks.copyDescription;
      callBacks.equal = CFEqual;
      CFSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, (const CFDictionaryValueCallBacks *)&callBacks);
      _bundlesByURL = (uint64_t)Mutable;
    }
    CFDictionarySetValue(Mutable, value[2], value);
    if (a2)
    {
      CFDictionaryRef v6 = (const __CFDictionary *)_bundlesByIdentifier;
      if (!_bundlesByIdentifier)
      {
        CFDictionaryRef v6 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        _bundlesByCFStringRef Identifier = (uint64_t)v6;
      }
      CFArrayRef v7 = (const __CFArray *)CFDictionaryGetValue(v6, a2);
      if (!v7)
      {
        memset(&callBacks, 0, 24);
        callBacks.copyDescription = kCFTypeArrayCallBacks.copyDescription;
        callBacks.equal = CFEqual;
        int v14 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
        CFArrayAppendValue(v14, value);
        CFDictionarySetValue((CFMutableDictionaryRef)_bundlesByIdentifier, a2, v14);
        int v15 = v14;
LABEL_28:
        CFRelease(v15);
        return;
      }
      CFArrayRef v8 = v7;
      CFIndex Count = CFArrayGetCount(v7);
      UInt32 VersionNumber = CFBundleGetVersionNumber((CFBundleRef)value);
      if (Count < 1)
      {
        CFIndex v12 = 0;
      }
      else
      {
        UInt32 v11 = VersionNumber;
        CFIndex v12 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v8, v12);
          if (v11 >= CFBundleGetVersionNumber(ValueAtIndex)) {
            break;
          }
          if (Count == ++v12)
          {
            CFIndex v12 = Count;
            break;
          }
        }
      }
      CFArrayInsertValueAtIndex(v8, v12, value);
      if (_CFBundleResourceLogger_onceToken != -1) {
        dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
      }
      if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v16 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        if (CFArrayGetCount(v8) >= 1)
        {
          CFIndex v17 = 0;
          do
          {
            CFDataRef v18 = CFArrayGetValueAtIndex(v8, v17);
            CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"Bundle %p at %@", v18, v18[2]);
            CFArrayAppendValue(v16, v19);
            CFRelease(v19);
            ++v17;
          }
          while (v17 < CFArrayGetCount(v8));
        }
        if (_CFBundleResourceLogger_onceToken != -1) {
          dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_DEBUG)) {
          _CFBundleAddToTablesLocked_cold_1();
        }
        int v15 = v16;
        goto LABEL_28;
      }
    }
  }
}

uint64_t _binaryLoadable(const __CFURL *a1)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  if (_CFURLExists(a1)) {
    return 1;
  }
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
  if (result) {
    return _dyld_shared_cache_contains_path((const char *)buffer);
  }
  return result;
}

CFStringRef _CFBundleCopyLoadedImagePathForPointer()
{
  v0 = (const char *)dyld_image_path_containing_address();
  char v1 = _CFBundleNormalizedPath(v0);
  if (v1) {
    CFStringRef v2 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
  }
  else {
    CFStringRef v2 = 0;
  }
  uint64_t v3 = _CFBundleLoadingLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
    _CFBundleCopyLoadedImagePathForPointer_cold_1();
  }
  return v2;
}

void _CFBundleEnsureBundlesUpToDateWithHint(const __CFString *a1)
{
  CFBundleGetMainBundle();
  CFStringRef v2 = _CFBundleDYLDCopyLoadedImagePathsForHint(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    _CFBundleEnsureBundlesExistForImagePaths(v2);
    CFRelease(v3);
  }
}

void _CFBundleEnsureBundlesExistForImagePaths(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      _CFBundleEnsureBundleExistsForImagePath((uint64_t)ValueAtIndex, 1);
    }
  }
}

void _CFBundleCreate_cold_2()
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_0();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_debug_impl(&dword_182B90000, v1, OS_LOG_TYPE_DEBUG, "Unable to create bundle at URL (%@): does not exist or not a directory (%d)", v2, 0x12u);
}

__CFArray *__CFArrayCreateMutableCopy0(__objc2_class **a1, uint64_t a2, unint64_t *a3)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)a3)) {
    uint64_t v6 = [a3 count];
  }
  else {
    uint64_t v6 = a3[2];
  }
  if (CF_IS_OBJC(0x13uLL, (unint64_t)a3)) {
    goto LABEL_5;
  }
  unsigned int v12 = atomic_load(a3 + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_5:
      CFArrayRef v7 = &kCFTypeArrayCallBacks;
      goto LABEL_6;
    }
    char v14 = atomic_load(a3 + 1);
    int v15 = v14 & 3;
    if (v15 != 2 && v15) {
      CFArrayRef v7 = 0;
    }
    else {
      CFArrayRef v7 = (const CFArrayCallBacks *)(a3 + 6);
    }
  }
  else
  {
    CFArrayRef v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_6:
  unint64_t Init = __CFArrayCreateInit(a1, 2, a2, v7);
  CFIndex v9 = (__CFArray *)Init;
  if (!a2) {
    _CFArraySetCapacity(Init, v6);
  }
  if (v6 >= 1)
  {
    for (uint64_t i = 0; i != v6; ++i)
      CFArrayAppendValue(v9, (const void *)[a3 objectAtIndex:i]);
  }
  return v9;
}

void _CFArraySetCapacity(unint64_t a1, uint64_t a2)
{
  if (!CF_IS_OBJC(0x13uLL, a1))
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    if ((v4 & 3) == 2)
    {
      uint64_t v5 = *(void **)(a1 + 40);
      if (a2 >= 4)
      {
        if (flsl(a2) == 31) {
          uint64_t v6 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v6 = 1 << flsl(a2);
        }
      }
      else
      {
        uint64_t v6 = 4;
      }
      if ((a1 & 0x8000000000000000) != 0)
      {
        CFArrayRef v7 = &kCFAllocatorSystemDefault;
      }
      else
      {
        char v8 = atomic_load((unint64_t *)(a1 + 8));
        if (v8 < 0) {
          CFArrayRef v7 = &kCFAllocatorSystemDefault;
        }
        else {
          CFArrayRef v7 = (const CFAllocatorRef *)(a1 - 16);
        }
      }
      CFAllocatorRef v9 = *v7;
      if (v5)
      {
        uint64_t v10 = v5[1];
        uint64_t Typed = (void *)CFAllocatorAllocateTyped(*v7, 8 * v6 + 16, 3380702267, 0);
        if (Typed)
        {
          unsigned int v12 = Typed;
          memmove(Typed, v5, 8 * v10 + 16);
          CFAllocatorDeallocate(v9, v5);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
LABEL_24:
          v12[1] = v6;
          *(void *)(a1 + 40) = v12;
          return;
        }
      }
      else
      {
        uint64_t v13 = CFAllocatorAllocateTyped(*v7, 8 * v6 + 16, 2017679120, 0);
        if (v13)
        {
          unsigned int v12 = (void *)v13;
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          if (v6 >= 0) {
            uint64_t v14 = v6;
          }
          else {
            uint64_t v14 = v6 + 1;
          }
          *unsigned int v12 = v14 >> 1;
          goto LABEL_24;
        }
      }
      __CFArrayHandleOutOfMemory(8 * v6 + 16);
    }
  }
}

void sub_182C34B70(_Unwind_Exception *exception_object)
{
}

Boolean CFSetGetValueIfPresent(CFSetRef theSet, const void *candidate, const void **value)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet)) {
    return [(__CFSet *)theSet __getValue:value forObj:candidate];
  }
  long long v7 = 0u;
  long long v8 = 0u;
  CFBasicHashFindBucket((uint64_t)theSet, (unint64_t)candidate, (uint64_t *)&v7);
  if (!*((void *)&v8 + 1)) {
    return 0;
  }
  if (value) {
    void *value = (const void *)v8;
  }
  return 1;
}

const void *__cdecl CFBagGetValue(CFBagRef theBag, const void *value)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  long long v3 = 0u;
  long long v4 = 0u;
  CFBasicHashFindBucket((uint64_t)theBag, (unint64_t)value, (uint64_t *)&v3);
  if (*((void *)&v4 + 1)) {
    return (const void *)v4;
  }
  else {
    return 0;
  }
}

uint64_t _CFSetFastEnumeration(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (CF_IS_OBJC(0x11uLL, a1)) {
    return 0;
  }

  return __CFBasicHashFastEnumeration(a1, a2, a3, a4);
}

BOOL _CFSetIsMutable(unint64_t a1)
{
  if (CF_IS_OBJC(0x11uLL, a1)) {
    return 0;
  }
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

CFBitVectorRef CFBitVectorCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex numBits)
{
  return (CFBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 0, bytes, numBits);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    -[__CFData replaceBytesInRange:withBytes:length:](theData, "replaceBytesInRange:withBytes:length:", location, length, 0, 0);
  }
  else
  {
    v5.CFIndex location = location;
    v5.CFIndex length = length;
    CFDataReplaceBytes(theData, v5, 0, 0);
  }
}

atomic_ullong *__CFURLSetResourceInfoPtr(atomic_ullong *result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    uint64_t result = (atomic_ullong *)CF_IS_OBJC(0x1DuLL, (unint64_t)result);
    if (!result || (uint64_t result = (atomic_ullong *)[(atomic_ullong *)v3 _cfurl], (v3 = result) != 0))
    {
      uint64_t v4 = 0;
      atomic_compare_exchange_strong(v3 + 6, (unint64_t *)&v4, (unint64_t)a2);
      if (!v4)
      {
        return (atomic_ullong *)CFRetain(a2);
      }
    }
  }
  return result;
}

uint64_t __NSCheckReentrancy(objc_class *a1, const char *a2)
{
  uint64_t result = _CFGetTSD(3u);
  if ((objc_class *)result == a1)
  {
    uint64_t v5 = __CFExceptionProem(a1, a2);
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@: invalid re-entrancy into cache %p", v5, a1);
    long long v7 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v6) userInfo:0];
    objc_exception_throw(v7);
  }
  return result;
}

void sub_182C37ED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
}

void sub_182C38578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL _CFPrefsDirectMode()
{
  BOOL result = 1;
  if ((isCFPrefsD & 1) == 0 && !forceDirect)
  {
    if (_CFPrefsProcessPathRequiresDirectMode_onceToken != -1) {
      dispatch_once(&_CFPrefsProcessPathRequiresDirectMode_onceToken, &__block_literal_global_159);
    }
    if (_CFPrefsProcessPathRequiresDirectMode_onBlacklist)
    {
      return 1;
    }
    else
    {
      if (_CFPrefsDirectMode_onceToken != -1) {
        dispatch_once(&_CFPrefsDirectMode_onceToken, &__block_literal_global_43);
      }
      return forceDirect != 0;
    }
  }
  return result;
}

void sub_182C3908C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x182C38FF8);
  }
  _Unwind_Resume(a1);
}

void sub_182C39774(_Unwind_Exception *exception_object)
{
}

uint64_t _CFPrefsEncodeValueIntoMessage(xpc_object_t xdict, char *key, __objc2_class **cf, void *a4)
{
  uint64_t v4 = 0;
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  if (!key || !cf) {
    return v4;
  }
  if (&__kCFBooleanTrue == cf || &__kCFBooleanFalse == cf)
  {
    xpc_dictionary_set_BOOL(xdict, key, &__kCFBooleanTrue == cf);
    CFIndex Length = 1;
  }
  else
  {
    if (&__kCFNull == cf)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_dictionary_set_value(xdict, key, v11);
      xpc_release(v11);
      return 1;
    }
    if (CFGetTypeID(cf) == 7)
    {
      bzero(buffer, 0x400uLL);
      if (CFStringGetCString((CFStringRef)cf, buffer, 1024, 0x8000100u))
      {
        xpc_dictionary_set_string(xdict, key, buffer);
      }
      else
      {
        uint64_t v4 = (uint64_t)_CFXPCCreateXPCObjectFromCFObject((__CFString *)cf);
        if (!v4) {
          goto LABEL_24;
        }
        xpc_dictionary_set_value(xdict, key, (xpc_object_t)v4);
        xpc_release((xpc_object_t)v4);
      }
      uint64_t v4 = 1;
LABEL_24:
      CFIndex Length = CFStringGetLength((CFStringRef)cf);
      if (!a4) {
        return v4;
      }
      goto LABEL_25;
    }
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (!Data)
    {
      size_t v16 = strlen(key);
      CFStringRef v17 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)key, v16, 0x8000100u, 0);
      _CFPrefsValidateValueForKey(cf, (uint64_t)v17);
      if (v17) {
        CFRelease(v17);
      }
      return 0;
    }
    CFDataRef v13 = Data;
    BytePtr = CFDataGetBytePtr(Data);
    size_t v15 = CFDataGetLength(v13);
    xpc_dictionary_set_data(xdict, key, BytePtr, v15);
    CFIndex Length = CFDataGetLength(v13);
    CFRelease(v13);
  }
  uint64_t v4 = 1;
  if (!a4) {
    return v4;
  }
LABEL_25:
  if (v4 && Length)
  {
    *a4 += Length;
    return 1;
  }
  return v4;
}

void sub_182C39F04(_Unwind_Exception *exception_object)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

BOOL _CFPrefsGetPathForManagedBundleID(__CFString *a1, __CFString *a2, int a3, UInt8 *a4)
{
  if (_CFPrefsGetPathForManagedBundleID_onceToken == -1)
  {
    if (!a3) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_onceToken, &__block_literal_global_8);
    if (!a3) {
      goto LABEL_5;
    }
  }
  if (_CFPrefsGetPathForManagedBundleID_containerizedOnceToken != -1) {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_containerizedOnceToken, &__block_literal_global_13_0);
  }
LABEL_5:
  if (a1 && (CacheStringForBundleID = (__CFString *)_CFPrefsGetCacheStringForBundleID(a1)) != 0)
  {
    uint64_t v9 = CacheStringForBundleID;
    if (CFEqual(CacheStringForBundleID, @"kCFPreferencesAnyApplication")) {
      uint64_t v10 = @".GlobalPreferences";
    }
    else {
      uint64_t v10 = v9;
    }
    if (!a3) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
    if (!a3)
    {
LABEL_11:
      CFURLRef v11 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFStringRef)_CFPrefsGetPathForManagedBundleID_containingDirectoryPath, kCFURLPOSIXPathStyle, 1u);
      goto LABEL_14;
    }
  }
  CFURLRef v11 = (const __CFURL *)CFRetain((CFTypeRef)_CFPrefsGetPathForManagedBundleID_containerizedContainingDirectoryURL);
LABEL_14:
  CFURLRef v12 = v11;
  if (!v11) {
    return 0;
  }
  if (CFEqual(a2, @"kCFPreferencesAnyUser"))
  {
    if (!v10)
    {
      CFStringRef v14 = &stru_1ECE10768;
      goto LABEL_29;
    }
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@.plist", v10);
    goto LABEL_18;
  }
  if (!CFEqual(a2, @"kCFPreferencesCurrentUser"))
  {
    uint64_t v20 = _CFPrefsCopyUsernameForMobileUser();
    if (v20)
    {
      uint64_t v21 = v20;
      if (CFEqual(a2, v20)) {
        a2 = @"mobile";
      }
      CFRelease(v21);
    }
    if (v10) {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@/%@.plist", a2, v10);
    }
    else {
      CFStringRef v13 = (const __CFString *)CFRetain(a2);
    }
LABEL_18:
    CFStringRef v14 = v13;
    goto LABEL_19;
  }
  if (_CFPrefsGetPathForManagedBundleID_onceToken_23 != -1) {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_onceToken_23, &__block_literal_global_25);
  }
  CFStringRef v15 = (CFStringRef)_CFPrefsGetPathForManagedBundleID_ourUserName;
  if (!_CFPrefsGetPathForManagedBundleID_ourUserName)
  {
    CFStringRef v15 = CFCopyUserName();
    if (v10) {
      goto LABEL_26;
    }
LABEL_41:
    CFStringRef v16 = (const __CFString *)CFRetain(v15);
    goto LABEL_42;
  }
  if (!v10) {
    goto LABEL_41;
  }
LABEL_26:
  CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@/%@.plist", v15, v10);
LABEL_42:
  CFStringRef v14 = v16;
  if (!_CFPrefsGetPathForManagedBundleID_ourUserName && v15) {
    CFRelease(v15);
  }
LABEL_19:
  if (v14)
  {
LABEL_29:
    CFURLRef v18 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, kCFURLPOSIXPathStyle, 0, v12);
    CFRelease(v14);
    CFRelease(v12);
    if (v18)
    {
      BOOL v17 = CFURLGetFileSystemRepresentation(v18, 1u, a4, 1024) != 0;
      CFURLRef v12 = v18;
      goto LABEL_31;
    }
    return 0;
  }
  BOOL v17 = 0;
LABEL_31:
  CFRelease(v12);
  return v17;
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)_CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory, 0);
}

__CFString *_CFPrefsCopyUsernameForMobileUser()
{
  if (!eduModeEnabled()) {
    return @"mobile";
  }
  if (_CFPrefsCopyUsernameForMobileUser_onceToken != -1) {
    dispatch_once(&_CFPrefsCopyUsernameForMobileUser_onceToken, &__block_literal_global_30);
  }
  int v0 = (const void *)_CFPrefsCopyUsernameForMobileUser_mobileUserName;

  return (__CFString *)CFRetain(v0);
}

void sub_182C3AA90(_Unwind_Exception *a1)
{
}

uint64_t _plistSizeIsAppropriateToRead(unint64_t a1)
{
  if (a1 - 0x7FFFFFFFFFFFFFFFLL <= 0x8000000000000001)
  {
    _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
    CFStringRef v2 = _CFPrefsClientLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      _plistSizeIsAppropriateToRead_cold_1();
    }
LABEL_11:
    _CFSetTSD(0xFu, 0, 0);
    return 0;
  }
  if (_plistSizeIsAppropriateToRead_onceToken != -1) {
    dispatch_once(&_plistSizeIsAppropriateToRead_onceToken, &__block_literal_global_187);
  }
  uint64_t result = 1;
  if (a1 >= 0x400000 && _plistSizeIsAppropriateToRead_isSizeLimitedProcess)
  {
    _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
    uint64_t v4 = _CFPrefsClientLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      _plistSizeIsAppropriateToRead_cold_2();
    }
    goto LABEL_11;
  }
  return result;
}

void sub_182C3ABFC(_Unwind_Exception *a1)
{
}

void *_CFUnsandboxedHomeDirectoryForCurrentUser()
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  uid_t v0 = geteuid();
  uid_t v1 = getuid();
  if (v0) {
    uid_t v1 = v0;
  }
  CFStringRef v2 = getpwuid(v1);
  if (!v2
    || (pw_dir = (const UInt8 *)v2->pw_dir) == 0
    || (size_t v4 = strnlen(v2->pw_dir, 0x400uLL),
        (uint64_t v5 = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_dir, v4, 1u)) == 0))
  {
    CFStringRef v6 = __CFgetenv("HOME");
    uint64_t v5 = (const UInt8 *)v6;
    if (v6)
    {
      size_t v7 = strnlen(v6, 0x400uLL);
      uint64_t v5 = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v7, 1u);
    }
  }
  bzero(buffer, 0x400uLL);
  CFURLGetFileSystemRepresentation((CFURLRef)v5, 1u, buffer, 1024);
  size_t v8 = strnlen((const char *)buffer, 0x400uLL);
  uint64_t v9 = malloc_type_malloc(v8 + 1, 0x100004077774924uLL);
  memmove(v9, buffer, v8);
  *((unsigned char *)v9 + v8) = 0;
  if (v5) {
    CFRelease(v5);
  }
  return v9;
}

void _CFPrefsApplyChangesQueueToDictionary(void *a1, __CFDictionary *a2)
{
  if (!a1) {
    _CFPrefsApplyChangesQueueToDictionary_cold_1();
  }
  if (object_getClass(a1) != (Class)off_1ECE0A668) {
    _CFPrefsApplyChangesQueueToDictionary_cold_4();
  }
  size_t count = xpc_array_get_count(a1);
  size_t v5 = count;
  if (count) {
    _CFPrefsApplyChangesQueueToDictionary_cold_3();
  }
  if (count)
  {
    char v6 = 0;
    size_t v7 = 0;
    while (1)
    {
      CFURLRef value = (const __CFURL *)xpc_array_get_value(a1, v7);
      CFDataRef v9 = _CFXPCCreateCFObjectFromXPCObject(value);
      size_t v10 = v7 + 1;
      xpc_object_t v11 = xpc_array_get_value(a1, v10);
      if (object_getClass(v11) == (Class)off_1ECE0A680)
      {
        size_t length = xpc_data_get_length(v11);
        bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v11);
        CFDataRef v15 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes_ptr, length, (CFAllocatorRef)&__kCFAllocatorNull);
        uint64_t v12 = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, 0, 0, 0);
        CFRelease(v15);
        if (!v9) {
          goto LABEL_13;
        }
      }
      else
      {
        uint64_t v12 = _CFXPCCreateCFObjectFromXPCObject((const __CFURL *)v11);
        if (!v9) {
          goto LABEL_13;
        }
      }
      if (v12)
      {
        CFTypeID v16 = CFGetTypeID(v12);
        if (v16 == CFNullGetTypeID()) {
          CFDictionaryRemoveValue(a2, v9);
        }
        else {
          CFDictionarySetValue(a2, v9, v12);
        }
LABEL_19:
        CFRelease(v9);
        if (!v12) {
          goto LABEL_16;
        }
LABEL_15:
        CFRelease(v12);
        goto LABEL_16;
      }
LABEL_13:
      char v6 = 1;
      if (v9) {
        goto LABEL_19;
      }
      if (v12) {
        goto LABEL_15;
      }
LABEL_16:
      size_t v7 = v10 + 1;
      if (v7 >= v5)
      {
        if (v6)
        {
          BOOL v17 = _CFPrefsDaemonLog();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
            _CFPrefsApplyChangesQueueToDictionary_cold_2();
          }
        }
        return;
      }
    }
  }
}

CFStringRef _CFStringCreateWithFormatAndArgumentsAux(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  return _CFStringCreateWithFormatAndArgumentsReturningMetadata(a1, a2, 0, a3, 0, 0, a4, 0, a5);
}

void sub_182C3B324(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFPlugInRef CFBundleGetPlugIn(CFPlugInRef bundle)
{
  if (!*((unsigned char *)bundle + 72)) {
    return 0;
  }
  return bundle;
}

CFStringRef CFStringCreateStringWithValidatedFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, va_list arguments, CFErrorRef *errorPtr)
{
  return _CFStringCreateStringWithValidatedFormatAux(alloc, (uint64_t)formatOptions, 0, (uint64_t)validFormatSpecifiers);
}

NSSet *mdict_keysOfEntriesWithOptionsPassingTest(uint64_t *a1, char a2, uint64_t a3)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  size_t v7 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((v5 >> 55) & 0x1F8));
  uint64_t v8 = *a1 + 8 * v7;
  int v23 = 0;
  v17[0] = off_1ECE0A5A0;
  v17[1] = 3221225472;
  v17[2] = __mdict_keysOfEntriesWithOptionsPassingTest_block_invoke;
  v17[3] = &unk_1ECE00F60;
  uint64_t v20 = v6;
  uint64_t v21 = v8;
  uint64_t v22 = &v23;
  CFURLRef v18 = +[NSSet set];
  uint64_t v19 = a3;
  CFDataRef v15 = v18;
  if ((__NSCollectionHandleConcurrentEnumerationIfSpecified(a2, 0, v7, (uint64_t)v17) & 1) == 0)
  {
    char v16 = 0;
    if (v5 >> 58)
    {
      size_t v9 = 0;
      do
      {
        size_t v10 = *(void **)(v6 + 8 * v9);
        if (v10) {
          BOOL v11 = v10 == &___NSDictionaryM_DeletedMarker;
        }
        else {
          BOOL v11 = 1;
        }
        if (!v11)
        {
          uint64_t v12 = *(void *)(v8 + 8 * v9);
          CFStringRef v13 = (void *)_CFAutoreleasePoolPush();
          if ((*(unsigned int (**)(uint64_t, void *, uint64_t, char *))(a3 + 16))(a3, v10, v12, &v16)) {
            [(NSSet *)v15 addObject:v10];
          }
          _CFAutoreleasePoolPop(v13);
          if (v16) {
            break;
          }
        }
        ++v9;
      }
      while (v9 < v7);
    }
    return (NSSet *)(id)[(NSSet *)v15 copy];
  }
  return v15;
}

void __NSSetEnumerate(void *a1, char a2, uint64_t a3)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  if ([a1 count])
  {
    if (a2)
    {
      uint64_t v6 = __CFActiveProcessorCount();
      if (v6 < 2) {
        a2 = 0;
      }
    }
    else
    {
      uint64_t v6 = 1;
    }
    if (a2)
    {
      unint64_t v8 = [a1 count];
      uint64_t v9 = 32;
      uint64_t v10 = 16;
      uint64_t v11 = 4;
      if (v8 < 4 * v6) {
        uint64_t v11 = 1;
      }
      if (v8 < 16 * v6) {
        uint64_t v10 = v11;
      }
      if (v8 < 32 * v6) {
        uint64_t v9 = v10;
      }
      if (48 * v6 > v8) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 48;
      }
      if (v8 < v6 << 6) {
        unint64_t v13 = v12;
      }
      else {
        unint64_t v13 = 64;
      }
      size_t v14 = (v8 + v13 - 1) / v13;
      CFDataRef v15 = (void *)_CFAutoreleasePoolPush();
      uint64_t v16 = [a1 objectEnumerator];
      long long v31 = 0u;
      long long v32 = 0u;
      long long v30 = 0u;
      uint64_t v33 = 0;
      uint64_t v29 = 850045857;
      v22[0] = 0;
      v22[1] = v22;
      v22[2] = 0x2020000000;
      char v23 = 0;
      block[0] = off_1ECE0A5A0;
      block[1] = 3221225472;
      block[2] = ____NSSetEnumerate_block_invoke;
      block[3] = &unk_1ECDABD48;
      block[6] = v22;
      block[7] = v13;
      block[8] = &v29;
      block[4] = v16;
      block[5] = a3;
      dispatch_apply(v14, 0, block);
      _CFAutoreleasePoolPop(v15);
      _Block_object_dispose(v22, 8);
    }
    else
    {
      size_t v7 = (void *)_CFAutoreleasePoolPush();
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v29 = 0;
        *(void *)&long long v30 = &v29;
        *((void *)&v30 + 1) = 0x2020000000;
        LOBYTE(v31) = 0;
        v20[0] = off_1ECE0A5A0;
        v20[1] = 3221225472;
        v20[2] = ____NSSetEnumerate_block_invoke_2;
        v20[3] = &unk_1ECDABD70;
        v20[4] = a3;
        v20[5] = &v29;
        CFBasicHashApply((uint64_t)a1, (uint64_t)v20);
        _Block_object_dispose(&v29, 8);
      }
      else
      {
        LOBYTE(v29) = 0;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        uint64_t v17 = [a1 countByEnumeratingWithState:&v25 objects:v24 count:16];
        if (v17)
        {
          uint64_t v18 = *(void *)v26;
LABEL_24:
          uint64_t v19 = 0;
          while (1)
          {
            if (*(void *)v26 != v18) {
              objc_enumerationMutation(a1);
            }
            __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(a3);
            if ((_BYTE)v29) {
              break;
            }
            if (v17 == ++v19)
            {
              uint64_t v17 = [a1 countByEnumeratingWithState:&v25 objects:v24 count:16];
              if (v17) {
                goto LABEL_24;
              }
              break;
            }
          }
        }
      }
      _CFAutoreleasePoolPop(v7);
    }
  }
}

void sub_182C3C0E8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __CFStringReplaceableChar32At(uint64_t a1, signed int a2)
{
  if (*(void *)(a1 + 8) <= a2) {
    return 0xFFFFLL;
  }
  if (a2 < 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 176);
  if (v4 <= a2) {
    return 0;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = *(void *)(a1 + 152);
  if (v6)
  {
    unsigned __int16 v7 = *(_WORD *)(v6 + 2 * (*(void *)(a1 + 168) + a2));
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 160);
    if (v10)
    {
      unsigned __int16 v7 = *(char *)(v10 + *(void *)(a1 + 168) + a2);
    }
    else
    {
      if (*(void *)(a1 + 192) <= a2 || (uint64_t v11 = *(void *)(a1 + 184), v11 > a2))
      {
        uint64_t v12 = a2 - 4;
        if (a2 < 4) {
          uint64_t v12 = 0;
        }
        if (v12 + 64 < v4) {
          uint64_t v4 = v12 + 64;
        }
        *(void *)(a1 + 184) = v12;
        *(void *)(a1 + 192) = v4;
        v20.CFIndex location = *(void *)(a1 + 168) + v12;
        v20.size_t length = v4 - v12;
        CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v20, (UniChar *)(a1 + 16));
        uint64_t v11 = *(void *)(a1 + 184);
      }
      unsigned __int16 v7 = *(_WORD *)(v5 + 2 * (a2 - v11));
    }
  }
  if (v7 >> 10 != 54 || *(void *)(a1 + 8) - 1 <= a2) {
    return v7;
  }
  uint64_t v8 = v7;
  uint64_t v13 = a2 + 1;
  uint64_t v14 = *(void *)(a1 + 176);
  if (v14 > v13)
  {
    uint64_t v15 = *(void *)(a1 + 152);
    if (v15)
    {
      unsigned __int16 v16 = *(_WORD *)(v15 + 2 * (*(void *)(a1 + 168) + v13));
    }
    else
    {
      uint64_t v17 = *(void *)(a1 + 160);
      if (v17)
      {
        unsigned __int16 v16 = *(char *)(v17 + *(void *)(a1 + 168) + v13);
      }
      else
      {
        if (*(void *)(a1 + 192) <= v13 || (uint64_t v18 = *(void *)(a1 + 184), v18 > v13))
        {
          uint64_t v19 = a2 - 3;
          if (a2 < 3) {
            uint64_t v19 = 0;
          }
          if (v19 + 64 < v14) {
            uint64_t v14 = v19 + 64;
          }
          *(void *)(a1 + 184) = v19;
          *(void *)(a1 + 192) = v14;
          v21.CFIndex location = *(void *)(a1 + 168) + v19;
          v21.size_t length = v14 - v19;
          CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v21, (UniChar *)(a1 + 16));
          uint64_t v18 = *(void *)(a1 + 184);
        }
        unsigned __int16 v16 = *(_WORD *)(v5 + 2 * (v13 - v18));
      }
    }
    if (v16 >> 10 == 55) {
      return (v8 << 10) + v16 - 56613888;
    }
  }
  return v8;
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)_CFStreamCreateWithFile((__objc2_class **)alloc, fileURL, 1);
}

uint64_t _CFRunLoop01(uint64_t a1, const void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = CFSetContainsValue(*(CFSetRef *)(a1 + 608), a2);
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t __createDictionary(void *a1, uint64_t a2, uint64_t a3)
{
  v5[1] = *(void *)off_1ECE0A5B0;
  uint64_t v4 = a3;
  v5[0] = a2;
  return [a1 initWithObjects:v5 forKeys:&v4 count:1];
}

void sub_182C3CB6C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFTypeRef _CFRunLoopGet2(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  CFTypeRef v2 = *(CFTypeRef *)(a1 + 672);
  if (v2)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }
  else
  {
    Class v3 = objc_lookUpClass("NSRunLoop");
    if (v3 && (Class v4 = v3, (objc_opt_respondsToSelector() & 1) != 0))
    {
      uint64_t v5 = (const void *)[(objc_class *)v4 _new:a1];
      if (v5) {
        CFTypeRef v2 = CFRetain(v5);
      }
      else {
        CFTypeRef v2 = 0;
      }
      *(void *)(a1 + 672) = v2;
    }
    else
    {
      CFTypeRef v2 = *(CFTypeRef *)(a1 + 672);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    if (!v2) {
      _CFRunLoopGet2_cold_1();
    }
  }
  return v2;
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  usedBufLen[1] = *(void *)off_1ECE0A5B0;
  usedBufLen[0] = 0;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url))
  {
    CFStringRef v6 = CFURLGetString(url);
    CFStringEncoding v7 = 134217984;
  }
  else
  {
    CFStringRef v6 = (const __CFString *)atomic_load((unint64_t *)url + 3);
    CFStringEncoding v7 = *((_DWORD *)url + 5);
  }
  CFIndex Length = CFStringGetLength(v6);
  v11.CFIndex location = 0;
  v11.size_t length = Length;
  if (CFStringGetBytes(v6, v11, v7, 0, 0, buffer, bufferLength, usedBufLen) == Length) {
    return usedBufLen[0];
  }
  else {
    return -1;
  }
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, *(uint64_t *)&bytes.byte0, *(uint64_t *)&bytes.byte8, 0);
}

uint64_t _NSIsNSURL(uint64_t a1)
{
  if (_NSURLClass)
  {
    if (a1) {
      goto LABEL_3;
    }
    goto LABEL_9;
  }
  Class Class = objc_getClass("NSURL");
  _NSURLClass Class = (uint64_t)Class;
  if (!Class) {
    return Class & 1;
  }
  if (!a1)
  {
LABEL_9:
    LOBYTE(Class) = 0;
    return Class & 1;
  }
LABEL_3:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
    return Class & 1;
  }

  return MethodImplementation(a1, sel_isNSURL__);
}

void sub_182C3D348(_Unwind_Exception *a1)
{
  *(void *)(v2 - 168) = v1;
  free(*(void **)(v2 - 168));
  _Unwind_Resume(a1);
}

void sub_182C3DF8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsSandboxCheckForMessage(void *a1)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  size_t length = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    long long v3 = data[1];
    long long v7 = *data;
    long long v8 = v3;
  }
  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      xpc_object_t value = xpc_dictionary_get_value(a1, "connection");
      if (!value || object_getClass(value) != (Class)off_1ECE0A678) {
        _CFPrefsSandboxCheckForMessage_cold_1();
      }
    }
    xpc_connection_get_audit_token();
  }
  return sandbox_check_by_audit_token();
}

uint64_t _CFPrefsGetFixedUpDomainForMessage(void *a1, const void *a2, char a3, const char **a4)
{
  CFStringRef string = xpc_dictionary_get_string(a1, "CFPreferencesDomain");
  if (!string) {
    return 0;
  }
  uint64_t v9 = string;
  CFStringRef v10 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string, 0x8000100u);
  if (v10)
  {
    CFRange v11 = (__CFString *)v10;
    if (CFEqual(v10, @"kCFPreferencesAnyApplication")
      || CFEqual(@"Apple Global Domain", v11)
      || CFEqual(@".GlobalPreferences", v11))
    {
      CFRelease(v11);
      uint64_t v9 = "kCFPreferencesAnyApplication";
      xpc_dictionary_set_string(a1, "CFPreferencesDomain", "kCFPreferencesAnyApplication");
      CFRange v11 = @"kCFPreferencesAnyApplication";
    }
    if ((CFStringFind(v11, @"..", 0).location != -1 || CFStringGetCharacterAtIndex(v11, 0) == 47)
      && !xpc_dictionary_get_BOOL(a1, "CFPreferencesShouldWriteSynchronously"))
    {
      if (_CFPrefsIsAppleInternal_onceToken != -1) {
        dispatch_once(&_CFPrefsIsAppleInternal_onceToken, &__block_literal_global_182);
      }
      if (_CFPrefsIsAppleInternal_internal == 1)
      {
        uint64_t v12 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          _CFPrefsGetFixedUpDomainForMessage_cold_1((uint64_t)v9, v12);
        }
      }
    }
    if (CFEqual(v11, @"kCFPreferencesCurrentApplication")
      || a2 && CFEqual(a2, @"kCFPreferencesAnyUser") && (a3 & 1) == 0)
    {
      CFRelease(v11);
      uint64_t v9 = 0;
    }
    else if (v11)
    {
      uint64_t v13 = _CFPrefsDInternString(v11);
      CFRelease(v11);
      if (!a4) {
        return v13;
      }
      goto LABEL_18;
    }
  }
  uint64_t v13 = 0;
  if (a4) {
LABEL_18:
  }
    *a4 = v9;
  return v13;
}

const void *_CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded(void *a1)
{
  length[1] = *(void *)off_1ECE0A5B0;
  xpc_dictionary_set_value(a1, "CFPreferencesAuditToken", 0);
  length[0] = 0;
  uint64_t result = xpc_dictionary_get_data(a1, "CFPreferencesAuditTokenToImpersonate", length);
  if (result && length[0] == 32)
  {
    long long v3 = result;
    remote_connection = xpc_dictionary_get_remote_connection(a1);
    if (!remote_connection)
    {
      xpc_object_t value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
      if (!value || (remote_connection = value, object_getClass(value) != (Class)off_1ECE0A678)) {
        _CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_cold_1();
      }
    }
    v6[0] = off_1ECE0A5A0;
    v6[1] = 3221225472;
    void v6[2] = ___CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_block_invoke;
    v6[3] = &unk_1ECE00560;
    v6[4] = a1;
    v6[5] = v3;
    v6[6] = length[0];
    return (const void *)withClientContext(remote_connection, (uint64_t)v6);
  }
  return result;
}

CFStringRef _CFPrefsCopyFixedUpUserForMessage(void *a1, BOOL *a2, unsigned char *a3)
{
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    xpc_object_t value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    if (!value || (remote_connection = value, object_getClass(value) != (Class)off_1ECE0A678)) {
      _CFPrefsCopyFixedUpUserForMessage_cold_1();
    }
  }
  CFStringRef string = xpc_dictionary_get_string(a1, "CFPreferencesUser");
  uint64_t v9 = string;
  if (string)
  {
    if (strcmp(string, "mobile") || (CFStringRef string = (const char *)_CFPrefsCopyUsernameForMobileUser()) == 0) {
      CFStringRef string = (const char *)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, 0x8000100u);
    }
  }
  if (string) {
    CFStringRef v10 = (__CFString *)string;
  }
  else {
    CFStringRef v10 = @"kCFPreferencesAnyUser";
  }
  if (CFEqual(v10, @"kCFPreferencesCurrentUser"))
  {
    CFRelease(v10);
    uid_t euid = xpc_connection_get_euid(remote_connection);
    CFStringRef v10 = _CFPrefsCopyUserNameForUID(euid);
    char isRootOrRoleAccountUserName = euid < 0x1F5;
  }
  else
  {
    char isRootOrRoleAccountUserName = _isRootOrRoleAccountUserName(v10);
  }
  *a3 = isRootOrRoleAccountUserName;
  if (v10)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10);
    CFRelease(v10);
  }
  else
  {
    CFStringRef Copy = 0;
  }
  *a2 = v9 != 0;
  return Copy;
}

uint64_t _CFPrefsDaemonLog()
{
  if (makeLogHandles_logToken != -1) {
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_167);
  }
  return daemonHandle;
}

uint64_t _CFPrefsDecodeKeyValuePairFromXPCMessage(void *a1, void *a2, void *a3, int *a4)
{
  if (xpc_dictionary_get_BOOL(a1, "MultiKeySet"))
  {
    uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "Value");
    if (!result) {
      return result;
    }
    uint64_t v9 = (void *)result;
    xpc_object_t v10 = xpc_string_create("MultipleKeys");
    int v11 = 1;
    if (a2) {
      goto LABEL_4;
    }
LABEL_12:
    xpc_release(v10);
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "Key");
  if (!result) {
    return result;
  }
  xpc_object_t v10 = (xpc_object_t)result;
  xpc_retain((xpc_object_t)result);
  uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "Value");
  if (!result) {
    return result;
  }
  uint64_t v9 = (void *)result;
  int v11 = 0;
  if (!a2) {
    goto LABEL_12;
  }
LABEL_4:
  *a2 = v10;
  if (a3)
  {
LABEL_5:
    xpc_retain(v9);
    *a3 = v9;
  }
LABEL_6:
  if (a4) {
    *a4 = v11;
  }
  return 1;
}

void sub_182C3F88C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C3FF4C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void CFBagAddValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog(3, @"%s(): immutable collection %p given to mutating function", v2, v3, v4, v5, v6, v7, (__int16)"void CFBagAddValue(CFMutableBagRef, const void *)");
  }

  CFBasicHashAddValue((uint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

void sub_182C40C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeID CFSetGetTypeID(void)
{
  return 17;
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet removeAllObjects];
  }
  else
  {
    char v8 = atomic_load((unint64_t *)theSet + 1);
    if ((v8 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function", v2, v3, v4, v5, v6, v7, (__int16)"void CFSetRemoveAllValues(CFMutableSetRef)");
    }
    CFBasicHashRemoveAllValues((uint64_t)theSet);
  }
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    [(__CFDictionary *)theDict removeAllObjects];
  }
  else
  {
    char v8 = atomic_load((unint64_t *)theDict + 1);
    if ((v8 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function", v2, v3, v4, v5, v6, v7, (__int16)"void CFDictionaryRemoveAllValues(CFMutableDictionaryRef)");
    }
    char v9 = atomic_load((unint64_t *)theDict + 1);
    if (v9)
    {
      if (!__CF_KVO_WillChangeKeysSelector_hc) {
        __CF_KVO_WillChangeKeysSelector_hc = (uint64_t)sel_registerName("_willChangeValuesForKeys:");
      }
      CFIndex Count = CFDictionaryGetCount(theDict);
      uint64_t v12 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      CFDictionaryGetKeysAndValues(theDict, v12, 0);
      CFSetRef v10 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, Count, &kCFTypeSetCallBacks);
      free(v12);
      objc_msgSend(theDict, (SEL)__CF_KVO_WillChangeKeysSelector_hc, v10);
    }
    else
    {
      CFSetRef v10 = 0;
    }
    CFBasicHashRemoveAllValues((uint64_t)theDict);
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if (v13)
    {
      uint64_t v14 = (const char *)__CF_KVO_DidChangeKeysSelector_hc;
      if (!__CF_KVO_DidChangeKeysSelector_hc)
      {
        uint64_t v14 = sel_registerName("_didChangeValuesForKeys:");
        __CF_KVO_DidChangeKeysSelector_hc = (uint64_t)v14;
      }
      objc_msgSend(theDict, v14, v10);
      if (v10)
      {
        CFRelease(v10);
      }
    }
  }
}

void CFBasicHashRemoveAllValues(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 0x40) != 0)
  {
    __break(1u);
  }
  else if (*(unsigned char *)(a1 + 26))
  {
    __CFBasicHashDrain(a1);
  }
}

CFStringRef _CFPrefsCopyFixedUpContainerForMessage(void *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  CFStringRef string = xpc_dictionary_get_string(a1, "CFPreferencesContainer");
  bzero(buffer, 0x402uLL);
  CFURLRef value = (const __CFURL *)xpc_dictionary_get_value(a1, "CFPreferencesHostBundleIdentifier");
  CFDataRef v11 = _CFXPCCreateCFObjectFromXPCObject(value);
  BOOL v12 = xpc_dictionary_get_BOOL(a1, "CFPreferencesCurrentApplicationDomain");
  if (!a2) {
    _CFPrefsCopyFixedUpContainerForMessage_cold_1();
  }
  BOOL v13 = v12;
  if (!v12)
  {
    *(void *)&long long length = 0;
    *((void *)&length + 1) = &length;
    *(void *)&long long v37 = 0x2020000000;
    BYTE8(v37) = 0;
    remote_connection = xpc_dictionary_get_remote_connection(a1);
    if (!remote_connection)
    {
      uint64_t v15 = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
      remote_connection = v15;
      if (!v15 || object_getClass(v15) != (Class)off_1ECE0A678) {
        __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
      }
    }
    *(void *)&long long v27 = off_1ECE0A5A0;
    *((void *)&v27 + 1) = 3221225472;
    *(void *)&long long v28 = ___CFPrefsGetSuiteContainer_block_invoke;
    *((void *)&v28 + 1) = &unk_1ECE007D0;
    uint64_t v31 = a2;
    long long v32 = buffer;
    uint64_t v29 = a1;
    p_long long length = &length;
    BOOL v35 = v13;
    uint64_t v33 = 1026;
    CFDataRef v34 = v11;
    withClientContext(remote_connection, (uint64_t)&v27);
    int v16 = *(unsigned __int8 *)(*((void *)&length + 1) + 24);
    _Block_object_dispose(&length, 8);
    if (v16) {
      CFStringRef string = buffer;
    }
  }
  if (v11) {
    CFRelease(v11);
  }
  if (!string || !*string)
  {
    CFStringRef v17 = 0;
    if (!a4 || !a5) {
      return v17;
    }
    *(void *)&long long length = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    data = (long long *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", (size_t *)&length);
    if (data && (void)length == 32)
    {
      long long v19 = data[1];
      long long v27 = *data;
      long long v28 = v19;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        xpc_object_t v20 = xpc_dictionary_get_value(a1, "connection");
        if (!v20 || object_getClass(v20) != (Class)off_1ECE0A678) {
          _CFPrefsCopyFixedUpContainerForMessage_cold_2();
        }
      }
      xpc_connection_get_audit_token();
    }
    long long length = v27;
    long long v37 = v28;
    CFStringRef v17 = 0;
    if (sandbox_container_path_for_audit_token() || !buffer[0]) {
      return v17;
    }
    if (_CFPrefsSandboxCheckForMessage_0(a1) && _CFPrefsSandboxCheckForMessage_0(a1)) {
      return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
    }
    return 0;
  }
  if (!strncmp(string, "kCFPreferencesNoContainer", 0x19uLL)) {
    return 0;
  }
  getpid();
  if (sandbox_check()) {
    return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, string);
  }
  int v22 = open(string, 1074790400, string);
  int v23 = v22;
  if (v22 < 0)
  {
    uint64_t v24 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      _CFPrefsCopyFixedUpContainerForMessage_cold_3((uint64_t)string, v24);
    }
    return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, string);
  }
  if (fcntl(v22, 50, buffer) == -1) {
    CFStringRef v17 = 0;
  }
  else {
    CFStringRef v17 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
  }
  close(v23);
  return v17;
}

void sub_182C41538(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t _isRootOrRoleAccountUserName(const __CFString *a1)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (CFEqual(a1, @"root")) {
    return 1;
  }
  if (!CFStringGetLength(a1) || CFStringGetCharacterAtIndex(a1, 0) != 95) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 0;
  v10[0] = off_1ECE0A5A0;
  v10[1] = 3221225472;
  CFDataRef v11 = ___isRootOrRoleAccountUserName_block_invoke;
  BOOL v12 = &unk_1ECE007F8;
  BOOL v13 = &v14;
  if (CFStringGetCStringPtr(a1, 0x8000100u))
  {
    ((void (*)(void *))v11)(v10);
  }
  else
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    size_t v6 = MaximumSizeForEncoding + 1;
    if ((unint64_t)(MaximumSizeForEncoding + 1) < 0x101)
    {
      if (MaximumSizeForEncoding == -1)
      {
        uint64_t v7 = 0;
      }
      else
      {
        MEMORY[0x1F4188790](MaximumSizeForEncoding, v5);
        uint64_t v7 = (char *)v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v7, v6);
      }
    }
    else
    {
      uint64_t v7 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x100004077774924uLL);
    }
    bzero(v7, v6);
    if (CFStringGetCString(a1, v7, v6, 0x8000100u)) {
      char v8 = v7;
    }
    else {
      char v8 = 0;
    }
    v11((passwd *)v10, v8);
    if (v6 >= 0x101) {
      free(v7);
    }
  }
  BOOL v2 = *((unsigned char *)v15 + 24) != 0;
  _Block_object_dispose(&v14, 8);
  return v2;
}

void sub_182C41784(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 88), 8);
  _Unwind_Resume(a1);
}

void DEBUG_READ(void *a1, void *a2, uint64_t a3)
{
  v7[5] = *(void *)off_1ECE0A5B0;
  size_t v6 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = off_1ECE0A5A0;
    v7[1] = 3221225472;
    v7[2] = __DEBUG_READ_block_invoke;
    v7[3] = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
    v7[4] = a3;
    _extractCFPDBits(a1, 0, a2, (uint64_t)v7);
  }
}

void sub_182C42948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v10 - 104), 8);
  _Unwind_Resume(a1);
}

void sub_182C429A0(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x182C42998);
}

void sub_182C42F04(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  uint64_t length = range.length;
  CFIndex location = range.location;
  uint64_t v57 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    objc_opt_class();
    isKindOfClass Class = objc_opt_isKindOfClass();
  }
  else
  {
    char v10 = atomic_load((unint64_t *)theArray + 1);
    isKindOfClass Class = (v10 & 3) != 0;
  }
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_5;
  }
  unsigned int v15 = atomic_load((unint64_t *)theArray + 1);
  int v16 = (v15 >> 2) & 3;
  if (v16)
  {
    if (v16 == 1)
    {
LABEL_5:
      CFDataRef v11 = &kCFTypeArrayCallBacks;
      goto LABEL_6;
    }
    char v17 = atomic_load((unint64_t *)theArray + 1);
    int v18 = v17 & 3;
    if (v18 != 2 && v18) {
      CFDataRef v11 = 0;
    }
    else {
      CFDataRef v11 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
  }
  else
  {
    CFDataRef v11 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_6:
  if ((isKindOfClass & 1) == 0) {
    goto LABEL_9;
  }
  CFArrayRetainCallBack retain = v11->retain;
  CFArrayReleaseCallBack release = v11->release;
  if (retain)
  {
    if (release) {
      goto LABEL_9;
    }
  }
  else if (!release)
  {
LABEL_9:
    if (length >= 2)
    {
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      *(_OWORD *)values = 0u;
      long long v26 = 0u;
      if ((unint64_t)length >= 0x101) {
        uint64_t Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * length, 0x80040B8603338, 0);
      }
      else {
        uint64_t Typed = values;
      }
      v58.CFIndex location = location;
      v58.uint64_t length = length;
      CFArrayGetValues(theArray, v58, (const void **)Typed);
      v24[0] = comparator;
      v24[1] = context;
      CFQSortArray(Typed, length, 8, (uint64_t)__CFArrayCompareValues, (uint64_t)v24, v19, v20, v21);
      if (isKindOfClass)
      {
        v59.CFIndex location = location;
        v59.uint64_t length = length;
        CFArrayReplaceValues(theArray, v59, (const void **)Typed, length);
      }
      if (Typed != values) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      }
    }
    return;
  }
  if (length >= 2)
  {
    do
    {
      if (location < location - 1 + length)
      {
        uint64_t v22 = 0;
        do
        {
          if (((uint64_t (*)(uint64_t, uint64_t, void *))comparator)([(__CFArray *)theArray objectAtIndex:location + v22 + 1], [(__CFArray *)theArray objectAtIndex:location + v22], context) < 0)CFArrayExchangeValuesAtIndices(theArray, location + v22, location + v22 + 1); {
          ++v22;
          }
        }
        while (length - 1 != v22);
      }
    }
    while (length-- > 2);
  }
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    -[__CFArray replaceObjectsInRange:withObjects:count:](theArray, "replaceObjectsInRange:withObjects:count:", location, length, newValues, newCount);
  }
  else
  {
    _CFArrayReplaceValues((unint64_t)theArray, location, length, newValues, newCount);
  }
}

void CFQSortArray(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v42[8] = *(void *)off_1ECE0A5B0;
  if (a2 < 2 || a3 < 1) {
    return;
  }
  if ((unsigned __int128)(a2 * (__int128)a3) >> 64 != (a2 * a3) >> 63)
  {
    uint64_t v17 = CFLog(3, @"Unable to qsort array - count: %ld elementSize: %ld product overflows", a3, a4, a5, a6, a7, a8, a2);
    long long v39 = (void *)&unk_1EC093000;
    long long v40 = "qsort - count/elementSize overflow";
LABEL_23:
    v39[341] = v40;
    __break(1u);
    goto LABEL_24;
  }
  uint64_t v11 = a3 * a2;
  if (__CFADD__(a1, a3 * a2))
  {
    uint64_t v17 = CFLog(3, @"Unable to qsort array - list: %lu count: %ld elementSize: %ld - array access overflows", a3, a4, a5, a6, a7, a8, (__int16)a1);
    long long v39 = (void *)&unk_1EC093000;
    long long v40 = "qsort - array access overflow";
    goto LABEL_23;
  }
  MEMORY[0x1F4188790](a1, a2);
  unsigned int v15 = (char *)&v42[-1] - v14;
  int v16 = (char *)&v42[-1] - v14;
  if ((unint64_t)a2 > 0x1000)
  {
    uint64_t v17 = (uint64_t)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    int v16 = (char *)v17;
    if (!v17) {
LABEL_24:
    }
      CFQSortArray_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
  }
  v42[0] = off_1ECE0A5A0;
  v42[1] = 0x40000000;
  v42[2] = __CFQSortArray_block_invoke;
  v42[3] = &__block_descriptor_tmp_14;
  v42[4] = a4;
  v42[5] = a1;
  v42[6] = a3;
  v42[7] = a5;
  CFSortIndexes((uint64_t)v16, a2, 0, (uint64_t)v42);
  MEMORY[0x1F4188790](v25, v26);
  long long v34 = (char *)&v42[-1] - v33;
  long long v35 = (char *)&v42[-1] - v33;
  if (v36 < a2) {
    long long v35 = (char *)malloc_type_malloc(a3 * a2, 0x146070BuLL);
  }
  uint64_t v41 = (uint64_t)&v41;
  if (__CFADD__(v35, v11))
  {
    uint64_t v17 = CFLog(3, @"Unable to qsort array - list: %lu count: %ld elementSize: %ld array - store overflows", v27, v28, v29, v30, v31, v32, (__int16)a1);
    long long v39 = &unk_1EC093000;
    long long v40 = "qsort - array storage overflow";
    goto LABEL_23;
  }
  uint64_t v37 = 0;
  long long v38 = v35;
  do
  {
    if (a3 == 8) {
      *(void *)&v35[8 * v37] = a1[*(void *)&v16[8 * v37]];
    }
    else {
      memmove(v38, (char *)a1 + *(void *)&v16[8 * v37] * a3, a3);
    }
    ++v37;
    v38 += a3;
  }
  while (a2 != v37);
  memmove(a1, v35, a3 * a2);
  if (v34 != v35) {
    free(v35);
  }
  if (v15 != v16) {
    free(v16);
  }
}

CFTimeInterval CFDateGetTimeIntervalSinceDate(CFDateRef theDate, CFDateRef otherDate)
{
  [(__CFDate *)theDate timeIntervalSinceDate:otherDate];
  return result;
}

void __ResetUDateFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  int v4 = v3;
  uint64_t v5 = v2;
  v160[192] = *(void *)off_1ECE0A5B0;
  size_t v6 = (void *)MEMORY[0x185311AE0]();
  uint64_t v7 = *(void *)(v5 + 16);
  if (v7) {
    __cficu_udat_close(v7);
  }
  *(void *)(v5 + 16) = 0;
  v158[0] = 0;
  CFLocaleRef v8 = *(const __CFLocale **)(v5 + 24);
  if (v8) {
    CFStringRef Identifier = CFLocaleGetIdentifier(v8);
  }
  else {
    CFStringRef Identifier = &stru_1ECE10768;
  }
  CFStringGetCString(Identifier, v158, 768, 0x600u);
  v157[0] = 0;
  uint64_t v11 = (uint64_t *)(v5 + 88);
  CFTimeZoneRef v10 = *(const __CFTimeZone **)(v5 + 88);
  if (v10)
  {
    CFStringRef Name = CFTimeZoneGetName(v10);
    if (!Name)
    {
      BOOL v13 = _CFOSLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        __ResetUDateFormat_cold_1(v11, v13);
      }
      goto LABEL_233;
    }
  }
  else
  {
    CFStringRef Name = @"GMT";
  }
  if (CFStringGetLength(Name) <= 768) {
    CFIndex Length = CFStringGetLength(Name);
  }
  else {
    CFIndex Length = 768;
  }
  v161.CFIndex location = 0;
  v161.CFIndex length = Length;
  CFStringGetCharacters(Name, v161, v157);
  unint64_t v15 = *(void *)(v5 + 40);
  if (v15 > 3) {
    int v16 = 0;
  }
  else {
    int v16 = dword_182D9EC90[v15];
  }
  switch(*(void *)(v5 + 32))
  {
    case 0:
      int v17 = -1;
      int v18 = 1;
      break;
    case 1:
      int v18 = 0;
      int v17 = 3;
      break;
    case 2:
      int v18 = 0;
      int v17 = 2;
      break;
    case 3:
      int v18 = 0;
      int v17 = 1;
      break;
    default:
      int v18 = 0;
      int v17 = 0;
      break;
  }
  uint64_t v19 = *(__objc2_class ***)(v5 + 72);
  uint64_t v20 = *(__objc2_class ***)(v5 + 80);
  if (v19) {
    BOOL v21 = v19 == &__kCFBooleanTrue;
  }
  else {
    BOOL v21 = 0;
  }
  int v22 = !v21;
  if (v20) {
    BOOL v23 = v20 == &__kCFBooleanTrue;
  }
  else {
    BOOL v23 = 0;
  }
  if (!v23 && v4 == 0) {
    int v25 = v22;
  }
  else {
    int v25 = 1;
  }
  if (v15) {
    int v26 = v25;
  }
  else {
    int v26 = 1;
  }
  if (v26) {
    int v27 = v16;
  }
  else {
    int v27 = v16 | 0x80;
  }
  int v155 = 0;
  uint64_t v28 = __cficu_udat_open(v17, v27, (uint64_t)v158, v157, Length, 0, 0, &v155);
  if (v28) {
    BOOL v29 = v155 <= 0;
  }
  else {
    BOOL v29 = 0;
  }
  if (v29)
  {
    uint64_t v30 = v28;
    if ((v22 & 1) == 0) {
      __cficu_udat_setContext(v28, 259, &v155);
    }
    int v153 = v18;
    uint64_t v31 = *(__objc2_class ***)(v5 + 64);
    if (v31) {
      BOOL v32 = &__kCFBooleanTrue == v31;
    }
    else {
      BOOL v32 = 0;
    }
    int v33 = v32;
    __cficu_udat_setLenient(v30, v33);
    if (!*(void *)(v5 + 40) && !*(void *)(v5 + 32)) {
      __cficu_udat_applyPattern(v30, 0, 0, 0);
    }
    if (v22 && *(__objc2_class ***)(v5 + 80) == &__kCFBooleanTrue)
    {
      CFIndex v34 = CFStringGetLength(*(CFStringRef *)(v5 + 48));
      CFIndex v36 = v34;
      size_t v37 = 2 * v34;
      if ((unint64_t)(2 * v34) < 0x101)
      {
        if (v34 < 1)
        {
          long long v38 = 0;
        }
        else
        {
          MEMORY[0x1F4188790](v34, v35);
          long long v38 = &v152[-((v37 + 15) & 0xFFFFFFFFFFFFFFF0)];
          bzero(v38, v37);
        }
      }
      else
      {
        long long v38 = malloc_type_malloc(2 * v34, 0x1000040BDFB0063uLL);
      }
      CharactersPtr = (UChar *)CFStringGetCharactersPtr(*(CFStringRef *)(v5 + 48));
      if (!CharactersPtr)
      {
        v162.CFIndex location = 0;
        v162.CFIndex length = v36;
        CFStringGetCharacters(*(CFStringRef *)(v5 + 48), v162, (UniChar *)v38);
        CharactersPtr = (UChar *)v38;
      }
      __cficu_udat_applyPattern(v30, 0, CharactersPtr, v36);
      if (v37 >= 0x101) {
        free(v38);
      }
    }
    CFTypeRef Value = CFLocaleGetValue(*(CFLocaleRef *)(v5 + 24), @"calendar");
    if (Value && CFEqual(Value, @"gregorian"))
    {
      int v155 = 0;
      __cficu_udat_set2DigitYearStart(v30, &v155, -6.31152e11);
    }
    *(void *)(v5 + 16) = v30;
    CFDictionaryRef AppleICUDateTimeSymbolsPref = (const __CFDictionary *)_CFLocaleGetAppleICUDateTimeSymbolsPref(*(void **)(v5 + 24), v41);
    if (AppleICUDateTimeSymbolsPref)
    {
      CFDictionaryRef v44 = AppleICUDateTimeSymbolsPref;
      CFTypeID v45 = CFGetTypeID(AppleICUDateTimeSymbolsPref);
      if (v45 == CFDictionaryGetTypeID()) {
        CFDictionaryApplyFunction(v44, (CFDictionaryApplierFunction)__CFDateFormatterStoreSymbolPrefs, (void *)v5);
      }
    }
    AppleFirstWeekdayPref = (const void *)_CFLocaleGetAppleFirstWeekdayPref(*(void **)(v5 + 24), v43);
    if (AppleFirstWeekdayPref)
    {
      long long v48 = AppleFirstWeekdayPref;
      CFTypeID v49 = CFGetTypeID(AppleFirstWeekdayPref);
      if (v49 == CFDictionaryGetTypeID())
      {
        long long v50 = *(const void **)(v5 + 512);
        if (v50) {
          CFRelease(v50);
        }
        *(void *)(v5 + 512) = CFRetain(v48);
      }
    }
    AppleMinDaysInFirstWeekPref = (const void *)_CFLocaleGetAppleMinDaysInFirstWeekPref(*(void **)(v5 + 24), v47);
    if (AppleMinDaysInFirstWeekPref)
    {
      long long v53 = AppleMinDaysInFirstWeekPref;
      CFTypeID v54 = CFGetTypeID(AppleMinDaysInFirstWeekPref);
      if (v54 == CFDictionaryGetTypeID())
      {
        long long v55 = *(const void **)(v5 + 520);
        if (v55) {
          CFRelease(v55);
        }
        *(void *)(v5 + 520) = CFRetain(v53);
      }
    }
    AppleICUForce24HourTimePref = (const void *)_CFLocaleGetAppleICUForce24HourTimePref(*(void **)(v5 + 24), v52);
    if (AppleICUForce24HourTimePref)
    {
      CFRange v58 = AppleICUForce24HourTimePref;
      CFTypeID v59 = CFGetTypeID(AppleICUForce24HourTimePref);
      if (v59 == CFBooleanGetTypeID())
      {
        uint64_t v60 = *(const void **)(v5 + 480);
        if (v60) {
          CFRelease(v60);
        }
        *(void *)(v5 + 480) = CFRetain(v58);
      }
    }
    AppleICUForce12HourTimePref = (const void *)_CFLocaleGetAppleICUForce12HourTimePref(*(void **)(v5 + 24), v57);
    if (AppleICUForce12HourTimePref)
    {
      CFTypeRef v63 = AppleICUForce12HourTimePref;
      CFTypeID v64 = CFGetTypeID(AppleICUForce12HourTimePref);
      if (v64 == CFBooleanGetTypeID())
      {
        uint64_t v65 = *(const void **)(v5 + 488);
        if (v65) {
          CFRelease(v65);
        }
        *(void *)(v5 + 488) = CFRetain(v63);
      }
    }
    CFDictionaryRef AppleICUDateFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUDateFormatStringsPref(*(void **)(v5 + 24), v62);
    if (AppleICUDateFormatStringsPref)
    {
      CFDictionaryRef v68 = AppleICUDateFormatStringsPref;
      CFTypeID v69 = CFGetTypeID(AppleICUDateFormatStringsPref);
      if (v69 == CFDictionaryGetTypeID())
      {
        unint64_t v70 = *(void *)(v5 + 40) - 1;
        uint64_t v71 = v70 > 3 ? @"0" : off_1ECDABCF8[v70];
        long long v72 = CFDictionaryGetValue(v68, v71);
        if (v72)
        {
          long long v73 = v72;
          CFTypeID v74 = CFGetTypeID(v72);
          if (v74 == CFStringGetTypeID())
          {
            v75 = *(const void **)(v5 + 464);
            if (v75) {
              CFRelease(v75);
            }
            *(void *)(v5 + 464) = CFRetain(v73);
          }
        }
      }
    }
    CFDictionaryRef AppleICUTimeFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUTimeFormatStringsPref(*(void **)(v5 + 24), v67);
    if (AppleICUTimeFormatStringsPref)
    {
      CFDictionaryRef v77 = AppleICUTimeFormatStringsPref;
      CFTypeID v78 = CFGetTypeID(AppleICUTimeFormatStringsPref);
      if (v78 == CFDictionaryGetTypeID())
      {
        unint64_t v79 = *(void *)(v5 + 32) - 1;
        long long v80 = v79 > 3 ? @"0" : off_1ECDABCF8[v79];
        long long v81 = CFDictionaryGetValue(v77, v80);
        if (v81)
        {
          long long v82 = v81;
          CFTypeID v83 = CFGetTypeID(v81);
          if (v83 == CFStringGetTypeID())
          {
            long long v84 = *(const void **)(v5 + 472);
            if (v84) {
              CFRelease(v84);
            }
            *(void *)(v5 + 472) = CFRetain(v82);
          }
        }
      }
    }
    CFTypeRef v85 = *(CFTypeRef *)(v5 + 104);
    if (!v85) {
      CFTypeRef v85 = CFLocaleGetValue(*(CFLocaleRef *)(v5 + 24), @"calendar");
    }
    v159[0] = 0;
    uint64_t Calendar = __cficu_udat_getCalendar(*(void *)(v5 + 16));
    if (!*(void *)(v5 + 96) && !*(void *)(v5 + 104)
      || (CFStringRef v87 = CFLocaleGetIdentifier(*(CFLocaleRef *)(v5 + 24)),
          (Uuint64_t Calendar = __CFCalendarCreateUCalendar(0, v87, *(const __CFTimeZone **)(v5 + 88))) == 0))
    {
      Uuint64_t Calendar = __cficu_ucal_clone(Calendar, v159);
    }
    long long v89 = *(__objc2_class ***)(v5 + 64);
    if (v89)
    {
      v159[0] = 0;
      __cficu_ucal_setAttribute(UCalendar, 0, &__kCFBooleanTrue == v89);
    }
    CFTimeZoneRef v90 = (const __CFTimeZone *)*v11;
    v154 = v6;
    if (v90)
    {
      v159[0] = 0;
      CFStringRef v91 = CFTimeZoneGetName(v90);
      CFIndex v92 = CFStringGetLength(v91);
      if (v92 >= 768) {
        CFIndex v93 = 768;
      }
      else {
        CFIndex v93 = v92;
      }
      v163.CFIndex location = 0;
      v163.CFIndex length = v93;
      CFStringGetCharacters(v91, v163, (UniChar *)v160);
      __cficu_ucal_setTimeZone(UCalendar, (UChar *)v160, v93, v159);
    }
    CFDateRef v94 = *(const __CFDate **)(v5 + 128);
    if (v94)
    {
      v159[0] = 0;
      double v95 = CFDateGetAbsoluteTime(v94) + 978307200.0;
    }
    else
    {
      if (!v85 || !CFEqual(v85, @"gregorian"))
      {
LABEL_133:
        long long v96 = *(__CFCalendar **)(v5 + 96);
        if (v96)
        {
          int FirstWeekday = CFCalendarGetFirstWeekday(v96);
          uint64_t v98 = UCalendar;
        }
        else
        {
          CFDictionaryRef v106 = *(const __CFDictionary **)(v5 + 512);
          if (!v106
            || (CFNumberRef v107 = (const __CFNumber *)CFDictionaryGetValue(v106, v85)) == 0
            || (CFNumberRef v108 = v107, v109 = CFGetTypeID(v107), v109 != CFNumberGetTypeID())
            || (v160[0] = 0, !CFNumberGetValue(v108, kCFNumberCFIndexType, v160)))
          {
LABEL_136:
            long long v99 = *(__CFCalendar **)(v5 + 96);
            if (v99)
            {
              int MinimumDaysInFirstWeek = CFCalendarGetMinimumDaysInFirstWeek(v99);
              uint64_t v101 = UCalendar;
            }
            else
            {
              CFDictionaryRef v110 = *(const __CFDictionary **)(v5 + 520);
              if (!v110
                || (CFNumberRef v111 = (const __CFNumber *)CFDictionaryGetValue(v110, v85)) == 0
                || (CFNumberRef v112 = v111, v113 = CFGetTypeID(v111), v113 != CFNumberGetTypeID())
                || (v160[0] = 0, !CFNumberGetValue(v112, kCFNumberCFIndexType, v160)))
              {
LABEL_139:
                __cficu_udat_setCalendar(*(void *)(v5 + 16), UCalendar);
                __cficu_ucal_close(UCalendar);
                if (v25)
                {
                  __substituteFormatStringFromPrefsDF(v5, 0);
                  __substituteFormatStringFromPrefsDF(v5, 1);
                  __ApplyUDateFormatSymbol(v5);
                  size_t v6 = v154;
                }
                else
                {
                  size_t v6 = v154;
                  if (*(void *)(v5 + 40))
                  {
                    CFStringRef v102 = *(const __CFString **)(v5 + 464);
                    if (!v102
                      || (CFStringGetLength(v102) > 767
                        ? (uint64_t v103 = 768)
                        : (uint64_t v103 = CFStringGetLength(*(CFStringRef *)(v5 + 464))),
                          v164.CFIndex location = 0,
                          v164.CFIndex length = v103,
                          CFStringGetCharacters(*(CFStringRef *)(v5 + 464), v164, (UniChar *)v160),
                          v103 == -1))
                    {
                      v159[0] = 0;
                      int v114 = __cficu_udat_toPatternRelativeDate(*(void *)(v5 + 16), (const UniChar *)v160, 768, v159);
                      if (v159[0] > 0) {
                        int v115 = -1;
                      }
                      else {
                        int v115 = v114;
                      }
                      uint64_t v103 = v115;
                    }
                    if (!*(void *)(v5 + 32)
                      || (CFStringRef v116 = *(const __CFString **)(v5 + 472)) == 0
                      || (CFStringGetLength(v116) > 767
                        ? (uint64_t v117 = 768)
                        : (uint64_t v117 = CFStringGetLength(*(CFStringRef *)(v5 + 472))),
                          v165.CFIndex location = 0,
                          v165.CFIndex length = v117,
                          CFStringGetCharacters(*(CFStringRef *)(v5 + 472), v165, (UniChar *)v159),
                          v117 == -1))
                    {
                      v156[0] = 0;
                      int v118 = __cficu_udat_toPatternRelativeTime(*(void *)(v5 + 16), (const UniChar *)v159, 768, v156);
                      if (v156[0] > 0) {
                        int v119 = -1;
                      }
                      else {
                        int v119 = v118;
                      }
                      uint64_t v117 = v119;
                    }
                    v156[0] = 0;
                    __cficu_udat_applyPatternRelative(*(void *)(v5 + 16), (UChar *)((unint64_t)v160 & ~(v103 >> 63)), v103 & ~(v103 >> 63), (UChar *)((unint64_t)v159 & ~(v117 >> 63)), v117 & ~(v117 >> 63), v156);
                  }
                  else
                  {
                    __substituteFormatStringFromPrefsDF(v5, 0);
                    __substituteFormatStringFromPrefsDF(v5, 1);
                  }
                  __ApplyUDateFormatSymbol(v5);
                  if (*(void *)(v5 + 40))
                  {
                    int v155 = 0;
                    uint64_t v120 = __cficu_udat_toPatternRelativeDate(v30, (const UniChar *)v160, 768, &v155);
                    int v121 = 0;
                    if ((v153 & 1) == 0) {
                      int v121 = __cficu_udat_toPatternRelativeTime(v30, (const UniChar *)v159, 768, &v155);
                    }
                    if (v155 <= 0 && (int)v120 <= 768 && v121 <= 768)
                    {
                      CFStringRef v122 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UniChar *)v159, v121);
                      CFStringRef ForcedString = (const __CFString *)__CFDateFormatterCreateForcedString((void *)v5, v122);
                      uint64_t v124 = CFStringGetLength(ForcedString);
                      if (v124 <= 768)
                      {
                        uint64_t v125 = v124;
                        v166.CFIndex location = 0;
                        v166.CFIndex length = v124;
                        CFStringGetCharacters(ForcedString, v166, (UniChar *)v159);
                        int v155 = 0;
                        __cficu_udat_applyPatternRelative(v30, (UChar *)v160, v120, (UChar *)v159, v125, &v155);
                        int v155 = 0;
                        int v126 = __cficu_udat_toPattern(v30, 0, (const UniChar *)v156, 768, &v155);
                        if (v155 <= 0)
                        {
                          int v127 = v126;
                          if (v126 <= 768)
                          {
                            v128 = *(const void **)(v5 + 48);
                            if (v128) {
                              CFRelease(v128);
                            }
                            *(void *)(v5 + 48) = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UniChar *)v156, v127);
                          }
                        }
                      }
                      CFRelease(ForcedString);
                      CFRelease(v122);
                      size_t v6 = v154;
                    }
                    goto LABEL_207;
                  }
                }
                int v155 = 0;
                int v129 = __cficu_udat_toPattern(v30, 0, (const UniChar *)v160, 768, &v155);
                if (v155 <= 0 && v129 <= 768)
                {
                  CFStringRef v130 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UniChar *)v160, v129);
                  CFStringRef v131 = (const __CFString *)__CFDateFormatterCreateForcedString((void *)v5, v130);
                  CFIndex v132 = CFStringGetLength(v131);
                  if (v132 <= 1024)
                  {
                    CFIndex v134 = v132;
                    size_t v135 = 2 * v132;
                    if ((unint64_t)(2 * v132) < 0x101)
                    {
                      if (v132 < 1)
                      {
                        v136 = 0;
                      }
                      else
                      {
                        MEMORY[0x1F4188790](v132, v133);
                        v136 = &v152[-((v135 + 15) & 0xFFFFFFFFFFFFFFF0)];
                        bzero(v136, v135);
                      }
                    }
                    else
                    {
                      v136 = malloc_type_malloc(2 * v132, 0x1000040BDFB0063uLL);
                    }
                    v137 = (UChar *)CFStringGetCharactersPtr(v131);
                    if (!v137)
                    {
                      v167.CFIndex location = 0;
                      v167.CFIndex length = v134;
                      CFStringGetCharacters(v131, v167, (UniChar *)v136);
                      v137 = (UChar *)v136;
                    }
                    __cficu_udat_applyPattern(*(void *)(v5 + 16), 0, v137, v134);
                    v138 = *(const void **)(v5 + 48);
                    if (v138) {
                      CFRelease(v138);
                    }
                    CFAllocatorRef v139 = CFGetAllocator((CFTypeRef)v5);
                    *(void *)(v5 + 48) = CFStringCreateCopy(v139, v131);
                    if (v135 >= 0x101) {
                      free(v136);
                    }
                  }
                  CFRelease(v131);
                  CFRelease(v130);
                }
LABEL_207:
                v140 = *(const void **)(v5 + 56);
                if (v140) {
                  CFRelease(v140);
                }
                CFTypeRef v141 = *(CFTypeRef *)(v5 + 48);
                if (v141) {
                  CFTypeRef v141 = CFRetain(v141);
                }
                *(void *)(v5 + 56) = v141;
                CFArrayRef v142 = *(const __CFArray **)(v5 + 64);
                if (v142) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterIsLenientKey", v142);
                }
                CFArrayRef v143 = *(const __CFArray **)(v5 + 72);
                if (v143) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterDoesRelativeDateFormattingKey", v143);
                }
                CFArrayRef v144 = *(const __CFArray **)(v5 + 96);
                if (v144) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterCalendarKey", v144);
                }
                CFArrayRef v145 = *(const __CFArray **)(v5 + 104);
                if (v145) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterCalendarIdentifierKey", v145);
                }
                if (*v11) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterTimeZoneKey", (CFArrayRef)*v11);
                }
                CFArrayRef v146 = *(const __CFArray **)(v5 + 112);
                if (v146) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterTwoDigitStartDateKey", v146);
                }
                CFArrayRef v147 = *(const __CFArray **)(v5 + 120);
                if (v147) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterDefaultDateKey", v147);
                }
                CFArrayRef v148 = *(const __CFArray **)(v5 + 128);
                if (v148) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterGregorianStartDateKey", v148);
                }
                CFArrayRef v149 = *(const __CFArray **)(v5 + 296);
                if (v149) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterAmbiguousYearStrategyKey", v149);
                }
                CFArrayRef v150 = *(const __CFArray **)(v5 + 304);
                if (v150) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterUsesCharacterDirectionKey", v150);
                }
                CFArrayRef v151 = *(const __CFArray **)(v5 + 312);
                if (v151) {
                  __CFDateFormatterSetProperty(v5, @"kCFDateFormatterFormattingContextKey", v151);
                }
                goto LABEL_233;
              }
              v159[0] = 0;
              int MinimumDaysInFirstWeek = v160[0];
              uint64_t v101 = UCalendar;
            }
            __cficu_ucal_setAttribute(v101, 2u, MinimumDaysInFirstWeek);
            goto LABEL_139;
          }
          v159[0] = 0;
          int FirstWeekday = v160[0];
          uint64_t v98 = UCalendar;
        }
        __cficu_ucal_setAttribute(v98, 1u, FirstWeekday);
        goto LABEL_136;
      }
      v159[0] = 0;
      double v104 = __cficu_ucal_getGregorianChange(Calendar, v159);
      if (v159[0] <= 0) {
        double v105 = v104 / 1000.0 - 978307200.0;
      }
      else {
        double v105 = -1.31976e10;
      }
      double v95 = v105 + 978307200.0;
      v159[0] = 0;
    }
    __cficu_ucal_setGregorianChange(UCalendar, v159, v95 * 1000.0);
    goto LABEL_133;
  }
LABEL_233:
}

void __CFDateFormatterSetProperty(uint64_t a1, const __CFString *cf1, __CFString *theArray, int a4)
{
  uint64_t v50 = *(void *)off_1ECE0A5B0;
  int v49 = 0;
  if (@"kCFDateFormatterIsLenientKey" == cf1)
  {
    if (a4) {
      return;
    }
    CFArrayRef v8 = *(const __CFArray **)(a1 + 64);
    *(void *)(a1 + 64) = 0;
    if (theArray) {
      CFTypeRef v9 = CFRetain(theArray);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *(void *)(a1 + 64) = v9;
LABEL_59:
    __ResetUDateFormat(a1, 0);
    goto LABEL_60;
  }
  if (@"kCFDateFormatterDoesRelativeDateFormattingKey" == cf1)
  {
    if (a4) {
      return;
    }
    CFArrayRef v8 = *(const __CFArray **)(a1 + 72);
    *(void *)(a1 + 72) = 0;
    if (&__kCFBooleanTrue == (__objc2_class **)theArray) {
      CFTimeZoneRef v10 = (__objc2_class **)theArray;
    }
    else {
      CFTimeZoneRef v10 = &__kCFBooleanFalse;
    }
    if (v10) {
      CFTimeZoneRef v10 = (__objc2_class **)CFRetain(v10);
    }
    *(void *)(a1 + 72) = v10;
    goto LABEL_59;
  }
  if (@"kCFDateFormatterCalendarKey" == cf1)
  {
    if (a4)
    {
      CFArrayRef v8 = 0;
    }
    else
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 96);
      *(void *)(a1 + 96) = 0;
    }
    CFAllocatorRef v12 = CFGetAllocator(*(CFTypeRef *)(a1 + 24));
    BOOL v13 = *(void **)(a1 + 24);
    CFCalendarGetIdentifier((CFCalendarRef)theArray);
    CopyWithNewCalendarCFStringRef Identifier = _CFLocaleCreateCopyWithNewCalendarIdentifier((uint64_t)v12, v13);
    unint64_t v15 = *(const void **)(a1 + 24);
    if (v15) {
      CFRelease(v15);
    }
    *(void *)(a1 + 24) = CopyWithNewCalendarIdentifier;
    if (a4) {
      goto LABEL_60;
    }
    *(void *)(a1 + 96) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
    goto LABEL_59;
  }
  if (@"kCFDateFormatterCalendarIdentifierKey" == cf1)
  {
    if (a4)
    {
      CFArrayRef v8 = 0;
    }
    else
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 104);
      *(void *)(a1 + 104) = 0;
    }
    CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a1 + 24));
    ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, Identifier);
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, ComponentsFromLocaleIdentifier);
    CFDictionarySetValue(MutableCopy, @"calendar", theArray);
    CFStringRef LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(ComponentsFromLocaleIdentifier);
    CFAllocatorRef v20 = CFGetAllocator(*(CFTypeRef *)(a1 + 24));
    CFLocaleRef v21 = CFLocaleCreate(v20, LocaleIdentifierFromComponents);
    CFRelease(LocaleIdentifierFromComponents);
    CFRelease(*(CFTypeRef *)(a1 + 24));
    *(void *)(a1 + 24) = v21;
    if (a4) {
      goto LABEL_60;
    }
    *(void *)(a1 + 104) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
    goto LABEL_59;
  }
  if (@"kCFDateFormatterTimeZoneKey" == cf1)
  {
    CFArrayRef v8 = *(const __CFArray **)(a1 + 88);
    if (v8 == (const __CFArray *)theArray) {
      return;
    }
    if (a4)
    {
      uint64_t v11 = *(const void **)(a1 + 88);
      CFArrayRef v8 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      *(void *)(a1 + 88) = 0;
    }
    if (theArray) {
      uint64_t v24 = (void *)CFRetain(theArray);
    }
    else {
      uint64_t v24 = CFTimeZoneCopyDefault();
    }
    *(void *)(a1 + 88) = v24;
    if (v11) {
      CFRelease(v11);
    }
    if (!a4)
    {
      int v25 = *(const void **)(a1 + 88);
      *(void *)(a1 + 88) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
      __ResetUDateFormat(a1, 0);
      if (v25) {
        CFRelease(v25);
      }
    }
    goto LABEL_60;
  }
  if (@"kCFDateFormatterDefaultFormatKey" == cf1) {
    return;
  }
  if (@"kCFDateFormatterTwoDigitStartDateKey" == cf1)
  {
    if (a4) {
      return;
    }
    CFArrayRef v8 = *(const __CFArray **)(a1 + 112);
    *(void *)(a1 + 112) = 0;
    if (theArray) {
      CFTypeRef v22 = CFRetain(theArray);
    }
    else {
      CFTypeRef v22 = 0;
    }
    *(void *)(a1 + 112) = v22;
    goto LABEL_60;
  }
  if (@"kCFDateFormatterDefaultDateKey" == cf1)
  {
    if (a4) {
      return;
    }
    CFArrayRef v8 = *(const __CFArray **)(a1 + 120);
    *(void *)(a1 + 120) = 0;
    if (theArray) {
      CFTypeRef v23 = CFRetain(theArray);
    }
    else {
      CFTypeRef v23 = 0;
    }
    *(void *)(a1 + 120) = v23;
    goto LABEL_60;
  }
  if (@"kCFDateFormatterGregorianStartDateKey" == cf1)
  {
    if (a4) {
      return;
    }
    CFArrayRef v8 = *(const __CFArray **)(a1 + 128);
    *(void *)(a1 + 128) = 0;
    if (theArray) {
      CFTypeRef v26 = CFRetain(theArray);
    }
    else {
      CFTypeRef v26 = 0;
    }
    *(void *)(a1 + 128) = v26;
    goto LABEL_59;
  }
  if (@"kCFDateFormatterEraSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 136);
      *(void *)(a1 + 136) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 136) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 0;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterLongEraSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 144);
      *(void *)(a1 + 144) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 7u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 144) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 7u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 7;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 152);
      *(void *)(a1 + 152) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 1u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 152) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 1u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 1;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterShortMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 160);
      *(void *)(a1 + 160) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 2u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 160) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 2u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 2;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterVeryShortMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 168);
      *(void *)(a1 + 168) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 8u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 168) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 8u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 8;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterStandaloneMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 176);
      *(void *)(a1 + 176) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xAu, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 176) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xAu, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 10;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterShortStandaloneMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 184);
      *(void *)(a1 + 184) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xBu, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 184) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xBu, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 11;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterVeryShortStandaloneMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 192);
      *(void *)(a1 + 192) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xCu, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 192) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xCu, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 12;
    goto LABEL_111;
  }
  if (@"kCFDateFormatterWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 200);
      *(void *)(a1 + 200) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 3u, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 200) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 3u, 1u);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 3;
    goto LABEL_133;
  }
  if (@"kCFDateFormatterShortWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 208);
      *(void *)(a1 + 208) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 4u, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 208) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 4u, 1u);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 4;
    goto LABEL_133;
  }
  if (@"kCFDateFormatterVeryShortWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 216);
      *(void *)(a1 + 216) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 9u, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 216) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 9u, 1u);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 9;
    goto LABEL_133;
  }
  if (@"kCFDateFormatterStandaloneWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 224);
      *(void *)(a1 + 224) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xDu, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 224) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xDu, 1u);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 13;
    goto LABEL_133;
  }
  if (@"kCFDateFormatterShortStandaloneWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 232);
      *(void *)(a1 + 232) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xEu, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 232) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xEu, 1u);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 14;
    goto LABEL_133;
  }
  if (@"kCFDateFormatterVeryShortStandaloneWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 240);
      *(void *)(a1 + 240) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xFu, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 240) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xFu, 1u);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 15;
LABEL_133:
    int v29 = 1;
    goto LABEL_112;
  }
  if (@"kCFDateFormatterQuarterSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 248);
      *(void *)(a1 + 248) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x10u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 248) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x10u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 16;
  }
  else if (@"kCFDateFormatterShortQuarterSymbolsKey" == cf1)
  {
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 256);
      *(void *)(a1 + 256) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x11u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 256) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x11u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 17;
  }
  else
  {
    if (@"kCFDateFormatterStandaloneQuarterSymbolsKey" != cf1)
    {
      if (@"kCFDateFormatterShortStandaloneQuarterSymbolsKey" != cf1)
      {
        if (@"kCFDateFormatterAMSymbolKey" == cf1)
        {
          if (a4)
          {
            CFArrayRef v8 = 0;
          }
          else
          {
            CFArrayRef v8 = *(const __CFArray **)(a1 + 280);
            *(void *)(a1 + 280) = 0;
          }
          CFIndex Length = CFStringGetLength(theArray);
          uint64_t v32 = Length;
          if (Length >= 768) {
            CFIndex v33 = 768;
          }
          else {
            CFIndex v33 = Length;
          }
          MEMORY[0x1F4188790](Length, v31);
          uint64_t v35 = (UniChar *)((char *)&valuePtr - v34);
          CharactersPtr = CFStringGetCharactersPtr(theArray);
          if (CharactersPtr)
          {
            size_t v37 = (UChar *)CharactersPtr;
          }
          else
          {
            v52.CFIndex location = 0;
            v52.CFIndex length = v33;
            CFStringGetCharacters(theArray, v52, v35);
            size_t v37 = v35;
            uint64_t v32 = v33;
          }
          __cficu_udat_setSymbols(*(void *)(a1 + 16), 5u, 0, v37, v32, &v49);
          if (!a4)
          {
            CFStringRef Copy = 0;
            if (theArray) {
              CFStringRef Copy = CFStringCreateCopy(0, theArray);
            }
            *(void *)(a1 + 280) = Copy;
          }
        }
        else if (@"kCFDateFormatterPMSymbolKey" == cf1)
        {
          if (a4)
          {
            CFArrayRef v8 = 0;
          }
          else
          {
            CFArrayRef v8 = *(const __CFArray **)(a1 + 288);
            *(void *)(a1 + 288) = 0;
          }
          CFIndex v39 = CFStringGetLength(theArray);
          uint64_t v41 = v39;
          if (v39 >= 768) {
            CFIndex v42 = 768;
          }
          else {
            CFIndex v42 = v39;
          }
          MEMORY[0x1F4188790](v39, v40);
          CFDictionaryRef v44 = (UniChar *)((char *)&valuePtr - v43);
          CFTypeID v45 = CFStringGetCharactersPtr(theArray);
          if (v45)
          {
            long long v46 = (UChar *)v45;
          }
          else
          {
            v53.CFIndex location = 0;
            v53.CFIndex length = v42;
            CFStringGetCharacters(theArray, v53, v44);
            uint64_t v41 = v42;
            long long v46 = v44;
          }
          __cficu_udat_setSymbols(*(void *)(a1 + 16), 5u, 1, v46, v41, &v49);
          if (!a4)
          {
            CFStringRef v47 = 0;
            if (theArray) {
              CFStringRef v47 = CFStringCreateCopy(0, theArray);
            }
            *(void *)(a1 + 288) = v47;
          }
        }
        else if (@"kCFDateFormatterAmbiguousYearStrategyKey" == cf1)
        {
          CFArrayRef v8 = *(const __CFArray **)(a1 + 296);
          *(void *)(a1 + 296) = 0;
          *(void *)(a1 + 296) = CFRetain(theArray);
        }
        else if (@"kCFDateFormatterUsesCharacterDirectionKey" == cf1)
        {
          CFArrayRef v8 = *(const __CFArray **)(a1 + 304);
          *(void *)(a1 + 304) = CFRetain(theArray);
        }
        else
        {
          if (!CFEqual(cf1, @"kCFDateFormatterFormattingContextKey")) {
            return;
          }
          if (a4)
          {
            CFArrayRef v8 = 0;
          }
          else
          {
            CFArrayRef v8 = *(const __CFArray **)(a1 + 312);
            *(void *)(a1 + 312) = 0;
          }
          int valuePtr = 0;
          CFNumberGetValue((CFNumberRef)theArray, kCFNumberIntType, &valuePtr);
          __cficu_udat_setContext(*(void *)(a1 + 16), valuePtr, &v49);
          if (!a4) {
            *(void *)(a1 + 312) = CFRetain(theArray);
          }
        }
        goto LABEL_60;
      }
      if (a4)
      {
        uint64_t v27 = *(void *)(a1 + 16);
        unsigned int v28 = 19;
        goto LABEL_111;
      }
      CFArrayRef v8 = *(const __CFArray **)(a1 + 272);
      *(void *)(a1 + 272) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x13u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 272) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x13u, 0);
LABEL_60:
      if (v8) {
        CFRelease(v8);
      }
      return;
    }
    if (!a4)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 264);
      *(void *)(a1 + 264) = 0;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x12u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 264) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x12u, 0);
      goto LABEL_60;
    }
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 18;
  }
LABEL_111:
  int v29 = 0;
LABEL_112:

  __CFDateFormatterSetSymbolsArray(v27, v28, v29, (CFArrayRef)theArray);
}

CFTypeRef CFDateFormatterCopyProperty(CFDateFormatterRef formatter, CFDateFormatterKey key)
{
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v4);
  }
  int v26 = 0;
  if (@"kCFDateFormatterIsLenientKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 8);
    if (result) {
      goto LABEL_116;
    }
    int isLenient = __cficu_udat_isLenient(*((void *)formatter + 2));
    CFArrayRef v8 = (CFTypeRef *)&kCFBooleanTrue;
    if (!isLenient) {
      CFArrayRef v8 = (CFTypeRef *)&kCFBooleanFalse;
    }
LABEL_42:
    CFTypeRef result = *v8;
    goto LABEL_116;
  }
  if (@"kCFDateFormatterDoesRelativeDateFormattingKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 9);
    if (result) {
      goto LABEL_116;
    }
LABEL_41:
    CFArrayRef v8 = (CFTypeRef *)&kCFBooleanFalse;
    goto LABEL_42;
  }
  if (@"kCFDateFormatterCalendarKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 12);
    if (result) {
      goto LABEL_116;
    }
    CFLocaleRef v9 = (const __CFLocale *)*((void *)formatter + 3);
    CFTimeZoneRef v10 = (CFLocaleKey *)&kCFLocaleCalendarKey;
LABEL_47:
    CFTypeRef result = CFLocaleGetValue(v9, *v10);
    if (!result) {
      return result;
    }
    goto LABEL_116;
  }
  if (@"kCFDateFormatterCalendarIdentifierKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 13);
    if (result) {
      goto LABEL_116;
    }
    CFLocaleRef v9 = (const __CFLocale *)*((void *)formatter + 3);
    CFTimeZoneRef v10 = (CFLocaleKey *)&kCFLocaleCalendarIdentifierKey;
    goto LABEL_47;
  }
  if (@"kCFDateFormatterTimeZoneKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 11);
    if (!result) {
      return result;
    }
    goto LABEL_116;
  }
  if (@"kCFDateFormatterDefaultFormatKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 7);
    if (!result) {
      return result;
    }
    goto LABEL_116;
  }
  if (@"kCFDateFormatterTwoDigitStartDateKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 14);
    if (!result) {
      return result;
    }
    goto LABEL_116;
  }
  if (@"kCFDateFormatterDefaultDateKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 15);
    if (!result) {
      return result;
    }
    goto LABEL_116;
  }
  if (@"kCFDateFormatterGregorianStartDateKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 16);
    if (!result)
    {
      uint64_t Calendar = __cficu_udat_getCalendar(*((void *)formatter + 2));
      double v12 = __cficu_ucal_getGregorianChange(Calendar, &v26);
      if (v26 <= 0)
      {
        CFAbsoluteTime v15 = v12 / 1000.0 - 978307200.0;
        CFAllocatorRef v16 = CFGetAllocator(formatter);
        return CFDateCreate(v16, v15);
      }
      return 0;
    }
LABEL_116:
    return CFRetain(result);
  }
  if (@"kCFDateFormatterEraSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 17);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 0;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterLongEraSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 18);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 7;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 19);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 1;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterShortMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 20);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 2;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterVeryShortMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 21);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 8;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterStandaloneMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 22);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 10;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterShortStandaloneMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 23);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 11;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterVeryShortStandaloneMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 24);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 12;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 25);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 3;
    goto LABEL_95;
  }
  if (@"kCFDateFormatterShortWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 26);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 4;
    goto LABEL_95;
  }
  if (@"kCFDateFormatterVeryShortWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 27);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 9;
    goto LABEL_95;
  }
  if (@"kCFDateFormatterStandaloneWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 28);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 13;
    goto LABEL_95;
  }
  if (@"kCFDateFormatterShortStandaloneWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 29);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 14;
    goto LABEL_95;
  }
  if (@"kCFDateFormatterVeryShortStandaloneWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 30);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 15;
LABEL_95:
    unsigned int v17 = 1;
    goto LABEL_80;
  }
  if (@"kCFDateFormatterQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 31);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 16;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterShortQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 32);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 17;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterStandaloneQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 33);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 18;
    goto LABEL_79;
  }
  if (@"kCFDateFormatterShortStandaloneQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 34);
    if (result) {
      goto LABEL_116;
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 19;
LABEL_79:
    unsigned int v17 = 0;
LABEL_80:
    return __CFDateFormatterCopySymbolsArray(v13, v14, v17);
  }
  if (@"kCFDateFormatterAMSymbolKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 35);
    if (result) {
      goto LABEL_116;
    }
    int v18 = __cficu_udat_countSymbols(*((void *)formatter + 2), 5u);
    if (v18 < 2) {
      return 0;
    }
    unsigned int v19 = v18;
    uint64_t v20 = *((void *)formatter + 2);
    uint64_t v21 = 0;
  }
  else
  {
    if (@"kCFDateFormatterPMSymbolKey" != key)
    {
      if (@"kCFDateFormatterAmbiguousYearStrategyKey" == key)
      {
        CFTypeRef result = (CFTypeRef)*((void *)formatter + 37);
        if (!result) {
          return result;
        }
        goto LABEL_116;
      }
      if (@"kCFDateFormatterUsesCharacterDirectionKey" != key)
      {
        if (CFEqual(key, @"kCFDateFormatterFormattingContextKey"))
        {
          CFTypeRef result = (CFTypeRef)*((void *)formatter + 39);
          if (!result)
          {
            *(_DWORD *)int valuePtr = __cficu_udat_getContext(*((void *)formatter + 2), 1, &v26);
            CFAllocatorRef v6 = CFGetAllocator(formatter);
            return CFNumberCreate(v6, kCFNumberIntType, valuePtr);
          }
          goto LABEL_116;
        }
        return 0;
      }
      CFTypeRef result = (CFTypeRef)*((void *)formatter + 38);
      if (result) {
        goto LABEL_116;
      }
      goto LABEL_41;
    }
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 36);
    if (result) {
      goto LABEL_116;
    }
    int v22 = __cficu_udat_countSymbols(*((void *)formatter + 2), 5u);
    if (v22 < 2) {
      return 0;
    }
    unsigned int v19 = v22;
    uint64_t v20 = *((void *)formatter + 2);
    uint64_t v21 = 1;
  }
  int Symbols = __cficu_udat_getSymbols(v20, 5u, v21, valuePtr, 768, &v26);
  CFTypeRef result = 0;
  if (v19 <= 0x300 && v26 <= 0)
  {
    CFIndex v24 = Symbols;
    CFAllocatorRef v25 = CFGetAllocator(formatter);
    return CFStringCreateWithCharacters(v25, valuePtr, v24);
  }
  return result;
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  CFAllocatorRef v5 = allocator;
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      CFAllocatorRef v5 = (const __CFAllocator *)v6;
    }
    else {
      CFAllocatorRef v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  }
  int v18 = 0;
  double v8 = (at + 978307200.0) * 1000.0 + 0.5;
  int v9 = __cficu_udat_format(*((void *)formatter + 2), v20, 768, 0, &v18, v8);
  CFIndex v10 = v9;
  int v11 = v18;
  if (v18 == 15 || v9 >= 769)
  {
    uint64_t v13 = v9 + 2;
    uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v13, 0x1000040BDFB0063, 0);
    int v18 = 0;
    CFIndex v10 = (int)__cficu_udat_format(*((void *)formatter + 2), Typed + 1, v13, 0, &v18, v8);
    int v11 = v18;
  }
  else
  {
    uint64_t Typed = 0;
  }
  if (v11 <= 0)
  {
    if (Typed) {
      CFAllocatorRef v16 = Typed;
    }
    else {
      CFAllocatorRef v16 = (UniChar *)&v19;
    }
    if (*((__objc2_class ***)formatter + 38) == &__kCFBooleanTrue
      && (CFStringRef Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
          CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
    {
      UniChar *v16 = 8207;
      ++v10;
    }
    else if (Typed)
    {
      CFAllocatorRef v16 = Typed + 1;
    }
    else
    {
      CFAllocatorRef v16 = v20;
    }
    CFStringRef v14 = CFStringCreateWithCharacters(v5, v16, v10);
    if (Typed) {
      goto LABEL_12;
    }
  }
  else
  {
    CFStringRef v14 = 0;
    if (Typed) {
LABEL_12:
    }
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  return v14;
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)chars, 2 * numChars, 256, 2u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

uint64_t __cficu_udat_format(uint64_t a1, const UniChar *a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = udat_format();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a2, a3);
    CFStringRef v16 = ___CFICUCreateArgumentForDouble(a6);
    CFStringRef v17 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
    {
      CFStringRef v18 = CFStringCreateWithCharacters(0, a2, (int)v12);
      if (!a4) {
        goto LABEL_7;
      }
    }
    else
    {
      CFStringRef v18 = 0;
      if (!a4)
      {
LABEL_7:
        ___CFICULogWithArguments(1, @"udat_format(%@, %@, %@, %d, NULL, &%@); // %d %@ %@",
          v13,
          v16,
          v15,
          a3,
          v14,
          v12,
          v18,
          v17);
        ___CFICULogWithArguments(1, @"u_printf(\"%@: '%%S'\\n\", %@);", v15, v15);
        CFRelease(v13);
        CFRelease(v14);
        CFRelease(v15);
        CFRelease(v16);
        if (v18) {
          CFRelease(v18);
        }
        CFRelease(v17);
        return v12;
      }
    }
    ___CFICULogWithArguments(1, @"#warning non-NULL position ignored");
    goto LABEL_7;
  }
  return v12;
}

void __cficu_udat_applyPattern(uint64_t a1, int a2, UChar *a3, uint64_t a4)
{
  udat_applyPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v8 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"udat_applyPattern(%@, %d, %@, %d);", v9, a2, v8, a4);
    CFRelease(v8);
    CFRelease(v9);
  }
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)[(__CFLocale *)locale objectForKey:key];
}

uint64_t __cficu_udat_getSymbols(uint64_t a1, unsigned int a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t Symbols = udat_getSymbols();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a4, a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    if (*a6 <= 0) {
      CFStringRef v17 = CFStringCreateWithCharacters(0, a4, (int)Symbols);
    }
    else {
      CFStringRef v17 = 0;
    }
    CFStringRef v18 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, @"udat_getSymbols(%@, %s, %d, %@, %d, &%@); // %d %@ %@",
      v13,
      v18,
      a3,
      v15,
      a5,
      v14,
      Symbols,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    if (v17) {
      CFRelease(v17);
    }
    CFRelease(v16);
  }
  return Symbols;
}

uint64_t __cficu_udat_countSymbols(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = udat_countSymbols();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v6 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, CFSTR(""udat_countSymbols(%@, %s);
    CFRelease(v5);
  }
  return v4;
}

void __substituteFormatStringFromPrefsDF(uint64_t a1, int a2)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = 40;
  if (a2) {
    uint64_t v2 = 32;
  }
  unint64_t v3 = *(void *)(a1 + v2);
  uint64_t v4 = 464;
  if (a2) {
    uint64_t v4 = 472;
  }
  CFStringRef v5 = *(const __CFString **)(a1 + v4);
  if (v3) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v3 >= 5) {
      int v9 = -1;
    }
    else {
      int v9 = 4 - v3;
    }
    CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a1 + 24));
    CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr)
    {
      if (CFStringGetCString(Identifier, v29, 768, 0x600u)) {
        CStringPtr = v29;
      }
      else {
        CStringPtr = 0;
      }
    }
    int v27 = 0;
    if (a2) {
      int v12 = v9;
    }
    else {
      int v12 = -1;
    }
    if (a2) {
      int v13 = -1;
    }
    else {
      int v13 = v9;
    }
    uint64_t v14 = __cficu_udat_open(v12, v13, (uint64_t)CStringPtr, 0, 0, 0, 0, &v27);
    if (v14)
    {
      uint64_t v15 = v14;
      int v27 = 0;
      int v16 = __cficu_udat_toPattern(v14, 0, v28, 768, &v27);
      if (v27 <= 0 && v16 <= 768)
      {
        CFStringRef v17 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28, v16);
        int v27 = 0;
        int v18 = __cficu_udat_toPattern(*(void *)(a1 + 16), 0, v28, 768, &v27);
        if (v27 <= 0)
        {
          int v19 = v18;
          if (v18 <= 768)
          {
            CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
            CFStringAppendCharacters(Mutable, v28, v19);
            v26.CFIndex location = 0;
            v26.CFIndex length = 0;
            v32.CFIndex location = 0;
            v32.CFIndex length = v19;
            if (CFStringFindWithOptions(Mutable, v17, v32, 0, &v26))
            {
              CFStringReplace(Mutable, v26, v5);
              CFIndex Length = CFStringGetLength(Mutable);
              MEMORY[0x1F4188790](Length, v22);
              CFIndex v24 = (UniChar *)((char *)&v26 - ((v23 + 15) & 0x3FFFFFFF0));
              CharactersPtr = (UChar *)CFStringGetCharactersPtr(Mutable);
              if (!CharactersPtr)
              {
                v31.CFIndex length = (int)Length;
                v31.CFIndex location = 0;
                CFStringGetCharacters(Mutable, v31, v24);
                CharactersPtr = v24;
              }
              int v27 = 0;
              __cficu_udat_applyPattern(*(void *)(a1 + 16), 0, CharactersPtr, Length);
            }
            CFRelease(Mutable);
          }
        }
        CFRelease(v17);
      }
      __cficu_udat_close(v15);
    }
  }
}

void __cficu_ucal_setAttribute(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  ucal_setAttribute();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      unint64_t v7 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4) {
          CFStringRef v8 = "<unknown UCalendarAttribute>";
        }
        else {
          CFStringRef v8 = off_1ECDFE0C0[a2];
        }
        int v9 = 138412802;
        CFStringRef v10 = v6;
        __int16 v11 = 2080;
        int v12 = v8;
        __int16 v13 = 1024;
        int v14 = a3;
        _os_log_debug_impl(&dword_182B90000, v7, OS_LOG_TYPE_DEBUG, "ucal_setAttribute(%@, %s, %d);",
          (uint8_t *)&v9,
          0x1Cu);
      }
      CFRelease(v6);
    }
  }
}

CFTypeRef __CFDateFormatterCreateForcedString(void *a1, const __CFString *a2)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  if (!a2) {
    return 0;
  }
  CFBooleanRef v4 = (const __CFBoolean *)a1[61];
  if (v4) {
    int v5 = (CFBooleanGetValue(v4) != 0) << 29;
  }
  else {
    int v5 = 0;
  }
  CFBooleanRef v7 = (const __CFBoolean *)a1[60];
  if (v7 && CFBooleanGetValue(v7))
  {
    int v5 = 0x40000000;
LABEL_10:
    if (__CFDateFormatterCreateForcedString_onceToken != -1) {
      dispatch_once(&__CFDateFormatterCreateForcedString_onceToken, &__block_literal_global_36);
    }
    CFRange result = (CFRange)xmmword_182D9EC80;
    CFCharacterSetRef v8 = (const __CFCharacterSet *)__CFDateFormatterCreateForcedString_hourCharacters;
    v25.CFIndex length = CFStringGetLength(a2);
    v25.CFIndex location = 0;
    if (CFStringFindCharacterFromSet(a2, v8, v25, 0, &result) && result.location != -1)
    {
      uint64_t v18 = 0;
      int v19 = &v18;
      uint64_t v20 = 0x2020000000;
      uint64_t v21 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = (int *)&v14;
      uint64_t v16 = 0x2020000000;
      int v17 = 0;
      CFLocaleRef v9 = (const __CFLocale *)a1[3];
      v12[0] = off_1ECE0A5A0;
      v12[1] = 3221225472;
      v12[2] = ____CFDateFormatterCreateForcedString_block_invoke_2;
      v12[3] = &unk_1ECDABCD8;
      v12[5] = &v18;
      v12[6] = a2;
      int v13 = v5;
      v12[4] = &v14;
      int v10 = useTemplatePatternGenerator(v9, (uint64_t)v12);
      CFTypeRef v6 = (CFTypeRef)v19[3];
      if (v10)
      {
        if (v6)
        {
          if (v15[6] > 0)
          {
LABEL_25:
            _Block_object_dispose(&v14, 8);
            _Block_object_dispose(&v18, 8);
            return v6;
          }
          goto LABEL_23;
        }
      }
      else if (v6)
      {
LABEL_23:
        CFRelease((CFTypeRef)v19[3]);
      }
      CFTypeRef v6 = CFRetain(a2);
      goto LABEL_25;
    }
    return CFRetain(a2);
  }
  if (v5) {
    goto LABEL_10;
  }

  return CFRetain(a2);
}

void sub_182C4776C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __cficu_udat_getCalendar(uint64_t a1)
{
  uint64_t Calendar = udat_getCalendar();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    unint64_t v3 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", Calendar);
    CFStringRef v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"const UCalendar *%@ = udat_getCalendar(%@);", v3, v4);
    CFRelease(v4);
    CFRelease(v3);
  }
  return Calendar;
}

void __cficu_ucal_close(uint64_t a1)
{
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      ___CFICURemoveVariableNameForHeapPointer(a1);
    }
    else
    {
      CFStringRef v2 = 0;
    }
    ucal_close();
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled != 1) {
      goto LABEL_18;
    }
    if (_NSCFCalendarLogger_onceToken != -1) {
      dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
    }
    unint64_t v3 = _NSCFCalendarLogger__logger;
    if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
    {
      __cficu_ucal_close_cold_1((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
      if (!v2) {
        return;
      }
    }
    else
    {
LABEL_18:
      if (!v2) {
        return;
      }
    }
    CFRelease(v2);
  }
  else
  {
    ucal_close();
  }
}

void __cficu_udat_set2DigitYearStart(uint64_t a1, int *a2, double a3)
{
  udat_set2DigitYearStart();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v8 = ___CFICUCreateArgumentForDouble(a3);
    CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"udat_set2DigitYearStart(%@, %@, &%@); %@", v6, v8, v7, v9);
    CFRelease(v7);
    CFRelease(v6);
    CFRelease(v8);
    CFRelease(v9);
  }
}

void __CFDateFormatterCreateDateFormatFromTemplate_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v61 = v3;
  uint64_t v4 = v2;
  uint64_t v69 = *(void *)off_1ECE0A5B0;
  if (*(unsigned char *)(v2 + 72))
  {
    CFIndex Count = 1;
LABEL_4:
    CFIndex v5 = 0;
    uint64_t v62 = v4;
    while (1)
    {
      CFArrayRef ValueAtIndex = *(const __CFArray **)(v4 + 40);
      CFIndex v64 = v5;
      if (!*(unsigned char *)(v4 + 72)) {
        CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v5);
      }
      CFRange v8 = CFStringFind((CFStringRef)ValueAtIndex, @"J", 0);
      CFIndex length = (const char *)v8.length;
      CFLocaleRef System = *(CFLocaleRef *)(v4 + 48);
      if (System)
      {
        if (!ValueAtIndex) {
          goto LABEL_15;
        }
      }
      else
      {
        CFLocaleRef System = CFLocaleGetSystem();
        if (!ValueAtIndex)
        {
LABEL_15:
          CFMutableStringRef Mutable = 0;
          goto LABEL_75;
        }
      }
      uint64_t v10 = *(void *)(v62 + 56);
      if (v10)
      {
        int Value = 1;
        if ((v10 & 2) == 0) {
          goto LABEL_17;
        }
      }
      else
      {
        CFBooleanRef AppleICUForce24HourTimePref = (const __CFBoolean *)_CFLocaleGetAppleICUForce24HourTimePref(System, length);
        if (AppleICUForce24HourTimePref
          && (CFBooleanRef v12 = AppleICUForce24HourTimePref,
              CFTypeID v13 = CFGetTypeID(AppleICUForce24HourTimePref),
              v13 == CFBooleanGetTypeID()))
        {
          int Value = CFBooleanGetValue(v12);
          if ((v10 & 2) == 0) {
            goto LABEL_17;
          }
        }
        else
        {
          int Value = 0;
          if ((v10 & 2) == 0)
          {
LABEL_17:
            CFBooleanRef AppleICUForce12HourTimePref = (const __CFBoolean *)_CFLocaleGetAppleICUForce12HourTimePref(System, length);
            BOOL v19 = AppleICUForce12HourTimePref
               && (CFBooleanRef v17 = AppleICUForce12HourTimePref,
                   CFTypeID v18 = CFGetTypeID(AppleICUForce12HourTimePref),
                   v18 == CFBooleanGetTypeID())
               && CFBooleanGetValue(v17) != 0;
            BOOL v63 = Value != 0;
            if (Value) {
              BOOL v20 = 0;
            }
            else {
              BOOL v20 = v19;
            }
            BOOL v60 = v20;
            if (!Value && !v19)
            {
              CFMutableStringRef Mutable = (__CFString *)CFRetain(ValueAtIndex);
              goto LABEL_75;
            }
            goto LABEL_29;
          }
        }
      }
      BOOL v63 = Value != 0;
      BOOL v60 = Value == 0;
LABEL_29:
      CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
      CFIndex v21 = CFStringGetLength((CFStringRef)ValueAtIndex);
      if (v21 >= 1)
      {
        CFIndex v22 = v21;
        CFIndex v23 = 0;
        BOOL v24 = 0;
        int v58 = Value | (v8.location != -1);
        CFIndex v25 = -1;
        while (1)
        {
          chars[0] = 0;
          int CharacterAtIndex = CFStringGetCharacterAtIndex((CFStringRef)ValueAtIndex, v23);
          chars[0] = CharacterAtIndex;
          if (CharacterAtIndex > 74) {
            break;
          }
          switch(CharacterAtIndex)
          {
            case '\'':
              BOOL v24 = !v24;
              break;
            case 'H':
              if (v24) {
                goto LABEL_67;
              }
              if (v25 == -1) {
                CFIndex v25 = CFStringGetLength(Mutable);
              }
              if (v60) {
                goto LABEL_54;
              }
              goto LABEL_72;
            case 'J':
LABEL_39:
              if (!v24)
              {
                if (v25 == -1) {
                  CFIndex v25 = CFStringGetLength(Mutable);
                }
                if (v63)
                {
LABEL_59:
                  BOOL v24 = 0;
                  UniChar v28 = 72;
                }
                else
                {
LABEL_54:
                  BOOL v24 = 0;
                  UniChar v28 = 104;
                }
LABEL_60:
                chars[0] = v28;
                break;
              }
LABEL_67:
              BOOL v24 = 1;
              break;
          }
LABEL_73:
          CFStringAppendCharacters(Mutable, chars, 1);
LABEL_74:
          if (v22 == ++v23) {
            goto LABEL_75;
          }
        }
        switch(CharacterAtIndex)
        {
          case 'h':
            if (v24) {
              goto LABEL_67;
            }
            if (v25 == -1) {
              CFIndex v25 = CFStringGetLength(Mutable);
            }
            if (v63) {
              goto LABEL_59;
            }
            break;
          case 'i':
          case 'l':
          case 'n':
          case 'o':
          case 'p':
          case 'q':
          case 'r':
            goto LABEL_73;
          case 'j':
            goto LABEL_39;
          case 'k':
            if (v24) {
              goto LABEL_67;
            }
            if (v25 == -1) {
              CFIndex v25 = CFStringGetLength(Mutable);
            }
            if (!v60) {
              break;
            }
            BOOL v24 = 0;
            UniChar v28 = 75;
            goto LABEL_60;
          case 'm':
          case 's':
            if (v24) {
              goto LABEL_67;
            }
            CFStringGetLength(Mutable);
            break;
          default:
            if (CharacterAtIndex != 75)
            {
              if (CharacterAtIndex == 97)
              {
                BOOL v27 = v24;
                BOOL v24 = v24;
                if (!v27)
                {
                  if (v58)
                  {
                    BOOL v24 = 0;
                    goto LABEL_74;
                  }
                }
              }
              goto LABEL_73;
            }
            if (v24) {
              goto LABEL_67;
            }
            if (v25 == -1) {
              CFIndex v25 = CFStringGetLength(Mutable);
            }
            if (v63)
            {
              BOOL v24 = 0;
              UniChar v28 = 107;
              goto LABEL_60;
            }
            break;
        }
LABEL_72:
        BOOL v24 = 0;
        goto LABEL_73;
      }
LABEL_75:
      CFIndex location = CFStringFind(Mutable, @"j", 1uLL).location;
      if (location == -1)
      {
        int v30 = 0;
        uint64_t v31 = 0;
      }
      else
      {
        CFStringGetCharacterAtIndex(Mutable, location);
        if (location + 1 < CFStringGetLength(Mutable)
          && (CFStringGetCharacterAtIndex(Mutable, location + 1) == 106
           || CFStringGetCharacterAtIndex(Mutable, location + 1) == 74))
        {
          CFStringGetCharacterAtIndex(Mutable, location + 1);
          int v30 = 1;
          uint64_t v31 = 2;
        }
        else
        {
          int v30 = 0;
          uint64_t v31 = 1;
        }
      }
      bzero(chars, 0x600uLL);
      bzero(v67, 0x600uLL);
      bzero(v66, 0x600uLL);
      CFIndex v32 = CFStringGetLength(Mutable);
      if (v32 >= 768) {
        CFIndex v33 = 768;
      }
      else {
        CFIndex v33 = v32;
      }
      v70.CFIndex location = 0;
      v70.CFIndex length = v33;
      CFStringGetCharacters(Mutable, v70, chars);
      CFRelease(Mutable);
      int v65 = 0;
      uint64_t Skeleton = __cficu_udatpg_getSkeleton(v61, chars, v33, v67, 768, &v65);
      CFStringRef v35 = 0;
      if (v65 <= 0)
      {
        if (location == -1)
        {
          uint64_t v36 = Skeleton;
        }
        else
        {
          uint64_t v36 = Skeleton;
          if ((unint64_t)(v31 + (int)Skeleton) <= 0x2FF)
          {
            uint64_t v36 = (int)Skeleton + 1;
            v67[(int)Skeleton] = 106;
            if (v30)
            {
              v67[v36] = 106;
              uint64_t v36 = (Skeleton + 2);
            }
          }
        }
        int v65 = 0;
        int BestPattern = __cficu_udatpg_getBestPattern(v61, v67, v36, v66, 768, &v65);
        if (v65 <= 0)
        {
          int v38 = BestPattern;
          if (v8.location != -1)
          {
            CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
            if (v38 >= 1)
            {
              CFCharacterSetRef v40 = Predefined;
              for (uint64_t i = 0; i < v38; ++i)
              {
                unsigned int v42 = v66[i] - 66;
                BOOL v43 = v42 > 0x20;
                uint64_t v44 = (1 << v42) & 0x180000003;
                if (!v43 && v44 != 0)
                {
                  uint64_t v46 = i - 1;
                  do
                  {
                    uint64_t v47 = v46;
                    uint64_t v48 = i - 1;
                    int IsCharacterMember = CFCharacterSetIsCharacterMember(v40, v66[i - 1]);
                    uint64_t v46 = v47 - 1;
                    --i;
                  }
                  while (IsCharacterMember);
                  uint64_t i = v48 + 1;
                  while (1)
                  {
                    int v50 = v66[v48 + 1];
                    BOOL v51 = (v50 - 66) > 0x20 || ((1 << (v50 - 66)) & 0x180000003) == 0;
                    if (v51 && !CFCharacterSetIsCharacterMember(v40, v50)) {
                      break;
                    }
                    if (v38 >= 767) {
                      int v52 = 767;
                    }
                    else {
                      int v52 = v38;
                    }
                    if (i < v52)
                    {
                      uint64_t v53 = v47;
                      do
                      {
                        v66[v53 + 1] = v66[v53 + 2];
                        uint64_t v54 = v53 + 2;
                        ++v53;
                      }
                      while (v54 < v52);
                    }
                    --v38;
                  }
                }
              }
            }
          }
          CFStringRef v35 = CFStringCreateWithCharacters(*(CFAllocatorRef *)(v62 + 64), v66, v38);
        }
        else
        {
          CFStringRef v35 = 0;
        }
      }
      uint64_t v4 = v62;
      uint64_t v55 = *(void *)(*(void *)(v62 + 32) + 8);
      if (*(unsigned char *)(v62 + 72))
      {
        *(void *)(v55 + 24) = v35;
        CFIndex v56 = v64;
      }
      else
      {
        if (v35) {
          uint64_t v57 = (__objc2_class **)v35;
        }
        else {
          uint64_t v57 = &__kCFNull;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v55 + 24), v57);
        CFIndex v56 = v64;
        if (v35) {
          CFRelease(v35);
        }
      }
      CFIndex v5 = v56 + 1;
      if (v5 == Count) {
        return;
      }
    }
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 40));
  if (Count >= 1) {
    goto LABEL_4;
  }
}

uint64_t _CFLocaleGetAppleICUForce12HourTimePref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUForce12HourTime"];
}

uint64_t _CFLocaleGetAppleICUForce24HourTimePref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUForce24HourTime"];
}

uint64_t __cficu_udatpg_getSkeleton(uint64_t a1, UChar *a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t Skeleton = udatpg_getSkeleton();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    uint64_t v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"skeleton", (uint64_t)a4, a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    if (*a6 <= 0) {
      CFStringRef v18 = CFStringCreateWithCharacters(0, a4, (int)Skeleton);
    }
    else {
      CFStringRef v18 = 0;
    }
    ___CFICULogWithArguments(1, @"udatpg_getSkeleton(%@, %@, %d, %@, %d, &%@); // %d %@ %@",
      v13,
      v17,
      a3,
      v15,
      a5,
      v14,
      Skeleton,
      v18,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v17);
    if (v18) {
      CFRelease(v18);
    }
    CFRelease(v16);
  }
  return Skeleton;
}

uint64_t __cficu_udatpg_getBestPattern(uint64_t a1, UChar *a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t BestPattern = udatpg_getBestPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    uint64_t v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"pattern", (uint64_t)a4, a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    if (*a6 <= 0) {
      CFStringRef v18 = CFStringCreateWithCharacters(0, a4, (int)BestPattern);
    }
    else {
      CFStringRef v18 = 0;
    }
    ___CFICULogWithArguments(1, @"udatpg_getBestPattern(%@, %@, %d, %@, %d, &%@); // %d %@ %@",
      v13,
      v17,
      a3,
      v15,
      a5,
      v14,
      BestPattern,
      v18,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    if (v18) {
      CFRelease(v18);
    }
    CFRelease(v17);
    CFRelease(v16);
  }
  return BestPattern;
}

void __cficu_udat_setCalendar(uint64_t a1, uint64_t a2)
{
  udat_setCalendar();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a2);
    ___CFICULogWithArguments(1, @"udat_setCalendar(%@, %@);", v4, v5);
    CFRelease(v4);
    CFRelease(v5);
  }
}

uint64_t __cficu_udat_toPattern(uint64_t a1, int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t v10 = udat_toPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFBooleanRef v12 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v13 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"pattern", (uint64_t)a3, a4);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    CFStringRef v15 = v14;
    if (*a5 < 1)
    {
      CFStringRef v16 = CFStringCreateWithCharacters(0, a3, (int)v10);
      ___CFICULogWithArguments(1, @"udat_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@",
        v11,
        a2,
        v13,
        a4,
        v12,
        v10,
        v16,
        v15);
      if (v16) {
        CFRelease(v16);
      }
    }
    else
    {
      ___CFICULogWithArguments(1, @"udat_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@",
        v11,
        a2,
        v13,
        a4,
        v12,
        v10,
        0,
        v14);
    }
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v15);
  }
  return v10;
}

void __cficu_ucal_setGregorianChange(uint64_t a1, int *a2, double a3)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  ucal_setGregorianChange();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateArgumentForDouble(a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      uint64_t v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v8;
        __int16 v15 = 2112;
        CFStringRef v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v9;
        _os_log_debug_impl(&dword_182B90000, v10, OS_LOG_TYPE_DEBUG, "ucal_setGregorianChange(%@, %@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
}

double __cficu_ucal_getGregorianChange(uint64_t a1, int *a2)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  ucal_getGregorianChange();
  double v5 = v4;
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v9 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v7;
        __int16 v15 = 2048;
        double v16 = v5;
        __int16 v17 = 2112;
        CFStringRef v18 = v8;
        _os_log_debug_impl(&dword_182B90000, v9, OS_LOG_TYPE_DEBUG, "ucal_getGregorianChange(%@, &%@); // %f %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }
  return v5;
}

void __ApplyUDateFormatSymbol(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  uint64_t v37 = 0;
  *(void *)&long long v3 = 0x100000001;
  *((void *)&v3 + 1) = 0x100000001;
  long long v35 = v3;
  long long v36 = 0u;
  *(void *)&long long v36 = 0x100000001;
  long long v4 = *(_OWORD *)(a1 + 152);
  v33[0] = *(_OWORD *)(a1 + 136);
  v33[1] = v4;
  long long v5 = *(_OWORD *)(a1 + 184);
  v33[2] = *(_OWORD *)(a1 + 168);
  v33[3] = v5;
  long long v6 = *(_OWORD *)(a1 + 216);
  v33[4] = *(_OWORD *)(a1 + 200);
  v33[5] = v6;
  long long v7 = *(_OWORD *)(a1 + 248);
  v33[6] = *(_OWORD *)(a1 + 232);
  v33[7] = v7;
  v33[8] = *(_OWORD *)(a1 + 264);
  memset(v34, 0, sizeof(v34));
  long long v8 = *(_OWORD *)(a1 + 336);
  v32[0] = *(_OWORD *)(a1 + 320);
  v32[1] = v8;
  long long v9 = *(_OWORD *)(a1 + 368);
  v32[2] = *(_OWORD *)(a1 + 352);
  v32[3] = v9;
  long long v10 = *(_OWORD *)(a1 + 400);
  v32[4] = *(_OWORD *)(a1 + 384);
  v32[5] = v10;
  long long v11 = *(_OWORD *)(a1 + 432);
  v32[6] = *(_OWORD *)(a1 + 416);
  long long v12 = *(_OWORD *)(a1 + 448);
  v32[7] = v11;
  v32[8] = v12;
  do
  {
    CFArrayRef v13 = (const __CFArray *)*((void *)v33 + v2);
    if (v13 || (CFArrayRef v13 = (const __CFArray *)*((void *)v32 + v2)) != 0) {
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), dword_182D9ECA0[v2], v34[v2], v13);
    }
    ++v2;
  }
  while (v2 != 18);
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v14 = *(void *)(a1 + 280);
  if (v14 || (uint64_t v14 = *(void *)(a1 + 496)) != 0) {
    uint64_t v30 = v14;
  }
  uint64_t v15 = *(void *)(a1 + 288);
  if (v15 || (uint64_t v15 = *(void *)(a1 + 504)) != 0) {
    uint64_t v31 = v15;
  }
  uint64_t v16 = 0;
  char v17 = 1;
  do
  {
    char v18 = v17;
    CFStringRef v19 = (const __CFString *)*(&v30 + v16);
    if (v19)
    {
      CFIndex Length = CFStringGetLength((CFStringRef)*(&v30 + v16));
      uint64_t v22 = Length;
      if (Length >= 768) {
        CFIndex v23 = 768;
      }
      else {
        CFIndex v23 = Length;
      }
      MEMORY[0x1F4188790](Length, v21);
      CFIndex v25 = (UniChar *)((char *)&v28 - v24);
      CharactersPtr = CFStringGetCharactersPtr(v19);
      if (CharactersPtr)
      {
        BOOL v27 = (UChar *)CharactersPtr;
      }
      else
      {
        v39.CFIndex location = 0;
        v39.CFIndex length = v23;
        CFStringGetCharacters(v19, v39, v25);
        uint64_t v22 = v23;
        BOOL v27 = v25;
      }
      int v29 = 0;
      __cficu_udat_setSymbols(*(void *)(a1 + 16), 5u, v16, v27, v22, &v29);
    }
    char v17 = 0;
    uint64_t v16 = 1;
  }
  while ((v18 & 1) != 0);
}

void __cficu_ucal_setTimeZone(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  ucal_setTimeZone();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      long long v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      CFStringRef v11 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      long long v12 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 138413314;
        CFStringRef v14 = v8;
        __int16 v15 = 2112;
        CFStringRef v16 = v11;
        __int16 v17 = 1024;
        int32_t v18 = a3;
        __int16 v19 = 2112;
        BOOL v20 = v9;
        __int16 v21 = 2112;
        CFStringRef v22 = v10;
        _os_log_debug_impl(&dword_182B90000, v12, OS_LOG_TYPE_DEBUG, "ucal_setTimeZone(%@, %@, %d, &%@); %@",
          (uint8_t *)&v13,
          0x30u);
      }
      CFRelease(v11);
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }
}

uint64_t _CFLocaleGetAppleICUDateTimeSymbolsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUDateTimeSymbols"];
}

uint64_t _CFLocaleGetAppleMinDaysInFirstWeekPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleMinDaysInFirstWeek"];
}

uint64_t _CFLocaleGetAppleICUTimeFormatStringsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUTimeFormatStrings"];
}

uint64_t _CFLocaleGetAppleFirstWeekdayPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleFirstWeekday"];
}

uint64_t _CFLocaleGetAppleICUDateFormatStringsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUDateFormatStrings"];
}

void __cficu_udat_setLenient(uint64_t a1, int a2)
{
  udat_setLenient();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"udat_setLenient(%@, %d);", v4, a2);
    CFRelease(v4);
  }
}

uint64_t __cficu_udat_open(int a1, int a2, uint64_t a3, UChar *a4, uint64_t a5, UChar *a6, uint64_t a7, int *a8)
{
  uint64_t v16 = udat_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v24 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", v16);
    __int16 v17 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a8);
    CFStringRef v18 = ___CFICUCreateErrorStringWithComment(a8, 1);
    CFStringRef v19 = ___CFICUCreateArgumentForUCharInput(a4, a5, 0);
    CFStringRef v20 = ___CFICUCreateArgumentForUCharInput(a6, a7, 1);
    __int16 v21 = ___CFICUGetEnumStringForUDateFormatStyle(a1);
    CFStringRef v22 = ___CFICUGetEnumStringForUDateFormatStyle(a2);
    ___CFICULogWithArguments(1, @"UDateFormat *%@ = udat_open(%s, %s, \"%s\", %@, %d, %@, %d, &%@); %@",
      v24,
      v21,
      v22,
      a3,
      v19,
      a5,
      v20,
      a7,
      v17,
      v18);
    CFRelease(v19);
    CFRelease(v20);
    CFRelease(v24);
    CFRelease(v17);
    CFRelease(v18);
  }
  return v16;
}

void __cficu_udat_setContext(uint64_t a1, int a2, int *a3)
{
  udat_setContext();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    long long v6 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    long long v7 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a3);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a3, 1);
    CFStringRef v9 = v8;
    if ((a2 - 256) > 4) {
      CFStringRef v10 = "<unknown UDisplayContext>";
    }
    else {
      CFStringRef v10 = off_1ECDFE4B8[a2 - 256];
    }
    ___CFICULogWithArguments(1, @"udat_setContext(%@, %s, %@); %@", v6, v10, v7, v8);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v9);
  }
}

uint64_t __cficu_udat_toPatternRelativeDate(uint64_t a1, const UniChar *a2, uint64_t a3, int *a4)
{
  uint64_t v8 = udat_toPatternRelativeDate();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
    CFTypeRef v11 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"pattern", (uint64_t)a2, a3);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a4, 0);
    CFStringRef v13 = v12;
    if (*a4 < 1)
    {
      CFStringRef v14 = CFStringCreateWithCharacters(0, a2, (int)v8);
      ___CFICULogWithArguments(1, @"udat_toPatternRelativeDate(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        v14,
        v13);
      if (v14) {
        CFRelease(v14);
      }
    }
    else
    {
      ___CFICULogWithArguments(1, @"udat_toPatternRelativeDate(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        0,
        v12);
    }
    CFRelease(v9);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
  }
  return v8;
}

void __cficu_udat_applyPatternRelative(uint64_t a1, UChar *a2, uint64_t a3, UChar *a4, uint64_t a5, int *a6)
{
  udat_applyPatternRelative();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v15 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    CFStringRef v16 = ___CFICUCreateArgumentForUCharInput(a4, a5, 1);
    ___CFICULogWithArguments(1, @"udat_applyPatternRelative(%@, %@, %d, %@, %d, &%@); %@",
      v12,
      v15,
      a3,
      v16,
      a5,
      v13,
      v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
  }
}

uint64_t __cficu_udat_toPatternRelativeTime(uint64_t a1, const UniChar *a2, uint64_t a3, int *a4)
{
  uint64_t v8 = udat_toPatternRelativeTime();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
    CFTypeRef v11 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"pattern", (uint64_t)a2, a3);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a4, 0);
    CFStringRef v13 = v12;
    if (*a4 < 1)
    {
      CFStringRef v14 = CFStringCreateWithCharacters(0, a2, (int)v8);
      ___CFICULogWithArguments(1, @"udat_toPatternRelativeTime(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        v14,
        v13);
      if (v14) {
        CFRelease(v14);
      }
    }
    else
    {
      ___CFICULogWithArguments(1, @"udat_toPatternRelativeTime(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        0,
        v12);
    }
    CFRelease(v9);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
  }
  return v8;
}

uint64_t __cficu_udat_getContext(uint64_t a1, int a2, int *a3)
{
  uint64_t Context = udat_getContext();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    long long v7 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v8 = (const void *)___CFICUCreateVariableName((uint64_t)"cxt");
    CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a3);
    CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a3, 1);
    CFStringRef v11 = v10;
    CFStringRef v12 = "<unknown UDisplayContextType>";
    if (a2 == 1) {
      CFStringRef v12 = "UDISPCTX_TYPE_CAPITALIZATION";
    }
    if (!a2) {
      CFStringRef v12 = "UDISPCTX_TYPE_DIALECT_HANDLING";
    }
    ___CFICULogWithArguments(1, @"UDisplayContext %@ = udat_getContext(%@, %s, %@); %@", v8, v7, v12, v9, v10);
    CFRelease(v7);
    CFRelease(v8);
    CFRelease(v9);
    CFRelease(v11);
  }
  return Context;
}

uint64_t __CFStringIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    [(__CFArray *)theArray removeAllObjects];
  }
  else
  {
    __CFArrayReleaseValues((unint64_t)theArray, 0, *((void *)theArray + 2), 1);
    uint64_t v2 = *((void *)theArray + 3) + 1;
    *((void *)theArray + 2) = 0;
    *((void *)theArray + 3) = v2;
  }
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  CFIndex location = range.location;
  if (range.length >= 1)
  {
    CFIndex length = range.length;
    CFIndex v11 = range.location + range.length;
    if (((uint64_t (*)(uint64_t, const void *, void *))comparator)([(__CFArray *)theArray objectAtIndex:range.location + range.length - 1], value, context) < 0)
    {
      return v11;
    }
    else if ((((uint64_t (*)(const void *, uint64_t, void *))comparator)(value, [(__CFArray *)theArray objectAtIndex:location], context) & 0x8000000000000000) == 0)
    {
      int v12 = flsl(length);
      int v13 = 1 << (v12 - 1);
      if (((uint64_t (*)(uint64_t, const void *, void *))comparator)([(__CFArray *)theArray objectAtIndex:location + v13 - 1], value, context) >= 0)uint64_t v14 = -1; {
      else
      }
        uint64_t v14 = length - v13;
      if (v12 != 1)
      {
        int v15 = v12 - 2;
        do
        {
          v14 += (1 << v15) & (unint64_t)(((uint64_t (*)(uint64_t, const void *, void *))comparator)([(__CFArray *)theArray objectAtIndex:v14 + location + (1 << v15)], value, context) >> 63);
          --v15;
        }
        while (v15 != -1);
      }
      location += v14 + 1;
    }
  }
  return location;
}

CFMutableStringRef CFBundleCopyLocalizedStringForLocalization(unint64_t *a1, void *a2, __CFString *a3, __CFString *a4, const void *a5)
{
  return _CFBundleCopyLocalizedStringForLocalizationAndTableURL(a1, a2, a3, a4, a5, 0);
}

void _CFPrefsRegisterUserDefaultsInstance(uint64_t a1)
{
}

Boolean CFRunLoopTimerDoesRepeat(CFRunLoopTimerRef timer)
{
  __CFCheckCFInfoPACSignature((uint64_t)timer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v2 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((double *)timer + 14) > 0.0;
}

uint64_t __CFStartSearchPathEnumeration()
{
  return sysdir_start_search_path_enumeration_private();
}

CFIndex CFBitVectorGetFirstIndexOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  if (range.length < 1) {
    return -1;
  }
  while (((*(unsigned __int8 *)(*((void *)bv + 4) + range.location / 8) >> (~LOBYTE(range.location) & 7)) & 1) != value)
  {
    ++range.location;
    if (!--range.length) {
      return -1;
    }
  }
  return range.location;
}

Boolean CFBitVectorContainsBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  if (!range.length) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v4 = value;
  __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorCountBits, (uint64_t)&v4);
  return v5 != 0;
}

void CFBitVectorSetCount(CFMutableBitVectorRef bv, CFIndex count)
{
  CFIndex v4 = *((void *)bv + 2);
  char v5 = atomic_load((unint64_t *)bv + 1);
  BOOL v6 = (v5 & 0xC) != 4 || count <= v4;
  if (!v6)
  {
    CFIndex v7 = count;
    if ((unint64_t)count <= 1) {
      CFIndex v7 = 1;
    }
    uint64_t v8 = v7 + 63;
    BOOL v6 = v7 < -63;
    uint64_t v9 = v7 + 126;
    if (!v6) {
      uint64_t v9 = v8;
    }
    uint64_t v10 = v9 >> 6;
    unint64_t v11 = v9 & 0xFFFFFFFFFFFFFFC0;
    CFAllocatorRef v12 = CFGetAllocator(bv);
    *((void *)bv + 3) = v11;
    *((void *)bv + 4) = __CFSafelyReallocateWithAllocatorTyped(v12, *((void *)bv + 4), (8 * v10) | 1, 0x100004077774924, 0, 0);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  if (count > v4) {
    __CFBitVectorInternalMap((uint64_t)bv, v4, count - v4, (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorZeroBits, 0);
  }
  *((void *)bv + 2) = count;
}

void CFBitVectorGetBits(CFBitVectorRef bv, CFRange range, UInt8 *bytes)
{
  v3[4] = *(void *)off_1ECE0A5B0;
  if (range.length)
  {
    v3[0] = bytes;
    v3[1] = range.location & 7;
    v3[2] = range.length;
    v3[3] = 1;
    __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorGetBits, (uint64_t)v3);
  }
}

uint64_t __CFBitVectorInternalMap(uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, uint64_t, uint64_t), uint64_t a5)
{
  if (a3)
  {
    uint64_t v7 = result;
    uint64_t v8 = a2 / 8;
    uint64_t v9 = (a2 & 7) + a3;
    if (v9 <= 7) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = (a2 | 0xFFFFFFFFFFFFFFF8) + a3;
    }
    if (v9 <= 7) {
      uint64_t v11 = (255 << (8 - a3)) >> (a2 & 7);
    }
    else {
      uint64_t v11 = 0xFFu >> (a2 & 7);
    }
    CFRange result = a4(*(unsigned __int8 *)(*(void *)(result + 32) + v8), v11, a5);
    *(unsigned char *)(*(void *)(v7 + 32) + v8) = *(unsigned char *)(*(void *)(v7 + 32) + v8) & ~(_BYTE)v11 | result & v11;
    if (v10 >= 0) {
      uint64_t v12 = v10;
    }
    else {
      uint64_t v12 = v10 + 7;
    }
    unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v14 = v8 + 1;
    if ((unint64_t)(v10 + 7) >= 0xF)
    {
      uint64_t v15 = v12 >> 3;
      do
      {
        --v15;
        CFRange result = a4(*(unsigned __int8 *)(*(void *)(v7 + 32) + v14), 255, a5);
        *(unsigned char *)(*(void *)(v7 + 32) + v14++) = result;
      }
      while (v15);
    }
    if (v13 != v10)
    {
      int v16 = 255 << (v13 - v10 + 8);
      CFRange result = a4(*(unsigned __int8 *)(*(void *)(v7 + 32) + v14), v16, a5);
      *(unsigned char *)(*(void *)(v7 + 32) + v14) = *(unsigned char *)(*(void *)(v7 + 32) + v14) & ~(_BYTE)v16 | result & v16;
    }
  }
  return result;
}

uint64_t __CFBitVectorZeroBits()
{
  return 0;
}

uint64_t __CFBitVectorGetBits(uint64_t result, int a2, uint64_t a3)
{
  unsigned int v3 = a2 & result;
  uint64_t v4 = *(void *)(a3 + 8);
  uint64_t v5 = 8 - v4;
  if (8 - v4 >= *(void *)(a3 + 16)) {
    uint64_t v5 = *(void *)(a3 + 16);
  }
  if (v4 >= 1)
  {
    if (!*(unsigned char *)(a3 + 24))
    {
      **(unsigned char **)a3 |= v3 >> (8 - v4);
      uint64_t v4 = *(void *)(a3 + 8);
      ++*(void *)a3;
      *(void *)(a3 + 16) -= v4;
      *(unsigned char *)(a3 + 24) = 0;
    }
    v3 <<= v4;
  }
  if (v5 < 8)
  {
    char v7 = v3;
    uint64_t v9 = v5;
  }
  else
  {
    BOOL v6 = *(unsigned char **)a3;
    do
    {
      char v7 = 0;
      *BOOL v6 = v3;
      uint64_t v8 = *(void *)(a3 + 8);
      BOOL v6 = (unsigned char *)(*(void *)a3 + 1);
      *(void *)a3 = v6;
      *(void *)(a3 + 16) -= v8;
      uint64_t v9 = v5 - 8;
      LOBYTE(v3) = 0;
      BOOL v10 = (unint64_t)v5 > 0xF;
      v5 -= 8;
    }
    while (v10);
  }
  if (v9 >= 1)
  {
    **(unsigned char **)a3 = v7;
    *(void *)(a3 + 16) -= v9;
  }
  return result;
}

uint64_t __CFBitVectorCountBits(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (*(_DWORD *)a3) {
    int v3 = result;
  }
  else {
    int v3 = ~result;
  }
  *(void *)(a3 + 8) += __CFBitVectorCountBits___CFNibbleBitCount[v3 & a2 & 0xFLL]
                       + (unint64_t)__CFBitVectorCountBits___CFNibbleBitCount[(unint64_t)(v3 & a2) >> 4];
  return result;
}

uint64_t CFArrayApply(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = a3 - 1;
  if (a3 >= 1)
  {
    char v7 = (void *)result;
    do
    {
      uint64_t v8 = [v7 objectAtIndex:a2];
      char v10 = 0;
      CFRange result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a4 + 16))(a4, v8, &v10);
      if (v10) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v4 == 0;
      }
      --v4;
      ++a2;
    }
    while (!v9);
  }
  return result;
}

CFURLRef CFURLCreateFilePathURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  uint64_t v74 = *(void *)off_1ECE0A5B0;
  char v39 = 0;
  if (!_CFURLHasFileURLScheme((unint64_t)url, &v39))
  {
    if (v39)
    {
      if (error)
      {
LABEL_11:
        CFURLRef v15 = 0;
        *error = CFErrorCreate(0, @"NSCocoaErrorDomain", 262, 0);
        return v15;
      }
    }
    else
    {
      CFLog(4, @"CFURLCreateFilePathURL failed because it was passed a URL which has no scheme");
      if (error) {
        goto LABEL_11;
      }
    }
    return 0;
  }
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url))
  {
    if ([(__CFURL *)url baseURL]) {
      goto LABEL_4;
    }
  }
  else if (*((void *)url + 4))
  {
LABEL_4:
    CFURLRef v6 = CFURLCopyAbsoluteURL(url);
    CFAllocatorRef v7 = CFGetAllocator(v6);
    CFStringRef v8 = CFURLCreateStringWithFileSystemPath(v7, (unint64_t)v6, 0, 0);
    CFStringRef v9 = CFURLCopyNetLocation(v6);
    CFStringRef v10 = CFURLCopyResourceSpecifier(v6);
    CFRelease(v6);
    if (v8) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }
  CFAllocatorRef v16 = CFGetAllocator(url);
  CFStringRef v8 = CFURLCreateStringWithFileSystemPath(v16, (unint64_t)url, 0, 0);
  CFStringRef v9 = CFURLCopyNetLocation(url);
  CFStringRef v10 = CFURLCopyResourceSpecifier(url);
  if (v8)
  {
LABEL_5:
    unint64_t Length = CFStringGetLength(v8);
    if (Length <= 1) {
      unint64_t Length = 1;
    }
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v13 = MaximumSizeForEncoding + 1;
    if (MaximumSizeForEncoding >= 1024) {
      uint64_t v14 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xBB047E6uLL);
    }
    else {
      uint64_t v14 = buffer;
    }
    if (CFStringGetCString(v8, v14, v13, 0x8000100u))
    {
      size_t v17 = strlen(v14);
      CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v14, v17, 0, 0, 0, 0);
    }
    else
    {
      CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
    }
    if (v14 != buffer) {
      free(v14);
    }
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    *(_OWORD *)buffer = 0u;
    long long v41 = 0u;
    CFIndex v72 = 0;
    CFMutableStringRef Mutable = CFStringCreateMutable(allocator, 0);
    CFIndex v19 = CFStringGetLength(@"file://");
    CFIndex v20 = v72;
    if (v19 < 1025)
    {
      CFIndex v21 = v19;
      if (v72 + v19 >= 1025)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        CFIndex v20 = 0;
        CFIndex v72 = 0;
      }
      CFStringRef v22 = (UniChar *)&buffer[2 * v20];
      v75.CFIndex location = 0;
      v75.CFIndex length = v21;
      CFStringGetCharacters(@"file://", v75, v22);
      v72 += v21;
      if (!v9)
      {
LABEL_40:
        CFIndex v27 = CFStringGetLength(StringFromFileSystemRepresentationByAddingPercentEscapes);
        CFIndex v28 = v72;
        if (v27 < 1025)
        {
          CFIndex v29 = v27;
          if (v72 + v27 >= 1025)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            CFIndex v28 = 0;
            CFIndex v72 = 0;
          }
          uint64_t v30 = (UniChar *)&buffer[2 * v28];
          v77.CFIndex location = 0;
          v77.CFIndex length = v29;
          CFStringGetCharacters(StringFromFileSystemRepresentationByAddingPercentEscapes, v77, v30);
          v72 += v29;
        }
        else
        {
          if (v72)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            CFIndex v72 = 0;
          }
          CFStringAppend(Mutable, StringFromFileSystemRepresentationByAddingPercentEscapes);
        }
        if (CFURLHasDirectoryPath(url)
          && CFStringCompare(StringFromFileSystemRepresentationByAddingPercentEscapes, @"/", 0))
        {
          CFIndex v31 = v72;
          if (v72 >= 1024)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            CFIndex v31 = 0;
            CFIndex v72 = 0;
          }
          *(_WORD *)&buffer[2 * v31] = 47;
          ++v72;
        }
        if (v10)
        {
          CFIndex v32 = CFStringGetLength(v10);
          CFIndex v33 = v72;
          if (v32 < 1025)
          {
            CFIndex v37 = v32;
            if (v72 + v32 >= 1025)
            {
              CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
              CFIndex v33 = 0;
              CFIndex v72 = 0;
            }
            uint64_t v38 = (UniChar *)&buffer[2 * v33];
            v78.CFIndex location = 0;
            v78.CFIndex length = v37;
            CFStringGetCharacters(v10, v78, v38);
            CFIndex v34 = v72 + v37;
            CFIndex v72 = v34;
            if (!v34)
            {
LABEL_59:
              CFStringRef v35 = Mutable;
              CFMutableStringRef Mutable = 0;
              if (v35)
              {
                CFURLRef v15 = (const __CFURL *)_CFURLCreateWithURLString((int)allocator, v35);
                CFRelease(v35);
              }
              else
              {
                CFURLRef v15 = 0;
              }
              CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
              CFRelease(v8);
              if (!v9) {
                goto LABEL_64;
              }
              goto LABEL_63;
            }
LABEL_58:
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v34);
            CFIndex v72 = 0;
            goto LABEL_59;
          }
          if (v72)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            CFIndex v72 = 0;
          }
          CFStringAppend(Mutable, v10);
        }
        CFIndex v34 = v72;
        if (!v72) {
          goto LABEL_59;
        }
        goto LABEL_58;
      }
    }
    else
    {
      if (v72)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        CFIndex v72 = 0;
      }
      CFStringAppend(Mutable, @"file://");
      if (!v9) {
        goto LABEL_40;
      }
    }
    CFIndex v23 = CFStringGetLength(v9);
    CFIndex v24 = v72;
    if (v23 < 1025)
    {
      CFIndex v25 = v23;
      if (v72 + v23 >= 1025)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        CFIndex v24 = 0;
        CFIndex v72 = 0;
      }
      CFRange v26 = (UniChar *)&buffer[2 * v24];
      v76.CFIndex location = 0;
      v76.CFIndex length = v25;
      CFStringGetCharacters(v9, v76, v26);
      v72 += v25;
    }
    else
    {
      if (v72)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        CFIndex v72 = 0;
      }
      CFStringAppend(Mutable, v9);
    }
    goto LABEL_40;
  }
LABEL_14:
  if (error)
  {
    CFURLRef v15 = 0;
    *error = CFErrorCreate(0, @"NSCocoaErrorDomain", 4, 0);
    if (!v9) {
      goto LABEL_64;
    }
LABEL_63:
    CFRelease(v9);
    goto LABEL_64;
  }
  CFURLRef v15 = 0;
  if (v9) {
    goto LABEL_63;
  }
LABEL_64:
  if (v10) {
    CFRelease(v10);
  }
  return v15;
}

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  CFURLRef v1 = anURL;
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
    CFURLRef v1 = (CFURLRef)[(__CFURL *)v1 _cfurl];
  }
  int v2 = *((_DWORD *)v1 + 4);
  if ((v2 & 0x4000) != 0)
  {
    unsigned int v4 = 0;
    for (unsigned int i = 256; i != 32; i >>= 1)
    {
      if ((i & v2) != 0) {
        unsigned int v4 = i;
      }
    }
    if (!v4) {
      return 0;
    }
    CFAllocatorRef v6 = CFGetAllocator(v1);
    if (v1 && (uint64_t v7 = *((void *)v1 + 5)) != 0)
    {
      int v8 = *(_DWORD *)(v7 + 16);
      CFStringRef v9 = *(const __CFString **)(v7 + 8);
    }
    else
    {
      int v8 = 0;
      CFStringRef v9 = 0;
    }
    unsigned int v19 = *((_DWORD *)v1 + 4);
    if ((v19 & 0x10000) != 0 || v4 == 512)
    {
LABEL_27:
      if ((v19 & v4) != 0)
      {
        if (v4)
        {
          uint64_t v21 = 0;
        }
        else
        {
          LODWORD(v21) = 0;
          do
          {
            char v22 = v4;
            v4 >>= 1;
            uint64_t v21 = (v19 & 1) + v21;
            v19 >>= 1;
          }
          while ((v22 & 2) == 0);
        }
        CFIndex v24 = *((void *)v1 + 2 * v21 + 7) - 1;
      }
      else
      {
        CFIndex v24 = -2;
      }
      uint64_t v30 = (unint64_t *)((char *)v1 + 24);
      CFStringRef v31 = (const __CFString *)atomic_load(v30);
      CFIndex Length = CFStringGetLength(v31);
      CFStringRef v14 = (const __CFString *)atomic_load(v30);
      v12.CFIndex length = Length - v24;
      CFAllocatorRef v13 = v6;
      v12.CFIndex location = v24;
    }
    else
    {
      unsigned int v20 = v4;
      while ((v20 & v8) == 0)
      {
        v20 *= 2;
        if (v20 == 512) {
          goto LABEL_27;
        }
      }
      unsigned int v25 = v4;
      while (v25 >= 2)
      {
        BOOL v26 = (v8 & (v25 >> 1)) == 0;
        v25 >>= 1;
        if (!v26)
        {
          unsigned int v38 = 0;
          _parseComponents(v9, *((const __CFURL **)v1 + 4), &v38, v39, &v37);
          unsigned int v27 = v38;
          if ((v38 & v4) != 0)
          {
            if (v4)
            {
              uint64_t v28 = 0;
            }
            else
            {
              LODWORD(v28) = 0;
              do
              {
                char v29 = v4;
                v4 >>= 1;
                uint64_t v28 = (v27 & 1) + v28;
                v27 >>= 1;
              }
              while ((v29 & 2) == 0);
            }
            uint64_t v3 = v39[2 * v28] - 1;
          }
          else
          {
            uint64_t v3 = -2;
          }
          CFIndex v36 = CFStringGetLength(v9);
          CFAllocatorRef v13 = CFGetAllocator(v1);
          v12.CFIndex length = v36 - v3;
          goto LABEL_18;
        }
      }
      if ((v19 & v4) != 0)
      {
        if (v4)
        {
          uint64_t v33 = 0;
        }
        else
        {
          LODWORD(v33) = 0;
          do
          {
            char v34 = v4;
            v4 >>= 1;
            uint64_t v33 = (v19 & 1) + v33;
            v19 >>= 1;
          }
          while ((v34 & 2) == 0);
        }
        uint64_t v35 = *((void *)v1 + 2 * v33 + 7) - 1;
      }
      else
      {
        uint64_t v35 = -2;
      }
      v12.CFIndex length = CFStringGetLength(v9) - v35;
      CFAllocatorRef v13 = v6;
      CFStringRef v14 = v9;
      v12.CFIndex location = v35;
    }
  }
  else
  {
    if (v2) {
      uint64_t v3 = *((void *)v1 + 7) + *((void *)v1 + 8) + 1;
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v10 = *((void *)v1 + 5);
    if (v10 && (CFStringRef v9 = *(const __CFString **)(v10 + 8)) != 0)
    {
      CFAllocatorRef v11 = CFGetAllocator(v1);
      v12.CFIndex length = CFStringGetLength(v9) - v3;
      CFAllocatorRef v13 = v11;
LABEL_18:
      CFStringRef v14 = v9;
    }
    else
    {
      CFAllocatorRef v15 = CFGetAllocator(v1);
      CFAllocatorRef v16 = (unint64_t *)((char *)v1 + 24);
      unint64_t v17 = atomic_load((unint64_t *)v1 + 3);
      CFStringRef v18 = (const __CFString *)atomic_load(v16);
      v12.CFIndex length = CFStringGetLength(v18) - v3;
      CFAllocatorRef v13 = v15;
      CFStringRef v14 = (const __CFString *)v17;
    }
    v12.CFIndex location = v3;
  }

  return CFStringCreateWithSubstring(v13, v14, v12);
}

uint64_t _appendPercentEscapesForCharacter(unsigned __int16 *a1, int a2, int a3, __CFString *a4)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  uint64_t v13 = 0;
  if (a2) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = 1;
  }
  int v6 = CFStringEncodingUnicodeToBytes(a3, 0, a1, v5, 0, v15, 8, &v13);
  uint64_t result = 0;
  if (!v6)
  {
    if (v13 < 1)
    {
      CFIndex v8 = 0;
    }
    else
    {
      CFIndex v8 = 0;
      CFStringRef v9 = (unsigned int *)((char *)v15 + v13);
      uint64_t v10 = v15;
      do
      {
        CFAllocatorRef v11 = &chars[v8];
        *CFAllocatorRef v11 = 37;
        unsigned int v12 = *(unsigned __int8 *)v10;
        uint64_t v10 = (unsigned int *)((char *)v10 + 1);
        v11[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v12 >> 4];
        v8 += 3;
        v11[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v12 & 0xF];
      }
      while (v10 < v9);
    }
    CFStringAppendCharacters(a4, chars, v8);
    return 1;
  }
  return result;
}

uint64_t __CFStringFormatLocalizedNumber(__CFString *a1, const void *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  *(void *)&length[1] = *(void *)off_1ECE0A5B0;
  length[0] = a5;
  if (__CFStringFormatLocalizedNumber_disableLocalizedFormatting != -1)
  {
    if (!__CFStringFormatLocalizedNumber_disableLocalizedFormatting) {
      goto LABEL_5;
    }
    return 0;
  }
  __CFStringFormatLocalizedNumber_disableLocalizedFormatting = getenv("CFStringDisableLocalizedNumberFormatting") != 0;
  if (__CFStringFormatLocalizedNumber_disableLocalizedFormatting) {
    return 0;
  }
LABEL_5:
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
  switch(*(unsigned char *)(a4 + 28))
  {
    case 1:
    case 4:
      if (!__CFStringFormatLocalizedNumber_decimalFormatter) {
        goto LABEL_17;
      }
      CFLocaleRef Locale = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_decimalFormatter);
      if (CFEqual(Locale, a2))
      {
        CFStringRef v14 = &__CFStringFormatLocalizedNumber_decimalFormatter;
        goto LABEL_27;
      }
      if (__CFStringFormatLocalizedNumber_decimalFormatter) {
        CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_decimalFormatter);
      }
LABEL_17:
      unint64_t v17 = CFNumberFormatterCreate(0, (CFLocaleRef)a2, kCFNumberFormatterDecimalStyle);
      __CFStringFormatLocalizedNumber_decimalFormatter = (uint64_t)v17;
      if (!v17) {
        goto LABEL_46;
      }
      goto LABEL_28;
    case 2:
      if (!__CFStringFormatLocalizedNumber_scientificFormatter) {
        goto LABEL_21;
      }
      CFLocaleRef v15 = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_scientificFormatter);
      if (CFEqual(v15, a2))
      {
        CFStringRef v14 = &__CFStringFormatLocalizedNumber_scientificFormatter;
        goto LABEL_27;
      }
      if (__CFStringFormatLocalizedNumber_scientificFormatter) {
        CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_scientificFormatter);
      }
LABEL_21:
      CFStringRef v18 = CFNumberFormatterCreate(0, (CFLocaleRef)a2, kCFNumberFormatterScientificStyle);
      __CFStringFormatLocalizedNumber_scientificFormatter = (uint64_t)v18;
      if (!v18) {
        goto LABEL_46;
      }
      CFStringRef v14 = &__CFStringFormatLocalizedNumber_scientificFormatter;
      CFNumberFormatterSetFormat(v18, @"#E+00");
      CFNumberFormatterSetProperty((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_scientificFormatter, @"kCFNumberFormatterUseSignificantDigitsKey", &__kCFBooleanTrue);
      goto LABEL_27;
    case 3:
      if (!__CFStringFormatLocalizedNumber_gFormatter) {
        goto LABEL_25;
      }
      CFLocaleRef v16 = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_gFormatter);
      if (CFEqual(v16, a2))
      {
        CFStringRef v14 = &__CFStringFormatLocalizedNumber_gFormatter;
      }
      else
      {
        if (__CFStringFormatLocalizedNumber_gFormatter) {
          CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_gFormatter);
        }
LABEL_25:
        unsigned int v19 = CFNumberFormatterCreate(0, (CFLocaleRef)a2, kCFNumberFormatterDecimalStyle);
        __CFStringFormatLocalizedNumber_gFormatter = (uint64_t)v19;
        if (!v19) {
          goto LABEL_46;
        }
        CFStringRef v14 = &__CFStringFormatLocalizedNumber_gFormatter;
        CFNumberRef v20 = (const __CFNumber *)CFNumberFormatterCopyProperty(v19, @"kCFNumberFormatterGroupingSizeKey");
        CFNumberGetValue(v20, kCFNumberSInt32Type, &__CFStringFormatLocalizedNumber_groupingSize);
        CFRelease(v20);
        CFNumberRef v21 = (const __CFNumber *)CFNumberFormatterCopyProperty((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_gFormatter, @"kCFNumberFormatterSecondaryGroupingSizeKey");
        CFNumberGetValue(v21, kCFNumberSInt32Type, &__CFStringFormatLocalizedNumber_secondaryGroupingSize);
        CFRelease(v21);
      }
LABEL_27:
      unint64_t v17 = (__CFNumberFormatter *)*v14;
      if (!*v14)
      {
LABEL_46:
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
        return 0;
      }
LABEL_28:
      CFStringRef Format = CFNumberFormatterGetFormat(v17);
      CFStringRef Copy = CFStringCreateCopy(0, Format);
      if (!a7)
      {
        if (*(_WORD *)(a4 + 2) == 33) {
          a6 = 0;
        }
        else {
          a6 = 6;
        }
      }
      int v61 = a6;
      if (*(unsigned char *)(a4 + 28) == 3)
      {
        if (!a6)
        {
          a6 = 1;
          int v61 = 1;
        }
        CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
        CFStringAppendCString(Mutable, "@", 0x600u);
        CFStringPad(Mutable, @"#", a6, 0);
        double v25 = *(double *)(a3 + 16 * *(char *)(a4 + 24) + 8);
        double v26 = __exp10((double)a6);
        if (v25 > 0.0 && (v25 < 0.0001 || v25 > v26) || v25 < 0.0 && (v25 > -0.0001 || v25 < -v26))
        {
          CFStringAppendCString(Mutable, "E+00", 0x600u);
        }
        else if (a6 > __CFStringFormatLocalizedNumber_groupingSize)
        {
          if (__CFStringFormatLocalizedNumber_groupingSize)
          {
            CFStringInsert(Mutable, a6 - __CFStringFormatLocalizedNumber_groupingSize, @",");
            if (__CFStringFormatLocalizedNumber_secondaryGroupingSize)
            {
              if (a6 > __CFStringFormatLocalizedNumber_groupingSize
                      + __CFStringFormatLocalizedNumber_secondaryGroupingSize)
                CFStringInsert(Mutable, a6- (__CFStringFormatLocalizedNumber_groupingSize+ __CFStringFormatLocalizedNumber_secondaryGroupingSize), @",");
            }
          }
        }
        CFNumberFormatterSetFormat(v17, Mutable);
        CFRelease(Mutable);
      }
      int valuePtr = 0;
      CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterFormatWidthKey", v27);
      CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v61);
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMaxFractionDigitsKey", v28);
      if (*(_WORD *)(a4 + 2) == 34) {
        CFNumberRef v29 = v28;
      }
      else {
        CFNumberRef v29 = v27;
      }
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMinFractionDigitsKey", v29);
      CFRelease(v28);
      CFRelease(v27);
      uint64_t v30 = *(char *)(a4 + 24);
      int v31 = *(__int16 *)(a3 + 16 * v30);
      if (v31 == 34)
      {
        LOBYTE(v32) = *(double *)(a3 + 16 * v30 + 8) < 0.0;
      }
      else
      {
        LOBYTE(v32) = 0;
        if (v31 == 33) {
          uint64_t v32 = *(void *)(a3 + 16 * v30 + 8) >> 63;
        }
      }
      CFStringRef v33 = CFNumberFormatterGetFormat(v17);
      int v34 = *(_DWORD *)(a4 + 20);
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v33, 0);
      if ((v32 & 1) != 0 || (v34 & 4) == 0)
      {
        if (CharacterAtIndex == 43)
        {
          v63.CFIndex length = CFStringGetLength(v33) - 1;
          v63.CFIndex location = 1;
          MutableCFStringRef Copy = (__CFString *)CFStringCreateWithSubstring(0, v33, v63);
          goto LABEL_62;
        }
      }
      else if (CharacterAtIndex != 43)
      {
        MutableCFStringRef Copy = CFStringCreateMutableCopy(0, 0, @"+");
        CFStringAppend(MutableCopy, v33);
LABEL_62:
        CFNumberFormatterSetFormat(v17, MutableCopy);
        CFRelease(MutableCopy);
      }
      int v37 = *(unsigned char *)(a4 + 20) & 1;
      if (a7 && *(_WORD *)(a4 + 2) == 33)
      {
        CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v61);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterFormatWidthKey", v38);
      }
      else
      {
        CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, length);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterFormatWidthKey", v38);
        if (!a7) {
          goto LABEL_69;
        }
      }
      if (*(_WORD *)(a4 + 2) == 33) {
        int v37 = 1;
      }
LABEL_69:
      if ((*(_DWORD *)(a4 + 20) & 2) != 0) {
        int v39 = 3;
      }
      else {
        int v39 = v37;
      }
      int v58 = 0;
      int v59 = v39;
      CFNumberGetValue(v38, kCFNumberSInt32Type, &v58);
      if (v37 && v58 >= 1 && v59 && *(_WORD *)(a4 + 2) != 34) {
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMinIntegerDigitsKey", v38);
      }
      CFRelease(v38);
      if (a7 && *(_WORD *)(a4 + 2) == 33)
      {
        LODWORD(v57[0]) = 1;
        uint64_t v40 = (int *)v57;
      }
      else
      {
        uint64_t v40 = &v59;
      }
      CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, v40);
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterPaddingPositionKey", v41);
      CFRelease(v41);
      if (v37)
      {
        int v42 = *(unsigned __int8 *)(a4 + 28);
        if (v42 != 3) {
          goto LABEL_86;
        }
        long long v43 = @"0";
      }
      else
      {
        long long v43 = @" ";
      }
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterPaddingCharacterKey", v43);
      int v42 = *(unsigned __int8 *)(a4 + 28);
LABEL_86:
      if (v42 == 2)
      {
        ++v61;
        CFNumberRef v44 = CFNumberCreate(0, kCFNumberSInt32Type, &v61);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMinSignificantDigitsKey", v44);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMaxSignificantDigitsKey", v44);
        CFRelease(v44);
      }
      int v45 = *(__int16 *)(a4 + 2);
      if (v45 == 34)
      {
        uint64_t v49 = a3 + 16 * *(char *)(a4 + 24);
        if (*(_WORD *)(v49 + 2) == 5)
        {
          v57[0] = *(void *)(v49 + 8);
          long long v46 = v57;
        }
        else
        {
          long long v46 = (void *)(v49 + 8);
        }
        long long v47 = v17;
        CFNumberType v48 = kCFNumberDoubleType;
      }
      else
      {
        if (v45 != 33)
        {
          StringWithint Value = 0;
          goto LABEL_99;
        }
        if ((*(unsigned char *)(a4 + 28) & 4) != 0)
        {
          uint64_t v51 = *(void *)(a3 + 16 * *(char *)(a4 + 24) + 8);
          v57[0] = 0;
          v57[1] = v51;
          long long v46 = v57;
          long long v47 = v17;
          CFNumberType v48 = kCFNumberMaxType|kCFNumberSInt8Type;
        }
        else
        {
          long long v46 = (void *)(a3 + 16 * *(char *)(a4 + 24) + 8);
          long long v47 = v17;
          CFNumberType v48 = kCFNumberSInt64Type;
        }
      }
      StringWithint Value = CFNumberFormatterCreateStringWithValue(0, v47, v48, v46);
LABEL_99:
      CFNumberFormatterSetFormat(v17, Copy);
      CFRelease(Copy);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
      if (!StringWithValue) {
        return 0;
      }
      if (a7)
      {
        if (*(_WORD *)(a4 + 2) == 33)
        {
          CFIndex v52 = CFStringGetLength(StringWithValue);
          if (v52 < length[0])
          {
            if (v59 == 3)
            {
              long long v53 = CFStringCreateMutableCopy(0, 0, StringWithValue);
              CFStringPad(v53, @" ", length[0], 0);
            }
            else
            {
              long long v53 = CFStringCreateMutable(0, 0);
              uint64_t v55 = length[0];
              CFIndex v56 = CFStringGetLength(StringWithValue);
              CFStringPad(v53, @" ", v55 - v56, 0);
              CFStringAppend(v53, StringWithValue);
            }
            CFRelease(StringWithValue);
            StringWithint Value = v53;
          }
        }
      }
      CFStringAppend(a1, StringWithValue);
      CFRelease(StringWithValue);
      return 1;
    default:
      __CFStringFormatLocalizedNumber_cold_1();
  }
}

void CFNumberFormatterSetProperty(CFNumberFormatterRef formatter, CFNumberFormatterKey key, CFTypeRef value)
{
  uint64_t v45 = *(void *)off_1ECE0A5B0;
  unsigned int valuePtr = 0;
  double v42 = 0.0;
  int v41 = 0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v6 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v6);
  }
  if (CFEqual(@"kCFNumberFormatterFormattingContextKey", key))
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    __cficu_unum_setContext(*((void *)formatter + 2), valuePtr, &v41);
  }
  uint64_t v7 = *((void *)formatter + 4);
  if ((unint64_t)(v7 - 8) < 0xFFFFFFFFFFFFFFFDLL && v7 != 9 || @"kCFNumberFormatterIsLenientKey" == key)
  {
    if (@"kCFNumberFormatterCurrencyCodeKey" == key)
    {
      CFIndex Length = CFStringGetLength((CFStringRef)value);
      if (Length >= 768) {
        CFIndex v14 = 768;
      }
      else {
        CFIndex v14 = Length;
      }
      v46.CFIndex location = 0;
      v46.CFIndex length = v14;
      CFStringGetCharacters((CFStringRef)value, v46, buffer);
      uint64_t v15 = *((void *)formatter + 2);
      unsigned int v16 = 5;
      goto LABEL_59;
    }
    if (@"kCFNumberFormatterDecimalSeparatorKey" == key)
    {
      CFIndex v17 = CFStringGetLength((CFStringRef)value);
      if (v17 >= 768) {
        CFIndex v18 = 768;
      }
      else {
        CFIndex v18 = v17;
      }
      v47.CFIndex location = 0;
      v47.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v47, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 0;
      goto LABEL_109;
    }
    if (@"kCFNumberFormatterCurrencyDecimalSeparatorKey" == key)
    {
      CFIndex v21 = CFStringGetLength((CFStringRef)value);
      if (v21 >= 768) {
        CFIndex v18 = 768;
      }
      else {
        CFIndex v18 = v21;
      }
      v48.CFIndex location = 0;
      v48.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v48, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 10;
      goto LABEL_109;
    }
    if (@"kCFNumberFormatterAlwaysShowDecimalSeparatorKey" == key)
    {
      uint64_t v11 = *((void *)formatter + 2);
      uint64_t v10 = &__kCFBooleanTrue == value;
      int v12 = 2;
      goto LABEL_74;
    }
    if (@"kCFNumberFormatterGroupingSeparatorKey" == key)
    {
      CFIndex v22 = CFStringGetLength((CFStringRef)value);
      if (v22 >= 768) {
        CFIndex v18 = 768;
      }
      else {
        CFIndex v18 = v22;
      }
      v49.CFIndex location = 0;
      v49.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v49, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 1;
      goto LABEL_109;
    }
    if (@"kCFNumberFormatterUseGroupingSeparatorKey" == key)
    {
      uint64_t v11 = *((void *)formatter + 2);
      uint64_t v10 = &__kCFBooleanTrue == value;
      int v12 = 1;
      goto LABEL_74;
    }
    if (@"kCFNumberFormatterPercentSymbolKey" == key)
    {
      CFIndex v23 = CFStringGetLength((CFStringRef)value);
      if (v23 >= 768) {
        CFIndex v18 = 768;
      }
      else {
        CFIndex v18 = v23;
      }
      v50.CFIndex location = 0;
      v50.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v50, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 3;
      goto LABEL_109;
    }
    if (@"kCFNumberFormatterZeroSymbolKey" == key)
    {
      CFIndex v24 = (const void *)*((void *)formatter + 9);
      if (value) {
        CFTypeRef v25 = CFRetain(value);
      }
      else {
        CFTypeRef v25 = 0;
      }
      *((void *)formatter + 9) = v25;
      if (!v24) {
        goto LABEL_110;
      }
    }
    else
    {
      if (@"kCFNumberFormatterNaNSymbolKey" == key)
      {
        CFIndex v26 = CFStringGetLength((CFStringRef)value);
        if (v26 >= 768) {
          CFIndex v18 = 768;
        }
        else {
          CFIndex v18 = v26;
        }
        v51.CFIndex location = 0;
        v51.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v51, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 15;
        goto LABEL_109;
      }
      if (@"kCFNumberFormatterInfinitySymbolKey" == key)
      {
        CFIndex v27 = CFStringGetLength((CFStringRef)value);
        if (v27 >= 768) {
          CFIndex v18 = 768;
        }
        else {
          CFIndex v18 = v27;
        }
        v52.CFIndex location = 0;
        v52.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v52, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 14;
        goto LABEL_109;
      }
      if (@"kCFNumberFormatterMinusSignKey" == key)
      {
        CFIndex v28 = CFStringGetLength((CFStringRef)value);
        if (v28 >= 768) {
          CFIndex v18 = 768;
        }
        else {
          CFIndex v18 = v28;
        }
        v53.CFIndex location = 0;
        v53.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v53, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 6;
        goto LABEL_109;
      }
      if (@"kCFNumberFormatterPlusSignKey" == key)
      {
        CFIndex v29 = CFStringGetLength((CFStringRef)value);
        if (v29 >= 768) {
          CFIndex v18 = 768;
        }
        else {
          CFIndex v18 = v29;
        }
        v54.CFIndex location = 0;
        v54.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v54, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 7;
        goto LABEL_109;
      }
      if (@"kCFNumberFormatterCurrencySymbolKey" == key)
      {
        CFIndex v30 = CFStringGetLength((CFStringRef)value);
        if (v30 >= 768) {
          CFIndex v18 = 768;
        }
        else {
          CFIndex v18 = v30;
        }
        v55.CFIndex location = 0;
        v55.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v55, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 8;
        goto LABEL_109;
      }
      if (@"kCFNumberFormatterExponentSymbolKey" == key)
      {
        CFIndex v31 = CFStringGetLength((CFStringRef)value);
        if (v31 >= 768) {
          CFIndex v18 = 768;
        }
        else {
          CFIndex v18 = v31;
        }
        v56.CFIndex location = 0;
        v56.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v56, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 11;
        goto LABEL_109;
      }
      if (@"kCFNumberFormatterMinIntegerDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 4;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterMaxIntegerDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 3;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterMinFractionDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 7;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterMaxFractionDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 6;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterGroupingSizeKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 10;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterSecondaryGroupingSizeKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 15;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterRoundingModeKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 11;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterRoundingIncrementKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberDoubleType, &v42);
        __cficu_unum_setDoubleAttribute(*((void *)formatter + 2), 12, v42);
        goto LABEL_110;
      }
      if (@"kCFNumberFormatterFormatWidthKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 13;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterPaddingPositionKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 14;
        goto LABEL_74;
      }
      if (@"kCFNumberFormatterPaddingCharacterKey" == key)
      {
        CFIndex v32 = CFStringGetLength((CFStringRef)value);
        if (v32 >= 768) {
          CFIndex v14 = 768;
        }
        else {
          CFIndex v14 = v32;
        }
        v57.CFIndex location = 0;
        v57.CFIndex length = v14;
        CFStringGetCharacters((CFStringRef)value, v57, buffer);
        uint64_t v15 = *((void *)formatter + 2);
        unsigned int v16 = 4;
        goto LABEL_59;
      }
      if (@"kCFNumberFormatterDefaultFormatKey" == key) {
        goto LABEL_110;
      }
      if (@"kCFNumberFormatterMultiplierKey" != key)
      {
        if (@"kCFNumberFormatterPositivePrefixKey" == key)
        {
          CFIndex v34 = CFStringGetLength((CFStringRef)value);
          if (v34 >= 768) {
            CFIndex v14 = 768;
          }
          else {
            CFIndex v14 = v34;
          }
          v58.CFIndex location = 0;
          v58.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v58, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 0;
        }
        else if (@"kCFNumberFormatterPositiveSuffixKey" == key)
        {
          CFIndex v35 = CFStringGetLength((CFStringRef)value);
          if (v35 >= 768) {
            CFIndex v14 = 768;
          }
          else {
            CFIndex v14 = v35;
          }
          v59.CFIndex location = 0;
          v59.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v59, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 1;
        }
        else if (@"kCFNumberFormatterNegativePrefixKey" == key)
        {
          CFIndex v36 = CFStringGetLength((CFStringRef)value);
          if (v36 >= 768) {
            CFIndex v14 = 768;
          }
          else {
            CFIndex v14 = v36;
          }
          v60.CFIndex location = 0;
          v60.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v60, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 2;
        }
        else
        {
          if (@"kCFNumberFormatterNegativeSuffixKey" != key)
          {
            if (@"kCFNumberFormatterPerMillSymbolKey" == key)
            {
              CFIndex v38 = CFStringGetLength((CFStringRef)value);
              if (v38 >= 768) {
                CFIndex v18 = 768;
              }
              else {
                CFIndex v18 = v38;
              }
              v62.CFIndex location = 0;
              v62.CFIndex length = v18;
              CFStringGetCharacters((CFStringRef)value, v62, buffer);
              uint64_t v19 = *((void *)formatter + 2);
              unsigned int v20 = 12;
            }
            else if (@"kCFNumberFormatterInternationalCurrencySymbolKey" == key)
            {
              CFIndex v39 = CFStringGetLength((CFStringRef)value);
              if (v39 >= 768) {
                CFIndex v18 = 768;
              }
              else {
                CFIndex v18 = v39;
              }
              v63.CFIndex location = 0;
              v63.CFIndex length = v18;
              CFStringGetCharacters((CFStringRef)value, v63, buffer);
              uint64_t v19 = *((void *)formatter + 2);
              unsigned int v20 = 9;
            }
            else
            {
              if (@"kCFNumberFormatterCurrencyGroupingSeparatorKey" != key)
              {
                if (@"kCFNumberFormatterIsLenientKey" == key)
                {
                  uint64_t v10 = &__kCFBooleanTrue == value;
                  *((unsigned char *)formatter + 80) = v10;
                  uint64_t v11 = *((void *)formatter + 2);
                  int v12 = 19;
                }
                else if (@"kCFNumberFormatterUseSignificantDigitsKey" == key)
                {
                  uint64_t v11 = *((void *)formatter + 2);
                  uint64_t v10 = &__kCFBooleanTrue == value;
                  int v12 = 16;
                }
                else if (@"kCFNumberFormatterMinSignificantDigitsKey" == key)
                {
                  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                  uint64_t v11 = *((void *)formatter + 2);
                  uint64_t v10 = valuePtr;
                  int v12 = 17;
                }
                else
                {
                  if (@"kCFNumberFormatterMaxSignificantDigitsKey" != key)
                  {
                    if (@"kCFNumberFormatterUsesCharacterDirectionKey" != key)
                    {
                      if (@"kCFNumberFormatterMinGroupingDigitsKey" != key) {
                        goto LABEL_110;
                      }
                      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                      uint64_t v10 = valuePtr;
                      if (valuePtr == -1)
                      {
                        uint64_t v10 = 4294967294;
                        unsigned int valuePtr = -2;
                      }
                      uint64_t v11 = *((void *)formatter + 2);
                      int v12 = 22;
                      goto LABEL_74;
                    }
                    *((unsigned char *)formatter + 82) = &__kCFBooleanTrue == value;
LABEL_110:
                    if (_CFExecutableLinkedOnOrAfter(6uLL)) {
                      CFNumberFormatterGetFormat(formatter);
                    }
                    return;
                  }
                  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                  uint64_t v11 = *((void *)formatter + 2);
                  uint64_t v10 = valuePtr;
                  int v12 = 18;
                }
LABEL_74:
                __cficu_unum_setAttribute(v11, v12, v10);
                goto LABEL_110;
              }
              CFIndex v40 = CFStringGetLength((CFStringRef)value);
              if (v40 >= 768) {
                CFIndex v18 = 768;
              }
              else {
                CFIndex v18 = v40;
              }
              v64.CFIndex location = 0;
              v64.CFIndex length = v18;
              CFStringGetCharacters((CFStringRef)value, v64, buffer);
              uint64_t v19 = *((void *)formatter + 2);
              unsigned int v20 = 17;
            }
LABEL_109:
            __cficu_unum_setSymbol(v19, v20, buffer, v18, &v41);
            goto LABEL_110;
          }
          CFIndex v37 = CFStringGetLength((CFStringRef)value);
          if (v37 >= 768) {
            CFIndex v14 = 768;
          }
          else {
            CFIndex v14 = v37;
          }
          v61.CFIndex location = 0;
          v61.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v61, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 3;
        }
LABEL_59:
        __cficu_unum_setTextAttribute(v15, v16, buffer, v14, &v41);
        goto LABEL_110;
      }
      CFIndex v24 = (const void *)*((void *)formatter + 8);
      if (value) {
        CFTypeRef v33 = CFRetain(value);
      }
      else {
        CFTypeRef v33 = 0;
      }
      *((void *)formatter + 8) = v33;
      *((unsigned char *)formatter + 81) = value != 0;
      if (!v24) {
        goto LABEL_110;
      }
    }
    CFRelease(v24);
    goto LABEL_110;
  }
}

CFStringRef CFNumberFormatterGetFormat(CFNumberFormatterRef formatter)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  unint64_t v3 = *((void *)formatter + 4) - 5;
  if (v3 < 5 && ((0x17u >> v3) & 1) != 0) {
    return 0;
  }
  int v12 = 0;
  int v4 = __cficu_unum_toPattern(*((void *)formatter + 2), 0, chars, 768, &v12);
  if (v12 <= 0)
  {
    int v5 = v4;
    if (v4 <= 768)
    {
      CFAllocatorRef v6 = CFGetAllocator(formatter);
      CFStringRef v7 = CFStringCreateWithCharacters(v6, chars, v5);
      if (v7)
      {
        CFStringRef v8 = v7;
        CFStringRef v9 = (const void *)*((void *)formatter + 5);
        if (v9)
        {
          if (CFEqual(v7, v9))
          {
            CFRelease(v8);
            return (CFStringRef)*((void *)formatter + 5);
          }
          CFRelease(*((CFTypeRef *)formatter + 5));
        }
        *((void *)formatter + 5) = v8;
        uint64_t v11 = (const void *)*((void *)formatter + 7);
        if (v11)
        {
          CFRelease(v11);
          CFStringRef v8 = (const __CFString *)*((void *)formatter + 5);
        }
        *((void *)formatter + 7) = __CFNumberFormatterCreateCompressedString(v8, 1, 0);
      }
    }
  }
  return (CFStringRef)*((void *)formatter + 5);
}

uint64_t __cficu_unum_toPattern(uint64_t a1, int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t v10 = unum_toPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    int v12 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v13 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a3, a4);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0) {
      CFStringRef v15 = CFStringCreateWithCharacters(0, a3, (int)v10);
    }
    else {
      CFStringRef v15 = 0;
    }
    ___CFICULogWithArguments(1, @"unum_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@",
      v11,
      a2,
      v13,
      a4,
      v12,
      v10,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(v14);
  }
  return v10;
}

CFNumberRef CFNumberFormatterCreateNumberFromString(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFOptionFlags options)
{
  char v5 = options;
  CFAllocatorRef v9 = allocator;
  valuePtr[2] = *(void *)off_1ECE0A5B0;
  if (!allocator)
  {
    uint64_t v10 = _CFGetTSD(1u);
    if (v10) {
      CFAllocatorRef v9 = (const __CFAllocator *)v10;
    }
    else {
      CFAllocatorRef v9 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v11 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v11 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v11);
  }
  if (rangep)
  {
    CFRange rangepa = *rangep;
  }
  else
  {
    rangepa.CFIndex location = 0;
    rangepa.CFIndex length = CFStringGetLength(string);
  }
  CFNumberRef v12 = (const __CFNumber *)*((void *)formatter + 8);
  *((void *)formatter + 8) = 0;
  int ValueFromString = CFNumberFormatterGetValueFromString(formatter, string, &rangepa, kCFNumberSInt64Type, valuePtr);
  *((void *)formatter + 8) = v12;
  if (!ValueFromString) {
    goto LABEL_29;
  }
  if (v12)
  {
    uint64_t v14 = valuePtr[0];
    double v34 = 1.0;
    if (CFNumberGetValue(v12, kCFNumberFloat64Type, &v34)) {
      double v15 = v34;
    }
    else {
      double v15 = 1.0;
    }
    if (v14 >= 0) {
      uint64_t v16 = v14;
    }
    else {
      uint64_t v16 = -v14;
    }
    double v17 = fabs(v15);
    if (v17 > (double)v16 || v17 < 1.0) {
      goto LABEL_29;
    }
    if (modf(v15, &__y) == 0.0)
    {
      uint64_t v19 = v14 / (uint64_t)v15;
      if (v14 % (uint64_t)v15) {
        goto LABEL_29;
      }
    }
    else if (v15 == -1.0)
    {
      uint64_t v19 = -v14;
    }
    else
    {
      if (v15 == 1.0) {
        goto LABEL_27;
      }
      double v32 = 0.0;
      int v24 = -1;
      do
        long double v25 = scalbn(v15, ++v24);
      while (modf(v25, &v32) != 0.0);
      for (uint64_t i = (uint64_t)v32; ; i *= 2)
      {
        unint64_t v27 = i >= 0 ? i : -i;
        if (v27 >> 50) {
          break;
        }
        LOBYTE(v24) = v24 + 1;
      }
      if ((unint64_t)v16 >> 53)
      {
        uint64_t v28 = 0;
        uint64_t v29 = v14;
        do
        {
          uint64_t v14 = v29 - i;
          uint64_t v30 = v29 - i;
          v28 += 1 << v24;
          if (v30 < 0) {
            uint64_t v30 = -v30;
          }
          unint64_t v31 = (unint64_t)v30 >> 53;
          uint64_t v29 = v14;
        }
        while (v31);
      }
      else
      {
        uint64_t v28 = 0;
      }
      if (fmod((double)v14, v15) != 0.0) {
        goto LABEL_29;
      }
      uint64_t v19 = v28 + (uint64_t)((double)v14 / v15);
    }
    valuePtr[0] = v19;
  }
LABEL_27:
  CFIndex length = rangepa.length;
  CFIndex v21 = CFStringGetLength(string);
  if ((v5 & 1) != 0 || length == v21)
  {
    if (rangep) {
      *rangep = rangepa;
    }
    CFNumberType v22 = kCFNumberSInt64Type;
    return CFNumberCreate(v9, v22, valuePtr);
  }
LABEL_29:
  if (v5) {
    return 0;
  }
  CFNumberType v22 = kCFNumberFloat64Type;
  if (!CFNumberFormatterGetValueFromString(formatter, string, rangep, kCFNumberFloat64Type, valuePtr)) {
    return 0;
  }
  return CFNumberCreate(v9, v22, valuePtr);
}

Boolean CFNumberFormatterGetValueFromString(CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFNumberType numberType, void *valuePtr)
{
  CFRange v56 = valuePtr;
  CFStringRef theString = string;
  v62[128] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v8 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v8);
  }
  if (*((unsigned char *)formatter + 80)) {
    CFStringRef CompressedString = __CFNumberFormatterCreateCompressedString(theString, 0, &rangep->location);
  }
  else {
    CFStringRef CompressedString = (const __CFString *)CFRetain(theString);
  }
  CFStringRef v10 = CompressedString;
  if (*((unsigned char *)formatter + 80))
  {
    CFIndex Length = CFStringGetLength(CompressedString);
    CFIndex location = 0;
  }
  else
  {
    if (rangep)
    {
      CFIndex location = rangep->location;
      CFIndex Length = rangep->length;
    }
    else
    {
      CFIndex Length = CFStringGetLength(CompressedString);
      CFIndex location = 0;
    }
    CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
    if (Length >= 1)
    {
      CFCharacterSetRef v36 = Predefined;
      while (1)
      {
        UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(v10, location);
        if (!CFCharacterSetIsCharacterMember(v36, CharacterAtIndex)) {
          break;
        }
        ++location;
        BOOL v33 = Length-- <= 1;
        if (v33)
        {
          CFIndex Length = 0;
          break;
        }
      }
    }
  }
  CFStringRef v13 = (const __CFString *)*((void *)formatter + 9);
  CFRange v58 = rangep;
  if (v13)
  {
    if (*((unsigned char *)formatter + 80)) {
      CFStringRef v14 = __CFNumberFormatterCreateCompressedString(v13, 0, 0);
    }
    else {
      CFStringRef v14 = (const __CFString *)CFRetain(v13);
    }
    CFStringRef v16 = v14;
    BOOL v15 = CFEqual(v10, v14);
    CFRelease(v16);
  }
  else
  {
    BOOL v15 = 0;
  }
  if ((Length & ~(Length >> 63)) >= 1024) {
    CFIndex v17 = 1024;
  }
  else {
    CFIndex v17 = Length & ~(Length >> 63);
  }
  CharactersPtr = CFStringGetCharactersPtr(v10);
  uint64_t v20 = MEMORY[0x1F4188790](CharactersPtr, v19);
  CFNumberType v22 = (UChar *)((char *)&v52 - v21);
  if (v20)
  {
    if (!*((unsigned char *)formatter + 80))
    {
      CFNumberType v22 = (UChar *)(v20 + 2 * location);
      CFIndex v23 = (const __CFNumber **)((char *)formatter + 64);
      CFNumberRef v57 = (const __CFNumber *)*((void *)formatter + 8);
LABEL_26:
      *CFIndex v23 = 0;
      goto LABEL_27;
    }
    CFIndex v23 = (const __CFNumber **)((char *)formatter + 64);
    CFNumberRef v57 = (const __CFNumber *)*((void *)formatter + 8);
    *((void *)formatter + 8) = 0;
    CFNumberType v22 = (UChar *)v20;
LABEL_23:
    __CFNumberFormatterApplyPattern((uint64_t)formatter, *((CFStringRef *)formatter + 7));
    long double v25 = (const void *)*((void *)formatter + 8);
    if (v25) {
      CFRelease(v25);
    }
    goto LABEL_26;
  }
  if (!v17)
  {
    if (v10) {
      CFRelease(v10);
    }
    return 0;
  }
  v63.CFIndex location = location;
  v63.CFIndex length = v17;
  CFStringGetCharacters(v10, v63, (UniChar *)((char *)&v52 - v21));
  CFIndex v23 = (const __CFNumber **)((char *)formatter + 64);
  CFNumberRef v57 = (const __CFNumber *)*((void *)formatter + 8);
  int v24 = *((unsigned __int8 *)formatter + 80);
  *((void *)formatter + 8) = 0;
  if (v24) {
    goto LABEL_23;
  }
LABEL_27:
  BOOL v26 = (unint64_t)numberType <= kCFNumberCFIndexType && ((1 << numberType) & 0x4F9E) != 0;
  __cficu_unum_setAttribute(*((void *)formatter + 2), 0, v26);
  uint64_t v61 = 0;
  if (v15)
  {
    uint64_t v27 = 0;
    HIDWORD(v61) = CFStringGetLength(v10);
    double v28 = 0.0;
    uint64_t v29 = v58;
  }
  else
  {
    CFRange v55 = v23;
    bzero(v62, 0x400uLL);
    int v30 = __cficu_unum_parseDecimal(*((void *)formatter + 2), v22, v17, (unsigned int *)&v61 + 1, (const UInt8 *)v62, 1024, (int *)&v61);
    int v31 = v30;
    int v32 = v61;
    BOOL v33 = (int)v61 >= 1 || v30 <= 0;
    if (!v33 && v26)
    {
      CFRange v60 = 0;
      *__error() = 0;
      uint64_t v27 = strtoll_l((const char *)v62, &v60, 10, 0);
      if (*__error() || *v60)
      {
        int v32 = 3;
        LODWORD(v61) = 3;
      }
      else
      {
        int v32 = v61;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    uint64_t v29 = v58;
    double v28 = 0.0;
    if (v32 > 0)
    {
      CFIndex v23 = v55;
    }
    else
    {
      BOOL v33 = v31 < 1;
      CFIndex v23 = v55;
      if (!v33)
      {
        CFRange v60 = 0;
        *__error() = 0;
        double v28 = strtod_l((const char *)v62, &v60, 0);
        if (*__error() || *v60) {
          LODWORD(v61) = 3;
        }
      }
    }
  }
  if (*((unsigned char *)formatter + 80))
  {
    if (v29)
    {
      CFIndex v38 = v29->location;
      if (SHIDWORD(v61) >= 1)
      {
        uint64_t v53 = v27;
        CFNumberType v54 = numberType;
        CFRange v55 = v23;
        uint64_t v39 = 0;
        CFIndex v40 = v29->length + v38;
        while (v38 < v40)
        {
          CFIndex v41 = v38;
          while (1)
          {
            int v42 = v22[v39];
            int v43 = CFStringGetCharacterAtIndex(theString, v41);
            CFCharacterSetRef v44 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
            int v45 = CFCharacterSetIsCharacterMember(v44, v43) ? 32 : v43;
            CFIndex v38 = v41 + 1;
            if (v42 == v45) {
              break;
            }
            ++v41;
            if (v40 == v38)
            {
              CFIndex v38 = v40;
              numberType = v54;
              goto LABEL_74;
            }
          }
          ++v39;
          numberType = v54;
          if (v39 >= SHIDWORD(v61))
          {
            CFIndex v38 = v41 + 1;
            break;
          }
        }
LABEL_74:
        uint64_t v29 = v58;
        CFIndex v23 = v55;
        uint64_t v27 = v53;
      }
      v29->CFIndex length = v38 - v29->location;
    }
    __CFNumberFormatterApplyPattern((uint64_t)formatter, *((CFStringRef *)formatter + 5));
    CFRange v46 = (const void *)*((void *)formatter + 8);
    if (v46) {
      CFRelease(v46);
    }
  }
  else if (v29)
  {
    v29->CFIndex length = location - v29->location + SHIDWORD(v61);
  }
  *CFIndex v23 = v57;
  CFRelease(v10);
  if ((int)v61 > 0) {
    return 0;
  }
  CFNumberRef v48 = *v23;
  if (*v23)
  {
    v62[0] = 0x3FF0000000000000;
    int Value = CFNumberGetValue(v48, kCFNumberFloat64Type, v62);
    double v50 = *(double *)v62;
    if (!Value) {
      double v50 = 1.0;
    }
    uint64_t v27 = (uint64_t)((double)v27 / v50);
    double v28 = v28 / v50;
  }
  switch(numberType)
  {
    case kCFNumberSInt8Type:
    case kCFNumberCharType:
      if (v27 != (char)v27) {
        return 0;
      }
      *CFRange v56 = v27;
      return 1;
    case kCFNumberSInt16Type:
    case kCFNumberShortType:
      if (v27 != (__int16)v27) {
        return 0;
      }
      *(_WORD *)CFRange v56 = v27;
      return 1;
    case kCFNumberSInt32Type:
    case kCFNumberIntType:
      if (v27 != (int)v27) {
        return 0;
      }
      *(_DWORD *)CFRange v56 = v27;
      return 1;
    case kCFNumberSInt64Type:
    case kCFNumberLongType:
    case kCFNumberLongLongType:
    case kCFNumberCFIndexType:
      *(void *)CFRange v56 = v27;
      return 1;
    case kCFNumberFloat32Type:
    case kCFNumberFloatType:
      Boolean result = 0;
      if (v28 < -3.40282347e38 || v28 > 3.40282347e38) {
        return result;
      }
      float v51 = v28;
      *(float *)CFRange v56 = v51;
      break;
    case kCFNumberFloat64Type:
    case kCFNumberDoubleType:
      Boolean result = 0;
      if (v28 < -1.79769313e308 || v28 > 1.79769313e308) {
        return result;
      }
      *(double *)CFRange v56 = v28;
      break;
    default:
      return 0;
  }
  return 1;
}

void __cficu_unum_setAttribute(uint64_t a1, int a2, uint64_t a3)
{
  unum_setAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v7 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, @"unum_setAttribute(%@, %s, %d);", v6, v7, a3);
    CFRelease(v6);
  }
}

uint64_t __cficu_unum_parseDecimal(uint64_t a1, UChar *a2, uint64_t a3, unsigned int *a4, const UInt8 *a5, uint64_t a6, int *a7)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v14 = ___CFICUCreateArgumentForParsePosition(a4);
    uint64_t v15 = unum_parseDecimal();
    CFStringRef v16 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFIndex v17 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    CFStringRef v18 = ___CFICUCreateErrorStringWithComment(a7, 0);
    if (*a7 <= 0) {
      CFStringRef v19 = CFStringCreateWithBytes(0, a5, (int)v15, 0x8000100u, 0);
    }
    else {
      CFStringRef v19 = 0;
    }
    CFStringRef v21 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    CFNumberType v22 = (const void *)___CFICUCreateVariableName((uint64_t)"result");
    ___CFICULogWithArguments(1, @"char %@[%d];", v22, a6);
    ___CFICULogWithArguments(1, @"unum_parseDecimal(%@, %@, %d, %@, %@, %d, &%@); // %d %@ %@",
      v16,
      v21,
      a3,
      v14,
      v22,
      a6,
      v17,
      v15,
      v19,
      v18);
    CFRelease(v16);
    CFRelease(v17);
    CFRelease(v22);
    CFRelease(v14);
    if (v19) {
      CFRelease(v19);
    }
    CFRelease(v21);
    CFRelease(v18);
    return v15;
  }
  else
  {
    return unum_parseDecimal();
  }
}

__CFString *__CFNumberFormatterCreateCompressedString(CFStringRef theString, int a2, CFIndex *a3)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  if (!theString) {
    return 0;
  }
  if (a3)
  {
    CFIndex v5 = *a3;
    CFIndex Length = a3[1];
  }
  else
  {
    CFIndex Length = CFStringGetLength(theString);
    CFIndex v5 = 0;
  }
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  CFCharacterSetRef v8 = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  if (Length >= 1)
  {
    CFCharacterSetRef theSet = v8;
    BOOL v9 = 0;
    UniChar v10 = 0;
    CFIndex v11 = Length + v5;
    do
    {
      UniChar chars = 0;
      int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, v5);
      CFCharacterSetRef v13 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      if (CFCharacterSetIsCharacterMember(v13, CharacterAtIndex)) {
        int v14 = 32;
      }
      else {
        int v14 = CharacterAtIndex;
      }
      UniChar chars = v14;
      if (++v5 >= Length)
      {
        UniChar v15 = 0;
      }
      else
      {
        UniChar v15 = CFStringGetCharacterAtIndex(theString, v5);
        int v14 = chars;
      }
      if (v14 == 39 && a2 != 0) {
        BOOL v9 = !v9;
      }
      if (v9
        || v14 != 32
        || CFCharacterSetIsCharacterMember(Predefined, v10) && CFCharacterSetIsCharacterMember(Predefined, v15)
        || CFCharacterSetIsCharacterMember(theSet, v10) && CFCharacterSetIsCharacterMember(theSet, v15))
      {
        CFStringAppendCharacters(Mutable, &chars, 1);
        UniChar v10 = chars;
      }
    }
    while (v5 < v11);
  }
  return Mutable;
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  if ((unint64_t)(theSetIdentifier - 16) <= 0xFFFFFFFFFFFFFFF0) {
    CFCharacterSetGetPredefined_cold_1();
  }
  return (CFCharacterSetRef)(&__CFBuiltinSets + 6 * theSetIdentifier - 6);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString appendCharacters:chars length:numChars];
    return;
  }
  p_info = &theString->info;
  char v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 1) == 0)
  {
    CFCharacterSetRef v8 = _CFOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      CFStringAppendCharacters_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    return;
  }
  char v16 = atomic_load((unint64_t *)p_info);
  uint64_t v17 = v16 & 5;
  char v18 = atomic_load((unint64_t *)p_info);
  uint64_t v19 = v18 & 0x60;
  if (v17 == 4)
  {
    p_data = &theString->data;
    if (v19)
    {
      uint64_t v21 = *p_data;
    }
    else
    {
      uint64_t v23 = atomic_load((unint64_t *)&theString->info);
      uint64_t v21 = (char *)&p_data[(v23 & 5) != 4];
    }
    uint64_t length = *v21;
  }
  else if ((v18 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }
  else
  {
    uint64_t length = (uint64_t)theString->data;
  }
  char v24 = atomic_load((unint64_t *)&theString->info);
  if ((v24 & 0x10) != 0)
  {
    uint64_t v41 = length;
    uint64_t v42 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, numChars, 1);
    char v31 = atomic_load((unint64_t *)&theString->info);
    int v30 = &theString->data;
    if ((v31 & 0x60) == 0)
    {
      double v28 = &theString->info;
LABEL_33:
      char v36 = atomic_load((unint64_t *)v28);
      int v32 = (char *)&v30[(v36 & 5) != 4];
      goto LABEL_34;
    }
LABEL_28:
    int v32 = *v30;
LABEL_34:
    memmove(&v32[2 * length], chars, 2 * numChars);
    return;
  }
  if (numChars < 1)
  {
    uint64_t v41 = length;
    uint64_t v42 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, numChars, 0);
  }
  else
  {
    CFIndex v25 = 0;
    do
      unsigned int v26 = chars[v25++];
    while (v26 <= 0x7F && v25 < numChars);
    uint64_t v41 = length;
    uint64_t v42 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, numChars, v26 > 0x7F);
    if (v26 >= 0x80)
    {
      double v28 = &theString->info;
      char v29 = atomic_load((unint64_t *)&theString->info);
      int v30 = &theString->data;
      if ((v29 & 0x60) == 0) {
        goto LABEL_33;
      }
      goto LABEL_28;
    }
  }
  char v33 = atomic_load((unint64_t *)&theString->info);
  double v34 = &theString->data;
  if ((v33 & 0x60) != 0)
  {
    CFIndex v35 = *v34;
  }
  else
  {
    char v37 = atomic_load((unint64_t *)&theString->info);
    CFIndex v35 = (char *)&v34[(v37 & 5) != 4];
  }
  unint64_t v38 = atomic_load((unint64_t *)&theString->info);
  if (numChars >= 1)
  {
    uint64_t v39 = &v35[length + ((v38 >> 2) & 1)];
    do
    {
      char v40 = *(unsigned char *)chars++;
      *v39++ = v40;
      --numChars;
    }
    while (numChars);
  }
}

CFLocaleRef CFNumberFormatterGetLocale(CFNumberFormatterRef formatter)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  return (CFLocaleRef)*((void *)formatter + 3);
}

void CFNumberFormatterSetFormat(CFNumberFormatterRef formatter, CFStringRef formatString)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v4);
  }
  unint64_t v5 = *((void *)formatter + 4);
  BOOL v6 = v5 > 9;
  uint64_t v7 = (1 << v5) & 0x2E0;
  if (v6 || v7 == 0)
  {
    CFIndex Length = CFStringGetLength(formatString);
    uint64_t v10 = (const void *)*((void *)formatter + 5);
    if (v10)
    {
      if (CFEqual(v10, formatString) || Length >= 1025) {
        return;
      }
    }
    else if (Length > 1024)
    {
      return;
    }
    if ((int)__CFNumberFormatterApplyPattern((uint64_t)formatter, formatString) <= 0)
    {
      int v16 = 0;
      int v11 = __cficu_unum_toPattern(*((void *)formatter + 2), 0, chars, 768, &v16);
      if (v16 <= 0)
      {
        int v12 = v11;
        if (v11 <= 768)
        {
          uint64_t v13 = (const void *)*((void *)formatter + 5);
          if (v13) {
            CFRelease(v13);
          }
          CFAllocatorRef v14 = CFGetAllocator(formatter);
          CFStringRef v15 = CFStringCreateWithCharacters(v14, chars, v12);
          *((void *)formatter + 5) = v15;
          if (*((void *)formatter + 7))
          {
            CFRelease(*((CFTypeRef *)formatter + 7));
            CFStringRef v15 = (const __CFString *)*((void *)formatter + 5);
          }
          *((void *)formatter + 7) = __CFNumberFormatterCreateCompressedString(v15, 1, 0);
        }
      }
    }
  }
}

void __cficu_unum_setTextAttribute(uint64_t a1, unsigned int a2, UChar *a3, uint64_t a4, int *a5)
{
  unum_setTextAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v10 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    int v11 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a5, 1);
    CFStringRef v13 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    CFStringRef v14 = v13;
    if (a2 > 7) {
      CFStringRef v15 = "<unknown UNumberFormatTextAttribute>";
    }
    else {
      CFStringRef v15 = off_1ECDFE460[a2];
    }
    ___CFICULogWithArguments(1, @"unum_setTextAttribute(%@, %s, %@, %d, &%@); %@", v10, v15, v13, a4, v11, v12);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v14);
    CFRelease(v12);
  }
}

uint64_t __CFNumberFormatterApplyPattern(uint64_t a1, CFStringRef theString)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  unint64_t v4 = *(void *)(a1 + 32) - 5;
  if (v4 < 5 && ((0x17u >> v4) & 1) != 0) {
    return 16;
  }
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v7 = Length;
  size_t v8 = 2 * Length;
  if ((unint64_t)(2 * Length) < 0x101)
  {
    if (Length < 1)
    {
      uint64_t v9 = 0;
    }
    else
    {
      MEMORY[0x1F4188790](Length, v6);
      uint64_t v9 = (char *)&valuePtr - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v9, v8);
    }
  }
  else
  {
    uint64_t v9 = (char *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
  }
  CharactersPtr = (UChar *)CFStringGetCharactersPtr(theString);
  if (!CharactersPtr)
  {
    v17.CFIndex location = 0;
    v17.uint64_t length = v7;
    CFStringGetCharacters(theString, v17, (UniChar *)v9);
    CharactersPtr = (UChar *)v9;
  }
  unsigned int v15 = 0;
  __cficu_unum_applyPattern(*(void *)(a1 + 16), 0, CharactersPtr, v7, 0, (int *)&v15);
  if (v8 >= 0x101) {
    free(v9);
  }
  if (!*(unsigned char *)(a1 + 81))
  {
    CFStringRef v12 = *(const void **)(a1 + 64);
    if (v12) {
      CFRelease(v12);
    }
    *(void *)(a1 + 64) = 0;
    int valuePtr = __cficu_unum_getAttribute(*(void *)(a1 + 16), 9);
    if (valuePtr == 1) {
      return v15;
    }
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
    *(void *)(a1 + 64) = CFNumberCreate(v13, kCFNumberSInt32Type, &valuePtr);
  }
  __cficu_unum_setAttribute(*(void *)(a1 + 16), 9, 1);
  return v15;
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  unint64_t v5 = (__objc2_class **)allocator;
  uint64_t v47 = *(void *)off_1ECE0A5B0;
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      unint64_t v5 = (__objc2_class **)v6;
    }
    else {
      unint64_t v5 = &__kCFAllocatorSystemDefault;
    }
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v5, 0x39uLL, 72, 0);
  if (Instance)
  {
    if (!locale) {
      locale = CFLocaleGetSystem();
    }
    *(void *)(Instance + 32) = style;
    if ((unint64_t)style >= (kCFNumberFormatterCurrencyAccountingStyle|kCFNumberFormatterDecimalStyle))
    {
      unsigned int v8 = 1;
      *(void *)(Instance + 32) = 1;
      if (locale) {
        goto LABEL_10;
      }
    }
    else
    {
      unsigned int v8 = dword_182DA119C[style];
      if (locale)
      {
LABEL_10:
        CFStringRef Identifier = CFLocaleGetIdentifier(locale);
        goto LABEL_13;
      }
    }
    CFStringRef Identifier = &stru_1ECE10768;
LABEL_13:
    CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr && (CStringPtr = buffer, !CFStringGetCString(Identifier, buffer, 768, 0x600u))
      || (int v41 = 0,
          uint64_t v11 = __cficu_unum_open(v8, 0, 0, (uint64_t)CStringPtr, 0, &v41),
          (*(void *)(Instance + 16) = v11) == 0))
    {
      CFRelease((CFTypeRef)Instance);
      return 0;
    }
    if (style)
    {
      if (locale)
      {
LABEL_18:
        CFLocaleRef System = (void *)CFRetain(locale);
LABEL_22:
        *(void *)(Instance + 24) = System;
        unint64_t v14 = *(void *)(Instance + 32);
        if (v14 > 9 || ((1 << v14) & 0x2E1) == 0)
        {
          CFDictionaryRef AppleICUNumberFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUNumberFormatStringsPref(System, v13);
          if (AppleICUNumberFormatStringsPref)
          {
            CFDictionaryRef v24 = AppleICUNumberFormatStringsPref;
            CFTypeID v25 = CFGetTypeID(AppleICUNumberFormatStringsPref);
            if (v25 == CFDictionaryGetTypeID())
            {
              unint64_t v26 = v14 - 1;
              uint64_t v27 = v26 > 9 ? @"0" : (__CFString *)*((void *)&off_1ECDB0148 + v26);
              CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v24, v27);
              if (Value)
              {
                CFStringRef v29 = Value;
                CFTypeID v30 = CFGetTypeID(Value);
                if (v30 == CFStringGetTypeID())
                {
                  if (v26 > 9) {
                    unsigned int v31 = 0;
                  }
                  else {
                    unsigned int v31 = dword_182DA11C8[v26];
                  }
                  CFStringRef v32 = CFLocaleGetIdentifier(*(CFLocaleRef *)(Instance + 24));
                  char v33 = (void *)CFStringGetCStringPtr(v32, 0x600u);
                  if (!v33)
                  {
                    if (CFStringGetCString(v32, v46, 768, 0x600u)) {
                      char v33 = v46;
                    }
                    else {
                      char v33 = 0;
                    }
                  }
                  int v43 = 0;
                  uint64_t v34 = __cficu_unum_open(v31, 0, 0, (uint64_t)v33, 0, &v43);
                  if (v34)
                  {
                    uint64_t v35 = v34;
                    int v43 = 0;
                    int v36 = __cficu_unum_toPattern(v34, 0, chars, 768, &v43);
                    if (v43 <= 0 && v36 <= 768)
                    {
                      CFStringRef v37 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, v36);
                      int v43 = 0;
                      int v38 = __cficu_unum_toPattern(*(void *)(Instance + 16), 0, chars, 768, &v43);
                      if (v43 <= 0)
                      {
                        int v39 = v38;
                        if (v38 <= 768)
                        {
                          CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                          CFStringAppendCharacters(Mutable, chars, v39);
                          result.CFIndex location = 0;
                          result.uint64_t length = 0;
                          v48.CFIndex location = 0;
                          v48.uint64_t length = v39;
                          if (CFStringFindWithOptions(Mutable, v37, v48, 0, &result))
                          {
                            CFStringReplace(Mutable, result, v29);
                            __CFNumberFormatterApplyPattern(Instance, Mutable);
                          }
                          CFRelease(Mutable);
                        }
                      }
                      CFRelease(v37);
                    }
                    __cficu_unum_close(v35);
                  }
                }
              }
            }
          }
        }
        CFDictionaryRef AppleICUNumberSymbolsPref = (const __CFDictionary *)_CFLocaleGetAppleICUNumberSymbolsPref(*(void **)(Instance + 24), v13);
        if (AppleICUNumberSymbolsPref)
        {
          CFDictionaryRef v16 = AppleICUNumberSymbolsPref;
          CFTypeID v17 = CFGetTypeID(AppleICUNumberSymbolsPref);
          if (v17 == CFDictionaryGetTypeID()) {
            CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)__CFNumberFormatterApplySymbolPrefs, (void *)Instance);
          }
        }
        unint64_t v18 = *(void *)(Instance + 32);
        if (v18 > 9 || ((1 << v18) & 0x2E0) == 0)
        {
          int v41 = 0;
          int v22 = __cficu_unum_toPattern(*(void *)(Instance + 16), 0, chars, 768, &v41);
          if (v41 <= 0 && v22 <= 768) {
            *(void *)(Instance + 40) = CFStringCreateWithCharacters((CFAllocatorRef)v5, chars, v22);
          }
        }
        uint64_t v19 = *(const void **)(Instance + 40);
        if (v19)
        {
          *(void *)(Instance + 48) = CFRetain(v19);
          *(void *)(Instance + 56) = __CFNumberFormatterCreateCompressedString(*(CFStringRef *)(Instance + 40), 1, 0);
        }
        unint64_t v20 = *(void *)(Instance + 32);
        if (v20 > 9 || ((1 << v20) & 0x2E0) == 0)
        {
          *(_DWORD *)UniChar chars = __cficu_unum_getAttribute(*(void *)(Instance + 16), 9);
          if (*(_DWORD *)chars != 1)
          {
            *(void *)(Instance + 64) = CFNumberCreate((CFAllocatorRef)v5, kCFNumberSInt32Type, chars);
            __cficu_unum_setAttribute(*(void *)(Instance + 16), 9, 1);
          }
        }
        __cficu_unum_setAttribute(*(void *)(Instance + 16), 19, 0);
        __cficu_unum_setContext(*(void *)(Instance + 16), 256, &v41);
        return (CFNumberFormatterRef)Instance;
      }
    }
    else
    {
      int v41 = 0;
      __cficu_unum_applyPattern(v11, 0, word_183035FE0, 1, 0, &v41);
      __cficu_unum_setAttribute(*(void *)(Instance + 16), 3, 42);
      __cficu_unum_setAttribute(*(void *)(Instance + 16), 6, 0);
      if (locale) {
        goto LABEL_18;
      }
    }
    CFLocaleRef System = CFLocaleGetSystem();
    goto LABEL_22;
  }
  return (CFNumberFormatterRef)Instance;
}

uint64_t __cficu_unum_getAttribute(uint64_t a1, int a2)
{
  uint64_t Attribute = unum_getAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v6 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, CFSTR(""unum_getAttribute(%@, %s);
    CFRelease(v5);
  }
  return Attribute;
}

void __cficu_unum_setContext(uint64_t a1, uint64_t a2, int *a3)
{
  unum_setContext();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a3, 1);
    ___CFICULogWithArguments(1, @"unum_setContext(%@, %d, &%@);", v6, a2, v7);
    CFRelease(v7);
    CFRelease(v6);
  }
}

uint64_t __cficu_unum_open(unsigned int a1, UChar *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  uint64_t v12 = unum_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFAllocatorRef v13 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"numFmt", v12);
    unint64_t v14 = (const void *)___CFICUCreateVariableNameForStatus((uint64_t)a6);
    CFStringRef v15 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v16 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    if (a5) {
      ___CFICULogWithArguments(1, @"#warning non-NULL parseErr ignored");
    }
    if (a1 > 0x11) {
      CFTypeID v17 = "<unknown UNumberFormatStyle>";
    }
    else {
      CFTypeID v17 = off_1ECDFE3D0[a1];
    }
    ___CFICULogWithArguments(1, @"UNumberFormat *%@ = unum_open(%s, %@, %d, \"%s\", NULL, &%@); %@",
      v13,
      v17,
      v16,
      a3,
      a4,
      v14,
      v15);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v16);
    CFRelease(v15);
  }
  return v12;
}

uint64_t _CFLocaleGetAppleICUNumberSymbolsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUNumberSymbols"];
}

void __cficu_unum_applyPattern(uint64_t a1, int a2, UChar *a3, uint64_t a4, uint64_t a5, int *a6)
{
  unum_applyPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFAllocatorRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v15 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    if (a5) {
      ___CFICULogWithArguments(1, @"#warning non-NULL parseError ignored");
    }
    ___CFICULogWithArguments(1, @"unum_applyPattern(%@, %d, %@, %d, NULL, &%@); %@", v12, a2, v15, a4, v13, v14);
    CFRelease(v15);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
  }
}

uint64_t _CFLocaleGetAppleICUNumberFormatStringsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUNumberFormatStrings"];
}

void __cficu_unum_setDoubleAttribute(uint64_t a1, int a2, double a3)
{
  unum_setDoubleAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v7 = ___CFICUCreateArgumentForDouble(a3);
    unsigned int v8 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, @"unum_setDoubleAttribute(%@, %s, %@);", v6, v8, v7);
    CFRelease(v6);
    CFRelease(v7);
  }
}

void __cficu_unum_setSymbol(uint64_t a1, unsigned int a2, UChar *a3, uint64_t a4, int *a5)
{
  unum_setSymbol();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v10 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v11 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a5, 1);
    CFStringRef v13 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    CFStringRef v14 = ___CFICUGetEnumStringForUNumberFormatSymbol(a2);
    ___CFICULogWithArguments(1, @"unum_setSymbol(%@, %s, %@, %d, &%@); %@", v10, v14, v13, a4, v11, v12);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
    CFRelease(v12);
  }
}

CFStringRef CFURLCopyParameterString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  void v3[5] = *(void *)off_1ECE0A5B0;
  v3[0] = off_1ECE0A5A0;
  v3[1] = 3221225472;
  v3[2] = __CFURLCopyParameterString_block_invoke_30;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = anURL;
  if (CFURLCopyParameterString_onceToken != -1) {
    dispatch_once(&CFURLCopyParameterString_onceToken, v3);
  }
  return 0;
}

void __NSCacheValueRelease(void *cf, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 28))
  {
    if (dyld_program_sdk_at_least() && *(unsigned char *)(a2 + 27))
    {
      if (__NSCacheValueRelease_oGuard != -1) {
        dispatch_once(&__NSCacheValueRelease_oGuard, &__block_literal_global_127);
      }
      unint64_t v4 = *(void **)(a2 + 8);
      uint64_t v5 = __NSCacheValueRelease_oMoribundCache;
    }
    else
    {
      unint64_t v4 = *(void **)(a2 + 8);
      uint64_t v5 = a2;
    }
    __NSCacheCallDelegateWillEvictObjectCallbackWithValue(v4, v5, (uint64_t)cf);
  }
  if (*(unsigned char *)(a2 + 24) != 1
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0)
  {
    [cf discardContentIfPossible];
  }

  CFRelease(cf);
}

uint64_t __NSCacheCallDelegateWillEvictObjectCallbackWithValue(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = _CFGetTSD(3u);
  _CFSetTSD(3u, a2, 0);
  [a1 cache:a2 willEvictObject:a3];

  return _CFSetTSD(3u, v6, 0);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutableCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFMutableCharacterSetRef)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 1, 1);
}

CFIndex CFArrayGetCountOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_2;
  }
  unsigned int v11 = atomic_load((unint64_t *)theArray + 1);
  int v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 == 1)
    {
LABEL_2:
      CFStringRef v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    char v13 = atomic_load((unint64_t *)theArray + 1);
    int v14 = v13 & 3;
    if (v14) {
      CFStringRef v15 = 0;
    }
    else {
      CFStringRef v15 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v14 == 2) {
      CFStringRef v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      CFStringRef v7 = v15;
    }
  }
  else
  {
    CFStringRef v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (length < 1) {
    return 0;
  }
  CFIndex v8 = 0;
  do
  {
    uint64_t v9 = (const void *)[(__CFArray *)theArray objectAtIndex:location];
    if (v9 == value
      || (equal = (unsigned int (*)(const void *, const void *))v7->equal) != 0 && equal(value, v9))
    {
      ++v8;
    }
    ++location;
    --length;
  }
  while (length);
  return v8;
}

CFIndex _CFNonObjCStringGetBytes(CFStringRef theString, CFRange range, uint64_t a3, unsigned int a4, int a5, UniChar *buffer, uint64_t a7, int64_t *a8)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  char v16 = atomic_load((unint64_t *)&theString->info);
  if ((v16 & 0x10) == 0)
  {
    int v17 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v17 = __CFDefaultEightBitStringEncoding;
    }
    if (v17 == a3) {
      goto LABEL_5;
    }
    if (v17 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v17 = __CFDefaultEightBitStringEncoding;
    }
    if (v17 == 1536)
    {
      switch(BYTE1(a3))
      {
        case 0:
          if (a3 <= 0x22 && ((1 << a3) & 0x600000032) != 0 || a3 == 152) {
            goto LABEL_36;
          }
          goto LABEL_5;
        case 1:
          if (a3 != 134217984) {
            goto LABEL_36;
          }
          goto LABEL_5;
        case 2:
          if (a3 == 518) {
            goto LABEL_36;
          }
          goto LABEL_5;
        case 6:
          if (a3 != 1536) {
            goto LABEL_36;
          }
          goto LABEL_5;
        case 8:
        case 0xC:
          goto LABEL_36;
        case 0xA:
          if ((a3 - 2561) > 0xF) {
            goto LABEL_5;
          }
          int v24 = 1 << (a3 - 1);
          int v25 = 32785;
          break;
        case 0xB:
          if ((a3 - 3059) > 0xC) {
            goto LABEL_5;
          }
          int v24 = 1 << (a3 + 13);
          int v25 = 4099;
          break;
        default:
          if (((unsigned __int16)a3 & 0xFF00u) > 0xC00) {
            goto LABEL_36;
          }
          goto LABEL_5;
      }
      if ((v24 & v25) == 0)
      {
LABEL_5:
        char v18 = atomic_load((unint64_t *)&theString->info);
        p_data = &theString->data;
        if ((v18 & 0x60) != 0)
        {
          unint64_t v20 = *p_data;
          if (buffer)
          {
LABEL_7:
            if (length >= a7) {
              CFIndex length = a7;
            }
            unint64_t v21 = atomic_load((unint64_t *)&theString->info);
            memmove(buffer, &v20[location + ((v21 >> 2) & 1)], length);
          }
        }
        else
        {
          char v23 = atomic_load((unint64_t *)&theString->info);
          unint64_t v20 = (char *)&p_data[(v23 & 5) != 4];
          if (buffer) {
            goto LABEL_7;
          }
        }
        if (a8) {
          *a8 = length;
        }
        return length;
      }
    }
  }
LABEL_36:
  v26.CFIndex location = location;
  v26.CFIndex length = length;

  return __CFStringEncodeByteStream(theString, v26, a5, a3, a4, buffer, a7, a8);
}

CFMachPortRef CFMachPortCreate(CFAllocatorRef allocator, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)_CFMachPortCreate4((__objc2_class **)allocator, (uint64_t)callout, (long long *)&context->version, shouldFreeInfo, 1);
}

CFStringRef CFURLCopyUserName(CFURLRef anURL)
{
  return _CFURLCopyUserName((unint64_t)anURL, 1);
}

CFStringRef CFURLCopyPassword(CFURLRef anURL)
{
  return _CFURLCopyPassword((unint64_t)anURL, 1);
}

uint64_t _CFURLComponentsGetURLHostAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 16);
}

CFStringRef _CFURLCopyHostName(unint64_t a1, int a2)
{
  while (1)
  {
    if (!a1) {
      _CFURLCopyHostName_cold_1();
    }
    if (CF_IS_OBJC(0x1DuLL, a1))
    {
      CFStringRef v7 = (const __CFString *)[(id)a1 host];
      CFStringRef v6 = v7;
      if (v7) {
        CFRetain(v7);
      }
      return v6;
    }
    CFStringRef v4 = _retainedComponentString(a1, 8, 1, a2);
    if (v4) {
      break;
    }
    if (*(void *)(a1 + 32))
    {
      char v5 = *(unsigned char *)(a1 + 16);
      a1 = *(void *)(a1 + 32);
      if ((v5 & 0x1F) == 0) {
        continue;
      }
    }
    return 0;
  }
  CFStringRef v6 = v4;
  if ((*(unsigned char *)(a1 + 17) & 4) == 0) {
    return v6;
  }
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
  v11.CFIndex length = CFStringGetLength(v6) - 2;
  v11.CFIndex location = 1;
  CFStringRef v10 = CFStringCreateWithSubstring(v9, v6, v11);
  CFRelease(v6);
  return v10;
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  uint64_t v3 = *(void *)&encoding;
  BytePtr = (int8x16_t *)CFDataGetBytePtr(data);
  CFIndex Length = CFDataGetLength(data);

  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, BytePtr, Length, v3, 3u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

uint64_t _CFURLGetResourcePropertyFlags(unint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    uint64_t result = _FSURLGetResourcePropertyFlags();
    if (result) {
      return result;
    }
  }
  else if (!v13)
  {
    CFLog(4, @"_CFURLGetResourcePropertyFlags failed because it was passed a URL which has no scheme", v5, v6, v7, v8, v9, v10, v12);
  }
  *a3 = 0;
  return 1;
}

Boolean CFURLSetResourcePropertiesForKeys(CFURLRef url, CFDictionaryRef keyedPropertyValues, CFErrorRef *error)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  char v12 = 0;
  if (_CFURLHasFileURLScheme((unint64_t)url, &v12))
  {
    __CFURLResourceInfoPtr((unint64_t)url);
    _FSURLSetResourcePropertiesForKeys();
  }
  else if (!v12)
  {
    CFLog(4, @"CFURLSetResourcePropertiesForKeys failed because it was passed a URL which has no scheme", v4, v5, v6, v7, v8, v9, v11);
  }
  return 1;
}

void CFURLClearResourcePropertyCache(CFURLRef url)
{
  unint64_t v2 = __CFURLResourceInfoPtr((unint64_t)url);

  MEMORY[0x1F4114F08](url, 0, v2);
}

CFURLRef CFURLCreateFileReferenceURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  if (url)
  {
    CFURLRef v5 = CFURLCopyAbsoluteURL(url);
    if (v5)
    {
      uint64_t v6 = (CFStringEncoding *)v5;
      char v28 = 0;
      if (_CFURLHasFileURLScheme((unint64_t)v5, &v28))
      {
        CFStringRef v13 = CFURLCopyPath((CFURLRef)v6);
        CFStringRef v14 = CFURLCopyNetLocation((CFURLRef)v6);
        CFStringRef v15 = CFURLCopyResourceSpecifier((CFURLRef)v6);
        if (v13)
        {
          if (CFStringHasPrefix(v13, @"/.file/id="))
          {
            result.CFIndex location = 0;
            result.CFIndex length = 0;
            v31.CFIndex length = CFStringGetLength(v13) - 10;
            v31.CFIndex location = 10;
            if (!CFStringFindWithOptions(v13, @"/", v31, 0, &result)) {
              goto LABEL_10;
            }
            CFIndex location = result.location;
            if (location == CFStringGetLength(v13) - 1) {
              goto LABEL_10;
            }
          }
          CFRelease(v13);
        }
        CFStringRef v13 = _CFURLCopyFileReferenceURLPath(v6, error);
        if (!v13)
        {
          CFURLRef v22 = 0;
          if (!v14)
          {
LABEL_32:
            if (v15) {
              CFRelease(v15);
            }
            goto LABEL_34;
          }
LABEL_31:
          CFRelease(v14);
          goto LABEL_32;
        }
LABEL_10:
        CFIndex Length = CFStringGetLength(v13);
        BOOL v18 = CFStringGetCharacterAtIndex(v13, Length - 1) == 47;
        uint64_t v19 = (__CFString *)v15;
        if (!v15)
        {
          if (!v14 || CFEqual(v14, @"localhost"))
          {
            CFStringRef v23 = URLPathToPOSIXPath(v13, allocator, v6[5], 1);
            if (!v23)
            {
              CFURLRef v22 = 0;
LABEL_30:
              CFRelease(v13);
              if (!v14) {
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            CFStringRef v24 = v23;
            CFURLRef v22 = (const __CFURL *)_CFURLCreateWithFileSystemPath(allocator, v23, 0, v18, 0);
            CFStringRef v25 = v24;
LABEL_29:
            CFRelease(v25);
            goto LABEL_30;
          }
          uint64_t v19 = &stru_1ECE10768;
        }
        unint64_t v20 = &stru_1ECE10768;
        if (v14) {
          unint64_t v20 = (__CFString *)v14;
        }
        CFStringRef v21 = CFStringCreateWithFormat(allocator, 0, @"file://%@%@%@", v20, v13, v19);
        if (v21) {
          CFURLRef v22 = (const __CFURL *)_CFURLCreateWithURLString((__objc2_class **)allocator, v21, 1, 0);
        }
        else {
          CFURLRef v22 = 0;
        }
        CFStringRef v25 = v21;
        goto LABEL_29;
      }
      if (v28)
      {
        if (error)
        {
LABEL_18:
          CFURLRef v22 = 0;
          *error = CFErrorCreate(0, @"NSCocoaErrorDomain", 262, 0);
LABEL_34:
          CFRelease(v6);
          return v22;
        }
      }
      else
      {
        CFLog(4, @"CFURLCreateFileReferenceURL failed because it was passed a URL which has no scheme", v7, v8, v9, v10, v11, v12, v27);
        if (error) {
          goto LABEL_18;
        }
      }
      CFURLRef v22 = 0;
      goto LABEL_34;
    }
  }
  return 0;
}

CFStringRef CFURLCopyNetLocation(CFURLRef anURL)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  while (1)
  {
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
      anURL = (CFURLRef)[(__CFURL *)anURL _cfurl];
    }
    int v2 = *((_DWORD *)anURL + 4);
    if ((v2 & 0x1E) != 0) {
      break;
    }
    anURL = (CFURLRef)*((void *)anURL + 4);
    if (!anURL) {
      return 0;
    }
  }
  uint64_t v4 = _netLocationRange(*((_DWORD *)anURL + 4), (uint64_t)anURL + 56);
  CFIndex v6 = v5;
  if ((v2 & 0x10000) == 0 && (uint64_t v7 = *((void *)anURL + 5)) != 0 && (*(unsigned char *)(v7 + 16) & 0x1E) != 0)
  {
    result.CFIndex location = 0;
    result.CFIndex length = 0;
    CFStringRef v8 = *(const __CFString **)(v7 + 8);
    CFIndex v9 = CFStringGetLength(v8) - v4;
    v17.CFIndex location = v4;
    v17.CFIndex length = v9;
    if (CFStringFindWithOptions(v8, @"/", v17, 0, &result)) {
      CFIndex v9 = result.location - v4;
    }
    CFAllocatorRef v10 = CFGetAllocator(anURL);
    v18.CFIndex location = v4;
    v18.CFIndex length = v9;
    return CFStringCreateWithSubstring(v10, v8, v18);
  }
  else
  {
    CFAllocatorRef v11 = CFGetAllocator(anURL);
    CFStringRef v12 = (const __CFString *)atomic_load((unint64_t *)anURL + 3);
    v13.CFIndex location = v4;
    v13.CFIndex length = v6;
    return CFStringCreateWithSubstring(v11, v12, v13);
  }
}

CFStringRef _CFURLCopyFileReferenceURLPath(const void *a1, CFErrorRef *a2)
{
  valuePtr[1] = *(void *)off_1ECE0A5B0;
  uint64_t v35 = 0;
  valuePtr[0] = 0;
  CFAllocatorRef v4 = CFGetAllocator(a1);
  block[0] = off_1ECE0A5A0;
  block[1] = 3221225472;
  block[2] = ___CFURLCopyFileReferenceURLPath_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v4;
  if (_CFURLCopyFileReferenceURLPath_onceToken != -1) {
    dispatch_once(&_CFURLCopyFileReferenceURLPath_onceToken, block);
  }
  CFDictionaryRef v5 = CFURLCopyResourcePropertiesForKeys((CFURLRef)a1, (CFArrayRef)_CFURLCopyFileReferenceURLPath_sPropertyKeys, a2);
  if (v5)
  {
    CFDictionaryRef v6 = v5;
    CFAllocatorRef v31 = v4;
    CFStringRef Value = (__objc2_class **)CFDictionaryGetValue(v5, @"NSURLIsDirectoryKey");
    if (Value == &__kCFBooleanTrue)
    {
      CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLVolumeIDKey");
      int v10 = 1;
    }
    else
    {
      CFStringRef v8 = (__objc2_class **)CFDictionaryGetValue(v6, @"_NSURLVolumeIsHFSStandardKey");
      CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLVolumeIDKey");
      if (v8 == &__kCFBooleanTrue)
      {
        CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLParentDirectoryIDKey");
        CFStringRef v14 = CFDictionaryGetValue(v6, @"NSURLNameKey");
        int v15 = 0;
        int v10 = 0;
        char v13 = 1;
LABEL_12:
        if (v14) {
          int v15 = 1;
        }
        if (v9 && v12 && v15)
        {
          if (CFNumberGetValue(v9, kCFNumberLongLongType, valuePtr)
            && CFNumberGetValue(v12, kCFNumberLongLongType, &v35))
          {
            uint64_t v16 = v35;
            if (v13)
            {
              CFAllocatorRef v4 = v31;
              CFAllocatorRef v17 = v31;
              uint64_t v18 = v35;
              uint64_t v16 = 0;
              uint64_t v19 = (uint64_t)v14;
              int v20 = 0;
            }
            else
            {
              CFAllocatorRef v4 = v31;
              CFAllocatorRef v17 = v31;
              uint64_t v18 = 0;
              uint64_t v19 = 0;
              int v20 = v10;
            }
            CFStringRef FileReferencePath = createFileReferencePath(v17, valuePtr[0], v18, v16, v19, v20);
            CFStringRef v11 = FileReferencePath;
            if (a2 && !FileReferencePath) {
              goto LABEL_47;
            }
            goto LABEL_54;
          }
          CFStringRef v11 = 0;
          if (a2) {
            *a2 = 0;
          }
LABEL_41:
          CFAllocatorRef v4 = v31;
          goto LABEL_54;
        }
        CFTypeRef propertyValueTypeRefPtr = 0;
        if (!CFURLCopyResourcePropertyForKey((CFURLRef)a1, @"NSURLParentDirectoryURLKey", &propertyValueTypeRefPtr, a2))
        {
          CFStringRef v11 = 0;
          goto LABEL_41;
        }
        CFAllocatorRef v4 = v31;
        if (!propertyValueTypeRefPtr)
        {
          CFStringRef v11 = 0;
          if (a2) {
LABEL_47:
          }
            *a2 = 0;
LABEL_54:
          CFRelease(v6);
          if (!a2) {
            return v11;
          }
          goto LABEL_55;
        }
        CFStringRef v21 = (const __CFString *)_CFURLCopyFileReferenceURLPath(propertyValueTypeRefPtr, a2);
        if (!v21)
        {
          CFStringRef v11 = 0;
LABEL_53:
          CFRelease(propertyValueTypeRefPtr);
          goto LABEL_54;
        }
        CFStringRef v22 = v21;
        CFTypeRef cf = 0;
        CFIndex Length = CFStringGetLength(v21);
        CFIndex v24 = Length - 1;
        if (Length < 1)
        {
          if (a2)
          {
            CFStringRef v11 = 0;
            *a2 = 0;
LABEL_52:
            CFRelease(v22);
            goto LABEL_53;
          }
        }
        else if (CFURLCopyResourcePropertyForKey((CFURLRef)a1, @"NSURLNameKey", &cf, a2))
        {
          int CharacterAtIndex = CFStringGetCharacterAtIndex(v22, v24);
          CFStringRef v26 = @"%@/%@";
          if (Value == &__kCFBooleanTrue) {
            CFStringRef v26 = @"%@/%@/";
          }
          CFStringRef v27 = @"%@%@";
          if (Value == &__kCFBooleanTrue) {
            CFStringRef v27 = @"%@%@/";
          }
          if (CharacterAtIndex == 47) {
            CFStringRef v28 = CFStringCreateWithFormat(v31, 0, v27, v22, cf);
          }
          else {
            CFStringRef v28 = CFStringCreateWithFormat(v31, 0, v26, v22, cf);
          }
          CFStringRef v11 = v28;
          if (a2 && !v28) {
            *a2 = 0;
          }
          if (cf) {
            CFRelease(cf);
          }
          goto LABEL_52;
        }
        CFStringRef v11 = 0;
        goto LABEL_52;
      }
      int v10 = 0;
    }
    CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLFileIDKey");
    char v13 = 0;
    CFStringRef v14 = 0;
    int v15 = 1;
    goto LABEL_12;
  }
  CFStringRef v11 = 0;
  if (!a2) {
    return v11;
  }
LABEL_55:
  if (!v11 && !*a2) {
    *a2 = CFErrorCreate(v4, @"NSCocoaErrorDomain", 256, 0);
  }
  return v11;
}

CFStringRef createFileReferencePath(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (!a2) {
    return 0;
  }
  if (!a5)
  {
    char v13 = "/";
    if (!a6) {
      char v13 = "";
    }
    if (snprintf(v15, 0x400uLL, "/.file/id=%lld.%lld%s", a2, a4, v13) <= 0x3FF) {
      return CFStringCreateWithCString(a1, v15, 0x8000100u);
    }
    return 0;
  }
  MEMORY[0x1F4188790](a1, a2);
  if (!CFStringGetCString(v10, v14, 1024, 0x8000100u)) {
    return 0;
  }
  CFStringRef v11 = "/";
  if (!a6) {
    CFStringRef v11 = "";
  }
  if (snprintf(v15, 0x400uLL, "/.file/id=%lld.%lld/%s%s", a2, a3, v14, v11) <= 0x3FF) {
    return CFStringCreateWithCString(a1, v15, 0x8000100u);
  }
  else {
    return 0;
  }
}

CFURLRef _CFURLIsItemPromiseAtURL(unint64_t a1)
{
  CFURLRef v1 = (const __CFURL *)a1;
  cf[1] = *(CFTypeRef *)off_1ECE0A5B0;
  if (a1)
  {
    if (_CFURLIsFileURL(a1))
    {
      cf[0] = 0;
      if (CFURLIsFileReferenceURL(v1)
        && _CFURLCopyResourcePropertyForKeyFromCache((unint64_t)v1, @"NSURLNameKey", cf))
      {
        CFStringRef PathComponent = (CFStringRef)cf[0];
        if (!cf[0]) {
          return 0;
        }
      }
      else
      {
        CFStringRef PathComponent = CFURLCopyLastPathComponent(v1);
        cf[0] = PathComponent;
        if (!PathComponent) {
          return 0;
        }
      }
      CFURLRef v1 = (const __CFURL *)_CFURLIsPromiseName(PathComponent);
      CFRelease(cf[0]);
      return v1;
    }
    return 0;
  }
  return v1;
}

void _CFURLPromiseSetPhysicalURL(const __CFURL *a1, const __CFURL *a2)
{
  if (a1 && _CFURLIsFileURL((unint64_t)a1))
  {
    if (a2 == a1 || a2)
    {
      _CFURLSetPermanentResourcePropertyForKey();
    }
    else
    {
      CFURLClearResourcePropertyCacheForKey(a1, @"_NSURLPromisePhysicalURLKey");
    }
  }
}

CFURLRef _CFURLPromiseCopyPhysicalURL(const __CFURL *result)
{
  v2[1] = *(void *)off_1ECE0A5B0;
  v2[0] = 0;
  if (result)
  {
    CFURLRef v1 = result;
    if (_CFURLIsFileURL((unint64_t)result))
    {
      CFURLCopyResourcePropertyForKey(v1, @"_NSURLPromisePhysicalURLKey", v2, 0);
      CFRange result = (const __CFURL *)v2[0];
      if ((__objc2_class **)v2[0] == &__kCFNull) {
        return (const __CFURL *)CFRetain(v1);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL _CFURLIsFileURL(unint64_t a1)
{
  return _CFURLHasFileURLScheme(a1, 0);
}

uint64_t _CFURLIsPromiseName(const __CFString *a1)
{
  if (!a1 || CFStringGetLength(a1) < 1 || CFStringGetCharacterAtIndex(a1, 0) != 46) {
    return 0;
  }

  return CFStringHasSuffix(a1, @".icloud");
}

uint64_t _CFURLGetVolumePropertyFlags(unint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    uint64_t result = _FSURLGetVolumePropertyFlags();
    if (result) {
      return result;
    }
  }
  else if (!v13)
  {
    CFLog(4, @"_CFURLGetVolumePropertyFlags failed because it was passed a URL which has no scheme", v5, v6, v7, v8, v9, v10, v12);
  }
  *a3 = 0;
  return 1;
}

void CFURLClearResourcePropertyCacheForKey(CFURLRef url, CFStringRef key)
{
  unint64_t v4 = __CFURLResourceInfoPtr((unint64_t)url);

  MEMORY[0x1F4114F08](url, key, v4);
}

uint64_t _CFURLCacheSetAutoFlushingEnabled(unint64_t a1, uint64_t a2)
{
  unint64_t v4 = __CFURLResourceInfoPtr(a1);

  return MEMORY[0x1F4114F78](a1, v4, a2);
}

uint64_t _CFURLCopyResourcePropertyForKeyFromCache(unint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    return _FSURLCopyResourcePropertyForKeyFromCache();
  }
  else
  {
    if (!v13) {
      CFLog(4, @"_CFURLCopyResourcePropertyForKeyFromCache failed because it was passed a URL which has no scheme", v5, v6, v7, v8, v9, v10, v12);
    }
    *a3 = 0;
    return 1;
  }
}

void CFURLSetTemporaryResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  char v11 = 0;
  if (_CFURLHasFileURLScheme((unint64_t)url, &v11))
  {
    __CFURLResourceInfoPtr((unint64_t)url);
    _FSURLSetResourcePropertyForKey();
  }
  else if (!v11)
  {
    CFLog(4, @"CFURLSetTemporaryResourcePropertyForKey failed because it was passed a URL which has no scheme", v4, v5, v6, v7, v8, v9, v10);
  }
}

uint64_t _CFURLCopyResourcePropertyValuesAndFlags(unint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  char v17 = 0;
  if (_CFURLHasFileURLScheme(a1, &v17))
  {
    __CFURLResourceInfoPtr(a1);
    uint64_t result = _FSURLCopyResourcePropertyValuesAndFlags();
    if (result) {
      return result;
    }
  }
  else if (!v17)
  {
    CFLog(4, @"_CFURLCopyResourcePropertyValuesAndFlags failed because it was passed a URL which has no scheme", v9, v10, v11, v12, v13, v14, v16);
  }
  *a3 = 0;
  *a6 = 0;
  return 1;
}

uint64_t __CFURLEndResourcePropertyCacheAccess(unint64_t a1)
{
  unint64_t v2 = __CFURLResourceInfoPtr(a1);

  return MEMORY[0x1F4114F40](a1, v2);
}

uint64_t __CFURLBeginResourcePropertyCacheAccess(unint64_t a1)
{
  unint64_t v2 = __CFURLResourceInfoPtr(a1);

  return MEMORY[0x1F4114EF0](a1, v2);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  char v14 = 0;
  if (!_CFURLHasFileURLScheme((unint64_t)url, &v14))
  {
    if (!v14) {
      CFLog(4, @"CFURLCopyResourcePropertyForKey failed because it was passed a URL which has no scheme", v6, v7, v8, v9, v10, v11, v13);
    }
    goto LABEL_6;
  }
  __CFURLResourceInfoPtr((unint64_t)url);
  if (!_FSURLCopyResourcePropertyForKey()) {
LABEL_6:
  }
    *(void *)CFTypeRef propertyValueTypeRefPtr = 0;
  return 1;
}

unint64_t __CFURLResourceInfoPtr(unint64_t result)
{
  if (result)
  {
    CFURLRef v1 = (unint64_t *)result;
    if (!CF_IS_OBJC(0x1DuLL, result)) {
      return atomic_load(v1 + 6);
    }
    uint64_t result = [v1 _cfurl];
    CFURLRef v1 = (unint64_t *)result;
    if (result) {
      return atomic_load(v1 + 6);
    }
  }
  return result;
}

CFDictionaryRef CFURLCopyResourcePropertiesForKeys(CFURLRef url, CFArrayRef keys, CFErrorRef *error)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (_CFURLHasFileURLScheme((unint64_t)url, &v13))
  {
    __CFURLResourceInfoPtr((unint64_t)url);
    CFDictionaryRef result = (CFDictionaryRef)_FSURLCopyResourcePropertiesForKeys();
    if (result) {
      return result;
    }
  }
  else if (!v13)
  {
    CFLog(4, @"CFURLCopyResourcePropertiesForKeys failed because it was passed a URL which has no scheme", v4, v5, v6, v7, v8, v9, v12);
  }
  CFAllocatorRef v11 = CFGetAllocator(url);
  return CFDictionaryCreate(v11, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

Boolean CFURLSetResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (_CFURLHasFileURLScheme((unint64_t)url, &v13))
  {
    __CFURLResourceInfoPtr((unint64_t)url);
    _FSURLSetResourcePropertyForKey();
  }
  else if (!v13)
  {
    CFLog(4, @"CFURLSetResourcePropertyForKey failed because it was passed a URL which has no scheme", v5, v6, v7, v8, v9, v10, v12);
  }
  return 1;
}

uint64_t __CFArrayCreate0(__objc2_class **a1, uint64_t *a2, uint64_t a3, const CFArrayCallBacks *a4)
{
  uint64_t Init = __CFArrayCreateInit(a1, 0, a3, a4);
  uint64_t v8 = Init;
  unsigned int v9 = atomic_load((unint64_t *)(Init + 8));
  int v10 = (v9 >> 2) & 3;
  if (v10)
  {
    if (v10 == 1)
    {
      CFAllocatorRef v11 = &kCFTypeArrayCallBacks;
    }
    else
    {
      char v12 = atomic_load((unint64_t *)(Init + 8));
      int v13 = v12 & 3;
      if (v13) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = (const CFArrayCallBacks *)(Init + 48);
      }
      if (v13 == 2) {
        CFAllocatorRef v11 = (const CFArrayCallBacks *)(Init + 48);
      }
      else {
        CFAllocatorRef v11 = v14;
      }
    }
  }
  else
  {
    CFAllocatorRef v11 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  char v15 = atomic_load((unint64_t *)(Init + 8));
  int v16 = v15 & 3;
  if (v16 == 2)
  {
    int v20 = (void *)(*(void *)(Init + 40) + 8 * **(void **)(Init + 40) + 16);
  }
  else if (v16)
  {
    int v20 = 0;
  }
  else
  {
    char v17 = atomic_load((unint64_t *)(Init + 8));
    BOOL v18 = (~v17 & 0xC) == 0;
    uint64_t v19 = 48;
    if (v18) {
      uint64_t v19 = 88;
    }
    int v20 = (void *)(Init + v19);
  }
  if (v11->retain)
  {
    if (a3 >= 1)
    {
      uint64_t v21 = a3;
      do
      {
        uint64_t v22 = *a2++;
        *v20++ = ((uint64_t (*)(__objc2_class **, uint64_t))v11->retain)(a1, v22);
        --v21;
      }
      while (v21);
    }
  }
  else if (a3 >= 1)
  {
    uint64_t v23 = a3;
    do
    {
      uint64_t v24 = *a2++;
      *v20++ = v24;
      --v23;
    }
    while (v23);
  }
  *(void *)(v8 + 16) = a3;
  return v8;
}

objc_class *__NSArrayParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  v24[1] = *(void *)off_1ECE0A5B0;
  if ((a4 & 0x1000000000000000) != 0)
  {
    uint64_t v6 = result;
    if (!a5)
    {
      uint64_t v14 = __CFExceptionProem(result, a2);
      CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@: index set is nil", v14);
      int v16 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v15) userInfo:0];
      objc_exception_throw(v16);
    }
    unint64_t v7 = [a5 lastIndex];
    CFDictionaryRef result = (objc_class *)[(objc_class *)v6 count];
    if ((v7 & 0x8000000000000000) != 0 || v7 != 0x7FFFFFFFFFFFFFFFLL && (unint64_t)result <= v7)
    {
      if (result)
      {
        char v17 = result;
        uint64_t v8 = _os_log_pack_size();
        int v10 = (char *)v24 - ((MEMORY[0x1F4188790](v8, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        uint64_t v19 = _os_log_pack_fill();
        int v20 = PROEM_SEL_0(a2);
        char v17 = (objc_class *)((char *)v17 - 1);
        __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(v19, (uint64_t)"NSArray", (uint64_t)v20, v7, (uint64_t)v17);
        uint64_t v23 = PROEM_SEL_0(a2);
        CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** -[%s %s]: index %lu beyond bounds [0 .. %lu]", "NSArray", v23, v7, v17);
      }
      else
      {
        uint64_t v8 = _os_log_pack_size();
        int v10 = (char *)v24 - ((MEMORY[0x1F4188790](v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0);
        uint64_t v11 = _os_log_pack_fill();
        char v12 = PROEM_SEL_0(a2);
        __os_log_helper_1_2_3_8_32_8_32_8_0(v11, (uint64_t)"NSArray", (uint64_t)v12, v7);
        uint64_t v22 = PROEM_SEL_0(a2);
        CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** -[%s %s]: index %lu beyond bounds for empty array", "NSArray", v22, v7);
      }
      uint64_t v21 = +[NSException exceptionWithName:@"NSRangeException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v13) userInfo:0 osLogPack:v10 size:v8];
      objc_exception_throw(v21);
    }
  }
  return result;
}

void sub_182C52760(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C52E5C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C534F0(_Unwind_Exception *a1)
{
}

void sub_182C53F88(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  free(0);
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSIndexSet()
{
  if (_NSIndexSetClass || (Class Class = objc_getClass("NSIndexSet"), (_NSIndexSetClass Class = (uint64_t)Class) != 0)) {
    LOBYTE(Class) = objc_opt_isKindOfClass();
  }
  return Class & 1;
}

void sub_182C545C0(_Unwind_Exception *a1)
{
  free(*(void **)(v1 - 160));
  _Unwind_Resume(a1);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, (byte6 << 48) | ((unint64_t)byte7 << 56) | (byte5 << 40) | (byte4 << 32) | ((unint64_t)byte3 << 24) | ((unint64_t)byte2 << 16) | ((unint64_t)byte1 << 8) | byte0, byte8 | ((unint64_t)byte9 << 8) | ((unint64_t)byte10 << 16) | ((unint64_t)byte11 << 24) | ((unint64_t)byte12 << 32) | ((unint64_t)byte13 << 40) | ((unint64_t)byte14 << 48) | ((unint64_t)byte15 << 56), 1);
}

void _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(CFDataRef theData, const __CFString *a2, void *a3, _DWORD *a4, void *a5, _DWORD *a6)
{
  uint64_t v49 = *(void *)off_1ECE0A5B0;
  CFSetRef v9 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, theData, 0, 0);
  if (!v9) {
    goto LABEL_15;
  }
  CFSetRef v10 = v9;
  CFMutableStringRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 5, &kCFTypeSetCallBacks);
  CFStringRef ProductNameSuffix = (const __CFString *)_CFBundleGetProductNameSuffix();
  PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
  Append3 = _CFStringCreateAppend3(a2, ProductNameSuffix, PlatformNameSuffix);
  CFStringRef v15 = _CFStringCreateAppend3(a2, PlatformNameSuffix, ProductNameSuffix);
  Append2 = _CFStringCreateAppend2(a2, PlatformNameSuffix);
  char v17 = _CFStringCreateAppend2(a2, ProductNameSuffix);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, Append3);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, v15);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, Append2);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, v17);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, a2);
  if (CFSetGetCount(Mutable) < 1) {
    goto LABEL_9;
  }
  CFDictionaryRef theDict = 0;
  int Filtered = _CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, theData, 0, Mutable, (CFTypeRef *)&theDict, 0);
  if (!theDict) {
    int Filtered = 0;
  }
  if (Filtered == 1)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"LocProvenance");
    CFDictionaryRef v20 = Value;
    if (Value && (CFIndex v21 = CFDictionaryGetCount(Value), v21 == CFSetGetCount(Mutable)))
    {
      uint64_t v22 = (void *)CFRetain(v20);
    }
    else
    {
      CFIndex Count = CFSetGetCount(Mutable);
      uint64_t v22 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      LOBYTE(valuePtr) = 3;
      CFNumberRef v24 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt8Type, &valuePtr);
      CFIndex Length = CFStringGetLength(@"LocProvenance");
      uint64_t v42 = off_1ECE0A5A0;
      uint64_t v43 = 3221225472;
      uint64_t v44 = (uint64_t)___CFBundleCopyLocTableProvenanceForDeviceAndPlatformVariants_block_invoke;
      int v45 = &__block_descriptor_56_e13_v24__0r_v8_16l;
      CFIndex v46 = Length + 1;
      uint64_t v47 = v22;
      CFNumberRef v48 = v24;
      CFSetApply(Mutable, (uint64_t)&v42);
      CFRelease(v24);
    }
    CFRelease(theDict);
  }
  else
  {
LABEL_9:
    uint64_t v22 = 0;
  }
  CFRelease(Append3);
  CFRelease(v15);
  CFRelease(Append2);
  CFRelease(v17);
  CFRelease(v10);
  CFRelease(Mutable);
  if (v22)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v22))
    {
      uint64_t v42 = 0;
      uint64_t v43 = (uint64_t)&v42;
      uint64_t v44 = 0x2020000000;
      LODWORD(v45) = 0;
      CFDictionaryRef theDict = 0;
      p_CFDictionaryRef theDict = &theDict;
      uint64_t v40 = 0x2020000000;
      uint64_t v41 = 0;
      uint64_t valuePtr = 0;
      p_uint64_t valuePtr = &valuePtr;
      uint64_t v36 = 0x2020000000;
      int v37 = 0;
      uint64_t v30 = 0;
      CFAllocatorRef v31 = &v30;
      uint64_t v32 = 0x2020000000;
      uint64_t v33 = 0;
      v29[0] = off_1ECE0A5A0;
      v29[1] = 3221225472;
      v29[2] = ___CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants_block_invoke;
      v29[3] = &unk_1ECDFFBC8;
      v29[7] = &v30;
      v29[8] = v22;
      v29[4] = &v42;
      v29[5] = &theDict;
      v29[6] = &valuePtr;
      CFDictionaryApply(v22, (uint64_t)v29);
      *a3 = p_theDict[3];
      *a4 = *(_DWORD *)(v43 + 24);
      *a5 = v31[3];
      *a6 = *((_DWORD *)p_valuePtr + 6);
      CFRelease(v22);
      _Block_object_dispose(&v30, 8);
      _Block_object_dispose(&valuePtr, 8);
      _Block_object_dispose(&theDict, 8);
      _Block_object_dispose(&v42, 8);
    }
    else
    {
      *a3 = 0;
      *a5 = 0;
      *a4 = 0;
      *a6 = 0;
      CFRelease(v22);
    }
  }
  else
  {
LABEL_15:
    *a3 = 0;
    *a5 = 0;
    *a4 = 0;
    *a6 = 0;
  }
}

void sub_182C55210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 152), 8);
  _Unwind_Resume(a1);
}

void _CFBundleAddProvenanceKeyPathIfPresent(const __CFSet *a1, __CFSet *a2, const __CFString *value)
{
  if (CFSetContainsValue(a1, value))
  {
    Append3 = _CFStringCreateAppend3(@"LocProvenance", @":", value);
    CFSetAddValue(a2, Append3);
    CFRelease(Append3);
  }
}

__CFString *_CFStringCreateAppend3(const __CFString *a1, const __CFString *a2, const __CFString *a3)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v7 = CFStringGetLength(a2) + Length;
  CFIndex v8 = CFStringGetLength(a3);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7 + v8, a1);
  CFStringAppend(MutableCopy, a2);
  CFStringAppend(MutableCopy, a3);
  return MutableCopy;
}

__CFString *_CFStringCreateAppend2(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5 + Length, a1);
  CFStringAppend(MutableCopy, a2);
  return MutableCopy;
}

uint64_t _CFPreferencesAppSynchronizeWithContainer(__CFString *a1, const __CFString *a2)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v5 = -[_CFXPreferences appSynchronizeWithIdentifier:container:]((uint64_t)v4, a1, a2);

  return v5;
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    unint64_t v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    unint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  Boolean v3 = -[_CFXPreferences appSynchronizeWithIdentifier:container:]((uint64_t)v2, (__CFString *)applicationID, 0);

  return v3;
}

void sub_182C55A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFRunLoopObserverDeallocate(uint64_t a1)
{
  CFRunLoopObserverInvalidate((CFRunLoopObserverRef)a1);

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
}

void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer)
{
  __CFCheckCFInfoPACSignature((uint64_t)observer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)observer + 16));
  CFRetain(observer);
  char v3 = atomic_load((unint64_t *)observer + 1);
  if ((v3 & 8) != 0)
  {
    uint64_t v4 = *((void *)observer + 10);
    uint64_t v5 = *((void *)observer + 16);
    *((void *)observer + 16) = 0;
    unint64_t v6 = atomic_load((unint64_t *)observer + 1);
    unint64_t v7 = v6;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)observer + 1, &v7, v6 & 0xFFFFFFFFFFFFFFF7);
      BOOL v8 = v7 == v6;
      unint64_t v6 = v7;
    }
    while (!v8);
    if (v4)
    {
      CFRetain((CFTypeRef)v4);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)observer + 16));
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
      CFArrayRef v9 = CFRunLoopCopyAllModes((CFRunLoopRef)v4);
      CFIndex Count = CFArrayGetCount(v9);
      if (Count)
      {
        CFIndex v11 = Count - 1;
        do
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v11);
          CFRunLoopRemoveObserver((CFRunLoopRef)v4, observer, ValueAtIndex);
          --v11;
        }
        while (v11 != -1);
      }
      CFRunLoopRemoveObserver((CFRunLoopRef)v4, observer, @"kCFRunLoopCommonModes");
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
      CFRelease(v9);
      CFRelease((CFTypeRef)v4);
      pthread_mutex_lock((pthread_mutex_t *)((char *)observer + 16));
    }
    CFStringRef v13 = (void (*)(uint64_t))*((void *)observer + 18);
    if (v13) {
      v13(v5);
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)observer + 16));

  CFRelease(observer);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  context[2] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if (v7)
  {
    BOOL v18 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v18 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  BOOL v8 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    CFSetRef v15 = (const __CFSet *)*((void *)rl + 77);
    if (v15 && CFSetContainsValue(v15, observer))
    {
      CFSetRef v16 = (const __CFSet *)*((void *)rl + 76);
      if (!v16)
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), observer);
        goto LABEL_21;
      }
      CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
      CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), observer);
      if (Copy)
      {
        context[0] = rl;
        context[1] = observer;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
        CFSetRef v14 = Copy;
LABEL_14:
        CFRelease(v14);
      }
    }
  }
  else
  {
    uint64_t v9 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
    if (v9)
    {
      CFSetRef v10 = (const __CFArray **)v9;
      CFIndex v11 = (pthread_mutex_t *)(v9 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
      if (v10[14])
      {
        CFRetain(observer);
        CFArrayRef v12 = v10[14];
        v20.CFIndex length = CFArrayGetCount(v12);
        v20.CFIndex location = 0;
        FirstIndexOfCFDictionaryRef Value = CFArrayGetFirstIndexOfValue(v12, v20, observer);
        if (FirstIndexOfValue != -1)
        {
          CFArrayRemoveValueAtIndex(v10[14], FirstIndexOfValue);
          __CFRunLoopObserverCancel((uint64_t)observer);
        }
        CFRelease(observer);
      }
      pthread_mutex_unlock(v11);
      CFSetRef v14 = (const __CFSet *)v10;
      goto LABEL_14;
    }
  }
LABEL_21:
  pthread_mutex_unlock(v8);
}

uint64_t __CFRunLoopObserverCancel(uint64_t a1)
{
  unint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v3 = *(void *)(a1 + 88) - 1;
  *(void *)(a1 + 88) = v3;
  if (!v3) {
    *(void *)(a1 + 80) = 0;
  }

  return pthread_mutex_unlock(v2);
}

void __CFRunLoopSourceRemoveFromRunLoop(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) != a1)
  {
    uint64_t v4 = *(__CFRunLoopSource **)a2;
    uint64_t v5 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    CFArrayRef v6 = CFRunLoopCopyAllModes((CFRunLoopRef)a1);
    CFIndex Count = CFArrayGetCount(v6);
    if (Count)
    {
      CFIndex v8 = Count - 1;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v8);
        CFRunLoopRemoveSource((CFRunLoopRef)a1, v4, ValueAtIndex);
        --v8;
      }
      while (v8 != -1);
    }
    CFRunLoopRemoveSource((CFRunLoopRef)a1, v4, @"kCFRunLoopCommonModes");
    pthread_mutex_unlock(v5);
    CFRelease(v6);
    *(void *)(a2 + 8) = a1;
  }
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  context[2] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if (v7)
  {
    BOOL v21 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v21 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    CFSetRef v18 = (const __CFSet *)*((void *)rl + 77);
    if (v18 && CFSetContainsValue(v18, source))
    {
      CFSetRef v19 = (const __CFSet *)*((void *)rl + 76);
      if (v19)
      {
        CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v19);
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), source);
        if (Copy)
        {
          context[0] = rl;
          context[1] = source;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
          CFRelease(Copy);
        }
      }
      else
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), source);
      }
    }
    goto LABEL_34;
  }
  uint64_t v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v8)
  {
LABEL_34:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    return;
  }
  uint64_t v9 = v8;
  CFSetRef v10 = (pthread_mutex_t *)(v8 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  CFSetRef v11 = *(const __CFSet **)(v9 + 96);
  if (v11 && CFSetContainsValue(v11, source)
    || (CFSetRef v12 = *(const __CFSet **)(v9 + 104)) != 0 && CFSetContainsValue(v12, source))
  {
    CFRetain(source);
    if (*((void *)source + 13) == 1)
    {
      mach_port_name_t v13 = (*((uint64_t (**)(void))source + 20))(*((void *)source + 14));
      if (v13)
      {
        mach_port_name_t v14 = v13;
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v9 + 128), (const void *)v13);
        mach_port_extract_member(*(_DWORD *)off_1ECE0A6C8, v14, *(_DWORD *)(v9 + 136));
      }
    }
    CFSetRemoveValue(*(CFMutableSetRef *)(v9 + 96), source);
    CFSetRemoveValue(*(CFMutableSetRef *)(v9 + 104), source);
    pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
    CFSetRef v15 = (__CFBag *)*((void *)source + 12);
    if (v15) {
      CFBagRemoveValue(v15, rl);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
    char v16 = 0;
    if (*((void *)source + 13)) {
      BOOL v17 = 1;
    }
    else {
      BOOL v17 = *((void *)source + 21) == 0;
    }
  }
  else
  {
    BOOL v17 = 1;
    char v16 = 1;
  }
  pthread_mutex_unlock(v10);
  CFRelease((CFTypeRef)v9);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  if (!v17) {
    (*((void (**)(void, CFRunLoopRef, CFRunLoopMode))source + 21))(*((void *)source + 14), rl, mode);
  }
  if ((v16 & 1) == 0)
  {
    CFRelease(source);
  }
}

void CFBagRemoveValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog(3, @"%s(): immutable collection %p given to mutating function", v2, v3, v4, v5, v6, v7, (__int16)"void CFBagRemoveValue(CFMutableBagRef, const void *)");
  }

  CFBasicHashRemoveValue((uint64_t)theBag, (unint64_t)value);
}

CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  CFIndex Count = CFSetGetCount(*((CFSetRef *)rl + 79));
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
  CFSetApplyFunction(*((CFSetRef *)rl + 79), (CFSetApplierFunction)__CFRunLoopGetModeName, Mutable);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  return Mutable;
}

void _CFStreamScheduleWithRunLoop(char *cf, void *a2, const __CFString *a3)
{
  values[2] = *(void **)off_1ECE0A5B0;
  uint64_t v6 = *((void *)cf + 6);
  uint64_t v7 = *((void *)cf + 4);
  if (!v7)
  {
    _initializeClient(cf);
    uint64_t v7 = *((void *)cf + 4);
    if (!v7) {
      return;
    }
  }
  if (!*(void *)(v7 + 56))
  {
    values[0] = a2;
    values[1] = (void *)a3;
    CFArrayRef v10 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    CFDictionaryRef Mutable = (const __CFDictionary *)sSharedSources;
    if (!sSharedSources)
    {
      CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      sSharedSources = (uint64_t)Mutable;
    }
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(Mutable, v10);
    if (!Value)
    {
      *(_OWORD *)&v46.copyDescription = xmmword_1ECE0FF48;
      *(_OWORD *)&v46.hash = unk_1ECE0FF58;
      *(_OWORD *)&v46.cancel = xmmword_1ECE0FF68;
      v46.version = xmmword_1ECE0FF28;
      *(_OWORD *)&v46.CFArrayRetainCallBack retain = *(_OWORD *)&off_1ECE0FF38;
      CFMutableArrayRef v13 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      CFDictionaryAddValue((CFMutableDictionaryRef)sSharedSources, v10, v13);
      v46.info = v13;
      CFRunLoopSourceRef v31 = CFRunLoopSourceCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v46);
      pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
      uint64_t v32 = *((void *)cf + 4);
      if (v32)
      {
        uint64_t v33 = *(const void **)(v32 + 56);
        if (v33)
        {
          CFRetain(*(CFTypeRef *)(v32 + 56));
          uint64_t v32 = *((void *)cf + 4);
        }
        *(void *)(v32 + 56) = v31;
        if (v31) {
          CFRetain(v31);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        if (v33)
        {
          CFRelease(v33);
          CFRelease(v33);
        }
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      }
      CFRunLoopAddSource((CFRunLoopRef)a2, v31, a3);
      CFRelease(v31);
      goto LABEL_57;
    }
    CFMutableArrayRef v13 = Value;
    CFStringRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(Value, 0);
    if (ValueAtIndex)
    {
      CFSetRef v15 = ValueAtIndex;
      char v16 = (pthread_mutex_t *)(ValueAtIndex + 56);
      pthread_mutex_lock((pthread_mutex_t *)(ValueAtIndex + 56));
      uint64_t v17 = *((void *)v15 + 4);
      if (v17)
      {
        CFSetRef v18 = *(const void **)(v17 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v17 + 56));
          pthread_mutex_unlock(v16);
          pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
          uint64_t v19 = *((void *)cf + 4);
          if (v19)
          {
            CFRange v20 = *(const void **)(v19 + 56);
            if (v20)
            {
              CFRetain(*(CFTypeRef *)(v19 + 56));
              *(void *)(*((void *)cf + 4) + 56) = v18;
              CFRetain(v18);
              pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
              CFRelease(v20);
              CFRelease(v20);
LABEL_55:
              CFRelease(v18);
              goto LABEL_56;
            }
            *(void *)(v19 + 56) = v18;
            CFRetain(v18);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
          goto LABEL_55;
        }
      }
      pthread_mutex_unlock(v16);
    }
LABEL_56:
    CFRetain(v13);
LABEL_57:
    CFArrayAppendValue(v13, cf);
    CFDictionaryAddValue((CFMutableDictionaryRef)sSharedSources, cf, v10);
    CFRelease(v10);
    CFRelease(v13);
    *((void *)cf + 2) |= 0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    goto LABEL_58;
  }
  if (cf[17])
  {
    CFAllocatorRef v21 = CFGetAllocator(cf);
    v46.version = 0;
    v46.info = cf;
    *(_OWORD *)&v46.CFArrayRetainCallBack retain = 0uLL;
    v46.copyDescription = CFCopyDescription;
    memset(&v46.equal, 0, 32);
    v46.perform = (void (__cdecl *)(void *))_cfstream_solo_signalEventSync;
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    uint64_t v22 = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, cf);
    CFTypeRef v23 = CFRetain(v22);
    CFArrayRef v24 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, v23);
    CFIndex Count = CFArrayGetCount(v24);
    v48.CFIndex location = 0;
    v48.CFIndex length = Count;
    FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v24, v48, cf);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex(v24, FirstIndexOfValue);
      --Count;
    }
    if (!Count)
    {
      pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
      uint64_t v27 = *((void *)cf + 4);
      if (v27 && (CFStringRef v28 = *(__CFRunLoopSource **)(v27 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v27 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        CFStringRef v29 = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0);
        CFStringRef v30 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 1);
        CFRunLoopRemoveSource(v29, v28, v30);
        CFRelease(v28);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, v23);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, cf);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    uint64_t v34 = *((void *)cf + 4);
    if (v34)
    {
      uint64_t v35 = *(void **)(v34 + 56);
      if (v35)
      {
        CFRetain(*(CFTypeRef *)(v34 + 56));
        *(void *)(*((void *)cf + 4) + 56) = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        CFRelease(v35);
        if (!Count) {
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v35);
        }
        CFRelease(v35);
        goto LABEL_41;
      }
      *(void *)(v34 + 56) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_41:
    *((void *)cf + 2) &= ~0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    CFRunLoopSourceRef v9 = CFRunLoopSourceCreate(v21, 0, &v46);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    uint64_t v36 = *((void *)cf + 4);
    if (v36)
    {
      int v37 = *(const void **)(v36 + 56);
      if (v37)
      {
        CFRetain(*(CFTypeRef *)(v36 + 56));
        uint64_t v36 = *((void *)cf + 4);
      }
      *(void *)(v36 + 56) = v9;
      if (v9) {
        CFRetain(v9);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      if (v37)
      {
        CFRelease(v37);
        CFRelease(v37);
      }
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
    int v38 = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0);
    CFStringRef v39 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 1);
    CFRunLoopAddSource(v38, v9, v39);
    CFRelease(v23);
    goto LABEL_50;
  }
  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  uint64_t v8 = *((void *)cf + 4);
  if (v8)
  {
    CFRunLoopSourceRef v9 = *(CFRunLoopSourceRef *)(v8 + 56);
    if (v9)
    {
      CFRetain(*(CFTypeRef *)(v8 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_50:
      CFRunLoopAddSource((CFRunLoopRef)a2, v9, a3);
      CFRelease(v9);
      goto LABEL_58;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_58:
  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  uint64_t v40 = *(__CFArray **)(*((void *)cf + 4) + 64);
  if (!v40)
  {
    CFAllocatorRef v41 = CFGetAllocator(cf);
    uint64_t v40 = CFArrayCreateMutable(v41, 0, &kCFTypeArrayCallBacks);
    *(void *)(*((void *)cf + 4) + 64) = v40;
  }
  CFArrayAppendValue(v40, a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*((void *)cf + 4) + 64), a3);
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
  if (v6)
  {
    uint64_t v42 = *(void (**)(char *, void *, const __CFString *, void))(v6 + 120);
    if (v42)
    {
      *((void *)cf + 2) |= 0x40uLL;
      v42(cf, a2, a3, *((void *)cf + 5));
      *((void *)cf + 2) &= ~0x40uLL;
    }
  }
  uint64_t v43 = *((void *)cf + 4);
  if (v43 && *(void *)(v43 + 72))
  {
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    uint64_t v44 = *((void *)cf + 4);
    if (v44 && (int v45 = *(__CFRunLoopSource **)(v44 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v44 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      CFRunLoopSourceSignal(v45);
      CFRelease(v45);
      _wakeUpRunLoop((uint64_t)cf);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
  }
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
  }
  char v8 = atomic_load((unint64_t *)rl + 1);
  if ((v8 & 4) == 0)
  {
    if (*((void *)source + 13) == 1)
    {
      mach_port_name_t v9 = (*((uint64_t (**)(void))source + 20))(*((void *)source + 14));
      ptype[0] = 0;
      uint64_t v10 = mach_port_type(*(_DWORD *)off_1ECE0A6C8, v9, ptype);
      if (!v10 && (ptype[0] & 0x20000) == 0)
      {
        v31[0] = off_1ECE0A5A0;
        v31[1] = 3221225472;
        v31[2] = __CFRunLoopAddSource_block_invoke;
        v31[3] = &__block_descriptor_56_e5_v8__0l;
        v31[4] = source;
        v31[5] = rl;
        v31[6] = mode;
        if (CFRunLoopAddSource_onceToken != -1) {
          dispatch_once(&CFRunLoopAddSource_onceToken, v31);
        }
        __CFRunLoopError_AddingSourceLackingReceiveRight(v10, v11, v12, v13, v14, v15, v16);
      }
    }
    char v17 = atomic_load((unint64_t *)source + 1);
    if ((v17 & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (mode == @"kCFRunLoopCommonModes")
      {
        CFSetRef v23 = (const __CFSet *)*((void *)rl + 76);
        if (v23) {
          CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v23);
        }
        else {
          CFSetRef Copy = 0;
        }
        CFDictionaryRef Mutable = (__CFSet *)*((void *)rl + 77);
        if (!Mutable)
        {
          CFDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
          *((void *)rl + 77) = Mutable;
        }
        CFSetAddValue(Mutable, source);
        if (!Copy) {
          goto LABEL_38;
        }
        *(void *)ptype = rl;
        CFRunLoopSourceRef v33 = source;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, ptype);
        CFSetRef v26 = Copy;
        goto LABEL_37;
      }
      uint64_t v18 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
      if (!v18)
      {
LABEL_38:
        pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
        return;
      }
      uint64_t v19 = v18;
      CFRange v20 = (pthread_mutex_t *)(v18 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v18 + 16));
      CFSetRef v21 = *(const __CFSet **)(v19 + 96);
      if (!v21)
      {
        *(void *)(v19 + 96) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        *(void *)(v19 + 104) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        *(void *)(v19 + 128) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0);
        CFSetRef v21 = *(const __CFSet **)(v19 + 96);
      }
      if (CFSetContainsValue(v21, source) || CFSetContainsValue(*(CFSetRef *)(v19 + 104), source)) {
        goto LABEL_36;
      }
      uint64_t v22 = *((void *)source + 13);
      if (v22 == 1)
      {
        CFSetAddValue(*(CFMutableSetRef *)(v19 + 104), source);
        mach_port_name_t v27 = (*((uint64_t (**)(void))source + 20))(*((void *)source + 14));
        if (v27)
        {
          mach_port_name_t v28 = v27;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 128), (const void *)v27, source);
          mach_port_insert_member(*(_DWORD *)off_1ECE0A6C8, v28, *(_DWORD *)(v19 + 136));
        }
      }
      else if (!v22)
      {
        CFSetAddValue(*(CFMutableSetRef *)(v19 + 96), source);
      }
      pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
      CFStringRef v29 = (__CFBag *)*((void *)source + 12);
      if (!v29)
      {
        CFStringRef v29 = CFBagCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeBagCallBacks);
        *((void *)source + 12) = v29;
      }
      CFBagAddValue(v29, rl);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
      if (*((void *)source + 13))
      {
LABEL_36:
        pthread_mutex_unlock(v20);
        CFSetRef v26 = (const __CFSet *)v19;
LABEL_37:
        CFRelease(v26);
        goto LABEL_38;
      }
      uint64_t v30 = *((void *)source + 20);
      pthread_mutex_unlock(v20);
      CFRelease((CFTypeRef)v19);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
      if (v30) {
        (*((void (**)(void, CFRunLoopRef, CFRunLoopMode))source + 20))(*((void *)source + 14), rl, mode);
      }
    }
  }
}

CFMutableBagRef CFBagCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFBagCallBacks *callBacks)
{
  uint64_t Generic = (__CFBag *)__CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  uint64_t v4 = Generic;
  if (Generic)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Generic, 4uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return v4;
}

uint64_t __CFBagCreateGeneric(__objc2_class **a1, uint64_t a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    uint64_t v3 = *(void *)(a2 + 16);
    long long v4 = *(_OWORD *)(a2 + 32);
    uint64_t v5 = *(void *)(a2 + 24);
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    uint64_t v5 = 0;
    long long v4 = 0uLL;
  }
  long long v8 = v4;
  uint64_t v10 = v5;
  uint64_t v11 = v5;
  v7[0] = v2;
  v7[1] = v2;
  v7[2] = v3;
  v7[3] = v3;
  v7[4] = v4;
  uint64_t v9 = 0;
  return CFBasicHashCreate(a1, 0x2002u, v7);
}

uint64_t __CFRunLoopTimerDeallocate(uint64_t a1)
{
  *(_WORD *)(a1 + 16) |= 4u;
  CFRunLoopTimerInvalidate((CFRunLoopTimerRef)a1);
  CFRelease(*(CFTypeRef *)(a1 + 96));
  *(void *)(a1 + 96) = 0;

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 24));
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
  v21[1] = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (unint64_t)timer))
  {
    [(__CFRunLoopTimer *)timer invalidate];
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
    if ((*((_WORD *)timer + 8) & 4) == 0) {
      CFRetain(timer);
    }
    char v2 = atomic_load((unint64_t *)timer + 1);
    if ((v2 & 8) != 0)
    {
      uint64_t v3 = *((void *)timer + 11);
      uint64_t v4 = *((void *)timer + 20);
      *((void *)timer + 20) = 0;
      unint64_t v5 = atomic_load((unint64_t *)timer + 1);
      unint64_t v6 = v5;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)timer + 1, &v6, v5 & 0xFFFFFFFFFFFFFFF7);
        BOOL v7 = v6 == v5;
        unint64_t v5 = v6;
      }
      while (!v7);
      if (v3)
      {
        CFIndex Count = CFSetGetCount(*((CFSetRef *)timer + 12));
        MEMORY[0x1F4188790](Count, v9);
        uint64_t v11 = (const void **)((char *)v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
        if (v10 >= 0x200) {
          size_t v12 = 512;
        }
        else {
          size_t v12 = v10;
        }
        bzero((char *)v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v12);
        CFSetGetValues(*((CFSetRef *)timer + 12), v11);
        if (Count >= 1)
        {
          uint64_t v13 = v11;
          CFIndex v14 = Count;
          do
          {
            uint64_t v15 = *v13++;
            CFRetain(v15);
            --v14;
          }
          while (v14);
        }
        CFRetain((CFTypeRef)v3);
        pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
        pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
        if (Count < 1)
        {
          CFRunLoopRemoveTimer((CFRunLoopRef)v3, timer, @"kCFRunLoopCommonModes");
          pthread_mutex_unlock((pthread_mutex_t *)(v3 + 16));
        }
        else
        {
          uint64_t v16 = (const __CFString **)v11;
          CFIndex v17 = Count;
          do
          {
            CFStringRef v18 = *v16++;
            CFRunLoopRemoveTimer((CFRunLoopRef)v3, timer, v18);
            --v17;
          }
          while (v17);
          CFRunLoopRemoveTimer((CFRunLoopRef)v3, timer, @"kCFRunLoopCommonModes");
          pthread_mutex_unlock((pthread_mutex_t *)(v3 + 16));
          do
          {
            uint64_t v19 = *v11++;
            CFRelease(v19);
            --Count;
          }
          while (Count);
        }
        CFRelease((CFTypeRef)v3);
        pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
      }
      CFRange v20 = (void (*)(uint64_t))*((void *)timer + 22);
      if (v20) {
        v20(v4);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
    if ((*((_WORD *)timer + 8) & 4) == 0) {
      CFRelease(timer);
    }
  }
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
  }
  char v8 = atomic_load((unint64_t *)rl + 1);
  if ((v8 & 4) == 0)
  {
    char v9 = atomic_load((unint64_t *)timer + 1);
    if ((v9 & 8) != 0)
    {
      unint64_t v10 = (__CFRunLoop *)*((void *)timer + 11);
      if (!v10 || v10 == rl)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
        if (mode == @"kCFRunLoopCommonModes")
        {
          CFSetRef v14 = (const __CFSet *)*((void *)rl + 76);
          if (v14) {
            CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
          }
          else {
            CFSetRef Copy = 0;
          }
          CFDictionaryRef Mutable = (__CFSet *)*((void *)rl + 77);
          if (!Mutable)
          {
            CFDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
            *((void *)rl + 77) = Mutable;
          }
          CFSetAddValue(Mutable, timer);
          if (!Copy) {
            goto LABEL_28;
          }
          v17.version = (CFIndex)rl;
          v17.CFArrayRetainCallBack retain = (CFArrayRetainCallBack)timer;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, &v17);
          goto LABEL_27;
        }
        uint64_t v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
        if (!v11)
        {
LABEL_28:
          pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
          return;
        }
        CFSetRef Copy = (CFSetRef)v11;
        uint64_t v13 = (pthread_mutex_t *)(v11 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
        if (!*((void *)Copy + 15))
        {
          *(_OWORD *)&v17.version = *(_OWORD *)&kCFTypeArrayCallBacks.version;
          *(_OWORD *)&v17.CFArrayReleaseCallBack release = *(_OWORD *)&kCFTypeArrayCallBacks.release;
          v17.equal = 0;
          *((void *)Copy + 15) = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v17);
        }
        if (CFSetContainsValue(*((CFSetRef *)timer + 12), *((const void **)Copy + 10)))
        {
LABEL_16:
          pthread_mutex_unlock(v13);
LABEL_27:
          CFRelease(Copy);
          goto LABEL_28;
        }
        pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
        uint64_t v15 = (__CFRunLoop *)*((void *)timer + 11);
        if (v15)
        {
          if (v15 != rl)
          {
            pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
            goto LABEL_16;
          }
        }
        else
        {
          *((void *)timer + 11) = rl;
        }
        CFSetAddValue(*((CFMutableSetRef *)timer + 12), *((const void **)Copy + 10));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
        os_unfair_lock_lock((os_unfair_lock_t)rl + 171);
        __CFRepositionTimerInMode((uint64_t)Copy, timer, 0);
        os_unfair_lock_unlock((os_unfair_lock_t)rl + 171);
        if (!_CFExecutableLinkedOnOrAfter(7uLL) && _CFRunLoopGetButDontCreateCurrent() != rl) {
          CFRunLoopWakeUp(rl);
        }
        goto LABEL_16;
      }
    }
  }
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  context[2] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if (v7)
  {
    BOOL v16 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v16 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    CFSetRef v14 = (const __CFSet *)*((void *)rl + 77);
    if (v14 && CFSetContainsValue(v14, timer))
    {
      CFSetRef v15 = (const __CFSet *)*((void *)rl + 76);
      if (!v15)
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), timer);
        goto LABEL_22;
      }
      CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15);
      CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), timer);
      if (Copy)
      {
        context[0] = rl;
        context[1] = timer;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
LABEL_15:
        CFRelease(Copy);
      }
    }
  }
  else
  {
    uint64_t v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
    if (v8)
    {
      CFSetRef Copy = (CFSetRef)v8;
      unint64_t v10 = (pthread_mutex_t *)(v8 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
      CFArrayRef v11 = (const __CFArray *)*((void *)Copy + 15);
      if (v11)
      {
        v18.CFIndex length = CFArrayGetCount(*((CFArrayRef *)Copy + 15));
        v18.CFIndex location = 0;
        FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v11, v18, timer);
        if (FirstIndexOfValue != -1)
        {
          CFIndex v13 = FirstIndexOfValue;
          pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
          CFSetRemoveValue(*((CFMutableSetRef *)timer + 12), *((const void **)Copy + 10));
          if (!CFSetGetCount(*((CFSetRef *)timer + 12))) {
            *((void *)timer + 11) = 0;
          }
          pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
          CFArrayRemoveValueAtIndex(v11, v13);
          __CFArmNextTimerInMode((uint64_t)Copy);
        }
      }
      pthread_mutex_unlock(v10);
      goto LABEL_15;
    }
  }
LABEL_22:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
  uint64_t v2 = ((uint64_t (*)(CFRunLoopTimerRef))MEMORY[0x1F4188790])(timer);
  double v4 = v3;
  uint64_t v5 = v2;
  v28[518] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature(v2);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)v5);
  if (v6 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v7 = atomic_load((unint64_t *)(v5 + 8));
  if ((v7 & 8) != 0)
  {
    if (v4 <= 4039289860.0) {
      double v8 = v4;
    }
    else {
      double v8 = 4039289860.0;
    }
    uint64_t v9 = mach_absolute_time();
    double Current = CFAbsoluteTimeGetCurrent();
    double v11 = Current;
    if (v8 >= Current)
    {
      double v12 = v8 - Current;
      if (v8 - v11 > 504911232.0) {
        double v12 = 504911232.0;
      }
      v9 += __CFTimeIntervalToTSR(v12);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 24));
    if (*(void *)(v5 + 88))
    {
      CFIndex Count = CFSetGetCount(*(CFSetRef *)(v5 + 96));
      MEMORY[0x1F4188790](Count, v14);
      BOOL v16 = (const void **)((char *)v28 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
      if (v15 >= 0x200) {
        size_t v17 = 512;
      }
      else {
        size_t v17 = v15;
      }
      bzero((char *)v28 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0), v17);
      CFSetGetValues(*(CFSetRef *)(v5 + 96), v16);
      if (Count >= 1)
      {
        CFRange v18 = v16;
        CFIndex v19 = Count;
        do
        {
          CFRange v20 = *v18++;
          CFRetain(v20);
          --v19;
        }
        while (v19);
      }
      CFSetRef v21 = (char *)CFRetain(*(CFTypeRef *)(v5 + 88));
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
      pthread_mutex_lock((pthread_mutex_t *)(v21 + 16));
      if (Count < 1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)v21 + 171);
        *(void *)(v5 + 128) = v9;
        *(double *)(v5 + 104) = v8;
        os_unfair_lock_unlock((os_unfair_lock_t)v21 + 171);
      }
      else
      {
        v28[0] = v28;
        uint64_t v22 = (const __CFString **)v16;
        CFIndex v23 = Count;
        do
        {
          CFStringRef v24 = *v22;
          const void *v22 = (const __CFString *)__CFRunLoopCopyMode((uint64_t)v21, *v22, 0);
          ++v22;
          CFRelease(v24);
          --v23;
        }
        while (v23);
        os_unfair_lock_lock((os_unfair_lock_t)v21 + 171);
        *(void *)(v5 + 128) = v9;
        *(double *)(v5 + 104) = v8;
        CFStringRef v25 = (uint64_t *)v16;
        CFIndex v26 = Count;
        do
        {
          if (*v25) {
            __CFRepositionTimerInMode(*v25, (const void *)v5, 1);
          }
          ++v25;
          --v26;
        }
        while (v26);
        os_unfair_lock_unlock((os_unfair_lock_t)v21 + 171);
        do
        {
          mach_port_name_t v27 = (char *)*v16;
          if (*v16)
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v27 + 16));
            CFRelease(v27);
          }
          ++v16;
          --Count;
        }
        while (Count);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v21 + 16));
      if (!v21 || _CFRunLoopGetButDontCreateCurrent() != v21) {
        CFRunLoopWakeUp((CFRunLoopRef)v21);
      }
      CFRelease(v21);
    }
    else
    {
      *(void *)(v5 + 128) = v9;
      *(double *)(v5 + 104) = v8;
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
    }
    kdebug_trace();
  }
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  mach_msg_return_t v5;
  mach_msg_header_t v6;
  uint64_t v7;
  uint64_t vars8;

  char v7 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  unsigned __int8 v3 = atomic_load(__CFMainThreadHasExited);
  if ((v3 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (*((unsigned char *)rl + *((unsigned __int8 *)rl + 84) + 339))
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
  else
  {
    kdebug_trace();
    mach_port_t v4 = *((_DWORD *)rl + 20);
    *(void *)&v6.msgh_bits = 0x1800000013;
    v6.msgh_remote_port = v4;
    v6.msgh_local_port = 0;
    *(void *)&v6.msgh_voucher_port = 0;
    uint64_t v5 = mach_msg(&v6, 17, 0x18u, 0, 0, 0, 0);
    __CFMachMessageCheckForAndDestroyUnsentMessage(v5, &v6);
    if (v5 && v5 != 268435460) {
      CFRunLoopWakeUp_cold_1();
    }
    kdebug_trace();
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
}

BOOL _CFRunLoopFinished(uint64_t a1, const __CFString *a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  mach_port_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = __CFRunLoopCopyMode(a1, a2, 0);
  if (v5)
  {
    unint64_t v6 = (const void *)v5;
    char v7 = (pthread_mutex_t *)(v5 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 16));
    BOOL v8 = __CFRunLoopModeIsEmpty(a1, (uint64_t)v6) != 0;
    pthread_mutex_unlock(v7);
    CFRelease(v6);
  }
  else
  {
    BOOL v8 = 1;
  }
  pthread_mutex_unlock(v4);
  return v8;
}

uint64_t CFRunLoopRunSpecific(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  v22[5] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v8 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v8);
  }
  unsigned __int8 v9 = atomic_load(__CFMainThreadHasExited);
  if (v9)
  {
    BOOL v21 = __CFRunLoopMain && __CFRunLoopMain == a1;
    if (v21 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!a2 || a2 == @"kCFRunLoopCommonModes" || CFEqual(a2, @"kCFRunLoopCommonModes"))
  {
    v22[0] = off_1ECE0A5A0;
    v22[1] = 3221225472;
    v22[2] = __CFRunLoopRunSpecific_block_invoke;
    void v22[3] = &__block_descriptor_40_e5_v8__0l;
    v22[4] = a2;
    if (CFRunLoopRunSpecific_onceToken != -1) {
      dispatch_once(&CFRunLoopRunSpecific_onceToken, v22);
    }
    return 1;
  }
  char v12 = atomic_load((unint64_t *)(a1 + 8));
  if ((v12 & 4) != 0) {
    return 1;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v13 = __CFRunLoopCopyMode(a1, a2, 0);
  if (!v13)
  {
LABEL_18:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return 1;
  }
  uint64_t v14 = v13;
  if (__CFRunLoopModeIsEmpty(a1, v13))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 16));
    CFRelease((CFTypeRef)v14);
    goto LABEL_18;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v14 + 16));
  uint64_t v15 = *(unsigned __int8 *)(a1 + 84);
  if (v15 >= 0xFE) {
    CFRunLoopRunSpecific_cold_1();
  }
  uint64_t v16 = v15 + 1;
  *(unsigned char *)(a1 + 84) = v16;
  uint64_t v17 = a1 + v16;
  *(unsigned char *)(v17 + 85) = 0;
  *(unsigned char *)(v17 + 339) = 0;
  uint64_t v18 = *(void *)(a1 + 624);
  *(void *)(a1 + 624) = v14;
  if (*(unsigned char *)(v14 + 144)) {
    __CFRunLoopDoObservers(a1, v14, 1);
  }
  CFIndex v19 = (_DWORD *)CFRunLoopRunSpecific_runloopNestingLevel();
  ++*v19;
  kdebug_trace();
  uint64_t v20 = __CFRunLoopRun(a1, v14, a3, *v19, a4);
  kdebug_trace();
  --*v19;
  if ((*(unsigned char *)(v14 + 144) & 0x80) != 0) {
    __CFRunLoopDoObservers(a1, v14, 128);
  }
  uint64_t v10 = v20;
  if (!*(unsigned char *)(a1 + 84)) {
    CFRunLoopRunSpecific_cold_2();
  }
  --*(unsigned char *)(a1 + 84);
  pthread_mutex_unlock((pthread_mutex_t *)(v14 + 16));
  CFRelease((CFTypeRef)v14);
  *(void *)(a1 + 624) = v18;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v10;
}

void sub_182C5837C(_Unwind_Exception *a1)
{
}

uint64_t __CFRunLoopCopyMode(uint64_t a1, const __CFString *a2, int a3)
{
  kern_return_t v9;
  int sig;
  mach_port_name_t port_4CF;
  mach_port_name_t v12;
  NSObject *v13;
  mach_port_name_t v14;
  mach_port_name_t v15;
  void handler[5];
  pthread_mutexattr_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD value[5];
  long long v21;
  long long v22;
  long long v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  uint64_t v28;
  uint64_t v29;

  CFStringRef v29 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  mach_port_name_t v28 = 0;
  CFIndex v26 = 0u;
  mach_port_name_t v27 = 0u;
  CFStringRef v24 = 0u;
  CFStringRef v25 = 0u;
  uint64_t v22 = 0u;
  CFIndex v23 = 0u;
  BOOL v21 = 0u;
  memset(value, 0, sizeof(value));
  _CFRuntimeSetInstanceTypeIDAndIsa(value, 0x2CuLL);
  *(void *)&BOOL v21 = a2;
  unint64_t v6 = CFSetGetValue(*(CFSetRef *)(a1 + 632), value);
  uint64_t Instance = (uint64_t)v6;
  if (v6)
  {
    CFRetain(v6);
  }
  else if (a3)
  {
    uint64_t Instance = _CFRuntimeCreateInstance(&__kCFAllocatorSystemDefault, 0x2CuLL, 184, 0);
    if (Instance)
    {
      v17.__sig = 0;
      *(void *)v17.__opaque = 0;
      pthread_mutexattr_init(&v17);
      pthread_mutexattr_settype(&v17, 2);
      pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &v17);
      pthread_mutexattr_destroy(&v17);
      *(void *)(Instance + 80) = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
      LODWORD(v17.__sig) = 0;
      unsigned __int8 v9 = mach_port_allocate(*(_DWORD *)off_1ECE0A6C8, 3u, (mach_port_name_t *)&v17);
      if (v9) {
        __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(v9);
      }
      sig = v17.__sig;
      *(unsigned char *)(Instance + 168) = 0;
      *(_DWORD *)(Instance + 136) = sig;
      *(void *)(Instance + 184) = -1;
      *(void *)(Instance + 192) = -1;
      *(void *)(Instance + 160) = _dispatch_runloop_root_queue_create_4CF();
      port_4CF = _dispatch_runloop_root_queue_get_port_4CF();
      if (!port_4CF) {
        __CFRunLoopCopyMode_cold_1();
      }
      char v12 = port_4CF;
      uint64_t v13 = dispatch_source_create((dispatch_source_type_t)off_1ECE0A620, 0, 0, *(dispatch_queue_t *)(Instance + 160));
      *(void *)(Instance + 152) = v13;
      v17.__sig = 0;
      *(void *)v17.__opaque = &v17;
      uint64_t v18 = 0x2020000000;
      CFIndex v19 = Instance + 168;
      handler[0] = off_1ECE0A5A0;
      handler[1] = 3221225472;
      handler[2] = ____CFRunLoopCopyMode_block_invoke;
      handler[3] = &unk_1ECDB04F8;
      handler[4] = &v17;
      dispatch_source_set_event_handler(v13, handler);
      dispatch_source_set_timer(*(dispatch_source_t *)(Instance + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x141uLL);
      dispatch_resume(*(dispatch_object_t *)(Instance + 152));
      if (mach_port_insert_member(*(_DWORD *)off_1ECE0A6C8, v12, *(_DWORD *)(Instance + 136))) {
        __CFRunLoopCopyMode_cold_5();
      }
      uint64_t v14 = mk_timer_create();
      *(_DWORD *)(Instance + 172) = v14;
      if (!v14) {
        __CFRunLoopCopyMode_cold_2();
      }
      if (mach_port_insert_member(*(_DWORD *)off_1ECE0A6C8, v14, *(_DWORD *)(Instance + 136))) {
        __CFRunLoopCopyMode_cold_4();
      }
      uint64_t v15 = *(_DWORD *)(a1 + 80);
      if (!v15 || mach_port_insert_member(*(_DWORD *)off_1ECE0A6C8, v15, *(_DWORD *)(Instance + 136))) {
        __CFRunLoopCopyMode_cold_3();
      }
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 632), (const void *)Instance);
      _Block_object_dispose(&v17, 8);
    }
  }
  else
  {
    return 0;
  }
  return Instance;
}

void sub_182C58698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const void *_CFRunLoopIsCurrent(const void *result)
{
  if (result) {
    return (const void *)(_CFRunLoopGetButDontCreateCurrent() == result);
  }
  return result;
}

const void *_CFRunLoopGetButDontCreateCurrent()
{
  CFDictionaryRef result = (const void *)_CFGetTSDCreateIfNeeded(0xAu, 0);
  if (!result)
  {
    uint64_t v1 = pthread_self();
    return _CFRunLoopCacheLookup(v1, 0);
  }
  return result;
}

void __CFMachMessageCheckForAndDestroyUnsentMessage(int a1, mach_msg_header_t *a2)
{
  if (a1 != 268435463)
  {
    if (a1 == 268435459)
    {
LABEL_10:
      mach_msg_destroy(a2);
      return;
    }
    if (a1 != 16) {
      return;
    }
  }
  mach_port_t msgh_local_port = a2->msgh_local_port;
  if (msgh_local_port - 1 <= 0xFFFFFFFD)
  {
    mach_msg_bits_t msgh_bits = a2->msgh_bits;
    if (((a2->msgh_bits >> 8) & 0x1F) - 17 <= 1)
    {
      mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, msgh_local_port);
      mach_msg_bits_t msgh_bits = a2->msgh_bits;
    }
    a2->mach_msg_bits_t msgh_bits = msgh_bits & 0xFFFFE0FF;
  }
  if (a1 == 268435459 || a1 == 16) {
    goto LABEL_10;
  }
}

uint64_t __CFMachPortGetPort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

const void *_CFRunLoopCacheLookup(_opaque_pthread_t *a1, int a2)
{
  unsigned __int8 v3 = a1;
  if (pthread_equal(a1, 0)) {
    unsigned __int8 v3 = (const void *)pthread_main_thread_np();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  CFDictionaryRef v4 = (const __CFDictionary *)__CFRunLoops;
  if (a2 && !__CFRunLoops)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    uint64_t v6 = pthread_main_thread_np();
    char v7 = (const void *)__CFRunLoopCreate(v6);
    unint64_t v8 = (const void *)pthread_main_thread_np();
    CFDictionarySetValue(Mutable, v8, v7);
    uint64_t v9 = 0;
    atomic_compare_exchange_strong(&__CFRunLoops, (unint64_t *)&v9, (unint64_t)Mutable);
    if (v9) {
      CFRelease(Mutable);
    }
    CFRelease(v7);
    os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
    CFDictionaryRef v4 = (const __CFDictionary *)__CFRunLoops;
  }
  if (v4) {
    CFArrayRef Value = CFDictionaryGetValue(v4, v3);
  }
  else {
    CFArrayRef Value = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  return Value;
}

void readDataSchedule(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a4 + 16))
  {
    *(unsigned char *)(a4 + 16) = 1;
    if (CFReadStreamGetStatus((CFReadStreamRef)a1) == kCFStreamStatusOpen)
    {
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)a4);
      if ((unint64_t)&BytePtr[CFDataGetLength(*(CFDataRef *)a4)] <= *(void *)(a4 + 8)) {
        unint64_t v12 = 16;
      }
      else {
        unint64_t v12 = 2;
      }
      CFReadStreamSignalEvent(a1, v12, 0, v7, v8, v9, v10, v11);
    }
  }
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    return [(__CFReadStream *)stream streamStatus];
  }
  else
  {
    return _CFStreamGetStatus((uint64_t)stream);
  }
}

void *__CFMessagePortCreateRemote(__objc2_class **a1, const __CFString *a2, int a3, int a4)
{
  uint64_t v29 = *(void *)off_1ECE0A5B0;
  memset(&context, 0, sizeof(context));
  *(void *)special_port = 0;
  ptr = 0;
  SanitizedStringCFStringRef Name = __CFMessagePortCreateSanitizedStringName(a2, (UInt8 **)&ptr);
  if (!SanitizedStringName) {
    return 0;
  }
  CFStringRef v8 = SanitizedStringName;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!a3
    && (CFURLRef value = 0, __CFAllRemoteMessagePorts)
    && CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllRemoteMessagePorts, v8, (const void **)&value))
  {
    CFRetain(value);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    CFRelease(v8);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    int IsValid = CFMessagePortIsValid((CFMessagePortRef)value);
    uint64_t v10 = (uint64_t)value;
    if (IsValid) {
      return (void *)v10;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x23uLL, 104, 0);
    uint64_t v10 = Instance;
    if (!Instance)
    {
      CFRelease(v8);
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
      return (void *)v10;
    }
    unint64_t v11 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v12 = v11;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v12, v11 & 0xFFFFFFFFFFFFFFFELL);
      BOOL v13 = v12 == v11;
      unint64_t v11 = v12;
    }
    while (!v13);
    unint64_t v14 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v15 = v14;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v15, v14 & 0xFFFFFFFFFFFFFFFDLL);
      BOOL v13 = v15 == v14;
      unint64_t v14 = v15;
    }
    while (!v13);
    unint64_t v16 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v17 = v16;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v17, v16 | 4);
      BOOL v13 = v17 == v16;
      unint64_t v16 = v17;
    }
    while (!v13);
    *(_DWORD *)(Instance + 112) = 0;
    *(void *)(Instance + 16) = v8;
    *(void *)(Instance + 32) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    if (a3) {
      *(_DWORD *)(v10 + 44) = a4;
    }
    context.version = 0;
    context.info = (void *)v10;
    memset(&context.retain, 0, 24);
    task_get_special_port(*(_DWORD *)off_1ECE0A6C8, 4, &special_port[1]);
    if (bootstrap_look_up2())
    {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    }
    else
    {
      CFMachPortRef v21 = CFMachPortCreateWithPort((CFAllocatorRef)a1, special_port[0], (CFMachPortCallBack)__CFMessagePortDummyCallback, &context, 0);
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
      if (v21)
      {
        *(void *)(v10 + 24) = v21;
        unint64_t v22 = atomic_load((unint64_t *)(v10 + 8));
        unint64_t v23 = v22;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v10 + 8), &v23, v22 | 1);
          BOOL v13 = v23 == v22;
          unint64_t v22 = v23;
        }
        while (!v13);
        os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
        if (!a3)
        {
          CFURLRef value = 0;
          if (!__CFAllRemoteMessagePorts) {
            goto LABEL_35;
          }
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllRemoteMessagePorts, v8, (const void **)&value))
          {
            CFRetain(value);
            os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
            CFRelease((CFTypeRef)v10);
            return value;
          }
          CFDictionaryRef Mutable = (__CFDictionary *)__CFAllRemoteMessagePorts;
          if (!__CFAllRemoteMessagePorts)
          {
LABEL_35:
            CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
            __CFAllRemoteMessagePorts = (uint64_t)Mutable;
          }
          CFDictionaryAddValue(Mutable, v8, (const void *)v10);
        }
        CFRetain(v21);
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
        CFMachPortSetInvalidationCallBack(v21, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
        if (CFMachPortIsValid(v21))
        {
          CFRelease(v21);
          return (void *)v10;
        }
        CFRelease((CFTypeRef)v10);
        CFMachPortRef v18 = v21;
        goto LABEL_18;
      }
    }
  }
  CFMachPortRef v18 = (CFMachPortRef)v10;
LABEL_18:
  CFRelease(v18);
  return 0;
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)_CFMachPortCreateWithPort4((__objc2_class **)allocator, portNum, (uint64_t)callout, (long long *)&context->version, shouldFreeInfo, 1);
}

uint64_t _CFMachPortCreate4(__objc2_class **a1, uint64_t a2, long long *a3, unsigned char *a4, int a5)
{
  kern_return_t inserted;
  NSObject *v11;
  NSObject *v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  mach_port_name_t name;
  uint64_t v20;

  uint64_t v20 = *(void *)off_1ECE0A5B0;
  if (a4) {
    *a4 = 1;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  name = 0;
  inserted = mach_port_allocate(*(_DWORD *)off_1ECE0A6C8, 1u, &name);
  if (inserted || (inserted = mach_port_insert_right(*(_DWORD *)off_1ECE0A6C8, name, name, 0x14u)) != 0)
  {
    if (name)
    {
      mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, name, 1u, -1);
      unint64_t v11 = _CFOSLog();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        _CFMachPortCreate4_cold_2((int *)&name, inserted, v11);
      }
    }
    else
    {
      unint64_t v12 = _CFOSLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        _CFMachPortCreate4_cold_1(inserted, v12);
      }
    }
    return 0;
  }
  CFDictionaryRef result = _CFMachPortCreateWithPort4(a1, name, a2, a3, a4, a5);
  if (!result)
  {
    if (name)
    {
      mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, name, 1u, -1);
      mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, name);
    }
    return 0;
  }
  unint64_t v14 = atomic_load((unint64_t *)(result + 8));
  unint64_t v15 = v14;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v15, v14 | 2);
    unint64_t v16 = v15 == v14;
    unint64_t v14 = v15;
  }
  while (!v16);
  unint64_t v17 = atomic_load((unint64_t *)(result + 8));
  CFMachPortRef v18 = v17;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v18, v17 | 4);
    unint64_t v16 = v18 == v17;
    unint64_t v17 = v18;
  }
  while (!v16);
  return result;
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  v13.perform = *(void (__cdecl **)(void *))off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)port);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v6 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0 && CFMachPortIsValid(port))
  {
    uint64_t v7 = (os_unfair_lock_s *)((char *)port + 96);
    os_unfair_lock_lock((os_unfair_lock_t)port + 24);
    if (*((_DWORD *)port + 4))
    {
LABEL_9:
      CFStringRef v8 = 0;
LABEL_18:
      os_unfair_lock_unlock(v7);
      return v8;
    }
    uint64_t v9 = (__CFRunLoopSource *)*((void *)port + 5);
    if (v9)
    {
      int IsValid = CFRunLoopSourceIsValid(v9);
      CFRunLoopSourceRef v11 = (CFRunLoopSourceRef)*((void *)port + 5);
      if (IsValid)
      {
        if (v11) {
          goto LABEL_17;
        }
      }
      else
      {
        CFRelease(v11);
        *((void *)port + 5) = 0;
      }
    }
    v13.version = 1;
    v13.info = port;
    v13.CFArrayRetainCallBack retain = CFRetain;
    v13.CFArrayReleaseCallBack release = CFRelease;
    v13.copyDescription = (CFStringRef (__cdecl *)(const void *))__CFMachPortCopyDescription;
    v13.equal = (Boolean (__cdecl *)(const void *, const void *))__CFMachPortEqual;
    v13.hash = (CFHashCode (__cdecl *)(const void *))__CFMachPortHash;
    v13.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMachPortGetPort;
    v13.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMachPortPerform;
    CFRunLoopSourceRef v11 = CFRunLoopSourceCreate(allocator, order, &v13);
    *((void *)port + 5) = v11;
    if (!v11) {
      goto LABEL_9;
    }
LABEL_17:
    CFStringRef v8 = (__CFRunLoopSource *)CFRetain(v11);
    goto LABEL_18;
  }
  return 0;
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!context) {
    CFRunLoopSourceCreate_cold_1();
  }
  uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)allocator, 0x2EuLL, 168, 0);
  uint64_t v7 = Instance;
  if (Instance)
  {
    unint64_t v8 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v9 = v8;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v9, v8 | 8);
      BOOL v10 = v9 == v8;
      unint64_t v8 = v9;
    }
    while (!v10);
    atomic_store(0, (unint64_t *)(Instance + 88));
    v15.__sig = 0;
    *(void *)v15.__opaque = 0;
    pthread_mutexattr_init(&v15);
    pthread_mutexattr_settype(&v15, 2);
    pthread_mutex_init((pthread_mutex_t *)(v7 + 16), &v15);
    pthread_mutexattr_destroy(&v15);
    *(void *)(v7 + 80) = order;
    uint64_t v11 = 72;
    if (context->version != 1) {
      uint64_t v11 = 0;
    }
    if (context->version) {
      size_t v12 = v11;
    }
    else {
      size_t v12 = 80;
    }
    memmove((void *)(v7 + 104), context, v12);
    CFArrayRetainCallBack retain = context->retain;
    if (retain) {
      *(void *)(v7 + 112) = ((uint64_t (*)(void *))retain)(context->info);
    }
  }
  return (CFRunLoopSourceRef)v7;
}

uint64_t _CFMachPortCreateWithPort4(__objc2_class **a1, mach_port_name_t name, uint64_t a3, long long *a4, unsigned char *a5, int a6)
{
  uint64_t v46 = *(void *)off_1ECE0A5B0;
  if (a5) {
    *a5 = 1;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  mach_port_type_t ptype = 0;
  uint64_t v12 = mach_port_type(*(_DWORD *)off_1ECE0A6C8, name, &ptype);
  if (v12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = (ptype & 0x70000) == 0;
  }
  if (v13)
  {
    uint64_t v14 = v12;
    mach_port_type_t v15 = ptype & 0xFFEFFFFF;
    uint64_t v16 = _CFOSLog();
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 134218496;
        uint64_t v41 = name;
        __int16 v42 = 1024;
        int v43 = v14;
        __int16 v44 = 2048;
        uint64_t v45 = ptype;
        _os_log_error_impl(&dword_182B90000, v16, OS_LOG_TYPE_ERROR, "*** CFMachPortCreateWithPort(): bad Mach port parameter (0x%lx) or unsupported mysterious kind of Mach port (%d, %ld)", buf, 0x1Cu);
      }
    }
    else if (v17)
    {
      _CFMachPortCreateWithPort4_cold_1(name, v14, v16);
    }
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMachPortsLock);
  if (__CFAllMachPorts && (CFIndex Count = CFArrayGetCount((CFArrayRef)__CFAllMachPorts), Count >= 1))
  {
    CFIndex v19 = Count;
    CFIndex v20 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)__CFAllMachPorts, v20);
      if (ValueAtIndex)
      {
        uint64_t v22 = (uint64_t)ValueAtIndex;
        if (ValueAtIndex[5] == name) {
          break;
        }
      }
      if (v19 == ++v20) {
        goto LABEL_22;
      }
    }
    CFRetain(ValueAtIndex);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
    uint64_t v31 = 1;
  }
  else
  {
LABEL_22:
    uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x24uLL, 104, 0);
    if (!Instance)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
      uint64_t v32 = _CFOSLog();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        _CFMachPortCreateWithPort4_cold_2(v32);
      }
      return 0;
    }
    uint64_t v22 = Instance;
    *(_DWORD *)(Instance + 20) = name;
    *(void *)(Instance + 48) = a3;
    *(_DWORD *)(Instance + 96) = 0;
    if (a4)
    {
      long long v24 = *a4;
      long long v25 = a4[1];
      *(void *)(Instance + 88) = *((void *)a4 + 4);
      *(_OWORD *)(Instance + 72) = v25;
      *(_OWORD *)(Instance + 56) = v24;
      uint64_t v26 = *((void *)a4 + 1);
      mach_port_name_t v27 = (uint64_t (*)(uint64_t))*((void *)a4 + 2);
      if (v27)
      {
        uint64_t v26 = v27(v26);
        mach_port_name_t v27 = (uint64_t (*)(uint64_t))*((void *)a4 + 2);
      }
      *(void *)(v22 + 64) = v26;
      *(void *)(v22 + 104) = v27;
      *(void *)(v22 + 112) = *((void *)a4 + 3);
      *(void *)(v22 + 72) = 0xAAAAAAAAAACCCAAALL;
      *(void *)(v22 + 80) = 0xAAAAAAAAAABBBAAALL;
    }
    *(_DWORD *)(v22 + 16) = 0;
    CFDictionaryRef Mutable = (__CFArray *)__CFAllMachPorts;
    if (!__CFAllMachPorts)
    {
      CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      __CFAllMachPorts = (uint64_t)Mutable;
    }
    CFArrayAppendValue(Mutable, (const void *)v22);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
    if (a5) {
      *a5 = 0;
    }
    if (a6 && (ptype & 0x50000) != 0)
    {
      _cfmp_record_intent_to_invalidate(0, name);
      if (_CFMachPortQueue_onceToken != -1) {
        dispatch_once(&_CFMachPortQueue_onceToken, &__block_literal_global_21);
      }
      uint64_t v29 = dispatch_source_create((dispatch_source_type_t)off_1ECE0A600, name, 1uLL, (dispatch_queue_t)_CFMachPortQueue___CFMachPortQueue);
      if (v29)
      {
        uint64_t v30 = v29;
        handler[0] = off_1ECE0A5A0;
        handler[1] = 3221225472;
        handler[2] = ___CFMachPortCreateWithPort4_block_invoke;
        handler[3] = &unk_1ECDAFF08;
        mach_port_name_t v38 = name;
        handler[4] = v29;
        dispatch_source_set_cancel_handler(v29, handler);
        v35[0] = off_1ECE0A5A0;
        v35[1] = 3221225472;
        v35[2] = ___CFMachPortCreateWithPort4_block_invoke_2;
        v35[3] = &__block_descriptor_36_e5_v8__0l;
        mach_port_name_t v36 = name;
        dispatch_source_set_event_handler(v30, v35);
        *(void *)(v22 + 24) = v30;
        dispatch_resume(v30);
      }
    }
    uint64_t v31 = 0;
  }
  if (!CFMachPortIsValid((CFMachPortRef)v22))
  {
    CFRunLoopSourceRef v33 = _CFOSLog();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      _CFMachPortCreateWithPort4_cold_3(v22, v31, v33);
    }
    CFRelease((CFTypeRef)v22);
    return 0;
  }
  return v22;
}

Boolean CFMachPortIsValid(CFMachPortRef port)
{
  kern_return_t v3;
  mach_port_type_t ptype;
  uint64_t v6;

  unint64_t v6 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x24uLL, (unint64_t)port)) {
    return [(__CFMachPort *)port isValid];
  }
  if (*((_DWORD *)port + 4)) {
    return 0;
  }
  mach_port_type_t ptype = 0;
  unsigned __int8 v3 = mach_port_type(*(_DWORD *)off_1ECE0A6C8, *((_DWORD *)port + 5), &ptype);
  return (ptype & 0x70000) != 0 && v3 == 0;
}

void _cfmp_record_intent_to_invalidate(char a1, int a2)
{
  if (a2)
  {
    CFDictionaryRef v4 = malloc_type_calloc(1uLL, 8uLL, 0x1000040789AEA99uLL);
    if (!v4) {
      _cfmp_record_intent_to_invalidate_cold_1();
    }
    uint64_t v5 = v4;
    *CFDictionaryRef v4 = a2;
    *((unsigned char *)v4 + 4) = a1;
    if (_cfmp_records_oGuard != -1) {
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    }
    unint64_t v6 = (__CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    if (CFSetGetValue(v6, v5))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
      free(v5);
    }
    else
    {
      CFSetAddValue(v6, v5);
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    }
  }
}

void CFMachPortSetInvalidationCallBack(CFMachPortRef port, CFMachPortInvalidationCallBack callout)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)port);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v4 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (callout)
    {
      mach_port_type_t ptype = 0;
      if (mach_port_type(*(_DWORD *)off_1ECE0A6C8, *((_DWORD *)port + 5), &ptype) || (ptype & 0x50000) == 0) {
        CFLog(3, @"*** WARNING: CFMachPortSetInvalidationCallBack() called on a CFMachPort with a Mach port (0x%x) which does not have any send rights.  This is not going to work.  Callback function: %p", v5, v6, v7, v8, v9, v10, *((_DWORD *)port + 5));
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)port + 24);
    if (callout && *((_DWORD *)port + 4))
    {
      if (*((void *)port + 4))
      {
        CFLog(4, @"CFMachPortSetInvalidationCallBack(): attempt to set invalidation callback (%p) on invalid CFMachPort (%p) thwarted", v11, v12, v13, v14, v15, v16, (__int16)callout);
      }
      else
      {
        uint64_t v17 = *((void *)port + 8);
        os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
        ((void (*)(CFMachPortRef, uint64_t))callout)(port, v17);
        os_unfair_lock_lock((os_unfair_lock_t)port + 24);
      }
    }
    else
    {
      *((void *)port + 4) = callout;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
  }
}

CFStringRef __CFMessagePortCreateSanitizedStringName(const __CFString *a1, UInt8 **a2)
{
  usedBufLen[1] = *(void *)off_1ECE0A5B0;
  usedBufLen[0] = 0;
  uint64_t Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 129, 179708275, 0);
  v9.CFIndex length = CFStringGetLength(a1);
  v9.CFIndex location = 0;
  CFStringGetBytes(a1, v9, 0x8000100u, 0, 0, Typed, 128, usedBufLen);
  CFIndex v5 = usedBufLen[0];
  Typed[usedBufLen[0]] = 0;
  if (strlen((const char *)Typed) != v5)
  {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    uint64_t Typed = 0;
    CFStringRef v6 = 0;
    if (!a2) {
      return v6;
    }
LABEL_5:
    *a2 = Typed;
    return v6;
  }
  CFStringRef v6 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed, v5, 0x8000100u, 0);
  if (a2) {
    goto LABEL_5;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v6;
}

void fileSchedule(void *a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  BOOL v9 = v8 == CFReadStreamGetTypeID();
  int v10 = v9;
  if (v9) {
    CFStreamStatus Status = CFReadStreamGetStatus((CFReadStreamRef)a1);
  }
  else {
    CFStreamStatus Status = CFWriteStreamGetStatus((CFWriteStreamRef)a1);
  }
  if ((*(_DWORD *)(a4 + 8) & 0x80000000) == 0 || Status == kCFStreamStatusNotOpen)
  {
    CFDictionaryRef Mutable = *(__CFArray **)(a4 + 16);
    if (Status)
    {
      if (!Mutable) {
        constructCFFD(a4, v10, a1);
      }
      CFAllocatorRef v13 = CFGetAllocator(a1);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v13, *(CFFileDescriptorRef *)(a4 + 16), 0);
      CFRunLoopAddSource(a2, RunLoopSource, a3);
      CFRelease(RunLoopSource);
    }
    else
    {
      if (!Mutable)
      {
        CFAllocatorRef v15 = CFGetAllocator(a1);
        CFDictionaryRef Mutable = CFArrayCreateMutable(v15, 0, &kCFTypeArrayCallBacks);
        *(void *)(a4 + 16) = Mutable;
      }
      CFArrayAppendValue(Mutable, a2);
      uint64_t v16 = *(__CFArray **)(a4 + 16);
      CFArrayAppendValue(v16, a3);
    }
  }
}

void boundPairWriteSchedule(int a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    CFStringRef v6 = *(const void **)(a4 + 64);
    if (v6) {
      CFRelease(v6);
    }
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *(void *)(a4 + 64) = v7;
    ++*(_WORD *)(a4 + 52);
  }
}

void boundPairReadSchedule(int a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    CFStringRef v6 = *(const void **)(a4 + 16);
    if (v6) {
      CFRelease(v6);
    }
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *(void *)(a4 + 16) = v7;
    ++*(_WORD *)(a4 + 4);
  }
}

void __CFFileDescriptorSchedule(int a1, CFRunLoopRef rl)
{
}

char *__NSMakeSpecialForwardingCaptureBlock(const char *a1, uint64_t a2)
{
  unint64_t v2 = 0;
  if (a1 && a2)
  {
    size_t v5 = strnlen(a1, 0x400uLL);
    if (v5 == 1024)
    {
      CFLog(3, @"Error: Attempt to make special forwarding block with a signature that is too large.", v6, v7, v8, v9, v10, v11, v14);
      return 0;
    }
    else
    {
      size_t v12 = v5 + 1;
      unint64_t v2 = (char *)malloc_type_calloc(1uLL, v5 + 89, 0x41F7ACABuLL);
      *(void *)unint64_t v2 = off_1ECE0A598;
      *((_DWORD *)v2 + 3) = 0;
      *((_DWORD *)v2 + 2) = -1023410174;
      *(_OWORD *)(v2 + 40) = xmmword_182EDD460;
      *((void *)v2 + 3) = v2 + 40;
      *((void *)v2 + 4) = a2;
      *((void *)v2 + 2) = __forwarding_prep_b___;
      *((void *)v2 + 7) = copyBlock;
      *((void *)v2 + 8) = destroyBlock;
      *((void *)v2 + 9) = v2 + 88;
      *((void *)v2 + 10) = 256;
      strlcpy(v2 + 88, a1, v12);
      *((void *)v2 + 4) = _Block_copy(*((const void **)v2 + 4));
    }
  }
  return v2;
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(CFAllocatorRef allocator, uint32_t lcid)
{
  unint64_t v2 = +[NSLocale localeIdentifierFromWindowsLocaleCode:*(void *)&lcid];

  return (CFLocaleIdentifier)v2;
}

void sub_182C5A114(_Unwind_Exception *a1)
{
}

void _CFBundleGetLocTableProvenanceForLanguage(const __CFData *a1, const __CFString *a2, unsigned char *a3, BOOL *a4)
{
  v17[1] = *(CFTypeRef *)off_1ECE0A5B0;
  v17[0] = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"LocProvenance");
  CFStringAppend((CFMutableStringRef)v17[0], @":");
  CFStringAppend((CFMutableStringRef)v17[0], a2);
  uint64_t v8 = [[NSSet alloc] initWithObjects:v17 count:1];
  CFTypeRef cf = 0;
  if (!_CFPropertyListCreateFiltered(0, a1, 0, (const __CFSet *)v8, &cf, 0)) {
    goto LABEL_10;
  }
  CFNumberRef ValueWithKeyPath = (const __CFNumber *)_CFPropertyListGetValueWithKeyPath(cf, (const __CFString *)v17[0]);
  char valuePtr = 0;
  if (ValueWithKeyPath
    && (CFNumberRef v10 = ValueWithKeyPath, CFGetTypeID(ValueWithKeyPath) == 22)
    && CFNumberGetValue(v10, kCFNumberCharType, &valuePtr))
  {
    char v11 = valuePtr;
    *a3 = valuePtr & 1;
    *a4 = (v11 & 2) != 0;
    BOOL v12 = 1;
  }
  else
  {
    BOOL v12 = CFEqual(a2, @"none") != 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (!v12)
  {
LABEL_10:
    CFSetRef v13 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, a1, 0, 0);
    if (v13)
    {
      CFSetRef v14 = v13;
      if (CFSetContainsValue(v13, a2))
      {
        *a3 = 1;
        *a4 = 1;
      }
      CFRelease(v14);
    }
  }
  CFRelease(v17[0]);
}

void ___loadLocTable_block_invoke_2(uint64_t a1, const __CFString *a2)
{
  CFNumberRef ValueWithKeyPath = _CFPropertyListGetValueWithKeyPath(*(const void **)(a1 + 40), a2);
  if (ValueWithKeyPath)
  {
    size_t v5 = ValueWithKeyPath;
    if (CFGetTypeID(ValueWithKeyPath) == 18) {
      *(unsigned char *)(*(void *)(a1 + 48) + 75) = 1;
    }
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, 1);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 56), ValueAtIndex, v5);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

const void *_CFPropertyListGetValueWithKeyPath(const void *a1, const __CFString *cf)
{
  CFDictionaryRef result = 0;
  if (a1 && cf)
  {
    if (CFGetTypeID(cf) == 19) {
      CFArrayRef ArrayBySeparatingStrings = (const __CFArray *)CFRetain(cf);
    }
    else {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, @":");
    }
    CFArrayRef v6 = ArrayBySeparatingStrings;
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      uint64_t v9 = 1;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v9 - 1);
        CFTypeID v11 = CFGetTypeID(a1);
        if (v11 == 19)
        {
          IntCFArrayRef Value = CFStringGetIntValue(ValueAtIndex);
          CFArrayRef Value = CFArrayGetValueAtIndex((CFArrayRef)a1, IntValue);
        }
        else
        {
          if (v11 != 18)
          {
            a1 = 0;
            break;
          }
          CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, ValueAtIndex);
        }
        a1 = Value;
        if (v9 < v8)
        {
          ++v9;
          if (Value) {
            continue;
          }
        }
        break;
      }
    }
    CFRelease(v6);
    return a1;
  }
  return result;
}

void sub_182C5A7B0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)pStr, *pStr + 1, *(uint64_t *)&encoding, 4u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

uint64_t _CFMZEnabled()
{
  return 0;
}

CFDateRef _CFXPCCreateCFObjectFromXPCMessage(void *a1)
{
  v2[1] = *(void *)off_1ECE0A5B0;
  v2[0] = 0;
  CFDateRef result = (CFDateRef)xpc_dictionary_get_data(a1, "ECF19A18-7AA6-4141-B4DC-A2E5123B2B5C", v2);
  if (result) {
    return __CFBinaryPlistCreate15((uint64_t)result, v2[0]);
  }
  return result;
}

CFDateRef __CFBinaryPlistCreate15(uint64_t a1, unint64_t a2)
{
  v11[1] = *(const void **)off_1ECE0A5B0;
  if (a2 < 0x10) {
    return 0;
  }
  if (__CFADD__(a2, a1)) {
    return 0;
  }
  if (*(void *)a1 != 0x35317473696C7062) {
    return 0;
  }
  if (a1 + a2 - 1 < a1 + 8) {
    return 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  if ((v2 & 0xF0) != 0x10) {
    return 0;
  }
  CFDateRef Object15 = 0;
  unint64_t v4 = (unsigned __int8 *)(a1 + 9);
  uint64_t v5 = 1 << (v2 & 0xF);
  if (!__CFADD__(v5, a1 + 9) && (unint64_t)&v4[v5] <= a1 + a2)
  {
    CFDateRef Object15 = 0;
    switch((int)v5)
    {
      case 1:
        uint64_t v6 = (char)*v4;
        if ((int)v6 >= 0) {
          uint64_t v7 = v6 - 128;
        }
        else {
          uint64_t v7 = *v4 ^ 0x80;
        }
        goto LABEL_17;
      case 2:
        unint64_t v8 = (__int16)(*(unsigned __int8 *)(a1 + 10) << 8) | (unint64_t)*(unsigned __int8 *)(a1 + 9);
        if ((v8 & 0x80000000) == 0) {
          uint64_t v7 = v8 - 0x8000;
        }
        else {
          uint64_t v7 = (unsigned __int16)v8 ^ 0x8000u;
        }
        goto LABEL_17;
      case 4:
        uint64_t v7 = *(int *)v4 ^ 0xFFFFFFFF80000000;
        goto LABEL_17;
      case 8:
        uint64_t v7 = *(void *)(a1 + 9) ^ 0x8000000000000000;
LABEL_17:
        CFDateRef Object15 = 0;
        if (v7 < 16 || v7 > a2) {
          return Object15;
        }
        uint64_t v9 = (char *)&v4[v5];
        if ((unint64_t)v9 >= a1 + a2) {
          return 0;
        }
        if (*v9 != 18) {
          return 0;
        }
        v11[0] = v9 + 5;
        if ((unint64_t)(v9 + 5) >= a1 + a2) {
          return 0;
        }
        CFDateRef Object15 = __readObject15(a1, v7, v11);
        break;
      default:
        return Object15;
    }
  }
  return Object15;
}

CFDateRef __readObject15(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v118 = *(void *)off_1ECE0A5B0;
  unint64_t v3 = a1 + a2;
  unint64_t v4 = a1 + a2 - 1;
  unint64_t v5 = (unint64_t)*a3;
  if ((unint64_t)*a3 < a1 + 22 || v4 < v5) {
    return 0;
  }
  uint64_t v9 = (char *)(v5 + 1);
  unsigned int v10 = *(unsigned __int8 *)v5;
  *a3 = (const void *)(v5 + 1);
  if (v5 == -1) {
    return 0;
  }
  CFURLRef v11 = 0;
  switch(v10 >> 4)
  {
    case 0u:
      CFURLRef v11 = 0;
      switch(v10)
      {
        case 0u:
          uint64_t v17 = &kCFNull;
          return *v17;
        case 8u:
          uint64_t v17 = &kCFBooleanFalse;
          return *v17;
        case 9u:
          uint64_t v17 = &kCFBooleanTrue;
          return *v17;
        case 0xCu:
          CFStringRef Object15 = (const __CFString *)__readObject15(a1, a2, a3);
          if (!Object15) {
            return 0;
          }
          CFStringRef v48 = Object15;
          if (CFGetTypeID(Object15) != 7) {
            goto LABEL_145;
          }
          CFURLRef v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v48, 0);
          uint64_t v49 = v48;
          goto LABEL_142;
        case 0xDu:
          CFURLRef v11 = (const __CFURL *)__readObject15(a1, a2, a3);
          if (!v11) {
            return v11;
          }
          CFTypeID v50 = CFURLGetTypeID();
          if (v50 == CFGetTypeID(v11) && (CFStringRef v51 = (const __CFString *)__readObject15(a1, a2, a3)) != 0)
          {
            CFStringRef v48 = v51;
            if (CFGetTypeID(v51) == 7)
            {
              CFURLRef v52 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v48, v11);
              CFRelease(v11);
              CFRelease(v48);
              return v52;
            }
            CFRelease(v11);
LABEL_145:
            CFRange v55 = v48;
          }
          else
          {
            CFRange v55 = v11;
          }
          break;
        case 0xEu:
          if (v5 > 0xFFFFFFFFFFFFFFEELL || v3 < v5 + 17) {
            return 0;
          }
          uint64_t v53 = *(void *)v9;
          *(void *)&v54.byte8 = *(void *)(v5 + 9);
          *a3 = (const void *)(v5 + 17);
          *(void *)&v54.byte0 = v53;
          return CFUUIDCreateFromUUIDBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v54);
        default:
          return v11;
      }
      goto LABEL_146;
    case 1u:
      unsigned int v18 = v10 & 0xF;
      if (v18 > 4) {
        return 0;
      }
      if (v18 != 4)
      {
        if (v3 >= (unint64_t)v9 && (*(unsigned char *)v5 & 0xF0) == 0x10)
        {
          uint64_t v43 = 1 << (*(unsigned char *)v5 & 0xF);
          if (v5 < ~v43 && v3 >= (unint64_t)&v9[v43])
          {
            CFURLRef v11 = 0;
            switch((int)v43)
            {
              case 1:
                uint64_t v45 = *v9;
                if ((int)v45 >= 0) {
                  unint64_t v46 = v45 - 128;
                }
                else {
                  unint64_t v46 = *v9 ^ 0x80;
                }
                goto LABEL_204;
              case 2:
                unint64_t v85 = (__int16)(*(unsigned __int8 *)(v5 + 2) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 1);
                if ((v85 & 0x80000000) == 0) {
                  unint64_t v46 = v85 - 0x8000;
                }
                else {
                  unint64_t v46 = (unsigned __int16)v85 ^ 0x8000u;
                }
                goto LABEL_204;
              case 4:
                unint64_t v46 = *(int *)v9 ^ 0xFFFFFFFF80000000;
                goto LABEL_204;
              case 8:
                unint64_t v46 = *(void *)v9 ^ 0x8000000000000000;
LABEL_204:
                values[0] = (void *)v46;
                *a3 = &v9[v43];
                CFNumberType v21 = kCFNumberSInt64Type;
                return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21, values);
              default:
                return v11;
            }
          }
        }
        return 0;
      }
      CFURLRef v11 = 0;
      if (v5 <= 0xFFFFFFFFFFFFFFEELL && v3 >= v5 + 17)
      {
        uint64_t v19 = *(void **)v9;
        *a3 = (const void *)(v5 + 9);
        uint64_t v20 = *(void *)(v5 + 9);
        *a3 = (const void *)(v5 + 17);
        values[0] = (void *)(v20 ^ 0x8000000000000000);
        values[1] = v19;
        CFNumberType v21 = kCFNumberMaxType|kCFNumberSInt8Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21, values);
      }
      return v11;
    case 2u:
      int v22 = v10 & 0xF;
      if (v22 == 3)
      {
        if (v5 <= 0xFFFFFFFFFFFFFFF6 && v3 >= v5 + 9)
        {
          unint64_t v42 = *(void *)v9;
          *a3 = (const void *)(v5 + 9);
          values[0] = (void *)bswap64(v42);
          CFNumberType v21 = kCFNumberFloat64Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21, values);
        }
      }
      else if (v22 == 2 && v5 <= 0xFFFFFFFFFFFFFFFALL && v3 >= v5 + 5)
      {
        unsigned int v23 = *(_DWORD *)v9;
        *a3 = (const void *)(v5 + 5);
        LODWORD(values[0]) = bswap32(v23);
        CFNumberType v21 = kCFNumberFloat32Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21, values);
      }
      return 0;
    case 3u:
      CFURLRef v11 = 0;
      if (v5 > 0xFFFFFFFFFFFFFFF6 || v10 != 51) {
        return v11;
      }
      if (v3 < v5 + 9) {
        return 0;
      }
      unint64_t v24 = *(void *)v9;
      *a3 = (const void *)(v5 + 9);
      CFAbsoluteTime v25 = COERCE_DOUBLE(bswap64(v24));
      return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v25);
    case 4u:
      CFIndex v27 = v10 & 0xF;
      if (v27 != 15) {
        goto LABEL_153;
      }
      if (v4 < (unint64_t)v9) {
        return 0;
      }
      mach_port_name_t v28 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0;
      }
      CFURLRef v11 = 0;
      uint64_t v29 = 1 << (*v9 & 0xF);
      if (__CFADD__(v29, v28) || v3 < (unint64_t)&v28[v29]) {
        return v11;
      }
      CFURLRef v11 = 0;
      switch((int)v29)
      {
        case 1:
          uint64_t v30 = (char)*v28;
          if ((int)v30 >= 0) {
            CFIndex v27 = v30 - 128;
          }
          else {
            CFIndex v27 = *v28 ^ 0x80;
          }
          break;
        case 2:
          unint64_t v71 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v71 & 0x80000000) == 0) {
            CFIndex v27 = v71 - 0x8000;
          }
          else {
            CFIndex v27 = (unsigned __int16)v71 ^ 0x8000u;
          }
          break;
        case 4:
          CFIndex v27 = *(int *)v28 ^ 0xFFFFFFFF80000000;
          break;
        case 8:
          CFIndex v27 = *(void *)(v5 + 2) ^ 0x8000000000000000;
          break;
        default:
          return v11;
      }
      uint64_t v9 = (char *)&v28[v29];
      *a3 = &v28[v29];
LABEL_153:
      if (__CFADD__(v27, v9)) {
        return 0;
      }
      CFIndex v72 = &v9[v27];
      if (v3 < (unint64_t)&v9[v27]) {
        return 0;
      }
      CFDateRef result = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v27);
      goto LABEL_198;
    case 5u:
      CFIndex v31 = v10 & 0xF;
      if (v31 != 15) {
        goto LABEL_162;
      }
      if (v4 < (unint64_t)v9) {
        return 0;
      }
      uint64_t v32 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0;
      }
      CFURLRef v11 = 0;
      uint64_t v33 = 1 << (*v9 & 0xF);
      if (__CFADD__(v33, v32) || v3 < (unint64_t)&v32[v33]) {
        return v11;
      }
      CFURLRef v11 = 0;
      switch((int)v33)
      {
        case 1:
          uint64_t v34 = (char)*v32;
          if ((int)v34 >= 0) {
            CFIndex v31 = v34 - 128;
          }
          else {
            CFIndex v31 = *v32 ^ 0x80;
          }
          break;
        case 2:
          unint64_t v73 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v73 & 0x80000000) == 0) {
            CFIndex v31 = v73 - 0x8000;
          }
          else {
            CFIndex v31 = (unsigned __int16)v73 ^ 0x8000u;
          }
          break;
        case 4:
          CFIndex v31 = *(int *)v32 ^ 0xFFFFFFFF80000000;
          break;
        case 8:
          CFIndex v31 = *(void *)(v5 + 2) ^ 0x8000000000000000;
          break;
        default:
          return v11;
      }
      uint64_t v9 = (char *)&v32[v33];
      *a3 = &v32[v33];
LABEL_162:
      if (__CFADD__(v31, v9)) {
        return 0;
      }
      CFIndex v72 = &v9[v31];
      if (v3 < (unint64_t)&v9[v31]) {
        return 0;
      }
      CFStringEncoding v74 = 1536;
      goto LABEL_197;
    case 6u:
      CFIndex v35 = v10 & 0xF;
      if (v35 == 15)
      {
        if (v4 < (unint64_t)v9) {
          return 0;
        }
        mach_port_name_t v36 = (unsigned __int8 *)(v5 + 2);
        if ((*v9 & 0xF0) != 0x10) {
          return 0;
        }
        CFURLRef v11 = 0;
        uint64_t v37 = 1 << (*v9 & 0xF);
        if (!__CFADD__(v37, v36) && v3 >= (unint64_t)&v36[v37])
        {
          CFURLRef v11 = 0;
          switch((int)v37)
          {
            case 1:
              uint64_t v38 = (char)*v36;
              if ((int)v38 >= 0) {
                CFIndex v35 = v38 - 128;
              }
              else {
                CFIndex v35 = *v36 ^ 0x80;
              }
              goto LABEL_170;
            case 2:
              unint64_t v75 = (__int16)(v9[2] << 8) | (unint64_t)v9[1];
              if ((v75 & 0x80000000) == 0) {
                CFIndex v35 = v75 - 0x8000;
              }
              else {
                CFIndex v35 = (unsigned __int16)v75 ^ 0x8000u;
              }
              goto LABEL_170;
            case 4:
              CFIndex v35 = *(int *)v36 ^ 0xFFFFFFFF80000000;
              goto LABEL_170;
            case 8:
              CFIndex v35 = *(void *)(v9 + 1) ^ 0x8000000000000000;
LABEL_170:
              uint64_t v9 = (char *)&v36[v37];
              *a3 = &v36[v37];
              goto LABEL_171;
            default:
              return v11;
          }
        }
        return v11;
      }
LABEL_171:
      unint64_t v76 = (unint64_t)&v9[v35 - 1];
      if (~v35 >= v76)
      {
        unint64_t v77 = v35 + v76;
        if ((unint64_t)v9 <= ~v35 && v4 >= v77)
        {
          if (v35)
          {
            if (v35 < 0) {
              return 0;
            }
            size_t v79 = 2 * v35;
          }
          else
          {
            size_t v79 = 0;
          }
          uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v79, 724697696, 0);
          if (Typed)
          {
            long long v81 = Typed;
            memmove(Typed, *a3, v79);
            if (v35)
            {
              long long v82 = v81;
              CFIndex v83 = v35;
              do
              {
                *long long v82 = bswap32(*v82) >> 16;
                ++v82;
                --v83;
              }
              while (v83);
            }
            CFURLRef v11 = (const __CFURL *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v81, v35);
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v81);
            *a3 = (const void *)(v77 + 1);
            return v11;
          }
        }
      }
      return 0;
    case 7u:
      CFIndex v31 = v10 & 0xF;
      if (v31 != 15) {
        goto LABEL_192;
      }
      if (v4 < (unint64_t)v9) {
        return 0;
      }
      CFStringRef v39 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0;
      }
      CFURLRef v11 = 0;
      uint64_t v40 = 1 << (*v9 & 0xF);
      if (__CFADD__(v40, v39) || v3 < (unint64_t)&v39[v40]) {
        return v11;
      }
      CFURLRef v11 = 0;
      switch((int)v40)
      {
        case 1:
          uint64_t v41 = (char)*v39;
          if ((int)v41 >= 0) {
            CFIndex v31 = v41 - 128;
          }
          else {
            CFIndex v31 = *v39 ^ 0x80;
          }
          break;
        case 2:
          unint64_t v84 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v84 & 0x80000000) == 0) {
            CFIndex v31 = v84 - 0x8000;
          }
          else {
            CFIndex v31 = (unsigned __int16)v84 ^ 0x8000u;
          }
          break;
        case 4:
          CFIndex v31 = *(int *)v39 ^ 0xFFFFFFFF80000000;
          break;
        case 8:
          CFIndex v31 = *(void *)(v5 + 2) ^ 0x8000000000000000;
          break;
        default:
          return v11;
      }
      uint64_t v9 = (char *)&v39[v40];
      *a3 = &v39[v40];
LABEL_192:
      if (__CFADD__(v31, v9)) {
        return 0;
      }
      CFIndex v72 = &v9[v31];
      if (v3 < (unint64_t)&v9[v31]) {
        return 0;
      }
      CFStringEncoding v74 = 134217984;
LABEL_197:
      CFDateRef result = (CFDateRef)CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v31, v74, 0);
LABEL_198:
      *a3 = v72;
      return result;
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
      CFIndex v13 = v10 & 0xF;
      if (v13 != 15)
      {
LABEL_108:
        int v57 = v10 & 0xF0;
        if (v57 == 208)
        {
          if (v13)
          {
            if (v13 < 0) {
              return 0;
            }
            v13 *= 2;
LABEL_113:
            if ((unint64_t)v13 >> 61) {
              return 0;
            }
            long long v116 = 0u;
            long long v117 = 0u;
            long long v114 = 0u;
            long long v115 = 0u;
            long long v112 = 0u;
            long long v113 = 0u;
            long long v110 = 0u;
            long long v111 = 0u;
            long long v108 = 0u;
            long long v109 = 0u;
            long long v106 = 0u;
            long long v107 = 0u;
            long long v104 = 0u;
            long long v105 = 0u;
            long long v102 = 0u;
            long long v103 = 0u;
            long long v100 = 0u;
            long long v101 = 0u;
            long long v98 = 0u;
            long long v99 = 0u;
            long long v96 = 0u;
            long long v97 = 0u;
            long long v94 = 0u;
            long long v95 = 0u;
            long long v92 = 0u;
            long long v93 = 0u;
            long long v90 = 0u;
            long long v91 = 0u;
            long long v88 = 0u;
            long long v89 = 0u;
            *(_OWORD *)values = 0u;
            long long v87 = 0u;
            if ((unint64_t)v13 >= 0x101)
            {
              CFRange v58 = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v13, 2666184794, 0);
              if (!v58) {
                return 0;
              }
            }
            else
            {
              CFRange v58 = values;
            }
            CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
            unint64_t v62 = 0;
            while (1)
            {
              CFURLRef v63 = (const __CFURL *)__readObject15(a1, a2, a3);
              CFURLRef v11 = v63;
              if (!v63)
              {
                uint64_t v49 = Mutable;
LABEL_142:
                CFRelease(v49);
                return v11;
              }
              if (v57 == 208 && v62 < (unint64_t)v13 >> 1 && CFGetTypeID(v63) - 17 <= 2) {
                break;
              }
              CFArrayAppendValue(Mutable, v11);
              if (v13 == ++v62) {
                goto LABEL_117;
              }
            }
            CFRelease(v11);
            CFRange v55 = Mutable;
LABEL_146:
            CFRelease(v55);
            return 0;
          }
        }
        else if (v13)
        {
          goto LABEL_113;
        }
        long long v116 = 0u;
        long long v117 = 0u;
        long long v114 = 0u;
        long long v115 = 0u;
        long long v112 = 0u;
        long long v113 = 0u;
        long long v110 = 0u;
        long long v111 = 0u;
        long long v108 = 0u;
        long long v109 = 0u;
        long long v106 = 0u;
        long long v107 = 0u;
        long long v104 = 0u;
        long long v105 = 0u;
        long long v102 = 0u;
        long long v103 = 0u;
        long long v100 = 0u;
        long long v101 = 0u;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        long long v94 = 0u;
        long long v95 = 0u;
        long long v92 = 0u;
        long long v93 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        long long v88 = 0u;
        long long v89 = 0u;
        *(_OWORD *)values = 0u;
        long long v87 = 0u;
        CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        CFIndex v13 = 0;
        CFRange v58 = values;
LABEL_117:
        v120.CFIndex location = 0;
        v120.CFIndex length = v13;
        CFArrayGetValues(Mutable, v120, (const void **)v58);
        switch(v57)
        {
          case 160:
            CFRange v60 = "newArrayWithObjects:count:";
            uint64_t v61 = "NSArray";
            break;
          case 192:
            CFRange v60 = "newSetWithObjects:count:";
            uint64_t v61 = "NSSet";
            break;
          case 176:
            CFRange v60 = "newOrderedSetWithObjects:count:";
            uint64_t v61 = "NSOrderedSet";
            break;
          default:
            Class v65 = __CFLookUpClass("NSDictionary");
            long long v66 = sel_registerName("newDictionaryWithObjects:forKeys:count:");
            if (v13 >= 0) {
              uint64_t v67 = v13;
            }
            else {
              uint64_t v67 = v13 + 1;
            }
            uint64_t v68 = v67 >> 1;
            CFURLRef v11 = (const __CFURL *)objc_msgSend(v65, v66, &v58[v67 >> 1], v58, v67 >> 1);
            if (v13 >= 2)
            {
              long long v69 = (const void **)v58;
              do
              {
                long long v70 = *v69++;
                CFRelease(v70);
                --v68;
              }
              while (v68);
            }
            goto LABEL_132;
        }
        Class v64 = __CFLookUpClass(v61);
        CFURLRef v11 = (const __CFURL *)objc_msgSend(v64, sel_registerName(v60), v58, v13);
LABEL_132:
        CFRelease(Mutable);
        if (v58 != values) {
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v58);
        }
        return v11;
      }
      if (v4 < (unint64_t)v9) {
        return 0;
      }
      CFSetRef v14 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0;
      }
      CFURLRef v11 = 0;
      uint64_t v15 = 1 << (*v9 & 0xF);
      if (!__CFADD__(v15, v14) && v3 >= (unint64_t)&v14[v15])
      {
        CFURLRef v11 = 0;
        switch((int)v15)
        {
          case 1:
            uint64_t v16 = (char)*v14;
            if ((int)v16 >= 0) {
              CFIndex v13 = v16 - 128;
            }
            else {
              CFIndex v13 = *v14 ^ 0x80;
            }
            goto LABEL_107;
          case 2:
            unint64_t v56 = (__int16)(v9[2] << 8) | (unint64_t)v9[1];
            if ((v56 & 0x80000000) == 0) {
              CFIndex v13 = v56 - 0x8000;
            }
            else {
              CFIndex v13 = (unsigned __int16)v56 ^ 0x8000u;
            }
            goto LABEL_107;
          case 4:
            CFIndex v13 = *(int *)v14 ^ 0xFFFFFFFF80000000;
            goto LABEL_107;
          case 8:
            CFIndex v13 = *(void *)(v9 + 1) ^ 0x8000000000000000;
LABEL_107:
            *a3 = &v14[v15];
            goto LABEL_108;
          default:
            return v11;
        }
      }
      return v11;
    default:
      return v11;
  }
}

uint64_t CFReadStreamCreateWithData(const __CFAllocator *a1, const __CFData *a2)
{
  v6[3] = *(void *)off_1ECE0A5B0;
  v6[1] = 0;
  void v6[2] = 0;
  CFDataRef Copy = CFDataCreateCopy(a1, a2);
  v6[0] = Copy;
  uint64_t v4 = _CFStreamCreateWithConstantCallbacks((__objc2_class **)a1, (uint64_t)v6, readDataCallBacks, 1);
  CFRelease(Copy);
  return v4;
}

void sub_182C5CC18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, os_activity_scope_state_s state)
{
}

void sub_182C5D004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

unint64_t visit(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v6 = 0;
  unint64_t v7 = 0;
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  unint64_t v8 = *(void *)(a1 + 24);
  unsigned __int8 v18 = 0;
  unint64_t v9 = a1 + 8;
  while (1)
  {
    unint64_t v10 = v9;
    unint64_t WeakRetained = (unint64_t)objc_loadWeakRetained((id *)v9);
    BOOL v12 = (void *)WeakRetained;
    if (!(WeakRetained | v7)) {
      unint64_t v7 = v9;
    }
    if (WeakRetained) {
      ++v6;
    }
    (*(void (**)(uint64_t, unint64_t, unint64_t, unsigned __int8 *))(a3 + 16))(a3, v9, WeakRetained, &v18);
    unint64_t v9 = *(void *)(v9 + 8);
    if (v12) {

    }
    int v13 = v18;
    if (v18 || v6 > v8) {
      break;
    }
    if (!v9)
    {
      uint64_t v15 = (void *)(v10 + 8);
      goto LABEL_15;
    }
  }
  uint64_t v15 = (void *)(v10 + 8);
  if (v9) {
    goto LABEL_16;
  }
LABEL_15:
  *(void *)(a1 + 24) = v6;
LABEL_16:
  if (!a2 && !v13 && !v7)
  {
    uint64_t v16 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040BD48D6D6uLL);
    if (!v16) {
      visit_cold_1();
    }
    unint64_t v7 = (unint64_t)v16;
    *uint64_t v15 = v16;
  }
  return v7;
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_SYSTEM_AND_USER_CFPREFSDS(const os_unfair_lock *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

void sub_182C5DC0C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C5E064(_Unwind_Exception *a1)
{
  free(*(void **)(v1 - 168));
  _Unwind_Resume(a1);
}

void sub_182C5E0C8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x182C5E0CCLL);
  }
  objc_terminate();
}

void sub_182C5E0D8(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (!v2) {
      JUMPOUT(0x182C5DF04);
    }
    JUMPOUT(0x182C5DEECLL);
  }
  JUMPOUT(0x182C5E0C0);
}

void sub_182C5E37C(_Unwind_Exception *exception_object)
{
}

CFStringRef createDeepCopyOfValueForKey(CFStringRef cf, uint64_t a2)
{
  CFStringRef v2 = cf;
  if (((unint64_t)cf & 0x8000000000000000) == 0
    && &__kCFBooleanFalse != (__objc2_class **)cf
    && &__kCFBooleanTrue != (__objc2_class **)cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID())
    {
      return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
    }
    else
    {
      CFTypeRef cf = (CFStringRef)CFPropertyListCreateDeepCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2, 0);
      if (!cf)
      {
        _CFPrefsValidateValueForKey(v2, a2);
        return 0;
      }
    }
  }
  return cf;
}

void sub_182C5E6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C5ED74(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x182C5EB9CLL);
  }
  _Unwind_Resume(exc_buf);
}

void sub_182C5EDB4(_Unwind_Exception *a1)
{
}

void sub_182C5EDCC(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x182C5EDD8);
}

uint64_t _CFPrefsReadOnly()
{
  return forceReadOnly;
}

CFArrayRef _arrayDeepImmutableCopy(const __CFAllocator *a1, CFArrayRef theArray)
{
  v17[1] = *(void *)off_1ECE0A5B0;
  unint64_t Count = CFArrayGetCount(theArray);
  if (Count)
  {
    unint64_t v6 = Count;
    if (Count >> 60) {
      _arrayDeepImmutableCopy_cold_1();
    }
    MEMORY[0x1F4188790](Count, v5);
    uint64_t Typed = (char *)v17 - v8;
    if (v7 >= 0x200) {
      size_t v10 = 512;
    }
    else {
      size_t v10 = v7;
    }
    bzero((char *)v17 - v8, v10);
    if (v6 > 0x100)
    {
      uint64_t Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v6, 0xC0040B8AA526DLL, 0);
      if (!Typed) {
        _arrayDeepImmutableCopy_cold_2();
      }
    }
    else
    {
      bzero(Typed, 8 * v6);
    }
    v19.CFIndex location = 0;
    v19.CFIndex length = v6;
    CFArrayGetValues(theArray, v19, (const void **)Typed);
    unint64_t v12 = 0;
    while (1)
    {
      DeepCFDataRef Copy = CFPropertyListCreateDeepCopy(a1, *(CFPropertyListRef *)&Typed[8 * v12], 0);
      if (!DeepCopy) {
        break;
      }
      *(void *)&Typed[8 * v12++] = DeepCopy;
      if (v6 == v12)
      {
        unint64_t v12 = v6;
        goto LABEL_17;
      }
    }
    if (v6 == v12)
    {
LABEL_17:
      CFArrayRef v14 = CFArrayCreate(a1, (const void **)Typed, v6, &kCFTypeArrayCallBacks);
      if (!v12) {
        goto LABEL_22;
      }
      goto LABEL_20;
    }
    CFArrayRef v14 = 0;
    if (!v12) {
      goto LABEL_22;
    }
LABEL_20:
    uint64_t v15 = (const void **)Typed;
    do
    {
      uint64_t v16 = *v15++;
      CFRelease(v16);
      --v12;
    }
    while (v12);
LABEL_22:
    if (v6 >= 0x101) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    return v14;
  }
  else
  {
    return CFArrayCreate(a1, 0, 0, &kCFTypeArrayCallBacks);
  }
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  uint64_t v36 = *(void *)off_1ECE0A5B0;
  valuePtr[0] = 1;
  long long v34 = 0u;
  uint64_t v35 = 0;
  valuePtr[1] = 200;
  CFMutableArrayRef Mutable = 0;
  if (__CFPropertyListIsValidAux(propertyList, valuePtr))
  {
    if (((unint64_t)propertyList & 0x8000000000000000) == 0 || mutabilityOption == 2)
    {
      CFTypeID v7 = CFGetTypeID(propertyList);
      switch(v7)
      {
        case 0x12uLL:
          unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)propertyList);
          if (!Count)
          {
            if (mutabilityOption) {
              return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            }
            else {
              return CFDictionaryCreate(allocator, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            }
          }
          CFIndex v10 = Count;
          if (((Count >> 59) & 0xF) != 0) {
            CFPropertyListCreateDeepCopy_cold_1();
          }
          unint64_t v11 = 2 * Count;
          MEMORY[0x1F4188790](Count, v9);
          uint64_t Typed = (char *)valuePtr - v13;
          if (v12 >= 0x200) {
            size_t v15 = 512;
          }
          else {
            size_t v15 = v12;
          }
          bzero((char *)valuePtr - v13, v15);
          if (v11 > 0x100)
          {
            uint64_t Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * v10, 0xC0040B8AA526DLL, 0);
            if (!Typed) {
              CFPropertyListCreateDeepCopy_cold_2();
            }
          }
          else
          {
            bzero(Typed, 16 * v10);
          }
          unint64_t v24 = (const void **)&Typed[8 * v10];
          CFDictionaryGetKeysAndValues((CFDictionaryRef)propertyList, (const void **)Typed, v24);
          if (v10 < 1) {
            goto LABEL_55;
          }
          uint64_t v25 = 0;
          break;
        case 0x13uLL:
          if (!mutabilityOption) {
            return _arrayDeepImmutableCopy(allocator, (CFArrayRef)propertyList);
          }
          CFIndex v18 = CFArrayGetCount((CFArrayRef)propertyList);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
          if (!Mutable) {
            return Mutable;
          }
          if (v18 < 1)
          {
            CFIndex v19 = 0;
          }
          else
          {
            CFIndex v19 = 0;
            while (1)
            {
              CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)propertyList, v19);
              DeepCFStringRef Copy = CFPropertyListCreateDeepCopy(allocator, ValueAtIndex, mutabilityOption);
              if (!DeepCopy) {
                break;
              }
              int v22 = DeepCopy;
              CFArrayAppendValue(Mutable, DeepCopy);
              CFRelease(v22);
              if (v18 == ++v19) {
                return Mutable;
              }
            }
          }
          if (v19 == v18) {
            return Mutable;
          }
          CFRelease(Mutable);
          return 0;
        case 0x14uLL:
          if (mutabilityOption == 2) {
            return CFDataCreateMutableCopy(allocator, 0, (CFDataRef)propertyList);
          }
          else {
            return CFDataCreateCopy(allocator, (CFDataRef)propertyList);
          }
        case 0x15uLL:
          CFRetain(propertyList);
          return propertyList;
        case 0x16uLL:
          CFNumberType Type2 = _CFNumberGetType2((unint64_t *)propertyList);
          CFNumberGetValue((CFNumberRef)propertyList, Type2, valuePtr);
          return CFNumberCreate(allocator, Type2, valuePtr);
        default:
          if (v7 == 7)
          {
            if (mutabilityOption == 2) {
              return CFStringCreateMutableCopy(allocator, 0, (CFStringRef)propertyList);
            }
            else {
              return CFStringCreateCopy(allocator, (CFStringRef)propertyList);
            }
          }
          else
          {
            if (v7 != 42) {
              return 0;
            }
            CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)propertyList);
            return CFDateCreate(allocator, AbsoluteTime);
          }
      }
      while (1)
      {
        CFStringRef Copy = CFStringCreateCopy(allocator, *(CFStringRef *)&Typed[8 * v25]);
        if (!Copy) {
          break;
        }
        *(void *)&Typed[8 * v25] = Copy;
        CFPropertyListRef v27 = CFPropertyListCreateDeepCopy(allocator, v24[v25], mutabilityOption);
        if (!v27)
        {
          CFRelease(*(CFTypeRef *)&Typed[8 * v25]);
          break;
        }
        v24[v25++] = v27;
        if (v10 == v25) {
          goto LABEL_50;
        }
      }
      if (v10 == v25)
      {
LABEL_50:
        if (mutabilityOption) {
          CFMutableDictionaryRef v29 = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        }
        else {
          CFMutableDictionaryRef v29 = CFDictionaryCreate(allocator, (const void **)Typed, (const void **)&Typed[8 * v10], v10, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        }
        CFMutableArrayRef Mutable = v29;
        CFIndex v31 = (const void **)Typed;
        CFIndex v32 = v10;
        do
        {
          if (mutabilityOption) {
            CFDictionarySetValue(Mutable, *v31, v31[v10]);
          }
          CFRelease(*v31);
          CFRelease(v31[v10]);
          ++v31;
          --v32;
        }
        while (v32);
        goto LABEL_61;
      }
      if (v25)
      {
        for (uint64_t i = 0; i != v25; ++i)
        {
          CFRelease(*(CFTypeRef *)&Typed[8 * i]);
          CFRelease(v24[i]);
        }
      }
LABEL_55:
      CFMutableArrayRef Mutable = 0;
LABEL_61:
      if (v11 >= 0x101) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      }
    }
    else
    {
      return propertyList;
    }
  }
  return Mutable;
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData)) {
    CFIndex v7 = [(__CFData *)theData length];
  }
  else {
    CFIndex v7 = *((void *)theData + 2);
  }
  if (capacity) {
    char v8 = 1;
  }
  else {
    char v8 = 3;
  }

  return (CFMutableDataRef)__CFDataInit((__objc2_class **)allocator, v8, capacity, BytePtr, v7, 0);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  if (!dyld_program_sdk_at_least()) {
    goto LABEL_31;
  }
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    return (CFDataRef)[(__CFData *)theData copy];
  }
  char v5 = atomic_load((unint64_t *)theData + 1);
  if (v5) {
    goto LABEL_31;
  }
  BOOL ShouldUseAllocator = __CFDataShouldUseAllocator((__objc2_class **)allocator);
  CFAllocatorRef v7 = 0;
  if (ShouldUseAllocator) {
    CFAllocatorRef v8 = allocator;
  }
  else {
    CFAllocatorRef v8 = 0;
  }
  char v9 = atomic_load((unint64_t *)theData + 1);
  if ((v9 & 8) != 0)
  {
    if (((unint64_t)theData & 0x8000000000000000) != 0)
    {
      CFIndex v10 = &kCFAllocatorSystemDefault;
    }
    else
    {
      char v11 = atomic_load((unint64_t *)theData + 1);
      if (v11 < 0) {
        CFIndex v10 = &kCFAllocatorSystemDefault;
      }
      else {
        CFIndex v10 = (const CFAllocatorRef *)((char *)theData - 16);
      }
    }
    CFAllocatorRef v7 = *v10;
  }
  if (v8 == v7 && ((char v14 = atomic_load((unint64_t *)theData + 1), (v14 & 4) != 0) || !*((void *)theData + 4)))
  {
    return (CFDataRef)CFRetain(theData);
  }
  else
  {
LABEL_31:
    if (CF_IS_OBJC(0x14uLL, (unint64_t)theData)) {
      uint64_t v12 = [(__CFData *)theData length];
    }
    else {
      uint64_t v12 = *((void *)theData + 2);
    }
    BytePtr = CFDataGetBytePtr(theData);
    return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, v12, BytePtr, v12, 0);
  }
}

void sub_182C5FB8C()
{
  objc_end_catch();
  _Unwind_Resume(v0);
}

void sub_182C5FBA4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *exc_buf)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x182C5FB64);
  }
  _Unwind_Resume(v10);
}

void sub_182C5FBBC()
{
  _Unwind_Resume(v0);
}

void sub_182C5FBC4()
{
  objc_end_catch();
  _Unwind_Resume(v0);
}

void sub_182C5FBDC()
{
  objc_end_catch();
  _Unwind_Resume(v0);
}

void sub_182C5FBF4(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x182C5FBFCLL);
  }
  objc_terminate();
}

uint64_t _CFPrefsDomainSizeAcceptabilityForByteCount(unint64_t a1)
{
  if (a1 < 0x400001) {
    unsigned int v1 = 1;
  }
  else {
    unsigned int v1 = 2;
  }
  if (a1 > 0x300000) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t _CFPrefsEncodeKeyValuePairsIntoMessage(xpc_object_t xdict, __objc2_class ***a2, __objc2_class ***a3, uint64_t a4, void *a5)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (a4 <= 0) {
    _CFPrefsEncodeKeyValuePairsIntoMessage_cold_1();
  }
  uint64_t v6 = a4;
  CFAllocatorRef v8 = (const __CFString **)a2;
  uint64_t v16 = 0;
  if (a4 == 1)
  {
    uint64_t result = _CFPrefsEncodeValueIntoMessage(xdict, "Key", *a2, &v16);
    if (result)
    {
      if (*a3) {
        char v11 = *a3;
      }
      else {
        char v11 = &__kCFNull;
      }
      uint64_t result = _CFPrefsEncodeValueIntoMessage(xdict, "Value", v11, &v16);
    }
  }
  else
  {
    xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
    char v13 = 1;
    do
    {
      CFStringRef v14 = *v8;
      if (*v8)
      {
        bzero(buffer, 0x402uLL);
        if ((v13 & 1) != 0 && CFStringGetCString(v14, buffer, 1026, 0x8000100u))
        {
          if (*a3) {
            size_t v15 = *a3;
          }
          else {
            size_t v15 = &__kCFNull;
          }
          char v13 = _CFPrefsEncodeValueIntoMessage(v12, buffer, v15, &v16);
        }
        else
        {
          char v13 = 0;
        }
      }
      ++a3;
      ++v8;
      --v6;
    }
    while (v6);
    xpc_dictionary_set_BOOL(xdict, "MultiKeySet", 1);
    xpc_dictionary_set_value(xdict, "Value", v12);
    xpc_release(v12);
    uint64_t result = v13 & 1;
  }
  if (a5) {
    *a5 = v16;
  }
  return result;
}

void sub_182C5FE84(_Unwind_Exception *a1)
{
}

void sub_182C600C0(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_182C600D8(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x182C600E4);
}

BOOL __CFNumberEqual(const __CFNumber *a1, const __CFNumber *a2, void *a3)
{
  return CFNumberCompare(a1, a2, a3) == kCFCompareEqualTo;
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x16uLL, (unint64_t)number))
  {
    return [(__CFNumber *)number compare:otherNumber];
  }
  if (!CF_IS_OBJC(0x16uLL, (unint64_t)otherNumber))
  {
    if (((unint64_t)number & 0x8000000000000000) == 0) {
      goto LABEL_20;
    }
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)number & 0xC000000000000007) == 0) {
      uint64_t v7 = 0;
    }
    unint64_t v8 = v7 ^ (unint64_t)number;
    unint64_t v9 = v8 & 7;
    while (v9 != *((unsigned __int8 *)off_1ECE0A6E0 + v6))
    {
      if (++v6 == 7) {
        goto LABEL_20;
      }
    }
    if (v6 == 3)
    {
      uint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
      if (v9 == 7) {
        uint64_t v10 = 0xFFFFFFFFFFFFFLL;
      }
      unint64_t v11 = v10 & (v8 >> 3);
    }
    else
    {
LABEL_20:
      LOBYTE(v11) = atomic_load((unint64_t *)number + 1);
    }
    uint64_t v12 = __CFNumberCanonicalTypes[v11 & 7];
    if (((unint64_t)otherNumber & 0x8000000000000000) == 0) {
      goto LABEL_32;
    }
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)otherNumber & 0xC000000000000007) == 0) {
      uint64_t v14 = 0;
    }
    unint64_t v15 = v14 ^ (unint64_t)otherNumber;
    unint64_t v16 = v15 & 7;
    while (v16 != *((unsigned __int8 *)off_1ECE0A6E0 + v13))
    {
      if (++v13 == 7) {
        goto LABEL_32;
      }
    }
    if (v13 == 3)
    {
      uint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      if (v16 == 7) {
        uint64_t v17 = 0xFFFFFFFFFFFFFLL;
      }
      unint64_t v18 = v17 & (v15 >> 3);
    }
    else
    {
LABEL_32:
      LOBYTE(v18) = atomic_load((unint64_t *)otherNumber + 1);
    }
    int v19 = __CFNumberTypeTable[__CFNumberCanonicalTypes[v18 & 7]] & 0x20;
    if ((__CFNumberTypeTable[v12] & 0x20) != 0)
    {
      if (v19)
      {
        double v36 = 0.0;
        double v34 = 0.0;
        __CFNumberGetValue((uint64_t)number, 6, (uint64_t)&v36);
        __CFNumberGetValue((uint64_t)otherNumber, 6, (uint64_t)&v34);
        *(double *)v23.i64 = v36;
        v24.i64[0] = 1.0;
        v25.f64[0] = NAN;
        v25.f64[1] = NAN;
        int8x16_t v26 = (int8x16_t)vnegq_f64(v25);
        v25.f64[0] = v34;
        double v27 = *(double *)vbslq_s8(v26, v24, (int8x16_t)v25).i64;
        double v28 = *(double *)vbslq_s8(v26, v24, v23).i64;
        if (v28 >= v27)
        {
          if (v27 < v28) {
            return 1;
          }
          if (v36 >= v34) {
            return (unint64_t)(v34 < v36);
          }
        }
        return -1;
      }
    }
    else if (!v19)
    {
      double v36 = 0.0;
      unint64_t v37 = 0;
      double v34 = 0.0;
      unint64_t v35 = 0;
      __CFNumberGetValue((uint64_t)number, 17, (uint64_t)&v36);
      __CFNumberGetValue((uint64_t)otherNumber, 17, (uint64_t)&v34);
      if (*(uint64_t *)&v36 >= *(uint64_t *)&v34)
      {
        if (*(uint64_t *)&v36 <= *(uint64_t *)&v34)
        {
          if (v37 >= v35) {
            return (unint64_t)(v37 > v35);
          }
          return -1;
        }
        return 1;
      }
      return -1;
    }
    if (v19) {
      CFNumberRef v20 = number;
    }
    else {
      CFNumberRef v20 = otherNumber;
    }
    if (!v19) {
      otherNumber = number;
    }
    double v32 = 0.0;
    double v33 = 0.0;
    __CFNumberGetValue((uint64_t)otherNumber, 6, (uint64_t)&v33);
    if (v33 < -1.70141183e38) {
      goto LABEL_46;
    }
    if (v33 >= 1.70141183e38) {
      goto LABEL_67;
    }
    double v36 = 0.0;
    unint64_t v37 = 0;
    double v34 = 0.0;
    unint64_t v35 = 0;
    __CFNumberGetValue((uint64_t)otherNumber, 17, (uint64_t)&v36);
    __CFNumberGetValue((uint64_t)v20, 17, (uint64_t)&v34);
    if (*(uint64_t *)&v36 < *(uint64_t *)&v34)
    {
LABEL_51:
      CFComparisonResult v22 = kCFCompareLessThan;
LABEL_56:
      BOOL v21 = v19 == 0;
      goto LABEL_68;
    }
    if (*(uint64_t *)&v36 > *(uint64_t *)&v34) {
      goto LABEL_55;
    }
    if (v37 < v35) {
      goto LABEL_51;
    }
    if (v37 > v35)
    {
LABEL_55:
      CFComparisonResult v22 = kCFCompareGreaterThan;
      goto LABEL_56;
    }
    *(double *)v29.i64 = v33;
    v30.i64[0] = 1.0;
    v31.f64[0] = NAN;
    v31.f64[1] = NAN;
    v29.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v31), v30, v29).u64[0];
    if (v34 < 0.0) {
      *(double *)v30.i64 = -1.0;
    }
    if (*(double *)v29.i64 >= *(double *)v30.i64)
    {
      if (*(double *)v30.i64 < *(double *)v29.i64)
      {
LABEL_67:
        BOOL v21 = v19 == 0;
        CFComparisonResult v22 = kCFCompareGreaterThan;
LABEL_68:
        if (v21) {
          return v22;
        }
        else {
          return -(uint64_t)v22;
        }
      }
      __CFNumberGetValue((uint64_t)v20, 6, (uint64_t)&v32);
      if (v33 >= v32)
      {
        if (v32 >= v33) {
          return 0;
        }
        goto LABEL_67;
      }
    }
LABEL_46:
    BOOL v21 = v19 == 0;
    CFComparisonResult v22 = kCFCompareLessThan;
    goto LABEL_68;
  }

  return [(__CFNumber *)otherNumber _reverseCompare:number];
}

uint64_t __CFGetNextSearchPathEnumeration(uint64_t a1, char *a2, int64_t a3)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if (a3 > 1023)
  {
    return MEMORY[0x185312640](a1, a2);
  }
  else
  {
    unsigned int v5 = MEMORY[0x185312640](a1, __source);
    strlcpy(a2, __source, a3);
  }
  return v5;
}

void _CFPreferencesSetAppValueWithContainerAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v11 = v10;
  [v10 setValue:a2 forKey:a1 appIdentifier:a3 container:a4 configurationURL:a5];
}

__CFString *_CFPrefsCopyUserNameForUID(uid_t a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  int v2 = cfprefsdEuid();
  if (v2 == a1)
  {
    block[0] = off_1ECE0A5A0;
    block[1] = 3221225472;
    block[2] = ___CFPrefsCopyUserNameForUID_block_invoke;
    block[3] = &__block_descriptor_36_e5_v8__0l;
    uid_t v10 = a1;
    if (_CFPrefsCopyUserNameForUID_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyUserNameForUID_onceToken, block);
    }
    unint64_t v3 = (const void *)_CFPrefsCopyUserNameForUID_ourUIDName;
    if (_CFPrefsCopyUserNameForUID_ourUIDName) {
      return (__CFString *)CFRetain(v3);
    }
    return 0;
  }
  v7[0] = off_1ECE0A5A0;
  v7[1] = 3221225472;
  v7[2] = ___CFPrefsCopyUserNameForUID_block_invoke_2;
  v7[3] = &__block_descriptor_36_e5_v8__0l;
  int v8 = v2;
  if (_CFPrefsCopyUserNameForUID_onceToken_96 != -1) {
    dispatch_once(&_CFPrefsCopyUserNameForUID_onceToken_96, v7);
  }
  if (_CFPrefsCopyUserNameForUID_otherCommonUID != a1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&_CFPrefsCopyUserNameForUID___cacheLock);
    if (_CFPrefsCopyUserNameForUID___cacheKey == a1 && _CFPrefsCopyUserNameForUID___hasCache == 1)
    {
      uint64_t v4 = (__CFString *)_CFPrefsCopyUserNameForUID___cachedResult;
    }
    else
    {
      unsigned int v5 = _calculateUserNameForUID(a1);
      uint64_t v4 = v5;
      if (!v5)
      {
LABEL_17:
        os_unfair_lock_unlock((os_unfair_lock_t)&_CFPrefsCopyUserNameForUID___cacheLock);
        return v4;
      }
      _CFPrefsCopyUserNameForUID___cacheKey = a1;
      _CFPrefsCopyUserNameForUID___hasCache = 1;
      _CFPrefsCopyUserNameForUID___cachedResult = (uint64_t)v5;
    }
    CFRetain(v4);
    goto LABEL_17;
  }
  unint64_t v3 = (const void *)_CFPrefsCopyUserNameForUID_otherCommonUIDName;
  if (!_CFPrefsCopyUserNameForUID_otherCommonUIDName) {
    return 0;
  }
  return (__CFString *)CFRetain(v3);
}

uint64_t cfprefsdEuid()
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    if (cfprefsdEuid_onceToken != -1) {
      dispatch_once(&cfprefsdEuid_onceToken, &__block_literal_global_45);
    }
    return cfprefsdEuid_euid;
  }
  else
  {
    return geteuid();
  }
}

uint64_t _CFPropertyListValidateData(const __CFData *a1, void *a2)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  char v10 = 0;
  memset(v12, 0, sizeof(v12));
  *(void *)unint64_t v9 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  unint64_t Length = CFDataGetLength(a1);
  if (Length >= 8
    && (int v6 = Length, __CFDataGetBinaryPlistTopLevelInfo(a1, &v10, (unint64_t *)v9, (uint64_t)v12)))
  {
    CFTypeRef cf = 0;
    uint64_t result = __CFBinaryPlistCreateObjectFiltered(BytePtr, v6, *(unint64_t *)v9, (uint64_t)v12, &__kCFAllocatorSystemDefault, 0, 0, 0, 0, 0, 0, 0, (CFTypeID *)&cf);
    if (a2) {
      *a2 = cf;
    }
  }
  else
  {
    CFTypeRef cf = 0;
    _CFPropertyListCreateWithData(&__kCFAllocatorSystemDefault, a1, 1u, 0, 1, 0, 0, &cf);
    CFTypeRef v8 = cf;
    if (cf)
    {
      if (a2) {
        *a2 = CFGetTypeID(cf);
      }
      CFRelease(v8);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_182C61EBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id location)
{
  objc_destroyWeak(v35);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _canDup()
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    char v0 = 1;
  }
  else
  {
    if (_canDup_once != -1) {
      dispatch_once(&_canDup_once, &__block_literal_global_371);
    }
    char v0 = _canDup_canDup ^ 1;
  }
  return v0 & 1;
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  uint64_t v3 = (uint64_t)allocator;
  if (allocator && allocator != (CFAllocatorRef)939)
  {
    unint64_t v4 = *(void *)allocator & ~(unint64_t)off_1ECE0A6D0;
    if ((*(void *)allocator & (unint64_t)off_1ECE0A6D0) != 0) {
      v4 |= *(void *)allocator & (unint64_t)off_1ECE0A6D0;
    }
    if (v4 != qword_1EB1DDDA0) {
      return 0;
    }
  }
  CFAllocatorAllocateCallBack allocate = context->allocate;
  info = context->info;
  CFAllocatorRetainCallBack retain = context->retain;
  if (retain) {
    info = (void *)((uint64_t (*)(void *))retain)(context->info);
  }
  if (!v3)
  {
    uint64_t v9 = _CFGetTSD(1u);
    if (v9) {
      uint64_t v3 = v9;
    }
    else {
      uint64_t v3 = (uint64_t)&__kCFAllocatorSystemDefault;
    }
    goto LABEL_16;
  }
  if (v3 != 939)
  {
LABEL_16:
    Impl = (char *)_CFAllocatorAllocateImpl((malloc_zone_t *)v3, 0xE0uLL, 0x10F00406A531AB1uLL, 0);
    if (!Impl) {
      return (CFAllocatorRef)Impl;
    }
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    goto LABEL_19;
  }
  if (!allocate) {
    return 0;
  }
  Impl = (char *)((uint64_t (*)(uint64_t, void, void *))allocate)(224, 0, info);
  if (!Impl) {
    return (CFAllocatorRef)Impl;
  }
  uint64_t v3 = 939;
LABEL_19:
  *(void *)Impl = 0;
  *((void *)Impl + 1) = 0;
  __CFRuntimeSetRC((uint64_t)Impl, 1u);
  _CFRuntimeSetInstanceTypeID((uint64_t)Impl, 2uLL);
  if (qword_1EB1DDDA0) {
    uint64_t v10 = qword_1EB1DDDA0;
  }
  else {
    uint64_t v10 = 0;
  }
  *(void *)Impl = v10;
  *((void *)Impl + 2) = __CFAllocatorCustomSize;
  *((void *)Impl + 3) = __CFAllocatorCustomMalloc;
  *((void *)Impl + 4) = __CFAllocatorCustomCalloc;
  *((void *)Impl + 5) = __CFAllocatorCustomValloc;
  *((void *)Impl + 6) = __CFAllocatorCustomFree;
  *((void *)Impl + 7) = __CFAllocatorCustomRealloc;
  *((void *)Impl + 8) = __CFAllocatorCustomDestroy;
  *((void *)Impl + 9) = "Custom CFAllocator";
  *((void *)Impl + 10) = 0;
  *((void *)Impl + 11) = 0;
  *((void *)Impl + 12) = __CFAllocatorZoneIntrospect;
  *((_DWORD *)Impl + 26) = 6;
  *((void *)Impl + 14) = 0;
  *((void *)Impl + 15) = 0;
  CFIndex version = context->version;
  *((void *)Impl + 16) = v3;
  *((void *)Impl + 17) = version;
  *((void *)Impl + 18) = info;
  *((void *)Impl + 19) = retain;
  *((_OWORD *)Impl + 10) = *(_OWORD *)&context->release;
  *((void *)Impl + 22) = allocate;
  *(_OWORD *)(Impl + 184) = *(_OWORD *)&context->reallocate;
  *((void *)Impl + 25) = context->preferredSize;
  *((void *)Impl + 26) = 0;
  *((void *)Impl + 27) = 0;
  return (CFAllocatorRef)Impl;
}

void __CFRuntimeSetRC(uint64_t a1, unsigned __int16 a2)
{
  unint64_t v2 = atomic_load((unint64_t *)(a1 + 8));
  atomic_store(v2 & 0xFFFFFFFFFFFFLL | ((unint64_t)a2 << 48), (unint64_t *)(a1 + 8));
}

unint64_t *_CFDataCreateFixedMutableWithBuffer(__objc2_class **a1, unint64_t a2, const UInt8 *a3, const void *a4)
{
  return __CFDataInit(a1, 1, a2, a3, 0, a4);
}

void *allocatePurgeable(int64_t a1, uint64_t a2, uint64_t a3)
{
  v8[1] = *(void *)off_1ECE0A5B0;
  v8[0] = 0;
  if (a1 <= 0) {
    int64_t v5 = *(void *)off_1ECE0A708;
  }
  else {
    int64_t v5 = a1;
  }
  vm_size_t v6 = (*(void *)off_1ECE0A708 + v5 - 1) & -*(void *)off_1ECE0A708;
  if (vm_allocate(*(_DWORD *)off_1ECE0A6C8, v8, v6, -268435453))
  {
    *(unsigned char *)(a3 + 25) = 1;
    *(void *)(a3 + 16) = a1;
    return malloc_type_malloc(a1, 0xB0F897C4uLL);
  }
  else
  {
    *(void *)(a3 + 16) = v6;
    return (void *)v8[0];
  }
}

unint64_t *__CFBinaryPlistCreateDataUsingExternalBufferAllocator(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v8 = __CFBinaryPlistWriteOrPresize(a1, 0, a3, a4, 1, a5);
  if (v8 < 1) {
    return 0;
  }
  unint64_t v9 = v8;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, v8);
  if (!v10)
  {
    if (!a5) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because an allocator could not be created.");
    goto LABEL_13;
  }
  uint64_t v11 = (const void *)v10;
  uint64_t Typed = (const UInt8 *)CFAllocatorAllocateTyped(v10, v9, 120675696, 0);
  if (!Typed)
  {
    CFRelease(v11);
    if (!a5) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because an external buffer could not be allocated.");
    goto LABEL_13;
  }
  uint64_t v13 = (UInt8 *)Typed;
  FixedMutableWithBuffer = _CFDataCreateFixedMutableWithBuffer(&__kCFAllocatorSystemDefault, v9, Typed, v11);
  if (!FixedMutableWithBuffer)
  {
    CFAllocatorDeallocate((CFAllocatorRef)v11, v13);
    if (!a5) {
      return 0;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3851, @"Binary property list writing could not be completed because a CFMutableDataRef using the external buffer could not be allocated.");
LABEL_13:
    unint64_t v15 = 0;
    *a5 = Error;
    return v15;
  }
  unint64_t v15 = FixedMutableWithBuffer;
  CFRelease(v11);
  if (v9 != __CFBinaryPlistWriteOrPresize(a1, v15, v16, v17, 0, a5))
  {
    CFRelease(v15);
    return 0;
  }
  return v15;
}

BOOL CFPreferencesIsManaged(__CFString *a1, int a2)
{
  uint64_t v3 = a1;
  if (CFEqual(a1, @"kCFPreferencesAnyUser")
    || CFEqual(v3, @"kCFPreferencesCurrentUser") && !cfprefsdEuid())
  {
    return _CFPrefsIsUserManaged(@"kCFPreferencesAnyUser", a2);
  }
  if (CFEqual(v3, @"kCFPreferencesCurrentUser"))
  {
    if (_CFPrefsCurrentProcessIsCFPrefsD()) {
      int64_t v5 = _CFPrefsDCopyCurrentUserName();
    }
    else {
      int64_t v5 = (__CFString *)CFCopyUserName();
    }
    uint64_t v3 = v5;
  }
  else
  {
    CFRetain(v3);
  }
  BOOL IsUserManaged = _CFPrefsIsUserManaged(v3, a2);
  CFRelease(v3);
  return IsUserManaged;
}

BOOL _CFPrefsIsUserManaged(__CFString *a1, int a2)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  os_unfair_lock_lock((os_unfair_lock_t)&managedPreferencesLock);
  CFDictionaryRef ManagedStateCache = locked_getManagedStateCache(a2);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ManagedStateCache, a1);
  *(_DWORD *)char valuePtr = 0;
  if (!Value || !CFNumberGetValue(Value, kCFNumberIntType, valuePtr) || (int v6 = *(_DWORD *)valuePtr) == 0)
  {
    bzero(valuePtr, 0x400uLL);
    if (_CFPrefsGetPathForManagedBundleID(0, a1, a2, valuePtr))
    {
      memset(&v11, 0, sizeof(v11));
      if (stat((const char *)valuePtr, &v11)) {
        int v6 = 2;
      }
      else {
        int v6 = 1;
      }
    }
    else
    {
      int v6 = 0;
    }
    uint64_t v7 = _CFPrefsClientLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      _CFPrefsIsUserManaged_cold_1(v6, (uint64_t)a1, v7);
    }
    v11.st_dev = v6;
    uint64_t v8 = locked_getManagedStateCache(a2);
    CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberIntType, &v11);
    CFDictionarySetValue(v8, a1, v9);
    CFRelease(v9);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&managedPreferencesLock);
  return v6 == 1;
}

CFMutableDictionaryRef locked_getManagedStateCache(int a1)
{
  if (a1)
  {
    CFMutableDictionaryRef result = (CFMutableDictionaryRef)locked_getManagedStateCache_knownContainerizedManagedPrefsStates;
    if (!locked_getManagedStateCache_knownContainerizedManagedPrefsStates)
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      locked_getManagedStateCache_knownContainerizedManagedPrefsStates = (uint64_t)result;
    }
  }
  else
  {
    CFMutableDictionaryRef result = (CFMutableDictionaryRef)locked_getManagedStateCache_knownManagedPrefsStates;
    if (!locked_getManagedStateCache_knownManagedPrefsStates)
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      locked_getManagedStateCache_knownManagedPrefsStates = (uint64_t)result;
    }
  }
  return result;
}

void sub_182C638F0(_Unwind_Exception *a1)
{
}

CFMutableBitVectorRef CFBitVectorCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 1, 0, 0);
}

void __getDefaultArguments_block_invoke()
{
  v13[1] = *(id *)off_1ECE0A5B0;
  if (!issetugid())
  {
    getDefaultArguments___NSDefaultArguments = objc_opt_new();
    char v0 = [+[NSProcessInfo processInfo] arguments];
    uint64_t v1 = [(NSArray *)v0 count] - 1;
    if (v1 >= 2)
    {
      uint64_t v2 = 1;
      do
      {
        id v3 = [(NSArray *)v0 objectAtIndex:v2];
        uint64_t v4 = v2 + 1;
        if (![v3 hasPrefix:@"-"]) {
          goto LABEL_20;
        }
        int64_t v5 = [(NSArray *)v0 objectAtIndex:v2 + 1];
        if ([(__CFString *)v5 hasPrefix:@"-"]) {
          goto LABEL_20;
        }
        uint64_t v6 = -[__CFString rangeOfCharacterFromSet:options:range:](v5, "rangeOfCharacterFromSet:options:range:", [+[NSCharacterSet whitespaceAndNewlineCharacterSet](&off_1ECF63310, "whitespaceAndNewlineCharacterSet") invertedSet], 0, 0, [(__CFString *)v5 length]);
        if (!v7)
        {
          int64_t v5 = &stru_1ECE10768;
LABEL_18:
          objc_msgSend((id)getDefaultArguments___NSDefaultArguments, "setObject:forKeyedSubscript:", v5, objc_msgSend(v3, "substringFromIndex:", 1));
          goto LABEL_19;
        }
        int v8 = [(__CFString *)v5 characterAtIndex:v6];
        if (((v8 - 34) > 0x39 || ((1 << (v8 - 34)) & 0x200000004000041) == 0)
          && v8 != 123)
        {
          goto LABEL_18;
        }
        v13[0] = 0;
        CFNumberRef v9 = (__CFString *)(id)_CFPropertyListCreateFromXMLString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v5, 0, (CFStringRef *)v13, 1, 0);
        if (v13[0])
        {
          id v10 = v13[0];
          CFDataRef v11 = (const __CFData *)[(__CFString *)v5 dataUsingEncoding:4 allowLossyConversion:0];
          CFErrorRef error = 0;
          int64_t v5 = (id)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, 0, 0, &error);
          if (!v5 && error)
          {
            CFRelease(error);
            goto LABEL_19;
          }
        }
        else
        {
          int64_t v5 = v9;
        }
        if (v5) {
          goto LABEL_18;
        }
LABEL_19:
        uint64_t v4 = v2 + 2;
LABEL_20:
        uint64_t v2 = v4;
      }
      while (v4 < v1);
    }
  }
}

void __CFApplySurrogatesInString(uint64_t a1, CFStringRef theString, void (*a3)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(theString);
  CFStringRef theStringa = theString;
  uint64_t v28 = 0;
  CFIndex v29 = Length;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0;
  int8x16_t v26 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  }
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  double v27 = CStringPtr;
  if (Length >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    memset(v24, 0, sizeof(v24));
    do
    {
      if (v26)
      {
        UniChar v12 = v26[v28 + v9];
      }
      else if (v27)
      {
        UniChar v12 = v27[v28 + v9];
      }
      else
      {
        uint64_t v13 = v30;
        if (v31 <= v9 || v30 > v9)
        {
          uint64_t v15 = v9 - 4;
          if (v9 < 4) {
            uint64_t v15 = 0;
          }
          CFIndex v16 = v15 + 64;
          if (v15 + 64 >= v29) {
            CFIndex v16 = v29;
          }
          uint64_t v30 = v15;
          uint64_t v31 = v16;
          v33.CFIndex location = v28 + v15;
          v33.CFIndex length = v16 - v15;
          CFStringGetCharacters(theStringa, v33, (UniChar *)v24);
          uint64_t v13 = v30;
        }
        UniChar v12 = *((_WORD *)v24 + v9 - v13);
      }
      CFIndex v17 = v9 + 1;
      if (v12 >> 10 == 54 && v17 < Length)
      {
        if (v26)
        {
          UniChar v19 = v26[v28 + v17];
        }
        else if (v27)
        {
          UniChar v19 = v27[v28 + v17];
        }
        else
        {
          if (v31 <= v17 || (uint64_t v20 = v30, v30 > v17))
          {
            uint64_t v21 = v9 - 3;
            if (v9 < 3) {
              uint64_t v21 = 0;
            }
            CFIndex v22 = v21 + 64;
            if (v21 + 64 >= v29) {
              CFIndex v22 = v29;
            }
            uint64_t v30 = v21;
            uint64_t v31 = v22;
            v34.CFIndex location = v28 + v21;
            v34.CFIndex length = v22 - v21;
            CFStringGetCharacters(theStringa, v34, (UniChar *)v24);
            uint64_t v20 = v30;
          }
          UniChar v19 = *((_WORD *)v24 + v17 - v20);
        }
        if (v19 >> 10 == 55)
        {
          uint64_t v23 = (v12 << 10) + v19 - 56613888;
          if (v10 + v11 == v23)
          {
            ++v10;
          }
          else
          {
            if (v10 >= 1) {
              a3(a1, v11, v10);
            }
            uint64_t v11 = v23;
            uint64_t v10 = 1;
          }
        }
      }
      else
      {
        CFIndex v17 = v9;
      }
      uint64_t v9 = v17 + 1;
    }
    while (v17 + 1 < Length);
    if (v10 >= 1) {
      a3(a1, v11, v10);
    }
  }
}

void _CFCharacterSetCompact(unint64_t *cf)
{
  char v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x30 && cf[3]) {
    __CFCSetMakeCompact(cf);
  }
  unint64_t v3 = cf[5];
  if (v3 && *(_DWORD *)(v3 + 8))
  {
    for (uint64_t i = 0; i != 16; ++i)
    {
      unint64_t v5 = cf[5];
      if (v5)
      {
        if (((*(_DWORD *)(v5 + 8) >> (i + 1)) & 1) != 0
          && *(unsigned __int8 *)(v5 + 12) >= (i + 1))
        {
          uint64_t v6 = *(unint64_t **)(*(void *)v5 + 8 * i);
          if (v6)
          {
            char v7 = atomic_load(v6 + 1);
            if ((v7 & 0x70) == 0x30)
            {
              if (v6[3]) {
                __CFCSetMakeCompact(v6);
              }
            }
          }
        }
      }
    }
  }
}

void __CFCSetMakeCompact(unint64_t *cf)
{
  char v1 = atomic_load(cf + 1);
  if ((v1 & 0x70) == 0x30)
  {
    unint64_t v3 = (unsigned __int8 *)cf[3];
    if (v3)
    {
      CFAllocatorRef v4 = CFGetAllocator(cf);
      unint64_t v5 = __CFCreateCompactBitmap((uint64_t)v4, v3);
      if (v5)
      {
        uint64_t v6 = v5;
        CFAllocatorRef v7 = CFGetAllocator(cf);
        CFAllocatorDeallocate(v7, v3);
        unint64_t v8 = atomic_load(cf + 1);
        unint64_t v9 = v8;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v9, v8 & 0xFFFFFFFFFFFFFF8FLL | 0x40);
          BOOL v10 = v9 == v8;
          unint64_t v8 = v9;
        }
        while (!v10);
        cf[3] = (unint64_t)v6;
      }
    }
  }
}

CFCharacterSetRef CFCharacterSetCreateWithBitmapRepresentation(CFAllocatorRef alloc, CFDataRef theData)
{
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  unint64_t v5 = Instance;
  if (!Instance) {
    return (CFCharacterSetRef)v5;
  }
  unint64_t v6 = atomic_load(Instance + 1);
  unint64_t v7 = v6;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v7, v6 & 0xFFFFFFFFFFFFFFFELL);
    BOOL v8 = v7 == v6;
    unint64_t v6 = v7;
  }
  while (!v8);
  unint64_t v9 = atomic_load(Instance + 1);
  unint64_t v10 = v9;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v10, v9 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
    BOOL v8 = v10 == v9;
    unint64_t v9 = v10;
  }
  while (!v8);
  Instance[2] = 0;
  Instance[5] = 0;
  if (!theData || (CFIndex Length = CFDataGetLength(theData), Length < 1))
  {
    v5[3] = 0;
    unint64_t v19 = atomic_load(v5 + 1);
    unint64_t v20 = v19;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v5 + 1, &v20, v19 | 4);
      BOOL v8 = v20 == v19;
      unint64_t v19 = v20;
    }
    while (!v8);
    return (CFCharacterSetRef)v5;
  }
  int64_t v12 = Length;
  if (!((unint64_t)Length >> 13))
  {
    uint64_t Typed = (char *)CFAllocatorAllocateTyped(alloc, 0x2000, 2153428176, 0);
    BytePtr = CFDataGetBytePtr(theData);
    memmove(Typed, BytePtr, v12);
    bzero(&Typed[v12], 0x2000 - v12);
    uint64_t v15 = __CFCreateCompactBitmap((uint64_t)alloc, (unsigned __int8 *)Typed);
    if (v15)
    {
      CFIndex v16 = v15;
      CFAllocatorDeallocate(alloc, Typed);
      v5[3] = (unint64_t)v16;
      unint64_t v17 = atomic_load(v5 + 1);
      unint64_t v18 = v17;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)v5 + 1, &v18, v17 & 0xFFFFFFFFFFFFFF8FLL | 0x40);
        BOOL v8 = v18 == v17;
        unint64_t v17 = v18;
      }
      while (!v8);
    }
    else
    {
      v5[3] = (unint64_t)Typed;
    }
    return (CFCharacterSetRef)v5;
  }
  CFIndex v22 = (unsigned __int8 *)CFDataGetBytePtr(theData);
  uint64_t v23 = __CFCreateCompactBitmap((uint64_t)alloc, v22);
  if (v23)
  {
    v5[3] = (unint64_t)v23;
    unint64_t v24 = atomic_load(v5 + 1);
    unint64_t v25 = v24;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v5 + 1, &v25, v24 & 0xFFFFFFFFFFFFFF8FLL | 0x40);
      BOOL v8 = v25 == v24;
      unint64_t v24 = v25;
    }
    while (!v8);
  }
  else
  {
    int8x16_t v26 = (void *)CFAllocatorAllocateTyped(alloc, 0x2000, 865737595, 0);
    double v27 = CFDataGetBytePtr(theData);
    memmove(v26, v27, 0x2000uLL);
    v5[3] = (unint64_t)v26;
  }
  uint64_t v28 = v12 - 0x2000;
  if (v12 <= 0x2000) {
    return (CFCharacterSetRef)v5;
  }
  CFCharacterSetRef result = (CFCharacterSetRef)CFDataGetBytePtr(theData);
  if (v12 == 8193) {
    return (CFCharacterSetRef)v5;
  }
  CFIndex v29 = (unsigned __int8 *)result;
  while (1)
  {
    uint64_t v30 = v29[0x2000];
    if (!v29[0x2000]) {
      break;
    }
    if (v30 <= 0x10)
    {
      unint64_t v32 = v5[5];
      if (v32)
      {
        if (*(unsigned __int8 *)(v32 + 12) < v30)
        {
          *(unsigned char *)(v32 + 12) = v30;
          uint64_t v33 = *(void *)v32;
          CFAllocatorRef v34 = CFGetAllocator(v5);
          if (v33)
          {
            uint64_t v35 = __CFSafelyReallocateWithAllocatorTyped(v34, *(void *)v5[5], 8 * v30, 0x6004044C4A2DFLL, 0, 0);
            goto LABEL_39;
          }
LABEL_38:
          uint64_t v35 = CFAllocatorAllocateTyped(v34, 8 * v30, 0x6004044C4A2DFLL, 0);
LABEL_39:
          unint64_t v32 = v5[5];
          *(void *)unint64_t v32 = v35;
        }
        if ((*(_DWORD *)(v32 + 8) & (1 << v30)) != 0)
        {
          uint64_t v38 = (v30 - 1);
        }
        else
        {
          CFAllocatorRef v39 = CFGetAllocator(v5);
          CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v39);
          uint64_t v38 = (v30 - 1);
          *(void *)(*(void *)v5[5] + 8 * v38) = Mutable;
          unint64_t v32 = v5[5];
          *(_DWORD *)(v32 + 8) |= 1 << v30;
        }
        uint64_t v31 = *(void *)(*(void *)v32 + 8 * v38);
        goto LABEL_44;
      }
      CFAllocatorRef v36 = CFGetAllocator(v5);
      uint64_t v37 = CFAllocatorAllocateTyped(v36, 16, 0x1080040FC6463CFLL, 0);
      v5[5] = v37;
      *(unsigned char *)(v37 + 12) = v30;
      *(unsigned char *)(v37 + 13) = 0;
      *(_DWORD *)(v37 + 8) = 0;
      CFAllocatorRef v34 = CFGetAllocator(v5);
      goto LABEL_38;
    }
    uint64_t v31 = 0;
LABEL_44:
    v29 += 8193;
    if ((unint64_t)v28 > 0x2000)
    {
      CFCharacterSetRef result = (CFCharacterSetRef)__CFCreateCompactBitmap((uint64_t)alloc, v29);
      if (result)
      {
        *(void *)(v31 + 24) = result;
        unint64_t v45 = atomic_load((unint64_t *)(v31 + 8));
        unint64_t v46 = v45;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 8), &v46, v45 & 0xFFFFFFFFFFFFFF8FLL | 0x40);
          BOOL v8 = v46 == v45;
          unint64_t v45 = v46;
        }
        while (!v8);
      }
      else
      {
        uint64_t v49 = (void *)CFAllocatorAllocateTyped(alloc, 0x2000, 1506995671, 0);
        CFCharacterSetRef result = (CFCharacterSetRef)memmove(v49, v29, 0x2000uLL);
        *(void *)(v31 + 24) = v49;
        unint64_t v50 = atomic_load((unint64_t *)(v31 + 8));
        unint64_t v51 = v50;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 8), &v51, v50 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
          BOOL v8 = v51 == v50;
          unint64_t v50 = v51;
        }
        while (!v8);
      }
    }
    else
    {
      uint64_t v41 = (char *)CFAllocatorAllocateTyped(alloc, 0x2000, 263798340, 0);
      memmove(v41, v29, v28 - 1);
      bzero(&v41[v28 - 1], 8193 - v28);
      CFCharacterSetRef result = (CFCharacterSetRef)__CFCreateCompactBitmap((uint64_t)alloc, (unsigned __int8 *)v41);
      if (result)
      {
        CFCharacterSetRef v42 = result;
        CFAllocatorDeallocate(alloc, v41);
        *(void *)(v31 + 24) = v42;
        unint64_t v43 = atomic_load((unint64_t *)(v31 + 8));
        unint64_t v44 = v43;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 8), &v44, v43 & 0xFFFFFFFFFFFFFF8FLL | 0x40);
          BOOL v8 = v44 == v43;
          unint64_t v43 = v44;
        }
        while (!v8);
      }
      else
      {
        *(void *)(v31 + 24) = v41;
        unint64_t v47 = atomic_load((unint64_t *)(v31 + 8));
        unint64_t v48 = v47;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 8), &v48, v47 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
          BOOL v8 = v48 == v47;
          unint64_t v47 = v48;
        }
        while (!v8);
      }
    }
    BOOL v52 = v28 <= 8194;
    v28 -= 8193;
    if (v52) {
      return (CFCharacterSetRef)v5;
    }
  }
  __break(1u);
  return result;
}

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  unint64_t v2 = MEMORY[0x1F4188790](theSet, theOtherSet);
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  uint64_t v122 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    [(id)v5 formUnionWithCharacterSet:v4];
    return;
  }
  char v12 = atomic_load((unint64_t *)(v5 + 8));
  if ((v12 & 1) == 0)
  {
    CFLog(3, @"%s: Immutable character set passed to mutable function", v6, v7, v8, v9, v10, v11, (__int16)"void CFCharacterSetUnion(CFMutableCharacterSetRef, CFCharacterSetRef)");
    if (dyld_program_sdk_at_least()) {
      CFCharacterSetUnion_cold_1();
    }
  }
  char v13 = atomic_load((unint64_t *)(v5 + 8));
  if ((v13 & 0x70) != 0
    || (char v14 = atomic_load((unint64_t *)(v5 + 8)), (v14 & 1) != 0)
    || (char v15 = atomic_load((unint64_t *)(v5 + 8)), (v15 & 8) != 0)
    || CFCharacterSetGetPredefined(*(CFCharacterSetPredefinedSet *)(v5 + 24)) != (CFCharacterSetRef)v5)
  {
    uint64_t v16 = *(void *)(v5 + 40);
    if (v16)
    {
      if (*(_DWORD *)(v16 + 8) || *(unsigned char *)(v16 + 13)) {
        goto LABEL_20;
      }
    }
    unsigned int v17 = atomic_load((unint64_t *)(v5 + 8));
    switch((v17 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(void *)(v5 + 32)) {
          goto LABEL_20;
        }
        break;
      case 3u:
      case 4u:
        if (*(void *)(v5 + 24)) {
          goto LABEL_20;
        }
        break;
      default:
        goto LABEL_20;
    }
    char v18 = atomic_load((unint64_t *)(v5 + 8));
    if ((v18 & 8) == 0)
    {
LABEL_20:
      if (CF_IS_OBJC(0x19uLL, v4))
      {
        uint64_t v19 = [(id)v4 _expandedCFCharacterSet];
        if (!v19)
        {
          CFDataRef BitmapRepresentation = CFCharacterSetCreateBitmapRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFCharacterSetRef)v4);
          if (BitmapRepresentation)
          {
            CFDataRef v21 = BitmapRepresentation;
            if (CFDataGetLength(BitmapRepresentation))
            {
              BytePtr = CFDataGetBytePtr(v21);
              if (BytePtr)
              {
                uint64_t v23 = BytePtr;
                __CFCSetMakeBitmap((char *)v5);
                uint64_t v24 = 0;
                uint64_t v25 = *(void *)(v5 + 24);
                do
                {
                  *(_DWORD *)(v25 + v24) |= *(_DWORD *)&v23[v24];
                  v24 += 4;
                }
                while (v24 != 0x2000);
                unint64_t v26 = atomic_load((unint64_t *)(v5 + 8));
                unint64_t v27 = v26;
                do
                {
                  atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v27, v26 & 0xFFFFFFFFFFFFFFFBLL);
                  BOOL v28 = v27 == v26;
                  unint64_t v26 = v27;
                }
                while (!v28);
              }
            }
            CFRelease(v21);
          }
          return;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      if (v19) {
        unint64_t v4 = v19;
      }
      uint64_t v29 = *(void *)(v4 + 40);
      if (!v29 || !*(_DWORD *)(v29 + 8) && !*(unsigned char *)(v29 + 13))
      {
        unsigned int v30 = atomic_load((unint64_t *)(v4 + 8));
        switch((v30 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*(void *)(v4 + 32)) {
              goto LABEL_41;
            }
            break;
          case 3u:
          case 4u:
            if (*(void *)(v4 + 24)) {
              goto LABEL_41;
            }
            break;
          default:
            goto LABEL_41;
        }
        char v47 = atomic_load((unint64_t *)(v4 + 8));
        if ((v47 & 8) != 0)
        {
          char v48 = atomic_load((unint64_t *)(v5 + 8));
          if ((v48 & 0x70) == 0x20 && *(void *)(v5 + 24)
            || (char v49 = atomic_load((unint64_t *)(v5 + 8)), (v49 & 0x70) == 0x30) && *(void *)(v5 + 24)
            || (char v50 = atomic_load((unint64_t *)(v5 + 8)), (v50 & 0x70) == 0x40) && *(void *)(v5 + 24))
          {
            CFAllocatorRef v51 = CFGetAllocator((CFTypeRef)v5);
            CFAllocatorDeallocate(v51, *(void **)(v5 + 24));
          }
          unint64_t v52 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v53 = v52;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v53, v52 & 0xFFFFFFFFFFFFFF8FLL | 0x10);
            BOOL v28 = v53 == v52;
            unint64_t v52 = v53;
          }
          while (!v28);
          *(void *)(v5 + 32) = 0;
          unint64_t v54 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v55 = v54;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v55, v54 | 8);
            BOOL v28 = v55 == v54;
            unint64_t v54 = v55;
          }
          while (!v28);
          unint64_t v56 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v57 = v56;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v57, v56 & 0xFFFFFFFFFFFFFFFBLL);
            BOOL v28 = v57 == v56;
            unint64_t v56 = v57;
          }
          while (!v28);
          if (*(void *)(v5 + 40))
          {
            for (uint64_t i = 0; i != 16; ++i)
            {
              uint64_t v59 = *(void *)(v5 + 40);
              if (((*(_DWORD *)(v59 + 8) >> i) & 2) != 0) {
                CFRelease(*(CFTypeRef *)(*(void *)v59 + 8 * i));
              }
            }
            CFAllocatorRef v60 = CFGetAllocator((CFTypeRef)v5);
            CFAllocatorDeallocate(v60, **(void ***)(v5 + 40));
            CFAllocatorRef v61 = CFGetAllocator((CFTypeRef)v5);
            CFAllocatorDeallocate(v61, *(void **)(v5 + 40));
            *(void *)(v5 + 40) = 0;
          }
        }
        goto LABEL_168;
      }
LABEL_41:
      uint64_t v31 = (unint64_t *)(v4 + 8);
      char v32 = atomic_load((unint64_t *)(v4 + 8));
      if ((v32 & 0x70) == 0)
      {
        uint64_t v40 = *(void *)(v5 + 40);
        if (!v40 || !*(_DWORD *)(v40 + 8) && !*(unsigned char *)(v40 + 13))
        {
          unsigned int v41 = atomic_load((unint64_t *)(v5 + 8));
          switch((v41 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (*(void *)(v5 + 32)) {
                goto LABEL_42;
              }
              break;
            case 3u:
            case 4u:
              if (*(void *)(v5 + 24)) {
                goto LABEL_42;
              }
              break;
            default:
              goto LABEL_42;
          }
          unint64_t v95 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v96 = v95;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v96, v95 & 0xFFFFFFFFFFFFFF8FLL);
            BOOL v28 = v96 == v95;
            unint64_t v95 = v96;
          }
          while (!v28);
          *(void *)(v5 + 24) = *(void *)(v4 + 24);
          char v97 = atomic_load((unint64_t *)(v4 + 8));
          if ((v97 & 8) != 0)
          {
            unint64_t v98 = atomic_load((unint64_t *)(v5 + 8));
            unint64_t v99 = v98;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v99, v98 | 8);
              BOOL v28 = v99 == v98;
              unint64_t v98 = v99;
            }
            while (!v28);
          }
          uint64_t v100 = *(void *)(v4 + 40);
          if (v100 && *(unsigned char *)(v100 + 13))
          {
            uint64_t Typed = *(void *)(v5 + 40);
            if (!Typed)
            {
              CFAllocatorRef v102 = CFGetAllocator((CFTypeRef)v5);
              uint64_t Typed = CFAllocatorAllocateTyped(v102, 16, 0x1080040FC6463CFLL, 0);
              *(void *)(v5 + 40) = Typed;
              *(void *)uint64_t Typed = 0;
              *(void *)(Typed + 6) = 0;
            }
            *(unsigned char *)(Typed + 13) = 1;
          }
          unint64_t v103 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v104 = v103;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v104, v103 & 0xFFFFFFFFFFFFFFFBLL);
            BOOL v28 = v104 == v103;
            unint64_t v103 = v104;
          }
          while (!v28);
          goto LABEL_168;
        }
      }
LABEL_42:
      char v33 = atomic_load(v31);
      char v34 = atomic_load(v31);
      if ((v33 & 0x70) == 0x10)
      {
        int v35 = *(_DWORD *)(v4 + 24);
        if ((v34 & 8) != 0)
        {
          uint64_t v42 = *(void *)(v4 + 32);
          if (v35)
          {
            v124.CFIndex location = 0;
            v124.CFIndex length = *(unsigned int *)(v4 + 24);
            CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)v5, v124);
          }
          v37.CFIndex location = (v35 + v42);
          v37.CFIndex length = (1114112 - LODWORD(v37.location));
          CFAllocatorRef v36 = (__CFCharacterSet *)v5;
        }
        else
        {
          v37.CFIndex length = *(void *)(v4 + 32);
          CFAllocatorRef v36 = (__CFCharacterSet *)v5;
          v37.CFIndex location = *(unsigned int *)(v4 + 24);
        }
        CFCharacterSetAddCharactersInRange(v36, v37);
      }
      else if ((v34 & 0x70) == 0x20)
      {
        CFAllocatorRef v38 = CFGetAllocator((CFTypeRef)v5);
        CFStringRef v39 = CFStringCreateWithCharactersNoCopy(v38, *(const UniChar **)(v4 + 24), *(void *)(v4 + 32), (CFAllocatorRef)&__kCFAllocatorNull);
        CFCharacterSetAddCharactersInString((CFMutableCharacterSetRef)v5, v39);
        CFRelease(v39);
      }
      else
      {
        __CFCSetMakeBitmap((char *)v5);
        char v43 = atomic_load((unint64_t *)(v4 + 8));
        uint64_t v44 = *(void *)(v5 + 24);
        if ((v43 & 0x70) == 0x30)
        {
          uint64_t v45 = 0;
          uint64_t v46 = *(void *)(v4 + 24);
          do
          {
            *(_DWORD *)(v44 + v45) |= *(_DWORD *)(v46 + v45);
            v45 += 4;
          }
          while (v45 != 0x2000);
        }
        else
        {
          __CFCSetGetBitmap(v4, __b);
          for (uint64_t j = 0; j != 2048; ++j)
            *(_DWORD *)(v44 + j * 4) |= __b[0].u32[j];
        }
        unint64_t v63 = atomic_load((unint64_t *)(v5 + 8));
        unint64_t v64 = v63;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v64, v63 & 0xFFFFFFFFFFFFFFFBLL);
          BOOL v28 = v64 == v63;
          unint64_t v63 = v64;
        }
        while (!v28);
      }
      uint64_t v65 = *(void *)(v4 + 40);
      if (v65)
      {
        int v66 = *(unsigned __int8 *)(v65 + 13);
        if (*(_DWORD *)(v65 + 8))
        {
          uint64_t v67 = 0;
          uint64_t v68 = 8;
          while (1)
          {
            uint64_t v69 = *(void *)(v4 + 40);
            if (v69)
            {
              int v70 = 1 << (v67 + 1);
              if ((*(_DWORD *)(v69 + 8) & v70) != 0)
              {
                unsigned int v71 = (v67 + 1);
                if (*(unsigned __int8 *)(v69 + 12) >= v71)
                {
                  CFCharacterSetRef v72 = *(const __CFCharacterSet **)(*(void *)v69 + 8 * v67);
                  if (v72) {
                    break;
                  }
                }
              }
            }
LABEL_118:
            ++v67;
            v68 += 8;
            if (v67 == 16) {
              goto LABEL_168;
            }
          }
          unint64_t v73 = *(uint64_t **)(v5 + 40);
          if (!v66)
          {
            if (v73)
            {
              if (*((unsigned __int8 *)v73 + 12) < v71)
              {
                *((unsigned char *)v73 + 12) = v71;
                uint64_t v77 = *v73;
                CFAllocatorRef v78 = CFGetAllocator((CFTypeRef)v5);
                if (v77)
                {
                  uint64_t v79 = __CFSafelyReallocateWithAllocatorTyped(v78, **(void **)(v5 + 40), v68, 0x6004044C4A2DFLL, 0, 0);
                  goto LABEL_114;
                }
LABEL_113:
                uint64_t v79 = CFAllocatorAllocateTyped(v78, v68, 0x6004044C4A2DFLL, 0);
LABEL_114:
                unint64_t v73 = *(uint64_t **)(v5 + 40);
                *unint64_t v73 = v79;
              }
              if ((v73[1] & v70) == 0)
              {
                CFAllocatorRef v85 = CFGetAllocator((CFTypeRef)v5);
                *(void *)(**(void **)(v5 + 40) + 8 * v67) = CFCharacterSetCreateMutable(v85);
                unint64_t v73 = *(uint64_t **)(v5 + 40);
                *((_DWORD *)v73 + 2) |= v70;
              }
              CFCharacterSetUnion(*(CFMutableCharacterSetRef *)(*v73 + 8 * v67), v72);
              goto LABEL_118;
            }
            CFAllocatorRef v83 = CFGetAllocator((CFTypeRef)v5);
            uint64_t v84 = CFAllocatorAllocateTyped(v83, 16, 0x1080040FC6463CFLL, 0);
            *(void *)(v5 + 40) = v84;
            *(_WORD *)(v84 + 12) = v71;
            *(_DWORD *)(v84 + 8) = 0;
            CFAllocatorRef v78 = CFGetAllocator((CFTypeRef)v5);
            goto LABEL_113;
          }
          if (v73)
          {
            if (*((unsigned __int8 *)v73 + 12) >= v71)
            {
LABEL_109:
              if ((v73[1] & v70) == 0)
              {
                CFAllocatorRef v82 = CFGetAllocator((CFTypeRef)v5);
                *(void *)(**(void **)(v5 + 40) + 8 * v67) = CFCharacterSetCreateMutable(v82);
                unint64_t v73 = *(uint64_t **)(v5 + 40);
                *((_DWORD *)v73 + 2) |= v70;
              }
              CFCharacterSetIntersect(*(CFMutableCharacterSetRef *)(*v73 + 8 * v67), v72);
              goto LABEL_118;
            }
            *((unsigned char *)v73 + 12) = v71;
            uint64_t v74 = *v73;
            CFAllocatorRef v75 = CFGetAllocator((CFTypeRef)v5);
            if (v74)
            {
              uint64_t v76 = __CFSafelyReallocateWithAllocatorTyped(v75, **(void **)(v5 + 40), v68, 0x6004044C4A2DFLL, 0, 0);
LABEL_108:
              unint64_t v73 = *(uint64_t **)(v5 + 40);
              *unint64_t v73 = v76;
              goto LABEL_109;
            }
          }
          else
          {
            CFAllocatorRef v80 = CFGetAllocator((CFTypeRef)v5);
            uint64_t v81 = CFAllocatorAllocateTyped(v80, 16, 0x1080040FC6463CFLL, 0);
            *(void *)(v5 + 40) = v81;
            *(_WORD *)(v81 + 12) = v71;
            *(_DWORD *)(v81 + 8) = 0;
            CFAllocatorRef v75 = CFGetAllocator((CFTypeRef)v5);
          }
          uint64_t v76 = CFAllocatorAllocateTyped(v75, v68, 0x6004044C4A2DFLL, 0);
          goto LABEL_108;
        }
        if (*(unsigned char *)(v65 + 13))
        {
          uint64_t v86 = *(void *)(v5 + 40);
          if (v86)
          {
            if (!*(_DWORD *)(v86 + 8))
            {
LABEL_129:
              *(unsigned char *)(v86 + 13) = 1;
              goto LABEL_168;
            }
            for (uint64_t k = 0; k != 16; ++k)
            {
              uint64_t v88 = *(void *)(v5 + 40);
              if (((*(_DWORD *)(v88 + 8) >> k) & 2) != 0) {
                CFRelease(*(CFTypeRef *)(*(void *)v88 + 8 * k));
              }
            }
            CFAllocatorRef v89 = CFGetAllocator((CFTypeRef)v5);
            CFAllocatorDeallocate(v89, **(void ***)(v5 + 40));
            CFAllocatorRef v90 = CFGetAllocator((CFTypeRef)v5);
            CFAllocatorDeallocate(v90, *(void **)(v5 + 40));
            *(void *)(v5 + 40) = 0;
          }
          CFAllocatorRef v91 = CFGetAllocator((CFTypeRef)v5);
          uint64_t v86 = CFAllocatorAllocateTyped(v91, 16, 0x1080040FC6463CFLL, 0);
          *(void *)(v5 + 40) = v86;
          *(void *)uint64_t v86 = 0;
          *(void *)(v86 + 6) = 0;
          goto LABEL_129;
        }
      }
      char v92 = atomic_load((unint64_t *)(v4 + 8));
      if ((v92 & 0x70) != 0)
      {
LABEL_168:
        if (__CFCheckForExapendedSet == 1) {
          __CFCheckForExpandedSet((const char *)v5);
        }
        return;
      }
      uint64_t v93 = *(void *)(v4 + 40);
      if (v93) {
        BOOL v94 = *(unsigned __int8 *)(v93 + 13) != 0;
      }
      else {
        BOOL v94 = 0;
      }
      unint64_t v105 = 1;
      while (1)
      {
        int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v4 + 24), v105, __b, v94);
        if (BitmapForPlane != 255) {
          break;
        }
LABEL_167:
        if (++v105 == 17) {
          goto LABEL_168;
        }
      }
      int v107 = BitmapForPlane;
      long long v108 = *(uint64_t **)(v5 + 40);
      if (v108)
      {
        if (v105 <= *((unsigned __int8 *)v108 + 12))
        {
LABEL_160:
          if ((v108[1] & (1 << v105)) != 0)
          {
            uint64_t v114 = (v105 - 1);
          }
          else
          {
            CFAllocatorRef v115 = CFGetAllocator((CFTypeRef)v5);
            CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v115);
            uint64_t v114 = (v105 - 1);
            *(void *)(**(void **)(v5 + 40) + 8 * v114) = Mutable;
            long long v108 = *(uint64_t **)(v5 + 40);
            *((_DWORD *)v108 + 2) |= 1 << v105;
          }
          uint64_t v117 = *v108;
          uint64_t v118 = *(void *)(v117 + 8 * v114);
          if (v107 == 1)
          {
            v125.CFIndex location = 0;
            v125.CFIndex length = 0x10000;
            CFCharacterSetAddCharactersInRange(*(CFMutableCharacterSetRef *)(v117 + 8 * v114), v125);
          }
          else
          {
            __CFCSetMakeBitmap(*(char **)(v117 + 8 * v114));
            uint64_t v119 = 0;
            uint64_t v120 = *(void *)(v118 + 24);
            do
            {
              *(_DWORD *)(v120 + v119 * 4) |= __b[0].u32[v119];
              ++v119;
            }
            while (v119 != 2048);
          }
          goto LABEL_167;
        }
        *((unsigned char *)v108 + 12) = v105;
        uint64_t v109 = *v108;
        CFAllocatorRef v110 = CFGetAllocator((CFTypeRef)v5);
        if (v109)
        {
          uint64_t v111 = __CFSafelyReallocateWithAllocatorTyped(v110, **(void **)(v5 + 40), 8 * v105, 0x6004044C4A2DFLL, 0, 0);
LABEL_159:
          long long v108 = *(uint64_t **)(v5 + 40);
          *long long v108 = v111;
          goto LABEL_160;
        }
      }
      else
      {
        CFAllocatorRef v112 = CFGetAllocator((CFTypeRef)v5);
        uint64_t v113 = CFAllocatorAllocateTyped(v112, 16, 0x1080040FC6463CFLL, 0);
        *(void *)(v5 + 40) = v113;
        *(unsigned char *)(v113 + 12) = v105;
        *(unsigned char *)(v113 + 13) = 0;
        *(_DWORD *)(v113 + 8) = 0;
        CFAllocatorRef v110 = CFGetAllocator((CFTypeRef)v5);
      }
      uint64_t v111 = CFAllocatorAllocateTyped(v110, 8 * v105, 0x6004044C4A2DFLL, 0);
      goto LABEL_159;
    }
  }
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    unint64_t v4 = (void *)[(__CFCharacterSet *)theSet invertedSet];
    return (CFCharacterSetRef)v4;
  }
  else
  {
    CFStringRef Copy = __CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 1, 1);
    CFCharacterSetInvert((CFMutableCharacterSetRef)Copy);
    unint64_t v7 = atomic_load(Copy + 1);
    unint64_t v8 = v7;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Copy + 1, &v8, v7 & 0xFFFFFFFFFFFFFFFELL);
      BOOL v9 = v8 == v7;
      unint64_t v7 = v8;
    }
    while (!v9);
    return (CFCharacterSetRef)Copy;
  }
}

unint64_t *__CFCharacterSetCreateCopy(CFAllocatorRef alloc, unint64_t *cf, char a3, int a4)
{
  if (a4 && CF_IS_OBJC(0x19uLL, (unint64_t)cf))
  {
    return (unint64_t *)[cf mutableCopy];
  }
  else if (a3 & 1) != 0 || (char v8 = atomic_load(cf + 1), (v8))
  {
    CFMutableCharacterSetRef Mutable = (unint64_t *)CFCharacterSetCreateMutable(alloc);
    _CFCharacterSetInitCopyingSet((char *)alloc, Mutable, (uint64_t)cf, a3);
    return Mutable;
  }
  else
  {
    return (unint64_t *)CFRetain(cf);
  }
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  CFMutableCharacterSetRef result = (CFMutableCharacterSetRef)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  if (result)
  {
    unint64_t v2 = atomic_load((unint64_t *)result + 1);
    unint64_t v3 = v2;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v3, v2 | 1);
      BOOL v4 = v3 == v2;
      unint64_t v2 = v3;
    }
    while (!v4);
    unint64_t v5 = atomic_load((unint64_t *)result + 1);
    unint64_t v6 = v5;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v6, v5 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
      BOOL v4 = v6 == v5;
      unint64_t v5 = v6;
    }
    while (!v4);
    *((void *)result + 5) = 0;
    *((void *)result + 2) = 0;
    *((void *)result + 3) = 0;
    unint64_t v7 = atomic_load((unint64_t *)result + 1);
    unint64_t v8 = v7;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v8, v7 | 4);
      BOOL v4 = v8 == v7;
      unint64_t v7 = v8;
    }
    while (!v4);
  }
  return result;
}

char *_CFCharacterSetInitCopyingSet(char *alloc, unint64_t *cf, uint64_t a3, char a4)
{
  CFAllocatorRef v6 = (const __CFAllocator *)alloc;
  char v7 = atomic_load((unint64_t *)(a3 + 8));
  uint64_t v8 = v7 & 0x70;
  unint64_t v9 = atomic_load(cf + 1);
  unint64_t v10 = v9;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v10, v9 & 0xFFFFFFFFFFFFFF8FLL | v8);
    BOOL v11 = v10 == v9;
    unint64_t v9 = v10;
  }
  while (!v11);
  char v12 = atomic_load((unint64_t *)(a3 + 8));
  unint64_t v13 = atomic_load(cf + 1);
  uint64_t v14 = v12 & 4;
  unint64_t v15 = v13;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v15, v13 & 0xFFFFFFFFFFFFFFFBLL | v14);
    BOOL v11 = v15 == v13;
    unint64_t v13 = v15;
  }
  while (!v11);
  char v16 = atomic_load((unint64_t *)(a3 + 8));
  unint64_t v17 = atomic_load(cf + 1);
  uint64_t v18 = v16 & 8;
  unint64_t v19 = v17;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v19, v17 & 0xFFFFFFFFFFFFFFF7 | v18);
    BOOL v11 = v19 == v17;
    unint64_t v17 = v19;
  }
  while (!v11);
  CFTypeRef cf[2] = *(void *)(a3 + 16);
  unsigned int v20 = atomic_load((unint64_t *)(a3 + 8));
  switch((v20 >> 4) & 7)
  {
    case 0u:
      cf[3] = *(void *)(a3 + 24);
      break;
    case 1u:
      *((_DWORD *)cf + 6) = *(_DWORD *)(a3 + 24);
      cf[4] = *(void *)(a3 + 32);
      break;
    case 2u:
      uint64_t Typed = (void *)CFAllocatorAllocateTyped(alloc, 128, 0x1000040BDFB0063, 0);
      cf[3] = (unint64_t)Typed;
      cf[4] = *(void *)(a3 + 32);
      alloc = (char *)memmove(Typed, *(const void **)(a3 + 24), 2 * *(void *)(a3 + 32));
      break;
    case 3u:
      CFIndex v22 = *(unsigned __int8 **)(a3 + 24);
      if (v22)
      {
        if ((a4 & 1) != 0 || (alloc = (char *)__CFCreateCompactBitmap((uint64_t)alloc, v22)) == 0)
        {
          CFStringRef v39 = (void *)CFAllocatorAllocateTyped(v6, 0x2000, 0x100004077774924, 0);
          alloc = (char *)memmove(v39, *(const void **)(a3 + 24), 0x2000uLL);
          cf[3] = (unint64_t)v39;
        }
        else
        {
          cf[3] = (unint64_t)alloc;
          unint64_t v23 = atomic_load(cf + 1);
          unint64_t v24 = v23;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v24, v23 & 0xFFFFFFFFFFFFFF8FLL | 0x40);
            BOOL v11 = v24 == v23;
            unint64_t v23 = v24;
          }
          while (!v11);
        }
      }
      else
      {
        cf[3] = 0;
      }
      break;
    case 4u:
      uint64_t v25 = *(char **)(a3 + 24);
      if (v25)
      {
        uint64_t v26 = 0;
        int32x4_t v27 = (int32x4_t)xmmword_182D9E900;
        int32x4_t v28 = 0uLL;
        v29.i64[0] = -1;
        v29.i64[1] = -1;
        v30.i64[0] = 0xFEFEFEFEFEFEFEFELL;
        v30.i64[1] = 0xFEFEFEFEFEFEFEFELL;
        v31.i64[0] = 0x2000000020;
        v31.i64[1] = 0x2000000020;
        int32x4_t v32 = 0uLL;
        int32x4_t v33 = 0uLL;
        do
        {
          int8x16_t v34 = (int8x16_t)vcgtq_u8(v30, (uint8x16_t)vaddq_s8(*(int8x16_t *)&v25[v26], v29));
          int16x8_t v35 = vmovl_s8(*(int8x8_t *)v34.i8);
          int16x8_t v36 = vmovl_high_s8(v34);
          int32x4_t v33 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v36), (int8x16_t)vaddq_s32(v33, v31), (int8x16_t)v33);
          int32x4_t v32 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v36.i8), (int8x16_t)vaddq_s32(v32, v31), (int8x16_t)v32);
          int32x4_t v28 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v35), (int8x16_t)vaddq_s32(v28, v31), (int8x16_t)v28);
          int32x4_t v27 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v35.i8), (int8x16_t)vaddq_s32(v27, v31), (int8x16_t)v27);
          v26 += 16;
        }
        while (v26 != 256);
        size_t v37 = vaddvq_s32(vaddq_s32(vaddq_s32(v27, v32), vaddq_s32(v28, v33)));
        CFAllocatorRef v38 = (void *)CFAllocatorAllocateTyped(alloc, v37, 1792907336, 0);
        alloc = (char *)memmove(v38, v25, v37);
        cf[3] = (unint64_t)v38;
      }
      break;
    default:
      break;
  }
  uint64_t v40 = *(void *)(a3 + 40);
  if (!v40) {
    return alloc;
  }
  if (!*(_DWORD *)(v40 + 8))
  {
    if (*(unsigned char *)(v40 + 13))
    {
      alloc = (char *)cf[5];
      if (!alloc) {
        goto LABEL_54;
      }
      goto LABEL_51;
    }
    return alloc;
  }
  uint64_t v41 = 0;
  for (uint64_t i = 1; i != 17; ++i)
  {
    uint64_t v43 = *(void *)(a3 + 40);
    if (!v43) {
      goto LABEL_47;
    }
    int v44 = 1 << i;
    if ((*(_DWORD *)(v43 + 8) & (1 << i)) == 0) {
      goto LABEL_47;
    }
    if (*(unsigned __int8 *)(v43 + 12) < i) {
      goto LABEL_47;
    }
    uint64_t v45 = *(const void **)(*(void *)v43 + v41);
    if (!v45) {
      goto LABEL_47;
    }
    CFStringRef Copy = (const void *)__CFCharacterSetCreateCopy(v6, v45);
    unint64_t v47 = cf[5];
    if (!v47)
    {
      CFAllocatorRef v51 = CFGetAllocator(cf);
      uint64_t v52 = CFAllocatorAllocateTyped(v51, 16, 0x1080040FC6463CFLL, 0);
      cf[5] = v52;
      *(_WORD *)(v52 + 12) = i;
      *(_DWORD *)(v52 + 8) = 0;
      CFAllocatorRef v49 = CFGetAllocator(cf);
      goto LABEL_39;
    }
    if (*(unsigned __int8 *)(v47 + 12) < i)
    {
      *(unsigned char *)(v47 + 12) = i;
      uint64_t v48 = *(void *)v47;
      CFAllocatorRef v49 = CFGetAllocator(cf);
      if (v48)
      {
        uint64_t v50 = __CFSafelyReallocateWithAllocatorTyped(v49, *(void *)cf[5], v41 + 8, 0x6004044C4A2DFLL, 0, 0);
LABEL_40:
        unint64_t v47 = cf[5];
        *(void *)unint64_t v47 = v50;
        goto LABEL_41;
      }
LABEL_39:
      uint64_t v50 = CFAllocatorAllocateTyped(v49, v41 + 8, 0x6004044C4A2DFLL, 0);
      goto LABEL_40;
    }
LABEL_41:
    if ((*(_DWORD *)(v47 + 8) & v44) != 0) {
      CFRelease(*(CFTypeRef *)(*(void *)v47 + v41));
    }
    if (Copy)
    {
      *(void *)(*(void *)cf[5] + v41) = CFRetain(Copy);
      unint64_t v53 = cf[5];
      int v54 = *(_DWORD *)(v53 + 8) | v44;
    }
    else
    {
      unint64_t v53 = cf[5];
      int v54 = *(_DWORD *)(v53 + 8) & ~v44;
    }
    *(_DWORD *)(v53 + 8) = v54;
    CFRelease(Copy);
LABEL_47:
    v41 += 8;
  }
  uint64_t v55 = *(void *)(a3 + 40);
  if (v55)
  {
    alloc = (char *)cf[5];
    if (*(unsigned char *)(v55 + 13))
    {
      if (alloc) {
        goto LABEL_51;
      }
LABEL_54:
      CFAllocatorRef v57 = CFGetAllocator(cf);
      alloc = (char *)CFAllocatorAllocateTyped(v57, 16, 0x1080040FC6463CFLL, 0);
      cf[5] = (unint64_t)alloc;
      *(void *)(alloc + 6) = 0;
      *(void *)alloc = 0;
LABEL_51:
      char v56 = 1;
LABEL_58:
      alloc[13] = v56;
      return alloc;
    }
  }
  else
  {
    alloc = (char *)cf[5];
  }
  if (alloc)
  {
    char v56 = 0;
    goto LABEL_58;
  }
  return alloc;
}

void CFCharacterSetInvert(CFMutableCharacterSetRef theSet)
{
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    [(__CFCharacterSet *)theSet invert];
    return;
  }
  char v2 = atomic_load((unint64_t *)theSet + 1);
  if ((v2 & 1) == 0)
  {
    CFLog(3, @"%s: Immutable character set passed to mutable function");
    if (dyld_program_sdk_at_least()) {
      CFCharacterSetInvert_cold_1();
    }
  }
  char v3 = atomic_load((unint64_t *)theSet + 1);
  if ((v3 & 0x70) != 0
    || (char v4 = atomic_load((unint64_t *)theSet + 1), (v4 & 1) != 0)
    || (char v5 = atomic_load((unint64_t *)theSet + 1), (v5 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    unint64_t v6 = atomic_load((unint64_t *)theSet + 1);
    unint64_t v7 = v6;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v7, v6 & 0xFFFFFFFFFFFFFFFBLL);
      BOOL v8 = v7 == v6;
      unint64_t v6 = v7;
    }
    while (!v8);
    char v9 = atomic_load((unint64_t *)theSet + 1);
    if ((v9 & 0x70) == 0x30)
    {
      uint64_t v10 = *((void *)theSet + 3);
      if (v10)
      {
        for (uint64_t i = 0; i != 0x2000; i += 16)
          *(int8x16_t *)(v10 + i) = vmvnq_s8(*(int8x16_t *)(v10 + i));
      }
      else
      {
        CFAllocatorRef v24 = CFGetAllocator(theSet);
        uint64_t Typed = (void *)CFAllocatorAllocateTyped(v24, 0x2000, 654288840, 0);
        *((void *)theSet + 3) = Typed;
        memset(Typed, 255, 0x2000uLL);
      }
    }
    else
    {
      char v12 = atomic_load((unint64_t *)theSet + 1);
      if ((v12 & 0x70) != 0x40)
      {
        char v17 = atomic_load((unint64_t *)theSet + 1);
        unint64_t v18 = atomic_load((unint64_t *)theSet + 1);
        uint64_t v19 = v17 & 8;
        unint64_t v20 = v18;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v20, (v18 & 0xFFFFFFFFFFFFFFF7 | v19) ^ 8);
          BOOL v8 = v20 == v18;
          unint64_t v18 = v20;
        }
        while (!v8);
        uint64_t v21 = *((void *)theSet + 5);
        if (!v21)
        {
          CFAllocatorRef v22 = CFGetAllocator(theSet);
          uint64_t v21 = CFAllocatorAllocateTyped(v22, 16, 0x1080040FC6463CFLL, 0);
          *((void *)theSet + 5) = v21;
          *(void *)uint64_t v21 = 0;
          *(void *)(v21 + 6) = 0;
          BOOL v23 = 1;
LABEL_41:
          *(unsigned char *)(v21 + 13) = v23;
          return;
        }
LABEL_40:
        BOOL v23 = *(unsigned char *)(v21 + 13) == 0;
        goto LABEL_41;
      }
      uint64_t v13 = 0;
      LODWORD(v14) = 0;
      uint64_t v15 = *((void *)theSet + 3);
      do
      {
        if (*(unsigned __int8 *)(v15 + v13) == 255)
        {
          *(unsigned char *)(v15 + v13) = 0;
        }
        else if (*(unsigned char *)(v15 + v13))
        {
          LODWORD(v14) = v14 + 32;
        }
        else
        {
          *(unsigned char *)(v15 + v13) = -1;
        }
        ++v13;
      }
      while (v13 != 256);
      if ((int)v14 >= 1)
      {
        char v16 = (unsigned char *)(v15 + 256);
        uint64_t v14 = v14;
        do
        {
          unsigned char *v16 = ~*v16;
          ++v16;
          --v14;
        }
        while (v14);
      }
    }
    uint64_t v21 = *((void *)theSet + 5);
    if (!v21)
    {
      CFAllocatorRef v26 = CFGetAllocator(theSet);
      uint64_t v21 = CFAllocatorAllocateTyped(v26, 16, 0x1080040FC6463CFLL, 0);
      *((void *)theSet + 5) = v21;
      *(void *)(v21 + 6) = 0;
      *(void *)uint64_t v21 = 0;
    }
    goto LABEL_40;
  }
}

uint64_t CFUniCharGetBitmapForPlane(unsigned int a1, unsigned int a2, unsigned char *a3, int a4)
{
  BitmapPtrForPlane = (char *)CFUniCharGetBitmapPtrForPlane(a1, a2);
  if (BitmapPtrForPlane)
  {
    unsigned int v9 = 8193;
    if (a4)
    {
      do
      {
        char v10 = *BitmapPtrForPlane++;
        *a3++ = ~v10;
        --v9;
      }
      while (v9 > 1);
    }
    else
    {
      do
      {
        char v11 = *BitmapPtrForPlane++;
        *a3++ = v11;
        --v9;
      }
      while (v9 > 1);
    }
LABEL_6:
    LOBYTE(v12) = 0;
    return v12;
  }
  if (a1 == 12)
  {
    if (a2 > 0xE)
    {
      if (a2 - 15 <= 1)
      {
        for (unsigned int i = 2049; i > 1; --i)
        {
          *(_DWORD *)a3 = a4 << 31 >> 31;
          a3 += 4;
        }
        LOBYTE(v12) = 0;
        if (a4) {
          char v19 = 63;
        }
        else {
          char v19 = -64;
        }
        *(a3 - 5) = v19;
        return v12;
      }
    }
    else
    {
      uint64_t v13 = (char *)*(&__CFUniCharLegalCharacterSetBitmap + a2);
      if (v13)
      {
        unsigned int v14 = 8193;
        if (a4)
        {
          do
          {
            LOBYTE(v12) = 0;
            char v15 = *v13++;
            *a3++ = v15;
            --v14;
          }
          while (v14 > 1);
        }
        else
        {
          do
          {
            LOBYTE(v12) = 0;
            char v16 = *v13++;
            *a3++ = ~v16;
            --v14;
          }
          while (v14 > 1);
        }
        return v12;
      }
      if (a2 == 14)
      {
        unint64_t v29 = 0;
        *a3 = 2;
        uint64x2_t v30 = (uint64x2_t)vdupq_n_s64(0x1FFFuLL);
        do
        {
          uint64x2_t v31 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v29), (int8x16_t)xmmword_182E0FE40);
          if (vmovn_s64((int64x2_t)vcgtq_u64(v30, v31)).u8[0]) {
            a3[v29 + 1] = (((v29 - 15) < 0xFFFFFFF4) ^ a4) << 31 >> 31;
          }
          if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FFFuLL), v31)).i32[1]) {
            a3[v29 + 2] = (((v29 - 14) < 0xFFFFFFF4) ^ a4) << 31 >> 31;
          }
          LOBYTE(v12) = 0;
          v29 += 2;
        }
        while (v29 != 0x2000);
        return v12;
      }
    }
    BOOL v17 = a4 == 0;
    int v12 = -1;
  }
  else
  {
    if ((a1 < 4 || a1 == 15) && !a2)
    {
      memset(a3, a4 << 31 >> 31, 0x2000uLL);
      if (a1 != 15 && a1 != 3) {
        goto LABEL_33;
      }
      for (uint64_t j = 0; j != 7; ++j)
      {
        unint64_t v21 = (unsigned __int16)word_182E0FE50[j];
        int v22 = 1 << (v21 & 7);
        unint64_t v23 = v21 >> 3;
        char v24 = a3[v23];
        char v25 = v24 & ~(_BYTE)v22;
        char v26 = v24 | v22;
        if (a4) {
          char v26 = v25;
        }
        a3[v23] = v26;
      }
      if (a1 != 15)
      {
LABEL_33:
        char v27 = a3[1];
        if (a4)
        {
          a3[1] = v27 & 0xFD;
          a3[4] &= ~1u;
          a3[20] &= ~1u;
          a3[720] &= ~1u;
          a3[1029] &= ~0x80u;
          a3[1035] &= ~0x80u;
          char v28 = a3[1536] & 0xFE;
        }
        else
        {
          a3[1] = v27 | 2;
          a3[4] |= 1u;
          a3[20] |= 1u;
          a3[720] |= 1u;
          a3[1029] |= 0x80u;
          a3[1035] |= 0x80u;
          char v28 = a3[1536] | 1;
        }
        a3[1536] = v28;
        for (uint64_t k = 0x2000; k != 8204; ++k)
        {
          int v34 = 1 << (k & 7);
          uint64_t v35 = (unsigned __int16)k >> 3;
          char v36 = a3[v35];
          char v37 = v36 & ~(_BYTE)v34;
          char v38 = v36 | v34;
          if (a4) {
            char v38 = v37;
          }
          a3[v35] = v38;
        }
      }
      goto LABEL_6;
    }
    BOOL v17 = a4 == 0;
    int v12 = 1;
  }
  if (v17) {
    return -v12;
  }
  return v12;
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  uint64_t v71 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    [(__CFCharacterSet *)theSet addCharactersInString:theString];
  }
  else
  {
    char v4 = atomic_load((unint64_t *)theSet + 1);
    if ((v4 & 1) == 0)
    {
      CFLog(3, @"%s: Immutable character set passed to mutable function");
      if (dyld_program_sdk_at_least()) {
        CFCharacterSetAddCharactersInString_cold_1();
      }
    }
    char v5 = atomic_load((unint64_t *)theSet + 1);
    if ((v5 & 0x70) != 0
      || (char v6 = atomic_load((unint64_t *)theSet + 1), (v6 & 1) != 0)
      || (char v7 = atomic_load((unint64_t *)theSet + 1), (v7 & 8) != 0)
      || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
    {
      uint64_t v8 = *((void *)theSet + 5);
      if (v8)
      {
        if (*(_DWORD *)(v8 + 8) || *(unsigned char *)(v8 + 13)) {
          goto LABEL_20;
        }
      }
      unsigned int v9 = atomic_load((unint64_t *)theSet + 1);
      switch((v9 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*((void *)theSet + 4)) {
            goto LABEL_20;
          }
          break;
        case 3u:
        case 4u:
          if (*((void *)theSet + 3)) {
            goto LABEL_20;
          }
          break;
        default:
          goto LABEL_20;
      }
      char v10 = atomic_load((unint64_t *)theSet + 1);
      if ((v10 & 8) == 0)
      {
LABEL_20:
        CFIndex Length = CFStringGetLength(theString);
        if (Length)
        {
          CFIndex v12 = Length;
          char v13 = atomic_load((unint64_t *)theSet + 1);
          if ((v13 & 8) != 0) {
            goto LABEL_33;
          }
          uint64_t v14 = *((void *)theSet + 5);
          if (v14 && (*(_DWORD *)(v14 + 8) || *(unsigned char *)(v14 + 13)))
          {
LABEL_29:
            char v17 = atomic_load((unint64_t *)theSet + 1);
            uint64_t v16 = (v17 & 0x70) == 0x20 ? *((void *)theSet + 4) : 64;
          }
          else
          {
            unsigned int v15 = atomic_load((unint64_t *)theSet + 1);
            switch((v15 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (*((void *)theSet + 4)) {
                  goto LABEL_29;
                }
                break;
              case 3u:
              case 4u:
                if (*((void *)theSet + 3)) {
                  goto LABEL_29;
                }
                break;
              default:
                goto LABEL_29;
            }
            uint64_t v16 = 0;
          }
          size_t v18 = v16 + Length;
          if (v16 + Length > 63)
          {
LABEL_33:
            __CFCSetMakeBitmap((char *)theSet);
            long long v62 = 0u;
            long long v63 = 0u;
            long long v60 = 0u;
            long long v61 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            *(_OWORD *)buffer = 0u;
            long long v57 = 0u;
            CFStringRef theStringa = theString;
            uint64_t v67 = 0;
            CFIndex v68 = v12;
            CharactersPtr = CFStringGetCharactersPtr(theString);
            CStringPtr = 0;
            uint64_t v65 = CharactersPtr;
            if (!CharactersPtr) {
              CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
            }
            int64_t v69 = 0;
            int64_t v70 = 0;
            int v66 = CStringPtr;
            if (v12 < 1)
            {
              char v23 = 0;
            }
            else
            {
              uint64_t v21 = 0;
              int64_t v22 = 0;
              char v23 = 0;
              uint64_t v24 = 64;
              do
              {
                if ((unint64_t)v22 >= 4) {
                  uint64_t v25 = 4;
                }
                else {
                  uint64_t v25 = v22;
                }
                if (v65)
                {
                  UniChar v26 = v65[v22 + v67];
                }
                else if (v66)
                {
                  UniChar v26 = v66[v67 + v22];
                }
                else
                {
                  int64_t v27 = v69;
                  if (v70 <= v22 || v69 > v22)
                  {
                    uint64_t v29 = -v25;
                    uint64_t v30 = v25 + v21;
                    uint64_t v31 = v24 - v25;
                    int64_t v32 = v22 + v29;
                    CFIndex v33 = v32 + 64;
                    if (v32 + 64 >= v68) {
                      CFIndex v33 = v68;
                    }
                    int64_t v69 = v32;
                    int64_t v70 = v33;
                    if (v68 < v31) {
                      uint64_t v31 = v68;
                    }
                    v73.CFIndex length = v31 + v30;
                    v73.CFIndex location = v32 + v67;
                    CFStringGetCharacters(theStringa, v73, buffer);
                    int64_t v27 = v69;
                  }
                  UniChar v26 = buffer[v22 - v27];
                }
                if ((v26 & 0xF800 | 0x400) == 0xDC00) {
                  char v23 = 1;
                }
                else {
                  *(unsigned char *)(*((void *)theSet + 3) + (v26 >> 3)) |= 1 << (v26 & 7);
                }
                ++v22;
                --v21;
                ++v24;
              }
              while (v12 != v22);
            }
            unint64_t v34 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v35 = v34;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v35, v34 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v36 = v35 == v34;
              unint64_t v34 = v35;
            }
            while (!v36);
            if (__CFCheckForExapendedSet == 1) {
              __CFCheckForExpandedSet((const char *)theSet);
            }
            if (v23) {
              __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetAddCharactersInRange);
            }
          }
          else
          {
            uint64_t v37 = *((void *)theSet + 3);
            if (v37)
            {
              uint64_t Typed = (UniChar *)(v37 + 2 * *((void *)theSet + 4));
            }
            else
            {
              CFAllocatorRef v39 = CFGetAllocator(theSet);
              uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(v39, 128, 0x1000040BDFB0063, 0);
            }
            v74.CFIndex location = 0;
            v74.CFIndex length = v12;
            CFStringGetCharacters(theString, v74, Typed);
            if (v12 < 2)
            {
              char v40 = 0;
            }
            else
            {
              char v40 = 0;
              uint64_t v41 = Typed;
              uint64_t v42 = &Typed[v12];
              do
              {
                if ((*v41 & 0xF800 | 0x400) == 0xDC00)
                {
                  memmove(v41, v41 + 1, (char *)v42-- - (char *)(v41 + 1));
                  char v40 = 1;
                }
                else
                {
                  ++v41;
                }
              }
              while (v41 < v42);
              size_t v18 = v16 + v42 - Typed;
            }
            uint64_t v43 = (UniChar *)*((void *)theSet + 3);
            if (v18)
            {
              if (!v43)
              {
                unint64_t v44 = atomic_load((unint64_t *)theSet + 1);
                unint64_t v45 = v44;
                do
                {
                  atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v45, v44 & 0xFFFFFFFFFFFFFF8FLL | 0x20);
                  BOOL v36 = v45 == v44;
                  unint64_t v44 = v45;
                }
                while (!v36);
                *((void *)theSet + 3) = Typed;
                uint64_t v43 = Typed;
              }
              *((void *)theSet + 4) = v18;
              qsort(v43, v18, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
              uint64_t v46 = *((void *)theSet + 4);
              if (v46 >= 2)
              {
                uint64_t v47 = 0;
                uint64_t v48 = *((void *)theSet + 3);
                uint64_t v49 = v46 - 1;
                uint64_t v50 = (unsigned __int16 *)(v48 + 2);
                do
                {
                  int v52 = *v50++;
                  __int16 v51 = v52;
                  if (*(unsigned __int16 *)(v48 + 2 * v47) != v52)
                  {
                    ++v47;
                    *(_WORD *)(v48 + 2 * v47) = v51;
                  }
                  --v49;
                }
                while (v49);
                uint64_t v46 = v47 + 1;
              }
              *((void *)theSet + 4) = v46;
            }
            else if (!v43)
            {
              CFAllocatorRef v53 = CFGetAllocator(theSet);
              CFAllocatorDeallocate(v53, Typed);
            }
            unint64_t v54 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v55 = v54;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v55, v54 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v36 = v55 == v54;
              unint64_t v54 = v55;
            }
            while (!v36);
            if (v40)
            {
              __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetAddCharactersInRange);
            }
          }
        }
      }
    }
  }
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  CFIndex length = theRange.length;
  unint64_t location = theRange.location;
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    -[__CFCharacterSet addCharactersInRange:](theSet, "addCharactersInRange:", location, length);
    return;
  }
  char v5 = atomic_load((unint64_t *)theSet + 1);
  if ((v5 & 1) == 0)
  {
    CFLog(3, @"%s: Immutable character set passed to mutable function");
    if (dyld_program_sdk_at_least()) {
      CFCharacterSetAddCharactersInRange_cold_1();
    }
  }
  if (location >> 16 > 0x10 || length >= 1114113 || (unint64_t v6 = location + length, location + length >= 0x110001))
  {
    CFLog(3, @"%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)");
    qword_1EC093AA8 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
    __break(1u);
    return;
  }
  char v7 = atomic_load((unint64_t *)theSet + 1);
  if ((v7 & 0x70) != 0
    || (char v8 = atomic_load((unint64_t *)theSet + 1), (v8 & 1) != 0)
    || (char v9 = atomic_load((unint64_t *)theSet + 1), (v9 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    if (length)
    {
      char v10 = atomic_load((unint64_t *)theSet + 1);
      if ((v10 & 8) == 0 || (uint64_t v11 = *((void *)theSet + 5)) != 0 && (*(_DWORD *)(v11 + 8) || *(unsigned char *)(v11 + 13)))
      {
LABEL_24:
        char v13 = atomic_load((unint64_t *)theSet + 1);
        if ((v13 & 8) == 0)
        {
          uint64_t v14 = *((void *)theSet + 5);
          if (!v14 || !*(_DWORD *)(v14 + 8) && !*(unsigned char *)(v14 + 13))
          {
            unsigned int v15 = atomic_load((unint64_t *)theSet + 1);
            switch((v15 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (*((void *)theSet + 4)) {
                  goto LABEL_30;
                }
                break;
              case 3u:
              case 4u:
                if (*((void *)theSet + 3)) {
                  goto LABEL_30;
                }
                break;
              default:
                goto LABEL_30;
            }
            unint64_t v47 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v48 = v47;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v48, v47 & 0xFFFFFFFFFFFFFF8FLL | 0x10);
              BOOL v22 = v48 == v47;
              unint64_t v47 = v48;
            }
            while (!v22);
            *((_DWORD *)theSet + 6) = location;
            *((void *)theSet + 4) = length;
            unint64_t v49 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v50 = v49;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v50, v49 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v22 = v50 == v49;
              unint64_t v49 = v50;
            }
            while (!v22);
            return;
          }
LABEL_30:
          char v16 = atomic_load((unint64_t *)theSet + 1);
          if ((v16 & 0x70) == 0x10)
          {
            unint64_t v17 = *((unsigned int *)theSet + 6);
            CFIndex v18 = *((void *)theSet + 4);
            if (location == v17)
            {
              if (v18 <= length) {
                CFIndex v19 = length;
              }
              else {
                CFIndex v19 = *((void *)theSet + 4);
              }
              *((void *)theSet + 4) = v19;
              unint64_t v20 = atomic_load((unint64_t *)theSet + 1);
              unint64_t v21 = v20;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v21, v20 & 0xFFFFFFFFFFFFFFFBLL);
                BOOL v22 = v21 == v20;
                unint64_t v20 = v21;
              }
              while (!v22);
              return;
            }
            if (location > v17 && (uint64_t)location <= (uint64_t)(v18 + v17))
            {
              if ((uint64_t)(v18 + v17) < (uint64_t)v6) {
                *((void *)theSet + 4) = v6 - v17;
              }
              unint64_t v53 = atomic_load((unint64_t *)theSet + 1);
              unint64_t v54 = v53;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v54, v53 & 0xFFFFFFFFFFFFFFFBLL);
                BOOL v22 = v54 == v53;
                unint64_t v53 = v54;
              }
              while (!v22);
              return;
            }
            if (location < v17 && v6 >= v17)
            {
              *((_DWORD *)theSet + 6) = location;
              int64_t v38 = v18 + v17;
              if (v38 <= (uint64_t)v6) {
                int64_t v38 = location + length;
              }
              *((void *)theSet + 4) = v38 - location;
              unint64_t v39 = atomic_load((unint64_t *)theSet + 1);
              unint64_t v40 = v39;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v40, v39 & 0xFFFFFFFFFFFFFFFBLL);
                BOOL v22 = v40 == v39;
                unint64_t v39 = v40;
              }
              while (!v22);
              return;
            }
          }
          else
          {
            char v23 = atomic_load((unint64_t *)theSet + 1);
            if ((v23 & 0x70) == 0x20)
            {
              uint64_t v24 = *((void *)theSet + 4);
              CFIndex v25 = v24 + length;
              if (v24 + length <= 63)
              {
                uint64_t Typed = *((void *)theSet + 3);
                if (!Typed)
                {
                  CFAllocatorRef v27 = CFGetAllocator(theSet);
                  uint64_t Typed = CFAllocatorAllocateTyped(v27, 128, 0x1000040BDFB0063, 0);
                  *((void *)theSet + 3) = Typed;
                  uint64_t v24 = *((void *)theSet + 4);
                  CFIndex v25 = v24 + length;
                }
                *((void *)theSet + 4) = v25;
                char v28 = (_WORD *)(Typed + 2 * v24);
                do
                {
                  *v28++ = location++;
                  --length;
                }
                while (length);
                qsort(*((void **)theSet + 3), *((void *)theSet + 4), 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
                uint64_t v29 = *((void *)theSet + 4);
                if (v29 >= 2)
                {
                  uint64_t v30 = 0;
                  uint64_t v31 = *((void *)theSet + 3);
                  uint64_t v32 = v29 - 1;
                  CFIndex v33 = (unsigned __int16 *)(v31 + 2);
                  do
                  {
                    int v35 = *v33++;
                    __int16 v34 = v35;
                    if (*(unsigned __int16 *)(v31 + 2 * v30) != v35)
                    {
                      ++v30;
                      *(_WORD *)(v31 + 2 * v30) = v34;
                    }
                    --v32;
                  }
                  while (v32);
                  uint64_t v29 = v30 + 1;
                }
                *((void *)theSet + 4) = v29;
                unint64_t v36 = atomic_load((unint64_t *)theSet + 1);
                unint64_t v37 = v36;
                do
                {
                  atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v37, v36 & 0xFFFFFFFFFFFFFFFBLL);
                  BOOL v22 = v37 == v36;
                  unint64_t v36 = v37;
                }
                while (!v22);
                return;
              }
            }
          }
        }
        __CFCSetMakeBitmap(theSet);
        __CFCSetAddNonBMPPlanesInRange(theSet);
        if (!(location >> 16))
        {
          uint64_t v41 = *((void *)theSet + 3);
          if (v6 >> 16) {
            int v42 = -(int)location;
          }
          else {
            LOWORD(v42) = length;
          }
          unsigned __int16 v43 = v42 + location - 1;
          if (v43 == (unsigned __int16)location)
          {
            *(unsigned char *)(v41 + (location >> 3)) |= 1 << (location & 7);
          }
          else
          {
            uint64_t v44 = location >> 3;
            unsigned int v45 = v43 >> 3;
            int v46 = 255 << (location & 7);
            if (v44 == v45)
            {
              *(unsigned char *)(v41 + v44) |= (0xFFu >> (~(_BYTE)v43 & 7)) & v46;
            }
            else
            {
              *(unsigned char *)(v41 + v44) |= v46;
              *(unsigned char *)(v41 + (v43 >> 3)) |= 0xFFu >> (~(_BYTE)v43 & 7);
              if ((int)v44 + 1 < v45) {
                memset((void *)(v41 + (location >> 3) + 1), 255, v45 - v44 - 2 + 1);
              }
            }
          }
        }
        unint64_t v51 = atomic_load((unint64_t *)theSet + 1);
        unint64_t v52 = v51;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v52, v51 & 0xFFFFFFFFFFFFFFFBLL);
          BOOL v22 = v52 == v51;
          unint64_t v51 = v52;
        }
        while (!v22);
        if (__CFCheckForExapendedSet == 1)
        {
          __CFCheckForExpandedSet((const char *)theSet);
        }
        return;
      }
      unsigned int v12 = atomic_load((unint64_t *)theSet + 1);
      switch((v12 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*((void *)theSet + 4)) {
            goto LABEL_24;
          }
          break;
        case 3u:
        case 4u:
          if (*((void *)theSet + 3)) {
            goto LABEL_24;
          }
          break;
        default:
          goto LABEL_24;
      }
    }
  }
}

void __CFCSetMakeBitmap(char *cf)
{
  char v2 = (unint64_t *)(cf + 8);
  char v3 = atomic_load((unint64_t *)cf + 1);
  if ((v3 & 0x70) == 0x30 && *((void *)cf + 3)) {
    return;
  }
  CFAllocatorRef v4 = CFGetAllocator(cf);
  uint64_t Typed = (int8x16_t *)CFAllocatorAllocateTyped(v4, 0x2000, 3746228942, 0);
  __CFCSetGetBitmap((uint64_t)cf, Typed);
  char v6 = atomic_load(v2);
  if ((v6 & 0x70) != 0)
  {
    char v7 = atomic_load((unint64_t *)cf + 1);
    if ((v7 & 0x70) == 0x40 && (char v8 = (void *)*((void *)cf + 3)) != 0
      || (char v9 = atomic_load((unint64_t *)cf + 1), (v9 & 0x70) == 0x20)
      && (char v8 = (void *)*((void *)cf + 3)) != 0)
    {
      CFAllocatorDeallocate(v4, v8);
      *((void *)cf + 3) = 0;
    }
    else
    {
      char v17 = atomic_load((unint64_t *)cf + 1);
      if ((v17 & 0x70) == 0x10)
      {
        uint64_t v18 = *((void *)cf + 5);
        if (v18 && *(_DWORD *)(v18 + 8))
        {
          __CFCSetAddNonBMPPlanesInRange(cf, *((unsigned int *)cf + 6), *((void *)cf + 4));
        }
        else
        {
          char v19 = atomic_load((unint64_t *)cf + 1);
          __CFCSetAddNonBMPPlanesInRange(cf, *((unsigned int *)cf + 6), *((void *)cf + 4));
          if ((v19 & 8) != 0)
          {
            uint64_t v20 = *((void *)cf + 5);
            if (!v20)
            {
              CFAllocatorRef v21 = CFGetAllocator(cf);
              uint64_t v20 = CFAllocatorAllocateTyped(v21, 16, 0x1080040FC6463CFLL, 0);
              *((void *)cf + 5) = v20;
              *(void *)uint64_t v20 = 0;
              *(void *)(v20 + 6) = 0;
            }
            *(unsigned char *)(v20 + 13) = 1;
          }
        }
      }
    }
    goto LABEL_61;
  }
  unsigned int NumberOfPlanes = CFUniCharGetNumberOfPlanes(*((_DWORD *)cf + 6));
  if (NumberOfPlanes < 2) {
    goto LABEL_61;
  }
  unsigned int v11 = NumberOfPlanes;
  unsigned __int8 v12 = NumberOfPlanes - 1;
  char v13 = (uint64_t *)*((void *)cf + 5);
  if (v13)
  {
    if (*((unsigned __int8 *)v13 + 12) < v12)
    {
      *((unsigned char *)v13 + 12) = v12;
      uint64_t v14 = *v13;
      CFAllocatorRef v15 = CFGetAllocator(cf);
      if (v14) {
        uint64_t v16 = __CFSafelyReallocateWithAllocatorTyped(v15, **((void **)cf + 5), 8 * v12, 0x6004044C4A2DFLL, 0, 0);
      }
      else {
        uint64_t v16 = CFAllocatorAllocateTyped(v15, 8 * v12, 0x6004044C4A2DFLL, 0);
      }
      **((void **)cf + 5) = v16;
    }
  }
  else
  {
    CFAllocatorRef v22 = CFGetAllocator(cf);
    uint64_t v23 = CFAllocatorAllocateTyped(v22, 16, 0x1080040FC6463CFLL, 0);
    *((void *)cf + 5) = v23;
    *(unsigned char *)(v23 + 12) = v12;
    *(unsigned char *)(v23 + 13) = 0;
    *(_DWORD *)(v23 + 8) = 0;
    if (v12)
    {
      CFAllocatorRef v24 = CFGetAllocator(cf);
      uint64_t v25 = CFAllocatorAllocateTyped(v24, 8 * v12, 0x6004044C4A2DFLL, 0);
      uint64_t v23 = *((void *)cf + 5);
    }
    else
    {
      uint64_t v25 = 0;
    }
    *(void *)uint64_t v23 = v25;
  }
  UniChar v26 = 0;
  for (unsigned int i = 1; i != v11; ++i)
  {
    if (!v26) {
      UniChar v26 = (unsigned char *)CFAllocatorAllocateTyped(v4, 0x2000, 111259299, 0);
    }
    int BitmapForPlane = CFUniCharGetBitmapForPlane(*((_DWORD *)cf + 6), i, v26, 0);
    if (BitmapForPlane != 255)
    {
      if (BitmapForPlane == 1) {
        memset(v26, 255, 0x2000uLL);
      }
      if (!(_BYTE)i)
      {
        __break(1u);
        return;
      }
      if (i > 0x10u) {
        goto LABEL_57;
      }
      uint64_t v29 = (uint64_t *)*((void *)cf + 5);
      if (v29)
      {
        if (*((unsigned __int8 *)v29 + 12) >= i) {
          goto LABEL_44;
        }
        *((unsigned char *)v29 + 12) = i;
        uint64_t v30 = *v29;
        CFAllocatorRef v31 = CFGetAllocator(cf);
        if (v30)
        {
          uint64_t v32 = __CFSafelyReallocateWithAllocatorTyped(v31, **((void **)cf + 5), 8 * i, 0x6004044C4A2DFLL, 0, 0);
LABEL_43:
          uint64_t v29 = (uint64_t *)*((void *)cf + 5);
          uint64_t *v29 = v32;
LABEL_44:
          if ((v29[1] & (1 << i)) != 0)
          {
            uint64_t v36 = i - 1;
          }
          else
          {
            CFAllocatorRef v37 = CFGetAllocator(cf);
            CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v37);
            uint64_t v36 = i - 1;
            *(void *)(**((void **)cf + 5) + 8 * v36) = Mutable;
            uint64_t v29 = (uint64_t *)*((void *)cf + 5);
            *((_DWORD *)v29 + 2) |= 1 << i;
          }
          uint64_t v39 = *(void *)(*v29 + 8 * v36);
          if (v39)
          {
            unint64_t v40 = atomic_load((unint64_t *)(v39 + 8));
            unint64_t v41 = v40;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v39 + 8), &v41, v40 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
              BOOL v42 = v41 == v40;
              unint64_t v40 = v41;
            }
            while (!v42);
            *(void *)(v39 + 24) = v26;
            unint64_t v43 = atomic_load((unint64_t *)(v39 + 8));
            unint64_t v44 = v43;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v39 + 8), &v44, v43 & 0xFFFFFFFFFFFFFFF7);
              BOOL v42 = v44 == v43;
              unint64_t v43 = v44;
            }
            while (!v42);
            unsigned int v45 = (unint64_t *)(v39 + 8);
            unint64_t v46 = atomic_load(v45);
            unint64_t v47 = v46;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)v45, &v47, v46 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v42 = v47 == v46;
              unint64_t v46 = v47;
            }
            while (!v42);
          }
LABEL_57:
          UniChar v26 = 0;
          continue;
        }
        uint64_t v35 = 8 * i;
      }
      else
      {
        CFAllocatorRef v33 = CFGetAllocator(cf);
        uint64_t v34 = CFAllocatorAllocateTyped(v33, 16, 0x1080040FC6463CFLL, 0);
        *((void *)cf + 5) = v34;
        *(_WORD *)(v34 + 12) = i;
        *(_DWORD *)(v34 + 8) = 0;
        CFAllocatorRef v31 = CFGetAllocator(cf);
        uint64_t v35 = 8 * i;
      }
      uint64_t v32 = CFAllocatorAllocateTyped(v31, v35, 0x6004044C4A2DFLL, 0);
      goto LABEL_43;
    }
  }
  if (v26) {
    CFAllocatorDeallocate(v4, v26);
  }
LABEL_61:
  unint64_t v48 = atomic_load((unint64_t *)cf + 1);
  unint64_t v49 = v48;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v49, v48 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
    BOOL v42 = v49 == v48;
    unint64_t v48 = v49;
  }
  while (!v42);
  *((void *)cf + 3) = Typed;
  unint64_t v50 = atomic_load((unint64_t *)cf + 1);
  unint64_t v51 = v50;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)cf + 1, &v51, v50 & 0xFFFFFFFFFFFFFFF7);
    BOOL v42 = v51 == v50;
    unint64_t v50 = v51;
  }
  while (!v42);
}

void __CFCSetAddNonBMPPlanesInRange(CFTypeRef cf, unint64_t a2, int a3)
{
  unint64_t v3 = a2 >> 16;
  if (((int)a2 + a3 - 1) >> 16 >= 16) {
    int v4 = 16;
  }
  else {
    int v4 = ((int)a2 + a3 - 1) >> 16;
  }
  if ((int)v3 <= 16)
  {
    uint64_t v6 = *((void *)cf + 5);
    if (v6) {
      BOOL v46 = *(unsigned char *)(v6 + 13) != 0;
    }
    else {
      BOOL v46 = 0;
    }
    if (v3 <= 1) {
      int v7 = 1;
    }
    else {
      int v7 = a2 >> 16;
    }
    if (v7 <= v4)
    {
      CFIndex v8 = (unsigned __int16)a2;
      int v45 = (unsigned __int16)(a2 + a3);
      uint64_t v9 = (unsigned __int16)(a2 + a3);
      __int16 v10 = 8 * v7;
      while (1)
      {
        if (v45) {
          BOOL v11 = v4 == v7;
        }
        else {
          BOOL v11 = 0;
        }
        uint64_t v12 = 0x10000;
        if (v11) {
          uint64_t v12 = v9;
        }
        CFIndex v13 = v12 - v8;
        if (v46)
        {
          if (!(_BYTE)v7) {
            goto LABEL_72;
          }
          if (v7 > 0x10u
            || (uint64_t v14 = (uint64_t *)*((void *)cf + 5)) == 0
            || ((*((_DWORD *)v14 + 2) >> v7) & 1) == 0
            || *((unsigned __int8 *)v14 + 12) < v7
            || (uint64_t v15 = *v14, (v16 = *(unint64_t **)(v15 + 8 * (v7 - 1))) == 0))
          {
            CFAllocatorRef v23 = CFGetAllocator(cf);
            CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v23);
            v48.unint64_t location = v8;
            v48.CFIndex length = v13;
            CFCharacterSetAddCharactersInRange(Mutable, v48);
            uint64_t v25 = (uint64_t *)*((void *)cf + 5);
            if (v25)
            {
              if (*((unsigned __int8 *)v25 + 12) < v7)
              {
                *((unsigned char *)v25 + 12) = v7;
                uint64_t v26 = *v25;
                CFAllocatorRef v27 = CFGetAllocator(cf);
                if (v26)
                {
                  uint64_t Typed = __CFSafelyReallocateWithAllocatorTyped(v27, **((void **)cf + 5), v10 & 0x7F8, 0x6004044C4A2DFLL, 0, 0);
                  goto LABEL_43;
                }
LABEL_42:
                uint64_t Typed = CFAllocatorAllocateTyped(v27, v10 & 0x7F8, 0x6004044C4A2DFLL, 0);
LABEL_43:
                uint64_t v25 = (uint64_t *)*((void *)cf + 5);
                *uint64_t v25 = Typed;
              }
              int v31 = 1 << v7;
              if ((v25[1] & (1 << v7)) != 0) {
                CFRelease(*(CFTypeRef *)(*v25 + 8 * (v7 - 1)));
              }
              if (Mutable)
              {
                *(void *)(**((void **)cf + 5) + 8 * (v7 - 1)) = CFRetain(Mutable);
                uint64_t v32 = *((void *)cf + 5);
                int v33 = *(_DWORD *)(v32 + 8) | v31;
              }
              else
              {
                uint64_t v32 = *((void *)cf + 5);
                int v33 = *(_DWORD *)(v32 + 8) & ~v31;
              }
              *(_DWORD *)(v32 + 8) = v33;
              CFRelease(Mutable);
              goto LABEL_58;
            }
            CFAllocatorRef v29 = CFGetAllocator(cf);
            uint64_t v30 = CFAllocatorAllocateTyped(v29, 16, 0x1080040FC6463CFLL, 0);
            *((void *)cf + 5) = v30;
            *(_WORD *)(v30 + 12) = v7;
            *(_DWORD *)(v30 + 8) = 0;
            CFAllocatorRef v27 = CFGetAllocator(cf);
            goto LABEL_42;
          }
          v47.unint64_t location = v8;
          v47.CFIndex length = v13;
          CFCharacterSetRemoveCharactersInRange(*(CFMutableCharacterSetRef *)(v15 + 8 * (v7 - 1)), v47);
          unint64_t v17 = v16[5];
          if (!v17 || !*(_DWORD *)(v17 + 8) && !*(unsigned char *)(v17 + 13))
          {
            unsigned int v18 = atomic_load(v16 + 1);
            switch((v18 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (!v16[4]) {
                  goto LABEL_61;
                }
                break;
              case 3u:
              case 4u:
                if (!v16[3])
                {
LABEL_61:
                  char v40 = atomic_load(v16 + 1);
                  if ((v40 & 8) == 0)
                  {
                    CFRelease(v16);
                    *(_DWORD *)(*((void *)cf + 5) + 8) &= ~(1 << v7);
                  }
                }
                break;
              default:
                break;
            }
          }
        }
        else
        {
          if (!(_BYTE)v7)
          {
LABEL_72:
            __break(1u);
            return;
          }
          if (v7 <= 0x10u)
          {
            char v19 = (uint64_t *)*((void *)cf + 5);
            if (v19)
            {
              if (*((unsigned __int8 *)v19 + 12) < v7)
              {
                *((unsigned char *)v19 + 12) = v7;
                uint64_t v20 = *v19;
                CFAllocatorRef v21 = CFGetAllocator(cf);
                if (v20)
                {
                  uint64_t v22 = __CFSafelyReallocateWithAllocatorTyped(v21, **((void **)cf + 5), v10 & 0x7F8, 0x6004044C4A2DFLL, 0, 0);
                  goto LABEL_52;
                }
LABEL_51:
                uint64_t v22 = CFAllocatorAllocateTyped(v21, v10 & 0x7F8, 0x6004044C4A2DFLL, 0);
LABEL_52:
                char v19 = (uint64_t *)*((void *)cf + 5);
                uint64_t *v19 = v22;
              }
              if ((v19[1] & (1 << v7)) != 0)
              {
                uint64_t v36 = v7 - 1;
              }
              else
              {
                CFAllocatorRef v37 = CFGetAllocator(cf);
                CFMutableCharacterSetRef v38 = CFCharacterSetCreateMutable(v37);
                uint64_t v36 = v7 - 1;
                *(void *)(**((void **)cf + 5) + 8 * v36) = v38;
                char v19 = (uint64_t *)*((void *)cf + 5);
                *((_DWORD *)v19 + 2) |= 1 << v7;
              }
              uint64_t v39 = *(__CFCharacterSet **)(*v19 + 8 * v36);
              if (v39)
              {
                v49.unint64_t location = v8;
                v49.CFIndex length = v13;
                CFCharacterSetAddCharactersInRange(v39, v49);
              }
              goto LABEL_58;
            }
            CFAllocatorRef v34 = CFGetAllocator(cf);
            uint64_t v35 = CFAllocatorAllocateTyped(v34, 16, 0x1080040FC6463CFLL, 0);
            *((void *)cf + 5) = v35;
            *(_WORD *)(v35 + 12) = v7;
            *(_DWORD *)(v35 + 8) = 0;
            CFAllocatorRef v21 = CFGetAllocator(cf);
            goto LABEL_51;
          }
        }
LABEL_58:
        ++v7;
        v10 += 8;
        if (v4 + 1 == v7)
        {
          uint64_t v6 = *((void *)cf + 5);
          break;
        }
      }
    }
    if (v6 && !*(_DWORD *)(v6 + 8) && !*(unsigned char *)(v6 + 13))
    {
      for (uint64_t i = 0; i != 16; ++i)
      {
        uint64_t v42 = *((void *)cf + 5);
        if (((*(_DWORD *)(v42 + 8) >> i) & 2) != 0) {
          CFRelease(*(CFTypeRef *)(*(void *)v42 + 8 * i));
        }
      }
      CFAllocatorRef v43 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v43, **((void ***)cf + 5));
      CFAllocatorRef v44 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v44, *((void **)cf + 5));
      *((void *)cf + 5) = 0;
    }
  }
}

_OWORD *__CFCreateCompactBitmap(uint64_t a1, unsigned __int8 *a2)
{
  char v2 = a2;
  uint64_t v3 = 0;
  int v4 = 0;
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  char v5 = a2;
  do
  {
    int v6 = *v5;
    if ((v6 + 1) <= 1u)
    {
      unsigned int v7 = 32;
      uint64_t v8 = 1;
      while (v5[v8] == v6)
      {
        --v7;
        ++v8;
        if (v7 <= 1)
        {
          __src[v3] = v6;
          goto LABEL_9;
        }
      }
    }
    __src[v3] = v4 + 1;
    if (v4++ > 127) {
      return 0;
    }
LABEL_9:
    v5 += 32;
    ++v3;
  }
  while (v3 != 256);
  uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(a1, 32 * v4 + 256, 1807271846, 0);
  uint64_t v15 = Typed;
  if (v4 < 1)
  {
    memmove(Typed, __src, 0x100uLL);
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = Typed + 16;
    do
    {
      int v13 = __src[v11];
      *((unsigned char *)Typed + v11) = v13;
      if (v13 && v13 != 255)
      {
        long long v14 = v2[1];
        *uint64_t v12 = *v2;
        v12[1] = v14;
        v12 += 2;
      }
      v2 += 2;
      ++v11;
    }
    while (v11 != 256);
  }
  return v15;
}

void __CFCSetGetBitmap(uint64_t a1, int8x16_t *__b)
{
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x70) == 0x30 && (char v5 = *(const void **)(a1 + 24)) != 0)
  {
    memmove(__b, v5, 0x2000uLL);
  }
  else
  {
    unint64_t v6 = atomic_load((unint64_t *)(a1 + 8));
    if ((v6 & 8) != 0) {
      int v7 = -1;
    }
    else {
      int v7 = 0;
    }
    memset(__b, v7, 0x2000uLL);
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8 && (*(_DWORD *)(v8 + 8) || *(unsigned char *)(v8 + 13)))
    {
LABEL_16:
      unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
      switch((v10 >> 4) & 7)
      {
        case 0u:
          int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(a1 + 24), 0, __b, (v6 >> 3) & 1);
          if (BitmapForPlane == 255 && (v6 & 8) != 0)
          {
            int v33 = (char *)__b;
            size_t v34 = 0x2000;
            goto LABEL_46;
          }
          if (BitmapForPlane == 1 && (v6 & 8) == 0)
          {
            int v13 = (char *)__b;
            size_t v14 = 0x2000;
            goto LABEL_25;
          }
          break;
        case 1u:
          unint64_t v23 = *(unsigned int *)(a1 + 24);
          if (!WORD1(v23))
          {
            uint64_t v24 = *(void *)(a1 + 32);
            if ((uint64_t)(v24 + v23) >= 0x10000) {
              LODWORD(v24) = -(int)v23;
            }
            unsigned __int16 v25 = v23 + v24 - 1;
            if ((v6 & 8) != 0)
            {
              uint64_t v35 = (unsigned __int16)v23 >> 3;
              int v36 = v25 >> 3;
              int v37 = 255 << (v23 & 7);
              if (v36 == v35)
              {
                __b->i8[v35] &= ~((0xFFu >> (~(_BYTE)v25 & 7)) & v37);
              }
              else
              {
                __b->i8[v35] &= ~(_BYTE)v37;
                __b->i8[v25 >> 3] &= -256 >> (~(_BYTE)v25 & 7);
                if (((unint64_t)(unsigned __int16)v23 >> 3) + 1 < v36)
                {
                  int v33 = &__b->i8[(v23 >> 3) + 1];
                  size_t v34 = v36 - (v23 >> 3) - 2 + 1;
LABEL_46:
                  bzero(v33, v34);
                }
              }
            }
            else if (v25 == (unsigned __int16)v23)
            {
              __b->i8[v23 >> 3] |= 1 << (v23 & 7);
            }
            else
            {
              unint64_t v38 = v23 >> 3;
              uint64_t v39 = v25 >> 3;
              int v40 = 255 << (v23 & 7);
              if (*(_DWORD *)(a1 + 24) >> 3 == v39)
              {
                __b->i8[v39] |= (0xFFu >> (~(_BYTE)v25 & 7)) & v40;
              }
              else
              {
                __b->i8[v38] |= v40;
                __b->i8[v25 >> 3] |= 0xFFu >> (~(_BYTE)v25 & 7);
                if ((int)v38 + 1 < v39)
                {
                  int v13 = &__b->i8[(v38 + 1)];
                  size_t v14 = (v39 - v38 - 2) + 1;
LABEL_25:
                  memset(v13, 255, v14);
                }
              }
            }
          }
          break;
        case 2u:
          uint64_t v15 = *(void *)(a1 + 32);
          if (v15)
          {
            uint64_t v16 = *(unsigned __int16 **)(a1 + 24);
            do
            {
              unsigned int v17 = *v16++;
              int v18 = 1 << (v17 & 7);
              unint64_t v19 = (unint64_t)v17 >> 3;
              char v20 = __b->i8[v19];
              char v21 = v20 | v18;
              char v22 = v20 & ~(_BYTE)v18;
              if ((v6 & 8) == 0) {
                char v22 = v21;
              }
              __b->i8[v19] = v22;
              --v15;
            }
            while (v15);
          }
          break;
        case 4u:
          uint64_t v26 = 0;
          CFAllocatorRef v27 = *(int8x16_t **)(a1 + 24);
          char v28 = v27 + 16;
          do
          {
            unsigned int v29 = v27->u8[v26];
            if ((v29 + 1) > 1u)
            {
              int8x16_t v31 = *v28;
              int8x16_t v32 = v28[1];
              v28 += 2;
              *__b = v31;
              __b[1] = v32;
            }
            else
            {
              int8x16_t v30 = vdupq_n_s8(v29);
              *__b = v30;
              __b[1] = v30;
            }
            __b += 2;
            ++v26;
          }
          while (v26 != 256);
          break;
        default:
          return;
      }
    }
    else
    {
      unsigned int v9 = atomic_load((unint64_t *)(a1 + 8));
      switch((v9 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(a1 + 32)) {
            goto LABEL_16;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(a1 + 24)) {
            goto LABEL_16;
          }
          break;
        default:
          goto LABEL_16;
      }
    }
  }
}

uint64_t CFUniCharGetNumberOfPlanes(unsigned int a1)
{
  uint64_t result = 15;
  if (a1 != 1 && a1 != 108)
  {
    if (a1 >= 4)
    {
      if (a1 == 12)
      {
        return 17;
      }
      else
      {
        if (a1 - 16 < 0x54) {
          a1 += 85;
        }
        if (a1 > 0x63) {
          a1 -= 85;
        }
        return LODWORD(__CFUniCharBitmapDataArray[2 * a1 - 8]);
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

CFIndex _loadStringsDictTable(const void *a1, void *a2, void *a3, CFDictionaryRef theDict, uint64_t a5, CFTypeRef *a6)
{
  CFIndex Count = CFDictionaryGetCount(theDict);
  StringsFromCFDataRef Data = _loadStringsFromData(a1, a2, a3, *(const __CFData **)(a5 + 40), *(unsigned __int8 *)(a5 + 65), theDict, (unsigned char *)a5);
  if (a6 && StringsFromData && !*a6) {
    *a6 = CFRetain(*(CFTypeRef *)(a5 + 24));
  }
  CFIndex result = CFDictionaryGetCount(theDict);
  if (result > Count) {
    *(unsigned char *)(a5 + 75) = 1;
  }
  return result;
}

uint64_t _loadStringsFromData(const void *a1, void *a2, void *a3, const __CFData *a4, int a5, const __CFDictionary *a6, unsigned char *a7)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  uint64_t v26 = 0;
  CFAllocatorRef v27 = &v26;
  uint64_t v28 = 0x2020000000;
  char v29 = 0;
  if (a7[73])
  {
    size_t v14 = 0;
    char v15 = 1;
    if (!a3)
    {
      CFSetRef Mutable = 0;
      goto LABEL_11;
    }
    CFSetRef Mutable = 0;
    if (a7[72]) {
      goto LABEL_11;
    }
  }
  else if (!a3)
  {
    size_t v14 = 0;
    CFSetRef Mutable = 0;
    char v15 = 1;
    goto LABEL_11;
  }
  if (_dictionaryContainsAllKeysInSet((uint64_t)a6, a3))
  {
    uint64_t v17 = 0;
    goto LABEL_20;
  }
  CFIndex Count = CFSetGetCount((CFSetRef)a3);
  CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
  v25[0] = off_1ECE0A5A0;
  v25[1] = 3221225472;
  void v25[2] = ___loadStringsFromData_block_invoke;
  v25[3] = &__block_descriptor_40_e13_v24__0r_v8_16l;
  v25[4] = Mutable;
  CFSetApply(a3, (uint64_t)v25);
  char v15 = 0;
  size_t v14 = a3;
LABEL_11:
  StringsFromPlistCFDataRef Data = (const __CFDictionary *)__CFBundleCreateStringsFromPlistData(a1, Mutable, a4, a5, a2);
  CFDictionaryRef v20 = StringsFromPlistData;
  if (StringsFromPlistData)
  {
    if (CFGetTypeID(StringsFromPlistData) == 18)
    {
      if (v15)
      {
        CFIndex v21 = CFDictionaryGetCount(a6);
        CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, a6);
        BOOL v22 = CFDictionaryGetCount(a6) > v21;
        *((unsigned char *)v27 + 24) = v22;
        a7[74] = 1;
      }
      else
      {
        v24[0] = off_1ECE0A5A0;
        v24[1] = 3221225472;
        void v24[2] = ___loadStringsFromData_block_invoke_2;
        v24[3] = &unk_1ECDFFC58;
        v24[4] = &v26;
        v24[5] = v20;
        v24[6] = a6;
        CFSetApply(v14, (uint64_t)v24);
      }
    }
    CFRelease(v20);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t v17 = *((unsigned __int8 *)v27 + 24);
LABEL_20:
  _Block_object_dispose(&v26, 8);
  return v17;
}

void sub_182C679F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _loadStringsInOrder(const void *a1, void *a2, void *a3, CFDictionaryRef theDict, uint64_t a5, CFTypeRef *a6)
{
  if (*(unsigned char *)(a5 + 67))
  {
    if (*(unsigned char *)(a5 + 77))
    {
      _loadStringsDictTable(a1, a2, a3, theDict, a5, a6);
    }
    else if (*(unsigned char *)(a5 + 78))
    {
      _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 32), a3, theDict, a5, (CFURLRef *)a6);
    }
  }
  if (*(unsigned char *)(a5 + 76))
  {
    StringsFromCFDataRef Data = _loadStringsFromData(a1, a2, a3, *(const __CFData **)(a5 + 16), *(unsigned __int8 *)(a5 + 64), *(const __CFDictionary **)(a5 + 88), (unsigned char *)a5);
    if (a6 && StringsFromData && !*a6) {
      *a6 = CFRetain(*(CFTypeRef *)a5);
    }
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a5 + 88), (CFDictionaryApplierFunction)__CFStringsDictAddFunction, theDict);
  }
  else if (*(unsigned char *)(a5 + 78))
  {
    _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 8), a3, theDict, a5, (CFURLRef *)a6);
  }
  if (!*(unsigned char *)(a5 + 67))
  {
    if (*(unsigned char *)(a5 + 77))
    {
      _loadStringsDictTable(a1, a2, a3, theDict, a5, a6);
    }
    else if (*(unsigned char *)(a5 + 78))
    {
      int v13 = *(const void **)(a5 + 32);
      _loadLocTable(a1, a2, v13, a3, theDict, a5, (CFURLRef *)a6);
    }
  }
}

void _loadLocTable(const void *a1, void *a2, CFTypeRef cf1, void *a4, void *a5, uint64_t a6, CFURLRef *a7)
{
  values[1] = *(void **)off_1ECE0A5B0;
  values[0] = (void *)cf1;
  if (cf1)
  {
    int v13 = *(const void **)(a6 + 80);
    if (!v13 || !CFEqual(cf1, v13))
    {
      uint64_t v27 = 0;
      uint64_t v28 = &v27;
      uint64_t v29 = 0x2020000000;
      char v30 = 0;
      if (!a4 || *(unsigned char *)(a6 + 73) && *(unsigned char *)(a6 + 72))
      {
        CFTypeRef cf = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 1, &kCFTypeArrayCallBacks);
        size_t v14 = [[NSSet alloc] initWithObjects:&cf count:1];
        StringsFromPlistCFDataRef Data = __CFBundleCreateStringsFromPlistData(a1, (const __CFSet *)v14, *(const __CFData **)(a6 + 56), *(unsigned __int8 *)(a6 + 66), a2);
        CFDictionaryRef ValueWithKeyPath = (const __CFDictionary *)_CFPropertyListGetValueWithKeyPath(StringsFromPlistData, (const __CFString *)values[0]);
        CFDictionaryRef v17 = ValueWithKeyPath;
        if (ValueWithKeyPath && CFGetTypeID(ValueWithKeyPath) == 18 && CFDictionaryGetCount(v17) >= 1)
        {
          BOOL v22 = 0;
          _CFBundleGetLocTableProvenanceForLanguage(*(const __CFData **)(a6 + 56), (const __CFString *)values[0], &v23, &v22);
          if (v22) {
            *(unsigned char *)(a6 + 75) = 1;
          }
          CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, a5);
          *((unsigned char *)v28 + 24) = 1;
          *(unsigned char *)(a6 + 74) = 1;
          *(void *)(a6 + 80) = CFRetain(values[0]);
        }
        CFRelease(cf);

        if (StringsFromPlistData) {
          CFRelease(StringsFromPlistData);
        }
      }
      else
      {
        if (_dictionaryContainsAllKeysInSet((uint64_t)a5, a4))
        {
LABEL_23:
          _Block_object_dispose(&v27, 8);
          return;
        }
        CFIndex Count = CFSetGetCount((CFSetRef)a4);
        CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
        v26[0] = off_1ECE0A5A0;
        v26[1] = 3221225472;
        v26[2] = ___loadLocTable_block_invoke;
        v26[3] = &__block_descriptor_48_e13_v24__0r_v8_16l;
        v26[4] = values[0];
        v26[5] = Mutable;
        CFSetApply(a4, (uint64_t)v26);
        CFTypeRef v20 = __CFBundleCreateStringsFromPlistData(a1, Mutable, *(const __CFData **)(a6 + 56), *(unsigned __int8 *)(a6 + 66), a2);
        v25[0] = off_1ECE0A5A0;
        v25[1] = 3221225472;
        void v25[2] = ___loadLocTable_block_invoke_2;
        v25[3] = &unk_1ECDFFC10;
        v25[6] = a6;
        v25[7] = a5;
        v25[4] = &v27;
        void v25[5] = v20;
        CFSetApply(Mutable, (uint64_t)v25);
        if (v20) {
          CFRelease(v20);
        }
        CFRelease(Mutable);
      }
      if (a7 && !*a7)
      {
        if (*((unsigned char *)v28 + 24))
        {
          CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"/LocTable/%@.lproj", values[0]);
          *a7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21, kCFURLPOSIXPathStyle, 1u);
          CFRelease(v21);
        }
      }
      goto LABEL_23;
    }
  }
}

void sub_182C67F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t _dictionaryContainsAllKeysInSet(uint64_t a1, void *a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uint64_t v5 = 0;
  unint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 1;
  v4[0] = off_1ECE0A5A0;
  v4[1] = 3221225472;
  v4[2] = ___dictionaryContainsAllKeysInSet_block_invoke;
  v4[3] = &unk_1ECDFFC80;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApply(a2, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182C68050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef __CFBundleCreateStringsFromPlistData(CFTypeRef cf, const __CFSet *a2, const __CFData *a3, int a4, void *a5)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  CFErrorRef error = 0;
  if (!a2)
  {
    CFOptionFlags v12 = (unint64_t)(a4 != 0) << 16;
    CFAllocatorRef v13 = CFGetAllocator(cf);
    CFPropertyListRef v14 = CFPropertyListCreateWithData(v13, a3, v12, 0, &error);
    if (v14)
    {
      uint64_t v11 = (void *)v14;
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v11)) {
        return v11;
      }
      uint64_t v16 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        __CFBundleCreateStringsFromPlistData_cold_1();
      }
      CFErrorRef v17 = (CFErrorRef)v11;
      goto LABEL_18;
    }
    if (error)
    {
      BOOL v22 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412802;
        CFSetRef v27 = (const __CFSet *)cf;
        __int16 v28 = 2112;
        CFTypeRef v29 = a5;
        __int16 v30 = 2112;
        CFErrorRef v31 = error;
        unint64_t v19 = "Unable to load .strings file: %@ / %@: %@";
        CFTypeRef v20 = v22;
        uint32_t v21 = 32;
        goto LABEL_22;
      }
LABEL_17:
      CFErrorRef v17 = error;
LABEL_18:
      CFRelease(v17);
    }
    return 0;
  }
  CFTypeRef v24 = 0;
  if (a4) {
    uint64_t v9 = 65537;
  }
  else {
    uint64_t v9 = 1;
  }
  CFAllocatorRef v10 = CFGetAllocator(cf);
  if (!_CFPropertyListCreateFiltered(v10, a3, v9, a2, &v24, &error))
  {
    if (error)
    {
      int v18 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138413058;
        CFSetRef v27 = a2;
        __int16 v28 = 2112;
        CFTypeRef v29 = cf;
        __int16 v30 = 2112;
        CFErrorRef v31 = (CFErrorRef)a5;
        __int16 v32 = 2112;
        CFErrorRef v33 = error;
        unint64_t v19 = "Unable to read key-paths %@ from .strings file: %@ / %@: %@";
        CFTypeRef v20 = v18;
        uint32_t v21 = 42;
LABEL_22:
        _os_log_error_impl(&dword_182B90000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    return 0;
  }
  return v24;
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  CFTypeRef result = 0;
  if (bundle)
  {
    if (key)
    {
      LocalCFDictionaryRef InfoDictionary = CFBundleGetLocalInfoDictionary(bundle);
      if (!LocalInfoDictionary || (CFTypeRef result = CFDictionaryGetValue(LocalInfoDictionary, key)) == 0)
      {
        CFTypeRef result = CFBundleGetInfoDictionary(bundle);
        if (result)
        {
          return CFDictionaryGetValue((CFDictionaryRef)result, key);
        }
      }
    }
  }
  return result;
}

void __notifyFunc_block_invoke_2(uint64_t a1, id a2)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  if (object_getClass(a2) != (Class)off_1ECE0A6A0)
  {
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x2020000000;
    char v13 = 0;
    uint64_t v3 = *(_xpc_connection_s **)(a1 + 32);
    v9[0] = off_1ECE0A5A0;
    v9[1] = 3221225472;
    int v9[2] = __notifyFunc_block_invoke_3;
    v9[3] = &unk_1ECE00450;
    v9[4] = &v10;
    if (withClientContext(v3, (uint64_t)v9) && *((unsigned char *)v11 + 24))
    {
      v5[0] = off_1ECE0A5A0;
      v5[1] = 3221225472;
      void v5[2] = __notifyFunc_block_invoke_4;
      v5[3] = &unk_1ECE00478;
      long long v6 = *(_OWORD *)(a1 + 40);
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 56);
      uint64_t v8 = v4;
      -[CFPDSource observingConnectionsLockedSync:]((os_unfair_lock_s *)v6, (uint64_t)v5);
    }
    _Block_object_dispose(&v10, 8);
  }
}

void sub_182C68464(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 72), 8);
  _Unwind_Resume(a1);
}

void sub_182C6881C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v10 - 88), 8);
  _Unwind_Resume(a1);
}

uint64_t __notifyFunc_block_invoke_4(uint64_t a1)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v1 = *(void *)(a1 + 56);
  uint64_t v5 = v2;
  return notifyFunc(v1, &v4);
}

void notifyFunc(_xpc_connection_s *a1, uint64_t *a2)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = (_xpc_connection_s *)a2[2];
  if (v2 != a1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = &v13;
    uint64_t v15 = 0x2020000000;
    char v16 = 0;
    v12[0] = off_1ECE0A5A0;
    v12[1] = 3221225472;
    _OWORD v12[2] = __notifyFunc_block_invoke;
    v12[3] = &unk_1ECE00450;
    v12[4] = &v13;
    BOOL v5 = withClientContext(a1, (uint64_t)v12);
    if (*((unsigned char *)v14 + 24)) {
      BOOL v6 = 0;
    }
    else {
      BOOL v6 = v5;
    }
    if (v6)
    {
      uint64_t v7 = a1;
      uint64_t v8 = v2;
      xpc_object_t v9 = xpc_copy((xpc_object_t)a2[1]);
      uint64_t v10 = *a2;
      if (_CFPrefsObservationConnectionQueue_onceToken != -1) {
        dispatch_once(&_CFPrefsObservationConnectionQueue_onceToken, &__block_literal_global_391);
      }
      v11[0] = off_1ECE0A5A0;
      v11[1] = 3221225472;
      v11[2] = __notifyFunc_block_invoke_2;
      v11[3] = &unk_1ECE004A0;
      v11[4] = a1;
      v11[5] = v10;
      v11[6] = v9;
      v11[7] = v2;
      xpc_connection_send_message_with_reply(a1, v9, (dispatch_queue_t)_CFPrefsObservationConnectionQueue_observationQueue, v11);
    }
    _Block_object_dispose(&v13, 8);
  }
}

void sub_182C68CA4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 88), 8);
  _Unwind_Resume(a1);
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  __CFCheckCFInfoPACSignature((uint64_t)center);
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v8 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v8);
  }
  char v9 = atomic_load((unint64_t *)center + 1);
  if ((v9 & 2) == 0)
  {
LABEL_3:
    char v10 = atomic_load((unint64_t *)center + 1);
    if (observer || (v10 & 1) == 0)
    {
      if (name) {
        uint64_t v11 = (__CFString *)name;
      }
      else {
        uint64_t v11 = @"kCFNotificationAnyName";
      }
      char v12 = atomic_load((unint64_t *)center + 1);
      if ((object == 0) | v12 & 1) {
        uint64_t v13 = @"kCFNotificationAnyObject";
      }
      else {
        uint64_t v13 = (__CFString *)object;
      }
      if (observer) {
        uint64_t v14 = observer;
      }
      else {
        uint64_t v14 = (const void *)kCFXNotificationPlaceholderObserver;
      }
      _CFXNotificationRemoveObservers((unint64_t *)center, v11, v13, (uint64_t)v14);
    }
    return;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (name)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(name))
      {
        CFLog(4, @"*** Attempt to unregister for a distributed notification with a non-string name ignored.", v16, v17, v18, v19, v20, v21, v29);
        return;
      }
    }
    if (object)
    {
      CFTypeID v22 = CFStringGetTypeID();
      if (v22 != CFGetTypeID(object))
      {
        CFLog(4, @"*** Attempt to unregister for a distributed notification (%@) with a non-string object ignored.", v23, v24, v25, v26, v27, v28, (__int16)name);
        return;
      }
    }
    goto LABEL_3;
  }
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  if (CFNotificationCenterGetDarwinNotifyCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetDarwinNotifyCenter_static_init, &__block_literal_global_15);
  }
  return (CFNotificationCenterRef)__darwinCenter;
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  __int16 v6 = suspensionBehavior;
  __CFCheckCFInfoPACSignature((uint64_t)center);
  unint64_t v12 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v12 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v12);
  }
  uint64_t v13 = 2;
  switch(v6 & 0xF)
  {
    case 1:
      goto LABEL_11;
    case 2:
      uint64_t v13 = 4;
      if ((v6 & 0x400) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    case 3:
      uint64_t v13 = 8;
LABEL_11:
      if ((v6 & 0x400) != 0) {
        goto LABEL_12;
      }
      goto LABEL_13;
    case 4:
      uint64_t v13 = 1;
      if ((v6 & 0x400) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    default:
      if ((v6 & 0xF) == 0xELL) {
        uint64_t v13 = 65537;
      }
      else {
        uint64_t v13 = 4;
      }
      if ((v6 & 0x400) == 0) {
        goto LABEL_13;
      }
LABEL_12:
      v13 |= 0x400uLL;
      self;
LABEL_13:
      if (name) {
        uint64_t v14 = (__CFString *)name;
      }
      else {
        uint64_t v14 = @"kCFNotificationAnyName";
      }
      char v15 = atomic_load((unint64_t *)center + 1);
      if ((object == 0) | v15 & 1) {
        uint64_t v16 = @"kCFNotificationAnyObject";
      }
      else {
        uint64_t v16 = (__CFString *)object;
      }
      if (observer) {
        uint64_t v17 = (__CFString *)observer;
      }
      else {
        uint64_t v17 = (__CFString *)kCFXNotificationPlaceholderObserver;
      }
      _CFXNotificationRegisterObserver((CFIndex)center, v14, v16, v13 | 0x80000, v17, callBack, 0);
      return;
  }
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  if (CFNotificationCenterGetLocalCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetLocalCenter_static_init, &__block_literal_global_7);
  }
  return (CFNotificationCenterRef)__taskCenter;
}

void __initDayChangedNotification()
{
  if (__initDayChangedNotification_onceToken != -1) {
    dispatch_once(&__initDayChangedNotification_onceToken, &__block_literal_global_31);
  }
}

void ___signalEventQueue_block_invoke(uint64_t a1)
{
  _signalEventSync(*(void *)(a1 + 32));
  uint64_t v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

uint64_t boundPairReadOpen(char *a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a4 + 4))
  {
    CFReadStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    if (boundPairReadCanRead(v12, a4)) {
      CFReadStreamSignalEvent(a1, 2uLL, 0, v13, v14, v15, v16, v17);
    }
    _wakeReadStreamScheduledRunLoops();
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

uint64_t boundPairWriteOpen(char *a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a4 + 52))
  {
    CFWriteStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    CFWriteStreamSignalEvent(a1, 4uLL, 0, v11, v12, v13, v14, v15);
    _wakeWriteStreamScheduledRunLoops();
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

uint64_t boundPairWrite(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 > 0)
  {
    unsigned int v10 = a3;
    pthread_mutex_lock((pthread_mutex_t *)(a5 + 104));
    if (!a5) {
      goto LABEL_5;
    }
LABEL_3:
    if (!*(unsigned char *)(a5 + 48) && _cbCanWrite(*(void *)(a5 + 96)))
    {
      if (!*(unsigned char *)(a5 + 2))
      {
        uint64_t v20 = (int)cbWrite(*(void *)(a5 + 96), a2, v10);
        goto LABEL_20;
      }
    }
    else
    {
LABEL_5:
      while (!*(unsigned char *)(a5 + 2))
      {
        if (*(_WORD *)(a5 + 4))
        {
          _CFReadStreamSignalEventDelayed(*(char **)(a5 + 32), 2uLL, 0, v12, v13, v14, v15, v16);
          _wakeReadStreamScheduledRunLoops();
        }
        double Current = CFRunLoopGetCurrent();
        CFRunLoopAddSource(Current, *(CFRunLoopSourceRef *)(a5 + 56), *(CFRunLoopMode *)(a5 + 72));
        uint64_t v18 = *(const void **)(a5 + 64);
        if (v18) {
          CFRelease(v18);
        }
        if (Current) {
          CFTypeRef v19 = CFRetain(Current);
        }
        else {
          CFTypeRef v19 = 0;
        }
        *(void *)(a5 + 64) = v19;
        *(unsigned char *)(a5 + 49) = 1;
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 104));
        CFRunLoopRunInMode(*(CFRunLoopMode *)(a5 + 72), 1.0e20, 1u);
        pthread_mutex_lock((pthread_mutex_t *)(a5 + 104));
        *(unsigned char *)(a5 + 49) = 0;
        CFRunLoopRemoveSource(Current, *(CFRunLoopSourceRef *)(a5 + 56), *(CFRunLoopMode *)(a5 + 72));
        if (a5) {
          goto LABEL_3;
        }
      }
    }
    uint64_t v20 = -1;
LABEL_20:
    if (*(unsigned char *)(a5 + 1))
    {
      CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a5 + 8));
      uint64_t v21 = *(__CFRunLoop **)(a5 + 16);
      if (v21) {
        CFRunLoopWakeUp(v21);
      }
    }
    if (*(_WORD *)(a5 + 4))
    {
      _CFReadStreamSignalEventDelayed(*(char **)(a5 + 32), 2uLL, 0, v12, v13, v14, v15, v16);
      _wakeReadStreamScheduledRunLoops();
    }
    if (!*(_WORD *)(a5 + 52)) {
      goto LABEL_32;
    }
    if (*(unsigned char *)(a5 + 48) || !_cbCanWrite(*(void *)(a5 + 96)))
    {
      if (!*(unsigned char *)(a5 + 2))
      {
LABEL_32:
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 104));
        return v20;
      }
      unint64_t v22 = 16;
    }
    else
    {
      unint64_t v22 = 4;
    }
    CFWriteStreamSignalEvent(a1, v22, 0, v12, v13, v14, v15, v16);
    _wakeWriteStreamScheduledRunLoops();
    goto LABEL_32;
  }
  *(_DWORD *)(a4 + 8) = 22;
  *(void *)a4 = 1;
  if (*(_WORD *)(a5 + 52))
  {
    CFWriteStreamSignalEvent(a1, 8uLL, (_OWORD *)a4, a4, a5, a6, a7, a8);
    _wakeWriteStreamScheduledRunLoops();
  }
  return -1;
}

BOOL _cbCanWrite(uint64_t a1)
{
  return *(_DWORD *)(a1 + 36) != 0;
}

void CFWriteStreamSignalEvent(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _wakeWriteStreamScheduledRunLoops()
{
  CFArrayRef v0 = (const __CFArray *)_CFWriteStreamCopyRunLoopsAndModes();
  if (v0)
  {
    CFArrayRef v1 = v0;
    _wakeRunLoops(v0);
    CFRelease(v1);
  }
}

uint64_t boundPairRead(char *a1, char *a2, int a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)a6)
  {
    *(_DWORD *)(a4 + 8) = 22;
    *(void *)a4 = 1;
    if (*(_WORD *)(a6 + 4))
    {
      CFReadStreamSignalEvent(a1, 8uLL, (_OWORD *)a4, a4, (uint64_t)a5, a6, a7, a8);
      _wakeReadStreamScheduledRunLoops();
    }
    return -1;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a6 + 104));
  while (1)
  {
    if (*(unsigned char *)a6)
    {
      int v20 = *(unsigned __int8 *)(a6 + 3);
      goto LABEL_10;
    }
    if (_cbCanRead(*(void *)(a6 + 96))) {
      break;
    }
    int v20 = *(unsigned __int8 *)(a6 + 3);
    if (v20 == 1) {
      break;
    }
LABEL_10:
    if (v20) {
      break;
    }
    if (*(_WORD *)(a6 + 52))
    {
      _CFWriteStreamSignalEventDelayed(*(char **)(a6 + 80), 4uLL, 0, v15, v16, v17, v18, v19);
      _wakeWriteStreamScheduledRunLoops();
    }
    double Current = CFRunLoopGetCurrent();
    CFRunLoopAddSource(Current, *(CFRunLoopSourceRef *)(a6 + 8), *(CFRunLoopMode *)(a6 + 24));
    unint64_t v22 = *(const void **)(a6 + 16);
    if (v22) {
      CFRelease(v22);
    }
    if (Current) {
      CFTypeRef v23 = CFRetain(Current);
    }
    else {
      CFTypeRef v23 = 0;
    }
    *(void *)(a6 + 16) = v23;
    *(unsigned char *)(a6 + 1) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
    CFRunLoopRunInMode(*(CFRunLoopMode *)(a6 + 24), 1.0e20, 1u);
    pthread_mutex_lock((pthread_mutex_t *)(a6 + 104));
    *(unsigned char *)(a6 + 1) = 0;
    CFRunLoopRemoveSource(Current, *(CFRunLoopSourceRef *)(a6 + 8), *(CFRunLoopMode *)(a6 + 24));
  }
  int v29 = cbRead(*(void *)(a6 + 96), a2, a3);
  if (!v29 && *(unsigned char *)(a6 + 3) == 1)
  {
    if (*(_WORD *)(a6 + 4))
    {
      CFReadStreamSignalEvent(*(char **)(a6 + 32), 0x10uLL, 0, v24, v25, v26, v27, v28);
      _wakeReadStreamScheduledRunLoops();
    }
    else
    {
      *a5 = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
    return 0;
  }
  if (*(unsigned char *)a6)
  {
    if (*(unsigned char *)(a6 + 3) == 1)
    {
      unint64_t v30 = 16;
      goto LABEL_28;
    }
  }
  else
  {
    _cbCanRead(*(void *)(a6 + 96));
    if (*(unsigned char *)(a6 + 3) == 1)
    {
      unint64_t v30 = 2;
LABEL_28:
      CFReadStreamSignalEvent(a1, v30, 0, v24, v25, v26, v27, v28);
      _wakeReadStreamScheduledRunLoops();
    }
  }
  *(_DWORD *)(a4 + 8) = 0;
  *a5 = 0;
  if (*(unsigned char *)(a6 + 49))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a6 + 56));
    CFErrorRef v31 = *(__CFRunLoop **)(a6 + 64);
    if (v31) {
      CFRunLoopWakeUp(v31);
    }
  }
  if (*(_WORD *)(a6 + 4) && !*(unsigned char *)(a6 + 3))
  {
    _CFWriteStreamSignalEventDelayed(*(char **)(a6 + 80), 4uLL, 0, v24, v25, v26, v27, v28);
    _wakeWriteStreamScheduledRunLoops();
  }
  if (*(_WORD *)(a6 + 52) && !*(unsigned char *)a6 && (_cbCanRead(*(void *)(a6 + 96)) || *(unsigned char *)(a6 + 3) == 1))
  {
    CFReadStreamSignalEvent(a1, 2uLL, 0, v32, v33, v34, v35, v36);
    _wakeReadStreamScheduledRunLoops();
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
  return v29;
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream)) {
    return [(__CFReadStream *)stream hasBytesAvailable];
  }
  if ((unint64_t)(_CFStreamGetStatus((uint64_t)stream) - 4) < 0xFFFFFFFFFFFFFFFELL) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)*((void *)stream + 6);
  long long v4 = (uint64_t (*)(CFReadStreamRef, char *, void))v3[8];
  if (!v4) {
    return 1;
  }
  *((void *)stream + 2) |= 0x40uLL;
  if (*v3 > 1)
  {
    Boolean v2 = v4(stream, (char *)stream + 24, *((void *)stream + 5));
    if (*((void *)stream + 3))
    {
      uint64_t v5 = *((void *)stream + 2);
      if ((v5 & 0x1F) != 7) {
        *((void *)stream + 2) = v5 & 0xFFFFFFE0 | 7;
      }
      uint64_t v6 = *((void *)stream + 4);
      if (v6 && (*(unsigned char *)(v6 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        uint64_t v7 = *((void *)stream + 4);
        if (v7 && (unint64_t v8 = *(__CFRunLoopSource **)(v7 + 56)) != 0)
        {
          CFRetain(*(CFTypeRef *)(v7 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(void *)(*((void *)stream + 4) + 72) |= 8uLL;
          CFRunLoopSourceSignal(v8);
          CFRelease(v8);
          _wakeUpRunLoop((uint64_t)stream);
        }
        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
  }
  else
  {
    Boolean v2 = ((uint64_t (*)(CFReadStreamRef, void))v4)(stream, *((void *)stream + 5));
  }
  *((void *)stream + 2) &= ~0x40uLL;
  return v2;
}

BOOL dataCanRead(uint64_t a1, uint64_t a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a2);
  return (unint64_t)&BytePtr[CFDataGetLength(*(CFDataRef *)a2)] > *(void *)(a2 + 8);
}

BOOL boundPairReadCanRead(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (*(unsigned char *)a2) {
    return 0;
  }
  if (_cbCanRead(*(void *)(a2 + 96))) {
    return 1;
  }
  return *(unsigned char *)(a2 + 3) == 1;
}

BOOL _cbCanRead(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 36) < *(_DWORD *)(result + 32);
  }
  return result;
}

BOOL fileCanRead(uint64_t a1, uint64_t a2)
{
  return fdCanRead(*(_DWORD *)(a2 + 8));
}

BOOL fdCanRead(int a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if (a1 >= 1024)
  {
    unsigned int v3 = (a1 + 1) >> 5;
    if (((a1 + 1) & 0x1F) != 0) {
      ++v3;
    }
    size_t v4 = 4 * v3;
    Boolean v2 = malloc_type_malloc(v4, 0xCE0D56CCuLL);
    bzero(v2, v4);
  }
  else
  {
    Boolean v2 = v7;
  }
  memset(v7, 0, sizeof(v7));
  if (__darwin_check_fd_set_overflow(a1, v2, 1)) {
    *(_DWORD *)((char *)v2 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  int v5 = select_DARWIN_EXTSN();
  if (v2 != v7) {
    free(v2);
  }
  return v5 == 1;
}

void _wakeReadStreamScheduledRunLoops()
{
  CFArrayRef v0 = (const __CFArray *)_CFReadStreamCopyRunLoopsAndModes();
  if (v0)
  {
    CFArrayRef v1 = v0;
    _wakeRunLoops(v0);
    CFRelease(v1);
  }
}

void _wakeRunLoops(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i < v3; CFIndex i = v6 + 1)
    {
      CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(a1, i);
      CFIndex v6 = i + 1;
      uint64_t v7 = CFArrayGetValueAtIndex(a1, v6);
      CFRunLoopMode v8 = CFRunLoopCopyCurrentMode(ValueAtIndex);
      if (!v8) {
        break;
      }
      CFRunLoopMode v9 = v8;
      if (CFEqual(v8, v7)) {
        CFRunLoopWakeUp(ValueAtIndex);
      }
      CFRelease(v9);
    }
  }
}

size_t cbRead(uint64_t a1, char *a2, int a3)
{
  size_t v3 = 0;
  if (a1 && a2 && a3 >= 1)
  {
    uint64_t v7 = (pthread_mutex_t *)(a1 + 40);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    unsigned int v8 = *(_DWORD *)(a1 + 32);
    CFRunLoopMode v9 = (unsigned char *)*(unsigned int *)(a1 + 36);
    if (v8 <= v9)
    {
      size_t v3 = 0;
    }
    else
    {
      unsigned int v10 = v8 - v9;
      if (v10 >= a3) {
        size_t v3 = a3;
      }
      else {
        size_t v3 = v10;
      }
      uint64_t v11 = *(char **)(a1 + 8);
      uint64_t v12 = *(unsigned char **)(a1 + 16);
      int64_t v13 = v12 - v11;
      if (v12 == v11)
      {
        if (v9) {
          cbRead_cold_3();
        }
        uint64_t v18 = *(void *)(a1 + 24);
        int v19 = v18 - v12;
        size_t v20 = (v3 - (v18 - v12));
        if (v3 <= (int)v18 - (int)v12)
        {
          __cbRead((uint64_t *)a1, a2, *(void **)(a1 + 16), v3);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_2();
          }
        }
        else
        {
          __cbRead((uint64_t *)a1, a2, *(void **)(a1 + 16), v18 - (void)v12);
          __cbRead((uint64_t *)a1, &a2[v19], *(void **)(a1 + 8), v20);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_1();
          }
        }
      }
      else if (v12 >= v11)
      {
        if ((unsigned char *)(v11 - &v12[*(void *)a1] + *(void *)(a1 + 24)) != v9) {
          cbRead_cold_10();
        }
        if (v13 <= v3)
        {
          size_t v3 = v12 - v11;
          __cbRead((uint64_t *)a1, a2, v11, v13);
          unint64_t v21 = *(void *)(a1 + 8);
          if (v21 != *(void *)(a1 + 16)) {
            cbRead_cold_9();
          }
          if (v21 > *(void *)(a1 + 24)) {
            cbRead_cold_8();
          }
        }
        else
        {
          __cbRead((uint64_t *)a1, a2, v11, v3);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_7();
          }
        }
      }
      else
      {
        if ((unsigned char *)(v11 - v12) != v9) {
          cbRead_cold_6();
        }
        uint64_t v14 = *(void *)(a1 + 24);
        int v15 = v14 - v11;
        size_t v16 = (v3 - (v14 - v11));
        if (v3 <= (int)v14 - (int)v11)
        {
          __cbRead((uint64_t *)a1, a2, v11, v3);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_5();
          }
        }
        else
        {
          __cbRead((uint64_t *)a1, a2, v11, v14 - (void)v11);
          __cbRead((uint64_t *)a1, &a2[v15], *(void **)(a1 + 8), v16);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_4();
          }
        }
      }
    }
    pthread_mutex_unlock(v7);
  }
  return v3;
}

size_t cbWrite(uint64_t a1, char *a2, unsigned int a3)
{
  size_t v3 = 0;
  if (a1 && a2 && (int)a3 >= 1)
  {
    uint64_t v7 = (pthread_mutex_t *)(a1 + 40);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    size_t v8 = *(unsigned int *)(a1 + 36);
    if (v8)
    {
      if (v8 >= a3) {
        size_t v3 = a3;
      }
      else {
        size_t v3 = v8;
      }
      unsigned int v10 = *(unsigned char **)(a1 + 8);
      CFRunLoopMode v9 = *(unsigned char **)(a1 + 16);
      if (v9 == v10)
      {
        if (v8 != *(_DWORD *)(a1 + 32)) {
          cbWrite_cold_1();
        }
        uint64_t v11 = *(void *)(a1 + 24);
        int v12 = v11 - v9;
        unsigned int v13 = v3 - (v11 - v9);
        if (v3 > (int)v11 - (int)v9)
        {
          __cbWrite((uint64_t *)a1, v9, a2, v11 - (void)v9);
          unsigned int v14 = *(_DWORD *)(a1 + 36);
          if (v13 >= v14) {
            size_t v15 = v14;
          }
          else {
            size_t v15 = v13;
          }
          __cbWrite((uint64_t *)a1, *(void **)(a1 + 16), &a2[v12], v15);
          size_t v3 = (v15 + v12);
          goto LABEL_27;
        }
      }
      else if (v9 >= v10)
      {
        uint64_t v16 = *(void *)(a1 + 24) - (void)v9;
        if (&v10[v16 - *(void *)a1] != (unsigned char *)v8) {
          cbWrite_cold_3();
        }
        unsigned int v17 = v3 - v16;
        if (v3 > v16)
        {
          __cbWrite((uint64_t *)a1, v9, a2, *(void *)(a1 + 24) - (void)v9);
          unsigned int v18 = *(_DWORD *)(a1 + 36);
          if (v17 >= v18) {
            size_t v19 = v18;
          }
          else {
            size_t v19 = v17;
          }
          __cbWrite((uint64_t *)a1, *(void **)(a1 + 16), &a2[v16], v19);
          size_t v3 = (v19 + v16);
          goto LABEL_27;
        }
      }
      else
      {
        if (v10 - v9 != v8) {
          cbWrite_cold_2();
        }
        if (v8 <= a3)
        {
          __cbWrite((uint64_t *)a1, v9, a2, *(unsigned int *)(a1 + 36));
          size_t v3 = v8;
LABEL_27:
          pthread_mutex_unlock(v7);
          return v3;
        }
      }
      __cbWrite((uint64_t *)a1, v9, a2, v3);
      goto LABEL_27;
    }
    size_t v3 = 0;
    goto LABEL_27;
  }
  return v3;
}

size_t __cbWrite(uint64_t *a1, void *__dst, void *__src, size_t __len)
{
  if (!__dst) {
    __cbWrite_cold_1();
  }
  if (!__src) {
    __cbWrite_cold_2();
  }
  if ((int)__len <= 0) {
    __cbWrite_cold_3();
  }
  memmove(__dst, __src, __len);
  uint64_t v6 = *((unsigned int *)a1 + 8);
  *((_DWORD *)a1 + 9) -= __len;
  uint64_t v7 = a1[2] + __len;
  if (v7 == *a1 + v6) {
    uint64_t v7 = *a1;
  }
  a1[2] = v7;
  return __len;
}

void _legacyStreamRunLoop_workThread(dispatch_semaphore_t *a1)
{
  pthread_setname_np("com.apple.CFStream.LegacyThread");
  sLegacyRL = (uint64_t)CFRunLoopGetCurrent();
  Boolean v2 = (__CFString *)CFStringCreateWithFormat(0, 0, @"<< CFStreamLegacySource for Runloop %p >>", sLegacyRL);
  context.CFIndex version = 0;
  context.info = v2;
  context.CFAllocatorRetainCallBack retain = CFRetain;
  context.CFArrayReleaseCallBack release = CFRelease;
  context.copyDescription = CFCopyDescription;
  context.equal = CFEqual;
  context.schedule = 0;
  context.cancel = 0;
  context.hash = CFHash;
  context.perform = (void (__cdecl *)(void *))_perform;
  size_t v3 = CFRunLoopSourceCreate(0, 0, &context);
  CFRelease(v2);
  CFRunLoopAddSource((CFRunLoopRef)sLegacyRL, v3, @"kCFRunLoopDefaultMode");
  CFRelease(v3);
  dispatch_semaphore_signal(*a1);
  while (1)
    CFRunLoopRunInMode(@"kCFRunLoopDefaultMode", 1.0e30, 1u);
}

void __CFRunLoopGetMain_block_invoke()
{
  CFArrayRef v0 = (_opaque_pthread_t *)pthread_main_thread_np();
  CFArrayRef v1 = _CFRunLoopGet0(v0);
  __CFRunLoopMain = (uint64_t)v1;

  __CFRuntimeSetImmortal((uint64_t)v1);
}

const void *_CFRunLoopGet0(_opaque_pthread_t *a1)
{
  CFArrayRef v1 = a1;
  if (pthread_equal(a1, 0)) {
    CFArrayRef v1 = (_opaque_pthread_t *)pthread_main_thread_np();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  CFDictionaryRef v2 = (const __CFDictionary *)__CFRunLoops;
  if (!__CFRunLoops)
  {
    CFSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    uint64_t v4 = pthread_main_thread_np();
    int v5 = (const void *)__CFRunLoopCreate(v4);
    uint64_t v6 = (const void *)pthread_main_thread_np();
    CFDictionarySetValue(Mutable, v6, v5);
    uint64_t v7 = 0;
    atomic_compare_exchange_strong(&__CFRunLoops, (unint64_t *)&v7, (unint64_t)Mutable);
    if (v7) {
      CFRelease(Mutable);
    }
    CFRelease(v5);
    CFDictionaryRef v2 = (const __CFDictionary *)__CFRunLoops;
  }
  CFNumberRef Value = CFDictionaryGetValue(v2, v1);
  if (Value)
  {
    CFRunLoopMode v9 = Value;
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }
  else
  {
    CFRunLoopMode v9 = (const void *)__CFRunLoopCreate((uint64_t)v1);
    kdebug_trace();
    CFDictionarySetValue((CFMutableDictionaryRef)__CFRunLoops, v1, v9);
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    if (v9) {
      CFRelease(v9);
    }
  }
  unsigned int v10 = pthread_self();
  if (pthread_equal(v1, v10))
  {
    _CFSetTSD(0xAu, (uint64_t)v9, 0);
    if (!_CFGetTSD(0xBu)) {
      _CFSetTSD(0xBu, 3, (uint64_t)__CFFinalizeRunLoop);
    }
  }
  return v9;
}

uint64_t __CFRunLoopCreate(uint64_t a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  uint64_t Instance = _CFRuntimeCreateInstance(&__kCFAllocatorSystemDefault, 0x2BuLL, 672, 0);
  if (!Instance) {
    return Instance;
  }
  v9.__sig = 0;
  *(void *)v9.__opaque = 0;
  pthread_mutexattr_init(&v9);
  pthread_mutexattr_settype(&v9, 2);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &v9);
  pthread_mutexattr_destroy(&v9);
  mach_port_name_t name = 0;
  *(_OWORD *)&options.flags = xmmword_182DA1E30;
  options.reserved[1] = 0;
  uint64_t result = mach_port_construct(*(_DWORD *)off_1ECE0A6C8, &options, Instance, &name);
  if (result)
  {
    uint64_t v7 = snprintf((char *)&v9, 0x100uLL, "*** The system has no mach ports available. You may be able to diagnose which application(s) are using ports by using 'top' or Activity Monitor. (%d) ***", result);
    qword_1EC093AA8 = (uint64_t)&v9;
    __THE_SYSTEM_HAS_NO_PORTS_AVAILABLE__(v7);
  }
  mach_port_name_t v4 = name;
  *(_DWORD *)(Instance + 80) = name;
  if (v4)
  {
    *(_WORD *)(Instance + 84) = 0;
    *(unsigned char *)(Instance + 339) = 1;
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    *(void *)(Instance + 608) = Mutable;
    CFSetAddValue(Mutable, @"kCFRunLoopDefaultMode");
    *(void *)(Instance + 632) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    *(void *)(Instance + 600) = a1;
    *(_DWORD *)(Instance + 684) = 0;
    *(unsigned char *)(Instance + 681) = 1;
    uint64_t v6 = (const void *)__CFRunLoopCopyMode(Instance, @"kCFRunLoopDefaultMode", 1);
    if (v6) {
      CFRelease(v6);
    }
    return Instance;
  }
  __break(1u);
  return result;
}

SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
{
  mach_msg_return_t v40;
  mach_port_name_t msgh_local_port;
  uint64_t v42;
  uint64_t v43;
  double v44;
  __objc2_class **Value;
  __objc2_class **v46;
  BOOL v47;
  int v48;
  CFDataRef v49;
  CFDataRef *v50;
  __CFRunLoop *rl;
  long long v52;
  CFTypeRef (__cdecl *v53)(CFTypeRef);
  void (__cdecl *v54)(CFTypeRef);
  CFStringRef (*v55)(unint64_t *);
  uint64_t v56;

  char v56 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)remote);
  unint64_t v14 = _CFGetNonObjCTypeID((unint64_t *)remote);
  if (v14 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v14);
  }
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  if (data && CFDataGetLength(data) >= 1610612737)
  {
    CFLog(4, @"*** CFMessagePortSendRequest: CFMessagePort cannot send more than %lu bytes of data", v16, v17, v18, v19, v20, v21, 0);
    return -4;
  }
  os_unfair_lock_lock((os_unfair_lock_t)remote + 28);
  char v22 = atomic_load((unint64_t *)remote + 1);
  if ((v22 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    return -3;
  }
  unint64_t v50 = returnData;
  rl = Current;
  CFRetain(remote);
  if (!*((void *)remote + 6))
  {
    *(void *)&unint64_t v52 = 0;
    *((void *)&v52 + 1) = remote;
    unint64_t v53 = CFRetain;
    unint64_t v54 = CFRelease;
    unint64_t v55 = __CFMessagePortCopyDescription;
    uint64_t v24 = (__objc2_class **)CFGetAllocator(remote);
    *((void *)remote + 6) = _CFMachPortCreateReply(v24, (uint64_t)__CFMessagePortReplyCallBack, &v52, 0);
  }
  int v25 = *((_DWORD *)remote + 10);
  *((_DWORD *)remote + 10) = v25 + 1;
  mach_port_t Port = CFMachPortGetPort(*((CFMachPortRef *)remote + 3));
  if (replyMode)
  {
    mach_port_t v27 = CFMachPortGetPort(*((CFMachPortRef *)remote + 6));
    if (data)
    {
LABEL_11:
      BytePtr = CFDataGetBytePtr(data);
      int Length = CFDataGetLength(data);
      goto LABEL_14;
    }
  }
  else
  {
    mach_port_t v27 = 0;
    if (data) {
      goto LABEL_11;
    }
  }
  BytePtr = 0;
  int Length = -1;
LABEL_14:
  Message = __CFMessagePortCreateMessage(0, Port, v27, v25 + 1, msgid, BytePtr, Length);
  if (!Message)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    CFRelease(remote);
    return -4;
  }
  CFErrorRef v31 = (mach_msg_header_t *)Message;
  int v32 = ~v25;
  if (replyMode)
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32, &__kCFNull);
    CFAllocatorRef v33 = CFGetAllocator(remote);
    RunLoopSource = CFMachPortCreateRunLoopSource(v33, *((CFMachPortRef *)remote + 6), -100);
    uint64_t v35 = rl;
    if (CFRunLoopContainsSource(rl, RunLoopSource, replyMode))
    {
      char v36 = 1;
    }
    else
    {
      CFRunLoopAddSource(rl, RunLoopSource, replyMode);
      char v36 = 0;
    }
  }
  else
  {
    RunLoopSource = 0;
    char v36 = 1;
    uint64_t v35 = rl;
  }
  if (sendTimeout >= 864000.0)
  {
    mach_msg_timeout_t v38 = 0;
    mach_msg_option_t v39 = 1;
  }
  else
  {
    double v37 = sendTimeout * 1000.0;
    if (sendTimeout * 1000.0 < 1.0) {
      double v37 = 0.0;
    }
    mach_msg_timeout_t v38 = vcvtmd_u64_f64(v37);
    mach_msg_option_t v39 = 17;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
  int v40 = mach_msg(v31, v39, v31->msgh_size, 0, 0, v38, 0);
  os_unfair_lock_lock((os_unfair_lock_t)remote + 28);
  if (!v40)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v31);
    if (replyMode)
    {
      _CFMachPortInstallNotifyPort(v35, replyMode);
      uint64_t v42 = mach_absolute_time();
      CFAllocatorRef v43 = __CFTimeIntervalToTSR(rcvTimeout) + v42;
      do
      {
        CFAllocatorRef v44 = __CFTimeIntervalUntilTSR(v43);
        CFRunLoopRunInMode(replyMode, v44, 1u);
        CFNumberRef Value = (__objc2_class **)CFDictionaryGetValue(*((CFDictionaryRef *)remote + 4), (const void *)v32);
        BOOL v46 = Value;
        if (Value) {
          CFRange v47 = &__kCFNull == Value;
        }
        else {
          CFRange v47 = 1;
        }
        CFRange v48 = v47;
      }
      while (v47 && v43 >= mach_absolute_time() && CFMessagePortIsValid(remote));
      if ((v36 & 1) == 0) {
        CFRunLoopRemoveSource(rl, RunLoopSource, replyMode);
      }
      if (RunLoopSource) {
        CFRelease(RunLoopSource);
      }
      if (v48)
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32);
        CFRelease(remote);
        if (CFMessagePortIsValid(remote)) {
          return -2;
        }
        else {
          return -5;
        }
      }
      if (v50)
      {
        if (&__kCFBooleanFalse == v46) {
          CFRange v49 = 0;
        }
        else {
          CFRange v49 = (const __CFData *)CFRetain(v46);
        }
        *unint64_t v50 = v49;
      }
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32);
    }
    CFRelease(remote);
    return 0;
  }
  if (replyMode)
  {
    if ((v40 - 268435459) <= 4 && ((1 << (v40 - 3)) & 0x13) != 0)
    {
      mach_port_t msgh_local_port = v31->msgh_local_port;
      if (msgh_local_port - 1 <= 0xFFFFFFFD && (v31->msgh_bits & 0x1F00) == 0x1200)
      {
        mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, msgh_local_port);
        v31->mach_port_t msgh_local_port = 0;
      }
    }
  }
  if ((v36 & 1) == 0) {
    CFRunLoopRemoveSource(v35, RunLoopSource, replyMode);
  }
  if (RunLoopSource) {
    CFRelease(RunLoopSource);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v31);
  CFRelease(remote);
  if (v40 == 268435460) {
    return -1;
  }
  else {
    return -4;
  }
}

mach_port_t CFMachPortGetPort(CFMachPortRef port)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  if (!CF_IS_OBJC(0x24uLL, (unint64_t)port)) {
    return *((_DWORD *)port + 5);
  }

  return [(__CFMachPort *)port machPort];
}

char *__CFMessagePortCreateMessage(int a1, int a2, int a3, int a4, int a5, const void *a6, int a7)
{
  if ((a7 - 1610612737) < 0x9FFFFFFE) {
    return 0;
  }
  if (a7 == -1) {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v15 = (a7 + 7) & 0xFFFFFFF8;
  }
  if (v15 >= 0xFA1) {
    size_t v16 = 60;
  }
  else {
    size_t v16 = v15 + 60;
  }
  uint64_t Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v16, 1304999177, 0);
  uint64_t v7 = Typed;
  if (Typed)
  {
    bzero(Typed, v16);
    *((_DWORD *)v7 + 2) = a2;
    *((_DWORD *)v7 + 3) = a3;
    if (a1) {
      int v18 = 18;
    }
    else {
      int v18 = 19;
    }
    if (a3) {
      int v19 = 5376;
    }
    else {
      int v19 = 0;
    }
    int v20 = v19 | v18;
    *(_DWORD *)uint64_t v7 = v20;
    *((_DWORD *)v7 + 1) = v16;
    *(void *)(v7 + 20) = 1667657072;
    *((_DWORD *)v7 + 11) = -252513032;
    *((_DWORD *)v7 + 12) = a5;
    *((_DWORD *)v7 + 13) = a4;
    *((_DWORD *)v7 + 14) = a7;
    if (v15 > 0xFA0)
    {
      *(_DWORD *)uint64_t v7 = v20 | 0x80000000;
      *((_DWORD *)v7 + 6) = 1;
      int v21 = v7[38];
      *(void *)(v7 + 28) = a6;
      *((_DWORD *)v7 + 9) = (v21 << 16) | 0x1000100;
      *((_DWORD *)v7 + 10) = a7;
    }
    else if (a6 && a7 >= 1)
    {
      memmove(v7 + 60, a6, a7);
    }
  }
  return v7;
}

void _cfstream_solo_signalEventSync(uint64_t a1)
{
  if ((CFGetTypeID((CFTypeRef)a1) & 0xFFFFFFFFFFFFFFFELL) == 0x26)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(unsigned char *)(a1 + 136))
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    }
    else
    {
      size_t v8 = *(NSObject **)(a1 + 128);
      if (v8)
      {
        dispatch_retain(*(dispatch_object_t *)(a1 + 128));
        CFRetain((CFTypeRef)a1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        _signalEventQueue(v8, (CFTypeRef)a1);
        dispatch_release(v8);
      }
      else
      {
        CFRetain((CFTypeRef)a1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        _signalEventSync(a1);
      }
      CFRelease((CFTypeRef)a1);
    }
  }
  else
  {
    CFLog(3, @"Expected a read or write stream for %p", v2, v3, v4, v5, v6, v7, a1);
  }
}

void _cfstream_shared_signalEventSync(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFArrayGetTypeID())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1)
    {
      CFIndex v10 = 0;
      unsigned int v13 = 0;
      uint64_t v12 = 0;
    }
    else
    {
      CFIndex v10 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
        if (!*((unsigned char *)ValueAtIndex + 136))
        {
          uint64_t v12 = (uint64_t)ValueAtIndex;
          if (*(void *)(ValueAtIndex[4] + 72)) {
            break;
          }
        }
        if (Count == ++v10)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
          return;
        }
      }
      CFRetain(ValueAtIndex);
      unsigned int v13 = *(NSObject **)(v12 + 128);
      if (v13) {
        dispatch_retain(*(dispatch_object_t *)(v12 + 128));
      }
      *(unsigned char *)(v12 + 136) = 1;
    }
    if (v10 < Count)
    {
      while (1)
      {
        unint64_t v14 = (char *)CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
        if (v14 != (char *)v12)
        {
          unsigned int v15 = v14;
          if (!v14[136])
          {
            if (*(void *)(*((void *)v14 + 4) + 72)) {
              break;
            }
          }
        }
        if (Count == ++v10) {
          goto LABEL_21;
        }
      }
      pthread_mutex_lock((pthread_mutex_t *)(v14 + 56));
      uint64_t v16 = *((void *)v15 + 4);
      if (v16 && (uint64_t v17 = *(__CFRunLoopSource **)(v16 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v16 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 56));
        CFRunLoopSourceSignal(v17);
        CFRelease(v17);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 56));
      }
    }
LABEL_21:
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    if (v12)
    {
      if (v13)
      {
        _signalEventQueue(v13, (CFTypeRef)v12);
        dispatch_release(v13);
      }
      else
      {
        _signalEventSync(v12);
      }
      CFRelease((CFTypeRef)v12);
    }
  }
  else
  {
    CFLog(3, @"Expected an array for %p", v3, v4, v5, v6, v7, v8, (__int16)a1);
  }
}

uint64_t _signalEventSync(uint64_t a1)
{
  *(void *)(a1 + 16) |= 0x40uLL;
  CFTypeID v2 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3 && (unint64_t v4 = v3[9]) != 0)
  {
    uint64_t v5 = (uint64_t (*)(uint64_t, unint64_t, uint64_t))v3[5];
    uint64_t v7 = v3[1];
    uint64_t v6 = (uint64_t (*)(void))v3[2];
    if (v6)
    {
      uint64_t v7 = v6(v3[1]);
      uint64_t v3 = *(void **)(a1 + 32);
      uint64_t v8 = (uint64_t (*)(uint64_t))v3[3];
      unint64_t v4 = v3[9];
    }
    else
    {
      uint64_t v8 = 0;
    }
    v3[9] = 0;
    *(unsigned char *)(a1 + 136) = 0;
    uint64_t result = pthread_mutex_unlock(v2);
    if (v4)
    {
      for (unint64_t i = 1; i <= v4; i *= 2)
      {
        pthread_mutex_lock(v2);
        if ((i & v4) != 0 && (uint64_t v11 = *(void *)(a1 + 32)) != 0)
        {
          unint64_t v12 = *(void *)(v11 + 48) & i;
          uint64_t result = pthread_mutex_unlock(v2);
          if (v12) {
            uint64_t result = v5(a1, i, v7);
          }
        }
        else
        {
          uint64_t result = pthread_mutex_unlock(v2);
        }
      }
    }
    if (v8) {
      uint64_t result = v8(v7);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 136) = 0;
    uint64_t result = pthread_mutex_unlock(v2);
  }
  *(void *)(a1 + 16) &= ~0x40uLL;
  return result;
}

void _CFStreamSignalEvent(char *cf, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v10 = *((void *)cf + 2);
  unint64_t v11 = v10 & 0x1F;
  if ((v10 & 0x1F) == 0)
  {
    CFLog(3, @"Stream %p is sending an event before being opened", (uint64_t)a3, a4, a5, a6, a7, a8, (__int16)cf);
    goto LABEL_7;
  }
  if ((v10 & 0x1E) == 6)
  {
LABEL_7:
    unint64_t v13 = 0;
    goto LABEL_8;
  }
  unint64_t v13 = a2;
  if (v11 == 1)
  {
    if (a2)
    {
      uint64_t v10 = v10 & 0xFFFFFFE0 | 2;
      *((void *)cf + 2) = v10;
    }
    goto LABEL_22;
  }
  if (v11 != 5)
  {
    unint64_t v13 = a2 & 0xFFFFFFFFFFFFFFFELL;
LABEL_22:
    if (v11 <= 4 && (v13 & 0x10) != 0 && (v10 & 0x1E) != 6) {
      *((void *)cf + 2) = v10 & 0xFFFFFFE0 | 5;
    }
    goto LABEL_30;
  }
  unint64_t v13 = a2 & 8;
LABEL_30:
  if ((v13 & 8) != 0)
  {
    if (**((uint64_t **)cf + 6) > 1)
    {
      CFRetain(a3);
      int v25 = (const void *)*((void *)cf + 3);
      if (v25) {
        CFRelease(v25);
      }
      *((void *)cf + 3) = a3;
    }
    else
    {
      uint64_t Typed = (_OWORD *)*((void *)cf + 3);
      if (!Typed)
      {
        CFAllocatorRef v24 = CFGetAllocator(cf);
        uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v24, 16, 0x1000040D9A13B51, 0);
        *((void *)cf + 3) = Typed;
      }
      _OWORD *Typed = *a3;
    }
    uint64_t v26 = *((void *)cf + 2);
    if ((v26 & 0x1F) != 7) {
      *((void *)cf + 2) = v26 & 0xFFFFFFE0 | 7;
    }
  }
LABEL_8:
  uint64_t v14 = *((void *)cf + 4);
  if (v14 && (*(void *)(v14 + 48) & v13) != 0 && (*(void *)(v14 + 72) & v13) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    uint64_t v15 = *((void *)cf + 4);
    if (v15 && (uint64_t v16 = *(__CFRunLoopSource **)(v15 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v15 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      *(void *)(*((void *)cf + 4) + 72) |= v13;
      if (v8
        && (cf[16] & 0x40) == 0
        && (Current = CFRunLoopGetCurrent(), (CFStringRef v18 = CFRunLoopCopyCurrentMode(Current)) != 0)
        && (v19 = v18, int v20 = CFRunLoopContainsSource(Current, v16, v18), CFRelease(v19), v20))
      {
        _cfstream_solo_signalEventSync((uint64_t)cf);
      }
      else
      {
        CFRunLoopSourceSignal(v16);
        _wakeUpRunLoop((uint64_t)cf);
      }
      CFRelease(v16);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
  }
}

void _wakeUpRunLoop(uint64_t a1)
{
  CFArrayRef v1 = _CFStreamCopyRunLoopsAndModes(a1);
  if (!v1) {
    return;
  }
  CFArrayRef v2 = v1;
  CFIndex Count = CFArrayGetCount(v1);
  if (Count == 2) {
    goto LABEL_3;
  }
  CFIndex v5 = Count;
  if (Count < 3) {
    goto LABEL_23;
  }
  CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, 0);
  if (ValueAtIndex)
  {
    unint64_t v4 = ValueAtIndex;
    uint64_t v7 = 4;
    do
    {
      int v8 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, v7 - 2);
      BOOL v9 = v8 == v4 && v7 < v5;
      v7 += 2;
    }
    while (v9);
    if (v8 != v4) {
      unint64_t v4 = 0;
    }
    if (v4) {
      goto LABEL_4;
    }
  }
  CFIndex v10 = 0;
  while (1)
  {
    unint64_t v4 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, v10);
    CFRunLoopMode v11 = CFRunLoopCopyCurrentMode(v4);
    if (v11) {
      break;
    }
LABEL_21:
    v10 += 2;
    if (v10 >= v5) {
      goto LABEL_3;
    }
  }
  CFRunLoopMode v12 = v11;
  unint64_t v13 = CFArrayGetValueAtIndex(v2, v10 + 1);
  if (!CFEqual(v12, v13) || !CFRunLoopIsWaiting(v4))
  {
    CFRelease(v12);
    goto LABEL_21;
  }
  CFRelease(v12);
  if (v4)
  {
LABEL_4:
    CFRunLoopWakeUp(v4);
    goto LABEL_23;
  }
LABEL_3:
  unint64_t v4 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, 0);
  if (v4) {
    goto LABEL_4;
  }
LABEL_23:

  CFRelease(v2);
}

CFArrayRef _CFStreamCopyRunLoopsAndModes(uint64_t a1)
{
  CFArrayRef Copy = (CFArrayRef)a1;
  if (a1)
  {
    if (*(void *)(a1 + 32))
    {
      CFArrayRef v2 = (pthread_mutex_t *)(a1 + 56);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      if (*(void *)(*((void *)Copy + 4) + 64))
      {
        CFAllocatorRef v3 = CFGetAllocator(Copy);
        CFArrayRef Copy = CFArrayCreateCopy(v3, *(CFArrayRef *)(*((void *)Copy + 4) + 64));
      }
      else
      {
        CFArrayRef Copy = 0;
      }
      pthread_mutex_unlock(v2);
    }
    else
    {
      return 0;
    }
  }
  return Copy;
}

void CFReadStreamSignalEvent(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t _CFRunLoopSetPerCalloutAutoreleasepoolEnabled(uint64_t a1)
{
  *((unsigned char *)CFRunLoopGetCurrent() + 681) = a1;
  return a1;
}

void CFRunLoopRun(void)
{
  do
  {
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    int v1 = CFRunLoopRunSpecific((uint64_t)Current, @"kCFRunLoopDefaultMode", 0, 1.0e10);
    if ((__CF_FORK_STATE & 2) == 0) {
      __CF_USED();
    }
    if (__CF_FORK_STATE) {
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
  }
  while ((v1 - 3) < 0xFFFFFFFE);
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  int v3 = returnAfterSourceHandled;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRunLoopRef Current = CFRunLoopGetCurrent();

  return CFRunLoopRunSpecific((uint64_t)Current, mode, v3, seconds);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRunLoopRef result = (CFRunLoopRef)_CFGetTSD(0xAu);
  if (!result)
  {
    int v1 = pthread_self();
    return (CFRunLoopRef)_CFRunLoopGet0(v1);
  }
  return result;
}

Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if (v7)
  {
    BOOL v17 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v17 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v8 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    CFSetRef v14 = (const __CFSet *)*((void *)rl + 77);
    if (v14)
    {
      Boolean v13 = CFSetContainsValue(v14, source);
      goto LABEL_19;
    }
LABEL_14:
    Boolean v13 = 0;
    goto LABEL_19;
  }
  uint64_t v9 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v9) {
    goto LABEL_14;
  }
  CFIndex v10 = (void *)v9;
  CFRunLoopMode v11 = (pthread_mutex_t *)(v9 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
  CFSetRef v12 = (const __CFSet *)v10[12];
  if (v12 && CFSetContainsValue(v12, source))
  {
    Boolean v13 = 1;
  }
  else
  {
    CFSetRef v15 = (const __CFSet *)v10[13];
    if (v15) {
      Boolean v13 = CFSetContainsValue(v15, source) != 0;
    }
    else {
      Boolean v13 = 0;
    }
  }
  pthread_mutex_unlock(v11);
  CFRelease(v10);
LABEL_19:
  pthread_mutex_unlock(v8);
  return v13;
}

uint64_t _CFMachPortCreateReply(__objc2_class **a1, uint64_t a2, long long *a3, unsigned char *a4)
{
  kern_return_t v8;
  int v9;
  NSObject *v10;
  uint64_t result;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  mach_port_name_t name;
  mach_port_options_t options;
  uint64_t v19;

  CFStringRef v19 = *(void *)off_1ECE0A5B0;
  if (a4) {
    *a4 = 1;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  mach_port_name_t name = 0;
  *(_OWORD *)&options.flags = xmmword_182DA0B10;
  options.reserved[1] = 0;
  int v8 = mach_port_construct(*(_DWORD *)off_1ECE0A6C8, &options, 0, &name);
  if (v8)
  {
    uint64_t v9 = v8;
    CFIndex v10 = _CFOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      _CFMachPortCreateReply_cold_1(v9, v10);
    }
    return 0;
  }
  CFRunLoopRef result = _CFMachPortCreateWithPort4(a1, name, a2, a3, a4, 1);
  if (!result)
  {
    if (name)
    {
      mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, name, 1u, -1);
      mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, name);
    }
    return 0;
  }
  CFSetRef v12 = atomic_load((unint64_t *)(result + 8));
  Boolean v13 = v12;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v13, v12 | 2);
    CFSetRef v14 = v13 == v12;
    CFSetRef v12 = v13;
  }
  while (!v14);
  CFSetRef v15 = atomic_load((unint64_t *)(result + 8));
  uint64_t v16 = v15;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v16, v15 | 4);
    CFSetRef v14 = v16 == v15;
    CFSetRef v15 = v16;
  }
  while (!v14);
  return result;
}

void _signalEventQueue(NSObject *a1, CFTypeRef cf)
{
  v4[5] = *(void *)off_1ECE0A5B0;
  CFRetain(cf);
  v4[0] = off_1ECE0A5A0;
  v4[1] = 3221225472;
  v4[2] = ___signalEventQueue_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = cf;
  dispatch_async(a1, v4);
}

void _outputStreamCallbackFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = (id)[a3 retainedDelegate];
  if (objc_opt_respondsToSelector()) {
    [v5 stream:a1 handleEvent:a2];
  }
}

id _NSObjectLoadWeakRetained(id *a1, unsigned char *a2)
{
  if (*a2) {
    return *a1;
  }
  else {
    return objc_loadWeakRetained(a1);
  }
}

size_t __cbRead(uint64_t *a1, void *__dst, void *__src, size_t __len)
{
  if (!__dst) {
    __cbRead_cold_1();
  }
  if (!__src) {
    __cbRead_cold_2();
  }
  if ((int)__len <= 0) {
    __cbRead_cold_3();
  }
  memmove(__dst, __src, __len);
  uint64_t v6 = *((unsigned int *)a1 + 8);
  *((_DWORD *)a1 + 9) += __len;
  uint64_t v7 = a1[1] + __len;
  if (v7 == *a1 + v6) {
    uint64_t v7 = *a1;
  }
  a1[1] = v7;
  return __len;
}

void __CF_USED()
{
}

uint64_t CFStorageGetCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 == -1) {
    return v1 / *(void *)(a1 + 16);
  }
  else {
    return v1 >> v2;
  }
}

uint64_t _CFURLRegisterFilePropertyProvider()
{
  return MEMORY[0x1F4114FD8]();
}

uint64_t decomposeToRFC1808(unint64_t a1, const __CFString **a2)
{
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  int v5 = CF_IS_OBJC(0x1DuLL, a1);
  uint64_t v6 = a1;
  if (v5) {
    uint64_t v6 = [(id)a1 _cfurl];
  }
  if ((*(unsigned char *)(v6 + 17) & 0x40) == 0) {
    return 0;
  }
  CFStringRef v8 = CFURLCopyPath((CFURLRef)a1);
  if (v8)
  {
    CFStringRef v9 = v8;
    a2[5] = (const __CFString *)CFStringCreateArrayBySeparatingStrings(v4, v8, @"/");
    CFRelease(v9);
  }
  else
  {
    a2[5] = 0;
  }
  if (CF_IS_OBJC(0x1DuLL, a1)) {
    CFStringRef v10 = (const __CFString *)[(id)a1 baseURL];
  }
  else {
    CFStringRef v10 = *(const __CFString **)(a1 + 32);
  }
  a2[9] = v10;
  if (v10)
  {
    CFRetain(v10);
    CFStringRef v11 = 0;
  }
  else
  {
    CFStringRef v11 = _retainedComponentString(a1, 1, 1, 0);
  }
  *a2 = v11;
  a2[1] = _retainedComponentString(a1, 2, 0, 0);
  a2[2] = _retainedComponentString(a1, 4, 0, 0);
  a2[3] = _retainedComponentString(a1, 8, 0, 0);
  if ((*(unsigned char *)(a1 + 16) & 0x10) != 0) {
    uint64_t v12 = CFURLGetPortNumber((CFURLRef)a1);
  }
  else {
    uint64_t v12 = -1;
  }
  a2[4] = (const __CFString *)v12;
  a2[6] = 0;
  a2[7] = _retainedComponentString(a1, 128, 0, 0);
  a2[8] = _retainedComponentString(a1, 256, 0, 0);
  return 1;
}

uint64_t _CFPreferencesGetAppIntegerValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  CFNumberRef v5 = (const __CFNumber *)_CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0);
  if (v5)
  {
    CFNumberRef v6 = v5;
    uint64_t valuePtr = 0;
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == 22)
    {
      int IsFloatType = CFNumberIsFloatType(v6);
      if (a4) {
        *a4 = IsFloatType == 0;
      }
      CFNumberGetValue(v6, kCFNumberCFIndexType, &valuePtr);
      goto LABEL_22;
    }
    if (v7 != 7)
    {
      if (v7 != CFBooleanGetTypeID())
      {
        uint64_t valuePtr = 0;
        if (a4) {
          *a4 = 0;
        }
        goto LABEL_22;
      }
      if (a4) {
        *a4 = 1;
      }
      uint64_t v12 = v6 == (const __CFNumber *)&__kCFBooleanTrue;
LABEL_21:
      uint64_t valuePtr = v12;
LABEL_22:
      CFRelease(v6);
      return valuePtr;
    }
    uint64_t v15 = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)buffer = 0u;
    long long v18 = 0u;
    CFNumberRef v25 = v6;
    uint64_t v28 = 0;
    CFIndex Length = CFStringGetLength((CFStringRef)v6);
    CharactersPtr = CFStringGetCharactersPtr((CFStringRef)v6);
    CStringPtr = 0;
    uint64_t v26 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr((CFStringRef)v6, 0x600u);
    }
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    mach_port_t v27 = CStringPtr;
    if (__CFStringScanInteger(buffer, 0, (int *)&v15 + 1, 0, &v15))
    {
      uint64_t v10 = SHIDWORD(v15);
      BOOL v11 = CFStringGetLength((CFStringRef)v6) == v10;
      if (!a4) {
        goto LABEL_9;
      }
    }
    else
    {
      BOOL v11 = 0;
      if (!a4)
      {
LABEL_9:
        if (v11) {
          uint64_t v12 = (int)v15;
        }
        else {
          uint64_t v12 = 0;
        }
        goto LABEL_21;
      }
    }
    *a4 = v11;
    goto LABEL_9;
  }
  uint64_t result = 0;
  if (a4) {
    *a4 = 0;
  }
  return result;
}

SInt32 CFURLGetPortNumber(CFURLRef anURL)
{
  *(void *)&v11[47] = *(void *)off_1ECE0A5B0;
  while (1)
  {
    if (!anURL) {
      CFURLGetPortNumber_cold_1();
    }
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
      break;
    }
    CFStringRef v2 = _retainedComponentString((uint64_t)anURL, 16, 1, 0);
    if (v2)
    {
      CFStringRef v6 = v2;
      memset(v11, 0, 132);
      int Length = CFStringGetLength(v2);
      *(void *)&v11[33] = v6;
      *(void *)&v11[39] = 0;
      *(void *)&v11[41] = Length;
      CharactersPtr = CFStringGetCharactersPtr(v6);
      CStringPtr = 0;
      *(void *)&v11[35] = CharactersPtr;
      if (!CharactersPtr) {
        CStringPtr = CFStringGetCStringPtr(v6, 0x600u);
      }
      *(void *)&v11[43] = 0;
      *(void *)&v11[45] = 0;
      *(void *)&v11[37] = CStringPtr;
      int v10 = 0;
      if (!__CFStringScanInteger((UniChar *)&v11[1], 0, &v10, 0, (uint64_t *)v11) || v10 != Length) {
        v11[0] = -1;
      }
      CFRelease(v6);
      return v11[0];
    }
    if (*((void *)anURL + 4))
    {
      char v3 = *((unsigned char *)anURL + 16);
      anURL = (CFURLRef)*((void *)anURL + 4);
      if ((v3 & 0x1F) == 0) {
        continue;
      }
    }
    return -1;
  }
  CFNumberRef v4 = (const __CFNumber *)[(__CFURL *)anURL port];
  v11[1] = 0;
  if (!v4) {
    return -1;
  }
  if (CFNumberGetValue(v4, kCFNumberSInt32Type, &v11[1])) {
    return v11[1];
  }
  else {
    return -1;
  }
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  int v5 = 0;
  CFStringRef v15 = str;
  uint64_t v18 = 0;
  CFIndex Length = CFStringGetLength(str);
  CharactersPtr = CFStringGetCharactersPtr(v15);
  uint64_t CStringPtrInternal = 0;
  uint64_t v16 = CharactersPtr;
  if (!CharactersPtr) {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal(str, 1536, 0, 1);
  }
  SInt32 v6 = 0;
  *(_OWORD *)buffer = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v17 = CStringPtrInternal;
  if (__CFStringScanInteger(buffer, 0, &v5, 0, (uint64_t *)&v6)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t __CFStringScanInteger(UniChar *buffer, uint64_t a2, int *a3, int a4, uint64_t *a5)
{
  int v9 = *a3;
  if ((*a3 & 0x80000000) == 0) {
    goto LABEL_4;
  }
LABEL_17:
  UniChar v13 = -1;
  while (v13 == 12288
       || (unsigned __int16)(v13 - 0x2000) < 0xCu
       || v13 < 0x21u
       || (unsigned __int16)(v13 - 127) <= 0x21u)
  {
    int v9 = *a3 + 1;
    *a3 = v9;
    if (v9 < 0) {
      goto LABEL_17;
    }
LABEL_4:
    uint64_t v10 = v9;
    uint64_t v11 = *((void *)buffer + 20);
    if (v11 <= v10) {
      goto LABEL_17;
    }
    uint64_t v12 = *((void *)buffer + 17);
    if (v12)
    {
      UniChar v13 = *(_WORD *)(v12 + 2 * (*((void *)buffer + 19) + v10));
    }
    else
    {
      uint64_t v14 = *((void *)buffer + 18);
      if (v14)
      {
        UniChar v13 = *(char *)(v14 + *((void *)buffer + 19) + v10);
      }
      else
      {
        if (*((void *)buffer + 22) <= v10 || (uint64_t v15 = *((void *)buffer + 21), v15 > v10))
        {
          uint64_t v16 = v10 - 4;
          if (v10 < 4) {
            uint64_t v16 = 0;
          }
          if (v16 + 64 < v11) {
            uint64_t v11 = v16 + 64;
          }
          *((void *)buffer + 21) = v16;
          *((void *)buffer + 22) = v11;
          v66.unint64_t location = *((void *)buffer + 19) + v16;
          v66.CFIndex length = v11 - v16;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v66, buffer);
          uint64_t v15 = *((void *)buffer + 21);
        }
        UniChar v13 = buffer[v10 - v15];
      }
    }
  }
  if (v13 == 45 || v13 == 43)
  {
    do
    {
      uint64_t v23 = *a3;
      uint64_t v24 = v23 + 1;
      *a3 = v23 + 1;
      if ((int)v23 < -1 || (uint64_t v22 = *((void *)buffer + 20), v22 <= v24))
      {
        UniChar v19 = -1;
      }
      else
      {
        uint64_t v25 = *((void *)buffer + 17);
        if (v25)
        {
          UniChar v19 = *(_WORD *)(v25 + 2 * (*((void *)buffer + 19) + v24));
        }
        else
        {
          uint64_t v18 = *((void *)buffer + 18);
          if (v18)
          {
            UniChar v19 = *(char *)(v18 + *((void *)buffer + 19) + v24);
          }
          else
          {
            if (*((void *)buffer + 22) <= v24 || (uint64_t v20 = *((void *)buffer + 21), v20 > v24))
            {
              uint64_t v21 = v24 - 4;
              if (v24 < 4) {
                uint64_t v21 = 0;
              }
              if (v21 + 64 < v22) {
                uint64_t v22 = v21 + 64;
              }
              *((void *)buffer + 21) = v21;
              *((void *)buffer + 22) = v22;
              v67.unint64_t location = *((void *)buffer + 19) + v21;
              v67.CFIndex length = v22 - v21;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v67, buffer);
              uint64_t v20 = *((void *)buffer + 21);
            }
            UniChar v19 = buffer[v24 - v20];
          }
        }
      }
    }
    while (v19 == 12288
         || (unsigned __int16)(v19 - 0x2000) < 0xCu
         || v19 < 0x21u
         || (unsigned __int16)(v19 - 127) < 0x22u);
    BOOL v17 = v13 == 45;
    UniChar v13 = v19;
  }
  else
  {
    BOOL v17 = 0;
  }
  if ((unsigned __int16)(v13 - 58) < 0xFFF6u) {
    return 0;
  }
  int v65 = a4;
  int v27 = 0;
  int v28 = 0;
  uint64_t v29 = 0;
  while (1)
  {
    if (v27)
    {
      if (v29 > 0xCCCCCCCCCCCCCCBLL && (v29 != 0xCCCCCCCCCCCCCCCLL || v13 - v17 - 48 >= 7))
      {
        if (v17) {
          uint64_t v29 = 0x8000000000000000;
        }
        else {
          uint64_t v29 = 0x7FFFFFFFFFFFFFFFLL;
        }
        while (1)
        {
          uint64_t v30 = *a3;
          uint64_t v31 = v30 + 1;
          *a3 = v30 + 1;
          if ((int)v30 < -1) {
            break;
          }
          uint64_t v32 = *((void *)buffer + 20);
          if (v32 <= v31) {
            break;
          }
          uint64_t v33 = *((void *)buffer + 17);
          if (v33)
          {
            UniChar v13 = *(_WORD *)(v33 + 2 * (*((void *)buffer + 19) + v31));
          }
          else
          {
            uint64_t v34 = *((void *)buffer + 18);
            if (v34)
            {
              UniChar v13 = *(char *)(v34 + *((void *)buffer + 19) + v31);
            }
            else
            {
              if (*((void *)buffer + 22) <= v31 || (uint64_t v35 = *((void *)buffer + 21), v35 > v31))
              {
                uint64_t v36 = v31 - 4;
                if (v31 < 4) {
                  uint64_t v36 = 0;
                }
                if (v36 + 64 < v32) {
                  uint64_t v32 = v36 + 64;
                }
                *((void *)buffer + 21) = v36;
                *((void *)buffer + 22) = v32;
                v68.unint64_t location = *((void *)buffer + 19) + v36;
                v68.CFIndex length = v32 - v36;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v68, buffer);
                uint64_t v35 = *((void *)buffer + 21);
              }
              UniChar v13 = buffer[v31 - v35];
            }
          }
          if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
          {
            int v37 = 0;
            BOOL v17 = 0;
            goto LABEL_122;
          }
        }
        BOOL v17 = 0;
LABEL_135:
        int v37 = 0;
LABEL_136:
        if (!a5) {
          return 1;
        }
        goto LABEL_137;
      }
      uint64_t v29 = 10 * v29 + v13 - 48;
      uint64_t v38 = *a3;
      uint64_t v39 = v38 + 1;
      *a3 = v38 + 1;
      if ((int)v38 < -1) {
        goto LABEL_135;
      }
      uint64_t v40 = *((void *)buffer + 20);
      if (v40 <= v39) {
        goto LABEL_135;
      }
      uint64_t v41 = *((void *)buffer + 17);
      if (v41)
      {
        int v37 = 0;
        UniChar v13 = *(_WORD *)(v41 + 2 * (*((void *)buffer + 19) + v39));
      }
      else
      {
        uint64_t v50 = *((void *)buffer + 18);
        if (v50)
        {
          int v37 = 0;
          UniChar v13 = *(char *)(v50 + *((void *)buffer + 19) + v39);
        }
        else
        {
          if (*((void *)buffer + 22) <= v39 || (uint64_t v59 = *((void *)buffer + 21), v59 > v39))
          {
            uint64_t v60 = v39 - 4;
            if (v39 < 4) {
              uint64_t v60 = 0;
            }
            if (v60 + 64 < v40) {
              uint64_t v40 = v60 + 64;
            }
            *((void *)buffer + 21) = v60;
            *((void *)buffer + 22) = v40;
            v70.unint64_t location = *((void *)buffer + 19) + v60;
            v70.CFIndex length = v40 - v60;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v70, buffer);
            uint64_t v59 = *((void *)buffer + 21);
          }
          int v37 = 0;
          UniChar v13 = buffer[v39 - v59];
        }
      }
      goto LABEL_122;
    }
    if (v28 > 214748363) {
      break;
    }
    unsigned __int16 v42 = v13 - 48;
    int v43 = v13 - 48;
LABEL_84:
    if (v42 >= 0xAu) {
      int v45 = -1;
    }
    else {
      int v45 = v43;
    }
    int v28 = v45 + 10 * v28;
    uint64_t v46 = *a3;
    uint64_t v47 = v46 + 1;
    *a3 = v46 + 1;
    if ((int)v46 < -1) {
      goto LABEL_149;
    }
    uint64_t v48 = *((void *)buffer + 20);
    if (v48 <= v47) {
      goto LABEL_149;
    }
    uint64_t v49 = *((void *)buffer + 17);
    if (v49)
    {
      int v27 = 0;
      UniChar v13 = *(_WORD *)(v49 + 2 * (*((void *)buffer + 19) + v47));
    }
    else
    {
      uint64_t v51 = *((void *)buffer + 18);
      if (v51)
      {
        int v27 = 0;
        UniChar v13 = *(char *)(v51 + *((void *)buffer + 19) + v47);
      }
      else
      {
        if (*((void *)buffer + 22) <= v47 || (uint64_t v61 = *((void *)buffer + 21), v61 > v47))
        {
          uint64_t v62 = v47 - 4;
          if (v47 < 4) {
            uint64_t v62 = 0;
          }
          if (v62 + 64 < v48) {
            uint64_t v48 = v62 + 64;
          }
          *((void *)buffer + 21) = v62;
          *((void *)buffer + 22) = v48;
          v71.unint64_t location = *((void *)buffer + 19) + v62;
          v71.CFIndex length = v48 - v62;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v71, buffer);
          uint64_t v61 = *((void *)buffer + 21);
        }
        int v27 = 0;
        UniChar v13 = buffer[v47 - v61];
      }
    }
    int v37 = 1;
LABEL_132:
    if ((unsigned __int16)(v13 - 58) <= 0xFFF5u) {
      goto LABEL_136;
    }
  }
  if (v28 == 214748364)
  {
    unsigned __int16 v42 = v13 - 48;
    int v43 = v13 - 48;
    int v44 = (unsigned __int16)(v13 - 48) >= 0xAu ? -1 : v13 - 48;
    if (v44 - v17 < 7) {
      goto LABEL_84;
    }
  }
  if (v65)
  {
    int v37 = 0;
    uint64_t v29 = v28;
LABEL_122:
    int v27 = 1;
    goto LABEL_132;
  }
  if (v17) {
    int v28 = 0x80000000;
  }
  else {
    int v28 = 0x7FFFFFFF;
  }
  while (1)
  {
    uint64_t v52 = *a3;
    uint64_t v53 = v52 + 1;
    *a3 = v52 + 1;
    if ((int)v52 < -1) {
      break;
    }
    uint64_t v54 = *((void *)buffer + 20);
    if (v54 <= v53) {
      break;
    }
    uint64_t v55 = *((void *)buffer + 17);
    if (v55)
    {
      UniChar v13 = *(_WORD *)(v55 + 2 * (*((void *)buffer + 19) + v53));
    }
    else
    {
      uint64_t v56 = *((void *)buffer + 18);
      if (v56)
      {
        UniChar v13 = *(char *)(v56 + *((void *)buffer + 19) + v53);
      }
      else
      {
        if (*((void *)buffer + 22) <= v53 || (uint64_t v57 = *((void *)buffer + 21), v57 > v53))
        {
          uint64_t v58 = v53 - 4;
          if (v53 < 4) {
            uint64_t v58 = 0;
          }
          if (v58 + 64 < v54) {
            uint64_t v54 = v58 + 64;
          }
          *((void *)buffer + 21) = v58;
          *((void *)buffer + 22) = v54;
          v69.unint64_t location = *((void *)buffer + 19) + v58;
          v69.CFIndex length = v54 - v58;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v69, buffer);
          uint64_t v57 = *((void *)buffer + 21);
        }
        UniChar v13 = buffer[v53 - v57];
      }
    }
    int v37 = 1;
    if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
    {
      int v27 = 0;
      BOOL v17 = 0;
      goto LABEL_132;
    }
  }
  BOOL v17 = 0;
LABEL_149:
  int v37 = 1;
  if (!a5) {
    return 1;
  }
LABEL_137:
  if (v65)
  {
    if (v37) {
      uint64_t v63 = v28;
    }
    else {
      uint64_t v63 = v29;
    }
    if (v17) {
      uint64_t v63 = -v63;
    }
    *a5 = v63;
  }
  else
  {
    if (v17) {
      int v64 = -v28;
    }
    else {
      int v64 = v28;
    }
    *(_DWORD *)a5 = v64;
  }
  return 1;
}

void CFURLGetPortNumber_cold_1()
{
}

CFRange CFURLGetByteRangeForComponent(CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFURLRef v5 = url;
  v47[1] = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url)) {
    CFURLRef v5 = (CFURLRef)[(__CFURL *)v5 _cfurl];
  }
  CFIndex v46 = 0;
  v47[0] = 0;
  uint64_t v6 = *((unsigned int *)v5 + 4);
  if ((v6 & 0x4000) == 0)
  {
    if (component == kCFURLComponentResourceSpecifier)
    {
      if (v6) {
        CFIndex v17 = *((void *)v5 + 8);
      }
      else {
        CFIndex v17 = 0;
      }
      CFStringRef v19 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      CFIndex Length = CFStringGetLength(v19);
      if (v17 + 1 == Length) {
        CFIndex v11 = Length;
      }
      else {
        CFIndex v11 = v17;
      }
      if (v17 + 1 == Length) {
        CFIndex v18 = 0;
      }
      else {
        CFIndex v18 = Length - v17;
      }
      if (v17 + 1 == Length) {
        CFIndex v7 = 0;
      }
      else {
        CFIndex v7 = Length - v17 - 1;
      }
      if (v17 + 1 == Length) {
        CFIndex v8 = -1;
      }
      else {
        CFIndex v8 = v17 + 1;
      }
      goto LABEL_60;
    }
    if (component == kCFURLComponentScheme)
    {
      if (v6)
      {
        CFIndex v8 = *((void *)v5 + 7);
        CFIndex v7 = *((void *)v5 + 8);
      }
      else
      {
        CFIndex v7 = 0;
        CFIndex v8 = -1;
      }
      CFIndex v11 = 0;
      CFIndex v18 = v7 + 1;
      goto LABEL_60;
    }
    CFIndex v18 = 0;
    CFIndex v7 = 0;
    CFIndex v11 = -1;
    goto LABEL_29;
  }
  uint64_t v9 = component - 1;
  if ((unint64_t)(component - 1) > 0xB || ((0xDFFu >> v9) & 1) == 0) {
    goto LABEL_83;
  }
  unint64_t v10 = qword_182E0FDD8[v9];
  if ((v10 & v6) == 0)
  {
    if (component == kCFURLComponentScheme || component == kCFURLComponentParameterString) {
      goto LABEL_56;
    }
    uint64_t v21 = 0;
    uint64_t v22 = 1;
    do
    {
      if ((v22 & v6) != 0) {
        uint64_t v21 = v22;
      }
      if (2 * v22 > 256) {
        break;
      }
      uint64_t v23 = v10 & (2 * v22);
      v22 *= 2;
    }
    while (!v23);
    if (!v21)
    {
LABEL_56:
      if (!rangeIncludingSeparators)
      {
        CFIndex v7 = 0;
        goto LABEL_76;
      }
      CFIndex v11 = 0;
      CFIndex v18 = 0;
      CFIndex v7 = 0;
      CFIndex v25 = 0;
      CFIndex v8 = -1;
LABEL_63:
      CFStringRef v26 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v49.CFIndex location = 0;
      v49.CFIndex length = v11;
      CFStringGetBytes(v26, v49, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &rangeIncludingSeparators->location);
      if (v8 == -1)
      {
        CFIndex v46 = -1;
        v47[0] = v25;
        CFStringRef v32 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
        v52.CFIndex location = v11;
        v52.CFIndex length = v18;
        CFStringGetBytes(v32, v52, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &rangeIncludingSeparators->length);
      }
      else
      {
        CFIndex v27 = v25 + v8;
        CFIndex v28 = v18 + v11;
        if (v8 == v11)
        {
          CFIndex location = rangeIncludingSeparators->location;
        }
        else
        {
          CFIndex v45 = 0;
          CFStringRef v33 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
          v53.CFIndex location = v11;
          v53.CFIndex length = v8 - v11;
          CFStringGetBytes(v33, v53, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &v45);
          CFIndex location = v45 + v11;
        }
        CFIndex v46 = location;
        CFStringRef v34 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
        v54.CFIndex location = v8;
        v54.CFIndex length = v7;
        CFStringGetBytes(v34, v54, *((_DWORD *)v5 + 5), 0, 0, 0, 0, v47);
        if (v28 == v27)
        {
          CFIndex v35 = v47[0] + v46;
        }
        else
        {
          CFIndex v45 = 0;
          CFStringRef v36 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
          v55.CFIndex location = v27;
          v55.CFIndex length = v28 - v27;
          CFStringGetBytes(v36, v55, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &v45);
          CFIndex v35 = v47[0] + v46 + v45;
        }
        rangeIncludingSeparators->CFIndex length = v35 - rangeIncludingSeparators->location;
      }
LABEL_77:
      CFIndex v37 = v46;
      CFIndex v38 = v47[0];
      goto LABEL_98;
    }
    if (v21 == 1)
    {
      if (v6) {
        uint64_t v24 = *((void *)v5 + 8);
      }
      else {
        uint64_t v24 = 0;
      }
      if ((v6 & 0x20) != 0)
      {
        unsigned int v42 = 0;
        unsigned int v43 = 32;
        do
        {
          char v44 = v43;
          v43 >>= 1;
          v42 += v6 & 1;
          LODWORD(v6) = v6 >> 1;
        }
        while ((v44 & 2) == 0);
        uint64_t v41 = *((void *)v5 + 2 * v42 + 7);
      }
      else
      {
        uint64_t v41 = -1;
      }
      CFIndex v18 = 0;
      CFIndex v7 = 0;
      if (v24 + 1 == v41) {
        CFIndex v11 = v24 + 1;
      }
      else {
        CFIndex v11 = v24 + 3;
      }
    }
    else
    {
      if ((v6 & v21) == 0) {
        goto LABEL_83;
      }
      if (v21)
      {
        uint64_t v39 = 0;
      }
      else
      {
        LODWORD(v39) = 0;
        do
        {
          char v40 = v21;
          LODWORD(v21) = v21 >> 1;
          uint64_t v39 = (v6 & 1) + v39;
          LODWORD(v6) = v6 >> 1;
        }
        while ((v40 & 2) == 0);
      }
      CFIndex v18 = 0;
      CFIndex v7 = 0;
      CFIndex v11 = *((void *)v5 + 2 * v39 + 8) + *((void *)v5 + 2 * v39 + 7);
    }
LABEL_29:
    CFIndex v8 = -1;
    goto LABEL_60;
  }
  CFIndex v11 = 0;
  BOOL v12 = 0;
  CFIndex v7 = 0;
  UniChar v13 = (CFIndex *)((char *)v5 + 56);
  CFIndex v8 = -1;
  unint64_t v14 = 1;
  while (v12)
  {
    if ((v14 & v6) != 0) {
      goto LABEL_17;
    }
    BOOL v12 = 1;
LABEL_23:
    BOOL v15 = v14 >= 0x81;
    v14 *= 2;
    if (v15) {
      goto LABEL_25;
    }
  }
  BOOL v12 = (v14 & v10) != 0;
  if ((v14 & v6) == 0) {
    goto LABEL_23;
  }
  if ((v14 & v10) == 0)
  {
    BOOL v12 = 0;
    CFIndex v11 = v13[1] + *v13;
LABEL_22:
    v13 += 2;
    goto LABEL_23;
  }
LABEL_17:
  if (v14 <= v10)
  {
    if (v8 == -1)
    {
      CFIndex v7 = v13[1];
      BOOL v12 = 1;
      CFIndex v8 = *v13;
    }
    else
    {
      CFIndex v7 = *v13 - v8 + v13[1];
      BOOL v12 = 1;
    }
    goto LABEL_22;
  }
  CFIndex v16 = *v13;
  if (*v13 == -1) {
LABEL_25:
  }
    CFIndex v16 = v7 + v8;
  CFIndex v18 = v16 - v11;
LABEL_60:
  if (v11 != -1)
  {
    if (rangeIncludingSeparators)
    {
      CFIndex v25 = v7;
      goto LABEL_63;
    }
    if (v8 != -1)
    {
      CFStringRef v30 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v50.CFIndex location = 0;
      v50.CFIndex length = v8;
      CFStringGetBytes(v30, v50, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &v46);
      CFStringRef v31 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v51.CFIndex location = v8;
      v51.CFIndex length = v7;
      CFStringGetBytes(v31, v51, *((_DWORD *)v5 + 5), 0, 0, 0, 0, v47);
      goto LABEL_77;
    }
LABEL_76:
    CFIndex v46 = -1;
    v47[0] = v7;
    goto LABEL_77;
  }
LABEL_83:
  CFIndex v38 = 0;
  if (rangeIncludingSeparators) {
    *rangeIncludingSeparators = (CFRange)xmmword_182D9EC80;
  }
  CFIndex v37 = -1;
LABEL_98:
  result.CFIndex length = v38;
  result.CFIndex location = v37;
  return result;
}

uint64_t _CFAppVersionCheckLessThan(CFTypeRef cf2, int a2, double a3)
{
  if (!cf2) {
    _CFAppVersionCheckLessThan_cold_1();
  }
  if (a2 != -1)
  {
    unint64_t v5 = a2;
    unsigned int active_platform = dyld_get_active_platform();
    if (_CFPlatformExecutableLinkedOnOrAfter(v5, active_platform)) {
      return 0;
    }
  }
  if (_bundleInfo_onceToken != -1) {
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  }
  if (!_bundleInfo_info_0) {
    _CFAppVersionCheckLessThan_cold_2();
  }
  uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if (result) {
    return *(double *)&_bundleInfo_info_2 < a3 || a3 < 0.0;
  }
  return result;
}

uint64_t _CFPlatformExecutableLinkedOnOrAfter(unint64_t a1, unsigned int a2)
{
  if (a2 != 6) {
    _CFBuildVersionForCFSystemVersion(a1, a2);
  }
  return dyld_program_sdk_at_least();
}

uint64_t _CFPredicatePolicyData_setFlags(uint64_t result)
{
  _cfprediacateelements_flags = result;
  return result;
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  CFArrayRef v0 = (void *)+[NSLocale _preferredLanguagesForCurrentUser:0];

  return (CFArrayRef)v0;
}

uint64_t _CFRuntimeRegisterClass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)a1 & 8) != 0 && !*(void *)(a1 + 80))
  {
    CFLog(4, @"*** _CFRuntimeRegisterClass() given inconsistent class '%s'.  Program will crash soon.", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 8));
    return 0;
  }
  os_unfair_lock_lock_with_options();
  if (dword_1EB1DE0D8[0] >= 1024)
  {
    CFLog(4, @"*** CoreFoundation class table full; registration failing for class '%s'.  Program will crash soon.",
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      *(void *)(a1 + 8));
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
    return 0;
  }
  uint64_t v15 = dword_1EB1DE0D8[0];
  uint64_t v16 = (uint64_t)dword_1EB1DE0D8[0] >> 6;
  CFIndex v17 = (void *)__CFRuntimeClassTables[dword_1EB1DE0D8[0] >> 6];
  if (!v17)
  {
    CFIndex v17 = malloc_type_calloc(0x40uLL, 8uLL, 0x2004093837F09uLL);
    CFIndex v18 = (char *)malloc_type_malloc(0x200uLL, 0x100004000313F17uLL);
    uint64_t v19 = 0;
    unint64_t v20 = (v15 & 0xFFFFFFFFFFFFFFC0) + 72;
    do
    {
      atomic_store(0, (unint64_t *)&v18[v19]);
      ++v20;
      v19 += 8;
    }
    while (v19 != 512);
    __dmb(0xBu);
    uint64_t v21 = &__CFRuntimeClassTables[v16];
    *uint64_t v21 = v17;
    v21[16] = v18;
    if (!v17) {
      _CFRuntimeRegisterClass_cold_1();
    }
  }
  uint64_t v22 = v15 + 72;
  v17[v15 & 0x3F] = a1;
  *(void *)(__CFRuntimeClassTables[v16 + 16] + 8 * (v15 & 0x3F)) = qword_1EB1DDD98;
  atomic_fetch_add_explicit(dword_1EB1DE0D8, 1u, memory_order_relaxed);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
  return v22;
}

unint64_t *_CFURLCreateCopyAppendingPathComponent(unint64_t a1, const __CFString *a2, int a3)
{
  return __CFURLCreateCopyAppendingPathComponent(0, a1, a2, a3, @";?/");
}

uint64_t _NSIsNSValue(uint64_t a1)
{
  if (!_NSValueClass)
  {
    Class Class = objc_getClass("NSValue");
    _NSValueClass Class = (uint64_t)Class;
    if (!Class) {
      return Class & 1;
    }
  }
  if (!a1)
  {
    LOBYTE(Class) = 0;
    return Class & 1;
  }
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if ((char *)MethodImplementation == (char *)off_1ECE0A630)
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
    return Class & 1;
  }

  return MethodImplementation(a1, sel_isNSValue__);
}

void _CFGetPathExtensionRangesFromPathComponentUniChars(const __CFString *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v107 = *(void *)off_1ECE0A5B0;
  theString[0] = 0;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v95 = 0u;
  CFIndex v104 = a2;
  uint64_t v105 = 0;
  theString[1] = a1;
  CFIndex length = 0;
  if (!((unint64_t)a3 | (unint64_t)a4)) {
    return;
  }
  if (a2 < 2) {
    goto LABEL_58;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  unint64_t v10 = a2 - 1;
  uint64_t v11 = 1 - a2;
  uint64_t v12 = a2 + 63;
  uint64_t v13 = &buffer[a2 - 1];
  uint64_t v14 = 2 - 2 * a2;
  while (1)
  {
    uint64_t v15 = a2 + v8;
    if (v10 >= 0x3F) {
      uint64_t v16 = 63;
    }
    else {
      uint64_t v16 = v10;
    }
    if (theString[1])
    {
      UniChar v17 = *((_WORD *)theString[1] + v15 + *((void *)&v103 + 1) - 1);
    }
    else if ((void)v103)
    {
      UniChar v17 = *(char *)(v103 + *((void *)&v103 + 1) + a2 + v8 - 1);
    }
    else
    {
      CFIndex v18 = v15 - 1;
      BOOL v19 = length > v18 && v9 <= v18;
      if (!v19)
      {
        uint64_t v20 = ~v16;
        uint64_t v21 = v16 ^ 0x3F;
        CFIndex v22 = v12 - v16;
        uint64_t v23 = v16 + v7;
        uint64_t v24 = a2 + v8 + v20;
        uint64_t v25 = a2 + v8 + v21;
        if (v25 >= v104) {
          uint64_t v25 = v104;
        }
        uint64_t v105 = v24;
        CFIndex length = v25;
        v26.CFIndex location = v24 + *((void *)&v103 + 1);
        if (v104 >= v22) {
          CFIndex v27 = v22;
        }
        else {
          CFIndex v27 = v104;
        }
        v26.CFIndex length = v11 + v23 + v27;
        uint64_t v28 = v11;
        uint64_t v29 = v13;
        CFStringGetCharacters(theString[0], v26, buffer);
        uint64_t v13 = v29;
        uint64_t v11 = v28;
        uint64_t v9 = v105;
      }
      UniChar v17 = v13[v8 - v9];
    }
    uint64_t v30 = 0;
    int v31 = v17;
    uint64_t v32 = -1;
    if (v31 > 8233)
    {
      unsigned int v33 = v31 - 8234;
      BOOL v19 = v33 > 0x3F;
      unint64_t v34 = (1 << v33) & 0xF00000000000001FLL;
      BOOL v35 = v19 || v34 == 0;
      uint64_t v36 = 0;
      uint64_t v37 = -1;
      if (!v35) {
        goto LABEL_61;
      }
      goto LABEL_35;
    }
    if (v31 > 1563)
    {
      if ((v31 - 8206) < 2)
      {
LABEL_37:
        uint64_t v36 = 0;
        goto LABEL_60;
      }
      uint64_t v36 = 0;
      uint64_t v37 = -1;
      if (v31 == 1564) {
        goto LABEL_61;
      }
      goto LABEL_35;
    }
    if (v31 == 32) {
      goto LABEL_37;
    }
    if (v31 == 46) {
      break;
    }
    uint64_t v36 = 0;
    uint64_t v37 = -1;
    if (v31 == 47) {
      goto LABEL_61;
    }
LABEL_35:
    --v10;
    v14 += 2;
    --v12;
    --v8;
    ++v7;
    if (a2 + v8 <= 1)
    {
      uint64_t v30 = 0;
      uint64_t v36 = 0;
LABEL_89:
      uint64_t v32 = -1;
      goto LABEL_61;
    }
  }
  if (!v8)
  {
    uint64_t v30 = 0;
    uint64_t v36 = 0;
    goto LABEL_60;
  }
  uint64_t v38 = a2 + v8;
  unint64_t v39 = a2 + v8 - 1;
  if (v39 > 2) {
    goto LABEL_66;
  }
  if (theString[1])
  {
    char v40 = (UniChar *)theString[1] + *((void *)&v103 + 1);
  }
  else
  {
    if ((uint64_t)v39 > length || v9 >= 1)
    {
      if (v104 >= 64) {
        v41.CFIndex length = 64;
      }
      else {
        v41.CFIndex length = v104;
      }
      uint64_t v105 = 0;
      CFIndex length = v41.length;
      v41.CFIndex location = *((void *)&v103 + 1);
      if ((void)v103)
      {
        if (v41.length)
        {
          unsigned int v42 = (char *)(v103 + *((void *)&v103 + 1));
          unsigned int v43 = buffer;
          do
          {
            UniChar v44 = *v42++;
            *v43++ = v44;
            --v41.length;
          }
          while (v41.length);
        }
      }
      else
      {
        uint64_t v45 = v11;
        CFStringGetCharacters(theString[0], v41, buffer);
        uint64_t v11 = v45;
      }
    }
    uint64_t v9 = v105;
    char v40 = &buffer[-v105];
  }
  if (*v40 != 46) {
    goto LABEL_66;
  }
  uint64_t v30 = v38 - 2;
  if (v38 == 2) {
    goto LABEL_59;
  }
  if (v40[1] != 46)
  {
LABEL_66:
    uint64_t v37 = a2 + v8;
    uint64_t v36 = -v8;
    if (!a4)
    {
LABEL_88:
      uint64_t v30 = 0;
      goto LABEL_89;
    }
    uint64_t v46 = v38 + 63;
    uint64_t v47 = v11 - v8;
    while (1)
    {
      if (v39 >= 0x40) {
        uint64_t v48 = 64;
      }
      else {
        uint64_t v48 = v39;
      }
      CFIndex v49 = v38 - 1;
      if (v38 - 1 < 2) {
        goto LABEL_88;
      }
      if (theString[1])
      {
        CFRange v50 = (UniChar *)theString[1] + v38 + *((void *)&v103 + 1);
      }
      else
      {
        if ((void)v103)
        {
          __int16 v51 = *(char *)(v103 + *((void *)&v103 + 1) + v38 - 2);
          goto LABEL_77;
        }
        if (length < v49 || v9 >= v49)
        {
          uint64_t v52 = -v48;
          uint64_t v53 = v48 + v47;
          CFIndex v54 = v46 - v48;
          uint64_t v55 = v38 + v52;
          CFIndex v56 = v55 + 63;
          if (v55 + 63 >= v104) {
            CFIndex v56 = v104;
          }
          uint64_t v105 = v55 - 1;
          CFIndex length = v56;
          v57.CFIndex location = v55 + *((void *)&v103 + 1) - 1;
          if (v104 >= v54) {
            CFIndex v58 = v54;
          }
          else {
            CFIndex v58 = v104;
          }
          v57.CFIndex length = v58 + v53;
          CFStringGetCharacters(theString[0], v57, buffer);
          uint64_t v9 = v105;
        }
        CFRange v50 = &buffer[v38 - v9];
      }
      __int16 v51 = *(v50 - 2);
LABEL_77:
      v14 += 2;
      ++v47;
      --v46;
      --v39;
      --v38;
      if (v51 != 32)
      {
        uint64_t v59 = 0;
        CFIndex v60 = 1 - v49;
        uint64_t v61 = (char *)buffer - v14;
        CFIndex v62 = v49 + 63;
        int64_t v63 = v49 - 1;
        while (1)
        {
          uint64_t v64 = (unint64_t)v63 >= 0x3F ? 63 : v63;
          if (theString[1])
          {
            __int16 v65 = *((_WORD *)&theString[1]->isa + v63 + *((void *)&v103 + 1));
          }
          else if ((void)v103)
          {
            __int16 v65 = *(char *)(v103 + *((void *)&v103 + 1) + v63);
          }
          else
          {
            if (length <= v63 || v9 > v63)
            {
              uint64_t v67 = -v64;
              uint64_t v68 = v64 + v60;
              CFIndex v69 = v62 - v64;
              uint64_t v70 = v63 + v67;
              CFIndex v71 = v70 + 64;
              if (v70 + 64 >= v104) {
                CFIndex v71 = v104;
              }
              uint64_t v105 = v70;
              CFIndex length = v71;
              v72.CFIndex location = v70 + *((void *)&v103 + 1);
              if (v104 >= v69) {
                CFIndex v73 = v69;
              }
              else {
                CFIndex v73 = v104;
              }
              v72.CFIndex length = v73 + v68;
              CFStringGetCharacters(theString[0], v72, buffer);
              uint64_t v9 = v105;
            }
            __int16 v65 = *(_WORD *)&v61[-2 * v9];
          }
          if (v65 == 32 || v65 == 46) {
            break;
          }
          ++v59;
          --v62;
          v61 -= 2;
          ++v60;
          uint64_t v32 = -1;
          BOOL v19 = v63-- <= 1;
          if (v19)
          {
LABEL_135:
            uint64_t v30 = 0;
            goto LABEL_61;
          }
        }
        int64_t v93 = v63 + 1;
        int64_t v74 = -v63;
        int64_t v75 = v63 + 64;
        while (1)
        {
          uint64_t v76 = (unint64_t)v63 >= 0x3F ? 63 : v63;
          if (theString[1])
          {
            __int16 v77 = *((_WORD *)&theString[1]->isa + v63 + *((void *)&v103 + 1));
          }
          else if ((void)v103)
          {
            __int16 v77 = *(char *)(v103 + *((void *)&v103 + 1) + v63);
          }
          else
          {
            if (length <= v63 || v9 > v63)
            {
              uint64_t v79 = -v76;
              uint64_t v80 = v76 + v74;
              CFIndex v81 = v75 - v76;
              uint64_t v82 = v63 + v79;
              CFIndex v83 = v82 + 64;
              if (v82 + 64 >= v104) {
                CFIndex v83 = v104;
              }
              uint64_t v105 = v82;
              CFIndex length = v83;
              v84.CFIndex location = v82 + *((void *)&v103 + 1);
              if (v104 >= v81) {
                CFIndex v85 = v81;
              }
              else {
                CFIndex v85 = v104;
              }
              v84.CFIndex length = v85 + v80;
              CFStringGetCharacters(theString[0], v84, buffer);
              uint64_t v9 = v105;
            }
            __int16 v77 = *(_WORD *)&v61[-2 * v9];
          }
          if (v77 != 32) {
            break;
          }
          --v75;
          v61 -= 2;
          ++v74;
          uint64_t v32 = -1;
          BOOL v19 = v63-- <= 1;
          if (v19) {
            goto LABEL_135;
          }
        }
        if (theString[1])
        {
          __int16 v86 = *((_WORD *)&theString[1]->isa + *((void *)&v103 + 1) + v63);
          uint64_t v87 = v93;
        }
        else
        {
          uint64_t v87 = v93;
          if ((void)v103)
          {
            __int16 v86 = *(char *)(v103 + *((void *)&v103 + 1) + v63);
          }
          else
          {
            if (length <= v63 || v9 > v63)
            {
              uint64_t v88 = 63;
              if ((unint64_t)v63 < 0x3F) {
                uint64_t v88 = v63;
              }
              uint64_t v89 = v63 - v88 + 64;
              if (v89 >= v104) {
                uint64_t v89 = v104;
              }
              uint64_t v105 = v63 - v88;
              CFIndex length = v89;
              CFIndex v90 = v75 - v88;
              if (v104 < v75 - v88) {
                CFIndex v90 = v104;
              }
              v108.CFIndex length = v88 + v90 - v63;
              v108.CFIndex location = v63 - v88 + *((void *)&v103 + 1);
              CFStringGetCharacters(theString[0], v108, buffer);
              uint64_t v9 = v105;
            }
            __int16 v86 = *(_WORD *)&v61[-2 * v9];
          }
        }
        BOOL v91 = v86 == 46;
        BOOL v92 = v59 != 0;
        if (v91 && v92) {
          uint64_t v30 = v59;
        }
        else {
          uint64_t v30 = 0;
        }
        if (v91 && v92) {
          uint64_t v32 = v87;
        }
        else {
          uint64_t v32 = -1;
        }
        goto LABEL_61;
      }
    }
  }
LABEL_58:
  uint64_t v30 = 0;
LABEL_59:
  uint64_t v36 = 0;
  uint64_t v32 = -1;
LABEL_60:
  uint64_t v37 = -1;
LABEL_61:
  if (a3)
  {
    *a3 = v37;
    a3[1] = v36;
  }
  if (a4)
  {
    *a4 = v32;
    a4[1] = v30;
  }
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
}

uint64_t _CFExtensionUniCharsIsValidToAppend(const __CFString *a1, uint64_t a2)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  theString[0] = 0;
  long long v36 = 0u;
  memset(v34, 0, sizeof(v34));
  uint64_t v37 = a2;
  uint64_t v38 = 0;
  theString[1] = a1;
  uint64_t v39 = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a2 - 1;
  if (a2 < 1) {
    return 1;
  }
  uint64_t v3 = 0;
  uint64_t v4 = 1 - a2;
  uint64_t v5 = a2 + 63;
  uint64_t v6 = a2 - 1;
  while (1)
  {
    uint64_t v7 = (unint64_t)v6 >= 0x3F ? 63 : v6;
    if (theString[1])
    {
      unsigned __int16 v8 = *((_WORD *)&theString[1]->isa + v6 + *((void *)&v36 + 1));
    }
    else if ((void)v36)
    {
      unsigned __int16 v8 = *(char *)(v36 + *((void *)&v36 + 1) + v6);
    }
    else
    {
      BOOL v9 = v39 > v6 && v3 <= v6;
      if (!v9)
      {
        uint64_t v10 = -v7;
        uint64_t v11 = v7 + v4;
        uint64_t v12 = v5 - v7;
        uint64_t v13 = v6 + v10;
        uint64_t v14 = v13 + 64;
        if (v13 + 64 >= v37) {
          uint64_t v14 = v37;
        }
        uint64_t v38 = v13;
        uint64_t v39 = v14;
        v15.CFIndex location = v13 + *((void *)&v36 + 1);
        if (v37 >= v12) {
          uint64_t v16 = v12;
        }
        else {
          uint64_t v16 = v37;
        }
        v15.CFIndex length = v16 + v11;
        CFStringGetCharacters(theString[0], v15, (UniChar *)v34);
        uint64_t v3 = v38;
      }
      unsigned __int16 v8 = *((_WORD *)v34 + v6 - v3);
    }
    uint64_t result = 0;
    if (v8 <= 0x2029u) {
      break;
    }
    unsigned int v18 = v8 - 8234;
    BOOL v9 = v18 > 0x3F;
    unint64_t v19 = (1 << v18) & 0xF00000000000001FLL;
    if (!v9 && v19 != 0) {
      return result;
    }
LABEL_35:
    ++v4;
    --v5;
    BOOL v9 = v6-- <= 0;
    if (v9) {
      return 1;
    }
  }
  if (v8 > 0x61Bu)
  {
    if (v8 - 8206 < 2 || v8 == 1564) {
      return result;
    }
    goto LABEL_35;
  }
  if (v8 == 32) {
    return result;
  }
  if (v8 != 46)
  {
    if (v8 == 47) {
      return result;
    }
    goto LABEL_35;
  }
  if (v6 >= v2) {
    return 0;
  }
  uint64_t v21 = v6 + 64;
  uint64_t v22 = -v6;
  for (uint64_t i = v6 + 1; ; --i)
  {
    uint64_t v24 = (unint64_t)v6 >= 0x40 ? 64 : v6;
    uint64_t v25 = i - 1;
    if (i - 1 < 1) {
      break;
    }
    if (theString[1])
    {
      __int16 v26 = *((_WORD *)theString[1] + i + *((void *)&v36 + 1) - 2);
    }
    else if ((void)v36)
    {
      __int16 v26 = *(char *)(v36 + *((void *)&v36 + 1) + i - 2);
    }
    else
    {
      if (v39 < v25 || v3 >= v25)
      {
        uint64_t v27 = -v24;
        uint64_t v28 = v24 + v22;
        uint64_t v29 = v21 - v24;
        uint64_t v30 = i + v27;
        uint64_t v31 = v30 + 63;
        if (v30 + 63 >= v37) {
          uint64_t v31 = v37;
        }
        uint64_t v38 = v30 - 1;
        uint64_t v39 = v31;
        v32.CFIndex location = v30 + *((void *)&v36 + 1) - 1;
        if (v37 >= v29) {
          uint64_t v33 = v29;
        }
        else {
          uint64_t v33 = v37;
        }
        v32.CFIndex length = v33 + v28;
        CFStringGetCharacters(theString[0], v32, (UniChar *)v34);
        uint64_t v3 = v38;
      }
      __int16 v26 = *((_WORD *)&v34[-1] + i - v3 + 6);
    }
    uint64_t result = 0;
    ++v22;
    --v21;
    --v6;
    if (v26 == 47) {
      return result;
    }
  }
  return 1;
}

void sub_182C6F138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesSynchronizeWithContainer((__CFString *)applicationID, userName, hostName, 0);
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  int v4 = reverse;
  uint64_t v50 = *(void *)off_1ECE0A5B0;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  if (__CFStringTransformCacheID && __CFStringTransformCacheRev == (v4 != 0))
  {
    CFStringRef v8 = transform;
    if ((CFStringRef)__CFStringTransformCacheID == transform)
    {
LABEL_6:
      CFRelease(v8);
      __CFStringTransformCacheID = 0;
      uint64_t v9 = __CFStringTransformCacheTL;
      __CFStringTransformCacheTL = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
      goto LABEL_30;
    }
    if (CFEqual(transform, (CFTypeRef)__CFStringTransformCacheID))
    {
      CFStringRef v8 = (CFStringRef)__CFStringTransformCacheID;
      goto LABEL_6;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  LODWORD(v3CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
  if (CFStringGetLength(transform) >= 1 && CFStringGetCharacterAtIndex(transform, 0) == 41)
  {
    uint64_t v10 = 0;
    uint64_t v11 = &kCFStringTransformStripCombiningMarks;
    uint64_t v12 = &off_1ECDFD148;
    while (*(CFStringRef *)v11 != transform)
    {
      ++v10;
      uint64_t v13 = *v12;
      v12 += 2;
      uint64_t v11 = (const NSStringTransform *)v13;
      if (v10 == 16)
      {
        uint64_t v10 = 0;
        p_isa = (CFTypeRef *)&kCFStringTransformStripCombiningMarks;
        CFRange v15 = &off_1ECDFD148;
        while (!CFEqual(*p_isa, transform))
        {
          ++v10;
          uint64_t v16 = *v15;
          v15 += 2;
          p_isa = (CFTypeRef *)&v16->isa;
          if (v10 == 16) {
            goto LABEL_17;
          }
        }
        break;
      }
    }
    uint64_t v20 = (const char *)*(&__CFStringTransformNameMap + 2 * v10 + 1);
    int64_t v21 = strlen(v20);
    if (v21 >= 1)
    {
      uint64_t v22 = buffer;
      int64_t v23 = v21;
      do
      {
        UniChar v24 = *v20++;
        *v22++ = v24;
        --v23;
      }
      while (v23);
    }
    goto LABEL_25;
  }
LABEL_17:
  uint64_t Length = CFStringGetLength(transform);
  if (CFStringGetCharactersPtr(transform))
  {
LABEL_25:
    uint64_t v9 = utrans_openU();
    goto LABEL_26;
  }
  if (Length <= 1024)
  {
    v51.CFIndex location = 0;
    v51.CFIndex length = Length;
    CFStringGetCharacters(transform, v51, buffer);
    goto LABEL_25;
  }
  uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * Length, 0x1000040BDFB0063, 0);
  if (!Typed)
  {
LABEL_29:
    uint64_t v9 = 0;
    goto LABEL_30;
  }
  unint64_t v19 = Typed;
  v52.CFIndex location = 0;
  v52.CFIndex length = Length;
  CFStringGetCharacters(transform, v52, Typed);
  uint64_t v9 = utrans_openU();
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v19);
LABEL_26:
  if ((int)v30 >= 1 && v9)
  {
    utrans_close();
    goto LABEL_29;
  }
LABEL_30:
  if (!v9) {
    return 0;
  }
  uint64_t v30 = 0;
  CFIndex v31 = 0;
  if (!range)
  {
    CFIndex v31 = CFStringGetLength(string);
    range = (CFRange *)&v30;
  }
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  *(void *)buffer = string;
  CFIndex v33 = CFStringGetLength(string);
  CFMutableStringRef v42 = string;
  uint64_t v45 = 0;
  CFIndex v46 = v33;
  CharactersPtr = CFStringGetCharactersPtr(string);
  CStringPtr = 0;
  unsigned int v43 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(string, 0x600u);
  }
  UniChar v44 = CStringPtr;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  CFTypeRef cf = 0;
  int v29 = LODWORD(range->length) + LODWORD(range->location);
  utrans_trans();
  if (cf) {
    CFRelease(cf);
  }
  range->CFIndex length = v29 - range->location;
  Boolean v27 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  if (__CFStringTransformCacheID)
  {
    CFRelease((CFTypeRef)__CFStringTransformCacheID);
    utrans_close();
  }
  __CFStringTransformCacheID = (uint64_t)CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, transform);
  __CFStringTransformCacheTL = v9;
  __CFStringTransformCacheRev = v4 != 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  return v27;
}

CFDictionaryRef CFBundleCopyInfoDictionaryInDirectory(CFURLRef bundleURL)
{
  return _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, bundleURL, 0);
}

void sub_182C6FB04(_Unwind_Exception *exception_object)
{
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  __CFCheckCFInfoPACSignature((uint64_t)uuid);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)uuid);
  if (v2 != 34) {
    _CFAssertMismatchedTypeID(0x22uLL, v2);
  }
  uint64_t v3 = *((void *)uuid + 2);
  uint64_t v4 = *((void *)uuid + 3);
  result.byte8 = v4;
  result.byte9 = BYTE1(v4);
  result.byte10 = BYTE2(v4);
  result.byte11 = BYTE3(v4);
  result.byte12 = BYTE4(v4);
  result.byte13 = BYTE5(v4);
  result.byte14 = BYTE6(v4);
  result.byte15 = HIBYTE(v4);
  result.byte0 = v3;
  result.byte1 = BYTE1(v3);
  result.byte2 = BYTE2(v3);
  result.byte3 = BYTE3(v3);
  result.byte4 = BYTE4(v3);
  result.byte5 = BYTE5(v3);
  result.byte6 = BYTE6(v3);
  result.byte7 = HIBYTE(v3);
  return result;
}

CFURLRef CFBundleCopyResourceURLInDirectory(CFURLRef bundleURL, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  if (!CFURLGetFileSystemRepresentation(bundleURL, 1u, buffer, 1026)) {
    return 0;
  }
  size_t v8 = strlen((const char *)buffer);
  CFURLRef v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v8, 1u);
  if (!v9) {
    CFURLRef v9 = (const __CFURL *)CFRetain(bundleURL);
  }
  if (_CFBundleCouldBeBundle(v9))
  {
    CFURLRef Resources = _CFBundleCopyFindResources(0, bundleURL, v10, resourceName, resourceType, subDirName, 0, 0, 0, 0);
    if (!v9) {
      return Resources;
    }
    goto LABEL_9;
  }
  CFURLRef Resources = 0;
  if (v9) {
LABEL_9:
  }
    CFRelease(v9);
  return Resources;
}

CFArrayRef CFBundleCopyResourceURLsOfTypeInDirectory(CFURLRef bundleURL, CFStringRef resourceType, CFStringRef subDirName)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (!CFURLGetFileSystemRepresentation(bundleURL, 1u, buffer, 1026)) {
    return 0;
  }
  size_t v6 = strlen((const char *)buffer);
  CFURLRef v7 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v6, 1u);
  if (!v7) {
    CFURLRef v7 = (const __CFURL *)CFRetain(bundleURL);
  }
  if (_CFBundleCouldBeBundle(v7))
  {
    CFArrayRef Resources = _CFBundleCopyFindResources(0, bundleURL, v8, 0, resourceType, subDirName, 0, 1, 0, 0);
    if (!v7) {
      return Resources;
    }
    goto LABEL_9;
  }
  CFArrayRef Resources = 0;
  if (v7) {
LABEL_9:
  }
    CFRelease(v7);
  return Resources;
}

void CFPlugInAddInstanceForFactory(CFUUIDRef factoryID)
{
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryID)) != 0
    && Value[24])
  {
    _CFPFactoryAddInstanceLocked(Value);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      CFPlugInAddInstanceForFactory_cold_2();
    }
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInAddInstanceForFactory_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
}

void *_CFPFactoryAddInstanceLocked(void *result)
{
  uint64_t v1 = (const void *)result[5];
  if (v1)
  {
    CFUUIDBytes result = (void *)__CFBundleGetPlugInData(result[5]);
    if (*(unsigned char *)result)
    {
      if (!*(_DWORD *)(__CFBundleGetPlugInData((uint64_t)v1) + 8)
        && *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)v1) + 1))
      {
        _CFPlugInUnscheduleForUnloading(v1);
      }
      PlugInCFDataRef Data = __CFBundleGetPlugInData((uint64_t)v1);
      ++*(_DWORD *)(PlugInData + 8);
      return CFRetain(v1);
    }
  }
  return result;
}

__CFBundle *_CFBundleCreateWithExecutableURLIfMightBeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  unint64_t v2 = _CFBundleCreateWithExecutableURLIfLooksLikeBundle(a1, a2);
  uint64_t v3 = (__CFBundle *)v2;
  if (v2)
  {
    if (_CFBundleEffectiveLayoutVersion((uint64_t)v2) - 3 <= 1)
    {
      CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(v3);
      if (!InfoDictionary || !CFDictionaryGetCount(InfoDictionary))
      {
        CFRelease(v3);
        return 0;
      }
    }
  }
  return v3;
}

uint64_t _CFBundleEffectiveLayoutVersion(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 53);
  if (!*(unsigned char *)(a1 + 53))
  {
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)a1);
    if (InfoDictionary && CFDictionaryGetCount(InfoDictionary))
    {
      return 0;
    }
    else
    {
      CFURLRef v5 = CFBundleCopyExecutableURL((CFBundleRef)a1);
      if (v5)
      {
        CFURLRef v7 = v5;
        int v8 = *(_DWORD *)(a1 + 48);
        if (!v8)
        {
          int v8 = _CFBundleGrokBinaryType(v7, v6);
          *(_DWORD *)(a1 + 48) = v8;
        }
        uint64_t v1 = 4;
        if (v8 != 1 && v8 != 6)
        {
          uint64_t v1 = 0;
          *(unsigned char *)(a1 + 64) = 1;
        }
        CFRelease(v7);
      }
      else
      {
        return 4;
      }
    }
  }
  return v1;
}

const char *__CFStringReplaceableReplace(uint64_t a1, int a2, int a3, UniChar *chars, int a5)
{
  int v8 = *(__CFString **)(a1 + 200);
  if (v8)
  {
    CFStringSetExternalCharactersNoCopy(v8, chars, a5, a5);
    MutableWithExternalCharactersNoCFArrayRef Copy = *(const __CFString **)(a1 + 200);
  }
  else
  {
    MutableWithExternalCharactersNoCFArrayRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, a5, a5, (CFAllocatorRef)&__kCFAllocatorNull);
    *(void *)(a1 + 20CFNotificationCenterRemoveObserver(center, observer, 0, 0) = MutableWithExternalCharactersNoCopy;
  }
  v14.CFIndex location = a2;
  v14.CFIndex length = a3 - a2;
  CFStringReplace(*(CFMutableStringRef *)a1, v14, MutableWithExternalCharactersNoCopy);
  CFIndex Length = CFStringGetLength(*(CFStringRef *)a1);
  *(void *)(a1 + 8) = Length;
  CFStringRef v11 = *(const __CFString **)a1;
  *(void *)(a1 + 144) = *(void *)a1;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = Length;
  CharactersPtr = CFStringGetCharactersPtr(v11);
  CFUUIDBytes result = 0;
  *(void *)(a1 + 152) = CharactersPtr;
  if (!CharactersPtr) {
    CFUUIDBytes result = CFStringGetCStringPtr(v11, 0x600u);
  }
  *(void *)(a1 + 16CFNotificationCenterRemoveObserver(center, observer, 0, 0) = result;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  return result;
}

void *__cdecl CFPlugInInstanceCreate(CFAllocatorRef allocator, CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  os_unfair_recursive_lock_lock_with_options();
  if (!_factoriesByFactoryID
    || (CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) == 0
    || (uint64_t v7 = (uint64_t)Value, !*((unsigned char *)Value + 24)))
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInInstanceCreate_cold_1();
    }
    goto LABEL_27;
  }
  CFArrayRef v8 = (const __CFArray *)*((void *)Value + 7);
  v34.CFIndex length = CFArrayGetCount(v8);
  v34.CFIndex location = 0;
  if ((CFArrayGetFirstIndexOfValue(v8, v34, typeUUID) & 0x80000000) != 0)
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInInstanceCreate_cold_4();
    }
    goto LABEL_27;
  }
  if (!*(unsigned char *)(v7 + 24))
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    UniChar v17 = _CFBundlePluginLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      CFPlugInInstanceCreate_cold_2(v7, v17, v18, v19, v20, v21, v22, v23);
    }
    goto LABEL_27;
  }
  FunctionPointerForCFStringRef Name = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
  if (!FunctionPointerForName)
  {
    FunctionPointerForCFStringRef Name = (uint64_t (*)(uint64_t, uint64_t))CFBundleGetFunctionPointerForName(*(CFBundleRef *)(v7 + 40), *(CFStringRef *)(v7 + 48));
    *(void *)(v7 + 32) = FunctionPointerForName;
    if (!FunctionPointerForName)
    {
      if (_CFBundlePluginLogger_onceToken != -1) {
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      }
      uint64_t v10 = _CFBundlePluginLogger__log;
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = *(void *)(v7 + 16);
        uint64_t v26 = *(void *)(v7 + 40);
        uint64_t v25 = *(void *)(v7 + 48);
        int v27 = 138543874;
        uint64_t v28 = v25;
        __int16 v29 = 2114;
        uint64_t v30 = v24;
        __int16 v31 = 2114;
        uint64_t v32 = v26;
        _os_log_error_impl(&dword_182B90000, v10, OS_LOG_TYPE_ERROR, "Cannot find function pointer %{public}@ for factory %{public}@ in %{public}@", (uint8_t *)&v27, 0x20u);
      }
      FunctionPointerForCFStringRef Name = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
      if (!FunctionPointerForName)
      {
LABEL_27:
        uint64_t v13 = 0;
        goto LABEL_28;
      }
    }
  }
  uint64_t v11 = *(void *)(v7 + 40);
  if (v11 && *(unsigned char *)__CFBundleGetPlugInData(*(void *)(v7 + 40)))
  {
    PlugInCFDataRef Data = __CFBundleGetPlugInData(v11);
    ++*(_DWORD *)(PlugInData + 12);
  }
  os_unfair_recursive_lock_unlock();
  uint64_t v13 = (void *)__CFPLUGIN_IS_CALLING_OUT_TO_A_FACTORY_FUNCTION__(FunctionPointerForName, (uint64_t)allocator, (uint64_t)typeUUID);
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    CFPlugInInstanceCreate_cold_3();
  }
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v14 = *(void *)(v7 + 40);
  if (v14 && *(unsigned char *)__CFBundleGetPlugInData(*(void *)(v7 + 40)))
  {
    uint64_t v15 = __CFBundleGetPlugInData(v14);
    --*(_DWORD *)(v15 + 12);
  }
LABEL_28:
  os_unfair_recursive_lock_unlock();
  return v13;
}

uint64_t __CFPLUGIN_IS_CALLING_OUT_TO_A_FACTORY_FUNCTION__(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

void *_CFBundleDlfcnGetSymbolByNameWithSearch(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  int32x4_t v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (!CFStringGetCString(a2, buffer, 1024, 0x8000100u) || (uint64_t v7 = *(void **)(a1 + 56)) == 0)
  {
LABEL_11:
    CFURLRef v9 = 0;
    goto LABEL_12;
  }
  CFArrayRef v8 = dlsym(v7, buffer);
  CFURLRef v9 = v8;
  if (a3 && !v8) {
    CFURLRef v9 = dlsym((void *)0xFFFFFFFFFFFFFFFELL, buffer);
  }
  uint64_t v10 = _CFBundleLoadingLogger();
  uint64_t v11 = v10;
  if (!v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      _CFBundleDlfcnGetSymbolByNameWithSearch_cold_1();
    }
    goto LABEL_11;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v12 = *(void *)(a1 + 56);
    int v14 = 138544130;
    uint64_t v15 = a1;
    __int16 v16 = 2048;
    uint64_t v17 = v12;
    __int16 v18 = 2048;
    uint64_t v19 = v9;
    __int16 v20 = 2082;
    uint64_t v21 = buffer;
    _os_log_debug_impl(&dword_182B90000, v11, OS_LOG_TYPE_DEBUG, "bundle %{public}@ handle %p dlsym returns symbol %p for %{public}s", (uint8_t *)&v14, 0x2Au);
  }
LABEL_12:
  os_unfair_lock_unlock(v6);
  return v9;
}

CFURLRef *_CFBundleCreateWithExecutableURLIfLooksLikeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  CFURLRef v4 = _CFBundleCopyBundleURLForExecutableURL(a2);
  CFURLRef v5 = _CFBundleCopyResolvedURLForExecutableURL(a2);
  CFURLRef v6 = v5;
  if (v4 && v5)
  {
    Unique = (CFURLRef *)_CFBundleCreateUnique(a1, v4);
    if (!Unique)
    {
      uint64_t v12 = 0;
      goto LABEL_19;
    }
    CFArrayRef v8 = Unique;
    CFURLRef v9 = _CFBundleCopyExecutableURLInDirectory2((CFBundleRef)Unique, Unique[2], 0, 1);
    CFURLRef NormalizedURL = _CFBundleCreateNormalizedURL(a1, v6);
    CFURLRef v11 = NormalizedURL;
    if (v9 && NormalizedURL)
    {
      if (!CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1026)
        || !CFURLGetFileSystemRepresentation(v11, 1u, v15, 1026)
        || strcmp((const char *)buffer, (const char *)v15))
      {
        CFRelease(v8);
        CFArrayRef v8 = 0;
      }
    }
    else
    {
      CFRelease(v8);
      CFArrayRef v8 = 0;
      uint64_t v12 = 0;
      if (!v9) {
        goto LABEL_17;
      }
    }
    CFRelease(v9);
    uint64_t v12 = v8;
LABEL_17:
    if (v11) {
      CFRelease(v11);
    }
LABEL_19:
    CFRelease(v4);
    uint64_t v13 = v12;
    if (!v6) {
      return v13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (v4) {
    goto LABEL_19;
  }
  if (v5) {
LABEL_12:
  }
    CFRelease(v6);
  return v13;
}

void *_CFBundleCreateUnique(const __CFAllocator *a1, const __CFURL *a2)
{
  return _CFBundleCreate(a1, a2, 1, 0);
}

void _CFBundleEnsureBundleExistsForImagePath(uint64_t a1, uint64_t a2)
{
  CFURLRef v2 = __CFBundleCopyFrameworkURLForExecutablePath(a1, a2);
  if (v2)
  {
    CFURLRef v3 = v2;
    CFURLRef v4 = (os_unfair_lock_s *)_CFBundleCreate(&__kCFAllocatorSystemDefault, v2, 4, 0);
    if (v4)
    {
      uint64_t v5 = (uint64_t)v4;
      CFURLRef v6 = v4 + 24;
      os_unfair_lock_lock(v4 + 24);
      if (!*(unsigned char *)(v5 + 52))
      {
        _CFBundleDlfcnCheckLoaded(v5);
        int v7 = *(_DWORD *)(v5 + 48);
        if (v7 != 6 && v7 != 1)
        {
          if (!v7) {
            *(_DWORD *)(v5 + 48) = 4;
          }
          *(unsigned char *)(v5 + 64) = 1;
        }
        if (!*(unsigned char *)(v5 + 52))
        {
          if (_CFBundleLoadingLogger_onceToken != -1) {
            dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
          }
          if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG)) {
            _CFBundleEnsureBundleExistsForImagePath_cold_2();
          }
        }
      }
      os_unfair_lock_unlock(v6);
      CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v5);
      _CFBundleInitPlugIn((void *)v5, InfoDictionary, 0);
      _CFPlugInHandleDynamicRegistration(v5);
    }
    else
    {
      if (_CFBundleLoadingLogger_onceToken != -1) {
        dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
      }
      if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG)) {
        _CFBundleEnsureBundleExistsForImagePath_cold_1();
      }
    }
    CFRelease(v3);
  }
}

uint64_t _CFBundleInitPlugIn(void *a1, CFDictionaryRef theDict, void *a3)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  memset(&callBacks, 0, sizeof(callBacks));
  if (!theDict) {
    return 1;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CFPlugInFactories");
  CFDictionaryRef v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFDictionaryGetTypeID()) {
      CFDictionaryRef v7 = 0;
    }
  }
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(theDict, @"CFPlugInDynamicRegistration");
  CFStringRef v10 = v9;
  if (v9)
  {
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 != CFStringGetTypeID())
    {
      LODWORD(v1CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
      if (v7) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
    LODWORD(v1CFNotificationCenterRemoveObserver(center, observer, 0, 0) = CFStringCompare(v10, @"YES", 1uLL) == kCFCompareEqualTo;
  }
  if (v7) {
    goto LABEL_12;
  }
LABEL_11:
  if (!v10) {
    return 1;
  }
LABEL_12:
  char context = 0;
  if (v7)
  {
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_searchForDummyUUID, &context);
    if (context)
    {
      if (_CFBundlePluginLogger_onceToken != -1) {
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      }
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
        _CFBundleInitPlugIn_cold_1();
      }
      return 1;
    }
  }
  os_unfair_recursive_lock_lock_with_options();
  if (*(unsigned char *)(__CFBundleGetPlugInData((uint64_t)a1) + 4)) {
    goto LABEL_19;
  }
  if (!dyld_program_sdk_at_least()
    || (uint64_t v18 = 0, !v7)
    || (CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_searchForExistingFactoryLocked, &v18), !v18))
  {
    *(unsigned char *)__CFBundleGetPlugInData((uint64_t)a1) = 1;
    *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)a1) + 1) = 1;
    *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)a1) + 2) = 0;
    *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)a1) + 3) = (_BYTE)v10;
    *(_DWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + 8) = 0;
    *(_DWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + 12) = 0;
    *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)a1) + 4) = 1;
    CFAllocatorRef v13 = CFGetAllocator(a1);
    CFMutableArrayRef v14 = CFArrayCreateMutable(v13, 0, &callBacks);
    *(void *)(__CFBundleGetPlugInData((uint64_t)a1) + 16) = v14;
    if (v7) {
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_registerFactoryLocked, a1);
    }
    CFDictionaryRef v15 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CFPlugInTypes");
    if (v15)
    {
      CFDictionaryRef v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFDictionaryGetTypeID()) {
        CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)_registerTypeLocked, a1);
      }
    }
LABEL_19:
    os_unfair_recursive_lock_unlock();
    return 1;
  }
  if (a3) {
    *a3 = v18;
  }
  os_unfair_recursive_lock_unlock();
  return 0;
}

CFURLRef __CFBundleCopyFrameworkURLForExecutablePath(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  int v4 = v3;
  CFStringRef v5 = (const __CFString *)v2;
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  bzero(buffer, 0x804uLL);
  bzero(v18, 0x804uLL);
  MutableWithExternalCharactersNoCFArrayRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, 0);
  CFIndex Length = CFStringGetLength(v5);
  if (Length >= 1026) {
    CFIndex v8 = 1026;
  }
  else {
    CFIndex v8 = Length;
  }
  v21.CFIndex location = 0;
  v21.CFIndex length = v8;
  CFStringGetCharacters(v5, v21, buffer);
  uint64_t v9 = _CFLengthAfterDeletingPathExtension(buffer, v8);
  _CFStartOfLastPathComponent(buffer, v9);
  __memmove_chk();
  uint64_t PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v9);
  if (v4) {
    CFStringRef v11 = &stru_1ECE10768;
  }
  else {
    CFStringRef v11 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
  }
  if (PathComponent >= 1)
  {
    do
    {
      uint64_t v12 = _CFStartOfLastPathComponent(buffer, PathComponent);
      if (PathComponent <= v12) {
        break;
      }
      CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, &buffer[v12], PathComponent - v12, 1026 - v12);
      if (!v4 && CFEqual(MutableWithExternalCharactersNoCopy, @"Resources"))
      {
        CFURLRef v16 = 0;
        goto LABEL_26;
      }
      if (CFEqual(MutableWithExternalCharactersNoCopy, @"Support Files")
        || CFEqual(MutableWithExternalCharactersNoCopy, @"Contents"))
      {
        if (v4
          || (uint64_t v13 = _CFStartOfLastPathComponent(buffer, PathComponent),
              CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, &buffer[v13], PathComponent - v13, 1026 - v13), CFStringHasPrefix(MutableWithExternalCharactersNoCopy, v11)))
        {
          CFIndex v15 = _CFLengthAfterDeletingLastPathComponent(buffer, PathComponent);
          CFMutableArrayRef v14 = MutableWithExternalCharactersNoCopy;
          goto LABEL_22;
        }
      }
      else if (CFStringHasSuffix(MutableWithExternalCharactersNoCopy, @".framework") {
             && (v4 || CFStringHasPrefix(MutableWithExternalCharactersNoCopy, v11)))
      }
      {
        CFMutableArrayRef v14 = MutableWithExternalCharactersNoCopy;
        CFIndex v15 = PathComponent;
LABEL_22:
        CFStringSetExternalCharactersNoCopy(v14, buffer, v15, 1026);
        CFURLRef v16 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableWithExternalCharactersNoCopy, kCFURLPOSIXPathStyle, 1u);
        if (_CFBundleCouldBeBundle(v16)) {
          goto LABEL_25;
        }
        CFRelease(v16);
        break;
      }
      uint64_t PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, PathComponent);
    }
    while (PathComponent > 0);
  }
  CFURLRef v16 = 0;
LABEL_25:
  if (!v4) {
LABEL_26:
  }
    CFRelease(v11);
  CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, 0, 0, 0);
  CFRelease(MutableWithExternalCharactersNoCopy);
  return v16;
}

CFMutableStringRef CFStringCreateMutableWithExternalCharactersNoCopy(CFAllocatorRef alloc, UniChar *chars, CFIndex numChars, CFIndex capacity, CFAllocatorRef externalCharactersAllocator)
{
  uint64_t v9 = (__objc2_class **)alloc;
  if (&__kCFAllocatorNull == (__objc2_class **)externalCharactersAllocator) {
    int v10 = 2;
  }
  else {
    int v10 = 3;
  }
  if (externalCharactersAllocator) {
    int v11 = v10;
  }
  else {
    int v11 = 1;
  }
  if (!alloc)
  {
    uint64_t v12 = _CFGetTSD(1u);
    if (v12) {
      uint64_t v9 = (__objc2_class **)v12;
    }
    else {
      uint64_t v9 = &__kCFAllocatorSystemDefault;
    }
  }
  if (v11 == 3) {
    uint64_t v13 = 40;
  }
  else {
    uint64_t v13 = 32;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v9, 7uLL, v13, 0);
  if (Instance)
  {
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    unint64_t v15 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v16 = v15;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v16, v15 & 0xFFFFFFFFFFFFFF9FLL | (32 * v11));
      BOOL v17 = v16 == v15;
      unint64_t v15 = v16;
    }
    while (!v17);
    unint64_t v18 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v19 = v18;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v19, v18 | 0x10);
      BOOL v17 = v19 == v18;
      unint64_t v18 = v19;
    }
    while (!v17);
    unint64_t v20 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v21 = v20;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v21, v20 | 1);
      BOOL v17 = v21 == v20;
      unint64_t v20 = v21;
    }
    while (!v17);
    *(void *)(Instance + 16) = 0;
    uint64_t v22 = (unint64_t *)(Instance + 8);
    char v23 = atomic_load((unint64_t *)(Instance + 8));
    BOOL v17 = (v23 & 0x60) == 0;
    uint64_t v24 = 24;
    if (v17) {
      uint64_t v24 = 16;
    }
    *(void *)(Instance + v24) = 0;
    *(_OWORD *)(Instance + 32) = xmmword_182DAF8C0;
    char v25 = atomic_load(v22);
    if ((~v25 & 0x60) == 0)
    {
      CFRetain(v9);
      *(void *)(Instance + 48) = v9;
    }
    *(void *)(Instance + 40) |= 4uLL;
    char v26 = atomic_load(v22);
    if ((~v26 & 0x60) == 0)
    {
      CFRelease(*(CFTypeRef *)(Instance + 48));
      CFRetain(externalCharactersAllocator);
      *(void *)(Instance + 48) = externalCharactersAllocator;
    }
    CFStringSetExternalCharactersNoCopy((CFMutableStringRef)Instance, chars, numChars, capacity);
  }
  return (CFMutableStringRef)Instance;
}

void CFStringSetExternalCharactersNoCopy(CFMutableStringRef theString, UniChar *chars, CFIndex length, CFIndex capacity)
{
  char v4 = atomic_load((unint64_t *)&theString->info);
  if (v4)
  {
    theString->data = (char *)chars;
    char v13 = atomic_load((unint64_t *)&theString->info);
    BOOL v14 = (v13 & 0x60) == 0;
    uint64_t v15 = 24;
    if (v14) {
      uint64_t v15 = 16;
    }
    *(void **)((char *)&theString->isa + v15) = (void *)length;
    uint64_t v16 = theString[1].info | 8;
    theString[1].isa = (void *)(2 * capacity);
    theString[1].info = v16;
  }
  else
  {
    CFStringRef v5 = _CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      CFStringSetExternalCharactersNoCopy_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
}

CFURLRef _CFBundleCopyBundleURLForExecutableURL(const __CFURL *a1)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  CFURLRef v1 = _CFBundleCopyResolvedURLForExecutableURL(a1);
  CFStringRef v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFIndex Length = CFStringGetLength(v2);
    if (Length >= 1026) {
      CFIndex v5 = 1026;
    }
    else {
      CFIndex v5 = Length;
    }
    v20.CFIndex location = 0;
    v20.CFIndex length = v5;
    CFStringGetCharacters(v3, v20, buffer);
    uint64_t PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v5);
    if (PathComponent >= 1)
    {
      uint64_t v7 = PathComponent;
      uint64_t v8 = _CFStartOfLastPathComponent(buffer, PathComponent);
      if (v8 < 1 || v7 <= v8) {
        goto LABEL_21;
      }
      CFStringRef v10 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v8], v7 - v8);
      PlatformExecutablesSubdirectoryCFStringRef Name = _CFBundleGetPlatformExecutablesSubdirectoryName();
      if (!CFEqual(v10, PlatformExecutablesSubdirectoryName))
      {
        CFRelease(v10);
        goto LABEL_21;
      }
      uint64_t v12 = _CFLengthAfterDeletingLastPathComponent(buffer, v7);
      if (v12 < 1)
      {
LABEL_16:
        CFURLRef v16 = 0;
LABEL_22:
        CFRelease(v10);
LABEL_24:
        CFRelease(v3);
        goto LABEL_25;
      }
      uint64_t v13 = v12;
      uint64_t v14 = _CFStartOfLastPathComponent(buffer, v12);
      if (v14 >= 1 && v13 > v14)
      {
        CFStringRef v15 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v14], v13 - v14);
        if (CFEqual(v15, @"Executables"))
        {
          uint64_t v13 = _CFLengthAfterDeletingLastPathComponent(buffer, v13);
          CFRelease(v15);
          if (v13 < 1) {
            goto LABEL_16;
          }
        }
        else
        {
          CFRelease(v15);
        }
      }
      uint64_t v7 = _CFLengthAfterDeletingLastPathComponent(buffer, v13);
      CFRelease(v10);
      if (v7 >= 1)
      {
LABEL_21:
        CFStringRef v10 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v7, (CFAllocatorRef)&__kCFAllocatorNull);
        CFURLRef v16 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, kCFURLPOSIXPathStyle, 1u);
        goto LABEL_22;
      }
    }
    CFURLRef v16 = 0;
    goto LABEL_24;
  }
  CFURLRef v16 = 0;
LABEL_25:
  CFRelease(v1);
  return v16;
}

uint64_t _CFStartOfLastPathComponent(_WORD *a1, uint64_t a2)
{
  if (a2 < 2) {
    return 0;
  }
  uint64_t v2 = a2;
  do
  {
    uint64_t v3 = v2 - 1;
    if (v2 == 1) {
      break;
    }
    int v4 = (unsigned __int16)a1[v2-- - 2];
  }
  while (v4 != 47);
  if (a2 >= 3 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
    return 2;
  }
  else {
    return 0;
  }
}

CFURLRef _CFBundleCopyResolvedURLForExecutableURL(const __CFURL *a1)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  CFURLRef v1 = CFURLCopyAbsoluteURL(a1);
  CFStringRef v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  if (!v2) {
    return v1;
  }
  CFStringRef v3 = v2;
  CFIndex Length = CFStringGetLength(v2);
  if (Length >= 1026) {
    CFIndex v5 = 1026;
  }
  else {
    CFIndex v5 = Length;
  }
  v21.CFIndex location = 0;
  v21.CFIndex length = v5;
  CFStringGetCharacters(v3, v21, buffer);
  CFIndex PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v5);
  if (PathComponent < 1 || PathComponent + 1 >= v5)
  {
    CFRelease(v3);
    return v1;
  }
  CFIndex v8 = PathComponent;
  CFStringRef v9 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, PathComponent);
  CFStringRef v10 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v8 + 1], v5 + ~v8);
  CFStringRef v11 = v10;
  if (v9) {
    BOOL v12 = v10 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    CFURLRef v13 = 0;
    if (!v9)
    {
      if (!v10) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  else
  {
    CFURLRef v15 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 1u);
    if (v15)
    {
      CFURLRef v16 = v15;
      CFURLRef v17 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, kCFURLPOSIXPathStyle, 0, v15);
      if (v17)
      {
        CFURLRef v18 = v17;
        CFURLRef v13 = CFURLCopyAbsoluteURL(v17);
        CFRelease(v18);
      }
      else
      {
        CFURLRef v13 = 0;
      }
      CFRelease(v16);
    }
    else
    {
      CFURLRef v13 = 0;
    }
  }
  CFRelease(v9);
  if (v11) {
LABEL_17:
  }
    CFRelease(v11);
LABEL_18:
  CFRelease(v3);
  if (v13)
  {
    CFRelease(v1);
    return v13;
  }
  return v1;
}

uint64_t _CFLengthAfterDeletingLastPathComponent(unsigned __int16 *a1, uint64_t a2)
{
  if (a2 >= 2)
  {
    uint64_t v3 = a2;
    while (1)
    {
      uint64_t v4 = v3 - 1;
      if (v3 == 1) {
        break;
      }
      int v5 = a1[v3-- - 2];
      if (v5 == 47)
      {
        uint64_t result = v4 - 1;
        if (v4 == 1) {
          return v4;
        }
        if (a1[1] == 58)
        {
          unsigned int v7 = *a1;
          if (v7 - 65 >= 0x1A)
          {
            if (v7 >= 0x61 && v4 == 3 && v7 <= 0x7A) {
              return v4;
            }
          }
          else if (v4 == 3)
          {
            return v4;
          }
        }
        return result;
      }
    }
    if (a2 >= 3 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
      return 2;
    }
  }
  return 0;
}

__CFString *_CFBundleGetPlatformExecutablesSubdirectoryName()
{
  return @"MacOS";
}

uint64_t _CFLengthAfterDeletingPathExtension(_WORD *a1, uint64_t a2)
{
  uint64_t result = _CFStartOfPathExtension(a1, a2);
  if (!result) {
    return a2;
  }
  return result;
}

uint64_t _CFStartOfPathExtension(_WORD *a1, uint64_t a2)
{
  if (a2 < 2) {
    return 0;
  }
  uint64_t v3 = &a1[a2 - 1];
  while (--a2)
  {
    if (*(v3 - 1) == 47) {
      return 0;
    }
    int v4 = *v3--;
    if (v4 == 46)
    {
      if (a2 == 2 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
        return 0;
      }
      return a2;
    }
  }
  return a2;
}

BOOL _CFBundleCouldBeBundle(CFURLRef url)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  char v4 = 0;
  int v3 = 0;
  int v1 = _CFGetFileProperties((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, &v4, &v3, 0, 0, 0, 0);
  BOOL result = 0;
  if (!v1)
  {
    if (v4) {
      return (v3 & 0xF000) == 0x4000 && (v3 & 0x124) != 0;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t _CFBundleLoadExecutableAndReturnError(uint64_t a1, int a2, void *a3)
{
  v18[1] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v6 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v6);
  }
  v18[0] = 0;
  if (a3) {
    unsigned int v7 = (CFTypeRef *)v18;
  }
  else {
    unsigned int v7 = 0;
  }
  CFURLRef v8 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (!v8) {
    *(_DWORD *)(a1 + 48) = 7;
  }
  _CFBundleDlfcnCheckLoaded(a1);
  if (!*(_DWORD *)(a1 + 48))
  {
    int v13 = _CFBundleGrokBinaryType(v8, v9);
    *(_DWORD *)(a1 + 48) = v13;
    if (v13 != 1 && v13 != 6) {
      *(unsigned char *)(a1 + 64) = 1;
    }
  }
  if (v8) {
    CFRelease(v8);
  }
  int v10 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  if (!v10)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 3:
      case 6:
      case 8:
        uint64_t Bundle = _CFBundleDlfcnLoadBundle(a1, a2, v7);
        goto LABEL_29;
      case 2:
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
        }
        if (!os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
        _CFBundleLoadExecutableAndReturnError_cold_2();
        if (!a3) {
          return 0;
        }
        goto LABEL_27;
      case 4:
        uint64_t Bundle = _CFBundleDlfcnLoadFramework(a1, v7);
LABEL_29:
        uint64_t v11 = Bundle;
        if (Bundle)
        {
          if (*(unsigned char *)(a1 + 72)) {
            _CFPlugInHandleDynamicRegistration(a1);
          }
          return v11;
        }
        if (a3) {
          goto LABEL_40;
        }
        return 0;
      case 7:
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
        {
          _CFBundleLoadExecutableAndReturnError_cold_3();
          if (!a3) {
            return 0;
          }
        }
        else if (!a3)
        {
          return 0;
        }
        CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
        CFURLRef v16 = (__CFBundle *)a1;
        CFIndex v17 = 4;
        goto LABEL_39;
      default:
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
        {
          _CFBundleLoadExecutableAndReturnError_cold_1();
          if (!a3) {
            return 0;
          }
        }
        else
        {
LABEL_26:
          if (!a3) {
            return 0;
          }
        }
LABEL_27:
        CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
        CFURLRef v16 = (__CFBundle *)a1;
        CFIndex v17 = 3584;
LABEL_39:
        v18[0] = _CFBundleCreateErrorDebug(v15, v16, v17, 0);
LABEL_40:
        uint64_t v11 = 0;
        *a3 = v18[0];
        return v11;
    }
  }
  _CFPlugInUnscheduleForUnloading((const void *)a1);
  return 1;
}

uint64_t _CFBundleDlfcnCheckLoaded(uint64_t a1)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 96));
  uint64_t result = *(unsigned __int8 *)(a1 + 52);
  if (!*(unsigned char *)(a1 + 52))
  {
    CFURLRef v3 = CFBundleCopyExecutableURL((CFBundleRef)a1);
    if (v3)
    {
      CFURLRef v4 = v3;
      if (CFURLGetFileSystemRepresentation(v3, 1u, buffer, 1026))
      {
        uint64_t v5 = dlopen((const char *)buffer, 277);
        if (v5)
        {
          if (!*(void *)(a1 + 56))
          {
            *(void *)(a1 + 56) = v5;
            unint64_t v6 = _CFBundleLoadingLogger();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v8 = *(void *)(a1 + 56);
              int v9 = 138544130;
              uint64_t v10 = a1;
              __int16 v11 = 2082;
              BOOL v12 = buffer;
              __int16 v13 = 1024;
              int v14 = 277;
              __int16 v15 = 2048;
              uint64_t v16 = v8;
              _os_log_debug_impl(&dword_182B90000, v6, OS_LOG_TYPE_DEBUG, "dlfcn check load bundle %{public}@, dlopen of %{public}s mode 0x%x getting handle %p", (uint8_t *)&v9, 0x26u);
            }
          }
          *(unsigned char *)(a1 + 52) = 1;
        }
        else
        {
          unsigned int v7 = _CFBundleLoadingLogger();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
            _CFBundleDlfcnCheckLoaded_cold_1();
          }
        }
      }
      CFRelease(v4);
    }
    return *(unsigned __int8 *)(a1 + 52);
  }
  return result;
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return _CFBundleCopyExecutableURLInDirectory2(bundle, *((CFURLRef *)bundle + 2), 0, 0);
}

uint64_t _CFBundleLoadingLogger()
{
  if (_CFBundleLoadingLogger_onceToken != -1) {
    dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_146);
  }
  return _CFBundleLoadingLogger__log;
}

uint64_t _CFPlugInUnscheduleForUnloading(const void *a1)
{
  if (_plugInsToUnload) {
    CFSetRemoveValue((CFMutableSetRef)_plugInsToUnload, a1);
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPlugInUnscheduleForUnloading_cold_1();
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _CFBundleDlfcnLoadBundle(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v31 = *(void *)off_1ECE0A5B0;
  unint64_t v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  int v7 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock(v6);
  if (v7) {
    return 1;
  }
  CFTypeRef cf = 0;
  CFURLRef v9 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  CFURLRef v10 = v9;
  if (!v9 || !CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1026))
  {
    __int16 v15 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadBundle_cold_1();
      if (!a3)
      {
LABEL_19:
        uint64_t v8 = 0;
        if (!v10) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }
    }
    else if (!a3)
    {
      goto LABEL_19;
    }
    CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
    CFTypeRef cf = _CFBundleCreateError(v16, (__CFBundle *)a1, 4);
    goto LABEL_19;
  }
  if (a2) {
    int v11 = 265;
  }
  else {
    int v11 = 262;
  }
  BOOL v12 = dlopen((const char *)buffer, v11);
  __int16 v13 = _CFBundleLoadingLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138544130;
    uint64_t v23 = a1;
    __int16 v24 = 2082;
    char v25 = buffer;
    __int16 v26 = 1024;
    int v27 = v11;
    __int16 v28 = 2048;
    __int16 v29 = v12;
    _os_log_debug_impl(&dword_182B90000, v13, OS_LOG_TYPE_DEBUG, "dlfcn load bundle %{public}@, dlopen of %{public}s mode 0x%x returns handle %p", buf, 0x26u);
  }
  os_unfair_lock_lock_with_options();
  if (!v12)
  {
    *(void *)(a1 + 56) = 0;
    os_unfair_lock_unlock(v6);
    CFIndex v17 = dlerror();
    uint64_t v18 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadBundle_cold_2();
      if (!v17)
      {
LABEL_24:
        if (a3)
        {
          _CFBundleDlfcnPreflight((unsigned __int8 *)a1, (CFErrorRef *)&cf);
          if (!cf)
          {
            CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)a1);
            CFTypeRef cf = _CFBundleCreateErrorDebug(v19, (CFBundleRef)a1, 3588, v17);
          }
        }
        if (v17) {
          CFRelease(v17);
        }
        uint64_t v8 = 0;
        goto LABEL_30;
      }
    }
    else if (!v17)
    {
      goto LABEL_24;
    }
    CFIndex v17 = (void *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)v17);
    goto LABEL_24;
  }
  if (v12 == *(void **)(a1 + 56))
  {
    int v14 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDlfcnLoadBundle_cold_3();
    }
    os_unfair_lock_unlock(v6);
    dlclose(v12);
    os_unfair_lock_lock_with_options();
  }
  *(void *)(a1 + 56) = v12;
  uint64_t v8 = 1;
  *(unsigned char *)(a1 + 52) = 1;
  os_unfair_lock_unlock(v6);
LABEL_30:
  CFRelease(v10);
LABEL_31:
  if (!a3 || v8)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *a3 = cf;
  }
  return v8;
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  if (!CFBundleLoadExecutable(bundle)) {
    return 0;
  }

  return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)bundle, functionName, 0);
}

void *__cdecl CFBundleGetDataPointerForName(CFBundleRef bundle, CFStringRef symbolName)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  if (!CFBundleLoadExecutable(bundle)) {
    return 0;
  }

  return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)bundle, symbolName, 0);
}

Boolean CFBundleLoadExecutable(CFBundleRef bundle)
{
  return _CFBundleLoadExecutableAndReturnError((uint64_t)bundle, 0, 0);
}

void _CFPlugInUnscheduleForUnloading_cold_1()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_2_1(&dword_182B90000, v0, v1, "PlugIn %{public}@ is now unscheduled for unloading", v2, v3, v4, v5, v6);
}

void OUTLINED_FUNCTION_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void _CFBundleDlfcnGetSymbolByNameWithSearch_cold_1()
{
  OUTLINED_FUNCTION_4();
  dlerror();
  OUTLINED_FUNCTION_2_0(&dword_182B90000, v0, v1, "dlsym cannot find symbol %{public}@ in %{public}@: %s", v2, v3, v4, v5, 2u);
}

void _CFBundleDlfcnCheckLoaded_cold_1()
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  OUTLINED_FUNCTION_5();
  __int16 v3 = 2082;
  uint64_t v4 = v0;
  __int16 v5 = 1024;
  int v6 = 277;
  _os_log_debug_impl(&dword_182B90000, v1, OS_LOG_TYPE_DEBUG, "dlfcn check load bundle %{public}@, dlopen of %{public}s mode 0x%x no handle", v2, 0x1Cu);
}

void _CFBundleCopyLoadedImagePathForPointer_cold_1()
{
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_0_3(&dword_182B90000, v0, v1, "dyld image path for pointer %p is %{public}@");
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

void CFXNotificationRegistrarRemoveRemoteToken(uint64_t a1, const void *a2)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  memset(v7, 0, sizeof(v7));
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 88);
  if (v5)
  {
    CFURLRef value = 0;
    if (CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value))
    {
      if (*(_DWORD *)(a1 + 156) > value
        && *(_DWORD *)(*(void *)(a1 + 144) + 56 * value + 40) == HIDWORD(value))
      {
        _CFXNotificationRegistrarInvalidateObserver(a1, value, -1, -1, (unsigned int *)v7);
      }
    }
  }
  os_unfair_lock_unlock(v4);
  _CFXNotificationDisposalListRelease((unsigned int *)v7);
}

void CFXNotificationRegistrarRemoveToken(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  memset(v5, 0, sizeof(v5));
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2
    && *(_DWORD *)(*(void *)(a1 + 144) + 56 * a2 + 40) == HIDWORD(a2))
  {
    _CFXNotificationRegistrarInvalidateObserver(a1, a2, -1, -1, (unsigned int *)v5);
  }
  os_unfair_lock_unlock(v4);
  _CFXNotificationDisposalListRelease((unsigned int *)v5);
}

void _CFXNotificationRegistrarInvalidateObserver(uint64_t a1, unsigned int a2, int a3, int a4, unsigned int *a5)
{
  if (*(_DWORD *)(a1 + 156) <= a2) {
    return;
  }
  uint64_t v7 = *(void *)(a1 + 144);
  int v8 = *(_DWORD *)(v7 + 56 * a2 + 44);
  if ((v8 & 0x800) != 0)
  {
    unsigned int v23 = *(_DWORD *)(v7 + 56 * a2 + 48);
    BOOL v24 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(*(void *)(a1 + 96) + 40 * v23 + 24), a2, a5);
    if (v23 != a3 && v24)
    {
      CFAllocatorRef v19 = (uint64_t *)(a1 + 64);
      uint64_t v20 = a1;
      unsigned int v21 = v23;
      int v22 = 1;
      goto LABEL_22;
    }
  }
  else
  {
    if ((v8 & 0x8000) != 0) {
      return;
    }
    uint64_t v9 = *(unsigned int *)(v7 + 56 * a2 + 48);
    if (v9 == -1)
    {
      _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(a1 + 80), a2, a5);
    }
    else
    {
      if (v9 >= *(_DWORD *)(a1 + 132)) {
        return;
      }
      int v11 = (*(unsigned __int8 *)(a1 + 24) >> 1) & 1;
      uint64_t v12 = *(void *)(a1 + 120) + 32 * v9;
      unsigned int v13 = *(_DWORD *)(v12 + 24);
      if (v13 == -1)
      {
        BOOL v26 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(v12 + 16), a2, a5);
        if (v9 != a4 && v26)
        {
          _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)(a1 + 48), v9, v11);
        }
      }
      else
      {
        uint64_t v14 = *(void *)(a1 + 96);
        BOOL v15 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(v12 + 16), a2, a5);
        if (v9 != a4 && v15)
        {
          BOOL v17 = _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)(v14 + 40 * v13 + 24), v9, v11);
          if (v13 != a3 && v17)
          {
            CFAllocatorRef v19 = (uint64_t *)(a1 + 32);
            uint64_t v20 = a1;
            unsigned int v21 = v13;
            int v22 = 0;
LABEL_22:
            _CFXNotificationRegistrarRecycleNameRegistration(v20, v19, v21, v22);
          }
        }
      }
    }
  }
}

BOOL _CFXNotificationRegistrarRecycleObjectRegistration(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = a3;
  uint64_t v10 = v8 + 32 * a3;
  unint64_t v13 = *(void *)(v10 + 8);
  uint64_t v12 = (const void **)(v10 + 8);
  unint64_t v11 = v13;
  if (a4)
  {
    CFHashCode v14 = CFHash((CFTypeRef)v11);
    uint64_t v8 = *(void *)(a1 + 120);
  }
  else
  {
    CFHashCode v14 = (v11 >> 5) & 0x7F;
  }
  if (a3 != -1)
  {
    uint64_t v15 = *a2;
    if (*a2)
    {
      unint64_t v16 = v14 % *((unsigned int *)a2 + 2);
      BOOL v17 = (unsigned int *)(v8 + 32 * v9);
      uint64_t v18 = *v17;
      uint64_t v19 = v17[1];
      if (*(_DWORD *)(v15 + 4 * v16) == a3) {
        *(_DWORD *)(v15 + 4 * v16) = v19;
      }
      if (v18 != -1) {
        *(_DWORD *)(v8 + 32 * v18 + 4) = v19;
      }
      if (v19 != -1) {
        *(_DWORD *)(v8 + 32 * v19) = v18;
      }
    }
  }
  if (a4) {
    _CFXNotificationRegistrarRemoveCachedName(v12);
  }
  *uint64_t v12 = 0;
  int v20 = *((_DWORD *)a2 + 3);
  if (v20) {
    *((_DWORD *)a2 + 3) = --v20;
  }
  if (a3 != -1)
  {
    uint64_t v21 = *(void *)(a1 + 120);
    uint64_t v22 = *(unsigned int *)(a1 + 136);
    if (v22 != -1) {
      *(_DWORD *)(v21 + 32 * v22) = a3;
    }
    unsigned int v23 = (_DWORD *)(v21 + 32 * v9);
    *unsigned int v23 = -1;
    v23[1] = v22;
    *(_DWORD *)(a1 + 136) = a3;
    int v20 = *((_DWORD *)a2 + 3);
  }
  --*(_DWORD *)(a1 + 128);
  return v20 == 0;
}

void _CFXNotificationRegistrarRecycleNameRegistration(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 96);
  if (a3 != -1)
  {
    uint64_t v10 = *a2;
    if (*a2)
    {
      unint64_t v11 = *(void *)(v8 + 40 * a3 + 16) % (unint64_t)*((unsigned int *)a2 + 2);
      uint64_t v12 = (unsigned int *)(v8 + 40 * a3);
      unsigned int v13 = *v12;
      unsigned int v14 = v12[1];
      if (*(_DWORD *)(v10 + 4 * v11) == a3) {
        *(_DWORD *)(v10 + 4 * v11) = v14;
      }
      if (v13 != -1) {
        *(_DWORD *)(v8 + 40 * v13 + 4) = v14;
      }
      if (v14 != -1) {
        *(_DWORD *)(v8 + 40 * v14) = v13;
      }
    }
  }
  uint64_t v15 = v8 + 40 * a3;
  uint64_t v17 = *(void *)(v15 + 8);
  unint64_t v16 = (const void **)(v15 + 8);
  if (v17) {
    _CFXNotificationRegistrarRemoveCachedName(v16);
  }
  if (!a4)
  {
    uint64_t v18 = v8 + 40 * a3;
    uint64_t v21 = *(void **)(v18 + 24);
    int v20 = (void *)(v18 + 24);
    uint64_t v19 = v21;
    if (v21)
    {
      free(v19);
      *int v20 = 0;
    }
  }
  --*((_DWORD *)a2 + 3);
  if (a3 != -1)
  {
    uint64_t v22 = *(void *)(a1 + 96);
    unsigned int v23 = *(_DWORD *)(a1 + 112);
    if (v23 != -1) {
      *(_DWORD *)(v22 + 40 * v23) = a3;
    }
    BOOL v24 = (_DWORD *)(v22 + 40 * a3);
    *BOOL v24 = -1;
    v24[1] = v23;
    *(_DWORD *)(a1 + 112) = a3;
  }
  --*(_DWORD *)(a1 + 104);
}

void _CFXNotificationRegistrarRemoveCachedName(const void **a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  NamePool = _CFXNotificationRegistrarGetNamePool();
  if (CFDictionaryGetValue(NamePool, *a1) == (const void *)1) {
    CFDictionaryRemoveValue(NamePool, *a1);
  }
  *a1 = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
}

void sub_182C72CB8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CFTypeRef CFNumberFormatterCopyProperty(CFNumberFormatterRef formatter, CFNumberFormatterKey key)
{
  uint64_t v42 = *(void *)off_1ECE0A5B0;
  int valuePtr = 0;
  Doubleint Attribute = 0.0;
  int v37 = 0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v4);
  }
  if (CFEqual(@"kCFNumberFormatterFormattingContextKey", key))
  {
    int Context = __cficu_unum_getContext(*((void *)formatter + 2), 1, &v37);
LABEL_4:
    int valuePtr = Context;
LABEL_5:
    CFAllocatorRef v6 = CFGetAllocator(formatter);
    p_int valuePtr = (double *)&valuePtr;
    CFNumberType v8 = kCFNumberSInt32Type;
    return CFNumberCreate(v6, v8, p_valuePtr);
  }
  uint64_t v10 = *((void *)formatter + 4);
  if (((unint64_t)(v10 - 8) >= 0xFFFFFFFFFFFFFFFDLL || v10 == 9)
    && @"kCFNumberFormatterIsLenientKey" != key)
  {
    return 0;
  }
  if (@"kCFNumberFormatterCurrencyCodeKey" != key)
  {
    if (@"kCFNumberFormatterDecimalSeparatorKey" == key)
    {
      uint64_t v22 = *((void *)formatter + 2);
      unsigned int v23 = 0;
    }
    else if (@"kCFNumberFormatterCurrencyDecimalSeparatorKey" == key)
    {
      uint64_t v22 = *((void *)formatter + 2);
      unsigned int v23 = 10;
    }
    else
    {
      if (@"kCFNumberFormatterAlwaysShowDecimalSeparatorKey" == key)
      {
        uint64_t v24 = *((void *)formatter + 2);
        int v25 = 2;
        goto LABEL_76;
      }
      if (@"kCFNumberFormatterGroupingSeparatorKey" == key)
      {
        uint64_t v22 = *((void *)formatter + 2);
        unsigned int v23 = 1;
      }
      else
      {
        if (@"kCFNumberFormatterUseGroupingSeparatorKey" == key)
        {
          uint64_t v24 = *((void *)formatter + 2);
          int v25 = 1;
          goto LABEL_76;
        }
        if (@"kCFNumberFormatterPercentSymbolKey" == key)
        {
          uint64_t v22 = *((void *)formatter + 2);
          unsigned int v23 = 3;
        }
        else
        {
          if (@"kCFNumberFormatterZeroSymbolKey" == key)
          {
            CFTypeRef result = (CFTypeRef)*((void *)formatter + 9);
            if (!result) {
              return result;
            }
            goto LABEL_80;
          }
          if (@"kCFNumberFormatterNaNSymbolKey" == key)
          {
            uint64_t v22 = *((void *)formatter + 2);
            unsigned int v23 = 15;
          }
          else if (@"kCFNumberFormatterInfinitySymbolKey" == key)
          {
            uint64_t v22 = *((void *)formatter + 2);
            unsigned int v23 = 14;
          }
          else if (@"kCFNumberFormatterMinusSignKey" == key)
          {
            uint64_t v22 = *((void *)formatter + 2);
            unsigned int v23 = 6;
          }
          else if (@"kCFNumberFormatterPlusSignKey" == key)
          {
            uint64_t v22 = *((void *)formatter + 2);
            unsigned int v23 = 7;
          }
          else if (@"kCFNumberFormatterCurrencySymbolKey" == key)
          {
            uint64_t v22 = *((void *)formatter + 2);
            unsigned int v23 = 8;
          }
          else
          {
            if (@"kCFNumberFormatterExponentSymbolKey" != key)
            {
              if (@"kCFNumberFormatterMinIntegerDigitsKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 4;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterMaxIntegerDigitsKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 3;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterMinFractionDigitsKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 7;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterMaxFractionDigitsKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 6;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterGroupingSizeKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 10;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterSecondaryGroupingSizeKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 15;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterRoundingModeKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 11;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterRoundingIncrementKey" == key)
              {
                Doubleint Attribute = __cficu_unum_getDoubleAttribute(*((void *)formatter + 2), 12);
                CFAllocatorRef v6 = CFGetAllocator(formatter);
                p_int valuePtr = &DoubleAttribute;
                CFNumberType v8 = kCFNumberDoubleType;
                return CFNumberCreate(v6, v8, p_valuePtr);
              }
              if (@"kCFNumberFormatterFormatWidthKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 13;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterPaddingPositionKey" == key)
              {
                uint64_t v32 = *((void *)formatter + 2);
                int v33 = 14;
                goto LABEL_109;
              }
              if (@"kCFNumberFormatterPaddingCharacterKey" == key)
              {
                uint64_t v34 = *((void *)formatter + 2);
                unsigned int v35 = 4;
              }
              else
              {
                if (@"kCFNumberFormatterDefaultFormatKey" == key)
                {
                  CFTypeRef result = (CFTypeRef)*((void *)formatter + 6);
                  if (!result) {
                    return result;
                  }
                  goto LABEL_80;
                }
                if (@"kCFNumberFormatterMultiplierKey" == key)
                {
                  CFTypeRef result = (CFTypeRef)*((void *)formatter + 8);
                  if (!result) {
                    return result;
                  }
                  goto LABEL_80;
                }
                if (@"kCFNumberFormatterPositivePrefixKey" == key)
                {
                  uint64_t v34 = *((void *)formatter + 2);
                  unsigned int v35 = 0;
                }
                else if (@"kCFNumberFormatterPositiveSuffixKey" == key)
                {
                  uint64_t v34 = *((void *)formatter + 2);
                  unsigned int v35 = 1;
                }
                else if (@"kCFNumberFormatterNegativePrefixKey" == key)
                {
                  uint64_t v34 = *((void *)formatter + 2);
                  unsigned int v35 = 2;
                }
                else
                {
                  if (@"kCFNumberFormatterNegativeSuffixKey" != key)
                  {
                    if (@"kCFNumberFormatterPerMillSymbolKey" == key)
                    {
                      uint64_t v22 = *((void *)formatter + 2);
                      unsigned int v23 = 12;
                    }
                    else if (@"kCFNumberFormatterInternationalCurrencySymbolKey" == key)
                    {
                      uint64_t v22 = *((void *)formatter + 2);
                      unsigned int v23 = 9;
                    }
                    else
                    {
                      if (@"kCFNumberFormatterCurrencyGroupingSeparatorKey" != key)
                      {
                        if (@"kCFNumberFormatterIsLenientKey" == key)
                        {
                          int v27 = (CFTypeRef *)&kCFBooleanTrue;
                          BOOL v28 = *((unsigned char *)formatter + 80) == 0;
                          goto LABEL_77;
                        }
                        if (@"kCFNumberFormatterUseSignificantDigitsKey" != key)
                        {
                          if (@"kCFNumberFormatterMinSignificantDigitsKey" == key)
                          {
                            uint64_t v32 = *((void *)formatter + 2);
                            int v33 = 17;
                          }
                          else
                          {
                            if (@"kCFNumberFormatterMaxSignificantDigitsKey" != key)
                            {
                              if (@"kCFNumberFormatterMinGroupingDigitsKey" == key)
                              {
                                int Attribute = __cficu_unum_getAttribute(*((void *)formatter + 2), 22);
                                if (Attribute == -2) {
                                  int v14 = -1;
                                }
                                else {
                                  int v14 = Attribute;
                                }
                                int valuePtr = v14;
                                goto LABEL_5;
                              }
                              return 0;
                            }
                            uint64_t v32 = *((void *)formatter + 2);
                            int v33 = 18;
                          }
LABEL_109:
                          int Context = __cficu_unum_getAttribute(v32, v33);
                          goto LABEL_4;
                        }
                        uint64_t v24 = *((void *)formatter + 2);
                        int v25 = 16;
LABEL_76:
                        int v26 = __cficu_unum_getAttribute(v24, v25);
                        int v27 = (CFTypeRef *)&kCFBooleanTrue;
                        BOOL v28 = v26 == 0;
LABEL_77:
                        if (v28) {
                          int v27 = (CFTypeRef *)&kCFBooleanFalse;
                        }
                        CFTypeRef result = *v27;
LABEL_80:
                        return CFRetain(result);
                      }
                      uint64_t v22 = *((void *)formatter + 2);
                      unsigned int v23 = 17;
                    }
                    goto LABEL_93;
                  }
                  uint64_t v34 = *((void *)formatter + 2);
                  unsigned int v35 = 3;
                }
              }
              Textint Attribute = __cficu_unum_getTextAttribute(v34, v35, chars, 768, &v37);
LABEL_94:
              int v30 = TextAttribute;
              CFTypeRef result = 0;
              if (v37 > 0 || v30 > 768) {
                return result;
              }
              CFIndex v16 = v30;
LABEL_97:
              CFAllocatorRef v31 = CFGetAllocator(formatter);
              return CFStringCreateWithCharacters(v31, chars, v16);
            }
            uint64_t v22 = *((void *)formatter + 2);
            unsigned int v23 = 11;
          }
        }
      }
    }
LABEL_93:
    Textint Attribute = __cficu_unum_getSymbol(v22, v23, chars, 768, &v37);
    goto LABEL_94;
  }
  int v15 = __cficu_unum_getTextAttribute(*((void *)formatter + 2), 5u, chars, 768, &v37);
  CFIndex v16 = v15;
  int v17 = v37;
  if (v37 <= 0 && !v15)
  {
    CFStringRef Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3));
    CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr)
    {
      CStringPtr = buffer;
      if (!CFStringGetCString(Identifier, buffer, 768, 0x600u)) {
        return 0;
      }
    }
    int v36 = 0;
    uint64_t v20 = __cficu_unum_open(2u, 0, 0, (uint64_t)CStringPtr, 0, &v36);
    if (v20)
    {
      uint64_t v21 = v20;
      CFIndex v16 = (int)__cficu_unum_getTextAttribute(v20, 5u, chars, 768, &v36);
      __cficu_unum_close(v21);
    }
    else
    {
      CFIndex v16 = 0;
    }
    int v17 = v37;
  }
  CFTypeRef result = 0;
  if (v17 <= 0 && v16 >= 1 && v16 <= 768) {
    goto LABEL_97;
  }
  return result;
}

uint64_t __cficu_unum_getSymbol(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t Symbol = unum_getSymbol();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFTypeRef v12 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", (uint64_t)a3, a4);
    unsigned int v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0) {
      CFStringRef v15 = CFStringCreateWithCharacters(0, a3, (int)Symbol);
    }
    else {
      CFStringRef v15 = 0;
    }
    CFIndex v16 = ___CFICUGetEnumStringForUNumberFormatSymbol(a2);
    ___CFICULogWithArguments(1, @"unum_getSymbol(%@, %s, %@, %d, &%@); // %d %@ %@",
      v11,
      v16,
      v12,
      a4,
      v13,
      Symbol,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(v14);
  }
  return Symbol;
}

uint64_t __cficu_unum_getContext(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t Context = unum_getContext();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a3, 1);
    ___CFICULogWithArguments(1, CFSTR(""unum_getContext(%@, %d, &%@);
    CFRelease(v8);
    CFRelease(v7);
  }
  return Context;
}

BOOL _CFDictionaryIsMutable(unint64_t a1)
{
  if (CF_IS_OBJC(0x12uLL, a1)) {
    return 0;
  }
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

BOOL __CFStringIsEightBit(uint64_t a1)
{
  unsigned int v1 = atomic_load((unint64_t *)(a1 + 8));
  return ((v1 >> 4) & 1) == 0;
}

void *__CFFileDescriptorCreateRunLoopSource_block_invoke(void *result)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t v1 = result[5];
  if (!*(_DWORD *)(v1 + 16))
  {
    uint64_t v2 = result;
    unsigned int v3 = *(__CFRunLoopSource **)(v1 + 56);
    if (v3)
    {
      int IsValid = CFRunLoopSourceIsValid(v3);
      uint64_t v1 = v2[5];
      if (!IsValid)
      {
        CFRelease(*(CFTypeRef *)(v1 + 56));
        *(void *)(v2[5] + 56) = 0;
        uint64_t v1 = v2[5];
      }
    }
    CFTypeRef result = *(void **)(v1 + 56);
    if (result) {
      goto LABEL_12;
    }
    context.CFIndex version = 0;
    context.info = (void *)v1;
    context.CFAllocatorRetainCallBack retain = CFRetain;
    context.CFArrayReleaseCallBack release = CFRelease;
    context.equal = 0;
    context.hash = 0;
    context.copyDescription = (CFStringRef (__cdecl *)(const void *))__CFFileDescriptorCopyDescription;
    context.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFFileDescriptorSchedule;
    context.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFFileDescriptorCancel;
    context.perform = (void (__cdecl *)(void *))__CFFileDescriptorPerform;
    *(void *)(v2[5] + 56) = CFRunLoopSourceCreate((CFAllocatorRef)v2[6], v2[7], &context);
    uint64_t v5 = v2[5];
    CFAllocatorRef v6 = *(__CFRunLoopSource **)(v5 + 56);
    if (v6)
    {
      if (*(unsigned char *)(v5 + 50))
      {
        CFRunLoopSourceSignal(v6);
        _CFRunLoopSourceWakeUpRunLoops(*(void *)(v2[5] + 56));
        uint64_t v5 = v2[5];
      }
      if (*(unsigned char *)(v5 + 51))
      {
        CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(v5 + 56));
        _CFRunLoopSourceWakeUpRunLoops(*(void *)(v2[5] + 56));
        uint64_t v5 = v2[5];
      }
    }
    CFTypeRef result = *(void **)(v5 + 56);
    if (result) {
LABEL_12:
    }
      CFTypeRef result = CFRetain(result);
    *(void *)(*(void *)(v2[4] + 8) + 24) = result;
  }
  return result;
}

Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source)
{
  __CFCheckCFInfoPACSignature((uint64_t)source);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)source + 1);
  return (v3 >> 3) & 1;
}

uint64_t _CFStreamSetDispatchQueue(uint64_t a1, NSObject *a2)
{
  CFArrayRef v4 = _CFStreamCopyRunLoopsAndModes(a1);
  if (v4)
  {
    CFArrayRef v5 = v4;
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i < v7; i += 2)
      {
        CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v5, i);
        CFStringRef v10 = (const __CFString *)CFArrayGetValueAtIndex(v5, i + 1);
        _CFStreamUnscheduleFromRunLoop(a1, ValueAtIndex, v10);
      }
    }
    CFRelease(v5);
  }
  if (a2)
  {
    if (_legacyStreamRunLoop_sOnce != -1) {
      dispatch_once(&_legacyStreamRunLoop_sOnce, &__block_literal_global_17);
    }
    _CFStreamScheduleWithRunLoop((char *)a1, (void *)sLegacyRL, @"kCFRunLoopDefaultMode");
    CFStringRef v11 = (pthread_mutex_t *)(a1 + 56);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(void *)(a1 + 32))
    {
      CFTypeRef v12 = *(NSObject **)(a1 + 128);
      if (v12 != a2)
      {
        if (v12) {
          dispatch_release(v12);
        }
        *(void *)(a1 + 128) = a2;
        dispatch_retain(a2);
      }
    }
  }
  else
  {
    CFStringRef v11 = (pthread_mutex_t *)(a1 + 56);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(void *)(a1 + 32))
    {
      unsigned int v13 = *(NSObject **)(a1 + 128);
      if (v13) {
        dispatch_release(v13);
      }
      *(void *)(a1 + 128) = 0;
    }
  }

  return pthread_mutex_unlock(v11);
}

uint64_t _CFStreamUnscheduleFromRunLoop(uint64_t result, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3 = *(void *)(result + 32);
  if (!v3 || !*(void *)(v3 + 56)) {
    return result;
  }
  uint64_t v6 = result;
  uint64_t v7 = *(void *)(result + 48);
  if ((*(unsigned char *)(result + 17) & 1) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(result + 56));
    uint64_t v8 = *(void *)(v6 + 32);
    if (v8 && (uint64_t v9 = *(__CFRunLoopSource **)(v8 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v8 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRunLoopRemoveSource(a2, v9, a3);
      CFRelease(v9);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
    }
    goto LABEL_24;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
  CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, (const void *)v6);
  CFArrayRef v11 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, Value);
  CFIndex Count = CFArrayGetCount(v11);
  v28.CFIndex location = 0;
  v28.CFIndex length = Count;
  FirstIndexOfCFDictionaryRef Value = CFArrayGetFirstIndexOfValue(v11, v28, (const void *)v6);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(v11, FirstIndexOfValue);
    --Count;
  }
  if (!Count)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
    uint64_t v14 = *(void *)(v6 + 32);
    if (v14 && (CFStringRef v15 = *(__CFRunLoopSource **)(v14 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v14 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRunLoopRemoveSource(a2, v15, a3);
      CFRelease(v15);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, Value);
  }
  CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, (const void *)v6);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
  uint64_t v16 = *(void *)(v6 + 32);
  if (v16)
  {
    int v17 = *(void **)(v16 + 56);
    if (v17)
    {
      CFRetain(*(CFTypeRef *)(v16 + 56));
      *(void *)(*(void *)(v6 + 32) + 56) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRelease(v17);
      if (!Count) {
        CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v17);
      }
      CFRelease(v17);
      goto LABEL_23;
    }
    *(void *)(v16 + 56) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
LABEL_23:
  *(void *)(v6 + 16) &= ~0x100uLL;
  os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
LABEL_24:
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
  uint64_t v18 = *(void *)(v6 + 32);
  CFArrayRef v19 = *(const __CFArray **)(v18 + 64);
  if (v19)
  {
    CFIndex v20 = CFArrayGetCount(*(CFArrayRef *)(v18 + 64));
    if (v20 >= 2)
    {
      CFIndex v21 = v20;
      CFIndex v22 = 1;
      while (1)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v19, v22 - 1);
        if (CFEqual(ValueAtIndex, a2))
        {
          uint64_t v24 = CFArrayGetValueAtIndex(v19, v22);
          if (CFEqual(v24, a3)) {
            break;
          }
        }
        v22 += 2;
        if (v22 >= v21) {
          goto LABEL_32;
        }
      }
      CFArrayRemoveValueAtIndex(v19, v22 - 1);
      CFArrayRemoveValueAtIndex(v19, v22 - 1);
    }
  }
LABEL_32:
  CFTypeRef result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
  if (v7)
  {
    int v25 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, uint64_t))(v7 + 128);
    if (v25)
    {
      uint64_t v26 = *(void *)(v6 + 40);
      return v25(v6, a2, a3, v26);
    }
  }
  return result;
}

void __CFFileDescriptorEnableCallBacks_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 16))
  {
    if ((*(unsigned char *)(a1 + 40) & 1) != 0 && *(void *)(v1 + 32))
    {
      BOOL is_readable = cffd_is_readable(*(_DWORD *)(v1 + 20));
      uint64_t v4 = *(void *)(a1 + 32);
      if (is_readable)
      {
        *(unsigned char *)(v4 + 5CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 1;
        if (!*(unsigned char *)(v4 + 48))
        {
          dispatch_suspend(*(dispatch_object_t *)(v4 + 32));
          uint64_t v4 = *(void *)(a1 + 32);
          *(unsigned char *)(v4 + 48) = 1;
        }
        CFArrayRef v5 = *(__CFRunLoopSource **)(v4 + 56);
        if (v5)
        {
          CFRunLoopSourceSignal(v5);
          _CFRunLoopSourceWakeUpRunLoops(*(void *)(*(void *)(a1 + 32) + 56));
        }
      }
      else if (*(unsigned char *)(v4 + 48))
      {
        *(unsigned char *)(v4 + 48) = 0;
        dispatch_resume(*(dispatch_object_t *)(v4 + 32));
      }
    }
    if ((*(unsigned char *)(a1 + 40) & 2) != 0)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      if (*(void *)(v6 + 40))
      {
        BOOL is_writeable = cffd_is_writeable(*(_DWORD *)(v6 + 20));
        uint64_t v8 = *(void *)(a1 + 32);
        if (is_writeable)
        {
          *(unsigned char *)(v8 + 51) = 1;
          if (!*(unsigned char *)(v8 + 49))
          {
            dispatch_suspend(*(dispatch_object_t *)(v8 + 40));
            uint64_t v8 = *(void *)(a1 + 32);
            *(unsigned char *)(v8 + 49) = 1;
          }
          uint64_t v9 = *(__CFRunLoopSource **)(v8 + 56);
          if (v9)
          {
            CFRunLoopSourceSignal(v9);
            uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 56);
            _CFRunLoopSourceWakeUpRunLoops(v10);
          }
        }
        else if (*(unsigned char *)(v8 + 49))
        {
          *(unsigned char *)(v8 + 49) = 0;
          CFArrayRef v11 = *(NSObject **)(v8 + 40);
          dispatch_resume(v11);
        }
      }
    }
  }
}

BOOL cffd_is_readable(unsigned int a1)
{
  if (a1 >= 0x100000) {
    __break(1u);
  }
  size_t v2 = ((a1 + 8) >> 3) + 7;
  uint64_t v3 = malloc_type_malloc(v2, 0x56647412uLL);
  int v4 = 1 << a1;
  uint64_t v5 = a1 >> 5;
  while (1)
  {
    bzero(v3, v2);
    if (__darwin_check_fd_set_overflow(a1, v3, 1)) {
      *((_DWORD *)v3 + v5) |= v4;
    }
    int v6 = pselect_DARWIN_EXTSN();
    if ((v6 & 0x80000000) == 0) {
      break;
    }
    if (*__error() != 4 && *__error() != 35) {
      goto LABEL_12;
    }
  }
  if (v6 && __darwin_check_fd_set_overflow(a1, v3, 1))
  {
    BOOL v7 = (*((_DWORD *)v3 + v5) & v4) != 0;
    goto LABEL_13;
  }
LABEL_12:
  BOOL v7 = 0;
LABEL_13:
  free(v3);
  return v7;
}

CFTypeRef _fs_retain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void _CFRunLoopSourceWakeUpRunLoops(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  uint64_t v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 8) != 0 && (CFBagRef v5 = *(const __CFBag **)(a1 + 96)) != 0)
  {
    CFBagRef Copy = CFBagCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
    pthread_mutex_unlock(v3);
    if (Copy)
    {
      CFBagApplyFunction(Copy, (CFBagApplierFunction)__CFRunLoopSourceWakeUpLoop, 0);
      CFRelease(Copy);
    }
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
}

void CFMachPortInvalidate(CFMachPortRef port)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (CF_IS_OBJC(0x24uLL, (unint64_t)port))
    {
      [(__CFMachPort *)port invalidate];
    }
    else
    {
      CFRetain(port);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMachPortsLock);
      os_unfair_lock_lock((os_unfair_lock_t)port + 24);
      int v2 = *((_DWORD *)port + 4);
      if (v2)
      {
        uint64_t v3 = 0;
      }
      else
      {
        *((_DWORD *)port + 4) = 1;
        __dmb(0xBu);
        if (__CFAllMachPorts)
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)__CFAllMachPorts);
          if (Count >= 1)
          {
            CFIndex v5 = Count;
            CFIndex v6 = 0;
            while (CFArrayGetValueAtIndex((CFArrayRef)__CFAllMachPorts, v6) != port)
            {
              if (v5 == ++v6) {
                goto LABEL_20;
              }
            }
            CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFAllMachPorts, v6);
          }
        }
LABEL_20:
        BOOL v7 = *((void *)port + 3);
        if (v7)
        {
          dispatch_source_cancel(v7);
          *((void *)port + 3) = 0;
        }
        uint64_t v3 = (__CFRunLoopSource *)*((void *)port + 5);
        *((void *)port + 5) = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
      if (!v2)
      {
        os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        uint64_t v8 = (void (*)(CFMachPortRef, uint64_t))*((void *)port + 4);
        uint64_t v9 = *((void *)port + 8);
        uint64_t v10 = (void (*)(uint64_t))*((void *)port + 14);
        *((void *)port + 8) = 0;
        if (v8)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          v8(port, v9);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }
        if (v3)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          CFRunLoopSourceInvalidate(v3);
          CFRelease(v3);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }
        if (v10 && v9)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          v10(v9);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }
        *((_DWORD *)port + 4) = 2;
        __dmb(0xBu);
        os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
      }
      CFRelease(port);
    }
  }
}

double __CFRunLoopSourceDeallocate(uint64_t a1)
{
  CFRunLoopSourceInvalidate((CFRunLoopSourceRef)a1);
  int v2 = *(void (**)(void))(a1 + 128);
  if (v2) {
    v2(*(void *)(a1 + 112));
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0u;
  *(void *)(a1 + 176) = 0;
  return result;
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
  context[2] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)source);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
  CFRetain(source);
  char v3 = atomic_load((unint64_t *)source + 1);
  if ((v3 & 8) != 0)
  {
    CFBagRef v4 = (const __CFBag *)*((void *)source + 12);
    unint64_t v5 = atomic_load((unint64_t *)source + 1);
    unint64_t v6 = v5;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)source + 1, &v6, v5 & 0xFFFFFFFFFFFFFFF7);
      BOOL v7 = v6 == v5;
      unint64_t v5 = v6;
    }
    while (!v7);
    atomic_store(0, (unint64_t *)source + 11);
    if (v4)
    {
      *((void *)source + 12) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
      context[0] = source;
      context[1] = 0;
      CFBagApplyFunction(v4, (CFBagApplierFunction)__CFRunLoopSourceRemoveFromRunLoop, context);
      CFRelease(v4);
      pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
  CFRelease(source);
}

void CFBagApplyFunction(CFBagRef theBag, CFBagApplierFunction applier, void *context)
{
  void v3[6] = *(void *)off_1ECE0A5B0;
  v3[0] = off_1ECE0A5A0;
  v3[1] = 3221225472;
  v3[2] = __CFBagApplyFunction_block_invoke;
  v3[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
  v3[4] = applier;
  void v3[5] = context;
  CFBasicHashApply((uint64_t)theBag, (uint64_t)v3);
}

CFBagRef CFBagCreateCopy(CFAllocatorRef allocator, CFBagRef theBag)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(4uLL, (unint64_t)theBag))
  {
    uint64_t Count = CFBasicHashGetCount((uint64_t)theBag);
    memset(v14, 0, 512);
    if (Count >= 257) {
      uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    }
    else {
      uint64_t Typed = v14;
    }
    uint64_t v7 = CFBasicHashGetCount((uint64_t)theBag);
    CFBasicHashGetElements((uint64_t)theBag, v7, 0, (uint64_t)Typed);
    uint64_t Generic = __CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)&kCFTypeBagCallBacks);
    CFBagRef Copy = (unint64_t *)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (uint64_t i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, *((void *)Typed + i), *((void *)Typed + i));
    }
    if (Count >= 257) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  else
  {
    CFBagRef Copy = (unint64_t *)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theBag);
  }
  if (Copy)
  {
    unint64_t v10 = atomic_load(Copy + 1);
    unint64_t v11 = v10;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Copy + 1, &v11, v10 | 0x40);
      BOOL v12 = v11 == v10;
      unint64_t v10 = v11;
    }
    while (!v12);
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 4uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return (CFBagRef)Copy;
}

void fileUnschedule(void *a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == CFReadStreamGetTypeID()) {
    CFStreamStatus Status = CFReadStreamGetStatus((CFReadStreamRef)a1);
  }
  else {
    CFStreamStatus Status = CFWriteStreamGetStatus((CFWriteStreamRef)a1);
  }
  CFArrayRef v10 = *(const __CFArray **)(a4 + 16);
  if (Status)
  {
    if (!v10) {
      return;
    }
    if ((*(unsigned char *)(a4 + 24) & 0x20) == 0)
    {
      CFAllocatorRef v11 = CFGetAllocator(a1);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v11, *(CFFileDescriptorRef *)(a4 + 16), 0);
      CFRunLoopRemoveSource(a2, RunLoopSource, a3);
      CFRelease(RunLoopSource);
      return;
    }
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a4 + 16));
    if (Count < 2) {
      return;
    }
    CFIndex v20 = Count;
    CFIndex v21 = 1;
    while (1)
    {
      CFIndex v16 = v21 - 1;
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v21 - 1);
      if (CFEqual(ValueAtIndex, a2))
      {
        unsigned int v23 = CFArrayGetValueAtIndex(v10, v21);
        if (CFEqual(v23, a3)) {
          break;
        }
      }
      v21 += 2;
      if (v21 >= v20) {
        return;
      }
    }
  }
  else
  {
    if (!v10) {
      return;
    }
    CFIndex v13 = CFArrayGetCount(*(CFArrayRef *)(a4 + 16));
    if (v13 < 2) {
      return;
    }
    CFIndex v14 = v13;
    CFIndex v15 = 1;
    while (1)
    {
      CFIndex v16 = v15 - 1;
      int v17 = CFArrayGetValueAtIndex(v10, v15 - 1);
      if (CFEqual(v17, a2))
      {
        uint64_t v18 = CFArrayGetValueAtIndex(v10, v15);
        if (CFEqual(v18, a3)) {
          break;
        }
      }
      v15 += 2;
      if (v15 >= v14) {
        return;
      }
    }
  }
  CFArrayRemoveValueAtIndex(v10, v16);

  CFArrayRemoveValueAtIndex(v10, v16);
}

void boundPairWriteUnschedule(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    int v4 = *(__int16 *)(a4 + 52);
    BOOL v5 = __OFSUB__(v4, 1);
    int v6 = v4 - 1;
    if (v6 < 0 == v5) {
      *(_WORD *)(a4 + 52) = v6;
    }
  }
}

void CFFileDescriptorInvalidate(CFFileDescriptorRef f)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    CFRetain(f);
    uint64_t v12 = 0;
    CFIndex v13 = &v12;
    uint64_t v14 = 0x2000000000;
    uint64_t v15 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000;
    char v11 = 0;
    char v3 = __fdQueue();
    v7[0] = off_1ECE0A5A0;
    v7[1] = 0x40000000;
    v7[2] = __CFFileDescriptorInvalidate_block_invoke;
    _OWORD v7[3] = &unk_1ECDAC000;
    uint64_t v7[5] = &v12;
    void v7[6] = f;
    void v7[4] = &v8;
    dispatch_sync(v3, v7);
    if (*((unsigned char *)v9 + 24))
    {
      int v4 = (__CFRunLoopSource *)v13[3];
      if (v4)
      {
        CFRunLoopSourceInvalidate(v4);
        CFRelease((CFTypeRef)v13[3]);
      }
      uint64_t v5 = *((void *)f + 10);
      *((void *)f + 1CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
      int v6 = (void (*)(uint64_t))*((void *)f + 12);
      if (v6) {
        v6(v5);
      }
      *((_DWORD *)f + 4) = 2;
      __dmb(0xBu);
    }
    CFRelease(f);
    _Block_object_dispose(&v8, 8);
    _Block_object_dispose(&v12, 8);
  }
}

void sub_182C74E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

void __CFFileDescriptorCreate_block_invoke(uint64_t a1)
{
  handler[6] = *(void *)off_1ECE0A5B0;
  unint64_t v2 = *(__objc2_class ***)(a1 + 40);
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v2, 0x3CuLL, 96, 0);
  if (Instance)
  {
    uint64_t v4 = Instance;
    if (*(unsigned char *)(a1 + 76))
    {
      unint64_t v5 = atomic_load((unint64_t *)(Instance + 8));
      unint64_t v6 = v5;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v6, v5 | 2);
        BOOL v7 = v6 == v5;
        unint64_t v5 = v6;
      }
      while (!v7);
    }
    *(_DWORD *)(Instance + 2CFNotificationCenterRemoveObserver(center, observer, 0, 0) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(Instance + 24) = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(Instance + 28) = *(_DWORD *)(a1 + 72);
    *(void *)(Instance + 32) = 0;
    *(void *)(Instance + 4CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
    uintptr_t v8 = *(unsigned int *)(a1 + 68);
    if ((v8 & 0x80000000) == 0)
    {
      uint64_t v9 = __fdQueue();
      uint64_t v10 = dispatch_source_create((dispatch_source_type_t)off_1ECE0A610, v8, 0, v9);
      handler[0] = off_1ECE0A5A0;
      handler[1] = 0x40000000;
      handler[2] = __CFFileDescriptorCreate_block_invoke_2;
      handler[3] = &__block_descriptor_tmp_2;
      handler[4] = v4;
      void handler[5] = v10;
      dispatch_source_set_event_handler(v10, handler);
      v23[0] = off_1ECE0A5A0;
      v23[1] = 0x40000000;
      v23[2] = __CFFileDescriptorCreate_block_invoke_3;
      v23[3] = &__block_descriptor_tmp_3;
      v23[4] = v10;
      int v24 = *(_DWORD *)(a1 + 68);
      dispatch_source_set_cancel_handler(v10, v23);
      *(void *)(v4 + 32) = v10;
    }
    uintptr_t v11 = *(unsigned int *)(a1 + 72);
    if ((v11 & 0x80000000) == 0)
    {
      uint64_t v12 = __fdQueue();
      CFIndex v13 = dispatch_source_create((dispatch_source_type_t)off_1ECE0A628, v11, 0, v12);
      v22[0] = off_1ECE0A5A0;
      v22[1] = 0x40000000;
      v22[2] = __CFFileDescriptorCreate_block_invoke_4;
      void v22[3] = &__block_descriptor_tmp_4;
      v22[4] = v4;
      v22[5] = v13;
      dispatch_source_set_event_handler(v13, v22);
      v20[0] = off_1ECE0A5A0;
      v20[1] = 0x40000000;
      v20[2] = __CFFileDescriptorCreate_block_invoke_5;
      v20[3] = &__block_descriptor_tmp_5;
      v20[4] = v13;
      int v21 = *(_DWORD *)(a1 + 72);
      dispatch_source_set_cancel_handler(v13, v20);
      *(void *)(v4 + 4CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v13;
    }
    *(_WORD *)(v4 + 48) = 257;
    *(void *)(v4 + 64) = *(void *)(a1 + 48);
    uint64_t v14 = *(long long **)(a1 + 56);
    if (v14)
    {
      long long v15 = *v14;
      long long v16 = v14[1];
      *(void *)(v4 + 104) = *((void *)v14 + 4);
      *(_OWORD *)(v4 + 88) = v16;
      *(_OWORD *)(v4 + 72) = v15;
      uint64_t v17 = *(void *)(a1 + 56);
      uint64_t v18 = *(void *)(v17 + 8);
      CFArrayRef v19 = *(uint64_t (**)(uint64_t))(v17 + 16);
      if (v19) {
        uint64_t v18 = v19(v18);
      }
      *(void *)(v4 + 8CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v18;
    }
    *(_DWORD *)(v4 + 16) = 0;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  }
}

void CFFileDescriptorEnableCallBacks(CFFileDescriptorRef f, CFOptionFlags callBackTypes)
{
  block[6] = *(void *)off_1ECE0A5B0;
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    unint64_t v5 = __fdQueue();
    block[0] = off_1ECE0A5A0;
    block[1] = 0x40000000;
    block[2] = __CFFileDescriptorEnableCallBacks_block_invoke;
    block[3] = &__block_descriptor_tmp_8;
    void block[4] = f;
    void block[5] = callBackTypes;
    dispatch_sync(v5, block);
  }
}

void __CFFileDescriptorPerform(uint64_t a1)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v22 = 0;
    unsigned int v23 = &v22;
    uint64_t v24 = 0x2000000000;
    char v25 = 0;
    uint64_t v18 = 0;
    CFArrayRef v19 = &v18;
    uint64_t v20 = 0x2000000000;
    char v21 = 0;
    uint64_t v14 = 0;
    long long v15 = &v14;
    uint64_t v16 = 0x2000000000;
    char v17 = 0;
    uint64_t v10 = 0;
    uintptr_t v11 = &v10;
    uint64_t v12 = 0x2000000000;
    uint64_t v13 = 0;
    uint64_t v6 = 0;
    BOOL v7 = &v6;
    uint64_t v8 = 0x2000000000;
    uint64_t v9 = 0;
    unint64_t v2 = __fdQueue();
    block[0] = off_1ECE0A5A0;
    block[1] = 0x40000000;
    block[2] = ____CFFileDescriptorPerform_block_invoke;
    block[3] = &unk_1ECDAC078;
    void block[4] = &v14;
    void block[5] = &v22;
    block[6] = &v18;
    void block[7] = &v10;
    block[8] = &v6;
    void block[9] = a1;
    dispatch_sync(v2, block);
    if (*((unsigned char *)v15 + 24) && (*((unsigned char *)v23 + 24) || *((unsigned char *)v19 + 24)))
    {
      char v3 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
      if (v3) {
        v3(a1, (*((unsigned char *)v23 + 24) != 0) | (2 * (*((unsigned char *)v19 + 24) != 0)), v11[3]);
      }
      unint64_t v4 = (void (*)(uint64_t))v7[3];
      if (v4) {
        v4(v11[3]);
      }
      if ((__CF_FORK_STATE & 2) == 0) {
        __CF_USED();
      }
      if (__CF_FORK_STATE) {
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
      }
    }
    _Block_object_dispose(&v6, 8);
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v14, 8);
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }
}

void sub_182C75444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v28 - 136), 8);
  _Block_object_dispose((const void *)(v28 - 104), 8);
  _Unwind_Resume(a1);
}

uint64_t __fdQueue()
{
  if (!__fdQueue___fddq)
  {
    uint64_t v0 = dispatch_queue_create("com.apple.CFFileDescriptor", 0);
    uint64_t v1 = 0;
    atomic_compare_exchange_strong(&__fdQueue___fddq, (unint64_t *)&v1, (unint64_t)v0);
    if (v1) {
      dispatch_release(v0);
    }
  }
  return __fdQueue___fddq;
}

void _fs_release(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void fileCallBack(int a1, uint64_t a2, void *cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFReadStreamGetTypeID())
    {
      uint64_t InfoPointer = CFReadStreamGetInfoPointer((uint64_t)cf);
      if (!InfoPointer) {
        return;
      }
    }
    else
    {
      uint64_t InfoPointer = CFWriteStreamGetInfoPointer((uint64_t)cf);
      if (!InfoPointer) {
        return;
      }
    }
    uint64_t v12 = *(void *)(InfoPointer + 24);
    if (a2 == 2)
    {
      *(void *)(InfoPointer + 24) = v12 | 1;
      CFWriteStreamSignalEvent((char *)cf, 4uLL, 0, v7, v8, v9, v10, v11);
    }
    else
    {
      *(void *)(InfoPointer + 24) = v12 | 2;
      CFReadStreamSignalEvent((char *)cf, 2uLL, 0, v7, v8, v9, v10, v11);
    }
  }
}

uint64_t __CFNotificationCenterGetDistributedCenter_block_invoke()
{
  uint64_t result = _CFXNotificationCenterCreate(&__kCFAllocatorSystemDefault, _kCFXNotificationConfigurationStandardDistributedConfiguration);
  __hostCenter = result;
  return result;
}

__CFArray *_CFBundleDYLDCopyLoadedImagePathsForHint(const __CFString *a1)
{
  uint64_t v32 = *(void *)off_1ECE0A5B0;
  uint32_t v2 = _dyld_image_count();
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t Length = CFStringGetLength(a1);
  result.uint64_t location = 0;
  result.CFIndex length = 0;
  unint64_t v4 = _CFProcessPath();
  CFTypeID v5 = _NSGetMachExecuteHeader();
  uint64_t location = 0;
  if (Length >= 15)
  {
    v33.uint64_t location = 0;
    v33.CFIndex length = Length;
    if (!CFStringFindWithOptions(a1, @".framework", v33, 0xDuLL, &result)
      || (uint64_t location = result.location, result.location < 1)
      || result.length <= 0)
    {
      v34.uint64_t location = 0;
      v34.CFIndex length = Length;
      if (!CFStringFindWithOptions(a1, @"framework", v34, 0xDuLL, &result)
        || (uint64_t location = result.location, result.location < 1)
        || result.length <= 0)
      {
        v35.uint64_t location = 0;
        v35.CFIndex length = Length;
        int v7 = CFStringFindWithOptions(a1, @"fw", v35, 0xDuLL, &result);
        if (result.length <= 0 || result.location <= 0 || v7 == 0) {
          uint64_t location = 0;
        }
        else {
          uint64_t location = result.location;
        }
      }
    }
  }
  if (v2)
  {
    uint32_t v10 = 0;
    uint32_t v28 = v2;
    uint64_t v26 = v5;
    int v27 = v4;
    do
    {
      image_mach_port_name_t name = _dyld_get_image_name(v10);
      uint64_t v12 = _CFBundleNormalizedPath(image_name);
      if (v12)
      {
        uint64_t v13 = (char *)v12;
        if ((!v4 || strcmp(v12, v4)) && v5 != (mach_header_64 *)_dyld_get_image_header(v10))
        {
          uint64_t v14 = strrchr(v13, 47);
          if (v14)
          {
            CFStringRef v15 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14 + 1);
            if (v15)
            {
              CFStringRef v16 = v15;
              char v17 = __CFgetenvIfNotRestricted("DYLD_IMAGE_SUFFIX");
              CFStringRef cf = v16;
              uint64_t v18 = _CFBundleDYLDCreateLoadedImagePathVariants(v17, v16);
              CFIndex Count = CFArrayGetCount(v18);
              if (Count >= 1)
              {
                CFIndex v20 = Count;
                for (CFIndex i = 0; i != v20; ++i)
                {
                  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, i);
                  v36.uint64_t location = 0;
                  v36.CFIndex length = Length;
                  if (!CFStringFindWithOptions(a1, ValueAtIndex, v36, 0xDuLL, 0))
                  {
                    if (location < 1) {
                      continue;
                    }
                    v37.uint64_t location = 0;
                    v37.CFIndex length = location;
                    if (!CFStringFindWithOptions(a1, ValueAtIndex, v37, 0xDuLL, 0)) {
                      continue;
                    }
                  }
                  CFStringRef v23 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
                  if (v23)
                  {
                    CFStringRef v24 = v23;
                    CFArrayAppendValue(theArray, v23);
                    CFRelease(v24);
                  }
                }
              }
              CFRelease(v18);
              CFRelease(cf);
              uint32_t v2 = v28;
              CFTypeID v5 = v26;
              unint64_t v4 = v27;
            }
          }
        }
      }
      ++v10;
    }
    while (v10 != v2);
  }
  return theArray;
}

const char *_CFBundleNormalizedPath(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!strncmp(result, "/private/preboot/Cryptexes/OS/", 0x1EuLL))
    {
      return v1 + 29;
    }
    else
    {
      int v2 = strncmp(v1, "/System/Cryptexes/OS/", 0x15uLL);
      uint64_t v3 = 20;
      if (v2) {
        uint64_t v3 = 0;
      }
      return &v1[v3];
    }
  }
  return result;
}

char *__CFgetenvIfNotRestricted(char *a1)
{
  if (issetugid()) {
    return 0;
  }

  return __CFgetenv(a1);
}

void __CFInitialize()
{
  v22[1] = *(void *)off_1ECE0A5B0;
  if (!__CFInitialized && (__CFInitializing & 1) == 0)
  {
    uint64_t v0 = 0;
    __CFInitializing = 1;
    __CFProphylacticAutofsAccess = 1;
    do
    {
      uint64_t v1 = (&__CFEnv)[v0];
      if (v1)
      {
        int v2 = getenv(v1);
        if (v2) {
          (&__CFEnv)[v0 + 1] = v2;
        }
      }
      v0 += 2;
    }
    while (v0 != 22);
    __exceptionInit();
    objc_setForwardHandler(_CF_forwarding_prep_0, 0);
    objc_setEnumerationMutationHandler((void (__cdecl *)(id))__NSFastEnumerationMutationHandler);
    v22[0] = 0;
    _CFStringGetUserDefaultEncoding((_DWORD *)v22 + 1, v22);
    pthread_atfork((void (*)(void))__cf_atfork_prepare, 0, __cf_atfork_child);
    uint64_t v3 = getenv("NSObjCMessageLoggingEnabled");
    if (v3 && (*v3 | 0x20) == 0x79) {
      instrumentObjcMessageSends();
    }
    _CFRuntimeBridgeClasses(0, "__NSCFType");
    unint64_t v4 = &qword_1EB1DDD98;
    uint64_t v5 = 1;
    uint64_t v6 = __CFRuntimeBuiltinObjCClassTable[0];
    do
    {
      __CFRuntimeBuiltinObjCClassTable[v5++] = v6;
      ++v4;
    }
    while (v5 != 72);
    _CFRuntimeBridgeClasses(7uLL, "__NSCFString");
    _CFRuntimeBridgeClasses(0x10uLL, "NSNull");
    _CFRuntimeBridgeClasses(0x11uLL, "__NSCFSet");
    _CFRuntimeBridgeClasses(0x12uLL, "__NSCFDictionary");
    _CFRuntimeBridgeClasses(0x13uLL, "__NSCFArray");
    _CFRuntimeBridgeClasses(0x14uLL, "__NSCFData");
    _CFRuntimeBridgeClasses(0x15uLL, "__NSCFBoolean");
    _CFRuntimeBridgeClasses(0x16uLL, "__NSCFNumber");
    CFNumberGetTypeID();
    __CFCharacterSetInitialize();
    CFTypeID TypeID = CFMachPortGetTypeID();
    _CFRuntimeBridgeClasses(TypeID, "NSMachPort");
    CFTypeID v8 = CFURLGetTypeID();
    _CFRuntimeBridgeClasses(v8, "NSURL");
    CFTypeID v9 = CFRunLoopTimerGetTypeID();
    _CFRuntimeBridgeClasses(v9, "__NSCFTimer");
    CFTypeID v10 = CFAttributedStringGetTypeID();
    _CFRuntimeBridgeClasses(v10, "__NSCFAttributedString");
    CFTypeID v11 = CFLocaleGetTypeID();
    _CFRuntimeBridgeClasses(v11, "__NSCFLocale");
    CFTypeID v12 = CFErrorGetTypeID();
    _CFRuntimeBridgeClasses(v12, "__NSCFError");
    CFTypeID v13 = CFCharacterSetGetTypeID();
    _CFRuntimeBridgeClasses(v13, "__NSCFCharacterSet");
    CFTypeID v14 = CFReadStreamGetTypeID();
    _CFRuntimeBridgeClasses(v14, "__NSCFInputStream");
    CFTypeID v15 = CFWriteStreamGetTypeID();
    _CFRuntimeBridgeClasses(v15, "__NSCFOutputStream");
    _CFProcessPath();
    *(void *)off_1ECE0A5C8 = _CFAutoreleasePoolPush;
    *(void *)off_1ECE0A5D8 = _CFAutoreleasePoolPop;
    __CFOAInitialize();
    __CFStringInitializeSystemEncoding();
    __CFMakeNSBlockClasses();
    CFStringRef v16 = getenv("NSZombieEnabled");
    if (v16 && (*v16 | 0x20) == 0x79 && !__CFZombieEnabled)
    {
      __CFZombieEnabled = -1;
      __CFZombifyNSObject();
    }
    char v17 = getenv("NSDeallocateZombies");
    if (v17 && (*v17 | 0x20) == 0x79) {
      __CFDeallocateZombies = -1;
    }
    __CFProphylacticAutofsAccess = 0;
    _os_log_set_nscf_formatter();
    uint64_t v18 = _CFGetHandleForInsertedOrInterposingLibrary("libclang_rt.tsan");
    if (v18)
    {
      CFArrayRef v19 = v18;
      __cf_tsanRegisterTagFunction = (uint64_t (*)(void))dlsym(v18, "__tsan_external_register_tag");
      __cf_tsanAssignTagFunction = (uint64_t (*)(void))dlsym(v19, "__tsan_external_assign_tag");
      __cf_tsanReadFunction = (uint64_t (*)(void, void, void))dlsym(v19, "__tsan_external_read");
      CFIndex v20 = dlsym(v19, "__tsan_external_write");
      __cf_tsanWriteFunction = (uint64_t (*)(void, void, void))v20;
      if (!__cf_tsanRegisterTagFunction
        || !__cf_tsanAssignTagFunction
        || !__cf_tsanReadFunction
        || !v20
        || (__CFTSANTagMutableArray = __cf_tsanRegisterTagFunction("NSMutableArray"),
            __CFTSANTagMutableDictionary = __cf_tsanRegisterTagFunction("NSMutableDictionary"),
            __CFTSANTagMutableSet = __cf_tsanRegisterTagFunction("NSMutableSet"),
            __CFTSANTagMutableOrderedSet = __cf_tsanRegisterTagFunction("NSMutableOrderedSet"),
            uint64_t v21 = __cf_tsanRegisterTagFunction("NSMutableData"),
            __CFTSANTagMutableCFDataRef Data = v21,
            !__CFTSANTagMutableArray)
        || !__CFTSANTagMutableDictionary
        || !__CFTSANTagMutableSet
        || !__CFTSANTagMutableOrderedSet
        || !v21)
      {
        __cf_tsanRegisterTagFunction = 0;
        __cf_tsanAssignTagFunction = 0;
        __cf_tsanReadFunction = 0;
        __cf_tsanWriteFunction = 0;
        __CFTSANTagMutableArray = 0;
        __CFTSANTagMutableDictionary = 0;
        __CFTSANTagMutableSet = 0;
        __CFTSANTagMutableOrderedSet = 0;
        __CFTSANTagMutableCFDataRef Data = 0;
      }
    }
    __CFInitializing = 0;
    __CFInitialized = 1;
  }
}

CFTypeID CFLocaleGetTypeID(void)
{
  return 55;
}

void _CFRuntimeBridgeClasses(unint64_t a1, const char *a2)
{
  os_unfair_lock_lock_with_options();
  if (a1 > 0x47)
  {
    uint64_t v6 = __CFRuntimeClassTables[(((int)a1 - 72) >> 6) + 16];
    FutureClass Class = objc_getFutureClass(a2);
    uint64_t v5 = (uint64_t *)(v6 + 8 * ((a1 - 72) & 0x3F));
  }
  else
  {
    FutureClass Class = objc_getFutureClass(a2);
    uint64_t v5 = &__CFRuntimeBuiltinObjCClassTable[a1];
  }
  *uint64_t v5 = (uint64_t)FutureClass;

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
}

uint64_t fileOpen(void *a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  CFTypeID v8 = CFGetTypeID(a1);
  CFTypeID TypeID = CFReadStreamGetTypeID();
  BOOL v10 = v8 == TypeID;
  *a3 = 1;
  if (!*(void *)a4)
  {
    if (*(void *)(a4 + 16)) {
      constructCFFD(a4, v10, a1);
    }
    return 1;
  }
  if (!CFURLGetFileSystemRepresentation(*(CFURLRef *)a4, 1u, buffer, 1026))
  {
    int v14 = 2;
    goto LABEL_19;
  }
  if (v8 == TypeID) {
    int v11 = 0;
  }
  else {
    int v11 = 1537;
  }
  if ((*(void *)(a4 + 24) & 8) != 0) {
    int v12 = open((const char *)buffer, v11 & 0x3F7 | 8, 438);
  }
  else {
    int v12 = open((const char *)buffer, v11, 438);
  }
  *(_DWORD *)(a4 + 8) = v12;
  if ((v12 & 0x80000000) == 0)
  {
    off_t v13 = *(void *)(a4 + 32);
    if ((v13 == -1 || lseek(v12, v13, 0) != -1) && (!*(void *)(a4 + 16) || constructCFFD(a4, v10, a1))) {
      return 1;
    }
  }
  *(void *)(a4 + 24) |= 0x20uLL;
  int v14 = *__error();
LABEL_19:
  uint64_t result = 0;
  *(_DWORD *)(a2 + 8) = v14;
  *(void *)a2 = 1;
  return result;
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return 38;
}

uint64_t __CFNotificationCenterGetDarwinNotifyCenter_block_invoke()
{
  uint64_t result = _CFXNotificationCenterCreate(&__kCFAllocatorSystemDefault, _kCFXNotificationConfigurationStandardDarwinConfiguration);
  __darwinCenter = result;
  return result;
}

uint64_t __CFNotificationCenterGetLocalCenter_block_invoke()
{
  uint64_t result = _CFXNotificationCenterCreate(&__kCFAllocatorSystemDefault, _kCFXNotificationConfigurationStandardLocalConfiguration);
  __taskCenter = result;
  return result;
}

uint64_t _CFXNotificationCenterCreate(__objc2_class **a1, int *a2)
{
  v26[5] = *(void *)off_1ECE0A5B0;
  if (*a2 != 1) {
    goto LABEL_7;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
LABEL_7:
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x34uLL, 16, 0);
  uint64_t v5 = Instance;
  if (Instance)
  {
    int v6 = *a2;
    if (*a2 == 1)
    {
      unint64_t v7 = atomic_load((unint64_t *)(Instance + 8));
      unint64_t v8 = v7;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v8, v7 | 2);
        BOOL v9 = v8 == v7;
        unint64_t v7 = v8;
      }
      while (!v9);
      int v6 = *a2;
    }
    if (v6 == 2)
    {
      unint64_t v10 = atomic_load((unint64_t *)(Instance + 8));
      unint64_t v11 = v10;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v11, v10 | 1);
        BOOL v9 = v11 == v10;
        unint64_t v10 = v11;
      }
      while (!v9);
    }
    unint64_t v12 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v13 = v12;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v13, v12 & 0xFFFFFFFFFFFFFFF7);
      BOOL v9 = v13 == v12;
      unint64_t v12 = v13;
    }
    while (!v9);
    if ((*a2 - 1) >= 2) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = 2;
    }
    CFXNotificationRegistrarCreate(&__kCFAllocatorSystemDefault, v14);
    *(void *)(v5 + 16) = v15;
    if (*a2 == 1)
    {
      CFStringRef v16 = _CFProcessPath();
      if (v16)
      {
        if (!strcmp("/usr/sbin/distnoted", v16)) {
          __CFIsDistNoteDaemon = 1;
        }
      }
    }
    *(void *)(v5 + 24) = 0;
    if (*a2 == 1 && (__CFIsDistNoteDaemon & 1) == 0)
    {
      uint64_t v17 = (_xpc_endpoint_s *)*((void *)a2 + 4);
      uint64_t v18 = (const char *)*((void *)a2 + 2);
      int v19 = *((unsigned __int8 *)a2 + 9);
      qos_class_t v20 = qos_class_main();
      uint64_t v21 = dispatch_queue_attr_make_with_qos_class(0, v20, 0);
      uint64_t v22 = dispatch_queue_create("com.apple.notification_center.server_conn", v21);
      if (v17)
      {
        CFStringRef v23 = xpc_connection_create_from_endpoint(v17);
        *(void *)(v5 + 24) = v23;
        xpc_connection_set_target_queue(v23, v22);
      }
      else
      {
        *(void *)(v5 + 24) = xpc_connection_create_mach_service(v18, v22, 2 * (v19 != 0));
      }
      dispatch_release(v22);
      CFStringRef v24 = *(_xpc_connection_s **)(v5 + 24);
      v26[0] = off_1ECE0A5A0;
      v26[1] = 3221225472;
      v26[2] = ____CFXNotificationCenterSetupConnection_block_invoke;
      v26[3] = &__block_descriptor_40_e33_v16__0__NSObject_OS_xpc_object__8l;
      v26[4] = v5;
      xpc_connection_set_event_handler(v24, v26);
      xpc_connection_activate(*(xpc_connection_t *)(v5 + 24));
    }
  }
  return v5;
}

void CFXNotificationRegistrarCreate(__objc2_class **a1, uint64_t a2)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x46uLL, 160, 0);
  *(void *)(Instance + 24) = a2;
  *(_DWORD *)(Instance + 16) = 0;
  *(_DWORD *)(Instance + 112) = -1;
  *(_DWORD *)(Instance + 136) = -1;
  *(_DWORD *)(Instance + 16CFNotificationCenterRemoveObserver(center, observer, 0, 0) = -1;
  *(_DWORD *)(Instance + 8CFNotificationCenterRemoveObserver(center, observer, 0, 0) = -1;
  atomic_store(1u, (unsigned int *)(Instance + 168));
}

const char *_CFProcessPath()
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  uint64_t result = (const char *)__CFProcessPath;
  if (!__CFProcessPath)
  {
    getpid();
    bufsize[1] = 0;
    bufsize[0] = 1026;
    uint64_t v1 = csops();
    MEMORY[0x1F4188790](v1, v2);
    if (!_NSGetExecutablePath(v6, bufsize))
    {
      uint64_t v3 = strdup(v6);
      __CFProcessPath = (uint64_t)v3;
      unint64_t v4 = strrchr(v3, 47);
      if (v4) {
        uint64_t v5 = (uint64_t)(v4 + 1);
      }
      else {
        uint64_t v5 = (uint64_t)v3;
      }
      __CFprogmach_port_name_t name = v5;
    }
    uint64_t result = (const char *)__CFProcessPath;
    if (!__CFProcessPath)
    {
      uint64_t result = "";
      __CFProcessPath = (uint64_t)"";
      __CFprogmach_port_name_t name = (uint64_t)"";
    }
  }
  return result;
}

objc_uncaught_exception_handler __exceptionInit()
{
  objc_setExceptionPreprocessor((objc_exception_preprocessor)__exceptionPreprocess);
  objc_setExceptionMatcher((objc_exception_matcher)__exceptionMatch);

  return objc_setUncaughtExceptionHandler((objc_uncaught_exception_handler)__handleUncaughtException);
}

uint64_t __CFStringInitializeSystemEncoding()
{
  __CFIsReadyToInitializeSystemEncoding = 1;
  return CFStringGetSystemEncoding();
}

void __CFOAInitialize()
{
  if (__CFgetenv("OAKeepAllocationStatistics"))
  {
    uint64_t v0 = (void (*)(void))__CFOAInitialize_dyfunc;
    if (__CFOAInitialize_dyfunc == -1)
    {
      uint64_t v0 = (void (*)(void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OAInitialize");
      __CFOAInitialize_dyfunc = (uint64_t)v0;
      if (!v0) {
        return;
      }
    }
    else if (!__CFOAInitialize_dyfunc)
    {
      return;
    }
    v0();
    __CFObjectAllocRecordAllocationFunction = (uint64_t (*)(void, void, void, void, void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OARecordAllocationEvent");
    __CFObjectAllocSetLastAllocEventNameFunction = (uint64_t (*)(void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OASetLastAllocationEventName");
    __CFOAInitializeNSObject();
    __CFOASafe = 1;
  }
}

void __CFMakeNSBlockClasses()
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  if (objc_lookUpClass("__NSStackBlock__"))
  {
    uint64_t v0 = (objc_class *)objc_opt_class();
    uint64_t v1 = objc_lookUpClass("__NSStackBlock__");
    class_setSuperclass(v1, v0);
    uint64_t v2 = objc_lookUpClass("__NSMallocBlock__");
    class_setSuperclass(v2, v0);
    uint64_t v3 = objc_lookUpClass("__NSAutoBlock__");
    class_setSuperclass(v3, v0);
    unint64_t v4 = objc_lookUpClass("__NSGlobalBlock__");
    class_setSuperclass(v4, v0);
  }
  else
  {
    objc_lookUpClass("__NSStackBlock");
    objc_initializeClassPair();
    objc_lookUpClass("__NSMallocBlock");
    objc_initializeClassPair();
    objc_lookUpClass("__NSAutoBlock");
    objc_initializeClassPair();
    objc_lookUpClass("__NSFinalizingBlock");
    objc_initializeClassPair();
    objc_lookUpClass("__NSGlobalBlock");
    objc_initializeClassPair();
    objc_lookUpClass("__NSBlockVariable");
    objc_initializeClassPair();
    objc_registerClassPair((Class)off_1ECE0A5A0);
    objc_registerClassPair((Class)off_1ECE0A598);
    objc_registerClassPair((Class)off_1ECE0A580);
    objc_registerClassPair((Class)off_1ECE0A588);
    objc_registerClassPair((Class)off_1ECE0A590);
    objc_registerClassPair((Class)off_1ECE0A5A8);
  }
  Block_callbacks_RR v5 = *(Block_callbacks_RR *)ymmword_1ECE10368;
  _Block_use_RR2(&v5);
}

void __CFCharacterSetInitialize()
{
  if (__CFCharacterSetInitialize_initOnce != -1) {
    dispatch_once(&__CFCharacterSetInitialize_initOnce, &__block_literal_global_0);
  }
}

uint64_t _CFStringGetUserDefaultEncoding(_DWORD *a1, _DWORD *a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  int v4 = _CFGetEUID();
  Block_callbacks_RR v5 = __CFgetenv("__CF_USER_TEXT_ENCODING");
  BOOL v9 = v5;
  if (v5)
  {
    if (strtol_l(v5, &v9, 0, 0) == v4 && *v9 == 58)
    {
      uint64_t v6 = ++v9;
      goto LABEL_8;
    }
    BOOL v9 = 0;
  }
  if (v4 < 1) {
    goto LABEL_14;
  }
  snprintf(__str, 0x20uLL, "0x%X:0:0", v4);
  setenv("__CF_USER_TEXT_ENCODING", __str, 1);
  uint64_t v6 = v9;
  if (!v9) {
    goto LABEL_14;
  }
LABEL_8:
  uint64_t result = strtol_l(v6, &v9, 0, 0);
  if ((result & 0xFFFFFFFE) == 4) {
    int v8 = 0;
  }
  else {
    int v8 = result;
  }
  *a1 = v8;
  if (*v9 != 58)
  {
LABEL_14:
    uint64_t result = 0;
    *a1 = 0;
    if (!a2) {
      return result;
    }
    goto LABEL_15;
  }
  if (!a2) {
    return result;
  }
  uint64_t result = strtol_l(++v9, 0, 0, 0);
LABEL_15:
  *a2 = result;
  return result;
}

void *_CFGetHandleForInsertedOrInterposingLibrary(const char *a1)
{
  if (!a1) {
    _CFGetHandleForInsertedOrInterposingLibrary_cold_1();
  }
  if (!dyld_has_inserted_or_interposing_libraries()) {
    return 0;
  }

  return _CFGetHandleForLoadedLibrary(a1);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return 39;
}

CFTypeID CFRunLoopTimerGetTypeID(void)
{
  return 47;
}

CFTypeID CFMachPortGetTypeID(void)
{
  return 36;
}

CFTypeID CFCharacterSetGetTypeID(void)
{
  return 25;
}

CFTypeID CFAttributedStringGetTypeID(void)
{
  return 62;
}

uint64_t CFReadStreamGetInfoPointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t constructCFFD(uint64_t a1, int a2, void *cf)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  v18.CFIndex version = 0;
  v18.info = cf;
  v18.CFAllocatorRetainCallBack retain = (void *(__cdecl *)(void *))_fs_retain;
  v18.CFArrayReleaseCallBack release = (void (__cdecl *)(void *))_fs_release;
  v18.copyDescription = (CFStringRef (__cdecl *)(void *))CFCopyDescription;
  CFAllocatorRef v6 = CFGetAllocator(cf);
  unint64_t v7 = CFFileDescriptorCreate(v6, *(_DWORD *)(a1 + 8), 0, (CFFileDescriptorCallBack)fileCallBack, &v18);
  if (v7)
  {
    int v8 = v7;
    if (a2) {
      CFOptionFlags v9 = 1;
    }
    else {
      CFOptionFlags v9 = 2;
    }
    CFFileDescriptorEnableCallBacks(v7, v9);
    CFArrayRef v10 = *(const __CFArray **)(a1 + 16);
    if (v10)
    {
      CFIndex Count = CFArrayGetCount(v10);
      CFAllocatorRef v12 = CFGetAllocator(cf);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v12, v8, 0);
      if (Count >= 2)
      {
        for (CFIndex i = 1; i < Count; i += 2)
        {
          CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i - 1);
          CFStringRef v16 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i);
          CFRunLoopAddSource(ValueAtIndex, RunLoopSource, v16);
        }
      }
      CFRelease(*(CFTypeRef *)(a1 + 16));
      CFRelease(RunLoopSource);
    }
    *(void *)(a1 + 16) = v8;
    return 1;
  }
  else
  {
    uint64_t result = *(void *)(a1 + 16);
    if (result)
    {
      CFRelease((CFTypeRef)result);
      uint64_t result = 0;
      *(void *)(a1 + 16) = 0;
    }
  }
  return result;
}

CFRunLoopSourceRef CFFileDescriptorCreateRunLoopSource(CFAllocatorRef allocator, CFFileDescriptorRef f, CFIndex order)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v6 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0 || !CFFileDescriptorIsValid(f)) {
    return 0;
  }
  uint64_t v11 = 0;
  CFAllocatorRef v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  unint64_t v7 = __fdQueue();
  block[0] = off_1ECE0A5A0;
  block[1] = 0x40000000;
  block[2] = __CFFileDescriptorCreateRunLoopSource_block_invoke;
  block[3] = &unk_1ECDAC028;
  block[6] = allocator;
  void block[7] = order;
  void block[4] = &v11;
  void block[5] = f;
  dispatch_sync(v7, block);
  int v8 = (__CFRunLoopSource *)v12[3];
  _Block_object_dispose(&v11, 8);
  return v8;
}

Boolean CFFileDescriptorIsValid(CFFileDescriptorRef f)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  }
  if (*((_DWORD *)f + 4)) {
    return 0;
  }
  memset(&v4, 0, sizeof(v4));
  if (fstat(*((_DWORD *)f + 5), &v4) < 0)
  {
    CFFileDescriptorInvalidate(f);
    return 0;
  }
  return 1;
}

CFFileDescriptorRef CFFileDescriptorCreate(CFAllocatorRef allocator, CFFileDescriptorNativeDescriptor fd, Boolean closeOnInvalidate, CFFileDescriptorCallBack callout, const CFFileDescriptorContext *context)
{
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  memset(&v27, 0, sizeof(v27));
  if (fstat(fd, &v27) < 0) {
    return 0;
  }
  unsigned int st_mode = v27.st_mode;
  int v11 = v27.st_mode & 0x180;
  if (v11 == 128)
  {
    int v12 = -1;
    if ((v27.st_mode & 0x80) == 0) {
      goto LABEL_9;
    }
  }
  else
  {
    int v12 = fcntl(fd, 67, 3);
    if ((st_mode & 0x80) == 0)
    {
LABEL_9:
      int v13 = -1;
      goto LABEL_12;
    }
  }
  int v13 = fcntl(fd, 67, 3);
LABEL_12:
  BOOL v14 = v12 >= 0 || v11 == 128;
  if (!v14 || ((v13 < 0) & (st_mode >> 7)) != 0)
  {
    if ((v12 & 0x80000000) == 0) {
      close(v12);
    }
    if ((v13 & 0x80000000) == 0) {
      close(v13);
    }
    return 0;
  }
  uint64_t v23 = 0;
  CFStringRef v24 = &v23;
  uint64_t v25 = 0x2000000000;
  uint64_t v26 = 0;
  uint64_t v15 = __fdQueue();
  block[0] = off_1ECE0A5A0;
  block[1] = 0x40000000;
  block[2] = __CFFileDescriptorCreate_block_invoke;
  block[3] = &unk_1ECDABF78;
  Boolean v22 = closeOnInvalidate;
  CFFileDescriptorNativeDescriptor v19 = fd;
  int v20 = v12;
  int v21 = v13;
  block[6] = callout;
  void block[7] = context;
  void block[4] = &v23;
  void block[5] = allocator;
  dispatch_sync(v15, block);
  CFStringRef v16 = (__CFFileDescriptor *)v24[3];
  if (!v16)
  {
    close(v12);
    close(v13);
    CFStringRef v16 = (__CFFileDescriptor *)v24[3];
  }
  _Block_object_dispose(&v23, 8);
  return v16;
}

void sub_182C7713C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t v66 = *(void *)off_1ECE0A5B0;
  p_info = &theString->info;
  unsigned int v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString _cfCapitalize:locale];
    return;
  }
  char v6 = atomic_load((unint64_t *)p_info);
  if (v6)
  {
    char v15 = atomic_load((unint64_t *)&theString->info);
    uint64_t v16 = v15 & 5;
    char v17 = atomic_load((unint64_t *)&theString->info);
    uint64_t v18 = v17 & 0x60;
    if (v16 == 4)
    {
      p_data = &theString->data;
      if (v18)
      {
        int v20 = *p_data;
      }
      else
      {
        uint64_t v22 = atomic_load((unint64_t *)&theString->info);
        int v20 = (char *)&p_data[(v22 & 5) != 4];
      }
      uint64_t length = *v20;
    }
    else if ((v17 & 0x60) != 0)
    {
      uint64_t length = theString->length;
    }
    else
    {
      uint64_t length = (uint64_t)theString->data;
    }
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Du, 0);
    if (locale) {
      locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
    }
    uint64_t v23 = 0;
    char IsMemberOf = 0;
    if (locale)
    {
      uint64_t v25 = BitmapPtrForPlane;
    }
    else
    {
      uint64_t v25 = BitmapPtrForPlane;
      if (((v5 >> 4) & 1) == 0)
      {
        char v26 = atomic_load((unint64_t *)&theString->info);
        stat v27 = &theString->data;
        if ((v26 & 0x60) != 0)
        {
          uint64_t v28 = *v27;
        }
        else
        {
          char v32 = atomic_load((unint64_t *)&theString->info);
          uint64_t v28 = (char *)&v27[(v32 & 5) != 4];
        }
        unint64_t v33 = atomic_load((unint64_t *)&theString->info);
        if (length < 1) {
          return;
        }
        uint64_t v23 = 0;
        char IsMemberOf = 0;
        CFRange v34 = &v28[(v33 >> 2) & 1];
        while ((v34[v23] & 0x80000000) == 0)
        {
          unint64_t v35 = v34[v23];
          int v36 = v34[v23];
          if ((v35 - 65) > 0x19u)
          {
            if ((v36 - 97) > 0x19)
            {
              if (BitmapPtrForPlane)
              {
                if (((1 << (v36 & 7)) & *(unsigned __int8 *)(BitmapPtrForPlane + (v35 >> 3))) == 0) {
                  char IsMemberOf = 0;
                }
              }
              else
              {
                char IsMemberOf = 0;
              }
              goto LABEL_40;
            }
            if (IsMemberOf) {
              char v38 = 0;
            }
            else {
              char v38 = -32;
            }
            char v37 = v35 + v38;
          }
          else
          {
            char v37 = v36 + 32 * (IsMemberOf != 0);
          }
          v34[v23] = v37;
          char IsMemberOf = 1;
LABEL_40:
          if (length == ++v23) {
            return;
          }
        }
      }
    }
    if (v23 >= length) {
      return;
    }
    if (((v5 >> 4) & 1) == 0)
    {
      uint64_t v62 = 0;
      uint64_t v63 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
    }
    char v29 = atomic_load((unint64_t *)&theString->info);
    int v30 = &theString->data;
    uint64_t v61 = &theString->data;
    if ((v29 & 0x60) != 0)
    {
      unint64_t v31 = (unint64_t)*v30;
    }
    else
    {
      char v39 = atomic_load((unint64_t *)&theString->info);
      unint64_t v31 = (unint64_t)&v30[(v39 & 5) != 4];
    }
    unsigned int ConditionalCaseMappingFlags = 0;
    while (1)
    {
      unsigned int v41 = *(unsigned __int16 *)(v31 + 2 * v23);
      uint64_t v42 = v23 + 1;
      if ((v41 & 0xFC00) == 0xD800 && v42 < length)
      {
        int v51 = *(unsigned __int16 *)(v31 + 2 * v42);
        if ((v51 & 0xFC00) == 0xDC00) {
          unsigned int v41 = v51 + (v41 << 10) - 56613888;
        }
      }
      if (!locale && (v41 == 931 ? (BOOL v44 = IsMemberOf == 0) : (BOOL v44 = 1), v44)) {
        unsigned int ConditionalCaseMappingFlags = 0;
      }
      else {
        unsigned int ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags(v41, v31, v23, length, 2 * (IsMemberOf == 0), (unsigned __int16 *)locale, ConditionalCaseMappingFlags);
      }
      uint64_t v45 = CFUniCharMapCaseTo(v41, &v64, 8, 2 * (IsMemberOf == 0), ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      uint64_t v46 = v45 - 1;
      if (v45 >= 1) {
        *(_WORD *)(v31 + 2 * v23) = v64;
      }
      if (v41 >= 0x10000)
      {
        uint64_t v47 = v45 - 2;
        if (v45 == 2)
        {
          ++v23;
          *(_WORD *)(v31 + 2 * v23) = v65[0];
        }
        else
        {
          uint64_t v48 = v45 - 1;
          if (v45 == 1)
          {
            uint64_t v62 = v23 + 1;
            uint64_t v63 = 1;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
            char v53 = atomic_load((unint64_t *)&theString->info);
            if ((v53 & 0x60) != 0)
            {
              unint64_t v31 = (unint64_t)*v61;
            }
            else
            {
              char v58 = atomic_load((unint64_t *)&theString->info);
              unint64_t v31 = (unint64_t)&v61[(v58 & 5) != 4];
            }
            uint64_t v25 = BitmapPtrForPlane;
            --length;
          }
          else if (v45)
          {
            uint64_t v62 = v23 + 1;
            uint64_t v63 = 0;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, v47, 1);
            char v54 = atomic_load((unint64_t *)&theString->info);
            if ((v54 & 0x60) != 0)
            {
              unint64_t v31 = (unint64_t)*v61;
            }
            else
            {
              char v59 = atomic_load((unint64_t *)&theString->info);
              unint64_t v31 = (unint64_t)&v61[(v59 & 5) != 4];
            }
            memmove((void *)(v31 + 2 * v23 + 2), v65, 2 * v48);
            length += v47;
            v23 += v48;
            uint64_t v25 = BitmapPtrForPlane;
          }
          else
          {
            uint64_t v62 = v23;
            uint64_t v63 = 2;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
            char v49 = atomic_load((unint64_t *)&theString->info);
            if ((v49 & 0x60) != 0)
            {
              unint64_t v31 = (unint64_t)*v61;
            }
            else
            {
              char v57 = atomic_load((unint64_t *)&theString->info);
              unint64_t v31 = (unint64_t)&v61[(v57 & 5) != 4];
            }
            uint64_t v25 = BitmapPtrForPlane;
            length -= 2;
          }
        }
        if (CFUniCharIsMemberOf(v41, 0x6Du)) {
          goto LABEL_100;
        }
LABEL_97:
        if (CFUniCharIsMemberOf(v41, 7u)) {
          char IsMemberOf = 1;
        }
        else {
          char IsMemberOf = CFUniCharIsMemberOf(v41, 6u);
        }
        goto LABEL_100;
      }
      if (!v45) {
        break;
      }
      if (v45 < 2) {
        goto LABEL_84;
      }
      uint64_t v62 = v23 + 1;
      uint64_t v63 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, v46, 1);
      char v50 = atomic_load((unint64_t *)&theString->info);
      if ((v50 & 0x60) != 0)
      {
        unint64_t v31 = (unint64_t)*v61;
      }
      else
      {
        char v56 = atomic_load((unint64_t *)&theString->info);
        unint64_t v31 = (unint64_t)&v61[(v56 & 5) != 4];
      }
      memmove((void *)(v31 + 2 * v23 + 2), v65, 2 * v46);
      length += v46;
      v23 += v46;
      if (!v25) {
        goto LABEL_97;
      }
LABEL_88:
      if (((*(unsigned __int8 *)(v25 + ((unint64_t)v41 >> 3)) >> (v41 & 7)) & 1) == 0) {
        goto LABEL_97;
      }
LABEL_100:
      if (++v23 >= length) {
        return;
      }
    }
    uint64_t v62 = v23;
    uint64_t v63 = 1;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
    char v52 = atomic_load((unint64_t *)&theString->info);
    if ((v52 & 0x60) != 0)
    {
      unint64_t v31 = (unint64_t)*v61;
    }
    else
    {
      char v55 = atomic_load((unint64_t *)&theString->info);
      unint64_t v31 = (unint64_t)&v61[(v55 & 5) != 4];
    }
    --length;
LABEL_84:
    if (!v25) {
      goto LABEL_97;
    }
    goto LABEL_88;
  }
  unint64_t v7 = _CFOSLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
    CFStringCapitalize_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
  }
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)_CFStreamCreateWithFile((__objc2_class **)alloc, fileURL, 0);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)_CFPreferencesCopyKeyListWithContainer((__CFString *)applicationID, userName, hostName, 0);
}

void sub_182C77A38(_Unwind_Exception *exception_object)
{
}

void sub_182C78664(_Unwind_Exception *a1)
{
  free(*(void **)(v1 - 384));
  free(*(void **)(v1 - 376));
  _Unwind_Resume(a1);
}

void _plistAppendFormat(__CFData *a1, CFStringRef format, ...)
{
  va_start(va, format);
  CFStringRef v3 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
  _plistAppendString(a1, v3);
  CFRelease(v3);
}

void _plistAppendString(__CFData *a1, CFStringRef theString)
{
  CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr)
  {
    unsigned int v5 = (UniChar *)CharactersPtr;
    CFIndex Length = CFStringGetLength(theString);
    _plistAppendCharacters(a1, v5, Length);
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    if (CStringPtr || (CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u)) != 0)
    {
      size_t v8 = strlen(CStringPtr);
      CFDataAppendBytes(a1, (const UInt8 *)CStringPtr, v8);
    }
    else
    {
      CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, 0x8000100u, 0);
      if (ExternalRepresentation)
      {
        CFDataRef v10 = ExternalRepresentation;
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        CFIndex v12 = CFDataGetLength(v10);
        CFDataAppendBytes(a1, BytePtr, v12);
        CFRelease(v10);
      }
    }
  }
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  unsigned int v4 = lossByte;
  uint64_t v5 = *(void *)&encoding;
  uint64_t v67 = *(void *)off_1ECE0A5B0;
  CFIndex length = 0;
  *(void *)uint64_t v66 = 0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    uint64_t data = CFStringGetLength(theString);
  }
  else
  {
    char v9 = atomic_load((unint64_t *)&theString->info);
    uint64_t v10 = v9 & 5;
    char v11 = atomic_load((unint64_t *)&theString->info);
    uint64_t v12 = v11 & 0x60;
    if (v10 == 4)
    {
      p_uint64_t data = &theString->data;
      if (v12)
      {
        uint64_t v14 = *p_data;
      }
      else
      {
        uint64_t v15 = atomic_load((unint64_t *)&theString->info);
        uint64_t v14 = (char *)&p_data[(v15 & 5) != 4];
      }
      uint64_t data = *v14;
    }
    else if ((v11 & 0x60) != 0)
    {
      uint64_t data = theString->length;
    }
    else
    {
      uint64_t data = (uint64_t)theString->data;
    }
    char v16 = atomic_load((unint64_t *)&theString->info);
    if ((v16 & 0x10) == 0)
    {
      int v17 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v17 = __CFDefaultEightBitStringEncoding;
      }
      if (v17 == v5) {
        goto LABEL_15;
      }
      if (v17 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v17 = __CFDefaultEightBitStringEncoding;
      }
      if (v17 == 1536)
      {
        switch(BYTE1(v5))
        {
          case 0:
            if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || v5 == 152) {
              goto LABEL_50;
            }
            goto LABEL_15;
          case 1:
            if (v5 != 134217984) {
              goto LABEL_50;
            }
            goto LABEL_15;
          case 2:
            if (v5 == 518) {
              goto LABEL_50;
            }
            goto LABEL_15;
          case 6:
            if (v5 != 1536) {
              goto LABEL_50;
            }
            goto LABEL_15;
          case 8:
          case 0xC:
            goto LABEL_50;
          case 0xA:
            if ((v5 - 2561) > 0xF) {
              goto LABEL_15;
            }
            int v30 = 1 << (v5 - 1);
            int v31 = 32785;
            break;
          case 0xB:
            if ((v5 - 3059) > 0xC) {
              goto LABEL_15;
            }
            int v30 = 1 << (v5 + 13);
            int v31 = 4099;
            break;
          default:
            if (((unsigned __int16)v5 & 0xFF00u) > 0xC00) {
              goto LABEL_50;
            }
            goto LABEL_15;
        }
        if ((v30 & v31) == 0)
        {
LABEL_15:
          char v18 = atomic_load((unint64_t *)&theString->info);
          CFFileDescriptorNativeDescriptor v19 = &theString->data;
          if ((v18 & 0x60) != 0)
          {
            int v20 = *v19;
          }
          else
          {
            char v21 = atomic_load((unint64_t *)&theString->info);
            int v20 = (char *)&v19[(v21 & 5) != 4];
          }
          unint64_t v22 = atomic_load((unint64_t *)&theString->info);
          char v23 = atomic_load((unint64_t *)&theString->info);
          char v24 = atomic_load((unint64_t *)&theString->info);
          uint64_t v25 = v24 & 0x60;
          if ((v23 & 5) == 4)
          {
            if (v25)
            {
              char v26 = *v19;
            }
            else
            {
              uint64_t v28 = atomic_load((unint64_t *)&theString->info);
              char v26 = (char *)&v19[(v28 & 5) != 4];
            }
            CFIndex v27 = *v26;
          }
          else if (v25)
          {
            CFIndex v27 = theString->length;
          }
          else
          {
            CFIndex v27 = (CFIndex)*v19;
          }
          return CFDataCreate(alloc, (const UInt8 *)&v20[(v22 >> 2) & 1], v27);
        }
      }
    }
  }
LABEL_50:
  if (!alloc)
  {
    CFAllocatorRef v32 = (const __CFAllocator *)_CFGetTSD(1u);
    if (v32) {
      alloc = v32;
    }
    else {
      alloc = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }
  if ((v5 & 0xFFF) == 0x100 && (v5 == 256 || (v5 - 134217985) >> 26 <= 4))
  {
    char v36 = 1;
    if ((v5 & 0x8000000) != 0) {
      char v36 = 2;
    }
    *(void *)uint64_t v66 = (data + 1) << v36;
  }
  else
  {
    *(void *)uint64_t v66 = CFStringGetMaximumSizeForEncoding(data, v5);
    if (*(uint64_t *)v66 > data && !CF_IS_OBJC(7uLL, (unint64_t)theString))
    {
      char v33 = atomic_load((unint64_t *)&theString->info);
      if ((v33 & 0x10) != 0)
      {
        char v39 = atomic_load((unint64_t *)&theString->info);
        long long v40 = &theString->data;
        if ((v39 & 0x60) != 0)
        {
          unsigned int v41 = (unsigned __int16 *)*v40;
        }
        else
        {
          char v42 = atomic_load((unint64_t *)&theString->info);
          unsigned int v41 = (unsigned __int16 *)&v40[(v42 & 5) != 4];
        }
        char v43 = atomic_load((unint64_t *)&theString->info);
        char v44 = atomic_load((unint64_t *)&theString->info);
        uint64_t v45 = v44 & 0x60;
        if ((v43 & 5) == 4)
        {
          if (v45)
          {
            uint64_t v46 = *v40;
          }
          else
          {
            uint64_t v48 = atomic_load((unint64_t *)&theString->info);
            uint64_t v46 = (char *)&v40[(v48 & 5) != 4];
          }
          uint64_t v47 = *v46;
        }
        else if (v45)
        {
          uint64_t v47 = theString->length;
        }
        else
        {
          uint64_t v47 = (uint64_t)*v40;
        }
        uint64_t v49 = CFStringEncodingByteLengthForCharacters(v5, 256, v41, v47);
        if (v49 >= 1) {
          *(void *)uint64_t v66 = v49;
        }
      }
      else
      {
        v69.uint64_t location = 0;
        v69.CFIndex length = data;
        int v34 = __CFStringEncodeByteStream(theString, v69, 1, v5, v4, 0, 0x7FFFFFFFFFFFFFFFLL, (int64_t *)v66);
        if (data != v34)
        {
          CFDataRef result = 0;
          if (!v4 || !v34) {
            return result;
          }
        }
        if (*(void *)v66 == data)
        {
          char v35 = atomic_load((unint64_t *)&theString->info);
          if ((v35 & 0x10) == 0)
          {
            switch(BYTE1(v5))
            {
              case 0:
                if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || v5 == 152) {
                  goto LABEL_73;
                }
                goto LABEL_107;
              case 1:
                if (v5 != 134217984) {
                  goto LABEL_73;
                }
                goto LABEL_107;
              case 2:
                if (v5 == 518) {
                  goto LABEL_73;
                }
                goto LABEL_107;
              case 6:
                if (v5 != 1536) {
                  goto LABEL_73;
                }
                goto LABEL_107;
              case 8:
              case 0xC:
                goto LABEL_73;
              case 0xA:
                if ((v5 - 2561) > 0xF) {
                  goto LABEL_107;
                }
                int v50 = 1 << (v5 - 1);
                int v51 = 32785;
                break;
              case 0xB:
                if ((v5 - 3059) > 0xC) {
                  goto LABEL_107;
                }
                int v50 = 1 << (v5 + 13);
                int v51 = 4099;
                break;
              default:
                if (((unsigned __int16)v5 & 0xFF00u) > 0xC00) {
                  goto LABEL_73;
                }
                goto LABEL_107;
            }
            if ((v50 & v51) == 0)
            {
LABEL_107:
              char v52 = atomic_load((unint64_t *)&theString->info);
              char v53 = &theString->data;
              if ((v52 & 0x60) != 0)
              {
                char v54 = *v53;
              }
              else
              {
                char v55 = atomic_load((unint64_t *)&theString->info);
                char v54 = (char *)&v53[(v55 & 5) != 4];
              }
              unint64_t v56 = atomic_load((unint64_t *)&theString->info);
              char v57 = (const UInt8 *)&v54[(v56 >> 2) & 1];
              char v58 = atomic_load((unint64_t *)&theString->info);
              uint64_t v59 = v58 & 5;
              char v60 = atomic_load((unint64_t *)&theString->info);
              uint64_t v61 = v60 & 0x60;
              if (v59 == 4)
              {
                if (v61)
                {
                  uint64_t v62 = *v53;
                }
                else
                {
                  uint64_t v64 = atomic_load((unint64_t *)&theString->info);
                  uint64_t v62 = (char *)&v53[(v64 & 5) != 4];
                }
                CFIndex v63 = *v62;
              }
              else if (v61)
              {
                CFIndex v63 = theString->length;
              }
              else
              {
                CFIndex v63 = (CFIndex)*v53;
              }
              return CFDataCreate(alloc, v57, v63);
            }
          }
        }
      }
    }
  }
LABEL_73:
  uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(alloc, *(void *)v66, 930960351, 0);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  v70.uint64_t location = 0;
  v70.CFIndex length = data;
  int v38 = __CFStringEncodeByteStream(theString, v70, 1, v5, v4, Typed, *(uint64_t *)v66, &length);
  if (data == v38 || v4 && v38) {
    return CFDataCreateWithBytesNoCopy(alloc, (const UInt8 *)Typed, length, alloc);
  }
  CFAllocatorDeallocate(alloc, Typed);
  return 0;
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  CFStringRef v3 = (void *)_CFAutoreleasePoolPush();
  CFTimeZoneRef v4 = (const __CFTimeZone *)(id)+[NSTimeZone _timeZoneWithSecondsFromGMT:vcvtmd_s64_f64(ti)];
  _CFAutoreleasePoolPop(v3);
  return v4;
}

uint64_t _CFURLAttachSecurityScopeToFileURL()
{
  return MEMORY[0x1F4114FE8]();
}

CFStringRef _CFURLCopyPath(unint64_t a1, int a2)
{
  CFStringRef v3 = (void *)a1;
  if (CF_IS_OBJC(0x1DuLL, a1)) {
    CFStringRef v3 = (void *)[v3 _cfurl];
  }

  return _retainedComponentString((uint64_t)v3, 32, 0, a2);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    return [(__CFDictionary *)theDict countForKey:key];
  }
  else
  {
    return CFBasicHashGetCountOfKey((uint64_t)theDict, (unint64_t)key);
  }
}

uint64_t _CFURLSetPermanentResourcePropertyForKey()
{
  return MEMORY[0x1F4114F80]();
}

CFDataRef _CFBundleCreateMappedOrLoadedPlistData(const __CFURL *a1, int a2, uint64_t a3, BOOL *a4, CFErrorRef *a5)
{
  int v9 = _CFBundleResourceURLIsSafeForMapping(a1);
  if (a2 && v9)
  {
    CFDataRef result = (CFDataRef)_CFBundleCreateMappedBPlistFile();
    *a4 = result != 0;
    if (result) {
      return result;
    }
  }
  else
  {
    *a4 = 0;
  }

  return _CFDataCreateFromURL(a1, a5);
}

uint64_t _CFBundleResourceURLIsSafeForMapping(const __CFURL *a1)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026);
  if (result)
  {
    memset(&v3, 0, 512);
    return !statfs((const char *)buffer, &v3) && (v3.f_flags & 0x1200) == 4096;
  }
  return result;
}

uint64_t _CFBundleCreateMappedBPlistFile()
{
  return __NSCreateBPlistMappedDataFromURL();
}

Boolean CFCharacterSetIsSupersetOfSet(CFCharacterSetRef theSet, CFCharacterSetRef theOtherset)
{
  unint64_t v2 = MEMORY[0x1F4188790](theSet, theOtherset);
  CFTimeZoneRef v4 = v3;
  uint64_t v5 = (unint64_t *)v2;
  uint64_t v63 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    uint64_t v6 = [v5 _expandedCFCharacterSet];
    if (!v6) {
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (CF_IS_OBJC(0x19uLL, (unint64_t)v4))
  {
    uint64_t v7 = [v4 _expandedCFCharacterSet];
    if (!v7) {
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (v6) {
    uint64_t v5 = (unint64_t *)v6;
  }
  if (v7) {
    CFTimeZoneRef v4 = (unint64_t *)v7;
  }
  unint64_t v8 = v5[5];
  if (!v8 || !*(_DWORD *)(v8 + 8) && !*(unsigned char *)(v8 + 13))
  {
    unsigned int v9 = atomic_load(v5 + 1);
    switch((v9 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v5[4]) {
          goto LABEL_18;
        }
        break;
      case 3u:
      case 4u:
        if (v5[3]) {
          goto LABEL_18;
        }
        break;
      default:
        goto LABEL_18;
    }
    char v12 = atomic_load(v5 + 1);
    if ((v12 & 8) == 0)
    {
      unint64_t v13 = v4[5];
      if (!v13 || !*(_DWORD *)(v13 + 8) && !*(unsigned char *)(v13 + 13))
      {
        unsigned int v14 = atomic_load(v4 + 1);
        switch((v14 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (v4[4]) {
              goto LABEL_103;
            }
            break;
          case 3u:
          case 4u:
            if (v4[3]) {
              goto LABEL_103;
            }
            break;
          default:
            goto LABEL_103;
        }
        char v58 = atomic_load(v4 + 1);
        if ((v58 & 8) == 0) {
          goto LABEL_47;
        }
      }
LABEL_103:
      LOBYTE(IsEqualBitmap) = 0;
      return IsEqualBitmap;
    }
    goto LABEL_97;
  }
LABEL_18:
  unint64_t v10 = v4[5];
  if (!v10 || !*(_DWORD *)(v10 + 8) && !*(unsigned char *)(v10 + 13))
  {
    unsigned int v11 = atomic_load(v4 + 1);
    switch((v11 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v4[4]) {
          goto LABEL_34;
        }
        break;
      case 3u:
      case 4u:
        if (v4[3]) {
          goto LABEL_34;
        }
        break;
      default:
        goto LABEL_34;
    }
    char v15 = atomic_load(v4 + 1);
    if ((v15 & 8) == 0) {
      goto LABEL_97;
    }
  }
LABEL_34:
  char v16 = atomic_load(v5 + 1);
  if ((v16 & 0x70) == 0 || (char v17 = atomic_load(v4 + 1), (v17 & 0x70) == 0))
  {
    unsigned __int8 v27 = atomic_load(v5 + 1);
    unsigned __int8 v28 = atomic_load(v4 + 1);
    if (((v28 ^ v27) & 0x70) != 0) {
      goto LABEL_47;
    }
    if (v5[3] != v4[3]) {
      goto LABEL_47;
    }
    char v29 = atomic_load(v5 + 1);
    if ((v29 & 8) != 0) {
      goto LABEL_47;
    }
    char v30 = atomic_load(v4 + 1);
    if ((v30 & 8) != 0) {
      goto LABEL_47;
    }
    goto LABEL_97;
  }
  char v18 = atomic_load(v5 + 1);
  if ((v18 & 0x70) != 0x10)
  {
    char v19 = atomic_load(v4 + 1);
    if ((v19 & 0x70) != 0x10)
    {
      unint64_t v33 = v5[5];
      if (v33) {
        int v34 = *(_DWORD *)(v33 + 8);
      }
      else {
        int v34 = 0;
      }
      unint64_t v38 = v4[5];
      if (v38)
      {
        int v39 = *(_DWORD *)(v38 + 8);
        if (v33) {
          goto LABEL_56;
        }
      }
      else
      {
        int v39 = 0;
        if (v33)
        {
LABEL_56:
          unsigned int v40 = *(unsigned __int8 *)(v33 + 13) != 0;
          if (v38) {
            goto LABEL_57;
          }
          goto LABEL_64;
        }
      }
      unsigned int v40 = 0;
      if (v38)
      {
LABEL_57:
        BOOL v41 = *(unsigned __int8 *)(v38 + 13) == 0;
        if (v40) {
          int v42 = ~v34 & 0x1FFFE;
        }
        else {
          int v42 = v34;
        }
        if (*(unsigned char *)(v38 + 13)) {
          int v39 = ~v39 & 0x1FFFE;
        }
        goto LABEL_68;
      }
LABEL_64:
      if (v40) {
        int v42 = ~v34 & 0x1FFFE;
      }
      else {
        int v42 = v34;
      }
      BOOL v41 = 1;
LABEL_68:
      __CFCSetGetBitmap((uint64_t)v5, v62);
      __CFCSetGetBitmap((uint64_t)v4, __b);
      uint64_t v43 = 0;
      while (v43 != 2048)
      {
        __int32 v44 = __b[0].i32[v43];
        __int32 v45 = v62[0].i32[v43++];
        if ((v44 & ~v45) != 0) {
          goto LABEL_103;
        }
      }
      if (v39)
      {
        if ((v39 & ~v42) == 0)
        {
          uint64_t v60 = v40 - 1;
          int v46 = (int)(v40 << 31) >> 31;
          uint64_t v47 = 1;
          while (1)
          {
            unint64_t v48 = v5[5];
            if (v48)
            {
              if ((*(_DWORD *)(v48 + 8) & (1 << v47)) != 0
                && *(unsigned __int8 *)(v48 + 12) >= v47)
              {
                uint64_t v49 = *(void *)(*(void *)v48 + 8 * (v47 - 1));
                if (v49)
                {
                  unint64_t v50 = v4[5];
                  if (v50
                    && (*(_DWORD *)(v50 + 8) & (1 << v47)) != 0
                    && *(unsigned __int8 *)(v50 + 12) >= v47
                    && (uint64_t v51 = *(void *)(*(void *)v50 + 8 * (v47 - 1))) != 0)
                  {
                    __CFCSetGetBitmap(v49, v62);
                    __CFCSetGetBitmap(v51, __b);
                    for (uint64_t i = 0; i != 2048; ++i)
                    {
                      LOBYTE(IsEqualBitmap) = 0;
                      __int32 v53 = __b[0].i32[i] ^ (v41 - 1);
                      __int32 v54 = v62[0].i32[i] ^ v46;
                      if ((v53 & ~v54) != 0) {
                        return IsEqualBitmap;
                      }
                    }
                  }
                  else if (!v41)
                  {
                    __CFCSetGetBitmap(v49, v62);
                    int IsEqualBitmap = __CFCSetIsEqualBitmap((uint64_t)v62, v60);
                    if (!IsEqualBitmap) {
                      return IsEqualBitmap;
                    }
                  }
                }
              }
            }
            if (++v47 == 17) {
              goto LABEL_97;
            }
          }
        }
        goto LABEL_103;
      }
      goto LABEL_97;
    }
  }
  unsigned __int8 v20 = atomic_load(v5 + 1);
  unsigned __int8 v21 = atomic_load(v4 + 1);
  if (((v21 ^ v20) & 0x70) != 0)
  {
LABEL_47:
    CFBagRef Copy = __CFCharacterSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, 1, 1);
    CFCharacterSetIntersect((CFMutableCharacterSetRef)Copy, (CFCharacterSetRef)v4);
    char v32 = __CFCharacterSetEqual((uint64_t)Copy, (uint64_t)v4);
    CFRelease(Copy);
    LOBYTE(IsEqualBitmap) = v32;
    return IsEqualBitmap;
  }
  char v22 = atomic_load(v5 + 1);
  char v23 = atomic_load(v4 + 1);
  if ((v22 & 8) != 0)
  {
    int64_t v35 = *((unsigned int *)v4 + 6);
    if ((v23 & 8) != 0)
    {
      uint64_t v57 = *((unsigned int *)v5 + 6);
      if (v35 > v57) {
        goto LABEL_103;
      }
      int64_t v37 = v5[4] + v57;
      v35 += v4[4];
    }
    else
    {
      int64_t v36 = *((unsigned int *)v5 + 6);
      if ((uint64_t)(v4[4] + v35) <= v36) {
        goto LABEL_97;
      }
      int64_t v37 = v5[4] + v36;
    }
    LOBYTE(IsEqualBitmap) = v37 <= v35;
    return IsEqualBitmap;
  }
  if ((v23 & 8) != 0)
  {
    uint64_t v55 = *((unsigned int *)v5 + 6);
    if (v55 || v5[4] != 1114112)
    {
      int64_t v56 = *((unsigned int *)v4 + 6);
      if (v56 || v55 < *((_DWORD *)v4 + 8))
      {
        if ((uint64_t)(v5[4] + v55) <= v56)
        {
          LOBYTE(IsEqualBitmap) = v4[4] + v56 == 1114112;
          return IsEqualBitmap;
        }
        goto LABEL_103;
      }
    }
LABEL_97:
    LOBYTE(IsEqualBitmap) = 1;
    return IsEqualBitmap;
  }
  uint64_t v24 = *((unsigned int *)v4 + 6);
  uint64_t v25 = *((unsigned int *)v5 + 6);
  if (v24 < v25) {
    goto LABEL_103;
  }
  LOBYTE(IsEqualBitmap) = (uint64_t)(v5[4] + v25) >= (uint64_t)(v4[4] + v24);
  return IsEqualBitmap;
}

void CFXNotificationRegisteredObserverSetDistributedConnection(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2) {
    _CFXNotificationRegisteredObserverSetDistributedConnection((void *)a1, SHIDWORD(a2), a2, a3);
  }

  os_unfair_lock_unlock(v6);
}

void *_CFXNotificationRegisteredObserverSetDistributedConnection(void *result, int a2, unsigned int a3, void *object)
{
  uint64_t v4 = result[18];
  if (*(_DWORD *)(v4 + 56 * a3 + 40) == a2)
  {
    uint64_t v6 = v4 + 56 * a3;
    unint64_t v8 = *(void **)(v6 + 32);
    uint64_t v7 = v6 + 32;
    uint64_t result = v8;
    *(_DWORD *)(v7 + 12) |= 0x2000u;
    if (v8 != object)
    {
      if (result) {
        xpc_release(result);
      }
      uint64_t result = xpc_retain(object);
      *(void *)uint64_t v7 = result;
    }
  }
  return result;
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet setObject:value];
  }
  else
  {
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function", v4, v5, v6, v7, v8, v9, (__int16)"void CFSetSetValue(CFMutableSetRef, const void *)");
    }
    CFBasicHashSetValue((uint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }
}

uint64_t __CFBitVectorInit(__objc2_class **a1, char a2, const void *a3, int64_t a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x18uLL, 24, 0);
  uint64_t v9 = Instance;
  if (Instance)
  {
    if ((unint64_t)a4 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = a4;
    }
    uint64_t v12 = v10 + 63;
    BOOL v11 = v10 < -63;
    uint64_t v13 = v10 + 126;
    if (!v11) {
      uint64_t v13 = v12;
    }
    *(void *)(Instance + 24) = v13 & 0xFFFFFFFFFFFFFFC0;
    uint64_t Typed = (void *)CFAllocatorAllocateTyped(a1, (8 * (v13 >> 6)) | 1, 0x100004077774924, 0);
    *(void *)(v9 + 32) = Typed;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      uint64_t Typed = *(void **)(v9 + 32);
    }
    if (Typed)
    {
      bzero(Typed, *(void *)(v9 + 24) / 8 + 1);
      *(void *)(v9 + 16) = a4;
      if (a3)
      {
        if ((a4 & 7) != 0) {
          size_t v15 = a4 / 8 + 1;
        }
        else {
          size_t v15 = a4 / 8;
        }
        memmove(*(void **)(v9 + 32), a3, v15);
      }
      unint64_t v16 = atomic_load((unint64_t *)(v9 + 8));
      unint64_t v17 = v16;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v9 + 8), &v17, v16 & 0xFFFFFFFFFFFFFFF3 | (4 * (a2 & 3)));
        BOOL v18 = v17 == v16;
        unint64_t v16 = v17;
      }
      while (!v18);
    }
    else
    {
      CFRelease((CFTypeRef)v9);
      return 0;
    }
  }
  return v9;
}

uint64_t _CFPrefsSizeOfValue(xpc_object_t xdict, int a2)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  uint64_t v10 = 0;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2020000000;
  uint64_t v13 = 0;
  if (a2 == 1)
  {
    v9[0] = off_1ECE0A5A0;
    v9[1] = 3221225472;
    int v9[2] = ___CFPrefsSizeOfValue_block_invoke;
    v9[3] = &unk_1ECDABE88;
    v9[4] = &v10;
    xpc_dictionary_apply(xdict, v9);
  }
  else if (!a2)
  {
    Class Class = object_getClass(xdict);
    if (Class == (Class)off_1ECE0A670)
    {
      uint64_t v5 = v11;
      uint64_t v6 = v11[3] + 1;
LABEL_12:
      _OWORD v5[3] = v6;
      goto LABEL_13;
    }
    if (Class == (Class)off_1ECE0A6B8)
    {
      size_t length = xpc_string_get_length(xdict);
      goto LABEL_11;
    }
    if (Class == (Class)off_1ECE0A6B0)
    {
      v11[3] = 0;
      goto LABEL_13;
    }
    if (Class == (Class)off_1ECE0A680)
    {
      size_t length = xpc_data_get_length(xdict);
LABEL_11:
      uint64_t v5 = v11;
      uint64_t v6 = v11[3] + length;
      goto LABEL_12;
    }
  }
LABEL_13:
  uint64_t v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_182C7B154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsTemporaryFDToWriteTo(uint64_t a1, uint64_t a2)
{
  CFURLRef v2 = (const __CFURL *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  unsigned int v7 = atomic_load(&dword_1EC090E0C);
  if (v7 == 1)
  {
    uint64_t v8 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      _CFPrefsTemporaryFDToWriteTo_cold_1();
    }
    *__error() = 28;
    return 0xFFFFFFFFLL;
  }
  int v9 = v6;
  mode_t v10 = v5;
  gid_t v11 = v4;
  uid_t v12 = v3;
  CFURLRef v13 = v2;
  if (!CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1026))
  {
    char v22 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      _CFPrefsTemporaryFDToWriteTo_cold_2();
    }
    return 0xFFFFFFFFLL;
  }
  CFURLRef v14 = CFURLCopyAbsoluteURL(v13);
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
  CFURLRef v16 = (const __CFURL *)CFRetain(PathComponent);
  CFStringRef v17 = CFURLCopyLastPathComponent(v14);
  CFRelease(v14);
  CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@.XXXXXXX", v17);
  CFURLRef v19 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, v18, 0);
  CFRelease(v18);
  if (v17) {
    CFRelease(v17);
  }
  if (!CFURLGetFileSystemRepresentation(v19, 1u, v29, 1026))
  {
    char v23 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      _CFPrefsTemporaryFDToWriteTo_cold_3();
    }
    goto LABEL_24;
  }
  if (!v9)
  {
LABEL_14:
    uint64_t v20 = mkstemp((char *)v29);
    goto LABEL_15;
  }
  uint64_t v20 = mkstemp_dprotected_np((char *)v29, v9, 0);
  unsigned __int8 v21 = __error();
  if (v20 == -1 && *v21 == 45)
  {
    memset(&v27, 0, 512);
    if (!statfs((const char *)v29, &v27) && (v27.f_flags & 0x80) != 0) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
LABEL_15:
  if ((v20 & 0x80000000) != 0)
  {
LABEL_21:
    int v24 = *__error();
    uint64_t v25 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      _CFPrefsTemporaryFDToWriteTo_cold_4(v24, (uint64_t)v29, v25);
    }
    *__error() = v24;
LABEL_24:
    CFRelease(v19);
    CFRelease(PathComponent);
    CFRelease(v16);
    return 0xFFFFFFFFLL;
  }
  fchown(v20, v12, v11);
  fchmod(v20, v10);
  CFRelease(v19);
  CFRelease(PathComponent);
  CFRelease(v16);
  return v20;
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)__CFURLCreateCopyAppendingPathComponent(allocator, (unint64_t)url, pathComponent, isDirectory, @";?");
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  CFURLRef v2 = url;
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url)) {
    CFURLRef v2 = (CFURLRef)[(__CFURL *)v2 _cfurl];
  }
  int v4 = CFURLIsFileReferenceURL(v2);
  if (v4)
  {
    CFURLRef v2 = CFURLCreateFilePathURL(allocator, v2, 0);
    if (!v2) {
      return 0;
    }
  }
  CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v2);
  if (PathComponent == -1
    || (CFIndex v7 = PathComponent,
        v19.size_t length = v6,
        CFStringRef v8 = (const __CFString *)atomic_load((unint64_t *)v2 + 3),
        v19.uint64_t location = PathComponent,
        (CFStringRef v9 = CFStringCreateWithSubstring(allocator, v8, v19)) == 0))
  {
    CFURLRef v13 = 0;
    if (!v4) {
      return v13;
    }
    goto LABEL_17;
  }
  CFStringRef v10 = v9;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  _CFGetPathExtensionRangesFromPathComponent(v9, &v15, 0);
  if (v15 == -1)
  {
    CFURLRef v13 = (const __CFURL *)CFRetain(v2);
  }
  else
  {
    CFStringRef v11 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
    MutableCFBagRef Copy = CFStringCreateMutableCopy(allocator, 0, v11);
    v18.uint64_t location = v7 + v15 - 1;
    v18.size_t length = v16 + 1;
    CFStringDelete(MutableCopy, v18);
    if (MutableCopy) {
      CFURLRef v13 = (const __CFURL *)_CFURLCreateWithURLString((__objc2_class **)allocator, MutableCopy, 0, *((const __CFURL **)v2 + 4));
    }
    else {
      CFURLRef v13 = 0;
    }
    CFRelease(MutableCopy);
  }
  CFRelease(v10);
  if (v4) {
LABEL_17:
  }
    CFRelease(v2);
  return v13;
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  CFStringRef PathComponent = CFURLCopyLastPathComponent(url);
  if (!PathComponent) {
    return 0;
  }
  CFStringRef v3 = PathComponent;
  v7.uint64_t location = 0;
  v7.size_t length = 0;
  _CFGetPathExtensionRangesFromPathComponent(PathComponent, &v7.location, 0);
  if (v7.location == -1)
  {
    CFStringRef v5 = 0;
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(url);
    CFStringRef v5 = CFStringCreateWithSubstring(v4, v3, v7);
  }
  CFRelease(v3);
  return v5;
}

void _CFGetPathExtensionRangesFromPathComponent(const __CFString *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v111 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  CFIndex v107 = 0;
  CFIndex v108 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  uint64_t v105 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v109 = 0;
  CFIndex v110 = 0;
  long long v106 = CStringPtr;
  if (!((unint64_t)a2 | (unint64_t)a3)) {
    return;
  }
  if (Length < 2) {
    goto LABEL_60;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = Length - 1;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  CFIndex v13 = 1 - Length;
  CFIndex v14 = Length + 63;
  *(_OWORD *)buffer = 0u;
  long long v97 = 0u;
  uint64_t v15 = &buffer[Length - 1];
  uint64_t v16 = 2 - 2 * Length;
  while (1)
  {
    CFIndex v17 = Length + v10;
    if (v12 >= 0x3F) {
      uint64_t v18 = 63;
    }
    else {
      uint64_t v18 = v12;
    }
    if (v105)
    {
      UniChar v19 = v105[v17 - 1 + v107];
    }
    else if (v106)
    {
      UniChar v19 = v106[v107 - 1 + Length + v10];
    }
    else
    {
      CFIndex v20 = v17 - 1;
      BOOL v21 = v110 > v20 && v11 <= v20;
      if (!v21)
      {
        uint64_t v22 = ~v18;
        uint64_t v23 = v18 ^ 0x3F;
        CFIndex v24 = v14 - v18;
        uint64_t v25 = v18 + v9;
        uint64_t v26 = Length + v10 + v22;
        CFIndex v27 = Length + v10 + v23;
        if (v27 >= v108) {
          CFIndex v27 = v108;
        }
        uint64_t v109 = v26;
        CFIndex v110 = v27;
        v28.uint64_t location = v26 + v107;
        if (v108 >= v24) {
          CFIndex v29 = v24;
        }
        else {
          CFIndex v29 = v108;
        }
        v28.size_t length = v13 + v25 + v29;
        CFIndex v30 = v13;
        int v31 = v15;
        CFStringGetCharacters(theString, v28, buffer);
        uint64_t v15 = v31;
        CFIndex v13 = v30;
        uint64_t v11 = v109;
      }
      UniChar v19 = v15[v10 - v11];
    }
    uint64_t v32 = 0;
    int v33 = v19;
    uint64_t v34 = -1;
    if (v33 > 8233)
    {
      unsigned int v35 = v33 - 8234;
      BOOL v21 = v35 > 0x3F;
      unint64_t v36 = (1 << v35) & 0xF00000000000001FLL;
      BOOL v37 = v21 || v36 == 0;
      uint64_t v38 = 0;
      uint64_t v39 = -1;
      if (!v37) {
        goto LABEL_63;
      }
      goto LABEL_37;
    }
    if (v33 > 1563)
    {
      if ((v33 - 8206) < 2)
      {
LABEL_39:
        uint64_t v38 = 0;
        goto LABEL_62;
      }
      uint64_t v38 = 0;
      uint64_t v39 = -1;
      if (v33 == 1564) {
        goto LABEL_63;
      }
      goto LABEL_37;
    }
    if (v33 == 32) {
      goto LABEL_39;
    }
    if (v33 == 46) {
      break;
    }
    uint64_t v38 = 0;
    uint64_t v39 = -1;
    if (v33 == 47) {
      goto LABEL_63;
    }
LABEL_37:
    --v12;
    v16 += 2;
    --v14;
    --v10;
    ++v9;
    if (Length + v10 <= 1)
    {
      uint64_t v32 = 0;
      uint64_t v38 = 0;
LABEL_91:
      uint64_t v34 = -1;
      goto LABEL_63;
    }
  }
  if (!v10)
  {
    uint64_t v32 = 0;
    uint64_t v38 = 0;
    goto LABEL_62;
  }
  CFIndex v40 = Length + v10;
  unint64_t v41 = Length + v10 - 1;
  if (v41 > 2) {
    goto LABEL_68;
  }
  if (v105)
  {
    int v42 = (UniChar *)&v105[v107];
  }
  else
  {
    if ((uint64_t)v41 > v110 || v11 >= 1)
    {
      if (v108 >= 64) {
        v43.size_t length = 64;
      }
      else {
        v43.size_t length = v108;
      }
      uint64_t v109 = 0;
      CFIndex v110 = v43.length;
      v43.uint64_t location = v107;
      if (v106)
      {
        if (v43.length)
        {
          __int32 v44 = &v106[v107];
          __int32 v45 = buffer;
          do
          {
            UniChar v46 = *v44++;
            *v45++ = v46;
            --v43.length;
          }
          while (v43.length);
        }
      }
      else
      {
        CFIndex v47 = v13;
        CFStringGetCharacters(theString, v43, buffer);
        CFIndex v13 = v47;
      }
    }
    uint64_t v11 = v109;
    int v42 = &buffer[-v109];
  }
  if (*v42 != 46) {
    goto LABEL_68;
  }
  uint64_t v32 = v40 - 2;
  if (v40 == 2) {
    goto LABEL_61;
  }
  if (v42[1] != 46)
  {
LABEL_68:
    uint64_t v39 = Length + v10;
    uint64_t v38 = -v10;
    if (!a3)
    {
LABEL_90:
      uint64_t v32 = 0;
      goto LABEL_91;
    }
    CFIndex v48 = v40 + 63;
    CFIndex v49 = v13 - v10;
    while (1)
    {
      if (v41 >= 0x40) {
        uint64_t v50 = 64;
      }
      else {
        uint64_t v50 = v41;
      }
      CFIndex v51 = v40 - 1;
      if (v40 - 1 < 2) {
        goto LABEL_90;
      }
      if (v105)
      {
        char v52 = (UniChar *)&v105[v40 + v107];
      }
      else
      {
        if (v106)
        {
          __int16 v53 = v106[v107 - 2 + v40];
          goto LABEL_79;
        }
        if (v110 < v51 || v11 >= v51)
        {
          uint64_t v54 = -v50;
          uint64_t v55 = v50 + v49;
          CFIndex v56 = v48 - v50;
          CFIndex v57 = v40 + v54;
          CFIndex v58 = v57 + 63;
          if (v57 + 63 >= v108) {
            CFIndex v58 = v108;
          }
          uint64_t v109 = v57 - 1;
          CFIndex v110 = v58;
          v59.uint64_t location = v57 + v107 - 1;
          if (v108 >= v56) {
            CFIndex v60 = v56;
          }
          else {
            CFIndex v60 = v108;
          }
          v59.size_t length = v60 + v55;
          CFStringGetCharacters(theString, v59, buffer);
          uint64_t v11 = v109;
        }
        char v52 = &buffer[v40 - v11];
      }
      __int16 v53 = *(v52 - 2);
LABEL_79:
      v16 += 2;
      ++v49;
      --v48;
      --v41;
      --v40;
      if (v53 != 32)
      {
        uint64_t v61 = 0;
        CFIndex v62 = 1 - v51;
        uint64_t v63 = (char *)buffer - v16;
        CFIndex v64 = v51 + 63;
        int64_t v65 = v51 - 1;
        while (1)
        {
          uint64_t v66 = (unint64_t)v65 >= 0x3F ? 63 : v65;
          if (v105)
          {
            UniChar v67 = v105[v65 + v107];
          }
          else if (v106)
          {
            UniChar v67 = v106[v107 + v65];
          }
          else
          {
            if (v110 <= v65 || v11 > v65)
            {
              uint64_t v69 = -v66;
              uint64_t v70 = v66 + v62;
              CFIndex v71 = v64 - v66;
              uint64_t v72 = v65 + v69;
              CFIndex v73 = v72 + 64;
              if (v72 + 64 >= v108) {
                CFIndex v73 = v108;
              }
              uint64_t v109 = v72;
              CFIndex v110 = v73;
              v74.uint64_t location = v72 + v107;
              if (v108 >= v71) {
                CFIndex v75 = v71;
              }
              else {
                CFIndex v75 = v108;
              }
              v74.size_t length = v75 + v70;
              CFStringGetCharacters(theString, v74, buffer);
              uint64_t v11 = v109;
            }
            UniChar v67 = *(_WORD *)&v63[-2 * v11];
          }
          if (v67 == 32 || v67 == 46) {
            break;
          }
          ++v61;
          --v64;
          v63 -= 2;
          ++v62;
          uint64_t v34 = -1;
          BOOL v21 = v65-- <= 1;
          if (v21)
          {
LABEL_137:
            uint64_t v32 = 0;
            goto LABEL_63;
          }
        }
        int64_t v95 = v65 + 1;
        int64_t v76 = -v65;
        int64_t v77 = v65 + 64;
        while (1)
        {
          uint64_t v78 = (unint64_t)v65 >= 0x3F ? 63 : v65;
          if (v105)
          {
            UniChar v79 = v105[v65 + v107];
          }
          else if (v106)
          {
            UniChar v79 = v106[v107 + v65];
          }
          else
          {
            if (v110 <= v65 || v11 > v65)
            {
              uint64_t v81 = -v78;
              uint64_t v82 = v78 + v76;
              CFIndex v83 = v77 - v78;
              uint64_t v84 = v65 + v81;
              CFIndex v85 = v84 + 64;
              if (v84 + 64 >= v108) {
                CFIndex v85 = v108;
              }
              uint64_t v109 = v84;
              CFIndex v110 = v85;
              v86.uint64_t location = v84 + v107;
              if (v108 >= v83) {
                CFIndex v87 = v83;
              }
              else {
                CFIndex v87 = v108;
              }
              v86.size_t length = v87 + v82;
              CFStringGetCharacters(theString, v86, buffer);
              uint64_t v11 = v109;
            }
            UniChar v79 = *(_WORD *)&v63[-2 * v11];
          }
          if (v79 != 32) {
            break;
          }
          --v77;
          v63 -= 2;
          ++v76;
          uint64_t v34 = -1;
          BOOL v21 = v65-- <= 1;
          if (v21) {
            goto LABEL_137;
          }
        }
        if (v105)
        {
          UniChar v88 = v105[v107 + v65];
          uint64_t v89 = v95;
        }
        else
        {
          uint64_t v89 = v95;
          if (v106)
          {
            UniChar v88 = v106[v107 + v65];
          }
          else
          {
            if (v110 <= v65 || v11 > v65)
            {
              uint64_t v90 = 63;
              if ((unint64_t)v65 < 0x3F) {
                uint64_t v90 = v65;
              }
              uint64_t v91 = v65 - v90 + 64;
              if (v91 >= v108) {
                uint64_t v91 = v108;
              }
              uint64_t v109 = v65 - v90;
              CFIndex v110 = v91;
              CFIndex v92 = v77 - v90;
              if (v108 < v77 - v90) {
                CFIndex v92 = v108;
              }
              v112.size_t length = v90 + v92 - v65;
              v112.uint64_t location = v65 - v90 + v107;
              CFStringGetCharacters(theString, v112, buffer);
              uint64_t v11 = v109;
            }
            UniChar v88 = *(_WORD *)&v63[-2 * v11];
          }
        }
        BOOL v93 = v88 == 46;
        BOOL v94 = v61 != 0;
        if (v93 && v94) {
          uint64_t v32 = v61;
        }
        else {
          uint64_t v32 = 0;
        }
        if (v93 && v94) {
          uint64_t v34 = v89;
        }
        else {
          uint64_t v34 = -1;
        }
        goto LABEL_63;
      }
    }
  }
LABEL_60:
  uint64_t v32 = 0;
LABEL_61:
  uint64_t v38 = 0;
  uint64_t v34 = -1;
LABEL_62:
  uint64_t v39 = -1;
LABEL_63:
  if (a2)
  {
    *a2 = v39;
    a2[1] = v38;
  }
  if (a3)
  {
    *a3 = v34;
    a3[1] = v32;
  }
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  CFURLRef v1 = url;
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url))
  {
    CFAllocatorRef v2 = CFGetAllocator(v1);
    CFStringRef v3 = CFURLCreateStringWithFileSystemPath(v2, (unint64_t)v1, 0, 0);
    CFStringRef v4 = v3;
    result.uint64_t location = 0;
    result.size_t length = 0;
    if (v3)
    {
      CFIndex Length = CFStringGetLength(v3);
      if (Length)
      {
        CFIndex v6 = Length;
        CFIndex v7 = Length - 1;
        if (CFStringGetCharacterAtIndex(v4, Length - 1) != 47) {
          CFIndex v7 = v6;
        }
        if (v7)
        {
          v32.uint64_t location = 0;
          v32.size_t length = v7;
          if (CFStringFindWithOptions(v4, @"/", v32, 4uLL, &result)) {
            CFIndex v8 = result.location + 1;
          }
          else {
            CFIndex v8 = 0;
          }
          CFIndex v9 = v7 - v8;
          if (v8) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = v9 == v6;
          }
          if (!v10)
          {
            CFAllocatorRef v11 = CFGetAllocator(v1);
            v33.uint64_t location = v8;
            v33.size_t length = v9;
            CFStringRef v12 = CFStringCreateWithSubstring(v11, v4, v33);
            CFRelease(v4);
            return v12;
          }
        }
      }
    }
    return v4;
  }
  int v13 = CFURLIsFileReferenceURL(v1);
  if (v13)
  {
    CFAllocatorRef v14 = CFGetAllocator(v1);
    CFURLRef v1 = CFURLCreateFilePathURL(v14, v1, 0);
    if (!v1) {
      return 0;
    }
  }
  CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v1);
  if (PathComponent == -1 || (CFIndex v17 = v16) == 0)
  {
    if (v13) {
      CFRelease(v1);
    }
    CFIndex v20 = &stru_1ECE10768;
  }
  else
  {
    CFIndex v18 = PathComponent;
    if (v16 != 1
      || (CFStringRef v19 = (const __CFString *)atomic_load((unint64_t *)v1 + 3), CFStringGetCharacterAtIndex(v19, v18) != 47))
    {
      CFAllocatorRef v22 = CFGetAllocator(v1);
      CFStringRef v23 = (const __CFString *)atomic_load((unint64_t *)v1 + 3);
      v34.uint64_t location = v18;
      v34.size_t length = v17;
      CFStringRef v4 = CFStringCreateWithSubstring(v22, v23, v34);
      if ((*((unsigned char *)v1 + 17) & 0x80) == 0)
      {
        int v24 = *((_DWORD *)v1 + 5);
        if (_CFURLHasFileURLScheme((unint64_t)v1, 0)) {
          CFStringRef v25 = @"/";
        }
        else {
          CFStringRef v25 = &stru_1ECE10768;
        }
        CFAllocatorRef v26 = CFGetAllocator(v1);
        if (v24 == 134217984) {
          CFStringRef v27 = CFURLCreateStringByReplacingPercentEscapes(v26, v4, v25);
        }
        else {
          CFStringRef v27 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v26, v4, v25, *((_DWORD *)v1 + 5));
        }
        CFStringRef v28 = v27;
        CFRelease(v4);
        CFStringRef v4 = v28;
      }
      if (v13) {
        CFRelease(v1);
      }
      return v4;
    }
    if (v13) {
      CFRelease(v1);
    }
    CFIndex v20 = @"/";
  }

  return (CFStringRef)CFRetain(v20);
}

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  if (CFStringGetLength(extension))
  {
    if (_CFExtensionIsValidToAppend(extension))
    {
      if (CF_IS_OBJC(0x1DuLL, (unint64_t)url)) {
        url = (CFURLRef)[(__CFURL *)url _cfurl];
      }
      int v6 = CFURLIsFileReferenceURL(url);
      if (!v6)
      {
        CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)url);
        if (PathComponent == -1) {
          return 0;
        }
        goto LABEL_13;
      }
      CFURLRef v7 = CFURLCreateFilePathURL(allocator, url, 0);
      if (v7)
      {
        url = v7;
        CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v7);
        if (PathComponent == -1)
        {
          CFRelease(url);
          return 0;
        }
LABEL_13:
        CFIndex v11 = PathComponent;
        uint64_t v12 = v9;
        CFStringRef v13 = (const __CFString *)atomic_load((unint64_t *)url + 3);
        MutableCFBagRef Copy = CFStringCreateMutableCopy(allocator, 0, v13);
        if (MutableCopy)
        {
          uint64_t v15 = MutableCopy;
          CFIndex v16 = v11 + v12;
          CFStringInsert(MutableCopy, v16, @".");
          if (_CFURLHasFileURLScheme((unint64_t)url, 0)) {
            CFStringRef v17 = POSIXPathToURLPath(extension, 0, 0, 0);
          }
          else {
            CFStringRef v17 = CFURLCreateStringByAddingPercentEscapes(allocator, extension, 0, @";?/", *((_DWORD *)url + 5));
          }
          CFStringRef v19 = v17;
          if (v17)
          {
            CFStringInsert(v15, v16 + 1, v17);
            CFRelease(v19);
            CFIndex v18 = _CFURLCreateWithURLString((__objc2_class **)allocator, v15, 0, *((const __CFURL **)url + 4));
          }
          else
          {
            CFIndex v18 = 0;
          }
          CFRelease(v15);
          if (!v6) {
            return (CFURLRef)v18;
          }
        }
        else
        {
          CFIndex v18 = 0;
          if (!v6) {
            return (CFURLRef)v18;
          }
        }
        CFRelease(url);
        return (CFURLRef)v18;
      }
    }
    return 0;
  }

  return (CFURLRef)CFRetain(url);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  uint64_t v62 = *(void *)off_1ECE0A5B0;
  if (!originalString) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(originalString);
  if (!Length)
  {
    return CFStringCreateCopy(allocator, originalString);
  }
  uint64_t v10 = Length;
  CFStringRef theString = originalString;
  uint64_t v58 = 0;
  CFIndex v59 = Length;
  CharactersPtr = CFStringGetCharactersPtr(originalString);
  CStringPtr = 0;
  CFIndex v56 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(originalString, 0x600u);
  }
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v48 = 0u;
  CFIndex v61 = 0;
  CFIndex v57 = CStringPtr;
  CFIndex v60 = 0;
  if (v10 < 1)
  {
LABEL_85:
    CFAllocatorRef v40 = CFGetAllocator(originalString);
    return CFStringCreateCopy(v40, originalString);
  }
  MutableCFBagRef Copy = 0;
  CFIndex v14 = 0;
  CFIndex v15 = 0;
  do
  {
    UniChar v43 = 0;
    if (v56)
    {
      UniChar v16 = v56[v58 + v14];
    }
    else if (v57)
    {
      UniChar v16 = v57[v58 + v14];
    }
    else
    {
      CFIndex v17 = v60;
      if (v61 <= v14 || v60 > v14)
      {
        CFIndex v19 = v14 - 4;
        if (v14 < 4) {
          CFIndex v19 = 0;
        }
        CFIndex v20 = v19 + 64;
        if (v19 + 64 >= v59) {
          CFIndex v20 = v59;
        }
        CFIndex v60 = v19;
        CFIndex v61 = v20;
        v64.uint64_t location = v58 + v19;
        v64.size_t length = v20 - v19;
        CFStringGetCharacters(theString, v64, buffer);
        CFIndex v17 = v60;
      }
      UniChar v16 = buffer[v14 - v17];
    }
    UniChar v43 = v16;
    if (v16 <= 0x7Fu && (sURLValidCharacters[v16] & 1) != 0)
    {
      if (!legalURLCharactersToBeEscaped || !_stringContainsCharacter(legalURLCharactersToBeEscaped, v16))
      {
LABEL_38:
        if (MutableCopy)
        {
          chars[v15] = v43;
          if (v15 == 1023)
          {
            CFStringAppendCharacters(MutableCopy, chars, 1024);
            CFIndex v15 = 0;
          }
          else
          {
            ++v15;
          }
        }
        goto LABEL_74;
      }
    }
    else if (charactersToLeaveUnescaped && _stringContainsCharacter(charactersToLeaveUnescaped, v16))
    {
      goto LABEL_38;
    }
    uint64_t v42 = 0;
    if (!MutableCopy)
    {
      CFAllocatorRef v21 = CFGetAllocator(originalString);
      MutableCFBagRef Copy = CFStringCreateMutableCopy(v21, 0, originalString);
      v65.size_t length = v10 - v14;
      v65.uint64_t location = v14;
      CFStringDelete(MutableCopy, v65);
    }
    if (v15 >= 1000)
    {
      CFStringAppendCharacters(MutableCopy, chars, v15);
      CFIndex v15 = 0;
    }
    if (!CFStringEncodingUnicodeToBytes(encoding, 0, &v43, 1, 0, v45, 8, &v42))
    {
      if (v42 >= 1)
      {
        int v24 = (unsigned int *)((char *)v45 + v42);
        CFStringRef v25 = &chars[v15 + 2];
        CFAllocatorRef v26 = v45;
        do
        {
          unsigned int v27 = *(unsigned __int8 *)v26;
          CFAllocatorRef v26 = (unsigned int *)((char *)v26 + 1);
          *(v25 - 2) = 37;
          *(v25 - 1) = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v27 >> 4];
          v15 += 3;
          *CFStringRef v25 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v27 & 0xF];
          v25 += 3;
        }
        while (v26 < v24);
      }
      goto LABEL_74;
    }
    if (encoding != 134217984) {
      break;
    }
    if ((v43 & 0xFC00) != 0xD800) {
      break;
    }
    CFIndex v22 = v14 + 1;
    if (v14 + 1 >= v10) {
      break;
    }
    if (v56)
    {
      UniChar v23 = v56[v58 + v22];
    }
    else if (v57)
    {
      UniChar v23 = v57[v58 + v22];
    }
    else
    {
      if (v61 <= v22 || (CFIndex v28 = v60, v60 > v22))
      {
        CFIndex v29 = v14 - 3;
        if (v14 < 3) {
          CFIndex v29 = 0;
        }
        CFIndex v30 = v29 + 64;
        if (v29 + 64 >= v59) {
          CFIndex v30 = v59;
        }
        CFIndex v60 = v29;
        CFIndex v61 = v30;
        v66.uint64_t location = v58 + v29;
        v66.size_t length = v30 - v29;
        CFStringGetCharacters(theString, v66, buffer);
        CFIndex v28 = v60;
      }
      UniChar v23 = buffer[v22 - v28];
    }
    if (v23 >> 10 != 55) {
      break;
    }
    v44[0] = v43;
    if (v56)
    {
      unsigned __int16 v31 = v56[v58 + v22];
    }
    else if (v57)
    {
      unsigned __int16 v31 = v57[v58 + v22];
    }
    else
    {
      if (v61 <= v22 || (CFIndex v32 = v60, v60 > v22))
      {
        CFIndex v33 = v14 - 3;
        if (v14 < 3) {
          CFIndex v33 = 0;
        }
        CFIndex v34 = v33 + 64;
        if (v33 + 64 >= v59) {
          CFIndex v34 = v59;
        }
        CFIndex v60 = v33;
        CFIndex v61 = v34;
        v67.uint64_t location = v58 + v33;
        v67.size_t length = v34 - v33;
        CFStringGetCharacters(theString, v67, buffer);
        CFIndex v32 = v60;
      }
      unsigned __int16 v31 = buffer[v22 - v32];
    }
    v44[1] = v31;
    if (CFStringEncodingUnicodeToBytes(134217984, 0, v44, 2, 0, v45, 6, &v42)) {
      break;
    }
    if (v42 >= 1)
    {
      unsigned int v35 = (unsigned int *)((char *)v45 + v42);
      unint64_t v36 = &chars[v15 + 2];
      BOOL v37 = v45;
      do
      {
        unsigned int v38 = *(unsigned __int8 *)v37;
        BOOL v37 = (unsigned int *)((char *)v37 + 1);
        *(v36 - 2) = 37;
        *(v36 - 1) = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v38 >> 4];
        v15 += 3;
        UniChar *v36 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v38 & 0xF];
        v36 += 3;
      }
      while (v37 < v35);
    }
    ++v14;
LABEL_74:
    ++v14;
  }
  while (v14 < v10);
  if (v14 >= v10)
  {
    if (MutableCopy)
    {
      if (v15) {
        CFStringAppendCharacters(MutableCopy, chars, v15);
      }
      return MutableCopy;
    }
    goto LABEL_85;
  }
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
    return 0;
  }
  return MutableCopy;
}

uint64_t _stringContainsCharacter(const __CFString *a1, int a2)
{
  uint64_t v30 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v26 = 0;
  CFIndex v27 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  int v24 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  CFStringRef v25 = CStringPtr;
  if (Length < 1) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 64;
  memset(v22, 0, sizeof(v22));
  while (1)
  {
    uint64_t v11 = (unint64_t)v9 >= 4 ? 4 : v9;
    if (v24)
    {
      UniChar v12 = v24[v9 + v26];
    }
    else if (v25)
    {
      UniChar v12 = v25[v26 + v9];
    }
    else
    {
      if (v29 <= v9 || v8 > v9)
      {
        uint64_t v14 = -v11;
        uint64_t v15 = v11 + v7;
        uint64_t v16 = v10 - v11;
        uint64_t v17 = v9 + v14;
        CFIndex v18 = v17 + 64;
        if (v17 + 64 >= v27) {
          CFIndex v18 = v27;
        }
        uint64_t v28 = v17;
        uint64_t v29 = v18;
        v19.uint64_t location = v17 + v26;
        if (v27 >= v16) {
          uint64_t v20 = v16;
        }
        else {
          uint64_t v20 = v27;
        }
        v19.size_t length = v20 + v15;
        CFStringGetCharacters(theString, v19, (UniChar *)v22);
        uint64_t v8 = v28;
      }
      UniChar v12 = *((_WORD *)v22 + v9 - v8);
    }
    if (a2 == v12) {
      break;
    }
    ++v9;
    --v7;
    ++v10;
    if (Length == v9) {
      return 0;
    }
  }
  return 1;
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  CFURLRef v2 = url;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)url)) {
    CFURLRef v2 = (CFURLRef)[(__CFURL *)v2 _cfurl];
  }
  int v4 = CFURLIsFileReferenceURL(v2);
  if (!v4)
  {
    unsigned int v6 = *((_DWORD *)v2 + 4);
    if ((v6 & 0x20) != 0) {
      goto LABEL_9;
    }
    return 0;
  }
  CFURLRef v5 = CFURLCreateFilePathURL(allocator, v2, 0);
  if (!v5) {
    return 0;
  }
  CFURLRef v2 = v5;
  unsigned int v6 = *((_DWORD *)v5 + 4);
  if ((v6 & 0x20) == 0)
  {
    uint64_t v7 = 0;
LABEL_37:
    CFRelease(v2);
    return (CFURLRef)v7;
  }
LABEL_9:
  unsigned int v8 = 0;
  unsigned int v9 = 32;
  do
  {
    char v10 = v9;
    v9 >>= 1;
    v8 += v6 & 1;
    v6 >>= 1;
  }
  while ((v10 & 2) == 0);
  uint64_t v11 = (char *)v2 + 16 * v8;
  CFIndex v13 = *((void *)v11 + 7);
  CFIndex v12 = *((void *)v11 + 8);
  CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v2);
  if (v15)
  {
    CFIndex v16 = PathComponent;
    if (v15 == 2)
    {
      CFStringRef v18 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      if (CFStringGetCharacterAtIndex(v18, v16) != 46) {
        goto LABEL_21;
      }
      CFStringRef v19 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      if (CFStringGetCharacterAtIndex(v19, v16 + 1) != 46) {
        goto LABEL_21;
      }
    }
    else if (v15 != 1 {
           || (CFStringRef v17 = (const __CFString *)atomic_load((unint64_t *)v2 + 3),
    }
               (CFStringGetCharacterAtIndex(v17, v16) & 0xFFFE) != 0x2E))
    {
LABEL_21:
      CFStringRef v25 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      MutableCFBagRef Copy = CFStringCreateMutableCopy(allocator, 0, v25);
      CFMutableStringRef v21 = MutableCopy;
      if (v16 == v13)
      {
        v32.uint64_t location = v13;
        v32.size_t length = v12;
        CFStringReplace(MutableCopy, v32, @".");
        CFStringInsert(v21, 1, @"/");
        goto LABEL_33;
      }
      v27.size_t length = v12 + v13 - v16;
      v27.uint64_t location = v16;
      goto LABEL_24;
    }
  }
  CFStringRef v20 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
  CFMutableStringRef v21 = CFStringCreateMutableCopy(allocator, 0, v20);
  if (v12 <= 0)
  {
    uint64_t v24 = 0;
    CFIndex v23 = v12 + v13;
  }
  else
  {
    CFStringRef v22 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
    CFIndex v23 = v12 + v13;
    if (CFStringGetCharacterAtIndex(v22, v23 - 1) == 47)
    {
      uint64_t v24 = 0;
    }
    else
    {
      CFStringInsert(v21, v23, @"/");
      uint64_t v24 = 1;
    }
  }
  CFStringInsert(v21, v24 + v23, @"..");
  CFStringInsert(v21, v24 + v23 + 2, @"/");
  uint64_t v28 = v24 + 3 + v12;
  if (v28 >= 5)
  {
    uint64_t v29 = v24 + 3 + v23;
    CFIndex v30 = v29 - 5;
    if (CFStringGetCharacterAtIndex(v21, v29 - 5) == 46)
    {
      if ((unint64_t)v28 < 8)
      {
        if (v28 == 5) {
          goto LABEL_31;
        }
      }
      else
      {
        CFIndex v30 = v29 - 6;
        if (CFStringGetCharacterAtIndex(v21, v29 - 6) == 47)
        {
LABEL_31:
          MutableCFBagRef Copy = v21;
          v27.uint64_t location = v30;
          v27.size_t length = 2;
LABEL_24:
          CFStringDelete(MutableCopy, v27);
        }
      }
    }
  }
LABEL_33:
  if (v21) {
    uint64_t v7 = _CFURLCreateWithURLString((__objc2_class **)allocator, v21, 0, *((const __CFURL **)v2 + 4));
  }
  else {
    uint64_t v7 = 0;
  }
  CFRelease(v21);
  if (v4) {
    goto LABEL_37;
  }
  return (CFURLRef)v7;
}

CFIndex _rangeOfLastPathComponent(uint64_t a1)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 0x20) == 0) {
    return -1;
  }
  unsigned int v3 = 0;
  unsigned int v4 = 32;
  do
  {
    char v5 = v4;
    v4 >>= 1;
    v3 += v1 & 1;
    v1 >>= 1;
  }
  while ((v5 & 2) == 0);
  unsigned int v6 = (CFIndex *)(a1 + 56 + 16 * v3);
  CFIndex v2 = *v6;
  CFIndex v7 = v6[1];
  if (*v6 != -1 && v7 != 0)
  {
    result.uint64_t location = 0;
    result.size_t length = 0;
    unsigned int v9 = (unint64_t *)(a1 + 24);
    CFStringRef v10 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFIndex v11 = v7 - 1;
    if (CFStringGetCharacterAtIndex(v10, v7 - 1 + v2) != 47 || (--v7, v11))
    {
      CFStringRef v12 = (const __CFString *)atomic_load(v9);
      v16.uint64_t location = v2;
      v16.size_t length = v7;
      if (CFStringFindWithOptions(v12, @"/", v16, 4uLL, &result)) {
        return result.location + 1;
      }
    }
  }
  return v2;
}

uint64_t _CFExtensionIsValidToAppend(const __CFString *a1)
{
  uint64_t v45 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v41 = 0;
  CFIndex v42 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  uint64_t v39 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  CFAllocatorRef v40 = CStringPtr;
  if (!Length) {
    return 0;
  }
  uint64_t v5 = Length - 1;
  if (Length < 1) {
    return 1;
  }
  uint64_t v6 = 0;
  CFIndex v7 = 1 - Length;
  CFIndex v8 = Length + 63;
  uint64_t v9 = Length - 1;
  memset(v37, 0, sizeof(v37));
  while (1)
  {
    uint64_t v10 = (unint64_t)v9 >= 0x3F ? 63 : v9;
    if (v39)
    {
      UniChar v11 = v39[v9 + v41];
    }
    else if (v40)
    {
      UniChar v11 = v40[v41 + v9];
    }
    else
    {
      BOOL v12 = v44 > v9 && v6 <= v9;
      if (!v12)
      {
        uint64_t v13 = -v10;
        uint64_t v14 = v10 + v7;
        CFIndex v15 = v8 - v10;
        uint64_t v16 = v9 + v13;
        CFIndex v17 = v16 + 64;
        if (v16 + 64 >= v42) {
          CFIndex v17 = v42;
        }
        uint64_t v43 = v16;
        uint64_t v44 = v17;
        v18.uint64_t location = v16 + v41;
        if (v42 >= v15) {
          CFIndex v19 = v15;
        }
        else {
          CFIndex v19 = v42;
        }
        v18.size_t length = v19 + v14;
        CFStringGetCharacters(theString, v18, (UniChar *)v37);
        uint64_t v6 = v43;
      }
      UniChar v11 = *((_WORD *)v37 + v9 - v6);
    }
    uint64_t result = 0;
    if (v11 <= 0x2029u) {
      break;
    }
    unsigned int v21 = v11 - 8234;
    BOOL v12 = v21 > 0x3F;
    unint64_t v22 = (1 << v21) & 0xF00000000000001FLL;
    if (!v12 && v22 != 0) {
      return result;
    }
LABEL_37:
    ++v7;
    --v8;
    BOOL v12 = v9-- <= 0;
    if (v12) {
      return 1;
    }
  }
  if (v11 > 0x61Bu)
  {
    if (v11 - 8206 < 2 || v11 == 1564) {
      return result;
    }
    goto LABEL_37;
  }
  if (v11 == 32) {
    return result;
  }
  if (v11 != 46)
  {
    if (v11 == 47) {
      return result;
    }
    goto LABEL_37;
  }
  if (v9 >= v5) {
    return 0;
  }
  uint64_t v24 = v9 + 64;
  uint64_t v25 = -v9;
  for (uint64_t i = v9 + 1; ; --i)
  {
    uint64_t v27 = (unint64_t)v9 >= 0x40 ? 64 : v9;
    uint64_t v28 = i - 1;
    if (i - 1 < 1) {
      break;
    }
    if (v39)
    {
      UniChar v29 = v39[i - 2 + v41];
    }
    else if (v40)
    {
      UniChar v29 = v40[v41 - 2 + i];
    }
    else
    {
      if (v44 < v28 || v6 >= v28)
      {
        uint64_t v30 = -v27;
        uint64_t v31 = v27 + v25;
        CFIndex v32 = v24 - v27;
        uint64_t v33 = i + v30;
        CFIndex v34 = v33 + 63;
        if (v33 + 63 >= v42) {
          CFIndex v34 = v42;
        }
        uint64_t v43 = v33 - 1;
        uint64_t v44 = v34;
        v35.uint64_t location = v33 + v41 - 1;
        if (v42 >= v32) {
          CFIndex v36 = v32;
        }
        else {
          CFIndex v36 = v42;
        }
        v35.size_t length = v36 + v31;
        CFStringGetCharacters(theString, v35, (UniChar *)v37);
        uint64_t v6 = v43;
      }
      UniChar v29 = *((_WORD *)&v37[-1] + i - v6 + 6);
    }
    uint64_t result = 0;
    ++v25;
    --v24;
    --v9;
    if (v29 == 47) {
      return result;
    }
  }
  return 1;
}

BOOL CFAttributedStringGetBidiLevelsAndResolvedDirections(const __CFAttributedString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v173 = a4;
  uint64_t v224 = *(void *)off_1ECE0A5B0;
  if (!a1)
  {
    uint64_t v14 = @"attributedString cannot be NULL";
LABEL_285:
    CFLog(3, (uint64_t)v14, a3, a4, a5, a6, a7, a8, v166);
    return 0;
  }
  if (!a5)
  {
    uint64_t v14 = @"bidiLevels cannot be NULL";
    goto LABEL_285;
  }
  uint64_t v9 = a6;
  uint64_t v10 = a3;
  CFStringRef String = CFAttributedStringGetString(a1);
  long long v206 = 0u;
  long long v207 = 0u;
  long long v204 = 0u;
  long long v205 = 0u;
  long long v202 = 0u;
  long long v203 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v201 = 0u;
  CFStringRef theString = String;
  uint64_t v211 = a2;
  int64_t v212 = v10;
  CharactersPtr = CFStringGetCharactersPtr(String);
  if (CharactersPtr) {
    CStringPtr = 0;
  }
  else {
    CStringPtr = CFStringGetCStringPtr(String, 0x600u);
  }
  int64_t v213 = 0;
  int64_t v214 = 0;
  v210 = CStringPtr;
  if (!ubidi_open())
  {
    uint64_t v14 = @"ubidi_open return NULL object";
    goto LABEL_285;
  }
  if (v10 <= 0)
  {
    ubidi_close();
    return 0;
  }
  CFRange v167 = (unsigned char *)a5;
  int64_t v15 = 0;
  uint64_t UnicodePropertyDataForPlane = 0;
  uint64_t v176 = a2 - 1;
  char v177 = -1;
  uint64_t v168 = v10;
  uint64_t v169 = a2;
  uint64_t v170 = v9;
  do
  {
    int64_t v178 = v15 + 1;
    if (v15 < 0 || (int64_t v17 = v212, v212 <= v15))
    {
      unsigned int v21 = 0;
      goto LABEL_17;
    }
    CFRange v18 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      int64_t v19 = v211 + v15;
    }
    else
    {
      if (v210)
      {
        UniChar v20 = v210[v211 + v15];
        goto LABEL_33;
      }
      if (v214 <= v15 || (int64_t v131 = v213, v213 > v15))
      {
        int64_t v132 = v15 - 4;
        if ((unint64_t)v15 < 4) {
          int64_t v132 = 0;
        }
        if (v132 + 64 < v212) {
          int64_t v17 = v132 + 64;
        }
        int64_t v213 = v132;
        int64_t v214 = v17;
        v226.int location = v211 + v132;
        v226.size_t length = v17 - v132;
        CFStringGetCharacters(theString, v226, buffer);
        int64_t v131 = v213;
      }
      int64_t v19 = v15 - v131;
      CFRange v18 = buffer;
    }
    UniChar v20 = v18[v19];
LABEL_33:
    unsigned int v21 = v20;
    if (v20 >> 10 != 54) {
      goto LABEL_17;
    }
    int64_t v28 = v212;
    if (v212 <= v178) {
      goto LABEL_17;
    }
    UniChar v29 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      int64_t v30 = v211 + v178;
LABEL_37:
      UniChar v31 = v29[v30];
      goto LABEL_223;
    }
    if (!v210)
    {
      if (v214 <= v178 || (int64_t v140 = v213, v213 > v178))
      {
        int64_t v141 = v15 - 3;
        if ((unint64_t)v178 < 4) {
          int64_t v141 = 0;
        }
        if (v141 + 64 < v212) {
          int64_t v28 = v141 + 64;
        }
        int64_t v213 = v141;
        int64_t v214 = v28;
        v227.int location = v211 + v141;
        v227.size_t length = v28 - v141;
        CFStringGetCharacters(theString, v227, buffer);
        int64_t v140 = v213;
      }
      int64_t v30 = v178 - v140;
      UniChar v29 = buffer;
      goto LABEL_37;
    }
    UniChar v31 = v210[v211 + v178];
LABEL_223:
    if (v31 >> 10 == 55)
    {
      int64_t v133 = v212;
      if (v212 <= v178)
      {
        UniChar v136 = 0;
      }
      else
      {
        CFIndex v134 = (UniChar *)CharactersPtr;
        if (CharactersPtr)
        {
          int64_t v135 = v211 + v178;
        }
        else
        {
          if (v210)
          {
            UniChar v136 = v210[v211 + v178];
            goto LABEL_236;
          }
          if (v214 <= v178 || (int64_t v160 = v213, v213 > v178))
          {
            int64_t v161 = v15 - 3;
            if ((unint64_t)v15 < 3) {
              int64_t v161 = 0;
            }
            if (v161 + 64 < v212) {
              int64_t v133 = v161 + 64;
            }
            int64_t v213 = v161;
            int64_t v214 = v133;
            v228.int location = v211 + v161;
            v228.size_t length = v133 - v161;
            CFStringGetCharacters(theString, v228, buffer);
            int64_t v160 = v213;
          }
          int64_t v135 = v178 - v160;
          CFIndex v134 = buffer;
        }
        UniChar v136 = v134[v135];
      }
LABEL_236:
      int64_t v178 = v15 + 2;
      unsigned int v21 = (v21 << 10) + v136 - 56613888;
    }
LABEL_17:
    if ((HIWORD(v21) & 0x1F) != v177)
    {
      uint64_t UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(1u, HIWORD(v21) & 0x1F);
      char v177 = BYTE2(v21) & 0x1F;
    }
    if (UnicodePropertyDataForPlane)
    {
      unsigned int v22 = *(unsigned __int8 *)(UnicodePropertyDataForPlane + BYTE1(v21));
      if (v22 >= 0x13) {
        unsigned int v22 = *(unsigned __int8 *)(UnicodePropertyDataForPlane + (v22 << 8) - 4864 + v21 + 256);
      }
    }
    else
    {
      unsigned int v22 = 1;
    }
    BOOL v23 = v22 == 13;
    uint64_t v24 = v178;
    if (!v23 && v178 != v10) {
      goto LABEL_265;
    }
    uint64_t v25 = v176;
    uint64_t range = v176 + 1;
    uint64_t v171 = v176 + 1 - a2;
    if (v9) {
      uint64_t v26 = (void *)(v9 + v171);
    }
    else {
      uint64_t v26 = 0;
    }
    UErrorCode code = U_ZERO_ERROR;
    int64_t v27 = v178;
    if (v173 == -1)
    {
      if (v26) {
        int64_t v27 = v178;
      }
      uint64_t v25 = v176;
    }
    v172 = v26;
    uint64_t v223 = 0;
    CFIndex v180 = v27 + a2;
    uint64_t v174 = v27 + a2 - 1;
    uint64_t v175 = UnicodePropertyDataForPlane;
    memset(v222, 0, sizeof(v222));
    memset(v221, 0, sizeof(v221));
    int v220 = -1;
    v219[0] = -1;
    v219[1] = -1;
    int v218 = -1;
    v217[1] = -1;
    v217[0] = -1;
    uint64_t inRange = v174 - v25;
    if (v174 - v25 < 1)
    {
      int v186 = 0;
      char v181 = 0;
      uint64_t v119 = 0;
      CFIndex v36 = (void **)v221;
      ptrb = v222;
      goto LABEL_187;
    }
    CFIndex v32 = 0;
    uint64_t v33 = 0;
    uint64_t v191 = 0;
    char v181 = 0;
    int v186 = 0;
    char v34 = 0;
    CFRange v35 = v222;
    CFIndex v36 = (void **)v221;
    uint64_t v185 = 10;
    CFIndex v37 = v176 + 1;
    do
    {
      range_8 = v36;
      ptr = v35;
      v215[0] = -1;
      v215[1] = -1;
      int v216 = -1;
      if (v32 && (v34 & 1) != 0) {
        CFRelease(v32);
      }
      longestEffectiveRange.int location = 0;
      longestEffectiveRange.size_t length = 0;
      CFIndex loc = v37;
      v229.int location = v176 + 1;
      v229.size_t length = inRange;
      CFTypeRef AttributeAndLongestEffectiveRange = CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, v37, @"NSLink", v229, &longestEffectiveRange);
      CFIndex v39 = longestEffectiveRange.length + longestEffectiveRange.location;
      if (!AttributeAndLongestEffectiveRange) {
        goto LABEL_75;
      }
      uint64_t numChars = v39 - v37;
      if (v39 - v37 < 1) {
        goto LABEL_74;
      }
      int64_t v40 = v37 - v211;
      int64_t v41 = loc - v211 + numChars;
      CFIndex v42 = v211 - loc;
      uint64_t v43 = loc - v211 + 64;
      int64_t v44 = loc - v211;
      while (1)
      {
        if ((unint64_t)v44 >= 4) {
          uint64_t v45 = 4;
        }
        else {
          uint64_t v45 = v44;
        }
        if (v44 < 0 || (int64_t v46 = v212, v212 <= v44))
        {
          unsigned int v48 = 0;
          UniChar v47 = 0;
          goto LABEL_66;
        }
        if (CharactersPtr)
        {
          UniChar v47 = CharactersPtr[v44 + v211];
        }
        else if (v210)
        {
          UniChar v47 = v210[v211 + v44];
        }
        else
        {
          if (v214 <= v44 || (int64_t v49 = v213, v213 > v44))
          {
            uint64_t v50 = v45 + v42;
            uint64_t v51 = v43 - v45;
            int64_t v52 = v44 - v45;
            int64_t v53 = v52 + 64;
            if (v52 + 64 >= v212) {
              int64_t v53 = v212;
            }
            int64_t v213 = v52;
            int64_t v214 = v53;
            if (v212 >= v51) {
              int64_t v46 = v51;
            }
            v225.size_t length = v46 + v50;
            v225.int location = v52 + v211;
            CFStringGetCharacters(theString, v225, buffer);
            int64_t v49 = v213;
          }
          UniChar v47 = buffer[v44 - v49];
        }
        unsigned int v48 = v47;
        if (v47 > 0x7Fu) {
          break;
        }
LABEL_66:
        int v54 = *((_DWORD *)off_1ECE0A578 + v48 + 15);
        if ((v54 & 0x4000) != 0) {
          goto LABEL_75;
        }
        if (v48 > 0x7F)
        {
          if (__maskrune(v48, 0x500uLL)) {
            goto LABEL_73;
          }
        }
        else if ((v54 & 0x500) != 0)
        {
          goto LABEL_73;
        }
        if (v47 > 0x2Eu || ((1 << v47) & 0x680000000000) == 0) {
          break;
        }
LABEL_73:
        ++v44;
        --v42;
        ++v43;
        if (v44 >= v41) {
          goto LABEL_74;
        }
      }
      if ((v40 & 0x8000000000000000) == 0 && v41 <= v212)
      {
        if (CharactersPtr)
        {
          CFIndex v83 = (UniChar *)&CharactersPtr[v211 + v40];
        }
        else
        {
          if (numChars > 64) {
            goto LABEL_131;
          }
          if (v41 > v214 || (int64_t v93 = v213, v40 < v213))
          {
            int64_t v94 = v40 + 64;
            if (v40 + 64 >= v212) {
              int64_t v94 = v212;
            }
            int64_t v213 = v40;
            int64_t v214 = v94;
            v95.int location = v211 + v40;
            v95.size_t length = v94 - v40;
            if (v210)
            {
              if (v95.length)
              {
                long long v96 = &v210[v95.location];
                long long v97 = buffer;
                do
                {
                  UniChar v98 = *v96++;
                  *v97++ = v98;
                  --v95.length;
                }
                while (v95.length);
              }
              int64_t v93 = v40;
            }
            else
            {
              CFStringGetCharacters(theString, v95, buffer);
              int64_t v93 = v213;
            }
          }
          CFIndex v83 = &buffer[v40 - v93];
        }
        CFStringRef v102 = CFStringCreateWithCharactersNoCopy(0, v83, numChars, (CFAllocatorRef)&__kCFAllocatorNull);
        if (!v102) {
          goto LABEL_75;
        }
        CFStringRef v85 = v102;
        int v86 = 0;
LABEL_167:
        CFURLRef v103 = CFURLCreateWithString(0, v85, 0);
        if (!v103)
        {
          CFRelease(v85);
          if (v86) {
            goto LABEL_171;
          }
          goto LABEL_75;
        }
        CFRelease(v103);
        CFRelease(v85);
        if (v86) {
          CFAllocatorDeallocate(0, v83);
        }
LABEL_74:
        int valuePtr = 8;
        values.int location = 0;
        values.int location = (CFIndex)CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        char v34 = 1;
        CFIndex v32 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
        CFRelease((CFTypeRef)values.location);
        if (!v32) {
          goto LABEL_75;
        }
        goto LABEL_78;
      }
LABEL_131:
      uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(0, 2 * numChars, 0x1000040BDFB0063, 0);
      CFIndex v83 = Typed;
      if (CharactersPtr)
      {
        memmove(Typed, &CharactersPtr[v211 + v40], 2 * numChars);
      }
      else
      {
        int64_t v87 = v40 - v213;
        if (v40 < v213 || v214 <= v40)
        {
          if (v41 <= v213 || v41 >= v214)
          {
            int64_t v91 = v40;
            uint64_t v90 = Typed;
            CFIndex v92 = numChars;
          }
          else
          {
            int64_t v91 = v40;
            CFIndex v92 = v213 - v40;
            memmove(&Typed[v213 - v40], buffer, 2 * (v41 - v213));
            uint64_t v90 = v83;
          }
        }
        else
        {
          int64_t v88 = v40;
          if (numChars >= v214 - v40) {
            uint64_t v89 = v214 - v40;
          }
          else {
            uint64_t v89 = numChars;
          }
          memmove(Typed, &buffer[v87], 2 * v89);
          uint64_t v90 = &v83[v89];
          int64_t v91 = v89 + v88;
          CFIndex v92 = numChars - v89;
        }
        if (v92 >= 1)
        {
          v99.int location = v211 + v91;
          if (v210)
          {
            long long v100 = &v210[v99.location];
            do
            {
              UniChar v101 = *v100++;
              *v90++ = v101;
              --v92;
            }
            while (v92);
          }
          else
          {
            v99.size_t length = v92;
            CFStringGetCharacters(theString, v99, v90);
          }
        }
      }
      CFStringRef v84 = CFStringCreateWithCharactersNoCopy(0, v83, numChars, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v84)
      {
        CFStringRef v85 = v84;
        int v86 = 1;
        goto LABEL_167;
      }
LABEL_171:
      CFAllocatorDeallocate(0, v83);
LABEL_75:
      values.int location = 0;
      values.size_t length = 0;
      v230.int location = v176 + 1;
      v230.size_t length = inRange;
      CFIndex v32 = CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, loc, @"NSWritingDirection", v230, &values);
      char v34 = 0;
      CFIndex v55 = values.length + values.location;
      if (v39 < values.length + values.location) {
        CFIndex v55 = v39;
      }
      uint64_t numChars = v55 - loc;
LABEL_78:
      uint64_t v56 = v185;
      CFRange v35 = ptr;
      if (v186 + 2 <= (int)v185)
      {
        CFIndex v36 = range_8;
      }
      else
      {
        v179 = (void *)CFAllocatorAllocateTyped(0, 16 * v185, 0x10040436913F5, 0);
        memcpy(v179, range_8, 8 * (int)v185);
        CFRange v35 = (_OWORD *)CFAllocatorAllocateTyped(0, 8 * v185, 0x100004052888210, 0);
        memcpy(v35, ptr, 4 * (int)v185);
        if (v181)
        {
          CFAllocatorDeallocate(0, range_8);
          CFAllocatorDeallocate(0, ptr);
        }
        char v181 = 1;
        CFIndex v36 = (void **)v179;
        uint64_t v56 = (2 * v185);
      }
      uint64_t v185 = v56;
      if (!v32)
      {
        if (v33 >= 1)
        {
          uint64_t v74 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
          for (uint64_t i = 0; i != v33; ++i)
          {
            uint64_t v76 = *((int *)v217 + i);
            if (v76 > 8) {
              __int16 v77 = 0;
            }
            else {
              __int16 v77 = *(_WORD *)&aHI[2 * v76 + 4];
            }
            *(_WORD *)(v74 + 2 * i) = v77;
            *((_DWORD *)v217 + i) = -1;
          }
          uint64_t v78 = (_WORD *)(v74 + 2 * v33);
          uint64_t v33 = 0;
          CFIndex v73 = loc;
LABEL_125:
          *uint64_t v78 = 0;
          v36[v186] = (void *)v74;
          *((_DWORD *)v35 + v186++) = v73 - range;
          goto LABEL_127;
        }
LABEL_116:
        CFIndex v73 = loc;
        goto LABEL_127;
      }
      ptra = v35;
      CFIndex Count = CFArrayGetCount((CFArrayRef)v32);
      if (Count < 1) {
        goto LABEL_116;
      }
      CFIndex v58 = Count;
      char v183 = v34;
      range_8a = v36;
      CFIndex v59 = 0;
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      while (2)
      {
        LODWORD(values.location) = 0;
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v32, v59);
        CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &values);
        int location = values.location;
        if (LODWORD(values.location) == LODWORD(v219[0]))
        {
          uint64_t v65 = 0;
LABEL_91:
          if (LODWORD(values.location) == *((_DWORD *)v217 + v65))
          {
            if (v33 >= 1)
            {
              for (uint64_t j = 0; j < v33; ++j)
              {
                int v68 = *((_DWORD *)v217 + j);
                if (location != v68)
                {
                  *((_DWORD *)v215 + v61++) = v68;
                  *((_DWORD *)v217 + j) = -1;
                  --v33;
                }
              }
            }
            goto LABEL_106;
          }
          char v69 = 1;
          if (v62) {
            goto LABEL_106;
          }
LABEL_101:
          uint64_t v70 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
          uint64_t v62 = v70;
          int v71 = values.location;
          if (LODWORD(values.location) > 9) {
            __int16 v72 = 0;
          }
          else {
            __int16 v72 = *(_WORD *)&aFG[2 * SLODWORD(values.location)];
          }
          *(_WORD *)(v70 + 2 * v60++) = v72;
          *((_DWORD *)v217 + v33++) = v71;
          if ((v69 & 1) == 0) {
            *((_DWORD *)v219 + v191++) = v71;
          }
        }
        else
        {
          uint64_t v65 = 0;
          while (v65 != 3)
          {
            int v66 = *((_DWORD *)v219 + ++v65);
            if (LODWORD(values.location) == v66) {
              goto LABEL_91;
            }
          }
          char v69 = 0;
          if (!v62) {
            goto LABEL_101;
          }
        }
LABEL_106:
        if (++v59 != v58) {
          continue;
        }
        break;
      }
      if (v62)
      {
        *(_WORD *)(v62 + 2 * v6CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
        CFIndex v36 = range_8a;
        range_8a[v186] = (void *)v62;
        CFRange v35 = ptra;
        CFIndex v73 = loc;
        *((_DWORD *)ptra + v186++) = loc - range;
      }
      else
      {
        CFIndex v73 = loc;
        CFRange v35 = ptra;
        CFIndex v36 = range_8a;
      }
      if (v61 >= 1)
      {
        uint64_t v74 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
        for (uint64_t k = 0; k != v61; ++k)
        {
          uint64_t v80 = *((int *)v215 + k);
          if (v80 > 8) {
            __int16 v81 = 0;
          }
          else {
            __int16 v81 = *(_WORD *)&aHI[2 * v80 + 4];
          }
          *(_WORD *)(v74 + 2 * k) = v81;
        }
        uint64_t v78 = (_WORD *)(v74 + 2 * v61);
        char v34 = v183;
        goto LABEL_125;
      }
      char v34 = v183;
LABEL_127:
      CFIndex v37 = numChars + v73;
    }
    while (v37 < v180);
    char v104 = v34 ^ 1;
    if (!v32) {
      char v104 = 1;
    }
    if ((v104 & 1) == 0) {
      CFRelease(v32);
    }
    ptrb = v35;
    if (v33 < 1)
    {
      uint64_t v119 = 0;
      uint64_t v10 = v168;
    }
    else
    {
      uint64_t v105 = v36;
      uint64_t v106 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
      CFIndex v107 = (void *)v106;
      uint64_t v108 = 0;
      uint64_t UnicodePropertyDataForPlane = v175;
      do
      {
        uint64_t v109 = *((int *)v217 + v108);
        if (v109 > 8) {
          __int16 v110 = 0;
        }
        else {
          __int16 v110 = *(_WORD *)&aHI[2 * v109 + 4];
        }
        *(_WORD *)(v106 + 2 * v108++) = v110;
      }
      while (v33 != v108);
      *(_WORD *)(v106 + 2 * v33) = 0;
      ubidi_setContext();
      __int16 v111 = code;
      if (code >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        u_errorName(code);
        CFLog(3, @"ubidi_setContext() failed with errorCode: %d -- %s", v112, v113, v114, v115, v116, v117, v111);
        uint64_t v10 = v168;
        uint64_t v118 = v105;
        LODWORD(v105) = v186;
        goto LABEL_258;
      }
      uint64_t v119 = v107;
      uint64_t v10 = v168;
      CFIndex v36 = v105;
    }
LABEL_187:
    int64_t v120 = range - v211;
    if (range - v211 >= 0)
    {
      int64_t v121 = v212;
      if (v120 + inRange <= v212)
      {
        if (CharactersPtr)
        {
          uint64_t v118 = v36;
          CFIndex v107 = 0;
        }
        else
        {
          if (inRange > 64) {
            goto LABEL_189;
          }
          if (v120 + inRange > v214 || v120 < v213)
          {
            if (v120 + 64 < v212) {
              int64_t v121 = v120 + 64;
            }
            int64_t v213 = range - v211;
            int64_t v214 = v121;
            v127.size_t length = v121 - v120;
            if (v210)
            {
              if (v127.length)
              {
                v128 = &v210[v176 + 1];
                int v129 = buffer;
                do
                {
                  UniChar v130 = *v128++;
                  *v129++ = v130;
                  --v127.length;
                }
                while (v127.length);
              }
            }
            else
            {
              v127.int location = v176 + 1;
              CFStringGetCharacters(theString, v127, buffer);
            }
          }
          uint64_t v118 = v36;
          CFIndex v107 = 0;
        }
        goto LABEL_249;
      }
    }
LABEL_189:
    uint64_t v118 = v36;
    uint64_t v122 = (UniChar *)CFAllocatorAllocateTyped(0, 2 * inRange, 0x1000040BDFB0063, 0);
    v123 = v122;
    if (CharactersPtr)
    {
      memmove(v122, &CharactersPtr[v211 + v120], 2 * inRange);
      goto LABEL_191;
    }
    if (v120 < v213 || v214 <= v120)
    {
      if (v120 + inRange <= v213 || v120 + inRange >= v214)
      {
        CFRange v125 = v122;
        CFIndex v126 = inRange;
      }
      else
      {
        CFIndex v126 = v213 - v120;
        memmove(&v122[v213 - v120], buffer, 2 * (v120 + inRange - v213));
        CFRange v125 = v123;
      }
    }
    else
    {
      if (inRange >= v214 - v120) {
        uint64_t v124 = v214 - v120;
      }
      else {
        uint64_t v124 = inRange;
      }
      memmove(v122, &buffer[v120 - v213], 2 * v124);
      CFRange v125 = &v123[v124];
      v120 += v124;
      CFIndex v126 = inRange - v124;
    }
    if (v126 < 1) {
      goto LABEL_191;
    }
    v137.int location = v211 + v120;
    if (!v210)
    {
      v137.size_t length = v126;
      CFStringGetCharacters(theString, v137, v125);
LABEL_191:
      CFIndex v107 = v123;
LABEL_249:
      uint64_t UnicodePropertyDataForPlane = v175;
      goto LABEL_250;
    }
    v138 = &v210[v137.location];
    uint64_t UnicodePropertyDataForPlane = v175;
    do
    {
      UniChar v139 = *v138++;
      *v125++ = v139;
      --v126;
    }
    while (v126);
    CFIndex v107 = v123;
LABEL_250:
    UErrorCode code = U_ZERO_ERROR;
    ubidi_setParaWithControls();
    if (v119) {
      CFAllocatorDeallocate(0, v119);
    }
    __int16 v142 = code;
    if (code >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      u_errorName(code);
      CFLog(3, @"ubidi_setParaWithControls() failed with errorCode: %d -- %s", v143, v144, v145, v146, v147, v148, v142);
      goto LABEL_256;
    }
    Levels = (const void *)ubidi_getLevels();
    __int16 v150 = code;
    if (code < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (Levels) {
        memcpy(&v167[v171], Levels, inRange);
      }
      LODWORD(v105) = v186;
      if (v172)
      {
        int ParaLevel = ubidi_getParaLevel();
        memset(v172, ParaLevel, inRange);
      }
    }
    else
    {
      u_errorName(code);
      CFLog(3, @"ubidi_getLevels() failed with errorCode: %d -- %s", v151, v152, v153, v154, v155, v156, v150);
LABEL_256:
      LODWORD(v105) = v186;
    }
    if (v107) {
LABEL_258:
    }
      CFAllocatorDeallocate(0, v107);
    if ((int)v105 >= 1)
    {
      uint64_t v105 = (void **)v105;
      v157 = v118;
      do
      {
        v158 = *v157++;
        CFAllocatorDeallocate(0, v158);
        uint64_t v105 = (void **)((char *)v105 - 1);
      }
      while (v105);
    }
    a2 = v169;
    if (v181)
    {
      CFAllocatorDeallocate(0, v118);
      CFAllocatorDeallocate(0, ptrb);
    }
    uint64_t v176 = v174;
    uint64_t v24 = v178;
    uint64_t v9 = v170;
LABEL_265:
    int64_t v15 = v24;
  }
  while (v24 < v10);
  ubidi_close();
  if (*v167) {
    return 1;
  }
  uint64_t v162 = 1;
  do
  {
    uint64_t v163 = v162;
    if (v10 == v162) {
      break;
    }
    char v164 = v167[v162++];
  }
  while ((v164 & 1) == 0);
  return v163 < v10;
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  if (!CF_IS_OBJC(0x3EuLL, (unint64_t)aStr)) {
    return (CFStringRef)*((void *)aStr + 2);
  }

  return (CFStringRef)[(__CFAttributedString *)aStr string];
}

uint64_t _CFAttributedStringCheckAndReplaceAttributed(uint64_t a1, CFIndex a2, CFIndex a3, const __CFAttributedString *a4)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3;
  }
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  if (v11) {
    return 1;
  }
  v12.int location = a2;
  v12.size_t length = a3;
  if (a4) {
    CFAttributedStringReplaceAttributedString((CFMutableAttributedStringRef)a1, v12, a4);
  }
  else {
    CFAttributedStringReplaceString((CFMutableAttributedStringRef)a1, v12, &stru_1ECE10768);
  }
  return 0;
}

void CFAttributedStringReplaceAttributedString(CFMutableAttributedStringRef aStr, CFRange range, CFAttributedStringRef replacement)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    -[__CFAttributedString replaceCharactersInRange:withAttributedString:](aStr, "replaceCharactersInRange:withAttributedString:", location, length, replacement);
  }
  else
  {
    if (CF_IS_OBJC(0x3EuLL, (unint64_t)replacement)) {
      CFStringRef v7 = (const __CFString *)[(__CFAttributedString *)replacement string];
    }
    else {
      CFStringRef v7 = (const __CFString *)*((void *)replacement + 2);
    }
    CFIndex v8 = CFStringGetLength(v7);
    if (v8 >= 1)
    {
      CFAllocatorRef v9 = CFGetAllocator(aStr);
      CFIndex v10 = 0;
      effectiveRange.CFIndex location = 0;
      effectiveRange.CFIndex length = 0;
      do
      {
        CFDictionaryRef Attributes = CFAttributedStringGetAttributes(replacement, v10, &effectiveRange);
        CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v9, Attributes);
        CFRunArrayInsert(*((CFTypeRef *)aStr + 3), effectiveRange.location + location, effectiveRange.length, AttributesDictionary);
        CFRelease(AttributesDictionary);
        CFIndex v10 = effectiveRange.location + effectiveRange.length;
        effectiveRange.CFIndex location = v10;
      }
      while (v10 < v8);
    }
    if (length >= 1) {
      CFRunArrayDelete(*((void **)aStr + 3), v8 + location, length);
    }
    v16.CFIndex location = location;
    v16.CFIndex length = length;
    CFStringReplace(*((CFMutableStringRef *)aStr + 2), v16, v7);
  }
}

CFStringRef _CFStringCreateByAddingPercentEncodingWithAllowedCharacters(const __CFAllocator *a1, CFStringRef theString, const __CFCharacterSet *a3)
{
  v46[1] = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(theString);
  if (Length)
  {
    CFIndex v7 = Length;
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding == -1) {
      return 0;
    }
    CFIndex v10 = MaximumSizeForEncoding;
    CFStringRef v11 = 0;
    size_t v12 = 4 * MaximumSizeForEncoding;
    if (!(4 * MaximumSizeForEncoding)) {
      return v11;
    }
    *((void *)&v13 + 1) = ((MaximumSizeForEncoding + __PAIR128__(1, 0xC000000000000000)) >> 64) & 1;
    *(void *)&long long v13 = MaximumSizeForEncoding - 0x4000000000000000;
    if ((unint64_t)(v13 >> 63) < 3 || MaximumSizeForEncoding >> 62 << 63 >> 63 < 0) {
      return v11;
    }
    if (v12 < 0x401)
    {
      MEMORY[0x1F4188790](MaximumSizeForEncoding, v9);
      uint64_t v14 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v14, v12);
    }
    else
    {
      uint64_t v14 = malloc_type_malloc(4 * MaximumSizeForEncoding, 0x100004077774924uLL);
    }
    v46[0] = 0;
    v48.CFIndex location = 0;
    v48.CFIndex length = v7;
    CFStringRef v11 = 0;
    if (CFStringGetBytes(theString, v48, 0x8000100u, 0, 0, v14, v10, v46) != v7)
    {
LABEL_76:
      if (v12 >= 0x401) {
        free(v14);
      }
      return v11;
    }
    CFRange v16 = &v14[v10];
    if (InitializeURLAllowedCharacterSets_static_init == -1)
    {
      if (a3)
      {
LABEL_16:
        uint64_t v17 = 0;
        while (*(const __CFCharacterSet **)(sURLAllowedCharacterSets + 8 * v17) != a3)
        {
          if (++v17 == 7) {
            goto LABEL_19;
          }
        }
        __int16 v21 = 2;
        switch(v17)
        {
          case 0:
            goto LABEL_68;
          case 1:
            __int16 v21 = 4;
            goto LABEL_68;
          case 2:
            CFIndex v22 = v46[0];
            if (v46[0] <= 1) {
              goto LABEL_79;
            }
            if (*v14 == 91)
            {
              if (v14[v46[0] - 1] == 93)
              {
                char v23 = 0;
                uint64_t v24 = v14 + 1;
                UInt8 *v16 = 91;
                CFRange v18 = v16 + 1;
                CFIndex v22 = v46[0] - 2;
                v46[0] -= 2;
                char v25 = 1;
              }
              else
              {
LABEL_79:
                char v25 = 0;
                char v23 = 1;
                CFRange v18 = &v14[v10];
                uint64_t v24 = v14;
              }
              if (v22 < 1)
              {
LABEL_93:
                if ((v23 & 1) == 0) {
                  *v18++ = 93;
                }
                goto LABEL_75;
              }
            }
            else
            {
              char v25 = 0;
              char v23 = 1;
              uint64_t v24 = v14;
              CFRange v18 = &v14[v10];
            }
            CFIndex v40 = 0;
            do
            {
              int v41 = (char)v24[v40];
              unint64_t v42 = v24[v40];
              if ((v41 & 0x80000000) == 0
                && (v41 == 58 ? (char v43 = v25) : (char v43 = 0), (v43 & 1) != 0 || (sURLAllowedCharacters[v42] & 8) != 0))
              {
                *v18++ = v41;
              }
              else
              {
                *CFRange v18 = 37;
                v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v42 >> 4];
                void v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v42 & 0xF];
                v18 += 3;
              }
              ++v40;
            }
            while (v40 < v46[0]);
            goto LABEL_93;
          case 3:
            CFRange v18 = &v14[v10];
            if (v46[0] < 1) {
              goto LABEL_75;
            }
            char v26 = 0;
            uint64_t v27 = 0;
            int64_t v28 = &__NLStringTokenizerSetStringWithOptions;
            UniChar v29 = &__NLStringTokenizerSetStringWithOptions;
            int64_t v30 = "0123456789ABCDEF";
            CFRange v18 = v16;
            break;
          case 4:
            __int16 v21 = 64;
            goto LABEL_68;
          case 5:
            __int16 v21 = 128;
            goto LABEL_68;
          case 7:
            goto LABEL_19;
          default:
            __int16 v21 = 0;
LABEL_68:
            CFRange v18 = &v14[v10];
            if (v46[0] >= 1)
            {
              CFIndex v37 = 0;
              CFRange v18 = v16;
              do
              {
                int v38 = (char)v14[v37];
                unint64_t v39 = v14[v37];
                if (v38 < 0 || ((unsigned __int16)v21 & sURLAllowedCharacters[v39]) == 0)
                {
                  *CFRange v18 = 37;
                  v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v39 >> 4];
                  void v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v39 & 0xF];
                  v18 += 3;
                }
                else
                {
                  *v18++ = v38;
                }
                ++v37;
              }
              while (v37 < v46[0]);
            }
            goto LABEL_75;
        }
        while (1)
        {
          unint64_t v31 = v14[v27];
          if (v26) {
            break;
          }
          int v33 = 0;
          char v26 = v31 == 47;
          if ((v31 & 0x80) == 0 && v31 != 58) {
            int v33 = (sURLAllowedCharacters[v31] >> 5) & 1;
          }
          if (v28[240] != (uint64_t (*)(void))-1)
          {
            HIDWORD(v44) = v31 == 47;
            unint64_t v45 = v31;
            dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_19);
            unint64_t v31 = v45;
            char v26 = BYTE4(v44);
            int64_t v30 = "0123456789ABCDEF";
            UniChar v29 = &__NLStringTokenizerSetStringWithOptions;
            int64_t v28 = &__NLStringTokenizerSetStringWithOptions;
          }
          if (*((unsigned char *)v29 + 1904))
          {
            if (!v33) {
              goto LABEL_62;
            }
          }
          else
          {
            if (v31 == 59) {
              char v35 = 0;
            }
            else {
              char v35 = v33;
            }
            if ((v35 & 1) == 0)
            {
LABEL_62:
              *CFRange v18 = 37;
              v18[1] = v30[v31 >> 4];
              void v18[2] = v30[v31 & 0xF];
              v18 += 3;
              goto LABEL_63;
            }
          }
          *v18++ = v31;
LABEL_63:
          if (++v27 >= v46[0]) {
            goto LABEL_75;
          }
        }
        if ((v31 & 0x80) != 0) {
          int v32 = 0;
        }
        else {
          int v32 = (sURLAllowedCharacters[v31] >> 5) & 1;
        }
        if (v28[240] != (uint64_t (*)(void))-1)
        {
          CFIndex v36 = v30;
          unint64_t v45 = v14[v27];
          dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_19);
          unint64_t v31 = v45;
          int64_t v30 = v36;
          UniChar v29 = &__NLStringTokenizerSetStringWithOptions;
          int64_t v28 = &__NLStringTokenizerSetStringWithOptions;
        }
        if (*((unsigned char *)v29 + 1904))
        {
          if (v32)
          {
LABEL_51:
            *v18++ = v31;
LABEL_57:
            char v26 = 1;
            goto LABEL_63;
          }
        }
        else
        {
          if (v31 == 59) {
            char v34 = 0;
          }
          else {
            char v34 = v32;
          }
          if (v34) {
            goto LABEL_51;
          }
        }
        *CFRange v18 = 37;
        v18[1] = v30[v31 >> 4];
        void v18[2] = v30[v31 & 0xF];
        v18 += 3;
        goto LABEL_57;
      }
    }
    else
    {
      dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
      if (a3) {
        goto LABEL_16;
      }
    }
LABEL_19:
    CFRange v18 = &v14[v10];
    if (v46[0] >= 1)
    {
      CFIndex v19 = 0;
      CFRange v18 = v16;
      do
      {
        int v20 = (char)v14[v19];
        if (v20 < 0 || !CFCharacterSetIsCharacterMember(a3, v14[v19]))
        {
          *CFRange v18 = 37;
          v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[(unint64_t)v20 >> 4];
          void v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v20 & 0xF];
          v18 += 3;
        }
        else
        {
          *v18++ = v20;
        }
        ++v19;
      }
      while (v19 < v46[0]);
    }
LABEL_75:
    CFStringRef v11 = CFStringCreateWithBytes(0, v16, v18 - v16, 0x8000100u, 0);
    goto LABEL_76;
  }

  return CFStringCreateCopy(a1, theString);
}

void sub_182C7F38C(_Unwind_Exception *exception_object)
{
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  v3[0] = 1;
  long long v4 = 0u;
  uint64_t v5 = 0;
  v3[1] = format;
  return __CFPropertyListIsValidAux(plist, v3);
}

CFDictionaryRef CFPreferencesCopyMultiple(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyMultipleWithContainer((uint64_t)keysToFetch, (__CFString *)applicationID, (__CFString *)userName, hostName, 0);
}

void CFBurstTrieCursorRelease(void *a1)
{
  if (a1) {
    free(a1);
  }
}

void __CFBundleDeallocate(void *a1)
{
  unsigned int v3 = (const void *)a1[2];
  CFDictionaryRef v2 = (const __CFDictionary *)a1[3];
  a1[2] = 0;
  if (v2) {
    CFDictionaryGetValue(v2, @"CFBundleIdentifier");
  }
  _CFBundleUnloadExecutable((uint64_t)a1, 0);
  _CFBundleDeallocatePlugIn((uint64_t)a1);
  if (v3) {
    CFRelease(v3);
  }
  long long v4 = (const void *)a1[3];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[4];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a1[5];
  if (v6) {
    CFRelease(v6);
  }
  CFIndex v7 = (const void *)a1[13];
  if (v7) {
    CFRelease(v7);
  }
  CFIndex v8 = (const void *)a1[27];
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)a1[18];
  if (v9) {
    CFRelease(v9);
  }
  CFIndex v10 = (const void *)a1[19];
  if (v10) {
    CFRelease(v10);
  }
  CFStringRef v11 = (const void *)a1[20];
  if (v11) {
    CFRelease(v11);
  }
  size_t v12 = (const void *)a1[21];
  if (v12) {
    CFRelease(v12);
  }
  long long v13 = (const void *)a1[24];
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = (const void *)a1[23];
  if (v14) {
    CFRelease(v14);
  }
  int64_t v15 = (const void *)a1[15];
  if (v15) {
    CFRelease(v15);
  }
  CFRange v16 = (const void *)a1[17];
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v17 = (const void *)a1[26];
  if (v17)
  {
    CFRelease(v17);
  }
}

void _CFBundleUnloadExecutable(uint64_t a1, int a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  if (!a2) {
    _CFPlugInUnloadScheduledPlugIns();
  }
  os_unfair_lock_lock_with_options();
  int v5 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  if (v5)
  {
    _CFPlugInUnscheduleForUnloading((const void *)a1);
    _CFPlugInWillUnload(a1);
    os_unfair_lock_lock_with_options();
    if (*(unsigned char *)(a1 + 52) && (*(_DWORD *)(a1 + 48) != 4 || _CFExecutableLinkedOnOrAfter(5uLL))) {
      _CFBundleDlfcnUnload(a1);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
}

uint64_t _CFPlugInUnloadScheduledPlugIns()
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  os_unfair_recursive_lock_lock_with_options();
  if (_plugInsToUnload)
  {
    CFIndex Count = CFSetGetCount((CFSetRef)_plugInsToUnload);
    if (Count >= 1)
    {
      CFIndex v1 = Count;
      uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0x2004093837F09, 0);
      CFSetGetValues((CFSetRef)_plugInsToUnload, Typed);
      for (uint64_t i = 0; i != v1; ++i)
      {
        uint64_t v4 = (uint64_t)Typed[i];
        if (!*(_DWORD *)(__CFBundleGetPlugInData(v4) + 12))
        {
          if (_CFBundlePluginLogger_onceToken != -1) {
            dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
          }
          int v5 = _CFBundlePluginLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543362;
            uint64_t v8 = v4;
            _os_log_debug_impl(&dword_182B90000, v5, OS_LOG_TYPE_DEBUG, "PlugIn %{public}@ is about to be unloaded", buf, 0xCu);
          }
          _CFBundleUnloadExecutable(v4, 1);
        }
      }
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _CFBundleDeallocatePlugIn(uint64_t a1)
{
  PlugInCFDataRef Data = __CFBundleGetPlugInData(a1);
  os_unfair_recursive_lock_lock_with_options();
  if (*(unsigned char *)PlugInData)
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDeallocatePlugIn_cold_1(a1);
    }
    int Count = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
    if (Count >= 1)
    {
      unint64_t v4 = Count + 1;
      do
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(PlugInData + 16), (v4 - 2));
        _CFPFactoryDisableLocked(ValueAtIndex);
        --v4;
      }
      while (v4 > 1);
    }
    CFRelease(*(CFTypeRef *)(PlugInData + 16));
    *(unsigned char *)PlugInCFDataRef Data = 0;
  }
  return os_unfair_recursive_lock_unlock();
}

BOOL __CFRunLoopDoTimers(uint64_t a1, uint64_t a2, unint64_t a3)
{
  kdebug_trace();
  CFArrayRef v6 = *(const __CFArray **)(a2 + 120);
  if (!v6) {
    goto LABEL_16;
  }
  CFIndex Count = CFArrayGetCount(v6);
  if (Count < 1) {
    goto LABEL_16;
  }
  CFIndex v8 = Count;
  CFIndex v9 = 0;
  CFSetRef Mutable = 0;
  do
  {
    CFNumberRef ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v9);
    char v12 = atomic_load(ValueAtIndex + 1);
    if ((v12 & 8) != 0)
    {
      long long v13 = ValueAtIndex;
      if ((ValueAtIndex[2] & 1) == 0 && ValueAtIndex[16] <= a3)
      {
        if (!Mutable) {
          CFSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        }
        CFArrayAppendValue(Mutable, v13);
      }
    }
    ++v9;
  }
  while (v8 != v9);
  if (Mutable)
  {
    CFIndex v14 = CFArrayGetCount(Mutable);
    if (v14 < 1)
    {
      BOOL v16 = 0;
    }
    else
    {
      CFIndex v15 = 0;
      BOOL v16 = 0;
      do
      {
        uint64_t v17 = (char *)CFArrayGetValueAtIndex(Mutable, v15);
        BOOL v16 = (v16 | __CFRunLoopDoTimer(a1, a2, v17)) != 0;
        ++v15;
      }
      while (v14 != v15);
    }
    CFRelease(Mutable);
  }
  else
  {
LABEL_16:
    BOOL v16 = 0;
  }
  kdebug_trace();
  return v16;
}

void sub_182C7FB00(_Unwind_Exception *a1)
{
}

void sub_182C7FB20(void *a1)
{
}

uint64_t __CFRunLoopDoTimer(uint64_t a1, uint64_t a2, char *cf)
{
  uint64_t v47 = *(void *)off_1ECE0A5B0;
  CFRetain(cf);
  pthread_mutex_lock((pthread_mutex_t *)(cf + 24));
  char v6 = atomic_load((unint64_t *)cf + 1);
  if ((v6 & 8) == 0
    || (uint64_t v7 = *((void *)cf + 16), v7 > mach_absolute_time())
    || (__int16 v8 = *((_WORD *)cf + 8), (v8 & 1) != 0)
    || *((void *)cf + 11) != a1)
  {
    uint64_t v9 = 0;
    atomic_load((unint64_t *)cf + 1);
LABEL_6:
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    goto LABEL_7;
  }
  uint64_t v12 = *((void *)cf + 20);
  CFStringRef v11 = (uint64_t (*)(void))*((void *)cf + 21);
  if (v11)
  {
    uint64_t v12 = v11(*((void *)cf + 20));
    int64_t v46 = (void (*)(uint64_t))*((void *)cf + 22);
    __int16 v8 = *((_WORD *)cf + 8);
  }
  else
  {
    int64_t v46 = 0;
  }
  double v13 = *((double *)cf + 14);
  *((_WORD *)cf + 8) = v8 | 1;
  *(void *)(a2 + 184) = -1;
  *(void *)(a2 + 192) = -1;
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
  os_unfair_lock_lock_with_options();
  unint64_t v14 = *((void *)cf + 16);
  os_unfair_lock_t v44 = (os_unfair_lock_t)(a1 + 684);
  unint64_t v45 = v14;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 684));
  __CFArmNextTimerInMode(a2);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  CFIndex v15 = (uint64_t (*)(uint64_t, uint64_t))*((void *)cf + 18);
  BOOL v16 = (void *)_CFAutoreleasePoolPush();
  kdebug_trace();
  __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(v15, (uint64_t)cf, v12);
  kdebug_trace();
  __CFRunLoopPerCalloutARPEnd(v16);
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (v13 == 0.0) {
    CFRunLoopTimerInvalidate((CFRunLoopTimerRef)cf);
  }
  if (v46) {
    v46(v12);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(cf + 24));
  *((_WORD *)cf + 8) &= ~1u;
  char v17 = atomic_load((unint64_t *)cf + 1);
  if ((v17 & 8) == 0)
  {
    uint64_t v9 = 1;
    goto LABEL_6;
  }
  if (v45 < *((void *)cf + 16))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    __CFArmNextTimerInMode(a2);
LABEL_47:
    uint64_t v9 = 1;
    goto LABEL_7;
  }
  double v18 = *((double *)cf + 14);
  if (v18 <= 0.0)
  {
    unint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    if (v45 >= 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  if (v18 > 504911232.0) {
    double v18 = 504911232.0;
  }
  unint64_t v19 = __CFTimeIntervalToTSR(v18);
  if ((v19 ^ 0x7FFFFFFFFFFFFFFFLL) <= v45)
  {
    unint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_34;
  }
  unint64_t v20 = v19;
  if (!v19) {
LABEL_32:
  }
    __CFRunLoopDoTimer_cold_1();
  uint64_t v21 = mach_absolute_time();
  unint64_t v22 = v45 - v20;
  do
    v22 += v20;
  while (v22 <= v21);
LABEL_34:
  char v23 = (const void *)*((void *)cf + 11);
  if (!v23)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    CFIndex v36 = v44;
    os_unfair_lock_lock(v44);
    *((void *)cf + 16) = v22;
    double Current = CFAbsoluteTimeGetCurrent();
    *((double *)cf + 13) = Current + __CFTimeIntervalUntilTSR(v22);
    os_unfair_lock_unlock(v36);
    goto LABEL_47;
  }
  CFRetain(*((CFTypeRef *)cf + 11));
  CFIndex Count = CFSetGetCount(*((CFSetRef *)cf + 12));
  MEMORY[0x1F4188790](Count, v25);
  uint64_t v27 = (const void **)((char *)&v44 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v26 >= 0x200) {
    size_t v28 = 512;
  }
  else {
    size_t v28 = v26;
  }
  bzero((char *)&v44 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0), v28);
  CFSetGetValues(*((CFSetRef *)cf + 12), v27);
  if (Count < 1)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
  }
  else
  {
    UniChar v29 = v27;
    CFIndex v30 = Count;
    do
    {
      unint64_t v31 = *v29++;
      CFRetain(v31);
      --v30;
    }
    while (v30);
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    int v32 = (const __CFString **)v27;
    CFIndex v33 = Count;
    do
    {
      CFStringRef v34 = *v32;
      uint64_t v35 = __CFRunLoopCopyMode((uint64_t)v23, *v32, 0);
      *int v32 = (const __CFString *)v35;
      if (v35) {
        pthread_mutex_lock((pthread_mutex_t *)(v35 + 16));
      }
      CFRelease(v34);
      ++v32;
      --v33;
    }
    while (v33);
  }
  int v38 = v44;
  os_unfair_lock_lock(v44);
  *((void *)cf + 16) = v22;
  double v39 = CFAbsoluteTimeGetCurrent();
  *((double *)cf + 13) = v39 + __CFTimeIntervalUntilTSR(v22);
  if (Count < 1)
  {
    os_unfair_lock_unlock(v38);
  }
  else
  {
    CFIndex v40 = (uint64_t *)v27;
    CFIndex v41 = Count;
    do
    {
      if (*v40) {
        __CFRepositionTimerInMode(*v40, cf, 1);
      }
      ++v40;
      --v41;
    }
    while (v41);
    os_unfair_lock_unlock(v44);
    unint64_t v42 = v27 - 1;
    do
    {
      char v43 = (char *)v42[Count];
      if (v43)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v43 + 16));
        CFRelease(v42[Count]);
      }
      --Count;
    }
    while ((unint64_t)(Count + 1) > 1);
  }
  CFRelease(v23);
  uint64_t v9 = 1;
LABEL_7:
  CFRelease(cf);
  return v9;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(uint64_t (*result)(uint64_t, uint64_t), uint64_t a2, uint64_t a3))(uint64_t, uint64_t)
{
  if (result) {
    return (uint64_t (*)(uint64_t, uint64_t))result(a2, a3);
  }
  return result;
}

double __CFTimeIntervalUntilTSR(unint64_t a1)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
  }
  uint64_t v2 = mach_absolute_time();
  unint64_t v3 = v2 - a1;
  if (v2 <= a1)
  {
    unint64_t v5 = a1 - v2;
    if (CFDateGetTypeID_initOnce != -1) {
      dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
    }
    return *(double *)&__CF1_TSRRate * (double)v5;
  }
  else
  {
    if (CFDateGetTypeID_initOnce != -1) {
      dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_115_0);
    }
    return -(*(double *)&__CF1_TSRRate * (double)v3);
  }
}

uint64_t _runLoopTimerWithBlockContext(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t __CFURLReservedPtr(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 40);
    if (v1) {
      return *(void *)v1;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t _CFStringGetFileSystemRepresentation(__CFString *a1, unsigned char *a2, uint64_t a3)
{
  if (CFStringGetLength(a1)) {
    return [(__CFString *)a1 getFileSystemRepresentation:a2 maxLength:a3];
  }
  if (!a3) {
    return 0;
  }
  *a2 = 0;
  return 1;
}

CFURLRef _CFBundleCopyFrameworkURLForExecutablePath(uint64_t a1)
{
  return __CFBundleCopyFrameworkURLForExecutablePath(a1, 0);
}

CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void *block)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  v6.CFIndex version = 0;
  v6.info = block;
  v6.CFAllocatorRetainCallBack retain = (const void *(__cdecl *)(const void *))off_1ECE0A568;
  v6.CFArrayReleaseCallBack release = (void (__cdecl *)(const void *))off_1ECE0A570;
  v6.copyDescription = 0;
  return CFRunLoopObserverCreate(allocator, activities, repeats, order, (CFRunLoopObserverCallBack)_runLoopObserverWithBlockContext, &v6);
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  int v9 = repeats;
  uint64_t v25 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t Instance = _CFRuntimeCreateInstance((__objc2_class **)allocator, 0x2DuLL, 144, 0);
  uint64_t v13 = Instance;
  if (Instance)
  {
    unint64_t v14 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v15 = v14;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v15, v14 | 8);
      BOOL v16 = v15 == v14;
      unint64_t v14 = v15;
    }
    while (!v16);
    unint64_t v17 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v18 = v17;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v18, v17 & 0xFFFFFFFFFFFFFFFELL);
      BOOL v16 = v18 == v17;
      unint64_t v17 = v18;
    }
    while (!v16);
    unint64_t v19 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v20 = v19;
    if (v9)
    {
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v20, v19 | 2);
        BOOL v16 = v20 == v19;
        unint64_t v19 = v20;
      }
      while (!v16);
    }
    else
    {
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v20, v19 & 0xFFFFFFFFFFFFFFFDLL);
        BOOL v16 = v20 == v19;
        unint64_t v19 = v20;
      }
      while (!v16);
    }
    v24.__sig = 0;
    *(void *)v24.__opaque = 0;
    pthread_mutexattr_init(&v24);
    pthread_mutexattr_settype(&v24, 2);
    pthread_mutex_init((pthread_mutex_t *)(v13 + 16), &v24);
    pthread_mutexattr_destroy(&v24);
    *(void *)(v13 + 8CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
    *(void *)(v13 + 88) = 0;
    *(void *)(v13 + 96) = activities;
    *(void *)(v13 + 104) = order;
    *(void *)(v13 + 112) = callout;
    if (context)
    {
      info = context->info;
      CFAllocatorRetainCallBack retain = context->retain;
      if (retain) {
        info = (void *)((uint64_t (*)(void *))retain)(info);
      }
      *(void *)(v13 + 128) = info;
      *(_OWORD *)(v13 + 136) = *(_OWORD *)&context->retain;
      *(void *)(v13 + 152) = context->copyDescription;
    }
  }
  return (CFRunLoopObserverRef)v13;
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  if (!_CFURLHasFileURLScheme((unint64_t)url, &v13))
  {
    if (v13)
    {
      if (error)
      {
LABEL_7:
        CFIndex v10 = CFErrorCreate(0, @"NSCocoaErrorDomain", 262, 0);
        LOBYTE(IsReachable) = 0;
        goto LABEL_8;
      }
    }
    else
    {
      CFLog(4, @"CFURLResourceIsReachable failed because it was passed a URL which has no scheme", v3, v4, v5, v6, v7, v8, v12);
      if (error) {
        goto LABEL_7;
      }
    }
    LOBYTE(IsReachable) = 0;
    return IsReachable;
  }
  int IsReachable = _FSURLResourceIsReachable();
  if (!IsReachable && error)
  {
    CFIndex v10 = CFErrorCreate(0, @"NSCocoaErrorDomain", 4, 0);
LABEL_8:
    *CFErrorRef error = v10;
  }
  return IsReachable;
}

CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void *block)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  v7.CFIndex version = 0;
  v7.info = block;
  v7.CFAllocatorRetainCallBack retain = (const void *(__cdecl *)(const void *))off_1ECE0A568;
  v7.CFArrayReleaseCallBack release = (void (__cdecl *)(const void *))off_1ECE0A570;
  v7.copyDescription = 0;
  return CFRunLoopTimerCreate(allocator, fireDate, interval, flags, order, (CFRunLoopTimerCallBack)_runLoopTimerWithBlockContext, &v7);
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  uint64_t v7 = MEMORY[0x1F4188790](allocator, flags);
  int v9 = v8;
  uint64_t v11 = v10;
  uint64_t v13 = v12;
  double v15 = v14;
  double v17 = v16;
  unint64_t v18 = (__objc2_class **)v7;
  uint64_t v33 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v18, 0x2FuLL, 176, 0);
  uint64_t v20 = Instance;
  if (Instance)
  {
    unint64_t v21 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v22 = v21;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v22, v21 | 8);
      BOOL v23 = v22 == v21;
      unint64_t v21 = v22;
    }
    while (!v23);
    *(_WORD *)(Instance + 16) &= ~1u;
    *(void *)v32.__opaque = 0;
    v32.__sig = 0;
    pthread_mutexattr_init(&v32);
    pthread_mutexattr_settype(&v32, 2);
    pthread_mutex_init((pthread_mutex_t *)(v20 + 24), &v32);
    pthread_mutexattr_destroy(&v32);
    *(void *)(v20 + 88) = 0;
    *(void *)(v20 + 96) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    *(void *)(v20 + 136) = v13;
    if (v15 < 0.0) {
      double v15 = 0.0;
    }
    *(void *)(v20 + 12CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
    if (v17 <= 4039289860.0) {
      double v24 = v17;
    }
    else {
      double v24 = 4039289860.0;
    }
    *(double *)(v20 + 104) = v24;
    *(double *)(v20 + 112) = v15;
    uint64_t v25 = mach_absolute_time();
    double Current = CFAbsoluteTimeGetCurrent();
    double v27 = Current;
    if (v24 >= Current)
    {
      double v28 = v24 - Current;
      if (v24 - v27 > 504911232.0) {
        double v28 = 504911232.0;
      }
      *(void *)(v20 + 128) = __CFTimeIntervalToTSR(v28) + v25;
    }
    else
    {
      *(void *)(v20 + 128) = v25;
    }
    *(void *)(v20 + 144) = v11;
    if (v9)
    {
      uint64_t v29 = v9[1];
      CFIndex v30 = (uint64_t (*)(uint64_t))v9[2];
      if (v30) {
        uint64_t v29 = v30(v29);
      }
      *(void *)(v20 + 16CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v29;
      *(_OWORD *)(v20 + 168) = *((_OWORD *)v9 + 1);
      *(void *)(v20 + 184) = v9[4];
    }
    kdebug_trace();
  }
  return (CFRunLoopTimerRef)v20;
}

const void *_CFCopySystemVersionDictionaryValue(const void *a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)_CFCopyServerVersionDictionary();
  if (!v2)
  {
    CFDictionaryRef v2 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (!v2) {
      return 0;
    }
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v2, a1);
  uint64_t v4 = Value;
  if (Value) {
    CFRetain(Value);
  }
  CFRelease(v2);
  return v4;
}

CFTypeRef _CFCopySystemVersionDictionary()
{
  if (_CFCopySystemVersionDictionary_onceToken != -1) {
    dispatch_once(&_CFCopySystemVersionDictionary_onceToken, &__block_literal_global_20_0);
  }
  CFTypeRef result = (CFTypeRef)_CFCopySystemVersionDictionary_result;
  if (_CFCopySystemVersionDictionary_result)
  {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef _CFCopyServerVersionDictionary()
{
  if (_CFCopyServerVersionDictionary_onceToken != -1) {
    dispatch_once(&_CFCopyServerVersionDictionary_onceToken, &__block_literal_global_32);
  }
  CFTypeRef result = (CFTypeRef)_CFCopyServerVersionDictionary_result;
  if (_CFCopyServerVersionDictionary_result)
  {
    return CFRetain(result);
  }
  return result;
}

CFDictionaryRef _CFCopyVersionDictionary(CFStringRef filePath)
{
  resourceData[1] = *(CFDataRef *)off_1ECE0A5B0;
  CFURLRef v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, filePath, kCFURLPOSIXPathStyle, 0);
  if (!v1) {
    return 0;
  }
  CFURLRef v2 = v1;
  resourceData[0] = 0;
  if (!CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, resourceData, 0, 0, 0))
  {
    CFRelease(v2);
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, resourceData[0], 1uLL, 0, 0);
  CFRelease(resourceData[0]);
  CFRelease(v2);
  if (v3)
  {
    CFTypeRef cf = 0;
    CFStringRef v4 = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, @"Version");
    CFStringRef v5 = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, @"Build");
    CFStringRef format = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, @"FullVersionString");
    if (cf) {
      CFRelease(cf);
    }
    CFDictionaryRef Value = CFDictionaryGetValue(v3, @"ProductBuildVersionOverride");
    if (Value) {
      CFDictionarySetValue(v3, @"ProductBuildVersion", Value);
    }
    CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(v3, @"ProductVersion");
    uint64_t v8 = CFDictionaryGetValue(v3, @"ProductVersionExtra");
    int v9 = v8;
    if (v7 && v8) {
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@ %@", v7, v8);
    }
    uint64_t v10 = (__CFString *)CFDictionaryGetValue(v3, @"ProductBuildVersion");
    uint64_t v11 = @"?";
    if (v7) {
      CFStringRef v12 = v7;
    }
    else {
      CFStringRef v12 = @"?";
    }
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    if (v10) {
      uint64_t v11 = v10;
    }
    StringWithValidatedCFStringRef Format = CFStringCreateStringWithValidatedFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@ %@", format, 0, v12, v11);
    CFStringRef v15 = StringWithValidatedFormat;
    if (StringWithValidatedFormat && !CFEqual(StringWithValidatedFormat, @"FullVersionString")) {
      double v16 = (void *)CFRetain(v15);
    }
    else {
      double v16 = (void *)CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@ %@ (%@ %@)", v4, v12, v5, v11);
    }
    double v17 = v16;
    if (v7 && v9) {
      CFRelease(v7);
    }
    if (v15) {
      CFRelease(v15);
    }
    CFDictionarySetValue(v3, @"Version", v4);
    CFDictionarySetValue(v3, @"Build", v5);
    CFDictionarySetValue(v3, @"FullVersionString", v17);
    CFDictionarySetValue(v3, @"ShortVersionString", Copy);
    CFRelease(v4);
    CFRelease(v5);
    CFRelease(format);
    CFRelease(v17);
    CFRelease(Copy);
  }
  return v3;
}

CFStringRef _CFCopyLocalizedVersionKey(CFBundleRef *a1, CFStringRef key)
{
  if (a1 && (CFStringRef v4 = *a1) != 0)
  {
    CFStringRef v5 = CFBundleCopyLocalizedString(*a1, key, key, @"SystemVersion");
  }
  else
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"/System/Library/CoreServices/SystemVersion.bundle");
    CFURLRef v7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, Copy, kCFURLPOSIXPathStyle, 0);
    CFRelease(Copy);
    if (!v7) {
      goto LABEL_10;
    }
    CFStringRef v4 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
    CFRelease(v7);
    if (!v4) {
      goto LABEL_10;
    }
    CFStringRef v5 = CFBundleCopyLocalizedString(v4, key, key, @"SystemVersion");
    if (!a1)
    {
      CFRelease(v4);
      if (v5) {
        return v5;
      }
      goto LABEL_10;
    }
  }
  *a1 = v4;
  if (v5) {
    return v5;
  }
LABEL_10:

  return (CFStringRef)CFRetain(key);
}

CFStringRef CFStringCreateStringWithValidatedFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, CFErrorRef *errorPtr, ...)
{
  return _CFStringCreateStringWithValidatedFormatAux(alloc, (uint64_t)formatOptions, 0, (uint64_t)validFormatSpecifiers);
}

CFStringRef _CFStringCreateStringWithValidatedFormatAux(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  Mutable[1].info = Mutable[1].info & 0xF | 0x780;
  if (__CFStringAppendFormatCore(Mutable, 0, 0, a2, 0, a3, a4)) {
    CFStringRef Copy = CFStringCreateCopy(a1, Mutable);
  }
  else {
    CFStringRef Copy = 0;
  }
  CFRelease(Mutable);
  return Copy;
}

uint64_t _CFXPreferencesCopyDictionaryForNamedVolatileSource(__CFString *a1)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    CFURLRef v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    CFURLRef v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v3 = -[_CFXPreferences copyDictionaryForVolatileSourceWithName:]((uint64_t)v2, a1);

  return v3;
}

void sub_182C81D8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

void _CFXPreferencesReplaceValuesInNamedVolatileSource(uint64_t a1, const __CFDictionary *a2)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v4 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v5 = (id)v4;
  -[_CFXPreferences replaceValuesInVolatileSourceNamed:withValues:](v4, a1, a2);
}

void _CFXPreferencesRegisterDefaultValues(uint64_t a1)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    CFURLRef v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    CFURLRef v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v3 = v2;
  [v2 registerDefaultValues:a1];
}

void withKeysAndValues(const __CFDictionary *a1, uint64_t a2)
{
  v15[1] = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    unint64_t Count = CFDictionaryGetCount(a1);
    uint64_t v6 = 2 * Count;
    if (((Count >> 59) & 0xF) != 0)
    {
      CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt", v6);
      uint64_t v13 = +[NSException exceptionWithName:@"NSGenericException" reason:v12 userInfo:0];
      CFRelease(v12);
      objc_exception_throw(v13);
    }
    if (Count)
    {
      unint64_t v7 = MEMORY[0x1F4188790](v6, v4);
      int v9 = (const void **)((char *)v15 - v8);
      v15[0] = 0;
      if (v7 >= 0x101)
      {
        uint64_t v10 = (const void **)_CFCreateArrayStorage(v7, 0, v15);
        int v9 = v10;
      }
      else
      {
        uint64_t v10 = 0;
      }
    }
    else
    {
      MEMORY[0x1F4188790](v6, v4);
      int v9 = (const void **)v14;
      uint64_t v10 = 0;
      v15[0] = 0;
    }
    uint64_t v11 = &v9[Count];
    CFDictionaryGetKeysAndValues(a1, v9, v11);
  }
  else
  {
    MEMORY[0x1F4188790](0, a2);
    uint64_t v11 = (const void **)v14;
    uint64_t v10 = 0;
    unint64_t Count = 0;
    v15[0] = 0;
    int v9 = (const void **)v14;
  }
  (*(void (**)(uint64_t, const void **, const void **, unint64_t))(a2 + 16))(a2, v9, v11, Count);
  free(v10);
}

void sub_182C822EC(_Unwind_Exception *exception_object)
{
}

void sub_182C82600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _addBackstopValuesForIdentifierAndSource(const void *a1, os_unfair_lock_s *a2)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  if (CFEqual(a1, @"NSRegistrationDomain"))
  {
    CFRange values = @"en-001";
    CFArrayRef v4 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    v25[0] = xmmword_1ECDFD478;
    v25[1] = *(_OWORD *)&off_1ECDFD488;
    v24[0] = (size_t)v4;
    v24[1] = (size_t)@"en_001";
    void v24[2] = (size_t)v4;
    v24[3] = (size_t)@"macintosh";
    if (a2) {
      -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:](a2, (uint64_t)v24, (uint64_t)v25, 4uLL, 1, 0, 0, 0);
    }
    CFRelease(v4);
  }
  else if (CFEqual(a1, @"NSArgumentDomain"))
  {
    if (getDefaultArguments_onceToken != -1) {
      dispatch_once(&getDefaultArguments_onceToken, &__block_literal_global_270);
    }
    id v5 = (void *)getDefaultArguments___NSDefaultArguments;
    if (getDefaultArguments___NSDefaultArguments)
    {
      unint64_t v6 = [(id)getDefaultArguments___NSDefaultArguments count];
      unint64_t v8 = v6;
      if (v6 >> 60)
      {
        CFStringRef v19 = CFStringCreateWithFormat(0, 0, @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt", v6);
        uint64_t v20 = +[NSException exceptionWithName:@"NSGenericException" reason:v19 userInfo:0];
        CFRelease(v19);
        objc_exception_throw(v20);
      }
      if (v6 <= 1) {
        unint64_t v9 = 1;
      }
      else {
        unint64_t v9 = v6;
      }
      uint64_t v10 = MEMORY[0x1F4188790](v6, v7);
      uint64_t v13 = (char *)&v22 - v12;
      *(void *)&v25[0] = 0;
      if (v8 > 0x100)
      {
        double v16 = (char *)_CFCreateArrayStorage(v9, 0, (size_t *)v25);
        MEMORY[0x1F4188790](v16, v18);
        CFStringRef v15 = (char *)&v21;
        v24[0] = 0;
        double v17 = (char *)_CFCreateArrayStorage(v9, 0, v24);
        uint64_t v13 = v16;
      }
      else
      {
        MEMORY[0x1F4188790](v10, v11);
        CFStringRef v15 = (char *)&v22 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
        double v16 = 0;
        double v17 = 0;
        v24[0] = 0;
      }
      if (v8 >= 0x101) {
        CFStringRef v15 = v17;
      }
      [v5 getObjects:v13 andKeys:v15 count:v8];
      if (a2) {
        -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:](a2, (uint64_t)v13, (uint64_t)v15, v8, 0, 0, 0, 0);
      }
      free(v17);
      free(v16);
    }
  }
}

void sub_182C82A1C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C82EE8(_Unwind_Exception *a1)
{
  free(*(void **)(v2 - 160));
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C82F54(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x182C82F58);
  }
  objc_terminate();
}

void sub_182C82F64(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x182C82DA4);
  }
  JUMPOUT(0x182C82F4CLL);
}

void sub_182C832FC(_Unwind_Exception *exception_object)
{
}

__CFArray *CFCopySearchPathForDirectoriesInDomains(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t started = sysdir_start_search_path_enumeration_private();
  uint64_t v6 = MEMORY[0x185312640](started, __s);
  if (v6)
  {
    uint64_t v7 = v6;
    size_t v8 = -1;
    do
    {
      unint64_t v9 = __s;
      if (a3 && __s[0] == 126)
      {
        if ((v8 & 0x8000000000000000) != 0)
        {
          uint64_t v10 = CFCopyHomeDirectoryURLForUser(0);
          if (v10)
          {
            uint64_t v11 = v10;
            CFURLGetFileSystemRepresentation((CFURLRef)v10, 1u, buffer, 1026);
            size_t v8 = strlen((const char *)buffer);
            CFRelease(v11);
          }
        }
        if (strlen(__s) + v8 > 0x401) {
          goto LABEL_12;
        }
        unint64_t v9 = (const char *)buffer;
        buffer[v8] = 0;
        __strlcat_chk();
      }
      size_t v12 = strlen(v9);
      CFURLRef v13 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v12, 1u);
      if (v13)
      {
        CFURLRef v14 = v13;
        CFArrayAppendValue(Mutable, v13);
        CFRelease(v14);
      }
LABEL_12:
      uint64_t v7 = MEMORY[0x185312640](v7, __s);
    }
    while (v7);
  }
  return Mutable;
}

const UInt8 *CFCopyHomeDirectoryURLForUser(const __CFString *a1)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (a1)
  {
    CFIndex Length = (int)CFStringGetLength(a1);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex usedBufLen = 0;
    uint64_t v4 = MaximumSizeForEncoding << 32;
    if ((int)MaximumSizeForEncoding > 126) {
      uint64_t Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, ((MaximumSizeForEncoding << 32) + 0x100000000) >> 32, 1826429807, 0);
    }
    else {
      uint64_t Typed = buffer;
    }
    v14.CFIndex location = 0;
    v14.CFIndex length = Length;
    CFIndex Bytes = CFStringGetBytes(a1, v14, 0x8000100u, 0, 1u, Typed, v4 >> 32, &usedBufLen);
    size_t v8 = 0;
    if (Bytes == Length)
    {
      Typed[usedBufLen] = 0;
      size_t v8 = (const char *)Typed;
    }
    unint64_t v9 = _CFCopyHomeDirURLForUser(v8, 0);
    if (buffer != Typed) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    return v9;
  }
  else
  {
    return _CFCopyHomeDirURLForUser(0, 1);
  }
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  uint64_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone systemTimeZone];
  if (v1) {
    CFTimeZoneRef v2 = (const __CFTimeZone *)CFRetain(v1);
  }
  else {
    CFTimeZoneRef v2 = 0;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

objc_class *__NSOrderedSetParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  v24[1] = *(void *)off_1ECE0A5B0;
  if ((a4 & 0x1000000000000000) != 0)
  {
    uint64_t v6 = result;
    if (!a5)
    {
      uint64_t v14 = __CFExceptionProem(result, a2);
      CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"%@: index set is nil", v14);
      double v16 = +[NSException exceptionWithName:@"NSInvalidArgumentException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v15) userInfo:0];
      objc_exception_throw(v16);
    }
    unint64_t v7 = [a5 lastIndex];
    CFTypeRef result = (objc_class *)[(objc_class *)v6 count];
    if ((v7 & 0x8000000000000000) != 0 || v7 != 0x7FFFFFFFFFFFFFFFLL && (unint64_t)result <= v7)
    {
      if (result)
      {
        double v17 = result;
        uint64_t v8 = _os_log_pack_size();
        uint64_t v10 = (char *)v24 - ((MEMORY[0x1F4188790](v8, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        uint64_t v19 = _os_log_pack_fill();
        uint64_t v20 = PROEM_SEL_1(a2);
        double v17 = (objc_class *)((char *)v17 - 1);
        __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(v19, (uint64_t)"NSOrderedSet", (uint64_t)v20, v7, (uint64_t)v17);
        BOOL v23 = PROEM_SEL_1(a2);
        CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** -[%s %s]: index %lu beyond bounds [0 .. %lu]", "NSOrderedSet", v23, v7, v17);
      }
      else
      {
        uint64_t v8 = _os_log_pack_size();
        uint64_t v10 = (char *)v24 - ((MEMORY[0x1F4188790](v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0);
        uint64_t v11 = _os_log_pack_fill();
        uint64_t v12 = PROEM_SEL_1(a2);
        __os_log_helper_1_2_3_8_32_8_32_8_0(v11, (uint64_t)"NSOrderedSet", (uint64_t)v12, v7);
        uint64_t v22 = PROEM_SEL_1(a2);
        CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"*** -[%s %s]: index %lu beyond bounds for empty array", "NSOrderedSet", v22, v7);
      }
      uint64_t v21 = +[NSException exceptionWithName:@"NSRangeException" reason:_CFAutoreleasePoolAddObject(0, (uint64_t)v13) userInfo:0 osLogPack:v10 size:v8];
      objc_exception_throw(v21);
    }
  }
  return result;
}

uint64_t _CFURLCopyComponents(unint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = (void *)a1;
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x1DuLL, a1)) {
    id v5 = (void *)[v5 _cfurl];
  }
  if (a2 == 2)
  {
    CFAllocatorRef v7 = CFGetAllocator(v5);
    memset(v21, 0, sizeof(v21));
    long long v19 = 0u;
    long long v20 = 0u;
    long long v18 = 0u;
    uint64_t result = decomposeToRFC1808((unint64_t)v5, (const __CFString **)&v18);
    if (!result) {
      return result;
    }
    uint64_t v9 = (const void *)*((void *)&v18 + 1);
    *(void *)a3 = v18;
    if (v9)
    {
      uint64_t v10 = (const void *)v19;
      if ((void)v19)
      {
        *(void *)(a3 + 8) = CFStringCreateWithFormat(v7, 0, @"%@:%@", v9, (void)v19);
        CFRelease(v10);
        CFRelease(v9);
      }
      else
      {
        *(void *)(a3 + 8) = v9;
      }
    }
    else
    {
      *(void *)(a3 + 8) = 0;
    }
    uint64_t v11 = v20;
    *(void *)(a3 + 16) = *((void *)&v19 + 1);
    *(void *)(a3 + 24) = v11;
    CFArrayRef v13 = (const __CFArray *)*((void *)&v20 + 1);
    uint64_t v12 = *(const void **)&v21[0];
    if (*(void *)&v21[0])
    {
      int Count = CFArrayGetCount(*((CFArrayRef *)&v20 + 1));
      MutableCFStringRef Copy = CFArrayCreateMutableCopy(v7, Count, v13);
      *(void *)(a3 + 32) = MutableCopy;
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, Count - 1);
      CFStringRef v17 = CFStringCreateWithFormat(v7, 0, @"%@;%@", ValueAtIndex, v12);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a3 + 32), Count - 1, v17);
      CFRelease(v17);
      if (v13) {
        CFRelease(v13);
      }
      CFRelease(v12);
    }
    else
    {
      *(void *)(a3 + 32) = *((void *)&v20 + 1);
    }
    *(_OWORD *)(a3 + 4CFNotificationCenterRemoveObserver(center, observer, 0, 0) = *(_OWORD *)((char *)v21 + 8);
    *(void *)(a3 + 56) = *((void *)&v21[1] + 1);
    return 1;
  }
  if (a2 != 1)
  {
    if (a2) {
      return 0;
    }
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)v5))
    {
      if ([v5 baseURL])
      {
LABEL_8:
        CFStringRef v6 = 0;
LABEL_19:
        *(void *)a3 = v6;
        *(void *)(a3 + 8) = CFURLCopyResourceSpecifier((CFURLRef)v5);
        return 1;
      }
    }
    else if (v5[4])
    {
      goto LABEL_8;
    }
    CFStringRef v6 = CFURLCopyScheme((CFURLRef)v5);
    goto LABEL_19;
  }

  return decomposeToRFC1808((unint64_t)v5, (const __CFString **)a3);
}

char *CFStorageGetValues(char *result, uint64_t a2, uint64_t a3, char *a4)
{
  v41[1] = *(void *)off_1ECE0A5B0;
  if (a3 >= 1)
  {
    uint64_t v5 = a3;
    CFAllocatorRef v7 = result;
    uint64_t v8 = (os_unfair_lock_s *)(result + 128);
    CFIndex v37 = (pthread_mutex_t *)(result + 32);
    uint64_t v38 = (uint64_t)(result + 144);
    while (1)
    {
      os_unfair_lock_lock_with_options();
      uint64_t v10 = (uint64_t *)*((void *)v7 + 13);
      uint64_t v9 = *((void *)v7 + 14);
      uint64_t v11 = *((void *)v7 + 15);
      os_unfair_lock_unlock(v8);
      if (!v10) {
        break;
      }
      if (!v10[3])
      {
        CFAllocatorRef v12 = CFGetAllocator(v7);
        uint64_t v13 = *v10;
        uint64_t v14 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v15 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v15 = v14 + 1;
        }
        if (v13 <= v15 >> 1)
        {
          uint64_t v19 = v13 + 63;
          BOOL v22 = v13 < -63;
          uint64_t v20 = v13 + 126;
          if (!v22) {
            uint64_t v20 = v19;
          }
          int64_t v17 = v20 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v16 = (v13 + v14 - 1) & -(int)v14;
          if (*((void *)v7 + 17) >= v16) {
            int64_t v17 = v16;
          }
          else {
            int64_t v17 = *((void *)v7 + 17);
          }
        }
        if (v17 > v10[2])
        {
          pthread_mutex_lock(v37);
          if (v17 > v10[2])
          {
            v10[3] = __CFSafelyReallocateWithAllocatorTyped(v12, v10[3], v17, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            void v10[2] = v17;
          }
          pthread_mutex_unlock(v37);
        }
      }
      uint64_t v18 = *((unsigned int *)v7 + 6);
      uint64_t v21 = a2 - v9;
      BOOL v22 = a2 < v9 || v11 + v9 <= a2;
      if (v22) {
        goto LABEL_31;
      }
      uint64_t v23 = v18 == 0xFFFFFFFFLL ? *((void *)v7 + 2) * v21 : v21 << v18;
      uint64_t v24 = v10[3];
      if (!v24) {
        goto LABEL_31;
      }
      Byte = (const void *)(v24 + v23);
LABEL_42:
      if (v5 >= v9 - a2 + v11) {
        uint64_t v35 = v9 - a2 + v11;
      }
      else {
        uint64_t v35 = v5;
      }
      if (v18 == 0xFFFFFFFFLL) {
        size_t v36 = *((void *)v7 + 2) * v35;
      }
      else {
        size_t v36 = v35 << v18;
      }
      uint64_t result = (char *)memmove(a4, Byte, v36);
      a4 += v36;
      a2 += v35;
      BOOL v22 = v5 <= v35;
      v5 -= v35;
      if (v22) {
        return result;
      }
    }
    uint64_t v18 = *((unsigned int *)v7 + 6);
LABEL_31:
    uint64_t v40 = 0;
    v41[0] = 0;
    uint64_t v39 = 0;
    if (v18 == 0xFFFFFFFFLL) {
      uint64_t v26 = *((void *)v7 + 2) * a2;
    }
    else {
      uint64_t v26 = a2 << v18;
    }
    Byte = (const void *)__CFStorageFindByte(v7, v38, v26, 0, v41, &v39, 0);
    uint64_t v27 = v41[0];
    uint64_t v28 = v39;
    if (v41[0])
    {
      uint64_t v29 = *(void *)v41[0];
      int v30 = *((_DWORD *)v7 + 6);
      if (v30 == -1)
      {
        uint64_t v33 = *((void *)v7 + 2);
        uint64_t v31 = v39 / v33;
        uint64_t v32 = v29 / v33;
      }
      else
      {
        uint64_t v31 = v39 >> v30;
        uint64_t v32 = v29 >> v30;
      }
    }
    else
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
    }
    os_unfair_lock_lock_with_options();
    *((void *)v7 + 13) = v27;
    *((void *)v7 + 14) = v31;
    *((void *)v7 + 15) = v32;
    os_unfair_lock_unlock(v8);
    uint64_t v18 = *((unsigned int *)v7 + 6);
    if (v18 == -1)
    {
      uint64_t v34 = *((void *)v7 + 2);
      uint64_t v9 = v28 / v34;
      uint64_t v11 = v40 / v34;
    }
    else
    {
      uint64_t v9 = v28 >> v18;
      uint64_t v11 = v40 >> v18;
    }
    goto LABEL_42;
  }
  return result;
}

uint64_t __CFStringValidateFormatSpec(const __CFString *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v27 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = _CFGetTSD(1u);
  if (v6) {
    CFAllocatorRef v7 = (const __CFAllocator *)v6;
  }
  else {
    CFAllocatorRef v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  ptr = 0;
  uint64_t v20 = 0;
  int64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  CFIndex Length = CFStringGetLength(a1);
  __CFStringSetUpFormatAndSpecBuffers(a1, Length, &v21, &v20, (UniChar **)&ptr, v26, (uint64_t *)&v18, (uint64_t)v25, (uint64_t *)&v17, (uint64_t)v23);
  uint64_t v9 = v17;
  uint64_t v10 = v18;
  FormatSpecifiersInCFStringRef String = __CFStringFindFormatSpecifiersInString((uint64_t)v21, (uint64_t)v20, Length, (uint64_t)v18, (uint64_t)v17, &v22);
  int v12 = __CFStringValidateFormatSpecBuffers(a2, 1, 1, (uint64_t)v10, FormatSpecifiersInString, v22, a3);
  if (ptr && ptr != v26) {
    CFAllocatorDeallocate(v7, ptr);
  }
  if (v10 != v25) {
    CFAllocatorDeallocate(v7, v10);
  }
  uint64_t v13 = v22;
  if (v22 >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = (const void *)v9[v14];
      if (v15)
      {
        CFRelease(v15);
        uint64_t v13 = v22;
      }
      ++v14;
    }
    while (v14 < v13);
  }
  if (v9 != (void *)v23) {
    CFAllocatorDeallocate(v7, v9);
  }
  if (v12) {
    return a3 + 1;
  }
  else {
    return -1;
  }
}

uint64_t __CFStringValidateFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  int v30 = v3;
  uint64_t v5 = v4;
  CFStringRef v7 = v6;
  CFStringRef v8 = (const __CFString *)v2;
  uint64_t v51 = *(void *)off_1ECE0A5B0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v9 = _CFGetTSD(1u);
  if (v9) {
    CFAllocatorRef v10 = (const __CFAllocator *)v9;
  }
  else {
    CFAllocatorRef v10 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  CFIndex v37 = 0;
  uint64_t v38 = 0;
  uint64_t v35 = 0;
  ptr = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v46 = 0;
  memset(v45, 0, sizeof(v45));
  uint64_t v44 = 0;
  memset(v43, 0, sizeof(v43));
  CFIndex Length = CFStringGetLength(v7);
  __CFStringSetUpFormatAndSpecBuffers(v7, Length, &v40, &v39, (UniChar **)&ptr, v50, (uint64_t *)&v34, (uint64_t)v48, (uint64_t *)&v32, (uint64_t)v45);
  CFIndex v12 = CFStringGetLength(v8);
  __CFStringSetUpFormatAndSpecBuffers(v8, v12, &v38, &v37, (UniChar **)&v35, v49, (uint64_t *)&v33, (uint64_t)v47, (uint64_t *)&v31, (uint64_t)v43);
  uint64_t v13 = v34;
  uint64_t v14 = v32;
  FormatSpecifiersInCFStringRef String = __CFStringFindFormatSpecifiersInString((uint64_t)v40, (uint64_t)v39, Length, (uint64_t)v34, (uint64_t)v32, &v42);
  int v16 = v33;
  int64_t v17 = v31;
  int v18 = __CFStringFindFormatSpecifiersInString((uint64_t)v38, (uint64_t)v37, v12, (uint64_t)v33, (uint64_t)v31, &v41);
  int v19 = __CFStringValidateFormatSpecBuffers(v13, FormatSpecifiersInString, v42, (uint64_t)v16, v18, v41, v5);
  int v20 = v19;
  if (v30 && (v19 & 1) == 0)
  {
    CFStringRef v21 = CFStringCreateWithFormat(v10, 0, @"Format '%@' does not match expected '%@'", v7, v8);
    CFMutableStringRef Mutable = CFDictionaryCreateMutable(v10, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, @"NSDebugDescription", v21);
    *int v30 = CFErrorCreate(v10, @"NSCocoaErrorDomain", 2048, Mutable);
    CFRelease(Mutable);
    CFRelease(v21);
  }
  if (ptr && ptr != v50) {
    CFAllocatorDeallocate(v10, ptr);
  }
  if (v35 && v35 != v49) {
    CFAllocatorDeallocate(v10, v35);
  }
  if (v13 != (unsigned __int16 *)v48) {
    CFAllocatorDeallocate(v10, v13);
  }
  if (v16 != v47) {
    CFAllocatorDeallocate(v10, v16);
  }
  uint64_t v23 = v42;
  if (v42 >= 1)
  {
    uint64_t v24 = 0;
    do
    {
      uint64_t v25 = (const void *)v14[v24];
      if (v25)
      {
        CFRelease(v25);
        uint64_t v23 = v42;
      }
      ++v24;
    }
    while (v24 < v23);
  }
  uint64_t v26 = v41;
  if (v41 >= 1)
  {
    uint64_t v27 = 0;
    do
    {
      uint64_t v28 = (const void *)v17[v27];
      if (v28)
      {
        CFRelease(v28);
        uint64_t v26 = v41;
      }
      ++v27;
    }
    while (v27 < v26);
  }
  if (v14 != (void *)v45) {
    CFAllocatorDeallocate(v10, v14);
  }
  if (v17 != (void *)v43) {
    CFAllocatorDeallocate(v10, v17);
  }
  if (v20) {
    return v5 + FormatSpecifiersInString;
  }
  else {
    return -1;
  }
}

void __CFStringSetUpFormatAndSpecBuffers(const __CFString *a1, CFIndex a2, char **a3, UniChar **a4, UniChar **a5, UniChar *a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
  uint64_t v18 = _CFGetTSD(1u);
  int v19 = &__kCFAllocatorSystemDefault;
  if (v18) {
    int v19 = (__objc2_class **)v18;
  }
  uint64_t v41 = v19;
  if (!CF_IS_OBJC(7uLL, (unint64_t)a1))
  {
    char v20 = atomic_load((unint64_t *)&a1->info);
    char v21 = atomic_load((unint64_t *)&a1->info);
    uint64_t v22 = v21 & 0x60;
    p_uint64_t data = &a1->data;
    if ((v20 & 0x10) == 0)
    {
      if (v22)
      {
        uint64_t v24 = *p_data;
      }
      else
      {
        uint64_t v26 = atomic_load((unint64_t *)&a1->info);
        uint64_t v24 = (char *)&p_data[(v26 & 5) != 4];
      }
      *a3 = v24;
      if (v24)
      {
        unint64_t v27 = atomic_load((unint64_t *)&a1->info);
        uint64_t v28 = &(*a3)[(v27 >> 2) & 1];
        *a3 = v28;
        if (v28) {
          goto LABEL_16;
        }
      }
      goto LABEL_22;
    }
    if (v22)
    {
      uint64_t v25 = *p_data;
    }
    else
    {
      uint64_t v29 = atomic_load((unint64_t *)&a1->info);
      uint64_t v25 = (char *)&p_data[(v29 & 5) != 4];
    }
    *a4 = (UniChar *)v25;
  }
  uint64_t v28 = *a3;
  if (*a3) {
    goto LABEL_16;
  }
LABEL_22:
  if (*a4) {
    goto LABEL_23;
  }
  if (a2 <= 400)
  {
    *a5 = a6;
  }
  else
  {
    uint64_t Typed = CFAllocatorAllocateTyped(v41, 2 * a2, 0x1000040BDFB0063, 0);
    *a5 = (UniChar *)Typed;
    if ((UniChar *)Typed == a6 || __CFOASafe == 0)
    {
      a6 = (UniChar *)Typed;
    }
    else
    {
      __CFSetLastAllocationEventName();
      a6 = *a5;
    }
  }
  v43.CFIndex location = 0;
  v43.CFIndex length = a2;
  CFStringGetCharacters(a1, v43, a6);
  *a4 = *a5;
  uint64_t v28 = *a3;
  if (!*a3)
  {
LABEL_23:
    if (a2 >= 1)
    {
      int v30 = 0;
      uint64_t v32 = *a4;
      do
      {
        int v33 = *v32++;
        if (v33 == 37) {
          ++v30;
        }
        --a2;
      }
      while (a2);
      goto LABEL_28;
    }
LABEL_41:
    *a7 = a8;
    *a9 = a10;
    return;
  }
LABEL_16:
  if (a2 < 1) {
    goto LABEL_41;
  }
  int v30 = 0;
  do
  {
    int v31 = *v28++;
    if (v31 == 37) {
      ++v30;
    }
    --a2;
  }
  while (a2);
LABEL_28:
  uint64_t v34 = (2 * v30) | 1u;
  if ((int)v34 < 62) {
    goto LABEL_41;
  }
  uint64_t v35 = CFAllocatorAllocateTyped(v41, 32 * ((2 * v30) | 1u), 0x10000408E5DAE1CLL, 0);
  *a7 = v35;
  if (v35 != a8 && __CFOASafe != 0) {
    __CFSetLastAllocationEventName();
  }
  uint64_t v37 = CFAllocatorAllocateTyped(v41, 8 * v34, 0x6004044C4A2DFLL, 0);
  *a9 = v37;
  if (v37 != a10 && __CFOASafe != 0)
  {
    __CFSetLastAllocationEventName();
  }
}

uint64_t __CFStringFindFormatSpecifiersInString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v83 = *(void *)off_1ECE0A5B0;
  if (a3 >= 1)
  {
    LODWORD(v9) = 0;
    LODWORD(v1CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
    if (a5) {
      BOOL v11 = a6 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    int v12 = !v11;
    long long v13 = xmmword_182DAF8B0;
    uint64_t v78 = a4;
    int v77 = v12;
    while (1)
    {
      uint64_t v14 = a4 + 32 * (int)v10;
      *(_DWORD *)(v14 + 4) = v9;
      uint64_t v15 = (int *)(v14 + 4);
      *(_OWORD *)(v14 + 8) = v13;
      int v16 = (_DWORD *)(v14 + 8);
      *(_DWORD *)uint64_t v14 = 0;
      int64_t v17 = (unsigned char *)(v14 + 26);
      *(_DWORD *)(v14 + 24) = -1;
      int v18 = v9;
      uint64_t v9 = (int)v9;
      if (a1)
      {
        if ((int)v9 < a3)
        {
          do
          {
            if (*(unsigned char *)(a1 + v9) == 37) {
              break;
            }
            ++v9;
          }
          while (v9 < a3);
          goto LABEL_17;
        }
      }
      else if ((int)v9 < a3)
      {
        do
        {
          if (*(_WORD *)(a2 + 2 * v9) == 37) {
            break;
          }
          ++v9;
        }
        while (v9 < a3);
LABEL_17:
        if (v18 != v9)
        {
          LODWORD(v1CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v10 + (~v10 >> 31);
          goto LABEL_125;
        }
      }
      int v19 = (__int16 *)(v14 + 2);
      LODWORD(v9) = v18 + 1;
      if (v18 + 1 >= (int)a3) {
        goto LABEL_118;
      }
      unsigned int v20 = 0;
      char v21 = 0;
      int v22 = 0;
      int v23 = 0;
      int v24 = 0;
      uint64_t v76 = (_DWORD *)(v14 + 20);
      uint64_t v25 = (_DWORD *)(v14 + 16);
      CFIndex v75 = (unsigned char *)(v14 + 25);
      uint64_t v26 = -1;
      unsigned __int8 v27 = -1;
      unsigned __int8 v28 = -1;
      uint64_t v80 = (_DWORD *)(v14 + 16);
LABEL_20:
      if (a1) {
        unsigned int v29 = *(unsigned __int8 *)(a1 + (int)v9);
      }
      else {
        unsigned int v29 = *(unsigned __int16 *)(a2 + 2 * (int)v9);
      }
      LODWORD(v9) = v9 + 1;
      if (v26 < 0)
      {
        __int16 v81 = v19;
        while (2)
        {
          if (v24) {
            uint64_t v34 = v25;
          }
          else {
            uint64_t v34 = (_DWORD *)(v14 + 12);
          }
          int v79 = v24;
          while (2)
          {
            if (v29 - 49 < 9)
            {
              uint64_t v35 = 0;
              if ((int)v9 <= (int)a3) {
                int v36 = a3;
              }
              else {
                int v36 = v9;
              }
              uint64_t v37 = v36 - (uint64_t)(int)v9;
              uint64_t v38 = (unsigned __int16 *)(a2 + 2 * (int)v9);
              uint64_t v39 = (unsigned __int8 *)(a1 + (int)v9);
              do
              {
                uint64_t v40 = (unsigned __int128)(v35 * (__int128)10) >> 64;
                uint64_t v41 = 10 * v35;
                if (v40 != v41 >> 63) {
                  goto LABEL_121;
                }
                uint64_t v42 = v29 - 48;
                BOOL v43 = __OFADD__(v41, v42);
                uint64_t v35 = v41 + v42;
                if (v43) {
                  goto LABEL_121;
                }
                if (!v37)
                {
                  *__int16 v81 = 43;
                  LODWORD(v9) = v36;
                  goto LABEL_121;
                }
                if (a1) {
                  unsigned int v29 = *v39;
                }
                else {
                  unsigned int v29 = *v38;
                }
                LODWORD(v9) = v9 + 1;
                --v37;
                ++v38;
                ++v39;
              }
              while (v29 - 48 < 0xA);
              if (v29 == 36)
              {
                uint64_t v25 = (_DWORD *)(v14 + 16);
                int v24 = v79;
                if (v35 <= 127)
                {
                  a4 = v78;
                  if (v28 == 254)
                  {
                    unsigned __int8 v28 = v35 - 1;
                    unsigned char *v75 = v35 - 1;
                  }
                  else if (v27 == 254)
                  {
                    *int64_t v17 = v35 - 1;
                    unsigned __int8 v27 = v35 - 1;
                  }
                  else
                  {
                    *(unsigned char *)(v14 + 24) = v35 - 1;
                  }
                  int v12 = v77;
                  goto LABEL_95;
                }
                a4 = v78;
                int v12 = v77;
              }
              else
              {
                uint64_t v25 = (_DWORD *)(v14 + 16);
                int v24 = v79;
                if (v35 <= 0x7FFFFFFF)
                {
                  _DWORD *v34 = v35;
                  continue;
                }
LABEL_121:
                a4 = v78;
LABEL_122:
                int v12 = v77;
              }
              goto LABEL_123;
            }
            break;
          }
          switch(v29)
          {
            case ' ':
              a4 = v78;
              if ((v20 & 4) == 0)
              {
                v20 |= 8u;
                *uint64_t v76 = v20;
              }
              goto LABEL_94;
            case '#':
              int v23 = 1;
              goto LABEL_93;
            case '*':
              unsigned __int8 v27 = -2;
              *int64_t v17 = -2;
              goto LABEL_93;
            case '+':
              unsigned int v20 = v20 & 0xFFFFFFF3 | 4;
              goto LABEL_86;
            case '-':
              unsigned int v20 = v20 & 0xFFFFFFFC | 2;
LABEL_86:
              *uint64_t v76 = v20;
              goto LABEL_93;
            case '.':
              a4 = v78;
              if ((int)v9 >= (int)a3)
              {
                *__int16 v81 = 43;
                goto LABEL_122;
              }
              if (a1) {
                unsigned int v29 = *(unsigned __int8 *)(a1 + (int)v9);
              }
              else {
                unsigned int v29 = *(unsigned __int16 *)(a2 + 2 * (int)v9);
              }
              LODWORD(v9) = v9 + 1;
              int v24 = 1;
              if (v29 != 42) {
                continue;
              }
              unsigned __int8 v28 = -2;
              unsigned char *v75 = -2;
LABEL_93:
              a4 = v78;
LABEL_94:
              int v12 = v77;
LABEL_95:
              int v19 = v81;
LABEL_71:
              if ((int)v9 >= (int)a3)
              {
LABEL_118:
                __int16 *v19 = 43;
                goto LABEL_123;
              }
              goto LABEL_20;
            case '0':
              a4 = v78;
              if (v24)
              {
                *uint64_t v25 = 0;
                int v24 = 1;
                goto LABEL_94;
              }
              int v19 = v81;
              int v24 = 0;
              if ((v20 & 2) == 0)
              {
                v20 |= 1u;
                *uint64_t v76 = v20;
              }
LABEL_117:
              int v12 = v77;
              goto LABEL_71;
            case '@':
              a4 = v78;
              if (v23)
              {
                int v23 = 0;
                uint64_t v26 = (int)v9;
                goto LABEL_94;
              }
              *__int16 v81 = 37;
              *(_WORD *)uint64_t v14 = 4;
              goto LABEL_122;
            case 'A':
            case 'a':
              goto LABEL_136;
            case 'C':
              *__int16 v81 = 41;
              __int16 v68 = 2;
              goto LABEL_191;
            case 'D':
            case 'U':
            case 'd':
            case 'i':
            case 'u':
              uint64_t v74 = a5;
              uint64_t v51 = a6;
              if (_CFExecutableLinkedOnOrAfter(8uLL)) {
                *v76 |= 0x20u;
              }
              if ((v29 & 0xFFDF) == 0x55) {
                char v52 = 4;
              }
              else {
                char v52 = 1;
              }
              *(unsigned char *)(v78 + 32 * (int)v10 + 28) = v52;
              a6 = v51;
              a5 = v74;
              long long v13 = xmmword_182DAF8B0;
              goto LABEL_147;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              __int16 v72 = a6;
              uint64_t v73 = a5;
              if (_CFExecutableLinkedOnOrAfter(8uLL)) {
                *v76 |= 0x20u;
              }
              if (v29 - 65 >= 0x1A) {
                __int16 v49 = v29;
              }
              else {
                __int16 v49 = v29 + 32;
              }
              *(unsigned char *)(v78 + 32 * (int)v10 + 28) = ((v49 & 0xFFFE) == 102) | (2 * ((v49 & 0xFFFD) == 101));
              a6 = v72;
              a5 = v73;
              long long v13 = xmmword_182DAF8B0;
              if (v79 && *v80 == -1 && *v75 == 255) {
                *uint64_t v80 = 0;
              }
LABEL_136:
              *__int16 v81 = 34;
              a4 = v78;
              if (*(_WORD *)v14 != 5) {
                *(_WORD *)uint64_t v14 = 4;
              }
              goto LABEL_149;
            case 'L':
              __int16 v44 = 5;
              goto LABEL_74;
            case 'O':
            case 'X':
            case 'o':
            case 'x':
LABEL_147:
              *__int16 v81 = 33;
              goto LABEL_148;
            case 'P':
              __int16 v69 = 40;
              goto LABEL_190;
            case 'S':
              __int16 v69 = 38;
              goto LABEL_190;
            case '[':
              if (!v22) {
                uint64_t v26 = (int)v9;
              }
              int v22 = 1;
              goto LABEL_93;
            case 'c':
              *__int16 v81 = 33;
              __int16 v70 = 1;
              goto LABEL_188;
            case 'h':
              a4 = v78;
              int v19 = v81;
              if ((int)v9 < (int)a3
                && (!a1 ? (int v46 = *(unsigned __int16 *)(a2 + 2 * (int)v9)) : (int v46 = *(unsigned __int8 *)(a1 + (int)v9)),
                    v46 == 104))
              {
                LODWORD(v9) = v9 + 1;
                __int16 v47 = 1;
              }
              else
              {
                __int16 v47 = 2;
              }
              goto LABEL_116;
            case 'j':
            case 'q':
            case 't':
            case 'z':
              __int16 v44 = 4;
LABEL_74:
              *(_WORD *)uint64_t v14 = v44;
              goto LABEL_93;
            case 'l':
              a4 = v78;
              int v19 = v81;
              if ((int)v9 < (int)a3)
              {
                int v45 = a1 ? *(unsigned __int8 *)(a1 + (int)v9) : *(unsigned __int16 *)(a2 + 2 * (int)v9);
                if (v45 == 108) {
                  LODWORD(v9) = v9 + 1;
                }
              }
              __int16 v47 = 4;
LABEL_116:
              *(_WORD *)uint64_t v14 = v47;
              goto LABEL_117;
            case 'n':
              __int16 v69 = 42;
              goto LABEL_190;
            case 'p':
              *__int16 v81 = 35;
              __int16 v70 = 4;
LABEL_188:
              *(_WORD *)uint64_t v14 = v70;
LABEL_148:
              a4 = v78;
LABEL_149:
              unint64_t v53 = (v9 - v18);
              _DWORD *v16 = v53;
              int v12 = v77;
              if (!v77) {
                goto LABEL_125;
              }
              uint64_t v54 = *v15;
              uint64_t v55 = a5;
              uint64_t v56 = a6;
              if (a1)
              {
                if ((int)v53 >= 1)
                {
                  uint64_t v57 = 0;
                  unsigned int v58 = 0;
                  while (1)
                  {
                    int v59 = *(unsigned __int8 *)(a1 + v57 + v54);
                    if (v59 == 36)
                    {
                      if ((v58 & 0x80000000) == 0)
                      {
                        uint64_t v60 = v58;
                        while (1)
                        {
                          BOOL v61 = v60-- < 1;
                          if (v61) {
                            break;
                          }
                          if (__s.u8[v60] - 48 >= 0xA) {
                            goto LABEL_161;
                          }
                        }
                        LODWORD(v6CFNotificationCenterRemoveObserver(center, observer, 0, 0) = -1;
                        goto LABEL_161;
                      }
                    }
                    else
                    {
                      __s.i8[v58] = v59;
                    }
                    LODWORD(v6CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v58;
LABEL_161:
                    unsigned int v58 = v60 + 1;
                    if (++v57 >= v53 || (int)v60 >= 127) {
                      goto LABEL_180;
                    }
                  }
                }
LABEL_179:
                unsigned int v58 = 0;
                goto LABEL_180;
              }
              if ((int)v53 < 1) {
                goto LABEL_179;
              }
              uint64_t v62 = 0;
              unsigned int v58 = 0;
              break;
            case 's':
              __int16 v69 = 39;
LABEL_190:
              *__int16 v81 = v69;
              __int16 v68 = 4;
LABEL_191:
              *(_WORD *)uint64_t v14 = v68;
              goto LABEL_121;
            default:
              *__int16 v81 = 32;
              LODWORD(v1CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v10 + (~v10 >> 31);
              a4 = v78;
              int v12 = v77;
              goto LABEL_125;
          }
          break;
        }
        while (2)
        {
          int v63 = *(unsigned __int16 *)(a2 + 2 * (v62 + v54));
          if (v63 == 36)
          {
            if ((v58 & 0x80000000) == 0)
            {
              uint64_t v64 = v58;
              while (1)
              {
                BOOL v61 = v64-- < 1;
                if (v61) {
                  break;
                }
                if (__s.u8[v64] - 48 >= 0xA) {
                  goto LABEL_175;
                }
              }
              LODWORD(v64) = -1;
LABEL_175:
              unsigned int v58 = v64 + 1;
              if (++v62 >= v53 || (int)v64 >= 127)
              {
LABEL_180:
                __s.i8[v58] = 0;
                size_t v65 = strlen(__s.i8);
                CFTypeRef v66 = __CFStringCreateImmutableFunnel3(0, &__s, v65, 134217984, 8u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
                a6 = v56;
                uint64_t v67 = (*v56)++;
                a5 = v55;
                *(void *)(v55 + 8 * v67) = v66;
                a4 = v78;
                int v12 = v77;
                long long v13 = xmmword_182DAF8B0;
                goto LABEL_125;
              }
              continue;
            }
          }
          else
          {
            __s.i8[v58] = v63;
          }
          break;
        }
        LODWORD(v64) = v58;
        goto LABEL_175;
      }
      if (v29 >= 0x30 && v29 - 58 >= 7)
      {
        BOOL v31 = v29 == 95 || v29 - 91 >= 6;
        BOOL v32 = !v31;
        if (v29 <= 0x7A && !v32) {
          goto LABEL_71;
        }
      }
      if (v29 == 93)
      {
        if (v22) {
          char v21 = 1;
        }
        goto LABEL_71;
      }
      if (v29 != 64)
      {
        uint64_t v26 = -1;
        goto LABEL_71;
      }
      int v50 = v20 | 0x40;
      if (!v21) {
        int v50 = v20;
      }
      *uint64_t v76 = v50 | 0x10;
      __int16 *v19 = 37;
      *(_WORD *)uint64_t v14 = 4;
LABEL_123:
      _DWORD *v16 = v9 - v18;
      if (v12)
      {
        uint64_t v48 = (*a6)++;
        *(void *)(a5 + 8 * v48) = 0;
      }
LABEL_125:
      uint64_t v10 = (v10 + 1);
      if ((int)v9 >= a3) {
        return v10;
      }
    }
  }
  return 0;
}

uint64_t __CFStringValidateFormatSpecBuffers(unsigned __int16 *a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  if (a3 > a6 || (uint64_t v7 = a2, a5 - a7 < a2))
  {
    if (a2) {
      return 0;
    }
  }
  else if (a2 >= 1)
  {
    while (1)
    {
      int v8 = *((unsigned __int8 *)a1 + 24);
      if (v8 == 255) {
        LOBYTE(v8) = a7;
      }
      if (a5 <= (char)v8
        || a1[1] != *(unsigned __int16 *)(a4 + 32 * (char)v8 + 2)
        || *a1 != *(unsigned __int16 *)(a4 + 32 * (char)v8))
      {
        break;
      }
      LOBYTE(a7) = a7 + 1;
      a1 += 16;
      if (!--v7) {
        return 1;
      }
    }
    return 0;
  }
  return 1;
}

CFStringRef _CFBundleCopyExecutableName(CFBundleRef bundle, CFURLRef relativeURL, CFDictionaryRef theDict)
{
  CFDictionaryRef InfoDictionary = theDict;
  if (bundle && !theDict) {
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(bundle);
  }
  if (bundle && !relativeURL) {
    relativeURL = (CFURLRef)*((void *)bundle + 2);
  }
  if (InfoDictionary
    && ((CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleExecutable")) != 0
     || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"NSExecutable")) != 0)
    && (CFTypeID v7 = CFGetTypeID(Value), v7 == CFStringGetTypeID())
    && CFStringGetLength(Value) >= 1)
  {
    CFRetain(Value);
  }
  else if (relativeURL {
         && (CFURLRef v8 = CFURLCopyAbsoluteURL(relativeURL),
  }
             CFStringRef v9 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle),
             CFRelease(v8),
             v9))
  {
    CFIndex Length = CFStringGetLength(v9);
    CFIndex PathComponent2 = _CFStartOfLastPathComponent2(v9);
    uint64_t v12 = _CFLengthAfterDeletingPathExtension2(v9);
    CFStringRef Value = 0;
    if (PathComponent2 <= Length && v12 <= Length && v12 > PathComponent2)
    {
      v14.CFIndex location = PathComponent2;
      v14.CFIndex length = v12 - PathComponent2;
      CFStringRef Value = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, v14);
    }
    CFRelease(v9);
  }
  else
  {
    return 0;
  }
  return Value;
}

uint64_t _CFStartOfLastPathComponent2(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length < 2) {
    return 0;
  }
  uint64_t v4 = Length;
  CFIndex v5 = Length;
  do
  {
    CFIndex v3 = v5 - 1;
    if (v5 == 1) {
      break;
    }
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v5 - 2);
    CFIndex v5 = v3;
  }
  while (CharacterAtIndex != 47);
  if (v4 >= 3 && _hasDrive(a1)) {
    return 2;
  }
  else {
    return 0;
  }
}

uint64_t _CFLengthAfterDeletingPathExtension2(const __CFString *a1)
{
  uint64_t result = _CFStartOfPathExtension2(a1);
  if (result <= 0)
  {
    return CFStringGetLength(a1);
  }
  return result;
}

CFIndex _CFStartOfPathExtension2(const __CFString *a1)
{
  if (CFStringGetLength(a1) >= 2)
  {
    BOOL hasDrive = _hasDrive(a1);
    CFIndex v4 = CFStringGetLength(a1) - 1;
    while (v4)
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v4);
      if (CharacterAtIndex == 47) {
        break;
      }
      --v4;
      if (CharacterAtIndex == 46)
      {
        if (hasDrive && v4 == 1) {
          return 0;
        }
        else {
          return v4 + 1;
        }
      }
    }
  }
  return 0;
}

CFStringRef _CFStreamCreateWithFile(__objc2_class **a1, CFURLRef anURL, int a3)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  if (anURL)
  {
    CFStringRef result = CFURLCopyScheme(anURL);
    if (!result) {
      return result;
    }
    CFStringRef v7 = result;
    if (CFEqual(result, @"file"))
    {
      long long v9 = 0u;
      long long v10 = 0u;
      CFRelease(v7);
      CFURLRef v8 = anURL;
      LODWORD(v9) = -1;
      return (CFStringRef)_CFStreamCreateWithConstantCallbacks(a1, (uint64_t)&v8, fileCallBacks, a3);
    }
    CFRelease(v7);
  }
  return 0;
}

uint64_t CFBurstTrieCursorGetPayload(uint64_t a1, _DWORD *a2)
{
  if (*(void *)(a1 + 17) != 1) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 12);
  if (!v2) {
    return 0;
  }
  if (a2) {
    *a2 = v2;
  }
  return 1;
}

CFIndex CFBinaryHeapGetCount(CFBinaryHeapRef heap)
{
  return *((void *)heap + 2);
}

void *__cdecl CFAllocatorReallocate(CFAllocatorRef allocator, void *ptr, CFIndex newsize, CFOptionFlags hint)
{
  return CFAllocatorReallocateImpl((malloc_zone_t *)allocator, (malloc_zone_t *)ptr, newsize, (v4 >> 2), hint);
}

__CFString *__CFNumberCopyDescription(unint64_t *a1)
{
  v20[16] = *(double *)off_1ECE0A5B0;
  if (((unint64_t)a1 & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)off_1ECE0A6F0;
  if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
    uint64_t v3 = 0;
  }
  unint64_t v4 = v3 ^ (unint64_t)a1;
  unint64_t v5 = v4 & 7;
  while (v5 != *((unsigned __int8 *)off_1ECE0A6E0 + v2))
  {
    if (++v2 == 7) {
      goto LABEL_12;
    }
  }
  if (v2 == 3)
  {
    uint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5 == 7) {
      uint64_t v6 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v7 = v6 & (v4 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v7) = atomic_load(a1 + 1);
  }
  uint64_t v8 = v7 & 7;
  uint64_t v9 = __CFNumberCanonicalTypes[v8];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFAllocatorRef v11 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<CFNumber %p [%p]>{CFURLRef value = ", a1, v11);
  __int16 v12 = __CFNumberTypeTable[v9];
  if ((v12 & 0x20) == 0)
  {
    v19[0] = 0;
    v19[1] = 0;
    __CFNumberGetValue((uint64_t)a1, 17, (uint64_t)v19);
    emit128((char *)v20, v19, 1);
    switch(v9)
    {
      case 1:
        long long v13 = "kCFNumberSInt8Type";
        break;
      case 2:
        long long v13 = "kCFNumberSInt16Type";
        break;
      case 3:
        long long v13 = "kCFNumberSInt32Type";
        break;
      case 4:
        long long v13 = "kCFNumberSInt64Type";
        break;
      default:
        long long v13 = "unknown integer";
        if (v9 == 17) {
          long long v13 = "kCFNumberSInt128Type";
        }
        break;
    }
    CFStringAppendFormat(Mutable, 0, @"%s, type = %s}", v20, v13);
    return Mutable;
  }
  v20[0] = 0.0;
  __CFNumberGetValue((uint64_t)a1, 6, (uint64_t)v20);
  if (fabs(v20[0]) == INFINITY)
  {
    if (v20[0] <= 0.0) {
      CFStringRef v14 = @"-infinity";
    }
    else {
      CFStringRef v14 = @"+infinity";
    }
  }
  else
  {
    if (v20[0] != 0.0)
    {
      uint64_t v15 = 20;
      if ((v12 & 0x40) == 0) {
        uint64_t v15 = 10;
      }
      CFStringAppendFormat(Mutable, 0, @"%+.*f", v20[0], v15, *(void *)&v20[0]);
      goto LABEL_31;
    }
    if (v20[0] >= 0.0) {
      CFStringRef v14 = @"+0.0";
    }
    else {
      CFStringRef v14 = @"-0.0";
    }
  }
  CFStringAppend(Mutable, v14);
LABEL_31:
  int v16 = "unknown float";
  if (v8 == 5) {
    int v16 = "kCFNumberFloat64Type";
  }
  if (v8 == 4) {
    int v16 = "kCFNumberFloat32Type";
  }
  CFStringAppendFormat(Mutable, 0, @", type = %s}", v16, v18);
  return Mutable;
}

char *emit128(char *result, uint64_t *a2, int a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  if (*a2 < 0)
  {
    BOOL v6 = v4 == 0;
    unint64_t v4 = -(uint64_t)v4;
    if (v6) {
      uint64_t v3 = -v3;
    }
    else {
      uint64_t v3 = ~v3;
    }
    char v5 = 45;
    goto LABEL_8;
  }
  if (a3)
  {
    char v5 = 43;
LABEL_8:
    *result++ = v5;
  }
  uint64_t v7 = 0;
  int v8 = 0;
  do
  {
    while (1)
    {
      int v9 = 0;
      long long v10 = (uint64_t *)((char *)&powersOf10 + 16 * v7);
      uint64_t v13 = *v10;
      CFAllocatorRef v11 = (unint64_t *)(v10 + 1);
      uint64_t v12 = v13;
      CFStringRef v14 = (void *)((char *)&neg_powersOf10 + 16 * v7);
      uint64_t v15 = v14 + 1;
      while (v12 < v3 || v12 <= v3 && *v11 <= v4)
      {
        v3 += __CFADD__(v4, *v15) + *v14;
        v4 += *v15;
        ++v9;
      }
      v8 |= v9;
      if (!v8) {
        break;
      }
      *result++ = v9 + 48;
      ++v7;
      int v8 = 1;
      if (v7 == 39) {
        goto LABEL_19;
      }
    }
    ++v7;
  }
  while (v7 != 39);
  *result++ = 48;
LABEL_19:
  *CFStringRef result = 0;
  return result;
}

uint64_t _CFPrefsMessageSenderIsSandboxed(void *a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    CFURLRef value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    if (!value || (remote_connection = value, object_getClass(value) != (Class)off_1ECE0A678)) {
      _CFPrefsMessageSenderIsSandboxed_cold_1();
    }
  }
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 1;
  v6[0] = off_1ECE0A5A0;
  v6[1] = 3221225472;
  void v6[2] = ___CFPrefsMessageSenderIsSandboxed_block_invoke;
  v6[3] = &unk_1ECE004C8;
  void v6[4] = a1;
  v6[5] = &v7;
  withClientContext(remote_connection, (uint64_t)v6);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_182C86E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t checkFileWriteData(_OWORD *a1, uint64_t a2, int a3, const char *a4, unsigned int a5)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  long long v8 = a1[1];
  v15[0] = *a1;
  v15[1] = v8;
  uint64_t v9 = sandbox_check_by_audit_token();
  if (v9)
  {
    int v10 = openat(a3, a4, 536871426, a5);
    if ((v10 & 0x80000000) == 0)
    {
      int v11 = v10;
      bzero(v15, 0x400uLL);
      fcntl(v11, 50, v15);
      uint64_t v9 = sandbox_check_by_audit_token();
      memset(&v14, 0, sizeof(v14));
      int v12 = fstat(v11, &v14);
      close(v11);
      if (!v12 && !v14.st_size) {
        unlinkat(a3, a4, 2048);
      }
    }
  }
  return v9;
}

CFStringRef CFDateFormatterGetFormat(CFDateFormatterRef formatter)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return (CFStringRef)*((void *)formatter + 6);
}

void _registerFactoryLocked(const __CFString *a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID()
    || (uint64_t v7 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) == 0)
  {
    uint64_t v7 = CFRetain(a1);
  }
  CFTypeID v8 = CFGetTypeID(a2);
  if (v8 != CFStringGetTypeID() || CFStringGetLength(a2) <= 0) {
    a2 = 0;
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  uint64_t v9 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
  {
    int v10 = @"<no func>";
    int v11 = 138543874;
    if (a2) {
      int v10 = (__CFString *)a2;
    }
    int v12 = v7;
    __int16 v13 = 2114;
    stat v14 = v10;
    __int16 v15 = 2050;
    uint64_t v16 = a3;
    _os_log_debug_impl(&dword_182B90000, v9, OS_LOG_TYPE_DEBUG, "Registering static factory %{public}@ %{public}@ bundle %{public}p", (uint8_t *)&v11, 0x20u);
  }
  _CFPlugInRegisterFactoryFunctionByNameLocked(v7, a3, a2);
  if (v7) {
    CFRelease(v7);
  }
}

void _registerTypeLocked(const __CFString *a1, const __CFString *cf, const void *a3)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID()) {
    int Count = CFArrayGetCount((CFArrayRef)cf);
  }
  else {
    int Count = 0;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == CFStringGetTypeID()
    && (uint64_t v9 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) != 0)
  {
    if (Count) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v9 = CFRetain(a1);
    if (Count)
    {
LABEL_7:
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFStringGetTypeID()
            || (CFAllocatorRef v13 = CFGetAllocator(a3), (v14 = CFUUIDCreateFromString(v13, ValueAtIndex)) == 0))
          {
            stat v14 = (void *)CFRetain(ValueAtIndex);
          }
          if (_CFBundlePluginLogger_onceToken != -1) {
            dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
          }
          __int16 v15 = _CFBundlePluginLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543618;
            char v21 = v14;
            __int16 v22 = 2114;
            int v23 = v9;
            _os_log_debug_impl(&dword_182B90000, v15, OS_LOG_TYPE_DEBUG, "Registering factory %{public}@ type %{public}@", buf, 0x16u);
          }
          _CFPlugInRegisterPlugInTypeLocked(v14, v9);
          if (v14) {
            CFRelease(v14);
          }
        }
      }
      goto LABEL_31;
    }
  }
  CFTypeID v16 = CFGetTypeID(cf);
  if (v16 != CFArrayGetTypeID())
  {
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 != CFStringGetTypeID() || (CFAllocatorRef v18 = CFGetAllocator(a3), (v19 = CFUUIDCreateFromString(v18, cf)) == 0)) {
      int v19 = (void *)CFRetain(cf);
    }
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _registerTypeLocked_cold_1();
    }
    _CFPlugInRegisterPlugInTypeLocked(v19, v9);
    if (v19) {
      CFRelease(v19);
    }
  }
LABEL_31:
  if (v9) {
    CFRelease(v9);
  }
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  uint64_t v127 = *(void *)off_1ECE0A5B0;
  if (!uuidStr) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(uuidStr);
  if (Length <= 100)
  {
    CFIndex v5 = Length;
    if (Length) {
      goto LABEL_5;
    }
    return 0;
  }
  CFIndex v5 = 100;
LABEL_5:
  v128.CFIndex location = 0;
  v128.CFIndex length = v5;
  CFStringGetCharacters(uuidStr, v128, v126);
  CFIndex v6 = 0;
  int v7 = v126[0];
  if (v126[0] - 48 >= 0xA && v126[0] - 97 >= 6)
  {
    CFIndex v9 = 0;
    while (v9 < v5 && (v7 - 71) <= 0xFFFFFFF9)
    {
      int v7 = v126[v9 + 1];
      CFIndex v6 = v9 + 1;
      BOOL v10 = (v7 - 48) >= 0xA && (v7 - 97) > 5;
      ++v9;
      if (!v10) {
        goto LABEL_20;
      }
    }
    CFIndex v6 = v9;
  }
LABEL_20:
  CFIndex v12 = v6 + 1;
  if (v6 + 1 >= v5)
  {
    unsigned int v14 = 0;
    goto LABEL_32;
  }
  uint64_t v13 = 0;
  LOBYTE(v14) = 0;
  char v15 = 1;
  while (1)
  {
    char v16 = v15;
    int v17 = v126[v6 + v13];
    char v18 = v17 - 48;
    if ((v17 - 48) >= 0xA) {
      break;
    }
LABEL_27:
    char v15 = 0;
    unsigned int v14 = (v18 | (16 * v14));
    uint64_t v13 = 1;
    if ((v16 & 1) == 0) {
      goto LABEL_31;
    }
  }
  if ((v17 - 97) <= 5)
  {
    char v18 = v17 - 87;
    goto LABEL_27;
  }
  if ((v17 - 65) <= 5)
  {
    char v18 = v17 - 55;
    goto LABEL_27;
  }
  unsigned int v14 = 0;
LABEL_31:
  CFIndex v12 = v6 + 3;
  v6 += 2;
LABEL_32:
  if (v12 >= v5)
  {
    unint64_t v25 = 0;
    goto LABEL_44;
  }
  uint64_t v19 = 0;
  LOBYTE(v2CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
  char v21 = 1;
  while (2)
  {
    char v22 = v21;
    int v23 = v126[v6 + v19];
    char v24 = v23 - 48;
    if ((v23 - 48) < 0xA)
    {
LABEL_39:
      char v21 = 0;
      unsigned int v20 = (v24 | (16 * v20));
      uint64_t v19 = 1;
      if ((v22 & 1) == 0) {
        goto LABEL_43;
      }
      continue;
    }
    break;
  }
  if ((v23 - 97) <= 5)
  {
    char v24 = v23 - 87;
    goto LABEL_39;
  }
  if ((v23 - 65) <= 5)
  {
    char v24 = v23 - 55;
    goto LABEL_39;
  }
  unsigned int v20 = 0;
LABEL_43:
  CFIndex v12 = v6 + 3;
  v6 += 2;
  unint64_t v25 = (unint64_t)v20 << 8;
LABEL_44:
  if (v12 >= v5)
  {
    unint64_t v32 = 0;
    goto LABEL_56;
  }
  uint64_t v26 = 0;
  LOBYTE(v27) = 0;
  char v28 = 1;
  while (2)
  {
    char v29 = v28;
    int v30 = v126[v6 + v26];
    char v31 = v30 - 48;
    if ((v30 - 48) < 0xA)
    {
LABEL_51:
      char v28 = 0;
      unsigned int v27 = (v31 | (16 * v27));
      uint64_t v26 = 1;
      if ((v29 & 1) == 0) {
        goto LABEL_55;
      }
      continue;
    }
    break;
  }
  if ((v30 - 97) <= 5)
  {
    char v31 = v30 - 87;
    goto LABEL_51;
  }
  if ((v30 - 65) <= 5)
  {
    char v31 = v30 - 55;
    goto LABEL_51;
  }
  unsigned int v27 = 0;
LABEL_55:
  CFIndex v12 = v6 + 3;
  v6 += 2;
  unint64_t v32 = (unint64_t)v27 << 16;
LABEL_56:
  if (v12 >= v5)
  {
    unint64_t v39 = 0;
    goto LABEL_68;
  }
  uint64_t v33 = 0;
  LOBYTE(v34) = 0;
  char v35 = 1;
  while (2)
  {
    char v36 = v35;
    int v37 = v126[v6 + v33];
    char v38 = v37 - 48;
    if ((v37 - 48) < 0xA)
    {
LABEL_63:
      char v35 = 0;
      unsigned int v34 = (v38 | (16 * v34));
      uint64_t v33 = 1;
      if ((v36 & 1) == 0) {
        goto LABEL_67;
      }
      continue;
    }
    break;
  }
  if ((v37 - 97) <= 5)
  {
    char v38 = v37 - 87;
    goto LABEL_63;
  }
  if ((v37 - 65) <= 5)
  {
    char v38 = v37 - 55;
    goto LABEL_63;
  }
  unsigned int v34 = 0;
LABEL_67:
  CFIndex v12 = v6 + 3;
  v6 += 2;
  unint64_t v39 = (unint64_t)v34 << 24;
LABEL_68:
  if (v6 + 2 >= v5)
  {
    uint64_t v47 = 0;
    goto LABEL_80;
  }
  uint64_t v40 = 0;
  LOBYTE(v41) = 0;
  uint64_t v42 = &v126[v12];
  char v43 = 1;
  while (2)
  {
    char v44 = v43;
    int v45 = v42[v40];
    char v46 = v45 - 48;
    if ((v45 - 48) < 0xA)
    {
LABEL_75:
      char v43 = 0;
      uint64_t v41 = (v46 | (16 * v41));
      uint64_t v40 = 1;
      if ((v44 & 1) == 0) {
        goto LABEL_79;
      }
      continue;
    }
    break;
  }
  if ((v45 - 97) <= 5)
  {
    char v46 = v45 - 87;
    goto LABEL_75;
  }
  if ((v45 - 65) <= 5)
  {
    char v46 = v45 - 55;
    goto LABEL_75;
  }
  uint64_t v41 = 0;
LABEL_79:
  CFIndex v12 = v6 + 3;
  uint64_t v47 = v41 << 32;
LABEL_80:
  CFIndex v48 = v12 + 1;
  if (v12 + 1 >= v5)
  {
    uint64_t v55 = 0;
    goto LABEL_92;
  }
  uint64_t v49 = 0;
  LOBYTE(v5CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
  char v51 = 1;
  while (2)
  {
    char v52 = v51;
    int v53 = v126[v12 + v49];
    char v54 = v53 - 48;
    if ((v53 - 48) < 0xA)
    {
LABEL_87:
      char v51 = 0;
      uint64_t v50 = (v54 | (16 * v50));
      uint64_t v49 = 1;
      if ((v52 & 1) == 0) {
        goto LABEL_91;
      }
      continue;
    }
    break;
  }
  if ((v53 - 97) <= 5)
  {
    char v54 = v53 - 87;
    goto LABEL_87;
  }
  if ((v53 - 65) <= 5)
  {
    char v54 = v53 - 55;
    goto LABEL_87;
  }
  uint64_t v50 = 0;
LABEL_91:
  CFIndex v48 = v12 + 3;
  v12 += 2;
  uint64_t v55 = v50 << 40;
LABEL_92:
  if (v12 + 2 >= v5)
  {
    uint64_t v63 = 0;
    goto LABEL_104;
  }
  uint64_t v56 = 0;
  LOBYTE(v57) = 0;
  unsigned int v58 = &v126[v48];
  char v59 = 1;
  while (2)
  {
    char v60 = v59;
    int v61 = v58[v56];
    char v62 = v61 - 48;
    if ((v61 - 48) < 0xA)
    {
LABEL_99:
      char v59 = 0;
      uint64_t v57 = (v62 | (16 * v57));
      uint64_t v56 = 1;
      if ((v60 & 1) == 0) {
        goto LABEL_103;
      }
      continue;
    }
    break;
  }
  if ((v61 - 97) <= 5)
  {
    char v62 = v61 - 87;
    goto LABEL_99;
  }
  if ((v61 - 65) <= 5)
  {
    char v62 = v61 - 55;
    goto LABEL_99;
  }
  uint64_t v57 = 0;
LABEL_103:
  CFIndex v48 = v12 + 3;
  uint64_t v63 = v57 << 48;
LABEL_104:
  CFIndex v64 = v48 + 1;
  if (v48 + 1 >= v5)
  {
    uint64_t v71 = 0;
    goto LABEL_116;
  }
  uint64_t v65 = 0;
  LOBYTE(v66) = 0;
  char v67 = 1;
  while (2)
  {
    char v68 = v67;
    int v69 = v126[v48 + v65];
    char v70 = v69 - 48;
    if ((v69 - 48) < 0xA)
    {
LABEL_111:
      char v67 = 0;
      uint64_t v66 = (v70 | (16 * v66));
      uint64_t v65 = 1;
      if ((v68 & 1) == 0) {
        goto LABEL_115;
      }
      continue;
    }
    break;
  }
  if ((v69 - 97) <= 5)
  {
    char v70 = v69 - 87;
    goto LABEL_111;
  }
  if ((v69 - 65) <= 5)
  {
    char v70 = v69 - 55;
    goto LABEL_111;
  }
  uint64_t v66 = 0;
LABEL_115:
  CFIndex v64 = v48 + 3;
  v48 += 2;
  uint64_t v71 = v66 << 56;
LABEL_116:
  if (v48 + 2 >= v5)
  {
    uint64_t v79 = 0;
    goto LABEL_128;
  }
  uint64_t v72 = 0;
  LOBYTE(v73) = 0;
  uint64_t v74 = &v126[v64];
  char v75 = 1;
  while (2)
  {
    char v76 = v75;
    int v77 = v74[v72];
    char v78 = v77 - 48;
    if ((v77 - 48) < 0xA)
    {
LABEL_123:
      char v75 = 0;
      unsigned int v73 = (v78 | (16 * v73));
      uint64_t v72 = 1;
      if ((v76 & 1) == 0) {
        goto LABEL_127;
      }
      continue;
    }
    break;
  }
  if ((v77 - 97) <= 5)
  {
    char v78 = v77 - 87;
    goto LABEL_123;
  }
  if ((v77 - 65) <= 5)
  {
    char v78 = v77 - 55;
    goto LABEL_123;
  }
  unsigned int v73 = 0;
LABEL_127:
  uint64_t v79 = v73;
  CFIndex v64 = v48 + 3;
LABEL_128:
  CFIndex v80 = v64 + 1;
  if (v64 + 1 >= v5) {
    goto LABEL_139;
  }
  uint64_t v81 = 0;
  LOBYTE(v82) = 0;
  char v83 = 1;
  while (2)
  {
    char v84 = v83;
    int v85 = v126[v64 + v81];
    char v86 = v85 - 48;
    if ((v85 - 48) < 0xA)
    {
LABEL_135:
      char v83 = 0;
      unsigned int v82 = (v86 | (16 * v82));
      uint64_t v81 = 1;
      if ((v84 & 1) == 0) {
        goto LABEL_138;
      }
      continue;
    }
    break;
  }
  if ((v85 - 97) <= 5)
  {
    char v86 = v85 - 87;
    goto LABEL_135;
  }
  if ((v85 - 65) <= 5)
  {
    char v86 = v85 - 55;
    goto LABEL_135;
  }
  unsigned int v82 = 0;
LABEL_138:
  v79 |= (unint64_t)v82 << 8;
  CFIndex v80 = v64 + 3;
  v64 += 2;
LABEL_139:
  if (v64 + 2 >= v5) {
    goto LABEL_150;
  }
  uint64_t v87 = 0;
  LOBYTE(v88) = 0;
  uint64_t v89 = &v126[v80];
  char v90 = 1;
  while (2)
  {
    char v91 = v90;
    int v92 = v89[v87];
    char v93 = v92 - 48;
    if ((v92 - 48) < 0xA)
    {
LABEL_146:
      char v90 = 0;
      unsigned int v88 = (v93 | (16 * v88));
      uint64_t v87 = 1;
      if ((v91 & 1) == 0) {
        goto LABEL_149;
      }
      continue;
    }
    break;
  }
  if ((v92 - 97) <= 5)
  {
    char v93 = v92 - 87;
    goto LABEL_146;
  }
  if ((v92 - 65) <= 5)
  {
    char v93 = v92 - 55;
    goto LABEL_146;
  }
  unsigned int v88 = 0;
LABEL_149:
  v79 |= (unint64_t)v88 << 16;
  CFIndex v80 = v64 + 3;
LABEL_150:
  CFIndex v94 = v80 + 1;
  if (v80 + 1 >= v5) {
    goto LABEL_161;
  }
  uint64_t v95 = 0;
  LOBYTE(v96) = 0;
  char v97 = 1;
  while (2)
  {
    char v98 = v97;
    int v99 = v126[v80 + v95];
    char v100 = v99 - 48;
    if ((v99 - 48) < 0xA)
    {
LABEL_157:
      char v97 = 0;
      unsigned int v96 = (v100 | (16 * v96));
      uint64_t v95 = 1;
      if ((v98 & 1) == 0) {
        goto LABEL_160;
      }
      continue;
    }
    break;
  }
  if ((v99 - 97) <= 5)
  {
    char v100 = v99 - 87;
    goto LABEL_157;
  }
  if ((v99 - 65) <= 5)
  {
    char v100 = v99 - 55;
    goto LABEL_157;
  }
  unsigned int v96 = 0;
LABEL_160:
  v79 |= (unint64_t)v96 << 24;
  CFIndex v94 = v80 + 3;
  v80 += 2;
LABEL_161:
  if (v94 >= v5) {
    goto LABEL_172;
  }
  uint64_t v101 = 0;
  LOBYTE(v102) = 0;
  char v103 = 1;
  while (2)
  {
    char v104 = v103;
    int v105 = v126[v80 + v101];
    char v106 = v105 - 48;
    if ((v105 - 48) < 0xA)
    {
LABEL_168:
      char v103 = 0;
      uint64_t v102 = (v106 | (16 * v102));
      uint64_t v101 = 1;
      if ((v104 & 1) == 0) {
        goto LABEL_171;
      }
      continue;
    }
    break;
  }
  if ((v105 - 97) <= 5)
  {
    char v106 = v105 - 87;
    goto LABEL_168;
  }
  if ((v105 - 65) <= 5)
  {
    char v106 = v105 - 55;
    goto LABEL_168;
  }
  uint64_t v102 = 0;
LABEL_171:
  v79 |= v102 << 32;
  CFIndex v94 = v80 + 3;
  v80 += 2;
LABEL_172:
  if (v94 >= v5) {
    goto LABEL_183;
  }
  uint64_t v107 = 0;
  LOBYTE(v108) = 0;
  char v109 = 1;
  while (2)
  {
    char v110 = v109;
    int v111 = v126[v80 + v107];
    char v112 = v111 - 48;
    if ((v111 - 48) < 0xA)
    {
LABEL_179:
      char v109 = 0;
      uint64_t v108 = (v112 | (16 * v108));
      uint64_t v107 = 1;
      if ((v110 & 1) == 0) {
        goto LABEL_182;
      }
      continue;
    }
    break;
  }
  if ((v111 - 97) <= 5)
  {
    char v112 = v111 - 87;
    goto LABEL_179;
  }
  if ((v111 - 65) <= 5)
  {
    char v112 = v111 - 55;
    goto LABEL_179;
  }
  uint64_t v108 = 0;
LABEL_182:
  v79 |= v108 << 40;
  CFIndex v94 = v80 + 3;
  v80 += 2;
LABEL_183:
  if (v94 >= v5) {
    goto LABEL_194;
  }
  uint64_t v113 = 0;
  LOBYTE(v114) = 0;
  char v115 = 1;
  while (2)
  {
    char v116 = v115;
    int v117 = v126[v80 + v113];
    char v118 = v117 - 48;
    if ((v117 - 48) < 0xA)
    {
LABEL_190:
      char v115 = 0;
      uint64_t v114 = (v118 | (16 * v114));
      uint64_t v113 = 1;
      if ((v116 & 1) == 0) {
        goto LABEL_193;
      }
      continue;
    }
    break;
  }
  if ((v117 - 97) <= 5)
  {
    char v118 = v117 - 87;
    goto LABEL_190;
  }
  if ((v117 - 65) <= 5)
  {
    char v118 = v117 - 55;
    goto LABEL_190;
  }
  uint64_t v114 = 0;
LABEL_193:
  v79 |= v114 << 48;
  CFIndex v94 = v80 + 3;
  v80 += 2;
LABEL_194:
  if (v94 >= v5) {
    return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v25 | v32 | v39 | v14 | v47 | v55 | v63 | v71, v79, 0);
  }
  uint64_t v119 = 0;
  LOBYTE(v12CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
  int64_t v121 = &v126[v80];
  char v122 = 1;
  while (2)
  {
    char v123 = v122;
    int v124 = v121[v119];
    char v125 = v124 - 48;
    if ((v124 - 48) < 0xA)
    {
LABEL_201:
      char v122 = 0;
      uint64_t v120 = (v125 | (16 * v120));
      uint64_t v119 = 1;
      if ((v123 & 1) == 0) {
        goto LABEL_204;
      }
      continue;
    }
    break;
  }
  if ((v124 - 97) <= 5)
  {
    char v125 = v124 - 87;
    goto LABEL_201;
  }
  if ((v124 - 65) <= 5)
  {
    char v125 = v124 - 55;
    goto LABEL_201;
  }
  uint64_t v120 = 0;
LABEL_204:
  v79 |= v120 << 56;
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v25 | v32 | v39 | v14 | v47 | v55 | v63 | v71, v79, 0);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  uint64_t v10 = *(void *)off_1ECE0A5B0;
  uint64_t v5 = 0;
  CFIndex v6 = &v5;
  uint64_t v7 = 0x2800000000;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  v4[0] = off_1ECE0A5A0;
  v4[1] = 0x40000000;
  v4[2] = __CFUUIDCreate_block_invoke;
  v4[3] = &unk_1ECDFD280;
  v4[4] = &v5;
  os_unfair_lock_lock_with_options();
  __CFUUIDCreate_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
  CFUUIDRef v2 = (const __CFUUID *)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v6[3], v6[4], 0);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182C87E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFUUIDCreateWithBytesPrimitive(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  v6[0] = off_1ECE0A5A0;
  v6[1] = 0x40000000;
  void v6[2] = ____CFUUIDCreateWithBytesPrimitive_block_invoke;
  v6[3] = &unk_1ECDFD2C8;
  void v6[6] = a2;
  void v6[7] = a3;
  void v6[4] = &v8;
  v6[5] = a1;
  char v7 = a4;
  os_unfair_lock_lock_with_options();
  ____CFUUIDCreateWithBytesPrimitive_block_invoke((uint64_t)v6);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
  uint64_t v4 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_182C87F98(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

void __CFRuntimeSetImmortal(uint64_t a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(a1 + 8));
  atomic_store(v1 & 0xFFFFFFFFFFFFLL, (unint64_t *)(a1 + 8));
}

double __CFUUIDCreate_block_invoke(uint64_t a1)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  memset(out, 0, sizeof(out));
  int v2 = __CFUUIDClass_block_invoke_useV1UUIDs;
  if (__CFUUIDClass_block_invoke_useV1UUIDs == 255)
  {
    uint64_t v3 = getenv("CFUUIDVersionNumber");
    if (!v3)
    {
LABEL_6:
      uuid_generate_random(out);
      goto LABEL_7;
    }
    int v2 = strtoul_l(v3, 0, 0, 0) == 1;
    __CFUUIDClass_block_invoke_useV1UUIDs = v2;
  }
  if (v2 != 1) {
    goto LABEL_6;
  }
  uuid_generate_time(out);
LABEL_7:
  double result = *(double *)out;
  *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_OWORD *)out;
  return result;
}

void _CFPlugInRegisterPlugInTypeLocked(void *key, const void *a2)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if (_factoriesByFactoryID
    && (uint64_t v3 = (CFMutableArrayRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, key)) != 0
    && (uint64_t v4 = v3, *((unsigned char *)v3 + 24)))
  {
    CFArrayAppendValue(v3[7], a2);
    CFDictionaryRef Mutable = (const __CFDictionary *)_factoriesByTypeID;
    if (!_factoriesByTypeID)
    {
      CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      _factoriesByCFTypeID TypeID = (uint64_t)Mutable;
    }
    CFStringRef Value = (void *)CFDictionaryGetValue(Mutable, a2);
    if (!Value)
    {
      memset(&v7, 0, sizeof(v7));
      CFStringRef Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v7);
      CFDictionarySetValue((CFMutableDictionaryRef)_factoriesByTypeID, a2, Value);
      CFRelease(Value);
    }
    CFArrayAppendValue((CFMutableArrayRef)Value, v4);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _CFPlugInRegisterPlugInTypeLocked_cold_2();
    }
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      _CFPlugInRegisterPlugInTypeLocked_cold_1();
    }
  }
}

CFStringRef _CFPlugInRegisterFactoryFunctionByNameLocked(const void *a1, const void *a2, const __CFString *a3)
{
  Locked = (void *)_CFPFactoryCommonCreateLocked(&__kCFAllocatorSystemDefault, a1);
  Locked[4] = 0;
  Locked[5] = CFRetain(a2);
  if (a2 && *(unsigned char *)__CFBundleGetPlugInData((uint64_t)a2))
  {
    PlugInCFDataRef Data = __CFBundleGetPlugInData((uint64_t)a2);
    CFArrayAppendValue(*(CFMutableArrayRef *)(PlugInData + 16), Locked);
  }
  if (a3) {
    CFStringRef result = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
  }
  else {
    CFStringRef result = 0;
  }
  Locked[6] = result;
  return result;
}

uint64_t _CFPFactoryCommonCreateLocked(__objc2_class **a1, const void *a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x20uLL, 48, 0);
  if (Instance)
  {
    *(void *)(Instance + 16) = CFRetain(a2);
    *(unsigned char *)(Instance + 24) = 1;
    *(void *)(Instance + 56) = CFArrayCreateMutable((CFAllocatorRef)a1, 0, &kCFTypeArrayCallBacks);
    uint64_t v5 = *(const void **)(Instance + 16);
    uint64_t v6 = (__CFDictionary *)_factoriesByFactoryID;
    if (!_factoriesByFactoryID)
    {
      memset(&v8, 0, sizeof(v8));
      uint64_t v6 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &v8);
      _factoriesByFactoryID = (uint64_t)v6;
    }
    CFDictionarySetValue(v6, v5, (const void *)Instance);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _CFPFactoryCommonCreateLocked_cold_1();
    }
  }
  return Instance;
}

CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
{
  return (CFMessagePortRef)__CFMessagePortCreateRemote((__objc2_class **)allocator, name, 0, 0);
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  CFAllocatorRef v5 = allocator;
  uint64_t v31 = *(void *)off_1ECE0A5B0;
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      CFAllocatorRef v5 = (const __CFAllocator *)v6;
    }
    else {
      CFAllocatorRef v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v7);
  }
  CFTypeID v8 = CFGetTypeID(number);
  if (!CF_IS_OBJC(v8, (unint64_t)number))
  {
    CFNumberType Type2 = _CFNumberGetType2((unint64_t *)number);
    CFNumberGetValue(number, Type2, v28);
    return CFNumberFormatterCreateStringWithValue(v5, formatter, Type2, v28);
  }
  [(__CFNumber *)number doubleValue];
  if (v9 != 0.0 || (uint64_t v10 = (const void *)*((void *)formatter + 9)) == 0)
  {
    double __y = 0.0;
    double valuePtr = 1.0;
    CFNumberRef v12 = (const __CFNumber *)*((void *)formatter + 8);
    double v13 = 1.0;
    if (v12)
    {
      if (CFNumberGetValue(v12, kCFNumberFloat64Type, &valuePtr)) {
        double v13 = valuePtr;
      }
      else {
        double valuePtr = 1.0;
      }
    }
    if (modf(v13, &__y) < 0.00000011920929)
    {
      double v13 = floor(v13);
      double valuePtr = v13;
    }
    if (![(__CFNumber *)number _getCString:__s length:768 multiplier:v13])return 0; {
    int v25 = 0;
    }
    size_t v16 = strlen(__s);
    int v17 = __cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v16, (uint64_t)v29, 768, 0, &v25);
    CFIndex v18 = v17;
    int v19 = v25;
    if (v25 == 15 || v17 >= 769)
    {
      uint64_t v21 = v17 + 2;
      uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v21, 0x1000040BDFB0063, 0);
      int v25 = 0;
      size_t v22 = strlen(__s);
      CFIndex v18 = (int)__cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v22, (uint64_t)(Typed + 1), v21, 0, &v25);
      int v19 = v25;
    }
    else
    {
      uint64_t Typed = 0;
    }
    if (v19 <= 0)
    {
      if (Typed) {
        int v23 = Typed;
      }
      else {
        int v23 = (UniChar *)v28;
      }
      if (*((unsigned char *)formatter + 82)
        && (CFStringRef Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
            CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
      {
        *int v23 = 8207;
        ++v18;
      }
      else if (Typed)
      {
        int v23 = Typed + 1;
      }
      else
      {
        int v23 = (UniChar *)v29;
      }
      CFStringRef v15 = CFStringCreateWithCharacters(v5, v23, v18);
      if (!Typed) {
        return v15;
      }
      goto LABEL_27;
    }
    CFStringRef v15 = 0;
    if (Typed) {
LABEL_27:
    }
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    return v15;
  }

  return (CFStringRef)CFRetain(v10);
}

uint64_t __cficu_unum_formatDecimal(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  uint64_t v14 = unum_formatDecimal();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v15 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    size_t v16 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    CFTypeRef v17 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", a4, a5);
    CFStringRef v18 = ___CFICUCreateErrorStringWithComment(a7, 1);
    if (a2)
    {
      int v19 = a3;
      if (a3 == -1) {
        int v19 = strlen(a2);
      }
      unsigned int v20 = (void *)CFStringCreateWithBytes(0, (const UInt8 *)a2, v19, 0x8000100u, 0);
    }
    else
    {
      unsigned int v20 = (void *)CFRetain(@"NULL");
    }
    uint64_t v21 = v20;
    if (a6) {
      ___CFICULogWithArguments(1, @"#warning non-NULL pos ignored.");
    }
    ___CFICULogWithArguments(1, @"unum_formatDecimal(%@, \"%@\", %d, %@, %d, NULL, &%@); %@",
      v15,
      v21,
      a3,
      v17,
      a5,
      v16,
      v18);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
    CFRelease(v21);
    CFRelease(v18);
  }
  return v14;
}

CFStringRef CFNumberFormatterCreateStringWithValue(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberType numberType, const void *valuePtr)
{
  CFAllocatorRef v7 = allocator;
  v53[192] = *(void *)off_1ECE0A5B0;
  if (!allocator)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      CFAllocatorRef v7 = (const __CFAllocator *)v8;
    }
    else {
      CFAllocatorRef v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v9 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v9 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v9);
  }
  double __y = 0.0;
  double valuePtra = 1.0;
  CFNumberRef v10 = (const __CFNumber *)*((void *)formatter + 8);
  double v11 = 1.0;
  if (v10)
  {
    if (CFNumberGetValue(v10, kCFNumberFloat64Type, &valuePtra)) {
      double v11 = valuePtra;
    }
    else {
      double valuePtra = 1.0;
    }
  }
  if (modf(v11, &__y) < 0.00000011920929)
  {
    double v11 = floor(v11);
    double valuePtra = v11;
  }
  int v45 = 0;
  if ((unint64_t)numberType > kCFNumberDoubleType)
  {
LABEL_28:
    if ((numberType & 0xFFFFFFFFFFFFFFFBLL) != 0xA)
    {
      CFStringRef v28 = 0;
      switch(numberType)
      {
        case kCFNumberSInt8Type:
        case kCFNumberCharType:
          char v33 = *(unsigned char *)valuePtr;
          if (!*(unsigned char *)valuePtr)
          {
            CFNumberRef v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }
          if (v11 != 1.0) {
            char v33 = (int)(v11 * (double)v33);
          }
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          uint64_t v51 = 0;
          _CFBigNumInitWithInt8((uint64_t)&v49, v33);
          goto LABEL_34;
        case kCFNumberSInt16Type:
        case kCFNumberShortType:
          __int16 v34 = *(_WORD *)valuePtr;
          if (!*(_WORD *)valuePtr)
          {
            CFNumberRef v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }
          if (v11 != 1.0) {
            __int16 v34 = (int)(v11 * (double)v34);
          }
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          uint64_t v51 = 0;
          _CFBigNumInitWithInt16((uint64_t)&v49, v34);
          goto LABEL_34;
        case kCFNumberSInt32Type:
        case kCFNumberIntType:
          if (!*(_DWORD *)valuePtr)
          {
            CFNumberRef v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }
          if (v11 == 1.0) {
            unsigned int v35 = *(_DWORD *)valuePtr;
          }
          else {
            unsigned int v35 = (int)(v11 * (double)*(int *)valuePtr);
          }
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          uint64_t v51 = 0;
          _CFBigNumInitWithInt32((uint64_t)&v49, v35);
          goto LABEL_34;
        case kCFNumberMaxType|kCFNumberSInt8Type:
          char v38 = valuePtr;
          uint64_t v36 = *(void *)valuePtr;
          uint64_t v37 = v38[1];
          if (!(v37 | v36))
          {
            CFNumberRef v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }
          uint64_t v39 = v37;
          uint64_t v40 = v36;
          *(_OWORD *)&uint64_t v41 = (__int128)(v11 * (double)*(long long *)&v39);
          if (v11 == 1.0) {
            uint64_t v43 = v37;
          }
          else {
            uint64_t v43 = v41;
          }
          if (v11 == 1.0) {
            uint64_t v44 = v36;
          }
          else {
            uint64_t v44 = v42;
          }
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          uint64_t v51 = 0;
          _CFBigNumInitWithInt128((uint64_t)&v49, v43, v44);
          goto LABEL_34;
        default:
          return v28;
      }
      return v28;
    }
LABEL_29:
    if (*(void *)valuePtr || (CFNumberRef v12 = (const void *)*((void *)formatter + 9)) == 0)
    {
      if (v11 == 1.0) {
        unint64_t v23 = *(void *)valuePtr;
      }
      else {
        unint64_t v23 = (uint64_t)(v11 * (double)*(uint64_t *)valuePtr);
      }
      uint64_t v49 = 0;
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      _CFBigNumInitWithInt64((uint64_t)&v49, v23);
LABEL_34:
      _CFBigNumToCString((uint64_t)&v49, 0, 1, __s, 0x300uLL);
      int v45 = 0;
      size_t v24 = strlen(__s);
      int v25 = __cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v24, (uint64_t)v53, 768, 0, &v45);
      CFIndex v18 = v25;
      if (v45 != 15 && v25 < 769)
      {
        uint64_t Typed = 0;
LABEL_39:
        int v19 = v45;
        goto LABEL_40;
      }
      uint64_t v26 = v25 + 2;
      uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v26, 0x1000040BDFB0063, 0);
      int v45 = 0;
      size_t v27 = strlen(__s);
      int v22 = __cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v27, (uint64_t)(Typed + 1), v26, 0, &v45);
LABEL_38:
      CFIndex v18 = v22;
      goto LABEL_39;
    }
    return (CFStringRef)CFRetain(v12);
  }
  if (((1 << numberType) & 0x810) != 0) {
    goto LABEL_29;
  }
  if (((1 << numberType) & 0x1020) == 0)
  {
    if (((1 << numberType) & 0x2040) != 0)
    {
      if (*(double *)valuePtr != 0.0 || (CFNumberRef v12 = (const void *)*((void *)formatter + 9)) == 0)
      {
        double v13 = *(double *)valuePtr * v11;
        uint64_t v14 = *((void *)formatter + 2);
        goto LABEL_24;
      }
      return (CFStringRef)CFRetain(v12);
    }
    goto LABEL_28;
  }
  float v15 = *(float *)valuePtr;
  if (*(float *)valuePtr == 0.0)
  {
    CFNumberRef v12 = (const void *)*((void *)formatter + 9);
    if (v12) {
      return (CFStringRef)CFRetain(v12);
    }
  }
  if (v11 != 1.0)
  {
    float v16 = v11 * v15;
    float v15 = v16;
  }
  uint64_t v14 = *((void *)formatter + 2);
  double v13 = v15;
LABEL_24:
  int v17 = __cficu_unum_formatDouble(v14, (uint64_t)v53, 768, 0, &v45, v13);
  CFIndex v18 = v17;
  int v19 = v45;
  if (v45 == 15 || v17 >= 769)
  {
    uint64_t v21 = v17 + 2;
    uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v21, 0x1000040BDFB0063, 0);
    int v45 = 0;
    int v22 = __cficu_unum_formatDouble(*((void *)formatter + 2), (uint64_t)(Typed + 1), v21, 0, &v45, v13);
    goto LABEL_38;
  }
  uint64_t Typed = 0;
LABEL_40:
  if (v19 > 0)
  {
    CFStringRef v28 = 0;
    if (!Typed) {
      return v28;
    }
    goto LABEL_54;
  }
  if (Typed) {
    char v29 = Typed;
  }
  else {
    char v29 = (UniChar *)v52;
  }
  if (*((unsigned char *)formatter + 82)
    && (CFStringRef Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
        CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
  {
    UniChar *v29 = 8207;
    ++v18;
  }
  else
  {
    if (Typed) {
      uint64_t v31 = Typed;
    }
    else {
      uint64_t v31 = (UniChar *)v52;
    }
    char v29 = v31 + 1;
  }
  CFStringRef v28 = CFStringCreateWithCharacters(v7, v29, v18);
  if (Typed) {
LABEL_54:
  }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v28;
}

uint64_t __cficu_unum_formatDouble(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = unum_formatDouble();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput((uint64_t)"result", a2, a3);
    CFStringRef v16 = ___CFICUCreateArgumentForDouble(a6);
    CFStringRef v17 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (a4) {
      ___CFICULogWithArguments(1, @"#warning non-NULL pos ignored.");
    }
    ___CFICULogWithArguments(1, @"unum_formatDouble(%@, %@, %@, %d, NULL, &%@); %@", v13, v16, v15, a3, v14, v17);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }
  return v12;
}

void *_CFBigNumToCString(uint64_t a1, int a2, int a3, char *a4, size_t a5)
{
  size_t v5 = a5;
  uint64_t v6 = a4;
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  if ((*(unsigned char *)(a1 + 20) & 0x80) != 0)
  {
    char v8 = 45;
  }
  else
  {
    if (!a3) {
      goto LABEL_6;
    }
    char v8 = 43;
  }
  *a4 = v8;
  uint64_t v6 = a4 + 1;
  size_t v5 = a5 - 1;
LABEL_6:
  snprintf(__str, 0x2EuLL, "%09u%09u%09u%09u%09u", *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4), *(_DWORD *)a1);
  if (a2)
  {
    memset(v6, 48, v5);
    if (v5 >= 0x2E) {
      size_t v9 = 46;
    }
    else {
      size_t v9 = v5;
    }
    return memmove(&v6[v5 - v9], &__str[-v9 + 46], v9);
  }
  else
  {
    for (CFIndex i = __str; *i == 48; ++i)
      ;
    if (*i) {
      uint64_t v12 = i;
    }
    else {
      uint64_t v12 = i - 1;
    }
    return (void *)strlcpy(v6, v12, v5);
  }
}

uint64_t _CFBigNumInitWithInt64(uint64_t result, unint64_t a2)
{
  *(void *)CFStringRef result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if ((a2 & 0x8000000000000000) != 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -(uint64_t)a2;
  }
  *(_DWORD *)CFStringRef result = a2 % 0xDE0B6B3A7640000 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 % 0xDE0B6B3A7640000 / 0x3B9ACA00;
  *(_DWORD *)(result + 8) = a2 / 0xDE0B6B3A7640000;
  return result;
}

uint64_t _CFBigNumInitWithInt32(uint64_t result, unsigned int a2)
{
  *(void *)CFStringRef result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if ((a2 & 0x80000000) != 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }
  *(_DWORD *)CFStringRef result = a2 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 / 0x3B9ACA00;
  return result;
}

__n128 _CFBigNumInitWithInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v3) = a2;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a3 < 0)
  {
    *(_DWORD *)(a1 + 20) |= 0xFFu;
    uint64_t v3 = -a2;
  }
  int v5 = __udivti3();
  unsigned int v6 = __udivti3();
  unsigned int v7 = __udivti3();
  unsigned __int32 v8 = __udivti3();
  result.n128_u32[0] = 1486618624 * v7 + 402653184 * v6 + v3 - 1000000000 * v8;
  result.n128_u32[1] = v8;
  result.n128_u64[1] = __PAIR64__(v6, v7);
  *(__n128 *)a1 = result;
  *(_DWORD *)(a1 + 16) = v5;
  return result;
}

CFLocaleRef CFLocaleCreateCopy(CFAllocatorRef allocator, CFLocaleRef locale)
{
  return (CFLocaleRef)MEMORY[0x1F41818D8](allocator, locale);
}

CFStringRef CFURLCopyQueryString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  CFStringRef String = _unescapedQueryString((unint64_t)anURL);
  if (!String) {
    return 0;
  }
  CFStringRef v5 = String;
  int v6 = *((_DWORD *)anURL + 5);
  CFAllocatorRef v7 = CFGetAllocator(anURL);
  if (v6 == 134217984) {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapes(v7, v5, charactersToLeaveEscaped);
  }
  else {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v7, v5, charactersToLeaveEscaped, *((_DWORD *)anURL + 5));
  }
  CFStringRef v9 = v8;
  CFRelease(v5);
  return v9;
}

CFStringRef _unescapedQueryString(unint64_t a1)
{
  while (1)
  {
    if (!a1) {
      _unescapedQueryString_cold_1();
    }
    if (CF_IS_OBJC(0x1DuLL, a1)) {
      break;
    }
    CFStringRef v2 = _retainedComponentString(a1, 128, 0, 0);
    if (v2) {
      return v2;
    }
    int v3 = *(_DWORD *)(a1 + 16);
    if ((v3 & 0x4000) == 0) {
      return 0;
    }
    uint64_t v4 = 0;
    if ((v3 & 0x3F) == 0)
    {
      a1 = *(void *)(a1 + 32);
      if (a1) {
        continue;
      }
    }
    return (const __CFString *)v4;
  }
  CFStringRef v5 = (const void *)[(id)a1 query];
  uint64_t v4 = v5;
  if (v5) {
    CFRetain(v5);
  }
  return (const __CFString *)v4;
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  uint64_t v41 = *(void *)off_1ECE0A5B0;
  if (!dictionary) {
    return 0;
  }
  CFAllocatorRef v33 = allocator;
  CFIndex Count = CFDictionaryGetCount(dictionary);
  v32[1] = v32;
  MEMORY[0x1F4188790](Count, v4);
  unint64_t v5 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  int v6 = (CFTypeRef *)((char *)v32 - v5);
  if ((unint64_t)(8 * Count) >= 0x200) {
    size_t v7 = 512;
  }
  else {
    size_t v7 = 8 * Count;
  }
  bzero((char *)v32 - v5, v7);
  MEMORY[0x1F4188790](v8, v9);
  CFNumberRef v10 = (const __CFString **)((char *)v32 - v5);
  bzero(v10, v7);
  CFDictionaryGetKeysAndValues(dictionary, (const void **)v10, v6);
  if (Count >= 1)
  {
    double v11 = 0;
    __int16 v34 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    unsigned int v35 = @"kCFLocaleCountryCodeKey";
    v32[0] = @"kCFLocaleVariantCodeKey";
    uint64_t v12 = (CFTypeRef *)v10;
    CFIndex v13 = Count;
    uint64_t v14 = (const __CFString **)v6;
    while (!CFEqual(@"kCFLocaleLanguageCodeKey", *v12))
    {
      if (CFEqual(@"kCFLocaleScriptCodeKey", *v12))
      {
        uint64_t v37 = __CStringFromString(*v14);
        goto LABEL_15;
      }
      if (CFEqual(v35, *v12))
      {
        uint64_t v36 = __CStringFromString(*v14);
        goto LABEL_15;
      }
      if (CFEqual(v32[0], *v12))
      {
        __int16 v34 = __CStringFromString(*v14);
        goto LABEL_15;
      }
LABEL_16:
      ++v14;
      ++v12;
      if (!--v13) {
        goto LABEL_20;
      }
    }
    double v11 = __CStringFromString(*v14);
LABEL_15:
    *uint64_t v12 = 0;
    goto LABEL_16;
  }
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  __int16 v34 = 0;
  double v11 = 0;
LABEL_20:
  uint64_t v39 = 0;
  CFStringRef v16 = "";
  CFStringRef v17 = "_";
  if (v11) {
    CFIndex v18 = (const char *)v11;
  }
  else {
    CFIndex v18 = "";
  }
  int v19 = v36;
  unsigned int v20 = v37;
  if (v37) {
    uint64_t v21 = "_";
  }
  else {
    uint64_t v21 = "";
  }
  if (v37) {
    int v22 = (const char *)v37;
  }
  else {
    int v22 = "";
  }
  unint64_t v23 = v34;
  if ((unint64_t)v36 | (unint64_t)v34) {
    size_t v24 = "_";
  }
  else {
    size_t v24 = "";
  }
  if (v36) {
    int v25 = (const char *)v36;
  }
  else {
    int v25 = "";
  }
  if (v34) {
    CFStringRef v16 = (const char *)v34;
  }
  else {
    CFStringRef v17 = "";
  }
  asprintf(&v39, "%s%s%s%s%s%s%s", v18, v21, v22, v24, v25, v17, v16);
  __strlcpy_chk();
  free(v11);
  free(v20);
  free(v19);
  free(v23);
  free(v39);
  if (Count >= 1)
  {
    do
    {
      if (*v10)
      {
        uint64_t v26 = __CStringFromString(*v10);
        int v27 = strcmp((const char *)v26, "kCFLocaleCalendarKey");
        CFStringRef v28 = (__CFString *)*v6;
        if (v27)
        {
          char v29 = __CStringFromString(v28);
        }
        else
        {
          CFStringRef Identifier = CFCalendarGetIdentifier((CFCalendarRef)v28);
          char v29 = __CStringFromString(Identifier);
          uint64_t v31 = strdup("calendar");
          free(v26);
          uint64_t v26 = (UInt8 *)v31;
        }
        int v38 = 0;
        uloc_setKeywordValue();
        free(v26);
        free(v29);
      }
      ++v6;
      ++v10;
      --Count;
    }
    while (Count);
  }
  return CFStringCreateWithCString(v33, v40, 0x600u);
}

UInt8 *__CStringFromString(const __CFString *a1)
{
  maxBufLen[1] = *(void *)off_1ECE0A5B0;
  if (!a1) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  maxBufLen[0] = 0;
  v6.CFIndex location = 0;
  v6.CFIndex length = Length;
  CFStringGetBytes(a1, v6, 0x600u, 0x3Fu, 0, 0, 0, maxBufLen);
  int v3 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x449D2309uLL);
  v7.CFIndex location = 0;
  v7.CFIndex length = Length;
  CFStringGetBytes(a1, v7, 0x600u, 0x3Fu, 0, v3, maxBufLen[0], maxBufLen);
  v3[maxBufLen[0]] = 0;
  return v3;
}

void CFAllocatorSetDefault(CFAllocatorRef allocator)
{
  CFAllocatorRef v2 = (CFAllocatorRef)_CFGetTSD(1u);
  if (!v2) {
    CFAllocatorRef v2 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  if (allocator)
  {
    unint64_t v3 = *(void *)allocator & ~(unint64_t)off_1ECE0A6D0;
    if ((*(void *)allocator & (unint64_t)off_1ECE0A6D0) != 0) {
      v3 |= *(void *)allocator & (unint64_t)off_1ECE0A6D0;
    }
    if (v3 == qword_1EB1DDDA0 && v2 != allocator)
    {
      CFRelease(v2);
      CFRetain(allocator);
      CFRetain(allocator);
      _CFSetTSD(1u, (uint64_t)allocator, 0);
    }
  }
}

CFDateRef CFDateFormatterCreateDateFromString(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep)
{
  CFAllocatorRef v7 = allocator;
  at[1] = *(CFAbsoluteTime *)off_1ECE0A5B0;
  if (!allocator)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      CFAllocatorRef v7 = (const __CFAllocator *)v8;
    }
    else {
      CFAllocatorRef v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v9 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v9 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v9);
  }
  at[0] = 0.0;
  if (CFDateFormatterGetAbsoluteTimeFromString(formatter, string, rangep, at)) {
    return CFDateCreate(v7, at[0]);
  }
  else {
    return 0;
  }
}

Boolean CFDateFormatterGetAbsoluteTimeFromString(CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  valuePtr[1] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v8 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v8);
  }
  if (rangep)
  {
    CFIndex location = rangep->location;
    CFIndex length = rangep->length;
  }
  else
  {
    CFIndex length = CFStringGetLength(string);
    CFIndex location = 0;
  }
  if (length >= 1024) {
    CFIndex v11 = 1024;
  }
  else {
    CFIndex v11 = length;
  }
  CharactersPtr = CFStringGetCharactersPtr(string);
  uint64_t v14 = MEMORY[0x1F4188790](CharactersPtr, v13);
  CFStringRef v16 = (UChar *)((char *)&v60 - v15);
  if (v14)
  {
    CFStringRef v16 = (UChar *)(v14 + 2 * location);
  }
  else
  {
    v63.CFIndex location = location;
    v63.CFIndex length = v11;
    CFStringGetCharacters(string, v63, (UniChar *)((char *)&v60 - v15));
  }
  uint64_t v61 = 0;
  uint64_t v17 = __cficu_udat_clone(*((void *)formatter + 2), (int *)&v61);
  uint64_t Calendar = __cficu_udat_getCalendar(v17);
  uint64_t v19 = __cficu_ucal_clone(Calendar, (int *)&v61);
  CFTypeRef v20 = CFDateFormatterCopyProperty(formatter, @"kCFDateFormatterCalendarIdentifierKey");
  if (CFEqual(v20, @"chinese") || CFEqual(v20, @"japanese"))
  {
    if (CFEqual(v20, @"chinese"))
    {
      __cficu_ucal_clear(v19);
      uint64_t v21 = v19;
      int v22 = 1;
    }
    else
    {
      if (!CFEqual(v20, @"japanese")) {
        goto LABEL_18;
      }
      double Now = __cficu_ucal_getNow();
      __cficu_ucal_setMillis(v19, (int *)&v61, Now);
      int v24 = __cficu_ucal_get(v19, 0, (int *)&v61);
      __cficu_ucal_clear(v19);
      uint64_t v21 = v19;
      int v22 = v24;
    }
    __cficu_ucal_set(v21, 0, v22);
  }
  else
  {
    __cficu_ucal_clear(v19);
    __cficu_ucal_set(v19, 1u, 12000);
    __cficu_udat_set2DigitYearStart(v17, (int *)&v61, 3.16516205e14);
  }
LABEL_18:
  CFDateRef v25 = (const __CFDate *)*((void *)formatter + 15);
  if (v25)
  {
    CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(v25);
    __cficu_ucal_setMillis(v19, (int *)&v61, (AbsoluteTime + 978307200.0) * 1000.0);
  }
  __cficu_udat_parseCalendar(v17, v19, v16, v11, (unsigned int *)&v61 + 1, (int *)&v61);
  double Millis = __cficu_ucal_getMillis(v19, (int *)&v61);
  if (rangep) {
    rangep->CFIndex length = SHIDWORD(v61);
  }
  if ((int)v61 > 0) {
    goto LABEL_74;
  }
  valuePtr[0] = 1;
  CFNumberRef v28 = (const __CFNumber *)*((void *)formatter + 37);
  if (v28) {
    CFNumberGetValue(v28, kCFNumberSInt64Type, valuePtr);
  }
  if (CFEqual(v20, @"chinese"))
  {
    if ((int)__cficu_ucal_get(v19, 0, (int *)&v61) > 9) {
      goto LABEL_73;
    }
    switch(valuePtr[0])
    {
      case 0:
        goto LABEL_74;
      case 2:
        double v29 = __cficu_ucal_getNow();
        __cficu_ucal_setMillis(v19, (int *)&v61, v29);
        int v30 = __cficu_ucal_get(v19, 0, (int *)&v61);
        goto LABEL_66;
      case 3:
        uint64_t v43 = v19;
        double v44 = Millis;
        uint64_t v45 = 60;
        uint64_t v46 = 29;
        uint64_t v47 = 30;
        break;
      case 4:
        uint64_t v43 = v19;
        double v44 = Millis;
        uint64_t v45 = 60;
        uint64_t v46 = 0;
        uint64_t v47 = 59;
        break;
      case 5:
        uint64_t v43 = v19;
        double v44 = Millis;
        uint64_t v45 = 60;
        uint64_t v46 = 59;
        uint64_t v47 = 0;
        break;
      case 6:
        uint64_t v43 = v19;
        double v44 = Millis;
        uint64_t v45 = 60;
        uint64_t v46 = 10;
        uint64_t v47 = 49;
        break;
      case 7:
        uint64_t v43 = v19;
        double v44 = Millis;
        uint64_t v45 = 60;
        uint64_t v46 = 49;
        uint64_t v47 = 10;
        break;
      default:
        goto LABEL_73;
    }
    int v48 = 1;
LABEL_45:
    double v49 = __CFDateFormatterCorrectTimeToARangeAroundCurrentDate(v43, v45, v46, v47, v48, (int *)&v61, v44);
  }
  else if (CFEqual(v20, @"japanese"))
  {
    __cficu_ucal_clear(v19);
    __cficu_ucal_set(v19, 0, 1);
    __cficu_udat_parseCalendar(v17, v19, v16, v11, 0, (int *)&v61);
    if (__cficu_ucal_getMillis(v19, (int *)&v61) == Millis) {
      goto LABEL_73;
    }
    __cficu_ucal_setMillis(v19, (int *)&v61, Millis);
    int v31 = __cficu_ucal_get(v19, 1u, (int *)&v61);
    double v32 = __cficu_ucal_getNow();
    __cficu_ucal_setMillis(v19, (int *)&v61, v32);
    int v33 = __cficu_ucal_get(v19, 1u, (int *)&v61);
    int v34 = __cficu_ucal_get(v19, 0, (int *)&v61);
    int v30 = v34;
    switch(valuePtr[0])
    {
      case 0:
        goto LABEL_74;
      case 2:
        goto LABEL_66;
      case 4:
        if (v31 < v33) {
          goto LABEL_74;
        }
        goto LABEL_66;
      case 5:
        if (v31 <= v33) {
          goto LABEL_66;
        }
        if (v34 < 235) {
          goto LABEL_74;
        }
        uint64_t v51 = (v34 - 1);
        break;
      case 6:
        if (v31 < v33 - 10) {
          goto LABEL_74;
        }
        goto LABEL_66;
      case 7:
        if (v31 <= v33 + 10)
        {
LABEL_66:
          uint64_t v53 = v19;
          double v54 = Millis;
          goto LABEL_67;
        }
        if (v34 < 235) {
          goto LABEL_74;
        }
        uint64_t v51 = (v34 - 1);
        do
        {
          if (v31 <= (int)__CFDateFormatterGetMaxYearGivenJapaneseEra(v19, v51, (int *)&v61)) {
            goto LABEL_81;
          }
          BOOL v52 = v51-- < 235;
        }
        while (!v52);
        goto LABEL_74;
      default:
        goto LABEL_73;
    }
    while (v31 > (int)__CFDateFormatterGetMaxYearGivenJapaneseEra(v19, v51, (int *)&v61))
    {
      BOOL v52 = v51-- < 235;
      if (v52) {
        goto LABEL_74;
      }
    }
LABEL_81:
    uint64_t v53 = v19;
    double v54 = Millis;
    int v30 = v51;
LABEL_67:
    int v55 = 1;
LABEL_68:
    double v49 = __CFDateFormatterCorrectTimeWithTarget(v53, v30, v55, (int *)&v61, v54);
  }
  else
  {
    int v35 = __cficu_ucal_get(v19, 1u, (int *)&v61);
    int v36 = v35 - 12000;
    if ((v35 - 12000) > 0x63) {
      goto LABEL_73;
    }
    int v37 = v35;
    if (!*((void *)formatter + 14))
    {
      switch(valuePtr[0])
      {
        case 0:
          goto LABEL_74;
        case 2:
          double v50 = __cficu_ucal_getNow();
          __cficu_ucal_setMillis(v19, (int *)&v61, v50);
          int v30 = (unsigned __int16)v37 % 0x64u + 100 * ((int)__cficu_ucal_get(v19, 1u, (int *)&v61) / 100);
          goto LABEL_87;
        case 3:
          uint64_t v43 = v19;
          double v44 = Millis;
          uint64_t v45 = 100;
          uint64_t v46 = 50;
          int v48 = 0;
          uint64_t v47 = 49;
          goto LABEL_45;
        case 4:
          uint64_t v43 = v19;
          double v44 = Millis;
          uint64_t v45 = 100;
          uint64_t v46 = 0;
          uint64_t v47 = 99;
          goto LABEL_92;
        case 5:
          uint64_t v43 = v19;
          double v44 = Millis;
          uint64_t v45 = 100;
          uint64_t v46 = 99;
          uint64_t v47 = 0;
LABEL_92:
          int v48 = 0;
          goto LABEL_45;
        case 6:
          uint64_t v43 = v19;
          double v44 = Millis;
          uint64_t v45 = 100;
          uint64_t v46 = 9;
          int v48 = 0;
          uint64_t v47 = 90;
          goto LABEL_45;
        case 7:
          uint64_t v43 = v19;
          double v44 = Millis;
          uint64_t v45 = 100;
          uint64_t v46 = 90;
          int v48 = 0;
          uint64_t v47 = 9;
          goto LABEL_45;
        default:
          if (!CFEqual(v20, @"gregorian")) {
            goto LABEL_73;
          }
          unsigned int v58 = (unsigned __int16)v37 % 0x64u;
          if (v58 >= 0x32) {
            int v59 = 1900;
          }
          else {
            int v59 = 2000;
          }
          int v30 = v59 + v58;
LABEL_87:
          uint64_t v53 = v19;
          double v54 = Millis;
          int v55 = 0;
          goto LABEL_68;
      }
    }
    uint64_t v38 = __cficu_ucal_clone(v19, (int *)&v61);
    __cficu_ucal_clear(v38);
    double v39 = (CFDateGetAbsoluteTime(*((CFDateRef *)formatter + 14)) + 978307200.0) * 1000.0;
    __cficu_ucal_setMillis(v38, (int *)&v61, v39);
    int v40 = __cficu_ucal_get(v38, 1u, (int *)&v61);
    int v41 = v40;
    int v42 = v40 % 100;
    if (v40 % 100 >= v36)
    {
      if (v36 >= v42)
      {
        __cficu_ucal_set(v19, 1u, v40);
        if (__cficu_ucal_getMillis(v19, (int *)&v61) < v39) {
          v41 += 100;
        }
      }
      else
      {
        int v41 = v37 + v40 - v42 - 11900;
      }
    }
    else
    {
      int v41 = v40 + v36 - v42;
    }
    __cficu_ucal_close(v38);
    __cficu_ucal_set(v19, 1u, v41);
    double v49 = __cficu_ucal_getMillis(v19, (int *)&v61);
  }
  double Millis = v49;
LABEL_73:
  if ((int)v61 <= 0)
  {
    if (atp) {
      *atp = Millis / 1000.0 - 978307200.0;
    }
    Boolean v56 = 1;
    if (v20) {
      goto LABEL_75;
    }
    goto LABEL_76;
  }
LABEL_74:
  Boolean v56 = 0;
  if (v20) {
LABEL_75:
  }
    CFRelease(v20);
LABEL_76:
  __cficu_udat_close(v17);
  __cficu_ucal_close(v19);
  return v56;
}

uint64_t __cficu_ucal_clone(uint64_t a1, int *a2)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = ucal_clone();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      unint64_t v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", v4);
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFAllocatorRef v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      unint64_t v9 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        uint64_t v12 = v5;
        __int16 v13 = 2112;
        CFStringRef v14 = v6;
        __int16 v15 = 2112;
        CFStringRef v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v8;
        _os_log_debug_impl(&dword_182B90000, v9, OS_LOG_TYPE_DEBUG, "UCalendar *%@ = ucal_clone(%@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v5);
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }
  return v4;
}

void __CFDateFormatterDeallocate(void *a1)
{
  uint64_t v2 = a1[2];
  if (v2) {
    __cficu_udat_close(v2);
  }
  unint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  unint64_t v5 = (const void *)a1[7];
  if (v5) {
    CFRelease(v5);
  }
  CFStringRef v6 = (const void *)a1[8];
  if (v6) {
    CFRelease(v6);
  }
  CFAllocatorRef v7 = (const void *)a1[9];
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v8 = (const void *)a1[11];
  if (v8) {
    CFRelease(v8);
  }
  unint64_t v9 = (const void *)a1[12];
  if (v9) {
    CFRelease(v9);
  }
  CFNumberRef v10 = (const void *)a1[13];
  if (v10) {
    CFRelease(v10);
  }
  int v11 = (const void *)a1[14];
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = (const void *)a1[15];
  if (v12) {
    CFRelease(v12);
  }
  __int16 v13 = (const void *)a1[16];
  if (v13) {
    CFRelease(v13);
  }
  CFStringRef v14 = (const void *)a1[17];
  if (v14) {
    CFRelease(v14);
  }
  __int16 v15 = (const void *)a1[18];
  if (v15) {
    CFRelease(v15);
  }
  CFStringRef v16 = (const void *)a1[19];
  if (v16) {
    CFRelease(v16);
  }
  __int16 v17 = (const void *)a1[20];
  if (v17) {
    CFRelease(v17);
  }
  CFStringRef v18 = (const void *)a1[21];
  if (v18) {
    CFRelease(v18);
  }
  uint64_t v19 = (const void *)a1[22];
  if (v19) {
    CFRelease(v19);
  }
  CFTypeRef v20 = (const void *)a1[23];
  if (v20) {
    CFRelease(v20);
  }
  uint64_t v21 = (const void *)a1[24];
  if (v21) {
    CFRelease(v21);
  }
  int v22 = (const void *)a1[25];
  if (v22) {
    CFRelease(v22);
  }
  unint64_t v23 = (const void *)a1[26];
  if (v23) {
    CFRelease(v23);
  }
  int v24 = (const void *)a1[27];
  if (v24) {
    CFRelease(v24);
  }
  CFDateRef v25 = (const void *)a1[28];
  if (v25) {
    CFRelease(v25);
  }
  uint64_t v26 = (const void *)a1[29];
  if (v26) {
    CFRelease(v26);
  }
  int v27 = (const void *)a1[30];
  if (v27) {
    CFRelease(v27);
  }
  CFNumberRef v28 = (const void *)a1[31];
  if (v28) {
    CFRelease(v28);
  }
  double v29 = (const void *)a1[32];
  if (v29) {
    CFRelease(v29);
  }
  int v30 = (const void *)a1[33];
  if (v30) {
    CFRelease(v30);
  }
  int v31 = (const void *)a1[34];
  if (v31) {
    CFRelease(v31);
  }
  double v32 = (const void *)a1[35];
  if (v32) {
    CFRelease(v32);
  }
  int v33 = (const void *)a1[36];
  if (v33) {
    CFRelease(v33);
  }
  int v34 = (const void *)a1[37];
  if (v34) {
    CFRelease(v34);
  }
  int v35 = (const void *)a1[38];
  if (v35) {
    CFRelease(v35);
  }
  int v36 = (const void *)a1[39];
  if (v36) {
    CFRelease(v36);
  }
  int v37 = (const void *)a1[40];
  if (v37) {
    CFRelease(v37);
  }
  uint64_t v38 = (const void *)a1[42];
  if (v38) {
    CFRelease(v38);
  }
  double v39 = (const void *)a1[43];
  if (v39) {
    CFRelease(v39);
  }
  int v40 = (const void *)a1[48];
  if (v40) {
    CFRelease(v40);
  }
  int v41 = (const void *)a1[49];
  if (v41) {
    CFRelease(v41);
  }
  int v42 = (const void *)a1[41];
  if (v42) {
    CFRelease(v42);
  }
  uint64_t v43 = (const void *)a1[44];
  if (v43) {
    CFRelease(v43);
  }
  double v44 = (const void *)a1[50];
  if (v44) {
    CFRelease(v44);
  }
  uint64_t v45 = (const void *)a1[45];
  if (v45) {
    CFRelease(v45);
  }
  uint64_t v46 = (const void *)a1[46];
  if (v46) {
    CFRelease(v46);
  }
  uint64_t v47 = (const void *)a1[47];
  if (v47) {
    CFRelease(v47);
  }
  int v48 = (const void *)a1[51];
  if (v48) {
    CFRelease(v48);
  }
  double v49 = (const void *)a1[52];
  if (v49) {
    CFRelease(v49);
  }
  double v50 = (const void *)a1[53];
  if (v50) {
    CFRelease(v50);
  }
  uint64_t v51 = (const void *)a1[54];
  if (v51) {
    CFRelease(v51);
  }
  BOOL v52 = (const void *)a1[55];
  if (v52) {
    CFRelease(v52);
  }
  uint64_t v53 = (const void *)a1[57];
  if (v53) {
    CFRelease(v53);
  }
  double v54 = (const void *)a1[58];
  if (v54) {
    CFRelease(v54);
  }
  int v55 = (const void *)a1[59];
  if (v55) {
    CFRelease(v55);
  }
  Boolean v56 = (const void *)a1[60];
  if (v56) {
    CFRelease(v56);
  }
  uint64_t v57 = (const void *)a1[61];
  if (v57) {
    CFRelease(v57);
  }
  unsigned int v58 = (const void *)a1[62];
  if (v58) {
    CFRelease(v58);
  }
  int v59 = (const void *)a1[63];
  if (v59) {
    CFRelease(v59);
  }
  uint64_t v60 = (const void *)a1[64];
  if (v60) {
    CFRelease(v60);
  }
  uint64_t v61 = (const void *)a1[65];
  if (v61)
  {
    CFRelease(v61);
  }
}

void __cficu_udat_close(uint64_t a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    udat_close();
    ___CFICULogWithArguments(1, @"udat_close(%@);", v2);
    CFRelease(v2);
  }
  else
  {
    udat_close();
  }
}

uint64_t __cficu_udat_clone(uint64_t a1, int *a2)
{
  uint64_t v4 = udat_clone();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    unint64_t v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", v4);
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFAllocatorRef v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"UDateFormat *%@ = udat_clone(%@, &%@); %@", v5, v6, v7, v8);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v8);
  }
  return v4;
}

double __cficu_ucal_getMillis(uint64_t a1, int *a2)
{
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  ucal_getMillis();
  double v5 = v4;
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFAllocatorRef v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      unint64_t v9 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v7;
        __int16 v15 = 2048;
        double v16 = v5;
        __int16 v17 = 2112;
        CFStringRef v18 = v8;
        _os_log_debug_impl(&dword_182B90000, v9, OS_LOG_TYPE_DEBUG, "ucal_getMillis(%@, &%@); // %f %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }
  return v5;
}

void __cficu_udat_parseCalendar(uint64_t a1, uint64_t a2, UChar *a3, uint64_t a4, unsigned int *a5, int *a6)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
  }
  if (___CFICULoggingEnabled_loggingEnabled)
  {
    CFStringRef v12 = ___CFICUCreateArgumentForParsePosition(a5);
    udat_parseCalendar();
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a2);
    __int16 v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    CFStringRef v18 = v17;
    if (a5) {
      uint64_t v19 = *a5;
    }
    else {
      uint64_t v19 = 0xFFFFFFFFLL;
    }
    ___CFICULogWithArguments(1, @"udat_parseCalendar(%@, %@, %@, %d, %@, &%@); // %d %@",
      v13,
      v14,
      v17,
      a4,
      v12,
      v15,
      v19,
      v16);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v14);
    CFRelease(v13);
    CFRelease(v18);
    CFRelease(v16);
  }
  else
  {
    udat_parseCalendar();
  }
}

void __cficu_ucal_set(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  ucal_set();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFAllocatorRef v7 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v8 = 138412802;
        CFStringRef v9 = v6;
        __int16 v10 = 2080;
        int v11 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v12 = 1024;
        int v13 = a3;
        _os_log_debug_impl(&dword_182B90000, v7, OS_LOG_TYPE_DEBUG, "ucal_set(%@, %s, %d);", (uint8_t *)&v8, 0x1Cu);
      }
      CFRelease(v6);
    }
  }
}

void __cficu_ucal_clear(uint64_t a1)
{
  MEMORY[0x1853127C0]();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      unint64_t v3 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG)) {
        __cficu_ucal_clear_cold_1((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
      }
      CFRelease(v2);
    }
  }
}

uint64_t __cficu_ucal_get(uint64_t a1, unsigned int a2, int *a3)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = ucal_get();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_183);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      __int16 v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 138413314;
        CFStringRef v13 = v7;
        __int16 v14 = 2080;
        __int16 v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v16 = 2112;
        CFStringRef v17 = v8;
        __int16 v18 = 1024;
        int v19 = v6;
        __int16 v20 = 2112;
        CFStringRef v21 = v9;
        _os_log_debug_impl(&dword_182B90000, v10, OS_LOG_TYPE_DEBUG, "ucal_get(%@, %s, &%@); // %d %@",
          (uint8_t *)&v12,
          0x30u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
  return v6;
}

void _cfmp_source_invalidated(int a1, int a2)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if (_cfmp_records_oGuard != -1) {
    dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
  }
  CFSetRef v4 = (const __CFSet *)_cfmp_records_oRecords;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
  v7[0] = a2;
  v7[1] = a1;
  CFStringRef Value = CFSetGetValue(v4, v7);
  if (!Value)
  {
    _cfmp_log_failure((uint64_t)"not expecting invalidation", 0, a1, a2);
    goto LABEL_7;
  }
  if ((Value[5] & 2) == 0)
  {
    Value[5] |= 4u;
LABEL_7:
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    return;
  }
  unint64_t v6 = *(void *)Value;
  CFSetRemoveValue(v4, Value);
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
  _cfmp_cleanup(v6);
}

unint64_t _cfmp_cleanup(unint64_t name)
{
  mach_port_name_t v1 = name;
  char v2 = BYTE5(name);
  if (((name >> 40) & 0x10) != 0)
  {
    mach_port_name_t name = mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, name, 1u, -1);
    if ((v2 & 8) == 0)
    {
LABEL_3:
      if ((v2 & 0x20) == 0) {
        return name;
      }
      goto LABEL_7;
    }
  }
  else if ((name & 0x80000000000) == 0)
  {
    goto LABEL_3;
  }
  mach_port_name_t name = mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, v1);
  if ((v2 & 0x20) == 0) {
    return name;
  }
LABEL_7:
  if (v2 < 0)
  {
    mach_port_name_t name = mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, v1, 1u, -1);
    if ((v2 & 0x40) == 0) {
      return name;
    }
  }
  else if ((v2 & 0x40) == 0)
  {
    return name;
  }
  ipc_space_t v3 = *(_DWORD *)off_1ECE0A6C8;

  return mach_port_deallocate(v3, v1);
}

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray)) {
    goto LABEL_2;
  }
  unsigned int v12 = atomic_load((unint64_t *)theArray + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_2:
      CFStringRef v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    char v14 = atomic_load((unint64_t *)theArray + 1);
    int v15 = v14 & 3;
    if (v15) {
      __int16 v16 = 0;
    }
    else {
      __int16 v16 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v15 == 2) {
      CFStringRef v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      CFStringRef v7 = v16;
    }
  }
  else
  {
    CFStringRef v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (!length) {
    return -1;
  }
  while (1)
  {
    CFIndex v8 = length - 1;
    CFStringRef v9 = (const void *)[(__CFArray *)theArray objectAtIndex:location - 1 + length];
    if (v9 == value) {
      return v8 + location;
    }
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal)
    {
      if (equal(value, v9)) {
        break;
      }
    }
    --length;
    if (!v8) {
      return -1;
    }
  }
  return location + length - 1;
}

void sub_182C8BE90(_Unwind_Exception *a1)
{
  free(*(void **)(v1 - 168));
  _Unwind_Resume(a1);
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)theArray))
  {
    [(__CFArray *)theArray exchangeObjectAtIndex:idx1 withObjectAtIndex:idx2];
  }
  else
  {
    unint64_t v6 = (unint64_t *)((char *)theArray + 8);
    char v7 = atomic_load((unint64_t *)theArray + 1);
    if ((v7 & 1 | 2) == 2)
    {
      char v8 = atomic_load(v6);
      int v9 = v8 & 3;
      if (v9 == 2)
      {
        int v13 = (char *)(*((void *)theArray + 5) + 8 * **((void **)theArray + 5) + 16);
      }
      else if (v9)
      {
        int v13 = 0;
      }
      else
      {
        char v10 = atomic_load((unint64_t *)theArray + 1);
        BOOL v11 = (~v10 & 0xC) == 0;
        uint64_t v12 = 48;
        if (v11) {
          uint64_t v12 = 88;
        }
        int v13 = (char *)theArray + v12;
      }
      char v14 = &v13[8 * idx1];
    }
    else
    {
      char v14 = 0;
    }
    atomic_load(v6);
    char v15 = atomic_load(v6);
    if ((v15 & 3) != 0)
    {
      __int16 v16 = (char *)(*((void *)theArray + 5) + 8 * **((void **)theArray + 5) + 16);
    }
    else
    {
      char v17 = atomic_load((unint64_t *)theArray + 1);
      BOOL v11 = (~v17 & 0xC) == 0;
      uint64_t v18 = 48;
      if (v11) {
        uint64_t v18 = 88;
      }
      __int16 v16 = (char *)theArray + v18;
    }
    uint64_t v19 = *(void *)v14;
    *(void *)char v14 = *(void *)&v16[8 * idx2];
    *(void *)&v16[8 * idx2] = v19;
    ++*((void *)theArray + 3);
  }
}

uint64_t _CFURLComponentsGetURLQueryAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 32);
}

CFArrayRef CFBundleCopyResourceURLsOfType(CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName)
{
  if (bundle) {
    return _CFBundleCopyFindResources((uint64_t)bundle, 0, (uint64_t)subDirName, 0, resourceType, subDirName, 0, 1, 0, 0);
  }

  return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
}

void sub_182C8C6B0(_Unwind_Exception *exception_object)
{
}

unint64_t *_CFURLCreateFromComponents(CFAllocatorRef alloc, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  if (a2 == 2)
  {
    CFDictionaryRef Mutable = CFStringCreateMutable(alloc, 0);
    MutableCFStringRef Copy = Mutable;
    CFStringRef v11 = *(CFStringRef *)a3;
    if (*(void *)a3)
    {
      CFStringAppend(Mutable, *(CFStringRef *)a3);
      CFStringAppend(MutableCopy, @"://");
      CFURLRef v12 = 0;
    }
    else
    {
      CFURLRef v12 = *(const __CFURL **)(a3 + 56);
    }
    CFStringRef v15 = *(const __CFString **)(a3 + 8);
    if (v15)
    {
      CFStringAppend(MutableCopy, v15);
      CFStringAppend(MutableCopy, @"@");
      CFStringRef v16 = *(const __CFString **)(a3 + 16);
      if (!v16)
      {
LABEL_26:
        CFArrayRef v18 = *(const __CFArray **)(a3 + 32);
        if (!v18
          || (CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, 0), CFStringGetLength(ValueAtIndex)))
        {
          CFStringAppend(MutableCopy, @"/");
        }
LABEL_29:
        CFArrayRef v20 = *(const __CFArray **)(a3 + 32);
        if (v20)
        {
          CFStringRef v21 = CFStringCreateByCombiningStrings(alloc, v20, @"/");
          CFStringAppend(MutableCopy, v21);
          CFRelease(v21);
        }
        if (*(void *)(a3 + 40))
        {
          CFStringAppend(MutableCopy, @"?");
          CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 40));
        }
        if (*(void *)(a3 + 48))
        {
          CFStringAppend(MutableCopy, @"#");
          CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 48));
        }
        if (!MutableCopy) {
          goto LABEL_58;
        }
LABEL_36:
        uint64_t v22 = (__objc2_class **)alloc;
        CFStringRef v23 = MutableCopy;
        CFURLRef v24 = v12;
LABEL_62:
        int v31 = _CFURLCreateWithURLString(v22, v23, 1, v24);
        goto LABEL_63;
      }
    }
    else
    {
      CFStringRef v16 = *(const __CFString **)(a3 + 16);
      if (!v16)
      {
        if (!v11) {
          goto LABEL_29;
        }
        goto LABEL_26;
      }
    }
    CFStringAppend(MutableCopy, v16);
    if (*(void *)(a3 + 24) != -1) {
      CFStringAppendFormat(MutableCopy, 0, @":%ld", *(void *)(a3 + 24));
    }
    goto LABEL_26;
  }
  if (a2 != 1)
  {
    if (!a2)
    {
      CFStringRef v5 = *(const __CFString **)a3;
      if (*(void *)a3)
      {
        UniChar chars = 58;
        CFIndex v6 = CFStringGetLength(v5) + 1;
        CFStringRef Length = *(const __CFString **)(a3 + 8);
        if (Length) {
          CFStringRef Length = (const __CFString *)CFStringGetLength(Length);
        }
        MutableCFStringRef Copy = CFStringCreateMutableCopy(alloc, (CFIndex)Length + v6, *(CFStringRef *)a3);
        CFStringAppendCharacters(MutableCopy, &chars, 1);
        CFStringRef v9 = *(const __CFString **)(a3 + 8);
        if (v9) {
          CFStringAppend(MutableCopy, v9);
        }
        if (!MutableCopy) {
          return 0;
        }
        goto LABEL_61;
      }
      MutableCFStringRef Copy = *(__CFString **)(a3 + 8);
      if (MutableCopy)
      {
        CFRetain(*(CFTypeRef *)(a3 + 8));
LABEL_61:
        uint64_t v22 = (__objc2_class **)alloc;
        CFStringRef v23 = MutableCopy;
        CFURLRef v24 = 0;
        goto LABEL_62;
      }
    }
    return 0;
  }
  int v13 = CFStringCreateMutable(alloc, 0);
  MutableCFStringRef Copy = v13;
  if (*(void *)a3)
  {
    CFStringAppend(v13, *(CFStringRef *)a3);
    CFStringAppend(MutableCopy, @"://");
    CFURLRef v12 = 0;
    int v14 = 1;
  }
  else
  {
    int v14 = 0;
    CFURLRef v12 = *(const __CFURL **)(a3 + 72);
  }
  CFStringRef v17 = *(const __CFString **)(a3 + 8);
  if (v17)
  {
    CFStringAppend(MutableCopy, v17);
    if (!*(void *)(a3 + 16)) {
      goto LABEL_39;
    }
  }
  else if (!*(void *)(a3 + 16))
  {
    goto LABEL_40;
  }
  CFStringAppend(MutableCopy, @":");
  CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 16));
LABEL_39:
  CFStringAppend(MutableCopy, @"@");
  int v14 = 1;
LABEL_40:
  CFStringRef v25 = *(const __CFString **)(a3 + 24);
  if (v25)
  {
    CFStringAppend(MutableCopy, v25);
    uint64_t v26 = *(void *)(a3 + 32);
    if (v26 == -1) {
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v26 = *(void *)(a3 + 32);
    if (v26 == -1)
    {
      if (!v14) {
        goto LABEL_49;
      }
      goto LABEL_45;
    }
  }
  CFStringAppendFormat(MutableCopy, 0, @":%ld", v26);
LABEL_45:
  CFArrayRef v27 = *(const __CFArray **)(a3 + 40);
  if (!v27
    || !CFArrayGetCount(v27)
    || (CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 40), 0), CFStringGetLength(v28)))
  {
    CFStringAppend(MutableCopy, @"/");
  }
LABEL_49:
  CFArrayRef v29 = *(const __CFArray **)(a3 + 40);
  if (v29)
  {
    CFStringRef v30 = CFStringCreateByCombiningStrings(alloc, v29, @"/");
    CFStringAppend(MutableCopy, v30);
    CFRelease(v30);
  }
  if (*(void *)(a3 + 48))
  {
    CFStringAppend(MutableCopy, @";");
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 48));
  }
  if (*(void *)(a3 + 56))
  {
    CFStringAppend(MutableCopy, @"?");
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 56));
  }
  if (*(void *)(a3 + 64))
  {
    CFStringAppend(MutableCopy, @"#");
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 64));
  }
  if (MutableCopy) {
    goto LABEL_36;
  }
LABEL_58:
  int v31 = 0;
LABEL_63:
  CFRelease(MutableCopy);
  return v31;
}

double __CFDateGetTypeID_block_invoke()
{
  v3[1] = *(mach_timebase_info *)off_1ECE0A5B0;
  v3[0] = 0;
  mach_timebase_info(v3);
  LODWORD(v1) = v3[0].denom;
  LODWORD(vCFNotificationCenterRemoveObserver(center, observer, 0, 0) = v3[0].numer;
  *(double *)&__CFTSRRate = 1000000000.0 / (double)v0 * (double)v1;
  double result = 1.0 / *(double *)&__CFTSRRate;
  *(double *)&__CF1_TSRRate = 1.0 / *(double *)&__CFTSRRate;
  return result;
}

CFStringRef _CFStringCreateByRemovingPercentEncoding(const __CFAllocator *a1, CFStringRef theString)
{
  v19[1] = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(theString);
  if (Length)
  {
    CFIndex v5 = Length;
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding == -1) {
      return 0;
    }
    CFIndex v8 = MaximumSizeForEncoding;
    CFStringRef v9 = 0;
    if ((MaximumSizeForEncoding & 0x8000000000000000) == 0)
    {
      unint64_t v10 = 2 * MaximumSizeForEncoding;
      if (2 * MaximumSizeForEncoding)
      {
        if (v10 < 0x401)
        {
          MEMORY[0x1F4188790](MaximumSizeForEncoding, v7);
          CFStringRef v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v11, 2 * v8);
        }
        else
        {
          CFStringRef v11 = (char *)malloc_type_malloc(2 * MaximumSizeForEncoding, 0x100004077774924uLL);
        }
        v19[0] = 0;
        v21.CFIndex location = 0;
        v21.CFIndex length = v5;
        if (CFStringGetBytes(theString, v21, 0x8000100u, 0, 0, (UInt8 *)v11, v8, v19))
        {
          CFIndex v13 = v19[0];
          int v14 = &v11[v8];
          if (v19[0] >= 1)
          {
            CFIndex v15 = 0;
            CFStringRef v16 = (unsigned __int8 *)v11;
            int v14 = &v11[v8];
            do
            {
              int v17 = *v16;
              if (v17 == 37)
              {
                v15 += 2;
                if (v15 >= v13) {
                  goto LABEL_22;
                }
                int v18 = _CFStringCreateByRemovingPercentEncoding_hexvalues[v16[1]];
                int v17 = _CFStringCreateByRemovingPercentEncoding_hexvalues[v16[2]];
                if (((v17 | v18) & 0x80) != 0) {
                  goto LABEL_22;
                }
                v16 += 3;
                LOBYTE(v17) = v17 + 16 * v18;
              }
              else
              {
                ++v16;
              }
              *v14++ = v17;
              ++v15;
              CFIndex v13 = v19[0];
            }
            while (v15 < v19[0]);
          }
          CFStringRef v9 = CFStringCreateWithBytes(0, (const UInt8 *)&v11[v8], v14 - &v11[v8], 0x8000100u, 0);
        }
        else
        {
LABEL_22:
          CFStringRef v9 = 0;
        }
        if (v10 >= 0x401) {
          free(v11);
        }
      }
    }
    return v9;
  }
  else
  {
    return CFStringCreateCopy(a1, theString);
  }
}

CFStringRef _CFURLCopyUserName(unint64_t a1, int a2)
{
  while (1)
  {
    if (!a1) {
      _CFURLCopyUserName_cold_1();
    }
    if (CF_IS_OBJC(0x1DuLL, a1)) {
      break;
    }
    CFStringRef v4 = _retainedComponentString(a1, 2, 1, a2);
    if (v4) {
      return v4;
    }
    if (*(void *)(a1 + 32))
    {
      char v5 = *(unsigned char *)(a1 + 16);
      a1 = *(void *)(a1 + 32);
      if ((v5 & 0x1F) == 0) {
        continue;
      }
    }
    return 0;
  }
  uint64_t v7 = (const void *)[(id)a1 user];
  CFIndex v6 = v7;
  if (v7) {
    CFRetain(v7);
  }
  return (const __CFString *)v6;
}

CFStringRef _CFURLCopyPassword(unint64_t a1, int a2)
{
  while (1)
  {
    if (!a1) {
      _CFURLCopyPassword_cold_1();
    }
    if (CF_IS_OBJC(0x1DuLL, a1)) {
      break;
    }
    CFStringRef v4 = _retainedComponentString(a1, 4, 1, a2);
    if (v4) {
      return v4;
    }
    if (*(void *)(a1 + 32))
    {
      char v5 = *(unsigned char *)(a1 + 16);
      a1 = *(void *)(a1 + 32);
      if ((v5 & 0x1F) == 0) {
        continue;
      }
    }
    return 0;
  }
  uint64_t v7 = (const void *)[(id)a1 password];
  CFIndex v6 = v7;
  if (v7) {
    CFRetain(v7);
  }
  return (const __CFString *)v6;
}

void client_context_finalizer(uint64_t a1)
{
  unint64_t v1 = (os_unfair_lock_s *)(a1 + 48);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
  uint64_t v2 = a1;
  if (*(unsigned char *)(a1 + 57)) {
    client_context_finalizer_cold_1();
  }
  ipc_space_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = a1;
  }
  CFStringRef v4 = *(void **)(v2 + 32);
  if (v4)
  {
    xpc_release(v4);
    uint64_t v2 = a1;
  }
  char v5 = *(const void **)(v2 + 40);
  if (v5) {
    CFRelease(v5);
  }
  os_unfair_lock_unlock(v1);
}

void ___bundleInfo_block_invoke()
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle)) != 0)
  {
    CFDictionaryRef v2 = InfoDictionary;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleIdentifier");
    CFStringRef v4 = (const __CFString *)CFDictionaryGetValue(v2, @"CFBundleShortVersionString");
    if (Value) {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value);
    }
    else {
      CFStringRef Copy = &stru_1ECE10768;
    }
    _bundleInfo_info_0 = (uint64_t)Copy;
    if (v4) {
      CFStringRef v6 = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
    }
    else {
      CFStringRef v6 = &stru_1ECE10768;
    }
  }
  else
  {
    CFStringRef v6 = &stru_1ECE10768;
    _bundleInfo_info_0 = (uint64_t)&stru_1ECE10768;
  }
  _bundleInfo_info_1 = (uint64_t)v6;
  _bundleInfo_info_2 = CFStringGetDoubleValue(v6);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  int v6 = 0;
  CFStringRef v16 = str;
  uint64_t v19 = 0;
  CFIndex Length = CFStringGetLength(str);
  CharactersPtr = CFStringGetCharactersPtr(v16);
  uint64_t CStringPtrInternal = 0;
  int v17 = CharactersPtr;
  if (!CharactersPtr) {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)str, 0x600u, 0, 1);
  }
  double v7 = 0.0;
  *(_OWORD *)buffer = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v18 = CStringPtrInternal;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int v4 = __CFStringScanDouble(buffer, 0, &v6, &v7);
  double result = v7;
  if (!v4) {
    return 0.0;
  }
  return result;
}

void _CFPreferencesRegisterStandardUserDefaultsExists()
{
  if (_CFPreferencesRegisterStandardUserDefaultsExists_onceToken != -1) {
    dispatch_once(&_CFPreferencesRegisterStandardUserDefaultsExists_onceToken, &__block_literal_global_181);
  }
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizationAndTableURL(unint64_t *a1, void *a2, __CFString *a3, __CFString *a4, const void *a5, CFTypeRef *a6)
{
  v14[1] = *(const void **)off_1ECE0A5B0;
  v14[0] = a5;
  if (a5)
  {
    CFArrayRef v11 = CFArrayCreate(0, v14, 1, &kCFTypeArrayCallBacks);
    CFMutableStringRef v12 = _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, v11, 0, a6);
    if (v11) {
      CFRelease(v11);
    }
    return v12;
  }
  else
  {
    return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, 0, 0, a6);
  }
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
  }
  if (CFGetTypeID(mode) == 7)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFStringRef)mode);
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    long long v9 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, Copy, 1);
    if (v9) {
      CFRelease(v9);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
  else
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(mode))
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)mode);
      CFMutableStringRef v12 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      v25.CFIndex location = 0;
      v25.CFIndex length = Count;
      CFArrayGetValues((CFArrayRef)mode, v25, v12);
      CFStringRef Copy = (const __CFString *)CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, Count, &kCFTypeSetCallBacks);
      long long v13 = (pthread_mutex_t *)((char *)rl + 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (Count >= 1)
      {
        long long v14 = (const __CFString **)v12;
        do
        {
          long long v15 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, *v14, 1);
          if (v15) {
            CFRelease(v15);
          }
          ++v14;
          --Count;
        }
        while (Count);
      }
    }
    else
    {
      CFTypeID v16 = CFSetGetTypeID();
      if (v16 != CFGetTypeID(mode))
      {
        CFStringRef Copy = 0;
        goto LABEL_26;
      }
      uint64_t v17 = CFSetGetCount((CFSetRef)mode);
      CFMutableStringRef v12 = (const void **)malloc_type_malloc(8 * v17, 0xC0040B8AA526DuLL);
      CFSetGetValues((CFSetRef)mode, v12);
      CFStringRef Copy = (const __CFString *)CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v17, &kCFTypeSetCallBacks);
      long long v13 = (pthread_mutex_t *)((char *)rl + 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (v17 >= 1)
      {
        uint64_t v18 = (const __CFString **)v12;
        do
        {
          uint64_t v19 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, *v18, 1);
          if (v19) {
            CFRelease(v19);
          }
          ++v18;
          --v17;
        }
        while (v17);
      }
    }
    pthread_mutex_unlock(v13);
    free(v12);
  }
LABEL_26:
  CFArrayRef v20 = _Block_copy(block);
  uint64_t v21 = v20;
  if (Copy && v20)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    uint64_t v22 = malloc_type_malloc(0x18uLL, 0xE00400670D255uLL);
    void *v22 = 0;
    v22[1] = Copy;
    void v22[2] = v21;
    uint64_t v23 = (void *)*((void *)rl + 81);
    if (!v23) {
      uint64_t v23 = (void *)((char *)rl + 640);
    }
    *uint64_t v23 = v22;
    *((void *)rl + 81) = v22;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
  else
  {
    if (Copy) {
      CFRelease(Copy);
    }
    if (v21)
    {
      _Block_release(v21);
    }
  }
}

void sub_182C8DD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if (v7)
  {
    BOOL v16 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v16 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFIndex v8 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    CFSetRef v14 = (const __CFSet *)*((void *)rl + 77);
    if (v14)
    {
      Boolean v13 = CFSetContainsValue(v14, observer);
      goto LABEL_16;
    }
LABEL_13:
    Boolean v13 = 0;
    goto LABEL_16;
  }
  uint64_t v9 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v9) {
    goto LABEL_13;
  }
  long long v10 = (CFArrayRef *)v9;
  CFArrayRef v11 = (pthread_mutex_t *)(v9 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
  CFArrayRef v12 = v10[14];
  if (v12)
  {
    v17.CFIndex length = CFArrayGetCount(v10[14]);
    v17.CFIndex location = 0;
    Boolean v13 = CFArrayContainsValue(v12, v17, observer);
  }
  else
  {
    Boolean v13 = 0;
  }
  pthread_mutex_unlock(v11);
  CFRelease(v10);
LABEL_16:
  pthread_mutex_unlock(v8);
  return v13;
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  if (CFNotificationCenterGetDistributedCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetDistributedCenter_static_init, &__block_literal_global_13);
  }
  return (CFNotificationCenterRef)__hostCenter;
}

void CFRunLoopTimerSetTolerance(CFRunLoopTimerRef timer, CFTimeInterval tolerance)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (unint64_t)timer))
  {
    [(__CFRunLoopTimer *)timer setTolerance:tolerance];
  }
  else
  {
    double v4 = *((double *)timer + 14);
    if (v4 <= 0.0)
    {
      double v5 = 0.0;
      if (tolerance >= 0.0) {
        double v5 = tolerance;
      }
    }
    else
    {
      double v5 = v4 * 0.5;
      if (v5 > tolerance) {
        double v5 = tolerance;
      }
    }
    *((double *)timer + 15) = v5;
  }
}

uint64_t _CFStringInitializeTaggedStrings(uint64_t a1)
{
  uint64_t result = _CFExecutableLinkedOnOrAfter(8uLL);
  if (result)
  {
    if (*(void *)off_1ECE0A6E8)
    {
      uint64_t result = _objc_registerTaggedPointerClass();
      __CFTaggedStringClass Class = a1;
    }
  }
  return result;
}

uint64_t CFStorageGetValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v40[1] = *(void *)off_1ECE0A5B0;
  unint64_t v6 = (os_unfair_lock_s *)(a1 + 128);
  os_unfair_lock_lock_with_options();
  uint64_t v7 = *(void *)(a1 + 104);
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 120);
  os_unfair_lock_unlock(v6);
  if (v7 && !*(unsigned char *)(v7 + 12))
  {
    if (!*(void *)(v7 + 24))
    {
      CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v20 = *(void *)v7;
      uint64_t v21 = *(void *)off_1ECE0A708;
      if (*(uint64_t *)off_1ECE0A708 >= 0) {
        uint64_t v22 = *(void *)off_1ECE0A708;
      }
      else {
        uint64_t v22 = v21 + 1;
      }
      if (v20 <= v22 >> 1)
      {
        uint64_t v32 = v20 + 63;
        BOOL v31 = v20 < -63;
        uint64_t v33 = v20 + 126;
        if (!v31) {
          uint64_t v33 = v32;
        }
        int64_t v24 = v33 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        int v23 = (v20 + v21 - 1) & -(int)v21;
        if (*(void *)(a1 + 136) >= v23) {
          int64_t v24 = v23;
        }
        else {
          int64_t v24 = *(void *)(a1 + 136);
        }
      }
      if (v24 > *(void *)(v7 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
        if (v24 > *(void *)(v7 + 16))
        {
          *(void *)(v7 + 24) = __CFSafelyReallocateWithAllocatorTyped(v19, *(void *)(v7 + 24), v24, 1893177561, 0, 0);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *(void *)(v7 + 16) = v24;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
      }
    }
    uint64_t v34 = a2 - v8;
    if (a2 >= v8 && v9 + v8 > a2)
    {
      if (a3)
      {
        *a3 = v8;
        a3[1] = v9;
      }
      uint64_t v35 = *(void *)(v7 + 24);
      int v36 = *(_DWORD *)(a1 + 24);
      if (v36 == -1)
      {
        uint64_t v37 = *(void *)(a1 + 16) * v34;
        if (!v35) {
          goto LABEL_3;
        }
      }
      else
      {
        uint64_t v37 = v34 << v36;
        if (!v35) {
          goto LABEL_3;
        }
      }
      return v35 + v37;
    }
  }
LABEL_3:
  uint64_t v39 = 0;
  v40[0] = 0;
  uint64_t v38 = 0;
  int v10 = *(_DWORD *)(a1 + 24);
  if (v10 == -1) {
    uint64_t v11 = *(void *)(a1 + 16) * a2;
  }
  else {
    uint64_t v11 = a2 << v10;
  }
  uint64_t Byte = __CFStorageFindByte((char *)a1, a1 + 144, v11, 0, v40, &v38, 1);
  uint64_t v13 = v40[0];
  uint64_t v14 = v38;
  if (v40[0])
  {
    uint64_t v15 = *(void *)v40[0];
    int v16 = *(_DWORD *)(a1 + 24);
    if (v16 == -1)
    {
      uint64_t v25 = *(void *)(a1 + 16);
      uint64_t v17 = v38 / v25;
      uint64_t v18 = v15 / v25;
    }
    else
    {
      uint64_t v17 = v38 >> v16;
      uint64_t v18 = v15 >> v16;
    }
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
  }
  os_unfair_lock_lock_with_options();
  *(void *)(a1 + 104) = v13;
  *(void *)(a1 + 112) = v17;
  *(void *)(a1 + 12CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v18;
  os_unfair_lock_unlock(v6);
  int v26 = *(_DWORD *)(a1 + 24);
  if (v26 != -1)
  {
    uint64_t v27 = v14 >> v26;
    uint64_t v28 = v39 >> v26;
    if (!a3) {
      return Byte;
    }
    goto LABEL_23;
  }
  uint64_t v29 = *(void *)(a1 + 16);
  uint64_t v27 = v14 / v29;
  uint64_t v28 = v39 / v29;
  if (a3)
  {
LABEL_23:
    *a3 = v27;
    a3[1] = v28;
  }
  return Byte;
}

uint64_t __CFStorageFindByte(char *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, void *a6, int a7)
{
  uint64_t v9 = a2;
  int v10 = cf;
  if (!*(unsigned char *)(a2 + 13))
  {
    uint64_t v43 = (pthread_mutex_t *)(cf + 32);
    while (1)
    {
      uint64_t v12 = a3;
      uint64_t v14 = v9 + 16;
      uint64_t v13 = *(void **)(v9 + 16);
      BOOL v15 = a3 < *v13;
      a3 -= *v13;
      if (v15) {
        break;
      }
      uint64_t v13 = *(void **)(v9 + 24);
      if (a3 < *v13)
      {
        uint64_t v16 = 1;
LABEL_8:
        uint64_t v9 = (uint64_t)v13;
        if (a7) {
          goto LABEL_11;
        }
        goto LABEL_52;
      }
      uint64_t v9 = *(void *)(v9 + 32);
      uint64_t v16 = 2;
      a3 -= *v13;
      if (a7)
      {
LABEL_11:
        if (*(unsigned char *)(v9 + 12))
        {
          if (*(_DWORD *)(v9 + 8) == 1)
          {
            *(unsigned char *)(v9 + 12) = 0;
          }
          else
          {
            CFAllocatorRef v17 = CFGetAllocator(v10);
            Node = (int64_t *)__CFStorageCreateNode((uint64_t)v17, (uint64_t)v10, *(unsigned char *)(v9 + 13), *(void *)v9);
            CFAllocatorRef v19 = Node;
            if (*(unsigned char *)(v9 + 13))
            {
              uint64_t v20 = *(const void **)(v9 + 24);
              if (v20)
              {
                int64_t v21 = *Node;
                uint64_t v22 = *(void *)off_1ECE0A708;
                if (*(uint64_t *)off_1ECE0A708 >= 0) {
                  uint64_t v23 = *(void *)off_1ECE0A708;
                }
                else {
                  uint64_t v23 = v22 + 1;
                }
                if (v21 <= v23 >> 1)
                {
                  int64_t v30 = v21 + 63;
                  if (v21 < -63) {
                    int64_t v30 = v21 + 126;
                  }
                  int64_t v24 = v30 & 0xFFFFFFFFFFFFFFC0;
                }
                else
                {
                  int64_t v24 = (int)((v21 + v22 - 1) & -(int)v22);
                  if (*((void *)v10 + 17) < v24) {
                    int64_t v24 = *((void *)v10 + 17);
                  }
                }
                if (v24 > Node[2])
                {
                  BOOL v31 = v43;
                  int64_t v42 = v24;
                  pthread_mutex_lock(v43);
                  if (v42 > v19[2])
                  {
                    v19[3] = __CFSafelyReallocateWithAllocatorTyped(v17, v19[3], v42, 1893177561, 0, 0);
                    if (__CFOASafe) {
                      __CFSetLastAllocationEventName();
                    }
                    BOOL v31 = v43;
                    CFIndex v19[2] = v42;
                  }
                  pthread_mutex_unlock(v31);
                  uint64_t v20 = *(const void **)(v9 + 24);
                  int64_t v21 = *v19;
                }
                memmove((void *)v19[3], v20, v21);
                int v10 = cf;
              }
            }
            else
            {
              int64_t v25 = *(void *)(v9 + 16);
              if (*(_DWORD *)(v25 + 8)) {
                atomic_fetch_add_explicit((atomic_uint *volatile)(v25 + 8), 1u, memory_order_relaxed);
              }
              Node[2] = v25;
              int64_t v26 = *(void *)(v9 + 24);
              if (v26)
              {
                if (*(_DWORD *)(v26 + 8)) {
                  atomic_fetch_add_explicit((atomic_uint *volatile)(v26 + 8), 1u, memory_order_relaxed);
                }
                Node[3] = v26;
              }
              int64_t v27 = *(void *)(v9 + 32);
              if (v27)
              {
                if (*(_DWORD *)(v27 + 8)) {
                  atomic_fetch_add_explicit((atomic_uint *volatile)(v27 + 8), 1u, memory_order_relaxed);
                }
                Node[4] = v27;
              }
              if (*(unsigned char *)(v9 + 12))
              {
                *(unsigned char *)(Node[2] + 12) = 1;
                int64_t v28 = Node[3];
                if (v28) {
                  *(unsigned char *)(v28 + 12) = 1;
                }
                int64_t v29 = Node[4];
                if (v29) {
                  *(unsigned char *)(v29 + 12) = 1;
                }
              }
            }
            *(void *)(v14 + 8 * v16) = v19;
            if (*(_DWORD *)(v9 + 8)
              && atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
            {
              __CFStorageDeallocateNode(v10, v9);
            }
            uint64_t v9 = (uint64_t)v19;
          }
        }
      }
LABEL_52:
      a4 = a4 + v12 - a3;
      if (*(unsigned char *)(v9 + 13)) {
        goto LABEL_53;
      }
    }
    uint64_t v16 = 0;
    a3 = v12;
    goto LABEL_8;
  }
LABEL_53:
  uint64_t v32 = *(void *)v9;
  *a6 = a4;
  a6[1] = v32;
  *a5 = v9;
  CFAllocatorRef v33 = CFGetAllocator(v10);
  uint64_t v34 = *(void *)v9;
  uint64_t v35 = *(void *)off_1ECE0A708;
  if (*(uint64_t *)off_1ECE0A708 >= 0) {
    uint64_t v36 = *(void *)off_1ECE0A708;
  }
  else {
    uint64_t v36 = v35 + 1;
  }
  if (v34 <= v36 >> 1)
  {
    uint64_t v39 = v34 + 63;
    BOOL v15 = v34 < -63;
    uint64_t v40 = v34 + 126;
    if (!v15) {
      uint64_t v40 = v39;
    }
    int64_t v38 = v40 & 0xFFFFFFFFFFFFFFC0;
  }
  else
  {
    int v37 = (v34 + v35 - 1) & -(int)v35;
    if (*((void *)v10 + 17) >= v37) {
      int64_t v38 = v37;
    }
    else {
      int64_t v38 = *((void *)v10 + 17);
    }
  }
  if (v38 > *(void *)(v9 + 16))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 32));
    if (v38 > *(void *)(v9 + 16))
    {
      *(void *)(v9 + 24) = __CFSafelyReallocateWithAllocatorTyped(v33, *(void *)(v9 + 24), v38, 1893177561, 0, 0);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      *(void *)(v9 + 16) = v38;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 32));
  }
  return *(void *)(v9 + 24) + a3;
}

uint64_t _CFPropertyListCreateFromXMLString(const __CFAllocator *a1, const __CFString *a2, int a3, CFStringRef *a4, char a5, void *a6)
{
  err[1] = *(CFErrorRef *)off_1ECE0A5B0;
  if (a4) {
    *a4 = 0;
  }
  err[0] = 0;
  uint64_t v7 = _CFPropertyListCreateFromXMLStringError(a1, a2, a3, err, a5, a6);
  CFErrorRef v8 = err[0];
  if (a4 && err[0])
  {
    CFDictionaryRef v9 = CFErrorCopyUserInfo(err[0]);
    CFURLRef value = 0;
    int ValueIfPresent = CFDictionaryGetValueIfPresent(v9, @"kCFPropertyListOldStyleParsingError", (const void **)&value);
    CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(v9, @"NSDebugDescription");
    CFStringRef v12 = v11;
    if (ValueIfPresent)
    {
      CFDictionaryRef v13 = CFErrorCopyUserInfo((CFErrorRef)value);
      uint64_t v14 = CFDictionaryGetValue(v9, @"NSDebugDescription");
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"XML parser error:\n\t%@\nOld-style plist parser error:\n\t%@\n", v12, v14);
      CFRelease(v13);
    }
    else if (v11)
    {
      CFRetain(v11);
    }
    CFRelease(v9);
    *a4 = v12;
    CFErrorRef v8 = err[0];
  }
  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  if (!CF_IS_OBJC(0x1BuLL, (unint64_t)err)) {
    return *((void *)err + 2);
  }

  return [(__CFError *)err code];
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  if (!CF_IS_OBJC(0x1BuLL, (unint64_t)err)) {
    return (CFErrorDomain)*((void *)err + 3);
  }

  return (CFErrorDomain)[(__CFError *)err domain];
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)err))
  {
    CFDictionaryRef v2 = (const void *)[(__CFError *)err userInfo];
    if (v2)
    {
LABEL_3:
      return (CFDictionaryRef)CFRetain(v2);
    }
  }
  else
  {
    CFDictionaryRef v2 = (const void *)*((void *)err + 4);
    if (v2) {
      goto LABEL_3;
    }
  }
  CFAllocatorRef v4 = CFGetAllocator(err);

  return _CFErrorCreateEmptyDictionary(v4);
}

uint64_t _CFPropertyListCreateFromXMLStringError(const __CFAllocator *a1, const __CFString *a2, int a3, void *a4, char a5, void *a6)
{
  v14[1] = *(void *)off_1ECE0A5B0;
  UTF8DataFromCFStringRef String = _createUTF8DataFromString(a1, a2);
  v14[0] = 0;
  _CFPropertyListCreateFromUTF8Data(a1, UTF8DataFromString, 0, a2, 0, a3, a4, a5, a6, 0, v14, 1, 1);
  if (UTF8DataFromString) {
    CFRelease(UTF8DataFromString);
  }
  return v14[0];
}

CFDataRef _createUTF8DataFromString(const __CFAllocator *a1, CFStringRef theString)
{
  maxBufLen[1] = *(void *)off_1ECE0A5B0;
  maxBufLen[0] = 0;
  v7.CFIndex length = CFStringGetLength(theString);
  v7.CFIndex location = 0;
  CFStringGetBytes(theString, v7, 0x8000100u, 0, 0, 0, 0, maxBufLen);
  uint64_t Typed = (UInt8 *)CFAllocatorAllocateTyped(a1, maxBufLen[0], 143755134, 0);
  v8.CFIndex length = CFStringGetLength(theString);
  v8.CFIndex location = 0;
  CFStringGetBytes(theString, v8, 0x8000100u, 0, 0, Typed, maxBufLen[0], 0);
  return CFDataCreateWithBytesNoCopy(a1, Typed, maxBufLen[0], a1);
}

void __magic_cookie_block_invoke()
{
  while (!magic_cookie_oValue)
    arc4random_buf(&magic_cookie_oValue, 4uLL);
}

void sub_182C8F410(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void __CFXNotificationPostToken(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  v11[1] = 0;
  memset(v13, 0, sizeof(v13));
  v11[0] = 0x100000000;
  CFStringRef v12 = (void **)v13;
  if (CFXNotificationRegistrarFindToken(a1[2], a2, (uint64_t)v11))
  {
    if (!a3) {
      a3 = *v12;
    }
    CFDictionaryRef v9 = [[__CFNotification alloc] initWithName:a3 object:a4 userInfo:a5 foundation:1];
    int v10 = _CFXRegistrationPost(a1, (uint64_t)v12, 1, (uint64_t)v9, v12[2]);
  }
  _CFXNotificationRegistrationBufferDestroy((unsigned int *)v11);
}

uint64_t CFXNotificationRegistrarFindToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v38 = *(void *)off_1ECE0A5B0;
  unsigned int v6 = *(unsigned __int8 *)(a1 + 24);
  int v7 = (v6 >> 1) & 1;
  *(unsigned char *)(a3 + 8) = (v6 & 2) != 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  CFRange v8 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) <= a2) {
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v10 = a2;
  uint64_t v11 = v9 + 56 * a2;
  int v13 = *(_DWORD *)(v11 + 40);
  CFStringRef v12 = (unsigned int *)(v11 + 40);
  if (v13 != HIDWORD(a2)
    || (uint64_t v14 = v9 + 56 * a2,
        int v17 = *(_DWORD *)(v14 + 44),
        uint64_t v16 = (int *)(v14 + 44),
        LOWORD(v15) = v17,
        (v17 & 0x8000) != 0))
  {
LABEL_6:
    uint64_t v19 = 0;
LABEL_7:
    long long v36 = 0u;
    long long v37 = 0u;
    long long v35 = 0u;
    goto LABEL_8;
  }
  uint64_t v18 = (id *)(v9 + 56 * a2 + 8);
  if ((v15 & 0x400) == 0)
  {
    *(void *)&long long v32 = *v18;
LABEL_14:
    uint64_t v25 = *(unsigned int *)(v9 + 56 * a2 + 48);
    if ((v15 & 0x800) != 0)
    {
      int64_t v29 = @"kCFNotificationAnyObject";
      if (v7) {
        int64_t v29 = (__CFString *)CFRetain(@"kCFNotificationAnyObject");
      }
      *((void *)&v31 + 1) = v29;
      *(void *)&long long v31 = CFCachedStringCopyString((CFTypeRef *)(*(void *)(a1 + 96) + 40 * v25 + 8));
    }
    else
    {
      if (v25 == -1)
      {
        CFStringRef Copy = @"kCFNotificationAnyObject";
        if (v7) {
          CFStringRef Copy = (__CFString *)CFRetain(@"kCFNotificationAnyObject");
        }
      }
      else
      {
        uint64_t v26 = *(void *)(a1 + 120);
        unsigned int v27 = *(_DWORD *)(v26 + 32 * v25 + 24);
        if (v27 == -1) {
          CFTypeRef v28 = CFRetain(@"kCFNotificationAnyName");
        }
        else {
          CFTypeRef v28 = CFCachedStringCopyString((CFTypeRef *)(*(void *)(a1 + 96) + 40 * v27 + 8));
        }
        *(void *)&long long v31 = v28;
        if (v7) {
          CFStringRef Copy = (__CFString *)CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(v26 + 32 * v25 + 8));
        }
        else {
          CFStringRef Copy = *(__CFString **)(v26 + 32 * v25 + 8);
        }
      }
      *((void *)&v31 + 1) = Copy;
    }
    CFXNotificationHandlerCopy(&v33, *(void **)(v9 + 56 * v10 + 16), *(CFTypeRef *)(v9 + 56 * v10 + 24), *v16);
    *((void *)&v32 + 1) = *v16;
    *(void *)&long long v34 = v10 | ((unint64_t)*v12 << 32);
    uint64_t v19 = 1;
    goto LABEL_7;
  }
  id WeakRetained = objc_loadWeakRetained(v18);
  if (WeakRetained)
  {
    *(void *)&long long v32 = WeakRetained;
    int v15 = *v16;
    goto LABEL_14;
  }
  long long v36 = 0u;
  long long v37 = 0u;
  long long v35 = 0u;
  _CFXNotificationRegistrarInvalidateObserver(a1, a2, -1, -1, (unsigned int *)&v35);
  uint64_t v19 = 0;
LABEL_8:
  os_unfair_lock_unlock(v8);
  _CFXNotificationDisposalListRelease((unsigned int *)&v35);
  if (v19)
  {
    uint64_t v20 = *(_OWORD **)(a3 + 16);
    *uint64_t v20 = v31;
    v20[1] = v32;
    long long v21 = v34;
    v20[2] = v33;
    v20[3] = v21;
    int v22 = 1;
  }
  else
  {
    int v22 = 0;
  }
  *(_DWORD *)a3 = v22;
  return v19;
}

void _CFPrefsSynchronizeForProcessTermination()
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v0 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v1 = (id)v0;
  -[_CFXPreferences synchronizeEverything](v0);
}

void sub_182C8FDE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFNotificationCenterRegisterDependentNotificationList(__CFString ****a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&_dependentNotificationLock);
  uint64_t v2 = 0;
  while ((&_unprocessedDependentNotificationLists)[v2])
  {
    if (++v2 == 8) {
      _CFNotificationCenterRegisterDependentNotificationList_cold_1();
    }
  }
  (&_unprocessedDependentNotificationLists)[v2] = a1;

  os_unfair_lock_unlock((os_unfair_lock_t)&_dependentNotificationLock);
}

Boolean CFURLStartAccessingSecurityScopedResource(CFURLRef url)
{
  return MEMORY[0x1853105C0](url) != 0;
}

void __CFTSDFinalize(unint64_t a1)
{
  if (pthread_main_np() == 1) {
    atomic_store(1u, __CFMainThreadHasExited);
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(void *)(StatusReg + 44CFNotificationCenterRemoveObserver(center, observer, 0, 0) = a1;
  if ((a1 | 0x1000) != 0x1000)
  {
    ++*(_DWORD *)a1;
    ipc_space_t v3 = (void *)_CFAutoreleasePoolPush();
    for (uint64_t i = 0; i != 560; i += 8)
    {
      double v5 = (_DWORD *)(a1 + i);
      if (*(void *)(a1 + i + 8))
      {
        unsigned int v6 = (void (*)(void))*((void *)v5 + 71);
        if (v6)
        {
          *((void *)v5 + 1) = 0;
          v6();
        }
      }
    }
    _CFAutoreleasePoolPop(v3);
    if (*(_DWORD *)a1 == 3)
    {
      free((void *)a1);
      *(void *)(StatusReg + 44CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 4096;
    }
  }
}

void __CFFinalizeRunLoop(unint64_t a1)
{
  if (a1 > 1)
  {
    _CFSetTSD(0xBu, a1 - 1, (uint64_t)__CFFinalizeRunLoop);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
    CFDictionaryRef v1 = (const __CFDictionary *)__CFRunLoops;
    if (__CFRunLoops)
    {
      pthread_t v2 = pthread_self();
      CFStringRef Value = CFDictionaryGetValue(v1, v2);
      if (Value)
      {
        uint64_t v4 = (uint64_t)Value;
        CFRetain(Value);
        double v5 = (__CFDictionary *)__CFRunLoops;
        pthread_t v6 = pthread_self();
        CFDictionaryRemoveValue(v5, v6);
        os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
        int v7 = (_opaque_pthread_t *)pthread_main_thread_np();
        if (_CFRunLoopGet0b(v7) != (const void *)v4)
        {
          CFRange v8 = *(const void **)(v4 + 672);
          if (v8)
          {
            CFRelease(v8);
            *(void *)(v4 + 672) = 0;
          }
          CFArrayRef v9 = CFRunLoopCopyAllModes((CFRunLoopRef)v4);
          CFIndex Count = CFArrayGetCount(v9);
          if (Count)
          {
            CFIndex v11 = Count - 1;
            do
            {
              CFStringRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v9, v11);
              __CFRunLoopRemoveAllSources(v4, ValueAtIndex);
              --v11;
            }
            while (v11 != -1);
          }
          __CFRunLoopRemoveAllSources(v4, @"kCFRunLoopCommonModes");
          CFRelease(v9);
        }
        atomic_store(1u, (unsigned __int8 *)(v4 + 680));
        CFRelease((CFTypeRef)v4);
        return;
      }
      int v13 = (__CFDictionary *)__CFRunLoops;
      pthread_t v14 = pthread_self();
      CFDictionaryRemoveValue(v13, v14);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }
}

uint64_t __CFRunLoopRemoveAllSources(uint64_t a1, __CFString *a2)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (a2 == @"kCFRunLoopCommonModes")
  {
    if (*(void *)(a1 + 616))
    {
      CFSetRef v12 = *(const __CFSet **)(a1 + 608);
      if (v12)
      {
        CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
        if (Copy)
        {
          CFSetRef v14 = Copy;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveSourcesFromCommonMode, (void *)a1);
          CFIndex v11 = v14;
LABEL_12:
          CFRelease(v11);
        }
      }
    }
  }
  else
  {
    uint64_t v4 = __CFRunLoopCopyMode(a1, a2, 0);
    if (v4)
    {
      double v5 = (const __CFSet **)v4;
      pthread_t v6 = (pthread_mutex_t *)(v4 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
      CFSetRef v7 = v5[12];
      if (v7)
      {
        CFSetRef v8 = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        uint64_t context = a1;
        int v17 = a2;
        CFSetApplyFunction(v8, (CFSetApplierFunction)__CFRunLoopRemoveSourceFromMode, &context);
        CFRelease(v8);
      }
      CFSetRef v9 = v5[13];
      if (v9)
      {
        CFSetRef v10 = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9);
        uint64_t context = a1;
        int v17 = a2;
        CFSetApplyFunction(v10, (CFSetApplierFunction)__CFRunLoopRemoveSourceFromMode, &context);
        CFRelease(v10);
      }
      pthread_mutex_unlock(v6);
      CFIndex v11 = v5;
      goto LABEL_12;
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

void *__CFRunLoopDeallocate(mach_port_context_t a1)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  pthread_t v2 = (unsigned __int8 *)(a1 + 680);
  if (!atomic_load((unsigned __int8 *)(a1 + 680))) {
    __CFRunLoopDeallocate_cold_1();
  }
  kdebug_trace();
  atomic_store(0, v2);
  double v5 = (_opaque_pthread_t *)pthread_main_thread_np();
  pthread_t v6 = _CFRunLoopGet0b(v5);
  if (v6 == (const void *)a1)
  {
    __break(1u);
    goto LABEL_22;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + 8));
  unint64_t v8 = v7;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v8, v7 | 4);
    BOOL v9 = v8 == v7;
    unint64_t v7 = v8;
  }
  while (!v9);
  CFSetRef v10 = *(const __CFSet **)(a1 + 632);
  if (v10)
  {
    CFSetApplyFunction(v10, (CFSetApplierFunction)__CFRunLoopCleanseSources, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateSources, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateObservers, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateTimers, (void *)a1);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  CFIndex v11 = *(CFTypeRef **)(a1 + 640);
  if (v11)
  {
    do
    {
      CFSetRef v12 = (CFTypeRef *)*v11;
      CFRelease(v11[1]);
      _Block_release(v11[2]);
      free(v11);
      CFIndex v11 = v12;
    }
    while (v12);
  }
  int v13 = *(const void **)(a1 + 616);
  if (v13) {
    CFRelease(v13);
  }
  CFSetRef v14 = *(const void **)(a1 + 608);
  if (v14) {
    CFRelease(v14);
  }
  int v15 = *(const void **)(a1 + 632);
  if (v15) {
    CFRelease(v15);
  }
  mach_port_name_t v1 = *(_DWORD *)(a1 + 80);
  LODWORD(v6) = mach_port_destruct(*(_DWORD *)off_1ECE0A6C8, v1, -1, a1);
  if (v6)
  {
LABEL_22:
    snprintf(__str, 0x100uLL, "*** Unable to destruct port. (0x%x, %d, %p) ***", v1, v6, (const void *)a1);
    qword_1EC093AA8 = (uint64_t)__str;
    __break(1u);
  }
  *(_DWORD *)(a1 + 8CFNotificationCenterRemoveObserver(center, observer, 0, 0) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));

  return memset((void *)(a1 + 16), 140, 0x2A0uLL);
}

const void *_CFRunLoopGet0b(_opaque_pthread_t *a1)
{
  mach_port_name_t v1 = a1;
  if (pthread_equal(a1, 0)) {
    mach_port_name_t v1 = (const void *)pthread_main_thread_np();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  if (__CFRunLoops) {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)__CFRunLoops, v1);
  }
  else {
    CFStringRef Value = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  return Value;
}

void __collatorFinalize(uint64_t a1)
{
  pthread_t v2 = (const void *)_CFGetTSD(8u);
  _CFSetTSD(9u, 0, 0);
  _CFSetTSD(8u, 0, 0);
  _CFSetTSD(0x11u, 0, 0);
  os_unfair_lock_lock_with_options();
  uint64_t v3 = __CFDefaultCollatorsCount;
  if ((const void *)__CFDefaultCollatorLocale == v2 && __CFDefaultCollatorsCount <= 7)
  {
    ++__CFDefaultCollatorsCount;
    __CFDefaultCollators[v3] = a1;
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    if (!v2) {
      return;
    }
    goto LABEL_8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
  if (a1) {
    ucol_close();
  }
  if (v2)
  {
LABEL_8:
    CFRelease(v2);
  }
}

Boolean CFReadStreamSetClient(CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    if (objc_opt_respondsToSelector())
    {
      return [(__CFReadStream *)stream _setCFClientFlags:streamEvents callback:clientCB context:clientContext];
    }
    else
    {
      if (clientCB)
      {
        BOOL v9 = [[_CFStreamDelegate alloc] initWithStreamEvents:streamEvents callback:clientCB context:clientContext];
        [(__CFReadStream *)stream setDelegate:v9];
        CFSetRef v10 = (const void *)objc_opt_class();
        objc_setAssociatedObject(stream, v10, v9, (void *)0x301);
      }
      else
      {
        [(__CFReadStream *)stream setDelegate:0];
      }
      return 1;
    }
  }
  else
  {
    return _CFStreamSetClient(stream, streamEvents & 0xFFFFFFFFFFFFFFFBLL, (uint64_t)clientCB, (uint64_t)clientContext);
  }
}

xpc_object_t _CFXPCCreateXPCMessageWithCFObject(uint64_t a1)
{
  address[1] = *(void *)off_1ECE0A5B0;
  unint64_t v2 = __CFBinaryPlistWrite15(a1, 0);
  if (!v2) {
    return 0;
  }
  if (v2 <= 0x4000)
  {
    address[0] = 0;
    alCFIndex loc = dispatch_data_create_alloc();
    __CFBinaryPlistWrite15(a1, 0);
LABEL_7:
    address[0] = (mach_vm_address_t)xpc_data_create_with_dispatch_data(alloc);
    dispatch_release(alloc);
    keys = "ECF19A18-7AA6-4141-B4DC-A2E5123B2B5C";
    xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, (xpc_object_t *)address, 1uLL);
    xpc_release((xpc_object_t)address[0]);
    return v4;
  }
  address[0] = 0;
  size_t v3 = (v2 + *(void *)off_1ECE0A708 - 1) & -*(void *)off_1ECE0A708;
  if (!mach_vm_allocate(*(_DWORD *)off_1ECE0A6C8, address, v3, 687865857))
  {
    __CFBinaryPlistWrite15(a1, 0);
    alCFIndex loc = dispatch_data_create((const void *)address[0], v3, 0, *(dispatch_block_t *)off_1ECE0A5D0);
    goto LABEL_7;
  }
  return 0;
}

uint64_t __CFBinaryPlistWrite15(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  xpc_object_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  CFSetRef v10 = v9;
  CFIndex v11 = (__CFString *)v2;
  *(void *)&__len_4[8148] = *(void *)off_1ECE0A5B0;
  bzero(&__len, 0x1FD8uLL);
  v15[0] = v10;
  v15[1] = v8;
  CFTypeRef cf = 0;
  uint64_t v17 = 0;
  size_t v15[2] = v6;
  int __len = 0;
  bufferWrite_0((uint64_t)v15, "bplist15", 8);
  bufferWrite_0((uint64_t)v15, byte_182EE0C60, 9);
  bufferWrite_0((uint64_t)v15, byte_182EE0C6A, 5);
  BOOL v12 = __writeObject15(v15, v11);
  writeBytes_0((uint64_t)v15, __len_4, __len);
  int __len = 0;
  if ((unint64_t)v10 | v8)
  {
    newBytes[0] = 19;
    *(void *)&newBytes[1] = v17 ^ 0x8000000000000000;
    if (v8)
    {
      *(void *)(v8 + 8) = *(void *)newBytes;
      *(unsigned char *)(v8 + 16) = newBytes[8];
    }
    if (v10)
    {
      v20.CFIndex location = 8;
      v20.CFIndex length = 9;
      CFDataReplaceBytes(v10, v20, newBytes, 9);
    }
  }
  if (v12) {
    return v17;
  }
  if (v4 && cf)
  {
    uint64_t result = 0;
    *xpc_object_t v4 = cf;
  }
  else
  {
    if (cf) {
      CFRelease(cf);
    }
    return 0;
  }
  return result;
}

void CFStringPad(CFMutableStringRef theString, CFStringRef padString, CFIndex length, CFIndex indexIntoPad)
{
  uint64_t v49 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString _cfPad:padString length:length padIndex:indexIntoPad];
    return;
  }
  p_info = &theString->info;
  char v9 = atomic_load((unint64_t *)&theString->info);
  if ((v9 & 1) == 0)
  {
    CFSetRef v10 = _CFOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      CFStringPad_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
    return;
  }
  char v18 = atomic_load((unint64_t *)p_info);
  uint64_t v19 = v18 & 5;
  char v20 = atomic_load((unint64_t *)p_info);
  uint64_t v21 = v20 & 0x60;
  if (v19 == 4)
  {
    p_uint64_t data = &theString->data;
    if (v21)
    {
      uint64_t v23 = *p_data;
    }
    else
    {
      uint64_t v25 = atomic_load((unint64_t *)&theString->info);
      uint64_t v23 = (char *)&p_data[(v25 & 5) != 4];
    }
    uint64_t data = *v23;
  }
  else if ((v20 & 0x60) != 0)
  {
    uint64_t data = theString->length;
  }
  else
  {
    uint64_t data = (uint64_t)theString->data;
  }
  if (data > length)
  {
    CFIndex v47 = length;
    uint64_t v48 = data - length;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v47, 1, 0, 0);
    return;
  }
  if (data < length)
  {
    uint64_t v26 = length - data;
    if (CF_IS_OBJC(7uLL, (unint64_t)padString))
    {
      CFIndex v27 = CFStringGetLength(padString);
    }
    else
    {
      char v28 = atomic_load((unint64_t *)&padString->info);
      uint64_t v29 = v28 & 5;
      char v30 = atomic_load((unint64_t *)&padString->info);
      uint64_t v31 = v30 & 0x60;
      if (v29 == 4)
      {
        long long v32 = &padString->data;
        if (v31)
        {
          long long v33 = *v32;
        }
        else
        {
          uint64_t v34 = atomic_load((unint64_t *)&padString->info);
          long long v33 = (char *)&v32[(v34 & 5) != 4];
        }
        CFIndex v27 = *v33;
      }
      else if ((v30 & 0x60) != 0)
      {
        CFIndex v27 = padString->length;
      }
      else
      {
        CFIndex v27 = (CFIndex)padString->data;
      }
      char v35 = atomic_load((unint64_t *)&theString->info);
      if ((v35 & 0x10) == 0)
      {
        unint64_t v36 = atomic_load((unint64_t *)&padString->info);
        uint64_t v37 = (v36 >> 4) & 1;
        goto LABEL_32;
      }
    }
    LODWORD(v37) = 1;
LABEL_32:
    CFIndex v47 = data;
    uint64_t v48 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v47, 1, v26, v37);
    char v39 = atomic_load((unint64_t *)&theString->info);
    uint64_t v40 = &theString->data;
    if ((v39 & 0x60) != 0)
    {
      int v41 = *v40;
    }
    else
    {
      char v42 = atomic_load((unint64_t *)&theString->info);
      int v41 = (char *)&v40[(v42 & 5) != 4];
    }
    unint64_t v43 = atomic_load((unint64_t *)&theString->info);
    if (v26 >= 1)
    {
      if (v26 >= v27 - indexIntoPad) {
        CFIndex v44 = v27 - indexIntoPad;
      }
      else {
        CFIndex v44 = v26;
      }
      uint64_t v45 = (UniChar *)&v41[(data << v37) + ((v43 >> 2) & 1)];
      do
      {
        if (v37)
        {
          v51.CFIndex location = indexIntoPad;
          v51.CFIndex length = v44;
          CFStringGetCharacters(padString, v51, v45);
        }
        else
        {
          CFStringEncoding v46 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding(Bytes);
            CFStringEncoding v46 = __CFDefaultEightBitStringEncoding;
          }
          v52.CFIndex location = indexIntoPad;
          v52.CFIndex length = v44;
          CFIndex Bytes = CFStringGetBytes(padString, v52, v46, 0, 0, (UInt8 *)v45, v26, 0);
        }
        indexIntoPad = 0;
        uint64_t v45 = (UniChar *)((char *)v45 + (v44 << v37));
        v26 -= v44;
        if (v26 >= v44) {
          CFIndex v44 = v27;
        }
        else {
          CFIndex v44 = v26;
        }
      }
      while (v26 > 0);
    }
  }
}

uint64_t _CFFileSecurityCreateFromFilesec(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  size_t v3 = [NSFileSecurity alloc];

  return (uint64_t)[(NSFileSecurity *)v3 initWithFileSec:a2];
}

CFFileSecurityRef CFFileSecurityCreateCopy(CFAllocatorRef allocator, CFFileSecurityRef fileSec)
{
  CFFileSecurityRef result = filesec_dup((filesec_t)[(__CFFileSecurity *)fileSec _filesec]);
  if (result)
  {
    size_t v3 = result;
    CFFileSecurityRef result = [[NSFileSecurity alloc] initWithFileSec:result];
    if (!result)
    {
      filesec_free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t _CFXNotificationGetTaskCenter()
{
  if (CFNotificationCenterGetLocalCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetLocalCenter_static_init, &__block_literal_global_7);
  }
  return __taskCenter;
}

CFBundleRef _CFBundleGetMainBundleIfLooksLikeBundle()
{
  CFBundleRef result = CFBundleGetMainBundle();
  if (result)
  {
    if (*((unsigned __int8 *)result + 53) - 3 < 2) {
      return 0;
    }
  }
  return result;
}

uint64_t __CFArrayCreateCopy0(__objc2_class **a1, unint64_t *a2)
{
  if (CF_IS_OBJC(0x13uLL, (unint64_t)a2)) {
    uint64_t v4 = [a2 count];
  }
  else {
    uint64_t v4 = a2[2];
  }
  if (CF_IS_OBJC(0x13uLL, (unint64_t)a2))
  {
LABEL_5:
    uint64_t v5 = &kCFTypeArrayCallBacks;
    goto LABEL_6;
  }
  unsigned int v11 = atomic_load(a2 + 1);
  int v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 != 1)
    {
      char v13 = atomic_load(a2 + 1);
      int v14 = v13 & 3;
      if (v14) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = (const CFArrayCallBacks *)(a2 + 6);
      }
      if (v14 == 2) {
        uint64_t v5 = (const CFArrayCallBacks *)(a2 + 6);
      }
      else {
        uint64_t v5 = v15;
      }
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v5 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
LABEL_6:
  uint64_t Init = __CFArrayCreateInit(a1, 0, v4, v5);
  uint64_t v7 = Init;
  unsigned int v8 = atomic_load((unint64_t *)(Init + 8));
  int v9 = (v8 >> 2) & 3;
  if (v9)
  {
    if (v9 == 1)
    {
      CFSetRef v10 = &kCFTypeArrayCallBacks;
    }
    else
    {
      char v16 = atomic_load((unint64_t *)(Init + 8));
      int v17 = v16 & 3;
      if (v17 != 2 && v17) {
        CFSetRef v10 = 0;
      }
      else {
        CFSetRef v10 = (const CFArrayCallBacks *)(Init + 48);
      }
    }
  }
  else
  {
    CFSetRef v10 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  char v18 = atomic_load((unint64_t *)(Init + 8));
  int v19 = v18 & 3;
  if (v19 == 2)
  {
    uint64_t v23 = *(void *)(Init + 40) + 8 * **(void **)(Init + 40) + 16;
  }
  else if (v19)
  {
    uint64_t v23 = 0;
  }
  else
  {
    char v20 = atomic_load((unint64_t *)(Init + 8));
    BOOL v21 = (~v20 & 0xC) == 0;
    uint64_t v22 = 48;
    if (v21) {
      uint64_t v22 = 88;
    }
    uint64_t v23 = Init + v22;
  }
  if (v4 >= 1)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t v25 = [a2 objectAtIndex:i];
      CFAllocatorRetainCallBack retain = (uint64_t (*)(__objc2_class **, uint64_t))v10->retain;
      if (retain) {
        uint64_t v25 = retain(a1, v25);
      }
      *(void *)(v23 + 8 * i) = v25;
    }
  }
  *(void *)(v7 + 16) = v4;
  return v7;
}

os_log_t __makeLogHandles_block_invoke()
{
  clientHandle = (uint64_t)os_log_create("com.apple.defaults", "User Defaults");
  os_log_t result = os_log_create("com.apple.defaults", "cfprefsd");
  daemonHandle = (uint64_t)result;
  return result;
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    return (CFMutableAttributedStringRef)[(__CFAttributedString *)aStr mutableCopy];
  }
  else
  {
    CFIndex Length = CFStringGetLength(*((CFStringRef *)aStr + 2));
    return __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)aStr, 0, Length);
  }
}

uint64_t _CFURLFileCacheClearPropertyValueForKey()
{
  return MEMORY[0x1F4114F98]();
}

void CFXNotificationRegistrarAddRemoteToken(uint64_t a1, const void *a2, __CFString *cf, __CFString *cf1, __CFString *a5, int a6, void *a7, const void *a8)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  unsigned int v11 = *(unsigned __int8 *)(a1 + 24);
  if (cf)
  {
    int v12 = cf;
    if (@"kCFNotificationAnyName" != cf && CFEqual(cf, @"kCFNotificationAnyName")) {
      int v12 = @"kCFNotificationAnyName";
    }
  }
  else
  {
    int v12 = @"kCFNotificationAnyName";
  }
  int v13 = (v11 >> 1) & 1;
  if (cf1)
  {
    if (v13 && @"kCFNotificationAnyObject" != cf1 && CFEqual(cf1, @"kCFNotificationAnyObject")) {
      cf1 = @"kCFNotificationAnyObject";
    }
  }
  else
  {
    cf1 = @"kCFNotificationAnyObject";
  }
  int v14 = @"kCFNotificationAnyObserver";
  if (a5) {
    int v14 = a5;
  }
  *(void *)long long v32 = v14;
  CFHashCode v15 = CFHash(v12);
  if (v13) {
    CFHashCode v16 = CFHash(cf1);
  }
  else {
    CFHashCode v16 = ((unint64_t)cf1 >> 5) & 0x7F;
  }
  unint64_t v17 = (unint64_t)atomic_fetch_add((atomic_uint *volatile)(a1 + 168), 1u) << 32;
  unsigned int v37 = -1;
  unsigned int v38 = -1;
  unsigned int v36 = -1;
  memset(v39, 0, sizeof(v39));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v12 == @"kCFNotificationAnyName")
  {
    if (cf1 == @"kCFNotificationAnyObject")
    {
      int v19 = (unsigned int *)(a1 + 80);
      uint64_t v29 = v17;
      unint64_t v30 = -1;
      uint64_t v21 = a1;
      uint64_t v22 = a7;
      uint64_t v23 = a8;
      int v20 = -1;
      goto LABEL_25;
    }
    int v19 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, a1 + 48, cf1, v16, &v37, -1, v13) + 16);
    int v20 = v37;
    LODWORD(v3CFNotificationCenterRemoveObserver(center, observer, 0, 0) = -1;
    HIDWORD(v3CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v37;
LABEL_24:
    uint64_t v29 = v17;
    uint64_t v21 = a1;
    uint64_t v22 = a7;
    uint64_t v23 = a8;
LABEL_25:
    int64_t v24 = *(void **)v32;
    int v25 = a6;
    goto LABEL_27;
  }
  if (cf1 != @"kCFNotificationAnyObject")
  {
    uint64_t v18 = _CFXNotificationRegistrarAddName(a1, a1 + 32, v12, v15, &v38, 0);
    int v19 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, v18 + 24, cf1, v16, &v37, v38, v13) + 16);
    int v20 = v37;
    unint64_t v30 = __PAIR64__(v37, v38);
    goto LABEL_24;
  }
  int v19 = (unsigned int *)(_CFXNotificationRegistrarAddName(a1, a1 + 64, v12, v15, &v38, 1) + 24);
  uint64_t v22 = a7;
  int v25 = a6 | 0x800;
  int v20 = v38;
  unint64_t v30 = __PAIR64__(v37, v38);
  uint64_t v29 = v17;
  uint64_t v21 = a1;
  uint64_t v23 = a8;
  int64_t v24 = *(void **)v32;
LABEL_27:
  uint64_t v26 = _CFXNotificationRegistrarAddObserver(v21, v19, v22, v23, v20, v24, &v36, v25, v29, v30, SHIDWORD(v30), (unsigned int *)v39);
  if (v26)
  {
    CFIndex v27 = (const void *)(v17 | v36);
    CFDictionaryRef Mutable = *(__CFDictionary **)(a1 + 88);
    if (!Mutable)
    {
      CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0);
      *(void *)(a1 + 88) = Mutable;
    }
    CFDictionarySetValue(Mutable, a2, v27);
    *((void *)v26 + 4) = a2;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v39);
}

uint64_t ___plistSizeIsAppropriateToRead_block_invoke()
{
  uint64_t v0 = (const void *)_CFProcessNameString();
  uint64_t result = CFEqual(v0, @"localizationswitcherd");
  if (result) {
    _plistSizeIsAppropriateToRead_isSizeLimitedProcess = 1;
  }
  return result;
}

uint64_t _CFProcessNameString()
{
  if (!_CFProcessNameString___CFProcessNameString)
  {
    uint64_t v0 = __CFprogname;
    if (!__CFprogname)
    {
      _CFProcessPath();
      uint64_t v0 = __CFprogname;
    }
    if (v0) {
      mach_port_name_t v1 = (const char *)v0;
    }
    else {
      mach_port_name_t v1 = "";
    }
    CFStringRef v2 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x8000100u);
    uint64_t v3 = 0;
    atomic_compare_exchange_strong(&_CFProcessNameString___CFProcessNameString, (unint64_t *)&v3, (unint64_t)v2);
    if (v3) {
      CFRelease(v2);
    }
  }
  return _CFProcessNameString___CFProcessNameString;
}

CFStringRef CFURLCopyFragment(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  CFStringRef v4 = _unescapedFragment(anURL);
  if (!v4) {
    return 0;
  }
  CFStringRef v5 = v4;
  int v6 = *((_DWORD *)anURL + 5);
  CFAllocatorRef v7 = CFGetAllocator(anURL);
  if (v6 == 134217984) {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapes(v7, v5, charactersToLeaveEscaped);
  }
  else {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v7, v5, charactersToLeaveEscaped, *((_DWORD *)anURL + 5));
  }
  CFStringRef v9 = v8;
  CFRelease(v5);
  return v9;
}

CFStringRef _unescapedFragment(void *a1)
{
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)a1))
  {
    CFStringRef v2 = (const void *)[a1 fragment];
    uint64_t v3 = v2;
    if (v2) {
      CFRetain(v2);
    }
    return (const __CFString *)v3;
  }
  else
  {
    return _retainedComponentString((uint64_t)a1, 256, 0, 0);
  }
}

void _CFPreferencesSetValueWithContainer(uint64_t a1, uint64_t a2, __CFString *a3, __CFString *a4, const void *a5, const __CFString *a6)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    int v12 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    int v12 = (const os_unfair_lock *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  int v13 = (os_unfair_lock *)v12;
  -[_CFXPreferences setValue:forKey:identifier:user:host:container:](v12, a2, a1, a3, a4, a5, a6);
}

CFDictionaryRef _CFURLCopyPropertyListRepresentation(unint64_t *a1)
{
  keys[4] = *(void **)off_1ECE0A5B0;
  CFAllocatorRef v2 = CFGetAllocator(a1);
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)a1)) {
    uint64_t v3 = (unint64_t *)[a1 baseURL];
  }
  else {
    uint64_t v3 = (unint64_t *)a1[4];
  }
  *(_OWORD *)CFRange values = 0u;
  long long v16 = 0u;
  keys[0] = @"_CFURLStringType";
  keys[1] = @"_CFURLString";
  keys[2] = @"_CFURLBaseStringType";
  keys[3] = @"_CFURLBaseURLString";
  int valuePtr = 15;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)a1))
  {
    values[0] = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    CFStringRef v4 = (void *)CFURLGetString((CFURLRef)a1);
  }
  else
  {
    values[0] = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    CFStringRef v5 = (const void *)atomic_load(a1 + 3);
    CFStringRef v4 = (void *)CFRetain(v5);
  }
  values[1] = v4;
  if (v3)
  {
    if (CF_IS_OBJC(0x1DuLL, (unint64_t)v3))
    {
      int valuePtr = 15;
      *(void *)&long long v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      int v6 = (void *)CFURLGetString((CFURLRef)v3);
    }
    else
    {
      int valuePtr = 15;
      *(void *)&long long v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      CFStringRef v8 = (const void *)atomic_load(v3 + 3);
      int v6 = (void *)CFRetain(v8);
    }
    *((void *)&v16 + 1) = v6;
    CFIndex v7 = 4;
  }
  else
  {
    CFIndex v7 = 2;
  }
  CFAllocatorRef v9 = CFGetAllocator(a1);
  CFDictionaryRef v10 = CFDictionaryCreate(v9, (const void **)keys, (const void **)values, v7, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  unint64_t v11 = 0;
  uint64_t v12 = 8 * v7;
  do
  {
    CFRelease(values[v11 / 8]);
    v11 += 8;
  }
  while (v12 != v11);
  return v10;
}

const char *__CFNumberGetTypeID_block_invoke()
{
  if (_CFExecutableLinkedOnOrAfter(7uLL) && *(void *)off_1ECE0A6E8) {
    _objc_registerTaggedPointerClass();
  }
  else {
    __CFNumberTaggedPointersDisabled = 1;
  }
  uint64_t result = getenv("CFNumberDisableCache");
  if (result)
  {
    uint64_t result = (const char *)strcmp(result, "all");
    if (result) {
      char v1 = 1;
    }
    else {
      char v1 = 2;
    }
    __CFNumberCaching = v1;
  }
  return result;
}

uint64_t _CFStreamSetClient(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2) {
    BOOL v6 = a3 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  BOOL v7 = v6 || a4 == 0;
  char v8 = v7;
  if (v7) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = a2;
  }
  if (v7) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = a3;
  }
  uint64_t v11 = a1[4];
  if (v11)
  {
LABEL_17:
    if (*(void *)(v11 + 40))
    {
      uint64_t v12 = *(void (**)(void))(v11 + 24);
      if (v12)
      {
        v12(*(void *)(v11 + 8));
        uint64_t v11 = a1[4];
      }
    }
    *(void *)(v11 + 4CFNotificationCenterRemoveObserver(center, observer, 0, 0) = v10;
    if (v8)
    {
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + 8) = 0u;
    }
    else
    {
      *(_OWORD *)(v11 + 16) = *(_OWORD *)(a4 + 16);
      uint64_t v14 = *(void *)(a4 + 8);
      *(void *)uint64_t v11 = *(void *)a4;
      *(void *)(v11 + 32) = *(void *)(a4 + 32);
      CFHashCode v15 = *(uint64_t (**)(void))(a4 + 16);
      if (v15 && v14)
      {
        uint64_t v14 = v15();
        uint64_t v11 = a1[4];
      }
      *(void *)(v11 + 8) = v14;
    }
    if (*(void *)(v11 + 48) != v9)
    {
      uint64_t v16 = a1[6];
      *(void *)(v11 + 48) = v9;
      unint64_t v17 = *(void (**)(void *, uint64_t, void))(v16 + 112);
      if (v17) {
        v17(a1, v9, a1[5]);
      }
    }
    return 1;
  }
  if ((v8 & 1) == 0)
  {
    _initializeClient(a1);
    uint64_t v11 = a1[4];
    if (!v11) {
      return 0;
    }
    goto LABEL_17;
  }
  return 1;
}

double _initializeClient(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(v2, 80, 0x10A00402EE2ECADLL, 0);
  a1[4] = Typed;
  double result = 0.0;
  _OWORD *Typed = 0u;
  Typed[1] = 0u;
  Typed[2] = 0u;
  Typed[3] = 0u;
  Typed[4] = 0u;
  return result;
}

Boolean CFWriteStreamSetClient(CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    if (objc_opt_respondsToSelector())
    {
      return [(__CFWriteStream *)stream _setCFClientFlags:streamEvents callback:clientCB context:clientContext];
    }
    else
    {
      if (clientCB)
      {
        uint64_t v9 = [[_CFStreamDelegate alloc] initWithStreamEvents:streamEvents callback:clientCB context:clientContext];
        [(__CFWriteStream *)stream setDelegate:v9];
        uint64_t v10 = (const void *)objc_opt_class();
        objc_setAssociatedObject(stream, v10, v9, (void *)0x301);
      }
      else
      {
        [(__CFWriteStream *)stream setDelegate:0];
      }
      return 1;
    }
  }
  else
  {
    return _CFStreamSetClient(stream, streamEvents & 0xFFFFFFFFFFFFFFFDLL, (uint64_t)clientCB, (uint64_t)clientContext);
  }
}

id _NSObjectStoreWeak(id *location, id obj, unsigned char *a3)
{
  if (!obj)
  {
    if (*location)
    {
      if (*a3)
      {
        id v5 = 0;
        *CFIndex location = 0;
        return v5;
      }
      objc_storeWeakOrNil(location, 0);
    }
    return 0;
  }
  id v5 = obj;
  if (*a3) {
    *CFIndex location = 0;
  }
  id v6 = objc_storeWeakOrNil(location, obj);
  if (v6)
  {
    *a3 = 0;
    return v6;
  }
  else
  {
    *a3 = 1;
    *CFIndex location = v5;
  }
  return v5;
}

CFLocaleRef CFDateFormatterGetLocale(CFDateFormatterRef formatter)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return (CFLocaleRef)*((void *)formatter + 3);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

void CFCalendarSetLocale(CFCalendarRef calendar, CFLocaleRef locale)
{
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  uint64_t v0 = (void *)+[NSCalendar _current];

  return (CFCalendarRef)v0;
}

CFTimeZoneRef CFTimeZoneCreateWithName(CFAllocatorRef allocator, CFStringRef name, Boolean tryAbbrev)
{
  int v3 = tryAbbrev;
  if (CFEqual(&stru_1ECE10768, name)) {
    return 0;
  }
  id v6 = (void *)_CFAutoreleasePoolPush();
  CFTimeZoneRef v7 = (const __CFTimeZone *)(id)+[NSTimeZone _timeZoneWithName:name tryAbbrev:v3 != 0];
  _CFAutoreleasePoolPop(v6);
  return v7;
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  CFURLRef v1 = anURL;
  if (CF_IS_OBJC(0x1DuLL, (unint64_t)anURL)) {
    CFURLRef v1 = (CFURLRef)[(__CFURL *)v1 _cfurl];
  }
  return (*((_DWORD *)v1 + 4) >> 14) & 1;
}

CFMutableBitVectorRef CFBitVectorCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFBitVectorRef bv)
{
  return (CFMutableBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 1, *((const void **)bv + 4), *((void *)bv + 2));
}

void *CFBurstTrieCreateCursorForBytes(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  id v6 = malloc_type_calloc(0x21uLL, 1uLL, 0x5F15F5FuLL);
  CFBurstTrieSetCursorForBytes(a1, (uint64_t)v6, a2, a3);
  if (!v7 && v6)
  {
    free(v6);
    return 0;
  }
  return v6;
}

void CFBurstTrieSetCursorForBytes(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4)
{
  uint64_t v4 = *(void *)(a1 + 2056);
  if (v4)
  {
    if ((a4 & 0x8000000000000000) == 0 && (*(_DWORD *)(a1 + 2072) & 0x18) != 0)
    {
      *(void *)(a2 + 25) = a1;
      *(void *)(a2 + 17) = 1;
      *(_DWORD *)a2 = *(_DWORD *)(v4 + 4);
      *(void *)(a2 + 9) = 0;
      *(void *)(a2 + 4) = 0;
      if (a3)
      {
        if (a4) {
          CFBurstTrieCursorAdvanceForBytes(a2, a3, a4);
        }
      }
    }
  }
}

void CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x26uLL, (unint64_t)stream))
  {
    if (objc_opt_respondsToSelector())
    {
      [(__CFReadStream *)stream _scheduleInCFRunLoop:runLoop forMode:runLoopMode];
    }
    else
    {
      CFTypeRef v6 = _CFRunLoopGet2((uint64_t)runLoop);
      [(__CFReadStream *)stream scheduleInRunLoop:v6 forMode:runLoopMode];
    }
  }
  else
  {
    _CFStreamScheduleWithRunLoop((char *)stream, runLoop, runLoopMode);
  }
}

const void *_CFErrorCreateLocalizedFailureReason(void *a1)
{
  return _CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
}

const void *CFCopySystemVersionString()
{
  CFDictionaryRef v0 = (const __CFDictionary *)_CFCopySupplementalVersionDictionary();
  if (!v0) {
    return 0;
  }
  CFDictionaryRef v1 = v0;
  CFStringRef Value = CFDictionaryGetValue(v0, @"FullVersionString");
  int v3 = Value;
  if (Value) {
    CFRetain(Value);
  }
  CFRelease(v1);
  return v3;
}

CFTypeRef _CFCopySupplementalVersionDictionary()
{
  if (_CFCopySupplementalVersionDictionary_onceToken != -1) {
    dispatch_once(&_CFCopySupplementalVersionDictionary_onceToken, &__block_literal_global_38);
  }
  CFTypeRef result = (CFTypeRef)_CFCopySupplementalVersionDictionary_result;
  if (_CFCopySupplementalVersionDictionary_result)
  {
    return CFRetain(result);
  }
  return result;
}

void sub_182C92FCC(_Unwind_Exception *a1)
{
}

void sub_182C9337C(_Unwind_Exception *a1)
{
}

uint64_t __CFBundleAllowMixedLocalizations_block_invoke()
{
  uint64_t result = _CFBundleGetInfoDictionaryBoolean(@"CFBundleAllowMixedLocalizations");
  CFBundleAllowMixedLocalizations_allowMixed = result;
  return result;
}

uint64_t _CFBundleGetInfoDictionaryBoolean(const void *a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (!MainBundle) {
    return 0;
  }
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
  if (!InfoDictionary) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, a1);
  if (!Value) {
    return 0;
  }
  CFStringRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFBooleanGetTypeID())
  {
    if (v6 == CFStringGetTypeID())
    {
      uint64_t v8 = 1;
      if (CFStringCompare(v5, @"true", 1uLL)) {
        return CFStringCompare(v5, @"YES", 1uLL) == kCFCompareEqualTo;
      }
      return v8;
    }
    if (v6 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)v5, kCFNumberSInt32Type, &valuePtr)) {
        BOOL v9 = valuePtr == 0;
      }
      else {
        BOOL v9 = 1;
      }
      return !v9;
    }
    return 0;
  }

  return CFBooleanGetValue((CFBooleanRef)v5);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  uint64_t v78 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString _cfTrimWS];
  }
  else
  {
    int64_t v77 = 0;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    *(_OWORD *)CFStringRef theStringa = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    *(_OWORD *)buffer = 0u;
    p_info = &theString->info;
    char v3 = atomic_load((unint64_t *)&theString->info);
    if (v3)
    {
      char v12 = atomic_load((unint64_t *)p_info);
      uint64_t v13 = v12 & 5;
      char v14 = atomic_load((unint64_t *)p_info);
      uint64_t v15 = v14 & 0x60;
      if (v13 == 4)
      {
        p_uint64_t data = &theString->data;
        if (v15)
        {
          unint64_t v17 = *p_data;
        }
        else
        {
          uint64_t v19 = atomic_load((unint64_t *)&theString->info);
          unint64_t v17 = (char *)&p_data[(v19 & 5) != 4];
        }
        uint64_t length = *v17;
      }
      else if ((v14 & 0x60) != 0)
      {
        uint64_t length = theString->length;
      }
      else
      {
        uint64_t length = (uint64_t)theString->data;
      }
      theStringa[0] = theString;
      *((void *)&v75 + 1) = 0;
      *(void *)&long long v76 = length;
      CFStringRef CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(theString);
      uint64_t v21 = 0;
      theStringa[1] = CharactersPtr;
      if (!CharactersPtr)
      {
        int v22 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          CFStringRef CharactersPtr = (const __CFString *)__CFStringComputeEightBitStringEncoding(0);
          int v22 = __CFDefaultEightBitStringEncoding;
        }
        if (v22 != 1536)
        {
          if (v22 == -1)
          {
            __CFStringComputeEightBitStringEncoding(CharactersPtr);
            int v22 = __CFDefaultEightBitStringEncoding;
          }
          if (v22 != 1536) {
            goto LABEL_25;
          }
        }
        uint64_t v23 = &theString->info;
        char v24 = atomic_load((unint64_t *)&theString->info);
        if ((v24 & 0x10) == 0 || (char v25 = atomic_load((unint64_t *)v23), (v25 & 8) != 0))
        {
          char v26 = atomic_load((unint64_t *)v23);
          CFIndex v27 = &theString->data;
          if ((v26 & 0x60) != 0)
          {
            char v28 = *v27;
          }
          else
          {
            char v29 = atomic_load((unint64_t *)&theString->info);
            char v28 = (char *)&v27[(v29 & 5) != 4];
          }
          unint64_t v30 = atomic_load((unint64_t *)&theString->info);
          uint64_t v21 = &v28[(v30 >> 2) & 1];
        }
        else
        {
LABEL_25:
          uint64_t v21 = 0;
        }
      }
      *((void *)&v76 + 1) = 0;
      int64_t v77 = 0;
      *(void *)&long long v75 = v21;
      if (length < 1)
      {
LABEL_48:
        uint64_t v64 = 0;
        uint64_t v65 = length;
      }
      else
      {
        int64_t v31 = 0;
        while (1)
        {
          if (theStringa[1])
          {
            UniChar v32 = *((_WORD *)&theStringa[1]->isa + *((void *)&v75 + 1) + v31);
          }
          else if ((void)v75)
          {
            UniChar v32 = *(char *)(v75 + *((void *)&v75 + 1) + v31);
          }
          else
          {
            uint64_t v33 = *((void *)&v76 + 1);
            BOOL v34 = v77 > v31 && *((void *)&v76 + 1) <= v31;
            if (!v34)
            {
              int64_t v35 = v31 - 4;
              if ((unint64_t)v31 < 4) {
                int64_t v35 = 0;
              }
              int64_t v36 = v35 + 64;
              if (v35 + 64 >= (uint64_t)v76) {
                int64_t v36 = v76;
              }
              *((void *)&v76 + 1) = v35;
              int64_t v77 = v36;
              v80.CFIndex location = *((void *)&v75 + 1) + v35;
              v80.uint64_t length = v36 - v35;
              CFStringGetCharacters(theStringa[0], v80, buffer);
              uint64_t v33 = *((void *)&v76 + 1);
            }
            UniChar v32 = buffer[v31 - v33];
          }
          if (!CFUniCharIsMemberOf(v32, 3u)) {
            break;
          }
          if (++v31 == length) {
            goto LABEL_48;
          }
        }
        char v37 = atomic_load((unint64_t *)&theString->info);
        unsigned int v38 = &theString->data;
        CFRange v63 = &theString->data;
        if ((v37 & 0x60) != 0)
        {
          char v39 = *v38;
        }
        else
        {
          char v40 = atomic_load((unint64_t *)&theString->info);
          char v39 = (char *)&v38[(v40 & 5) != 4];
        }
        unint64_t v41 = atomic_load((unint64_t *)&theString->info);
        char v42 = &v39[(v41 >> 2) & 1];
        unint64_t v43 = atomic_load((unint64_t *)&theString->info);
        uint64_t v44 = (v43 >> 4) & 1;
        uint64_t v45 = -length;
        uint64_t v46 = length + 64;
        do
        {
          uint64_t v47 = length;
          if ((unint64_t)length >= 5) {
            uint64_t v48 = 5;
          }
          else {
            uint64_t v48 = length;
          }
          BOOL v34 = length-- < 1;
          if (v34) {
            break;
          }
          if (theStringa[1])
          {
            UniChar v49 = *((_WORD *)theStringa[1] + v47 + *((void *)&v75 + 1) - 1);
          }
          else if ((void)v75)
          {
            UniChar v49 = *(char *)(v75 + *((void *)&v75 + 1) + v47 - 1);
          }
          else
          {
            uint64_t v50 = *((void *)&v76 + 1);
            if (v77 < v47 || *((void *)&v76 + 1) >= v47)
            {
              uint64_t v52 = -v48;
              uint64_t v53 = v48 + v45;
              uint64_t v54 = v46 - v48;
              uint64_t v55 = v47 + v52;
              int64_t v56 = v55 + 64;
              if (v55 + 64 >= (uint64_t)v76) {
                int64_t v56 = v76;
              }
              *((void *)&v76 + 1) = v55;
              int64_t v77 = v56;
              if ((uint64_t)v76 < v54) {
                uint64_t v54 = v76;
              }
              v81.uint64_t length = v54 + v53;
              v81.CFIndex location = v55 + *((void *)&v75 + 1);
              CFStringGetCharacters(theStringa[0], v81, buffer);
              uint64_t v50 = *((void *)&v76 + 1);
            }
            UniChar v49 = buffer[v47 - 1 - v50];
          }
          ++v45;
          --v46;
        }
        while ((CFUniCharIsMemberOf(v49, 3u) & 1) != 0);
        memmove(v42, &v42[v31 << v44], (v47 - v31) << v44);
        char v57 = atomic_load((unint64_t *)&theString->info);
        char v58 = atomic_load((unint64_t *)&theString->info);
        uint64_t v59 = v58 & 0x60;
        if ((v57 & 5) == 4)
        {
          if (v59)
          {
            uint64_t v60 = *v63;
          }
          else
          {
            char v62 = atomic_load((unint64_t *)&theString->info);
            uint64_t v60 = (char *)&v63[(v62 & 5) != 4];
          }
          uint64_t v61 = *v60;
        }
        else if (v59)
        {
          uint64_t v61 = theString->length;
        }
        else
        {
          uint64_t v61 = (uint64_t)*v63;
        }
        uint64_t v64 = v47 - v31;
        uint64_t v65 = v61 + v31 - v47;
      }
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v64, 1, 0, 0);
    }
    else
    {
      uint64_t v4 = _CFOSLog();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        CFStringTrimWhitespace_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
  }
}

uint64_t _CFPreferencesSynchronizeWithContainer(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v9 = -[_CFXPreferences synchronizeIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void sub_182C93C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___deque_enumerateObjectsWithOptionsBlock_block_invoke(uint64_t a1)
{
  return __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(*(void *)(a1 + 32));
}

CFBinaryHeapRef CFBinaryHeapCreate(CFAllocatorRef allocator, CFIndex capacity, const CFBinaryHeapCallBacks *callBacks, const CFBinaryHeapCompareContext *compareContext)
{
  return (CFBinaryHeapRef)__CFBinaryHeapCreateInit((__objc2_class **)allocator, 0, 0, (uint64_t)callBacks, (long long *)&compareContext->version);
}

void CFPlugInRemoveInstanceForFactory(CFUUIDRef factoryID)
{
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryID)) != 0
    && Value[24])
  {
    _CFPFactoryRemoveInstanceLocked((uint64_t)Value);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      CFPlugInRemoveInstanceForFactory_cold_2();
    }
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInRemoveInstanceForFactory_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
}

void _CFPFactoryRemoveInstanceLocked(uint64_t a1)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  CFDictionaryRef v1 = *(const void **)(a1 + 40);
  if (v1 && *(unsigned char *)__CFBundleGetPlugInData(*(void *)(a1 + 40)))
  {
    PlugInCFDataRef Data = __CFBundleGetPlugInData((uint64_t)v1);
    --*(_DWORD *)(PlugInData + 8);
    if (!*(_DWORD *)(__CFBundleGetPlugInData((uint64_t)v1) + 8) && *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)v1) + 1))
    {
      os_unfair_recursive_lock_lock_with_options();
      char v3 = (__CFSet *)_plugInsToUnload;
      if (!_plugInsToUnload)
      {
        memset(&v4, 0, 24);
        v4.copyDescription = kCFTypeSetCallBacks.copyDescription;
        *(_OWORD *)&v4.equal = *(_OWORD *)&kCFTypeSetCallBacks.equal;
        char v3 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v4);
        _plugInsToUnload = (uint64_t)v3;
      }
      CFSetAddValue(v3, v1);
      if (_CFBundlePluginLogger_onceToken != -1) {
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      }
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
        _CFPFactoryRemoveInstanceLocked_cold_1();
      }
      os_unfair_recursive_lock_unlock();
    }
    CFRelease(v1);
  }
}

uint64_t __CFDictionaryGetValueCallbacks@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  uint64_t result = __CFBasicHashGetCallbacks(a1, &v8);
  uint64_t v4 = v8;
  uint64_t v5 = v9;
  *a2 = 0;
  a2[1] = v4;
  uint64_t v6 = v12;
  uint64_t v7 = v10;
  a2[2] = v5;
  a2[3] = v6;
  a2[4] = v7;
  return result;
}

uint64_t __CFBasicHashGetCallbacks@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *(void *)(a1 + 24);
  unint64_t v2 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(CFBasicHashCallBackPtrs[(v3 >> 39) & 0x1F] + 8 * ((v3 >> 34) & 0x1F));
  uint64_t v5 = *(void *)(CFBasicHashCallBackPtrs[((v3 >> 24) >> 5) & 0x1F] + 8 * ((v3 >> 24) & 0x1F));
  uint64_t v6 = *(void *)(*(uint64_t *)((char *)CFBasicHashCallBackPtrs + (HIBYTE(v3) & 0xF8)) + 8 * ((v3 >> 54) & 0x1F));
  uint64_t v7 = *(void *)(CFBasicHashCallBackPtrs[(v3 >> 49) & 0x1F] + 8 * ((v3 >> 44) & 0x1F));
  uint64_t v8 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 34) >> 5) & 0x1F] + 8 * ((v2 >> 34) & 0x1F));
  uint64_t v9 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 24) >> 5) & 0x1F] + 8 * ((v2 >> 24) & 0x1F));
  uint64_t result = (v2 >> 44) & 0x1F;
  uint64_t v11 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 44) >> 5) & 0x1F] + 8 * result);
  *a2 = v4;
  a2[1] = v5;
  uint64_t v12 = CFBasicHashCallBackPtrs[(v2 >> 54) >> 5];
  a2[2] = v6;
  a2[3] = v7;
  uint64_t v13 = *(void *)(v12 + 8 * ((v2 >> 54) & 0x1F));
  uint64_t v14 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 14) >> 5) & 0x1F] + 8 * ((v2 >> 14) & 0x1F));
  a2[4] = v8;
  a2[5] = v9;
  uint64_t v15 = CFBasicHashCallBackPtrs[((v2 >> 4) >> 5) & 0x1F];
  a2[6] = v11;
  a2[7] = v13;
  uint64_t v16 = *(void *)(v15 + 8 * ((v2 >> 4) & 0x1F));
  a2[8] = v14;
  a2[9] = v16;
  return result;
}

double __CFDictionaryGetKeyCallbacks@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  long long v10 = 0u;
  long long v8 = 0u;
  memset(v9, 0, sizeof(v9));
  long long v7 = 0u;
  __CFBasicHashGetCallbacks(a1, &v7);
  uint64_t v3 = *((void *)&v7 + 1);
  uint64_t v4 = *((void *)&v8 + 1);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = v3;
  uint64_t v5 = *((void *)&v10 + 1);
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  double result = *((double *)v9 + 1);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)v9 + 8);
  return result;
}

Boolean CFBundleLoadExecutableAndReturnError(CFBundleRef bundle, CFErrorRef *error)
{
  return _CFBundleLoadExecutableAndReturnError((uint64_t)bundle, 0, error);
}

void *__CFBasicHashGetPtrIndex_block_invoke()
{
  CFBasicHashCallBackPtrsLocuint64_t k = 0;
  double result = malloc_type_malloc(0x100uLL, 0x80040B8603338uLL);
  CFBasicHashCallBackPtrs[0] = (uint64_t)result;
  if (result)
  {
    *double result = 0;
    result[1] = CFCopyDescription;
    result[2] = __CFTypeCollectionRelease;
    result[3] = __CFTypeCollectionRetain;
    result[4] = CFEqual;
    result[5] = CFHash;
    result[6] = __CFStringCollectionCopy;
    result[7] = 0;
    atomic_store(8u, (unsigned int *)&CFBasicHashCallBackPtrsCount);
  }
  else
  {
    __break(1u);
  }
  return result;
}

void _CFPrefsSetDirectModeEnabled(char a1)
{
  forceDirect = a1;
  _CFPrefsResetPreferences(1);
}

CFTypeRef _CFBundleCopyInfoPlistURL(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  uint64_t v3 = *(const void **)(a1 + 216);
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

unint64_t _CFNumberFormatterGetFormatter(unint64_t *a1)
{
  __CFCheckCFInfoPACSignature((uint64_t)a1);
  unint64_t v2 = _CFGetNonObjCTypeID(a1);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  return a1[2];
}

uint64_t __CFStringComputeEightBitStringEncoding()
{
  if (__CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2) {
    return 1536;
  }
  __CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 = 1;
  int v1 = _CFExecutableLinkedOnOrAfter(9uLL);
  __CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 = 0;
  if (v1)
  {
    uint64_t result = 1536;
LABEL_5:
    __CFDefaultEightBitStringEncoding = result;
    return result;
  }
  if (__CFStringIsBeingInitialized == 1 || __CFIsReadyToInitializeSystemEncoding == 0) {
    return 0;
  }
  uint64_t result = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    if (CFStringGetSystemEncoding() == -1) {
      return 1536;
    }
    uint64_t result = 0;
    goto LABEL_5;
  }
  return result;
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_DIRECT_CFPREFSD(const os_unfair_lock *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

void sub_182C94D60(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

__n128 CFBurstTrieCursorAdvanceForBytes(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  if (*(void *)(a1 + 17) == 1)
  {
    char v4 = *(unsigned char *)(a1 + 16);
    __n128 v6 = *(__n128 *)a1;
    if (!advanceMapCursor(*(void *)(a1 + 25), (int *)a1, a2, a3))
    {
      *(unsigned char *)(a1 + 16) = v4;
      __n128 result = v6;
      *(__n128 *)a1 = v6;
    }
  }
  return result;
}

BOOL advanceMapCursor(uint64_t a1, int *a2, unsigned __int8 *a3, size_t a4)
{
  int v4 = *a2;
  switch(*a2 & 3)
  {
    case 1:
      goto LABEL_3;
    case 2:
      uint64_t v9 = 0;
      if (!a3 || (a4 & 0x8000000000000000) != 0) {
        return v9;
      }
      uint64_t v10 = *(void *)(a1 + 2056) + (v4 & 0xFFFFFFFC);
      unsigned int v11 = *(_DWORD *)v10 - 4;
      if (*(_DWORD *)v10 == 4) {
        return 0;
      }
      int v12 = *(_DWORD *)(a1 + 2072);
      if ((v12 & 8) != 0)
      {
        if (a4)
        {
          uint64_t v22 = 0;
          BOOL v23 = *((unsigned char *)a2 + 16) == 0;
          while (1)
          {
            unsigned int v24 = a3[v22];
            if (v23) {
              break;
            }
            uint64_t v25 = a2[1];
            CFIndex v27 = (unsigned __int8 *)(v10 + v25 + 4);
            if (!v25)
            {
              unsigned int v26 = *(unsigned __int16 *)(v10 + v25 + 5);
              if (!*(_WORD *)(v10 + v25 + 5))
              {
                LODWORD(v25) = 0;
                goto LABEL_33;
              }
            }
            uint64_t v28 = a2[2];
            unsigned int v29 = v27[v28 + 7];
            if (v29 != v24)
            {
              if (v29 > v24)
              {
                uint64_t v9 = 0;
                a2[2] = v28 + 1;
                return v9;
              }
              unsigned int v26 = v28 + *v27;
              LODWORD(v25) = v25 + *(unsigned __int16 *)(v10 + v25 + 5) + 7;
              goto LABEL_32;
            }
            int v30 = v28 + 1;
LABEL_45:
            BOOL v23 = 0;
            a2[2] = v30;
            *((unsigned char *)a2 + 16) = 1;
            if (++v22 == a4)
            {
              uint64_t v57 = v10 + v25;
              a2[3] = 0;
              int v58 = v25 | v30;
              int v59 = *(unsigned __int16 *)(v57 + 5);
              if (v58 | v59) {
                BOOL v60 = v30 == v59;
              }
              else {
                BOOL v60 = 1;
              }
              if (v60)
              {
                __int32 v21 = *(_DWORD *)(v57 + 7);
LABEL_20:
                a2[3] = v21;
              }
              return 1;
            }
          }
          LODWORD(v25) = 0;
          unsigned int v26 = 0;
LABEL_32:
          a2[1] = v25;
LABEL_33:
          unsigned int v31 = *(_DWORD *)v10 - 4;
          if (v25 >= v31) {
            return 0;
          }
          while (1)
          {
            uint64_t v32 = v10 + v25;
            unsigned int v34 = *(unsigned __int8 *)(v32 + 4);
            uint64_t v33 = v32 + 4;
            BOOL v35 = v26 >= v34;
            if (v26 > v34) {
              return 0;
            }
            int v36 = *(unsigned __int16 *)(v33 + 1);
            if (v35)
            {
              if (!*(_WORD *)(v33 + 1))
              {
                LODWORD(v25) = v25 + 7;
                goto LABEL_41;
              }
              unsigned int v37 = *(unsigned __int8 *)(v33 + 7);
              if (v37 > v24) {
                return 0;
              }
              if (v37 >= v24)
              {
                int v30 = 1;
                goto LABEL_45;
              }
            }
            LODWORD(v25) = v25 + v36 + 7;
LABEL_41:
            uint64_t v9 = 0;
            a2[1] = v25;
            if (v25 >= v31) {
              return v9;
            }
          }
        }
        if (*((unsigned char *)a2 + 16))
        {
          int v42 = a2[2];
          BOOL v43 = a2[1] == 0;
        }
        else
        {
          BOOL v47 = 0;
          a2[1] = 0;
          a2[2] = 0;
          if (!*(unsigned char *)(v10 + 4)) {
            BOOL v47 = *(_WORD *)(v10 + 5) == 0;
          }
          int v42 = 0;
          *((unsigned char *)a2 + 16) = v47;
          BOOL v43 = 1;
        }
        a2[3] = 0;
        if (v43 && !v42)
        {
          if (!*(_WORD *)(v10 + 5))
          {
LABEL_67:
            __int32 v21 = *(_DWORD *)(v10 + 7);
            goto LABEL_20;
          }
          int v42 = 0;
        }
        if (v42 != *(unsigned __int16 *)(v10 + 5)) {
          return 1;
        }
        goto LABEL_67;
      }
      if ((v12 & 0x10) == 0) {
        return 0;
      }
      if (!a4)
      {
        if (*((unsigned char *)a2 + 16))
        {
          a2[3] = 0;
          uint64_t v44 = a2 + 3;
          int v45 = a2[2];
          if (a2[1])
          {
            int v46 = *(unsigned __int16 *)(v10 + 4);
            goto LABEL_91;
          }
          int v46 = *(unsigned __int16 *)(v10 + 4);
          if (v45)
          {
LABEL_91:
            if (v45 != v46) {
              return 1;
            }
LABEL_92:
            int64_t v56 = (int *)(v10 + 6);
            goto LABEL_93;
          }
        }
        else
        {
          a2[3] = 0;
          uint64_t v44 = a2 + 3;
          *(void *)(a2 + 1) = 0;
          int v46 = *(unsigned __int16 *)(v10 + 4);
          *((unsigned char *)a2 + 16) = *(_WORD *)(v10 + 4) == 0;
        }
        if (!v46) {
          goto LABEL_92;
        }
        int v45 = 0;
        goto LABEL_91;
      }
      uint64_t v13 = a2[1];
      if (*((unsigned char *)a2 + 16))
      {
        char v62 = (const void *)(v10 + v13 + 10);
        unsigned int v14 = a2[2];
      }
      else
      {
        char v62 = 0;
        unsigned int v14 = 0;
      }
      if (v13 >= v11) {
        return 0;
      }
      uint64_t v61 = a4 + v14;
      while (1)
      {
        uint64_t v48 = v10 + v13;
        unsigned int v51 = *(unsigned __int16 *)(v48 + 4);
        uint64_t v50 = v48 + 4;
        unsigned int v49 = v51;
        if (v51) {
          break;
        }
        LODWORD(v13) = v13 + 6;
LABEL_83:
        uint64_t v9 = 0;
        a2[1] = v13;
        if (v13 >= v11) {
          return v9;
        }
      }
      if (v49 <= v14) {
        return 0;
      }
      if (v14)
      {
        int v52 = memcmp((const void *)(v50 + 6), v62, v14);
        if (v52 > 0) {
          return 0;
        }
        if (v52)
        {
LABEL_82:
          LODWORD(v13) = v13 + v49 + 6;
          goto LABEL_83;
        }
      }
      uint64_t v53 = (const void *)(v50 + v14 + 6);
      if (v61 > v49)
      {
        if (memcmp(v53, a3, v49 - v14) > 0) {
          return 0;
        }
        goto LABEL_82;
      }
      int v54 = memcmp(v53, a3, a4);
      if (v54 > 0) {
        return 0;
      }
      if (v54) {
        goto LABEL_82;
      }
      a2[3] = 0;
      uint64_t v44 = a2 + 3;
      uint64_t v9 = 1;
      *((unsigned char *)v44 + 4) = 1;
      *(v44 - 1) = v61;
      if (v61 == v49)
      {
        int64_t v56 = (int *)(v50 + 2);
LABEL_93:
        *uint64_t v44 = *v56;
        return 1;
      }
      return v9;
    case 3:
      uint64_t v9 = 0;
      if (!a3 || (a4 & 0x8000000000000000) != 0) {
        return v9;
      }
      uint64_t v15 = (int8x8_t *)(*(void *)(a1 + 2056) + (v4 & 0xFFFFFFFC));
      if (!a4)
      {
        __int32 v21 = v15[4].i32[0];
        goto LABEL_20;
      }
      unsigned int v16 = *a3;
      LODWORD(v17) = v16 >> 6;
      int8x8_t v18 = v15[v16 >> 6];
      uint64_t v19 = 1 << v16;
      if (((1 << v16) & *(void *)&v18) == 0) {
        return 0;
      }
      if (v16 >= 0x40)
      {
        int v20 = 0;
        if (v17 <= 1) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = v17;
        }
        unsigned int v38 = v15;
        do
        {
          int8x8_t v39 = *v38++;
          uint8x8_t v40 = (uint8x8_t)vcnt_s8(v39);
          v40.i16[0] = vaddlv_u8(v40);
          v20 += v40.i32[0];
          --v17;
        }
        while (v17);
      }
      else
      {
        int v20 = 0;
      }
      uint8x8_t v41 = (uint8x8_t)vcnt_s8((int8x8_t)((v19 - 1) & *(void *)&v18));
      v41.i16[0] = vaddlv_u8(v41);
      *a2 = v15[4].i32[v20 + v41.i32[0] + 1];
      int v8 = advanceMapCursor();
      return v8 != 0;
    default:
      if (v4 != *(_DWORD *)(*(void *)(a1 + 2056) + 4)) {
        return 0;
      }
LABEL_3:
      int v8 = advanceCursorMappedLevel(a1, a2, a3, a4);
      return v8 != 0;
  }
}

uint64_t advanceCursorMappedLevel(uint64_t a1, _DWORD *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v4 = 0;
  if (a3 && (a4 & 0x8000000000000000) == 0)
  {
    uint64_t v5 = (*a2 & 0xFFFFFFFC) + *(void *)(a1 + 2056);
    if (a4)
    {
      *a2 = *(_DWORD *)(v5 + 4 * *a3);
      return advanceMapCursor();
    }
    a2[3] = *(_DWORD *)(v5 + 1024);
    return 1;
  }
  return v4;
}

CFMutableSetRef ___cfmp_records_block_invoke()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  CFSetCallBacks v1 = *(CFSetCallBacks *)byte_1ECE0FCB8;
  CFMutableSetRef result = CFSetCreateMutable(0, 16, &v1);
  _cfmp_records_oRecords = (uint64_t)result;
  return result;
}

uint64_t CFStorageCreate(__objc2_class **a1, int64_t a2)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x1AuLL, 168, 0);
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 128) = 0;
    *(void *)(Instance + 16) = a2;
    BOOL v5 = (a2 & (a2 - 1)) != 0 || a2 <= 0;
    int v6 = __clz(__rbit64(a2));
    if (v5) {
      int v6 = -1;
    }
    *(_DWORD *)(Instance + 24) = v6;
    *(void *)(Instance + 32) = 850045857;
    *(_OWORD *)(Instance + 4_CFPreferencesSetValueWithContainer((uint64_t)key, (uint64_t)value, (__CFString *)applicationID, (__CFString *)userName, hostName, 0) = 0u;
    *(_OWORD *)(Instance + 56) = 0u;
    *(_OWORD *)(Instance + 72) = 0u;
    *(void *)(Instance + 88) = 0;
    *(void *)(Instance + 136) = 12288;
    if (a2 && 12288 % a2) {
      *(void *)(Instance + 136) = 12288 - 12288 % a2;
    }
    *(unsigned char *)(Instance + 157) = 1;
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return v4;
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  v9[1] = *(void *)off_1ECE0A5B0;
  if (errorString) {
    *errorCFStringRef String = 0;
  }
  CFTypeRef cf = 0;
  v9[0] = 0;
  _CFPropertyListCreateWithData((__objc2_class **)allocator, xmlData, mutabilityOption, (CFErrorRef *)&cf, 1, 0, 0, v9);
  CFTypeRef v5 = cf;
  int v6 = (const void *)v9[0];
  if (errorString && cf)
  {
    *errorCFStringRef String = __copyErrorDebugDescription((__CFError *)cf);
    CFTypeRef v5 = cf;
  }
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t _CFURLGetEncoding(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t _CFPrefsSetReadOnly(uint64_t result)
{
  forceReadOnly = result != 0;
  return result;
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (!__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return 0;
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x28uLL, 8, 0);
  if (Instance)
  {
    uint64_t v12 = __NLStringTokenizerCreate(alloc, string, location, length, options, locale);
    Instance[2] = v12;
    if (!v12)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return (CFStringTokenizerRef)Instance;
}

uint64_t __NSCollectionsShouldCopy()
{
  return 0;
}

uint64_t __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void CFRunLoopStop(CFRunLoopRef rl)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  unsigned __int8 v3 = atomic_load(__CFMainThreadHasExited);
  if (v3)
  {
    BOOL v4 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v4 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (*((void *)rl + 78))
  {
    *((unsigned char *)rl + *((unsigned __int8 *)rl + 84) + 85) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    CFRunLoopWakeUp(rl);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
}

_DWORD *CFBurstTrieCreateFromMapBytes(_DWORD *result)
{
  if (result)
  {
    CFSetCallBacks v1 = result;
    int v2 = *result;
    if (*result == 14531089 || v2 == -889275714)
    {
      CFMutableSetRef result = malloc_type_malloc(0x830uLL, 0x1010040873DE71CuLL);
      *((void *)result + 257) = v1;
      int v4 = v1[4];
      result[516] = v1[3];
LABEL_10:
      result[518] = v4;
      result[519] = v1[2];
      atomic_store(1u, result + 521);
      *((unsigned char *)result + 2088) = 0;
      return result;
    }
    if (v2 == -1161889074)
    {
      CFMutableSetRef result = malloc_type_malloc(0x830uLL, 0x1010040873DE71CuLL);
      *((void *)result + 257) = v1;
      int v4 = v1[4];
      result[516] = v1[3];
      result[517] = v1[1];
      goto LABEL_10;
    }
    return 0;
  }
  return result;
}

Boolean CFGregorianDateIsValid(CFGregorianDate gdate, CFOptionFlags unitFlags)
{
  uint64_t v2 = *(void *)&gdate.year;
  if ((unitFlags & 1) != 0 && gdate.year < 1) {
    return 0;
  }
  SInt8 month = gdate.month;
  if ((unitFlags & 2) != 0 && (gdate.month - 1) > 0xBu) {
    return 0;
  }
  uint64_t v4 = *(void *)&gdate.year >> 40;
  if ((unitFlags & 4) != 0 && (gdate.day - 1) > 0x1Eu) {
    return 0;
  }
  if ((unitFlags & 8) != 0 && (*(void *)&gdate.year >> 24) >> 27 > 2) {
    return 0;
  }
  if ((unitFlags & 0x10) == 0
    || (LOBYTE(gdate.year) = 0, (v2 & 0x8000000000000000) == 0) && *(int *)&gdate.month <= 1006632959)
  {
    if ((unitFlags & 0x20) == 0 || (LOBYTE(gdate.year) = 0, gdate.second >= 0.0) && gdate.second < 60.0)
    {
      if ((~(_BYTE)unitFlags & 7) != 0)
      {
        LOBYTE(gdate.year) = 1;
      }
      else
      {
        if ((gdate.month - 1) >= 0xCu)
        {
          gdate.year = os_log_type_enabled((os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR);
          if (gdate.year) {
            CFGregorianDateIsValid_cold_1(month);
          }
        }
        uint64_t v5 = ((int)v2 - 2001 + 1) % 400;
        if (v5 >= 0) {
          uint64_t v6 = ((int)v2 - 2001 + 1) % 400;
        }
        else {
          uint64_t v6 = -v5;
        }
        if ((v6 & 3) != 0)
        {
          BOOL v7 = 0;
        }
        else
        {
          BOOL v7 = 0;
          if (v6 != 100 && v6 != 200) {
            BOOL v7 = v6 != 300;
          }
        }
        if (BYTE4(v2) >= 0x10u)
        {
          __break(1u);
        }
        else
        {
          if (BYTE4(v2) != 2) {
            BOOL v7 = 0;
          }
          LOBYTE(gdate.year) = (daysInMonth[BYTE4(v2)] + v7) >= (char)v4;
        }
      }
    }
  }
  return gdate.year;
}

CFMutableDictionaryRef _CFPreferencesCopyMultipleWithContainer(uint64_t a1, __CFString *a2, __CFString *a3, const void *a4, const __CFString *a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = (os_unfair_lock *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  CFMutableDictionaryRef v11 = -[_CFXPreferences copyValuesForKeys:identifier:user:host:container:](v10, a1, a2, a3, a4, a5);

  return v11;
}

void sub_182C96428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFURLRef CFBundleCopyBuiltInPlugInsURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFAllocatorRef v3 = CFGetAllocator(bundle);
  CFAllocatorRef v4 = v3;
  unsigned int v5 = *((unsigned __int8 *)bundle + 53);
  if (v5 <= 0xB)
  {
    if (v5 == 1)
    {
      CFURLRef v6 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v7 = @"Support%20Files/PlugIns/";
      goto LABEL_13;
    }
    if (v5 == 2)
    {
      CFURLRef v6 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v7 = @"Contents/PlugIns/";
LABEL_13:
      CFURLRef v11 = CFURLCreateWithString(v3, v7, v6);
      goto LABEL_14;
    }
LABEL_12:
    CFURLRef v6 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v7 = @"PlugIns/";
    goto LABEL_13;
  }
  if (v5 == 12)
  {
    CFAllocatorRef v8 = CFGetAllocator(bundle);
    CFURLRef v9 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v10 = @"WrappedBundle/Contents/PlugIns/";
  }
  else
  {
    if (v5 != 13) {
      goto LABEL_12;
    }
    CFAllocatorRef v8 = CFGetAllocator(bundle);
    CFURLRef v9 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v10 = @"WrappedBundle/PlugIns/";
  }
  CFURLRef v11 = _CFURLCreateResolvedDirectoryWithString(v8, v10, v9);
LABEL_14:
  CFURLRef v12 = v11;
  if (v11 && (_CFURLExists(v11) & 1) != 0) {
    return v12;
  }
  unsigned int v13 = *((unsigned __int8 *)bundle + 53);
  if (v13 > 0xB)
  {
    if (v13 == 12)
    {
      CFAllocatorRef v16 = CFGetAllocator(bundle);
      CFURLRef v17 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v18 = @"WrappedBundle/Contents/Plug-ins/";
    }
    else
    {
      if (v13 != 13) {
        goto LABEL_26;
      }
      CFAllocatorRef v16 = CFGetAllocator(bundle);
      CFURLRef v17 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v18 = @"WrappedBundle/Plug-ins/";
    }
    CFURLRef v19 = _CFURLCreateResolvedDirectoryWithString(v16, v18, v17);
    goto LABEL_28;
  }
  if (v13 == 1)
  {
    CFURLRef v14 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v15 = @"Support%20Files/Plug-ins/";
    goto LABEL_27;
  }
  if (v13 != 2)
  {
LABEL_26:
    CFURLRef v14 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v15 = @"Plug-ins/";
    goto LABEL_27;
  }
  CFURLRef v14 = (const __CFURL *)*((void *)bundle + 2);
  CFStringRef v15 = @"Contents/Plug-ins/";
LABEL_27:
  CFURLRef v19 = CFURLCreateWithString(v4, v15, v14);
LABEL_28:
  CFURLRef v20 = v19;
  if (v19)
  {
    unsigned int v21 = _CFURLExists(v19);
    if (v12 || (v21 & 1) == 0)
    {
      if (v21) {
        CFURLRef v22 = v20;
      }
      else {
        CFURLRef v22 = v12;
      }
      if (v21) {
        CFURLRef v23 = v12;
      }
      else {
        CFURLRef v23 = v20;
      }
      CFRelease(v23);
      return v22;
    }
    else
    {
      return v20;
    }
  }
  return v12;
}

void CFStorageDeleteValues(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  int v7 = *(_DWORD *)(a1 + 24);
  if (v7 == -1)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    uint64_t v8 = v10 * a2;
    uint64_t v9 = v10 * a3;
  }
  else
  {
    uint64_t v8 = a2 << v7;
    uint64_t v9 = a3 << v7;
  }
  os_unfair_lock_lock_with_options();
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12_CFPreferencesSetValueWithContainer((uint64_t)key, (uint64_t)value, (__CFString *)applicationID, (__CFString *)userName, hostName, 0) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 128));
  uint64_t v11 = __CFStorageDeleteUnfrozen((uint64_t)v6, (void *)a1, a1 + 144, v8, v9, 1);
  if (v11)
  {
    uint64_t v12 = v11;
    if (v11 != a1 + 144)
    {
      uint64_t v13 = *(void *)v11;
      char v14 = *(unsigned char *)(v11 + 13);
      *(void *)(a1 + 16_CFPreferencesSetValueWithContainer((uint64_t)key, (uint64_t)value, (__CFString *)applicationID, (__CFString *)userName, hostName, 0) = 0;
      CFStringRef v15 = (int64_t *)(a1 + 160);
      *(void *)(a1 + 144) = v13;
      *(unsigned char *)(a1 + 157) = v14;
      *(void *)(a1 + 168) = 0;
      *(void *)(a1 + 176) = 0;
      if (*(unsigned char *)(v11 + 13))
      {
        if (*(unsigned char *)(v11 + 12))
        {
          CFAllocatorRef v16 = *(const void **)(v11 + 24);
          if (v16)
          {
            uint64_t v17 = *(void *)off_1ECE0A708;
            if (*(uint64_t *)off_1ECE0A708 >= 0) {
              uint64_t v18 = *(void *)off_1ECE0A708;
            }
            else {
              uint64_t v18 = v17 + 1;
            }
            if (v13 <= v18 >> 1)
            {
              uint64_t v25 = v13 + 63;
              BOOL v24 = v13 < -63;
              uint64_t v26 = v13 + 126;
              if (!v24) {
                uint64_t v26 = v25;
              }
              int64_t v20 = v26 & 0xFFFFFFFFFFFFFFC0;
            }
            else
            {
              int v19 = (v13 + v17 - 1) & -(int)v17;
              if (*(void *)(a1 + 136) >= v19) {
                int64_t v20 = v19;
              }
              else {
                int64_t v20 = *(void *)(a1 + 136);
              }
            }
            if (v20 > *v15)
            {
              pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
              if (v20 > *(void *)(a1 + 160))
              {
                *(void *)(a1 + 168) = __CFSafelyReallocateWithAllocatorTyped(v6, *(void *)(a1 + 168), v20, 1893177561, 0, 0);
                if (__CFOASafe) {
                  __CFSetLastAllocationEventName();
                }
                *CFStringRef v15 = v20;
              }
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
              CFAllocatorRef v16 = *(const void **)(v12 + 24);
            }
            memmove(*(void **)(a1 + 168), v16, *(void *)v12);
          }
        }
        else
        {
          *(void *)(a1 + 168) = *(void *)(v11 + 24);
          *(void *)(v11 + 16) = 0;
          *(void *)(v11 + 24) = 0;
          *(void *)(v11 + 32) = 0;
        }
      }
      else
      {
        int64_t v21 = *(void *)(v11 + 16);
        if (*(_DWORD *)(v21 + 8)) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v21 + 8), 1u, memory_order_relaxed);
        }
        *CFStringRef v15 = v21;
        uint64_t v22 = *(void *)(v11 + 24);
        if (*(_DWORD *)(v22 + 8)) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v22 + 8), 1u, memory_order_relaxed);
        }
        *(void *)(a1 + 168) = v22;
        uint64_t v23 = *(void *)(v11 + 32);
        if (v23)
        {
          if (*(_DWORD *)(v23 + 8)) {
            atomic_fetch_add_explicit((atomic_uint *volatile)(v23 + 8), 1u, memory_order_relaxed);
          }
          *(void *)(a1 + 176) = v23;
        }
      }
    }
    if (*(_DWORD *)(v12 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      __CFStorageDeallocateNode((const void *)a1, v12);
    }
  }
  else
  {
    __CFStorageClearRootNode(a1);
  }
}

uint64_t __CFStorageDeleteUnfrozen(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v44 = *(void *)off_1ECE0A5B0;
  uint64_t v6 = *(void *)a3 - a5;
  if (*(void *)a3 == a5) {
    return 0;
  }
  uint64_t v7 = a3;
  if (*(unsigned char *)(a3 + 13))
  {
    *(void *)a3 = v6;
    uint64_t v13 = *(void *)(a3 + 24);
    if (v13)
    {
      memmove((void *)(v13 + a4), (const void *)(v13 + a4 + a5), v6 - a4);
      if (a6)
      {
        uint64_t v14 = *(void *)v7;
        uint64_t v15 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v16 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v16 = v15 + 1;
        }
        if (v14 <= v16 >> 1)
        {
          uint64_t v36 = v14 + 63;
          BOOL v28 = v14 < -63;
          uint64_t v37 = v14 + 126;
          if (!v28) {
            uint64_t v37 = v36;
          }
          unint64_t v18 = v37 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v17 = (v14 + v15 - 1) & -(int)v15;
          if (a2[17] >= v17) {
            unint64_t v18 = v17;
          }
          else {
            unint64_t v18 = a2[17];
          }
        }
        if (v18 != *(void *)(v7 + 16))
        {
          unsigned int v38 = (pthread_mutex_t *)(a2 + 4);
          pthread_mutex_lock(v38);
          if (v18 != *(void *)(v7 + 16))
          {
            *(void *)(v7 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(v7 + 24), v18, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v7 + 16) = v18;
          }
          pthread_mutex_unlock(v38);
        }
      }
    }
    goto LABEL_61;
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint8x8_t v41 = (void *)(a3 + 16);
  long long v42 = 0uLL;
  uint64_t v43 = 0;
  uint64_t v21 = a4 + a5;
  for (uint64_t i = 16; i != 40; i += 8)
  {
    uint64_t v23 = *(void *)(v7 + i);
    if (!v23) {
      break;
    }
    uint64_t v24 = *(void *)v23;
    if (a4 <= v20) {
      uint64_t v25 = v20;
    }
    else {
      uint64_t v25 = a4;
    }
    uint64_t v26 = v24 + v20;
    if (v21 >= v24 + v20) {
      uint64_t v27 = v24 + v20;
    }
    else {
      uint64_t v27 = a4 + a5;
    }
    BOOL v28 = v27 <= v25;
    uint64_t v29 = v27 - v25;
    if (v28) {
      uint64_t v30 = 0;
    }
    else {
      uint64_t v30 = v29;
    }
    if (v28) {
      uint64_t v31 = 0;
    }
    else {
      uint64_t v31 = v25;
    }
    if (!v30)
    {
      if (*(_DWORD *)(v23 + 8)) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v23 + 8), 1u, memory_order_relaxed);
      }
LABEL_36:
      *((void *)&v42 + v19++) = v23;
      goto LABEL_37;
    }
    if (!*(unsigned char *)(v23 + 12)) {
      goto LABEL_31;
    }
    if (*(_DWORD *)(v23 + 8) == 1)
    {
      *(unsigned char *)(v23 + 12) = 0;
LABEL_31:
      uint64_t v32 = __CFStorageDeleteUnfrozen(a1, a2);
      goto LABEL_35;
    }
    uint64_t v32 = __CFStorageDeleteFrozen(a1, (uint64_t)a2, (uint64_t *)v23, v31 - v20, v30);
LABEL_35:
    uint64_t v23 = v32;
    if (v32) {
      goto LABEL_36;
    }
LABEL_37:
    uint64_t v20 = v26;
  }
  *(void *)v7 -= a5;
  uint64_t v33 = *(void *)(v7 + 16);
  if (*(_DWORD *)(v33 + 8)
    && atomic_fetch_add_explicit((atomic_uint *volatile)(v33 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    __CFStorageDeallocateNode(a2, v33);
  }
  uint64_t v34 = *(void *)(v7 + 24);
  if (v34
    && *(_DWORD *)(v34 + 8)
    && atomic_fetch_add_explicit((atomic_uint *volatile)(v34 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    __CFStorageDeallocateNode(a2, v34);
  }
  uint64_t v35 = *(void *)(v7 + 32);
  if (v35
    && *(_DWORD *)(v35 + 8)
    && atomic_fetch_add_explicit((atomic_uint *volatile)(v35 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    __CFStorageDeallocateNode(a2, v35);
  }
  *uint8x8_t v41 = 0;
  v41[1] = 0;
  uint64_t v41[2] = 0;
  if (v19 == 1) {
    return v42;
  }
  *(_OWORD *)uint8x8_t v41 = v42;
  uint64_t v41[2] = v43;
LABEL_61:
  int v39 = *(_DWORD *)(v7 + 8);
  if (v39) {
    *(_DWORD *)(v7 + 8) = v39 + 1;
  }
  return v7;
}

void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)source);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v4 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v5 = 72;
  if (context->version != 1) {
    uint64_t v5 = 0;
  }
  if (context->version) {
    size_t v6 = v5;
  }
  else {
    size_t v6 = 80;
  }

  memmove(context, (char *)source + 104, v6);
}

void CFAllocatorGetContext(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  CFAllocatorRef v3 = allocator;
  if (!allocator)
  {
    uint64_t v4 = _CFGetTSD(1u);
    if (v4) {
      CFAllocatorRef v3 = (CFAllocatorRef)v4;
    }
    else {
      CFAllocatorRef v3 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }
  unint64_t v5 = *(void *)v3 & ~(unint64_t)off_1ECE0A6D0;
  if ((*(void *)v3 & (unint64_t)off_1ECE0A6D0) != 0) {
    v5 |= *(void *)v3 & (unint64_t)off_1ECE0A6D0;
  }
  if (v5 == qword_1EB1DDDA0)
  {
    context->CFIndex version = 0;
    size_t v6 = (malloc_zone_t *)*((void *)v3 + 18);
    if (v6 == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
      size_t v6 = malloc_default_zone();
    }
    context->info = v6;
    *(_OWORD *)&context->CFAllocatorRetainCallBack retain = *(_OWORD *)((char *)v3 + 152);
    *(_OWORD *)&context->copyDescription = *(_OWORD *)((char *)v3 + 168);
    *(_OWORD *)&context->reCFAllocatorAllocateCallBack allocate = *(_OWORD *)((char *)v3 + 184);
    context->preferredSize = (CFAllocatorPreferredSizeCallBack)*((void *)v3 + 25);
  }
}

Boolean CFFileSecurityGetOwner(CFFileSecurityRef fileSec, uid_t *owner)
{
  return [(__CFFileSecurity *)fileSec getOwner:owner];
}

Boolean CFFileSecurityGetMode(CFFileSecurityRef fileSec, mode_t *mode)
{
  return [(__CFFileSecurity *)fileSec getMode:mode];
}

Boolean CFFileSecurityGetGroup(CFFileSecurityRef fileSec, gid_t *group)
{
  return [(__CFFileSecurity *)fileSec getGroup:group];
}

void CFBundleUnloadExecutable(CFBundleRef bundle)
{
}

uint64_t _CFPreferencesCopyKeyListWithContainer(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  uint64_t v9 = -[_CFXPreferences copyKeyListForIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void sub_182C978AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFURLCopySecurityScopeFromFileURL()
{
  return MEMORY[0x1F4114FF0]();
}

CFURLEnumeratorRef CFURLEnumeratorCreateForMountedVolumes(CFAllocatorRef alloc, CFURLEnumeratorOptions option, CFArrayRef propertyKeys)
{
  return (CFURLEnumeratorRef)MEMORY[0x1F4115008](alloc, option, propertyKeys);
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromMainExecutable()
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = 0;
  SectCFDataRef Data = (UInt8 *)getsegbyname("__TEXT");
  if (SectData)
  {
    SectCFDataRef Data = (UInt8 *)_CFBundleGetSectData("__TEXT", "__info_plist", v3);
    CFIndex v1 = LODWORD(v3[0]);
  }
  else
  {
    CFIndex v1 = 0;
  }
  return _CFBundleCreateInfoDictFromData(SectData, v1);
}

const section_64 *_CFBundleGetSectData(const char *a1, const char *a2, uint64_t *a3)
{
  uint32_t v6 = _dyld_image_count();
  uint64_t v7 = _NSGetMachExecuteHeader();
  if (!v6)
  {
LABEL_5:
    CFMutableSetRef result = 0;
    goto LABEL_6;
  }
  uint64_t v8 = (const mach_header *)v7;
  uint32_t v9 = 0;
  while (v8 != _dyld_get_image_header(v9))
  {
    if (v6 == ++v9) {
      goto LABEL_5;
    }
  }
  CFMutableSetRef result = getsectbynamefromheader_64((const mach_header_64 *)v8, a1, a2);
  if (!result)
  {
LABEL_6:
    uint64_t size = 0;
    if (!a3) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v12 = result;
  uint64_t addr = result->addr;
  CFMutableSetRef result = (const section_64 *)(_dyld_get_image_vmaddr_slide(v9) + addr);
  uint64_t size = v12->size;
  if (!a3) {
    return result;
  }
LABEL_7:
  *a3 = size;
  return result;
}

Boolean CFBundlePreflightExecutable(CFBundleRef bundle, CFErrorRef *error)
{
  v15[1] = *(void *)off_1ECE0A5B0;
  v15[0] = 0;
  if (error) {
    uint64_t v4 = (CFErrorRef *)v15;
  }
  else {
    uint64_t v4 = 0;
  }
  CFURLRef v5 = CFBundleCopyExecutableURL(bundle);
  os_unfair_lock_lock((os_unfair_lock_t)bundle + 24);
  if (!v5) {
    *((_DWORD *)bundle + 12) = 7;
  }
  _CFBundleDlfcnCheckLoaded((uint64_t)bundle);
  if (!*((_DWORD *)bundle + 12))
  {
    int v9 = _CFBundleGrokBinaryType(v5, v6);
    *((_DWORD *)bundle + 12) = v9;
    if (v9 != 1 && v9 != 6) {
      *((unsigned char *)bundle + 64) = 1;
    }
  }
  if (v5) {
    CFRelease(v5);
  }
  int v7 = *((unsigned __int8 *)bundle + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 24);
  if (v7)
  {
    LOBYTE(v8) = 1;
  }
  else
  {
    switch(*((_DWORD *)bundle + 12))
    {
      case 0:
      case 3:
      case 4:
      case 6:
      case 8:
        int v8 = _CFBundleDlfcnPreflight((unsigned __int8 *)bundle, v4);
        if (error) {
          goto LABEL_22;
        }
        break;
      case 7:
        if (!error) {
          goto LABEL_24;
        }
        CFAllocatorRef v10 = CFGetAllocator(bundle);
        uint64_t v11 = bundle;
        CFIndex v12 = 4;
        goto LABEL_21;
      default:
        if (error)
        {
          CFAllocatorRef v10 = CFGetAllocator(bundle);
          uint64_t v11 = bundle;
          CFIndex v12 = 3584;
LABEL_21:
          CFErrorRef ErrorDebug = _CFBundleCreateErrorDebug(v10, v11, v12, 0);
          int v8 = 0;
          v15[0] = ErrorDebug;
LABEL_22:
          if (!v8) {
            *CFErrorRef error = (CFErrorRef)v15[0];
          }
        }
        else
        {
LABEL_24:
          LOBYTE(v8) = 0;
        }
        break;
    }
  }
  return v8;
}

uint64_t _CFBundleGrokBinaryType(const __CFURL *a1, int32x4_t a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  if (a1) {
    uint64_t v2 = 6;
  }
  else {
    uint64_t v2 = 7;
  }
  int v8 = 0;
  if (_CFBundleGrokFileType(a1, 0, 0, &v8, 0, 0, 0, 0, a2, 0))
  {
    if (v8 == 4096) {
      int v3 = 1;
    }
    else {
      int v3 = v2;
    }
    if (v8 == 8) {
      unsigned int v4 = 3;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v8 == 6) {
      int v5 = 4;
    }
    else {
      int v5 = v2;
    }
    if (v8 == 2) {
      unsigned int v6 = 2;
    }
    else {
      unsigned int v6 = v5;
    }
    if (v8 <= 7) {
      return v6;
    }
    else {
      return v4;
    }
  }
  return v2;
}

CFDictionaryRef CFBundleCopyInfoDictionaryForURL(CFURLRef url)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  char v4 = 0;
  if (!_CFIsResourceAtURL(url, &v4)) {
    return 0;
  }
  if (v4) {
    return _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, 0);
  }
  return _CFBundleCopyInfoDictionaryInExecutable(url, v2);
}

BOOL _CFIsResourceAtURL(CFURLRef url, char *a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  unsigned __int8 v11 = 0;
  int v10 = 0;
  int v3 = _CFGetFileProperties((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, (char *)&v11, &v10, 0, 0, 0, 0);
  BOOL result = 0;
  if (!v3)
  {
    int v5 = v11;
    __int16 v6 = v10;
    if (a2)
    {
      if (v11) {
        BOOL v7 = (v10 & 0xF000) == 0x4000;
      }
      else {
        BOOL v7 = 0;
      }
      char v8 = v7;
      *a2 = v8;
    }
    return (v6 & 0x124) != 0 && v5 != 0;
  }
  return result;
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInExecutable(const __CFURL *a1, int32x4_t a2)
{
  v3[1] = *(CFMutableDictionaryRef *)off_1ECE0A5B0;
  v3[0] = 0;
  _CFBundleGrokFileType(a1, 0, 0, 0, 0, v3, 0, 0, a2, 0);
  return v3[0];
}

BOOL _CFBundleGrokFileType(const __CFURL *a1, const __CFData *a2, CFStringRef *a3, int *a4, const __CFArray **a5, CFMutableDictionaryRef *a6, char *a7, unsigned int *a8, int32x4_t a9, unsigned int *a10)
{
  uint64_t v149 = *(void *)off_1ECE0A5B0;
  char v145 = 0;
  if (a5) {
    *a5 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a10) {
    *a10 = 0;
  }
  if (a1
    && (int v17 = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026),
        a9.i64[1] = 0,
        memset(&valuePtr, 0, sizeof(valuePtr)),
        v17)
    && !stat((const char *)buffer, &valuePtr)
    && (valuePtr.st_mode & 0xF000) == 0x8000)
  {
    int v18 = open((const char *)buffer, 0, 511);
    int v142 = v18;
    if (v18 < 0)
    {
      off_t st_size = 0;
      int v141 = 0;
      ssize_t v20 = 0;
      uint64_t v19 = 0;
      if (!a2) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v19 = (unsigned __int16 *)v148;
      ssize_t v20 = read(v18, v148, 0x200uLL);
      int v141 = 1;
      off_t st_size = valuePtr.st_size;
      if (!a2) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    off_t st_size = 0;
    ssize_t v20 = 0;
    uint64_t v19 = 0;
    int v141 = 0;
    int v142 = -1;
    if (!a2) {
      goto LABEL_22;
    }
  }
  if (!v141)
  {
    CFIndex Length = CFDataGetLength(a2);
    CFDataRef v22 = a2;
    off_t v23 = Length;
    BytePtr = CFDataGetBytePtr(v22);
    uint64_t v19 = (unsigned __int16 *)BytePtr;
    if (!v23)
    {
      int v30 = 0;
      uint64_t v27 = "txt";
      if (BytePtr)
      {
        uint64_t v144 = 0;
        off_t st_size = 0;
        int v31 = v142;
        goto LABEL_517;
      }
LABEL_42:
      int v31 = v142;
      goto LABEL_43;
    }
    off_t st_size = v23;
    ssize_t v20 = v23;
  }
LABEL_22:
  if (!v19)
  {
    uint64_t v27 = 0;
    int v30 = 0;
    goto LABEL_42;
  }
  UniChar v139 = (_DWORD *)((char *)v19 + 257);
  __s1 = (char *)v19;
  uint64_t v144 = v20;
  if (v20 < 4)
  {
    uint64_t v27 = 0;
    int v30 = 0;
    goto LABEL_47;
  }
  unint64_t v25 = 0;
  int v26 = *(_DWORD *)v19;
  uint64_t v27 = (char *)&__CFBundleMagicNumbersArray[62] + 3;
  int v28 = bswap32(*(_DWORD *)v19);
  do
  {
    int v29 = __CFBundleMagicNumbersArray[v25];
    v27 += 5;
    if (v29 == v28) {
      break;
    }
    BOOL v108 = v25++ >= 0x3F;
  }
  while (!v108);
  if (v29 != v28)
  {
    uint64_t v27 = 0;
    int v30 = 0;
    int v31 = v142;
LABEL_30:
    uint64_t v19 = (unsigned __int16 *)__s1;
    goto LABEL_31;
  }
  if (v26 == -1095041334 && v20 >= 8 && *((_WORD *)__s1 + 2))
  {
    int v30 = 0;
    uint64_t v27 = "class";
    int v31 = v142;
LABEL_152:
    uint64_t v19 = (unsigned __int16 *)__s1;
    goto LABEL_290;
  }
  if (v20 < 32) {
    goto LABEL_226;
  }
  if (a3) {
    CFRange v63 = (BOOL *)&v145;
  }
  else {
    CFRange v63 = 0;
  }
  *(void *)buffer = 0;
  if (a3) {
    char v145 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a10) {
    *a10 = 0;
  }
  valuePtr.st_dev = 0;
  if (v26 > -17958195)
  {
    if (v26 > 561606473)
    {
      if (v26 == 561606474 || v26 == 1248819489)
      {
        int v30 = 4096;
        uint64_t v27 = "pef";
        int v31 = v142;
LABEL_516:
        uint64_t v19 = (unsigned __int16 *)__s1;
        goto LABEL_517;
      }
      goto LABEL_226;
    }
    if (v26 != -17958194)
    {
      if (v26 != -17958193) {
        goto LABEL_226;
      }
      CFRange v128 = v63;
      int v133 = -17958193;
      unsigned int v138 = *((_DWORD *)__s1 + 3);
      valuePtr.st_dev = *((_DWORD *)__s1 + 1);
      if (a5)
      {
        CFNumberRef v132 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
        *(void *)buffer = v132;
      }
      else
      {
        CFNumberRef v132 = 0;
      }
      if (a3 && v138 == 2) {
        BOOL *v128 = _CFBundleGrokX11FromFile(v142, (uint64_t)__s1, v144, 0, 0, 1);
      }
      if (a6) {
        *a6 = _CFBundleCreateInfoDictFromFile(v142, (UInt8 *)__s1, v144, 0, 0, 1);
      }
      if (a7 || a8 || a10)
      {
        CFIndex v126 = a10;
        int v110 = v142;
        uint64_t v111 = (uint64_t)__s1;
        uint64_t v112 = v144;
        int v113 = 0;
LABEL_476:
        int v114 = 1;
LABEL_498:
        _CFBundleGrokObjcImageInfoFromFile(v110, v111, v112, 0, v113, v114, a7, a8, v126);
      }
LABEL_499:
      int v30 = v138;
      CFNumberRef v115 = v132;
      if (a5 && v132)
      {
        *a5 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)buffer, 1, &kCFTypeArrayCallBacks);
        CFNumberRef v115 = *(CFNumberRef *)buffer;
      }
      if (v115) {
        CFRelease(v115);
      }
      int v26 = v133;
      goto LABEL_505;
    }
    UniChar v130 = v63;
    int v133 = -17958194;
    unsigned int v138 = *((_DWORD *)__s1 + 3);
    valuePtr.st_dev = *((_DWORD *)__s1 + 1);
    if (a5)
    {
      CFNumberRef v132 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
      *(void *)buffer = v132;
    }
    else
    {
      CFNumberRef v132 = 0;
    }
    if (a3 && v138 == 2) {
      *UniChar v130 = _CFBundleGrokX11FromFile(v142, (uint64_t)__s1, v144, 0, 0, 0);
    }
    if (a6) {
      *a6 = _CFBundleCreateInfoDictFromFile(v142, (UInt8 *)__s1, v144, 0, 0, 0);
    }
    if (!a7 && !a8 && !a10) {
      goto LABEL_499;
    }
    CFIndex v126 = a10;
    int v110 = v142;
    uint64_t v111 = (uint64_t)__s1;
    uint64_t v112 = v144;
    int v113 = 0;
LABEL_497:
    int v114 = 0;
    goto LABEL_498;
  }
  if (v26 > -822415875)
  {
    if (v26 != -822415874)
    {
      if (v26 != -805638658) {
        goto LABEL_226;
      }
      int v129 = v63;
      int v133 = -805638658;
      UniChar v136 = a3;
      unsigned int v73 = *((_DWORD *)__s1 + 3);
      valuePtr.st_dev = bswap32(*((_DWORD *)__s1 + 1));
      if (a5)
      {
        CFNumberRef v132 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
        *(void *)buffer = v132;
      }
      else
      {
        CFNumberRef v132 = 0;
      }
      if (v136 && v73 == 0x2000000) {
        *int v129 = _CFBundleGrokX11FromFile(v142, (uint64_t)__s1, v144, 0, 1, 1);
      }
      unsigned int v138 = bswap32(v73);
      if (a6) {
        *a6 = _CFBundleCreateInfoDictFromFile(v142, (UInt8 *)__s1, v144, 0, 1, 1);
      }
      a3 = v136;
      if (a7 || a8 || a10)
      {
        CFIndex v126 = a10;
        int v110 = v142;
        uint64_t v111 = (uint64_t)__s1;
        uint64_t v112 = v144;
        int v113 = 1;
        goto LABEL_476;
      }
      goto LABEL_499;
    }
    int64_t v131 = v63;
    int v133 = -822415874;
    CFRange v137 = a3;
    unsigned int v84 = *((_DWORD *)__s1 + 3);
    valuePtr.st_dev = bswap32(*((_DWORD *)__s1 + 1));
    if (a5)
    {
      CFNumberRef v132 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
      *(void *)buffer = v132;
    }
    else
    {
      CFNumberRef v132 = 0;
    }
    if (v137 && v84 == 0x2000000) {
      *int64_t v131 = _CFBundleGrokX11FromFile(v142, (uint64_t)__s1, v144, 0, 1, 0);
    }
    unsigned int v138 = bswap32(v84);
    if (a6) {
      *a6 = _CFBundleCreateInfoDictFromFile(v142, (UInt8 *)__s1, v144, 0, 1, 0);
    }
    a3 = v137;
    if (!a7 && !a8 && !a10) {
      goto LABEL_499;
    }
    CFIndex v126 = a10;
    int v110 = v142;
    uint64_t v111 = (uint64_t)__s1;
    uint64_t v112 = v144;
    int v113 = 1;
    goto LABEL_497;
  }
  if (v26 == -1095041334)
  {
    char v125 = a8;
    uint64_t v127 = a10;
    int v64 = v142;
    uint64_t v65 = (UInt8 *)__s1;
    uint64_t v66 = v20;
    int v67 = 1;
    goto LABEL_329;
  }
  if (v26 != -889275714)
  {
LABEL_226:
    int v30 = 0;
    int v31 = v142;
    goto LABEL_227;
  }
  char v125 = a8;
  uint64_t v127 = a10;
  int v64 = v142;
  uint64_t v65 = (UInt8 *)__s1;
  uint64_t v66 = v20;
  int v67 = 0;
LABEL_329:
  CFRange v81 = a6;
  int v82 = v26;
  int v83 = _CFBundleGrokMachTypeForFatFile(v64, v65, v66, v67, v63, a5, v81, a7, v125, v127);
  int v26 = v82;
  int v30 = v83;
LABEL_505:
  int v31 = v142;
  ssize_t v20 = v144;
  switch(v30)
  {
    case 1:
      uint64_t v27 = "o";
      goto LABEL_516;
    case 2:
      if (v145) {
        uint64_t v27 = "x11app";
      }
      else {
        uint64_t v27 = "tool";
      }
      int v30 = 2;
      goto LABEL_516;
    case 3:
    case 5:
    case 7:
      break;
    case 4:
      uint64_t v27 = "core";
      goto LABEL_516;
    case 6:
      uint64_t v27 = "dylib";
      goto LABEL_516;
    case 8:
      uint64_t v27 = "bundle";
      goto LABEL_516;
    default:
      int v31 = v142;
      if (v30 == 4096)
      {
        uint64_t v27 = "pef";
        goto LABEL_516;
      }
      ssize_t v20 = v144;
      break;
  }
LABEL_227:
  if (v28 <= 1112493394)
  {
    if (v28 > 626017349)
    {
      if (v28 > 808923190)
      {
        switch(v28)
        {
          case 808923191:
            if (v20 < 6) {
              goto LABEL_444;
            }
            uint64_t v19 = (unsigned __int16 *)__s1;
            if (__s1[4] != 48) {
              goto LABEL_442;
            }
            break;
          case 1031365221:
            if (v20 >= 12)
            {
              uint64_t v19 = (unsigned __int16 *)__s1;
              if (*((_DWORD *)__s1 + 1) == 544106855)
              {
                int v74 = *((_DWORD *)__s1 + 2);
                if (v74 == 1701734764) {
                  goto LABEL_290;
                }
                int v75 = 1953653104;
                goto LABEL_441;
              }
              goto LABEL_442;
            }
            goto LABEL_444;
          case 1094922544:
            uint64_t v19 = (unsigned __int16 *)__s1;
            if (v20 < 6 || __s1[4] != 49) {
              goto LABEL_442;
            }
            break;
          default:
            goto LABEL_152;
        }
        if (*((unsigned __int8 *)v19 + 5) - 48 >= 0xA) {
          goto LABEL_442;
        }
        goto LABEL_290;
      }
      switch(v28)
      {
        case 626017350:
          if (v20 >= 6)
          {
            uint64_t v19 = (unsigned __int16 *)__s1;
            if (__s1[4] != 45) {
              goto LABEL_442;
            }
            goto LABEL_290;
          }
          goto LABEL_444;
        case 675567430:
          if (v20 < 6) {
            goto LABEL_444;
          }
          uint64_t v19 = (unsigned __int16 *)__s1;
          int v74 = *((unsigned __int16 *)__s1 + 2);
          int v75 = 22048;
          break;
        case 807842421:
          uint64_t v19 = (unsigned __int16 *)__s1;
          if (v20 < 8) {
            goto LABEL_442;
          }
          int v74 = *((_DWORD *)__s1 + 1);
          int v75 = 298804878;
          break;
        default:
          goto LABEL_152;
      }
    }
    else
    {
      if (v28 < 0x10000)
      {
        if (v28 != -1991225785)
        {
          if (v28 != -791735840)
          {
            if (v28 != 12) {
              goto LABEL_152;
            }
            uint64_t v19 = (unsigned __int16 *)__s1;
            if (v20 >= 6)
            {
              int v74 = *((unsigned __int16 *)__s1 + 2);
              int v75 = 20586;
              goto LABEL_441;
            }
LABEL_442:
            uint64_t v27 = 0;
            goto LABEL_31;
          }
          if (v20 < 52) {
            goto LABEL_152;
          }
          uint64_t v19 = (unsigned __int16 *)__s1;
          CFIndex v94 = _CFBundleGrokFileTypeForOLEFile(v31, (uint64_t)__s1, v20, ((*((_DWORD *)__s1 + 12) << 9) + 512));
LABEL_430:
          uint64_t v27 = v94;
          goto LABEL_517;
        }
        if (v20 >= 8)
        {
          uint64_t v19 = (unsigned __int16 *)__s1;
          int v74 = *((_DWORD *)__s1 + 1);
          int v75 = 169478669;
          goto LABEL_441;
        }
LABEL_444:
        uint64_t v27 = 0;
        goto LABEL_30;
      }
      if (v28 == 0x10000)
      {
        if (v20 >= 6)
        {
          uint64_t v19 = (unsigned __int16 *)__s1;
          if (!__s1[4]) {
            goto LABEL_290;
          }
          goto LABEL_442;
        }
        goto LABEL_444;
      }
      if (v28 != 592859725)
      {
        if (v28 != 622940243) {
          goto LABEL_152;
        }
        uint64_t v19 = (unsigned __int16 *)__s1;
        if (v20 < 11) {
          goto LABEL_442;
        }
        int v79 = v26;
        if (!strncmp(__s1 + 4, "-Adobe-", 7uLL))
        {
          uint64_t v27 = "ps";
          goto LABEL_517;
        }
        ssize_t v20 = v144;
        if ((unint64_t)v144 < 0xE)
        {
          uint64_t v27 = 0;
        }
        else
        {
          if (!strncmp(__s1 + 4, "-AdobeFont", 0xAuLL))
          {
            uint64_t v27 = "pfa";
            goto LABEL_517;
          }
          uint64_t v27 = 0;
          ssize_t v20 = v144;
        }
        int v26 = v79;
        goto LABEL_31;
      }
      if (v20 < 6) {
        goto LABEL_444;
      }
      uint64_t v19 = (unsigned __int16 *)__s1;
      int v74 = *((unsigned __int16 *)__s1 + 2);
      int v75 = 8268;
    }
LABEL_441:
    if (v74 != v75) {
      goto LABEL_442;
    }
LABEL_290:
    if (!a3) {
      goto LABEL_56;
    }
    if (v27) {
      goto LABEL_518;
    }
    goto LABEL_292;
  }
  if (v28 <= 1400141157)
  {
    if (v28 > 1230262091)
    {
      if (v28 == 1230262092)
      {
        if (v20 < 8) {
          goto LABEL_444;
        }
        uint64_t v19 = (unsigned __int16 *)__s1;
        int v74 = *((_DWORD *)__s1 + 1);
        int v75 = 1397511241;
        goto LABEL_441;
      }
      if (v28 == 1347093252)
      {
        uint64_t v19 = (unsigned __int16 *)__s1;
        CFIndex v94 = _CFBundleGrokFileTypeForZipFile(v31, (uint64_t)__s1, v20, st_size);
        goto LABEL_430;
      }
      if (v28 != 1380533830) {
        goto LABEL_152;
      }
      if (v20 < 12) {
        goto LABEL_444;
      }
      uint64_t v19 = (unsigned __int16 *)__s1;
      unsigned int v80 = bswap32(*((_DWORD *)__s1 + 2));
      if (v80 == 1096173856)
      {
        uint64_t v27 = "avi";
        goto LABEL_517;
      }
      if (v80 == 1463899717)
      {
        uint64_t v27 = "wav";
        goto LABEL_517;
      }
    }
    else
    {
      if (v28 == 1112493395)
      {
        if (v20 < 8) {
          goto LABEL_444;
        }
        uint64_t v19 = (unsigned __int16 *)__s1;
        int v74 = *((_DWORD *)__s1 + 1);
        int v75 = 1701998452;
        goto LABEL_441;
      }
      if (v28 != 1179603533)
      {
        if (v28 != 1195984440) {
          goto LABEL_152;
        }
        uint64_t v19 = (unsigned __int16 *)__s1;
        if (v20 < 6) {
          goto LABEL_442;
        }
        int v74 = *((unsigned __int16 *)__s1 + 2);
        if (v74 == 24887) {
          goto LABEL_290;
        }
        int v75 = 24889;
        goto LABEL_441;
      }
      if (v20 < 12) {
        goto LABEL_444;
      }
      uint64_t v19 = (unsigned __int16 *)__s1;
      unsigned int v95 = bswap32(*((_DWORD *)__s1 + 2));
      if (v95 == 4278598)
      {
        uint64_t v27 = "aifc";
        goto LABEL_517;
      }
      if (v95 == 1095321158)
      {
        uint64_t v27 = "aiff";
        goto LABEL_517;
      }
    }
    uint64_t v27 = 0;
    ssize_t v20 = v144;
    goto LABEL_31;
  }
  if (v28 > 1734962543)
  {
    if (v28 != 1734962544)
    {
      if (v28 != 1920231012)
      {
        if (v28 != 2069656180) {
          goto LABEL_152;
        }
        uint64_t v19 = (unsigned __int16 *)__s1;
        if (v20 >= 6 && __s1[4] == 102) {
          goto LABEL_290;
        }
        goto LABEL_442;
      }
      if (v20 >= 8)
      {
        uint64_t v19 = (unsigned __int16 *)__s1;
        if (*((_DWORD *)__s1 + 1)) {
          goto LABEL_442;
        }
        goto LABEL_290;
      }
      goto LABEL_444;
    }
    if (v20 < 8) {
      goto LABEL_444;
    }
    uint64_t v19 = (unsigned __int16 *)__s1;
    int v74 = *((_DWORD *)__s1 + 1);
    int v75 = 1717794848;
    goto LABEL_441;
  }
  if (v28 == 1400141158)
  {
    if (v20 < 8) {
      goto LABEL_444;
    }
    uint64_t v19 = (unsigned __int16 *)__s1;
    int v74 = *((_DWORD *)__s1 + 1);
    int v75 = 544491878;
    goto LABEL_441;
  }
  if (v28 != 1650812777)
  {
    if (v28 != 1667327590) {
      goto LABEL_152;
    }
    uint64_t v19 = (unsigned __int16 *)__s1;
    if (v20 < 12 || __s1[4]) {
      goto LABEL_442;
    }
    int v74 = *((_DWORD *)__s1 + 2);
    int v75 = 1668506980;
    goto LABEL_441;
  }
  if (v20 < 76) {
    goto LABEL_444;
  }
  uint64_t v19 = (unsigned __int16 *)__s1;
  if (__s1[4] != 110
    || __s1[5] != 32
    || __s1[6] - 48 > 9
    || __s1[7] - 48 > 9)
  {
    goto LABEL_442;
  }
  int v96 = v26;
  if (__s1[8] - 48 > 9)
  {
    uint64_t v27 = 0;
    int v31 = v142;
  }
  else
  {
    if (__s1[9] != 32) {
      goto LABEL_589;
    }
    uint64_t v97 = 0;
    do
    {
      int v98 = __s1[v97 + 10];
      uint64_t v99 = v97 + 11;
      ++v97;
    }
    while (v98 != 10 && v99 < v144);
    uint64_t v101 = v97 + 9;
    unint64_t v102 = v98 == 10 ? v101 : 0;
    if (v102 >= 0xA && (unint64_t v103 = v102 + 62, (uint64_t)(v102 + 62) < v144) && __s1[v102 + 1] == 77 && __s1[v103] == 10)
    {
      char v104 = __s1 + 1;
      do
      {
        uint64_t v105 = v104[v102];
        if (v104[v102] < 0) {
          int v106 = __maskrune(v105, 0x40000uLL);
        }
        else {
          int v106 = *((_DWORD *)off_1ECE0A578 + v105 + 15) & 0x40000;
        }
        unint64_t v107 = v102 + 2;
        ++v102;
        if (v106) {
          BOOL v108 = v107 >= v103;
        }
        else {
          BOOL v108 = 1;
        }
      }
      while (!v108);
      if (v106) {
        uint64_t v27 = "uu";
      }
      else {
        uint64_t v27 = 0;
      }
    }
    else
    {
LABEL_589:
      uint64_t v27 = 0;
    }
    int v31 = v142;
    uint64_t v19 = (unsigned __int16 *)__s1;
  }
  ssize_t v20 = v144;
  int v26 = v96;
LABEL_31:
  if (!a3 || v27) {
    goto LABEL_47;
  }
  unsigned int v32 = *v19;
  if (v20 < 5) {
    goto LABEL_180;
  }
  unsigned int v33 = v32 >> 8;
  if (*((unsigned char *)v19 + 3) || *((unsigned char *)v19 + 4)) {
    goto LABEL_36;
  }
  if (v33)
  {
    if (v33 == 1 && (v19[1] & 0xF7) == 1) {
      goto LABEL_455;
    }
  }
  else if ((v19[1] & 0xF6) == 2)
  {
LABEL_455:
    uint64_t v27 = "tga";
    goto LABEL_518;
  }
LABEL_36:
  if ((unint64_t)v20 < 8)
  {
LABEL_180:
    BOOL v68 = 0;
    char v69 = 0;
    goto LABEL_181;
  }
  int v34 = *((_DWORD *)v19 + 1);
  uint64_t v27 = "mov";
  if (v34 <= 1952539752)
  {
    if (v34 == 1329745730)
    {
      uint64_t v27 = "cwk";
      goto LABEL_518;
    }
    if (v34 != 1668506729)
    {
      int v35 = 1701079415;
      goto LABEL_259;
    }
LABEL_327:
    uint64_t v27 = "qtif";
    goto LABEL_518;
  }
  if (v34 == 1952539753) {
    goto LABEL_327;
  }
  if (v34 == 1952539757) {
    goto LABEL_518;
  }
  int v35 = 1987014509;
LABEL_259:
  if (v34 == v35) {
    goto LABEL_518;
  }
  if (v26 == 1768714338
    && (unsigned __int16)*((_DWORD *)v19 + 1) == 29811
    && (HIWORD(v34) & 0xFE) - 48 <= 9u
    && HIBYTE(v34) - 48 <= 9u)
  {
    uint64_t v27 = "plist";
    if ((unint64_t)v20 < 0x18) {
      goto LABEL_518;
    }
    unint64_t v76 = 8;
    do
    {
      int v77 = strncmp((const char *)v19 + v76, "WebMainResource", 0xFuLL);
      if (!v77) {
        break;
      }
      if (v76 > 0x7E) {
        break;
      }
      uint64_t v78 = v76 + 17;
      ++v76;
    }
    while (v78 <= v144);
    if (!v77) {
      uint64_t v27 = "webarchive";
    }
    goto LABEL_517;
  }
  BOOL v68 = (unint64_t)v20 > 0xB;
  if (*v19 || (unint64_t)v20 < 0xC)
  {
    if (v32 == 19778 && (unint64_t)v20 >= 0x12)
    {
      int v118 = *(_DWORD *)(v19 + 7);
      uint64_t v27 = "bmp";
      if ((v118 - 12) <= 0x34 && ((1 << (v118 - 12)) & 0x10000010000001) != 0
        || v118 == 108
        || v118 == 124)
      {
        goto LABEL_518;
      }
      goto LABEL_372;
    }
  }
  else if (v34 == 1887007846)
  {
    signed int v109 = bswap32(*((_DWORD *)v19 + 2));
    if (v109 > 1769172785)
    {
      uint64_t v27 = "mp4";
      if ((v109 - 1836069937) < 2 || v109 == 1769172786 || v109 == 1769172845) {
        goto LABEL_518;
      }
    }
    else if (v109 > 1295275551)
    {
      if ((v109 - 1295275552) <= 0x30 && ((1 << (v109 - 32)) & 0x1010000000001) != 0)
      {
        uint64_t v27 = "m4v";
        goto LABEL_518;
      }
    }
    else
    {
      switch(v109)
      {
        case 1295270176:
          uint64_t v27 = "m4a";
          goto LABEL_518;
        case 1295270432:
          uint64_t v27 = "m4b";
          goto LABEL_518;
        case 1295274016:
          uint64_t v27 = "m4p";
          goto LABEL_518;
      }
    }
    if (HIWORD(v109) != 13159)
    {
      uint64_t v27 = 0;
LABEL_593:
      uint64_t v19 = (unsigned __int16 *)__s1;
LABEL_594:
      ssize_t v20 = v144;
LABEL_47:
      if (!a3 || v27) {
        goto LABEL_289;
      }
      CFIndex v134 = a4;
      int64_t v135 = a3;
      if (*(unsigned __int8 *)v19 == 239 && *((unsigned __int8 *)v19 + 1) == 187)
      {
        int v37 = *((unsigned __int8 *)v19 + 2);
        BOOL v38 = v37 != 191;
        if (v37 == 191) {
          uint64_t v39 = 3;
        }
        else {
          uint64_t v39 = 0;
        }
      }
      else
      {
        uint64_t v39 = 0;
        BOOL v38 = 1;
      }
      if (v20 >= 512) {
        uint64_t v41 = 512;
      }
      else {
        uint64_t v41 = v20;
      }
      BOOL v42 = 1;
      int v43 = 1;
      char v44 = 1;
      while (1)
      {
        if (v39 >= v41)
        {
          a4 = v134;
          a3 = v135;
LABEL_176:
          if (v44)
          {
            if (v20 >= 16)
            {
              int v31 = v142;
              if (strncmp((const char *)v19, "StartFontMetrics", 0x10uLL)) {
                goto LABEL_179;
              }
              uint64_t v27 = "afm";
              goto LABEL_289;
            }
            uint64_t v27 = "txt";
LABEL_198:
            int v31 = v142;
            goto LABEL_518;
          }
          uint64_t v27 = 0;
          if (v38 && v20 >= 512 && st_size >= 526)
          {
            if (v141)
            {
              int v31 = v142;
              if (lseek(v142, 512, 0) == 512 && read(v142, v148, 0x200uLL) >= 14)
              {
                if (*(_DWORD *)((char *)&v148[2] + 2) != -16641792)
                {
LABEL_292:
                  ssize_t v20 = v144;
                  goto LABEL_293;
                }
LABEL_287:
                uint64_t v27 = "pict";
                goto LABEL_518;
              }
            }
            else if ((unint64_t)v20 >= 0x20E)
            {
              int v31 = v142;
              if (*(_DWORD *)((char *)v139 + 265) != -16641792)
              {
LABEL_293:
                uint64_t v27 = 0;
                if (v20 < 512 || st_size < 512) {
                  goto LABEL_43;
                }
                goto LABEL_521;
              }
              goto LABEL_287;
            }
            uint64_t v27 = 0;
          }
LABEL_289:
          int v31 = v142;
          goto LABEL_290;
        }
        int v45 = (char *)v19 + v39;
        __darwin_ct_rune_t v46 = *v45;
        ssize_t v47 = v39 + 14;
        if (v42 && v46 == 60 && v47 <= v20)
        {
          int v49 = strncasecmp_l(v45 + 1, "!doctype html", 0xDuLL, 0);
          ssize_t v20 = v144;
          if (v49) {
            uint64_t v27 = 0;
          }
          else {
            uint64_t v27 = "html";
          }
          if (!v43) {
            goto LABEL_125;
          }
        }
        else
        {
          uint64_t v27 = 0;
          if (!v43) {
            goto LABEL_125;
          }
        }
        if (v46 != 60 || v47 > v20) {
          goto LABEL_125;
        }
        unsigned int v51 = v45 + 1;
        if (!strncasecmp_l(v51, "!doctype html", 0xDuLL, 0)
          || !strncasecmp_l(v51, "head", 4uLL, 0)
          || !strncasecmp_l(v51, "title", 5uLL, 0)
          || !strncasecmp_l(v51, "script", 6uLL, 0)
          || !strncasecmp_l(v51, "html", 4uLL, 0))
        {
          uint64_t v27 = "html";
LABEL_124:
          ssize_t v20 = v144;
          goto LABEL_125;
        }
        if (strncasecmp_l(v51, "?xml", 4uLL, 0)) {
          goto LABEL_124;
        }
        uint64_t v52 = v39 + 4;
        BOOL v53 = v27 != 0;
        ssize_t v20 = v144;
        if (!v27 && v39 <= 123)
        {
          for (ssize_t i = v39 + 24; i <= v20; ssize_t i = v57 + 21)
          {
            uint64_t v55 = &__s1[v52];
            if (__s1[v52] == 60)
            {
              int64_t v56 = v55 + 1;
              if (!strncasecmp_l(v55 + 1, "abiword", 7uLL, 0))
              {
                uint64_t v27 = "abw";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype svg", 0xCuLL, 0))
              {
                uint64_t v27 = "svg";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype rdf", 0xCuLL, 0))
              {
                uint64_t v27 = "rdf";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype x3d", 0xCuLL, 0))
              {
                uint64_t v27 = "x3d";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype html", 0xDuLL, 0))
              {
                uint64_t v27 = "html";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype posingfont", 0x13uLL, 0))
              {
                uint64_t v27 = "sfont";
                goto LABEL_110;
              }
              if (strncasecmp_l(v56, "!doctype plist", 0xEuLL, 0))
              {
                uint64_t v27 = 0;
LABEL_110:
                uint64_t v57 = v52;
                ssize_t v20 = v144;
                goto LABEL_111;
              }
              uint64_t v57 = v52 + 14;
              ssize_t v20 = v144;
              if (v52 + 30 <= v144)
              {
                do
                {
                  int v58 = strncmp(&__s1[v57], "WebMainResource", 0xFuLL);
                  ssize_t v20 = v144;
                  uint64_t v59 = v57 + 1;
                  if (!v58) {
                    break;
                  }
                  if (v57 > 254) {
                    break;
                  }
                  uint64_t v60 = v57 + 17;
                  ++v57;
                }
                while (v60 <= v144);
                if (v58) {
                  uint64_t v27 = "plist";
                }
                else {
                  uint64_t v27 = "webarchive";
                }
                uint64_t v57 = v59;
              }
              else
              {
                uint64_t v27 = "plist";
              }
            }
            else
            {
              uint64_t v27 = 0;
              uint64_t v57 = v52;
            }
LABEL_111:
            uint64_t v52 = v57 + 1;
            BOOL v53 = v27 != 0;
            if (v27 || v57 > 126) {
              break;
            }
          }
        }
        if (!v53) {
          uint64_t v27 = "xml";
        }
        uint64_t v39 = v52;
LABEL_125:
        if (v46) {
          BOOL v38 = 0;
        }
        uint64_t v19 = (unsigned __int16 *)__s1;
        if (v38 || v46 == 127)
        {
          char v44 = 0;
          if (v38) {
            goto LABEL_139;
          }
        }
        else
        {
          if (v46 > 31) {
            goto LABEL_137;
          }
          if (v46 < 0)
          {
            int v61 = __maskrune(v46, 0x4000uLL);
            ssize_t v20 = v144;
            if (v61) {
              goto LABEL_137;
            }
          }
          else if ((*((_DWORD *)off_1ECE0A578 + v46 + 15) & 0x4000) != 0)
          {
            goto LABEL_137;
          }
          char v44 = 0;
        }
LABEL_137:
        if ((v46 & 0x80000000) == 0)
        {
          if ((*((_DWORD *)off_1ECE0A578 + v46 + 15) & 0x4000) != 0) {
            goto LABEL_140;
          }
LABEL_139:
          int v43 = 0;
          goto LABEL_140;
        }
        int v62 = __maskrune(v46, 0x4000uLL);
        ssize_t v20 = v144;
        if (!v62) {
          goto LABEL_139;
        }
LABEL_140:
        BOOL v42 = v44 != 0;
        if (!v27)
        {
          ++v39;
          if (v38 | v44) {
            continue;
          }
        }
        a4 = v134;
        a3 = v135;
        if (v27) {
          goto LABEL_289;
        }
        goto LABEL_176;
      }
    }
    *(int8x8_t *)a9.i8 = vand_s8((int8x8_t)vdup_n_s32(v109), (int8x8_t)0xFDFF0000FFFELL);
    uint64_t v27 = "3gp";
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32(vzip1q_s32(a9, vdupq_lane_s32(*(int32x2_t *)a9.i8, 0)), (int32x4_t)xmmword_182EC7C60))) & 1) == 0&& (unsigned __int16)v109 != 26422)
    {
      if ((unsigned __int16)v109 == 12897) {
        uint64_t v27 = "3g2";
      }
      else {
        uint64_t v27 = 0;
      }
      goto LABEL_593;
    }
LABEL_595:
    int v31 = v142;
    uint64_t v19 = (unsigned __int16 *)__s1;
    goto LABEL_518;
  }
  if ((unint64_t)v20 < 0x14) {
    goto LABEL_579;
  }
  if (!strncmp((const char *)v19 + 6, "%!PS-AdobeFont", 0xEuLL))
  {
    uint64_t v27 = "pfb";
    goto LABEL_518;
  }
  ssize_t v20 = v144;
  if ((unint64_t)v144 < 0x28) {
    goto LABEL_578;
  }
  if (*(_DWORD *)(v19 + 17) == 1215195458 && v19[19] == 30821)
  {
    uint64_t v27 = "hqx";
    goto LABEL_518;
  }
  if ((unint64_t)v144 < 0x80)
  {
LABEL_578:
    BOOL v68 = 1;
LABEL_579:
    char v69 = 1;
    goto LABEL_181;
  }
  uint64_t v27 = "bin";
  if (*(_DWORD *)(v19 + 51) == 1313423981) {
    goto LABEL_198;
  }
  if (!*(unsigned char *)v19 && v33 - 1 <= 0x3E && !__s1[74] && !__s1[82] && (st_size & 0x7F) == 0)
  {
    uint64_t v19 = (unsigned __int16 *)__s1;
    unsigned int v119 = bswap32(*(_DWORD *)(__s1 + 83));
    unsigned int v120 = bswap32(*(_DWORD *)(__s1 + 87));
    unsigned int v121 = ((v119 + 127) >> 7) + ((v120 + 127) >> 7) + 1;
    if (st_size != v121 << 7 || v121 <= 1 || v120 >= 0x800000 || v119 >= 0x800000) {
      uint64_t v27 = 0;
    }
    goto LABEL_594;
  }
  if ((unint64_t)v144 >= 0x109 && *v139 == 1635021685)
  {
    uint64_t v27 = "tar";
    if (v139[1] == 2105458 || (unsigned __int16)v139[1] == 114) {
      goto LABEL_595;
    }
  }
  BOOL v68 = 1;
  char v69 = 1;
  int v31 = v142;
  uint64_t v19 = (unsigned __int16 *)__s1;
  ssize_t v20 = v144;
LABEL_181:
  int v70 = __rev16(v32);
  if (v70 > 18755)
  {
    if (v70 > 63233)
    {
      if (v70 > 65495)
      {
        if (v70 == 65496)
        {
          if (*((unsigned __int8 *)v19 + 2) == 255)
          {
            uint64_t v27 = "jpeg";
            goto LABEL_518;
          }
          goto LABEL_370;
        }
        int v72 = 65534;
      }
      else
      {
        if (v70 == 63234)
        {
          uint64_t v27 = "dvi";
          goto LABEL_518;
        }
        int v72 = 65279;
      }
      if (v70 == v72)
      {
        if (v68)
        {
          if (*(_DWORD *)v19 == -115712)
          {
            if (*((_DWORD *)v19 + 1) != 1744860160 || *((_DWORD *)v19 + 2) != 1828744192) {
              goto LABEL_179;
            }
          }
          else if (*(_DWORD *)v19 != 3997439 || *((_DWORD *)v19 + 1) != 7602280 || *((_DWORD *)v19 + 2) != 7077997)
          {
            goto LABEL_179;
          }
          uint64_t v27 = "html";
          goto LABEL_518;
        }
LABEL_179:
        uint64_t v27 = "txt";
        goto LABEL_518;
      }
      goto LABEL_370;
    }
    if (v70 == 18756)
    {
      if (*((unsigned char *)v19 + 2) == 51 && *((unsigned __int8 *)v19 + 3) < 0x20u)
      {
        uint64_t v27 = "mp3";
        goto LABEL_518;
      }
    }
    else if (v70 == 29127 || v70 == 51057)
    {
      uint64_t v27 = "cpio";
      goto LABEL_518;
    }
LABEL_370:
    int v93 = v19[1];
    uint64_t v27 = "tfm";
    if (v93 == 4352 || v93 == 4608) {
      goto LABEL_518;
    }
LABEL_372:
    uint64_t v27 = 0;
    goto LABEL_47;
  }
  if (v70 <= 8992)
  {
    switch(v70)
    {
      case 474:
        if (*((unsigned __int8 *)v19 + 2) <= 1u && *((unsigned __int8 *)v19 + 3) - 1 < 0xF)
        {
          uint64_t v27 = "sgi";
          goto LABEL_518;
        }
        break;
      case 8075:
        uint64_t v27 = "gz";
        goto LABEL_518;
      case 8093:
        uint64_t v27 = "Z";
        goto LABEL_518;
    }
    goto LABEL_370;
  }
  if (v70 > 17238)
  {
    if (v70 == 17239)
    {
      if (*((unsigned char *)v19 + 2) == 83)
      {
        uint64_t v27 = "swc";
        goto LABEL_518;
      }
    }
    else if (v70 == 18007 && *((unsigned char *)v19 + 2) == 83)
    {
      uint64_t v27 = "swf";
      goto LABEL_518;
    }
    goto LABEL_370;
  }
  if (v70 == 8993)
  {
    uint64_t v85 = 0;
    do
    {
      int v86 = *((unsigned __int8 *)v19 + v85 + 2);
      ssize_t v87 = v85 + 3;
      ++v85;
    }
    while (v86 != 10 && v87 < v20);
    uint64_t v27 = 0;
    if ((unint64_t)(v85 + 1) < 4 || v86 != 10) {
      goto LABEL_47;
    }
    do
    {
      if (*((unsigned char *)v19 + v85) == 47) {
        uint64_t v89 = v85;
      }
      else {
        uint64_t v89 = 0;
      }
      if ((unint64_t)(v85 + 1) < 4) {
        break;
      }
      --v85;
    }
    while (!v89);
    if (!v89) {
      goto LABEL_372;
    }
    char v90 = (char *)v19 + v89 + 1;
    if (!strncmp(v90, "perl", 4uLL))
    {
      uint64_t v27 = "pl";
    }
    else if (!strncmp(v90, "python", 6uLL))
    {
      uint64_t v27 = "py";
    }
    else if (!strncmp(v90, "ruby", 4uLL))
    {
      uint64_t v27 = "rb";
    }
    else
    {
      uint64_t v27 = "sh";
    }
LABEL_517:
    if (!a3) {
      goto LABEL_56;
    }
    goto LABEL_518;
  }
  if (v70 != 16986) {
    goto LABEL_370;
  }
  int v71 = *((unsigned __int8 *)v19 + 2);
  if ((v71 - 48) <= 9 && *((unsigned __int8 *)v19 + 3) - 48 < 0xA)
  {
    uint64_t v27 = "bz";
    goto LABEL_518;
  }
  if (v71 != 104) {
    goto LABEL_370;
  }
  char v91 = v69 ^ 1;
  if (*((unsigned __int8 *)v19 + 3) - 48 > 9) {
    char v91 = 1;
  }
  if (v91) {
    goto LABEL_370;
  }
  int v92 = *((_DWORD *)v19 + 1);
  uint64_t v27 = "bz2";
  if (v92 != 643383601 && v92 != 944075287) {
    goto LABEL_370;
  }
LABEL_518:
  if (strcmp(v27, "bz2")) {
    goto LABEL_43;
  }
  ssize_t v20 = v144;
  if (v144 < 512 || st_size <= 511) {
    goto LABEL_43;
  }
LABEL_521:
  if (!v141)
  {
    int v117 = (char *)v19 + v20;
    if (*(_DWORD *)((char *)v19 + v20 - 512) != 2037149547)
    {
      if (*((_DWORD *)v117 - 2) != 1634952291) {
        goto LABEL_43;
      }
      int v116 = *((_DWORD *)v117 - 1);
LABEL_530:
      if (v116 != 1919118949) {
        goto LABEL_43;
      }
    }
LABEL_531:
    uint64_t v27 = "dmg";
    goto LABEL_43;
  }
  if (lseek(v31, st_size - 512, 0) == st_size - 512 && read(v31, v148, 0x200uLL) >= 512)
  {
    if (v148[0] != 2037149547)
    {
      if (v148[126] != 1634952291) {
        goto LABEL_43;
      }
      int v116 = v148[127];
      goto LABEL_530;
    }
    goto LABEL_531;
  }
LABEL_43:
  if (a3)
  {
    if (v27) {
      CFStringRef v36 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v27, 0x8000100u, (CFAllocatorRef)&__kCFAllocatorNull);
    }
    else {
      CFStringRef v36 = 0;
    }
    *a3 = v36;
  }
LABEL_56:
  if (a4) {
    *a4 = v30;
  }
  if ((v31 & 0x80000000) == 0) {
    close(v31);
  }
  return v27 != 0;
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromFile(int a1, UInt8 *a2, unint64_t st_size, int a4, int a5, int a6)
{
  LODWORD(v8) = a4;
  uint64_t v66 = *(void *)off_1ECE0A5B0;
  memset(&v65, 0, sizeof(v65));
  if (a1 < 0 || fstat(a1, &v65))
  {
    uint64_t v58 = 0;
  }
  else
  {
    uint64_t v15 = (UInt8 *)mmap(0, v65.st_size, 1, 8194, a1, 0);
    if (v15 == (UInt8 *)-1)
    {
      uint64_t v58 = -1;
    }
    else
    {
      off_t st_size = v65.st_size;
      uint64_t v58 = (uint64_t)v15;
      a2 = v15;
    }
  }
  uint64_t v8 = v8;
  if (st_size <= (unint64_t)v8 + 32) {
    goto LABEL_65;
  }
  uint64_t v12 = (unsigned int *)&a2[v8];
  int v62 = a5;
  uint64_t v60 = v12;
  uint64_t v61 = v8;
  if (!a6)
  {
    unsigned int v16 = v12[4];
    if (a5)
    {
      unsigned int v16 = bswap32(v16);
      unsigned int v17 = bswap32(v12[5]);
    }
    else
    {
      unsigned int v17 = v12[5];
    }
    CFStringRef v36 = (int *)(v12 + 7);
    unint64_t v37 = (unint64_t)v12 + v17 + 28;
    uint64_t v57 = &a2[st_size];
    if (v37 <= (unint64_t)&a2[st_size]) {
      unint64_t v38 = v37;
    }
    else {
      unint64_t v38 = (unint64_t)&a2[st_size];
    }
    if (v16) {
      BOOL v39 = (unint64_t)v36 >= v38;
    }
    else {
      BOOL v39 = 1;
    }
    if (v39) {
      goto LABEL_65;
    }
    int v41 = 0;
    InfoDictFromCFDataRef Data = 0;
    unint64_t v42 = 28;
    unsigned int v64 = v16;
    while (1)
    {
      int v43 = *v36;
      if (a5) {
        break;
      }
      if (v43 == 1)
      {
        unsigned int v44 = v36[12];
        goto LABEL_74;
      }
      unsigned int v49 = v36[1];
LABEL_88:
      if (++v41 < v16)
      {
        v42 += v49;
        CFStringRef v36 = (int *)((char *)v12 + v42);
        if (v42 >= 0x1C && (unint64_t)v36 < v38) {
          continue;
        }
      }
      goto LABEL_66;
    }
    if (v43 == 0x1000000)
    {
      unsigned int v44 = bswap32(v36[12]);
LABEL_74:
      int v45 = 0;
      if (v44 && (unint64_t)v12 + v42 + 56 < v38)
      {
        uint64_t v46 = v8 + v42;
        unsigned int v47 = 1;
        while (1)
        {
          uint64_t v48 = &a2[v46];
          if (!strncmp((const char *)&a2[v46 + 56], "__info_plist", 0x10uLL)
            && !strncmp((const char *)v48 + 72, "__TEXT", 0x10uLL))
          {
            break;
          }
          if (v47 < v44)
          {
            v46 += 68;
            ++v47;
            if ((unint64_t)(v48 + 124) < v38) {
              continue;
            }
          }
          int v45 = 0;
          a5 = v62;
          uint64_t v12 = v60;
          uint64_t v8 = v61;
          goto LABEL_82;
        }
        unsigned int v51 = &a2[v46];
        CFIndex v52 = *(unsigned int *)&a2[v46 + 92];
        a5 = v62;
        uint64_t v12 = v60;
        if (v62)
        {
          CFIndex v52 = bswap32(v52);
          unsigned int v53 = bswap32(*((_DWORD *)v51 + 24));
        }
        else
        {
          unsigned int v53 = *((_DWORD *)v51 + 24);
        }
        uint64_t v8 = v61;
        unsigned int v16 = v64;
        int v54 = (UInt8 *)v60 + v53;
        if (a2 <= v54 && &v54[v52] <= v57) {
          InfoDictFromCFDataRef Data = _CFBundleCreateInfoDictFromData(v54, v52);
        }
        int v45 = 1;
      }
      else
      {
LABEL_82:
        unsigned int v16 = v64;
      }
      unsigned int v49 = v36[1];
      if (!a5)
      {
LABEL_87:
        if (v45) {
          goto LABEL_66;
        }
        goto LABEL_88;
      }
    }
    else
    {
      int v45 = 0;
      unsigned int v49 = v36[1];
    }
    unsigned int v49 = bswap32(v49);
    goto LABEL_87;
  }
  unsigned int v13 = v12[4];
  if (a5)
  {
    unsigned int v13 = bswap32(v13);
    unsigned int v14 = bswap32(v12[5]);
  }
  else
  {
    unsigned int v14 = v12[5];
  }
  int v18 = (int *)(v12 + 8);
  unint64_t v19 = (unint64_t)v12 + v14 + 32;
  int64_t v56 = &a2[st_size];
  if (v19 <= (unint64_t)&a2[st_size]) {
    unint64_t v20 = v19;
  }
  else {
    unint64_t v20 = (unint64_t)&a2[st_size];
  }
  if (v13) {
    BOOL v21 = (unint64_t)v18 >= v20;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    int v22 = 0;
    InfoDictFromCFDataRef Data = 0;
    unint64_t v23 = 32;
    unsigned int v63 = v13;
    while (1)
    {
      int v24 = *v18;
      if (a5) {
        break;
      }
      if (v24 == 25)
      {
        unsigned int v25 = v18[16];
        goto LABEL_26;
      }
      unsigned int v30 = v18[1];
LABEL_40:
      if (++v22 < v13)
      {
        v23 += v30;
        int v18 = (int *)((char *)v12 + v23);
        if (v23 >= 0x20 && (unint64_t)v18 < v20) {
          continue;
        }
      }
      goto LABEL_66;
    }
    if (v24 == 419430400)
    {
      unsigned int v25 = bswap32(v18[16]);
LABEL_26:
      int v26 = 0;
      if (v25 && (unint64_t)v12 + v23 + 72 < v20)
      {
        uint64_t v27 = v8 + v23;
        unsigned int v28 = 1;
        while (1)
        {
          int v29 = &a2[v27];
          if (!strncmp((const char *)&a2[v27 + 72], "__info_plist", 0x10uLL)
            && !strncmp((const char *)v29 + 88, "__TEXT", 0x10uLL))
          {
            break;
          }
          if (v28 < v25)
          {
            v27 += 80;
            ++v28;
            if ((unint64_t)(v29 + 152) < v20) {
              continue;
            }
          }
          int v26 = 0;
          a5 = v62;
          uint64_t v12 = v60;
          uint64_t v8 = v61;
          goto LABEL_34;
        }
        unsigned int v32 = &a2[v27];
        unint64_t v33 = *(void *)&a2[v27 + 112];
        a5 = v62;
        if (v62)
        {
          unint64_t v33 = bswap64(v33);
          unsigned int v34 = bswap32(*((_DWORD *)v32 + 30));
        }
        else
        {
          unsigned int v34 = *((_DWORD *)v32 + 30);
        }
        uint64_t v12 = v60;
        uint64_t v8 = v61;
        unsigned int v13 = v63;
        int v26 = 1;
        if (!HIDWORD(v33))
        {
          int v35 = (UInt8 *)v60 + v34;
          if (a2 <= v35 && &v35[v33] <= v56)
          {
            InfoDictFromCFDataRef Data = _CFBundleCreateInfoDictFromData(v35, v33);
            int v26 = 1;
          }
        }
      }
      else
      {
LABEL_34:
        unsigned int v13 = v63;
      }
      unsigned int v30 = v18[1];
      if (!a5)
      {
LABEL_39:
        if (v26) {
          goto LABEL_66;
        }
        goto LABEL_40;
      }
    }
    else
    {
      int v26 = 0;
      unsigned int v30 = v18[1];
    }
    unsigned int v30 = bswap32(v30);
    goto LABEL_39;
  }
LABEL_65:
  InfoDictFromCFDataRef Data = 0;
LABEL_66:
  if (v58) {
    munmap((void *)v58, v65.st_size);
  }
  return InfoDictFromData;
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromData(UInt8 *bytes, CFIndex length)
{
  CFMutableDictionaryRef Mutable = 0;
  if (bytes && length)
  {
    CFDataRef v3 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, length, (CFAllocatorRef)&__kCFAllocatorNull);
    if (v3)
    {
      CFDataRef v4 = v3;
      int v5 = (__CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, 1uLL, 0, 0);
      if (v5)
      {
        CFMutableDictionaryRef Mutable = v5;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(Mutable))
        {
          CFRelease(v4);
LABEL_10:
          _CFBundleInfoPlistProcessInfoDictionary(Mutable);
          return Mutable;
        }
        CFRelease(Mutable);
      }
      CFRelease(v4);
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable) {
      goto LABEL_10;
    }
  }
  return Mutable;
}

xpc_object_t createErrorReply(const char *a1, xpc_object_t original)
{
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (!reply) {
    xpc_object_t reply = xpc_dictionary_create(0, 0, 0);
  }
  populateErrorReply(a1, reply, 1u);
  return reply;
}

void populateErrorReply(const char *a1, xpc_object_t xdict, unsigned int a3)
{
  if (!xdict) {
    populateErrorReply_cold_1();
  }
  xpc_dictionary_set_value(xdict, "CFPreferencesPropertyList", 0);
  xpc_dictionary_set_string(xdict, "CFPreferencesErrorDescription", a1);

  xpc_dictionary_set_int64(xdict, "CFPreferencesErrorType", a3);
}

void sub_182C9A998(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void CFErrorSetCallBackBlockForDomain(const void *a1, const void *a2)
{
  if (!_CFErrorCallBackTable) {
    _CFErrorInitializeCallBackTable();
  }
  os_unfair_lock_lock_with_options();
  if (a2) {
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, a1, a2);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_CFErrorCallBackTable, a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
}

void _CFErrorInitializeCallBackTable()
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  v1.CFIndex version = kCFTypeDictionaryValueCallBacks.version;
  v1.copyDescription = kCFTypeDictionaryValueCallBacks.copyDescription;
  v1.equal = CFEqual;
  v1.CFAllocatorRetainCallBack retain = (CFDictionaryRetainCallBack)blockCopyValueCallBack;
  v1.CFArrayReleaseCallBack release = (CFDictionaryReleaseCallBack)blockReleaseValueCallBack;
  CFMutableDictionaryRef v0 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &v1);
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
    CFRelease(v0);
  }
  else
  {
    _CFErrorCallBackTable = (uint64_t)v0;
    CFURLRef value = off_1ECE0A5A0;
    uint64_t v3 = 3221225472;
    CFDataRef v4 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    int v5 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    __int16 v6 = _CFErrorPOSIXCallBack;
    CFDictionarySetValue(v0, @"NSPOSIXErrorDomain", &value);
    CFURLRef value = off_1ECE0A5A0;
    uint64_t v3 = 3221225472;
    CFDataRef v4 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    int v5 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    __int16 v6 = _CFErrorMachCallBack;
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, @"NSMachErrorDomain", &value);
    CFURLRef value = off_1ECE0A5A0;
    uint64_t v3 = 3221225472;
    CFDataRef v4 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    int v5 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    __int16 v6 = _CFErrorCocoaCallBack;
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, @"NSCocoaErrorDomain", &value);
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  }
}

void sub_182C9AEFC(_Unwind_Exception *a1)
{
}

uint64_t _allObjectsInvokeFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t __CFDateComponentsEqual(void *a1, void *a2)
{
  if (!a1) {
    __CFDateComponentsEqual_cold_1();
  }
  if (!a2) {
    __CFDateComponentsEqual_cold_2();
  }
  if (a1[4] != a2[4]
    || a1[5] != a2[5]
    || a1[15] != a2[15]
    || a1[6] != a2[6]
    || a1[8] != a2[8]
    || a1[9] != a2[9]
    || a1[10] != a2[10]
    || a1[11] != a2[11]
    || a1[19] != a2[19]
    || a1[12] != a2[12]
    || a1[17] != a2[17]
    || a1[20] != a2[20]
    || a1[16] != a2[16]
    || a1[18] != a2[18]
    || a1[13] != a2[13]
    || a1[14] != a2[14])
  {
    return 0;
  }
  uint64_t v2 = a1[7];
  if (v2)
  {
    if (v2 == 0x7FFFFFFFFFFFFFFFLL)
    {
      uint64_t v3 = a2[7];
      if (!v3) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v3 = a2[7];
    }
  }
  else
  {
    uint64_t v3 = a2[7];
    if (v3 == 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_29;
    }
  }
  if (v2 != v3) {
    return 0;
  }
LABEL_29:
  CFDataRef v4 = (const void *)a1[2];
  int v5 = (const void *)a2[2];
  if (v4)
  {
    if (!v5) {
      return 0;
    }
    uint64_t result = CFEqual(v4, v5);
    if (!result) {
      return result;
    }
  }
  else if (v5)
  {
    return 0;
  }
  uint64_t v7 = (const void *)a1[3];
  uint64_t v8 = (const void *)a2[3];
  if (!v7) {
    return !v8;
  }
  if (!v8) {
    return 0;
  }
  uint64_t result = CFEqual(v7, v8);
  if (result) {
    return 1;
  }
  return result;
}

void CFPreferencesFlushCaches()
{
}

uint64_t _CFURLCopyFileURL(unint64_t a1)
{
  unint64_t v1 = a1;
  if (CF_IS_OBJC(0x1DuLL, a1)) {
    unint64_t v1 = [(id)v1 _cfurl];
  }
  if (*(void *)(v1 + 32) || !_CFURLHasFileURLScheme(v1, 0)) {
    return 0;
  }
  CFDataRef v4 = (__objc2_class **)CFGetAllocator((CFTypeRef)v1);
  unsigned int v5 = *(_DWORD *)(v1 + 16) & 0x1FF;
  if (v5)
  {
    uint64_t v6 = 0;
    do
    {
      v6 += v5 & 1;
      BOOL v7 = v5 > 1;
      v5 >>= 1;
    }
    while (v7);
    size_t v8 = 16 * v6;
  }
  else
  {
    size_t v8 = 0;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v4, 0x1DuLL, (v8 & 0xFF0) + 40, 0);
  uint64_t v2 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 134217984;
    *(void *)(Instance + 16) = *(void *)(v1 + 16);
    int v10 = (const void *)atomic_load((unint64_t *)(v1 + 24));
    atomic_store((unint64_t)CFRetain(v10), (unint64_t *)(v2 + 24));
    *(void *)(v2 + 32) = 0;
    *(void *)(v2 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    if ((*(unsigned char *)(v2 + 18) & 1) == 0)
    {
      uint64_t v11 = *(void *)(v1 + 40);
      if (v11)
      {
        CFStringRef v12 = *(const __CFString **)(v11 + 8);
        if (v12)
        {
          _CFURLAllocateExtraDataspace((void *)v2);
          uint64_t v13 = *(void *)(v2 + 40);
          if (v13)
          {
            unsigned int v14 = *(const void **)(v13 + 8);
            if (v14) {
              CFRelease(v14);
            }
            CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)v2);
            CFStringRef Copy = CFStringCreateCopy(v15, v12);
            uint64_t v13 = *(void *)(v2 + 40);
            *(void *)(v13 + 8) = Copy;
          }
          uint64_t v17 = *(void *)(v1 + 40);
          if (v17)
          {
            int v18 = *(_DWORD *)(v17 + 16);
            if (v18 && !v13)
            {
              _CFURLAllocateExtraDataspace((void *)v2);
              uint64_t v13 = *(void *)(v2 + 40);
            }
          }
          else
          {
            int v18 = 0;
          }
          if (v13) {
            *(_DWORD *)(v13 + 16) = v18;
          }
        }
      }
    }
    if (atomic_load((unint64_t *)(v1 + 48))) {
      atomic_store(_FileCacheCreateShallowCopy(), (unint64_t *)(v2 + 48));
    }
    memcpy((void *)(v2 + 56), (const void *)(v1 + 56), v8);
  }
  return v2;
}

Class _CFRuntimeInitStaticInstance(Class result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  Class v8 = result;
  if (a2 > 0x47)
  {
    int v10 = a2 - 72;
    if ((int)a2 - 72 >= dword_1EB1DE0D8[0]) {
      goto LABEL_21;
    }
    uint64_t v11 = __CFRuntimeClassTables[v10 >> 6];
    if (!v11) {
      goto LABEL_21;
    }
    uint64_t v9 = (uint64_t *)(v11 + 8 * (v10 & 0x3F));
  }
  else
  {
    uint64_t v9 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + a2);
  }
  uint64_t v12 = *v9;
  if (!*v9)
  {
LABEL_21:
    __break(1u);
    return result;
  }
  if ((*(unsigned char *)v12 & 8) != 0) {
    return (Class)CFLog(3, @"*** Cannot initialize a static instance to a class (%s) with custom ref counting", a3, a4, a5, a6, a7, a8, *(void *)(v12 + 8));
  }
  atomic_store((a2 << 8) | 0x80, (unint64_t *)result + 1);
  atomic_fetch_and((atomic_ullong *volatile)result + 1, 0xFFFF000000FFFFFFLL);
  unint64_t v13 = atomic_load((unint64_t *)result + 1);
  atomic_fetch_or((atomic_ullong *volatile)result + 1, ((v13 & 0x83FF00) >> 16) & 0xFFFFFF000000);
  *(void *)uint64_t result = 0;
  if (a2 <= 0x47)
  {
    unsigned int v14 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
LABEL_14:
    uint64_t v17 = *v14;
    goto LABEL_16;
  }
  int v15 = a2 - 72;
  if ((int)a2 - 72 < dword_1EB1DE0D8[0])
  {
    uint64_t v16 = __CFRuntimeClassTables[(v15 >> 6) + 16];
    if (v16)
    {
      unsigned int v14 = (objc_class **)(v16 + 8 * (v15 & 0x3F));
      goto LABEL_14;
    }
  }
  uint64_t v17 = 0;
LABEL_16:
  uint64_t result = object_setClass(result, v17);
  int v18 = *(uint64_t (**)(Class))(v12 + 16);
  if (v18)
  {
    return (Class)v18(v8);
  }
  return result;
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef alloc, CFRange theRange)
{
  CFIndex length = theRange.length;
  int location = theRange.location;
  if ((unint64_t)theRange.location >> 16 > 0x10
    || theRange.length >= 1114113
    || theRange.location + theRange.length >= 0x110001uLL)
  {
    CFCharacterSetRef result = (CFCharacterSetRef)CFLog(3, @"%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)", theRange.length, v2, v3, v4, v5, v6, (__int16)"CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef, CFRange)");
    qword_1EC093AA8 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
    __break(1u);
  }
  else
  {
    CFCharacterSetRef result = (CFCharacterSetRef)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
    if (length)
    {
      if (result)
      {
        unint64_t v10 = atomic_load((unint64_t *)result + 1);
        unint64_t v11 = v10;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v11, v10 & 0xFFFFFFFFFFFFFFFELL);
          BOOL v12 = v11 == v10;
          unint64_t v10 = v11;
        }
        while (!v12);
        unint64_t v13 = atomic_load((unint64_t *)result + 1);
        unint64_t v14 = v13;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v14, v13 & 0xFFFFFFFFFFFFFF8FLL | 0x10);
          BOOL v12 = v14 == v13;
          unint64_t v13 = v14;
        }
        while (!v12);
        *((void *)result + 2) = 0;
        *((_DWORD *)result + 6) = location;
        *((void *)result + 4) = length;
        *((void *)result + 5) = 0;
      }
    }
    else if (result)
    {
      unint64_t v15 = atomic_load((unint64_t *)result + 1);
      unint64_t v16 = v15;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v16, v15 & 0xFFFFFFFFFFFFFFFELL);
        BOOL v12 = v16 == v15;
        unint64_t v15 = v16;
      }
      while (!v12);
      unint64_t v17 = atomic_load((unint64_t *)result + 1);
      unint64_t v18 = v17;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v18, v17 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
        BOOL v12 = v18 == v17;
        unint64_t v17 = v18;
      }
      while (!v12);
      *((void *)result + 5) = 0;
      *((void *)result + 2) = 0;
      *((void *)result + 3) = 0;
      unint64_t v19 = atomic_load((unint64_t *)result + 1);
      unint64_t v20 = v19;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)result + 1, &v20, v19 | 4);
        BOOL v12 = v20 == v19;
        unint64_t v19 = v20;
      }
      while (!v12);
    }
  }
  return result;
}

uint64_t CFBundleGetLocalizationInfoForLocalization(CFStringRef localeIdentifier, unsigned int *a2, unsigned int *a3, _DWORD *a4, _DWORD *a5)
{
  CFStringRef ValueAtIndex = localeIdentifier;
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  unsigned int v22 = -1;
  unsigned int v23 = -1;
  if (localeIdentifier) {
    goto LABEL_2;
  }
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (!MainBundle || (CFTypeRef v16 = _CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle)) == 0)
  {
    CFTypeRef v16 = _CFBundleCopyUserLanguages();
    if (!v16)
    {
LABEL_13:
      _CFBundleGetLanguageAndRegionCodes(&v23, &v22);
      unsigned int RegionCodeForLocalization = v22;
      unsigned int LanguageCodeForLocalization = v23;
      goto LABEL_14;
    }
  }
  if (CFArrayGetCount((CFArrayRef)v16) <= 0)
  {
    CFRelease(v16);
    goto LABEL_13;
  }
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v16, 0);
  CFRelease(v16);
  if (!ValueAtIndex) {
    goto LABEL_13;
  }
LABEL_2:
  __int16 v21 = -1;
  __int16 v20 = -1;
  __int16 v19 = 0;
  int v18 = 0;
  uint64_t result = CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(ValueAtIndex, &v21, &v20, &v19, &v18);
  if (result)
  {
    unsigned int LanguageCodeForLocalization = v21;
    unsigned int RegionCodeForLocalization = v20;
    int v13 = v19;
    int v14 = v18;
    if (!a2) {
      goto LABEL_28;
    }
LABEL_27:
    *a2 = LanguageCodeForLocalization;
    goto LABEL_28;
  }
  unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(ValueAtIndex);
  unsigned int v23 = LanguageCodeForLocalization;
  unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLocalization(ValueAtIndex);
  unsigned int v22 = RegionCodeForLocalization;
LABEL_14:
  if (LanguageCodeForLocalization < 0x99 || RegionCodeForLocalization == -1)
  {
    BOOL v17 = LanguageCodeForLocalization != -1;
    if (RegionCodeForLocalization == -1 && LanguageCodeForLocalization != -1)
    {
      unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
      BOOL v17 = 1;
    }
  }
  else
  {
    unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForRegionCode(RegionCodeForLocalization);
    BOOL v17 = LanguageCodeForLocalization != -1;
  }
  if (LanguageCodeForLocalization > 0x97)
  {
    int v13 = 0;
    int v14 = 0;
  }
  else
  {
    int v13 = __CFBundleScriptCodesArray[LanguageCodeForLocalization];
    int v14 = __CFBundleStringEncodingsArray[LanguageCodeForLocalization];
  }
  uint64_t result = RegionCodeForLocalization != -1 || v17;
  if (a2) {
    goto LABEL_27;
  }
LABEL_28:
  if (a3) {
    *a3 = RegionCodeForLocalization;
  }
  if (a4) {
    *a4 = v13;
  }
  if (a5) {
    *a5 = v14;
  }
  return result;
}

void _CFBundleGetLanguageAndRegionCodes(unsigned int *a1, unsigned int *a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (CFArrayRef v5 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle)) != 0
    || (CFArrayRef v5 = (const __CFArray *)_CFBundleCopyUserLanguages()) != 0)
  {
    if (CFArrayGetCount(v5) < 1)
    {
      unsigned int RegionCodeForLocalization = 0;
      unsigned int LanguageCodeForLocalization = 0;
    }
    else
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
      __int16 v10 = -1;
      __int16 v9 = -1;
      if (CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(ValueAtIndex, &v10, &v9, 0, 0))
      {
        unsigned int LanguageCodeForLocalization = v10;
        unsigned int RegionCodeForLocalization = v9;
      }
      else
      {
        unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(ValueAtIndex);
        unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLocalization(ValueAtIndex);
      }
      if (LanguageCodeForLocalization != -1 || RegionCodeForLocalization == -1)
      {
        if (LanguageCodeForLocalization != -1 && RegionCodeForLocalization == -1) {
          unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
        }
      }
      else
      {
        unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForRegionCode(RegionCodeForLocalization);
      }
    }
    CFRelease(v5);
    if (a1) {
      goto LABEL_18;
    }
  }
  else
  {
    unsigned int RegionCodeForLocalization = 0;
    unsigned int LanguageCodeForLocalization = 0;
    if (a1) {
LABEL_18:
    }
      *a1 = LanguageCodeForLocalization;
  }
  if (a2) {
    *a2 = RegionCodeForLocalization;
  }
}

uint64_t CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(CFStringRef localeIdentifier, _WORD *a2, _WORD *a3, _WORD *a4, _DWORD *a5)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  CanonicalLocaleIdentifierFromCFStringRef String = CFLocaleCreateCanonicalLocaleIdentifierFromString(0, localeIdentifier);
  if (CanonicalLocaleIdentifierFromString)
  {
    CFStringRef v10 = CanonicalLocaleIdentifierFromString;
    if (!CFStringGetCString(CanonicalLocaleIdentifierFromString, buffer, 257, 0x600u))
    {
LABEL_27:
      uint64_t v12 = 0;
      goto LABEL_28;
    }
    int v22 = 0;
    int Language = uloc_getLanguage();
    uint64_t v12 = 0;
    int v13 = Language;
    if (Language < 1)
    {
LABEL_28:
      CFRelease(v10);
      return v12;
    }
    __s[Language] = 0;
    __key[0] = __s;
    __key[1] = 0;
    int v22 = 0;
    int Script = uloc_getScript();
    BOOL v15 = Script != 0;
    if (!Script)
    {
      int v22 = 0;
      int Script = uloc_getCountry();
      if (!Script)
      {
        int v22 = 0;
        int Script = uloc_getVariant();
      }
    }
    if (Script >= 1)
    {
      v23[Script] = 0;
      __strlcat_chk();
      __strlcat_chk();
    }
    CFTypeRef v16 = bsearch(__key, &localeToLegacyCodes, 0xA3uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))CompareLocaleToLegacyCodesEntries);
    if (!v16)
    {
      if (a5) {
        BOOL v18 = v15;
      }
      else {
        BOOL v18 = 0;
      }
      int v19 = strlen(__s);
      uint64_t v12 = 0;
      if (v18 || v13 >= v19) {
        goto LABEL_28;
      }
      __s[v13] = 0;
      CFTypeRef v16 = bsearch(__key, &localeToLegacyCodes, 0xA3uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))CompareLocaleToLegacyCodesEntries);
      if (!v16) {
        goto LABEL_27;
      }
    }
    if (a2) {
      *a2 = *((_WORD *)v16 + 5);
    }
    if (a3) {
      *a3 = *((_WORD *)v16 + 4);
    }
    if (a5) {
      *a5 = *((_DWORD *)v16 + 3);
    }
    if (!a4)
    {
LABEL_19:
      uint64_t v12 = 1;
      goto LABEL_28;
    }
    int v17 = *((_DWORD *)v16 + 3);
    if (v17 <= 0x20)
    {
LABEL_18:
      *a4 = v17;
      goto LABEL_19;
    }
    if (v17 > 235)
    {
      if (v17 == 236)
      {
        LOWORD(v17) = 28;
        goto LABEL_18;
      }
      if (v17 == 252)
      {
        LOWORD(v17) = 32;
        goto LABEL_18;
      }
    }
    else
    {
      if (v17 == 140)
      {
        LOWORD(v17) = 4;
        goto LABEL_18;
      }
      if (v17 == 152)
      {
        LOWORD(v17) = 7;
        goto LABEL_18;
      }
    }
    LOWORD(v17) = 0;
    goto LABEL_18;
  }
  return 0;
}

void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFRunLoopMode mode)
{
  context[2] = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v4 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v4);
  }
  unsigned __int8 v5 = atomic_load(__CFMainThreadHasExited);
  if (v5)
  {
    BOOL v9 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v9 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v6 = atomic_load((unint64_t *)rl + 1);
  if ((v6 & 4) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (!CFSetContainsValue(*((CFSetRef *)rl + 76), mode))
    {
      CFSetRef v7 = (const __CFSet *)*((void *)rl + 77);
      if (v7)
      {
        CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        CFSetAddValue(*((CFMutableSetRef *)rl + 76), mode);
        if (Copy)
        {
          context[0] = rl;
          context[1] = mode;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemsToCommonMode, context);
          CFRelease(Copy);
        }
      }
      else
      {
        CFSetAddValue(*((CFMutableSetRef *)rl + 76), mode);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
}

CFAbsoluteTime CFRunLoopTimerGetNextFireDate(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (unint64_t)timer))
  {
    [(__CFRunLoopTimer *)timer _cffireTime];
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
    char v3 = atomic_load((unint64_t *)timer + 1);
    double v4 = 0.0;
    if ((v3 & 8) != 0) {
      double v4 = *((double *)timer + 13);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
    return v4;
  }
  return result;
}

void sub_182C9CA7C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t ___canDup_block_invoke()
{
  getpid();
  uint64_t result = sandbox_check();
  if (result) {
    _canDup_canDup = 1;
  }
  return result;
}

void CFBitVectorSetAllBits(CFMutableBitVectorRef bv, CFBit value)
{
  uint64_t v4 = *((void *)bv + 2);
  uint64_t v5 = v4 + 7;
  if (v4 >= 0) {
    uint64_t v5 = *((void *)bv + 2);
  }
  size_t v6 = v5 >> 3;
  uint64_t v7 = v4 - (v5 & 0xFFFFFFFFFFFFFFF8);
  if (v7 >= 1)
  {
    if (value) {
      Class v8 = __CFBitVectorOneBits;
    }
    else {
      Class v8 = __CFBitVectorZeroBits;
    }
    __CFBitVectorInternalMap((uint64_t)bv, v5 & 0xFFFFFFFFFFFFFFF8, v7, (uint64_t (*)(void, uint64_t, uint64_t))v8, 0);
  }
  BOOL v9 = (void *)*((void *)bv + 4);
  if (value) {
    int v10 = -1;
  }
  else {
    int v10 = 0;
  }

  memset(v9, v10, v6);
}

void CFBagRemoveAllValues(CFMutableBagRef theBag)
{
  char v8 = atomic_load((unint64_t *)theBag + 1);
  if ((v8 & 0x40) != 0) {
    CFLog(3, @"%s(): immutable collection %p given to mutating function", v1, v2, v3, v4, v5, v6, (__int16)"void CFBagRemoveAllValues(CFMutableBagRef)");
  }

  CFBasicHashRemoveAllValues((uint64_t)theBag);
}

CFTypeRef _CFCopySystemVersionPlatformDictionary()
{
  if (_CFCopySystemVersionPlatformDictionary_onceToken != -1) {
    dispatch_once(&_CFCopySystemVersionPlatformDictionary_onceToken, &__block_literal_global_26);
  }
  CFTypeRef result = (CFTypeRef)_CFCopySystemVersionPlatformDictionary_result;
  if (_CFCopySystemVersionPlatformDictionary_result)
  {
    return CFRetain(result);
  }
  return result;
}

CFIndex CFBitVectorGetLastIndexOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  CFIndex v3 = range.length + range.location - 1;
  while (range.length)
  {
    --range.length;
    int v4 = (*(unsigned __int8 *)(*((void *)bv + 4) + v3 / 8) >> (~(_BYTE)v3 & 7)) & 1;
    --v3;
    if (v4 == value) {
      return v3 + 1;
    }
  }
  return -1;
}

void CFStreamCreateBoundPair(CFAllocatorRef alloc, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream, CFIndex transferBufferSize)
{
  v10[1] = *(void ***)off_1ECE0A5B0;
  if (readStream) {
    *readStream = 0;
  }
  if (writeStream) {
    *writeStream = 0;
  }
  v10[0] = 0;
  if (cbInit(v10, transferBufferSize))
  {
    uint64_t Typed = CFAllocatorAllocateTyped(alloc, 176, 0x10600400B962E3FLL, 0);
    *(_OWORD *)uint64_t Typed = 0u;
    *(_OWORD *)(Typed + 16) = 0u;
    *(_OWORD *)(Typed + 32) = 0u;
    *(_OWORD *)(Typed + 48) = 0u;
    *(_OWORD *)(Typed + 64) = 0u;
    *(_OWORD *)(Typed + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0u;
    *(_OWORD *)(Typed + 96) = 0u;
    *(_OWORD *)(Typed + 112) = 0u;
    *(_OWORD *)(Typed + 128) = 0u;
    *(_OWORD *)(Typed + 144) = 0u;
    *(_OWORD *)(Typed + 16_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0u;
    *(void ***)(Typed + 96) = v10[0];
    *(void *)(Typed + 88) = alloc;
    pthread_mutex_init((pthread_mutex_t *)(Typed + 104), 0);
    *(void *)(Typed + 168) = transferBufferSize;
    *(void *)(Typed + 24) = @"_kCFBoundPairReadPrivateRunLoopMode";
    *(void *)(Typed + 8) = CFRunLoopSourceCreate(alloc, 0, &_emptySourceCtxt);
    *(void *)(Typed + 72) = @"_kCFBoundPairWritePrivateRunLoopMode";
    *(void *)(Typed + 56) = CFRunLoopSourceCreate(alloc, 0, &_emptySourceCtxt);
    CFReadStreamCreate((__objc2_class **)alloc, (uint64_t)&boundPairReadCallBacks, Typed);
    CFWriteStreamCreate((__objc2_class **)alloc, boundPairWriteCallBacks, Typed);
    BOOL v9 = *(__CFReadStream **)(Typed + 32);
    if (v9 && *(void *)(Typed + 80))
    {
      if (readStream) {
        *readStream = v9;
      }
      if (writeStream) {
        *writeStream = *(CFWriteStreamRef *)(Typed + 80);
      }
    }
    else
    {
      boundPairCommonFinalize(Typed);
    }
  }
}

void *CFReadStreamCreate(__objc2_class **a1, uint64_t a2, uint64_t a3)
{
  _CFStreamCreate(a1, 1);
  uint64_t v7 = v6;
  if (v6)
  {
    uint64_t Typed = CFAllocatorAllocateTyped(a1, 136, 0x108004021366E3ELL, 0);
    if (Typed)
    {
      uint64_t v9 = Typed;
      if (*(void *)a2 == 1)
      {
        int v13 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        if (v13)
        {
          a3 = v13(v7, a3);
          int v13 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        }
        uint64_t v7[5] = a3;
        uint64_t v14 = 1;
      }
      else
      {
        if (!*(void *)a2)
        {
          uint64_t v10 = *(void *)(a3 + 8);
          uint64_t v11 = *(uint64_t (**)(uint64_t))(a3 + 16);
          if (v11)
          {
            uint64_t v10 = v11(v10);
            uint64_t v11 = *(uint64_t (**)(uint64_t))(a3 + 16);
          }
          uint64_t v7[5] = v10;
          *(void *)uint64_t v9 = 0;
          *(void *)(v9 + 8) = v11;
          *(_OWORD *)(v9 + 16) = *(_OWORD *)(a3 + 24);
          *(_OWORD *)(v9 + 32) = *(_OWORD *)(a2 + 8);
          *(_OWORD *)(v9 + 48) = *(_OWORD *)(a2 + 24);
          *(void *)(v9 + 64) = *(void *)(a2 + 40);
          *(void *)(v9 + 72) = 0;
          *(void *)(v9 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
          *(_OWORD *)(v9 + 88) = *(_OWORD *)(a2 + 48);
          *(void *)(v9 + 104) = 0;
          *(void *)(v9 + 112) = 0;
          *(void *)(v9 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = *(void *)(a2 + 64);
          uint64_t v12 = (void *)(a2 + 72);
          goto LABEL_16;
        }
        int v13 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        if (v13)
        {
          a3 = v13(v7, a3);
          int v13 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        }
        uint64_t v7[5] = a3;
        uint64_t v14 = 2;
      }
      *(void *)uint64_t v9 = v14;
      *(void *)(v9 + 8) = v13;
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v9 + 32) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(v9 + 48) = *(_OWORD *)(a2 + 48);
      *(void *)(v9 + 64) = *(void *)(a2 + 64);
      *(void *)(v9 + 72) = 0;
      *(void *)(v9 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      *(_OWORD *)(v9 + 88) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(v9 + 104) = *(_OWORD *)(a2 + 88);
      *(void *)(v9 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = *(void *)(a2 + 104);
      uint64_t v12 = (void *)(a2 + 112);
LABEL_16:
      *(void *)(v9 + 128) = *v12;
      void v7[6] = v9;
      return v7;
    }
    CFRelease(v7);
    return 0;
  }
  return v7;
}

uint64_t cbInit(void ***a1, unsigned int a2)
{
  uint64_t result = (uint64_t)malloc_type_malloc(0x68uLL, 0x10500408CE9FA50uLL);
  *a1 = (void **)result;
  if (result)
  {
    **a1 = malloc_type_malloc(a2, 0x91765FA5uLL);
    uint64_t v5 = *a1;
    uint64_t v6 = **a1;
    if (!v6)
    {
LABEL_5:
      free(v5);
      uint64_t result = 0;
      *a1 = 0;
      return result;
    }
    v5[1] = v6;
    (*a1)[2] = **a1;
    uint64_t v7 = *a1;
    *((_DWORD *)v7 + 8) = a2;
    *((_DWORD *)v7 + 9) = a2;
    _OWORD v7[3] = (char *)*v7 + a2;
    if (pthread_mutex_init((pthread_mutex_t *)(*a1 + 5), 0))
    {
      free(**a1);
      **a1 = 0;
      (*a1)[1] = 0;
      (*a1)[2] = 0;
      char v8 = *a1;
      v8[3] = 0;
      v8[4] = 0;
      uint64_t v5 = *a1;
      goto LABEL_5;
    }
    return 1;
  }
  return result;
}

uint64_t boundPairReadCreate(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 32) = a1;
  }
  return a2;
}

void *CFWriteStreamCreate(__objc2_class **a1, uint64_t *a2, uint64_t a3)
{
  _CFStreamCreate(a1, 0);
  uint64_t v7 = v6;
  if (v6)
  {
    uint64_t Typed = (void *)CFAllocatorAllocateTyped(a1, 136, 0x108004021366E3ELL, 0);
    if (Typed)
    {
      uint64_t v9 = Typed;
      uint64_t v10 = *a2;
      if (*a2 == 1 || v10)
      {
        void *Typed = v10;
        uint64_t v14 = (uint64_t (*)(void *, uint64_t))a2[1];
        if (v14)
        {
          a3 = v14(v7, a3);
          uint64_t v14 = (uint64_t (*)(void *, uint64_t))a2[1];
        }
        uint64_t v7[5] = a3;
        v9[1] = v14;
        *((_OWORD *)v9 + 1) = *((_OWORD *)a2 + 1);
        *((_OWORD *)v9 + 2) = *((_OWORD *)a2 + 2);
        v9[7] = 0;
        v9[8] = 0;
        v9[6] = 0;
        *(_OWORD *)(v9 + 9) = *((_OWORD *)a2 + 3);
        *(_OWORD *)(v9 + 11) = *((_OWORD *)a2 + 4);
        *(_OWORD *)(v9 + 13) = *((_OWORD *)a2 + 5);
        v9[15] = a2[12];
        int v13 = a2 + 13;
      }
      else
      {
        uint64_t v11 = *(void *)(a3 + 8);
        uint64_t v12 = *(uint64_t (**)(uint64_t))(a3 + 16);
        if (v12)
        {
          uint64_t v11 = v12(v11);
          uint64_t v12 = *(uint64_t (**)(uint64_t))(a3 + 16);
        }
        uint64_t v7[5] = v11;
        *uint64_t v9 = 0;
        v9[1] = v12;
        *((_OWORD *)v9 + 1) = *(_OWORD *)(a3 + 24);
        *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 1);
        v9[7] = 0;
        v9[8] = 0;
        v9[6] = 0;
        *(_OWORD *)(v9 + 9) = *(_OWORD *)(a2 + 3);
        *(_OWORD *)(v9 + 11) = *(_OWORD *)(a2 + 5);
        v9[13] = 0;
        v9[14] = 0;
        v9[15] = a2[7];
        int v13 = a2 + 8;
      }
      v9[16] = *v13;
      void v7[6] = v9;
    }
    else
    {
      CFRelease(v7);
      return 0;
    }
  }
  return v7;
}

uint64_t boundPairWriteCreate(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = a1;
  }
  return a2;
}

CFArrayRef __CFDateFormatterCopySymbolsArray(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  int v21 = 0;
  uint64_t v6 = __cficu_udat_countSymbols(a1, a2);
  uint64_t v8 = (int)v6;
  if ((int)v6 <= (uint64_t)a3)
  {
    return CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  }
  else
  {
    uint64_t v20 = (uint64_t)&v20;
    uint64_t v9 = a3;
    CFIndex v10 = (int)v6 - (unint64_t)a3;
    MEMORY[0x1F4188790](v6, v7);
    int v13 = (const void **)((char *)&v20 - v12);
    if (v11 >= 0x200) {
      size_t v14 = 512;
    }
    else {
      size_t v14 = v11;
    }
    bzero((char *)&v20 - v12, v14);
    if (v10 >= 1)
    {
      BOOL v15 = v13;
      do
      {
        int v21 = 0;
        int Symbols = __cficu_udat_getSymbols(a1, a2, v9, v22, 768, &v21);
        if ((unint64_t)v10 > 0x300
          || v21 > 0
          || (int v17 = (void *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v22, Symbols)) == 0)
        {
          int v17 = (void *)CFRetain(@"<error>");
        }
        *v15++ = v17;
        ++v9;
      }
      while (v8 != v9);
    }
    for (CFArrayRef i = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v10, &kCFTypeArrayCallBacks); v10; --v10)
      CFRelease(v13[v10 - 1]);
    return i;
  }
}

uint64_t _CFDiscorporateMemoryDematerialize(uint64_t *a1)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v1 = *a1;
  int v4 = 1;
  if (!v1) {
    return 34;
  }
  MEMORY[0x185313090](*(unsigned int *)off_1ECE0A6C8, v1, 0, &v4);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

void _CFPrefsResetPreferences(uint64_t a1)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = _os_activity_create(&dword_182B90000, "Resetting CFPreferences/NSUserDefaults", (os_activity_t)off_1ECE0A638, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v2, &state);
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    CFIndex v3 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    CFIndex v3 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  [v3 resetPreferences:a1];

  os_activity_scope_leave(&state);
}

void sub_182C9DA50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
}

void sub_182C9DB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFString *_calculateUserNameForUID(uid_t a1)
{
  int v2 = 0;
  while (1)
  {
    *__error() = 0;
    CFIndex v3 = getpwuid(a1);
    if (*__error() != 4) {
      break;
    }
LABEL_6:
    if (v3) {
      goto LABEL_10;
    }
  }
  if (!*__error()) {
    goto LABEL_9;
  }
  if (v2 < 3)
  {
    ++v2;
    goto LABEL_6;
  }
  int v4 = _CFPrefsDaemonLog();
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
  {
LABEL_9:
    if (!v3) {
      return 0;
    }
    goto LABEL_10;
  }
  _calculateUserNameForUID_cold_1(a1, v4);
  if (!v3) {
    return 0;
  }
LABEL_10:
  if (v3->pw_name)
  {
    uint64_t v5 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3->pw_name, 0x8000100u);
    uint64_t v6 = _internString(v5);
    CFRelease(v5);
    return v6;
  }
  return 0;
}

uint64_t _CFURLComponentsGetURLPathAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 24);
}

__CFString *_CFStringSlowPathCopyBundleUnloadingProtectedString(__CFString *a1)
{
  v17[1] = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  if (!Length) {
    return &stru_1ECE10768;
  }
  CFIndex v3 = Length;
  uint64_t FastestEncoding = CFStringGetFastestEncoding(a1);
  uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)a1, FastestEncoding, 0, 1);
  if (!CStringPtrInternal)
  {
    CFStringRef CharactersPtr = CFStringGetCharactersPtr(a1);
    if (CharactersPtr)
    {
      uint64_t v6 = (int8x16_t *)CharactersPtr;
      int64_t v7 = 2 * v3;
      uint64_t v8 = 256;
      goto LABEL_8;
    }
    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v3, FastestEncoding);
    size_t v14 = MaximumSizeForEncoding;
    v17[0] = 0;
    if (MaximumSizeForEncoding < 0x101)
    {
      if (MaximumSizeForEncoding)
      {
        MEMORY[0x1F4188790](MaximumSizeForEncoding, v13);
        BOOL v15 = (int8x16_t *)((char *)v17 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v15, v14);
      }
      else
      {
        BOOL v15 = 0;
      }
    }
    else
    {
      BOOL v15 = (int8x16_t *)malloc_type_malloc(MaximumSizeForEncoding, 0x100004077774924uLL);
    }
    v19.int location = 0;
    v19.CFIndex length = v3;
    if (CFStringGetBytes(a1, v19, FastestEncoding, 0, 0, (UInt8 *)v15, v14, v17)) {
      ImmutableFunnel3 = (void *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v15, v17[0], FastestEncoding, 2u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
    }
    else {
      ImmutableFunnel3 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a1);
    }
    uint64_t v9 = ImmutableFunnel3;
    if (v14 >= 0x101) {
      free(v15);
    }
    return (__CFString *)v9;
  }
  uint64_t v6 = (int8x16_t *)CStringPtrInternal;
  int64_t v7 = v3;
  uint64_t v8 = FastestEncoding;
LABEL_8:

  return (__CFString *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v6, v7, v8, 2u, (__objc2_class **)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFIndex CFDictionaryGetCountOfValue(CFDictionaryRef theDict, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (unint64_t)theDict))
  {
    return [(__CFDictionary *)theDict countForObject:value];
  }
  else
  {
    return CFBasicHashGetCountOfValue((uint64_t)theDict, (unint64_t)value);
  }
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (unint64_t)stream))
  {
    return [(__CFWriteStream *)stream streamStatus];
  }
  else
  {
    return _CFStreamGetStatus((uint64_t)stream);
  }
}

uint64_t _CFDiscorporateMemoryMaterialize(uint64_t *a1)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  uint64_t v1 = *a1;
  int v5 = 0;
  if (v1)
  {
    char v2 = 0;
    LODWORD(result) = 34;
  }
  else
  {
    LODWORD(result) = MEMORY[0x185313090](*(unsigned int *)off_1ECE0A6C8, a1[2], 0, &v5);
    if (result)
    {
      char v2 = 0;
    }
    else
    {
      *a1 = a1[2];
      char v2 = 1;
    }
  }
  if ((v2 & (v5 == 2)) != 0) {
    return 2;
  }
  else {
    return result;
  }
}

CFArrayRef CFBundleCopyResourceURLsOfTypeForLocalization(CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  if (bundle) {
    return _CFBundleCopyFindResources((uint64_t)bundle, 0, (uint64_t)subDirName, 0, resourceType, subDirName, localizationName, 1, 1, 0);
  }

  return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
}

void sub_182C9E500(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

void sub_182C9E9B8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void CFTimeZoneResetSystem(void)
{
  CFMutableDictionaryRef v0 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone resetSystemTimeZone];

  _CFAutoreleasePoolPop(v0);
}

unint64_t __NSOrderedSetGetIndexPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v51 = *(void *)off_1ECE0A5B0;
  if (![a1 count]) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((a3 & 0x1000000000000000) != 0)
  {
    uint64_t v7 = [a4 firstIndex];
    unint64_t v37 = [a4 lastIndex];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v37 = [a1 count] - 1;
  }
  unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL && v37 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3)
    {
      uint64_t v9 = __CFActiveProcessorCount();
      if (v9 < 2) {
        a3 &= ~1uLL;
      }
    }
    else
    {
      uint64_t v9 = 1;
    }
    if ((a3 & 3) != 0)
    {
      unint64_t v10 = (v37 - v7 + 1) / v9 / v9;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000) {
          unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
        }
        else {
          unint64_t v11 = 4096;
        }
      }
      else
      {
        unint64_t v11 = 16;
      }
      unint64_t v21 = v11 + v37 - v7;
      size_t v22 = v21 / v11;
      if (a3)
      {
        v44[0] = 0;
        v44[1] = (unint64_t)v44;
        unsigned __int16 v44[2] = 0x2020000000;
        char v45 = 0;
        uint64_t v40 = 0;
        int v41 = &v40;
        uint64_t v42 = 0x2020000000;
        uint64_t v43 = 0x7FFFFFFFFFFFFFFFLL;
        block[0] = off_1ECE0A5A0;
        block[1] = 3221225472;
        block[2] = ____NSOrderedSetGetIndexPassingTest_block_invoke;
        block[3] = &unk_1ECDB0760;
        void block[10] = v11;
        block[11] = v37;
        block[12] = a3;
        void block[4] = a1;
        void block[5] = a4;
        block[6] = a2;
        void block[7] = v44;
        void block[8] = &v40;
        void block[9] = v7;
        dispatch_apply(v22, 0, block);
        unint64_t v8 = atomic_load((unint64_t *)v41 + 3);
        _Block_object_dispose(&v40, 8);
        _Block_object_dispose(v44, 8);
      }
      else
      {
        uint64_t v36 = a2;
        v44[0] = 0x7FFFFFFFFFFFFFFFLL;
        if (v11 <= v21)
        {
          unint64_t v23 = v7;
          uint64_t v24 = 0;
          unint64_t v25 = v11 - 1;
          if (v22 <= 1) {
            uint64_t v26 = 1;
          }
          else {
            uint64_t v26 = v21 / v11;
          }
          uint64_t v27 = v26 - 1;
          unint64_t v28 = v23;
          unint64_t v29 = v37;
          do
          {
            uint64_t v30 = v27;
            if ((a3 & 2) != 0)
            {
              if (v25 >= v29 - v23) {
                unint64_t v32 = v23;
              }
              else {
                unint64_t v32 = 1 - v11 + v29;
              }
              unint64_t v31 = v29;
            }
            else
            {
              if (v25 >= v29 - v23) {
                unint64_t v31 = v37;
              }
              else {
                unint64_t v31 = v25 + v24 * v11 + v23;
              }
              unint64_t v32 = v28;
            }
            if (__NSOrderedSetChunkIterate(a1, a3, v32, v31, a4, v36, v44, 0, 0)) {
              break;
            }
            ++v24;
            uint64_t v27 = v30 - 1;
            v29 -= v11;
            v28 += v11;
          }
          while (v30);
        }
        return atomic_load(v44);
      }
      return v8;
    }
    uint64_t v12 = (void *)_CFAutoreleasePoolPush();
    LOBYTE(v44[0]) = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    uint64_t v13 = [a1 countByEnumeratingWithState:&v47 objects:v46 count:16];
    if (!v13) {
      goto LABEL_56;
    }
    uint64_t v14 = v13;
    uint64_t context = v12;
    unint64_t v35 = v7;
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = *(void *)v48;
LABEL_17:
    uint64_t v18 = 0;
    while (1)
    {
      if (*(void *)v48 != v17) {
        objc_enumerationMutation(a1);
      }
      unint64_t v19 = v16 + v18;
      uint64_t v20 = *(void *)(*((void *)&v47 + 1) + 8 * v18);
      if ((a3 & 0x1000000000000000) == 0
        || v35 <= v19 && v19 <= v37 && [a4 containsIndex:v16 + v18])
      {
        if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(a2 + 16))(a2, v20, v16 + v18, v44))
        {
          unint64_t v8 = v16 + v18;
LABEL_55:
          uint64_t v12 = context;
LABEL_56:
          _CFAutoreleasePoolPop(v12);
          return v8;
        }
        if (LOBYTE(v44[0])) {
          goto LABEL_31;
        }
        if (v15 >= 0x3FF)
        {
          _CFAutoreleasePoolPop(context);
          uint64_t context = (void *)_CFAutoreleasePoolPush();
          unint64_t v15 = 0;
        }
        else
        {
          ++v15;
        }
      }
      if (v14 == ++v18)
      {
        uint64_t v14 = [a1 countByEnumeratingWithState:&v47 objects:v46 count:16];
        v16 += v18;
        if (v14) {
          goto LABEL_17;
        }
LABEL_31:
        unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_55;
      }
    }
  }
  return v8;
}

uint64_t _CFLocaleCopyPreferred()
{
  return +[NSLocale _newLocaleAsIfCurrent:0 overrides:0 disableBundleMatching:1];
}

id *(*_CFDoExceptionOperation(uint64_t a1, uint64_t (*exception)(void)))(id *a1)
{
  char v2 = __exceptionPreprocess;
  if (a1 <= 139)
  {
    if (a1 == 100)
    {
      return (id *(*)(id *))__uncaughtExceptionHandler;
    }
    else
    {
      if (a1 != 101) {
        return 0;
      }
      char v2 = 0;
      __uncaughtExceptionHandler = exception;
    }
  }
  else if (a1 != 160)
  {
    if (a1 == 161)
    {
      if (exception) {
        CFIndex v3 = (id (__cdecl *)(id))exception;
      }
      else {
        CFIndex v3 = (id (__cdecl *)(id))__exceptionPreprocess;
      }
      objc_setExceptionPreprocessor(v3);
    }
    else if (a1 == 140)
    {
      objc_exception_throw(exception);
    }
    return 0;
  }
  return v2;
}

void _CFPreferencesSetBackupDisabled(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    uint64_t v10 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  id v11 = (id)v10;
  -[_CFXPreferences setBackupDisabled:identifier:user:host:container:](v10, a5 != 0, a1, a2, a3, a4);
}

CFStringEncoding CFStringConvertIANACharSetNameToEncoding(CFStringRef theString)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  CFStringEncoding v2 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(theString);
    CFStringEncoding v2 = __CFDefaultEightBitStringEncoding;
  }
  CStringPtr = CFStringGetCStringPtr(theString, v2);
  if (!CStringPtr)
  {
    CFStringEncoding v4 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(0);
      CFStringEncoding v4 = __CFDefaultEightBitStringEncoding;
    }
    CStringPtr = buffer;
    if (!CFStringGetCString(theString, buffer, 100, v4)) {
      return -1;
    }
  }
  CFStringEncoding result = __CFStringEncodingGetFromCanonicalName(CStringPtr);
  if (result == -1)
  {
    CFStringEncoding result = __CFStringEncodingGetFromICUName(CStringPtr);
    if (result == -1)
    {
      if (!strncasecmp(CStringPtr, "ms950", 5uLL)) {
        return __CFStringEncodingGetFromCanonicalName("cp950");
      }
      return -1;
    }
  }
  return result;
}

uint64_t __CFStringEncodingGetFromCanonicalName(const char *a1)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  if (!strncasecmp_l(a1, "iso-8859-", 9uLL, 0))
  {
    int v7 = strtol(a1 + 9, 0, 10);
    if ((v7 - 17) < 0xFFFFFFF0) {
      return 0xFFFFFFFFLL;
    }
    else {
      return (v7 + 512);
    }
  }
  if (strncasecmp_l(a1, "cp", 2uLL, 0))
  {
    if (strncasecmp_l(a1, "windows-", 8uLL, 0))
    {
      os_unfair_lock_lock_with_options();
      if (!__CFStringEncodingGetFromCanonicalName_mappingTable)
      {
        CFDictionaryKeyCallBacks v10 = *(CFDictionaryKeyCallBacks *)byte_1ECE102F8;
        __CFStringEncodingGetFromCanonicalName_mappingTable = (uint64_t)CFDictionaryCreateMutable(0, 0, &v10, 0);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-7", (const void *)0x4000100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-8", (const void *)0x8000100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-16", (const void *)0x100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-16be", (const void *)0x10000100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-16le", (const void *)0x14000100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-32", (const void *)0xC000100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-32be", (const void *)0x18000100);
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-32le", (const void *)0x1C000100);
        for (uint64_t i = 0; i != 98; ++i)
        {
          CFIndex v3 = __CFCanonicalNameList[i];
          if (v3) {
            CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, v3, (const void *)(unsigned __int16)__CFKnownEncodingList[i]);
          }
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringEncodingGetFromCanonicalName_lock);
      uint64_t result = strncasecmp_l(a1, "macintosh", 9uLL, 0);
      if (result)
      {
        CFDictionaryRef v5 = (const __CFDictionary *)__CFStringEncodingGetFromCanonicalName_mappingTable;
        if (strncasecmp_l(a1, "x-mac-", 6uLL, 0)) {
          uint64_t v6 = 0;
        }
        else {
          uint64_t v6 = 6;
        }
        LODWORD(result) = CFDictionaryGetValue(v5, &a1[v6]);
        if (result) {
          return result;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
      return result;
    }
    unint64_t v8 = a1 + 8;
  }
  else
  {
    unint64_t v8 = a1 + 2;
  }
  int v9 = (unsigned __int16)strtol(v8, 0, 10);

  return __CFStringEncodingGetFromWindowsCodePage(v9);
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex(theString, theIndex, 2);
  result.CFIndex length = v3;
  result.int location = RangeOfCharacterClusterAtIndex;
  return result;
}

void _CFBundleSetupXPCBootstrap(void *a1)
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFArrayRef v3 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle);
    if (v3)
    {
      CFArrayRef v4 = v3;
      _CFBundleSetupXPCBootstrapWithLanguages(a1, v3);
      CFRelease(v4);
    }
  }
}

void _CFBundleSetupXPCBootstrapWithLanguages(void *a1, const __CFArray *a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (CFArrayGetCount(a2) >= 1)
  {
    CFIndex v5 = 0;
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v5);
      if (CFStringGetCString(ValueAtIndex, buffer, 128, 0x8000100u))
      {
        xpc_object_t v7 = xpc_string_create(buffer);
        if (v7)
        {
          unint64_t v8 = v7;
          xpc_array_append_value(v4, v7);
          xpc_release(v8);
        }
      }
      ++v5;
    }
    while (v5 < CFArrayGetCount(a2));
  }
  if (xpc_array_get_count(v4))
  {
    xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_value(v9, "MainBundleLanguages", v4);
    xpc_dictionary_set_value(a1, "_NSBundleEntry", v9);
    xpc_release(v9);
  }
  xpc_release(v4);
}

CFURLRef CFBundleCopySupportFilesDirectoryURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFURLRef v3 = (const __CFURL *)*((void *)bundle + 2);
  if (!v3) {
    return 0;
  }
  unsigned int v4 = *((unsigned __int8 *)bundle + 53);
  if (v4 <= 0xB)
  {
    if (v4 == 1)
    {
      CFStringRef v5 = @"Support%20Files/";
      goto LABEL_12;
    }
    if (v4 == 2)
    {
      CFStringRef v5 = @"Contents/";
LABEL_12:
      return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v3);
    }
    goto LABEL_19;
  }
  if (v4 == 12)
  {
    CFStringRef v7 = @"WrappedBundle/Contents/";
  }
  else
  {
    if (v4 != 13)
    {
LABEL_19:
      unint64_t v8 = (const void *)*((void *)bundle + 2);
      return (CFURLRef)CFRetain(v8);
    }
    CFStringRef v7 = @"WrappedBundle/";
  }

  return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v7, v3);
}

void CFStringGetLineBounds(CFStringRef theString, CFRange range, CFIndex *lineBeginIndex, CFIndex *lineEndIndex, CFIndex *contentsEndIndex)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    -[__CFString getLineStart:end:contentsEnd:forRange:]((id)theString, "getLineStart:end:contentsEnd:forRange:", lineBeginIndex, lineEndIndex, contentsEndIndex, location, length);
  }
  else
  {
    __CFStringGetLineOrParagraphBounds(theString, location, length, lineBeginIndex, (unint64_t)lineEndIndex, contentsEndIndex, 1);
  }
}

CFDictionaryRef CFBundleCopyLocalizedStringTableForLocalization(unint64_t *a1, __CFString *a2, const void *a3)
{
  v10[1] = *(const void **)off_1ECE0A5B0;
  v10[0] = a3;
  __CFCheckCFInfoPACSignature((uint64_t)a1);
  unint64_t v6 = _CFGetNonObjCTypeID(a1);
  if (v6 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v6);
  }
  CFBundleAllowMixedLocalizations();
  if (!a2 || CFEqual(a2, &stru_1ECE10768)) {
    a2 = @"Localizable";
  }
  if (!a3)
  {
    CFDictionaryRef v8 = _copyStringTable((uint64_t)a1, a2, 0, 0, 0, 0);
    if (v8) {
      return v8;
    }
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  CFArrayRef v7 = CFArrayCreate(0, v10, 1, &kCFTypeArrayCallBacks);
  CFDictionaryRef v8 = _copyStringTable((uint64_t)a1, a2, 0, v7, 0, 0);
  if (v7) {
    CFRelease(v7);
  }
  if (!v8) {
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  return v8;
}

uint64_t CFStringEncodingBytesToUnicode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  v35[1] = *(void *)off_1ECE0A5B0;
  unint64_t v15 = (uint64_t *)__CFGetConverter();
  if (!v15) {
    return 3;
  }
  uint64_t v16 = v15;
  v35[0] = 0;
  int v17 = *(unsigned __int8 *)(*v15 + 20);
  if (v17 == 4) {
    return __CFStringEncodingPlatformBytesToUnicode();
  }
  if (v17 == 5) {
    return __CFStringEncodingICUToUnicode(v15[1], a2, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v33 = a5;
  if (a4 < 1)
  {
    uint64_t v20 = 0;
    uint64_t v19 = 0;
    unsigned int v29 = 0;
    goto LABEL_50;
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  while (1)
  {
    if (a7 && a7 <= v19)
    {
LABEL_43:
      unsigned int v29 = 0;
      goto LABEL_50;
    }
    unint64_t v21 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))v16[2];
    if (v21)
    {
      if ((a2 & 0xC0) != 0) {
        unint64_t v21 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))v16[3];
      }
      uint64_t v22 = a7 ? a7 - v19 : 0;
      uint64_t v23 = v21(v16, a2, a3 + v20, a4 - v20, a6 + 2 * v19, v22, v35);
    }
    else
    {
      uint64_t v24 = a7 ? a7 - v19 : 0;
      uint64_t v23 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))(*v16 + 8))(a2, a3 + v20, a4 - v20, a6 + 2 * v19, v24, v35);
    }
    v20 += v23;
    if (a4 > v20) {
      break;
    }
LABEL_42:
    v19 += v35[0];
    if (v20 >= a4) {
      goto LABEL_43;
    }
  }
  uint64_t v34 = 0;
  if (!a7) {
    goto LABEL_27;
  }
  if (v35[0] + v19 == a7)
  {
    unsigned int v29 = 2;
    goto LABEL_49;
  }
  if ((a2 & 0xC0) == 0 && v35[0] + v19 + 1 != a7)
  {
LABEL_27:
    if ((a2 & 1) == 0)
    {
      unsigned int v29 = 1;
      goto LABEL_49;
    }
    goto LABEL_38;
  }
  unint64_t v25 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, void, void, uint64_t *))v16[2];
  if (v25)
  {
    int v32 = a2 & 1;
    if ((a2 & 0xC0) != 0) {
      uint64_t v26 = ((uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, void, void, uint64_t *))v16[3])(v16, a2, a3 + v20, a4 - v20, 0, 0, &v34);
    }
    else {
      uint64_t v26 = v25(v16, a2, a3 + v20, a4 - v20, 0, 0, &v34);
    }
  }
  else
  {
    int v32 = a2 & 1;
    uint64_t v26 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, void, void, uint64_t *))(*v16 + 8))(a2, a3 + v20, a4 - v20, 0, 0, &v34);
  }
  if (v26) {
    BOOL v27 = 1;
  }
  else {
    BOOL v27 = v32 == 0;
  }
  if (!v27)
  {
LABEL_38:
    v19 += v35[0];
    if (a7) {
      uint64_t v28 = a7 - v19;
    }
    else {
      uint64_t v28 = 0;
    }
    v20 += ((uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))v16[5])(a3 + v20, a4 - v20, a6 + 2 * v19, v28, v35);
    goto LABEL_42;
  }
  if (v26) {
    unsigned int v29 = 2;
  }
  else {
    unsigned int v29 = 1;
  }
LABEL_49:
  v19 += v35[0];
LABEL_50:
  if (v29) {
    BOOL v30 = 0;
  }
  else {
    BOOL v30 = v20 < a4;
  }
  if (!v30 || a7 == 0) {
    uint64_t result = v29;
  }
  else {
    uint64_t result = 2;
  }
  if (a8) {
    *a8 = v19;
  }
  if (v33) {
    *unint64_t v33 = v20;
  }
  return result;
}

uint64_t __CFStringEncodingICUCharLength(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  v5[1] = *(void *)off_1ECE0A5B0;
  v5[0] = 0;
  if (__CFStringEncodingICUToUnicode(a1, a2, a3, a4, 0, 0, 0, v5)) {
    return 0;
  }
  else {
    return v5[0];
  }
}

uint64_t __CFStringEncodingICUToUnicode(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  if ((a2 & 0xFF0000) == 0) {
    goto LABEL_6;
  }
  uint64_t Typed = (void *)_CFGetTSD(7u);
  if (!Typed)
  {
    uint64_t Typed = (void *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
    void *Typed = 0;
    Typed[1] = 0;
    _CFSetTSD(7u, (uint64_t)Typed, (uint64_t)__CFICUThreadDataDestructor);
  }
  if (*(unsigned __int8 *)Typed <= (BYTE2(a2) - 1)
    || (uint64_t v16 = *(void *)(Typed[1] + 8 * (BYTE2(a2) - 1))) == 0)
  {
LABEL_6:
    uint64_t v17 = ucnv_open();
    if (!v17) {
      return 3;
    }
    uint64_t v16 = v17;
    int v18 = HIBYTE(a2);
    if ((a2 & 0xFF000001) == 1) {
      int v18 = 63;
    }
    if (v18) {
      ucnv_setSubstChars();
    }
    else {
      ucnv_setToUCallBack();
    }
  }
  if (a7)
  {
    ucnv_toUnicode();
    if (a8) {
      *a8 = (a6 - a6) >> 1;
    }
    goto LABEL_20;
  }
  if (a4 < 1)
  {
    if (!a8) {
      goto LABEL_20;
    }
  }
  else
  {
    do
      ucnv_toUnicode();
    while (a3 < a3 + a4);
    if (!a8) {
      goto LABEL_20;
    }
  }
  *a8 = 0;
LABEL_20:
  if (a5) {
    *a5 = a3 - a3;
  }
  return __CFStringEncodingConverterReleaseICUConverter(v16, a2, 0);
}

uint64_t __CFBinaryHeapCreateInit(__objc2_class **a1, const void **a2, uint64_t a3, uint64_t a4, long long *a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x17uLL, 104, 0);
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 24) = 4;
    uint64_t Typed = CFAllocatorAllocateTyped(a1, 32, 0x80040B8603338, 0);
    *(void *)(v11 + 112) = Typed;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      uint64_t Typed = *(void *)(v11 + 112);
    }
    if (Typed)
    {
      if (a4)
      {
        *(_OWORD *)(v11 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = *(_OWORD *)(a4 + 8);
        *(_OWORD *)(v11 + 56) = *(_OWORD *)(a4 + 24);
      }
      if (a5)
      {
        long long v13 = *a5;
        long long v14 = a5[1];
        *(void *)(v11 + 104) = *((void *)a5 + 4);
        *(_OWORD *)(v11 + 88) = v14;
        *(_OWORD *)(v11 + 72) = v13;
      }
      unint64_t v15 = atomic_load((unint64_t *)(v11 + 8));
      unint64_t v16 = v15;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v11 + 8), &v16, v15 & 0xFFFFFFFFFFFFFFF3 | 4);
        BOOL v17 = v16 == v15;
        unint64_t v15 = v16;
      }
      while (!v17);
      if (a3 >= 1)
      {
        do
        {
          int v18 = *a2++;
          CFBinaryHeapAddValue((CFBinaryHeapRef)v11, v18);
          --a3;
        }
        while (a3);
      }
      unint64_t v19 = atomic_load((unint64_t *)(v11 + 8));
      unint64_t v20 = v19;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v11 + 8), &v20, v19 & 0xFFFFFFFFFFFFFFF3 | 4);
        BOOL v17 = v20 == v19;
        unint64_t v19 = v20;
      }
      while (!v17);
    }
    else
    {
      CFRelease((CFTypeRef)v11);
      return 0;
    }
  }
  return v11;
}

void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  CFIndex length = theRange.length;
  unint64_t location = theRange.location;
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    -[__CFCharacterSet removeCharactersInRange:](theSet, "removeCharactersInRange:", location, length);
    return;
  }
  char v5 = atomic_load((unint64_t *)theSet + 1);
  if ((v5 & 1) == 0)
  {
    CFLog(3, @"%s: Immutable character set passed to mutable function");
    if (dyld_program_sdk_at_least()) {
      CFCharacterSetRemoveCharactersInRange_cold_1();
    }
  }
  if (location >> 16 > 0x10 || length >= 1114113 || (unint64_t v6 = location + length, location + length >= 0x110001))
  {
    CFLog(3, @"%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)");
    qword_1EC093AA8 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
LABEL_145:
    __break(1u);
  }
  else
  {
    char v7 = atomic_load((unint64_t *)theSet + 1);
    if ((v7 & 0x70) == 0)
    {
      char v8 = atomic_load((unint64_t *)theSet + 1);
      if ((v8 & 1) == 0)
      {
        char v9 = atomic_load((unint64_t *)theSet + 1);
        if ((v9 & 8) == 0 && CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) == theSet) {
          return;
        }
      }
    }
    if (!length) {
      return;
    }
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 8) != 0 || (uint64_t v11 = *((void *)theSet + 5)) != 0 && (*(_DWORD *)(v11 + 8) || *(unsigned char *)(v11 + 13)))
    {
LABEL_24:
      char v13 = atomic_load((unint64_t *)theSet + 1);
      if ((v13 & 8) != 0)
      {
        uint64_t v23 = *((void *)theSet + 5);
        if (!v23 || !*(_DWORD *)(v23 + 8) && !*(unsigned char *)(v23 + 13))
        {
          unsigned int v24 = atomic_load((unint64_t *)theSet + 1);
          switch((v24 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (*((void *)theSet + 4)) {
                goto LABEL_49;
              }
              break;
            case 3u:
            case 4u:
              if (*((void *)theSet + 3)) {
                goto LABEL_49;
              }
              break;
            default:
              goto LABEL_49;
          }
          unint64_t v75 = atomic_load((unint64_t *)theSet + 1);
          unint64_t v76 = v75;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v76, v75 & 0xFFFFFFFFFFFFFF8FLL | 0x10);
            BOOL v35 = v76 == v75;
            unint64_t v75 = v76;
          }
          while (!v35);
          *((_DWORD *)theSet + 6) = location;
          *((void *)theSet + 4) = length;
          unint64_t v77 = atomic_load((unint64_t *)theSet + 1);
          unint64_t v78 = v77;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v78, v77 & 0xFFFFFFFFFFFFFFFBLL);
            BOOL v35 = v78 == v77;
            unint64_t v77 = v78;
          }
          while (!v35);
          return;
        }
LABEL_49:
        char v25 = atomic_load((unint64_t *)theSet + 1);
        if ((v25 & 0x70) == 0x10)
        {
          unint64_t v26 = *((unsigned int *)theSet + 6);
          CFIndex v27 = *((void *)theSet + 4);
          if (v26 == location)
          {
            if (v27 >= length) {
              CFIndex v27 = length;
            }
            *((void *)theSet + 4) = v27;
            unint64_t v28 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v29 = v28;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v29, v28 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v35 = v29 == v28;
              unint64_t v28 = v29;
            }
            while (!v35);
            return;
          }
          if (v26 < location && (uint64_t)location <= (uint64_t)(v27 + v26))
          {
            if ((uint64_t)(v27 + v26) < (uint64_t)v6) {
              *((void *)theSet + 4) = v6 - v26;
            }
            unint64_t v81 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v82 = v81;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v82, v81 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v35 = v82 == v81;
              unint64_t v81 = v82;
            }
            while (!v35);
            return;
          }
          if (v26 > location && v6 >= v26)
          {
            *((_DWORD *)theSet + 6) = location;
            *((void *)theSet + 4) = v26 - location + v27;
            unint64_t v73 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v74 = v73;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v74, v73 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v35 = v74 == v73;
              unint64_t v73 = v74;
            }
            while (!v35);
            return;
          }
        }
        else
        {
          char v52 = atomic_load((unint64_t *)theSet + 1);
          if ((v52 & 0x70) == 0x20)
          {
            uint64_t v53 = *((void *)theSet + 4);
            CFIndex v54 = v53 + length;
            if (v53 + length <= 63)
            {
              uint64_t Typed = *((void *)theSet + 3);
              if (!Typed)
              {
                CFAllocatorRef v56 = CFGetAllocator(theSet);
                uint64_t Typed = CFAllocatorAllocateTyped(v56, 128, 0x1000040BDFB0063, 0);
                *((void *)theSet + 3) = Typed;
                uint64_t v53 = *((void *)theSet + 4);
                CFIndex v54 = v53 + length;
              }
              *((void *)theSet + 4) = v54;
              uint64_t v57 = (_WORD *)(Typed + 2 * v53);
              do
              {
                *v57++ = location++;
                --length;
              }
              while (length);
              qsort(*((void **)theSet + 3), *((void *)theSet + 4), 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
              uint64_t v58 = *((void *)theSet + 4);
              if (v58 >= 2)
              {
                uint64_t v59 = 0;
                uint64_t v60 = *((void *)theSet + 3);
                uint64_t v61 = v58 - 1;
                int v62 = (unsigned __int16 *)(v60 + 2);
                do
                {
                  int v64 = *v62++;
                  __int16 v63 = v64;
                  if (*(unsigned __int16 *)(v60 + 2 * v59) != v64)
                  {
                    ++v59;
                    *(_WORD *)(v60 + 2 * v59) = v63;
                  }
                  --v61;
                }
                while (v61);
                uint64_t v58 = v59 + 1;
              }
              *((void *)theSet + 4) = v58;
              unint64_t v65 = atomic_load((unint64_t *)theSet + 1);
              unint64_t v66 = v65;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v66, v65 & 0xFFFFFFFFFFFFFFFBLL);
                BOOL v35 = v66 == v65;
                unint64_t v65 = v66;
              }
              while (!v35);
              return;
            }
          }
        }
      }
      CFIndex v83 = length;
      uint64_t v85 = location;
      __CFCSetMakeBitmap(theSet);
      uint64_t v84 = location + length;
      int v14 = v6 - 1;
      if ((location >> 16) <= 1) {
        int v15 = 1;
      }
      else {
        int v15 = location >> 16;
      }
      if (v15 <= v14 >> 16)
      {
        CFIndex v30 = (unsigned __int16)location;
        int v31 = v14 >> 16;
        int v32 = (unsigned __int16)v84;
        __int16 v33 = 8 * v15;
        int v34 = (v14 >> 16) + 1;
        do
        {
          if (v32) {
            BOOL v35 = v31 == v15;
          }
          else {
            BOOL v35 = 0;
          }
          if (v35) {
            uint64_t v36 = (unsigned __int16)v84;
          }
          else {
            uint64_t v36 = 0x10000;
          }
          CFIndex v37 = v36 - v30;
          unint64_t v38 = (uint64_t *)*((void *)theSet + 5);
          if (v38 && *((unsigned char *)v38 + 13))
          {
            if (!(_BYTE)v15) {
              goto LABEL_145;
            }
            if (v15 <= 0x10u)
            {
              if (*((unsigned __int8 *)v38 + 12) < v15)
              {
                *((unsigned char *)v38 + 12) = v15;
                uint64_t v39 = *v38;
                CFAllocatorRef v40 = CFGetAllocator(theSet);
                if (v39) {
                  uint64_t v41 = __CFSafelyReallocateWithAllocatorTyped(v40, **((void **)theSet + 5), v33 & 0x7F8, 0x6004044C4A2DFLL, 0, 0);
                }
                else {
                  uint64_t v41 = CFAllocatorAllocateTyped(v40, v33 & 0x7F8, 0x6004044C4A2DFLL, 0);
                }
                unint64_t v38 = (uint64_t *)*((void *)theSet + 5);
                uint64_t *v38 = v41;
              }
              if ((v38[1] & (1 << v15)) != 0)
              {
                uint64_t v47 = v15 - 1;
              }
              else
              {
                CFAllocatorRef v48 = CFGetAllocator(theSet);
                CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v48);
                uint64_t v47 = v15 - 1;
                *(void *)(**((void **)theSet + 5) + 8 * v47) = Mutable;
                unint64_t v38 = (uint64_t *)*((void *)theSet + 5);
                *((_DWORD *)v38 + 2) |= 1 << v15;
              }
              int v32 = (unsigned __int16)v84;
              long long v50 = *(__CFCharacterSet **)(*v38 + 8 * v47);
              if (v50)
              {
                v88.unint64_t location = v30;
                v88.CFIndex length = v37;
                CFCharacterSetAddCharactersInRange(v50, v88);
              }
            }
          }
          else
          {
            if (!(_BYTE)v15) {
              goto LABEL_145;
            }
            if (v15 <= 0x10u)
            {
              if (v38)
              {
                if (((*((_DWORD *)v38 + 2) >> v15) & 1) != 0
                  && *((unsigned __int8 *)v38 + 12) >= v15)
                {
                  uint64_t v42 = *v38;
                  unsigned int v43 = v15 - 1;
                  unsigned int v44 = *(unint64_t **)(v42 + 8 * v43);
                  if (v44)
                  {
                    v87.unint64_t location = v30;
                    v87.CFIndex length = v37;
                    CFCharacterSetRemoveCharactersInRange(*(CFMutableCharacterSetRef *)(v42 + 8 * v43), v87);
                    unint64_t v45 = v44[5];
                    if (!v45 || !*(_DWORD *)(v45 + 8) && !*(unsigned char *)(v45 + 13))
                    {
                      unsigned int v46 = atomic_load(v44 + 1);
                      switch((v46 >> 4) & 7)
                      {
                        case 1u:
                        case 2u:
                          if (!v44[4]) {
                            goto LABEL_93;
                          }
                          break;
                        case 3u:
                        case 4u:
                          if (!v44[3])
                          {
LABEL_93:
                            char v51 = atomic_load(v44 + 1);
                            if ((v51 & 8) == 0)
                            {
                              CFRelease(v44);
                              *(_DWORD *)(*((void *)theSet + 5) + 8) &= ~(1 << v15);
                            }
                          }
                          break;
                        default:
                          break;
                      }
                    }
                  }
                }
              }
            }
          }
          ++v15;
          v33 += 8;
        }
        while (v34 != v15);
      }
      uint64_t v16 = *((void *)theSet + 5);
      if (v16 && !*(_DWORD *)(v16 + 8) && !*(unsigned char *)(v16 + 13))
      {
        for (uint64_t i = 0; i != 16; ++i)
        {
          uint64_t v18 = *((void *)theSet + 5);
          if (((*(_DWORD *)(v18 + 8) >> i) & 2) != 0) {
            CFRelease(*(CFTypeRef *)(*(void *)v18 + 8 * i));
          }
        }
        CFAllocatorRef v19 = CFGetAllocator(theSet);
        CFAllocatorDeallocate(v19, **((void ***)theSet + 5));
        CFAllocatorRef v20 = CFGetAllocator(theSet);
        CFAllocatorDeallocate(v20, *((void **)theSet + 5));
        *((void *)theSet + 5) = 0;
      }
      if (v85 < 0x10000)
      {
        if (v84 <= 0x10000) {
          uint64_t v21 = v83;
        }
        else {
          uint64_t v21 = 0x10000 - v85;
        }
        if (v85 || v21 != 0x10000)
        {
          uint64_t v67 = *((void *)theSet + 3);
          unsigned __int16 v68 = v21 + v85 - 1;
          uint64_t v69 = (unsigned __int16)v85 >> 3;
          unint64_t v70 = v68;
          uint64_t v71 = v68 >> 3;
          int v72 = 255 << (v85 & 7);
          if (v71 == v69)
          {
            *(unsigned char *)(v67 + v69) &= ~((0xFFu >> (~(_BYTE)v70 & 7)) & v72);
          }
          else
          {
            *(unsigned char *)(v67 + v69) &= ~(_BYTE)v72;
            *(unsigned char *)(v67 + v71) &= -256 >> (~(_BYTE)v70 & 7);
            if (((unint64_t)(unsigned __int16)v85 >> 3) + 1 < (v70 >> 3)) {
              bzero((void *)(v69 + v67 + 1), (v71 - v69 - 2) + 1);
            }
          }
        }
        else
        {
          CFAllocatorRef v22 = CFGetAllocator(theSet);
          CFAllocatorDeallocate(v22, *((void **)theSet + 3));
          *((void *)theSet + 3) = 0;
        }
      }
      unint64_t v79 = atomic_load((unint64_t *)theSet + 1);
      unint64_t v80 = v79;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v80, v79 & 0xFFFFFFFFFFFFFFFBLL);
        BOOL v35 = v80 == v79;
        unint64_t v79 = v80;
      }
      while (!v35);
      if (__CFCheckForExapendedSet == 1)
      {
        __CFCheckForExpandedSet((const char *)theSet);
      }
    }
    else
    {
      unsigned int v12 = atomic_load((unint64_t *)theSet + 1);
      switch((v12 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*((void *)theSet + 4)) {
            goto LABEL_24;
          }
          break;
        case 3u:
        case 4u:
          if (*((void *)theSet + 3)) {
            goto LABEL_24;
          }
          break;
        default:
          goto LABEL_24;
      }
    }
  }
}

os_unfair_lock_s *__directCFPrefsD_block_invoke()
{
  CFMutableDictionaryRef v0 = [CFPrefsDaemon alloc];
  if (__CFProcessIsRestricted()) {
    BOOL v1 = 0;
  }
  else {
    BOOL v1 = getenv("__CFPreferencesTestDaemon") != 0;
  }
  uint64_t result = -[CFPrefsDaemon initWithRole:testMode:](v0, 3, v1);
  directCFPrefsD_daemon = (uint64_t)result;
  return result;
}

CFPlugInRef CFPlugInCreate(CFAllocatorRef allocator, CFURLRef plugInURL)
{
  unint64_t v2 = CFBundleCreate(allocator, plugInURL);
  if (!atomic_load(CFPlugInCreate_checkedLinkage))
  {
    int32_t v4 = NSVersionOfLinkTimeLibrary("System");
    int32_t v5 = NSVersionOfLinkTimeLibrary("CoreFoundation");
    if (v4 == -1 && v5 == -1 || v5 != -1 && v5 < 24576000 || v4 != -1 && v4 < 5832704) {
      atomic_store(1u, CFPlugInCreate_doDynamicRegistrationAtCreateTime);
    }
    atomic_store(1u, CFPlugInCreate_checkedLinkage);
  }
  if (v2)
  {
    if (atomic_load(CFPlugInCreate_doDynamicRegistrationAtCreateTime))
    {
      if (*(unsigned char *)__CFBundleGetPlugInData((uint64_t)v2)
        && *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)v2) + 3)
        && !CFBundleIsExecutableLoaded(v2))
      {
        CFBundleLoadExecutable(v2);
      }
    }
  }
  return v2;
}

void CFStorageInsertValues(uint64_t cf, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(cf + 24);
  if (v4 == -1)
  {
    uint64_t v7 = *(void *)(cf + 16);
    uint64_t v5 = v7 * a3;
    uint64_t v6 = v7 * a2;
  }
  else
  {
    uint64_t v5 = a3 << v4;
    uint64_t v6 = a2 << v4;
  }
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)cf);
  if (v5 >= 1)
  {
    uint64_t v9 = (uint64_t)v8;
    uint64_t v10 = *(void *)(cf + 136);
    do
    {
      if (v5 >= v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v5;
      }
      __CFStorageInsertUnfrozen(v9, cf, cf + 144, v6, v11, v6);
      if (v12)
      {
        char v13 = v12;
        uint64_t Node = __CFStorageCreateNode(v9, cf, *(unsigned char *)(cf + 157), *(void *)(cf + 144));
        uint64_t v15 = *(void *)(cf + 176);
        *(_OWORD *)(Node + 16) = *(_OWORD *)(cf + 160);
        *(void *)(Node + 32) = v15;
        if (*(unsigned char *)(cf + 157))
        {
          os_unfair_lock_lock_with_options();
          *(void *)(cf + 104) = 0;
          *(void *)(cf + 112) = 0;
          *(void *)(cf + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
          os_unfair_lock_unlock((os_unfair_lock_t)(cf + 128));
          *(unsigned char *)(cf + 157) = 0;
        }
        *(void *)(cf + 16_CFBundleUnloadExecutable((uint64_t)bundle, 0) = Node;
        *(void *)(cf + 168) = v13;
        *(void *)(cf + 176) = 0;
        *(void *)(cf + 144) = *v13 + *(void *)Node;
      }
      v6 += v11;
      BOOL v16 = v5 <= v11;
      v5 -= v11;
    }
    while (!v16);
  }
}

uint64_t __CFStorageInsertUnfrozen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(unsigned char *)(a3 + 13))
  {
    uint64_t v22 = a4 - 1;
    uint64_t v24 = a3 + 16;
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v25 = *(void *)v23;
    if (*(void *)v23 < a4)
    {
      v22 -= v25;
      uint64_t v23 = *(void *)(a3 + 24);
      uint64_t v26 = v22 - *(void *)v23;
      if (v22 >= *(void *)v23)
      {
        uint64_t v23 = *(void *)(a3 + 32);
        uint64_t v32 = 2;
        uint64_t v22 = v26;
      }
      else
      {
        uint64_t v32 = 1;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    int64_t v54 = v22 + 1;
    if (*(unsigned char *)(v23 + 12))
    {
      if (*(_DWORD *)(v23 + 8) != 1)
      {
        uint64_t v55 = a1;
        uint64_t inserted = __CFStorageInsertFrozen(a1, a2, v23, v54, a5, a6);
LABEL_49:
        uint64_t v58 = inserted;
        uint64_t v59 = v57;
        if (v23 != inserted)
        {
          if (*(_DWORD *)(v23 + 8)
            && atomic_fetch_add_explicit((atomic_uint *volatile)(v23 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
          {
            __CFStorageDeallocateNode((const void *)a2, v23);
          }
          *(void *)(v24 + 8 * v32) = v58;
        }
        if (v59)
        {
          if (*(void *)(a3 + 32))
          {
            uint64_t Node = (void *)__CFStorageCreateNode(v55, a2, 0, 0);
            if (v32 == 1)
            {
              Node[2] = v59;
              Node[3] = *(void *)(a3 + 32);
            }
            else if (v32)
            {
              Node[2] = *(void *)(a3 + 32);
              Node[3] = v59;
            }
            else
            {
              Node[2] = *(void *)(a3 + 24);
              Node[3] = *(void *)(a3 + 32);
              *(void *)(a3 + 24) = v59;
            }
            *(void *)(a3 + 32) = 0;
            *(void *)a3 = **(void **)(a3 + 24) + **(void **)(a3 + 16);
            void *Node = *(void *)Node[3] + *(void *)Node[2];
            return a3;
          }
          if (v25 >= a4) {
            *(void *)(a3 + 32) = *(void *)(a3 + 24);
          }
          *(void *)(v24 + 8 * v32 + 8) = v59;
        }
        uint64_t v61 = *(void *)a3 + a5;
LABEL_64:
        *(void *)a3 = v61;
        return a3;
      }
      *(unsigned char *)(v23 + 12) = 0;
    }
    uint64_t v55 = a1;
    uint64_t inserted = __CFStorageInsertUnfrozen(a1, a2, v23, v54, a5, a6);
    goto LABEL_49;
  }
  uint64_t v12 = *(void *)a3;
  uint64_t v13 = *(void *)a3 + a5;
  uint64_t v14 = *(void *)(a2 + 136);
  if (v13 > v14)
  {
    uint64_t v15 = v12 - a4;
    if (!v15)
    {
      BOOL v16 = (uint64_t *)__CFStorageCreateNode(a1, a2, 1, a5);
      BOOL v17 = v16;
      if (v16)
      {
        uint64_t v18 = *v16;
        int v19 = *(_DWORD *)(a2 + 24);
        if (v19 == -1)
        {
          uint64_t v72 = *(void *)(a2 + 16);
          uint64_t v20 = a6 / v72;
          uint64_t v21 = v18 / v72;
        }
        else
        {
          uint64_t v20 = a6 >> v19;
          uint64_t v21 = v18 >> v19;
        }
      }
      else
      {
        uint64_t v20 = 0;
        uint64_t v21 = 0;
      }
      unint64_t v73 = (os_unfair_lock_s *)(a2 + 128);
      os_unfair_lock_lock_with_options();
      *(void *)(a2 + 104) = v17;
      goto LABEL_140;
    }
    if (a4)
    {
      uint64_t v33 = a5 + a4;
      if (a5 + a4 > v14)
      {
        uint64_t v35 = __CFStorageCreateNode(a1, a2, 1, v13 - v14);
        uint64_t v36 = v35;
        uint64_t v37 = *(void *)(a3 + 24);
        if (v37)
        {
          uint64_t v38 = *(void *)a3;
          uint64_t v39 = *(void *)(a2 + 136);
          uint64_t v40 = *(void *)a3 + a5 - v39;
          uint64_t v41 = *(void *)off_1ECE0A708;
          if (*(uint64_t *)off_1ECE0A708 >= 0) {
            uint64_t v42 = *(void *)off_1ECE0A708;
          }
          else {
            uint64_t v42 = v41 + 1;
          }
          uint64_t v43 = a1;
          if (v40 <= v42 >> 1)
          {
            uint64_t v75 = v40 + 63;
            BOOL v46 = v40 < -63;
            uint64_t v76 = v40 + 126;
            if (!v46) {
              uint64_t v76 = v75;
            }
            int64_t v45 = v76 & 0xFFFFFFFFFFFFFFC0;
          }
          else
          {
            int v44 = (v40 + v41 - 1) & -(int)v41;
            if (v39 >= v44) {
              int64_t v45 = v44;
            }
            else {
              int64_t v45 = *(void *)(a2 + 136);
            }
          }
          if (v45 > *(void *)(v35 + 16))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
            if (v45 > *(void *)(v36 + 16))
            {
              *(void *)(v36 + 24) = __CFSafelyReallocateWithAllocatorTyped(v43, *(void *)(v36 + 24), v45, 1893177561, 0, 0);
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              *(void *)(v36 + 16) = v45;
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
            uint64_t v39 = *(void *)(a2 + 136);
            uint64_t v37 = *(void *)(a3 + 24);
            uint64_t v38 = *(void *)a3;
          }
          memmove((void *)(*(void *)(v36 + 24) + a4 + a5 - v39), (const void *)(v37 + a4), v38 - a4);
          uint64_t v77 = *(void *)(a2 + 136);
          uint64_t v78 = *(void *)off_1ECE0A708;
          if (*(uint64_t *)off_1ECE0A708 >= 0) {
            uint64_t v79 = *(void *)off_1ECE0A708;
          }
          else {
            uint64_t v79 = v78 + 1;
          }
          if (v77 <= v79 >> 1)
          {
            uint64_t v87 = v77 + 63;
            BOOL v46 = v77 < -63;
            uint64_t v88 = v77 + 126;
            if (!v46) {
              uint64_t v88 = v87;
            }
            int64_t v81 = v88 & 0xFFFFFFFFFFFFFFC0;
          }
          else
          {
            int v80 = (v77 + v78 - 1) & -(int)v78;
            if (v77 >= v80) {
              int64_t v81 = v80;
            }
            else {
              int64_t v81 = *(void *)(a2 + 136);
            }
          }
          if (v81 > *(void *)(a3 + 16))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
            if (v81 > *(void *)(a3 + 16))
            {
              *(void *)(a3 + 24) = __CFSafelyReallocateWithAllocatorTyped(v43, *(void *)(a3 + 24), v81, 1893177561, 0, 0);
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              *(void *)(a3 + 16) = v81;
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          }
        }
        uint64_t v89 = a6 - a4;
        uint64_t v90 = *(void *)a3;
        int v91 = *(_DWORD *)(a2 + 24);
        if (v91 == -1)
        {
          uint64_t v94 = *(void *)(a2 + 16);
          uint64_t v92 = v89 / v94;
          uint64_t v93 = v90 / v94;
        }
        else
        {
          uint64_t v92 = v89 >> v91;
          uint64_t v93 = v90 >> v91;
        }
        os_unfair_lock_lock_with_options();
        *(void *)(a2 + 104) = a3;
        *(void *)(a2 + 112) = v92;
        *(void *)(a2 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v93;
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
        uint64_t v61 = *(void *)(a2 + 136);
        goto LABEL_64;
      }
      uint64_t v64 = __CFStorageCreateNode(a1, a2, 1, v15);
      uint64_t v65 = v64;
      uint64_t v66 = *(void *)(a3 + 24);
      if (v66)
      {
        int64_t v67 = *(void *)a3 - a4;
        uint64_t v68 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v69 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v69 = v68 + 1;
        }
        if (v67 <= v69 >> 1)
        {
          int64_t v82 = v67 + 63;
          if (v67 < -63) {
            int64_t v82 = v67 + 126;
          }
          int64_t v71 = v82 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v70 = (v67 + v68 - 1) & -(int)v68;
          if (*(void *)(a2 + 136) >= v70) {
            int64_t v71 = v70;
          }
          else {
            int64_t v71 = *(void *)(a2 + 136);
          }
        }
        if (v71 > *(void *)(v64 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v71 > *(void *)(v65 + 16))
          {
            *(void *)(v65 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(v65 + 24), v71, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v65 + 16) = v71;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          uint64_t v66 = *(void *)(a3 + 24);
          int64_t v67 = *(void *)a3 - a4;
        }
        memmove(*(void **)(v65 + 24), (const void *)(v66 + a4), v67);
        uint64_t v83 = *(void *)off_1ECE0A708;
        if (*(uint64_t *)off_1ECE0A708 >= 0) {
          uint64_t v84 = *(void *)off_1ECE0A708;
        }
        else {
          uint64_t v84 = v83 + 1;
        }
        if (v33 <= v84 >> 1)
        {
          uint64_t v95 = v33 + 63;
          if (v33 < -63) {
            uint64_t v95 = v33 + 126;
          }
          int64_t v86 = v95 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          int v85 = (v33 + v83 - 1) & -(int)v83;
          if (*(void *)(a2 + 136) >= v85) {
            int64_t v86 = v85;
          }
          else {
            int64_t v86 = *(void *)(a2 + 136);
          }
        }
        if (v86 > *(void *)(a3 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v86 > *(void *)(a3 + 16))
          {
            *(void *)(a3 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(a3 + 24), v86, 1893177561, 0, 0);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(a3 + 16) = v86;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
      }
      *(void *)a3 = v33;
      uint64_t v96 = a6 - a4;
      int v97 = *(_DWORD *)(a2 + 24);
      if (v97 == -1)
      {
        uint64_t v98 = *(void *)(a2 + 16);
        uint64_t v20 = v96 / v98;
        uint64_t v21 = v33 / v98;
      }
      else
      {
        uint64_t v20 = v96 >> v97;
        uint64_t v21 = v33 >> v97;
      }
    }
    else
    {
      int v62 = (void *)__CFStorageCreateNode(a1, a2, 1, 0);
      *int v62 = *(void *)a3;
      v62[2] = *(void *)(a3 + 16);
      v62[3] = *(void *)(a3 + 24);
      *(void *)a3 = a5;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      int v63 = *(_DWORD *)(a2 + 24);
      if (v63 == -1)
      {
        uint64_t v74 = *(void *)(a2 + 16);
        uint64_t v20 = a6 / v74;
        uint64_t v21 = a5 / v74;
      }
      else
      {
        uint64_t v20 = a6 >> v63;
        uint64_t v21 = a5 >> v63;
      }
    }
    unint64_t v73 = (os_unfair_lock_s *)(a2 + 128);
    os_unfair_lock_lock_with_options();
    *(void *)(a2 + 104) = a3;
LABEL_140:
    *(void *)(a2 + 112) = v20;
    *(void *)(a2 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v21;
    os_unfair_lock_unlock(v73);
    return a3;
  }
  uint64_t v27 = *(void *)(a3 + 24);
  if (v27)
  {
    uint64_t v28 = *(void *)off_1ECE0A708;
    if (*(uint64_t *)off_1ECE0A708 >= 0) {
      uint64_t v29 = *(void *)off_1ECE0A708;
    }
    else {
      uint64_t v29 = v28 + 1;
    }
    if (v13 <= v29 >> 1)
    {
      uint64_t v47 = v13 + 63;
      BOOL v46 = v13 < -63;
      uint64_t v48 = v13 + 126;
      if (!v46) {
        uint64_t v48 = v47;
      }
      int64_t v31 = v48 & 0xFFFFFFFFFFFFFFC0;
    }
    else
    {
      int v30 = (v13 + v28 - 1) & -(int)v28;
      if (v14 >= v30) {
        int64_t v31 = v30;
      }
      else {
        int64_t v31 = *(void *)(a2 + 136);
      }
    }
    if (v31 > *(void *)(a3 + 16))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
      if (v31 > *(void *)(a3 + 16))
      {
        *(void *)(a3 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(void *)(a3 + 24), v31, 1893177561, 0, 0);
        if (__CFOASafe) {
          __CFSetLastAllocationEventName();
        }
        *(void *)(a3 + 16) = v31;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
      uint64_t v27 = *(void *)(a3 + 24);
      uint64_t v12 = *(void *)a3;
    }
    memmove((void *)(v27 + a4 + a5), (const void *)(v27 + a4), v12 - a4);
    uint64_t v13 = *(void *)a3 + a5;
  }
  *(void *)a3 = v13;
  uint64_t v49 = a6 - a4;
  int v50 = *(_DWORD *)(a2 + 24);
  if (v50 == -1)
  {
    uint64_t v53 = *(void *)(a2 + 16);
    uint64_t v51 = v49 / v53;
    uint64_t v52 = v13 / v53;
  }
  else
  {
    uint64_t v51 = v49 >> v50;
    uint64_t v52 = v13 >> v50;
  }
  os_unfair_lock_lock_with_options();
  *(void *)(a2 + 104) = a3;
  *(void *)(a2 + 112) = v51;
  *(void *)(a2 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v52;
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
  return a3;
}

CFStringRef CFStringConvertEncodingToIANACharSetName(CFStringEncoding encoding)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  unint64_t v2 = (const void *)encoding;
  os_unfair_lock_lock_with_options();
  if (!CFStringConvertEncodingToIANACharSetName_mappingTable
    || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFStringConvertEncodingToIANACharSetName_mappingTable, v2)) == 0)
  {
    if (__CFStringEncodingGetCanonicalName(encoding, cStr, 100))
    {
      CFStringRef Value = CFStringCreateWithCString(0, cStr, 0x600u);
      if (Value)
      {
        CFMutableCharacterSetRef Mutable = (__CFDictionary *)CFStringConvertEncodingToIANACharSetName_mappingTable;
        if (!CFStringConvertEncodingToIANACharSetName_mappingTable)
        {
          CFMutableCharacterSetRef Mutable = CFDictionaryCreateMutable(0, 0, 0, &kCFTypeDictionaryValueCallBacks);
          CFStringConvertEncodingToIANACharSetName_mappingTable = (uint64_t)Mutable;
        }
        CFDictionaryAddValue(Mutable, v2, Value);
        CFRelease(Value);
      }
    }
    else
    {
      CFStringRef Value = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CFStringConvertEncodingToIANACharSetName_lock);
  return Value;
}

BOOL __CFStringEncodingGetCanonicalName(int a1, char *__str, int64_t __size)
{
  unsigned int v4 = ((a1 & 0xF00u) - 256) >> 8;
  if (v4 - 3 < 2)
  {
    uint64_t v7 = (__int16 *)&unk_182EDDA66;
    unsigned int v8 = a1 & 0xFFF;
    uint64_t v9 = __CFKnownEncodingList;
    while (1)
    {
      uint64_t v10 = (char *)&v9[((char *)v7 - (char *)v9) >> 2];
      unsigned int v11 = *(unsigned __int16 *)v10;
      if (v8 == v11) {
        break;
      }
      uint64_t v12 = (unsigned __int16 *)(v10 - 2);
      uint64_t v13 = (__int16 *)(v10 + 2);
      if (v8 < v11) {
        uint64_t v7 = (__int16 *)v12;
      }
      else {
        uint64_t v9 = v13;
      }
      if (v9 > v7) {
        return 0;
      }
    }
    if (v10 - (char *)__CFKnownEncodingList != -2
      && *(__int16 *)((char *)__CFWindowsCPList + v10 - (char *)__CFKnownEncodingList))
    {
      if ((a1 & 0xF00) == 0x400) {
        uint64_t v14 = "cp%d";
      }
      else {
        uint64_t v14 = "windows-%d";
      }
      int v6 = snprintf(__str, __size, v14, *(unsigned __int16 *)((char *)__CFWindowsCPList + v10 - (char *)__CFKnownEncodingList));
      return v6 < __size;
    }
  }
  else
  {
    if (v4 == 1)
    {
      int v6 = snprintf(__str, __size, "iso-8859-%u");
      return v6 < __size;
    }
    if (v4)
    {
      BOOL v16 = (__int16 *)&unk_182EDDA66;
      unsigned int v17 = a1 & 0xFFF;
      uint64_t v18 = __CFKnownEncodingList;
      while (1)
      {
        int v19 = (char *)&v18[((char *)v16 - (char *)v18) >> 2];
        unsigned int v20 = *(unsigned __int16 *)v19;
        if (v17 == v20) {
          break;
        }
        uint64_t v21 = (unsigned __int16 *)(v19 - 2);
        uint64_t v22 = (__int16 *)(v19 + 2);
        if (v17 < v20) {
          BOOL v16 = (__int16 *)v21;
        }
        else {
          uint64_t v18 = v22;
        }
        if (v18 > v16) {
          return 0;
        }
      }
      if (v19 - (char *)__CFKnownEncodingList != -2
        && *(char **)((char *)__CFCanonicalNameList + 4 * (v19 - (char *)__CFKnownEncodingList)))
      {
        int v6 = snprintf(__str, __size, "%s%s");
        return v6 < __size;
      }
    }
    else
    {
      HIDWORD(v5) = a1 - 256;
      LODWORD(v5) = a1 - 256;
      if ((v5 >> 26) <= 7)
      {
        int v6 = snprintf(__str, __size, "%s");
        return v6 < __size;
      }
    }
  }
  return 0;
}

void sub_182CA220C(_Unwind_Exception *a1)
{
  free(v2);
  free(v1);
  _Unwind_Resume(a1);
}

uint64_t __CFFileDescriptorCreate_block_invoke_5(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  int v2 = *(_DWORD *)(a1 + 40);

  return close(v2);
}

uint64_t __CFFileDescriptorCreate_block_invoke_3(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  int v2 = *(_DWORD *)(a1 + 40);

  return close(v2);
}

uint64_t _CFDiscorporateMemoryDeallocate(uint64_t a1)
{
  mach_vm_address_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = mach_vm_deallocate(*(_DWORD *)off_1ECE0A6C8, v2, *(void *)(a1 + 8));
    uint64_t v4 = v3;
    if (v3)
    {
      __int16 v5 = (unsigned __int16)mach_error_string(v3);
      CFLog(3, @"CFDiscorporateMemoryDeallocate: mach_vm_deallocate returned %s", v6, v7, v8, v9, v10, v11, v5);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  return v4;
}

uint64_t _CFURLComponentsGetURLFragmentAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 40);
}

uint64_t _CFDiscorporateMemoryAllocate(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = a3;
  if (((a2 + *(void *)off_1ECE0A708 - 1) & -*(void *)off_1ECE0A708) != 0) {
    mach_vm_size_t v5 = (a2 + *(void *)off_1ECE0A708 - 1) & -*(void *)off_1ECE0A708;
  }
  else {
    mach_vm_size_t v5 = *(void *)off_1ECE0A708;
  }
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v6 = (mach_vm_address_t *)(a1 + 16);
  *(_OWORD *)a1 = 0u;
  if (a3) {
    int v7 = 687865859;
  }
  else {
    int v7 = 687865857;
  }
  uint64_t result = mach_vm_allocate(*(_DWORD *)off_1ECE0A6C8, v6, v5, v7);
  if (result)
  {
    *uint64_t v6 = 0;
  }
  else
  {
    *(void *)a1 = *(void *)(a1 + 16);
    *(void *)(a1 + 8) = v5;
    *(unsigned char *)(a1 + 24) = v3;
  }
  return result;
}

NSObject *_CFStreamCopyDispatchQueue(uint64_t a1)
{
  mach_vm_address_t v2 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  if (*(void *)(a1 + 32))
  {
    char v3 = *(NSObject **)(a1 + 128);
    if (v3) {
      dispatch_retain(v3);
    }
  }
  else
  {
    char v3 = 0;
  }
  pthread_mutex_unlock(v2);
  return v3;
}

Boolean CFRunLoopIsWaiting(CFRunLoopRef rl)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  unsigned __int8 v3 = atomic_load(__CFMainThreadHasExited);
  if (v3)
  {
    BOOL v6 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v6 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v4 = atomic_load((unint64_t *)rl + 1);
  return (v4 >> 1) & 1;
}

SInt32 CFAbsoluteTimeGetDayOfWeek(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  else {
    double SecondsFromGMT = 0.0;
  }
  uint64_t v4 = vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0);
  uint64_t v5 = ((unint64_t)~v4 * (unsigned __int128)0x2492492492492493uLL) >> 64;
  uint64_t v6 = (~v4 - 7 * ((v5 + ((unint64_t)(~v4 - v5) >> 1)) >> 2)) ^ 7;
  if (v4 >= 0) {
    return v4 % 7uLL + 1;
  }
  else {
    LODWORD(v7) = v6;
  }
  return v7;
}

void sub_182CA2D84(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void boundPairReadClose(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unsigned __int8 v3 = (pthread_mutex_t *)(a2 + 104);
    uint64_t v8 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    *(unsigned char *)(a2 + 2) = 1;
    if (!*(unsigned char *)(a2 + 50))
    {
      if (*(_WORD *)(a2 + 52))
      {
        setupScheduledStreamCloseBlock(&v6, *(CFTypeRef *)(a2 + 80), *(CFTypeRef *)(a2 + 56), *(CFTypeRef *)(a2 + 64));
      }
      else
      {
        uint64_t v5 = *(const void **)(a2 + 56);
        uint64_t v4 = *(const void **)(a2 + 64);
        uint64_t v6 = 0;
        if (v5) {
          CFRetain(v5);
        }
        uint64_t v7 = v5;
        if (v4) {
          CFRetain(v4);
        }
        uint64_t v8 = v4;
      }
    }
    pthread_mutex_unlock(v3);
    performUnlockParamsAndDealloc((uint64_t)&v6);
  }
}

void boundPairWriteClose(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unsigned __int8 v3 = (pthread_mutex_t *)(a2 + 104);
    uint64_t v8 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    *(unsigned char *)(a2 + 5_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
    *(unsigned char *)(a2 + 3) = 1;
    if (!*(unsigned char *)(a2 + 2))
    {
      if (*(_WORD *)(a2 + 4))
      {
        setupScheduledStreamCloseBlock(&v6, *(CFTypeRef *)(a2 + 32), *(CFTypeRef *)(a2 + 8), *(CFTypeRef *)(a2 + 16));
      }
      else
      {
        uint64_t v5 = *(const void **)(a2 + 8);
        uint64_t v4 = *(const void **)(a2 + 16);
        uint64_t v6 = 0;
        if (v5) {
          CFRetain(v5);
        }
        uint64_t v7 = v5;
        if (v4) {
          CFRetain(v4);
        }
        uint64_t v8 = v4;
      }
    }
    pthread_mutex_unlock(v3);
    performUnlockParamsAndDealloc((uint64_t)&v6);
  }
}

void performUnlockParamsAndDealloc(uint64_t a1)
{
  unint64_t v2 = *(char **)a1;
  if (v2)
  {
    CFTypeID v3 = CFGetTypeID(v2);
    CFTypeID TypeID = CFReadStreamGetTypeID();
    uint64_t v10 = *(char **)a1;
    if (v3 == TypeID)
    {
      CFReadStreamSignalEvent(v10, 2uLL, 0, v4, v5, v6, v7, v8);
      char v11 = 0;
      goto LABEL_6;
    }
    CFWriteStreamSignalEvent(v10, 0x10uLL, 0, v4, v5, v6, v7, v8);
  }
  char v11 = 1;
LABEL_6:
  uint64_t v12 = *(__CFRunLoopSource **)(a1 + 8);
  if (v12) {
    CFRunLoopSourceSignal(v12);
  }
  if (*(void *)a1)
  {
    if (v11) {
      _wakeWriteStreamScheduledRunLoops();
    }
    else {
      _wakeReadStreamScheduledRunLoops();
    }
  }
  uint64_t v13 = *(__CFRunLoop **)(a1 + 16);
  if (v13) {
    CFRunLoopWakeUp(v13);
  }
  if (*(void *)a1)
  {
    CFRelease(*(CFTypeRef *)a1);
    *(void *)a1 = 0;
  }
  uint64_t v14 = *(const void **)(a1 + 8);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v15 = *(const void **)(a1 + 16);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 16) = 0;
  }
}

void ___isValidSpecialCase_block_invoke()
{
  CFMutableDictionaryRef v0 = dlopen("/usr/lib/libMobileGestalt.dylib", 5);
  if (v0)
  {
    BOOL v1 = (uint64_t (*)(__CFString *, void))dlsym(v0, "MGCopyAnswer");
    if (v1)
    {
      unint64_t v2 = (const void *)v1(@"h63QSdBCiT/z0WU6rdQv6Q", 0);
      if (v2)
      {
        CFTypeID v3 = v2;
        _isValidSpecialCase_useSpecialCase = CFEqual(v2, @"CH") != 0;
        CFRelease(v3);
      }
      else
      {
        _isValidSpecialCase_useSpecialCase = 0;
      }
    }
  }
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(7uLL, (unint64_t)theString))
  {
    [(__CFString *)theString _cfTrim:trimString];
  }
  else
  {
    result.unint64_t location = 0;
    result.CFIndex length = 0;
    p_info = &theString->info;
    char v5 = atomic_load((unint64_t *)&theString->info);
    if (v5)
    {
      char v14 = atomic_load((unint64_t *)p_info);
      uint64_t v15 = v14 & 5;
      char v16 = atomic_load((unint64_t *)p_info);
      uint64_t v17 = v16 & 0x60;
      if (v15 == 4)
      {
        p_uint64_t data = &theString->data;
        if (v17)
        {
          int v19 = *p_data;
        }
        else
        {
          uint64_t v21 = atomic_load((unint64_t *)&theString->info);
          int v19 = (char *)&p_data[(v21 & 5) != 4];
        }
        CFIndex length = *v19;
      }
      else if ((v16 & 0x60) != 0)
      {
        CFIndex length = theString->length;
      }
      else
      {
        CFIndex length = (CFIndex)theString->data;
      }
      v45.unint64_t location = 0;
      v45.CFIndex length = length;
      if (CFStringFindWithOptionsAndLocale(theString, trimString, v45, 8uLL, 0, &result))
      {
        do
        {
          CFIndex v22 = result.length + result.location;
          CFIndex v23 = length - (result.length + result.location);
          v46.unint64_t location = result.length + result.location;
          v46.CFIndex length = v23;
        }
        while (CFStringFindWithOptionsAndLocale(theString, trimString, v46, 8uLL, 0, &result));
      }
      else
      {
        CFIndex v22 = 0;
        CFIndex v23 = length;
      }
      if (v22 >= length)
      {
        CFIndex v41 = 0;
        CFIndex v42 = length;
      }
      else
      {
        unint64_t v24 = atomic_load((unint64_t *)&theString->info);
        char v25 = atomic_load((unint64_t *)&theString->info);
        uint64_t v26 = &theString->data;
        if ((v25 & 0x60) != 0)
        {
          uint64_t v27 = *v26;
        }
        else
        {
          char v28 = atomic_load((unint64_t *)&theString->info);
          uint64_t v27 = (char *)&v26[(v28 & 5) != 4];
        }
        uint64_t v29 = (v24 >> 4) & 1;
        int v30 = &theString->info;
        unint64_t v31 = atomic_load((unint64_t *)&theString->info);
        uint64_t v32 = &v27[(v31 >> 2) & 1];
        if (CFStringGetLength(trimString) < v23)
        {
          while (1)
          {
            v47.unint64_t location = v22;
            v47.CFIndex length = v23;
            if (!CFStringFindWithOptionsAndLocale(theString, trimString, v47, 0xCuLL, 0, &result)) {
              break;
            }
            CFIndex v23 = result.location - v22;
          }
        }
        memmove(v32, &v32[v22 << v29], v23 << v29);
        char v33 = atomic_load((unint64_t *)v30);
        uint64_t v34 = v33 & 5;
        char v35 = atomic_load((unint64_t *)v30);
        uint64_t v36 = v35 & 0x60;
        if (v34 == 4)
        {
          if (v36)
          {
            uint64_t v37 = *v26;
          }
          else
          {
            char v39 = atomic_load((unint64_t *)&theString->info);
            uint64_t v37 = (char *)&v26[(v39 & 5) != 4];
          }
          uint64_t v38 = *v37;
        }
        else if (v36)
        {
          uint64_t v38 = theString->length;
        }
        else
        {
          uint64_t v38 = (uint64_t)*v26;
        }
        CFIndex v41 = v23;
        CFIndex v42 = v38 - v23;
      }
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, 0, 0);
    }
    else
    {
      uint64_t v6 = _CFOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        CFStringTrim_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
  }
}

void CFCharacterSetIntersect(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  unint64_t v2 = MEMORY[0x1F4188790](theSet, theOtherSet);
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  uint64_t v226 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    [(id)v5 formIntersectionWithCharacterSet:v4];
    return;
  }
  char v12 = atomic_load((unint64_t *)(v5 + 8));
  if ((v12 & 1) == 0)
  {
    CFLog(3, @"%s: Immutable character set passed to mutable function", v6, v7, v8, v9, v10, v11, (__int16)"void CFCharacterSetIntersect(CFMutableCharacterSetRef, CFCharacterSetRef)");
    if (dyld_program_sdk_at_least()) {
      CFCharacterSetIntersect_cold_1();
    }
  }
  char v13 = atomic_load((unint64_t *)(v5 + 8));
  if ((v13 & 0x70) != 0
    || (char v14 = atomic_load((unint64_t *)(v5 + 8)), (v14 & 1) != 0)
    || (char v15 = atomic_load((unint64_t *)(v5 + 8)), (v15 & 8) != 0)
    || CFCharacterSetGetPredefined(*(CFCharacterSetPredefinedSet *)(v5 + 24)) != (CFCharacterSetRef)v5)
  {
    uint64_t v16 = *(void *)(v5 + 40);
    if (!v16 || !*(_DWORD *)(v16 + 8) && !*(unsigned char *)(v16 + 13))
    {
      unsigned int v17 = atomic_load((unint64_t *)(v5 + 8));
      switch((v17 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (!*(void *)(v5 + 32)) {
            goto LABEL_19;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(v5 + 24)) {
            break;
          }
LABEL_19:
          char v18 = atomic_load((unint64_t *)(v5 + 8));
          if ((v18 & 8) != 0) {
            break;
          }
          return;
        default:
          break;
      }
    }
    if (CF_IS_OBJC(0x19uLL, v4))
    {
      uint64_t v19 = [(id)v4 _expandedCFCharacterSet];
      if (!v19)
      {
        CFDataRef BitmapRepresentation = CFCharacterSetCreateBitmapRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFCharacterSetRef)v4);
        if (BitmapRepresentation)
        {
          CFDataRef v21 = BitmapRepresentation;
          if (CFDataGetLength(BitmapRepresentation))
          {
            BytePtr = CFDataGetBytePtr(v21);
            if (BytePtr)
            {
              CFIndex v23 = BytePtr;
              __CFCSetMakeBitmap((char *)v5);
              uint64_t v24 = 0;
              uint64_t v25 = *(void *)(v5 + 24);
              do
              {
                *(_DWORD *)(v25 + v24) &= *(_DWORD *)&v23[v24];
                v24 += 4;
              }
              while (v24 != 0x2000);
              unint64_t v26 = atomic_load((unint64_t *)(v5 + 8));
              unint64_t v27 = v26;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v27, v26 & 0xFFFFFFFFFFFFFFFBLL);
                BOOL v28 = v27 == v26;
                unint64_t v26 = v27;
              }
              while (!v28);
            }
          }
          CFRelease(v21);
        }
        return;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    if (v19) {
      unint64_t v4 = v19;
    }
    uint64_t v29 = *(void *)(v4 + 40);
    if (!v29 || !*(_DWORD *)(v29 + 8) && !*(unsigned char *)(v29 + 13))
    {
      unsigned int v30 = atomic_load((unint64_t *)(v4 + 8));
      switch((v30 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v4 + 32)) {
            goto LABEL_41;
          }
          goto LABEL_137;
        case 3u:
        case 4u:
          if (*(void *)(v4 + 24)) {
            goto LABEL_41;
          }
LABEL_137:
          char v86 = atomic_load((unint64_t *)(v4 + 8));
          if ((v86 & 8) != 0) {
            goto LABEL_332;
          }
          char v87 = atomic_load((unint64_t *)(v5 + 8));
          if ((v87 & 0x70) == 0x20 && *(void *)(v5 + 24)
            || (char v88 = atomic_load((unint64_t *)(v5 + 8)), (v88 & 0x70) == 0x30) && *(void *)(v5 + 24)
            || (char v89 = atomic_load((unint64_t *)(v5 + 8)), (v89 & 0x70) == 0x40) && *(void *)(v5 + 24))
          {
            CFAllocatorRef v90 = CFGetAllocator((CFTypeRef)v5);
            CFAllocatorDeallocate(v90, *(void **)(v5 + 24));
          }
          unint64_t v91 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v92 = v91;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v92, v91 & 0xFFFFFFFFFFFFFF8FLL | 0x30);
            BOOL v28 = v92 == v91;
            unint64_t v91 = v92;
          }
          while (!v28);
          *(void *)(v5 + 24) = 0;
          unint64_t v93 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v94 = v93;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v94, v93 & 0xFFFFFFFFFFFFFFF7);
            BOOL v28 = v94 == v93;
            unint64_t v93 = v94;
          }
          while (!v28);
          *(void *)(v5 + 16) = 0;
          unint64_t v95 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v96 = v95;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v96, v95 | 4);
            BOOL v28 = v96 == v95;
            unint64_t v95 = v96;
          }
          while (!v28);
          if (!*(void *)(v5 + 40)) {
            goto LABEL_332;
          }
          for (uint64_t i = 0; i != 16; ++i)
          {
            uint64_t v98 = *(void *)(v5 + 40);
            if (((*(_DWORD *)(v98 + 8) >> i) & 2) != 0) {
              CFRelease(*(CFTypeRef *)(*(void *)v98 + 8 * i));
            }
          }
          break;
        default:
          goto LABEL_41;
      }
LABEL_202:
      CFAllocatorRef v123 = CFGetAllocator((CFTypeRef)v5);
      CFAllocatorDeallocate(v123, **(void ***)(v5 + 40));
      CFAllocatorRef v124 = CFGetAllocator((CFTypeRef)v5);
      CFAllocatorDeallocate(v124, *(void **)(v5 + 40));
      *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      goto LABEL_332;
    }
LABEL_41:
    uint64_t v31 = *(void *)(v5 + 40);
    if (!v31 || !*(_DWORD *)(v31 + 8) && !*(unsigned char *)(v31 + 13))
    {
      unsigned int v32 = atomic_load((unint64_t *)(v5 + 8));
      switch((v32 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v5 + 32)) {
            goto LABEL_46;
          }
          goto LABEL_204;
        case 3u:
        case 4u:
          if (*(void *)(v5 + 24)) {
            goto LABEL_46;
          }
LABEL_204:
          char v125 = atomic_load((unint64_t *)(v4 + 8));
          uint64_t v126 = v125 & 0x70;
          unint64_t v127 = atomic_load((unint64_t *)(v5 + 8));
          unint64_t v128 = v127;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v128, v127 & 0xFFFFFFFFFFFFFF8FLL | v126);
            BOOL v28 = v128 == v127;
            unint64_t v127 = v128;
          }
          while (!v28);
          char v129 = atomic_load((unint64_t *)(v4 + 8));
          unint64_t v130 = atomic_load((unint64_t *)(v5 + 8));
          uint64_t v131 = v129 & 4;
          unint64_t v132 = v130;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v132, v130 & 0xFFFFFFFFFFFFFFFBLL | v131);
            BOOL v28 = v132 == v130;
            unint64_t v130 = v132;
          }
          while (!v28);
          char v133 = atomic_load((unint64_t *)(v4 + 8));
          unint64_t v134 = atomic_load((unint64_t *)(v5 + 8));
          uint64_t v135 = v133 & 8;
          unint64_t v136 = v134;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v136, v134 & 0xFFFFFFFFFFFFFFF7 | v135);
            BOOL v28 = v136 == v134;
            unint64_t v134 = v136;
          }
          while (!v28);
          *(void *)(v5 + 16) = *(void *)(v4 + 16);
          uint64_t v137 = *(void *)(v4 + 40);
          if (!v137 || !*(_DWORD *)(v137 + 8)) {
            goto LABEL_321;
          }
          uint64_t v138 = 0;
          uint64_t v139 = 1;
          break;
        default:
          goto LABEL_46;
      }
      while (1)
      {
        uint64_t v140 = *(void *)(v4 + 40);
        if (v140)
        {
          int v141 = 1 << v139;
          if ((*(_DWORD *)(v140 + 8) & (1 << v139)) != 0
            && *(unsigned __int8 *)(v140 + 12) >= v139)
          {
            int v142 = *(unint64_t **)(*(void *)v140 + v138);
            if (v142) {
              break;
            }
          }
        }
LABEL_233:
        ++v139;
        v138 += 8;
        if (v139 == 17)
        {
          uint64_t v153 = *(void *)(v4 + 40);
          if (v153)
          {
            uint64_t Typed = *(void *)(v5 + 40);
            if (*(unsigned char *)(v153 + 13))
            {
              if (!Typed)
              {
                CFAllocatorRef v155 = CFGetAllocator((CFTypeRef)v5);
                uint64_t Typed = CFAllocatorAllocateTyped(v155, 16, 0x1080040FC6463CFLL, 0);
                *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = Typed;
                *(void *)uint64_t Typed = 0;
                *(void *)(Typed + 6) = 0;
              }
              char v156 = 1;
LABEL_320:
              *(unsigned char *)(Typed + 13) = v156;
              goto LABEL_321;
            }
          }
          else
          {
            uint64_t Typed = *(void *)(v5 + 40);
          }
          if (Typed)
          {
            char v156 = 0;
            goto LABEL_320;
          }
LABEL_321:
          unsigned int v202 = atomic_load((unint64_t *)(v4 + 8));
          switch((v202 >> 4) & 7)
          {
            case 0u:
              *(void *)(v5 + 24) = *(void *)(v4 + 24);
              break;
            case 1u:
              *(_DWORD *)(v5 + 24) = *(_DWORD *)(v4 + 24);
              *(void *)(v5 + 32) = *(void *)(v4 + 32);
              break;
            case 2u:
              uint64_t v203 = *(void *)(v4 + 32);
              *(void *)(v5 + 32) = v203;
              long long v204 = *(void **)(v5 + 24);
              if (!v204)
              {
                CFAllocatorRef v205 = CFGetAllocator((CFTypeRef)v5);
                long long v204 = (void *)CFAllocatorAllocateTyped(v205, 128, 0x1000040BDFB0063, 0);
                *(void *)(v5 + 24) = v204;
                uint64_t v203 = *(void *)(v5 + 32);
              }
              long long v206 = *(const void **)(v4 + 24);
              size_t v207 = 2 * v203;
              goto LABEL_331;
            case 3u:
              CFAllocatorRef v208 = CFGetAllocator((CFTypeRef)v5);
              long long v204 = (void *)CFAllocatorAllocateTyped(v208, 0x2000, 0x100004077774924, 0);
              *(void *)(v5 + 24) = v204;
              long long v206 = *(const void **)(v4 + 24);
              size_t v207 = 0x2000;
              goto LABEL_331;
            case 4u:
              uint64_t v209 = 0;
              int32x4_t v210 = (int32x4_t)xmmword_182D9E900;
              uint64_t v211 = *(char **)(v4 + 24);
              int32x4_t v212 = 0uLL;
              v213.i64[0] = -1;
              v213.i64[1] = -1;
              v214.i64[0] = 0xFEFEFEFEFEFEFEFELL;
              v214.i64[1] = 0xFEFEFEFEFEFEFEFELL;
              v215.i64[0] = 0x2000000020;
              v215.i64[1] = 0x2000000020;
              int32x4_t v216 = 0uLL;
              int32x4_t v217 = 0uLL;
              do
              {
                int8x16_t v218 = (int8x16_t)vcgtq_u8(v214, (uint8x16_t)vaddq_s8(*(int8x16_t *)&v211[v209], v213));
                int16x8_t v219 = vmovl_s8(*(int8x8_t *)v218.i8);
                int16x8_t v220 = vmovl_high_s8(v218);
                int32x4_t v217 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v220), (int8x16_t)vaddq_s32(v217, v215), (int8x16_t)v217);
                int32x4_t v216 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v220.i8), (int8x16_t)vaddq_s32(v216, v215), (int8x16_t)v216);
                int32x4_t v212 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v219), (int8x16_t)vaddq_s32(v212, v215), (int8x16_t)v212);
                int32x4_t v210 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v219.i8), (int8x16_t)vaddq_s32(v210, v215), (int8x16_t)v210);
                v209 += 16;
              }
              while (v209 != 256);
              size_t v221 = vaddvq_s32(vaddq_s32(vaddq_s32(v210, v216), vaddq_s32(v212, v217)));
              CFAllocatorRef v222 = CFGetAllocator((CFTypeRef)v5);
              long long v204 = (void *)CFAllocatorAllocateTyped(v222, v221, 0x100004077774924, 0);
              *(void *)(v5 + 24) = v204;
              long long v206 = v211;
              size_t v207 = v221;
LABEL_331:
              memmove(v204, v206, v207);
              break;
            default:
              break;
          }
LABEL_332:
          if (__CFCheckForExapendedSet == 1) {
            __CFCheckForExpandedSet((const char *)v5);
          }
          return;
        }
      }
      CFAllocatorRef v143 = CFGetAllocator((CFTypeRef)v5);
      CFSetRef Copy = __CFCharacterSetCreateCopy(v143, v142, 1, 1);
      char v145 = *(uint64_t **)(v5 + 40);
      if (v145)
      {
        if (*((unsigned __int8 *)v145 + 12) >= v139)
        {
LABEL_227:
          if ((v145[1] & v141) != 0) {
            CFRelease(*(CFTypeRef *)(*v145 + v138));
          }
          if (Copy)
          {
            *(void *)(**(void **)(v5 + 40) + v138) = CFRetain(Copy);
            uint64_t v151 = *(void *)(v5 + 40);
            int v152 = *(_DWORD *)(v151 + 8) | v141;
          }
          else
          {
            uint64_t v151 = *(void *)(v5 + 40);
            int v152 = *(_DWORD *)(v151 + 8) & ~v141;
          }
          *(_DWORD *)(v151 + 8) = v152;
          CFRelease(Copy);
          goto LABEL_233;
        }
        *((unsigned char *)v145 + 12) = v139;
        uint64_t v146 = *v145;
        CFAllocatorRef v147 = CFGetAllocator((CFTypeRef)v5);
        if (v146)
        {
          uint64_t v148 = __CFSafelyReallocateWithAllocatorTyped(v147, **(void **)(v5 + 40), v138 + 8, 0x6004044C4A2DFLL, 0, 0);
LABEL_226:
          char v145 = *(uint64_t **)(v5 + 40);
          *char v145 = v148;
          goto LABEL_227;
        }
      }
      else
      {
        CFAllocatorRef v149 = CFGetAllocator((CFTypeRef)v5);
        uint64_t v150 = CFAllocatorAllocateTyped(v149, 16, 0x1080040FC6463CFLL, 0);
        *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v150;
        *(_WORD *)(v150 + 12) = v139;
        *(_DWORD *)(v150 + 8) = 0;
        CFAllocatorRef v147 = CFGetAllocator((CFTypeRef)v5);
      }
      uint64_t v148 = CFAllocatorAllocateTyped(v147, v138 + 8, 0x6004044C4A2DFLL, 0);
      goto LABEL_226;
    }
LABEL_46:
    __CFCSetMakeBitmap((char *)v5);
    char v33 = atomic_load((unint64_t *)(v4 + 8));
    uint64_t v34 = *(void *)(v5 + 24);
    if ((v33 & 0x70) == 0x30)
    {
      uint64_t v35 = 0;
      uint64_t v36 = *(void *)(v4 + 24);
      do
      {
        *(_DWORD *)(v34 + v35) &= *(_DWORD *)(v36 + v35);
        v35 += 4;
      }
      while (v35 != 0x2000);
    }
    else
    {
      __CFCSetGetBitmap(v4, __b);
      for (uint64_t j = 0; j != 2048; ++j)
        *(_DWORD *)(v34 + j * 4) &= __b[0].u32[j];
    }
    unint64_t v38 = atomic_load((unint64_t *)(v5 + 8));
    unint64_t v39 = v38;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 8), &v39, v38 & 0xFFFFFFFFFFFFFFFBLL);
      BOOL v28 = v39 == v38;
      unint64_t v38 = v39;
    }
    while (!v28);
    uint64_t v40 = *(void *)(v4 + 40);
    if (v40 && *(_DWORD *)(v40 + 8))
    {
      CFCharacterSetRef Mutable = CFCharacterSetCreateMutable(0);
      uint64_t v42 = 0;
      uint64_t v43 = 1;
      while (1)
      {
        uint64_t v44 = *(void *)(v4 + 40);
        if (v44)
        {
          int v45 = 1 << v43;
          if ((*(_DWORD *)(v44 + 8) & (1 << v43)) != 0
            && *(unsigned __int8 *)(v44 + 12) >= v43)
          {
            CFRange v46 = *(__CFCharacterSet **)(*(void *)v44 + v42);
            if (v46) {
              break;
            }
          }
        }
        uint64_t v51 = *(uint64_t **)(v5 + 40);
        if (v51)
        {
          int v52 = 1 << v43;
          if ((v51[1] & (1 << v43)) != 0)
          {
            if (*((unsigned __int8 *)v51 + 12) >= v43)
            {
              CFMutableCharacterSetRef v53 = *(CFMutableCharacterSetRef *)(*v51 + v42);
              if (v53)
              {
                if (!*((unsigned char *)v51 + 13))
                {
                  CFRelease(v53);
                  uint64_t v68 = *(uint64_t **)(v5 + 40);
                  int v69 = v68[1] & ~v52;
LABEL_110:
                  *((_DWORD *)v68 + 2) = v69;
                  goto LABEL_117;
                }
                CFCharacterSetInvert(v53);
                CFCharacterSetIntersect(v53, Mutable);
                goto LABEL_108;
              }
            }
            if (*((unsigned __int8 *)v51 + 12) >= v43 && *(void *)(*v51 + v42)) {
              goto LABEL_117;
            }
          }
          if (!*((unsigned char *)v51 + 13)) {
            goto LABEL_117;
          }
          if (*((unsigned __int8 *)v51 + 12) < v43)
          {
            *((unsigned char *)v51 + 12) = v43;
            uint64_t v54 = *v51;
            CFAllocatorRef v55 = CFGetAllocator((CFTypeRef)v5);
            if (v54) {
              uint64_t v56 = __CFSafelyReallocateWithAllocatorTyped(v55, **(void **)(v5 + 40), v42 + 8, 0x6004044C4A2DFLL, 0, 0);
            }
            else {
              uint64_t v56 = CFAllocatorAllocateTyped(v55, v42 + 8, 0x6004044C4A2DFLL, 0);
            }
            uint64_t v51 = *(uint64_t **)(v5 + 40);
            *uint64_t v51 = v56;
          }
          if ((v51[1] & v52) != 0)
          {
            uint64_t v65 = (CFMutableCharacterSetRef *)(*v51 + v42);
          }
          else
          {
            CFAllocatorRef v66 = CFGetAllocator((CFTypeRef)v5);
            *(void *)(**(void **)(v5 + 40) + v42) = CFCharacterSetCreateMutable(v66);
            uint64_t v51 = *(uint64_t **)(v5 + 40);
            *((_DWORD *)v51 + 2) |= v52;
            uint64_t v65 = (CFMutableCharacterSetRef *)(*v51 + 8 * v43 - 8);
          }
          CFMutableCharacterSetRef v53 = *v65;
          if (*((unsigned char *)v51 + 13)) {
            CFCharacterSetInvert(*v65);
          }
          CFCharacterSetIntersect(v53, Mutable);
          uint64_t v67 = *(void *)(v5 + 40);
          if (!v67 || !*(unsigned char *)(v67 + 13)) {
            goto LABEL_117;
          }
LABEL_108:
          CFCharacterSetInvert(v53);
        }
LABEL_117:
        ++v43;
        v42 += 8;
        if (v42 == 128)
        {
          CFRelease(Mutable);
          uint64_t v83 = *(void *)(v5 + 40);
          if (!v83 || *(_DWORD *)(v83 + 8)) {
            goto LABEL_332;
          }
          for (uint64_t k = 0; k != 16; ++k)
          {
            uint64_t v85 = *(void *)(v5 + 40);
            if (((*(_DWORD *)(v85 + 8) >> k) & 2) != 0) {
              CFRelease(*(CFTypeRef *)(*(void *)v85 + 8 * k));
            }
          }
          goto LABEL_202;
        }
      }
      if (*(unsigned char *)(v44 + 13)) {
        CFCharacterSetInvert(v46);
      }
      CFRange v47 = *(uint64_t **)(v5 + 40);
      if (v47)
      {
        if (*((unsigned __int8 *)v47 + 12) >= v43) {
          goto LABEL_83;
        }
        *((unsigned char *)v47 + 12) = v43;
        uint64_t v48 = *v47;
        CFAllocatorRef v49 = CFGetAllocator((CFTypeRef)v5);
        if (v48)
        {
          uint64_t v50 = __CFSafelyReallocateWithAllocatorTyped(v49, **(void **)(v5 + 40), v42 + 8, 0x6004044C4A2DFLL, 0, 0);
LABEL_82:
          CFRange v47 = *(uint64_t **)(v5 + 40);
          *CFRange v47 = v50;
LABEL_83:
          if ((v47[1] & v45) == 0)
          {
            CFAllocatorRef v59 = CFGetAllocator((CFTypeRef)v5);
            *(void *)(**(void **)(v5 + 40) + v42) = CFCharacterSetCreateMutable(v59);
            CFRange v47 = *(uint64_t **)(v5 + 40);
            *((_DWORD *)v47 + 2) |= v45;
          }
          uint64_t v60 = *(unint64_t **)(*v47 + v42);
          if (*((unsigned char *)v47 + 13)) {
            CFCharacterSetInvert((CFMutableCharacterSetRef)v60);
          }
          CFCharacterSetIntersect((CFMutableCharacterSetRef)v60, v46);
          uint64_t v61 = *(void *)(v5 + 40);
          if (v61 && *(unsigned char *)(v61 + 13)) {
            CFCharacterSetInvert((CFMutableCharacterSetRef)v60);
          }
          uint64_t v62 = *(void *)(v4 + 40);
          if (v62 && *(unsigned char *)(v62 + 13)) {
            CFCharacterSetInvert(v46);
          }
          unint64_t v63 = v60[5];
          if (!v63 || !*(_DWORD *)(v63 + 8) && !*(unsigned char *)(v63 + 13))
          {
            unsigned int v64 = atomic_load(v60 + 1);
            switch((v64 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (!v60[4]) {
                  goto LABEL_112;
                }
                goto LABEL_117;
              case 3u:
              case 4u:
                if (v60[3]) {
                  goto LABEL_117;
                }
LABEL_112:
                char v70 = atomic_load(v60 + 1);
                if ((v70 & 8) != 0) {
                  goto LABEL_117;
                }
                uint64_t v68 = *(uint64_t **)(v5 + 40);
                if (v68)
                {
                  if (*((unsigned __int8 *)v68 + 12) >= v43)
                  {
LABEL_122:
                    int v76 = *((_DWORD *)v68 + 2);
                    if ((v76 & v45) != 0)
                    {
                      CFRelease(*(CFTypeRef *)(*v68 + v42));
                      uint64_t v68 = *(uint64_t **)(v5 + 40);
                      int v76 = *((_DWORD *)v68 + 2);
                    }
                    int v69 = v76 & ~v45;
                    goto LABEL_110;
                  }
                  *((unsigned char *)v68 + 12) = v43;
                  uint64_t v71 = *v68;
                  CFAllocatorRef v72 = CFGetAllocator((CFTypeRef)v5);
                  if (v71)
                  {
                    uint64_t v73 = __CFSafelyReallocateWithAllocatorTyped(v72, **(void **)(v5 + 40), v42 + 8, 0x6004044C4A2DFLL, 0, 0);
LABEL_121:
                    uint64_t v68 = *(uint64_t **)(v5 + 40);
                    *uint64_t v68 = v73;
                    goto LABEL_122;
                  }
                }
                else
                {
                  CFAllocatorRef v74 = CFGetAllocator((CFTypeRef)v5);
                  uint64_t v75 = CFAllocatorAllocateTyped(v74, 16, 0x1080040FC6463CFLL, 0);
                  *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v75;
                  *(_WORD *)(v75 + 12) = v43;
                  *(_DWORD *)(v75 + 8) = 0;
                  CFAllocatorRef v72 = CFGetAllocator((CFTypeRef)v5);
                }
                uint64_t v73 = CFAllocatorAllocateTyped(v72, v42 + 8, 0x6004044C4A2DFLL, 0);
                goto LABEL_121;
              default:
                goto LABEL_117;
            }
          }
          goto LABEL_117;
        }
      }
      else
      {
        CFAllocatorRef v57 = CFGetAllocator((CFTypeRef)v5);
        uint64_t v58 = CFAllocatorAllocateTyped(v57, 16, 0x1080040FC6463CFLL, 0);
        *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v58;
        *(_WORD *)(v58 + 12) = v43;
        *(_DWORD *)(v58 + 8) = 0;
        CFAllocatorRef v49 = CFGetAllocator((CFTypeRef)v5);
      }
      uint64_t v50 = CFAllocatorAllocateTyped(v49, v42 + 8, 0x6004044C4A2DFLL, 0);
      goto LABEL_82;
    }
    char v77 = atomic_load((unint64_t *)(v4 + 8));
    if ((v77 & 0x70) == 0)
    {
      uint64_t v103 = *(void *)(v4 + 40);
      if (!v103 || !*(unsigned char *)(v103 + 13))
      {
        unint64_t v104 = 1;
        while (1)
        {
          uint64_t v105 = *(void *)(v5 + 40);
          if (v105)
          {
            int v106 = 1 << v104;
            if ((*(_DWORD *)(v105 + 8) & (1 << v104)) != 0 && v104 <= *(unsigned __int8 *)(v105 + 12))
            {
              uint64_t v107 = *(void *)(*(void *)v105 + 8 * (v104 - 1));
              if (v107)
              {
                int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v4 + 24), v104, __b, 0);
                if (!BitmapForPlane)
                {
                  __CFCSetMakeBitmap((char *)v107);
                  uint64_t v109 = 0;
                  uint64_t v110 = *(void *)(v107 + 24);
                  char v111 = 1;
                  do
                  {
                    int v112 = *(_DWORD *)(v110 + v109 * 4);
                    BOOL v28 = (v112 & __b[0].i32[v109]) == 0;
                    *(_DWORD *)(v110 + v109 * 4) = v112 & __b[0].i32[v109];
                    if (!v28) {
                      char v111 = 0;
                    }
                    ++v109;
                  }
                  while (v109 != 2048);
                  if (!v111) {
                    goto LABEL_195;
                  }
LABEL_185:
                  int v113 = *(uint64_t **)(v5 + 40);
                  if (v113)
                  {
                    if (v104 > *((unsigned __int8 *)v113 + 12))
                    {
                      *((unsigned char *)v113 + 12) = v104;
                      uint64_t v114 = *v113;
                      CFAllocatorRef v115 = CFGetAllocator((CFTypeRef)v5);
                      if (v114)
                      {
                        uint64_t v116 = __CFSafelyReallocateWithAllocatorTyped(v115, **(void **)(v5 + 40), 8 * v104, 0x6004044C4A2DFLL, 0, 0);
                        goto LABEL_191;
                      }
LABEL_190:
                      uint64_t v116 = CFAllocatorAllocateTyped(v115, 8 * v104, 0x6004044C4A2DFLL, 0);
LABEL_191:
                      int v113 = *(uint64_t **)(v5 + 40);
                      *int v113 = v116;
                    }
                    int v119 = *((_DWORD *)v113 + 2);
                    if ((v119 & v106) != 0)
                    {
                      CFRelease(*(CFTypeRef *)(*v113 + 8 * (v104 - 1)));
                      int v113 = *(uint64_t **)(v5 + 40);
                      int v119 = *((_DWORD *)v113 + 2);
                    }
                    *((_DWORD *)v113 + 2) = v119 & ~v106;
                    goto LABEL_195;
                  }
                  CFAllocatorRef v117 = CFGetAllocator((CFTypeRef)v5);
                  uint64_t v118 = CFAllocatorAllocateTyped(v117, 16, 0x1080040FC6463CFLL, 0);
                  *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v118;
                  *(unsigned char *)(v118 + 12) = v104;
                  *(unsigned char *)(v118 + 13) = 0;
                  *(_DWORD *)(v118 + 8) = 0;
                  CFAllocatorRef v115 = CFGetAllocator((CFTypeRef)v5);
                  goto LABEL_190;
                }
                if (BitmapForPlane == 255) {
                  goto LABEL_185;
                }
              }
            }
          }
LABEL_195:
          if (++v104 == 17)
          {
            uint64_t v120 = *(void *)(v5 + 40);
            if (!v120 || *(_DWORD *)(v120 + 8)) {
              goto LABEL_332;
            }
            for (uint64_t m = 0; m != 16; ++m)
            {
              uint64_t v122 = *(void *)(v5 + 40);
              if (((*(_DWORD *)(v122 + 8) >> m) & 2) != 0) {
                CFRelease(*(CFTypeRef *)(*(void *)v122 + 8 * m));
              }
            }
            goto LABEL_202;
          }
        }
      }
    }
    char v78 = atomic_load((unint64_t *)(v4 + 8));
    if ((v78 & 0x70) != 0x10)
    {
      uint64_t v99 = *(void *)(v5 + 40);
      if (!v99 || !*(_DWORD *)(v99 + 8) && !*(unsigned char *)(v99 + 13)) {
        goto LABEL_332;
      }
      uint64_t v100 = *(void *)(v4 + 40);
      if (v100)
      {
        if (*(unsigned char *)(v100 + 13)) {
          goto LABEL_332;
        }
      }
      for (uint64_t n = 0; n != 16; ++n)
      {
        uint64_t v102 = *(void *)(v5 + 40);
        if (((*(_DWORD *)(v102 + 8) >> n) & 2) != 0) {
          CFRelease(*(CFTypeRef *)(*(void *)v102 + 8 * n));
        }
      }
      goto LABEL_202;
    }
    CFAllocatorRef v79 = CFGetAllocator((CFTypeRef)v5);
    CFMutableCharacterSetRef v80 = CFCharacterSetCreateMutable(v79);
    CFCharacterSetRef theOtherSeta = CFCharacterSetCreateMutable(0);
    __CFCSetAddNonBMPPlanesInRange(v80, *(unsigned int *)(v4 + 24), *(void *)(v4 + 32));
    uint64_t v81 = *(void *)(v5 + 40);
    if (v81) {
      BOOL v82 = *(unsigned __int8 *)(v81 + 13) != 0;
    }
    else {
      BOOL v82 = 0;
    }
    uint64_t v157 = *((void *)v80 + 5);
    if (v157) {
      BOOL v223 = *(unsigned __int8 *)(v157 + 13) != 0;
    }
    else {
      BOOL v223 = 0;
    }
    uint64_t v158 = 0;
    uint64_t v159 = 8;
    uint64_t v160 = 1;
    while (1)
    {
      char v161 = v158 + 1;
      unsigned int v162 = (v158 + 1);
      uint64_t v163 = *((void *)v80 + 5);
      if (v163)
      {
        int v164 = 1 << v161;
        if ((*(_DWORD *)(v163 + 8) & (1 << v161)) != 0 && *(unsigned __int8 *)(v163 + 12) >= v162)
        {
          CFRange v165 = *(__CFCharacterSet **)(*(void *)v163 + 8 * v158);
          if (v165) {
            break;
          }
        }
      }
      uint64_t v170 = *(uint64_t **)(v5 + 40);
      if (v170)
      {
        int v164 = 1 << v161;
        if ((v170[1] & (1 << v161)) == 0) {
          goto LABEL_263;
        }
        if (*((unsigned __int8 *)v170 + 12) >= v162)
        {
          uint64_t v171 = *(__CFCharacterSet **)(*v170 + 8 * v158);
          if (v171)
          {
            if (!v82)
            {
              v172 = *(const void **)(*v170 + 8 * v158);
LABEL_258:
              CFRelease(v172);
              int v173 = *(uint64_t **)(v5 + 40);
              int v174 = *((_DWORD *)v173 + 2);
LABEL_259:
              *((_DWORD *)v173 + 2) = v174 & ~v164;
              goto LABEL_278;
            }
            goto LABEL_277;
          }
        }
        if (*((unsigned __int8 *)v170 + 12) >= v162) {
          uint64_t v178 = *(void *)(*v170 + 8 * v158);
        }
        else {
LABEL_263:
        }
          uint64_t v178 = 0;
        if (v178) {
          BOOL v179 = 0;
        }
        else {
          BOOL v179 = v82;
        }
        if (!v179) {
          goto LABEL_278;
        }
        if (*((unsigned __int8 *)v170 + 12) < v162)
        {
          *((unsigned char *)v170 + 12) = v162;
          uint64_t v180 = *v170;
          CFAllocatorRef v177 = CFGetAllocator((CFTypeRef)v5);
          if (v180) {
            uint64_t v181 = __CFSafelyReallocateWithAllocatorTyped(v177, **(void **)(v5 + 40), v159, 0x6004044C4A2DFLL, 0, 0);
          }
          else {
LABEL_272:
          }
            uint64_t v181 = CFAllocatorAllocateTyped(v177, v159, 0x6004044C4A2DFLL, 0);
          uint64_t v170 = *(uint64_t **)(v5 + 40);
          *uint64_t v170 = v181;
        }
        uint64_t v182 = v158;
        if ((v170[1] & (1 << v161)) == 0)
        {
          CFAllocatorRef v183 = CFGetAllocator((CFTypeRef)v5);
          CFMutableCharacterSetRef v184 = CFCharacterSetCreateMutable(v183);
          uint64_t v182 = v160 - 1;
          *(void *)(**(void **)(v5 + 40) + 8 * v158) = v184;
          uint64_t v170 = *(uint64_t **)(v5 + 40);
          *((_DWORD *)v170 + 2) |= 1 << v161;
        }
        uint64_t v171 = *(__CFCharacterSet **)(*v170 + 8 * v182);
LABEL_277:
        CFCharacterSetInvert(v171);
        CFCharacterSetIntersect(v171, theOtherSeta);
        CFCharacterSetInvert(v171);
        goto LABEL_278;
      }
      if (v82)
      {
        CFAllocatorRef v175 = CFGetAllocator((CFTypeRef)v5);
        uint64_t v176 = CFAllocatorAllocateTyped(v175, 16, 0x1080040FC6463CFLL, 0);
        *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v176;
        *(_WORD *)(v176 + 12) = v162;
        *(_DWORD *)(v176 + 8) = 0;
        CFAllocatorRef v177 = CFGetAllocator((CFTypeRef)v5);
        goto LABEL_272;
      }
LABEL_278:
      ++v160;
      ++v158;
      v159 += 8;
      if (v158 == 16)
      {
        uint64_t v197 = *(void *)(v5 + 40);
        if (v197 && !*(_DWORD *)(v197 + 8))
        {
          for (iuint64_t i = 0; ii != 16; ++ii)
          {
            uint64_t v199 = *(void *)(v5 + 40);
            if (((*(_DWORD *)(v199 + 8) >> ii) & 2) != 0) {
              CFRelease(*(CFTypeRef *)(*(void *)v199 + 8 * ii));
            }
          }
          CFAllocatorRef v200 = CFGetAllocator((CFTypeRef)v5);
          CFAllocatorDeallocate(v200, **(void ***)(v5 + 40));
          CFAllocatorRef v201 = CFGetAllocator((CFTypeRef)v5);
          CFAllocatorDeallocate(v201, *(void **)(v5 + 40));
          *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
        }
        CFRelease(v80);
        CFRelease(theOtherSeta);
        goto LABEL_332;
      }
    }
    __int16 v166 = *(uint64_t **)(v5 + 40);
    if (v166)
    {
      if (*((unsigned __int8 *)v166 + 12) >= v162) {
        goto LABEL_283;
      }
      *((unsigned char *)v166 + 12) = v162;
      uint64_t v167 = *v166;
      CFAllocatorRef v168 = CFGetAllocator((CFTypeRef)v5);
      if (v167)
      {
        uint64_t v169 = __CFSafelyReallocateWithAllocatorTyped(v168, **(void **)(v5 + 40), v159, 0x6004044C4A2DFLL, 0, 0);
LABEL_282:
        __int16 v166 = *(uint64_t **)(v5 + 40);
        *__int16 v166 = v169;
LABEL_283:
        if ((v166[1] & v164) == 0)
        {
          CFAllocatorRef v187 = CFGetAllocator((CFTypeRef)v5);
          *(void *)(**(void **)(v5 + 40) + 8 * v158) = CFCharacterSetCreateMutable(v187);
          __int16 v166 = *(uint64_t **)(v5 + 40);
          *((_DWORD *)v166 + 2) |= v164;
        }
        v188 = *(unint64_t **)(*v166 + 8 * v158);
        if (v223) {
          CFCharacterSetInvert(v165);
        }
        if (v82)
        {
          CFCharacterSetInvert((CFMutableCharacterSetRef)v188);
          CFCharacterSetIntersect((CFMutableCharacterSetRef)v188, v165);
          CFCharacterSetInvert((CFMutableCharacterSetRef)v188);
        }
        else
        {
          CFCharacterSetIntersect((CFMutableCharacterSetRef)v188, v165);
        }
        if (v223) {
          CFCharacterSetInvert(v165);
        }
        unint64_t v189 = v188[5];
        if (!v189 || !*(_DWORD *)(v189 + 8) && !*(unsigned char *)(v189 + 13))
        {
          unsigned int v190 = atomic_load(v188 + 1);
          switch((v190 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (!v188[4]) {
                goto LABEL_299;
              }
              goto LABEL_278;
            case 3u:
            case 4u:
              if (v188[3]) {
                goto LABEL_278;
              }
LABEL_299:
              char v191 = atomic_load(v188 + 1);
              if ((v191 & 8) != 0) {
                goto LABEL_278;
              }
              int v173 = *(uint64_t **)(v5 + 40);
              if (v173)
              {
                if (*((unsigned __int8 *)v173 + 12) >= v162)
                {
LABEL_307:
                  int v174 = *((_DWORD *)v173 + 2);
                  if ((v174 & v164) == 0) {
                    goto LABEL_259;
                  }
                  v172 = *(const void **)(*v173 + 8 * v158);
                  goto LABEL_258;
                }
                *((unsigned char *)v173 + 12) = v162;
                uint64_t v192 = *v173;
                CFAllocatorRef v193 = CFGetAllocator((CFTypeRef)v5);
                if (v192)
                {
                  uint64_t v194 = __CFSafelyReallocateWithAllocatorTyped(v193, **(void **)(v5 + 40), v159, 0x6004044C4A2DFLL, 0, 0);
LABEL_306:
                  int v173 = *(uint64_t **)(v5 + 40);
                  *int v173 = v194;
                  goto LABEL_307;
                }
              }
              else
              {
                CFAllocatorRef v195 = CFGetAllocator((CFTypeRef)v5);
                uint64_t v196 = CFAllocatorAllocateTyped(v195, 16, 0x1080040FC6463CFLL, 0);
                *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v196;
                *(_WORD *)(v196 + 12) = v162;
                *(_DWORD *)(v196 + 8) = 0;
                CFAllocatorRef v193 = CFGetAllocator((CFTypeRef)v5);
              }
              uint64_t v194 = CFAllocatorAllocateTyped(v193, v159, 0x6004044C4A2DFLL, 0);
              goto LABEL_306;
            default:
              goto LABEL_278;
          }
        }
        goto LABEL_278;
      }
    }
    else
    {
      CFAllocatorRef v185 = CFGetAllocator((CFTypeRef)v5);
      uint64_t v186 = CFAllocatorAllocateTyped(v185, 16, 0x1080040FC6463CFLL, 0);
      *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v186;
      *(_WORD *)(v186 + 12) = v162;
      *(_DWORD *)(v186 + 8) = 0;
      CFAllocatorRef v168 = CFGetAllocator((CFTypeRef)v5);
    }
    uint64_t v169 = CFAllocatorAllocateTyped(v168, v159, 0x6004044C4A2DFLL, 0);
    goto LABEL_282;
  }
}

void ___legacyStreamRunLoop_block_invoke()
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  sLegacyRL = 0;
  dispatch_semaphore_t dsema = dispatch_semaphore_create(0);
  memset(&__attr, 0, sizeof(__attr));
  pthread_attr_init(&__attr);
  pthread_attr_setdetachstate(&__attr, 2);
  qos_class_t v0 = qos_class_main();
  pthread_attr_set_qos_class_np(&__attr, v0, 0);
  pthread_t v1 = 0;
  pthread_create(&v1, &__attr, (void *(__cdecl *)(void *))_legacyStreamRunLoop_workThread, &dsema);
  pthread_attr_destroy(&__attr);
  dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(dsema);
}

void _cfmp_record_nsmachport_is_interested(unsigned __int8 a1, int a2)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    if (_cfmp_records_oGuard != -1) {
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    }
    CFSetRef v4 = (const __CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    v6[0] = a2;
    v6[1] = a1;
    CFStringRef Value = CFSetGetValue(v4, v6);
    if (Value) {
      Value[5] |= 0x20u;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
  }
}

void ____initDayChangedNotification_block_invoke()
{
  qos_class_t v0 = qos_class_main();
  global_queue = dispatch_get_global_queue(v0, 2uLL);
  __CFMidnightTimer = (uint64_t)dispatch_source_create((dispatch_source_type_t)off_1ECE0A620, 0, 0, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)__CFMidnightTimer, &__block_literal_global_3);
  __postAndResetMidnight(0, 0);
  unint64_t v2 = __CFMidnightTimer;

  dispatch_resume(v2);
}

void __postAndResetMidnight(int a1, int a2)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  v10.tv_sec = 0;
  *(void *)&v10.tv_usec = 0;
  memset(&v9, 0, sizeof(v9));
  gettimeofday(&v10, 0);
  localtime_r(&v10.tv_sec, &v9);
  uint64_t v4 = (v9.tm_gmtoff + v10.tv_sec) / 86400;
  if (a1 && v4 < __CFLastLocalMidnightDay || a2 && v4 > __CFLastLocalMidnightDay)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    atomic_fetch_add(&__CFMidnightNoteCount, 1uLL);
    CFNotificationCenterPostNotification(LocalCenter, @"NSCalendarDayChangedNotification", 0, 0, 1u);
  }
  gettimeofday(&v10, 0);
  localtime_r(&v10.tv_sec, &v9);
  __CFLastLocalMidnightDay = (v10.tv_sec + v9.tm_gmtoff) / 86400;
  v8.tv_sec = 86400 * __CFLastLocalMidnightDay - v9.tm_gmtoff + 86400;
  v8.tv_nsec = 0;
  uint64_t v6 = __CFMidnightTimer;
  dispatch_time_t v7 = dispatch_walltime(&v8, 0);
  dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0xB2D05E00uLL);
}

uint64_t __CFFileDescriptorGetTypeID_block_invoke()
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  v6.rlim_cur = 0;
  v6.int rlim_max = 0;
  int v0 = getrlimit(8, &v6);
  *(void *)dispatch_time_t v7 = 0x1D00000001;
  int rlim_max = 0;
  size_t v4 = 4;
  uint64_t result = sysctl(v7, 2u, &rlim_max, &v4, 0, 0);
  if (result | v0)
  {
    if (v0) {
      return result;
    }
    LODWORD(v2) = rlim_max;
  }
  else
  {
    LODWORD(v2) = rlim_max;
    if (v6.rlim_max < rlim_max)
    {
      int rlim_max = v6.rlim_max;
      LODWORD(v2) = v6.rlim_max;
    }
  }
  if (v6.rlim_cur < (int)v2)
  {
    rlim_t v2 = (int)v2;
    rlimit v3 = v6;
    if (v6.rlim_cur + 2304 < (int)v2) {
      rlim_t v2 = v6.rlim_cur + 2304;
    }
    v3.rlim_cur = v2;
    return setrlimit(8, &v3);
  }
  return result;
}

void _CFPreferencesAddSuitePreferencesToAppWithContainer(const void *a1, const void *a2, uint64_t a3)
{
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    rlimit v6 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_229);
    }
    rlimit v6 = (const os_unfair_lock *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }
  dispatch_time_t v7 = (os_unfair_lock *)v6;
  -[_CFXPreferences addSuitePreferences:toAppIdentifier:container:](v6, a2, a1, a3);
}

void sub_182CA54C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (v10) {
    objc_end_catch();
  }
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 88), 8);
  _Unwind_Resume(a1);
}

void __CFFileDescriptorInvalidate_block_invoke(void *a1)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = *(_DWORD *)(a1[6] + 16) == 0;
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    *(_DWORD *)(a1[6] + 16) = 1;
    __dmb(0xBu);
    rlim_t v2 = (void *)a1[6];
    rlimit v3 = v2[4];
    if (v3)
    {
      dispatch_source_cancel(v3);
      uint64_t v4 = a1[6];
      if (*(unsigned char *)(v4 + 48))
      {
        *(unsigned char *)(v4 + 48) = 0;
        dispatch_resume(*(dispatch_object_t *)(v4 + 32));
        uint64_t v4 = a1[6];
      }
      *(void *)(v4 + 32) = 0;
      rlim_t v2 = (void *)a1[6];
    }
    unint64_t v5 = v2[5];
    if (v5)
    {
      dispatch_source_cancel(v5);
      uint64_t v6 = a1[6];
      if (*(unsigned char *)(v6 + 49))
      {
        *(unsigned char *)(v6 + 49) = 0;
        dispatch_resume(*(dispatch_object_t *)(v6 + 40));
        uint64_t v6 = a1[6];
      }
      *(void *)(v6 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      rlim_t v2 = (void *)a1[6];
    }
    *(void *)(*(void *)(a1[5] + 8) + 24) = v2[7];
    *(void *)(a1[6] + 56) = 0;
    char v7 = atomic_load((unint64_t *)(a1[6] + 8));
    if ((v7 & 2) != 0)
    {
      shutdown(*(_DWORD *)(a1[6] + 20), 2);
      int v8 = open("/dev/null", 0);
      dup2(v8, *(_DWORD *)(a1[6] + 20));
      close(v8);
      close(*(_DWORD *)(a1[6] + 20));
    }
    *(_DWORD *)(a1[6] + 2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -1;
  }
}

void _CFXNotificationSetSuspended(uint64_t a1, int a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    if ((v4 & 2) != 0)
    {
      char v5 = atomic_load((unint64_t *)(a1 + 8));
      if ((v5 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
      {
        unint64_t v6 = atomic_load((unint64_t *)(a1 + 8));
        if (((v6 >> 3) & 1) != a2)
        {
          unint64_t v7 = atomic_load((unint64_t *)(a1 + 8));
          if (a2)
          {
            int v8 = "suspend";
            unint64_t v9 = v7;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v9, v7 | 8);
              BOOL v10 = v9 == v7;
              unint64_t v7 = v9;
            }
            while (!v10);
          }
          else
          {
            int v8 = "unsuspend";
            unint64_t v11 = v7;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v11, v7 & 0xFFFFFFFFFFFFFFF7);
              BOOL v10 = v11 == v7;
              unint64_t v7 = v11;
            }
            while (!v10);
          }
          xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
          xpc_dictionary_set_string(v12, "method", v8);
          xpc_dictionary_set_uint64(v12, "version", 1uLL);
          char v13 = *(_xpc_connection_s **)(a1 + 24);
          _CFSuddenTerminationDisable();
          xpc_connection_send_message(v13, v12);
          xpc_connection_send_barrier(v13, &__block_literal_global_124);
          xpc_release(v12);
        }
      }
    }
    else
    {
      __break(1u);
    }
  }
}

void __CFStringGetLineOrParagraphBounds(CFStringRef theString, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, uint64_t *a6, int a7)
{
  uint64_t v103 = *(void *)off_1ECE0A5B0;
  uint64_t v102 = 0;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  *(_OWORD *)CFStringRef theStringa = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  *(_OWORD *)buffer = 0u;
  char v14 = atomic_load((unint64_t *)&theString->info);
  uint64_t v15 = v14 & 5;
  char v16 = atomic_load((unint64_t *)&theString->info);
  uint64_t v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_uint64_t data = &theString->data;
    if (v17)
    {
      uint64_t v19 = *p_data;
    }
    else
    {
      uint64_t v21 = atomic_load((unint64_t *)&theString->info);
      uint64_t v19 = (char *)&p_data[(v21 & 5) != 4];
    }
    uint64_t length = *v19;
    if (!a4) {
      goto LABEL_87;
    }
  }
  else if ((v16 & 0x60) != 0)
  {
    uint64_t length = theString->length;
    if (!a4) {
      goto LABEL_87;
    }
  }
  else
  {
    uint64_t length = (uint64_t)theString->data;
    if (!a4) {
      goto LABEL_87;
    }
  }
  if (!a2)
  {
    uint64_t v28 = 0;
    goto LABEL_86;
  }
  theStringa[0] = theString;
  *((void *)&v100 + 1) = 0;
  *(void *)&long long v101 = length;
  CFStringRef CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(theString);
  CFIndex v23 = 0;
  theStringa[1] = CharactersPtr;
  if (!CharactersPtr)
  {
    int v24 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v24 = __CFDefaultEightBitStringEncoding;
    }
    if (v24 != 1536)
    {
      if (v24 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v24 = __CFDefaultEightBitStringEncoding;
      }
      if (v24 != 1536) {
        goto LABEL_21;
      }
    }
    p_info = &theString->info;
    char v26 = atomic_load((unint64_t *)&theString->info);
    if ((v26 & 0x10) == 0 || (char v27 = atomic_load((unint64_t *)p_info), (v27 & 8) != 0))
    {
      char v29 = atomic_load((unint64_t *)p_info);
      unsigned int v30 = &theString->data;
      if ((v29 & 0x60) != 0)
      {
        uint64_t v31 = *v30;
      }
      else
      {
        char v32 = atomic_load((unint64_t *)&theString->info);
        uint64_t v31 = (char *)&v30[(v32 & 5) != 4];
      }
      unint64_t v33 = atomic_load((unint64_t *)&theString->info);
      CFIndex v23 = &v31[(v33 >> 2) & 1];
    }
    else
    {
LABEL_21:
      CFIndex v23 = 0;
    }
  }
  *((void *)&v101 + 1) = 0;
  uint64_t v102 = 0;
  *(void *)&long long v100 = v23;
  uint64_t v90 = length;
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v34 = v101;
    if ((uint64_t)v101 > a2)
    {
      if (theStringa[1])
      {
        uint64_t v35 = 0;
        UniChar v36 = *((_WORD *)&theStringa[1]->isa + *((void *)&v100 + 1) + a2);
      }
      else if (v23)
      {
        uint64_t v35 = 0;
        UniChar v36 = v23[*((void *)&v100 + 1) + a2];
      }
      else
      {
        uint64_t v38 = a2 - 4;
        if ((unint64_t)a2 < 4) {
          uint64_t v38 = 0;
        }
        if (v38 + 64 < (uint64_t)v101) {
          uint64_t v34 = v38 + 64;
        }
        *((void *)&v101 + 1) = v38;
        uint64_t v102 = v34;
        v104.unint64_t location = *((void *)&v100 + 1) + v38;
        v104.uint64_t length = v34 - v38;
        CFStringGetCharacters(theStringa[0], v104, buffer);
        uint64_t v35 = *((void *)&v101 + 1);
        UniChar v36 = buffer[a2 - *((void *)&v101 + 1)];
      }
      uint64_t v37 = a2 - 1;
      if (v36 != 10) {
        goto LABEL_49;
      }
      uint64_t v39 = v101;
      if ((uint64_t)v101 < a2) {
        goto LABEL_49;
      }
      uint64_t v40 = (UniChar *)theStringa[1];
      if (theStringa[1])
      {
        uint64_t v41 = *((void *)&v100 + 1) + v37;
      }
      else
      {
        if ((void)v100)
        {
          UniChar v42 = *(char *)(v100 + *((void *)&v100 + 1) + v37);
          goto LABEL_47;
        }
        if (v102 < a2 || v35 >= a2)
        {
          uint64_t v86 = a2 - 5;
          if ((unint64_t)a2 < 5) {
            uint64_t v86 = 0;
          }
          if (v86 + 64 < (uint64_t)v101) {
            uint64_t v39 = v86 + 64;
          }
          *((void *)&v101 + 1) = v86;
          uint64_t v102 = v39;
          v107.unint64_t location = *((void *)&v100 + 1) + v86;
          v107.uint64_t length = v39 - v86;
          CFStringGetCharacters(theStringa[0], v107, buffer);
          uint64_t v35 = *((void *)&v101 + 1);
        }
        uint64_t v41 = v37 - v35;
        uint64_t v40 = buffer;
      }
      UniChar v42 = v40[v41];
LABEL_47:
      if (v42 != 13) {
        goto LABEL_49;
      }
      uint64_t v37 = a2 - 2;
      if (((a2 - 2) & 0x8000000000000000) == 0) {
        goto LABEL_49;
      }
LABEL_32:
      uint64_t v28 = 0;
      uint64_t length = v90;
      goto LABEL_86;
    }
  }
  uint64_t v35 = 0;
  uint64_t v37 = a2 - 1;
  if (a2 - 1 < 0) {
    goto LABEL_32;
  }
LABEL_49:
  char v89 = a6;
  uint64_t v43 = -v37;
  uint64_t v44 = v37 + 64;
  while (1)
  {
    if ((unint64_t)v37 >= 4) {
      uint64_t v45 = 4;
    }
    else {
      uint64_t v45 = v37;
    }
    if ((uint64_t)v101 <= v37)
    {
      UniChar v46 = 0;
      goto LABEL_78;
    }
    if (theStringa[1])
    {
      UniChar v46 = *((_WORD *)&theStringa[1]->isa + v37 + *((void *)&v100 + 1));
    }
    else if ((void)v100)
    {
      UniChar v46 = *(char *)(v100 + *((void *)&v100 + 1) + v37);
    }
    else
    {
      BOOL v47 = v102 > v37 && v35 <= v37;
      if (!v47)
      {
        uint64_t v48 = -v45;
        uint64_t v49 = v45 + v43;
        uint64_t v50 = v44 - v45;
        uint64_t v51 = v37 + v48;
        uint64_t v52 = v51 + 64;
        if (v51 + 64 >= (uint64_t)v101) {
          uint64_t v52 = v101;
        }
        *((void *)&v101 + 1) = v51;
        uint64_t v102 = v52;
        v53.unint64_t location = v51 + *((void *)&v100 + 1);
        if ((uint64_t)v101 >= v50) {
          uint64_t v54 = v50;
        }
        else {
          uint64_t v54 = v101;
        }
        v53.uint64_t length = v54 + v49;
        CFStringGetCharacters(theStringa[0], v53, buffer);
        uint64_t v35 = *((void *)&v101 + 1);
      }
      UniChar v46 = buffer[v37 - v35];
    }
    if ((unsigned __int16)(v46 - 14) < 0x77u) {
      goto LABEL_81;
    }
    BOOL v55 = v46 == 10 || v46 == 13;
    if (v55 || v46 == 8233) {
      break;
    }
LABEL_78:
    if (a7 && (v46 == 8232 || v46 == 133)) {
      break;
    }
LABEL_81:
    ++v43;
    --v44;
    BOOL v47 = v37-- <= 0;
    if (v47)
    {
      uint64_t v28 = 0;
      goto LABEL_85;
    }
  }
  uint64_t v28 = v37 + 1;
LABEL_85:
  a6 = v89;
  uint64_t length = v90;
LABEL_86:
  *a4 = v28;
LABEL_87:
  if (!(a5 | (unint64_t)a6)) {
    return;
  }
  theStringa[0] = theString;
  *((void *)&v100 + 1) = 0;
  *(void *)&long long v101 = length;
  CFStringRef v57 = (const __CFString *)CFStringGetCharactersPtr(theString);
  uint64_t v58 = 0;
  theStringa[1] = v57;
  if (!v57)
  {
    int v67 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v67 = __CFDefaultEightBitStringEncoding;
    }
    if (v67 == 1536)
    {
      if (!theString) {
        goto LABEL_142;
      }
    }
    else
    {
      if (v67 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v67 = __CFDefaultEightBitStringEncoding;
      }
      uint64_t v58 = 0;
      if (!theString || v67 != 1536) {
        goto LABEL_89;
      }
    }
    uint64_t v73 = &theString->info;
    char v74 = atomic_load((unint64_t *)&theString->info);
    if ((v74 & 0x10) == 0 || (char v75 = atomic_load((unint64_t *)v73), (v75 & 8) != 0))
    {
      char v76 = atomic_load((unint64_t *)v73);
      char v77 = &theString->data;
      if ((v76 & 0x60) != 0)
      {
        char v78 = *v77;
      }
      else
      {
        char v79 = atomic_load((unint64_t *)&theString->info);
        char v78 = (char *)&v77[(v79 & 5) != 4];
      }
      unint64_t v80 = atomic_load((unint64_t *)&theString->info);
      uint64_t v58 = &v78[(v80 >> 2) & 1];
      goto LABEL_89;
    }
LABEL_142:
    uint64_t v58 = 0;
  }
LABEL_89:
  *((void *)&v101 + 1) = 0;
  uint64_t v102 = 0;
  *(void *)&long long v100 = v58;
  uint64_t v59 = a2 + a3 - (a3 != 0);
  if (v59 < 0 || (uint64_t v60 = v101, (uint64_t)v101 <= v59))
  {
    uint64_t v61 = 0;
    UniChar v62 = -1;
  }
  else
  {
    if (theStringa[1])
    {
      uint64_t v61 = 0;
      UniChar v62 = *((_WORD *)&theStringa[1]->isa + *((void *)&v100 + 1) + v59);
    }
    else if (v58)
    {
      uint64_t v61 = 0;
      UniChar v62 = v58[*((void *)&v100 + 1) + v59];
    }
    else
    {
      uint64_t v81 = v59 - 4;
      if ((unint64_t)v59 < 4) {
        uint64_t v81 = 0;
      }
      if (v81 + 64 < (uint64_t)v101) {
        uint64_t v60 = v81 + 64;
      }
      *((void *)&v101 + 1) = v81;
      uint64_t v102 = v60;
      v106.unint64_t location = *((void *)&v100 + 1) + v81;
      v106.uint64_t length = v60 - v81;
      CFStringGetCharacters(theStringa[0], v106, buffer);
      uint64_t v61 = *((void *)&v101 + 1);
      UniChar v62 = buffer[v59 - *((void *)&v101 + 1)];
    }
    if (v62 == 10)
    {
      uint64_t v82 = v59 - 1;
      if (v59 && (uint64_t v83 = v101, (uint64_t)v101 >= v59))
      {
        if (theStringa[1])
        {
          UniChar v84 = *((_WORD *)&theStringa[1]->isa + *((void *)&v100 + 1) + v82);
        }
        else if ((void)v100)
        {
          UniChar v84 = *(char *)(v100 + *((void *)&v100 + 1) + v82);
        }
        else
        {
          if (v102 < v59 || v61 >= v59)
          {
            uint64_t v87 = v59 - 5;
            if ((unint64_t)v59 < 5) {
              uint64_t v87 = 0;
            }
            if (v87 + 64 < (uint64_t)v101) {
              uint64_t v83 = v87 + 64;
            }
            *((void *)&v101 + 1) = v87;
            uint64_t v102 = v83;
            v108.unint64_t location = *((void *)&v100 + 1) + v87;
            v108.uint64_t length = v83 - v87;
            CFStringGetCharacters(theStringa[0], v108, buffer);
            uint64_t v61 = *((void *)&v101 + 1);
          }
          UniChar v84 = buffer[v82 - v61];
        }
      }
      else
      {
        UniChar v84 = -1;
      }
      BOOL v85 = v84 == 13;
      if (v84 == 13) {
        uint64_t v64 = v59 - 1;
      }
      else {
        uint64_t v64 = a2 + a3 - (a3 != 0);
      }
LABEL_184:
      uint64_t v68 = 1;
      if (v85) {
        uint64_t v68 = 2;
      }
      if (a6) {
        goto LABEL_135;
      }
      goto LABEL_136;
    }
  }
  if (length <= v59) {
    uint64_t v63 = a2 + a3 - (a3 != 0);
  }
  else {
    uint64_t v63 = length;
  }
  while (2)
  {
    uint64_t v64 = v59;
    if ((unsigned __int16)(v62 - 14) < 0x77u)
    {
LABEL_104:
      if (v63 == v59)
      {
        uint64_t v68 = 0;
        uint64_t v64 = length;
        if (a6) {
          goto LABEL_135;
        }
        goto LABEL_136;
      }
      ++v59;
      UniChar v62 = -1;
      if (v64 >= -1 && (uint64_t)v101 > v59)
      {
        if (theStringa[1])
        {
          UniChar v62 = *((_WORD *)&theStringa[1]->isa + *((void *)&v100 + 1) + v64 + 1);
        }
        else if ((void)v100)
        {
          UniChar v62 = *(char *)(v100 + *((void *)&v100 + 1) + 1 + v64);
        }
        else
        {
          uint64_t v59 = v64 + 1;
          if (v102 <= v64 + 1 || v61 > v59)
          {
            uint64_t v65 = v64 - 3;
            if ((unint64_t)v59 < 4) {
              uint64_t v65 = 0;
            }
            uint64_t v66 = v65 + 64;
            if (v65 + 64 >= (uint64_t)v101) {
              uint64_t v66 = v101;
            }
            *((void *)&v101 + 1) = v65;
            uint64_t v102 = v66;
            v105.unint64_t location = *((void *)&v100 + 1) + v65;
            v105.uint64_t length = v66 - v65;
            CFStringGetCharacters(theStringa[0], v105, buffer);
            uint64_t v61 = *((void *)&v101 + 1);
          }
          UniChar v62 = buffer[v64 + 1 - v61];
        }
      }
      continue;
    }
    break;
  }
  if (v62 == 10) {
    goto LABEL_134;
  }
  if (v62 != 13)
  {
    if (v62 == 8233 || a7 && (v62 == 133 || v62 == 8232)) {
      goto LABEL_134;
    }
    goto LABEL_104;
  }
  if (v59 >= -1)
  {
    int64_t v69 = v59 + 1;
    uint64_t v70 = v101;
    if ((uint64_t)v101 > v59 + 1)
    {
      if (theStringa[1])
      {
        uint64_t v71 = (UniChar *)theStringa[1] + *((void *)&v100 + 1) + v59;
        goto LABEL_133;
      }
      if ((void)v100)
      {
        UniChar v72 = *(char *)(v100 + *((void *)&v100 + 1) + v59 + 1);
      }
      else
      {
        if (v102 <= v69 || v61 > v69)
        {
          uint64_t v88 = v59 - 3;
          if ((unint64_t)v69 < 4) {
            uint64_t v88 = 0;
          }
          if (v88 + 64 < (uint64_t)v101) {
            uint64_t v70 = v88 + 64;
          }
          *((void *)&v101 + 1) = v88;
          uint64_t v102 = v70;
          v109.unint64_t location = *((void *)&v100 + 1) + v88;
          v109.uint64_t length = v70 - v88;
          CFStringGetCharacters(theStringa[0], v109, buffer);
          uint64_t v61 = *((void *)&v101 + 1);
        }
        uint64_t v71 = &buffer[v59 - v61];
LABEL_133:
        UniChar v72 = v71[1];
      }
      BOOL v85 = v72 == 10;
      goto LABEL_184;
    }
  }
LABEL_134:
  uint64_t v68 = 1;
  if (!a6) {
    goto LABEL_136;
  }
LABEL_135:
  *a6 = v64;
LABEL_136:
  if (a5) {
    *(void *)a5 = v68 + v64;
  }
}

void CFCharacterSetRemoveCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  uint64_t v71 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    [(__CFCharacterSet *)theSet removeCharactersInString:theString];
  }
  else
  {
    char v4 = atomic_load((unint64_t *)theSet + 1);
    if ((v4 & 1) == 0)
    {
      CFLog(3, @"%s: Immutable character set passed to mutable function");
      if (dyld_program_sdk_at_least()) {
        CFCharacterSetRemoveCharactersInString_cold_1();
      }
    }
    char v5 = atomic_load((unint64_t *)theSet + 1);
    if ((v5 & 0x70) != 0
      || (char v6 = atomic_load((unint64_t *)theSet + 1), (v6 & 1) != 0)
      || (char v7 = atomic_load((unint64_t *)theSet + 1), (v7 & 8) != 0)
      || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
    {
      uint64_t v8 = *((void *)theSet + 5);
      if (v8)
      {
        if (*(_DWORD *)(v8 + 8) || *(unsigned char *)(v8 + 13)) {
          goto LABEL_20;
        }
      }
      unsigned int v9 = atomic_load((unint64_t *)theSet + 1);
      switch((v9 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*((void *)theSet + 4)) {
            goto LABEL_20;
          }
          break;
        case 3u:
        case 4u:
          if (*((void *)theSet + 3)) {
            goto LABEL_20;
          }
          break;
        default:
          goto LABEL_20;
      }
      char v10 = atomic_load((unint64_t *)theSet + 1);
      if ((v10 & 8) != 0)
      {
LABEL_20:
        CFIndex Length = CFStringGetLength(theString);
        if (Length)
        {
          CFIndex v12 = Length;
          char v13 = atomic_load((unint64_t *)theSet + 1);
          if ((v13 & 8) == 0) {
            goto LABEL_33;
          }
          uint64_t v14 = *((void *)theSet + 5);
          if (v14 && (*(_DWORD *)(v14 + 8) || *(unsigned char *)(v14 + 13)))
          {
LABEL_29:
            char v17 = atomic_load((unint64_t *)theSet + 1);
            uint64_t v16 = (v17 & 0x70) == 0x20 ? *((void *)theSet + 4) : 64;
          }
          else
          {
            unsigned int v15 = atomic_load((unint64_t *)theSet + 1);
            switch((v15 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (*((void *)theSet + 4)) {
                  goto LABEL_29;
                }
                break;
              case 3u:
              case 4u:
                if (*((void *)theSet + 3)) {
                  goto LABEL_29;
                }
                break;
              default:
                goto LABEL_29;
            }
            uint64_t v16 = 0;
          }
          size_t v18 = v16 + Length;
          if (v16 + Length <= 63)
          {
            uint64_t v37 = *((void *)theSet + 3);
            if (v37)
            {
              uint64_t Typed = (UniChar *)(v37 + 2 * *((void *)theSet + 4));
            }
            else
            {
              CFAllocatorRef v39 = CFGetAllocator(theSet);
              uint64_t Typed = (UniChar *)CFAllocatorAllocateTyped(v39, 128, 0x1000040BDFB0063, 0);
            }
            v74.unint64_t location = 0;
            v74.uint64_t length = v12;
            CFStringGetCharacters(theString, v74, Typed);
            if (v12 < 2)
            {
              char v40 = 0;
            }
            else
            {
              char v40 = 0;
              uint64_t v41 = &Typed[v12];
              uint64_t v42 = -2 - (void)Typed;
              uint64_t v43 = Typed;
              do
              {
                if ((*v43 & 0xF800 | 0x400) == 0xDC00)
                {
                  memmove(v43, v43 + 1, ((uint64_t)v41-- + v42) >> 1);
                  char v40 = 1;
                }
                ++v43;
                v42 -= 2;
              }
              while (v43 < v41);
              size_t v18 = v16 + v41 - Typed;
            }
            uint64_t v44 = (UniChar *)*((void *)theSet + 3);
            if (!v44)
            {
              unint64_t v45 = atomic_load((unint64_t *)theSet + 1);
              unint64_t v46 = v45;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v46, v45 & 0xFFFFFFFFFFFFFF8FLL | 0x20);
                BOOL v36 = v46 == v45;
                unint64_t v45 = v46;
              }
              while (!v36);
              *((void *)theSet + 3) = Typed;
              uint64_t v44 = Typed;
            }
            *((void *)theSet + 4) = v18;
            qsort(v44, v18, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
            uint64_t v47 = *((void *)theSet + 4);
            if (v47 >= 2)
            {
              uint64_t v48 = 0;
              uint64_t v49 = *((void *)theSet + 3);
              uint64_t v50 = v47 - 1;
              uint64_t v51 = (unsigned __int16 *)(v49 + 2);
              do
              {
                int v53 = *v51++;
                __int16 v52 = v53;
                if (*(unsigned __int16 *)(v49 + 2 * v48) != v53)
                {
                  ++v48;
                  *(_WORD *)(v49 + 2 * v48) = v52;
                }
                --v50;
              }
              while (v50);
              uint64_t v47 = v48 + 1;
            }
            *((void *)theSet + 4) = v47;
            unint64_t v54 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v55 = v54;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v55, v54 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v36 = v55 == v54;
              unint64_t v54 = v55;
            }
            while (!v36);
            if (v40)
            {
              __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetRemoveCharactersInRange);
            }
          }
          else
          {
LABEL_33:
            __CFCSetMakeBitmap((char *)theSet);
            long long v62 = 0u;
            long long v63 = 0u;
            long long v60 = 0u;
            long long v61 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            *(_OWORD *)buffer = 0u;
            long long v57 = 0u;
            CFStringRef theStringa = theString;
            uint64_t v67 = 0;
            CFIndex v68 = v12;
            CFStringRef CharactersPtr = CFStringGetCharactersPtr(theString);
            CStringPtr = 0;
            uint64_t v65 = CharactersPtr;
            if (!CharactersPtr) {
              CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
            }
            int64_t v69 = 0;
            int64_t v70 = 0;
            uint64_t v66 = CStringPtr;
            if (v12 < 1)
            {
              char v23 = 0;
            }
            else
            {
              uint64_t v21 = 0;
              int64_t v22 = 0;
              char v23 = 0;
              uint64_t v24 = 64;
              do
              {
                if ((unint64_t)v22 >= 4) {
                  uint64_t v25 = 4;
                }
                else {
                  uint64_t v25 = v22;
                }
                if (v65)
                {
                  UniChar v26 = v65[v22 + v67];
                }
                else if (v66)
                {
                  UniChar v26 = v66[v67 + v22];
                }
                else
                {
                  int64_t v27 = v69;
                  if (v70 <= v22 || v69 > v22)
                  {
                    uint64_t v29 = -v25;
                    uint64_t v30 = v25 + v21;
                    uint64_t v31 = v24 - v25;
                    int64_t v32 = v22 + v29;
                    CFIndex v33 = v32 + 64;
                    if (v32 + 64 >= v68) {
                      CFIndex v33 = v68;
                    }
                    int64_t v69 = v32;
                    int64_t v70 = v33;
                    if (v68 < v31) {
                      uint64_t v31 = v68;
                    }
                    v73.uint64_t length = v31 + v30;
                    v73.unint64_t location = v32 + v67;
                    CFStringGetCharacters(theStringa, v73, buffer);
                    int64_t v27 = v69;
                  }
                  UniChar v26 = buffer[v22 - v27];
                }
                if ((v26 & 0xF800 | 0x400) == 0xDC00) {
                  char v23 = 1;
                }
                else {
                  *(unsigned char *)(*((void *)theSet + 3) + (v26 >> 3)) &= ~(1 << (v26 & 7));
                }
                ++v22;
                --v21;
                ++v24;
              }
              while (v12 != v22);
            }
            unint64_t v34 = atomic_load((unint64_t *)theSet + 1);
            unint64_t v35 = v34;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)theSet + 1, &v35, v34 & 0xFFFFFFFFFFFFFFFBLL);
              BOOL v36 = v35 == v34;
              unint64_t v34 = v35;
            }
            while (!v36);
            if (__CFCheckForExapendedSet == 1) {
              __CFCheckForExpandedSet((const char *)theSet);
            }
            if (v23) {
              __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetRemoveCharactersInRange);
            }
          }
        }
      }
    }
  }
}

void CFBundleGetPackageInfo(CFBundleRef bundle, UInt32 *packageType, UInt32 *packageCreator)
{
  CFURLRef v6 = CFBundleCopyBundleURL(bundle);
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (!_CFBundleGetPackageInfoInDirectoryWithInfoDictionary(v6, InfoDictionary, (int *)packageType, packageCreator))
  {
    if (packageType) {
      *packageType = 1112425548;
    }
    if (packageCreator) {
      *packageCreator = 1061109567;
    }
  }
  if (v6)
  {
    CFRelease(v6);
  }
}

uint64_t _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(CFURLRef baseURL, const __CFDictionary *a2, int *a3, _DWORD *a4)
{
  usedBufLen[257] = *(void *)off_1ECE0A5B0;
  resourceCFDataRef Data = 0;
  CFURLRef v8 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Contents/PkgInfo", baseURL);
  CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8, &resourceData, 0, 0, 0);
  CFRelease(v8);
  CFDataRef v9 = resourceData;
  if (!resourceData)
  {
    CFURLRef v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Support%20Files/PkgInfo", baseURL);
    CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, &resourceData, 0, 0, 0);
    CFRelease(v10);
    CFDataRef v9 = resourceData;
    if (!resourceData)
    {
      CFURLRef v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"PkgInfo", baseURL);
      CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, &resourceData, 0, 0, 0);
      CFRelease(v11);
      CFDataRef v9 = resourceData;
      if (!resourceData) {
        goto LABEL_14;
      }
    }
  }
  if (CFDataGetLength(v9) < 8)
  {
    if (resourceData) {
      CFRelease(resourceData);
    }
LABEL_14:
    CFDictionaryRef v16 = a2;
    if (!a2)
    {
      CFDictionaryRef v16 = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, baseURL, 0);
      if (!v16)
      {
        BOOL v21 = 0;
        goto LABEL_42;
      }
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v16, @"CFBundlePackageType");
    CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(v16, @"CFBundleSignature");
    *(_DWORD *)buffer = 0;
    usedBufLen[0] = 0;
    if (Value && (CFTypeID v19 = CFGetTypeID(Value), v19 == CFStringGetTypeID()) && CFStringGetLength(Value) == 4)
    {
      v48.unint64_t location = 0;
      v48.uint64_t length = 4;
      uint64_t v14 = 0;
      if (CFStringGetBytes(Value, v48, 0, 0, 0, buffer, 4, usedBufLen) == 4 && usedBufLen[0] == 4)
      {
        if (a3) {
          *a3 = bswap32(*(unsigned int *)buffer);
        }
        uint64_t v14 = 1;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    if (v18 && (CFTypeID v20 = CFGetTypeID(v18), v20 == CFStringGetTypeID()) && CFStringGetLength(v18) == 4)
    {
      v49.unint64_t location = 0;
      v49.uint64_t length = 4;
      int v13 = 0;
      if (CFStringGetBytes(v18, v49, 0, 0, 0, buffer, 4, usedBufLen) == 4)
      {
        uint64_t v15 = v14;
        if (usedBufLen[0] == 4)
        {
          if (a4) {
            *a4 = bswap32(*(unsigned int *)buffer);
          }
          int v13 = 1;
          uint64_t v15 = 1;
        }
        goto LABEL_35;
      }
    }
    else
    {
      int v13 = 0;
    }
    uint64_t v15 = v14;
LABEL_35:
    if (!a2) {
      CFRelease(v16);
    }
    goto LABEL_37;
  }
  BytePtr = (unsigned int *)CFDataGetBytePtr(resourceData);
  if (a3) {
    *a3 = bswap32(*BytePtr);
  }
  if (a4) {
    *a4 = bswap32(BytePtr[1]);
  }
  if (resourceData) {
    CFRelease(resourceData);
  }
  int v13 = 1;
  LODWORD(v14) = 1;
  uint64_t v15 = 1;
LABEL_37:
  BOOL v21 = v14 != 0;
  LOBYTE(v16) = v13 != 0;
  if (v13 && v14) {
    return v15;
  }
  if (v15)
  {
LABEL_43:
    if (a4 && (v16 & 1) == 0) {
      *a4 = 1061109567;
    }
    if (a3) {
      char v22 = v21;
    }
    else {
      char v22 = 1;
    }
    if (v22) {
      return 1;
    }
    CFURLRef v23 = CFURLCopyAbsoluteURL(baseURL);
    CFStringRef v24 = CFURLCopyFileSystemPath(v23, kCFURLPOSIXPathStyle);
    CFRelease(v23);
    if (!v24) {
      goto LABEL_107;
    }
    CFIndex Length = CFStringGetLength(v24);
    if (Length >= 1026) {
      CFIndex v26 = 1026;
    }
    else {
      CFIndex v26 = Length;
    }
    v50.unint64_t location = 0;
    v50.uint64_t length = v26;
    CFStringGetCharacters(v24, v50, (UniChar *)usedBufLen);
    CFRelease(v24);
    uint64_t v27 = _CFStartOfPathExtension(usedBufLen, v26);
    CFIndex v28 = v26 - v27;
    unint64_t v29 = (v26 - v27) & 0xFFFFFFFFFFFFFFFELL;
    switch(v29)
    {
      case 4uLL:
        if (*((_WORD *)usedBufLen + v27) != 46) {
          goto LABEL_107;
        }
        uint64_t v30 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v30 + 1) != 97 || *((_WORD *)v30 + 2) != 112 || *((_WORD *)usedBufLen + v27 + 3) != 112) {
          goto LABEL_107;
        }
        if (v28 == 4)
        {
LABEL_62:
          int v32 = 1095782476;
LABEL_108:
          *a3 = v32;
          return 1;
        }
        int v31 = *((unsigned __int16 *)&usedBufLen[1] + v27);
        break;
      case 6uLL:
        if (*((_WORD *)usedBufLen + v27) != 46) {
          goto LABEL_107;
        }
        if (*((_WORD *)usedBufLen + v27 + 1) != 100) {
          goto LABEL_107;
        }
        CFIndex v33 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v33 + 2) != 101) {
          goto LABEL_107;
        }
        if (*((_WORD *)v33 + 3) != 98) {
          goto LABEL_107;
        }
        unint64_t v34 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v34 + 4) != 117 || *((_WORD *)v34 + 5) != 103) {
          goto LABEL_107;
        }
        if (v28 == 6) {
          goto LABEL_62;
        }
        int v31 = *((unsigned __int16 *)&usedBufLen[1] + v27 + 2);
        break;
      case 8uLL:
        if (*((_WORD *)usedBufLen + v27) != 46) {
          goto LABEL_107;
        }
        if (*((_WORD *)usedBufLen + v27 + 1) == 112)
        {
          unint64_t v35 = (char *)usedBufLen + 2 * v27;
          if (*((_WORD *)v35 + 2) == 114 && *((_WORD *)v35 + 3) == 111)
          {
            BOOL v36 = (char *)usedBufLen + 2 * v27;
            if (*((_WORD *)v36 + 4) == 102 && *((_WORD *)v36 + 5) == 105)
            {
              uint64_t v37 = (char *)usedBufLen + 2 * v27;
              if (*((_WORD *)v37 + 6) == 108
                && *((_WORD *)v37 + 7) == 101
                && (v28 == 8 || *((_WORD *)&usedBufLen[2] + v27) == 47))
              {
                goto LABEL_62;
              }
            }
          }
        }
        if (*((_WORD *)usedBufLen + v27 + 1) != 115
          || *((_WORD *)usedBufLen + v27 + 2) != 101
          || (uint64_t v38 = (char *)usedBufLen + 2 * v27, *((_WORD *)v38 + 3) != 114)
          || *((_WORD *)v38 + 4) != 118
          || (CFAllocatorRef v39 = (char *)usedBufLen + 2 * v27, *((_WORD *)v39 + 5) != 105)
          || *((_WORD *)v39 + 6) != 99
          || *((_WORD *)&usedBufLen[1] + v27 + 3) != 101)
        {
LABEL_107:
          int v32 = 1112425548;
          goto LABEL_108;
        }
        if (v28 == 8) {
          goto LABEL_62;
        }
        int v31 = *((unsigned __int16 *)&usedBufLen[2] + v27);
        break;
      default:
        if (v29 == 10 && *((_WORD *)usedBufLen + v27) == 46 && *((_WORD *)usedBufLen + v27 + 1) == 102)
        {
          char v40 = (char *)usedBufLen + 2 * v27;
          if (*((_WORD *)v40 + 2) == 114 && *((_WORD *)v40 + 3) == 97)
          {
            uint64_t v41 = (char *)usedBufLen + 2 * v27;
            if (*((_WORD *)v41 + 4) == 109 && *((_WORD *)v41 + 5) == 101)
            {
              uint64_t v42 = (char *)usedBufLen + 2 * v27;
              if (*((_WORD *)v42 + 6) == 119 && *((_WORD *)v42 + 7) == 111)
              {
                uint64_t v43 = (char *)usedBufLen + 2 * v27;
                if (*((_WORD *)v43 + 8) == 114
                  && *((_WORD *)v43 + 9) == 107
                  && (v28 == 10 || *((_WORD *)&usedBufLen[2] + v27 + 2) == 47))
                {
                  int v32 = 1179473739;
                  goto LABEL_108;
                }
              }
            }
          }
        }
        goto LABEL_107;
    }
    if (v31 == 47) {
      goto LABEL_62;
    }
    goto LABEL_107;
  }
LABEL_42:
  if (_CFBundleURLLooksLikeBundle(baseURL)) {
    goto LABEL_43;
  }
  return 0;
}

uint64_t cbDestroy(void **a1)
{
  if (!a1) {
    return 0;
  }
  rlim_t v2 = *a1;
  if (v2)
  {
    free(v2);
    uint64_t v3 = 1;
  }
  else
  {
    uint64_t v3 = 0;
  }
  free(a1);
  return v3;
}

void boundPairWriteFinalize(uint64_t a1, unsigned __int8 *a2)
{
  if (a2)
  {
    uint64_t v3 = (pthread_mutex_t *)(a2 + 104);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    int v4 = *a2;
    a2[48] = 1;
    *((_WORD *)a2 + 26) = 0;
    char v5 = (const void *)*((void *)a2 + 8);
    if (v5)
    {
      CFRelease(v5);
      *((void *)a2 + 8) = 0;
    }
    pthread_mutex_unlock(v3);
    if (v4)
    {
      boundPairCommonFinalize((uint64_t)a2);
    }
  }
}

void boundPairReadFinalize(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (pthread_mutex_t *)(a2 + 104);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    int v4 = *(unsigned __int8 *)(a2 + 48);
    *(unsigned char *)a2 = 1;
    *(_WORD *)(a2 + 4) = 0;
    char v5 = *(const void **)(a2 + 16);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a2 + 16) = 0;
    }
    CFURLRef v6 = *(const void **)(a2 + 40);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a2 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    }
    pthread_mutex_unlock(v3);
    if (v4)
    {
      boundPairCommonFinalize(a2);
    }
  }
}

void boundPairCommonFinalize(uint64_t a1)
{
  cbDestroy(*(void ***)(a1 + 96));
  if (*(void *)(a1 + 8))
  {
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 8));
    *(void *)(a1 + 8) = 0;
  }
  rlim_t v2 = *(__CFRunLoopSource **)(a1 + 56);
  if (v2)
  {
    CFRunLoopSourceInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 56));
    *(void *)(a1 + 56) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 104));
  CFAllocatorRef v3 = *(const __CFAllocator **)(a1 + 88);

  CFAllocatorDeallocate(v3, (void *)a1);
}

BOOL __CFStringIsRegionalIndicatorAtIndex(UniChar *buffer, int64_t a2)
{
  if (a2 < 0) {
    return 0;
  }
  int64_t v4 = *((void *)buffer + 20);
  if (v4 <= a2) {
    return 0;
  }
  uint64_t v5 = *((void *)buffer + 17);
  if (v5)
  {
    CFURLRef v6 = (UniChar *)(v5 + 2 * (*((void *)buffer + 19) + a2));
  }
  else
  {
    if (*((void *)buffer + 18)) {
      return 0;
    }
    if (*((void *)buffer + 22) <= a2 || (int64_t v12 = *((void *)buffer + 21), v12 > a2))
    {
      int64_t v13 = a2 - 4;
      if ((unint64_t)a2 < 4) {
        int64_t v13 = 0;
      }
      if (v13 + 64 < v4) {
        int64_t v4 = v13 + 64;
      }
      *((void *)buffer + 21) = v13;
      *((void *)buffer + 22) = v4;
      v17.unint64_t location = *((void *)buffer + 19) + v13;
      v17.uint64_t length = v4 - v13;
      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v17, buffer);
      int64_t v12 = *((void *)buffer + 21);
    }
    CFURLRef v6 = &buffer[a2 - v12];
  }
  if (*v6 != 55356) {
    return 0;
  }
  int64_t v7 = a2 + 1;
  int64_t v8 = *((void *)buffer + 20);
  if (v8 <= a2 + 1)
  {
    UniChar v10 = 0;
  }
  else
  {
    uint64_t v9 = *((void *)buffer + 17);
    if (v9)
    {
      UniChar v10 = *(_WORD *)(v9 + 2 * (*((void *)buffer + 19) + v7));
    }
    else
    {
      uint64_t v14 = *((void *)buffer + 18);
      if (v14)
      {
        UniChar v10 = *(char *)(v14 + *((void *)buffer + 19) + v7);
      }
      else
      {
        if (*((void *)buffer + 22) <= v7 || (int64_t v15 = *((void *)buffer + 21), v15 > v7))
        {
          int64_t v16 = a2 - 3;
          if ((unint64_t)a2 < 3) {
            int64_t v16 = 0;
          }
          if (v16 + 64 < v8) {
            int64_t v8 = v16 + 64;
          }
          *((void *)buffer + 21) = v16;
          *((void *)buffer + 22) = v8;
          v18.unint64_t location = *((void *)buffer + 19) + v16;
          v18.uint64_t length = v8 - v16;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v18, buffer);
          int64_t v15 = *((void *)buffer + 21);
        }
        UniChar v10 = buffer[v7 - v15];
      }
    }
  }
  return (unsigned __int16)(v10 + 8730) < 0x1Au;
}

void CFGetRetainCount_cold_1()
{
  qword_1EC093AA8 = (uint64_t)"*** CFGetRetainCount() called with NULL ***";
  __break(1u);
}

uint64_t __CFArrayHash(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__CFString *__CFArrayCopyDescription(unint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if ((a1 & 0x8000000000000000) != 0)
  {
    CFAllocatorRef v3 = &kCFAllocatorSystemDefault;
  }
  else
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    if (v4 < 0) {
      CFAllocatorRef v3 = &kCFAllocatorSystemDefault;
    }
    else {
      CFAllocatorRef v3 = (const CFAllocatorRef *)(a1 - 16);
    }
  }
  CFAllocatorRef v5 = *v3;
  CFCharacterSetRef Mutable = CFStringCreateMutable(*v3, 0);
  int64_t v7 = Mutable;
  char v8 = atomic_load((unint64_t *)(a1 + 8));
  int v9 = v8 & 3;
  if (v9)
  {
    if (v9 != 2) {
      goto LABEL_13;
    }
    CFStringRef v10 = CFSTR("<CFArray %p [%p]>{type = mutable-small, count = %lu, values = (%s");
  }
  else
  {
    CFStringRef v10 = CFSTR("<CFArray %p [%p]>{type = immutable, count = %lu, values = (%s");
  }
  CFURLRef v11 = "\n";
  if (!v2) {
    CFURLRef v11 = "";
  }
  CFStringAppendFormat(Mutable, 0, v10, a1, v5, v2, v11);
LABEL_13:
  unsigned int v12 = atomic_load((unint64_t *)(a1 + 8));
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      uint64_t v14 = &kCFTypeArrayCallBacks;
    }
    else
    {
      char v15 = atomic_load((unint64_t *)(a1 + 8));
      int v16 = v15 & 3;
      if (v16 != 2 && v16) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = (const CFArrayCallBacks *)(a1 + 48);
      }
    }
  }
  else
  {
    uint64_t v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      atomic_load((unint64_t *)(a1 + 8));
      char v18 = atomic_load((unint64_t *)(a1 + 8));
      if ((v18 & 3) != 0)
      {
        uint64_t v19 = *(void *)(a1 + 40) + 8 * **(void **)(a1 + 40) + 16;
      }
      else
      {
        char v20 = atomic_load((unint64_t *)(a1 + 8));
        BOOL v21 = (~v20 & 0xC) == 0;
        uint64_t v22 = 48;
        if (v21) {
          uint64_t v22 = 88;
        }
        uint64_t v19 = a1 + v22;
      }
      uint64_t v23 = *(void *)(v19 + 8 * i);
      copyDescriptiouint64_t n = (uint64_t (*)(uint64_t))v14->copyDescription;
      if (copyDescription && (uint64_t v25 = copyDescription(v23)) != 0)
      {
        CFIndex v26 = (const void *)v25;
        CFStringAppendFormat(v7, 0, @"\t%lu : %@\n", i, v25);
        CFRelease(v26);
      }
      else
      {
        CFStringAppendFormat(v7, 0, @"\t%lu : <%p>\n", i, v23);
      }
    }
  }
  CFStringAppend(v7, @"}"));
  return v7;
}

void _CFArraySortValues(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v44 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(0x13uLL, (unint64_t)a1)) {
    CFIndex v6 = [a1 count];
  }
  else {
    CFIndex v6 = a1[2];
  }
  if (v6 >= 2)
  {
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t Typed = values;
    *(_OWORD *)CFRange values = 0u;
    long long v13 = 0u;
    if ((unint64_t)v6 >= 0x101) {
      uint64_t Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v6, 0x80040B8603338, 0);
    }
    v45.unint64_t location = 0;
    v45.uint64_t length = v6;
    CFArrayGetValues((CFArrayRef)a1, v45, (const void **)Typed);
    v11[0] = a2;
    v11[1] = a3;
    CFQSortArray(Typed, v6, 8, (uint64_t)__CFArrayCompareValues, (uint64_t)v11, v8, v9, v10);
    v46.unint64_t location = 0;
    v46.uint64_t length = v6;
    CFArrayReplaceValues((CFMutableArrayRef)a1, v46, (const void **)Typed, v6);
    if (Typed != values) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
}

uint64_t __CFAttributedStringEqual(CFStringRef *a1, void *a2)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  CFStringRef v4 = a1[2];
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)a2)) {
    CFAllocatorRef v5 = (const void *)[a2 string];
  }
  else {
    CFAllocatorRef v5 = (const void *)a2[2];
  }
  uint64_t result = CFEqual(v4, v5);
  if (result)
  {
    CFIndex Length = CFStringGetLength(a1[2]);
    effectiveRange.CFIndex location = 0;
    effectiveRange.uint64_t length = 0;
    v16.CFIndex location = 0;
    v16.uint64_t length = 0;
    if (Length < 1)
    {
      return 1;
    }
    else
    {
      CFIndex v8 = Length;
      CFIndex location = 0;
      CFIndex v10 = 0;
      CFIndex v11 = 0;
      CFIndex v12 = 0;
      CFDictionaryRef v13 = 0;
      CFDictionaryRef Attributes = 0;
      CFIndex v15 = 0;
      while (1)
      {
        if (v15 >= v11 + v12)
        {
          CFDictionaryRef Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)a1, v15, &effectiveRange);
          CFIndex location = v16.location;
          CFIndex v10 = v16.length;
        }
        if (v15 >= location + v10) {
          CFDictionaryRef v13 = CFAttributedStringGetAttributes((CFAttributedStringRef)a2, v15, &v16);
        }
        uint64_t result = CFEqual(Attributes, v13);
        if (!result) {
          break;
        }
        CFIndex location = v16.location;
        CFIndex v10 = v16.length;
        CFIndex v11 = effectiveRange.location;
        CFIndex v12 = effectiveRange.length;
        if (effectiveRange.location + effectiveRange.length >= v16.location + v16.length) {
          CFIndex v15 = v16.location + v16.length;
        }
        else {
          CFIndex v15 = effectiveRange.location + effectiveRange.length;
        }
        if (v15 >= v8) {
          return 1;
        }
      }
    }
  }
  return result;
}

CFHashCode __CFAttributedStringHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__CFAttributedStringCopyDescription(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (CFStringRef *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v81 = *(void *)off_1ECE0A5B0;
  CFCharacterSetRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFIndex Length = CFStringGetLength(v2[2]);
  effectiveRange.CFIndex location = 0;
  effectiveRange.uint64_t length = 0;
  if (Length >= 1)
  {
    CFIndex v5 = Length;
    CFIndex location = 0;
    while (1)
    {
      CFDictionaryRef Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)v2, location, &effectiveRange);
      CFStringRef v8 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2[2], effectiveRange);
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
      CFStringAppendFormat(Mutable, 0, @" %p {", Attributes);
      unint64_t Count = CFDictionaryGetCount(Attributes);
      long long v80 = 0u;
      long long v79 = 0u;
      long long v78 = 0u;
      long long v77 = 0u;
      long long v76 = 0u;
      long long v75 = 0u;
      long long v74 = 0u;
      long long v73 = 0u;
      long long v72 = 0u;
      long long v71 = 0u;
      long long v70 = 0u;
      long long v69 = 0u;
      long long v68 = 0u;
      long long v67 = 0u;
      long long v66 = 0u;
      long long v65 = 0u;
      long long v64 = 0u;
      long long v63 = 0u;
      long long v62 = 0u;
      long long v61 = 0u;
      long long v60 = 0u;
      long long v59 = 0u;
      long long v58 = 0u;
      long long v57 = 0u;
      long long v56 = 0u;
      long long v55 = 0u;
      long long v54 = 0u;
      long long v53 = 0u;
      long long v52 = 0u;
      long long v51 = 0u;
      long long v50 = 0u;
      *(_OWORD *)keys = 0u;
      if (Count >= 0xFFFFFFFFFFFFFFFLL) {
        __CFAttributedStringCopyDescription_cold_1();
      }
      unint64_t v10 = Count;
      if (Count >= 0x101) {
        break;
      }
      long long v47 = 0uLL;
      long long v48 = 0uLL;
      long long v45 = 0uLL;
      long long v46 = 0uLL;
      long long v43 = 0uLL;
      long long v44 = 0uLL;
      long long v41 = 0uLL;
      long long v42 = 0uLL;
      long long v39 = 0uLL;
      long long v40 = 0uLL;
      long long v37 = 0uLL;
      long long v38 = 0uLL;
      long long v35 = 0uLL;
      long long v36 = 0uLL;
      long long v33 = 0uLL;
      long long v34 = 0uLL;
      long long v31 = 0uLL;
      long long v32 = 0uLL;
      long long v29 = 0uLL;
      long long v30 = 0uLL;
      long long v27 = 0uLL;
      long long v28 = 0uLL;
      long long v25 = 0uLL;
      long long v26 = 0uLL;
      long long v23 = 0uLL;
      long long v24 = 0uLL;
      long long v21 = 0uLL;
      long long v22 = 0uLL;
      long long v19 = 0uLL;
      long long v20 = 0uLL;
      *(_OWORD *)CFRange values = 0uLL;
      long long v18 = 0uLL;
      CFIndex v11 = keys;
      CFIndex v12 = values;
      CFDictionaryGetKeysAndValues(Attributes, (const void **)keys, (const void **)values);
      if (v10) {
        goto LABEL_8;
      }
LABEL_13:
      CFStringAppendFormat(Mutable, 0, @"} Len %ld\n", effectiveRange.length);
      effectiveRange.location += effectiveRange.length;
      if (v11 != keys) {
        free(v11);
      }
      if (v12 != values) {
        free(v12);
      }
      CFIndex location = effectiveRange.location;
      if (effectiveRange.location >= v5) {
        return Mutable;
      }
    }
    CFIndex v11 = (void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)CFRange values = 0u;
    long long v18 = 0u;
    CFIndex v12 = (void **)malloc_type_malloc(8 * v10, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues(Attributes, (const void **)v11, (const void **)v12);
LABEL_8:
    unint64_t v13 = v10 - 1;
    do
    {
      if (v13) {
        long long v14 = ", ";
      }
      else {
        long long v14 = "";
      }
      CFStringAppendFormat(Mutable, 0, @"%@=%@%s", v11[v13], v12[v13], v14);
      --v13;
    }
    while (v13 != -1);
    goto LABEL_13;
  }
  return Mutable;
}

uint64_t _CFAttributedStringCreateWithRuns(__objc2_class **a1, const __CFString *a2, const __CFDictionary **a3, uint64_t a4, uint64_t a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x3EuLL, 16, 0);
  if (Instance)
  {
    *(void *)(Instance + 16) = CFStringCreateCopy((CFAllocatorRef)a1, a2);
    *(void *)(Instance + 24) = CFRunArrayCreate(a1);
    CFIndex Length = CFStringGetLength(*(CFStringRef *)(Instance + 16));
    if (Length)
    {
      uint64_t v12 = Length;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)a1, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFRunArrayInsert(*(CFTypeRef *)(Instance + 24), 0, v12, Mutable);
      CFRelease(Mutable);
    }
    if (a5 >= 1)
    {
      long long v14 = (uint64_t *)(a4 + 8);
      do
      {
        CFDictionaryRef v15 = *a3++;
        CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary((const __CFAllocator *)a1, v15);
        CFRunArrayReplace(*(void **)(Instance + 24), *(v14 - 1), *v14, AttributesDictionary, *v14);
        CFRelease(AttributesDictionary);
        v14 += 2;
        --a5;
      }
      while (a5);
    }
    unint64_t v17 = atomic_load((unint64_t *)(Instance + 8));
    unint64_t v18 = v17;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v18, v17 | 1);
      BOOL v19 = v18 == v17;
      unint64_t v17 = v18;
    }
    while (!v19);
  }
  return Instance;
}

uint64_t _CFAttributedStringGetNumberOfRuns(const __CFAttributedString *a1, int a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFAttributedStringGetLength(a1);
  if (Length < 1) {
    return 0;
  }
  CFIndex v5 = Length;
  CFIndex v6 = 0;
  uint64_t v7 = 0;
  do
  {
    longestEffectiveRange.CFIndex location = 0;
    longestEffectiveRange.uint64_t length = 0;
    v13.CFIndex location = v6;
    v13.uint64_t length = v5;
    CFDictionaryRef AttributesAndLongestEffectiveRange = CFAttributedStringGetAttributesAndLongestEffectiveRange(a1, v6, v13, &longestEffectiveRange);
    if (a2 || CFDictionaryGetCount(AttributesAndLongestEffectiveRange) >= 1) {
      ++v7;
    }
    v6 += longestEffectiveRange.length;
    BOOL v9 = v5 <= longestEffectiveRange.length;
    v5 -= longestEffectiveRange.length;
  }
  while (!v9);
  return v7;
}

uint64_t _CFAttributedStringGetRuns(const __CFAttributedString *a1, int a2, uint64_t *a3, CFRange *a4)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  uint64_t result = CFAttributedStringGetLength(a1);
  if (result >= 1)
  {
    CFIndex v9 = result;
    CFIndex v10 = 0;
    do
    {
      longestEffectiveRange.CFIndex location = 0;
      longestEffectiveRange.uint64_t length = 0;
      v15.CFIndex location = v10;
      v15.uint64_t length = v9;
      uint64_t result = (uint64_t)CFAttributedStringGetAttributesAndLongestEffectiveRange(a1, v10, v15, &longestEffectiveRange);
      uint64_t v11 = result;
      if (a2 || (uint64_t result = CFDictionaryGetCount((CFDictionaryRef)result), result >= 1))
      {
        if (a3) {
          *a3++ = v11;
        }
        if (a4) {
          *a4++ = longestEffectiveRange;
        }
      }
      v10 += longestEffectiveRange.length;
      BOOL v12 = v9 <= longestEffectiveRange.length;
      v9 -= longestEffectiveRange.length;
    }
    while (!v12);
  }
  return result;
}

CFMutableStringRef CFAttributedStringGetMutableString(CFMutableAttributedStringRef aStr)
{
  if (!CF_IS_OBJC(0x3EuLL, (unint64_t)aStr)) {
    return 0;
  }

  return (CFMutableStringRef)[(__CFAttributedString *)aStr mutableString];
}

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (!CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    if (!length) {
      return;
    }
    while (1)
    {
      CFIndex v15 = 0;
      CFIndex v16 = 0;
      CFStringRef ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), location, &v15, 0);
      CFStringRef v8 = ValueAtIndex;
      uint64_t v10 = v15;
      uint64_t v9 = v16;
      BOOL v11 = v15 == location && v16 <= length;
      if (!v11) {
        goto LABEL_14;
      }
      if (CFGetRetainCount(ValueAtIndex) != 1) {
        break;
      }
      CFDictionaryRemoveValue(v8, attrName);
LABEL_21:
      location += v16;
      length -= v16;
      if (!length) {
        return;
      }
    }
    uint64_t v10 = v15;
    uint64_t v9 = v16;
LABEL_14:
    BOOL v11 = v10 < location;
    uint64_t v12 = v10 - location;
    if (v11)
    {
      v9 += v12;
      CFIndex v15 = location;
      CFIndex v16 = v9;
    }
    if (v9 > length) {
      CFIndex v16 = length;
    }
    if (CFDictionaryContainsKey(v8, attrName))
    {
      CFAllocatorRef v13 = CFGetAllocator(aStr);
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v13, v8);
      CFDictionaryRemoveValue(AttributesDictionary, attrName);
      CFRunArrayReplace(*((void **)aStr + 3), v15, v16, AttributesDictionary, v16);
      CFRelease(AttributesDictionary);
    }
    goto LABEL_21;
  }

  -[__CFAttributedString removeAttribute:range:](aStr, "removeAttribute:range:", attrName, location, length);
}

void CFAttributedStringBeginEditing(CFMutableAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    [(__CFAttributedString *)aStr beginEditing];
  }
}

void CFAttributedStringEndEditing(CFMutableAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (unint64_t)aStr))
  {
    [(__CFAttributedString *)aStr endEditing];
  }
}

BOOL _CFAttributedStringIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 1) == 0;
}

BOOL __CFAttributedStringMtbl(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 1) == 0;
}

uint64_t _CFAttributedStringCheckAndReplace(uint64_t a1, CFIndex a2, CFIndex a3, const __CFString *a4)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3;
  }
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  if (v11) {
    return 1;
  }
  v12.CFIndex location = a2;
  v12.CFIndex length = a3;
  CFAttributedStringReplaceString((CFMutableAttributedStringRef)a1, v12, a4);
  return 0;
}

uint64_t _CFAttributedStringCheckAndSetAttribute(uint64_t a1, CFIndex a2, CFIndex a3, const __CFString *a4, const void *a5)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3;
  }
  char v13 = atomic_load((unint64_t *)(a1 + 8));
  if (v13) {
    return 1;
  }
  if (!a4) {
    return 2;
  }
  v14.CFIndex location = a2;
  v14.CFIndex length = a3;
  if (a5) {
    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)a1, v14, a4, a5);
  }
  else {
    CFAttributedStringRemoveAttribute((CFMutableAttributedStringRef)a1, v14, a4);
  }
  return 0;
}

void *__CFBagCreateTransfer(__objc2_class **a1, unint64_t *a2, uint64_t a3)
{
  v11[10] = *(void *)off_1ECE0A5B0;
  v11[0] = (uint64_t)__CFTypeCollectionRetain;
  v11[1] = (uint64_t)__CFTypeCollectionRetain;
  void v11[2] = (uint64_t)__CFTypeCollectionRelease;
  v11[3] = (uint64_t)__CFTypeCollectionRelease;
  v11[4] = (uint64_t)CFEqual;
  v11[5] = (uint64_t)CFEqual;
  v11[6] = (uint64_t)CFHash;
  v11[7] = 0;
  void v11[8] = (uint64_t)CFCopyDescription;
  v11[9] = (uint64_t)CFCopyDescription;
  CFIndex v5 = (void *)CFBasicHashCreate(a1, 0x2002u, v11);
  CFBasicHashSuppressRC((uint64_t)v5);
  if (a3 >= 1)
  {
    CFBasicHashSetCapacity((uint64_t)v5, a3);
    do
    {
      unint64_t v6 = *a2++;
      CFBasicHashAddValue((uint64_t)v5, v6, v6);
      --a3;
    }
    while (a3);
  }
  CFBasicHashUnsuppressRC((uint64_t)v5);
  unint64_t v7 = atomic_load(v5 + 1);
  unint64_t v8 = v7;
  do
  {
    atomic_compare_exchange_strong(v5 + 1, &v8, v7 | 0x40);
    BOOL v9 = v8 == v7;
    unint64_t v7 = v8;
  }
  while (!v9);
  _CFRuntimeSetInstanceTypeIDAndIsa(v5, 4uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v5;
}

CFBagRef CFBagCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFBagCallBacks *callBacks)
{
  uint64_t Generic = __CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  unint64_t v7 = (unint64_t *)Generic;
  if (Generic)
  {
    if (numValues >= 1)
    {
      CFBasicHashSetCapacity(Generic, numValues);
      do
      {
        unint64_t v8 = (unint64_t)*values++;
        CFBasicHashAddValue((uint64_t)v7, v8, v8);
        --numValues;
      }
      while (numValues);
    }
    unint64_t v9 = atomic_load(v7 + 1);
    unint64_t v10 = v9;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v7 + 1, &v10, v9 | 0x40);
      BOOL v11 = v10 == v9;
      unint64_t v9 = v10;
    }
    while (!v11);
    _CFRuntimeSetInstanceTypeIDAndIsa(v7, 4uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return (CFBagRef)v7;
}

void CFBagGetValues(CFBagRef theBag, const void **values)
{
  uint64_t Count = CFBasicHashGetCount((uint64_t)theBag);

  CFBasicHashGetElements((uint64_t)theBag, Count, 0, (uint64_t)values);
}

CFMutableBagRef CFBagCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFBagRef theBag)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  if (CF_IS_OBJC(4uLL, (unint64_t)theBag))
  {
    uint64_t Count = CFBasicHashGetCount((uint64_t)theBag);
    memset(v12, 0, 512);
    if (Count >= 257) {
      uint64_t Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    }
    else {
      uint64_t Typed = v12;
    }
    uint64_t v8 = CFBasicHashGetCount((uint64_t)theBag);
    CFBasicHashGetElements((uint64_t)theBag, v8, 0, (uint64_t)Typed);
    uint64_t Generic = __CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)&kCFTypeBagCallBacks);
    CFSetRef Copy = (__CFBag *)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (uint64_t i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, *((void *)Typed + i), *((void *)Typed + i));
    }
    if (Count >= 257) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  else
  {
    CFSetRef Copy = (__CFBag *)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theBag);
  }
  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 4uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }
  return Copy;
}

Boolean CFBagContainsValue(CFBagRef theBag, const void *value)
{
  return CFBasicHashGetCountOfKey((uint64_t)theBag, (unint64_t)value) > 0;
}

Boolean CFBagGetValueIfPresent(CFBagRef theBag, const void *candidate, const void **value)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  long long v5 = 0u;
  long long v6 = 0u;
  CFBasicHashFindBucket((uint64_t)theBag, (unint64_t)candidate, (uint64_t *)&v5);
  if (!*((void *)&v6 + 1)) {
    return 0;
  }
  if (value) {
    void *value = (const void *)v6;
  }
  return 1;
}

BOOL _CFBagIsMutable(unint64_t a1)
{
  if (CF_IS_OBJC(4uLL, a1)) {
    return 0;
  }
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

void _CFBagSetCapacity(unint64_t a1, uint64_t a2)
{
  if (!CF_IS_OBJC(4uLL, a1))
  {
    CFBasicHashSetCapacity(a1, a2);
  }
}

void CFBagReplaceValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog(3, @"%s(): immutable collection %p given to mutating function", v2, v3, v4, v5, v6, v7, (__int16)"void CFBagReplaceValue(CFMutableBagRef, const void *)");
  }

  CFBasicHashReplaceValue((unint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

void CFBagSetValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog(3, @"%s(): immutable collection %p given to mutating function", v2, v3, v4, v5, v6, v7, (__int16)"void CFBagSetValue(CFMutableBagRef, const void *)");
  }

  CFBasicHashSetValue((uint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

uint64_t __CFAllocatorGetAllocator(uint64_t result)
{
  if (*(void *)(result + 128) != 939) {
    return *(void *)(result + 128);
  }
  return result;
}

CFStringRef __CFAllocatorCopyDescription(uint64_t a1)
{
  CFAllocatorRef v1 = *(const __CFAllocator **)(a1 + 128);
  if (v1 == (const __CFAllocator *)939) {
    CFAllocatorRef v1 = (const __CFAllocator *)a1;
  }
  return CFStringCreateWithFormat(v1, 0, @"<CFAllocator %p [%p]>{info = %p}", a1, v1, *(void *)(a1 + 144));
}

CFTypeID CFAllocatorGetTypeID(void)
{
  return 2;
}

void *CFAllocatorAllocateBytes(malloc_zone_t *a1, size_t a2, uint64_t a3)
{
  return _CFAllocatorAllocateImpl(a1, a2, 0x100000000000000uLL, a3);
}

void *CFAllocatorReallocateBytes(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3, uint64_t a4)
{
  return CFAllocatorReallocateImpl(a1, a2, a3, 0x100000000000000uLL, a4);
}

CFIndex CFAllocatorGetPreferredSizeForSize(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  if (!allocator)
  {
    CFAllocatorRef allocator = (CFAllocatorRef)_CFGetTSD(1u);
    if (!allocator) {
      CFAllocatorRef allocator = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }
  unint64_t v5 = *(void *)allocator & ~(unint64_t)off_1ECE0A6D0;
  if ((*(void *)allocator & (unint64_t)off_1ECE0A6D0) != 0) {
    v5 |= *(void *)allocator & (unint64_t)off_1ECE0A6D0;
  }
  if (v5 == qword_1EB1DDDA0)
  {
    uint64_t v6 = 0;
    if (size >= 1)
    {
      uint64_t v7 = (uint64_t (*)(CFIndex, CFOptionFlags, void))*((void *)allocator + 25);
      if (v7) {
        uint64_t v6 = v7(size, hint, *((void *)allocator + 18));
      }
    }
    if (v6 <= size) {
      return size;
    }
    else {
      return v6;
    }
  }
  else
  {
    return malloc_good_size(size);
  }
}

uint64_t _CFGetOutOfMemoryErrorCallBack()
{
  return 0;
}

void *__CFSafelyReallocate(void *a1, size_t a2, uint64_t a3)
{
  return __CFSafelyReallocateImpl(a1, a2, (v3 >> 2), a3);
}

void *__CFSafelyReallocateWithAllocator(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3, malloc_type_id_t type_id, uint64_t a5)
{
  return __CFSafelyReallocateWithAllocatorImpl(a1, a2, a3, (v5 >> 2), type_id, a5);
}

CFTypeRef __CFNullCopyFormattingDescription()
{
  return CFRetain(@"null");
}

CFStringRef __CFNullCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFNull %p [%p]>", a1, v2);
}

uint64_t __CFAllocatorCustomSize()
{
  return 0;
}

void *__CFAllocatorCustomMalloc(malloc_zone_t *a1, size_t a2)
{
  return _CFAllocatorAllocateImpl(a1, a2, 0x28C574BCuLL, 0);
}

void *__CFAllocatorCustomCalloc(malloc_zone_t *a1, int a2, size_t size)
{
  Impl = _CFAllocatorAllocateImpl(a1, size, 0xC7E02CA8uLL, 0);
  unint64_t v5 = Impl;
  if (Impl) {
    bzero(Impl, size);
  }
  return v5;
}

unint64_t __CFAllocatorCustomValloc(malloc_zone_t *a1, unint64_t a2)
{
  if (~(2 * *(void *)off_1ECE0A708) <= a2) {
    return 0;
  }
  else {
    return ((unint64_t)_CFAllocatorAllocateImpl(a1, *(void *)off_1ECE0A708 + a2, 0x19AD8B8CuLL, 0)
  }
          + *(void *)off_1ECE0A708
          - 1) & -*(void *)off_1ECE0A708;
}

void *__CFAllocatorCustomRealloc(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3)
{
  return CFAllocatorReallocateImpl(a1, a2, a3, 0xE716AB6EuLL, 0);
}

uint64_t __CFAllocatorZoneIntrospectNoOp()
{
  return 0;
}

CFIndex __CFAllocatorCustomGoodSize(const __CFAllocator *a1, CFIndex a2)
{
  return CFAllocatorGetPreferredSizeForSize(a1, a2, 0);
}

uint64_t __CFAllocatorZoneIntrospectTrue()
{
  return 1;
}

uint64_t __CFAllocatorNullSize()
{
  return 0;
}

uint64_t __CFAllocatorNullMalloc()
{
  return 0;
}

uint64_t __CFAllocatorNullCalloc()
{
  return 0;
}

uint64_t __CFAllocatorNullValloc()
{
  return 0;
}

uint64_t __CFAllocatorNullRealloc()
{
  return 0;
}

uint64_t __CFAllocatorNullAllocate()
{
  return 0;
}

uint64_t __CFAllocatorNullReallocate()
{
  return 0;
}

uint64_t __CFAllocatorNullGoodSize(uint64_t a1, uint64_t a2)
{
  return a2;
}

double __os_log_helper_1_2_4_8_32_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&double result = 136315906;
  *(_DWORD *)a1 = 136315906;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2048;
  *(void *)(a1 + 34) = a5;
  return result;
}

void sub_182CA9A60(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CA9EDC(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CAA80C(_Unwind_Exception *a1)
{
  free(*v1);
  _Unwind_Resume(a1);
}

void sub_182CAAC10(_Unwind_Exception *exception_object)
{
}

uint64_t (**__CFStringEncodingGetArabicConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter)
  {
    __CFStringEncodingPrecomposeLatinCharacter = (_UNKNOWN *)a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1 = (_UNKNOWN *)a2(3);
  }
  if (a1 > 517)
  {
    if (a1 != 518)
    {
      if (a1 == 1286) {
        return __CFConverterWindowsArabic;
      }
      return 0;
    }
    return __CFConverterISOLatinArabic;
  }
  else
  {
    if (a1 != 4)
    {
      if (a1 == 140) {
        return __CFConverterMacFarsi;
      }
      return 0;
    }
    return __CFConverterMacArabic;
  }
}

uint64_t __CFToMacArabic(uint64_t IsValidCombiningCharacterForLatin1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v21 = *(void *)off_1ECE0A5B0;
  char v20 = 0;
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    goto LABEL_25;
  }
  char v11 = IsValidCombiningCharacterForLatin1;
  uint64_t v12 = 0;
  while (1)
  {
    if (a5 < 0)
    {
      if ((v11 & 0x10) == 0) {
        goto LABEL_25;
      }
      IsValidCombiningCharacterForLatin1 = *(unsigned __int16 *)(a2 + 2 * v12);
      if ((IsValidCombiningCharacterForLatin1 - 1619) >= 3)
      {
        IsValidCombiningCharacterForLatin1 = __CFStringEncodingIsValidCombiningCharacterForLatin1();
        if (!IsValidCombiningCharacterForLatin1) {
          goto LABEL_25;
        }
      }
    }
    unsigned int v13 = *(unsigned __int16 *)(a2 + 2 * v12);
    if (v13 <= 0x7F)
    {
      char v20 = *(_WORD *)(a2 + 2 * v12);
      if (!a5) {
        goto LABEL_20;
      }
LABEL_19:
      *(unsigned char *)(a4 + v12) = v20;
      goto LABEL_20;
    }
    if ((unsigned __int16)(v13 - 10059) < 0xD955u) {
      break;
    }
    CFRange v14 = (unsigned __int16 *)&unk_182D611E4;
    CFIndex v15 = (unsigned __int16 *)&macarabic_from_uni;
    while (1)
    {
      uint64_t v16 = ((char *)v14 - (char *)v15) >> 3;
      uint64_t v17 = &v15[2 * v16];
      unsigned int v18 = *v17;
      if (v18 <= v13) {
        break;
      }
      CFRange v14 = v17 - 2;
LABEL_16:
      if (v15 > v14) {
        goto LABEL_17;
      }
    }
    if (v18 < v13)
    {
      CFIndex v15 = v17 + 2;
      goto LABEL_16;
    }
    char v20 = v15[2 * v16 + 1];
    if (a5) {
      goto LABEL_19;
    }
LABEL_20:
    if (++v12 == a3)
    {
      uint64_t v12 = a3;
      goto LABEL_25;
    }
  }
LABEL_17:
  IsValidCombiningCharacterForLatin1 = __CFToISOArabic(IsValidCombiningCharacterForLatin1, v13, &v20);
  if (IsValidCombiningCharacterForLatin1)
  {
    if (!a5) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
LABEL_25:
  *a6 = 0;
  return v12;
}

uint64_t __CFFromMacArabic(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t result = a3;
  }
  else {
    uint64_t result = a5;
  }
  if (result >= 1)
  {
    uint64_t v8 = result;
    while (1)
    {
      int v9 = *a2++;
      int v10 = v9;
      if (v9 < 0) {
        break;
      }
      if (a5) {
        goto LABEL_11;
      }
LABEL_12:
      ++a4;
      if (!--v8) {
        goto LABEL_17;
      }
    }
    LOWORD(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = macarabic_to_uni[v10 - 128];
    if (!a5) {
      goto LABEL_12;
    }
LABEL_11:
    *a4 = v10;
    goto LABEL_12;
  }
  uint64_t result = 0;
LABEL_17:
  *a6 = result;
  return result;
}

uint64_t __CFIsValidCombiningCharacterForArabic(int a1)
{
  if ((a1 - 1619) >= 3) {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1();
  }
  else {
    return 1;
  }
}

uint64_t __CFToISOArabic(uint64_t a1, int a2, unsigned char *a3)
{
  if (a2 < 0xA1) {
    goto LABEL_2;
  }
  if ((a2 - 1569) <= 0x31)
  {
    if ((a2 - 59) < 5u) {
      return 0;
    }
    LOBYTE(a2) = a2 - 96;
    goto LABEL_2;
  }
  uint64_t result = 0;
  if (a2 <= 1547)
  {
    if (a2 == 164 || a2 == 173) {
      goto LABEL_2;
    }
  }
  else
  {
    switch(a2)
    {
      case 1548:
        LOBYTE(a2) = -84;
        goto LABEL_2;
      case 1563:
        LOBYTE(a2) = -69;
        goto LABEL_2;
      case 1567:
        LOBYTE(a2) = -65;
LABEL_2:
        *a3 = a2;
        return 1;
    }
  }
  return result;
}

uint64_t __CFToMacFarsi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (a5 >= a3 || a5 == 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = a5;
  }
  if (v8 < 1)
  {
    uint64_t v12 = 0;
    goto LABEL_28;
  }
  uint64_t v12 = 0;
  char v21 = 0;
  while (1)
  {
    unsigned int v13 = *(unsigned __int16 *)(a2 + 2 * v12);
    if (v13 <= 0x7F)
    {
      char v21 = *(_WORD *)(a2 + 2 * v12);
      goto LABEL_22;
    }
    if (v13 - 1776 <= 9)
    {
      char v14 = v13 - 64;
      goto LABEL_13;
    }
    if ((unsigned __int16)(v13 - 10059) < 0xD955u) {
      break;
    }
    CFIndex v15 = (unsigned __int16 *)&unk_182D611E4;
    uint64_t v16 = (unsigned __int16 *)&macarabic_from_uni;
    while (1)
    {
      uint64_t v17 = ((char *)v15 - (char *)v16) >> 3;
      unsigned int v18 = &v16[2 * v17];
      unsigned int v19 = *v18;
      if (v19 <= v13) {
        break;
      }
      CFIndex v15 = v18 - 2;
LABEL_20:
      if (v16 > v15) {
        goto LABEL_21;
      }
    }
    if (v19 < v13)
    {
      uint64_t v16 = v18 + 2;
      goto LABEL_20;
    }
    char v14 = v16[2 * v17 + 1];
LABEL_13:
    char v21 = v14;
LABEL_22:
    if (a5) {
      *(unsigned char *)(a4 + v12) = v21;
    }
    if (++v12 == v8)
    {
      uint64_t v12 = v8;
      goto LABEL_28;
    }
  }
LABEL_21:
  a1 = __CFToISOArabic(a1, v13, &v21);
  if (a1) {
    goto LABEL_22;
  }
LABEL_28:
  *a6 = v12;
  return v12;
}

uint64_t __CFFromMacFarsi(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t result = a3;
  }
  else {
    uint64_t result = a5;
  }
  if (result >= 1)
  {
    uint64_t v8 = result;
    while (1)
    {
      int v10 = *a2++;
      unsigned __int8 v9 = v10;
      int v11 = v10;
      if (v10 < 0)
      {
        if ((v9 + 80) > 9u)
        {
          LOWORD(v11) = macarabic_to_uni[v11 - 128];
          if (!a5) {
            goto LABEL_14;
          }
LABEL_13:
          *a4 = v11;
          goto LABEL_14;
        }
        LOWORD(v11) = v9 + 1600;
      }
      if (a5) {
        goto LABEL_13;
      }
LABEL_14:
      ++a4;
      if (!--v8) {
        goto LABEL_19;
      }
    }
  }
  uint64_t result = 0;
LABEL_19:
  *a6 = result;
  return result;
}

uint64_t __CFToWinArabic(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0;
  }
  unint64_t v5 = (unsigned __int16 *)&cp1256_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182D614C4;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    unint64_t v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWinArabic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = cp1256_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinArabicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = *a2;
  if (v9 >= 0x80)
  {
    int v11 = a2[1];
    if (v11 == 1621)
    {
      if (v9 != 1575) {
        return 0;
      }
      unsigned int v10 = 1573;
    }
    else if (v11 == 1620)
    {
      uint64_t result = 0;
      if (*a2 > 0x6C0u)
      {
        switch(v9)
        {
          case 0x6C1u:
            unsigned int v10 = 1730;
            break;
          case 0x6D2u:
            unsigned int v10 = 1747;
            break;
          case 0x6D5u:
            unsigned int v10 = 1728;
            break;
          default:
            return result;
        }
      }
      else
      {
        switch(v9)
        {
          case 0x627u:
            unsigned int v10 = 1571;
            break;
          case 0x648u:
            unsigned int v10 = 1572;
            break;
          case 0x64Au:
            unsigned int v10 = 1574;
            break;
          default:
            return result;
        }
      }
    }
    else
    {
      if (v11 != 1619 || v9 != 1575) {
        return 0;
      }
      unsigned int v10 = 1570;
    }
  }
  else
  {
    unsigned int v10 = __CFStringEncodingPrecomposeLatinCharacter(a2, a3, 0);
    if (v10 <= 0x7F) {
      goto LABEL_33;
    }
    if ((unsigned __int16)(v10 - 8483) < 0xDF7Du) {
      return 0;
    }
  }
  unsigned int v13 = (unsigned __int16 *)&cp1256_from_uni;
  char v14 = (unsigned __int16 *)&unk_182D614C4;
  while (1)
  {
    uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
    uint64_t v16 = &v13[2 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v10) {
      break;
    }
    char v14 = v16 - 2;
LABEL_30:
    if (v13 > v14) {
      return 0;
    }
  }
  if (v17 < v10)
  {
    unsigned int v13 = v16 + 2;
    goto LABEL_30;
  }
  LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v13[2 * v15 + 1];
LABEL_33:
  if (!(_BYTE)v10) {
    return 0;
  }
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFFromISOArabic(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 < 0xA1) {
    goto LABEL_2;
  }
  if (a2 < 0xC1)
  {
    uint64_t result = 0;
    if ((int)a2 <= 172)
    {
      if (a2 == 164) {
        goto LABEL_2;
      }
      if (a2 == 172)
      {
        LOWORD(a2) = 1548;
        goto LABEL_2;
      }
    }
    else
    {
      switch(a2)
      {
        case 0xADu:
          goto LABEL_2;
        case 0xBBu:
          LOWORD(a2) = 1563;
          goto LABEL_2;
        case 0xBFu:
          LOWORD(a2) = 1567;
          goto LABEL_2;
      }
    }
  }
  else
  {
    uint64_t result = 0;
    if (a2 <= 0xF2 && (a2 + 37) >= 5u)
    {
      LOWORD(a2) = a2 + 1376;
LABEL_2:
      *a3 = a2;
      return 1;
    }
  }
  return result;
}

uint64_t __CFToISOArabicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  int v9 = a2[1];
  if (v9 == 1621)
  {
    if (*a2 == 1575)
    {
      int v10 = 1573;
      goto LABEL_18;
    }
LABEL_17:
    int v10 = 65533;
    goto LABEL_18;
  }
  if (v9 == 1620)
  {
    unsigned int v11 = *a2;
    if (v11 > 0x6C0)
    {
      switch(v11)
      {
        case 0x6C1u:
          int v10 = 1730;
          goto LABEL_18;
        case 0x6D2u:
          int v10 = 1747;
          goto LABEL_18;
        case 0x6D5u:
          int v10 = 1728;
          goto LABEL_18;
      }
    }
    else
    {
      switch(v11)
      {
        case 0x627u:
          int v10 = 1571;
          goto LABEL_18;
        case 0x648u:
          int v10 = 1572;
          goto LABEL_18;
        case 0x64Au:
          int v10 = 1574;
          goto LABEL_18;
      }
    }
    goto LABEL_17;
  }
  if (v9 != 1619 || *a2 != 1575) {
    goto LABEL_17;
  }
  int v10 = 1570;
LABEL_18:
  char v14 = 0;
  int v12 = __CFToISOArabic(a1, v10, &v14);
  uint64_t result = 0;
  if (v12 && v14)
  {
    if (a5) {
      *a4 = v14;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t CFUniCharGetBidiCategory(uint64_t result, uint64_t a2, unsigned char *a3)
{
  if (a2 >= 1)
  {
    uint64_t v4 = (unsigned __int16 *)result;
    uint64_t result = 0;
    uint64_t v5 = -1;
    uint64_t v6 = &v4[a2];
    do
    {
      uint64_t v7 = v4 + 1;
      unsigned int v8 = *v4;
      if ((v8 & 0xFC00) != 0xD800 || v7 >= v6)
      {
        ++v4;
      }
      else
      {
        int v10 = *v7;
        BOOL v11 = (v10 & 0xFC00) == 56320;
        int v12 = v10 + (v8 << 10) - 56613888;
        if (v11) {
          v4 += 2;
        }
        else {
          ++v4;
        }
        if (v11) {
          unsigned int v8 = v12;
        }
      }
      if (v5 != (HIWORD(v8) & 0x1F))
      {
        uint64_t result = CFUniCharGetUnicodePropertyDataForPlane(1u, HIWORD(v8) & 0x1F);
        uint64_t v5 = HIWORD(v8) & 0x1F;
      }
      if (result)
      {
        unint64_t v13 = *(unsigned __int8 *)(result + BYTE1(v8));
        if (v13 >= 0x13) {
          LOBYTE(v13) = *(unsigned char *)(result + ((v13 << 8) - 4864) + v8 + 256);
        }
      }
      else
      {
        LOBYTE(v13) = 1;
      }
      *a3 = v13;
      if (v8 < 0x10000)
      {
        ++a3;
      }
      else
      {
        a3[1] = v13;
        a3 += 2;
      }
    }
    while (v4 < v6);
  }
  return result;
}

uint64_t CFUniCharGetFirstBidiParagraphLength(uint64_t a1, uint64_t a2)
{
  if (a2 < 1) {
    return 0;
  }
  uint64_t v2 = 0;
  while (1)
  {
    int v3 = *(unsigned __int8 *)(a1 + v2);
    if (v3 == 13) {
      break;
    }
    if ((v3 - 11) <= 2) {
      *(unsigned char *)(a1 + v2) = 0;
    }
    if (a2 == ++v2) {
      return a2;
    }
  }
  a2 = v2 + 1;
  *(unsigned char *)(a1 + v2) = 10;
  return a2;
}

uint64_t CFUniCharApplyUnicodeBidiAlgorithm(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 < 1) {
    return result;
  }
  unint64_t v5 = a2;
  int v6 = result;
  unint64_t v7 = a2 + a4;
  if (result) {
    int v8 = 1;
  }
  else {
    int v8 = 2;
  }
  int v75 = result & 1;
  BOOL v76 = !(result & 1);
  int v77 = v8;
  int v80 = result;
  unint64_t v78 = a2 + a4;
  do
  {
    uint64_t v9 = v7 - v5;
    if (v9 < 1)
    {
      uint64_t result = resolveExplicit(v6, 0, v5, a3, 0, 0);
      int v13 = 0;
      uint64_t v12 = 0;
      int v14 = 0;
      int v15 = 0;
      int v16 = v75;
      int v17 = v77;
      goto LABEL_72;
    }
    uint64_t v10 = 0;
    while (1)
    {
      int v11 = *(unsigned __int8 *)(v5 + v10);
      if (v11 == 13) {
        break;
      }
      if ((v11 - 11) <= 2) {
        *(unsigned char *)(v5 + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      }
      if (v9 == ++v10)
      {
        uint64_t result = resolveExplicit(v6, 0, v5, a3, v9, 0);
        uint64_t v12 = v9;
        goto LABEL_15;
      }
    }
    uint64_t v18 = v10 + 1;
    *(unsigned char *)(v5 + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 10;
    uint64_t result = resolveExplicit(v6, 0, v5, a3, v10 + 1, 0);
    uint64_t v12 = v18;
LABEL_15:
    int v15 = 0;
    uint64_t v19 = 0;
    int v20 = v6;
    int v17 = v77;
    do
    {
      unsigned __int8 v21 = *(unsigned char *)(v5 + v19);
      if ((v21 & 0x7F) == 0xA)
      {
        *(unsigned char *)(a3 + v19) = v6;
        uint64_t v22 = v19 + 1;
        if (v19 + 1 != v12 || v6 == v80)
        {
          if (v22 >= v12 || (int v42 = *(unsigned __int8 *)(a3 + v22), v6 == v42) || *(unsigned char *)(v5 + v22) == 10)
          {
            if (v15) {
              ++v15;
            }
            else {
              int v15 = 0;
            }
            char v41 = *(unsigned char *)(v5 + v19) | 0x80;
            goto LABEL_64;
          }
          if (v6 > v42) {
            LOBYTE(v42) = v6;
          }
          *(unsigned char *)(a3 + v19) = v42;
          if (v42) {
            unsigned __int8 v21 = 2;
          }
          else {
            unsigned __int8 v21 = 1;
          }
          *(unsigned char *)(v5 + v19) = v21;
          int v6 = *(unsigned __int8 *)(a3 + v22);
        }
        else
        {
          if (v6) {
            unsigned __int8 v21 = 2;
          }
          else {
            unsigned __int8 v21 = 1;
          }
          *(unsigned char *)(v5 + v19) = v21;
        }
        char v23 = 0x80;
      }
      else
      {
        char v23 = 0;
      }
      uint64_t v24 = (int)v19 - 1;
      int v25 = *(unsigned __int8 *)(a3 + v19);
      if (v20 != v25)
      {
        BOOL v26 = v21 > 5u || ((1 << v21) & 0x26) == 0;
        if (v26)
        {
          if (v15 >= 1)
          {
            if (v6 <= v25) {
              char v27 = *(unsigned char *)(a3 + v19);
            }
            else {
              char v27 = v6;
            }
            BOOL v26 = (v27 & 1) == 0;
            uint64_t v28 = 2;
            if (v26) {
              uint64_t v28 = 1;
            }
            int v29 = actionWeak[10 * v17 + v28] >> 4;
            if (v29 != 15)
            {
              int v30 = v19 - v15;
              if ((int)v24 < v30) {
                int v30 = v19 - 1;
              }
              uint64_t v31 = v12;
              uint64_t result = (uint64_t)memset((void *)(v5 + v24 - (v24 - v30)), v29, (v24 - v30) + 1);
              uint64_t v12 = v31;
              int v15 = 0;
              int v25 = *(unsigned __int8 *)(a3 + v19);
            }
          }
          if (v20 <= v25) {
            char v32 = v25;
          }
          else {
            char v32 = v20;
          }
          if (v32) {
            int v17 = 1;
          }
          else {
            int v17 = 2;
          }
        }
        int v20 = v25;
      }
      uint64_t v33 = v21;
      unsigned int v34 = actionWeak[10 * v17 + v21];
      int v35 = v34 >> 4;
      if (v35 != 15)
      {
        if (v15 >= 1)
        {
          int v36 = v19 - v15;
          if ((int)v24 < v36) {
            int v36 = v19 - 1;
          }
          uint64_t v37 = (v24 - v36);
          long long v38 = (void *)(v5 + v24 - v37);
          uint64_t v39 = v12;
          uint64_t result = (uint64_t)memset(v38, v35, v37 + 1);
          uint64_t v12 = v39;
        }
        int v15 = 0;
      }
      char v40 = v34 & 0xF;
      if ((v34 & 0xF) == 0xF) {
        char v40 = *(unsigned char *)(v5 + v19);
      }
      v15 += (v34 >> 8) & 1;
      int v17 = stateWeak[10 * v17 + v33];
      char v41 = v40 | v23;
      uint64_t v22 = v19 + 1;
LABEL_64:
      *(unsigned char *)(v5 + v19) = v41;
      uint64_t v19 = v22;
    }
    while (v22 != v12);
    int v16 = v6 & 1;
    int v13 = 1;
    int v14 = v12;
LABEL_72:
    BOOL v26 = v16 == 0;
    uint64_t v43 = 2;
    if (v26) {
      uint64_t v43 = 1;
    }
    int v44 = actionWeak[10 * v17 + v43] >> 4;
    BOOL v45 = v44 == 15 || v15 < 1;
    uint64_t v79 = v12;
    if (!v45)
    {
      int v46 = v14 - v15;
      int v47 = v14 - 1;
      if (v46 >= v47) {
        int v46 = v47;
      }
      uint64_t result = (uint64_t)memset((void *)(v5 - (v47 - v46) + v47), v44, (v47 - v46) + 1);
      uint64_t v12 = v79;
    }
    if (v13)
    {
      int v74 = v13;
      int v48 = 0;
      int v49 = 0;
      int v50 = -1;
      long long v51 = (char *)v5;
      long long v52 = (char *)a3;
      uint64_t v53 = v12;
      char v54 = v80;
      int v55 = v76;
      uint64_t v81 = a3;
      do
      {
        unsigned int v56 = *v51;
        unsigned int v57 = v56;
        if ((v56 & 0x80) != 0)
        {
          unsigned int v57 = v56 & 0x7F;
          *long long v51 = v56 & 0x7F;
        }
        int v58 = v50;
        if (v57 == 10)
        {
          if (v49) {
            ++v49;
          }
          else {
            int v49 = 0;
          }
          char v59 = 10;
        }
        else
        {
          unsigned int v60 = actionNeutrals[5 * v55 + v57];
          int v61 = v60 >> 4;
          if (v60 >> 4)
          {
            if (v61 == 3)
            {
              if (v54) {
                int v61 = 2;
              }
              else {
                int v61 = 1;
              }
            }
            if (v49 >= 1)
            {
              int v62 = v48 - v49;
              if (v50 < v62) {
                int v62 = v50;
              }
              uint64_t result = (uint64_t)memset((void *)(v5 + v50 - (unint64_t)(v50 - v62)), v61, (v50 - v62) + 1);
              uint64_t v12 = v79;
            }
            int v49 = 0;
          }
          char v59 = v60 & 0xF;
          if ((v60 & 0xF) != 0) {
            *long long v51 = v59;
          }
          else {
            char v59 = *v51;
          }
          v49 += (v60 >> 8) & 1;
          int v55 = stateNeutrals[5 * v55 + v57];
          char v54 = *v52;
          a3 = v81;
        }
        *v51++ = v59 | v56 & 0x80;
        ++v52;
        int v50 = v58 + 1;
        ++v48;
        --v53;
      }
      while (v53);
      int v63 = v54 & 1;
      int v64 = v12;
      int v6 = v80;
      unint64_t v7 = v78;
      int v13 = v74;
    }
    else
    {
      int v64 = 0;
      int v49 = 0;
      int v63 = v75;
      int v55 = v76;
      int v6 = v80;
      unint64_t v7 = v78;
    }
    if (v63) {
      unsigned int v65 = 2;
    }
    else {
      unsigned int v65 = 1;
    }
    if (actionNeutrals[5 * v55 + v65] >> 4)
    {
      if (actionNeutrals[5 * v55 + v65] >> 4 != 3) {
        unsigned int v65 = actionNeutrals[5 * v55 + v65] >> 4;
      }
      if (v49 >= 1)
      {
        int v66 = v64 - v49;
        int v67 = v64 - 1;
        if (v66 >= v67) {
          int v66 = v67;
        }
        uint64_t result = (uint64_t)memset((void *)(v5 - (v67 - v66) + v67), v65, (v67 - v66) + 1);
        uint64_t v12 = v79;
      }
    }
    if (v13)
    {
      long long v68 = (char *)v5;
      long long v69 = (unsigned char *)a3;
      uint64_t v70 = v12;
      LOBYTE(v71) = v6;
      do
      {
        int v73 = *v68++;
        unsigned __int8 v72 = v73;
        if ((v73 & 0x80000000) == 0) {
          int v71 = *v69 + addLevel[4 * (*v69 & 1) - 1 + v72];
        }
        *v69++ = v71;
        --v70;
      }
      while (v70);
    }
    v5 += v12;
    a3 += v12;
  }
  while (v5 < v7);
  return result;
}

uint64_t resolveExplicit(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a5 >= 1)
  {
    uint64_t v6 = a5;
    char v10 = a1;
    uint64_t v11 = 0;
    if (a1) {
      int v12 = 2;
    }
    else {
      int v12 = 1;
    }
    unsigned int v13 = v12 + a1;
    if (a1) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
    unsigned int v15 = v14 + a1;
    int v23 = a6;
    uint64_t v16 = a6;
    while (1)
    {
      int v17 = *(unsigned __int8 *)(a3 + v11);
      if ((v17 - 14) < 2)
      {
        uint64_t v18 = (v16 + 1);
        if (v13 > 0x3D)
        {
LABEL_24:
          LOBYTE(v17) = -118;
          *(unsigned char *)(a3 + v11) = -118;
LABEL_26:
          *(unsigned char *)(a4 + v11) = v10;
          if ((*(unsigned char *)(a3 + v11) & 0x7F) != 0xA)
          {
            if (a2) {
              LOBYTE(v17) = a2;
            }
            *(unsigned char *)(a3 + v11) = v17;
          }
          uint64_t v16 = v18;
          goto LABEL_31;
        }
        *(unsigned char *)(a4 + v11) = v13;
        *(unsigned char *)(a3 + v11) = -118;
        uint64_t v19 = *(unsigned __int8 *)(a4 + v11);
        uint64_t v20 = 2 * (v17 != 15);
      }
      else
      {
        if ((v17 - 16) >= 2)
        {
          if (v17 == 18)
          {
            *(unsigned char *)(a3 + v11) = -118;
            if ((int)v16 <= v23) {
              uint64_t v21 = v11;
            }
            else {
              uint64_t v21 = v6;
            }
            if (v16)
            {
              uint64_t v6 = v21;
              uint64_t v18 = v16 - ((int)v16 > v23);
            }
            else
            {
              uint64_t v18 = 0;
            }
            LOBYTE(v17) = -118;
          }
          else
          {
            uint64_t v18 = v16;
          }
          goto LABEL_26;
        }
        uint64_t v18 = (v16 + 1);
        if (v15 > 0x3D) {
          goto LABEL_24;
        }
        *(unsigned char *)(a4 + v11) = v15;
        *(unsigned char *)(a3 + v11) = -118;
        uint64_t v19 = *(unsigned __int8 *)(a4 + v11);
        uint64_t v20 = v17 != 17;
      }
      v11 += resolveExplicit(v19, v20, a3 + v11 + 1, a4 + v11 + 1, v6 - (v11 + 1), v18);
LABEL_31:
      if (++v11 >= v6) {
        return v11;
      }
    }
  }
  return 0;
}

BOOL CFAttributedStringGetBidiLevels(const __CFAttributedString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFAttributedStringGetBidiLevelsAndResolvedDirections(a1, a2, a3, a4, a5, 0, a7, a8);
}

uint64_t CFUniCharGetDefaultWritingDirection()
{
  CFDictionaryRef v0 = __CFXPreferencesCopyCurrentApplicationState();
  uint64_t v1 = CFUniCharGetDefaultWritingDirection_defaultDirection;
  if (CFUniCharGetDefaultWritingDirection_defaultDirection == 255)
  {
    CFDictionaryRef v2 = v0;
    if (__CFUniCharGetBooleanValueForKey(@"NSForceRightToLeftWritingDirection", v0))
    {
      uint64_t v1 = 1;
    }
    else
    {
      CFBundleRef MainBundle = CFBundleGetMainBundle();
      if (MainBundle && (CFArrayRef v4 = CFBundleCopyBundleLocalizations(MainBundle)) != 0)
      {
        CFArrayRef v5 = v4;
        CFArrayRef v6 = CFBundleCopyLocalizationsForPreferences(v4, 0);
        uint64_t v1 = (uint64_t)v6;
        if (v6)
        {
          if (CFArrayGetCount(v6) >= 1
            && (CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v1, 0),
                CFLocaleGetLanguageCharacterDirection(ValueAtIndex) == kCFLocaleLanguageDirectionRightToLeft))
          {
            CFRelease((CFTypeRef)v1);
            uint64_t v1 = __CFUniCharGetBooleanValueForKey(@"NSForceLeftToRightWritingDirection", v2) ^ 1;
          }
          else
          {
            CFRelease((CFTypeRef)v1);
            uint64_t v1 = 0;
          }
        }
        CFRelease(v5);
      }
      else
      {
        uint64_t v1 = 0;
      }
    }
    CFUniCharGetDefaultWritingDirection_defaultDirectiouint64_t n = v1;
    if (v2)
    {
      CFRelease(v2);
      return CFUniCharGetDefaultWritingDirection_defaultDirection;
    }
  }
  return v1;
}

uint64_t __CFUniCharGetBooleanValueForKey(CFStringRef key, CFDictionaryRef theDict)
{
  v14[1] = *(void *)off_1ECE0A5B0;
  if (theDict && (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, key)) != 0)
  {
    CFStringRef v4 = Value;
    int v5 = 0;
  }
  else
  {
    CFStringRef v6 = (const __CFString *)CFPreferencesCopyAppValue(key, @"kCFPreferencesCurrentApplication");
    if (!v6) {
      return 0;
    }
    CFStringRef v4 = v6;
    int v5 = 1;
  }
  CFTypeID v7 = CFGetTypeID(v4);
  if (v7 == CFBooleanGetTypeID())
  {
    BOOL v8 = CFBooleanGetValue((CFBooleanRef)v4) == 0;
  }
  else
  {
    if (v7 != CFNumberGetTypeID())
    {
      if (v7 == CFStringGetTypeID() && (CFIndex Length = CFStringGetLength(v4), Length >= 1))
      {
        CFIndex v12 = Length;
        int CharacterAtIndex = CFStringGetCharacterAtIndex(v4, 0);
        if ((CharacterAtIndex & 0xFFFFFFDF) == 0x59
          || (uint64_t v9 = 0, v12 == 1) && (CharacterAtIndex - 49) <= 8)
        {
          uint64_t v9 = 1;
        }
      }
      else
      {
        uint64_t v9 = 0;
      }
      goto LABEL_15;
    }
    v14[0] = 0;
    if (CFNumberGetValue((CFNumberRef)v4, kCFNumberCFIndexType, v14)) {
      BOOL v8 = v14[0] == 0;
    }
    else {
      BOOL v8 = 1;
    }
  }
  uint64_t v9 = !v8;
LABEL_15:
  if (v5) {
    CFRelease(v4);
  }
  return v9;
}

void __CFRelativeDateTimeFormatterDeallocate(uint64_t a1)
{
  if (!a1) {
    __CFRelativeDateTimeFormatterDeallocate_cold_1();
  }
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1)
  {
    CFRelease(v1);
  }
}

CFStringRef __CFRelativeDateTimeFormatterCopyDescription(const void *a1)
{
  if (!a1) {
    __CFRelativeDateTimeFormatterCopyDescription_cold_1();
  }
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFRelativeDateTimeFormatter %p>[%p]", a1, v3);
}

uint64_t _CFRelativeDateTimeFormatterGetTypeID()
{
  return 67;
}

void *_CFRelativeDateTimeFormatterCreate(__objc2_class **a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1) {
      a1 = &__kCFAllocatorSystemDefault;
    }
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance(a1, 0x43uLL, 32, 0);
  if (Instance)
  {
    Instance[4] = CFRetain(a2);
    Instance[5] = a5;
    Instance[2] = a4;
    Instance[3] = a3;
  }
  return Instance;
}

CFStringRef _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit(const __CFAllocator *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a2 + 32));
  CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(Identifier, buffer, 157, 0x600u)) {
      return 0;
    }
  }
  uint64_t v10 = 0;
  unsigned int v11 = 0;
  switch(*(void *)(a2 + 24))
  {
    case 0:
      goto LABEL_10;
    case 1:
      int v24 = 0;
      uint64_t v12 = __cficu_unum_open(5u, 0, 0, (uint64_t)CStringPtr, 0, &v24);
      uint64_t v10 = v12;
      if (v24 >= 1)
      {
        if (v12) {
          __cficu_unum_close(v12);
        }
        return 0;
      }
      unsigned int v11 = 0;
LABEL_10:
      int v24 = 0;
      unint64_t v13 = *(void *)(a2 + 40);
      if (v13 >= 6) {
        _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_4();
      }
      uint64_t v14 = __cficu_ureldatefmt_open((uint64_t)CStringPtr, v10, v11, dword_182D9DD38[v13], &v24);
      uint64_t v15 = v14;
      if (v24 >= 1)
      {
        if (v14) {
          __cficu_ureldatefmt_close(v14);
        }
        return 0;
      }
      if (a3 <= 31)
      {
        switch(a3)
        {
          case 4:
            uint64_t v17 = 0;
            goto LABEL_31;
          case 8:
            uint64_t v17 = 2;
            goto LABEL_31;
          case 16:
            uint64_t v17 = 4;
            goto LABEL_31;
        }
LABEL_45:
        _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_2();
      }
      if (a3 > 127)
      {
        if (a3 == 128)
        {
          uint64_t v17 = 7;
          goto LABEL_31;
        }
        if (a3 == 4096)
        {
          uint64_t v17 = 3;
          goto LABEL_31;
        }
        goto LABEL_45;
      }
      if (a3 == 32)
      {
        uint64_t v17 = 5;
        goto LABEL_31;
      }
      if (a3 != 64) {
        goto LABEL_45;
      }
      uint64_t v17 = 6;
LABEL_31:
      MEMORY[0x1F4188790](v14, v17);
      int v24 = 0;
      uint64_t v19 = *(void *)(a2 + 16);
      if (v19 == 1)
      {
        int v20 = __cficu_ureldatefmt_format(v15, v18, v23, 128, &v24, a4);
      }
      else
      {
        if (v19) {
          _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_3();
        }
        int v20 = __cficu_ureldatefmt_formatNumeric(v15, v18, v23, 128, &v24, a4);
      }
      int v21 = v20;
      __cficu_ureldatefmt_close(v15);
      if (v24 > 0) {
        return 0;
      }
      if (!a1)
      {
        uint64_t v22 = _CFGetTSD(1u);
        if (v22) {
          a1 = (const __CFAllocator *)v22;
        }
        else {
          a1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
        }
      }
      return CFStringCreateWithCharacters(a1, v23, v21);
    case 2:
      uint64_t v10 = 0;
      unsigned int v11 = 1;
      goto LABEL_10;
    case 3:
      uint64_t v10 = 0;
      unsigned int v11 = 2;
      goto LABEL_10;
    default:
      _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_1();
  }
}

uint64_t (**__CFStringEncodingGetVietnameseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_0) {
    __CFStringEncodingPrecomposeLatinCharacter_0 = (_UNKNOWN *)a2(4);
  }
  if (a1 == 1288) {
    return __CFConverterWindowsVietnamese;
  }
  else {
    return 0;
  }
}

uint64_t __CFToWindowsVietnamese(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0;
  }
  int v5 = (unsigned __int16 *)&WindowsVietnamese_from_uni;
  CFStringRef v6 = (unsigned __int16 *)&unk_182D9E080;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    BOOL v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFStringRef v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWindowsVietnamese(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsVietnamese_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsVietnamesePrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_0(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      unsigned int v11 = (unsigned __int16 *)&WindowsVietnamese_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182D9E080;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          unsigned int v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFIsValidCombiningCharacterForVietnamese(int a1)
{
  if ((a1 - 768) > 0x5F) {
    return 0;
  }
  else {
    return (__CFVietnameseCombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

void __CFBinaryHeapDeallocate(unint64_t *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFBinaryHeapRemoveAllValues((CFBinaryHeapRef)a1);
  char v3 = atomic_load(a1 + 1);
  if ((v3 & 0xC) == 4)
  {
    CFStringRef v4 = (void *)a1[14];
    CFAllocatorDeallocate(v2, v4);
  }
}

#error "182CAE70C: call analysis failed (funcsize=110)"

uint64_t __CFBinaryHeapHash(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__CFString *__CFBinaryHeapCopyDescription(void *a1)
{
  uint64_t v47 = *(void *)off_1ECE0A5B0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)CFRange values = 0u;
  long long v16 = 0u;
  uint64_t v2 = a1[2];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFBinaryHeap %p [%p]>{size_t count = %lu, capacity = %lu, objects = (\n"), a1, v5, v2, a1[3], 0, 0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0);
  if (v2 >= 129)
  {
    uint64_t Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v2, 0x80040B8603338, 0);
    BOOL v7 = Typed != values;
    if (__CFOASafe && Typed != values)
    {
      __CFSetLastAllocationEventName();
      BOOL v7 = 1;
    }
    CFBinaryHeapGetValues((CFBinaryHeapRef)a1, (const void **)Typed);
  }
  else
  {
    uint64_t Typed = values;
    CFBinaryHeapGetValues((CFBinaryHeapRef)a1, (const void **)values);
    if (v2 <= 0)
    {
      CFStringAppend(Mutable, @"}"));
      return Mutable;
    }
    BOOL v7 = 0;
  }
  for (uint64_t i = 0; i != v2; ++i)
  {
    unsigned int v9 = Typed[i];
    uint64_t v10 = (uint64_t (*)(void *))a1[7];
    if (v10 && (uint64_t v11 = v10(Typed[i])) != 0)
    {
      uint64_t v12 = (const void *)v11;
      CFStringAppendFormat(Mutable, 0, @"\t%lu : %@\n", i, v11);
      CFRelease(v12);
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, @"\t%lu : <%p>\n", i, v9);
    }
  }
  CFStringAppend(Mutable, @"}"));
  if (v7)
  {
    CFAllocatorRef v13 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v13, Typed);
  }
  return Mutable;
}

CFTypeID CFBinaryHeapGetTypeID(void)
{
  return 23;
}

CFBinaryHeapRef CFBinaryHeapCreateCopy(CFAllocatorRef allocator, CFIndex capacity, CFBinaryHeapRef heap)
{
  return (CFBinaryHeapRef)__CFBinaryHeapCreateInit((__objc2_class **)allocator, *((const void ***)heap + 14), *((void *)heap + 2), (uint64_t)heap + 32, (long long *)((char *)heap + 72));
}

CFIndex CFBinaryHeapGetCountOfValue(CFBinaryHeapRef heap, const void *value)
{
  uint64_t v2 = *((void *)heap + 2);
  if (v2 < 1) {
    return 0;
  }
  CFIndex v5 = 0;
  uint64_t v6 = 0;
  BOOL v7 = (uint64_t (*)(const void *))*((void *)heap + 8);
  do
  {
    if (*(const void **)(*((void *)heap + 14) + 8 * v6) == value || v7 && !v7(value)) {
      ++v5;
    }
    ++v6;
  }
  while (v2 != v6);
  return v5;
}

Boolean CFBinaryHeapContainsValue(CFBinaryHeapRef heap, const void *value)
{
  uint64_t v2 = *((void *)heap + 2);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = (uint64_t (*)(const void *))*((void *)heap + 8);
  while (*(const void **)(*((void *)heap + 14) + 8 * v5) != value && (!v6 || v6(value)))
  {
    if (v2 == ++v5) {
      return 0;
    }
  }
  return 1;
}

const void *__cdecl CFBinaryHeapGetMinimum(CFBinaryHeapRef heap)
{
  if (*((uint64_t *)heap + 2) < 1) {
    return 0;
  }
  else {
    return (const void *)**((void **)heap + 14);
  }
}

Boolean CFBinaryHeapGetMinimumIfPresent(CFBinaryHeapRef heap, const void **value)
{
  if (!*((void *)heap + 2)) {
    return 0;
  }
  if (value) {
    void *value = (const void *)**((void **)heap + 14);
  }
  return 1;
}

void CFBinaryHeapGetValues(CFBinaryHeapRef heap, const void **values)
{
  if (*((void *)heap + 2))
  {
    CFStringRef v4 = (__objc2_class **)CFGetAllocator(heap);
    uint64_t Init = __CFBinaryHeapCreateInit(v4, *((const void ***)heap + 14), *((void *)heap + 2), (uint64_t)heap + 32, (long long *)((char *)heap + 72));
    if (*(uint64_t *)(Init + 16) >= 1)
    {
      do
      {
        uint64_t v6 = **(const void ***)(Init + 112);
        CFBinaryHeapRemoveMinimumValue((CFBinaryHeapRef)Init);
        *values++ = v6;
      }
      while (*(uint64_t *)(Init + 16) > 0);
    }
    CFRelease((CFTypeRef)Init);
  }
}

void CFBinaryHeapRemoveMinimumValue(CFBinaryHeapRef heap)
{
  uint64_t v1 = *((void *)heap + 2);
  if (!v1) {
    return;
  }
  uint64_t v3 = v1 - 1;
  *((void *)heap + 2) = v1 - 1;
  CFStringRef v4 = (uint64_t (*)(unint64_t, unint64_t, void))*((void *)heap + 8);
  CFAllocatorRef v5 = CFGetAllocator(heap);
  uint64_t v6 = (void (*)(CFAllocatorRef, void))*((void *)heap + 6);
  if (v6) {
    v6(v5, **((void **)heap + 14));
  }
  uint64_t v7 = *((void *)heap + 14);
  unint64_t v8 = *(void *)(v7 + 8 * v3);
  uint64_t v9 = *((void *)heap + 2);
  if (v9 < 2)
  {
    uint64_t v10 = 0;
    goto LABEL_24;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 1;
  while (1)
  {
    uint64_t v12 = v10;
    uint64_t v7 = *((void *)heap + 14);
    unint64_t v13 = *(void *)(v7 + 8 * v11);
    uint64_t v14 = v11 + 1;
    if (v11 + 1 < v9) {
      break;
    }
    if (!v4 && v13 > v8) {
      goto LABEL_23;
    }
    uint64_t v10 = v11;
    if (v4) {
      goto LABEL_14;
    }
LABEL_20:
    *(void *)(v7 + 8 * v12) = v13;
    uint64_t v11 = (2 * v10) | 1;
    if (v11 >= v9)
    {
      uint64_t v7 = *((void *)heap + 14);
      goto LABEL_24;
    }
  }
  unint64_t v15 = *(void *)(v7 + 8 * v14);
  if (v4)
  {
    if (v4(*(void *)(v7 + 8 * v11), *(void *)(v7 + 8 * v14), *((void *)heap + 10)) == 1)
    {
      ++v11;
      unint64_t v13 = v15;
    }
LABEL_14:
    uint64_t v16 = v4(v13, v8, *((void *)heap + 10));
    uint64_t v7 = *((void *)heap + 14);
    if (v16 == 1) {
      goto LABEL_23;
    }
    uint64_t v9 = *((void *)heap + 2);
    uint64_t v10 = v11;
    goto LABEL_20;
  }
  if (v13 <= v15)
  {
    uint64_t v10 = v11;
  }
  else
  {
    unint64_t v13 = *(void *)(v7 + 8 * v14);
    uint64_t v10 = v11 + 1;
  }
  if (v13 <= v8) {
    goto LABEL_20;
  }
LABEL_23:
  uint64_t v10 = v12;
LABEL_24:
  *(void *)(v7 + 8 * v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v8;
}

void CFBinaryHeapApplyFunction(CFBinaryHeapRef heap, CFBinaryHeapApplierFunction applier, void *context)
{
  if (*((void *)heap + 2))
  {
    uint64_t v6 = (__objc2_class **)CFGetAllocator(heap);
    uint64_t Init = __CFBinaryHeapCreateInit(v6, *((const void ***)heap + 14), *((void *)heap + 2), (uint64_t)heap + 32, (long long *)((char *)heap + 72));
    if (*(uint64_t *)(Init + 16) >= 1)
    {
      do
      {
        uint64_t v8 = **(void **)(Init + 112);
        CFBinaryHeapRemoveMinimumValue((CFBinaryHeapRef)Init);
        ((void (*)(uint64_t, void *))applier)(v8, context);
      }
      while (*(uint64_t *)(Init + 16) > 0);
    }
    CFRelease((CFTypeRef)Init);
  }
}

void CFBinaryHeapAddValue(CFBinaryHeapRef heap, const void *value)
{
  CFAllocatorRef v4 = CFGetAllocator(heap);
  char v5 = atomic_load((unint64_t *)heap + 1);
  if ((v5 & 0xC) == 4)
  {
    uint64_t v6 = *((void *)heap + 2);
    if (v6 == *((void *)heap + 3))
    {
      uint64_t v7 = v6 >= 3 ? 1 << flsl(v6 + 1) : 4;
      CFAllocatorRef v8 = CFGetAllocator(heap);
      *((void *)heap + 3) = v7;
      *((void *)heap + 14) = __CFSafelyReallocateWithAllocatorTyped(v8, *((void *)heap + 14), 8 * v7, 0x80040B8603338, 0, 0);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }
  uint64_t v9 = *((void *)heap + 2);
  *((void *)heap + 2) = v9 + 1;
  if (v9 >= 1)
  {
    uint64_t v10 = (uint64_t (*)(void, const void *, void))*((void *)heap + 8);
    while (1)
    {
      uint64_t v11 = (v9 - 1) >> 1;
      uint64_t v12 = *((void *)heap + 14);
      unint64_t v13 = *(void *)(v12 + 8 * v11);
      if (!v10 && v13 <= (unint64_t)value) {
        break;
      }
      if (v10)
      {
        if (v10(*(void *)(v12 + 8 * v11), value, *((void *)heap + 10)) != 1) {
          break;
        }
        uint64_t v12 = *((void *)heap + 14);
      }
      *(void *)(v12 + 8 * v9) = v13;
      BOOL v14 = v9 <= 2;
      uint64_t v9 = (v9 - 1) >> 1;
      if (v14) {
        goto LABEL_19;
      }
    }
  }
  uint64_t v11 = v9;
LABEL_19:
  unint64_t v15 = (uint64_t (*)(CFAllocatorRef, const void *))*((void *)heap + 5);
  if (v15) {
    CFURLRef value = (const void *)v15(v4, value);
  }
  *(void *)(*((void *)heap + 14) + 8 * v11) = value;
}

void CFBinaryHeapRemoveAllValues(CFBinaryHeapRef heap)
{
  uint64_t v2 = *((void *)heap + 2);
  if (*((void *)heap + 6)) {
    BOOL v3 = v2 < 1;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = 0;
    do
    {
      char v5 = (void (*)(CFAllocatorRef, void))*((void *)heap + 6);
      CFAllocatorRef v6 = CFGetAllocator(heap);
      v5(v6, *(void *)(*((void *)heap + 14) + 8 * v4++));
    }
    while (v2 != v4);
  }
  *((void *)heap + 2) = 0;
}

CFStringRef __CFKeyedArchiverUIDCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"@%u@", *(unsigned int *)(a1 + 16));
}

CFStringRef __CFKeyedArchiverUIDCopyDescription(unsigned int *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFKeyedArchiverUID %p [%p]>{CFURLRef value = %u}", a1, v2, a1[4]);
}

uint64_t __CFBinaryPlistWriteToStream(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0);
}

uint64_t __CFBinaryPlistWriteToStreamWithEstimate(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0);
}

BOOL __CFBinaryPlistIsArray(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL result = 0;
  if (a3 >= 8 && *(void *)(a4 + 24) - 1 >= a3) {
    return (*(unsigned char *)(a1 + a3) & 0xF0) == 160;
  }
  return result;
}

unint64_t __CFBinaryPlistIsDictionary(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = 0;
  if (a3 < 8) {
    return v4;
  }
  unint64_t v5 = *(void *)(a4 + 24) - 1;
  if (v5 < a3) {
    return v4;
  }
  unint64_t v4 = 0;
  CFAllocatorRef v6 = (unsigned char *)(a1 + a3);
  if (a1 + a3 == -1) {
    return v4;
  }
  char v7 = *v6;
  if ((*v6 & 0xF0) != 0xD0) {
    return v4;
  }
  CFAllocatorRef v8 = v6 + 1;
  unint64_t v4 = v7 & 0xF;
  if ((v7 & 0xF) == 0xF)
  {
    if (a1 + v5 < (unint64_t)v8) {
      return 0;
    }
    uint64_t v9 = v8 + 1;
    unsigned __int8 v10 = *v8;
    if ((*v8 & 0xF0) != 0x10) {
      return 0;
    }
    unint64_t v4 = 0;
    unsigned int v11 = v10 & 0xF;
    uint64_t v12 = 1 << (v10 & 0xF);
    if (__CFADD__(v12, v9) || (unint64_t)&v8[v12] > a1 + v5) {
      return v4;
    }
    switch((char)v12)
    {
      case 1:
        unint64_t v4 = *v9;
        goto LABEL_23;
      case 2:
        unint64_t v4 = __rev16(*(unsigned __int16 *)(v8 + 1));
        goto LABEL_23;
      case 4:
        unint64_t v4 = bswap32(*(_DWORD *)(v8 + 1));
        goto LABEL_23;
      case 8:
        unint64_t v4 = bswap64(*(void *)(v8 + 1));
        goto LABEL_22;
      default:
        if (v11 >= 8)
        {
          unint64_t v4 = 0;
          CFAllocatorRef v8 = &v9[v12];
          goto LABEL_28;
        }
        unint64_t v4 = 0;
        if ((v12 & 0xFE) != 0) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = 1;
        }
        BOOL v14 = v9;
        do
        {
          unsigned int v15 = *v14++;
          unint64_t v4 = v15 | (v4 << 8);
          --v13;
        }
        while (v13);
LABEL_22:
        if ((v4 & 0x8000000000000000) != 0) {
          return 0;
        }
LABEL_23:
        CFAllocatorRef v8 = &v9[v12];
        break;
    }
  }
  if (v4)
  {
    unint64_t v16 = 2 * v4;
    if (!is_mul_ok(v16, *(unsigned __int8 *)(a4 + 7))) {
      return 0;
    }
    unint64_t v4 = v16 * *(unsigned __int8 *)(a4 + 7);
  }
LABEL_28:
  BOOL v17 = __CFADD__(v4, v8);
  LODWORD(v4) = a1 + v5 >= (unint64_t)&v8[v4 - 1];
  if (v17) {
    return 0;
  }
  else {
    return v4;
  }
}

uint64_t __CFBitVectorEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (v2) {
      BOOL v3 = v2 < -7;
    }
    else {
      BOOL v3 = 1;
    }
    if (v3) {
      return 1;
    }
    uint64_t v4 = v2 / 8;
    unint64_t v5 = *(unsigned __int8 **)(a1 + 32);
    CFAllocatorRef v6 = *(unsigned __int8 **)(a2 + 32);
    uint64_t v7 = v4 + 1;
    while (1)
    {
      int v9 = *v5++;
      int v8 = v9;
      int v10 = *v6++;
      if (v8 != v10) {
        break;
      }
      if (!--v7) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t __CFBitVectorHash(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__CFString *__CFBitVectorCopyDescription(void *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[4];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<CFBitVector %p [%p]>{size_t count = %lu, capacity = %lu, objects = (\n"), a1, v5, v2, a1[3];
  uint64_t v6 = 0;
  uint64_t v7 = v2 + 63;
  if (v2 >= 0) {
    uint64_t v7 = v2;
  }
  if (v2 >= 64)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = v7 >> 6;
    do
    {
      CFStringAppendFormat(Mutable, 0, @"\t%lu : ", v9 << 6);
      unint64_t v11 = 0;
      do
      {
        unsigned int v12 = *(unsigned __int8 *)(v3 + ((v8 + v11) >> 3));
        CFStringAppendFormat(Mutable, 0, @"%u%u%u%u", (v12 >> (v11 & 4 ^ 7)) & 1, (v12 >> (v11 & 4 ^ 6)) & 1, (v12 >> (v11 & 4 ^ 5)) & 1, (v12 >> (v11 & 4 ^ 4)) & 1);
        BOOL v13 = v11 >= 0x3C;
        v11 += 4;
      }
      while (!v13);
      CFStringAppend(Mutable, @"\n");
      ++v9;
      v8 += 64;
    }
    while (v9 != v10);
    uint64_t v6 = v10 << 6;
  }
  if (v6 < v2)
  {
    CFStringAppendFormat(Mutable, 0, @"\t%lu : ", v6);
    do
    {
      CFStringAppendFormat(Mutable, 0, @"%u", (*(unsigned __int8 *)(v3 + ((unint64_t)v6 >> 3)) >> (~(_BYTE)v6 & 7)) & 1);
      ++v6;
    }
    while (v2 != v6);
  }
  CFStringAppend(Mutable, @"\n}"));
  return Mutable;
}

CFTypeID CFBitVectorGetTypeID(void)
{
  return 24;
}

CFBitVectorRef CFBitVectorCreateCopy(CFAllocatorRef allocator, CFBitVectorRef bv)
{
  return (CFBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 0, *((const void **)bv + 4), *((void *)bv + 2));
}

CFIndex CFBitVectorGetCountOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  if (!range.length) {
    return 0;
  }
  CFIndex v5 = 0;
  uint64_t v4 = value;
  __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorCountBits, (uint64_t)&v4);
  return v5;
}

void CFBitVectorFlipBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx)
{
  *(unsigned char *)(*((void *)bv + 4) + idx / 8) ^= 1 << (~(_BYTE)idx & 7);
}

void CFBitVectorFlipBits(CFMutableBitVectorRef bv, CFRange range)
{
  if (range.length) {
    __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorFlipBits, 0);
  }
}

uint64_t __CFBitVectorFlipBits(int a1)
{
  return a1 ^ 0xFFu;
}

void CFBitVectorSetBits(CFMutableBitVectorRef bv, CFRange range, CFBit value)
{
  if (range.length)
  {
    if (value) {
      uint64_t v3 = __CFBitVectorOneBits;
    }
    else {
      uint64_t v3 = __CFBitVectorZeroBits;
    }
    __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(void, uint64_t, uint64_t))v3, 0);
  }
}

uint64_t __CFBitVectorOneBits()
{
  return 255;
}

uint64_t CFStringEncodingPrecomposeLatinCharacter(unsigned __int16 *a1, uint64_t a2, unint64_t *a3)
{
  if (a2 < 1) {
    goto LABEL_18;
  }
  unsigned int v5 = *a1;
  if ((v5 & 0xF800 | 0x400) == 0xDC00)
  {
    if (a3) {
      *a3 = 1;
    }
    return (unsigned __int16)v5;
  }
  unint64_t v7 = 1;
  if ((unint64_t)a2 >= 2)
  {
    while (1)
    {
      unsigned int v8 = a1[v7];
      if ((v8 & 0xF800 | 0x400) == 0xDC00 || !CFUniCharIsMemberOf(a1[v7], 8u)) {
        break;
      }
      unsigned int v9 = CFUniCharPrecomposeCharacter(v5, v8);
      if (v9 == 65533 || HIWORD(v9) != 0) {
        break;
      }
      ++v7;
      unsigned int v5 = v9;
      if (a2 == v7)
      {
        LOWORD(v5) = v9;
        unint64_t v7 = a2;
        break;
      }
    }
  }
  if (a3) {
    *a3 = v7;
  }
  if (v7 <= 1) {
LABEL_18:
  }
    LOWORD(v5) = -3;
  return (unsigned __int16)v5;
}

uint64_t __CFFromASCII(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if ((a2 & 0x80) == 0) {
    *a3 = a2;
  }
  return (a2 >> 7) ^ 1;
}

uint64_t __CFFromISOLatin1(uint64_t a1, __int16 a2, _WORD *a3)
{
  *a3 = a2;
  return 1;
}

unint64_t __CFToISOLatin1Precompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v12[1] = *(void *)off_1ECE0A5B0;
  v12[0] = 0;
  unsigned int v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v12);
  unint64_t result = 0;
  if (v9 <= 0xFF)
  {
    unint64_t result = 0;
    if ((_BYTE)v9)
    {
      unint64_t v11 = v12[0];
      if ((uint64_t)v12[0] >= 2)
      {
        if (a5) {
          *a4 = v9;
        }
        *a6 = 1;
        return v11;
      }
    }
  }
  return result;
}

uint64_t __CFFromMacRoman(uint64_t a1, int a2, _WORD *a3)
{
  *a3 = __CFMacRomanCharToUnicharTable[a2];
  return 1;
}

unint64_t __CFToMacRomanPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v18[1] = *(void *)off_1ECE0A5B0;
  v18[0] = 0;
  unsigned int v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v18);
  if (v9 <= 0x7F)
  {
    int v10 = v9;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1277) < 0x59Du) {
    return 0;
  }
  BOOL v13 = (unsigned __int16 *)&macRoman_from_uni;
  BOOL v14 = (unsigned __int16 *)&unk_182D9E3B4;
  while (1)
  {
    uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
    unint64_t v16 = &v13[2 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v9) {
      break;
    }
    BOOL v14 = v16 - 2;
LABEL_16:
    if (v13 > v14) {
      return 0;
    }
  }
  if (v17 < v9)
  {
    BOOL v13 = v16 + 2;
    goto LABEL_16;
  }
  int v10 = LOBYTE(v13[2 * v15 + 1]);
LABEL_3:
  unint64_t result = v18[0];
  if (!v10 || (int64_t)v18[0] < 2) {
    return 0;
  }
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return result;
}

uint64_t __CFToWinLatin1(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 < 0x80 || a2 - 160 <= 0x5F)
  {
    char v9 = a2;
    goto LABEL_12;
  }
  if (a2 - 8483 < 0xFFFFE02F) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)&cp1252_from_uni;
  uint64_t v4 = (unsigned __int16 *)&unk_182D9E420;
  while (1)
  {
    uint64_t v5 = ((char *)v4 - (char *)v3) >> 3;
    uint64_t v6 = &v3[2 * v5];
    unsigned int v7 = *v6;
    if (v7 <= a2) {
      break;
    }
    uint64_t v4 = v6 - 2;
LABEL_9:
    if (v3 > v4) {
      return 0;
    }
  }
  if (v7 < a2)
  {
    uint64_t v3 = v6 + 2;
    goto LABEL_9;
  }
  char v9 = v3[2 * v5 + 1];
LABEL_12:
  *a3 = v9;
  return 1;
}

BOOL __CFFromWinLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((char)a2 < -96) {
    a2 = cp1252_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinLatin1Precompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  char v16 = 0;
  int64_t v15 = 0;
  uint64_t v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, (unint64_t *)&v15);
  int v10 = __CFToWinLatin1(v9, v9, &v16);
  uint64_t result = 0;
  uint64_t v12 = v15;
  if (v10) {
    BOOL v13 = v16 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13 && v15 >= 2)
  {
    if (a5) {
      *a4 = v16;
    }
    *a6 = 1;
    return v12;
  }
  return result;
}

uint64_t __CFToNextStepLatin(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 2) >= 0xA2u)
    {
      uint64_t v4 = (unsigned __int16 *)&nextstep_from_tab;
      uint64_t v5 = (unsigned __int16 *)&unk_182D9E65C;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        unsigned int v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          uint64_t v4 = v7 + 2;
        }
        else
        {
          uint64_t v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromNextStepLatin(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = NSToPrecompUnicodeTable[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

unint64_t __CFToNextStepLatinPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  v18[1] = *(void *)off_1ECE0A5B0;
  v18[0] = 0;
  unsigned int v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v18);
  if (v9 <= 0x7F)
  {
    int v10 = v9;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 2) < 0xA2u) {
    return 0;
  }
  BOOL v13 = (unsigned __int16 *)&nextstep_from_tab;
  BOOL v14 = (unsigned __int16 *)&unk_182D9E65C;
  while (1)
  {
    uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
    char v16 = &v13[2 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v9) {
      break;
    }
    BOOL v14 = v16 - 2;
LABEL_16:
    if (v13 > v14) {
      return 0;
    }
  }
  if (v17 < v9)
  {
    BOOL v13 = v16 + 2;
    goto LABEL_16;
  }
  int v10 = LOBYTE(v13[2 * v15 + 1]);
LABEL_3:
  unint64_t result = v18[0];
  if (!v10 || (int64_t)v18[0] < 2) {
    return 0;
  }
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return result;
}

uint64_t __CFToUTF8Len(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  LODWORD(result) = 0;
  uint64_t v4 = a2;
  do
  {
    unsigned int v6 = *v4++;
    unsigned int v5 = v6;
    uint64_t v7 = a3 - 1;
    if ((v6 & 0xFC00) != 0xD800 || a3 == 1)
    {
      --a3;
    }
    else
    {
      int v9 = *v4;
      int v10 = v9 & 0xFC00;
      unint64_t v11 = a2 + 2;
      int v12 = v9 + (v5 << 10) - 56613888;
      a3 -= 2;
      if (v10 == 56320) {
        uint64_t v4 = v11;
      }
      else {
        a3 = v7;
      }
      if (v10 == 56320) {
        unsigned int v5 = v12;
      }
    }
    if (v5 < 0x10000) {
      int v13 = 3;
    }
    else {
      int v13 = 4;
    }
    if (v5 < 0x800) {
      int v13 = 2;
    }
    if (v5 >= 0x80) {
      int v14 = v13;
    }
    else {
      int v14 = 1;
    }
    uint64_t result = (v14 + result);
    a2 = v4;
  }
  while (a3);
  return result;
}

uint64_t __CFFromUTF8Len(__int16 a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v23 = *(void *)off_1ECE0A5B0;
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v6 = 0;
    int v7 = a1 & 0xC0;
    while (1)
    {
      unsigned int v8 = *a2;
      if (v3 <= (unsigned __int16)trailingBytesForUTF8[*a2]) {
        return v6;
      }
      --v3;
      if ((~(_BYTE)v8 & 0xF8) == 0) {
        break;
      }
      uint64_t v9 = (unsigned __int16)trailingBytesForUTF8[*a2];
      if ((a1 & 0x800) == 0)
      {
        int v10 = &a2[v9];
        while (v10 > a2)
        {
          char v11 = *v10--;
          if ((v11 & 0xC0) != 0x80) {
            goto LABEL_5;
          }
        }
        if ((char)v8 < -62 || v8 > 0xF4) {
          break;
        }
        if (*a2 > 0xEFu)
        {
          if (v8 == 240)
          {
            if (a2[1] < 0x90u) {
              break;
            }
          }
          else if (v8 == 244 && a2[1] >= 0x90u)
          {
            break;
          }
        }
        else if (v8 == 224)
        {
          if (a2[1] < 0xA0u) {
            break;
          }
        }
        else if (v8 == 237 && a2[1] > 0x9Fu)
        {
          break;
        }
      }
      int v12 = 0;
      int v13 = (unsigned __int16)trailingBytesForUTF8[*a2];
      switch(*a2)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
        case 0x90u:
        case 0x91u:
        case 0x92u:
        case 0x93u:
        case 0x94u:
        case 0x95u:
        case 0x96u:
        case 0x97u:
        case 0x98u:
        case 0x99u:
        case 0x9Au:
        case 0x9Bu:
        case 0x9Cu:
        case 0x9Du:
        case 0x9Eu:
        case 0x9Fu:
        case 0xA0u:
        case 0xA1u:
        case 0xA2u:
        case 0xA3u:
        case 0xA4u:
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
        case 0xAAu:
        case 0xABu:
        case 0xACu:
        case 0xADu:
        case 0xAEu:
        case 0xAFu:
        case 0xB0u:
        case 0xB1u:
        case 0xB2u:
        case 0xB3u:
        case 0xB4u:
        case 0xB5u:
        case 0xB6u:
        case 0xB7u:
        case 0xB8u:
        case 0xB9u:
        case 0xBAu:
        case 0xBBu:
        case 0xBCu:
        case 0xBDu:
        case 0xBEu:
        case 0xBFu:
          goto LABEL_34;
        case 0xC0u:
        case 0xC1u:
        case 0xC2u:
        case 0xC3u:
        case 0xC4u:
        case 0xC5u:
        case 0xC6u:
        case 0xC7u:
        case 0xC8u:
        case 0xC9u:
        case 0xCAu:
        case 0xCBu:
        case 0xCCu:
        case 0xCDu:
        case 0xCEu:
        case 0xCFu:
        case 0xD0u:
        case 0xD1u:
        case 0xD2u:
        case 0xD3u:
        case 0xD4u:
        case 0xD5u:
        case 0xD6u:
        case 0xD7u:
        case 0xD8u:
        case 0xD9u:
        case 0xDAu:
        case 0xDBu:
        case 0xDCu:
        case 0xDDu:
        case 0xDEu:
        case 0xDFu:
          goto LABEL_33;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
          goto LABEL_32;
        case 0xF0u:
        case 0xF1u:
        case 0xF2u:
        case 0xF3u:
        case 0xF4u:
        case 0xF5u:
        case 0xF6u:
        case 0xF7u:
          int v12 = v8 << 6;
          unsigned int v14 = *++a2;
          unsigned int v8 = v14;
LABEL_32:
          unsigned int v15 = *++a2;
          int v12 = (v12 + v8) << 6;
          unsigned int v8 = v15;
LABEL_33:
          unsigned int v16 = *++a2;
          int v13 = (v12 + v8) << 6;
          unsigned int v8 = v16;
LABEL_34:
          ++a2;
          int v12 = v13 + v8;
          break;
        default:
          break;
      }
      v3 -= v9;
      unsigned int v17 = v12 - offsetsFromUTF8[v9];
      if (HIWORD(v17))
      {
        if (v17 < 0x110000)
        {
          if (v7 && CFUniCharIsMemberOf(v17, 0x65u))
          {
            uint64_t v18 = CFUniCharDecomposeCharacter(v17, v22, 10);
            if (v18 >= 1)
            {
              do
              {
                if (v22[v18 - 1] < 0x10000) {
                  uint64_t v19 = 1;
                }
                else {
                  uint64_t v19 = 2;
                }
                v6 += v19;
              }
              while ((unint64_t)v18-- > 1);
            }
          }
          else
          {
            v6 += 2;
          }
          goto LABEL_9;
        }
      }
      else
      {
        if ((a1 & 0x80) == 0 && (v17 & 0xFFFFF800) == 0xD800) {
          return v6;
        }
        if (v7 && v17 >= 0x80 && CFUniCharIsMemberOf(v17, 0x65u))
        {
          v6 += CFUniCharDecomposeCharacter(v17, v22, 10);
          goto LABEL_9;
        }
      }
LABEL_8:
      ++v6;
LABEL_9:
      if (!v3) {
        return v6;
      }
    }
LABEL_5:
    if ((a1 & 1) == 0 && v8 != 169) {
      return v6;
    }
    ++a2;
    goto LABEL_8;
  }
  return 0;
}

CFURLRef _CFBundleCopyMainBundleExecutableURL(unsigned char *a1)
{
  uint64_t v2 = _CFProcessPath();
  if (v2 && (CFStringRef v3 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2)) != 0)
  {
    CFStringRef v4 = v3;
    CFURLRef v5 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, kCFURLPOSIXPathStyle, 0);
    CFRelease(v4);
    if (!a1) {
      return v5;
    }
  }
  else
  {
    CFURLRef v5 = 0;
    if (!a1) {
      return v5;
    }
  }
  char v6 = _mainBundle;
  if (_mainBundle) {
    char v6 = *(unsigned __int8 *)(_mainBundle + 53) - 5 < 0xFFFFFFFE;
  }
  *a1 = v6;
  return v5;
}

uint64_t _CFBundleSupportsFHSBundles()
{
  return 0;
}

uint64_t _CFBundleSupportsFreestandingBundles()
{
  return 0;
}

CFURLRef _CFURLCreateResolvedDirectoryWithString(const __CFAllocator *a1, const __CFString *a2, const __CFURL *a3)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  CFURLRef v4 = CFURLCreateWithString(a1, a2, a3);
  CFURLRef v5 = CFURLCopyAbsoluteURL(v4);
  CFRelease(v4);
  CFStringRef v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  CFRelease(v5);
  LODWORD(v5) = CFStringGetFileSystemRepresentation(v6, buffer, 1024);
  CFRelease(v6);
  if (!v5) {
    return 0;
  }
  int v7 = open(buffer, 0);
  if (v7 < 1) {
    return 0;
  }
  int v8 = v7;
  if (fcntl(v7, 50, v13) == -1)
  {
    if (_CFBundleResourceLogger_onceToken != -1) {
      dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
    }
    char v11 = _CFBundleResourceLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_ERROR)) {
      _CFURLCreateResolvedDirectoryWithString_cold_1(v11);
    }
    close(v8);
    return 0;
  }
  close(v8);
  CFStringRef v9 = CFStringCreateWithFileSystemRepresentation(a1, v13);
  CFURLRef v10 = CFURLCreateWithFileSystemPath(a1, v9, kCFURLPOSIXPathStyle, 1u);
  CFRelease(v9);
  return v10;
}

const void *_CFBundleCreateIfLooksLikeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  uint64_t v2 = _CFBundleCreate(a1, a2, 1, 0);
  CFStringRef v3 = v2;
  if (v2 && _CFBundleEffectiveLayoutVersion((uint64_t)v2) - 3 <= 1)
  {
    CFRelease(v3);
    return 0;
  }
  return v3;
}

uint64_t _CFBundleURLLooksLikeBundle(const __CFURL *a1)
{
  uint64_t result = (uint64_t)_CFBundleCreateIfLooksLikeBundle((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1;
  }
  return result;
}

CFBundleRef _CFBundleMainBundleInfoDictionaryComesFromResourceFork()
{
  CFBundleRef result = CFBundleGetMainBundle();
  if (result) {
    return (CFBundleRef)(*((unsigned char *)result + 65) != 0);
  }
  return result;
}

void _CFBundleFlushBundleCaches(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 24);
  CFStringRef v3 = *(const void **)(a1 + 32);
  *(void *)(a1 + 24) = 0;
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 32) = 0;
  }
  CFURLRef v5 = *(const void **)(a1 + 216);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 216) = 0;
  }
  CFStringRef v6 = *(const void **)(a1 + 104);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 104) = 0;
  }
  int v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
  }
  int v8 = *(const void **)(a1 + 144);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 144) = 0;
  }
  CFStringRef v9 = *(const void **)(a1 + 152);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 152) = 0;
  }
  CFURLRef v10 = *(const void **)(a1 + 160);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 16_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
  }
  if (*(unsigned char *)(a1 + 128))
  {
    *(unsigned char *)(a1 + 128) = 0;
    char v11 = *(const void **)(a1 + 120);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    }
  }
  _CFBundleRefreshInfoDictionaryAlreadyLocked(a1);
  if (v4)
  {
    if (!*(void *)(a1 + 24)) {
      *(void *)(a1 + 24) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    CFStringRef Value = CFDictionaryGetValue(v4, @"NSPrincipalClass");
    if (Value) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"NSPrincipalClass", Value);
    }
    CFRelease(v4);
  }
  _CFBundleFlushQueryTableCache(a1);

  os_unfair_lock_unlock(v2);
}

CFTypeID CFBundleGetTypeID(void)
{
  return 31;
}

CFBundleRef _CFBundleGetExistingBundleWithBundleURL(CFURLRef bundleURL)
{
  return CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bundleURL);
}

void *_CFBundleCreateUniqueWithOptions(const __CFAllocator *a1, const __CFURL *a2, const __CFSet *a3, char a4)
{
  if (a4) {
    int v5 = 2;
  }
  else {
    int v5 = 1;
  }
  return _CFBundleCreate(a1, a2, v5, a3);
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
  int v5 = _CFCreateContentsOfDirectory((uint64_t)allocator, 0);
  if (v5)
  {
    CFArrayRef v6 = v5;
    CFIndex Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0; i != v8; ++i)
      {
        CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v6, i);
        CFBundleRef v11 = CFBundleCreate(allocator, ValueAtIndex);
        if (v11) {
          CFArrayAppendValue(Mutable, v11);
        }
      }
    }
    CFRelease(v6);
  }
  return Mutable;
}

UInt32 CFBundleGetVersionNumber(CFBundleRef bundle)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(bundle);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(InfoDictionary, @"CFBundleNumericVersion");
  if (Value)
  {
    CFNumberRef v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
      LODWORD(Value) = valuePtr;
    }
    else
    {
      LODWORD(Value) = 0;
    }
  }
  return Value;
}

uint64_t _CFBundleGetHasChanged()
{
  return 1;
}

uint64_t _CFBundleGetStringsFilesShared()
{
  return 0;
}

CFURLRef _CFBundleCopyAppStoreReceiptURLInDirectory(CFURLRef baseURL, unsigned int a2)
{
  if (baseURL && a2 <= 0xD && ((0x300Fu >> a2) & 1) != 0) {
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, off_1ECDABA78[(char)a2], baseURL);
  }
  else {
    return 0;
  }
}

CFURLRef _CFBundleCopyAppStoreReceiptURL(uint64_t a1)
{
  return _CFBundleCopyAppStoreReceiptURLInDirectory(*(CFURLRef *)(a1 + 16), *(unsigned __int8 *)(a1 + 53));
}

CFURLRef _CFBundleCopyWrappedBundleURL(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  if ((*(unsigned char *)(a1 + 53) & 0xFE) != 0xC) {
    return 0;
  }
  CFURLRef v3 = *(const __CFURL **)(a1 + 16);

  return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, @"WrappedBundle", v3);
}

CFURLRef _CFBundleCopyWrapperContainerURL(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  if ((*(unsigned char *)(a1 + 53) & 0xFE) != 0xC) {
    return 0;
  }
  CFURLRef v3 = *(const __CFURL **)(a1 + 16);

  return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Wrapper", v3);
}

CFURLRef CFBundleGetExecutableType(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFURLRef result = CFBundleCopyExecutableURL((CFBundleRef)a1);
  if (result)
  {
    CFURLRef v5 = result;
    if (!*(_DWORD *)(a1 + 48))
    {
      int v7 = _CFBundleGrokBinaryType(result, v4);
      *(_DWORD *)(a1 + 48) = v7;
      if (v7 != 1 && v7 != 6) {
        *(unsigned char *)(a1 + 64) = 1;
      }
    }
    CFRelease(v5);
    int v6 = *(_DWORD *)(a1 + 48) - 1;
    if (v6 > 7) {
      return 0;
    }
    else {
      return (const __CFURL *)dword_182D9E8B8[v6];
    }
  }
  else
  {
    *(_DWORD *)(a1 + 48) = 7;
  }
  return result;
}

CFErrorRef _CFBundleCreateErrorDebug(const __CFAllocator *a1, CFBundleRef bundle, CFIndex a3, void *a4)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  CFURLRef v7 = CFBundleCopyBundleURL(bundle);
  CFURLRef v8 = CFURLCopyAbsoluteURL(v7);
  CFURLRef v9 = CFBundleCopyExecutableURL(bundle);
  BundleWithCFStringRef Identifier = _CFBundleGetBundleWithIdentifier(@"com.apple.CoreFoundation", v4);
  CFStringRef v11 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle);
  if (v9) {
    CFStringRef v12 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  }
  else {
    CFStringRef v12 = 0;
  }
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  *(_OWORD *)userInfoKeys = 0u;
  *(_OWORD *)userInfoValues = 0u;
  long long v34 = 0u;
  CFIndex v31 = a3;
  if (!BundleWithIdentifier)
  {
    StringWithValidatedCFStringRef Format = 0;
    CFStringRef v16 = 0;
    goto LABEL_32;
  }
  CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(bundle, @"CFBundleName");
  if (ValueForInfoDictionaryKey)
  {
    unsigned int v14 = (__CFString *)CFRetain(ValueForInfoDictionaryKey);
  }
  else
  {
    CFURLRef v17 = CFBundleCopyBundleURL(bundle);
    if (!v17)
    {
      uint64_t v23 = @"<unknown>";
      goto LABEL_18;
    }
    CFURLRef v18 = v17;
    CFStringRef v19 = CFURLCopyFileSystemPath(v17, kCFURLPOSIXPathStyle);
    CFIndex Length = CFStringGetLength(v19);
    CFRelease(v18);
    if (Length >= 1026) {
      CFIndex v21 = 1026;
    }
    else {
      CFIndex v21 = Length;
    }
    v41.CFIndex location = 0;
    v41.CFIndex length = v21;
    CFStringGetCharacters(v19, v41, buffer);
    CFRelease(v19);
    if (Length < 1) {
      uint64_t PathComponent = 0;
    }
    else {
      uint64_t PathComponent = _CFStartOfLastPathComponent(buffer, v21);
    }
    unsigned int v14 = (__CFString *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[PathComponent], v21 - PathComponent);
  }
  uint64_t v23 = v14;
LABEL_18:
  switch(a3)
  {
    case 3584:
      CFStringRef v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3584", @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because its executable isn\\U2019t loadable.", @"Error");
      CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3584-C", @"The bundle\\U2019s executable isn\\U2019t loadable.", @"Error");
      CFStringRef v25 = @"BundleErr3584-R";
      goto LABEL_26;
    case 3585:
      CFStringRef v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3585", @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it doesn\\U2019t contain a version for the current architecture.", @"Error");
      CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3585-C", @"The bundle doesn\\U2019t contain a version for the current architecture.", @"Error");
      CFStringRef v25 = @"BundleErr3585-R";
      CFStringRef v26 = @"Try installing a universal version of the bundle.";
      goto LABEL_27;
    case 3586:
      CFStringRef v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3586", @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it isn\\U2019t compatible with the current application.", @"Error");
      CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3586-C", @"The bundle isn\\U2019t compatible with this application.", @"Error");
      CFStringRef v25 = @"BundleErr3586-R";
      CFStringRef v26 = @"Try installing a newer version of the bundle.";
      goto LABEL_27;
    case 3587:
      CFStringRef v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3587", @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it is damaged or missing necessary resources.", @"Error");
      CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3587-C", @"The bundle is damaged or missing necessary resources.", @"Error");
      CFStringRef v25 = @"BundleErr3587-R";
      goto LABEL_26;
    case 3588:
      CFStringRef v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3588", @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded.", @"Error");
      CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr3588-C", @"The bundle couldn\\U2019t be loaded.", @"Error");
      CFStringRef v25 = @"BundleErr3588-R";
      goto LABEL_26;
    default:
      if (a3 == 4)
      {
        CFStringRef v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr4", @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because its executable couldn\\U2019t be located.", @"Error");
        CFStringRef v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"BundleErr4-C", @"The bundle\\U2019s executable couldn\\U2019t be located.", @"Error");
        CFStringRef v25 = @"BundleErr4-R";
LABEL_26:
        CFStringRef v26 = @"Try reinstalling the bundle.";
LABEL_27:
        BundleWithCFStringRef Identifier = (__CFBundle *)CFBundleCopyLocalizedString(BundleWithIdentifier, v25, v26, @"Error");
        if (v24)
        {
          StringWithValidatedCFStringRef Format = CFStringCreateStringWithValidatedFormat(a1, 0, @"%@", v24, 0, v23);
          CFRelease(v24);
          goto LABEL_31;
        }
      }
      else
      {
        BundleWithCFStringRef Identifier = 0;
        CFStringRef v16 = 0;
      }
      StringWithValidatedCFStringRef Format = 0;
LABEL_31:
      CFRelease(v23);
      break;
  }
LABEL_32:
  if (v11)
  {
    userInfoKeys[0] = @"NSBundlePath";
    userInfoValues[0] = (void *)v11;
    CFIndex v27 = 1;
    if (!v12) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  CFIndex v27 = 0;
  if (v12)
  {
LABEL_34:
    *(void *)((unint64_t)userInfoKeys | (8 * v27)) = @"NSFilePath";
    *(void *)((unint64_t)userInfoValues & 0xFFFFFFFFFFFFFFF7 | (8 * (v27++ & 1))) = v12;
  }
LABEL_35:
  if (StringWithValidatedFormat)
  {
    userInfoKeys[v27] = @"NSLocalizedDescription";
    userInfoValues[v27++] = (void *)StringWithValidatedFormat;
  }
  if (v16)
  {
    userInfoKeys[v27] = @"NSLocalizedFailureReason";
    userInfoValues[v27++] = (void *)v16;
  }
  if (BundleWithIdentifier)
  {
    userInfoKeys[v27] = @"NSLocalizedRecoverySuggestion";
    userInfoValues[v27++] = BundleWithIdentifier;
  }
  if (a4)
  {
    userInfoKeys[v27] = @"NSDebugDescription";
    userInfoValues[v27++] = a4;
  }
  CFErrorRef v28 = CFErrorCreateWithUserInfoKeysAndValues(a1, @"NSCocoaErrorDomain", v31, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, v27);
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (StringWithValidatedFormat) {
    CFRelease(StringWithValidatedFormat);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (BundleWithIdentifier) {
    CFRelease(BundleWithIdentifier);
  }
  return v28;
}

CFErrorRef _CFBundleCreateError(const __CFAllocator *a1, __CFBundle *a2, CFIndex a3)
{
  return _CFBundleCreateErrorDebug(a1, a2, a3, 0);
}

CFArrayRef CFBundleCopyExecutableArchitectures(CFBundleRef bundle)
{
  CFArrayRef result = CFBundleCopyExecutableURL(bundle);
  if (result)
  {
    CFArrayRef v3 = result;
    CFArrayRef v4 = _CFBundleCopyArchitecturesForExecutable(result, v2);
    CFRelease(v3);
    return v4;
  }
  return result;
}

uint64_t __CFBundleGetResourceData(uint64_t a1)
{
  return a1 + 64;
}

__CFBundle *_CFBundleGetBundleWithIdentifierAndLibraryName(void *a1, const __CFString *a2)
{
  if (a2) {
    _CFBundleEnsureBundlesUpToDateWithHint(a2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  CFArrayRef v3 = _CFBundleGetFromTablesLocked(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v3;
}

CFArrayRef CFBundleGetAllBundles(void)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  if (CFBundleGetAllBundles__lastBundleList)
  {
    if (!CFEqual((CFTypeRef)CFBundleGetAllBundles__lastBundleList, (CFTypeRef)_allBundles))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      CFDictionaryRef v0 = _CFBundleCopyAllBundles();
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      CFBundleGetAllBundles__lastBundleList = (uint64_t)v0;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    uint64_t v1 = _CFBundleCopyAllBundles();
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (CFBundleGetAllBundles__lastBundleList) {
      CFRelease(v1);
    }
    else {
      CFBundleGetAllBundles__lastBundleList = (uint64_t)v1;
    }
  }
  CFArrayRef v2 = (const __CFArray *)CFBundleGetAllBundles__lastBundleList;
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v2;
}

__CFArray *_CFBundleCopyAllBundles()
{
  _CFBundleEnsureAllBundlesUpToDate();
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  CFIndex Count = CFArrayGetCount((CFArrayRef)_allBundles);
  MutableCFSetRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count + 1, (CFArrayRef)_allBundles);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  CFArrayInsertValueAtIndex(MutableCopy, 0, MainBundle);
  return MutableCopy;
}

void _CFBundleEnsureAllBundlesUpToDate()
{
  CFBundleGetMainBundle();
  CFDictionaryRef v0 = _CFBundleDYLDCopyLoadedImagePathsIfChanged();
  if (v0)
  {
    uint64_t v1 = v0;
    _CFBundleEnsureBundlesExistForImagePaths(v0);
    CFRelease(v1);
  }
}

CFURLRef CFBundleCopyPrivateFrameworksURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 <= 0xB)
  {
    if (v3 == 1)
    {
      CFAllocatorRef v4 = CFGetAllocator(bundle);
      CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v6 = @"Support%20Files/Frameworks/";
      goto LABEL_15;
    }
    if (v3 == 2)
    {
      CFAllocatorRef v4 = CFGetAllocator(bundle);
      CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v6 = @"Contents/Frameworks/";
LABEL_15:
      return CFURLCreateWithString(v4, v6, v5);
    }
LABEL_14:
    CFAllocatorRef v4 = CFGetAllocator(bundle);
    CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v6 = @"Frameworks/";
    goto LABEL_15;
  }
  if (v3 == 12)
  {
    CFAllocatorRef v7 = CFGetAllocator(bundle);
    CFURLRef v8 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v9 = @"WrappedBundle/Contents/Frameworks/";
  }
  else
  {
    if (v3 != 13) {
      goto LABEL_14;
    }
    CFAllocatorRef v7 = CFGetAllocator(bundle);
    CFURLRef v8 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v9 = @"WrappedBundle/Frameworks/";
  }

  return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
}

CFURLRef CFBundleCopySharedFrameworksURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 <= 0xB)
  {
    if (v3 == 1)
    {
      CFAllocatorRef v4 = CFGetAllocator(bundle);
      CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v6 = @"Support%20Files/SharedFrameworks/";
      goto LABEL_15;
    }
    if (v3 == 2)
    {
      CFAllocatorRef v4 = CFGetAllocator(bundle);
      CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v6 = @"Contents/SharedFrameworks/";
LABEL_15:
      return CFURLCreateWithString(v4, v6, v5);
    }
LABEL_14:
    CFAllocatorRef v4 = CFGetAllocator(bundle);
    CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v6 = @"SharedFrameworks/";
    goto LABEL_15;
  }
  if (v3 == 12)
  {
    CFAllocatorRef v7 = CFGetAllocator(bundle);
    CFURLRef v8 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v9 = @"WrappedBundle/Contents/SharedFrameworks/";
  }
  else
  {
    if (v3 != 13) {
      goto LABEL_14;
    }
    CFAllocatorRef v7 = CFGetAllocator(bundle);
    CFURLRef v8 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v9 = @"WrappedBundle/SharedFrameworks/";
  }

  return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
}

CFURLRef CFBundleCopySharedSupportURL(CFBundleRef bundle)
{
  __CFCheckCFInfoPACSignature((uint64_t)bundle);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 <= 0xB)
  {
    if (v3 == 1)
    {
      CFAllocatorRef v4 = CFGetAllocator(bundle);
      CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v6 = @"Support%20Files/SharedSupport/";
      goto LABEL_15;
    }
    if (v3 == 2)
    {
      CFAllocatorRef v4 = CFGetAllocator(bundle);
      CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
      CFStringRef v6 = @"Contents/SharedSupport/";
LABEL_15:
      return CFURLCreateWithString(v4, v6, v5);
    }
LABEL_14:
    CFAllocatorRef v4 = CFGetAllocator(bundle);
    CFURLRef v5 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v6 = @"SharedSupport/";
    goto LABEL_15;
  }
  if (v3 == 12)
  {
    CFAllocatorRef v7 = CFGetAllocator(bundle);
    CFURLRef v8 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v9 = @"WrappedBundle/Contents/SharedSupport/";
  }
  else
  {
    if (v3 != 13) {
      goto LABEL_14;
    }
    CFAllocatorRef v7 = CFGetAllocator(bundle);
    CFURLRef v8 = (const __CFURL *)*((void *)bundle + 2);
    CFStringRef v9 = @"WrappedBundle/SharedSupport/";
  }

  return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void _CFBundleFlushQueryTableCache(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 176);
  os_unfair_lock_lock_with_options();
  unsigned int v3 = *(__CFDictionary **)(a1 + 184);
  if (v3) {
    CFDictionaryRemoveAllValues(v3);
  }

  os_unfair_lock_unlock(v2);
}

CFMutableArrayRef _CFBundleCopyResourceURLForLanguage(CFMutableArrayRef result, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  if (result) {
    return _CFBundleCopyFindResources((uint64_t)result, 0, (uint64_t)a3, a2, a3, a4, a5, 0, 1, 0);
  }
  return result;
}

uint64_t _CFBundleGetSupportedPlatforms()
{
  return 0;
}

__CFString *_CFBundleGetCurrentPlatform()
{
  return @"iPhoneOS";
}

CFArrayRef CFBundleCopyExecutableArchitecturesForURL(CFURLRef url)
{
  unint64_t v2 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, url);
  if (v2)
  {
    CFAllocatorRef v4 = v2;
    CFArrayRef v5 = CFBundleCopyExecutableArchitectures(v2);
    CFRelease(v4);
    return v5;
  }
  else
  {
    return _CFBundleCopyArchitecturesForExecutable(url, v3);
  }
}

CFBundleRef _CFBundleAddResourceURL(uint64_t a1, const __CFURL *a2)
{
  CFBundleRef result = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
  if (result)
  {
    CFArrayRef v5 = result;
    if (result == (CFBundleRef)a1)
    {
      __break(1u);
    }
    else
    {
      os_unfair_lock_lock_with_options();
      CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a1 + 208);
      if (!Mutable)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)(a1 + 208) = Mutable;
      }
      CFDictionarySetValue(Mutable, a2, v5);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 200));
      CFRelease(v5);
      _CFBundleFlushStringSourceCache(a1);
      return (CFBundleRef)1;
    }
  }
  return result;
}

uint64_t _CFBundleRemoveResourceURL(uint64_t a1, const void *a2)
{
  CFAllocatorRef v4 = (os_unfair_lock_s *)(a1 + 200);
  os_unfair_lock_lock_with_options();
  CFArrayRef v5 = *(__CFDictionary **)(a1 + 208);
  if (v5)
  {
    CFDictionaryRemoveValue(v5, a2);
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v6 = 0;
  }
  os_unfair_lock_unlock(v4);
  _CFBundleFlushStringSourceCache(a1);
  return v6;
}

void _CFBundleFindResourcesWithPredicate(__CFArray *a1, CFDictionaryRef theDict, uint64_t a3, unsigned char *a4)
{
  CFIndex Count = CFDictionaryGetCount(theDict);
  if (!Count) {
    return;
  }
  uint64_t v9 = Count;
  size_t v10 = 8 * Count;
  CFStringRef v11 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  CFStringRef v12 = (const void **)malloc_type_malloc(v10, 0xC0040B8AA526DuLL);
  int v13 = v12;
  if (v11 && v12)
  {
    CFIndex v21 = v12;
    CFDictionaryGetKeysAndValues(theDict, v11, v12);
    uint64_t v14 = v9 - 1;
    if (v9 >= 1)
    {
      uint64_t v15 = v11;
      do
      {
        if ((*(unsigned int (**)(uint64_t, const void *, unsigned char *))(a3 + 16))(a3, *v15, a4))
        {
          CFTypeID v16 = CFGetTypeID(*v13);
          CFTypeID TypeID = CFStringGetTypeID();
          CFArrayRef v18 = (const __CFArray *)*v13;
          if (v16 == TypeID)
          {
            CFArrayAppendValue(a1, *v13);
          }
          else
          {
            v23.CFIndex length = CFArrayGetCount((CFArrayRef)*v13);
            v23.CFIndex location = 0;
            CFArrayAppendArray(a1, v18, v23);
          }
        }
        if (*a4) {
          BOOL v19 = 1;
        }
        else {
          BOOL v19 = v14 == 0;
        }
        --v14;
        ++v13;
        ++v15;
      }
      while (!v19);
    }
    free(v11);
    long long v20 = v21;
    goto LABEL_20;
  }
  if (v11) {
    free(v11);
  }
  if (v13)
  {
    long long v20 = v13;
LABEL_20:
    free(v20);
  }
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t __CFCharacterSetIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

BOOL _CFCharacterSetIsValidRange(unint64_t a1, uint64_t a2)
{
  return a1 >> 16 <= 0x10 && a2 < 1114113 && a1 + a2 < 0x110001;
}

uint64_t __CFCharacterSetEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v149 = *(void *)off_1ECE0A5B0;
  char v6 = atomic_load((unint64_t *)(v2 + 8));
  char v7 = atomic_load((unint64_t *)(v3 + 8));
  char v8 = atomic_load((unint64_t *)(v2 + 8));
  if ((v8 & 4) != 0)
  {
    char v9 = atomic_load((unint64_t *)(v3 + 8));
    if ((v9 & 4) != 0 && *(void *)(v2 + 16) != *(void *)(v3 + 16)) {
      return 0;
    }
  }
  char v10 = v7 ^ v6;
  uint64_t v11 = *(void *)(v2 + 40);
  if (!v11 || !*(_DWORD *)(v11 + 8) && !*(unsigned char *)(v11 + 13))
  {
    unsigned int v12 = atomic_load((unint64_t *)(v2 + 8));
    switch((v12 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(void *)(v2 + 32)) {
          goto LABEL_19;
        }
        break;
      case 3u:
      case 4u:
        if (*(void *)(v2 + 24)) {
          goto LABEL_19;
        }
        break;
      default:
        goto LABEL_19;
    }
    uint64_t v13 = *(void *)(v3 + 40);
    if (!v13 || !*(_DWORD *)(v13 + 8) && !*(unsigned char *)(v13 + 13))
    {
      unsigned int v14 = atomic_load((unint64_t *)(v3 + 8));
      switch((v14 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v3 + 32)) {
            goto LABEL_19;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(v3 + 24)) {
            goto LABEL_19;
          }
          break;
        default:
          goto LABEL_19;
      }
      if ((v10 & 8) != 0) {
        return 0;
      }
    }
  }
LABEL_19:
  unsigned __int8 v15 = atomic_load((unint64_t *)(v2 + 8));
  unsigned __int8 v16 = atomic_load((unint64_t *)(v3 + 8));
  if (((v16 ^ v15) & 0x70) == 0)
  {
    char v17 = atomic_load((unint64_t *)(v2 + 8));
    if ((v17 & 0x70) != 0x40)
    {
      unsigned int v20 = atomic_load((unint64_t *)(v2 + 8));
      switch((v20 >> 4) & 7)
      {
        case 0u:
          return (v10 & 8) == 0 && *(void *)(v2 + 24) == *(void *)(v3 + 24);
        case 1u:
          if (*(_DWORD *)(v2 + 24) != *(_DWORD *)(v3 + 24) || !*(void *)(v2 + 32)) {
            return 0;
          }
          return (v10 & 8) == 0 && *(void *)(v3 + 32) != 0;
        case 2u:
          if ((v10 & 8) != 0) {
            return 0;
          }
          uint64_t v113 = *(void *)(v2 + 32);
          if (*(void *)(v3 + 32) != v113 || memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), 2 * v113)) {
            return 0;
          }
          goto LABEL_218;
        case 3u:
          uint64_t result = __CFCSetIsEqualBitmap(*(void *)(v2 + 24), *(void *)(v3 + 24));
          if (result) {
            goto LABEL_218;
          }
          return result;
        default:
LABEL_218:
          uint64_t result = __CFCSetIsEqualAnnex(v5, v4);
          break;
      }
      return result;
    }
  }
  uint64_t v18 = *(void *)(v2 + 40);
  if (v18 && (*(_DWORD *)(v18 + 8) || *(unsigned char *)(v18 + 13)))
  {
LABEL_32:
    uint64_t v22 = *(void *)(v3 + 40);
    if (!v22 || !*(_DWORD *)(v22 + 8) && !*(unsigned char *)(v22 + 13))
    {
      unsigned int v23 = atomic_load((unint64_t *)(v3 + 8));
      switch((v23 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v3 + 32)) {
            break;
          }
          goto LABEL_112;
        case 3u:
        case 4u:
          if (!*(void *)(v3 + 24)) {
            goto LABEL_112;
          }
          break;
        default:
          break;
      }
    }
    char v24 = atomic_load((unint64_t *)(v2 + 8));
    if ((v24 & 0x70) != 0)
    {
      char v25 = atomic_load((unint64_t *)(v3 + 8));
      if ((v25 & 0x70) != 0)
      {
        char v26 = atomic_load((unint64_t *)(v2 + 8));
        if ((v26 & 0x70) == 0x10 || (char v27 = atomic_load((unint64_t *)(v3 + 8)), (v27 & 0x70) == 0x10))
        {
          char v28 = atomic_load((unint64_t *)(v2 + 8));
          if ((v28 & 0x70) == 0x10) {
            uint64_t v29 = v2;
          }
          else {
            uint64_t v29 = v3;
          }
          if (v29 == v2) {
            uint64_t v5 = v3;
          }
          int v30 = *(_DWORD *)(v29 + 24);
          int v31 = v30 + *(_DWORD *)(v29 + 32);
          unsigned int v32 = atomic_load((unint64_t *)(v29 + 8));
          char v33 = atomic_load((unint64_t *)(v5 + 8));
          if ((v33 & 0x70) == 0x30)
          {
            long long v34 = *(int8x16_t **)(v5 + 24);
          }
          else
          {
            long long v34 = v148;
            __CFCSetGetBitmap(v5, v148);
          }
          int v72 = (v32 >> 3) & 1;
          int v73 = v31 - 1;
          if ((v30 & 0xFF0000) != 0)
          {
            if (v72) {
              uint64_t v74 = -1;
            }
            else {
              uint64_t v74 = 0;
            }
            uint64_t result = __CFCSetIsEqualBitmap((uint64_t)v34, v74);
            if (!result) {
              return result;
            }
            unsigned int v75 = (unsigned __int16)v30;
            unint64_t v76 = BYTE2(v30);
          }
          else
          {
            if ((v73 & 0xFF0000) != 0) {
              unsigned __int16 v77 = -1;
            }
            else {
              unsigned __int16 v77 = v31 - 1;
            }
            uint64_t result = __CFCSetIsBitmapEqualToRange((uint64_t)v34, (unsigned __int16)v30, v77, v72);
            if (!result) {
              return result;
            }
            unsigned int v75 = 0;
            unint64_t v76 = 1;
          }
          int v78 = (unsigned __int16)(v31 - 1);
          uint64_t v79 = *(void *)(v5 + 40);
          if (v79) {
            LODWORD(v79) = *(unsigned __int8 *)(v79 + 13) != 0;
          }
          uint64_t v80 = 0;
          uint64_t v81 = ((v32 & 8) == 0) ^ v79;
          uint64_t v142 = v81 ^ 1;
          unsigned int v141 = v75;
          if (v75) {
            char v82 = 1;
          }
          else {
            char v82 = ((v32 & 8) == 0) ^ v79;
          }
          if (v76 == BYTE2(v73)) {
            unsigned __int16 v83 = v31 - 1;
          }
          else {
            unsigned __int16 v83 = -1;
          }
          BOOL v84 = v78 == 0xFFFF;
          if (v78 == 0xFFFF) {
            char v85 = ((v32 & 8) == 0) ^ v79;
          }
          else {
            char v85 = 1;
          }
          char v146 = v85;
          BOOL v86 = !v84 && v76 == BYTE2(v73);
          char v144 = v82 | v86;
          unint64_t v87 = v76 - 1;
          uint64_t v88 = BYTE2(v73) - 1;
          unsigned int v140 = v83;
          while (1)
          {
            unint64_t v89 = v80 + 1;
            uint64_t v90 = *(void *)(v5 + 40);
            if (v90
              && ((*(_DWORD *)(v90 + 8) >> v89) & 1) != 0
              && *(unsigned __int8 *)(v90 + 12) >= v89
              && (uint64_t v91 = *(void *)(*(void *)v90 + 8 * v80)) != 0)
            {
              char v92 = atomic_load((unint64_t *)(v91 + 8));
              if ((v92 & 0x70) == 0x30)
              {
                long long v93 = *(int8x16_t **)(v91 + 24);
              }
              else
              {
                long long v93 = v148;
                __CFCSetGetBitmap(v91, v148);
              }
              if (v89 < v76 || v89 > BYTE2(v73))
              {
                uint64_t v95 = (uint64_t)v93;
                uint64_t v96 = v142 << 63 >> 63;
LABEL_176:
                uint64_t result = __CFCSetIsEqualBitmap(v95, v96);
                if (!result) {
                  return result;
                }
                goto LABEL_160;
              }
              if (v89 > v76 && v89 < BYTE2(v73))
              {
                uint64_t v95 = (uint64_t)v93;
                uint64_t v96 = v81 << 63 >> 63;
                goto LABEL_176;
              }
              if (v87 == v80)
              {
                uint64_t v97 = (uint64_t)v93;
                unsigned int v99 = v140;
                unsigned int v98 = v141;
              }
              else
              {
                if (v88 != v80) {
                  goto LABEL_160;
                }
                unsigned int v99 = (unsigned __int16)v73;
                uint64_t v97 = (uint64_t)v93;
                unsigned int v98 = 0;
              }
              uint64_t result = __CFCSetIsBitmapEqualToRange(v97, v98, v99, v142);
              if (!result) {
                return result;
              }
            }
            else if (v89 < v76 || v89 > BYTE2(v73))
            {
              if ((v81 & 1) == 0) {
                return 0;
              }
            }
            else if (v89 <= v76 || v89 >= BYTE2(v73))
            {
              if (v87 == v80)
              {
                if (v144) {
                  return 0;
                }
              }
              else
              {
                char v94 = v146;
                if (v88 != v80) {
                  char v94 = 0;
                }
                if (v94) {
                  return 0;
                }
              }
            }
            else if (v81)
            {
              return 0;
            }
LABEL_160:
            if (++v80 == 15) {
              return 1;
            }
          }
        }
        char v100 = atomic_load((unint64_t *)(v2 + 8));
        uint64_t v101 = v100 & 0x70;
        char v102 = atomic_load((unint64_t *)(v3 + 8));
        uint64_t v103 = v102 & 0x70;
        if (v101 == 48 && v103 == 48)
        {
          CFRange v104 = *(int8x16_t **)(v2 + 24);
          CFRange v105 = *(int8x16_t **)(v3 + 24);
        }
        else
        {
          if (v101 == 48 || v103 == 48)
          {
            if (v103 == 48) {
              uint64_t v139 = v2;
            }
            else {
              uint64_t v139 = v3;
            }
            if (v103 == 48) {
              uint64_t v5 = v3;
            }
            __CFCSetGetBitmap(v139, v148);
            uint64_t result = __CFCSetIsEqualBitmap(*(void *)(v5 + 24), (uint64_t)v148);
            if (!result) {
              return result;
            }
            uint64_t v4 = v139;
            return __CFCSetIsEqualAnnex(v5, v4);
          }
          __CFCSetGetBitmap(v2, v148);
          __CFCSetGetBitmap(v4, __b);
          CFRange v104 = v148;
          CFRange v105 = __b;
        }
        uint64_t result = __CFCSetIsEqualBitmap((uint64_t)v104, (uint64_t)v105);
        if (!result) {
          return result;
        }
        return __CFCSetIsEqualAnnex(v5, v4);
      }
    }
    char v35 = atomic_load((unint64_t *)(v2 + 8));
    if ((v35 & 0x70) != 0) {
      uint64_t v36 = v3;
    }
    else {
      uint64_t v36 = v2;
    }
    if (v36 == v2) {
      uint64_t v5 = v3;
    }
    char v37 = atomic_load((unint64_t *)(v5 + 8));
    if ((v37 & 0x70) == 0x10)
    {
      unint64_t v38 = 0;
      int v39 = *(_DWORD *)(v5 + 24);
      int v40 = v39 + *(_DWORD *)(v5 + 32);
      int v41 = -v40;
      int v42 = v40 - 1;
      if (BYTE2(v39) != BYTE2(v42)) {
        unsigned __int16 v43 = 0;
      }
      else {
        unsigned __int16 v43 = v39;
      }
      if (BYTE2(*(_DWORD *)(v5 + 24)) != BYTE2(v42)) {
        unsigned __int16 v44 = -1;
      }
      else {
        unsigned __int16 v44 = v42;
      }
      if ((_WORD)v39) {
        BOOL v45 = BYTE2(*(_DWORD *)(v5 + 24)) == BYTE2(v42);
      }
      else {
        BOOL v45 = 0;
      }
      BOOL v46 = (unsigned __int16)v41 == 0;
      if ((_WORD)v41) {
        BOOL v47 = BYTE2(*(_DWORD *)(v5 + 24)) == BYTE2(v42);
      }
      else {
        BOOL v47 = 0;
      }
      char v48 = !v46 || v45;
      unint64_t v49 = BYTE2(v42);
      if ((_WORD)v39) {
        BOOL v47 = 1;
      }
      BOOL v143 = v47;
      char v145 = v48;
      unsigned int v50 = v44;
      unsigned int v51 = v43;
      unsigned int v52 = (unsigned __int16)v42;
      while (1)
      {
        int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v36 + 24), v38, v148, (v10 & 8) == 0);
        if (v38 < BYTE2(v39) || v38 > v49)
        {
          if (BitmapForPlane)
          {
            if (BitmapForPlane == 1) {
              return 0;
            }
          }
          else
          {
            if (v148 == (int8x16_t *)-1) {
              return 0;
            }
            for (uint64_t i = 0; i != 2048; ++i)
            {
              if (v148[0].i32[i]) {
                return 0;
              }
            }
          }
        }
        else if (v38 <= BYTE2(v39) || v38 >= v49)
        {
          if (BitmapForPlane == 1)
          {
            if (v38 == BYTE2(v39))
            {
              if (v143) {
                return 0;
              }
            }
            else if (v145)
            {
              return 0;
            }
          }
          else
          {
            if (BitmapForPlane == 255) {
              return 0;
            }
            if (v38 == BYTE2(v39))
            {
              unsigned int v54 = (unsigned __int16)v39;
              unsigned int v55 = v50;
            }
            else
            {
              unsigned int v54 = v51;
              unsigned int v55 = v52;
            }
            uint64_t result = __CFCSetIsBitmapEqualToRange((uint64_t)v148, v54, v55, 0);
            if (!result) {
              return result;
            }
          }
        }
        else if (BitmapForPlane)
        {
          if (BitmapForPlane == 255) {
            return 0;
          }
        }
        else if (v148 != (int8x16_t *)-1)
        {
          for (uint64_t j = 0; j != 2048; ++j)
          {
            uint64_t result = 0;
            __int32 v60 = v148[0].i32[j];
            if (v60 != -1) {
              return result;
            }
          }
        }
        ++v38;
        uint64_t result = 1;
        if (v38 == 16) {
          return result;
        }
      }
    }
    unsigned int v61 = *(_DWORD *)(v36 + 24);
    unint64_t v62 = atomic_load((unint64_t *)(v36 + 8));
    int v63 = CFUniCharGetBitmapForPlane(v61, 0, v148, (v62 >> 3) & 1);
    char v64 = atomic_load((unint64_t *)(v5 + 8));
    uint64_t v65 = v64 & 0x70;
    if (v63)
    {
      int v66 = v63;
      if (v65 == 48)
      {
        if (v63 == 1) {
          uint64_t v67 = -1;
        }
        else {
          uint64_t v67 = 0;
        }
        long long v68 = *(int8x16_t **)(v5 + 24);
      }
      else
      {
        __CFCSetGetBitmap(v5, v148);
        if (v66 == 1) {
          uint64_t v67 = -1;
        }
        else {
          uint64_t v67 = 0;
        }
        long long v68 = v148;
      }
    }
    else if (v65 == 48)
    {
      long long v68 = *(int8x16_t **)(v5 + 24);
      uint64_t v67 = (uint64_t)v148;
    }
    else
    {
      __CFCSetGetBitmap(v5, __b);
      uint64_t v67 = (uint64_t)v148;
      long long v68 = __b;
    }
    uint64_t result = __CFCSetIsEqualBitmap(v67, (uint64_t)v68);
    if (!result) {
      return result;
    }
    unint64_t v114 = atomic_load((unint64_t *)(v36 + 8));
    uint64_t v115 = *(void *)(v5 + 40);
    if (v115) {
      LODWORD(v115) = *(unsigned __int8 *)(v115 + 13) != 0;
    }
    uint64_t v116 = 0;
    int v117 = (v114 >> 3) & 1 ^ v115;
    while (1)
    {
      unsigned __int8 v118 = v116 + 1;
      int v119 = CFUniCharGetBitmapForPlane(*(_DWORD *)(v36 + 24), (int)v116 + 1, v148, v117);
      uint64_t v120 = *(void *)(v5 + 40);
      if (v120 && ((*(_DWORD *)(v120 + 8) >> v118) & 1) != 0 && *(unsigned __int8 *)(v120 + 12) >= v118)
      {
        uint64_t result = *(void *)(*(void *)v120 + 8 * v116);
        if (!v119)
        {
LABEL_239:
          if (!result) {
            return result;
          }
          char v125 = atomic_load((unint64_t *)(result + 8));
          if ((v125 & 0x70) == 0x30)
          {
            CFAllocatorRef v123 = *(int8x16_t **)(result + 24);
            uint64_t v124 = (uint64_t)v148;
          }
          else
          {
            __CFCSetGetBitmap(result, __b);
            uint64_t v124 = (uint64_t)v148;
            CFAllocatorRef v123 = __b;
          }
LABEL_247:
          uint64_t result = __CFCSetIsEqualBitmap(v124, (uint64_t)v123);
          if (!result) {
            return result;
          }
          goto LABEL_248;
        }
      }
      else
      {
        uint64_t result = 0;
        if (!v119) {
          goto LABEL_239;
        }
      }
      if (result)
      {
        char v121 = atomic_load((unint64_t *)(result + 8));
        if ((v121 & 0x70) == 0x30)
        {
          if (v119 == 1) {
            uint64_t v122 = -1;
          }
          else {
            uint64_t v122 = 0;
          }
          CFAllocatorRef v123 = *(int8x16_t **)(result + 24);
          uint64_t v124 = v122;
        }
        else
        {
          __CFCSetGetBitmap(result, v148);
          if (v119 == 1) {
            uint64_t v124 = -1;
          }
          else {
            uint64_t v124 = 0;
          }
          CFAllocatorRef v123 = v148;
        }
        goto LABEL_247;
      }
      if (v119 == 1) {
        return 0;
      }
LABEL_248:
      if (++v116 == 15) {
        return 1;
      }
    }
  }
  unsigned int v19 = atomic_load((unint64_t *)(v2 + 8));
  switch((v19 >> 4) & 7)
  {
    case 1u:
    case 2u:
      if (*(void *)(v2 + 32)) {
        goto LABEL_32;
      }
      break;
    case 3u:
    case 4u:
      if (*(void *)(v2 + 24)) {
        goto LABEL_32;
      }
      break;
    default:
      goto LABEL_32;
  }
LABEL_112:
  uint64_t v69 = *(void *)(v2 + 40);
  if (v69 && (*(_DWORD *)(v69 + 8) || *(unsigned char *)(v69 + 13)))
  {
LABEL_192:
    int v71 = 0;
  }
  else
  {
    unsigned int v70 = atomic_load((unint64_t *)(v2 + 8));
    switch((v70 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(void *)(v2 + 32)) {
          goto LABEL_192;
        }
        break;
      case 3u:
      case 4u:
        if (*(void *)(v2 + 24)) {
          goto LABEL_192;
        }
        break;
      default:
        goto LABEL_192;
    }
    int v71 = 1;
  }
  if (v3 == v2) {
    int v71 = 1;
  }
  if (v71) {
    uint64_t v5 = v3;
  }
  char v106 = atomic_load((unint64_t *)(v5 + 8));
  if ((v106 & 0x70) == 0) {
    return 0;
  }
  char v107 = atomic_load((unint64_t *)(v5 + 8));
  if ((v107 & 0x70) == 0x10)
  {
    uint64_t v108 = *(void *)(v5 + 32);
    if ((v10 & 8) != 0) {
      return v108 == 1114112;
    }
    else {
      return v108 == 0;
    }
  }
  uint64_t v109 = *(void *)(v5 + 40);
  if (v109)
  {
    int v110 = *(unsigned __int8 *)(v109 + 13);
    int v111 = *(_DWORD *)(v109 + 8);
    if (v110)
    {
      if (v111 != 131070) {
        return 0;
      }
    }
    else if (v111)
    {
      return 0;
    }
  }
  char v126 = atomic_load((unint64_t *)(v5 + 8));
  if ((v126 & 0x70) == 0x30)
  {
    unint64_t v127 = *(int8x16_t **)(v5 + 24);
    if (!v127) {
      goto LABEL_262;
    }
  }
  else
  {
    unint64_t v127 = v148;
    __CFCSetGetBitmap(v5, v148);
  }
  if (v127 == (int8x16_t *)-1) {
    return 0;
  }
  for (uint64_t k = 0; k != 2048; ++k)
  {
    if (v127->i32[k]) {
      return 0;
    }
  }
LABEL_262:
  uint64_t v128 = *(void *)(v5 + 40);
  if (v128 && *(unsigned char *)(v128 + 13))
  {
    uint64_t v129 = 1;
    while (1)
    {
      char v130 = atomic_load((unint64_t *)(v5 + 8));
      if ((v130 & 0x70) == 0x30)
      {
        uint64_t v131 = *(void *)(v5 + 40);
        if (v131)
        {
          if (*(unsigned char *)(v131 + 13)) {
            uint64_t v132 = 0;
          }
          else {
            uint64_t v132 = -1;
          }
        }
        else
        {
          uint64_t v132 = -1;
        }
        uint64_t result = __CFCSetIsEqualBitmap(v132, (uint64_t)v148);
        if (!result) {
          return result;
        }
      }
      else
      {
        if (!(_BYTE)v129)
        {
          __break(1u);
          JUMPOUT(0x182CB2E04);
        }
        uint64_t v133 = *(void *)(v5 + 40);
        if (v133
          && ((*(_DWORD *)(v133 + 8) >> v129) & 1) != 0
          && *(unsigned __int8 *)(v133 + 12) >= v129)
        {
          uint64_t v134 = *(void *)(*(void *)v133 + 8 * (v129 - 1));
        }
        else
        {
          uint64_t v134 = 0;
        }
        __CFCSetGetBitmap(v134, v148);
        if (v148 != (int8x16_t *)-1)
        {
          for (uint64_t m = 0; m != 2048; ++m)
          {
            uint64_t result = 0;
            __int32 v136 = v148[0].i32[m];
            if (v136 != -1) {
              return result;
            }
          }
        }
      }
      ++v129;
      uint64_t result = 1;
      if (v129 == 16) {
        return result;
      }
    }
  }
  return 1;
}

unint64_t __CFCharacterSetHash(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (unint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v3 = v2;
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  char v4 = atomic_load(v2 + 1);
  if ((v4 & 4) == 0)
  {
    unint64_t v5 = v2[5];
    if (v5 && (*(_DWORD *)(v5 + 8) || *(unsigned char *)(v5 + 13)))
    {
LABEL_7:
      char v7 = atomic_load(v2 + 1);
      if ((v7 & 0x70) == 0x30)
      {
        char v8 = (int8x16_t *)v2[3];
      }
      else
      {
        __CFCSetGetBitmap((uint64_t)v2, __b);
        char v8 = __b;
      }
      CFMutableDictionaryRef v3[2] = CFHashBytes((uint64_t)v8, 0x2000);
    }
    else
    {
      unsigned int v6 = atomic_load(v2 + 1);
      switch((v6 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (v2[4]) {
            goto LABEL_7;
          }
          break;
        case 3u:
        case 4u:
          if (v2[3]) {
            goto LABEL_7;
          }
          break;
        default:
          goto LABEL_7;
      }
      int v13 = atomic_load(v2 + 1);
      size_t v2[2] = (v13 << 28 >> 31);
    }
    unint64_t v9 = atomic_load(v3 + 1);
    unint64_t v10 = v9;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v3 + 1, &v10, v9 | 4);
      BOOL v11 = v10 == v9;
      unint64_t v9 = v10;
    }
    while (!v11);
  }
  return v3[2];
}

CFStringRef __CFCharacterSetCopyDescription(unint64_t *cf)
{
  unint64_t v2 = cf[5];
  if (v2 && (*(_DWORD *)(v2 + 8) || *(unsigned char *)(v2 + 13)))
  {
LABEL_6:
    unsigned int v4 = atomic_load(cf + 1);
    switch((v4 >> 4) & 7)
    {
      case 0u:
        switch(cf[3])
        {
          case 1uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Control Set>";
            goto LABEL_8;
          case 2uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Whitespace Set>";
            goto LABEL_8;
          case 3uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined WhitespaceAndNewline Set>";
            goto LABEL_8;
          case 4uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined DecimalDigit Set>";
            goto LABEL_8;
          case 5uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Letter Set>";
            goto LABEL_8;
          case 6uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined LowercaseLetter Set>";
            goto LABEL_8;
          case 7uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined UppercaseLetter Set>";
            goto LABEL_8;
          case 8uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined NonBase Set>";
            goto LABEL_8;
          case 9uLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Decomposable Set>";
            goto LABEL_8;
          case 0xAuLL:
            unint64_t v5 = @"<CFCharacterSet Predefined AlphaNumeric Set>";
            goto LABEL_8;
          case 0xBuLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Punctuation Set>";
            goto LABEL_8;
          case 0xCuLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Illegal Set>";
            goto LABEL_8;
          case 0xDuLL:
            unint64_t v5 = @"<CFCharacterSet Predefined CapitalizedLetter Set>";
            goto LABEL_8;
          case 0xEuLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Symbol Set>";
            goto LABEL_8;
          case 0xFuLL:
            unint64_t v5 = @"<CFCharacterSet Predefined Newline Set>";
            goto LABEL_8;
          default:
            goto LABEL_16;
        }
      case 1u:
        CFAllocatorRef v9 = CFGetAllocator(cf);
        return CFStringCreateWithFormat(v9, 0, @"<CFCharacterSet Range(%u, %ld)>", *((unsigned int *)cf + 6), cf[4]);
      case 2u:
        uint64_t v10 = cf[4];
        CFAllocatorRef v11 = CFGetAllocator(cf);
        CFIndex Length = CFStringGetLength(@"<CFCharacterSet Items(");
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(v11, Length - v10 + 8 * v10 + 2);
        CFStringAppend(Mutable, @"<CFCharacterSet Items(");
        if (v10 >= 1)
        {
          for (uint64_t i = 0; i != v10; ++i)
          {
            if (i) {
              unsigned int v14 = " ";
            }
            else {
              unsigned int v14 = "";
            }
            CFStringAppendFormat(Mutable, 0, @"%sU+%04X", v14, *(unsigned __int16 *)(cf[3] + 2 * i));
          }
        }
        CFStringAppend(Mutable, @">"));
        goto LABEL_25;
      case 3u:
      case 4u:
        unint64_t v5 = @"<CFCharacterSet Bitmap>";
        goto LABEL_8;
      default:
LABEL_16:
        CFMutableDictionaryRef Mutable = 0;
LABEL_25:
        CFStringRef result = Mutable;
        break;
    }
  }
  else
  {
    unsigned int v3 = atomic_load(cf + 1);
    switch((v3 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (cf[4]) {
          goto LABEL_6;
        }
        break;
      case 3u:
      case 4u:
        if (cf[3]) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
    char v7 = atomic_load(cf + 1);
    if ((v7 & 8) != 0) {
      unint64_t v5 = @"<CFCharacterSet All>";
    }
    else {
      unint64_t v5 = @"<CFCharacterSet Empty>";
    }
LABEL_8:
    return (CFStringRef)CFRetain(v5);
  }
  return result;
}

unint64_t *_CFCharacterSetCreateCopy(const __CFAllocator *a1, unint64_t *a2)
{
  return __CFCharacterSetCreateCopy(a1, a2, 0, 0);
}

unint64_t *_CFCharacterSetCreateMutableCopy(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableDictionaryRef Mutable = (unint64_t *)CFCharacterSetCreateMutable(a1);
  _CFCharacterSetInitCopyingSet((char *)a1, Mutable, a2, 1);
  return Mutable;
}

uint64_t CFCharacterSetIsSurrogatePairMember(const __CFCharacterSet *a1, int a2, int a3)
{
  return CFCharacterSetIsLongCharacterMember(a1, a3 + (a2 << 10) - 56613888);
}

uint64_t __CFCSetIsEqualBitmap(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (a1 && a2)
    {
      if (a1 == -1)
      {
        for (uint64_t i = 0; i != 0x2000; i += 4)
        {
          int v9 = *(_DWORD *)(a2 + i);
          if (v9 != -1) {
            return 0;
          }
        }
      }
      else if (a2 == -1)
      {
        for (uint64_t j = 0; j != 0x2000; j += 4)
        {
          int v11 = *(_DWORD *)(a1 + j);
          if (v11 != -1) {
            return 0;
          }
        }
      }
      else
      {
        for (uint64_t k = 0; k != 0x2000; k += 4)
        {
          int v3 = *(_DWORD *)(a1 + k);
          int v4 = *(_DWORD *)(a2 + k);
          if (v3 != v4) {
            return 0;
          }
        }
      }
    }
    else if (a1 | a2)
    {
      if (a2) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = a1;
      }
      if (v5 == -1) {
        return 0;
      }
      for (uint64_t m = 0; m != 0x2000; m += 4)
      {
        if (*(_DWORD *)(v5 + m)) {
          return 0;
        }
      }
    }
  }
  return 1;
}

Boolean CFCharacterSetHasMemberInPlane(CFCharacterSetRef theSet, CFIndex thePlane)
{
  unint64_t v2 = MEMORY[0x1F4188790](theSet, thePlane);
  uint64_t v37 = *(void *)off_1ECE0A5B0;
  unint64_t v4 = atomic_load((unint64_t *)(v2 + 8));
  if (v3 > 0x10) {
    goto LABEL_2;
  }
  unint64_t v6 = v3;
  unint64_t v7 = v2;
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    LOBYTE(v5) = [(id)v7 hasMemberInPlane:v6];
    return v5;
  }
  uint64_t v5 = (v4 >> 3) & 1;
  uint64_t v8 = *(void *)(v7 + 40);
  if (v8 && (*(_DWORD *)(v8 + 8) || *(unsigned char *)(v8 + 13)))
  {
LABEL_13:
    unint64_t v10 = v4 & 8;
    char v11 = atomic_load((unint64_t *)(v7 + 8));
    if ((v11 & 0x70) != 0)
    {
      char v12 = atomic_load((unint64_t *)(v7 + 8));
      if ((v12 & 0x70) == 0x10)
      {
        unint64_t v13 = v10 >> 3;
        unint64_t v14 = *(unsigned int *)(v7 + 24);
        unint64_t v15 = v14 >> 16;
        unint64_t v16 = (v14 + *(_DWORD *)(v7 + 32) - 1) >> 16;
        if (!v13)
        {
          LOBYTE(v5) = v15 <= v6 && v16 >= v6;
          return v5;
        }
        LOBYTE(v5) = 1;
        if (v15 > v6 || v16 < v6) {
          return v5;
        }
        if (v15 >= v6 || v16 <= v6)
        {
          int v17 = (unsigned __int16)(v14 + *(_WORD *)(v7 + 32) - 1);
          if (v15 == v6)
          {
            if (!(unsigned __int16)*(_DWORD *)(v7 + 24))
            {
              BOOL v18 = v15 != v16 || v17 == 0xFFFF;
              goto LABEL_65;
            }
LABEL_88:
            LOBYTE(v5) = 1;
            return v5;
          }
          if (v17 != 0xFFFF) {
            goto LABEL_88;
          }
          if ((unsigned __int16)*(_DWORD *)(v7 + 24)) {
            BOOL v28 = v15 == v16;
          }
          else {
            BOOL v28 = 0;
          }
LABEL_74:
          LOBYTE(v5) = v28;
          return v5;
        }
        goto LABEL_2;
      }
      if (v6)
      {
        uint64_t v19 = *(void *)(v7 + 40);
        if (!v19) {
          goto LABEL_2;
        }
        if (((*(_DWORD *)(v19 + 8) >> v6) & 1) != 0
          && *(unsigned __int8 *)(v19 + 12) >= v6
          && (unsigned int v20 = *(void **)(*(void *)v19 + 8 * (v6 - 1))) != 0)
        {
          char v21 = atomic_load(v20 + 1);
          if ((v21 & 0x70) != 0x10)
          {
            char v29 = atomic_load(v20 + 1);
            if ((v29 & 0x70) == 0x30)
            {
              uint64_t v30 = *(void *)(v7 + 40);
              if (!v30 || !*(unsigned char *)(v30 + 13)) {
                goto LABEL_88;
              }
              BOOL v28 = __CFCSetIsEqualBitmap(v20[3], -1) == 0;
              goto LABEL_74;
            }
            __CFCSetGetBitmap((uint64_t)v20, __b);
            uint64_t v31 = *(void *)(v7 + 40);
            if (!v31 || !*(unsigned char *)(v31 + 13)) {
              goto LABEL_88;
            }
            if (&v35 != (uint64_t *)-9)
            {
              uint64_t v32 = 0;
              do
              {
                LOBYTE(v5) = v32 != 2048;
                if (v32 == 2048) {
                  break;
                }
                __int32 v33 = __b[0].i32[v32++];
              }
              while (v33 == -1);
              return v5;
            }
LABEL_2:
            LOBYTE(v5) = 0;
            return v5;
          }
          uint64_t v22 = *(void *)(v7 + 40);
          if (!v22 || !*(unsigned char *)(v22 + 13) || *((_DWORD *)v20 + 6)) {
            goto LABEL_88;
          }
          BOOL v18 = v20[4] == 0x10000;
        }
        else
        {
          BOOL v18 = *(unsigned char *)(v19 + 13) == 0;
        }
      }
      else
      {
        unsigned int v26 = atomic_load((unint64_t *)(v7 + 8));
        int v27 = (v26 >> 4) & 7;
        if (v27 != 4 && v27 != 3)
        {
          if (v27 == 2 && !*(void *)(v7 + 32)) {
            return v5;
          }
          goto LABEL_88;
        }
        BOOL v18 = *(void *)(v7 + 24) == 0;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(v7 + 24);
      if (v5 == 1)
      {
        if (v6 == 14 || (v4 & 8) != 0) {
          return v5;
        }
        LODWORD(v5) = 1;
      }
      else
      {
        if (v5 < 4 || v5 == 15)
        {
          if (v6) {
            BOOL v18 = v10 == 0;
          }
          else {
            BOOL v18 = 0;
          }
          goto LABEL_65;
        }
        unint64_t v23 = v10 >> 3;
        if (v5 == 12)
        {
          if (v23) {
            BOOL v24 = v6 - 14 >= 0xFFFFFFFFFFFFFFF5;
          }
          else {
            BOOL v24 = 0;
          }
          LOBYTE(v5) = !v24;
          return v5;
        }
        if (v23) {
          goto LABEL_88;
        }
      }
      BOOL v18 = CFUniCharGetBitmapPtrForPlane(v5, v6) == 0;
    }
LABEL_65:
    LOBYTE(v5) = !v18;
    return v5;
  }
  unsigned int v9 = atomic_load((unint64_t *)(v7 + 8));
  switch((v9 >> 4) & 7)
  {
    case 1u:
    case 2u:
      if (*(void *)(v7 + 32)) {
        goto LABEL_13;
      }
      break;
    case 3u:
    case 4u:
      if (*(void *)(v7 + 24)) {
        goto LABEL_13;
      }
      break;
    default:
      goto LABEL_13;
  }
  return v5;
}

CFDataRef CFCharacterSetCreateBitmapRepresentation(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  uint64_t v91 = *(void *)off_1ECE0A5B0;
  if (!CF_IS_OBJC(0x19uLL, (unint64_t)theSet))
  {
    uint64_t v5 = *((void *)theSet + 5);
    if (v5)
    {
      int v6 = *(unsigned __int8 *)(v5 + 13);
      BOOL v7 = *(unsigned char *)(v5 + 13) != 0;
      unsigned int v8 = *(_DWORD *)(v5 + 8);
      if (v8)
      {
        uint64_t v9 = 0;
        int v10 = 0;
        do
        {
          unint64_t v11 = v9 + 1;
          if (v6
            || ((v8 >> (v9 + 1)) & 1) != 0
            && v11 <= *(unsigned __int8 *)(v5 + 12)
            && *(void *)(*(void *)v5 + 8 * v9))
          {
            v90[v10++] = v11;
          }
          ++v9;
        }
        while (v9 != 16);
        CFIndex v12 = 8193 * v10 + 0x2000;
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(alloc, v12);
        CFDataSetLength(Mutable, v12);
        MutableBytePtr = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
        __CFCSetGetBitmap((uint64_t)theSet, MutableBytePtr);
        if (v10 > 0)
        {
          unint64_t v15 = CFDataGetMutableBytePtr(Mutable);
          uint64_t v16 = *((void *)theSet + 5);
          if (v16)
          {
            if (*(_DWORD *)(v16 + 8))
            {
              int v17 = (int8x16_t *)v15;
              uint64_t v18 = 0;
              if (v6) {
                unsigned int v19 = -1;
              }
              else {
                unsigned int v19 = 0;
              }
              int32x4_t v20 = vdupq_n_s32(v19);
              char v21 = v15 + 8193;
              int32x4_t v89 = v20;
              do
              {
                unsigned int v22 = v90[v18];
                v17[512].i8[0] = v22;
                if (!v22) {
                  __break(1u);
                }
                int v17 = (int8x16_t *)((char *)v17 + 8193);
                if (v22 <= 0x10
                  && (uint64_t v23 = *((void *)theSet + 5)) != 0
                  && ((*(_DWORD *)(v23 + 8) >> v22) & 1) != 0
                  && *(unsigned __int8 *)(v23 + 12) >= v22
                  && (uint64_t v24 = *(void *)(*(void *)v23 + 8 * (v22 - 1))) != 0)
                {
                  __CFCSetGetBitmap(v24, v17);
                  int32x4_t v20 = v89;
                  if (v6)
                  {
                    for (uint64_t i = 0; i != 0x2000; i += 16)
                      *(int8x16_t *)&v21[i] = vmvnq_s8(*(int8x16_t *)&v21[i]);
                  }
                }
                else
                {
                  for (uint64_t j = 0; j != 0x2000; j += 16)
                    *(int32x4_t *)&v21[j] = v20;
                }
                ++v18;
                v21 += 8193;
              }
              while (v18 != v10);
            }
          }
        }
        return Mutable;
      }
    }
    else
    {
      BOOL v7 = 0;
    }
    char v27 = atomic_load((unint64_t *)theSet + 1);
    char v28 = atomic_load((unint64_t *)theSet + 1);
    if ((v27 & 0x70) == 0)
    {
      if ((v28 & 8) != 0) {
        int v34 = 16;
      }
      else {
        int v34 = CFUniCharGetNumberOfPlanes(*((_DWORD *)theSet + 6)) - 1;
      }
      CFIndex v39 = 8193 * v34 + 0x2000;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(alloc, v39);
      CFDataSetLength(Mutable, v39);
      int v40 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
      __CFCSetGetBitmap((uint64_t)theSet, v40);
      if (v34 >= 1)
      {
        int v41 = 0;
        int v42 = CFDataGetMutableBytePtr(Mutable) + 0x2000;
        unint64_t v43 = atomic_load((unint64_t *)theSet + 1);
        uint64_t v44 = (v43 >> 3) & 1;
        do
        {
          int BitmapForPlane = CFUniCharGetBitmapForPlane(*((_DWORD *)theSet + 6), ++v41, v42 + 1, v44);
          if (BitmapForPlane != 255)
          {
            *int v42 = v41;
            if (BitmapForPlane == 1) {
              memset(v42 + 1, 255, 0x2000uLL);
            }
            v42 += 8193;
          }
        }
        while (v34 != v41);
        CFIndex v46 = v42 - CFDataGetBytePtr(Mutable);
        if (v46 < v39) {
          CFDataSetLength(Mutable, v46);
        }
      }
      return Mutable;
    }
    if ((v28 & 0x70) != 0x10)
    {
      if (v7)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(alloc, 139280);
        CFDataSetLength(Mutable, 139280);
        uint64_t v35 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
        __CFCSetGetBitmap((uint64_t)theSet, v35);
        uint64_t v36 = CFDataGetMutableBytePtr(Mutable) + 0x2000;
        uint64_t v37 = -16;
        do
        {
          UInt8 *v36 = v37 + 17;
          memset(v36 + 1, 255, 0x2000uLL);
          v36 += 8193;
          BOOL v38 = __CFADD__(v37++, 1);
        }
        while (!v38);
      }
      else
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(alloc, 0x2000);
        CFDataSetLength(Mutable, 0x2000);
        unsigned int v70 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
        __CFCSetGetBitmap((uint64_t)theSet, v70);
      }
      return Mutable;
    }
    unsigned int v29 = *((_DWORD *)theSet + 6);
    unsigned int v30 = v29 + *((_DWORD *)theSet + 8) - 1;
    char v31 = atomic_load((unint64_t *)theSet + 1);
    uint64_t v32 = v31 & 8;
    if (v30 >= 0x10000)
    {
      unsigned int v47 = HIWORD(v30);
      int v48 = HIWORD(v29);
      if (v29 < 0x10000) {
        int v48 = 1;
      }
      unsigned int v49 = v47 - v48;
      if (v29 <= 0x10000) {
        LOWORD(v29) = 0;
      }
      if ((_WORD)v29) {
        int v50 = 16 - v49;
      }
      else {
        int v50 = 15 - v49;
      }
      if ((_WORD)v30 != 0xFFFF) {
        ++v50;
      }
      if ((unsigned __int16)v29 | (unsigned __int16)~(_WORD)v30) {
        int v51 = 16 - v49;
      }
      else {
        int v51 = 15 - v49;
      }
      if (v47 != v48) {
        int v51 = v50;
      }
      if (v32) {
        int v33 = v51;
      }
      else {
        int v33 = v49 + 1;
      }
    }
    else
    {
      int v33 = 2 * v32;
    }
    CFIndex v52 = 8193 * v33 + 0x2000;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(alloc, v52);
    CFDataSetLength(Mutable, v52);
    uint64_t v53 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v53);
    if (v33 < 1) {
      return Mutable;
    }
    unsigned int v54 = CFDataGetMutableBytePtr(Mutable);
    unsigned int v55 = *((_DWORD *)theSet + 6);
    unsigned int v56 = v55 + *((_DWORD *)theSet + 8) - 1;
    unsigned int v57 = HIWORD(v56);
    if (v55 <= 0x10000) {
      unsigned __int16 v58 = 0;
    }
    else {
      unsigned __int16 v58 = *((_DWORD *)theSet + 6);
    }
    if (v55 < 0x10000) {
      unsigned int v59 = 1;
    }
    else {
      unsigned int v59 = HIWORD(v55);
    }
    char v60 = atomic_load((unint64_t *)theSet + 1);
    if ((v60 & 8) == 0)
    {
      unsigned int v61 = v57 - v59;
      if (v57 >= v59)
      {
        uint64_t v62 = 0;
        int v63 = v54 + 8194;
        do
        {
          *(v63 - 2) = v59 + v62;
          if (v62) {
            unsigned __int16 v64 = 0;
          }
          else {
            unsigned __int16 v64 = v58;
          }
          if (v61 == v62) {
            unsigned __int16 v65 = v56;
          }
          else {
            unsigned __int16 v65 = -1;
          }
          char v66 = v64;
          if (v64 == v65)
          {
            v63[(v64 >> 3) - 1] |= 1 << (v64 & 7);
          }
          else
          {
            uint64_t v67 = v64 >> 3;
            unsigned int v68 = v65 >> 3;
            int v69 = 255 << (v66 & 7);
            if (v67 == v68)
            {
              v63[v67 - 1] |= (0xFFu >> (~(_BYTE)v65 & 7)) & v69;
            }
            else
            {
              v63[v67 - 1] |= v69;
              v63[(v65 >> 3) - 1] |= 0xFFu >> (~(_BYTE)v65 & 7);
              if ((int)v67 + 1 < v68) {
                memset(&v63[v67], 255, v68 - v67 - 2 + 1);
              }
            }
          }
          ++v62;
          v63 += 8193;
        }
        while (v61 + 1 != v62);
      }
      return Mutable;
    }
    int v71 = (char *)(v54 + 0x2000);
    if (v59 < 2)
    {
      char v73 = 1;
    }
    else
    {
      uint64_t v72 = 0;
      do
      {
        *int v71 = ++v72;
        memset(v71 + 1, 255, 0x2000uLL);
        v71 += 8193;
      }
      while (v59 - 1 != v72);
      char v73 = v59;
    }
    if (v57 == v59)
    {
      if (v58 || (unsigned __int16)v56 != 0xFFFF)
      {
        *int v71 = v73;
        uint64_t v74 = v71 + 1;
        memset(v71 + 1, 255, 0x2000uLL);
        uint64_t v75 = v58 >> 3;
        int v76 = (unsigned __int16)v56 >> 3;
        int v77 = 255 << (v58 & 7);
        if (v76 == v75)
        {
          v74[v75] &= ~((0xFFu >> (~(_BYTE)v56 & 7)) & v77);
        }
        else
        {
          v74[v75] &= ~(_BYTE)v77;
          v74[(unsigned __int16)v56 >> 3] &= -256 >> (~(_BYTE)v56 & 7);
          if (((unint64_t)v58 >> 3) + 1 < v76) {
            bzero(&v71[(v58 >> 3) + 2], v76 - (v58 >> 3) - 2 + 1);
          }
        }
        v71 += 8193;
      }
      goto LABEL_134;
    }
    if (v57 <= v59)
    {
LABEL_134:
      if (!(v56 >> 20))
      {
        unsigned int v86 = 15 - v57;
        if (v57 > 0xF) {
          unsigned int v86 = 0;
        }
        uint64_t v87 = -(uint64_t)(v86 + 1);
        unsigned int v88 = v57 + 1;
        do
        {
          *int v71 = v88;
          memset(v71 + 1, 255, 0x2000uLL);
          v71 += 8193;
          ++v88;
          BOOL v38 = __CFADD__(v87++, 1);
        }
        while (!v38);
      }
      return Mutable;
    }
    if (!v58)
    {
LABEL_122:
      if ((unsigned __int16)v56 != 0xFFFF)
      {
        uint64_t v81 = v71 + 0x2000;
        *int v71 = v73;
        bzero(v71 + 1, 0x2000uLL);
        unint64_t v82 = (unint64_t)(unsigned __int16)v56 >> 3;
        int v83 = 255 << (v56 & 7);
        if (v82 == 0x1FFF)
        {
          *uint64_t v81 = v83;
        }
        else
        {
          v71[v82 + 1] |= v83;
          *uint64_t v81 = -1;
          if ((unsigned __int16)v56 >> 4 <= 0xFFEu)
          {
            BOOL v38 = v82 <= 0x1FFD;
            int v85 = 8189 - v82;
            if (!v38) {
              int v85 = 0;
            }
            memset(&v71[((unsigned __int16)v56 >> 3) + 2], 255, (v85 + 1));
          }
        }
        v71 += 8193;
      }
      goto LABEL_134;
    }
    *int v71 = v73;
    int v78 = v71 + 1;
    bzero(v71 + 1, 0x2000uLL);
    unsigned __int16 v79 = v58 - 1;
    if (v58 == 1)
    {
      LOBYTE(v8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
    }
    else
    {
      if ((unsigned __int16)(v58 - 1) > 7u)
      {
        uint64_t v84 = v79 >> 3;
        *int v78 = -1;
        v78[v84] |= 0xFFu >> (~(_BYTE)v79 & 7);
        if ((unsigned __int16)(v58 - 1) >= 0x10u)
        {
          if (v84 <= 2) {
            LODWORD(v84) = 2;
          }
          memset(v71 + 2, 255, (v84 - 1));
        }
        goto LABEL_121;
      }
      unsigned int v80 = 0xFFu >> (v79 ^ 7);
    }
    *int v78 = v80;
LABEL_121:
    v71 += 8193;
    goto LABEL_122;
  }

  return (CFDataRef)[(__CFCharacterSet *)theSet _retainedBitmapRepresentation];
}

const char *__CFCheckForExpandedSet(const char *result)
{
  char v1 = result;
  char v2 = __CFCheckForExpandedSet___CFNumberOfPlanesForLogging;
  if (__CFCheckForExpandedSet___CFNumberOfPlanesForLogging < 0)
  {
    CFStringRef result = getenv("CFCharacterSetCheckForExpandedSet");
    if (result) {
      CFStringRef result = (const char *)strtol_l(result, 0, 0, 0);
    }
    if ((unint64_t)(result - 1) >= 0x10) {
      char v2 = 0;
    }
    else {
      char v2 = (char)result;
    }
    __CFCheckForExpandedSet___CFNumberOfPlanesForLogging = v2;
  }
  if (v2)
  {
    uint64_t v3 = *((void *)v1 + 5);
    if (v3)
    {
      unsigned int v4 = *(_DWORD *)(v3 + 8);
      if (v4)
      {
        int v5 = 0;
        while ((v4 & 1) == 0 || ++v5 < v2)
        {
          BOOL v6 = v4 > 1;
          v4 >>= 1;
          if (!v6) {
            return result;
          }
        }
        if ((__CFCheckForExpandedSet_warnedOnce & 1) == 0)
        {
          CFStringRef result = (const char *)CFLog(4, @"An expanded CFMutableCharacter has been detected.  Recommend to compact with CFCharacterSetCreateCopy");
          __CFCheckForExpandedSet_warnedOnce = 1;
        }
      }
    }
  }
  return result;
}

void _CFCharacterSetFast(unint64_t *cf)
{
  char v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x40 && cf[3]) {
    __CFCSetMakeBitmap((char *)cf);
  }
  unint64_t v3 = cf[5];
  if (v3 && *(_DWORD *)(v3 + 8))
  {
    for (uint64_t i = 0; i != 16; ++i)
    {
      unint64_t v5 = cf[5];
      if (v5)
      {
        if (((*(_DWORD *)(v5 + 8) >> (i + 1)) & 1) != 0
          && *(unsigned __int8 *)(v5 + 12) >= (i + 1))
        {
          uint64_t v6 = *(void *)(*(void *)v5 + 8 * i);
          if (v6)
          {
            char v7 = atomic_load((unint64_t *)(v6 + 8));
            if ((v7 & 0x70) == 0x40)
            {
              if (*(void *)(v6 + 24)) {
                __CFCSetMakeBitmap((char *)v6);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t _CFCharacterSetGetKeyedCodingType(void *a1)
{
  if (CF_IS_OBJC(0x19uLL, (unint64_t)a1)) {
    return 1;
  }
  unsigned int v3 = atomic_load(a1 + 1);
  int v4 = (v3 >> 4) & 7;
  if (v4 == 2)
  {
    uint64_t v5 = a1[5];
    if (!v5 || !*(_DWORD *)(v5 + 8) && !*(unsigned char *)(v5 + 13)) {
      return 4;
    }
    return 1;
  }
  if (v4 == 1) {
    return 3;
  }
  if (v4) {
    return 1;
  }
  if ((uint64_t)a1[3] >= 14) {
    return 5;
  }
  else {
    return 2;
  }
}

uint64_t _CFCharacterSetIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFCharacterSetGetKeyedCodingBuiltinType(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t _CFCharacterSetGetKeyedCodingRange(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

CFStringRef _CFCharacterSetCreateKeyedCodingString(uint64_t a1)
{
  return CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(const UniChar **)(a1 + 24), *(void *)(a1 + 32));
}

uint64_t _CFCharacterSetIsInverted(uint64_t a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 >> 3) & 1;
}

uint64_t _CFCharacterSetSetIsInverted(uint64_t result, int a2)
{
  unint64_t v2 = atomic_load((unint64_t *)(result + 8));
  uint64_t v3 = 8;
  if (!a2) {
    uint64_t v3 = 0;
  }
  unint64_t v4 = v2;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v4, v2 & 0xFFFFFFFFFFFFFFF7 | v3);
    BOOL v5 = v4 == v2;
    unint64_t v2 = v4;
  }
  while (!v5);
  return result;
}

unint64_t *_CFCreateCharacterSetFromUSet(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(0);
  if (!Mutable) {
    return 0;
  }
  uint64_t v3 = Mutable;
  ItemCFIndex Count = uset_getItemCount();
  if (ItemCount >= 1)
  {
    int v5 = ItemCount;
    for (int i = 0; i != v5; ++i)
    {
      Iteuint64_t m = uset_getItem();
      if (Item <= 0)
      {
        v13.CFIndex location = 0;
        v13.CFIndex length = 1;
        CFCharacterSetAddCharactersInRange(v3, v13);
      }
      else
      {
        CFStringRef v8 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, Item, (CFAllocatorRef)&__kCFAllocatorNull);
        CFCharacterSetAddCharactersInString(v3, v8);
        CFRelease(v8);
      }
    }
  }
  CFSetRef Copy = __CFCharacterSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (unint64_t *)v3, 0, 1);
  CFRelease(v3);
  return Copy;
}

uint64_t __CFCSetIsEqualAnnex(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v46 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = *(void *)(v3 + 40);
  if (!v4)
  {
    uint64_t v6 = (uint64_t *)(v2 + 40);
    uint64_t v7 = *(void *)(v2 + 40);
    if (!v7)
    {
LABEL_66:
      uint64_t v36 = 0;
      while (1)
      {
        char v37 = v36 + 1;
        unsigned int v38 = (v36 + 1);
        uint64_t v39 = *(void *)(v3 + 40);
        if (v39 && ((*(_DWORD *)(v39 + 8) >> v37) & 1) != 0 && *(unsigned __int8 *)(v39 + 12) >= v38) {
          uint64_t v40 = *(void *)(*(void *)v39 + 8 * v36);
        }
        else {
          uint64_t v40 = 0;
        }
        uint64_t v41 = *v6;
        if (*v6 && ((*(_DWORD *)(v41 + 8) >> v37) & 1) != 0 && *(unsigned __int8 *)(v41 + 12) >= v38)
        {
          uint64_t v42 = *(void *)(*(void *)v41 + 8 * v36);
          if (v40)
          {
LABEL_75:
            uint64_t result = __CFCharacterSetEqual(v40, v42);
            if (!result) {
              return result;
            }
          }
        }
        else
        {
          uint64_t v42 = 0;
          if (v40) {
            goto LABEL_75;
          }
        }
        if (++v36 == 16) {
          return 1;
        }
      }
    }
    int v8 = *(unsigned __int8 *)(v7 + 13);
    if (!*(unsigned char *)(v7 + 13)) {
      goto LABEL_63;
    }
    goto LABEL_9;
  }
  uint64_t v6 = (uint64_t *)(v2 + 40);
  uint64_t v5 = *(void *)(v2 + 40);
  if (!v5)
  {
    if (!*(unsigned char *)(v4 + 13))
    {
      uint64_t v7 = 0;
      goto LABEL_62;
    }
    goto LABEL_9;
  }
  uint64_t v7 = *(void *)(v2 + 40);
  if ((*(unsigned char *)(v4 + 13) != 0) != (*(unsigned char *)(v5 + 13) != 0))
  {
LABEL_9:
    uint64_t v9 = 1;
    while (1)
    {
      uint64_t v10 = *(void *)(v3 + 40);
      if (v10
        && ((*(_DWORD *)(v10 + 8) >> v9) & 1) != 0
        && *(unsigned __int8 *)(v10 + 12) >= v9)
      {
        uint64_t v11 = *(void *)(*(void *)v10 + 8 * v9 - 8);
      }
      else
      {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *v6;
      if (*v6
        && ((*(_DWORD *)(v12 + 8) >> v9) & 1) != 0
        && *(unsigned __int8 *)(v12 + 12) >= v9)
      {
        uint64_t v13 = *(void *)(*(void *)v12 + 8 * v9 - 8);
      }
      else
      {
        uint64_t v13 = 0;
      }
      if (!(v11 | v13)) {
        return 0;
      }
      if (v11)
      {
        char v14 = atomic_load((unint64_t *)(v11 + 8));
        uint64_t v15 = v14 & 0x70;
        if (v13)
        {
          char v16 = atomic_load((unint64_t *)(v13 + 8));
          uint64_t v17 = v16 & 0x70;
          if (v15 == 48 && v17 == 48)
          {
            for (uint64_t i = 0; i != 0x2000; i += 4)
            {
              int v19 = *(_DWORD *)(*(void *)(v11 + 24) + i);
              int v20 = ~*(_DWORD *)(*(void *)(v13 + 24) + i);
              if (v19 != v20) {
                return 0;
              }
            }
          }
          else if (v15 == 48 || v17 == 48)
          {
            BOOL v30 = v17 == 48;
            if (v17 == 48) {
              uint64_t v31 = v11;
            }
            else {
              uint64_t v31 = v13;
            }
            if (!v30) {
              uint64_t v13 = v11;
            }
            __CFCSetGetBitmap(v31, v45);
            for (uint64_t j = 0; j != 2048; ++j)
            {
              int v33 = *(_DWORD *)(*(void *)(v13 + 24) + j * 4);
              __int32 v34 = ~v45[0].i32[j];
              if (v33 != v34) {
                return 0;
              }
            }
          }
          else
          {
            __CFCSetGetBitmap(v11, v45);
            __CFCSetGetBitmap(v13, __b);
            for (uint64_t k = 0; k != 2048; ++k)
            {
              __int32 v24 = v45[0].i32[k];
              __int32 v25 = ~__b[0].i32[k];
              if (v24 != v25) {
                return 0;
              }
            }
          }
        }
        else
        {
          if (v15 == 48)
          {
            uint64_t v22 = *(void *)(v11 + 24);
LABEL_31:
            if (!__CFCSetIsEqualBitmap(v22, -1)) {
              return 0;
            }
            goto LABEL_32;
          }
          __CFCSetGetBitmap(v11, v45);
          if (v45 != (int8x16_t *)-1)
          {
            for (uint64_t m = 0; m != 2048; ++m)
            {
              __int32 v29 = v45[0].i32[m];
              if (v29 != -1) {
                return 0;
              }
            }
          }
        }
      }
      else
      {
        char v21 = atomic_load((unint64_t *)(v13 + 8));
        if ((v21 & 0x70) == 0x30)
        {
          uint64_t v22 = *(void *)(v13 + 24);
          goto LABEL_31;
        }
        __CFCSetGetBitmap(v13, v45);
        if (v45 != (int8x16_t *)-1)
        {
          for (uint64_t n = 0; n != 2048; ++n)
          {
            __int32 v27 = v45[0].i32[n];
            if (v27 != -1) {
              return 0;
            }
          }
        }
      }
LABEL_32:
      if (++v9 == 17) {
        return 1;
      }
    }
  }
LABEL_62:
  int v8 = *(_DWORD *)(v4 + 8);
  if (v5)
  {
LABEL_63:
    int v35 = *(_DWORD *)(v7 + 8);
    goto LABEL_65;
  }
  int v35 = 0;
LABEL_65:
  if (v8 == v35) {
    goto LABEL_66;
  }
  return 0;
}

uint64_t __CFCSetIsBitmapEqualToRange(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if ((a3 ^ a2) <= 7)
  {
    if (a4) {
      unsigned int v4 = ~(((0xFFu >> (~(_BYTE)a3 & 7)) & (255 << (a2 & 7))) << 24 >> (~(_BYTE)a2 & 0x18));
    }
    else {
      unsigned int v4 = ((0xFFu >> (~(_BYTE)a3 & 7)) & (255 << (a2 & 7))) << 24 >> (~(_BYTE)a2 & 0x18);
    }
    uint64_t v5 = a2 >> 5;
    if (a4) {
      int v6 = -1;
    }
    else {
      int v6 = 0;
    }
    if (*(_DWORD *)(a1 + 4 * v5) == v4)
    {
      uint64_t v7 = a2 >> 5;
      goto LABEL_26;
    }
    return 0;
  }
  unsigned int v8 = ((255 << (a2 & 7)) << (a2 & 0x18 ^ 0x18)) | (0xFFFFFFu >> (a2 & 0x18));
  unsigned int v9 = (0xFFu >> (~(_BYTE)a3 & 7) << (a3 & 0x18 ^ 0x18)) | (0xFFFFFFFFLL << (32 - (a3 & 0x18)));
  uint64_t v5 = a2 >> 5;
  uint64_t v7 = a3 >> 5;
  if (v5 == a3 >> 5)
  {
    unsigned int v10 = bswap32(v9 & v8);
    if (a4) {
      unsigned int v11 = ~v10;
    }
    else {
      unsigned int v11 = v10;
    }
    int v12 = *(_DWORD *)(a1 + 4 * v5);
    if (a4) {
      int v6 = -1;
    }
    else {
      int v6 = 0;
    }
  }
  else
  {
    unsigned int v13 = bswap32(v8);
    if (a4) {
      int v14 = ~v13;
    }
    else {
      int v14 = v13;
    }
    if (a4) {
      int v6 = -1;
    }
    else {
      int v6 = 0;
    }
    if (*(_DWORD *)(a1 + 4 * v5) != v14) {
      return 0;
    }
    int v12 = *(_DWORD *)(a1 + 4 * v7);
    unsigned int v11 = bswap32(v9) ^ v6;
  }
  if (v12 != v11) {
    return 0;
  }
LABEL_26:
  uint64_t v15 = 0;
  while (v5 != v15)
  {
    int v16 = *(_DWORD *)(a1 + 4 * v15++);
    if (v16 != v6) {
      return 0;
    }
  }
  uint64_t v17 = v7 + ~v5;
  if (a4) {
    int v18 = 0;
  }
  else {
    int v18 = -1;
  }
  int v19 = (int *)(4 * v5 + a1 + 4);
  while (v17-- >= 1)
  {
    int v21 = *v19++;
    if (v21 != v18) {
      return 0;
    }
  }
  if (v5 == v7) {
    uint64_t v22 = v19;
  }
  else {
    uint64_t v22 = v19 + 1;
  }
  for (uint64_t i = v7 - 2047; i; ++i)
  {
    int v24 = *v22++;
    if (v24 != v6) {
      return 0;
    }
  }
  return 1;
}

BOOL fdCanWrite(int a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if (a1 >= 1024)
  {
    unsigned int v3 = (a1 + 1) >> 5;
    if (((a1 + 1) & 0x1F) != 0) {
      ++v3;
    }
    size_t v4 = 4 * v3;
    uint64_t v2 = malloc_type_malloc(v4, 0x5DEC1D89uLL);
    bzero(v2, v4);
  }
  else
  {
    uint64_t v2 = v7;
  }
  memset(v7, 0, sizeof(v7));
  if (__darwin_check_fd_set_overflow(a1, v2, 1)) {
    *(_DWORD *)((char *)v2 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  int v5 = select_DARWIN_EXTSN();
  if (v2 != v7) {
    free(v2);
  }
  return v5 == 1;
}

uint64_t _CFReadStreamCreateFromFileDescriptor(__objc2_class **a1, int a2)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  DWORD2(v3[0]) = a2;
  return _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)v3, fileCallBacks, 1);
}

uint64_t _CFWriteStreamCreateFromFileDescriptor(__objc2_class **a1, int a2)
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  DWORD2(v3[0]) = a2;
  return _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)v3, fileCallBacks, 0);
}

CFWriteStreamRef CFWriteStreamCreateWithBuffer(CFAllocatorRef alloc, UInt8 *buffer, CFIndex bufferCapacity)
{
  void v5[4] = *(void *)off_1ECE0A5B0;
  v4[0] = buffer;
  v4[1] = bufferCapacity;
  v4[2] = 0;
  v4[3] = 0;
  v5[0] = v4;
  v5[1] = v4;
  uint64_t v5[2] = &__kCFAllocatorNull;
  _OWORD v5[3] = 0;
  return (CFWriteStreamRef)_CFStreamCreateWithConstantCallbacks((__objc2_class **)alloc, (uint64_t)v5, writeDataCallBacks, 0);
}

CFStringRef fileCopyDescription(const void *a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = *(const void **)a2;
    return CFCopyDescription(v2);
  }
  else
  {
    CFAllocatorRef v5 = CFGetAllocator(a1);
    return CFStringCreateWithFormat(v5, 0, @"fd = %d", *(unsigned int *)(a2 + 8));
  }
}

BOOL fileCanWrite(uint64_t a1, uint64_t a2)
{
  return fdCanWrite(*(_DWORD *)(a2 + 8));
}

CFDataRef fileCopyProperty(const void *a1, CFTypeRef cf1, uint64_t a3)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  if (!CFEqual(cf1, @"kCFStreamPropertyFileCurrentOffset"))
  {
    if (CFEqual(cf1, @"_kCFStreamPropertyFileNativeHandle"))
    {
      *(_DWORD *)bytes = *(_DWORD *)(a3 + 8);
      if (*(_DWORD *)bytes != -1)
      {
        CFAllocatorRef v11 = CFGetAllocator(a1);
        return CFDataCreate(v11, bytes, 4);
      }
    }
    return 0;
  }
  if ((*(unsigned char *)(a3 + 24) & 8) == 0)
  {
    int v6 = *(_DWORD *)(a3 + 8);
    if (v6 != -1) {
      *(void *)(a3 + 32) = lseek(v6, 0, 1);
    }
  }
  uint64_t v8 = *(void *)(a3 + 32);
  uint64_t v7 = (const void *)(a3 + 32);
  if (v8 == -1) {
    return 0;
  }
  CFAllocatorRef v9 = CFGetAllocator(a1);

  return CFNumberCreate(v9, kCFNumberSInt64Type, v7);
}

uint64_t fileSetProperty(void *a1, CFTypeRef cf1, __objc2_class **a3, uint64_t a4)
{
  if (CFEqual(cf1, @"kCFStreamPropertyAppendToFile")
    && (CFTypeID v8 = CFGetTypeID(a1), v8 == CFWriteStreamGetTypeID())
    && CFWriteStreamGetStatus((CFWriteStreamRef)a1) == kCFStreamStatusNotOpen)
  {
    uint64_t v11 = *(void *)(a4 + 24);
    if (&__kCFBooleanTrue == a3)
    {
      *(void *)(a4 + 24) = v11 | 8;
      *(void *)(a4 + 32) = -1;
    }
    else
    {
      *(void *)(a4 + 24) = v11 & 0xFFFFFFFFFFFFFFF7;
    }
    return 1;
  }
  else if (CFEqual(cf1, @"kCFStreamPropertyFileCurrentOffset"))
  {
    if ((*(unsigned char *)(a4 + 24) & 8) != 0) {
      uint64_t Value = 0;
    }
    else {
      uint64_t Value = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, (void *)(a4 + 32));
    }
    int v10 = *(_DWORD *)(a4 + 8);
    if (v10 != -1)
    {
      if (lseek(v10, *(void *)(a4 + 32), 0) == -1) {
        return 0;
      }
      else {
        return Value;
      }
    }
  }
  else
  {
    return 0;
  }
  return Value;
}

CFStringRef readDataCopyDescription(uint64_t a1, CFTypeRef *a2)
{
  return CFCopyDescription(*a2);
}

uint64_t dataGetBuffer(char *a1, CFIndex a2, CFIndex *a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a6);
  CFIndex v18 = (CFIndex)&BytePtr[CFDataGetLength(*(CFDataRef *)a6) - *(void *)(a6 + 8)];
  BOOL v19 = v18 <= a2;
  if (v18 >= a2) {
    CFIndex v18 = a2;
  }
  *a3 = v18;
  *a5 = v19;
  *(_DWORD *)(a4 + 8) = 0;
  uint64_t v20 = *(void *)(a6 + 8);
  *(void *)(a6 + 8) = v20 + *a3;
  if (*(unsigned char *)(a6 + 16) && !*a5) {
    CFReadStreamSignalEvent(a1, 2uLL, 0, v13, v14, v15, v16, v17);
  }
  return v20;
}

CFStringRef writeDataCopyDescription(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFWriteDataContext %p>", a2);
}

BOOL dataCanWrite(uint64_t a1, uint64_t a2)
{
  return *(__objc2_class ***)(a2 + 16) != &__kCFAllocatorNull
      || *(void *)(*(void *)(a2 + 8) + 8) > *(void *)(*(void *)(a2 + 8) + 16);
}

void writeDataSchedule(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a4 + 24))
  {
    *(unsigned char *)(a4 + 24) = 1;
    if (CFWriteStreamGetStatus((CFWriteStreamRef)a1) == kCFStreamStatusOpen)
    {
      if (*(__objc2_class ***)(a4 + 16) == &__kCFAllocatorNull)
      {
        if (*(void *)(*(void *)(a4 + 8) + 8) <= *(void *)(*(void *)(a4 + 8) + 16)) {
          unint64_t v11 = 16;
        }
        else {
          unint64_t v11 = 4;
        }
      }
      else
      {
        unint64_t v11 = 4;
      }
      CFWriteStreamSignalEvent(a1, v11, 0, v6, v7, v8, v9, v10);
    }
  }
}

void sub_182CB687C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CB6ED8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CB7350(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CB77C4(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CB7F54(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CB9554(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CBB5C0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CBBC3C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CBC0CC(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CBC738(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CBCBC8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182CBD054(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void _CFDataInit(unint64_t *a1, int a2, unint64_t a3, const UInt8 *a4, CFIndex a5, int a6)
{
  char v8 = a2;
  a1[2] = 0;
  unint64_t v10 = atomic_load(a1 + 1);
  unint64_t v11 = v10;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)a1 + 1, &v11, v10 & 0xFFFFFFFFFFFFFFEFLL | (4 * a2) & 0x10);
    BOOL v12 = v11 == v10;
    unint64_t v10 = v11;
  }
  while (!v12);
  if (a2 & 2) != 0 && (a2)
  {
    a1[3] = 16;
    unint64_t v13 = atomic_load(a1 + 1);
    unint64_t v14 = v13;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)a1 + 1, &v14, v13 | 3);
      BOOL v12 = v14 == v13;
      unint64_t v13 = v14;
    }
    while (!v12);
  }
  else
  {
    a1[3] = a3;
    unint64_t v15 = atomic_load(a1 + 1);
    unint64_t v16 = v15;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)a1 + 1, &v16, v15 & 0xFFFFFFFFFFFFFFFCLL | 1);
      BOOL v12 = v16 == v15;
      unint64_t v15 = v16;
    }
    while (!v12);
  }
  if (a6)
  {
    a1[5] = (unint64_t)a4;
    a1[2] = a5;
LABEL_27:
    unint64_t v22 = atomic_load(a1 + 1);
    unint64_t v23 = v22;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)a1 + 1, &v23, v22 & 0xFFFFFFFFFFFFFFFCLL | v8 & 3);
      BOOL v12 = v23 == v22;
      unint64_t v22 = v23;
    }
    while (!v12);
    return;
  }
  BOOL v17 = 0;
  if (a2 & 2) == 0 && (a2) {
    BOOL v17 = _CFExecutableLinkedOnOrAfter(6uLL) == 0;
  }
  CFIndex v18 = __CFDataAllocate((uint64_t)a1, a1[3], v17);
  a1[5] = (unint64_t)v18;
  if (__CFOASafe)
  {
    __CFSetLastAllocationEventName();
    CFIndex v18 = (void *)a1[5];
  }
  if (v18)
  {
    unint64_t v19 = atomic_load(a1 + 1);
    uint64_t v20 = 64;
    if (v17) {
      uint64_t v20 = 0;
    }
    unint64_t v21 = v19;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)a1 + 1, &v21, v19 & 0xFFFFFFFFFFFFFFBFLL | v20);
      BOOL v12 = v21 == v19;
      unint64_t v19 = v21;
    }
    while (!v12);
    v24.CFIndex location = 0;
    v24.CFIndex length = 0;
    CFDataReplaceBytes((CFMutableDataRef)a1, v24, a4, a5);
    goto LABEL_27;
  }
}

uint64_t _CFDataFindBytes(const __CFData *a1, const __CFData *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  BytePtr = CFDataGetBytePtr(a1);
  unint64_t v11 = (unsigned __int8 *)CFDataGetBytePtr(a2);
  if (CF_IS_OBJC(0x14uLL, (unint64_t)a1)) {
    uint64_t v12 = [(__CFData *)a1 length];
  }
  else {
    uint64_t v12 = *((void *)a1 + 2);
  }
  if (CF_IS_OBJC(0x14uLL, (unint64_t)a2)) {
    unint64_t v13 = [(__CFData *)a2 length];
  }
  else {
    unint64_t v13 = *((void *)a2 + 2);
  }
  uint64_t v14 = ((a5 << 63 >> 63) & (a4 - v13)) + a3;
  if (a4 > v13)
  {
    unint64_t v15 = v13;
  }
  else
  {
    uint64_t v14 = a3;
    unint64_t v15 = a4;
  }
  if ((a5 & 2) != 0)
  {
    a3 = v14;
    unint64_t v16 = v15;
  }
  else
  {
    unint64_t v16 = a4;
  }
  if (v16 >= v12 - a3) {
    unint64_t v16 = v12 - a3;
  }
  uint64_t result = -1;
  if (v13 - 1 < v16 && v12)
  {
    unint64_t v18 = (unint64_t)&BytePtr[a3];
    unint64_t v19 = __CFDataSearchBoyerMoore(v18, v16, v11, v13, a5 & 1);
    if (v19) {
      return (uint64_t)&v19[a3 - v18];
    }
    else {
      return -1;
    }
  }
  return result;
}

unsigned __int8 *__CFDataSearchBoyerMoore(unint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, int a5)
{
  uint64_t v53 = *(void *)off_1ECE0A5B0;
  bzero(v52, 0x800uLL);
  if (a4 >> 60) {
    goto LABEL_65;
  }
  uint64_t v12 = MEMORY[0x1F4188790](v10, v11);
  unint64_t v15 = (uint64_t *)&v50[-v14];
  if (a4 <= 0x100)
  {
    MEMORY[0x1F4188790](v12, v13);
    unint64_t v16 = (uint64_t *)&v50[-((8 * a4 + 15) & 0xFFFFFFFFFFFFFFF0)];
    goto LABEL_7;
  }
  BOOL v17 = (uint64_t *)malloc_type_malloc(8 * a4, 0x100004000313F17uLL);
  if (!v17 || (unint64_t v15 = v17, (v18 = (uint64_t *)malloc_type_malloc(8 * a4, 0x100004000313F17uLL)) == 0)) {
LABEL_65:
  }
    __CFDataHandleOutOfMemory(8 * a4);
  unint64_t v16 = v18;
LABEL_7:
  int64x2_t v19 = vdupq_n_s64(a4);
  uint64_t v20 = 0;
  if (a5)
  {
    do
    {
      *(int64x2_t *)&v52[v20] = v19;
      v20 += 16;
    }
    while (v20 != 2048);
    int v51 = a5;
    uint64_t v21 = (a4 - 1);
    if ((int)a4 - 1 >= 0)
    {
      int v22 = a4;
      do
      {
        *(void *)&v52[8 * a3[v21]] = v21;
        --v21;
        --v22;
      }
      while (v22);
    }
    unint64_t v23 = malloc_type_malloc(a4, 0x100004077774924uLL);
    if (!v23) {
      __CFDataHandleOutOfMemory(a4);
    }
    CFRange v24 = v23;
    memmove(v23, a3, a4);
    unint64_t v25 = a4 - 1;
    if (a4 > 1)
    {
      uint64_t v35 = 0;
      if (a4 >> 1 <= 1) {
        uint64_t v36 = 1;
      }
      else {
        uint64_t v36 = a4 >> 1;
      }
      do
      {
        char v37 = v24[v35];
        v24[v35] = v24[v25];
        v24[v25] = v37;
        ++v35;
        --v25;
      }
      while (v36 != v35);
      _computeGoodSubstringShift((uint64_t)v24, a4, v15, v16);
      unsigned int v38 = &v15[a4 - 1];
      uint64_t v39 = v15;
      do
      {
        uint64_t v40 = *v39;
        *v39++ = *v38;
        *v38-- = v40;
        --v36;
      }
      while (v36);
    }
    else
    {
      _computeGoodSubstringShift((uint64_t)v24, a4, v15, v16);
    }
    free(v24);
    if (v51)
    {
      uint64_t v41 = &a3[a4];
      uint64_t v42 = (unsigned __int8 *)(a1 + a2 - a4);
      if ((unint64_t)v42 < a1 || (uint64_t)a4 < 1)
      {
        unint64_t v43 = a3;
      }
      else
      {
        unint64_t v43 = a3;
        do
        {
          uint64_t v44 = *v42;
          if (v44 == *v43)
          {
            ++v42;
            ++v43;
          }
          else
          {
            unint64_t v45 = *(void *)&v52[8 * v44];
            unint64_t v46 = v15[v43 - a3];
            if (v45 > v46) {
              unint64_t v46 = v45;
            }
            v42 -= v46;
            unint64_t v43 = a3;
          }
        }
        while ((unint64_t)v42 >= a1 && v43 < v41);
      }
      if (v43 == v41) {
        int v48 = &v42[-a4];
      }
      else {
        int v48 = 0;
      }
      goto LABEL_62;
    }
  }
  else
  {
    do
    {
      *(int64x2_t *)&v52[v20] = v19;
      v20 += 16;
    }
    while (v20 != 2048);
    if (a4)
    {
      unint64_t v26 = a4 - 1;
      __int32 v27 = a3;
      do
      {
        int v28 = *v27++;
        *(void *)&v52[8 * v28] = v26--;
      }
      while (v26 != -1);
    }
    _computeGoodSubstringShift((uint64_t)a3, a4, v15, v16);
  }
  __int32 v29 = (unsigned __int8 *)(a1 + a4 - 1);
  if ((unint64_t)v29 >= a1 + a2 || &a3[a4 - 1] < a3)
  {
    BOOL v30 = &a3[a4 - 1];
  }
  else
  {
    BOOL v30 = &a3[a4 - 1];
    do
    {
      uint64_t v31 = *v29;
      if (v31 == *v30)
      {
        --v29;
        --v30;
      }
      else
      {
        unint64_t v32 = *(void *)&v52[8 * v31];
        unint64_t v33 = v15[v30 - a3];
        if (v32 > v33) {
          unint64_t v33 = v32;
        }
        v29 += v33;
        BOOL v30 = &a3[a4 - 1];
      }
    }
    while ((unint64_t)v29 < a1 + a2 && v30 >= a3);
  }
  if (v30 < a3) {
    int v48 = v29 + 1;
  }
  else {
    int v48 = 0;
  }
LABEL_62:
  if (a4 >= 0x101)
  {
    free(v15);
    free(v16);
  }
  return v48;
}

CFRange CFDataFind(CFDataRef theData, CFDataRef dataToFind, CFRange searchRange, CFDataSearchFlags compareOptions)
{
  CFIndex length = searchRange.length;
  CFIndex location = searchRange.location;
  if (CF_IS_OBJC(0x14uLL, (unint64_t)theData))
  {
    uint64_t v9 = [(__CFData *)theData length];
    if ((location & 0x8000000000000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t v9 = *((void *)theData + 2);
    if ((location & 0x8000000000000000) == 0)
    {
LABEL_3:
      if (location <= v9)
      {
        if (length < 0)
        {
          if (dyld_program_sdk_at_least()) {
            CFDataFind_cold_5();
          }
          uint64_t v12 = _CFOSLog();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
            CFDataFind_cold_6();
          }
        }
        else if (location + length > v9)
        {
          if (dyld_program_sdk_at_least()) {
            CFDataFind_cold_3();
          }
          uint64_t v13 = _CFOSLog();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
            CFDataFind_cold_4();
          }
        }
      }
      else
      {
        if (dyld_program_sdk_at_least()) {
          CFDataFind_cold_1();
        }
        uint64_t v11 = _CFOSLog();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          CFDataFind_cold_2();
        }
      }
      goto LABEL_23;
    }
  }
  if (dyld_program_sdk_at_least()) {
    CFDataFind_cold_7();
  }
  uint64_t v10 = _CFOSLog();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
    CFDataFind_cold_8();
  }
LABEL_23:
  CFIndex Bytes = _CFDataFindBytes(theData, dataToFind, location, length, compareOptions);
  result.CFIndex length = v15;
  result.CFIndex location = Bytes;
  return result;
}

uint64_t _computeGoodSubstringShift(uint64_t result, int a2, void *a3, uint64_t *a4)
{
  uint64_t v4 = (a2 - 1);
  a4[(int)v4] = a2;
  if (a2 > 1)
  {
    uint64_t v5 = (a2 - 2);
    LODWORD(v6) = a2 - 1;
    int v7 = a2 - 1;
    do
    {
      if (v5 <= (int)v6 || (unint64_t v8 = a4[~v7 + a2 + (int)v5], v8 >= (int)v5 - (int)v6))
      {
        if ((int)v5 >= (int)v6) {
          int v9 = v6;
        }
        else {
          int v9 = v5;
        }
        if (v9 < 0)
        {
          LODWORD(v6) = v9;
        }
        else
        {
          uint64_t v6 = (int)v6;
          if (v5 < (int)v6) {
            uint64_t v6 = v5;
          }
          while (*(unsigned __int8 *)(result + v6) == *(unsigned __int8 *)(result + a2 - 1 - (int)v5 + (int)v6))
          {
            BOOL v10 = v6-- <= 0;
            if (v10)
            {
              LODWORD(v6) = -1;
              break;
            }
          }
        }
        unint64_t v8 = (int)v5 - (int)v6;
        int v7 = v5;
      }
      a4[v5] = v8;
      BOOL v10 = v5-- <= 0;
    }
    while (!v10);
  }
  if (a2 >= 1)
  {
    uint64_t v11 = (int)v4;
    uint64_t v12 = a2;
    uint64_t v13 = a3;
    do
    {
      *v13++ = a2;
      --v12;
    }
    while (v12);
    LODWORD(v14) = 0;
    uint64_t v15 = a2;
    do
    {
      uint64_t v16 = v15--;
      if (a4[v15] == v16 && (int)v4 - v15 > (int)v14)
      {
        uint64_t v14 = (int)v14;
        do
        {
          if (a3[v14] == a2) {
            a3[v14] = (int)v4 - v15;
          }
          ++v14;
        }
        while (v12 != v14);
        LODWORD(v14) = v12;
      }
      ++v12;
    }
    while (v12 != a2);
    if (a2 >= 2)
    {
      uint64_t v17 = (a2 - 1);
      uint64_t v18 = (int)v4;
      do
      {
        uint64_t v19 = *a4++;
        a3[(int)v4 - v19] = v18--;
        --v17;
      }
      while (v17);
      do
      {
        *a3++ += v11--;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

void sub_182CBEB98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182CBEF64(_Unwind_Exception *exception_object)
{
}

uint64_t _compare_clumpiness(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

CFURLRef _CFBundleCopyExecutableURLInDirectory(CFURLRef url)
{
  return _CFBundleCopyExecutableURLInDirectory2(0, url, 0, 1);
}

CFURLRef _CFBundleCopyOtherExecutableURLInDirectory(CFURLRef url)
{
  return _CFBundleCopyExecutableURLInDirectory2(0, url, 0, 1);
}

CFURLRef CFBundleCopyAuxiliaryExecutableURL(CFBundleRef bundle, CFStringRef executableName)
{
  return _CFBundleCopyExecutableURLInDirectory2(bundle, *((CFURLRef *)bundle + 2), executableName, 1);
}

CFGregorianUnits *__cdecl CFAbsoluteTimeGetDifferenceAsGregorianUnits(CFGregorianUnits *__return_ptr retstr, CFAbsoluteTime at1, CFAbsoluteTime at2, CFGregorianUnits *tz, CFOptionFlags unitFlags)
{
  int v5 = unitFlags;
  uint64_t v6 = tz;
  uint64_t v10 = 0;
  uint64_t v19 = *(void *)off_1ECE0A5B0;
  if (at2 < at1) {
    int v11 = 1;
  }
  else {
    int v11 = -1;
  }
  *(_OWORD *)&retstr->years = 0uLL;
  *(_OWORD *)&retstr->minutes = 0uLL;
  double v12 = at2;
  do
  {
    if (((1 << v10) & v5) != 0)
    {
      int v13 = (int)((at1 - v12) / (double)dword_182D9EC10[v10]);
      *(&retstr->years + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -3 * v11 + v13;
      do
      {
        double v14 = v12;
        *(&retstr->years + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -2 * v11 + v13;
        long long v15 = *(_OWORD *)&retstr->minutes;
        *(_OWORD *)&v18.years = *(_OWORD *)&retstr->years;
        *(_OWORD *)&v18.minutes = v15;
        double v12 = CFAbsoluteTimeAddGregorianUnits(at2, (CFTimeZoneRef)v6, &v18);
        BOOL v16 = v12 <= at1;
        if (at2 >= at1) {
          BOOL v16 = v12 >= at1;
        }
        v13 += v11;
      }
      while (v16);
      *(&retstr->years + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -4 * v11 + v13;
      double v12 = v14;
    }
    ++v10;
  }
  while (v10 != 5);
  if ((v5 & 0x20) == 0 || (double v17 = at1 - v12, retstr->seconds = v17, v17 == 0.0)) {
    retstr->seconds = 0.0;
  }
  return tz;
}

SInt32 CFAbsoluteTimeGetDayOfYear(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  else {
    double SecondsFromGMT = 0.0;
  }
  uint64_t v12 = 0;
  __int16 v11 = 0;
  __CFYMDFromAbsolute(vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0), &v12, (unint64_t)&v11 + 1, (unint64_t)&v11);
  int v4 = SHIBYTE(v11);
  unsigned int v5 = HIBYTE(v11);
  if ((SHIBYTE(v11) - 1) >= 0xC && os_log_type_enabled((os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    int v14 = v4;
    _os_log_error_impl(&dword_182B90000, (os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR, "Month %d is out of bounds", buf, 8u);
    unsigned int v5 = HIBYTE(v11);
  }
  uint64_t v6 = (v12 + 1) % 400;
  if (v6 >= 0) {
    uint64_t v7 = (v12 + 1) % 400;
  }
  else {
    uint64_t v7 = -v6;
  }
  if ((v7 & 3) != 0)
  {
    __int16 v8 = 0;
  }
  else
  {
    __int16 v8 = 0;
    if (v7 != 100 && v7 != 200) {
      __int16 v8 = v7 != 300;
    }
  }
  if (v5 > 0xF)
  {
    int v9 = 0xFFFF;
  }
  else
  {
    if (v5 <= 2) {
      __int16 v8 = 0;
    }
    int v9 = (unsigned __int16)(daysBeforeMonth[v5] + v8);
  }
  return v9 + (char)v11;
}

SInt32 CFAbsoluteTimeGetWeekOfYear(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  else {
    double SecondsFromGMT = 0.0;
  }
  uint64_t v21 = 0;
  __int16 v20 = 0;
  __CFYMDFromAbsolute(vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0), &v21, (unint64_t)&v20 + 1, (unint64_t)&v20);
  uint64_t v4 = v21;
  double v5 = __CFAbsoluteFromYMD(v21, 1u, 1);
  float v6 = floor(v5 - floor(v5 / 7.0) * 7.0);
  if ((int)v6 >= 0) {
    int v7 = (int)v6;
  }
  else {
    int v7 = (int)v6 + 7;
  }
  int v8 = SHIBYTE(v20);
  unsigned int v9 = v20;
  if (SHIBYTE(v20) == 1 && (char)v20 <= 3)
  {
    if (v7 == 4 || (char)v20 <= 2 && v7 == 5) {
      return 53;
    }
    unsigned int v10 = 1;
    if ((char)v20 < 2 && v7 == 6) {
      return 53;
    }
  }
  else
  {
    unsigned int v10 = HIBYTE(v20);
    if (HIBYTE(v20) == 12 && (char)v20 >= 29)
    {
      SInt32 v11 = 1;
      double v12 = __CFAbsoluteFromYMD(v4 + 1, 1u, 1);
      float v13 = floor(v12 - floor(v12 / 7.0) * 7.0);
      if ((int)v13 + ((int)v13 < 0 ? 7 : 0) == 3 || v9 >= 0x1E && (int)v13 + ((int)v13 < 0 ? 7 : 0) == 2) {
        return v11;
      }
      unsigned int v10 = 12;
      if (v9 >= 0x1F && (int)v13 + ((int)v13 < 0 ? 7 : 0) == 1) {
        return 1;
      }
    }
    else if (HIBYTE(v20) - 1 >= 0xC && os_log_type_enabled((os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v23 = v8;
      _os_log_error_impl(&dword_182B90000, (os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR, "Month %d is out of bounds", buf, 8u);
      unsigned int v10 = HIBYTE(v20);
      uint64_t v4 = v21;
    }
  }
  uint64_t v14 = (v4 + 1) % 400;
  if (v14 >= 0) {
    uint64_t v15 = (v4 + 1) % 400;
  }
  else {
    uint64_t v15 = -v14;
  }
  if ((v15 & 3) != 0)
  {
    __int16 v16 = 0;
  }
  else
  {
    __int16 v16 = 0;
    if (v15 != 100 && v15 != 200) {
      __int16 v16 = v15 != 300;
    }
  }
  if (v10 > 0xF)
  {
    int v17 = 0xFFFF;
  }
  else
  {
    if (v10 <= 2) {
      __int16 v16 = 0;
    }
    int v17 = (unsigned __int16)(daysBeforeMonth[v10] + v16);
  }
  int v18 = (unint64_t)(2454267027 * (v17 + v7 - 10 + (char)v20 - 7 * ((v7 - 10) / 7) + 2)) >> 32;
  return (v18 >> 2) + (v18 >> 31) + 1;
}

CFStringRef __CFDateFormatterCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFDateFormatter %p [%p]>", a1, v3);
}

CFTypeID CFDateFormatterGetTypeID(void)
{
  return 56;
}

CFDateFormatterStyle CFDateFormatterGetDateStyle(CFDateFormatterRef formatter)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return *((void *)formatter + 5);
}

CFDateFormatterStyle CFDateFormatterGetTimeStyle(CFDateFormatterRef formatter)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return *((void *)formatter + 4);
}

uint64_t _CFDateFormatterCreateSkeletonFromTemplate(const __CFString *a1, const __CFLocale *a2, _DWORD *a3)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  if (Length)
  {
    uint64_t v11 = 0;
    double v12 = &v11;
    uint64_t v13 = 0x2020000000;
    uint64_t v14 = 0;
    v10[0] = off_1ECE0A5A0;
    v10[1] = 3221225472;
    void v10[2] = ___CFDateFormatterCreateSkeletonFromTemplate_block_invoke;
    v10[3] = &unk_1ECDABC88;
    v10[4] = &v11;
    v10[5] = Length;
    v10[6] = a1;
    v10[7] = a3;
    int v7 = useTemplatePatternGenerator(a2, (uint64_t)v10);
    uint64_t v8 = v12[3];
    if (!v7 && v8)
    {
      CFRelease((CFTypeRef)v12[3]);
      uint64_t v8 = 0;
      v12[3] = 0;
    }
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    uint64_t v8 = 0;
    if (a3) {
      *a3 = 1;
    }
  }
  return v8;
}

void sub_182CBF908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __useTemplatePatternGenerator_block_invoke()
{
  useTemplatePatternGenerator_ptg = 0;
  free((void *)useTemplatePatternGenerator_ptgLocaleName);
  useTemplatePatternGenerator_ptgLocaleCFStringRef Name = 0;
}

void __useTemplatePatternGenerator_block_invoke_2(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  dispatch_source_cancel((dispatch_source_t)useTemplatePatternGenerator_pressureSrc);
  dispatch_release((dispatch_object_t)useTemplatePatternGenerator_pressureSrc);
  useTemplatePatternGenerator_pressureSrc = 0;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  os_unfair_lock_unlock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
}

uint64_t __CFDateFormatterStoreSymbolPrefs(const __CFString *a1, const void *a2, void *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  uint64_t result = CFStringGetTypeID();
  if (v6 == result)
  {
    CFTypeID v8 = CFGetTypeID(a2);
    uint64_t result = CFArrayGetTypeID();
    if (v8 == result)
    {
      Intuint64_t Value = CFStringGetIntValue(a1);
      uint64_t result = CFArrayGetCount((CFArrayRef)a2);
      switch(IntValue)
      {
        case 0:
          unsigned int v10 = a3 + 40;
          uint64_t v11 = (const void *)a3[40];
          if (v11) {
            goto LABEL_51;
          }
          goto LABEL_52;
        case 1:
          unsigned int v10 = a3 + 42;
          uint64_t v11 = (const void *)a3[42];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 2:
          unsigned int v10 = a3 + 43;
          uint64_t v11 = (const void *)a3[43];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 3:
          unsigned int v10 = a3 + 48;
          uint64_t v11 = (const void *)a3[48];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 4:
          unsigned int v10 = a3 + 49;
          uint64_t v11 = (const void *)a3[49];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 5:
          uint64_t v12 = result;
          if (result < 1) {
            return result;
          }
          CFIndex v13 = 0;
          uint64_t v14 = (const void **)(a3 + 63);
          uint64_t v15 = (const void **)(a3 + 62);
          break;
        case 7:
          unsigned int v10 = a3 + 41;
          uint64_t v11 = (const void *)a3[41];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 8:
          unsigned int v10 = a3 + 44;
          uint64_t v11 = (const void *)a3[44];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 9:
          unsigned int v10 = a3 + 50;
          uint64_t v11 = (const void *)a3[50];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 10:
          unsigned int v10 = a3 + 45;
          uint64_t v11 = (const void *)a3[45];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 11:
          unsigned int v10 = a3 + 46;
          uint64_t v11 = (const void *)a3[46];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 12:
          unsigned int v10 = a3 + 47;
          uint64_t v11 = (const void *)a3[47];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 13:
          unsigned int v10 = a3 + 51;
          uint64_t v11 = (const void *)a3[51];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 14:
          unsigned int v10 = a3 + 52;
          uint64_t v11 = (const void *)a3[52];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 15:
          unsigned int v10 = a3 + 53;
          uint64_t v11 = (const void *)a3[53];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 16:
          unsigned int v10 = a3 + 54;
          uint64_t v11 = (const void *)a3[54];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 17:
          unsigned int v10 = a3 + 55;
          uint64_t v11 = (const void *)a3[55];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 18:
          unsigned int v10 = a3 + 56;
          uint64_t v11 = (const void *)a3[56];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 19:
          unsigned int v10 = a3 + 57;
          uint64_t v11 = (const void *)a3[57];
          if (v11) {
LABEL_51:
          }
            CFRelease(v11);
LABEL_52:
          uint64_t result = (uint64_t)CFRetain(a2);
          *unsigned int v10 = result;
          return result;
        default:
          return result;
      }
      do
      {
        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v13);
        CFTypeID v17 = CFGetTypeID(ValueAtIndex);
        uint64_t result = CFStringGetTypeID();
        if (v17 == result)
        {
          if (v13 == 1)
          {
            int v18 = *v14;
            uint64_t v19 = v14;
            if (*v14) {
              goto LABEL_22;
            }
            goto LABEL_23;
          }
          if (!v13)
          {
            int v18 = *v15;
            uint64_t v19 = v15;
            if (!*v15) {
              goto LABEL_23;
            }
LABEL_22:
            CFRelease(v18);
LABEL_23:
            uint64_t result = (uint64_t)CFRetain(ValueAtIndex);
            void *v19 = result;
          }
        }
        ++v13;
      }
      while (v12 != v13);
    }
  }
  return result;
}

void __CFDateFormatterSetSymbolsArray(uint64_t a1, unsigned int a2, int a3, CFArrayRef theArray)
{
  unsigned int v20 = a2;
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  int v21 = 0;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0;
    int v10 = a3;
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
      CFIndex Length = CFStringGetLength(ValueAtIndex);
      uint64_t v14 = Length;
      if (Length >= 768) {
        CFIndex v15 = 768;
      }
      else {
        CFIndex v15 = Length;
      }
      MEMORY[0x1F4188790](Length, v13);
      CFTypeID v17 = (UniChar *)((char *)&v20 - v16);
      CFStringRef CharactersPtr = CFStringGetCharactersPtr(ValueAtIndex);
      if (CharactersPtr)
      {
        uint64_t v19 = (UChar *)CharactersPtr;
      }
      else
      {
        v23.CFIndex location = 0;
        v23.CFIndex length = v15;
        CFStringGetCharacters(ValueAtIndex, v23, v17);
        uint64_t v14 = v15;
        uint64_t v19 = v17;
      }
      int v21 = 0;
      __cficu_udat_setSymbols(a1, v20, (v10 + v9++), v19, v14, &v21);
    }
    while (v8 != v9);
  }
}

double __CFDateFormatterCorrectTimeWithTarget(uint64_t a1, int a2, int a3, int *a4, double a5)
{
  __cficu_ucal_setMillis(a1, a4, a5);
  __cficu_ucal_set(a1, a3 == 0, a2);

  return __cficu_ucal_getMillis(a1, a4);
}

double __CFDateFormatterCorrectTimeToARangeAroundCurrentDate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6, double a7)
{
  double Now = __cficu_ucal_getNow();
  __cficu_ucal_setMillis(a1, a6, Now);
  int v15 = __cficu_ucal_get(a1, 1u, a6);
  int v16 = __cficu_ucal_get(a1, a5 == 0, a6);
  int v17 = v16;
  if (a5)
  {
    uint64_t v18 = a4 + v15;
    uint64_t v19 = v15 - a3;
    BOOL v20 = v18 <= a2;
    uint64_t v21 = v18 - a2;
    if (v20) {
      uint64_t v22 = -1;
    }
    else {
      uint64_t v22 = 1;
    }
    if (v20) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = v21;
    }
    if (v19 >= 1) {
      uint64_t v24 = -1;
    }
    else {
      uint64_t v24 = v19 + a2;
    }
    if (v19 >= 1) {
      uint64_t v25 = 0;
    }
    else {
      uint64_t v25 = 1 - v19;
    }
  }
  else
  {
    int v17 = 100 * (v16 / 100);
    uint64_t v26 = a4 + v15 % 100;
    uint64_t v27 = v15 % 100 - a3;
    BOOL v28 = v26 < a2;
    uint64_t v29 = v26 - a2;
    if (v28) {
      uint64_t v22 = -1;
    }
    else {
      uint64_t v22 = 0;
    }
    if (v28) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = v29 + 1;
    }
    if (v27 >= 0) {
      uint64_t v24 = -1;
    }
    else {
      uint64_t v24 = v27 + a2;
    }
    uint64_t v25 = -v27 & (v27 >> 63);
  }
  __cficu_ucal_setMillis(a1, a6, a7);
  int v30 = __cficu_ucal_get(a1, 1u, a6);
  int v31 = v30 % 100;
  int v32 = v30 % 100 + v17;
  if (a5)
  {
    int v32 = v17;
    int v31 = v30;
  }
  if (v24 == -1 || v31 < v24 || v31 - v24 >= v25)
  {
    if (v22 == -1)
    {
      int v33 = 0;
    }
    else
    {
      BOOL v20 = v31 < v22;
      uint64_t v34 = v31 - v22;
      int v33 = !v20 && v34 < v23;
    }
  }
  else
  {
    int v33 = -1;
  }
  if (!a5) {
    v33 *= 100;
  }

  return __CFDateFormatterCorrectTimeWithTarget(a1, v33 + v32, a5, a6, a7);
}

uint64_t __CFDateFormatterGetMaxYearGivenJapaneseEra(uint64_t a1, int a2, int *a3)
{
  __cficu_ucal_clear(a1);
  __cficu_ucal_set(a1, 0, a2 + 1);
  double Millis = __cficu_ucal_getMillis(a1, a3);
  __cficu_ucal_set(a1, 0, a2);
  return __cficu_ucal_getFieldDifference(a1, 1u, a3, Millis) + 1;
}

BOOL __CFDictionaryApply_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  char v2 = 0;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  return v2 == 0;
}

uint64_t _CFDictionaryGetKVOBit(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFDictionarySetKVOBit(uint64_t result, char a2)
{
  unint64_t v2 = atomic_load((unint64_t *)(result + 8));
  unint64_t v3 = v2;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 8), &v3, v2 & 0xFFFFFFFFFFFFFFFELL | a2 & 1);
    BOOL v4 = v3 == v2;
    unint64_t v2 = v3;
  }
  while (!v4);
  return result;
}

CFMutableStringRef _CFDoubledStringCreate(const __CFString *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFStringAppend(Mutable, a1);
  v4.CFIndex length = CFStringGetLength(Mutable);
  v4.CFIndex location = 0;
  CFStringFindAndReplace(Mutable, @"%", &stru_1ECE10768, v4, 0);
  CFStringAppendFormat(Mutable, 0, @" %@", a1);
  return Mutable;
}

CFStringRef _CFAffixedStringCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0, 0, @"%@%@%@", a2, a1, a3);
}

CFStringRef _CFRLORightToLeftStringCreate(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"%C%@%C", 8238, a1, 8236);
}

CFStringRef _CFAccentuatedStringCreate(const __CFString *a1)
{
  if (_CFAccentuatedStringCreate_onceToken != -1) {
    dispatch_once(&_CFAccentuatedStringCreate_onceToken, &__block_literal_global_2);
  }
  CFCharacterSetRef v2 = (const __CFCharacterSet *)_CFAccentuatedStringCreate_charsToSkip;

  return __CFPseudoLanguageStringCreateWithTransform(a1, 2, v2, (uint64_t)&__block_literal_global_17);
}

CFStringRef __CFPseudoLanguageStringCreateWithTransform(const __CFString *a1, uint64_t a2, const __CFCharacterSet *a3, uint64_t a4)
{
  uint64_t v43 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  MutableCFStringRef Copy = CFStringCreateMutableCopy(0, Length, a1);
  CFIndex v10 = CFStringGetLength(MutableCopy);
  CFStringRef theString = MutableCopy;
  uint64_t v39 = 0;
  CFIndex v40 = v10;
  CFStringRef CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
  CStringPtr = 0;
  char v37 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
  }
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v29 = 0u;
  CFIndex v41 = 0;
  CFIndex v42 = 0;
  unsigned int v38 = CStringPtr;
  uint64_t v13 = (UniChar *)malloc_type_malloc(2 * a2 * v10 + 2, 0x1000040BDFB0063uLL);
  CFIndex v27 = 0;
  if (v10 < 1)
  {
    CFIndex v23 = 0;
  }
  else
  {
    CFIndex v14 = 0;
    do
    {
      CFRange RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(MutableCopy, v14);
      if (RangeOfComposedCharactersAtIndex.length < 1)
      {
        CFIndex v16 = v14;
      }
      else
      {
        CFIndex v16 = RangeOfComposedCharactersAtIndex.length + v14;
        do
        {
          if (v14 < 0 || (CFIndex v17 = v40, v40 <= v14))
          {
            UniChar v18 = 0;
          }
          else if (v37)
          {
            UniChar v18 = v37[v39 + v14];
          }
          else if (v38)
          {
            UniChar v18 = v38[v39 + v14];
          }
          else
          {
            if (v42 <= v14 || (CFIndex v20 = v41, v41 > v14))
            {
              CFIndex v21 = v14 - 4;
              if ((unint64_t)v14 < 4) {
                CFIndex v21 = 0;
              }
              if (v21 + 64 < v40) {
                CFIndex v17 = v21 + 64;
              }
              CFIndex v41 = v21;
              CFIndex v42 = v17;
              v44.CFIndex location = v39 + v21;
              v44.CFIndex length = v17 - v21;
              CFStringGetCharacters(theString, v44, buffer);
              CFIndex v20 = v41;
            }
            UniChar v18 = buffer[v14 - v20];
          }
          ++v14;
          CFIndex v19 = v27++;
          v13[v19] = v18;
        }
        while (v14 != v16);
        if (RangeOfComposedCharactersAtIndex.length == 1)
        {
          uint64_t v22 = v18;
          if (!CFCharacterSetIsCharacterMember(a3, v18)) {
            (*(void (**)(uint64_t, UniChar *, CFIndex *, uint64_t))(a4 + 16))(a4, v13, &v27, v22);
          }
        }
      }
      CFIndex v14 = v16;
    }
    while (v16 < v10);
    CFIndex v23 = v27;
  }
  v13[v23] = 0;
  MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy(0, v13, v23, v23, (CFAllocatorRef)&__kCFAllocatorNull);
  CFStringRef Copy = CFStringCreateCopy(0, MutableWithExternalCharactersNoCopy);
  CFRelease(MutableCopy);
  CFRelease(MutableWithExternalCharactersNoCopy);
  free(v13);
  return Copy;
}

CFStringRef _CFTallStringCreate(uint64_t a1)
{
  CFStringRef v2 = CFStringCreateWithCharacters(0, _CFTallStringCreate_tallCharacters, 7);
  CFStringRef v3 = CFStringCreateWithFormat(0, 0, @"%@%@%@", v2, a1, v2);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetNonBase);
  CFStringRef v5 = __CFPseudoLanguageStringCreateWithTransform(v3, 7, Predefined, (uint64_t)&__block_literal_global_20);
  CFRelease(v2);
  CFRelease(v3);
  return v5;
}

BOOL __CFErrorEqual(void *a1, void *a2)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    uint64_t v4 = [a1 code];
  }
  else {
    uint64_t v4 = a1[2];
  }
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a2)) {
    uint64_t v5 = [a2 code];
  }
  else {
    uint64_t v5 = a2[2];
  }
  if (v4 != v5) {
    return 0;
  }
  CFTypeID v6 = (const void *)(CF_IS_OBJC(0x1BuLL, (unint64_t)a1) ? [a1 domain] : a1[3]);
  int v7 = (const void *)(CF_IS_OBJC(0x1BuLL, (unint64_t)a2) ? [a2 domain] : a2[3]);
  if (!CFEqual(v6, v7)) {
    return 0;
  }
  CFDictionaryRef v8 = CFErrorCopyUserInfo((CFErrorRef)a1);
  CFDictionaryRef v9 = CFErrorCopyUserInfo((CFErrorRef)a2);
  CFDictionaryRef v10 = v9;
  if (v8 == v9)
  {
    BOOL v11 = 1;
    goto LABEL_21;
  }
  BOOL v11 = 0;
  if (!v8 || !v9)
  {
LABEL_21:
    if (!v8) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  BOOL v11 = CFEqual(v8, v9) != 0;
LABEL_22:
  CFRelease(v8);
LABEL_23:
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

CFHashCode __CFErrorHash(uint64_t a1)
{
  return *(void *)(a1 + 16) + CFHash(*(CFTypeRef *)(a1 + 24));
}

CFStringRef __CFErrorCopyFormattingDescription(__CFError *a1)
{
  if (dyld_program_sdk_at_least())
  {
    return (CFStringRef)_CFErrorCreateDebugDescription(a1);
  }
  else
  {
    return CFErrorCopyDescription(a1);
  }
}

const void *_CFErrorCreateLocalizedRecoverySuggestion(void *a1)
{
  return _CFErrorCopyUserInfoKey(a1, @"NSLocalizedRecoverySuggestion");
}

uint64_t _CFErrorCreateUnlocalizedDebugDescription(void *a1)
{
  v3[3] = *(void *)off_1ECE0A5B0;
  v3[1] = 0;
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  _OWORD v3[2] = 0;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)err))
  {
    CFStringRef result = (CFStringRef)[(__CFError *)err localizedDescription];
    if (result)
    {
      return (CFStringRef)CFRetain(result);
    }
  }
  else
  {
    return _CFErrorCreateLocalizedDescription(err);
  }
  return result;
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)err))
  {
    CFStringRef result = (CFStringRef)[(__CFError *)err localizedFailureReason];
    if (result)
    {
      return (CFStringRef)CFRetain(result);
    }
  }
  else
  {
    return (CFStringRef)_CFErrorCopyUserInfoKey(err, @"NSLocalizedFailureReason");
  }
  return result;
}

CFStringRef CFErrorCopyRecoverySuggestion(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)err))
  {
    CFStringRef result = (CFStringRef)[(__CFError *)err localizedRecoverySuggestion];
    if (result)
    {
      return (CFStringRef)CFRetain(result);
    }
  }
  else
  {
    return (CFStringRef)_CFErrorCopyUserInfoKey(err, @"NSLocalizedRecoverySuggestion");
  }
  return result;
}

const void *CFErrorGetCallBackBlockForDomain(const void *a1)
{
  if (!_CFErrorCallBackTable) {
    _CFErrorInitializeCallBackTable();
  }
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable) {
    uint64_t Value = CFDictionaryGetValue((CFDictionaryRef)_CFErrorCallBackTable, a1);
  }
  else {
    uint64_t Value = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  return Value;
}

void CFErrorSetCallBackForDomain(const void *a1, void *a2)
{
  void v3[5] = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    CFStringRef v2 = a2;
    a2 = v3;
    v3[0] = off_1ECE0A5A0;
    v3[1] = 3221225472;
    _OWORD v3[2] = __CFErrorSetCallBackForDomain_block_invoke;
    v3[3] = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    void v3[4] = v2;
  }
  CFErrorSetCallBackBlockForDomain(a1, a2);
}

const void *__CFErrorSetCallBackForDomain_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v3 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 32))(a2, a3);
  uint64_t v4 = v3;
  if (v3) {
    CFAutorelease(v3);
  }
  return v4;
}

uint64_t CFErrorGetCallBackForDomain()
{
  return 0;
}

void blockReleaseValueCallBack(int a1, void *aBlock)
{
}

CFStringRef _CFErrorMachCallBack(void *a1, CFTypeRef cf1)
{
  if (!CFEqual(cf1, @"NSDescription")) {
    return 0;
  }
  if (CF_IS_OBJC(0x1BuLL, (unint64_t)a1)) {
    LODWORD(v3) = [a1 code];
  }
  else {
    uint64_t v3 = a1[2];
  }
  uint64_t v4 = mach_error_string(v3);
  if (!v4 || !*v4) {
    return 0;
  }

  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, 0x8000100u);
}

CFStringRef __CFFileDescriptorCopyDescription(uint64_t a1)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(void *)(a1 + 80);
  if (!v2) {
    goto LABEL_5;
  }
  uint64_t v3 = *(uint64_t (**)(void))(a1 + 104);
  if (!v3) {
    goto LABEL_5;
  }
  CFStringRef v4 = (CFStringRef)v3();
  if (!v4)
  {
    uint64_t v2 = *(void *)(a1 + 80);
LABEL_5:
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFFileDescriptor context %p>", v2);
  }
  memset(&v12, 0, sizeof(v12));
  uint64_t v5 = *(void **)(a1 + 64);
  dli_smach_port_name_t name = "???";
  if (dladdr(v5, &v12))
  {
    if (v12.dli_sname && v12.dli_saddr == v5) {
      dli_smach_port_name_t name = v12.dli_sname;
    }
  }
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  CFDictionaryRef v9 = "No";
  if (!*(_DWORD *)(a1 + 16)) {
    CFDictionaryRef v9 = "Yes";
  }
  CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFFileDescriptor %p [%p]>{valid = %s, fd = %x, source = %p, callout = %s (%p), context = %@}", a1, v8, v9, *(unsigned int *)(a1 + 20), *(void *)(a1 + 56), dli_sname, v5, v4);
  if (v4) {
    CFRelease(v4);
  }
  return v10;
}

CFTypeID CFFileDescriptorGetTypeID(void)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  return 60;
}

void __CFFileDescriptorCreate_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(v2 + 5_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
  if (!*(unsigned char *)(v2 + 48))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 40));
    uint64_t v2 = *(void *)(a1 + 32);
    *(unsigned char *)(v2 + 48) = 1;
  }
  uint64_t v3 = *(__CFRunLoopSource **)(v2 + 56);
  if (v3)
  {
    CFRunLoopSourceSignal(v3);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 56);
    _CFRunLoopSourceWakeUpRunLoops(v4);
  }
}

void __CFFileDescriptorCreate_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(v2 + 51) = 1;
  if (!*(unsigned char *)(v2 + 49))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 40));
    uint64_t v2 = *(void *)(a1 + 32);
    *(unsigned char *)(v2 + 49) = 1;
  }
  uint64_t v3 = *(__CFRunLoopSource **)(v2 + 56);
  if (v3)
  {
    CFRunLoopSourceSignal(v3);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 56);
    _CFRunLoopSourceWakeUpRunLoops(v4);
  }
}

CFFileDescriptorNativeDescriptor CFFileDescriptorGetNativeDescriptor(CFFileDescriptorRef f)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return -1;
  }
  else {
    return *((_DWORD *)f + 5);
  }
}

void CFFileDescriptorGetContext(CFFileDescriptorRef f, CFFileDescriptorContext *context)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  }
  long long v5 = *(_OWORD *)((char *)f + 72);
  long long v6 = *(_OWORD *)((char *)f + 88);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(void *))*((void *)f + 13);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

BOOL cffd_is_writeable(unsigned int a1)
{
  if (a1 >= 0x100000) {
    __break(1u);
  }
  size_t v2 = ((a1 + 8) >> 3) + 7;
  uint64_t v3 = malloc_type_malloc(v2, 0xEF2DA67DuLL);
  int v4 = 1 << a1;
  uint64_t v5 = a1 >> 5;
  while (1)
  {
    bzero(v3, v2);
    if (__darwin_check_fd_set_overflow(a1, v3, 1)) {
      *((_DWORD *)v3 + v5) |= v4;
    }
    int v6 = pselect_DARWIN_EXTSN();
    if ((v6 & 0x80000000) == 0) {
      break;
    }
    if (*__error() != 4 && *__error() != 35) {
      goto LABEL_12;
    }
  }
  if (v6 && __darwin_check_fd_set_overflow(a1, v3, 1))
  {
    BOOL v7 = (*((_DWORD *)v3 + v5) & v4) != 0;
    goto LABEL_13;
  }
LABEL_12:
  BOOL v7 = 0;
LABEL_13:
  free(v3);
  return v7;
}

void CFFileDescriptorDisableCallBacks(CFFileDescriptorRef f, CFOptionFlags callBackTypes)
{
  block[6] = *(void *)off_1ECE0A5B0;
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  __CFCheckCFInfoPACSignature((uint64_t)f);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v5 = __fdQueue();
    block[0] = off_1ECE0A5A0;
    block[1] = 0x40000000;
    block[2] = __CFFileDescriptorDisableCallBacks_block_invoke;
    block[3] = &__block_descriptor_tmp_9;
    void block[4] = f;
    void block[5] = callBackTypes;
    dispatch_sync(v5, block);
  }
}

void __CFFileDescriptorDisableCallBacks_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 16))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      unint64_t v4 = *(NSObject **)(v1 + 32);
      if (v4)
      {
        if (!*(unsigned char *)(v1 + 48))
        {
          dispatch_suspend(v4);
          uint64_t v1 = *(void *)(a1 + 32);
          uint64_t v3 = *(void *)(a1 + 40);
          *(unsigned char *)(v1 + 48) = 1;
        }
      }
    }
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = *(NSObject **)(v1 + 40);
      if (v5)
      {
        if (!*(unsigned char *)(v1 + 49))
        {
          dispatch_suspend(v5);
          *(unsigned char *)(*(void *)(a1 + 32) + 49) = 1;
        }
      }
    }
  }
}

CFTypeRef _CFCopyExtensionForAbstractType(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

BOOL _CFCreateDirectory(char *a1)
{
  if (__CFProphylacticAutofsAccess)
  {
    int v2 = open("/dev/autofs_nowait", 0);
    int v3 = mkdir(a1, 0x1FFu);
    if (v2 != -1) {
      close(v2);
    }
  }
  else
  {
    int v3 = mkdir(a1, 0x1FFu);
  }
  return v3 == 0;
}

BOOL _CFRemoveDirectory(char *a1)
{
  if (__CFProphylacticAutofsAccess)
  {
    int v2 = open("/dev/autofs_nowait", 0);
    int v3 = rmdir(a1);
    if (v2 != -1) {
      close(v2);
    }
  }
  else
  {
    int v3 = rmdir(a1);
  }
  return v3 == 0;
}

BOOL _CFDeleteFile(char *a1)
{
  if (__CFProphylacticAutofsAccess)
  {
    int v2 = open("/dev/autofs_nowait", 0);
    int v3 = unlink(a1);
    if (v2 != -1) {
      close(v2);
    }
  }
  else
  {
    int v3 = unlink(a1);
  }
  return v3 == 0;
}

uint64_t _CFWriteBytesToFile(const __CFURL *a1, const void *a2, size_t a3)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  memset(&v12, 0, sizeof(v12));
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026);
  if (result)
  {
    if (__CFProphylacticAutofsAccess) {
      int v6 = open("/dev/autofs_nowait", 0);
    }
    else {
      int v6 = -1;
    }
    if (stat((const char *)buffer, &v12) && *__error() != 2 || (int v7 = open((const char *)buffer, 1537, 438), v7 < 0))
    {
      if (v6 != -1) {
        close(v6);
      }
      return 0;
    }
    else
    {
      int v8 = v7;
      if (a3 && write(v7, a2, a3) != a3)
      {
        int v9 = *__error();
        close(v8);
        if (v6 != -1) {
          close(v6);
        }
        CFStringRef v10 = __error();
        uint64_t result = 0;
        *CFStringRef v10 = v9;
      }
      else
      {
        fsync(v8);
        close(v8);
        if (v6 != -1) {
          close(v6);
        }
        return 1;
      }
    }
  }
  return result;
}

__CFArray *_CFCreateContentsOfDirectory(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  CFURLRef v7 = v6;
  int v8 = (UInt8 *)v3;
  CFAllocatorRef v9 = (const __CFAllocator *)v2;
  *(void *)&v54[1025] = *(void *)off_1ECE0A5B0;
  if (v3)
  {
    size_t v10 = strlen(v3);
    if (!v5)
    {
LABEL_15:
      CFStringRef v12 = 0;
      int v18 = 0;
      CFIndex usedBufLen = 0;
      char v19 = 1;
      if (v8) {
        goto LABEL_20;
      }
      goto LABEL_18;
    }
  }
  else
  {
    size_t v10 = 0;
    if (!v4) {
      goto LABEL_15;
    }
  }
  CFStringRef v11 = (const __CFString *)CFRetain(v5);
  if (!v11) {
    goto LABEL_15;
  }
  CFStringRef v12 = v11;
  uint64_t Length = CFStringGetLength(v11);
  CFIndex usedBufLen = Length;
  if (Length < 1) {
    goto LABEL_17;
  }
  CFIndex v14 = Length;
  CFStringEncoding v15 = CFStringFileSystemEncoding();
  v55.CFIndex location = 0;
  v55.CFIndex length = v14;
  CFStringGetBytes(v12, v55, v15, 0, 0, &buffer, 1024, &usedBufLen);
  v54[usedBufLen - 1] = 0;
  CFIndex v16 = buffer == 46 ? v54 : (char *)&buffer;
  CFIndex v17 = strchr(v16, 46);
  if (v17)
  {
    int v18 = 0;
    do
    {
      ++v18;
      CFIndex v17 = strchr(v17 + 1, 46);
    }
    while (v17);
    char v19 = 0;
    if (v8) {
      goto LABEL_20;
    }
  }
  else
  {
LABEL_17:
    char v19 = 0;
    int v18 = 0;
    if (v8) {
      goto LABEL_20;
    }
  }
LABEL_18:
  if (!CFURLGetFileSystemRepresentation(v7, 1u, v52, 1024))
  {
    if (v19) {
      return 0;
    }
    CFStringRef v40 = v12;
LABEL_90:
    CFRelease(v40);
    return 0;
  }
  int v8 = v52;
  size_t v10 = strlen((const char *)v52);
LABEL_20:
  memset(&v51, 0, 512);
  unsigned int v47 = 0;
  char v46 = v19;
  if (__CFProphylacticAutofsAccess) {
    int v45 = open("/dev/autofs_nowait", 0);
  }
  else {
    int v45 = -1;
  }
  CFIndex v20 = opendir((const char *)v8);
  if (!v20)
  {
    if ((v19 & 1) == 0) {
      CFRelease(v12);
    }
    if (v45 != -1) {
      close(v45);
    }
    return 0;
  }
  CFIndex v21 = v20;
  CFStringRef cf = v12;
  CFMutableStringRef Mutable = CFArrayCreateMutable(v9, 0, &kCFTypeArrayCallBacks);
  if (!readdir_r(v21, &v51, &v47))
  {
    bufLeuint64_t n = v10;
    CFIndex v23 = v47;
    if (v47)
    {
      int v44 = 0;
      while (1)
      {
        unsigned int v24 = strlen(v23->d_name);
        if (v23->d_name[0] != 46 || v24 != 1 && (v24 != 2 || v23->d_name[1] != 46))
        {
          size_t v25 = usedBufLen;
          if (usedBufLen <= v24)
          {
            if (usedBufLen < 1) {
              goto LABEL_52;
            }
            if (v23->d_name[v24 - 1] != 46)
            {
              d_mach_port_name_t name = v23->d_name;
              if (!v18)
              {
                long long v30 = strrchr(d_name, 46);
                goto LABEL_47;
              }
              CFIndex v27 = strchr(d_name, 46);
              if (v27)
              {
                do
                {
                  int v28 = 0;
                  long long v29 = v27;
                  while (1)
                  {
                    long long v29 = strchr(v29, 46);
                    if (!v29) {
                      break;
                    }
                    if (v18 == ++v28)
                    {
                      int v28 = v18;
                      break;
                    }
                  }
                  if (v28 == v18) {
                    long long v30 = v27;
                  }
                  else {
                    long long v30 = 0;
                  }
                  long long v31 = strchr(v27, 46);
                  if (!v31) {
                    break;
                  }
                  CFIndex v27 = v31;
                }
                while (!v30);
LABEL_47:
                if (!v30) {
                  goto LABEL_69;
                }
                if (buffer != 46) {
                  ++v30;
                }
                if (strlen(v30) != v25 || strncmp(v30, (const char *)&buffer, v25)) {
                  goto LABEL_69;
                }
LABEL_52:
                if (!v7)
                {
                  int v44 = 1;
                  CFURLRef v7 = CFURLCreateFromFileSystemRepresentation(v9, v8, bufLen, 1u);
                  CFIndex v23 = v47;
                }
                unsigned int v32 = ((v23->d_type >> 1) | (v23->d_type << 7));
                BOOL v33 = v32 > 7;
                int v34 = (1 << v32) & 0xA5;
                if (v33 || v34 == 0)
                {
                  Boolean v36 = 0;
                }
                else if (v23->d_type == 4)
                {
                  Boolean v36 = 1;
                }
                else
                {
                  memset(&v49, 0, sizeof(v49));
                  __strlcpy_chk();
                  __strlcat_chk();
                  __strlcat_chk();
                  if (stat(v50, &v49)) {
                    BOOL v37 = 0;
                  }
                  else {
                    BOOL v37 = (v49.st_mode & 0xF000) == 0x4000;
                  }
                  Boolean v36 = v37;
                  CFIndex v23 = v47;
                }
                CFURLRef v38 = CFURLCreateFromFileSystemRepresentationRelativeToBase(v9, (const UInt8 *)v23->d_name, v23->d_namlen, v36, v7);
                CFArrayAppendValue(Mutable, v38);
                CFRelease(v38);
              }
            }
          }
        }
LABEL_69:
        if (!readdir_r(v21, &v51, &v47))
        {
          CFIndex v23 = v47;
          if (v47) {
            continue;
          }
        }
        goto LABEL_77;
      }
    }
  }
  int v44 = 0;
LABEL_77:
  int v39 = closedir(v21);
  if (v45 != -1) {
    close(v45);
  }
  if (v39)
  {
    CFRelease(Mutable);
    if (v44) {
      CFRelease(v7);
    }
    CFStringRef v40 = cf;
    if (v46) {
      return 0;
    }
    goto LABEL_90;
  }
  if ((v46 & 1) == 0) {
    CFRelease(cf);
  }
  if (v44) {
    CFRelease(v7);
  }
  return Mutable;
}

BOOL _CFIsAbsolutePath(unsigned __int16 *a1, uint64_t a2)
{
  if (a2 < 1) {
    return 0;
  }
  int v2 = *a1;
  return v2 == 126 || v2 == 47;
}

BOOL _CFStripTrailingPathSlashes(unsigned __int16 *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2 >= 2 && a1[1] == 58)
  {
    int v3 = *a1;
    unsigned int v4 = v3 - 65;
    BOOL v5 = (v3 - 97) < 0x1A;
    if (v4 < 0x1A) {
      BOOL v5 = 1;
    }
  }
  else
  {
    BOOL v5 = 0;
  }
  for (uint64_t i = 0; ; --i)
  {
    uint64_t v7 = v2 + i;
    if (v5)
    {
      if (v7 <= 3) {
        return i != 0;
      }
    }
    else if (v7 < 2)
    {
      return i != 0;
    }
    if (a1[v2 - 1 + i] != 47) {
      break;
    }
    *a2 = v2 + i - 1;
  }
  return i != 0;
}

void _CFAppendConditionalTrailingPathSlash2(__CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (CFStringGetCharacterAtIndex(a1, Length - 1) != 47)
  {
    CFStringAppendCharacters(a1, &_CFAppendConditionalTrailingPathSlash2_slash, 1);
  }
}

uint64_t _CFAppendPathComponent(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, void *__src, uint64_t a5)
{
  if (!a5) {
    return 1;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = *a2 + 1;
  if (v8 + a5 > a3) {
    return 0;
  }
  if (v7 < a3 && v7 != 0)
  {
    if (v7 != 2)
    {
      if (v7 == 1 && *a1 == 47)
      {
        uint64_t v7 = 1;
        goto LABEL_20;
      }
LABEL_19:
      *a2 = v8;
      a1[v7] = 47;
      uint64_t v7 = v8;
      goto LABEL_20;
    }
    int v11 = a1[1];
    int v12 = *a1;
    if (v11 == 58)
    {
      if ((v12 & 0xFFFFFFDF) - 65 >= 0x1A) {
        goto LABEL_19;
      }
    }
    else if (v11 != 92 || v12 != 92)
    {
      goto LABEL_19;
    }
    uint64_t v7 = 2;
  }
LABEL_20:
  memmove(&a1[v7], __src, 2 * a5);
  *a2 += a5;
  return 1;
}

uint64_t _CFAppendPathExtension(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  if (a5 + *a2 + 1 > a3) {
    return 0;
  }
  if (a5 >= 1)
  {
    int v9 = *a4;
    if (v9 == 47 || (unint64_t)a5 >= 2 && a4[1] == 58 && (v9 & 0xFFFFFFDF) - 65 < 0x1A) {
      return 0;
    }
  }
  _CFStripTrailingPathSlashes(a1, a2);
  uint64_t v11 = *a2;
  uint64_t result = 0;
  switch(*a2)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = 0;
      int v12 = *a1;
      if (v12 != 47 && v12 != 126) {
        goto LABEL_29;
      }
      return result;
    case 2:
      int v13 = a1[1];
      int v14 = *a1;
      if (v13 == 58)
      {
        if ((v14 & 0xFFFFFFDF) - 65 < 0x1A) {
          return 0;
        }
        goto LABEL_22;
      }
      if (v14 != 92) {
        goto LABEL_22;
      }
      if (v13 == 92) {
        return 0;
      }
      goto LABEL_29;
    case 3:
      if (a1[2] == 47 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
        return 0;
      }
      goto LABEL_21;
    default:
      if (v11 < 1) {
        goto LABEL_29;
      }
LABEL_21:
      int v14 = *a1;
LABEL_22:
      if (v14 != 126) {
        goto LABEL_29;
      }
      uint64_t v15 = v11 - 1;
      CFIndex v16 = a1 + 1;
      break;
  }
  while (1)
  {
    int v17 = *v16++;
    if (v17 == 47) {
      break;
    }
    if (!--v15) {
      return 0;
    }
  }
LABEL_29:
  *a2 = v11 + 1;
  a1[v11] = 46;
  memmove(&a1[v11 + 1], a4, 2 * a5);
  *a2 += a5;
  return 1;
}

BOOL _CFTransmutePathSlashes(_WORD *a1, uint64_t *a2, __int16 a3)
{
  uint64_t v3 = *a2;
  if (*a2 >= 2 && *a1 == 92) {
    uint64_t v4 = 2 * (a1[1] == 92);
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 >= v3)
  {
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = v4;
    while (1)
    {
      int v6 = (unsigned __int16)a1[v4];
      if (v6 == 47) {
        break;
      }
      uint64_t v9 = v4 + 1;
      a1[v5] = v6;
LABEL_16:
      ++v5;
      uint64_t v4 = v9;
      if (v9 >= v3) {
        goto LABEL_20;
      }
    }
    a1[v5] = a3;
    if (v3 <= v4 + 1) {
      uint64_t v7 = v4 + 1;
    }
    else {
      uint64_t v7 = v3;
    }
    uint64_t v8 = v7 - 1;
    while (v8 != v4)
    {
      uint64_t v9 = v4 + 1;
      int v10 = (unsigned __int16)a1[++v4];
      if (v10 != 47) {
        goto LABEL_16;
      }
    }
    ++v5;
  }
LABEL_20:
  *a2 = v5;
  return v3 != v5;
}

uint64_t _cfmp_log_failure(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v39 = *(void *)off_1ECE0A5B0;
  BOOL v8 = os_log_type_enabled((os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR);
  if (a2)
  {
    if (v8)
    {
      unsigned int v9 = *((unsigned __int8 *)a2 + 5);
      int v10 = *((unsigned __int8 *)a2 + 4);
      int v11 = *a2;
      int v13 = 136449283;
      uint64_t v14 = a1;
      __int16 v15 = 1025;
      int v16 = v11;
      __int16 v17 = 1024;
      int v18 = v10;
      __int16 v19 = 1024;
      int v20 = v9 & 1;
      __int16 v21 = 1024;
      int v22 = (v9 >> 2) & 1;
      __int16 v23 = 1024;
      int v24 = (v9 >> 1) & 1;
      __int16 v25 = 1024;
      int v26 = (v9 >> 3) & 1;
      __int16 v27 = 1024;
      int v28 = (v9 >> 4) & 1;
      __int16 v29 = 1024;
      int v30 = (v9 >> 5) & 1;
      __int16 v31 = 1024;
      int v32 = (v9 >> 6) & 1;
      __int16 v33 = 1024;
      unsigned int v34 = v9 >> 7;
      __int16 v35 = 1024;
      int v36 = a3;
      __int16 v37 = 1024;
      int v38 = a4;
      _os_log_error_impl(&dword_182B90000, (os_log_t)off_1ECE0A640, OS_LOG_TYPE_ERROR, "*** %{public}s, break on '_CFMachPortDeallocationFailure' to debug: {p:%{private}d c:%d is:%d <i:%d,d:%d> s:%d,r:%d nsi:%d,nss:%d,nsr:%d - ic:%d,ip:%d}", (uint8_t *)&v13, 0x54u);
    }
  }
  else if (v8)
  {
    _cfmp_log_failure_cold_1(a1, a3, a4);
  }
  return _CFMachPortDeallocationFailure();
}

void _cfmp_source_record_deadness(int a1, int a2)
{
  uint64_t v7 = *(void *)off_1ECE0A5B0;
  if (_cfmp_records_oGuard != -1) {
    dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
  }
  CFSetRef v4 = (const __CFSet *)_cfmp_records_oRecords;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
  v6[0] = a2;
  v6[1] = a1;
  uint64_t Value = CFSetGetValue(v4, v6);
  if (Value) {
    Value[5] &= ~0x10u;
  }
  else {
    _cfmp_log_failure((uint64_t)"received deadname notification for untracked port", 0, a1, a2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
}

void _cfmp_record_nsmachport_deallocation(int a1, unsigned int a2, int a3, int a4)
{
  uint64_t v17 = *(void *)off_1ECE0A5B0;
  if (a2)
  {
    char v4 = a4;
    char v5 = a3;
    if (a4 | a3)
    {
      unsigned int v6 = a2;
      if (_cfmp_records_oGuard != -1) {
        dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
      }
      CFSetRef v8 = (const __CFSet *)_cfmp_records_oRecords;
      os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
      v16[0] = v6;
      v16[1] = a1;
      uint64_t Value = (int *)CFSetGetValue(v8, v16);
      if (Value)
      {
        char v10 = *((unsigned char *)Value + 5);
        if ((v10 & 0x20) == 0)
        {
          _cfmp_log_failure((uint64_t)"setting nsport state - when its not interested", Value, a1, v6);
LABEL_11:
          os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
          return;
        }
        if ((*((unsigned char *)Value + 5) & 4) == 0)
        {
          *((unsigned char *)Value + 5) = ((v5 & 1) << 6) | v10 & 0x3F | (v4 << 7) | 2;
          goto LABEL_11;
        }
        unsigned int v6 = *Value;
        uint64_t v14 = *((unsigned __int8 *)Value + 4);
        unsigned __int8 v13 = v10 & 0x3F | ((v5 & 1) << 6) | (v4 << 7);
        uint64_t v15 = *((unsigned __int16 *)Value + 3);
        CFSetRemoveValue(v8, Value);
        uint64_t v12 = v15 << 48;
        uint64_t v11 = v14 << 32;
      }
      else
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        unsigned __int8 v13 = (v4 << 7) | ((v5 & 1) << 6) | 0x20;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
      _cfmp_cleanup(v11 | v6 | v12 | ((unint64_t)v13 << 40));
    }
  }
}

CFStringRef _cfmp_copy_description(unsigned int *a1)
{
  if (!a1) {
    return @"{null}";
  }
  unsigned int v1 = *((unsigned __int8 *)a1 + 5);
  return CFStringCreateWithFormat(0, 0, @"{p:%d c:%d is:%d <i:%d,d:%d> s:%d,r:%d nsi:%d,nss:%d,nsr:%d}", *a1, *((unsigned __int8 *)a1 + 4), v1 & 1, (v1 >> 2) & 1, (v1 >> 1) & 1, (v1 >> 3) & 1, (v1 >> 4) & 1, (v1 >> 5) & 1, (v1 >> 6) & 1, v1 >> 7);
}

uint64_t (**__CFStringEncodingGetLatinSuppConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_1)
  {
    __CFStringEncodingPrecomposeLatinCharacter_1 = (_UNKNOWN *)a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_0 = (_UNKNOWN *)a2(3);
  }
  if (a1 > 1029)
  {
    if (a1 > 1286)
    {
      switch(a1)
      {
        case 1287:
          return __CFConverterWindowsBalticRim;
        case 2564:
          return __CFConverterMacRomanLatin1;
        case 2817:
          return __CFConverterNextStepLatin_0;
      }
    }
    else
    {
      switch(a1)
      {
        case 1030:
          return __CFConverterDOSBalticRim;
        case 1040:
          return __CFConverterDOSLatin1;
        case 1046:
          return __CFConverterDOSIcelandic;
      }
    }
    return 0;
  }
  uint64_t result = __CFConverterISOLatin6;
  switch(a1)
  {
    case 522:
      return result;
    case 523:
    case 524:
      return 0;
    case 525:
      return __CFConverterISOLatin7;
    case 526:
      return __CFConverterISOLatin8;
    case 527:
      return __CFConverterISOLatin9;
    default:
      if (a1 == 37)
      {
        uint64_t result = __CFConverterMacIcelandic;
      }
      else
      {
        if (a1 != 1024) {
          return 0;
        }
        uint64_t result = __CFConverterDOSLatinUS;
      }
      break;
  }
  return result;
}

uint64_t __CFToISOLatin6(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8214 < 0xFFFFE091) {
    return 0;
  }
  char v5 = (unsigned __int16 *)&ISOLatin6_from_uni;
  unsigned int v6 = (unsigned __int16 *)&unk_182D9EED0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    CFSetRef v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    unsigned int v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    char v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromISOLatin6(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    LOWORD(a2) = ISOLatin6_to_uni[a2 - 161];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin6Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 8214) >= 0xE091u)
    {
      uint64_t v11 = (unsigned __int16 *)&ISOLatin6_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182D9EED0;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFIsValidCombiningCharacterForLatinSupp(int a1)
{
  if ((a1 - 768) > 0x5F) {
    return 0;
  }
  else {
    return (__CFLatinSuppCombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t __CFToISOLatin7(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  uint64_t result = 0;
  if (a2 != 161 && a2 <= 0x201E)
  {
    char v5 = (unsigned __int16 *)&ISOLatin7_from_uni;
    unsigned int v6 = (unsigned __int16 *)&unk_182D9F118;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      CFSetRef v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        char v5 = v8 + 2;
      }
      else
      {
        unsigned int v6 = v8 - 2;
      }
      if (v5 > v6) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t __CFFromISOLatin7(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    LOWORD(a2) = ISOLatin7_to_uni[a2 - 161];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin7Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA0)
  {
    if (v9 != 161 && v9 <= 0x201E)
    {
      uint64_t v12 = (unsigned __int16 *)&ISOLatin7_from_uni;
      uint64_t v13 = (unsigned __int16 *)&unk_182D9F118;
      while (1)
      {
        uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
        unsigned int v15 = &v12[2 * v14];
        unsigned int v16 = *v15;
        if (v16 <= v9)
        {
          if (v16 >= v9)
          {
            LOBYTE(v9) = v12[2 * v14 + 1];
            goto LABEL_2;
          }
          uint64_t v12 = v15 + 2;
        }
        else
        {
          uint64_t v13 = v15 - 2;
        }
        if (v12 > v13) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToISOLatin8(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 7924 < 0xFFFFE1AF) {
    return 0;
  }
  char v5 = (unsigned __int16 *)&ISOLatin8_from_uni;
  unsigned int v6 = (unsigned __int16 *)&unk_182D9F352;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    CFSetRef v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    unsigned int v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    char v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromISOLatin8(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    LOWORD(a2) = ISOLatin8_to_uni[a2 - 161];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin8Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 7924) >= 0xE1AFu)
    {
      uint64_t v11 = (unsigned __int16 *)&ISOLatin8_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_182D9F352;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          uint64_t v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToISOLatin9(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xA3)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  uint64_t result = 0;
  if (a2 != 164 && a2 <= 0x20AC)
  {
    char v5 = (unsigned __int16 *)&ISOLatin9_from_uni;
    unsigned int v6 = (unsigned __int16 *)&unk_182D9F580;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      CFSetRef v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        char v5 = v8 + 2;
      }
      else
      {
        unsigned int v6 = v8 - 2;
      }
      if (v5 > v6) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t __CFFromISOLatin9(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA3) {
    LOWORD(a2) = ISOLatin9_to_uni[a2 - 164];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin9Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA3)
  {
    if (v9 != 164 && v9 <= 0x20AC)
    {
      uint64_t v12 = (unsigned __int16 *)&ISOLatin9_from_uni;
      uint64_t v13 = (unsigned __int16 *)&unk_182D9F580;
      while (1)
      {
        uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
        unsigned int v15 = &v12[2 * v14];
        unsigned int v16 = *v15;
        if (v16 <= v9)
        {
          if (v16 >= v9)
          {
            LOBYTE(v9) = v12[2 * v14 + 1];
            goto LABEL_2;
          }
          uint64_t v12 = v15 + 2;
        }
        else
        {
          uint64_t v13 = v15 - 2;
        }
        if (v12 > v13) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToMacIcelandic(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      char v4 = (unsigned __int16 *)&MacIcelandic_from_uni;
      char v5 = (unsigned __int16 *)&unk_182D9F838;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          char v4 = v7 + 2;
        }
        else
        {
          char v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

uint64_t __CFFromMacIcelandic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = MacIcelandic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacIcelandicPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0;
    }
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1792) < 0x7A0u) {
    return 0;
  }
  uint64_t v12 = (unsigned __int16 *)&MacIcelandic_from_uni;
  uint64_t v13 = (unsigned __int16 *)&unk_182D9F838;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    uint64_t v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0;
    }
  }
  if (v16 < v9)
  {
    uint64_t v12 = v15 + 2;
    goto LABEL_12;
  }
  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToWindowsBalticRim(uint64_t a1, unsigned int a2, char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 < 0xA8)
  {
LABEL_12:
    if (a2 < 0xA0) {
      return 0;
    }
  }
  else if (a2 <= 0x2122)
  {
    char v5 = (unsigned __int16 *)&WindowsBalticRim_from_uni;
    uint64_t v6 = (unsigned __int16 *)&unk_182D9F998;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      unsigned int v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
LABEL_29:
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        char v5 = v8 + 2;
      }
      else
      {
        uint64_t v6 = v8 - 2;
      }
      if (v5 > v6) {
        goto LABEL_12;
      }
    }
  }
  uint64_t result = 0;
  if ((a2 - 161 > 0x13 || ((1 << (a2 + 95)) & 0x80011) == 0) && a2 != 255)
  {
    if (a2 < 0xA1)
    {
      char v3 = -96;
      goto LABEL_3;
    }
    uint64_t result = 0;
    if (a2 != 161 && a2 <= 0x201E)
    {
      char v5 = (unsigned __int16 *)&ISOLatin7_from_uni;
      int v10 = (unsigned __int16 *)&unk_182D9F118;
      do
      {
        uint64_t v7 = ((char *)v10 - (char *)v5) >> 3;
        uint64_t v11 = &v5[2 * v7];
        unsigned int v12 = *v11;
        if (v12 <= a2)
        {
          if (v12 >= a2) {
            goto LABEL_29;
          }
          char v5 = v11 + 2;
        }
        else
        {
          int v10 = v11 - 2;
        }
        uint64_t result = 0;
      }
      while (v5 <= v10);
    }
  }
  return result;
}

uint64_t __CFFromWindowsBalticRim(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) == 0) {
    goto LABEL_2;
  }
  if (a2 >= 0xA0)
  {
    *a3 = -3;
  }
  else
  {
    *a3 = WindowsBalticRim_to_uni[a2 - 128];
    if (((0x9501150AuLL >> a2) & 1) == 0) {
      return 1;
    }
  }
  if (a2 > 179)
  {
    if (a2 != 180)
    {
      if (a2 != 255)
      {
LABEL_16:
        if (a2 > 0xA0) {
          LOWORD(a2) = ISOLatin7_to_uni[a2 - 161];
        }
        goto LABEL_2;
      }
      LOWORD(a2) = 729;
    }
LABEL_2:
    *a3 = a2;
    return 1;
  }
  uint64_t result = 0;
  if (a2 != 161 && a2 != 165) {
    goto LABEL_16;
  }
  return result;
}

uint64_t __CFToWindowsBalticRimPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  int v10 = __CFToWindowsBalticRim(v9, v9, &v13);
  uint64_t result = 0;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToNextStepLatin_0(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 2) >= 0xA2u)
    {
      char v4 = (unsigned __int16 *)&nextstep_from_tab_0;
      char v5 = (unsigned __int16 *)&unk_182D9FBD8;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          char v4 = v7 + 2;
        }
        else
        {
          char v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromNextStepLatin_0(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = NSToPrecompUnicodeTable_0[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToNextStepLatinPrecompose_0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0;
    }
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 2) < 0xA2u) {
    return 0;
  }
  BOOL v12 = (unsigned __int16 *)&nextstep_from_tab_0;
  char v13 = (unsigned __int16 *)&unk_182D9FBD8;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    char v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0;
    }
  }
  if (v16 < v9)
  {
    BOOL v12 = v15 + 2;
    goto LABEL_12;
  }
  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFStringEncodingIsValidCombiningCharacterForLatin1Wrapper()
{
  return __CFStringEncodingIsValidCombiningCharacterForLatin1_0();
}

uint64_t __CFToMacRomanLatin1(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1277) >= 0x59Du)
    {
      char v4 = (unsigned __int16 *)&MacRomanLatin1_from_uni;
      char v5 = (unsigned __int16 *)&unk_182D9FEE0;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          char v4 = v7 + 2;
        }
        else
        {
          char v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromMacRomanLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = MacRomanLatin1_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacRomanLatin1Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0;
    }
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1277) < 0x59Du) {
    return 0;
  }
  BOOL v12 = (unsigned __int16 *)&MacRomanLatin1_from_uni;
  char v13 = (unsigned __int16 *)&unk_182D9FEE0;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    char v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0;
    }
  }
  if (v16 < v9)
  {
    BOOL v12 = v15 + 2;
    goto LABEL_12;
  }
  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSLatinUS(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  char v5 = (unsigned __int16 *)&DOSLatinUS_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182DA01E0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    char v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSLatinUS(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSLatinUS_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatinUSPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSLatinUS_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182DA01E0;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSLatin1(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  char v5 = (unsigned __int16 *)&DOSLatin1_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182DA04E0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    char v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSLatin1_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatin1Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSLatin1_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182DA04E0;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSBalticRim(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  char v5 = (unsigned __int16 *)&DOSBalticRim_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182DA07E0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    char v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSBalticRim(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSIcelandic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSBalticRimPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSBalticRim_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182DA07E0;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSIcelandic(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  char v5 = (unsigned __int16 *)&DOSIcelandic_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182DA09E0;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    char v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSIcelandic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSIcelandic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSIcelandicPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSIcelandic_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182DA09E0;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(CFAllocatorRef allocator, LangCode lcode, RegionCode rcode)
{
  unsigned int v3 = lcode;
  if (rcode > 0x6C
    || (char v5 = regionCodeToLocaleString[(unsigned __int16)rcode]) == 0
    || !*v5
    || (CFLocaleIdentifier result = CFStringCreateWithCStringNoCopy(allocator, v5, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull)) == 0)
  {
    if (v3 <= 0x97
      && (unint64_t)(unsigned __int16)v3 - 95 >= 0x21
      && (uint64_t v7 = langCodeToLocaleString[(unsigned __int16)v3], *v7))
    {
      return CFStringCreateWithCStringNoCopy(allocator, v7, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const NXArchInfo *_CFBundleCurrentArchitecture()
{
  CFLocaleIdentifier result = NXGetLocalArchInfo();
  if (result) {
    return (const NXArchInfo *)result->cputype;
  }
  return result;
}

__CFArray *_CFBundleDYLDCopyLoadedImagePathsIfChanged()
{
  uint32_t v0 = _dyld_image_count();
  if (v0 != _CFBundleDYLDCopyLoadedImagePathsIfChanged__cachedDYLDImageCount)
  {
    int v2 = v0;
    unsigned int v3 = _CFProcessPath();
    char v4 = _NSGetMachExecuteHeader();
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    if (!v2)
    {
LABEL_37:
      _CFBundleDYLDCopyLoadedImagePathsIfChanged__cachedDYLDImageCFIndex Count = v2;
      return Mutable;
    }
    uint32_t v5 = 0;
    while (1)
    {
      image_mach_port_name_t name = _dyld_get_image_name(v5);
      uint64_t v7 = _CFBundleNormalizedPath(image_name);
      unsigned int v8 = v7;
      unsigned int v9 = 0;
      if (!v5 && v7)
      {
        int v10 = strdup(v7);
        unsigned int v9 = v10;
        if (!v10) {
          goto LABEL_27;
        }
        int64_t v11 = strlen(v10);
        uint64_t v12 = 0;
        if (v11 >= 1)
        {
          for (int64_t i = 0; i < v11; ++i)
          {
            v9[v12] = v9[i];
            while (i < v11 - 1 && v9[i] == 47)
            {
              int v14 = v9[i + 1];
              if (v14 != 47)
              {
                BOOL v15 = v14 == 46 && i < v11 - 2;
                if (!v15 || v9[i + 2] != 47) {
                  break;
                }
              }
              if (v14 == 47) {
                uint64_t v16 = 1;
              }
              else {
                uint64_t v16 = 2;
              }
              i += v16;
            }
            ++v12;
          }
        }
        v9[v12] = 0;
      }
      if (!v8) {
        goto LABEL_34;
      }
LABEL_27:
      if (v3)
      {
        if (!strcmp(v8, v3)) {
          goto LABEL_34;
        }
        if (v9 && !strcmp(v9, v3))
        {
LABEL_35:
          free(v9);
          goto LABEL_36;
        }
      }
      if (v4 != (mach_header_64 *)_dyld_get_image_header(v5))
      {
        CFStringRef v17 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
        if (v17)
        {
          CFStringRef v18 = v17;
          CFArrayAppendValue(Mutable, v17);
          CFRelease(v18);
        }
      }
LABEL_34:
      if (v9) {
        goto LABEL_35;
      }
LABEL_36:
      if (++v5 == v2) {
        goto LABEL_37;
      }
    }
  }
  return 0;
}

uint64_t _CFBundleDlfcnPreflight(unsigned __int8 *a1, CFErrorRef *a2)
{
  uint64_t v31 = *(void *)off_1ECE0A5B0;
  char v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  int v5 = a1[52];
  os_unfair_lock_unlock(v4);
  if (v5) {
    return 1;
  }
  CFURLRef v7 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  CFURLRef v8 = v7;
  if (!v7 || !CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1026))
  {
    if (a2)
    {
      CFAllocatorRef v16 = CFGetAllocator(a1);
      CFErrorRef Error = _CFBundleCreateError(v16, (__CFBundle *)a1, 4);
    }
    else
    {
      CFErrorRef Error = 0;
    }
    goto LABEL_41;
  }
  BOOL v9 = dlopen_preflight((const char *)buffer);
  BOOL v10 = v9;
  CFErrorRef Error = 0;
  if (a2 && !v9)
  {
    CFArrayRef v12 = CFBundleCopyExecutableArchitectures((CFBundleRef)a1);
    uint64_t v13 = dlerror();
    if (v13 && *v13)
    {
      int v14 = (__CFString *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
      if (!v12)
      {
LABEL_10:
        CFAllocatorRef v15 = CFGetAllocator(a1);
        CFErrorRef Error = _CFBundleCreateErrorDebug(v15, (CFBundleRef)a1, 3587, v14);
LABEL_39:
        if (v14) {
          CFRelease(v14);
        }
LABEL_41:
        BOOL v10 = 0;
        uint64_t result = 0;
        if (!v8) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
    }
    else
    {
      int v14 = 0;
      if (!v12) {
        goto LABEL_10;
      }
    }
    CFIndex Count = CFArrayGetCount(v12);
    int valuePtr = 0;
    CFStringRef v18 = NXGetLocalArchInfo();
    if (v18) {
      cpu_type_t cputype = v18->cputype;
    }
    else {
      cpu_type_t cputype = 0;
    }
    if (Count < 1) {
      goto LABEL_31;
    }
    CFIndex v20 = 0;
    do
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v12, v20);
      if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr)) {
        BOOL v22 = valuePtr == cputype;
      }
      else {
        BOOL v22 = 0;
      }
      int v23 = !v22;
      ++v20;
    }
    while (v23 == 1 && v20 < Count);
    if (v23)
    {
LABEL_31:
      CFIndex v25 = 3585;
    }
    else
    {
      int v28 = 0;
      if (_CFBundleGrokObjCImageInfoFromMainExecutable(0, &v28)
        && (v28 & 2) != 0
        && (int v27 = 0, _CFBundleGetObjCImageInfo((__CFBundle *)a1, 0, &v27))
        && (v27 & 2) == 0)
      {
        CFIndex v25 = 3586;
      }
      else
      {
        CFIndex v25 = 3587;
      }
    }
    CFAllocatorRef v26 = CFGetAllocator(a1);
    CFErrorRef Error = _CFBundleCreateErrorDebug(v26, (CFBundleRef)a1, v25, v14);
    CFRelease(v12);
    goto LABEL_39;
  }
LABEL_42:
  CFRelease(v8);
  uint64_t result = v10;
LABEL_43:
  if (a2)
  {
    if (!result) {
      *a2 = Error;
    }
  }
  return result;
}

uint64_t _CFBundleDlfcnLoadFramework(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v28 = *(void *)off_1ECE0A5B0;
  char v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  int v5 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock(v4);
  if (v5) {
    return 1;
  }
  CFTypeRef cf = 0;
  CFURLRef v7 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  CFURLRef v8 = v7;
  if (!v7 || !CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1026))
  {
    CFArrayRef v12 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadFramework_cold_1();
      if (!a2)
      {
LABEL_16:
        uint64_t v6 = 0;
        if (!v8) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }
    }
    else if (!a2)
    {
      goto LABEL_16;
    }
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
    CFTypeRef cf = _CFBundleCreateError(v13, (__CFBundle *)a1, 4);
    goto LABEL_16;
  }
  BOOL v9 = dlopen((const char *)buffer, 265);
  BOOL v10 = _CFBundleLoadingLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138544130;
    uint64_t v20 = a1;
    __int16 v21 = 2082;
    BOOL v22 = buffer;
    __int16 v23 = 1024;
    int v24 = 265;
    __int16 v25 = 2048;
    CFAllocatorRef v26 = v9;
    _os_log_debug_impl(&dword_182B90000, v10, OS_LOG_TYPE_DEBUG, "dlfcn load framework %{public}@, dlopen of %{public}s mode 0x%x returns handle %p", buf, 0x26u);
  }
  os_unfair_lock_lock_with_options();
  if (!v9)
  {
    *(void *)(a1 + 56) = 0;
    os_unfair_lock_unlock(v4);
    int v14 = dlerror();
    CFAllocatorRef v15 = _CFOSLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadFramework_cold_2();
      if (!v14)
      {
LABEL_21:
        if (a2)
        {
          _CFBundleDlfcnPreflight((unsigned __int8 *)a1, (CFErrorRef *)&cf);
          if (!cf)
          {
            CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
            CFTypeRef cf = _CFBundleCreateErrorDebug(v16, (CFBundleRef)a1, 3588, v14);
          }
        }
        if (v14) {
          CFRelease(v14);
        }
        uint64_t v6 = 0;
        goto LABEL_27;
      }
    }
    else if (!v14)
    {
      goto LABEL_21;
    }
    int v14 = (void *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)v14);
    goto LABEL_21;
  }
  if (v9 == *(void **)(a1 + 56))
  {
    int64_t v11 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDlfcnLoadFramework_cold_3();
    }
    os_unfair_lock_unlock(v4);
    dlclose(v9);
    os_unfair_lock_lock_with_options();
  }
  *(void *)(a1 + 56) = v9;
  uint64_t v6 = 1;
  *(unsigned char *)(a1 + 52) = 1;
  os_unfair_lock_unlock(v4);
LABEL_27:
  CFRelease(v8);
LABEL_28:
  if (!a2 || v6)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *a2 = cf;
  }
  return v6;
}

void _CFBundleDlfcnUnload(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 96));
  unsigned int v3 = *(void **)(a1 + 56);
  if (*(unsigned char *)(a1 + 52)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    int v5 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDlfcnUnload_cold_2();
    }
    *(void *)(a1 + 56) = 0;
    *(unsigned char *)(a1 + 52) = 0;
    os_unfair_lock_unlock(v2);
    int v6 = dlclose(v3);
    os_unfair_lock_lock(v2);
    if (v6)
    {
      CFURLRef v7 = _CFBundleLoadingLogger();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        _CFBundleDlfcnUnload_cold_1(a1, v7);
      }
      *(void *)(a1 + 56) = v3;
      *(unsigned char *)(a1 + 52) = 1;
    }
  }
}

void *_CFBundleDlfcnGetSymbolByName(uint64_t a1, const __CFString *a2)
{
  return _CFBundleDlfcnGetSymbolByNameWithSearch(a1, a2, 0);
}

void *_CFBundleGetCFMFunctionPointerForName(__CFBundle *a1, const __CFString *a2)
{
  if (!CFBundleLoadExecutable(a1)) {
    return 0;
  }

  return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)a1, a2, 1);
}

void CFBundleGetFunctionPointersForNames(CFBundleRef bundle, CFArrayRef functionNames, void *ftbl[])
{
  if (ftbl)
  {
    int Count = CFArrayGetCount(functionNames);
    if (Count >= 1)
    {
      CFIndex v7 = 0;
      uint64_t v8 = Count;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(functionNames, v7);
        ftbl[v7++] = CFBundleGetFunctionPointerForName(bundle, ValueAtIndex);
      }
      while (v8 != v7);
    }
  }
}

__CFBundle *_CFBundleGetCFMFunctionPointersForNames(__CFBundle *result, CFArrayRef theArray, uint64_t a3)
{
  if (a3)
  {
    int v5 = result;
    uint64_t result = (__CFBundle *)CFArrayGetCount(theArray);
    if ((int)result >= 1)
    {
      CFIndex v6 = 0;
      uint64_t v7 = result;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v6);
        uint64_t result = (__CFBundle *)_CFBundleGetCFMFunctionPointerForName(v5, ValueAtIndex);
        *(void *)(a3 + 8 * v6++) = result;
      }
      while (v7 != v6);
    }
  }
  return result;
}

void CFBundleGetDataPointersForNames(CFBundleRef bundle, CFArrayRef symbolNames, void *stbl[])
{
  if (stbl)
  {
    int Count = CFArrayGetCount(symbolNames);
    if (Count >= 1)
    {
      CFIndex v7 = 0;
      uint64_t v8 = Count;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(symbolNames, v7);
        stbl[v7++] = CFBundleGetDataPointerForName(bundle, ValueAtIndex);
      }
      while (v8 != v7);
    }
  }
}

void OUTLINED_FUNCTION_0_3(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_2_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

CFStringRef __CFMachPortCopyDescription(uint64_t a1)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    goto LABEL_5;
  }
  unsigned int v3 = *(uint64_t (**)(void))(a1 + 88);
  if (!v3) {
    goto LABEL_5;
  }
  CFStringRef v4 = (CFStringRef)v3();
  if (!v4)
  {
    uint64_t v2 = *(void *)(a1 + 64);
LABEL_5:
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFMachPort context %p>", v2);
  }
  memset(&v12, 0, sizeof(v12));
  int v5 = *(void **)(a1 + 48);
  dli_smach_port_name_t name = "???";
  if (dladdr(v5, &v12))
  {
    if (v12.dli_sname && v12.dli_saddr == v5) {
      dli_smach_port_name_t name = v12.dli_sname;
    }
  }
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  BOOL v9 = "No";
  if (!*(_DWORD *)(a1 + 16)) {
    BOOL v9 = "Yes";
  }
  CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFMachPort %p [%p]>{valid = %s, port = %x, source = %p, callout = %s (%p), context = %@}", a1, v8, v9, *(unsigned int *)(a1 + 20), *(void *)(a1 + 40), dli_sname, v5, v4);
  if (v4) {
    CFRelease(v4);
  }
  return v10;
}

uint64_t _CFMachPortCreateWithPort2(__objc2_class **a1, mach_port_name_t a2, uint64_t a3, long long *a4, unsigned char *a5)
{
  return _CFMachPortCreateWithPort4(a1, a2, a3, a4, a5, 1);
}

uint64_t _CFMachPortCreateWithPort3(__objc2_class **a1, mach_port_name_t a2, uint64_t a3, long long *a4, unsigned char *a5)
{
  return _CFMachPortCreateWithPort4(a1, a2, a3, a4, a5, 0);
}

uint64_t _CFMachPortCreate3(__objc2_class **a1, uint64_t a2, long long *a3, unsigned char *a4)
{
  return _CFMachPortCreate4(a1, a2, a3, a4, 0);
}

void CFMachPortGetContext(CFMachPortRef port, CFMachPortContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)port);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v4 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v4);
  }
  long long v5 = *(_OWORD *)((char *)port + 56);
  long long v6 = *(_OWORD *)((char *)port + 72);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)port + 11);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

CFMachPortInvalidationCallBack CFMachPortGetInvalidationCallBack(CFMachPortRef port)
{
  __CFCheckCFInfoPACSignature((uint64_t)port);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v2 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v2);
  }
  unsigned int v3 = (os_unfair_lock_s *)((char *)port + 96);
  os_unfair_lock_lock((os_unfair_lock_t)port + 24);
  unint64_t v4 = (void (__cdecl *)(CFMachPortRef, void *))*((void *)port + 4);
  os_unfair_lock_unlock(v3);
  return v4;
}

uint64_t CFMachPortGetQueuedMessageCount(uint64_t a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (__CF_FORK_STATE) {
    return 0;
  }
  uint64_t v7 = 0;
  *(_OWORD *)port_info_uuid_t out = 0u;
  long long v6 = 0u;
  mach_msg_type_number_t port_info_outCnt = 10;
  if (mach_port_get_attributes(*(_DWORD *)off_1ECE0A6C8, *(_DWORD *)(a1 + 20), 2, port_info_out, &port_info_outCnt)) {
    return 0;
  }
  else {
    return v6;
  }
}

uint64_t __CFDescribeCFMachPortPerformCallout(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5)
{
  uint64_t v16 = *(void *)off_1ECE0A5B0;
  if (__CFDescribeCFMachPortPerformCallout_onceToken != -1) {
    dispatch_once(&__CFDescribeCFMachPortPerformCallout_onceToken, &__block_literal_global_5);
  }
  CFStringRef v10 = (uint64_t (*)(uint64_t, uint64_t, char *, size_t, char *, size_t))__CFDescribeCFMachPortPerformCallout_foundationDescribeNSMachPortCallout;
  int64_t v11 = *(const void **)(a1 + 48);
  if (__CFDescribeCFMachPortPerformCallout_foundationFireMachPort) {
    BOOL v12 = __CFDescribeCFMachPortPerformCallout_foundationDescribeNSMachPortCallout == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12 && v11 == (const void *)__CFDescribeCFMachPortPerformCallout_foundationFireMachPort)
  {
    return v10(a1, a1 + 56, a2, a3, a4, a5);
  }
  else
  {
    memset(&v15, 0, sizeof(v15));
    uint64_t result = dladdr(v11, &v15);
    if (result)
    {
      snprintf(a4, a5, "(CFMachPort) %s", v15.dli_sname);
      return snprintf(a2, a3, "%s", v15.dli_fname);
    }
  }
  return result;
}

BOOL __CFMachPortCheck(mach_port_name_t name)
{
  kern_return_t v1;
  mach_port_type_t ptype;
  uint64_t v5;

  long long v5 = *(void *)off_1ECE0A5B0;
  mach_port_type_t ptype = 0;
  unsigned int v1 = mach_port_type(*(_DWORD *)off_1ECE0A6C8, name, &ptype);
  return (ptype & 0x70000) != 0 && v1 == 0;
}

void OUTLINED_FUNCTION_0_4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

void __CFMessagePortDeallocate(CFMessagePortRef ms)
{
  unint64_t v2 = atomic_load((unint64_t *)ms + 1);
  unint64_t v3 = v2;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)ms + 1, &v3, v2 | 8);
    BOOL v4 = v3 == v2;
    unint64_t v2 = v3;
  }
  while (!v4);
  CFMessagePortInvalidate(ms);
  long long v5 = (const void *)*((void *)ms + 4);
  if (v5) {
    CFRelease(v5);
  }
  long long v6 = (const void *)*((void *)ms + 2);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (__CFMachPort *)*((void *)ms + 3);
  if (v7)
  {
    mach_port_t Port = CFMachPortGetPort(v7);
    char v9 = atomic_load((unint64_t *)ms + 1);
    _cfmp_record_deallocation(1u, Port, (v9 & 2) != 0, (v9 & 2) != 0);
    CFMachPortInvalidate(*((CFMachPortRef *)ms + 3));
    CFRelease(*((CFTypeRef *)ms + 3));
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (__CFAllRemoteMessagePorts)
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)__CFAllRemoteMessagePorts);
    uint64_t Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0x2004093837F09, 0);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)__CFAllRemoteMessagePorts, 0, Typed);
    if (Count < 1)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      if (!Typed) {
        return;
      }
    }
    else
    {
      BOOL v12 = Typed;
      CFIndex v13 = Count;
      do
      {
        int v14 = *v12++;
        CFRetain(v14);
        --v13;
      }
      while (v13);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      Dl_info v15 = (CFMessagePortRef *)Typed;
      do
      {
        CFMessagePortIsValid(*v15);
        CFMessagePortRef v16 = *v15++;
        CFRelease(v16);
        --Count;
      }
      while (Count);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  }
}

CFStringRef __CFMessagePortCopyDescription(unint64_t *cf)
{
  uint64_t v24 = *(void *)off_1ECE0A5B0;
  unint64_t v2 = cf + 1;
  char v3 = atomic_load(cf + 1);
  if ((v3 & 4) == 0)
  {
    unint64_t v4 = cf[16];
    if (v4)
    {
      long long v5 = (uint64_t (*)(void))cf[19];
      if (v5)
      {
        CFStringRef v6 = (CFStringRef)v5();
        if (v6)
        {
LABEL_7:
          uint64_t v7 = (void *)cf[12];
          if (!v7) {
            uint64_t v7 = (void *)cf[13];
          }
          memset(&v23, 0, sizeof(v23));
          dli_smach_port_name_t name = "???";
          if (dladdr(v7, &v23))
          {
            if (v23.dli_sname && v23.dli_saddr == v7) {
              dli_smach_port_name_t name = v23.dli_sname;
            }
          }
          CFAllocatorRef v10 = CFGetAllocator(cf);
          char v11 = atomic_load(cf + 1);
          if (v11) {
            BOOL v12 = "Yes";
          }
          else {
            BOOL v12 = "No";
          }
          char v13 = atomic_load(cf + 1);
          if ((v13 & 4) != 0) {
            int v14 = "Yes";
          }
          else {
            int v14 = "No";
          }
          Dl_info v15 = @"<no description>";
          if (v6) {
            Dl_info v15 = (__CFString *)v6;
          }
          CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFMessagePort %p [%p]>{locked = %s, valid = %s, remote = %s, name = %@, source = %p, callout = %s (%p), context = %@}", cf, v10, "Maybe", v12, v14, cf[2], cf[7], dli_sname, v7, v15);
          if (v6) {
            CFRelease(v6);
          }
          return v16;
        }
        unint64_t v4 = cf[16];
      }
    }
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFMessagePort context %p>", v4);
    goto LABEL_7;
  }
  CFAllocatorRef v18 = CFGetAllocator(cf);
  char v19 = atomic_load(v2);
  uint64_t v20 = "Yes";
  if (v19) {
    __int16 v21 = "Yes";
  }
  else {
    __int16 v21 = "No";
  }
  char v22 = atomic_load(v2);
  if ((v22 & 4) == 0) {
    uint64_t v20 = "No";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFMessagePort %p [%p]>{locked = %s, valid = %s, remote = %s, mach_port_name_t name = %@}", cf, v18, "Maybe", v21, v20, cf[2]);
}

CFTypeID CFMessagePortGetTypeID(void)
{
  return 35;
}

CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMessagePortRef)__CFMessagePortCreateLocal((__objc2_class **)allocator, name, (uint64_t)callout, (long long *)&context->version, shouldFreeInfo, 0, 0);
}

CFTypeRef __CFMessagePortCreateLocal(__objc2_class **a1, const __CFString *a2, uint64_t a3, long long *a4, unsigned char *a5, int a6, uint64_t a7)
{
  kern_return_t v35;
  kern_return_t v36;
  NSObject *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  kern_return_t inserted;
  int v55;
  NSObject *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  long long v62;
  long long v63;
  uint64_t v64;
  uint64_t (*v65)(uint64_t);
  __CFDictionary *Mutable;
  NSObject *v68;
  const char *v69;
  CFTypeRef cf[2];
  long long v71;
  uint64_t v72;
  mach_port_t special_port[2];
  void *ptr;
  uint8_t buf[4];
  kern_return_t v76;
  __int16 v77;
  kern_return_t v78;
  __int16 v79;
  const char *v80;
  __int16 v81;
  mach_port_t v82;
  __int16 v83;
  void *v84;
  uint64_t v85;

  int v85 = *(void *)off_1ECE0A5B0;
  ptr = 0;
  if (a5) {
    *a5 = 1;
  }
  if (a2) {
    SanitizedStringCFStringRef Name = __CFMessagePortCreateSanitizedStringName(a2, (UInt8 **)&ptr);
  }
  else {
    SanitizedStringCFStringRef Name = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (a6) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = SanitizedStringName == 0;
  }
  int v15 = !v14;
  if (!v14)
  {
    cf[0] = 0;
    if (__CFAllLocalMessagePorts)
    {
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, SanitizedStringName, cf))
      {
        CFRetain(cf[0]);
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
        CFRelease(SanitizedStringName);
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
        if (!CFMessagePortIsValid((CFMessagePortRef)cf[0]))
        {
          CFStringRef v16 = _CFOSLog();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            __CFMessagePortCreateLocal_cold_5(v16, v17, v18, v19, v20, v21, v22, v23);
          }
          CFTypeRef v24 = cf[0];
          goto LABEL_50;
        }
        return cf[0];
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x23uLL, 144, 0);
  if (!Instance)
  {
    if (SanitizedStringName) {
      CFRelease(SanitizedStringName);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    int v38 = _CFOSLog();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      __CFMessagePortCreateLocal_cold_1(v38, v39, v40, v41, v42, v43, v44, v45);
    }
    return 0;
  }
  uint64_t v26 = Instance;
  unint64_t v27 = atomic_load((unint64_t *)(Instance + 8));
  unint64_t v28 = v27;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v28, v27 & 0xFFFFFFFFFFFFFFFELL);
    BOOL v14 = v28 == v27;
    unint64_t v27 = v28;
  }
  while (!v14);
  unint64_t v29 = atomic_load((unint64_t *)(Instance + 8));
  unint64_t v30 = v29;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v30, v29 & 0xFFFFFFFFFFFFFFFDLL);
    BOOL v14 = v30 == v29;
    unint64_t v29 = v30;
  }
  while (!v14);
  unint64_t v31 = atomic_load((unint64_t *)(Instance + 8));
  unint64_t v32 = v31;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(Instance + 8), &v32, v31 & 0xFFFFFFFFFFFFFFFBLL);
    BOOL v14 = v32 == v31;
    unint64_t v31 = v32;
  }
  while (!v14);
  *(_DWORD *)(Instance + 112) = 0;
  *(void *)(Instance + 16) = SanitizedStringName;
  if (a6) {
    *(_DWORD *)(Instance + 44) = getpid();
  }
  *(void *)(v26 + 96) = a3;
  *(void *)(v26 + 104) = a7;
  if (SanitizedStringName)
  {
    *(void *)special_port = 0;
    task_get_special_port(*(_DWORD *)off_1ECE0A6C8, 4, &special_port[1]);
    if (a6 || bootstrap_check_in(special_port[1], (const char *)ptr, special_port))
    {
      cf[0] = 0;
      int v71 = 0u;
      uint64_t v72 = 0;
      cf[1] = (CFTypeRef)v26;
      __int16 v33 = (__CFMachPort *)_CFMachPortCreate3(a1, (uint64_t)__CFMessagePortDummyCallback, (long long *)cf, 0);
      if (!v33)
      {
        char v46 = _CFOSLog();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          __CFMessagePortCreateLocal_cold_4(v46, v47, v48, v49, v50, v51, v52, v53);
        }
        goto LABEL_49;
      }
      unsigned int v34 = v33;
      special_port[0] = CFMachPortGetPort(v33);
      __int16 v35 = bootstrap_register2();
      if (v35)
      {
        int v36 = v35;
        __int16 v37 = _CFOSLog();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          int v69 = bootstrap_strerror(v36);
          *(_DWORD *)buf = 67110146;
          int v76 = v36;
          int v77 = 1024;
          int v78 = v36;
          unsigned __int16 v79 = 2080;
          unsigned int v80 = v69;
          uint64_t v81 = 1024;
          unint64_t v82 = special_port[0];
          int v83 = 2080;
          uint64_t v84 = ptr;
          _os_log_error_impl(&dword_182B90000, v37, OS_LOG_TYPE_ERROR, "*** CFMessagePort: bootstrap_register(): failed %d (0x%x) '%s', port = 0x%x, mach_port_name_t name = '%s'\nSee /usr/include/servers/bootstrap_defs.h for the error codes.", buf, 0x28u);
        }
        CFMachPortInvalidate(v34);
        CFRelease(v34);
LABEL_49:
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
        CFTypeRef v24 = (CFTypeRef)v26;
LABEL_50:
        CFRelease(v24);
        return 0;
      }
    }
    else
    {
      uint64_t inserted = mach_port_insert_right(*(_DWORD *)off_1ECE0A6C8, special_port[0], special_port[0], 0x14u);
      if (inserted)
      {
        CFRange v55 = inserted;
        unsigned int v56 = _CFOSLog();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
          __CFMessagePortCreateLocal_cold_3((int *)special_port, v55, v56);
        }
        mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, special_port[0], 1u, -1);
        goto LABEL_49;
      }
      cf[0] = 0;
      int v71 = 0u;
      uint64_t v72 = 0;
      cf[1] = (CFTypeRef)v26;
      unsigned int v57 = _CFMachPortCreateWithPort3(a1, special_port[0], (uint64_t)__CFMessagePortDummyCallback, (long long *)cf, 0);
      if (!v57)
      {
        unsigned int v68 = _CFOSLog();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
          __CFMessagePortCreateLocal_cold_2((int *)special_port, v68);
        }
        mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, special_port[0], 1u, -1);
        mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, special_port[0]);
        goto LABEL_49;
      }
      unsigned int v34 = (__CFMachPort *)v57;
      unsigned __int16 v58 = atomic_load((unint64_t *)(v26 + 8));
      unsigned int v59 = v58;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v26 + 8), &v59, v58 | 2);
        BOOL v14 = v59 == v58;
        unsigned __int16 v58 = v59;
      }
      while (!v14);
    }
    CFMachPortSetInvalidationCallBack(v34, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
    *(void *)(v26 + 24) = v34;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  char v60 = atomic_load((unint64_t *)(v26 + 8));
  unsigned int v61 = v60;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(v26 + 8), &v61, v60 | 1);
    BOOL v14 = v61 == v60;
    char v60 = v61;
  }
  while (!v14);
  if (a4)
  {
    uint64_t v62 = *a4;
    int v63 = a4[1];
    *(void *)(v26 + 152) = *((void *)a4 + 4);
    *(_OWORD *)(v26 + 136) = v63;
    *(_OWORD *)(v26 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v62;
    unsigned __int16 v64 = *((void *)a4 + 1);
    unsigned __int16 v65 = (uint64_t (*)(uint64_t))*((void *)a4 + 2);
    if (v65) {
      unsigned __int16 v64 = v65(v64);
    }
    *(void *)(v26 + 128) = v64;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (v15)
  {
    cf[0] = 0;
    if (!__CFAllLocalMessagePorts) {
      goto LABEL_70;
    }
    if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, SanitizedStringName, cf))
    {
      CFRetain(cf[0]);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      CFRelease((CFTypeRef)v26);
      return cf[0];
    }
    CFMutableStringRef Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
    if (!__CFAllLocalMessagePorts)
    {
LABEL_70:
      CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
      __CFAllLocalMessagePorts = (uint64_t)Mutable;
    }
    CFDictionaryAddValue(Mutable, SanitizedStringName, (const void *)v26);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (a5) {
    *a5 = 0;
  }
  return (CFTypeRef)v26;
}

CFTypeRef CFMessagePortCreatePerProcessLocal(__objc2_class **a1, const __CFString *a2, uint64_t a3, long long *a4, unsigned char *a5)
{
  return __CFMessagePortCreateLocal(a1, a2, a3, a4, a5, 1, 0);
}

CFTypeRef _CFMessagePortCreateLocalEx(__objc2_class **a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, long long *a6, unsigned char *a7)
{
  return __CFMessagePortCreateLocal(a1, a2, 0, a6, a7, a3, a5);
}

void *CFMessagePortCreatePerProcessRemote(__objc2_class **a1, const __CFString *a2, int a3)
{
  return __CFMessagePortCreateRemote(a1, a2, 1, a3);
}

Boolean CFMessagePortIsRemote(CFMessagePortRef ms)
{
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  unsigned int v3 = atomic_load((unint64_t *)ms + 1);
  return (v3 >> 2) & 1;
}

CFStringRef CFMessagePortGetName(CFMessagePortRef ms)
{
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  return (CFStringRef)*((void *)ms + 2);
}

Boolean CFMessagePortSetName(CFMessagePortRef ms, CFStringRef newName)
{
  kern_return_t v24;
  kern_return_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  mach_port_t Port;
  __CFDictionary *Mutable;
  const void *v38;
  unint64_t v39;
  void *value[2];
  long long v42;
  uint64_t v43;
  mach_port_t special_port[2];
  void *ptr[2];

  ptr[1] = *(void **)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  }
  CFAllocatorRef v5 = CFGetAllocator(ms);
  ptr[0] = 0;
  if (*((_DWORD *)ms + 11)) {
    goto LABEL_14;
  }
  char v6 = atomic_load((unint64_t *)ms + 1);
  if ((v6 & 4) != 0) {
    goto LABEL_14;
  }
  uint64_t v7 = (__objc2_class **)v5;
  SanitizedStringCFStringRef Name = __CFMessagePortCreateSanitizedStringName(newName, (UInt8 **)ptr);
  if (SanitizedStringName)
  {
    CFStringRef v9 = SanitizedStringName;
    os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    value[0] = 0;
    if (__CFAllLocalMessagePorts
      && CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, v9, (const void **)value))
    {
      CFAllocatorRef v10 = (os_unfair_lock_s *)&__CFAllMessagePortsLock;
LABEL_13:
      os_unfair_lock_unlock(v10);
      CFRelease(v9);
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
LABEL_14:
      LOBYTE(SanitizedStringName) = 0;
      return SanitizedStringName;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
    if (*((void *)ms + 8))
    {
      CFLog(7, @"*** CFMessagePort: Unable to SetName on CFMessagePort %p as it already has a dispatch queue associated with itself.", v11, v12, v13, v14, v15, v16, (__int16)ms);
LABEL_12:
      CFAllocatorRef v10 = (os_unfair_lock_s *)((char *)ms + 112);
      goto LABEL_13;
    }
    int v17 = dyld_program_sdk_at_least();
    uint64_t v18 = (const void *)*((void *)ms + 2);
    if (v17)
    {
      if (v18) {
        goto LABEL_12;
      }
    }
    else if (v18)
    {
      if (CFEqual(v18, v9))
      {
        CFRelease(v9);
LABEL_44:
        os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
        LOBYTE(SanitizedStringName) = 1;
        return SanitizedStringName;
      }
      uint64_t v21 = (__CFMachPort **)((char *)ms + 24);
      uint64_t v20 = (__CFMachPort *)*((void *)ms + 3);
      if (*((void *)ms + 2))
      {
        uint64_t v39 = atomic_load((unint64_t *)ms + 1);
        uint64_t v19 = (v39 >> 1) & 1;
      }
      else
      {
        LODWORD(v19) = 0;
      }
LABEL_21:
      *(void *)special_port = 0;
      task_get_special_port(*(_DWORD *)off_1ECE0A6C8, 4, &special_port[1]);
      if (bootstrap_check_in(special_port[1], (const char *__attribute__((__org_typedef(name_t))))ptr[0], special_port)) {
        goto LABEL_22;
      }
      if (mach_port_insert_right(*(_DWORD *)off_1ECE0A6C8, special_port[0], special_port[0], 0x14u))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
        mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, special_port[0], 1u, -1);
        goto LABEL_28;
      }
      value[0] = 0;
      CFIndex v42 = 0u;
      uint64_t v43 = 0;
      value[1] = ms;
      unint64_t v32 = _CFMachPortCreateWithPort3(v7, special_port[0], (uint64_t)__CFMessagePortDummyCallback, (long long *)value, 0);
      uint64_t v23 = (__CFMachPort *)v32;
      __int16 v33 = atomic_load((unint64_t *)ms + 1);
      unsigned int v34 = v33;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)ms + 1, &v34, v33 | 2);
        __int16 v35 = v34 == v33;
        __int16 v33 = v34;
      }
      while (!v35);
      if (!v32)
      {
LABEL_22:
        value[0] = 0;
        CFIndex v42 = 0u;
        uint64_t v43 = 0;
        value[1] = ms;
        uint64_t v22 = (__CFMachPort *)_CFMachPortCreate3(v7, (uint64_t)__CFMessagePortDummyCallback, (long long *)value, 0);
        if (!v22)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
          goto LABEL_28;
        }
        uint64_t v23 = v22;
        special_port[0] = CFMachPortGetPort(v22);
        CFTypeRef v24 = bootstrap_register2();
        if (v24)
        {
          __int16 v25 = v24;
          os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
          bootstrap_strerror(v25);
          CFLog(7, @"*** CFMessagePort: bootstrap_register(): failed %d (0x%x) '%s', port = 0x%x, mach_port_name_t name = '%s'\nSee /usr/include/servers/bootstrap_defs.h for the error codes.", v26, v27, v28, v29, v30, v31, v25);
          CFMachPortInvalidate(v23);
          CFRelease(v23);
LABEL_28:
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
          CFRelease(v9);
          goto LABEL_14;
        }
      }
      CFMachPortSetInvalidationCallBack(v23, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
      *uint64_t v21 = v23;
      if (v20 && v20 != v23)
      {
        if (v19)
        {
          if (*((void *)ms + 8)) {
            CFMessagePortSetName_cold_1();
          }
          mach_port_t Port = CFMachPortGetPort(v20);
          mach_port_mod_refs(*(_DWORD *)off_1ECE0A6C8, Port, 1u, -1);
          mach_port_deallocate(*(_DWORD *)off_1ECE0A6C8, Port);
        }
        CFMachPortInvalidate(v20);
        CFRelease(v20);
      }
      os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      CFMutableStringRef Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
      if (!__CFAllLocalMessagePorts)
      {
        CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
        __CFAllLocalMessagePorts = (uint64_t)Mutable;
      }
      int v38 = (const void *)*((void *)ms + 2);
      if (v38)
      {
        CFDictionaryRemoveValue(Mutable, v38);
        CFRelease(*((CFTypeRef *)ms + 2));
        CFMutableStringRef Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
      }
      *((void *)ms + 2) = v9;
      CFDictionaryAddValue(Mutable, v9, ms);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      goto LABEL_44;
    }
    LODWORD(v19) = 0;
    uint64_t v21 = (__CFMachPort **)((char *)ms + 24);
    uint64_t v20 = (__CFMachPort *)*((void *)ms + 3);
    goto LABEL_21;
  }
  return SanitizedStringName;
}

void __CFMessagePortInvalidationCallBack(int a1, CFMessagePortRef ms)
{
  if (ms) {
    CFMessagePortInvalidate(ms);
  }
}

void CFMessagePortGetContext(CFMessagePortRef ms, CFMessagePortContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  }
  long long v5 = *(_OWORD *)((char *)ms + 120);
  long long v6 = *(_OWORD *)((char *)ms + 136);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)ms + 19);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

void CFMessagePortInvalidate(CFMessagePortRef ms)
{
  if (ms)
  {
    __CFCheckCFInfoPACSignature((uint64_t)ms);
    unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
    if (v2 != 35) {
      _CFAssertMismatchedTypeID(0x23uLL, v2);
    }
    char v3 = atomic_load((unint64_t *)ms + 1);
    if ((v3 & 8) == 0) {
      CFRetain(ms);
    }
    os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
    char v4 = atomic_load((unint64_t *)ms + 1);
    if (v4)
    {
      uint64_t v5 = *((void *)ms + 8);
      if (v5)
      {
        dispatch_source_cancel(*((dispatch_source_t *)ms + 8));
        *((void *)ms + 8) = 0;
        *((void *)ms + 9) = 0;
      }
      long long v6 = (__CFMachPort *)*((void *)ms + 6);
      uint64_t v7 = (__CFRunLoopSource *)*((void *)ms + 7);
      uint64_t v8 = *((void *)ms + 10);
      CFStringRef v9 = (void (*)(CFMessagePortRef, uint64_t))*((void *)ms + 11);
      uint64_t v11 = (const void *)*((void *)ms + 2);
      CFAllocatorRef v10 = (__CFMachPort *)*((void *)ms + 3);
      unint64_t v12 = atomic_load((unint64_t *)ms + 1);
      unint64_t v13 = v12;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)ms + 1, &v13, v12 & 0xFFFFFFFFFFFFFFFELL);
        BOOL v14 = v13 == v12;
        unint64_t v12 = v13;
      }
      while (!v14);
      char v15 = atomic_load((unint64_t *)ms + 1);
      if ((v15 & 4) != 0)
      {
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v16 = *((void *)ms + 16);
        *((void *)ms + 16) = 0;
      }
      *((void *)ms + 3) = 0;
      *((void *)ms + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      *((void *)ms + 6) = 0;
      *((void *)ms + 7) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      if (!*((_DWORD *)ms + 11) && v11)
      {
        char v17 = atomic_load((unint64_t *)ms + 1);
        uint64_t v18 = (v17 & 4) != 0 ? &__CFAllRemoteMessagePorts : &__CFAllLocalMessagePorts;
        if (*v18)
        {
          char v19 = atomic_load((unint64_t *)ms + 1);
          if ((v19 & 4) != 0) {
            uint64_t v20 = &__CFAllRemoteMessagePorts;
          }
          else {
            uint64_t v20 = &__CFAllLocalMessagePorts;
          }
          CFDictionaryRemoveValue((CFMutableDictionaryRef)*v20, v11);
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      if (v9) {
        v9(ms, v16);
      }
      char v21 = atomic_load((unint64_t *)ms + 1);
      if ((v21 & 4) == 0)
      {
        uint64_t v22 = (void (*)(uint64_t))*((void *)ms + 18);
        if (v22) {
          v22(v16);
        }
      }
      if (v7)
      {
        CFRunLoopSourceInvalidate(v7);
        CFRelease(v7);
      }
      if (v6)
      {
        CFMachPortInvalidate(v6);
        CFRelease(v6);
      }
      if (v10)
      {
        mach_port_t Port = CFMachPortGetPort(v10);
        char v24 = atomic_load((unint64_t *)ms + 1);
        if ((v24 & 4) != 0) {
          _cfmp_record_deallocation(1u, Port, 1, 0);
        }
        CFMachPortSetInvalidationCallBack(v10, 0);
        char v25 = atomic_load((unint64_t *)ms + 1);
        _cfmp_record_deallocation(1u, Port, (v25 & 2) != 0, (v25 & 2) != 0);
        CFMachPortInvalidate(v10);
        CFRelease(v10);
      }
      if (v8)
      {
        if (v5) {
          dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
        }
        dispatch_release(v8);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    }
    char v26 = atomic_load((unint64_t *)ms + 1);
    if ((v26 & 8) == 0)
    {
      CFRelease(ms);
    }
  }
}

Boolean CFMessagePortIsValid(CFMessagePortRef ms)
{
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  char v3 = atomic_load((unint64_t *)ms + 1);
  if ((v3 & 1) == 0) {
    return 0;
  }
  CFRetain(ms);
  uint64_t v5 = (__CFMachPort *)*((void *)ms + 3);
  if (v5 && !CFMachPortIsValid(v5) || (long long v6 = (__CFMachPort *)*((void *)ms + 6)) != 0 && !CFMachPortIsValid(v6))
  {
    CFMessagePortInvalidate(ms);
    Boolean v4 = 0;
  }
  else
  {
    Boolean v4 = 1;
  }
  CFRelease(ms);
  return v4;
}

CFMessagePortInvalidationCallBack CFMessagePortGetInvalidationCallBack(CFMessagePortRef ms)
{
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  return (CFMessagePortInvalidationCallBack)*((void *)ms + 11);
}

void CFMessagePortSetInvalidationCallBack(CFMessagePortRef ms, CFMessagePortInvalidationCallBack callout)
{
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v3 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v3 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v3);
  }
  char v4 = atomic_load((unint64_t *)ms + 1);
  if (!callout || (v4 & 1) != 0)
  {
    *((void *)ms + 11) = callout;
  }
  else
  {
    uint64_t v5 = *((void *)ms + 16);
    ((void (*)(CFMessagePortRef, uint64_t))callout)(ms, v5);
  }
}

void __CFMessagePortReplyCallBack(uint64_t a1, int *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = (os_unfair_lock_s *)(a4 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a4 + 112));
  char v14 = atomic_load((unint64_t *)(a4 + 8));
  if ((v14 & 1) == 0) {
    goto LABEL_79;
  }
  if (a3 < 0x18)
  {
LABEL_3:
    LOWORD(v15) = 0;
LABEL_78:
    CFLog(4, @"*** CFMessagePort: dropping corrupt reply Mach message (0b%d%d%d%d%d%d)", v8, v9, v10, v11, v12, v13, v15);
    mach_msg_destroy((mach_msg_header_t *)a2);
    goto LABEL_79;
  }
  int v17 = *a2;
  if (*a2 < 0)
  {
    if (a3 < 0x3C) {
      goto LABEL_3;
    }
    LODWORD(v24) = a2[1];
    if (v24 < 0x3C) {
      goto LABEL_3;
    }
    int v25 = a2[11];
    BOOL v15 = v25 != -252513032 && v25 != -118164752;
    BOOL v27 = a2[6] != 1 || *((unsigned __int8 *)a2 + 39) != 1;
    goto LABEL_56;
  }
  if (a2[5] == 1128680784)
  {
    if (a3 < 0x38) {
      goto LABEL_3;
    }
    unint64_t v18 = 56;
  }
  else
  {
    if (a3 < 0x3C) {
      goto LABEL_3;
    }
    unint64_t v18 = 60;
  }
  unint64_t v24 = a2[1];
  if (v18 > v24) {
    goto LABEL_3;
  }
  if (a2[5] != 1128680784)
  {
    if (a2[11] == -252513032)
    {
      BOOL v15 = 0;
      goto LABEL_54;
    }
    uint64_t v30 = 11;
LABEL_53:
    BOOL v15 = a2[v30] != -118164752;
LABEL_54:
    BOOL v27 = 0;
    if (a2[5] == 1128680784) {
      goto LABEL_55;
    }
LABEL_56:
    unsigned int v31 = 4060;
    goto LABEL_57;
  }
  if (a2[10] != -252513032)
  {
    uint64_t v30 = 10;
    goto LABEL_53;
  }
  BOOL v27 = 0;
  BOOL v15 = 0;
LABEL_55:
  unsigned int v31 = 4056;
LABEL_57:
  BOOL v32 = v31 < v24;
  if (v27 || v31 < v24)
  {
    BOOL v35 = 0;
    int v33 = 0;
    if (v17 < 0) {
      goto LABEL_76;
    }
    goto LABEL_74;
  }
  if (v17 < 0)
  {
    int v33 = a2[14];
    BOOL v36 = (v33 - 1610612737) < 0x9FFFFFFE || a2[10] != v33;
    BOOL v35 = v36;
    goto LABEL_76;
  }
  if (a2[5] == 1128680784)
  {
    int v33 = a2[13];
    if ((v33 - 1610612737) >= 0x9FFFFFFE)
    {
      int v34 = -56;
LABEL_72:
      BOOL v37 = v34 + (int)v24 < v33;
      goto LABEL_73;
    }
  }
  else
  {
    int v33 = a2[14];
    if ((v33 - 1610612737) >= 0x9FFFFFFE)
    {
      int v34 = -60;
      goto LABEL_72;
    }
  }
  BOOL v37 = 1;
LABEL_73:
  BOOL v35 = v37;
LABEL_74:
  if (a2[5] == 1128680784)
  {
    uint64_t v38 = 10;
    goto LABEL_77;
  }
LABEL_76:
  uint64_t v38 = 11;
LABEL_77:
  BOOL v39 = a2[v38 + 2] >= 0;
  if (v27 || v15 || v32 || v35 || v39) {
    goto LABEL_78;
  }
  if (*a2 < 0 || a2[5] != 1128680784) {
    uint64_t v16 = 11;
  }
  else {
    uint64_t v16 = 10;
  }
  int v19 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a4 + 32), (const void *)a2[v16 + 2]);
  int v20 = *a2;
  if (v19)
  {
    if (v20 < 0)
    {
      CFDataRef v28 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(const UInt8 **)(a2 + 7), a2[10]);
      mach_vm_deallocate(*(_DWORD *)off_1ECE0A6C8, *(void *)(a2 + 7), a2[10]);
    }
    else
    {
      uint64_t v21 = 11;
      if (a2[5] == 1128680784) {
        uint64_t v21 = 10;
      }
      uint64_t v22 = (const UInt8 *)&a2[v21 + 4];
      if (&v22[v33] <= (const UInt8 *)a2 + a2[1]) {
        CFDataRef v23 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v22, v33 & ~(v33 >> 31));
      }
      else {
        CFDataRef v23 = (const __CFData *)CFRetain(&__kCFBooleanFalse);
      }
      CFDataRef v28 = v23;
    }
    if (*a2 < 0 || a2[5] != 1128680784) {
      uint64_t v29 = 11;
    }
    else {
      uint64_t v29 = 10;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 32), (const void *)a2[v29 + 2], v28);
    CFRelease(v28);
  }
  else if (v20 < 0)
  {
    mach_vm_deallocate(*(_DWORD *)off_1ECE0A6C8, *(void *)(a2 + 7), a2[10]);
  }
LABEL_79:

  os_unfair_lock_unlock(v7);
}

CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
{
  v15.perforuint64_t m = *(void (__cdecl **)(void *))off_1ECE0A5B0;
  if (local)
  {
    __CFCheckCFInfoPACSignature((uint64_t)local);
    unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)local);
    if (v6 != 35) {
      _CFAssertMismatchedTypeID(0x23uLL, v6);
    }
  }
  if (CFMessagePortIsValid(local))
  {
    char v7 = atomic_load((unint64_t *)local + 1);
    if ((v7 & 4) == 0)
    {
      uint64_t v8 = (os_unfair_lock_s *)((char *)local + 112);
      os_unfair_lock_lock((os_unfair_lock_t)local + 28);
      uint64_t v9 = (__CFRunLoopSource *)*((void *)local + 7);
      if (v9)
      {
        int IsValid = CFRunLoopSourceIsValid(v9);
        CFRunLoopSourceRef v11 = (CFRunLoopSourceRef)*((void *)local + 7);
        if (IsValid)
        {
          if (v11) {
            goto LABEL_17;
          }
        }
        else
        {
          CFRelease(v11);
          *((void *)local + 7) = 0;
        }
      }
      if (*((void *)local + 8)) {
        goto LABEL_12;
      }
      char v13 = atomic_load((unint64_t *)local + 1);
      if (v13)
      {
        v15.CFIndex version = 1;
        v15.info = local;
        v15.CFAllocatorRetainCallBack retain = CFRetain;
        v15.CFArrayReleaseCallBack release = CFRelease;
        v15.equal = 0;
        v15.hash = 0;
        v15.copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))__CFMessagePortCopyDescription;
        v15.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMessagePortGetPort;
        v15.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMessagePortPerform;
        CFRunLoopSourceRef v11 = CFRunLoopSourceCreate(allocator, order, &v15);
        *((void *)local + 7) = v11;
      }
      else
      {
        CFRunLoopSourceRef v11 = (CFRunLoopSourceRef)*((void *)local + 7);
      }
      if (!v11)
      {
LABEL_12:
        uint64_t v12 = 0;
LABEL_18:
        os_unfair_lock_unlock(v8);
        return v12;
      }
LABEL_17:
      uint64_t v12 = (__CFRunLoopSource *)CFRetain(v11);
      goto LABEL_18;
    }
  }
  return 0;
}

__CFMachPort *__CFMessagePortGetPort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(__CFMachPort **)(a1 + 24);
  if (result) {
    goto LABEL_5;
  }
  char v10 = atomic_load((unint64_t *)(a1 + 8));
  if (v10) {
    CFLog(4, @"*** Warning: A local CFMessagePort (%p) is being put in a run loop or dispatch queue, but it has not been named yet, so this will be a no-op and no messages are going to be received, even if named later.", a3, a4, a5, a6, a7, a8, a1);
  }
  uint64_t result = *(__CFMachPort **)(a1 + 24);
  if (result)
  {
LABEL_5:
    return (__CFMachPort *)CFMachPortGetPort(result);
  }
  return result;
}

void CFMessagePortSetDispatchQueue(CFMessagePortRef ms, dispatch_queue_t queue)
{
  uint64_t v37 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature((uint64_t)ms);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  char v12 = atomic_load((unint64_t *)ms + 1);
  if ((v12 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    int v19 = @"*** CFMessagePortSetDispatchQueue(): CFMessagePort is invalid";
LABEL_8:
    CFLog(4, (uint64_t)v19, v13, v14, v15, v16, v17, v18, v33[0]);
    return;
  }
  char v20 = atomic_load((unint64_t *)ms + 1);
  if ((v20 & 4) != 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    int v19 = @"*** CFMessagePortSetDispatchQueue(): CFMessagePort is not a local port, queue cannot be set";
    goto LABEL_8;
  }
  if (*((void *)ms + 7))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    int v19 = @"*** CFMessagePortSetDispatchQueue(): CFMessagePort already has a CFRunLoopSourceRef, queue cannot be set";
    goto LABEL_8;
  }
  uint64_t v22 = (void *)((char *)ms + 64);
  uint64_t v21 = *((void *)ms + 8);
  if (v21)
  {
    dispatch_source_cancel(v21);
    void *v22 = 0;
    *((void *)ms + 9) = 0;
  }
  if (queue)
  {
    unsigned int Port = __CFMessagePortGetPort((uint64_t)ms, v5, v6, v7, v8, v9, v10, v11);
    if (Port)
    {
      unsigned int v30 = Port;
      if (CFMessagePortSetDispatchQueue_once != -1) {
        dispatch_once(&CFMessagePortSetDispatchQueue_once, &__block_literal_global_6);
      }
      unsigned int v31 = dispatch_semaphore_create(0);
      dispatch_retain(v31);
      *((void *)ms + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v31;
      _cfmp_record_intent_to_invalidate(1, v30);
      BOOL v32 = dispatch_source_create((dispatch_source_type_t)off_1ECE0A5F8, v30, 0, (dispatch_queue_t)CFMessagePortSetDispatchQueue_mportQueue);
      handler[0] = off_1ECE0A5A0;
      handler[1] = 0x40000000;
      handler[2] = __CFMessagePortSetDispatchQueue_block_invoke_2;
      handler[3] = &__block_descriptor_tmp_21;
      handler[4] = queue;
      void handler[5] = v32;
      unsigned int v36 = v30;
      handler[6] = v31;
      dispatch_source_set_cancel_handler(v32, handler);
      v33[0] = off_1ECE0A5A0;
      v33[1] = 0x40000000;
      v33[2] = __CFMessagePortSetDispatchQueue_block_invoke_3;
      v33[3] = &__block_descriptor_tmp_23;
      unsigned int v34 = v30;
      v33[4] = ms;
      v33[5] = queue;
      dispatch_source_set_event_handler(v32, v33);
      *((void *)ms + 8) = v32;
      if (v32) {
        goto LABEL_16;
      }
    }
    else if (*v22)
    {
LABEL_16:
      dispatch_retain(queue);
      *((void *)ms + 9) = queue;
      dispatch_resume(*((dispatch_object_t *)ms + 8));
      goto LABEL_19;
    }
    CFLog(4, @"*** CFMessagePortSetDispatchQueue(): dispatch source could not be created", v24, v25, v26, v27, v28, v29, v33[0]);
  }
LABEL_19:
  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
}

dispatch_queue_t __CFMessagePortSetDispatchQueue_block_invoke()
{
  qos_class_t v0 = qos_class_main();
  unsigned int v1 = dispatch_queue_attr_make_with_qos_class(0, v0, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.CFMessagePort", v1);
  CFMessagePortSetDispatchQueue_mportQueue = (uint64_t)result;
  return result;
}

void __CFMessagePortSetDispatchQueue_block_invoke_2(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  _cfmp_source_invalidated(1, *(_DWORD *)(a1 + 56));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
  unint64_t v2 = *(NSObject **)(a1 + 48);

  dispatch_release(v2);
}

void __CFMessagePortSetDispatchQueue_block_invoke_3(uint64_t a1)
{
  mach_msg_return_t v5;
  NSObject *v6;
  uint64_t v7;
  void block[7];

  block[6] = *(void *)off_1ECE0A5B0;
  CFRetain(*(CFTypeRef *)(a1 + 32));
  mach_msg_size_t v2 = 2048;
  uint64_t Typed = (mach_msg_header_t *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2048, 848243402, 0);
  for (Typed->msgh_uint64_t size = 2048; ; Typed->msgh_uint64_t size = v2)
  {
    Typed->mach_msg_bits_t msgh_bits = 0;
    mach_port_t v4 = *(_DWORD *)(a1 + 48);
    Typed->msgh_remote_port = 0;
    Typed->mach_port_t msgh_local_port = v4;
    Typed->msgh_id = 0;
    uint64_t v5 = mach_msg(Typed, 117440518, 0, v2, *(_DWORD *)(a1 + 48), 0, 0);
    if (v5 != 268451844) {
      break;
    }
    mach_msg_size_t v2 = (Typed->msgh_size + 71) & 0xFFFFFFFC;
    uint64_t Typed = (mach_msg_header_t *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, v2, 4290513023, 0, 0);
  }
  if (v5) {
    __break(1u);
  }
  block[0] = off_1ECE0A5A0;
  block[1] = 0x40000000;
  block[2] = __CFMessagePortSetDispatchQueue_block_invoke_4;
  block[3] = &__block_descriptor_tmp_22_0;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v6 = *(NSObject **)(a1 + 40);
  void block[4] = Typed;
  void block[5] = v7;
  dispatch_async(v6, block);
}

void __CFMessagePortSetDispatchQueue_block_invoke_4(uint64_t a1)
{
  mach_msg_return_t v4;
  const void *v5;
  uint64_t vars8;

  mach_msg_size_t v2 = (mach_msg_header_t *)__CFMessagePortPerform(*(int **)(a1 + 32), *(unsigned int *)(*(void *)(a1 + 32) + 4), (const __CFAllocator *)&__kCFAllocatorSystemDefault, *(void *)(a1 + 40));
  if (v2)
  {
    unint64_t v3 = v2;
    mach_port_t v4 = mach_msg(v2, 1, v2->msgh_size, 0, 0, 0, 0);
    __CFMachMessageCheckForAndDestroyUnsentMessage(v4, v3);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3);
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(void **)(a1 + 32));
  uint64_t v5 = *(const void **)(a1 + 40);

  CFRelease(v5);
}

void OUTLINED_FUNCTION_0_5(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

CFTypeID CFNotificationCenterGetTypeID(void)
{
  return 52;
}

CFMutableStringRef _CFXNotificationCenterCopyDebugInfo(uint64_t a1)
{
  v5[6] = *(void *)off_1ECE0A5B0;
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  unint64_t v3 = *(os_unfair_lock_s **)(a1 + 16);
  v5[0] = off_1ECE0A5A0;
  v5[1] = 3221225472;
  uint64_t v5[2] = ___CFXNotificationCenterCopyDebugInfo_block_invoke;
  _OWORD v5[3] = &__block_descriptor_48_e80_v16__0___CFXNotificationRegistration_____CFString__v_vQ_________v_____Q___i_Q__8l;
  void v5[4] = Mutable;
  void v5[5] = a1;
  CFXNotificationRegistrarEnumerate(v3, (uint64_t)v5);
  return Mutable;
}

BOOL _CFXNotificationCenterIsEmpty(uint64_t a1)
{
  return CFXNotificationRegistrarIsEmpty(*(os_unfair_lock_s **)(a1 + 16));
}

void _CFXNotificationGetSuspended(uint64_t a1)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 2) != 0) {
      atomic_load((unint64_t *)(a1 + 8));
    }
    else {
      __break(1u);
    }
  }
}

void CFNotificationCenterSetSuspended(unint64_t *a1, int a2)
{
  __CFCheckCFInfoPACSignature((uint64_t)a1);
  unint64_t v4 = _CFGetNonObjCTypeID(a1);
  if (v4 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    _CFXNotificationSetSuspended((uint64_t)a1, a2 != 0);
  }
}

void CFNotificationCenterIsSuspended(unint64_t *a1)
{
  __CFCheckCFInfoPACSignature((uint64_t)a1);
  unint64_t v2 = _CFGetNonObjCTypeID(a1);
  if (v2 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0) {
    _CFXNotificationGetSuspended((uint64_t)a1);
  }
}

uint64_t ___registerSubNotifications_block_invoke(uint64_t a1)
{
  uint64_t v5 = *(uint64_t (**)(CFNotificationCenterRef, void, uint64_t, void, void))(*(void *)(a1 + 32) + 24);
  CFNotificationCenterRef DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  uint64_t v3 = *(void *)(a1 + 40);

  return v5(DarwinNotifyCenter, 0, v3, 0, 0);
}

CFStringRef __CFNumberCreateFormattingDescription(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if ((a2 & 0x8000000000000000) == 0) {
    goto LABEL_12;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)off_1ECE0A6F0;
  if ((~a2 & 0xC000000000000007) == 0) {
    uint64_t v4 = 0;
  }
  unint64_t v5 = v4 ^ a2;
  unint64_t v6 = v5 & 7;
  while (v6 != *((unsigned __int8 *)off_1ECE0A6E0 + v3))
  {
    if (++v3 == 7) {
      goto LABEL_12;
    }
  }
  if (v3 == 3)
  {
    uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7) {
      uint64_t v7 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v8 = v7 & (v5 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(a2 + 8));
  }
  if ((__CFNumberTypeTable[__CFNumberCanonicalTypes[v8 & 7]] & 0x20) != 0)
  {
    return __CFNumberCreateFormattingDescriptionAsFloat64(a1, (CFNumberRef)a2);
  }
  else
  {
    v10[0] = 0;
    v10[1] = 0;
    __CFNumberGetValue(a2, 17, (uint64_t)v10);
    emit128(v11, v10, 0);
    return CFStringCreateWithFormat(a1, 0, @"%s", v11);
  }
}

double _CFNumberInitBool(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  char v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 7, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt8(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  char v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 7, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt8(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  char v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 7, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt16(uint64_t a1, __int16 a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  __int16 v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 8, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt16(uint64_t a1, __int16 a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  __int16 v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 8, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt32(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  int v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 9, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt32(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  int v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 9, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt(uint64_t a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 10, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt(uint64_t a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 10, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt64(uint64_t a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 11, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt64(uint64_t a1, uint64_t a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 11, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitFloat(uint64_t a1, float a2)
{
  uint64_t v4 = *(void *)off_1ECE0A5B0;
  float v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 12, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitDouble(uint64_t a1, double a2)
{
  v3[1] = *(void *)off_1ECE0A5B0;
  *(double *)float v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 13, (char *)v3).n128_u64[0];
  return result;
}

CFStringRef __CFNumberFormatterCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFNumberFormatter %p [%p]>", a1, v3);
}

CFTypeID CFNumberFormatterGetTypeID(void)
{
  return 57;
}

CFNumberFormatterStyle CFNumberFormatterGetStyle(CFNumberFormatterRef formatter)
{
  __CFCheckCFInfoPACSignature((uint64_t)formatter);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  return *((void *)formatter + 4);
}

Boolean CFNumberFormatterGetDecimalInfoForCurrencyCode(CFStringRef currencyCode, int32_t *defaultFractionDigits, double *roundingIncrement)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  v9.CFIndex location = 0;
  v9.CFIndex length = 3;
  CFStringGetCharacters(currencyCode, v9, buffer);
  buffer[3] = 0;
  int v6 = 0;
  if (defaultFractionDigits) {
    *defaultFractionDigits = __cficu_ucurr_getDefaultFractionDigits(buffer, &v6);
  }
  if (roundingIncrement) {
    *roundingIncrement = __cficu_ucurr_getRoundingIncrement(buffer, &v6);
  }
  if (v6 > 0) {
    return 0;
  }
  if (!defaultFractionDigits)
  {
    if (!roundingIncrement) {
      return 1;
    }
    return *roundingIncrement >= 0.0;
  }
  Boolean result = *defaultFractionDigits >= 0;
  if (roundingIncrement && (*defaultFractionDigits & 0x80000000) == 0) {
    return *roundingIncrement >= 0.0;
  }
  return result;
}

void __CFNumberFormatterApplySymbolPrefs(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      Intuint64_t Value = CFStringGetIntValue(a1);
      HIDWORD(v17) = 0;
      CFIndex Length = CFStringGetLength(a2);
      if (Length < 1)
      {
        __cficu_unum_setSymbol(*(void *)(a3 + 16), IntValue, &word_183035FE4, 0, (int *)&v17 + 1);
      }
      else
      {
        uint64_t v11 = Length;
        if (Length >= 768) {
          CFIndex v12 = 768;
        }
        else {
          CFIndex v12 = Length;
        }
        MEMORY[0x1F4188790](Length, v10);
        uint64_t v14 = (UniChar *)((char *)&v17 - v13);
        CFStringRef CharactersPtr = CFStringGetCharactersPtr(a2);
        if (CharactersPtr)
        {
          uint64_t v16 = (UChar *)CharactersPtr;
        }
        else
        {
          v19.CFIndex location = 0;
          v19.CFIndex length = v12;
          CFStringGetCharacters(a2, v19, v14);
          uint64_t v11 = v12;
          uint64_t v16 = v14;
        }
        __cficu_unum_setSymbol(*(void *)(a3 + 16), IntValue, v16, v11, (int *)&v17 + 1);
      }
    }
  }
}

void sub_182CC8F84(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void mutateError(SEL sel, uint64_t a2, void *a3)
{
  if (a2 != 3)
  {
    if (a2 != 2)
    {
      if (a2 == 1)
      {
        CFStringRef Name = sel_getName(sel);
        _CFThrowFormattedException(@"NSInvalidArgumentException", @"Attempt to mutate immutable object with %s", Name);
      }
      unint64_t v5 = sel_getName(sel);
      Class Class = object_getClass(a3);
      _CFThrowFormattedException(@"NSInvalidArgumentException", @"Can't call %s in %@", v5, Class);
    }
    uint64_t v7 = __CFExceptionProem((objc_class *)a3, sel);
    _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: nil argument", v7);
  }
  uint64_t v6 = __CFExceptionProem((objc_class *)a3, sel);
  _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: Range or index out of bounds", v6);
}

void mutateError2(SEL sel, uint64_t a2, void *a3)
{
  if (a2 != 3)
  {
    if (a2 != 2)
    {
      if (a2 == 1)
      {
        CFStringRef Name = sel_getName(sel);
        _CFThrowFormattedException(@"NSInvalidArgumentException", @"Attempt to mutate immutable object with %s", Name);
      }
      unint64_t v5 = sel_getName(sel);
      Class Class = object_getClass(a3);
      _CFThrowFormattedException(@"NSInvalidArgumentException", @"Can't call %s in %@", v5, Class);
    }
    uint64_t v7 = __CFExceptionProem((objc_class *)a3, sel);
    _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: nil argument", v7);
  }
  uint64_t v6 = __CFExceptionProem((objc_class *)a3, sel);
  _CFThrowFormattedException(@"NSInvalidArgumentException", @"%@: Range or index out of bounds", v6);
}

void *__CFFireTimer(void *a1, uint64_t a2)
{
  CFAllocatorRef v3 = *(void **)(a2 + 8);
  uint64_t v4 = *(const char **)(a2 + 16);
  unint64_t v5 = (void *)_CFAutoreleasePoolPush();
  id v6 = a1;
  id v7 = v3;
  objc_msgSend(v3, v4, a1);

  return _CFAutoreleasePoolPop(v5);
}

uint64_t __CFDescribeTimer(uint64_t a1, uint64_t a2, char *a3, size_t a4, char *a5, size_t a6, uint64_t *a7)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  CFIndex v12 = *(void **)(a2 + 8);
  uint64_t v13 = *(const char **)(a2 + 16);
  ClassCFStringRef Name = object_getClassName(v12);
  CFStringRef Name = sel_getName(v13);
  if (a7) {
    *a7 = object_getMethodImplementation();
  }
  uint64_t v16 = "<unknown name>";
  if (ClassName) {
    uint64_t v16 = ClassName;
  }
  uint64_t v17 = "<unknown selector>";
  if (Name) {
    uint64_t v17 = Name;
  }
  snprintf(a5, a6, "(CFTimer) %s %s", v16, v17);
  Class Class = object_getClass(v12);
  memset(&v21, 0, sizeof(v21));
  uint64_t result = dladdr(Class, &v21);
  if (result)
  {
    dli_fmach_port_name_t name = v21.dli_fname;
    if (!v21.dli_fname) {
      dli_fmach_port_name_t name = "<unknown library>";
    }
    return snprintf(a3, a4, "%s", dli_fname);
  }
  return result;
}

atomic_uint *_timerRetain(atomic_uint *result)
{
  return result;
}

atomic_uint *_timerRelease(atomic_uint *result)
{
  if ((int)atomic_fetch_add(result, 0xFFFFFFFF) <= 1)
  {
    unsigned int v1 = (id *)result;
    unint64_t v2 = (void *)_CFAutoreleasePoolPush();

    free(v1);
    return (atomic_uint *)_CFAutoreleasePoolPop(v2);
  }
  return result;
}

void _inputStreamCallbackFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = (id)[a3 retainedDelegate];
  if (objc_opt_respondsToSelector()) {
    [v5 stream:a1 handleEvent:a2];
  }
}

void mergeFunc(uint64_t a1, const __CFDictionary *cf, os_unfair_lock_s *a3)
{
  if (CFGetTypeID(cf) == 18)
  {
    uint64_t Value = CFDictionaryGetValue(cf, @"NSUserDefaultsDefaultValue");
    if (Value)
    {
      -[CFPrefsSource setValue:forKey:from:](a3, (uint64_t)Value, a1, 0);
    }
  }
}

uint64_t remoteStoreChanged(void *a1)
{
  v2[5] = *(void *)off_1ECE0A5B0;
  v2[0] = off_1ECE0A5A0;
  v2[1] = 3221225472;
  size_t v2[2] = __remoteStoreChanged_block_invoke;
  v2[3] = &unk_1ECDB0298;
  v2[4] = a1;
  return [a1 lockedAsync:v2];
}

void sub_182CCB558(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int buf, long long a16, id a17)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  if (a2 == 2)
  {
    id v18 = objc_begin_catch(a1);
    CFRange v19 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *(void *)(v17 + 48);
      buf = 138543874;
      WORD2(a16) = 2114;
      *(void *)((char *)&a16 + 6) = v20;
      HIWORD(a16) = 2114;
      a17 = v18;
      _os_log_error_impl(&dword_182B90000, v19, OS_LOG_TYPE_ERROR, "writing key %{public}@ in cloud domain %{public}@ failed with exception %{public}@", (uint8_t *)&buf, 0x20u);
    }
    objc_end_catch();
  }
  else
  {
    objc_begin_catch(a1);
  }
  JUMPOUT(0x182CCB504);
}

uint64_t __remoteStoreChanged_block_invoke(uint64_t a1)
{
  unsigned int v1 = (id *)(a1 + 32);
  [*(id *)(*(void *)(a1 + 32) + 152) synchronizeForced:1];
  unint64_t v2 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
    __remoteStoreChanged_block_invoke_cold_1(v1, v2);
  }
  [*v1 updateShmemEntry];
  return [*v1 asyncNotifyObserversOfWriteFromConnection:0 message:0];
}

void *initSYDRemotePreferencesSource()
{
  if (SyncedDefaultsLibrary_frameworkLibrary
    || (uint64_t result = dlopen("/System/Library/PrivateFrameworks/SyncedDefaults.framework/SyncedDefaults", 2),
        (SyncedDefaultsLibrary_frameworkLibrary = (uint64_t)result) != 0))
  {
    uint64_t result = objc_getClass("SYDRemotePreferencesSource");
    classSYDRemotePreferencesSource = (uint64_t)result;
    getSYDRemotePreferencesSourceClass Class = SYDRemotePreferencesSourceFunction;
  }
  return result;
}

uint64_t SYDRemotePreferencesSourceFunction()
{
  return classSYDRemotePreferencesSource;
}

void sub_182CCBDBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const char *PROEM_CLS()
{
  qos_class_t v0 = (objc_class *)objc_opt_class();
  if (!v0) {
    return "(null class)";
  }

  return class_getName(v0);
}

const char *PROEM_SEL(const char *a1)
{
  if (a1) {
    return sel_getName(a1);
  }
  else {
    return "(null selector)";
  }
}

double __os_log_helper_1_2_5_8_32_8_32_8_0_8_32_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)&double result = 136316162;
  *(_DWORD *)a1 = 136316162;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2080;
  *(void *)(a1 + 34) = a5;
  *(_WORD *)(a1 + 42) = 2048;
  *(void *)(a1 + 44) = a6;
  return result;
}

uint64_t (**(*CFStringEncodingConverterFindBootstrap(int a1))(int a1, uint64_t (*a2)(uint64_t)))()
{
  unsigned int v1 = __CFStringEncodingGetArabicConverterDefinition;
  if (a1 > 1039)
  {
    if (a1 <= 2111)
    {
      switch(a1)
      {
        case 1040:
        case 1046:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 1041:
        case 1043:
        case 1045:
        case 1047:
        case 1048:
        case 1049:
        case 1050:
        case 1052:
        case 1054:
        case 1055:
        case 1057:
          return 0;
        case 1042:
          return __CFStringEncodingGetLatin2ConverterDefinition;
        case 1044:
          return __CFStringEncodingGetLatin5ConverterDefinition;
        case 1051:
          return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetCyrillicConverterDefinition;
        case 1053:
          return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetThaiConverterDefinition;
        case 1056:
          return __CFStringEncodingGetJapaneseConverterDefinition;
        case 1058:
          return __CFStringEncodingGetKoreanConverterDefinition;
        default:
          JUMPOUT(0);
      }
    }
    if (a1 > 2367)
    {
      if ((a1 - 3056) <= 4 && a1 != 3059) {
        return __CFStringEncodingGetJapaneseConverterDefinition;
      }
      if (a1 != 2368) {
        return 0;
      }
    }
    else if (a1 != 2112)
    {
      if (a1 != 2336)
      {
        if (a1 != 2352) {
          return 0;
        }
        return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
      }
      return __CFStringEncodingGetJapaneseConverterDefinition;
    }
    return __CFStringEncodingGetKoreanConverterDefinition;
  }
  if (a1 <= 151)
  {
    switch(a1)
    {
      case 21:
        return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetThaiConverterDefinition;
      case 22:
      case 23:
      case 24:
      case 26:
      case 27:
      case 28:
      case 30:
      case 31:
      case 32:
        return 0;
      case 25:
        return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
      case 29:
      case 36:
      case 38:
        return __CFStringEncodingGetLatin2ConverterDefinition;
      case 33:
      case 34:
        return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetSymbolConverterDefinition;
      case 35:
        return __CFStringEncodingGetLatin5ConverterDefinition;
      case 37:
        return __CFStringEncodingGetLatinSuppConverterDefinition;
      default:
        switch(a1)
        {
          case 1:
            return __CFStringEncodingGetJapaneseConverterDefinition;
          case 2:
            return __CFStringEncodingGetTraditionalChineseConverterDefinition;
          case 3:
            return __CFStringEncodingGetKoreanConverterDefinition;
          case 6:
            return __CFStringEncodingGetGreekConverterDefinition;
          case 7:
            return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetCyrillicConverterDefinition;
          default:
            return 0;
        }
    }
  }
  if (a1 > 1023)
  {
    if (a1 != 1024)
    {
      if (a1 == 1029) {
        return __CFStringEncodingGetGreekConverterDefinition;
      }
      if (a1 != 1030) {
        return 0;
      }
    }
    return __CFStringEncodingGetLatinSuppConverterDefinition;
  }
  switch(a1)
  {
    case 514:
      return __CFStringEncodingGetLatin2ConverterDefinition;
    case 515:
    case 516:
    case 524:
      return 0;
    case 517:
      return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetCyrillicConverterDefinition;
    case 518:
      return v1;
    case 519:
      return __CFStringEncodingGetGreekConverterDefinition;
    case 520:
      return __CFStringEncodingGetHebrewConverterDefinition;
    case 521:
      return __CFStringEncodingGetLatin5ConverterDefinition;
    case 522:
    case 525:
    case 526:
    case 527:
      return __CFStringEncodingGetLatinSuppConverterDefinition;
    case 523:
      return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetThaiConverterDefinition;
    default:
      if (a1 == 152) {
        return (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetCyrillicConverterDefinition;
      }
      return 0;
  }
  return v1;
}

char **_CFArgv()
{
  return *_NSGetArgv();
}

uint64_t _CFArgc()
{
  return *_NSGetArgc();
}

BOOL _CFIsMainThread()
{
  return pthread_main_np() == 1;
}

CFStringRef _CFStringCreateHostName()
{
  uint64_t v2 = *(void *)off_1ECE0A5B0;
  if (gethostname(cStr, 0x101uLL)) {
    cStr[0] = 0;
  }
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr, 0x8000100u);
}

CFStringRef CFCopyFullUserName()
{
  uint64_t v5 = *(void *)off_1ECE0A5B0;
  uid_t v4 = 0;
  __CFGetUGIDs(&v4, 0);
  uid_t v0 = v4;
  if (!v4) {
    uid_t v0 = getuid();
  }
  unsigned int v1 = getpwuid(v0);
  if (!v1) {
    return (CFStringRef)CFRetain(&stru_1ECE10768);
  }
  pw_gecos = v1->pw_gecos;
  if (!pw_gecos) {
    return (CFStringRef)CFRetain(&stru_1ECE10768);
  }
  CFStringRef result = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_gecos, 0x8000100u);
  if (!result) {
    return (CFStringRef)CFRetain(&stru_1ECE10768);
  }
  return result;
}

CFURLRef CFCopyHomeDirectoryURL(void)
{
  return (CFURLRef)_CFCopyHomeDirURLForUser(0, 1);
}

BOOL _CFRSCompatible()
{
  return dyld_get_active_platform() == 2;
}

void __CFTSDInitialize()
{
  if (__CFTSDInitialize_once != -1) {
    dispatch_once(&__CFTSDInitialize_once, &__block_literal_global_11);
  }
}

uint64_t (*CFStringEncodingGetAddressForSelector(unsigned int a1))()
{
  if (a1 > 4) {
    return 0;
  }
  else {
    return off_1ECE0FE40[a1];
  }
}

uint64_t CFStringEncodingIsDecomposableCharacter(unsigned int a1)
{
  if (a1 >= 0x80) {
    return CFUniCharIsMemberOf(a1, 0x65u);
  }
  else {
    return 0;
  }
}

uint64_t CFStringEncodingDecomposeCharacter(char a1, unsigned __int16 a2, unsigned int *a3)
{
  uint64_t v6 = *(void *)off_1ECE0A5B0;
  unsigned __int16 v5 = a2;
  uint64_t v4 = 0;
  CFUniCharDecompose(&v5, 1, 0, a3, 10, &v4, 0, 0, a1 < 0);
  return v4;
}

uint64_t (**__CFStringEncodingGetExternalConverter(uint64_t a1))()
{
  if (WORD1(a1) || (Bootstrap = CFStringEncodingConverterFindBootstrap(a1)) == 0)
  {
    if (__CFStringEncodingGetICUName(a1)) {
      return (uint64_t (**)())&__CFICUBootstrap;
    }
    else {
      return 0;
    }
  }
  else
  {
    return Bootstrap(a1, (uint64_t (*)(uint64_t))CFStringEncodingGetAddressForSelector);
  }
}

uint64_t __CFStringEncodingCreateListOfAvailablePlatformConverters(uint64_t a1, void *a2)
{
  uint64_t result = CFAllocatorAllocateTyped(a1, 220, 0x100004052888210, 0);
  for (uint64_t i = 0; i != 55; ++i)
    *(_DWORD *)(result + 4 * i) = __CFStringEncodingDylibConveters[i];
  *a2 = 55;
  return result;
}

uint64_t __CFStringEncodingPlatformUnicodeToBytes()
{
  return 3;
}

uint64_t __CFStringEncodingPlatformBytesToUnicode()
{
  return 3;
}

uint64_t __CFStringEncodingPlatformCharLengthForBytes()
{
  return 0;
}

uint64_t __CFStringEncodingPlatformByteLengthForCharacters()
{
  return 0;
}

uint64_t __CFCalendarEqual(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

id __CFCalendarCopyDescription(void *a1)
{
  unsigned int v1 = (void *)[a1 debugDescription];

  return v1;
}

CFTypeID CFCalendarGetTypeID(void)
{
  return 49;
}

CFLocaleRef CFCalendarCopyLocale(CFCalendarRef calendar)
{
  unsigned int v1 = (void *)[(__CFCalendar *)calendar locale];

  return (CFLocaleRef)[v1 copy];
}

CFTimeZoneRef CFCalendarCopyTimeZone(CFCalendarRef calendar)
{
  unsigned int v1 = (void *)[(__CFCalendar *)calendar timeZone];

  return (CFTimeZoneRef)[v1 copy];
}

id CFCalendarCopyGregorianStartDate(void *a1)
{
  unsigned int v1 = (void *)[a1 gregorianStartDate];

  return v1;
}

uint64_t CFCalendarSetGregorianStartDate(void *a1, const char *a2)
{
  return [a1 setGregorianStartDate:a2];
}

CFRange CFCalendarGetMinimumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2 = [(__CFCalendar *)calendar minimumRangeOfUnit:unit];
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    CFIndex v2 = -1;
    CFIndex v3 = -1;
  }
  result.CFIndex length = v3;
  result.CFIndex location = v2;
  return result;
}

CFRange CFCalendarGetMaximumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2 = [(__CFCalendar *)calendar maximumRangeOfUnit:unit];
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    CFIndex v2 = -1;
    CFIndex v3 = -1;
  }
  result.CFIndex length = v3;
  result.CFIndex location = v2;
  return result;
}

Boolean CFCalendarAddComponents(CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  va_copy(v16, va);
  uint64_t v8 = (void *)[objc_allocWithZone((Class)NSDateComponents) init];
  int v9 = *(unsigned __int8 *)componentDesc;
  if (*componentDesc)
  {
    uint64_t v10 = componentDesc + 1;
    do
    {
      int v11 = va_arg(v16, void);
      switch(v9)
      {
        case 'D':
          [v8 setDayOfYear:v11];
          break;
        case 'E':
        case 'c':
          [v8 setWeekday:v11];
          break;
        case 'F':
          [v8 setWeekdayOrdinal:v11];
          break;
        case 'G':
          [v8 setEra:v11];
          break;
        case 'H':
          [v8 setHour:v11];
          break;
        case 'I':
        case 'J':
        case 'K':
        case 'N':
        case 'O':
        case 'P':
        case 'R':
        case 'S':
        case 'T':
        case 'V':
        case 'X':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '_':
        case 'a':
        case 'b':
          break;
        case 'L':
        case 'M':
          [v8 setMonth:v11];
          break;
        case 'Q':
          [v8 setQuarter:v11];
          break;
        case 'U':
LABEL_6:
          objc_msgSend(v8, "setYear:", v11, v16);
          break;
        case 'W':
          [v8 setWeekOfMonth:v11];
          break;
        case 'Y':
          [v8 setYearForWeekOfYear:v11];
          break;
        case '^':
LABEL_8:
          objc_msgSend(v8, "setWeekOfYear:", v11, v16);
          [v8 setWeek:v11];
          break;
        case 'd':
          [v8 setDay:v11];
          break;
        default:
          switch(v9)
          {
            case 'l':
              [v8 setLeapMonth:v11 != 0];
              break;
            case 'm':
              [v8 setMinute:v11];
              break;
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 't':
            case 'u':
            case 'v':
            case 'x':
              goto LABEL_22;
            case 'r':
            case 'y':
              goto LABEL_6;
            case 's':
              [v8 setSecond:v11];
              break;
            case 'w':
              goto LABEL_8;
            default:
              if (v9 == 35) {
                [v8 setNanosecond:v11];
              }
              break;
          }
          break;
      }
LABEL_22:
      int v12 = *(unsigned __int8 *)v10++;
      int v9 = v12;
    }
    while (v12);
  }
  uint64_t v13 = (void *)[(__CFCalendar *)calendar dateByAddingComponents:v8 toDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", *at, v16) options:options];

  if (!v13) {
    return 0;
  }
  [v13 timeIntervalSinceReferenceDate];
  *(void *)at = v14;
  return 1;
}

Boolean CFCalendarGetTimeRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit, CFAbsoluteTime at, CFAbsoluteTime *startp, CFTimeInterval *tip)
{
  v11[1] = *(id *)off_1ECE0A5B0;
  uint64_t v10 = 0;
  v11[0] = 0;
  int v7 = [(__CFCalendar *)calendar rangeOfUnit:unit startDate:v11 interval:&v10 forDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  if (v7)
  {
    if (startp)
    {
      [v11[0] timeIntervalSinceReferenceDate];
      *(void *)startp = v8;
    }
    if (tip) {
      *(void *)tip = v10;
    }
    LOBYTE(v7) = 1;
  }
  return v7;
}

uint64_t CFCalendarGetComponentFromDate(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = [a1 component:a2 fromDate:a3];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

CFRange CFCalendarGetRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex v4 = [(__CFCalendar *)calendar rangeOfUnit:smallerUnit inUnit:biggerUnit forDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  if (v4 == 0x7FFFFFFFFFFFFFFFLL)
  {
    CFIndex v4 = -1;
    CFIndex v5 = -1;
  }
  result.CFIndex length = v5;
  result.CFIndex location = v4;
  return result;
}

CFIndex CFCalendarGetOrdinalityOfUnit(CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex result = [(__CFCalendar *)calendar ordinalityOfUnit:smallerUnit inUnit:biggerUnit forDate:+[NSDate dateWithTimeIntervalSinceReferenceDate:at]];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1;
  }
  return result;
}

void _CFLocaleSetPreferredMeasurementSystem(__CFString *cf1)
{
  unsigned int v1 = cf1;
  if (cf1)
  {
    if (CFEqual(cf1, @"Metric"))
    {
      CFIndex v2 = &kCFBooleanTrue;
      unsigned int v1 = @"Centimeters";
    }
    else
    {
      if (CFEqual(v1, @"U.S."))
      {
        CFIndex v2 = &kCFBooleanFalse;
      }
      else
      {
        if (!CFEqual(v1, @"U.K.")) {
          return;
        }
        CFIndex v2 = &kCFBooleanTrue;
      }
      unsigned int v1 = @"Inches";
    }
    CFBooleanRef v3 = *v2;
  }
  else
  {
    CFBooleanRef v3 = 0;
  }
  CFPreferencesSetValue(@"AppleMetricUnits", v3, @"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
  CFPreferencesSetValue(@"AppleMeasurementUnits", v1, @"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
  CFPreferencesSynchronize(@"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
  __CFLocaleResetCurrent(1);

  _CFLocalePostChangeNotification(@"AppleMeasurementSystemPreferencesChangedNotification");
}

void _CFLocalePostChangeNotification(const __CFString *a1)
{
  __CFLocaleResetCurrent(1);
  CFNotificationCenterRef DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();

  CFNotificationCenterPostNotification(DarwinNotifyCenter, a1, 0, 0, 1u);
}

CFTypeRef _CFLocaleCopyPreferredMeasurementSystem()
{
  uid_t v0 = (__objc2_class **)CFPreferencesCopyValue(@"AppleMetricUnits", @"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
  unint64_t v1 = (unint64_t)CFPreferencesCopyValue(@"AppleMeasurementUnits", @"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
  if (!((unint64_t)v0 | v1)) {
    return 0;
  }
  CFIndex v2 = (const void *)v1;
  if (v1) {
    BOOL v3 = &__kCFBooleanTrue == v0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3 && CFEqual((CFTypeRef)v1, @"Inches"))
  {
    if (dyld_program_sdk_at_least())
    {
      CFIndex v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemUK;
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  if (v0) {
    BOOL v6 = &__kCFBooleanFalse == v0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    CFIndex v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemUS;
LABEL_19:
    CFTypeRef v5 = CFRetain(*v4);
    if (!v0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (v2 && CFEqual(v2, @"Centimeters"))
  {
LABEL_17:
    CFIndex v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemMetric;
    goto LABEL_19;
  }
  CFTypeRef v5 = 0;
  if (v0) {
LABEL_20:
  }
    CFRelease(v0);
LABEL_21:
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

void _CFLocaleSetPreferredTemperatureUnit(CFPropertyListRef value)
{
  uint64_t v3 = *(void *)off_1ECE0A5B0;
  if (!value || _CFLocaleGetTemperatureUnitForPreferences((uint64_t)value, &v2))
  {
    CFPreferencesSetValue(@"AppleTemperatureUnit", value, @"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
    CFPreferencesSynchronize(@"kCFPreferencesAnyApplication", @"kCFPreferencesCurrentUser", @"kCFPreferencesAnyHost");
    __CFLocaleResetCurrent(1);
    _CFLocalePostChangeNotification(@"AppleTemperatureUnitPreferencesChangedNotification");
  }
}

Boolean CFPlugInRegisterFactoryFunction(CFUUIDRef factoryUUID, CFPlugInFactoryFunction func)
{
  os_unfair_recursive_lock_lock_with_options();
  Locked = (void *)_CFPFactoryCommonCreateLocked(&__kCFAllocatorSystemDefault, factoryUUID);
  Locked[5] = 0;
  Locked[6] = 0;
  Locked[4] = func;
  os_unfair_recursive_lock_unlock();
  return 1;
}

Boolean CFPlugInRegisterFactoryFunctionByName(CFUUIDRef factoryUUID, CFPlugInRef plugIn, CFStringRef functionName)
{
  return 1;
}

Boolean CFPlugInUnregisterFactory(CFUUIDRef factoryUUID)
{
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (uint64_t Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) != 0
    && Value[24])
  {
    _CFPFactoryDisableLocked(Value);
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInUnregisterFactory_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  return 1;
}

void _CFPFactoryDisableLocked(unsigned char *a1)
{
  a1[24] = 0;
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  char v2 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPFactoryDisableLocked_cold_1((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
  }
  CFRelease(a1);
}

Boolean CFPlugInRegisterPlugInType(CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  return 1;
}

Boolean CFPlugInUnregisterPlugInType(CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (uint64_t Value = (CFMutableArrayRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) != 0
    && *((unsigned char *)Value + 24))
  {
    _CFPFactoryRemoveTypeLocked(Value, typeUUID);
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInUnregisterPlugInType_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  return 1;
}

void _CFPFactoryRemoveTypeLocked(CFMutableArrayRef *a1, const void *a2)
{
  CFArrayRef v4 = a1[7];
  v9.CFIndex length = CFArrayGetCount(v4);
  v9.CFIndex location = 0;
  FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v4, v9, a2);
  if ((FirstIndexOfValue & 0x80000000) == 0) {
    CFArrayRemoveValueAtIndex(a1[7], FirstIndexOfValue);
  }
  if (_factoriesByTypeID)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, a2);
    if (Value)
    {
      CFArrayRef v7 = Value;
      v10.CFIndex length = CFArrayGetCount(Value);
      v10.CFIndex location = 0;
      unsigned int v8 = CFArrayGetFirstIndexOfValue(v7, v10, a1);
      if ((v8 & 0x80000000) == 0)
      {
        CFArrayRemoveValueAtIndex(v7, v8);
        if (!CFArrayGetCount(v7)) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)_factoriesByTypeID, a2);
        }
      }
    }
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPFactoryRemoveTypeLocked_cold_1();
  }
}

uint64_t __CFPLUGIN_IS_CALLING_OUT_TO_A_DYNAMIC_REGISTRATION_FUNCTION__(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void CFPlugInSetLoadOnDemand(CFPlugInRef plugIn, Boolean flag)
{
  int v2 = flag;
  PlugInCFDataRef Data = (unsigned char *)__CFBundleGetPlugInData((uint64_t)plugIn);
  if (*PlugInData)
  {
    uint64_t v5 = PlugInData;
    os_unfair_recursive_lock_lock_with_options();
    v5[1] = v2;
    if (v2)
    {
      if (v5[2] || *((_DWORD *)v5 + 2))
      {
        os_unfair_recursive_lock_unlock();
      }
      else
      {
        os_unfair_recursive_lock_unlock();
        CFBundleUnloadExecutable(plugIn);
      }
    }
    else
    {
      os_unfair_recursive_lock_unlock();
      CFBundleLoadExecutable(plugIn);
    }
  }
}

Boolean CFPlugInIsLoadOnDemand(CFPlugInRef plugIn)
{
  if (*(unsigned char *)__CFBundleGetPlugInData((uint64_t)plugIn)) {
    return *(unsigned char *)(__CFBundleGetPlugInData((uint64_t)plugIn) + 1);
  }
  else {
    return 0;
  }
}

unsigned char *_CFPlugInWillUnload(uint64_t a1)
{
  CFIndex result = (unsigned char *)__CFBundleGetPlugInData(a1);
  if (*result)
  {
    os_unfair_recursive_lock_lock_with_options();
    PlugInCFDataRef Data = __CFBundleGetPlugInData(a1);
    int Count = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
    if (Count >= 1)
    {
      unint64_t v5 = Count + 1;
      do
      {
        uint64_t v6 = __CFBundleGetPlugInData(a1);
        *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 16), (v5-- - 2)) + 4) = 0;
      }
      while (v5 > 1);
    }
    return (unsigned char *)os_unfair_recursive_lock_unlock();
  }
  return result;
}

void _CFPFactoryDeallocate(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(void *)(a1 + 16)) {
    BOOL v2 = _factoriesByTypeID == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2) {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_factoriesByFactoryID, *(const void **)(a1 + 16));
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPFactoryDeallocate_cold_1();
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (*(unsigned char *)__CFBundleGetPlugInData(*(void *)(a1 + 40)))
    {
      CFArrayRef v4 = *(const __CFArray **)(__CFBundleGetPlugInData(v3) + 16);
      PlugInCFDataRef Data = __CFBundleGetPlugInData(v3);
      v13.CFIndex length = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
      v13.CFIndex location = 0;
      FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v4, v13, (const void *)a1);
      if ((FirstIndexOfValue & 0x80000000) == 0)
      {
        uint64_t v7 = __CFBundleGetPlugInData(v3);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v7 + 16), FirstIndexOfValue);
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  int Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
  if (Count >= 1)
  {
    unint64_t v9 = Count + 1;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (v9 - 2));
      _CFPFactoryRemoveTypeLocked((CFMutableArrayRef *)a1, ValueAtIndex);
      --v9;
    }
    while (v9 > 1);
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  os_unfair_recursive_lock_unlock();
  int v11 = *(const void **)(a1 + 48);
  if (v11) {
    CFRelease(v11);
  }
  int v12 = *(const void **)(a1 + 16);
  if (v12) {
    CFRelease(v12);
  }
}

CFArrayRef CFPlugInFindFactoriesForPlugInType(CFUUIDRef typeUUID)
{
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByTypeID
    && (CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, typeUUID)) != 0)
  {
    CFArrayRef v3 = Value;
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0; i != v6; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
        unint64_t v9 = (const void *)*((void *)ValueAtIndex + 2);
        if (v9)
        {
          CFRetain(*((CFTypeRef *)ValueAtIndex + 2));
          CFArrayAppendValue(Mutable, v9);
          CFRelease(v9);
        }
      }
    }
  }
  else
  {
    CFMutableStringRef Mutable = 0;
  }
  os_unfair_recursive_lock_unlock();
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  uint64_t v10 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    CFPlugInFindFactoriesForPlugInType_cold_1(Mutable, (uint64_t)typeUUID, v10, v11, v12, v13, v14, v15);
  }
  return Mutable;
}

uint64_t __CFPlugInInstanceDeallocate(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v2 = *(void (**)(uint64_t))(a1 + 32);
  if (v2) {
    v2(a1 + 40);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    _CFPFactoryRemoveInstanceLocked(v3);
  }

  return os_unfair_recursive_lock_unlock();
}

__CFString *__CFPlugInInstanceCopyDescription()
{
  return @"Some CFPlugInInstance";
}

CFTypeID CFPlugInInstanceGetTypeID(void)
{
  return 33;
}

CFPlugInInstanceRef CFPlugInInstanceCreateWithInstanceDataSize(CFAllocatorRef allocator, CFIndex instanceDataSize, CFPlugInInstanceDeallocateInstanceDataFunction deallocateInstanceFunction, CFStringRef factoryName, CFPlugInInstanceGetInterfaceFunction getInterfaceFunction)
{
  uint64_t Instance = (__CFPlugInInstance *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x21uLL, (instanceDataSize + 24), 0);
  if (Instance)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (_factoriesByFactoryID
      && (CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryName)) != 0
      && Value[24])
    {
      *((void *)Instance + 2) = Value;
      _CFPFactoryAddInstanceLocked(Value);
    }
    else
    {
      *((void *)Instance + 2) = 0;
    }
    *((void *)Instance + 3) = getInterfaceFunction;
    *((void *)Instance + 4) = deallocateInstanceFunction;
    os_unfair_recursive_lock_unlock();
  }
  return Instance;
}

Boolean CFPlugInInstanceGetInterfaceFunctionTable(CFPlugInInstanceRef instance, CFStringRef interfaceName, void **ftbl)
{
  uint64_t v9 = *(void *)off_1ECE0A5B0;
  unsigned int v8 = 0;
  CFArrayRef v4 = (uint64_t (*)(void))*((void *)instance + 3);
  if (v4)
  {
    BOOL v5 = v4() != 0;
    if (!ftbl) {
      return v5;
    }
  }
  else
  {
    BOOL v5 = 0;
    if (!ftbl) {
      return v5;
    }
  }
  CFIndex v6 = v8;
  if (!v5) {
    CFIndex v6 = 0;
  }
  *ftbl = v6;
  return v5;
}

CFStringRef CFPlugInInstanceGetFactoryName(CFPlugInInstanceRef instance)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *((void *)instance + 2);
  CFStringRef v3 = *(const __CFString **)(v2 + 16);
  if (v3) {
    CFRetain(*(CFTypeRef *)(v2 + 16));
  }
  os_unfair_recursive_lock_unlock();
  return v3;
}

void *__cdecl CFPlugInInstanceGetInstanceData(CFPlugInInstanceRef instance)
{
  return (char *)instance + 40;
}

void OUTLINED_FUNCTION_1_4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_2_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_3_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_6(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_7(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return _CFPropertyListCreateXMLData(allocator, (const __CFString *)propertyList, 1);
}

__CFData *_CFPropertyListCreateXMLDataWithExtras(const __CFAllocator *a1, const __CFString *a2)
{
  return _CFPropertyListCreateXMLData(a1, a2, 0);
}

BOOL _CFPropertyListCreateSingleValue(__objc2_class **a1, const __CFData *a2, uint64_t a3, CFStringRef theString, void *a5, CFErrorRef *a6)
{
  uint64_t v45 = *(void *)off_1ECE0A5B0;
  if (!theString || !CFStringGetLength(theString)) {
    return 0;
  }
  char v42 = 0;
  memset(v44, 0, sizeof(v44));
  unint64_t v41 = 0;
  BytePtr = (char *)CFDataGetBytePtr(a2);
  unint64_t Length = CFDataGetLength(a2);
  if (Length < 8 || (uint64_t v14 = Length, !__CFDataGetBinaryPlistTopLevelInfo(a2, &v42, &v41, (uint64_t)v44)))
  {
    uint64_t v43 = 0;
    _CFPropertyListCreateWithData(a1, a2, a3, a6, 1, 0, 0, &v43);
    uint64_t v26 = v43;
    if (v43)
    {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, @":");
      uint64_t v28 = v26;
      if (CFArrayGetCount(ArrayBySeparatingStrings) < 1)
      {
LABEL_36:
        BOOL v34 = v28 != 0;
        int v35 = 1;
        if (a5 && v28)
        {
          *a5 = v28;
          CFRetain(v28);
          uint64_t v36 = 1;
        }
        else
        {
LABEL_45:
          uint64_t v36 = v35 & v34;
        }
        CFRelease(ArrayBySeparatingStrings);
        CFRelease(v26);
        return v36;
      }
      CFIndex v29 = 0;
      uint64_t v28 = v26;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v29);
        IntCFArrayRef Value = CFStringGetIntValue(ValueAtIndex);
        SInt32 v32 = IntValue;
        if (IntValue == 0x7FFFFFFF) {
          goto LABEL_26;
        }
        if (!IntValue) {
          break;
        }
        if (IntValue != 0x80000000 || !v28)
        {
LABEL_32:
          if (!v28)
          {
LABEL_43:
            int v35 = 0;
            BOOL v34 = 0;
            goto LABEL_45;
          }
          goto LABEL_33;
        }
LABEL_30:
        if (CFGetTypeID(v28) == 18)
        {
          CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)v28, ValueAtIndex);
          goto LABEL_35;
        }
LABEL_33:
        if (CFGetTypeID(v28) != 19)
        {
          int v35 = 0;
          BOOL v34 = 1;
          goto LABEL_45;
        }
        CFArrayRef Value = CFArrayGetValueAtIndex((CFArrayRef)v28, v32);
LABEL_35:
        uint64_t v28 = Value;
        if (++v29 >= CFArrayGetCount(ArrayBySeparatingStrings)) {
          goto LABEL_36;
        }
      }
      if (CFEqual(@"0", ValueAtIndex)) {
        goto LABEL_32;
      }
LABEL_26:
      if (!v28) {
        goto LABEL_43;
      }
      goto LABEL_30;
    }
    return 0;
  }
  CFArrayRef v15 = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, @":");
  uint64_t v43 = 0;
  *(void *)CFStringRef v40 = v41;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  CFIndex Count = CFArrayGetCount(v15);
  _CFDictionarySetCapacity((unint64_t)Mutable, Count + 1);
  CFIndex v18 = Count - 1;
  if (Count < 1)
  {
    int v25 = 0;
    goto LABEL_42;
  }
  uint64_t v38 = a5;
  CFIndex v19 = 0;
  char v20 = 0;
  do
  {
    CFStringRef v21 = (const __CFString *)CFArrayGetValueAtIndex(v15, v19);
    if (__CFBinaryPlistIsDictionary((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44))
    {
      char OffsetForValueFromDictionary3 = __CFBinaryPlistGetOffsetForValueFromDictionary3(BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44, v21, (unint64_t *)&v43, (unint64_t *)v40);
LABEL_9:
      char v20 = OffsetForValueFromDictionary3;
      goto LABEL_13;
    }
    if (__CFBinaryPlistIsArray((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44))
    {
      unsigned int v23 = CFStringGetIntValue(v21);
      if (v23 <= 0x7FFFFFFE)
      {
        char OffsetForValueFromDictionary3 = __CFBinaryPlistGetOffsetForValueFromArray2((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44, v23, (unint64_t *)v40);
        goto LABEL_9;
      }
    }
LABEL_13:
    if ((v20 & 1) == 0) {
      break;
    }
  }
  while (v18 != v19++);
  int v25 = v20 & 1;
  if (v38)
  {
    if (v20)
    {
      CFTypeRef v39 = 0;
      int v25 = __CFBinaryPlistCreateObjectFiltered(BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44, a1, a3, 0, Mutable, 0, 0, 0, &v39, 0);
      if (v25) {
        void *v38 = v39;
      }
    }
  }
LABEL_42:
  CFRelease(v15);
  CFRelease(Mutable);
  return v25 != 0;
}

uint64_t _CFPropertyListCreateFromXMLData(__objc2_class **a1, const __CFData *a2, unsigned int a3, CFStringRef *a4, char a5, void *a6)
{
  v11[1] = *(void *)off_1ECE0A5B0;
  v11[0] = 0;
  if (a4) {
    *a4 = 0;
  }
  CFTypeRef cf = 0;
  int v7 = _CFPropertyListCreateWithData(a1, a2, a3, (CFErrorRef *)&cf, a5, a6, 0, v11);
  CFTypeRef v8 = cf;
  if (a4 && !v7 && cf)
  {
    *a4 = __copyErrorDebugDescription((__CFError *)cf);
    CFTypeRef v8 = cf;
  }
  if (v8) {
    CFRelease(v8);
  }
  return v11[0];
}

CFStringRef __copyErrorDebugDescription(__CFError *a1)
{
  CFDictionaryRef v1 = CFErrorCopyUserInfo(a1);
  if (!v1) {
    return 0;
  }
  CFDictionaryRef v2 = v1;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v1, @"NSDebugDescription");
  if (Value) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value);
  }
  else {
    CFStringRef Copy = 0;
  }
  CFRelease(v2);
  return Copy;
}

uint64_t __CFRunArrayEqual()
{
  return 0;
}

uint64_t __CFRunArrayHash(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 8);
}

__CFString *__CFRunArrayCopyDescription(uint64_t a1)
{
  CFDictionaryRef v1 = *(void **)(a1 + 16);
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFStringAppendFormat(Mutable, 0, @"%ld blocks used, total length %ld (%ld blocks, block %ld is at %ld)\n", v1[2], v1[1], v1[3], v1[4], v1[5]);
  if ((uint64_t)v1[2] >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = v1 + 7;
    do
    {
      CFStringAppendFormat(Mutable, 0, @" %ld %p %@\n", *(v4 - 1), *v4, *v4);
      ++v3;
      v4 += 2;
    }
    while (v3 < v1[2]);
  }
  return Mutable;
}

uint64_t CFRunArrayGetTypeID()
{
  return 63;
}

void *__CFRunArrayMakeNewList(CFTypeRef cf, uint64_t *a2)
{
  if (a2) {
    uint64_t v4 = a2[2];
  }
  else {
    uint64_t v4 = 2;
  }
  CFAllocatorRef v5 = CFGetAllocator(cf);
  CFIndex result = (void *)CFAllocatorAllocateTyped(v5, 16 * v4 + 48, 1930815021, 0);
  uint64_t v7 = (uint64_t)result;
  result[3] = v4;
  if (a2)
  {
    uint64_t v8 = a2[2];
    if (v8 >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (const void **)(a2 + 7);
      uint64_t v11 = result + 7;
      do
      {
        *(v11 - 1) = *(v10 - 1);
        uint64_t v12 = *v10;
        v10 += 2;
        CFIndex result = CFRetain(v12);
        *uint64_t v11 = result;
        v11 += 2;
        ++v9;
        uint64_t v8 = a2[2];
      }
      while (v9 < v8);
    }
    *(void *)(v7 + 16) = v8;
    *(_OWORD *)(v7 + 32) = *((_OWORD *)a2 + 2);
    uint64_t v13 = *a2;
    *(void *)(v7 + 8) = a2[1];
    *a2 = v13 - 1;
  }
  else
  {
    result[1] = 0;
    result[2] = 0;
    result[4] = 0;
    result[5] = 0;
  }
  *(void *)uint64_t v7 = 1;
  *((void *)cf + 2) = v7;
  return result;
}

uint64_t CFRunArrayGetCount(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 8);
}

uint64_t CFRunArrayGetValueAtRunArrayIndex(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (*(void *)(v3 + 16) <= a2) {
    return 0;
  }
  if (a3) {
    *a3 = *(void *)(v3 + 16 * a2 + 48);
  }
  return *(void *)(v3 + 16 * a2 + 56);
}

void CFRunArrayDelete(void *a1, uint64_t a2, uint64_t a3)
{
}

uint64_t __CFLocaleEqual(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

uint64_t __CFLocaleCopyDescription(void *a1)
{
  CFDictionaryRef v1 = (void *)[a1 description];

  return [v1 copy];
}

id _CFLocaleCopyNumberingSystemForLocaleIdentifier(uint64_t a1)
{
  CFDictionaryRef v1 = (void *)+[NSLocale _numberingSystemForLocaleIdentifier:a1];

  return v1;
}

id _CFLocaleCopyValidNumberingSystemsForLocaleIdentifier(uint64_t a1)
{
  CFDictionaryRef v1 = (void *)+[NSLocale _validNumberingSystemsForLocaleIdentifier:a1];

  return v1;
}

id _CFLocaleCreateLocaleIdentiferByReplacingLanguageCodeAndScriptCode(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v2 = (void *)+[NSLocale _localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode:a1 desiredComponents:a2];

  return v2;
}

id _CFLocaleCreateLikeCurrentWithBundleLocalizations(uint64_t a1, int a2)
{
  CFDictionaryRef v2 = (void *)+[NSLocale _currentLocaleWithBundleLocalizations:a1 disableBundleMatching:a2 != 0];

  return v2;
}

uint64_t _CFLocaleCopyAsIfCurrent(uint64_t a1)
{
  return +[NSLocale _newLocaleAsIfCurrent:a1 overrides:0 disableBundleMatching:0];
}

uint64_t _CFLocaleCopyAsIfCurrentWithOverrides(uint64_t a1, uint64_t a2)
{
  return +[NSLocale _newLocaleAsIfCurrent:a1 overrides:a2 disableBundleMatching:0];
}

CFStringRef CFLocaleCopyDisplayNameForPropertyValue(CFLocaleRef displayLocale, CFLocaleKey key, CFStringRef value)
{
  uint64_t v3 = (void *)[(__CFLocale *)displayLocale displayNameForKey:key value:value];

  return (CFStringRef)v3;
}

CFArrayRef CFLocaleCopyAvailableLocaleIdentifiers(void)
{
  uid_t v0 = +[NSLocale availableLocaleIdentifiers];

  return (CFArrayRef)v0;
}

CFArrayRef CFLocaleCopyISOLanguageCodes(void)
{
  uid_t v0 = +[NSLocale ISOLanguageCodes];

  return (CFArrayRef)v0;
}

CFArrayRef CFLocaleCopyISOCountryCodes(void)
{
  uid_t v0 = +[NSLocale ISOCountryCodes];

  return (CFArrayRef)v0;
}

CFArrayRef CFLocaleCopyISOCurrencyCodes(void)
{
  uid_t v0 = +[NSLocale ISOCurrencyCodes];

  return (CFArrayRef)v0;
}

CFArrayRef CFLocaleCopyCommonISOCurrencyCodes(void)
{
  uid_t v0 = +[NSLocale commonISOCurrencyCodes];

  return (CFArrayRef)v0;
}

uint32_t CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(CFLocaleIdentifier localeIdentifier)
{
  return +[NSLocale windowsLocaleCodeFromLocaleIdentifier:localeIdentifier];
}

CFLocaleLanguageDirection CFLocaleGetLanguageLineDirection(CFStringRef isoLangCode)
{
  return +[NSLocale lineDirectionForLanguage:isoLangCode];
}

id _CFLocaleCopyPreferredLanguagesForCurrentUser()
{
  uid_t v0 = (void *)+[NSLocale _preferredLanguagesForCurrentUser:1];

  return v0;
}

void __CFLocaleResetCurrent(int a1)
{
  CFPreferencesAppSynchronize(@"kCFPreferencesCurrentApplication");
  if (a1) {
    +[NSLocale _resetCurrent];
  }

  dispatch_async((dispatch_queue_t)off_1ECE0A5E0, &__block_literal_global_13);
}

void _CFLocaleResetCurrent()
{
  CFPreferencesAppSynchronize(@"kCFPreferencesCurrentApplication");
  +[NSLocale _resetCurrent];

  dispatch_async((dispatch_queue_t)off_1ECE0A5E0, &__block_literal_global_13);
}

void __CFLocalePrefsChanged()
{
  void v4[5] = *(void *)off_1ECE0A5B0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  __lastNote = *(void *)&Current;
  dispatch_time_t v1 = dispatch_time(0, 10000000);
  qos_class_t v2 = qos_class_main();
  global_queue = dispatch_get_global_queue(v2, 2uLL);
  v4[0] = off_1ECE0A5A0;
  v4[1] = 3221225472;
  v4[2] = ____CFLocalePrefsChanged_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  *(CFAbsoluteTime *)&void v4[4] = Current;
  dispatch_after(v1, global_queue, v4);
}

uint64_t (**__CFStringEncodingGetLatin5ConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_2) {
    __CFStringEncodingPrecomposeLatinCharacter_2 = (_UNKNOWN *)a2(4);
  }
  if (a1 > 1043)
  {
    if (a1 != 1044)
    {
      if (a1 == 1284) {
        return __CFConverterWindowsLatin5;
      }
      return 0;
    }
    return __CFConverterDOSTurkish;
  }
  else
  {
    if (a1 != 35)
    {
      if (a1 == 521) {
        return __CFConverterISOLatin5;
      }
      return 0;
    }
    return __CFConverterMacTurkish;
  }
}

uint64_t __CFToISOLatin5(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0xCF) {
    goto LABEL_2;
  }
  if (a2 < 0x11E)
  {
LABEL_11:
    if (a2 <= 0xFF && (a2 - 208 >= 0x2F || ((0x600100006001uLL >> (a2 + 48)) & 1) == 0))
    {
LABEL_2:
      *a3 = a2;
      return 1;
    }
  }
  else if (a2 <= 0x15F)
  {
    uint64_t v4 = (unsigned __int16 *)&ISOLatin5_from_uni;
    CFAllocatorRef v5 = (unsigned __int16 *)&unk_182DA1514;
    while (1)
    {
      uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
      uint64_t v7 = &v4[2 * v6];
      unsigned int v8 = *v7;
      if (v8 <= a2)
      {
        if (v8 >= a2)
        {
          LOBYTE(a2) = v4[2 * v6 + 1];
          goto LABEL_2;
        }
        uint64_t v4 = v7 + 2;
      }
      else
      {
        CFAllocatorRef v5 = v7 - 2;
      }
      if (v4 > v5) {
        goto LABEL_11;
      }
    }
  }
  return 0;
}

uint64_t __CFFromISOLatin5(uint64_t a1, int a2, _WORD *a3)
{
  if (a2 > 239)
  {
    switch(a2)
    {
      case 240:
        LOWORD(a2) = 287;
        break;
      case 253:
        LOWORD(a2) = 305;
        break;
      case 254:
        LOWORD(a2) = 351;
        break;
    }
  }
  else
  {
    switch(a2)
    {
      case 208:
        LOWORD(a2) = 286;
        break;
      case 221:
        LOWORD(a2) = 304;
        break;
      case 222:
        LOWORD(a2) = 350;
        break;
    }
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin5Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  char v13 = 0;
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  int v10 = __CFToISOLatin5(v9, v9, &v13);
  uint64_t result = 0;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFIsValidCombiningCharacterForLatin5(int a1)
{
  if ((a1 - 768) > 0x5F) {
    return 0;
  }
  else {
    return (__CFLatin5CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t __CFToMacTurkish(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      uint64_t v4 = (unsigned __int16 *)&MacTurkish_from_uni;
      CFAllocatorRef v5 = (unsigned __int16 *)&unk_182DA1720;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          uint64_t v4 = v7 + 2;
        }
        else
        {
          CFAllocatorRef v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromMacTurkish(__int16 a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    if (a2 == 245 && (a1 & 0x200) != 0) {
      a2 = 65533;
    }
    else {
      a2 = MacTurkish_to_uni[a2 - 128];
    }
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacTurkishPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0;
    }
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1792) < 0x7A0u) {
    return 0;
  }
  BOOL v12 = (unsigned __int16 *)&MacTurkish_from_uni;
  char v13 = (unsigned __int16 *)&unk_182DA1720;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    CFArrayRef v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    char v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0;
    }
  }
  if (v16 < v9)
  {
    BOOL v12 = v15 + 2;
    goto LABEL_12;
  }
  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSTurkish(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0;
  }
  CFAllocatorRef v5 = (unsigned __int16 *)&DOSTurkish_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182DA1A14;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    CFAllocatorRef v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSTurkish(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSTurkish_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSTurkishPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSTurkish_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182DA1A14;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

uint64_t __CFToWindowsLatin5(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0;
  }
  CFAllocatorRef v5 = (unsigned __int16 *)&WindowsLatin5_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_182DA1CF8;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0;
    }
  }
  if (v9 < a2)
  {
    CFAllocatorRef v5 = v8 + 2;
    goto LABEL_10;
  }
  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWindowsLatin5(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsLatin5_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsLatin5Precompose(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      uint64_t v11 = (unsigned __int16 *)&WindowsLatin5_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_182DA1CF8;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          uint64_t v11 = v14 + 2;
        }
        else
        {
          BOOL v12 = v14 - 2;
        }
        if (v11 > v12) {
          return 0;
        }
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9) {
    return 0;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1;
  return 2;
}

void __CFRunLoopDump()
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFStringRef v1 = CFCopyDescription(Current);
  CFShow(v1);

  CFRelease(v1);
}

__CFString *__CFRunLoopModeCopyDescription(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"<CFRunLoopMode %p [%p]>{mach_port_name_t name = %@, ", a1, v3, *(void *)(a1 + 80));
  CFStringAppendFormat(Mutable, 0, @"port set = 0x%x, ", *(unsigned int *)(a1 + 136));
  CFStringAppendFormat(Mutable, 0, @"queue = %p, ", *(void *)(a1 + 160));
  if (*(unsigned char *)(a1 + 168)) {
    uint64_t v4 = "fired";
  }
  else {
    uint64_t v4 = "not fired";
  }
  CFStringAppendFormat(Mutable, 0, @"source = %p (%s), ", *(void *)(a1 + 152), v4);
  CFStringAppendFormat(Mutable, 0, @"timer port = 0x%x, ", *(unsigned int *)(a1 + 172));
  long long v17 = *(_OWORD *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t v6 = *(void *)(a1 + 120);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = mach_absolute_time();
  uint64_t v9 = *(void *)(a1 + 184);
  uint64_t v10 = mach_absolute_time();
  double v11 = __CFTSRToTimeInterval(v9 - v10);
  uint64_t v12 = *(void *)(a1 + 184);
  uint64_t v13 = *(void *)(a1 + 192);
  uint64_t v14 = mach_absolute_time();
  double v15 = __CFTSRToTimeInterval(v13 - v14);
  CFStringAppendFormat(Mutable, 0, @"\n\tsources0 = %@,\n\tsources1 = %@,\n\tobservers = %@,\n\ttimers = %@,\n\tcurrently %0.09g (%lld) / soft deadline in: %0.09g sec (@ %lld) / hard deadline in: %0.09g sec (@ %lld)\n},\n", v17, v5, v6, *(void *)&Current, v8, *(void *)&v11, v12, *(void *)&v15, *(void *)(a1 + 192));
  return Mutable;
}

__CFString *__CFRunLoopCopyDescription(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v4 = a1 + *(unsigned __int8 *)(a1 + 84);
  int v5 = *(unsigned __int8 *)(v4 + 85);
  int v6 = *(unsigned __int8 *)(v4 + 339);
  uint64_t v7 = *(void *)(a1 + 624);
  if (v7) {
    uint64_t v8 = *(__CFString **)(v7 + 80);
  }
  else {
    uint64_t v8 = @"(none)";
  }
  if (v6) {
    uint64_t v9 = "true";
  }
  else {
    uint64_t v9 = "false";
  }
  if (v5) {
    uint64_t v10 = "true";
  }
  else {
    uint64_t v10 = "false";
  }
  CFStringAppendFormat(Mutable, 0, @"<CFRunLoop %p [%p]>{wakeup port = 0x%x, stopped = %s, ignoreWakeUps = %s, \ncurrent mode = %@,\n", a1, v3, *(unsigned int *)(a1 + 80), v10, v9, v8);
  CFStringAppendFormat(Mutable, 0, @"common modes = %@,\ncommon mode items = %@,\nmodes = %@}\n", *(void *)(a1 + 608), *(void *)(a1 + 616), *(void *)(a1 + 632));
  return Mutable;
}

CFTypeID CFRunLoopGetTypeID(void)
{
  return 43;
}

uint64_t _CFRunLoopGet1(uint64_t a1)
{
  return *(void *)(a1 + 600);
}

uint64_t _CFRunLoopGet2b(uint64_t a1)
{
  return *(void *)(a1 + 672);
}

uint64_t __CFRunLoopRunSpecific_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = CFLog(3, @"invalid mode '%@' provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution.", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 32));

  return _CFRunLoopError_RunCalledWithInvalidMode(v8);
}

CFAbsoluteTime CFRunLoopGetNextTimerFireDate(CFRunLoopRef rl, CFRunLoopMode mode)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v4 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v4);
  }
  unsigned __int8 v5 = atomic_load(__CFMainThreadHasExited);
  if (v5)
  {
    BOOL v14 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v14 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v6 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  uint64_t v7 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (v7)
  {
    unint64_t v8 = (CFArrayRef *)v7;
    uint64_t v9 = (pthread_mutex_t *)(v7 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 16));
    CFArrayRef v10 = v8[15];
    double NextFireDate = 0.0;
    if (v10)
    {
      if (CFArrayGetCount(v10) >= 1)
      {
        CFStringRef ValueAtIndex = (__CFRunLoopTimer *)CFArrayGetValueAtIndex(v8[15], 0);
        if (ValueAtIndex) {
          double NextFireDate = CFRunLoopTimerGetNextFireDate(ValueAtIndex);
        }
      }
    }
    pthread_mutex_unlock(v9);
    CFRelease(v8);
  }
  else
  {
    double NextFireDate = 0.0;
  }
  pthread_mutex_unlock(v6);
  return NextFireDate;
}

void _CFRunLoopStopMode(uint64_t a1, const __CFString *a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v4 = __CFRunLoopCopyMode(a1, a2, 1);
  if (v4)
  {
    unsigned __int8 v5 = (unsigned char *)v4;
    int v6 = (pthread_mutex_t *)(v4 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
    v5[88] = 1;
    pthread_mutex_unlock(v6);
    CFRelease(v5);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));

  CFRunLoopWakeUp((CFRunLoopRef)a1);
}

uint64_t _CFRunLoopModeContainsMode()
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return 0;
}

uint64_t _CFRunLoopPerCalloutAutoreleasepoolEnabled()
{
  return *((unsigned __int8 *)CFRunLoopGetCurrent() + 681);
}

unint64_t __CFRunLoopAddSource_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog(3, @"Attempting to add a runloop source %p to runloop %p in mode '%@', but the port associated with this source does not have a receive right. This means your source will never be signalled and is likely an error. Break on __CFRunLoopError_AddingSourceLackingReceiveRight to debug. This message will only appear once per execution.", a3, a4, a5, a6, a7, a8, *(_OWORD *)(a1 + 32));
}

Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  __CFCheckCFInfoPACSignature((uint64_t)rl);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if (v7)
  {
    BOOL v16 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v16 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_60);
    }
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  LOBYTE(v8) = 0;
  uint64_t v9 = (__CFRunLoop *)*((void *)timer + 11);
  if (v9 && v9 == rl)
  {
    CFArrayRef v10 = (pthread_mutex_t *)((char *)rl + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (mode == @"kCFRunLoopCommonModes")
    {
      CFSetRef v14 = (const __CFSet *)*((void *)rl + 77);
      if (v14)
      {
        LOBYTE(v8) = CFSetContainsValue(v14, timer);
LABEL_17:
        pthread_mutex_unlock(v10);
        return v8;
      }
    }
    else
    {
      uint64_t v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
      if (v11)
      {
        uint64_t v12 = (CFArrayRef *)v11;
        uint64_t v13 = (pthread_mutex_t *)(v11 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
        CFArrayRef v8 = v12[15];
        if (v8)
        {
          v17.CFIndex length = CFArrayGetCount(v12[15]);
          v17.CFIndex location = 0;
          LOBYTE(v8) = CFArrayGetFirstIndexOfValue(v8, v17, timer) != -1;
        }
        pthread_mutex_unlock(v13);
        CFRelease(v12);
        goto LABEL_17;
      }
    }
    LOBYTE(v8) = 0;
    goto LABEL_17;
  }
  return v8;
}

CFStringRef __CFRunLoopSourceCopyDescription(void *a1)
{
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  qos_class_t v2 = (uint64_t (*)(void))a1[17];
  if (v2)
  {
    uint64_t v3 = v2(a1[14]);
    if (v3)
    {
      CFStringRef v4 = (CFStringRef)v3;
      goto LABEL_17;
    }
  }
  uint64_t v5 = a1[13];
  if (v5 == 1)
  {
    unint64_t v6 = (const void **)(a1 + 21);
    goto LABEL_8;
  }
  if (!v5)
  {
    unint64_t v6 = (const void **)(a1 + 22);
LABEL_8:
    unsigned __int8 v7 = (void *)*v6;
    goto LABEL_10;
  }
  unsigned __int8 v7 = 0;
LABEL_10:
  memset(&v17, 0, sizeof(v17));
  int v8 = dladdr(v7, &v17);
  dli_smach_port_name_t name = "???";
  if (v8)
  {
    if (v17.dli_sname && v17.dli_saddr == v7) {
      dli_smach_port_name_t name = v17.dli_sname;
    }
  }
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFRunLoopSource context>{version = %ld, info = %p, callout = %s (%p)}", a1[13], a1[14], dli_sname, v7);
LABEL_17:
  CFAllocatorRef v11 = CFGetAllocator(a1);
  uint64_t v12 = "Yes";
  if (atomic_load_explicit(a1 + 11, memory_order_acquire)) {
    uint64_t v13 = "Yes";
  }
  else {
    uint64_t v13 = "No";
  }
  char v14 = atomic_load(a1 + 1);
  if ((v14 & 8) == 0) {
    uint64_t v12 = "No";
  }
  CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFRunLoopSource %p [%p]>{signalled = %s, valid = %s, order = %ld, context = %@}", a1, v11, v13, v12, a1[10], v4);
  CFRelease(v4);
  return v15;
}

CFTypeID CFRunLoopSourceGetTypeID(void)
{
  return 46;
}

CFIndex CFRunLoopSourceGetOrder(CFRunLoopSourceRef source)
{
  __CFCheckCFInfoPACSignature((uint64_t)source);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)source + 10);
}

BOOL CFRunLoopSourceIsSignalled(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  BOOL v4 = atomic_load_explicit((atomic_ullong *volatile)(a1 + 88), memory_order_acquire) != 0;
  pthread_mutex_unlock(v3);
  return v4;
}

CFStringRef __CFRunLoopObserverCopyDescription(unint64_t *a1)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  unint64_t v2 = (uint64_t (*)(unint64_t))a1[19];
  if (!v2 || (CFStringRef v3 = (CFStringRef)v2(a1[16])) == 0) {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFRunLoopObserver context %p>", a1[16]);
  }
  BOOL v4 = (void *)a1[14];
  memset(&v14, 0, sizeof(v14));
  dli_smach_port_name_t name = "???";
  if (dladdr(v4, &v14))
  {
    if (v14.dli_sname && v14.dli_saddr == v4) {
      dli_smach_port_name_t name = v14.dli_sname;
    }
  }
  CFAllocatorRef v7 = CFGetAllocator(a1);
  char v8 = atomic_load(a1 + 1);
  if ((v8 & 8) != 0) {
    uint64_t v9 = "Yes";
  }
  else {
    uint64_t v9 = "No";
  }
  char v10 = atomic_load(a1 + 1);
  if ((v10 & 2) != 0) {
    CFAllocatorRef v11 = "Yes";
  }
  else {
    CFAllocatorRef v11 = "No";
  }
  CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFRunLoopObserver %p [%p]>{valid = %s, activities = 0x%lx, repeats = %s, order = %ld, callout = %s (%p), context = %@}", a1, v7, v9, a1[12], v11, a1[13], dli_sname, v4, v3);
  CFRelease(v3);
  return v12;
}

CFTypeID CFRunLoopObserverGetTypeID(void)
{
  return 45;
}

CFOptionFlags CFRunLoopObserverGetActivities(CFRunLoopObserverRef observer)
{
  __CFCheckCFInfoPACSignature((uint64_t)observer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)observer + 12);
}

CFIndex CFRunLoopObserverGetOrder(CFRunLoopObserverRef observer)
{
  __CFCheckCFInfoPACSignature((uint64_t)observer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)observer + 13);
}

Boolean CFRunLoopObserverDoesRepeat(CFRunLoopObserverRef observer)
{
  __CFCheckCFInfoPACSignature((uint64_t)observer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)observer + 1);
  return (v3 >> 1) & 1;
}

Boolean CFRunLoopObserverIsValid(CFRunLoopObserverRef observer)
{
  __CFCheckCFInfoPACSignature((uint64_t)observer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)observer + 1);
  return (v3 >> 3) & 1;
}

void CFRunLoopObserverGetContext(CFRunLoopObserverRef observer, CFRunLoopObserverContext *context)
{
  __CFCheckCFInfoPACSignature((uint64_t)observer);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v4 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  long long v5 = *(_OWORD *)((char *)observer + 120);
  long long v6 = *(_OWORD *)((char *)observer + 136);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)observer + 19);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

CFStringRef __CFRunLoopTimerCopyDescription(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v3 = v2;
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  unint64_t v4 = *(uint64_t (**)(void))(v2 + 184);
  if (!v4 || (CFStringRef v5 = (CFStringRef)v4(*(void *)(v2 + 160))) == 0) {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFRunLoopTimer context %p>", *(void *)(v3 + 160));
  }
  uint64_t v6 = *(void *)(v3 + 144);
  uint64_t v7 = *(void *)(v3 + 160);
  strcpy(__str, "<unknown>");
  strcpy(v24, "<unknown>");
  uint64_t v22 = 0;
  if (__CFRunLoopDebugInfoForRunLoopTimer_onceToken != -1) {
    dispatch_once(&__CFRunLoopDebugInfoForRunLoopTimer_onceToken, &__block_literal_global_115);
  }
  char v8 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 144);
  if (v8 == _runLoopTimerWithBlockContext)
  {
    if (!*(void *)(v7 + 16))
    {
      char v8 = 0;
      goto LABEL_12;
    }
    char v8 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 16);
  }
  if ((char *)v8 == (char *)__CFFireTimer)
  {
    __CFDescribeTimer(v3, v7, __str, 0x800uLL, v24, 0x800uLL, (uint64_t *)&v22);
    goto LABEL_27;
  }
LABEL_12:
  if (v8 == (uint64_t (*)(uint64_t, uint64_t))__CFRunLoopDebugInfoForRunLoopTimer_foundationTimerFunc
    && __CFRunLoopDebugInfoForRunLoopTimer_foundationTimerFunc
    && (uint64_t v9 = (void (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t)))__CFRunLoopDebugInfoForRunLoopTimer_foundationDescribeTimerCalloutFunc) != 0
    || v8 == (uint64_t (*)(uint64_t, uint64_t))__CFRunLoopDebugInfoForRunLoopTimer_foundationDelayedPerformFunc
    && __CFRunLoopDebugInfoForRunLoopTimer_foundationDelayedPerformFunc
    && (uint64_t v9 = (void (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t)))__CFRunLoopDebugInfoForRunLoopTimer_foundationDescribeDelayedPerformFunc) != 0)
  {
    v9(v3, v7, __str, 2048, v24, 2048, &v22);
  }
  else
  {
    memset(&v23, 0, sizeof(v23));
    if (dladdr(v8, &v23))
    {
      dli_fmach_port_name_t name = v23.dli_fname;
      if (!v23.dli_fname) {
        dli_fmach_port_name_t name = "<unknown library>";
      }
      snprintf(__str, 0x800uLL, "%s", dli_fname);
      dli_smach_port_name_t name = v23.dli_sname;
      if (!v23.dli_sname) {
        dli_smach_port_name_t name = "<unknown function>";
      }
      snprintf(v24, 0x800uLL, "%s", dli_sname);
    }
    else
    {
      strcpy(__str, "<unknown library>");
      strcpy(v24, "<unknown function>");
    }
    uint64_t v22 = v8;
  }
LABEL_27:
  CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)v3);
  char v13 = atomic_load((unint64_t *)(v3 + 8));
  if ((v13 & 8) != 0) {
    Dl_info v14 = "Yes";
  }
  else {
    Dl_info v14 = "No";
  }
  if (*(_WORD *)(v3 + 16)) {
    uint64_t v15 = "Yes";
  }
  else {
    uint64_t v15 = "No";
  }
  uint64_t v17 = *(void *)(v3 + 112);
  uint64_t v16 = *(void *)(v3 + 120);
  double v18 = *(double *)(v3 + 104);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, @"<CFRunLoopTimer %p [%p]>{valid = %s, firing = %s, interval = %0.09g, tolerance = %0.09g, next fire date = %0.09g (%0.09g @ %lld), callout = %s (%p / %p) (%s), context = %@}", v3, v12, v14, v15, v17, v16, *(void *)&v18, v18 - Current, *(void *)(v3 + 128), v24, v6, v22, __str, v5);
  CFRelease(v5);
  return v20;
}

CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!CF_IS_OBJC(0x2FuLL, (unint64_t)timer)) {
    return *((double *)timer + 14);
  }

  [(__CFRunLoopTimer *)timer timeInterval];
  return result;
}

CFIndex CFRunLoopTimerGetOrder(CFRunLoopTimerRef timer)
{
  __CFCheckCFInfoPACSignature((uint64_t)timer);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v2 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)timer + 17);
}

CFTimeInterval CFRunLoopTimerGetTolerance(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!CF_IS_OBJC(0x2FuLL, (unint64_t)timer)) {
    return *((double *)timer + 15);
  }

  [(__CFRunLoopTimer *)timer tolerance];
  return result;
}

uint64_t __CFRunLoopKillOneTimer(uint64_t a1)
{
  unint64_t v2 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 96));
  *(void *)(a1 + 88) = 0;

  return pthread_mutex_unlock(v2);
}

void __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(int a1)
{
  if (a1 == 6) {
    __RESOURCE_SHORTAGE__();
  }
  if (a1 == 3) {
    __NO_SPACE__();
  }
  __break(1u);
}

uint64_t __CFRunLoopRemoveSourcesFromCommonMode(uint64_t a1, uint64_t a2)
{
  return __CFRunLoopRemoveAllSources(a2, a1);
}

void __CFRunLoopRemoveSourceFromMode(CFRunLoopSourceRef source, uint64_t a2)
{
}

uint64_t __CFRecordAllocationEvent()
{
  if (__CFOASafe) {
    BOOL v0 = __CFObjectAllocRecordAllocationFunction == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (!v0) {
    return __CFObjectAllocRecordAllocationFunction();
  }
  return result;
}

void *__CFRuntimeEnumerateClassTable(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void *, uint64_t, void **), uint64_t a4)
{
  __dst[33] = *(void *)off_1ECE0A5B0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, const char *))(a2 + 16))(a2, "__CFRuntimeBuiltinClassTable");
  if (v8)
  {
    __dst[0] = 0;
    if (!a3(a1, (void *)v8, 576, (void **)__dst))
    {
      for (uint64_t i = 0; i != 576; i += 8)
        (*(void (**)(uint64_t, void))(a4 + 16))(a4, *(void *)(__dst[0] + i));
    }
  }
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, const char *))(a2 + 16))(a2, "__CFRuntimeClassTables");
  if (result)
  {
    __src = 0;
    uint64_t result = (void *)a3(a1, result, 264, &__src);
    if (!result)
    {
      uint64_t result = memcpy(__dst, __src, 0x108uLL);
      uint64_t v15 = 0;
      int v11 = atomic_load((unsigned int *)&__dst[32]);
      if (v11 >= 1)
      {
        unsigned int v12 = 0;
        int v13 = -1;
        do
        {
          if (v12 >> 6 != v13)
          {
            uint64_t result = (void *)a3(a1, (void *)__dst[v12 >> 6], 512, (void **)&v15);
            int v13 = v12 >> 6;
            if (result) {
              break;
            }
          }
          uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void))(a4 + 16))(a4, *(void *)(v15 + 8 * (v12++ & 0x3F)));
          signed int v14 = atomic_load((unsigned int *)&__dst[32]);
        }
        while ((int)v12 < v14);
      }
    }
  }
  return result;
}

void _CFRuntimeUnregisterClassWithTypeID(unint64_t a1)
{
  if (a1 <= 0x47) {
    _CFRuntimeUnregisterClassWithTypeID_cold_1();
  }
  int v1 = a1;
  os_unfair_lock_lock_with_options();
  *(void *)(__CFRuntimeClassTables[(v1 - 72) >> 6] + 8 * ((v1 - 72) & 0x3F)) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
}

void _CFEnableZombies()
{
  if (!__CFZombieEnabled)
  {
    __CFZombieEnabled = -1;
    __CFZombifyNSObject();
  }
}

uint64_t __CFRuntimeIsFreedObject(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    if (!__CFRuntimeIsFreedObject_freedClass) {
      __CFRuntimeIsFreedObject_freedClass Class = _objc_getFreedObjectClass();
    }
    Class Class = object_getClass(v1);
    if (Class == (Class)__CFRuntimeIsFreedObject_freedClass) {
      return 1;
    }
    uint64_t v3 = Class;
    uint64_t result = (uint64_t)object_getClass(Class);
    if (!result) {
      return result;
    }
    CFStringRef Name = class_getName(v3);
    return Name && !strncmp(Name, "_NSZombie_", 0xAuLL);
  }
  return result;
}

uint64_t __CFGenericTypeID(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    uint64_t v1 = 0;
    uint64_t v2 = *(void *)off_1ECE0A6F0;
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0) {
      uint64_t v2 = 0;
    }
    unint64_t v3 = v2 ^ (unint64_t)a1;
    do
    {
      if ((v3 & 7) == *((unsigned char *)off_1ECE0A6E0 + v1)) {
        break;
      }
      ++v1;
    }
    while (v1 != 7);
    unint64_t v4 = v1 | v3;
    uint64_t v5 = v1 & 7;
    int v6 = (v4 >> 55) + 8;
    if (v5 == 7) {
      int v7 = v6;
    }
    else {
      int v7 = v5;
    }
    uint64_t v8 = 22;
    switch(v7)
    {
      case 0:
        if (dyld_program_sdk_at_least()) {
          __CFGenericTypeID_cold_1();
        }
        return 1;
      case 1:
        goto LABEL_18;
      case 2:
        return 7;
      case 3:
        return v8;
      case 4:
      case 5:
        return 1;
      case 6:
        return 42;
      default:
        if (v7 == 20) {
          return 1;
        }
        if (v7 == 22) {
          return 7;
        }
LABEL_18:
        uint64_t result = [a1 _cfTypeID];
        break;
    }
  }
  else
  {
    unint64_t v9 = atomic_load(a1 + 1);
    return (v9 >> 8) & 0x3FF;
  }
  return result;
}

uint64_t _CFGetTypeIDDescription(unint64_t a1)
{
  if (a1 > 0x47)
  {
    int v2 = a1 - 72;
    if ((int)a1 - 72 >= dword_1EB1DE0D8) {
      return 0;
    }
    uint64_t v3 = __CFRuntimeClassTables[v2 >> 6];
    if (!v3) {
      return 0;
    }
    uint64_t v1 = (uint64_t *)(v3 + 8 * (v2 & 0x3F));
  }
  else
  {
    uint64_t v1 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + a1);
  }
  uint64_t v4 = 0;
  if (a1 != 1)
  {
    uint64_t v5 = *v1;
    if (v5) {
      return *(void *)(v5 + 8);
    }
  }
  return v4;
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  if (type_id > 0x47) {
    uint64_t v1 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)type_id - 72) >> 6] + 8 * ((type_id - 72) & 0x3F));
  }
  else {
    uint64_t v1 = &__CFRuntimeBuiltinClassTable + type_id;
  }
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, *((const char **)*v1 + 1), 0x600u);
}

uint64_t _objc_getTaggedPointerTag(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)off_1ECE0A6F0;
  if ((~a1 & 0xC000000000000007) == 0) {
    uint64_t v2 = 0;
  }
  uint64_t v3 = v2 ^ a1;
  do
  {
    if ((v3 & 7) == *((unsigned char *)off_1ECE0A6E0 + v1)) {
      break;
    }
    ++v1;
  }
  while (v1 != 7);
  unint64_t v4 = v1 | v3;
  uint64_t v5 = v1 & 7;
  unsigned int v6 = (v4 >> 55) + 8;
  if (v5 == 7) {
    return v6;
  }
  else {
    return v5;
  }
}

ssize_t __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__()
{
  write(2, "The process has forked and you cannot use this CoreFoundation functionality safely. You MUST exec().\n", 0x65uLL);

  return write(2, "Break on __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__() to debug.\n", 0x75uLL);
}

uint64_t os_log_callback()
{
  return 0;
}

uint64_t __cf_atfork_prepare()
{
  uint64_t result = pthread_is_threaded_np();
  if (result) {
    atomic_fetch_or(&__CF_FORK_STATE, 4u);
  }
  else {
    atomic_fetch_and(&__CF_FORK_STATE, 0xFBu);
  }
  return result;
}

void __cf_atfork_child()
{
  if ((__CF_FORK_STATE & 2) != 0) {
    atomic_fetch_or(&__CF_FORK_STATE, 1u);
  }
}

uint64_t _CFRegisterThreadSanitizerTag(uint64_t a1)
{
  if (__cf_tsanRegisterTagFunction) {
    BOOL v1 = a1 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0;
  }
  else {
    return __cf_tsanRegisterTagFunction();
  }
}

uint64_t _CFAssignThreadSanitizerTag(uint64_t result, uint64_t a2)
{
  if (__cf_tsanAssignTagFunction) {
    BOOL v2 = result == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2 && a2 != 0) {
    return __cf_tsanAssignTagFunction();
  }
  return result;
}

const char *PROEM_SEL_0(const char *a1)
{
  if (a1) {
    return sel_getName(a1);
  }
  else {
    return "(null selector)";
  }
}

double __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&double result = 136315906;
  *(_DWORD *)a1 = 136315906;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2048;
  *(void *)(a1 + 34) = a5;
  return result;
}

double __os_log_helper_1_2_3_8_32_8_32_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)&double result = 136315650;
  *(_DWORD *)a1 = 136315650;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  return result;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_182CD1800(_Unwind_Exception *exception_object)
{
}

uint64_t _compare_clumpiness_0(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void sub_182CD2504(_Unwind_Exception *exception_object)
{
}

double __CFSetGetCallbacks@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v11 = *(void *)off_1ECE0A5B0;
  long long v10 = 0u;
  long long v8 = 0u;
  memset(v9, 0, sizeof(v9));
  long long v7 = 0u;
  __CFBasicHashGetCallbacks(a1, &v7);
  uint64_t v3 = *((void *)&v7 + 1);
  uint64_t v4 = *((void *)&v8 + 1);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = v3;
  uint64_t v5 = *((void *)&v10 + 1);
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  double result = *((double *)v9 + 1);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)v9 + 8);
  return result;
}

void *__CFSetCreateTransfer(__objc2_class **a1, unint64_t *a2, uint64_t a3)
{
  v11[10] = *(void *)off_1ECE0A5B0;
  v11[0] = (uint64_t)__CFTypeCollectionRetain;
  v11[1] = (uint64_t)__CFTypeCollectionRetain;
  void v11[2] = (uint64_t)__CFTypeCollectionRelease;
  v11[3] = (uint64_t)__CFTypeCollectionRelease;
  v11[4] = (uint64_t)CFEqual;
  v11[5] = (uint64_t)CFEqual;
  v11[6] = (uint64_t)CFHash;
  v11[7] = 0;
  void v11[8] = (uint64_t)CFCopyDescription;
  v11[9] = (uint64_t)CFCopyDescription;
  uint64_t v5 = (void *)CFBasicHashCreate(a1, 0x2000u, v11);
  CFBasicHashSuppressRC((uint64_t)v5);
  if (a3 >= 1)
  {
    CFBasicHashSetCapacity((uint64_t)v5, a3);
    do
    {
      unint64_t v6 = *a2++;
      CFBasicHashAddValue((uint64_t)v5, v6, v6);
      --a3;
    }
    while (a3);
  }
  CFBasicHashUnsuppressRC((uint64_t)v5);
  unint64_t v7 = atomic_load(v5 + 1);
  unint64_t v8 = v7;
  do
  {
    atomic_compare_exchange_strong(v5 + 1, &v8, v7 | 0x40);
    BOOL v9 = v8 == v7;
    unint64_t v7 = v8;
  }
  while (!v9);
  _CFRuntimeSetInstanceTypeIDAndIsa(v5, 0x11uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v5;
}

CFIndex CFSetGetCountOfValue(CFSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    return [(__CFSet *)theSet countForObject:value];
  }
  else
  {
    return CFBasicHashGetCountOfKey((uint64_t)theSet, (unint64_t)value);
  }
}

void CFSetReplaceValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (unint64_t)theSet))
  {
    [(__CFSet *)theSet replaceObject:value];
  }
  else
  {
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0) {
      CFLog(3, @"%s(): immutable collection %p given to mutating function", v4, v5, v6, v7, v8, v9, (__int16)"void CFSetReplaceValue(CFMutableSetRef, const void *)");
    }
    CFBasicHashReplaceValue((unint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }
}

uint64_t __CFSocketSetSocketReadBufferAttrs(uint64_t a1, CFIndex a2, double a3)
{
  if (a3 == 0.0)
  {
    int v5 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    BOOL v7 = a3 < 2147483650.0 && a3 > 0.0;
    double v8 = floor(a3);
    if (v7)
    {
      float v9 = v8;
      uint64_t v6 = (int)v9;
    }
    else
    {
      uint64_t v6 = 0x7FFFFFFFLL;
    }
    int v5 = (int)((a3 - v8) * 1000000.0);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  CFIndex v10 = *(void *)(a1 + 296);
  if (v10 != a2)
  {
    uint64_t v11 = *(void *)(a1 + 304);
    uint64_t v12 = *(void *)(a1 + 312);
    CFIndex v13 = v11 - v12;
    if (v11 != v12)
    {
      CFDictionaryRef Mutable = *(__CFData **)(a1 + 328);
      if (!Mutable)
      {
        CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
        CFDictionaryRef Mutable = CFDataCreateMutable(v15, 0);
        *(void *)(a1 + 328) = Mutable;
      }
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 288));
      CFDataAppendBytes(Mutable, &BytePtr[*(void *)(a1 + 312)], v13);
      CFRelease(*(CFTypeRef *)(a1 + 288));
      CFIndex v10 = 0;
      *(_OWORD *)(a1 + 288) = 0u;
      *(_OWORD *)(a1 + 304) = 0u;
    }
    uint64_t v17 = (CFIndex *)(a1 + 296);
    if (a2)
    {
      double v18 = (void *)(a1 + 304);
      CFIndex v19 = *(const void **)(a1 + 288);
      if (v10 < a2)
      {
        if (v19)
        {
          CFRelease(v19);
          *(void *)(a1 + 288) = 0;
        }
        *uint64_t v17 = a2;
        *double v18 = 0;
        *(void *)(a1 + 312) = 0;
        goto LABEL_23;
      }
      *uint64_t v17 = a2;
      *double v18 = 0;
      *(void *)(a1 + 312) = 0;
      if (!v19)
      {
LABEL_23:
        CFStringRef v21 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
        *(void *)(a1 + 288) = v21;
        CFDataSetLength(v21, a2);
      }
    }
    else
    {
      *uint64_t v17 = 0;
      *(void *)(a1 + 304) = 0;
      *(void *)(a1 + 312) = 0;
      CFStringRef v20 = *(const void **)(a1 + 288);
      if (v20)
      {
        CFRelease(v20);
        int v5 = 0;
        uint64_t v6 = 0;
        *(void *)(a1 + 288) = 0;
      }
      else
      {
        int v5 = 0;
        uint64_t v6 = 0;
      }
    }
  }
  if (*(void *)(a1 + 272) != v6 || *(_DWORD *)(a1 + 280) != v5)
  {
    *(void *)(a1 + 272) = v6;
    *(_DWORD *)(a1 + 28_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v5;
    *(_DWORD *)(a1 + 284) = 0;
    __CFReadSocketsTimeoutInvalid = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
}

int64_t __CFSocketRead(uint64_t a1, void *a2, int64_t a3, int *a4)
{
  double v8 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  *a4 = 0;
  CFDataRef v9 = *(const __CFData **)(a1 + 328);
  if (v9)
  {
    CFIndex Length = CFDataGetLength(v9);
    if (Length < a3) {
      a3 = Length;
    }
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 328));
    memcpy(a2, BytePtr, a3);
    CFIndex v12 = CFDataGetLength(*(CFDataRef *)(a1 + 328));
    CFIndex v13 = *(void **)(a1 + 328);
    if (a3 >= v12)
    {
      CFRelease(v13);
      *(void *)(a1 + 328) = 0;
    }
    else
    {
      v25.CFIndex location = 0;
      v25.CFIndex length = a3;
      CFDataReplaceBytes((CFMutableDataRef)v13, v25, 0, 0);
    }
  }
  else if (*(void *)(a1 + 296) && (uint64_t v14 = *(void *)(a1 + 312), v15 = *(void *)(a1 + 304) - v14, v15 >= 1))
  {
    if (v15 < a3) {
      a3 = *(void *)(a1 + 304) - v14;
    }
    uint64_t v16 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 288));
    memcpy(a2, &v16[*(void *)(a1 + 312)], a3);
    uint64_t v17 = *(void *)(a1 + 304);
    int64_t v18 = *(void *)(a1 + 312) + a3;
    *(void *)(a1 + 312) = v18;
    if (v18 == v17)
    {
      *(void *)(a1 + 304) = 0;
      *(void *)(a1 + 312) = 0;
    }
  }
  else
  {
    int v19 = *(_DWORD *)(a1 + 324);
    if (v19)
    {
      *a4 = v19;
      a3 = -1;
    }
    else if (*(unsigned char *)(a1 + 320))
    {
      a3 = 0;
    }
    else
    {
      CFSocketNativeHandle Native = CFSocketGetNative((CFSocketRef)a1);
      ssize_t v22 = read(Native, a2, a3);
      a3 = v22;
      if (v22)
      {
        if (v22 < 0)
        {
          Dl_info v23 = __error();
          int v24 = *v23;
          *a4 = *v23;
          if (v24 != 35) {
            *(_DWORD *)(a1 + 324) = v24;
          }
        }
      }
      else
      {
        *(unsigned char *)(a1 + 32_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
      }
    }
  }
  pthread_mutex_unlock(v8);
  return a3;
}

CFSocketNativeHandle CFSocketGetNative(CFSocketRef s)
{
  if (CFSocketGetTypeID_initOnce == -1)
  {
    if (!s) {
      goto LABEL_4;
    }
  }
  else
  {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
    if (!s) {
      goto LABEL_4;
    }
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
LABEL_4:
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (s) {
    return *((_DWORD *)s + 38);
  }
  else {
    return -1;
  }
}

uint64_t __CFSocketGetBytesAvailable(__CFSocket *a1, void *a2)
{
  v6[1] = *(void *)off_1ECE0A5B0;
  uint64_t v3 = *((void *)a1 + 38) - *((void *)a1 + 39);
  if (!v3)
  {
    v6[0] = 0;
    CFSocketNativeHandle Native = CFSocketGetNative(a1);
    if (ioctl(Native, 0x4004667FuLL, v6) < 0) {
      return 0;
    }
    uint64_t v3 = v6[0];
  }
  *a2 = v3;
  return 1;
}

void __CFSocketDeallocate(uint64_t a1)
{
  unint64_t v2 = *(const void **)(a1 + 168);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 288);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 288) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 328);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 328) = 0;
  }
  *(_DWORD *)(a1 + 28_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 32_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
  *(_DWORD *)(a1 + 324) = 0;
}

__CFString *__CFSocketCopyDescription(uint64_t a1)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v4 = *(void **)(a1 + 208);
  memset(&v19, 0, sizeof(v19));
  dli_smach_port_name_t name = "???";
  if (dladdr(v4, &v19))
  {
    if (v19.dli_sname && v19.dli_saddr == v4) {
      dli_smach_port_name_t name = v19.dli_sname;
    }
  }
  CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
  double v8 = "Yes";
  char v9 = atomic_load((unint64_t *)(a1 + 8));
  if ((v9 & 0x10) == 0) {
    double v8 = "No";
  }
  uint64_t v10 = *(int *)(a1 + 184);
  uint64_t v12 = *(unsigned int *)(a1 + 152);
  uint64_t v11 = *(unsigned int *)(a1 + 156);
  char v13 = atomic_load((unint64_t *)(a1 + 8));
  CFStringAppendFormat(Mutable, 0, @"<CFSocket %p [%p]>{valid = %s, type = %d, socket = %d, socket set size_t count = %ld,\n    callback types = 0x%x, callout = %s (%p), source = %p,\n    run loops = %@,\n    context = ", a1, v7, v8, v11, v12, v10, v13 & 0xF, dli_sname, v4, *(void *)(a1 + 192), *(void *)(a1 + 200));
  uint64_t v14 = *(void *)(a1 + 224);
  uint64_t v15 = *(uint64_t (**)(uint64_t))(a1 + 248);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
  if (!v14 || !v15 || (CFStringRef v16 = (const __CFString *)v15(v14)) == 0)
  {
    CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
    CFStringRef v16 = CFStringCreateWithFormat(v17, 0, @"<CFSocket context %p>", v14);
  }
  CFStringAppend(Mutable, v16);
  CFStringAppend(Mutable, @"}");
  CFRelease(v16);
  return Mutable;
}

CFTypeID CFSocketGetTypeID(void)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  return 61;
}

uint64_t __CFSocketGetTypeID_block_invoke()
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  v6.rlim_cur = 0;
  v6.int rlim_max = 0;
  int v0 = getrlimit(8, &v6);
  *(void *)CFAllocatorRef v7 = 0x1D00000001;
  int rlim_max = 0;
  size_t v4 = 4;
  uint64_t result = sysctl(v7, 2u, &rlim_max, &v4, 0, 0);
  if (result | v0)
  {
    if (v0) {
      return result;
    }
    LODWORD(v2) = rlim_max;
  }
  else
  {
    LODWORD(v2) = rlim_max;
    if (v6.rlim_max < rlim_max)
    {
      int rlim_max = v6.rlim_max;
      LODWORD(v2) = v6.rlim_max;
    }
  }
  if (v6.rlim_cur < (int)v2)
  {
    rlim_t v2 = (int)v2;
    rlimit v3 = v6;
    if (v6.rlim_cur + 2304 < (int)v2) {
      rlim_t v2 = v6.rlim_cur + 2304;
    }
    v3.rlim_cur = v2;
    return setrlimit(8, &v3);
  }
  return result;
}

CFSocketRef CFSocketCreateWithNative(CFAllocatorRef allocator, CFSocketNativeHandle sock, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  char v7 = callBackTypes;
  uint64_t v49 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFURLRef value = 0;
  socklen_t v46 = 4;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  if (!__CFReadSockets)
  {
    __CFWriteSockets = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
    __CFReadSockets = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
    __CFWriteSocketsFds = (uint64_t)CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    __CFReadSocketsFds = (uint64_t)CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    if (socketpair(1, 2, 0, (int *)&__CFWakeupSocketPair) < 0
      || (__int16 v44 = 1, fcntl(__CFWakeupSocketPair, 2) < 0)
      || (__int16 v44 = 1, fcntl(SHIDWORD(__CFWakeupSocketPair), 2) < 0))
    {
      close(__CFWakeupSocketPair);
      close(SHIDWORD(__CFWakeupSocketPair));
      __CFWakeupSocketPair = -1;
      CFLog(4, @"*** Could not create wakeup socket pair for CFSocket!!!", v14, v15, v16, v17, v18, v19, v44);
    }
    else
    {
      LODWORD(callBacks.__sig) = 1;
      ioctl(__CFWakeupSocketPair, 0x8004667EuLL, &callBacks);
      ioctl(SHIDWORD(__CFWakeupSocketPair), 0x8004667EuLL, &callBacks);
      int64_t v10 = HIDWORD(__CFWakeupSocketPair);
      if ((__CFWakeupSocketPair & 0x8000000000000000) == 0)
      {
        uint64_t v11 = (__CFData *)__CFReadSocketsFds;
        unint64_t v12 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
        if ((uint64_t)v12 <= v10)
        {
          unint64_t v42 = v12 >> 5;
          unint64_t v43 = 4 * (((unint64_t)(v10 + 32) >> 5) - (v12 >> 5));
          CFDataIncreaseLength(v11, v43);
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
          bzero(&MutableBytePtr[4 * v42], v43);
        }
        else
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
        }
        if ((!__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1)
           || ((*(_DWORD *)&MutableBytePtr[((unint64_t)v10 >> 3) & 0x1FFFFFFC] >> v10) & 1) == 0)
          && __darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
        {
          *(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] |= 1 << v10;
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllSocketsLock);
  CFDictionaryRef Mutable = (const __CFDictionary *)__CFAllSockets;
  if (!__CFAllSockets)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    __CFAllSockets = (uint64_t)Mutable;
  }
  if (sock == -1 || !CFDictionaryGetValueIfPresent(Mutable, (const void *)sock, (const void **)&value))
  {
    if (CFSocketGetTypeID_initOnce != -1) {
      dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
    }
    uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x3DuLL, 344, 0);
    CFURLRef value = Instance;
    if (!Instance)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
      return 0;
    }
    unint64_t v22 = atomic_load(Instance + 1);
    unint64_t v23 = v22;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)Instance + 1, &v23, v22 & 0xFFFFFFFFFFFFFFF0 | v7 & 0xF);
      BOOL v24 = v23 == v22;
      unint64_t v22 = v23;
    }
    while (!v24);
    if (sock != -1)
    {
      CFRange v25 = (atomic_ullong *)((char *)value + 8);
      unint64_t v26 = atomic_load((unint64_t *)value + 1);
      unint64_t v27 = v26;
      do
      {
        atomic_compare_exchange_strong(v25, &v27, v26 | 0x10);
        BOOL v24 = v27 == v26;
        unint64_t v26 = v27;
      }
      while (!v24);
    }
    uint64_t v28 = (atomic_ullong *)((char *)value + 8);
    unint64_t v29 = atomic_load((unint64_t *)value + 1);
    unint64_t v30 = v29;
    do
    {
      atomic_compare_exchange_strong(v28, &v30, v29 & 0xFFFFFFFFFFFFFFBFLL);
      BOOL v24 = v30 == v29;
      unint64_t v29 = v30;
    }
    while (!v24);
    unsigned int v31 = (atomic_ullong *)((char *)value + 8);
    unint64_t v32 = atomic_load((unint64_t *)value + 1);
    unint64_t v33 = v32;
    do
    {
      atomic_compare_exchange_strong(v31, &v33, v32 & 0xFFFFFFFFFFFFFFDFLL);
      BOOL v24 = v33 == v32;
      unint64_t v32 = v33;
    }
    while (!v24);
    BOOL v34 = value;
    *((_DWORD *)value + 4) = v7 & 0x73 | *((_DWORD *)value + 4) & 0xFFFFFF00 | 0x80;
    v34[3] = 850045857;
    *((_OWORD *)v34 + 2) = 0u;
    *((_OWORD *)v34 + 3) = 0u;
    *((_OWORD *)v34 + 4) = 0u;
    v34[10] = 0;
    v34[11] = 850045857;
    *((_OWORD *)v34 + 6) = 0u;
    *((_OWORD *)v34 + 7) = 0u;
    *((_OWORD *)v34 + 8) = 0u;
    v34[18] = 0;
    *((_DWORD *)v34 + 38) = sock;
    if (sock == -1)
    {
      *((_DWORD *)v34 + 39) = 0;
      v34[26] = callout;
      *((_DWORD *)v34 + 7_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      v34[34] = 0;
      *((_DWORD *)v34 + 86) = 0;
      v34[42] = 0;
    }
    else
    {
      if (getsockopt(sock, 0xFFFF, 4104, (char *)v34 + 156, &v46)) {
        *((_DWORD *)value + 39) = 0;
      }
      *(_OWORD *)&callBacks.__sig = *(_OWORD *)&kCFTypeArrayCallBacks.version;
      *(void *)&callBacks.__opaque[8] = kCFTypeArrayCallBacks.release;
      *(void *)&callBacks.__opaque[16] = 0;
      *(void *)&callBacks.__opaque[24] = CFEqual;
      CFMutableArrayRef v35 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (const CFArrayCallBacks *)&callBacks);
      uint64_t v36 = value;
      *((void *)value + 25) = v35;
      v36[26] = callout;
      *((_DWORD *)v36 + 7_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
      v36[34] = 0;
      *((_DWORD *)v36 + 86) = 0;
      v36[42] = 0;
      CFDictionaryAddValue((CFMutableDictionaryRef)__CFAllSockets, (const void *)sock, v36);
    }
    if (!__CFSocketManagerThread)
    {
      pthread_t v45 = 0;
      memset(&callBacks, 0, sizeof(callBacks));
      pthread_attr_init(&callBacks);
      pthread_attr_setscope(&callBacks, 1);
      pthread_attr_setdetachstate(&callBacks, 2);
      qos_class_t v38 = qos_class_main();
      pthread_attr_set_qos_class_np(&callBacks, v38, 0);
      pthread_create(&v45, &callBacks, (void *(__cdecl *)(void *))__CFSocketManager, 0);
      pthread_attr_destroy(&callBacks);
      __CFSocketManagerThread = (uint64_t)v45;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
    if (context)
    {
      info = context->info;
      CFAllocatorRetainCallBack retain = context->retain;
      if (retain) {
        info = (void *)((uint64_t (*)(void *))retain)(context->info);
      }
      pthread_mutex_lock((pthread_mutex_t *)((char *)value + 24));
      unint64_t v41 = (char *)value;
      *(_OWORD *)((char *)value + 232) = *(_OWORD *)&context->retain;
      *((void *)v41 + 31) = context->copyDescription;
      *((void *)v41 + 28) = info;
      pthread_mutex_unlock((pthread_mutex_t *)(v41 + 24));
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
    CFRetain(value);
  }
  return (CFSocketRef)value;
}

void CFSocketInvalidate(CFSocketRef s)
{
  uint64_t v34 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRetain(s);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllSocketsLock);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  char v3 = atomic_load((unint64_t *)s + 1);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v4 = atomic_load((unint64_t *)s + 1);
    unint64_t v5 = v4;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)s + 1, &v5, v4 & 0xFFFFFFFFFFFFFFEFLL);
      BOOL v6 = v5 == v4;
      unint64_t v4 = v5;
    }
    while (!v6);
    unint64_t v7 = atomic_load((unint64_t *)s + 1);
    unint64_t v8 = v7;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)s + 1, &v8, v7 & 0xFFFFFFFFFFFFFFBFLL);
      BOOL v6 = v8 == v7;
      unint64_t v7 = v8;
    }
    while (!v6);
    unint64_t v9 = atomic_load((unint64_t *)s + 1);
    unint64_t v10 = v9;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)s + 1, &v10, v9 & 0xFFFFFFFFFFFFFFDFLL);
      BOOL v6 = v10 == v9;
      unint64_t v9 = v10;
    }
    while (!v6);
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    CFArrayRef v11 = (const __CFArray *)__CFWriteSockets;
    v35.CFIndex length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
    v35.CFIndex location = 0;
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v11, v35, s);
    if ((FirstIndexOfValue & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFWriteSockets, FirstIndexOfValue);
      CFIndex v13 = *((unsigned int *)s + 38);
      if ((v13 & 0x80000000) == 0)
      {
        uint64_t v14 = (__CFData *)__CFWriteSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, MutableBytePtr, 1)) {
                *(_DWORD *)&MutableBytePtr[4 * (v13 >> 5)] &= ~(1 << v13);
              }
              if (__CFWakeupSocketPair != -1)
              {
                char v32 = 120;
                send(__CFWakeupSocketPair, &v32, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    CFArrayRef v16 = (const __CFArray *)__CFReadSockets;
    v36.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
    v36.CFIndex location = 0;
    unsigned int v17 = CFArrayGetFirstIndexOfValue(v16, v36, s);
    if ((v17 & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFReadSockets, v17);
      __CFReadSocketsTimeoutInvalid = 0;
      CFIndex v18 = *((unsigned int *)s + 38);
      if ((v18 & 0x80000000) == 0)
      {
        uint64_t v19 = (__CFData *)__CFReadSocketsFds;
        if (v18 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          uint64_t v20 = CFDataGetMutableBytePtr(v19);
          if (__darwin_check_fd_set_overflow(v18, v20, 1))
          {
            if ((*(_DWORD *)&v20[4 * (v18 >> 5)] & (1 << v18)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v18, v20, 1)) {
                *(_DWORD *)&v20[4 * (v18 >> 5)] &= ~(1 << v18);
              }
              if (__CFWakeupSocketPair != -1)
              {
                char v33 = 115;
                send(__CFWakeupSocketPair, &v33, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)__CFAllSockets, (const void *)*((int *)s + 38));
    if ((*((unsigned char *)s + 16) & 0x80) != 0) {
      close(*((_DWORD *)s + 38));
    }
    *((_DWORD *)s + 38) = -1;
    CFStringRef v21 = (const void *)*((void *)s + 22);
    if (v21)
    {
      CFRelease(v21);
      *((void *)s + 22) = 0;
    }
    unint64_t v22 = (const void *)*((void *)s + 32);
    if (v22)
    {
      CFRelease(v22);
      *((void *)s + 32) = 0;
    }
    unint64_t v23 = (const void *)*((void *)s + 33);
    if (v23)
    {
      CFRelease(v23);
      *((void *)s + 33) = 0;
    }
    *((_DWORD *)s + 46) = 0;
    CFArrayRef v24 = (const __CFArray *)CFRetain(*((CFTypeRef *)s + 25));
    CFRelease(*((CFTypeRef *)s + 25));
    CFRange v25 = (__CFRunLoopSource *)*((void *)s + 24);
    *((void *)s + 24) = 0;
    *((void *)s + 25) = 0;
    uint64_t v26 = *((void *)s + 28);
    unint64_t v27 = (void (*)(uint64_t))*((void *)s + 30);
    *((_OWORD *)s + 14) = 0u;
    *((_OWORD *)s + 15) = 0u;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
    int Count = CFArrayGetCount(v24);
    if (Count)
    {
      CFIndex v29 = Count - 1;
      do
      {
        CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v24, v29);
        CFRunLoopWakeUp(ValueAtIndex);
      }
      while (v29--);
    }
    CFRelease(v24);
    if (v27) {
      v27(v26);
    }
    if (v25)
    {
      CFRunLoopSourceInvalidate(v25);
      CFRelease(v25);
    }
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
  CFRelease(s);
}

Boolean CFSocketIsValid(CFSocketRef s)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)s + 1);
  return (v3 >> 4) & 1;
}

CFDataRef CFSocketCopyAddress(CFSocketRef s)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  socklen_t v10 = 256;
  char v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) != 0 && !*((void *)s + 21))
  {
    int v8 = *((_DWORD *)s + 38);
    if (v8 != -1 && !getsockname(v8, &v11, &v10) && (int)v10 >= 1)
    {
      CFAllocatorRef v9 = CFGetAllocator(s);
      *((void *)s + 21) = CFDataCreate(v9, &v11.sa_len, (int)v10);
    }
  }
  unint64_t v5 = (const void *)*((void *)s + 21);
  if (v5) {
    CFDataRef v6 = (const __CFData *)CFRetain(v5);
  }
  else {
    CFDataRef v6 = 0;
  }
  pthread_mutex_unlock(v3);
  return v6;
}

CFDataRef CFSocketCopyPeerAddress(CFSocketRef s)
{
  uint64_t v12 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  socklen_t v10 = 256;
  char v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) != 0 && !*((void *)s + 22))
  {
    int v8 = *((_DWORD *)s + 38);
    if (v8 != -1 && !getpeername(v8, &v11, &v10) && (int)v10 >= 1)
    {
      CFAllocatorRef v9 = CFGetAllocator(s);
      *((void *)s + 22) = CFDataCreate(v9, &v11.sa_len, (int)v10);
    }
  }
  unint64_t v5 = (const void *)*((void *)s + 22);
  if (v5) {
    CFDataRef v6 = (const __CFData *)CFRetain(v5);
  }
  else {
    CFDataRef v6 = 0;
  }
  pthread_mutex_unlock(v3);
  return v6;
}

void CFSocketGetContext(CFSocketRef s, CFSocketContext *context)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  long long v5 = *(_OWORD *)((char *)s + 216);
  long long v6 = *(_OWORD *)((char *)s + 232);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)s + 31);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

CFOptionFlags CFSocketGetSocketFlags(CFSocketRef s)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((unsigned __int8 *)s + 16);
}

void CFSocketSetSocketFlags(CFSocketRef s, CFOptionFlags flags)
{
  char v2 = flags;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  *((unsigned char *)s + 16) = v2;

  pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
}

void CFSocketDisableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  unsigned __int8 v2 = callBackTypes;
  uint64_t v18 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  long long v5 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  char v6 = atomic_load((unint64_t *)s + 1);
  if ((v6 & 0x10) != 0 && *((int *)s + 46) >= 1)
  {
    unsigned __int8 v7 = atomic_load((unint64_t *)s + 1);
    unint64_t v8 = v2 & v7 & 0xF;
    unsigned __int8 v9 = atomic_load((unint64_t *)s + 1);
    *((_DWORD *)s + 4) |= v8 << 8;
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    if ((v9 & 3) == 2 || *((_DWORD *)s + 39) != 1) {
      *((_DWORD *)s + 4) |= 0x10000u;
    }
    if (v8 > 7 || (v8 & 4) != 0 && (*((unsigned char *)s + 18) & 1) == 0)
    {
      CFIndex v10 = *((unsigned int *)s + 38);
      if ((v10 & 0x80000000) == 0)
      {
        sockaddr v11 = (__CFData *)__CFWriteSocketsFds;
        if (v10 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
          if (__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] & (1 << v10)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1)) {
                *(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] &= ~(1 << v10);
              }
              if (__CFWakeupSocketPair != -1)
              {
                char v16 = 120;
                send(__CFWakeupSocketPair, &v16, 1uLL, 0);
              }
              atomic_load((unint64_t *)s + 1);
            }
          }
        }
      }
    }
    if ((v9 & 3) != 0 && (v9 & v8 & 3) != 0)
    {
      __CFReadSocketsTimeoutInvalid = 0;
      CFIndex v13 = *((unsigned int *)s + 38);
      if ((v13 & 0x80000000) == 0)
      {
        uint64_t v14 = (__CFData *)__CFReadSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          uint64_t v15 = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, v15, 1))
          {
            if ((*(_DWORD *)&v15[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, v15, 1)) {
                *(_DWORD *)&v15[4 * (v13 >> 5)] &= ~(1 << v13);
              }
              if (__CFWakeupSocketPair != -1)
              {
                char v17 = 115;
                send(__CFWakeupSocketPair, &v17, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  }
  pthread_mutex_unlock(v5);
}

uint64_t __CFSocketEnableCallBacks(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v40 = *(void *)off_1ECE0A5B0;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (a2)
  {
    char v6 = atomic_load((unint64_t *)(a1 + 8));
    if ((v6 & 0x10) == 0 || *(int *)(a1 + 184) < 1) {
      return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
    }
    unsigned __int8 v7 = atomic_load((unint64_t *)(a1 + 8));
    int v8 = v7 & 3;
    unsigned __int8 v9 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v10 = a2 & v9 & 0xF;
    if (a3) {
      *(_DWORD *)(a1 + 16) &= (~v10 << 8) | 0xFFFF00FF;
    }
    if (v8 == 2 || *(_DWORD *)(a1 + 156) != 1)
    {
      int v11 = *(_DWORD *)(a1 + 16) | 0x10000;
      *(_DWORD *)(a1 + 16) = v11;
      if ((v11 & 0x10000) != 0) {
        goto LABEL_20;
      }
    }
    else
    {
      int v11 = *(_DWORD *)(a1 + 16);
      if ((v11 & 0x10000) != 0) {
        goto LABEL_20;
      }
    }
    if ((v10 & 4) != 0)
    {
      BOOL v13 = 0;
      BOOL v14 = (v11 & 0x400) == 0;
      goto LABEL_23;
    }
LABEL_20:
    BOOL v14 = 0;
    BOOL v13 = v10 >= 8 && (v11 & 0x800) == 0;
LABEL_23:
    uint64_t v15 = v7 & v10 & 3;
    unsigned int v16 = v11 & 0x100;
    BOOL v17 = v16 == 0;
    unsigned int v18 = v16 >> 8;
    BOOL v19 = v15 == 0;
    if (v15) {
      BOOL v20 = v17;
    }
    else {
      BOOL v20 = 0;
    }
    if (v19) {
      LOBYTE(v18) = 1;
    }
    BOOL v21 = v8 == 0;
    if (v8) {
      BOOL v22 = v20;
    }
    else {
      BOOL v22 = 0;
    }
    if (v21) {
      char v23 = 1;
    }
    else {
      char v23 = v18;
    }
    if (v14 || v13 || v22)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      if (v14 || v13)
      {
        if (a3)
        {
          CFArrayRef v24 = (const __CFArray *)__CFWriteSockets;
          v42.CFIndex length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
          v42.CFIndex location = 0;
          if (CFArrayGetFirstIndexOfValue(v24, v42, (const void *)a1) == -1) {
            CFArrayAppendValue((CFMutableArrayRef)__CFWriteSockets, (const void *)a1);
          }
        }
        int64_t v25 = *(unsigned int *)(a1 + 152);
        if ((v25 & 0x80000000) == 0)
        {
          uint64_t v26 = (__CFData *)__CFWriteSocketsFds;
          unint64_t v27 = 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
          if ((uint64_t)v27 <= v25)
          {
            unint64_t v29 = v27 >> 5;
            unint64_t v30 = 4 * (((unint64_t)(v25 + 32) >> 5) - (v27 >> 5));
            CFDataIncreaseLength(v26, v30);
            MutableBytePtr = CFDataGetMutableBytePtr(v26);
            bzero(&MutableBytePtr[4 * v29], v30);
          }
          else
          {
            MutableBytePtr = CFDataGetMutableBytePtr(v26);
          }
          if (!__darwin_check_fd_set_overflow(v25, MutableBytePtr, 1)
            || ((*(_DWORD *)&MutableBytePtr[((unint64_t)v25 >> 3) & 0x1FFFFFFC] >> v25) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(v25, MutableBytePtr, 1)) {
              *(_DWORD *)&MutableBytePtr[4 * (v25 >> 5)] |= 1 << v25;
            }
            if (__CFWakeupSocketPair != -1)
            {
              char v38 = 119;
              send(__CFWakeupSocketPair, &v38, 1uLL, 0);
            }
          }
        }
      }
      if ((v23 & 1) == 0)
      {
        if (a3)
        {
          CFArrayRef v31 = (const __CFArray *)__CFReadSockets;
          v43.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
          v43.CFIndex location = 0;
          if (CFArrayGetFirstIndexOfValue(v31, v43, (const void *)a1) == -1) {
            CFArrayAppendValue((CFMutableArrayRef)__CFReadSockets, (const void *)a1);
          }
        }
        __CFReadSocketsTimeoutInvalid = 0;
        int64_t v32 = *(unsigned int *)(a1 + 152);
        if ((v32 & 0x80000000) == 0)
        {
          char v33 = (__CFData *)__CFReadSocketsFds;
          unint64_t v34 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
          if ((uint64_t)v34 <= v32)
          {
            unint64_t v36 = v34 >> 5;
            unint64_t v37 = 4 * (((unint64_t)(v32 + 32) >> 5) - (v34 >> 5));
            CFDataIncreaseLength(v33, v37);
            CFRange v35 = CFDataGetMutableBytePtr(v33);
            bzero(&v35[4 * v36], v37);
          }
          else
          {
            CFRange v35 = CFDataGetMutableBytePtr(v33);
          }
          if (!__darwin_check_fd_set_overflow(v32, v35, 1)
            || ((*(_DWORD *)&v35[((unint64_t)v32 >> 3) & 0x1FFFFFFC] >> v32) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(v32, v35, 1)) {
              *(_DWORD *)&v35[4 * (v32 >> 5)] |= 1 << v32;
            }
            if (__CFWakeupSocketPair != -1)
            {
              char v39 = 114;
              send(__CFWakeupSocketPair, &v39, 1uLL, 0);
            }
          }
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    }
    return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
}

void CFSocketEnableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));

  __CFSocketEnableCallBacks((uint64_t)s, callBackTypes, 1);
}

CFRunLoopSourceRef CFSocketCreateRunLoopSource(CFAllocatorRef allocator, CFSocketRef s, CFIndex order)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v6 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned __int8 v7 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  char v8 = atomic_load((unint64_t *)s + 1);
  if ((v8 & 0x10) != 0)
  {
    unint64_t v10 = (__CFRunLoopSource *)*((void *)s + 24);
    if (v10)
    {
      int IsValid = CFRunLoopSourceIsValid(v10);
      CFRunLoopSourceRef v12 = (CFRunLoopSourceRef)*((void *)s + 24);
      if (IsValid)
      {
        if (v12)
        {
LABEL_16:
          CFRetain(v12);
          unsigned __int8 v9 = (__CFRunLoopSource *)*((void *)s + 24);
          goto LABEL_17;
        }
      }
      else
      {
        CFRelease(v12);
        *((void *)s + 24) = 0;
      }
    }
    context.CFIndex version = 0;
    context.info = s;
    context.CFAllocatorRetainCallBack retain = CFRetain;
    context.CFArrayReleaseCallBack release = CFRelease;
    context.copyDescriptiouint64_t n = CFCopyDescription;
    context.equal = CFEqual;
    context.hash = CFHash;
    context.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFSocketSchedule;
    context.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFSocketCancel;
    context.perforuint64_t m = (void (__cdecl *)(void *))__CFSocketPerformV0;
    CFRunLoopSourceRef v12 = CFRunLoopSourceCreate(allocator, order, &context);
    *((void *)s + 24) = v12;
    goto LABEL_16;
  }
  unsigned __int8 v9 = 0;
LABEL_17:
  pthread_mutex_unlock(v7);
  return v9;
}

uint64_t __CFSocketSchedule(uint64_t a1, const void *a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  char v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 0x10) != 0 {
    && (CFArrayRef v6 = *(const __CFArray **)(a1 + 200),
  }
        MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v6),
        CFArrayAppendValue(MutableCopy, a2),
        *(void *)(a1 + 20_CFBundleUnloadExecutable((uint64_t)bundle, 0) = MutableCopy,
        CFRelease(v6),
        int v8 = *(_DWORD *)(a1 + 184),
        *(_DWORD *)(a1 + 184) = v8 + 1,
        !v8))
  {
    int v10 = atomic_load((unint64_t *)(a1 + 8));
    return __CFSocketEnableCallBacks(a1, v10 & 0xF, 1);
  }
  else
  {
    return pthread_mutex_unlock(v4);
  }
}

uint64_t __CFSocketCancel(uint64_t a1, const void *a2)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  unint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  int v5 = *(_DWORD *)(a1 + 184) - 1;
  *(_DWORD *)(a1 + 184) = v5;
  if (!v5)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    CFArrayRef v6 = (const __CFArray *)__CFWriteSockets;
    v23.CFIndex length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
    v23.CFIndex location = 0;
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v6, v23, (const void *)a1);
    if ((FirstIndexOfValue & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFWriteSockets, FirstIndexOfValue);
      CFIndex v8 = *(unsigned int *)(a1 + 152);
      if ((v8 & 0x80000000) == 0)
      {
        unsigned __int8 v9 = (__CFData *)__CFWriteSocketsFds;
        if (v8 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v9);
          if (__darwin_check_fd_set_overflow(v8, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v8 >> 5)] & (1 << v8)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v8, MutableBytePtr, 1)) {
                *(_DWORD *)&MutableBytePtr[4 * (v8 >> 5)] &= ~(1 << v8);
              }
              if (__CFWakeupSocketPair != -1)
              {
                char v20 = 120;
                send(__CFWakeupSocketPair, &v20, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    CFArrayRef v11 = (const __CFArray *)__CFReadSockets;
    v24.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
    v24.CFIndex location = 0;
    unsigned int v12 = CFArrayGetFirstIndexOfValue(v11, v24, (const void *)a1);
    if ((v12 & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFReadSockets, v12);
      __CFReadSocketsTimeoutInvalid = 0;
      CFIndex v13 = *(unsigned int *)(a1 + 152);
      if ((v13 & 0x80000000) == 0)
      {
        BOOL v14 = (__CFData *)__CFReadSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          uint64_t v15 = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, v15, 1))
          {
            if ((*(_DWORD *)&v15[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, v15, 1)) {
                *(_DWORD *)&v15[4 * (v13 >> 5)] &= ~(1 << v13);
              }
              if (__CFWakeupSocketPair != -1)
              {
                char v21 = 115;
                send(__CFWakeupSocketPair, &v21, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  }
  unsigned int v16 = *(const void **)(a1 + 200);
  if (v16)
  {
    MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, *(CFArrayRef *)(a1 + 200));
    v25.CFIndex length = CFArrayGetCount(MutableCopy);
    v25.CFIndex location = 0;
    unsigned int v18 = CFArrayGetFirstIndexOfValue(MutableCopy, v25, a2);
    if ((v18 & 0x80000000) == 0) {
      CFArrayRemoveValueAtIndex(MutableCopy, v18);
    }
    *(void *)(a1 + 20_CFBundleUnloadExecutable((uint64_t)bundle, 0) = MutableCopy;
    CFRelease(v16);
  }
  return pthread_mutex_unlock(v4);
}

void __CFSocketPerformV0(uint64_t a1)
{
  uint64_t v53 = *(void *)off_1ECE0A5B0;
  unsigned __int8 v2 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  unsigned int v3 = (unint64_t *)(a1 + 8);
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x10) == 0)
  {
    pthread_mutex_unlock(v2);
    return;
  }
  atomic_load(v3);
  int v5 = atomic_load(v3);
  int v6 = atomic_load(v3);
  int v7 = v5 & (v6 << 26 >> 31);
  unint64_t v8 = atomic_load(v3);
  if ((v5 & 3) == 2)
  {
    CFArrayRef v12 = *(const __CFArray **)(a1 + 256);
    if (v12 && CFArrayGetCount(v12) >= 1)
    {
      unsigned int ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), 0);
      int v10 = 0;
      goto LABEL_13;
    }
  }
  else if ((v5 & 3) == 3)
  {
    CFArrayRef v9 = *(const __CFArray **)(a1 + 256);
    if (v9)
    {
      if (CFArrayGetCount(v9) >= 1)
      {
        int v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), 0);
        CFRetain(v10);
        unsigned int ValueAtIndex = -1;
LABEL_13:
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 256), 0);
        CFIndex v13 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 264), 0);
        CFRetain(v13);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 264), 0);
        goto LABEL_15;
      }
    }
  }
  int v10 = 0;
  CFIndex v13 = 0;
  unsigned int ValueAtIndex = -1;
LABEL_15:
  BOOL v14 = *(void (**)(void))(a1 + 232);
  theCFDataRef Data = (const __CFData *)v10;
  if (v14)
  {
    int v48 = *(void (**)(uint64_t))(a1 + 240);
    uint64_t v45 = *(void *)(a1 + 224);
    v14();
  }
  else
  {
    uint64_t v45 = 0;
    int v48 = 0;
  }
  uint64_t v15 = v13;
  BOOL v16 = 0;
  char v49 = v5;
  int v17 = v7 & 3;
  uint64_t v18 = (v8 >> 6) & 1;
  int v51 = 0;
  unsigned int v52 = ValueAtIndex;
  unsigned int v19 = atomic_load((unint64_t *)(a1 + 8));
  char v20 = atomic_load((unint64_t *)(a1 + 8));
  char v21 = atomic_load((unint64_t *)(a1 + 8));
  char v22 = atomic_load((unint64_t *)(a1 + 8));
  if ((v22 & 0x40) != 0) {
    BOOL v16 = (*(unsigned char *)(a1 + 18) & 1) == 0;
  }
  unsigned int v50 = v17 | (8 * v18);
  int v23 = v20 & 3;
  unint64_t v24 = atomic_load((unint64_t *)(a1 + 8));
  unint64_t v25 = v24;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v25, v24 & 0xFFFFFFFFFFFFFFDFLL);
    BOOL v26 = v25 == v24;
    unint64_t v24 = v25;
  }
  while (!v26);
  unint64_t v27 = atomic_load((unint64_t *)(a1 + 8));
  unint64_t v28 = v27;
  do
  {
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8), &v28, v27 & 0xFFFFFFFFFFFFFFBFLL);
    BOOL v26 = v28 == v27;
    unint64_t v27 = v28;
  }
  while (!v26);
  unint64_t v29 = *(void (**)(uint64_t, uint64_t, const void *, int *, uint64_t))(a1 + 208);
  uint64_t v46 = *(void *)(a1 + 224);
  if ((v22 & 0x40) != 0)
  {
    int v51 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)(a1 + 16) |= 0x10000u;
  }
  pthread_mutex_unlock(v2);
  int v30 = v16 & (v19 >> 2);
  if (v30 != 1)
  {
    int v33 = 0;
    goto LABEL_37;
  }
  if (v51)
  {
    if (v29)
    {
      CFArrayRef v31 = &v51;
      uint64_t v32 = a1;
LABEL_35:
      v29(v32, 4, 0, v31, v46);
    }
  }
  else if (v29)
  {
    uint64_t v32 = a1;
    CFArrayRef v31 = 0;
    goto LABEL_35;
  }
  int v33 = 1;
LABEL_37:
  if (v23 == 2)
  {
    unint64_t v34 = v15;
    CFDataRef v35 = theData;
    if (v52 == -1) {
      goto LABEL_64;
    }
    if (v30)
    {
      int v33 = 1;
      if (!CFSocketIsValid((CFSocketRef)a1) || !v29) {
        goto LABEL_64;
      }
    }
    else if (!v29)
    {
      goto LABEL_63;
    }
    v29(a1, 2, v34, (int *)&v52, v46);
    goto LABEL_63;
  }
  if (v23 == 3)
  {
    unint64_t v34 = v15;
    CFDataRef v35 = theData;
    if (!theData) {
      goto LABEL_64;
    }
    if (!v30 || CFSocketIsValid((CFSocketRef)a1))
    {
      int Length = CFDataGetLength(theData);
      if (v29) {
        v29(a1, 3, v34, (int *)theData, v46);
      }
      if (!Length && *(_DWORD *)(a1 + 156) == 1) {
        CFSocketInvalidate((CFSocketRef)a1);
      }
    }
    goto LABEL_63;
  }
  if (v23 != 1)
  {
    unint64_t v34 = v15;
    CFDataRef v35 = theData;
    goto LABEL_64;
  }
  unint64_t v34 = v15;
  CFDataRef v35 = theData;
  if ((v21 & 0x20) == 0) {
    goto LABEL_64;
  }
  if (v30)
  {
    int v33 = 1;
    if (!CFSocketIsValid((CFSocketRef)a1) || !v29) {
      goto LABEL_64;
    }
    goto LABEL_62;
  }
  if (v29)
  {
LABEL_62:
    int v33 = 1;
    v29(a1, 1, 0, 0, v46);
    goto LABEL_64;
  }
LABEL_63:
  int v33 = 1;
LABEL_64:
  if ((v19 & 8) != 0 && (v22 & 0x40) != 0 && !v51 && (!v33 || CFSocketIsValid((CFSocketRef)a1)) && v29) {
    v29(a1, 8, 0, 0, v46);
  }
  if (v48) {
    v48(v45);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (v34) {
    CFRelease(v34);
  }
  pthread_mutex_lock(v2);
  unint64_t v37 = 0;
  char v38 = atomic_load((unint64_t *)(a1 + 8));
  if ((v49 & 2) == 0 || (v38 & 0x10) == 0) {
    goto LABEL_94;
  }
  CFArrayRef v39 = *(const __CFArray **)(a1 + 256);
  if (!v39 || CFArrayGetCount(v39) < 1)
  {
    unint64_t v37 = 0;
    goto LABEL_94;
  }
  CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 192));
  CFTypeRef v40 = CFRetain(*(CFTypeRef *)(a1 + 200));
  MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, *(CFArrayRef *)(a1 + 200));
  CFRange v42 = *(void **)(a1 + 192);
  if (v42)
  {
    if (CFRunLoopSourceIsValid(*(CFRunLoopSourceRef *)(a1 + 192)))
    {
      CFRetain(v42);
      char v43 = 0;
      goto LABEL_87;
    }
    CFRange v42 = 0;
  }
  char v43 = 1;
LABEL_87:
  pthread_mutex_unlock(v2);
  unint64_t v37 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v42, MutableCopy);
  if ((v43 & 1) == 0) {
    CFRelease(v42);
  }
  pthread_mutex_lock(v2);
  if (v40 == *(CFTypeRef *)(a1 + 200))
  {
    *(void *)(a1 + 20_CFBundleUnloadExecutable((uint64_t)bundle, 0) = MutableCopy;
    CFRelease(v40);
    CFArrayRef v44 = (const __CFArray *)v40;
  }
  else
  {
    CFRelease(v40);
    if (!MutableCopy) {
      goto LABEL_94;
    }
    CFArrayRef v44 = MutableCopy;
  }
  CFRelease(v44);
LABEL_94:
  __CFSocketEnableCallBacks(a1, *(_DWORD *)(a1 + 16) & v50, 0);
  if (v37)
  {
    CFRunLoopWakeUp((CFRunLoopRef)v37);
    CFRelease(v37);
  }
}

CFSocketError CFSocketSendData(CFSocketRef s, CFDataRef address, CFDataRef data, CFTimeInterval timeout)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v8 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v8);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v21 = 0;
  if (address)
  {
    BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
    LODWORD(address) = CFDataGetLength(address);
  }
  else
  {
    BytePtr = 0;
  }
  int v10 = CFDataGetBytePtr(data);
  int Length = CFDataGetLength(data);
  if (!CFSocketIsValid(s)) {
    return -1;
  }
  CFSocketNativeHandle Native = CFSocketGetNative(s);
  if (Native == -1) {
    return -1;
  }
  int v13 = Native;
  CFRetain(s);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFSocketWriteLock_);
  BOOL v14 = timeout < 2147483650.0 && timeout > 0.0;
  double v15 = floor(timeout);
  uint64_t v16 = (int)vcvtmd_s64_f64(timeout);
  if (!v14) {
    uint64_t v16 = 0x7FFFFFFFLL;
  }
  uint64_t v20 = v16;
  LODWORD(v21) = vcvtmd_s64_f64((timeout - v15) * 1000000.0);
  setsockopt(v13, 0xFFFF, 4101, &v20, 0x10u);
  if (BytePtr && (int)address >= 1) {
    int v17 = sendto(v13, v10, Length, 0, BytePtr, (socklen_t)address);
  }
  else {
    int v17 = send(v13, v10, Length, 0);
  }
  int v19 = v17;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFSocketWriteLock_);
  CFRelease(s);
  if (v19 >= 1) {
    return 0;
  }
  else {
    return -1;
  }
}

CFSocketError CFSocketSetAddress(CFSocketRef s, CFDataRef address)
{
  uint64_t v26 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!address || !CFSocketIsValid(s)) {
    return -1;
  }
  BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
  socklen_t Length = CFDataGetLength(address);
  CFSocketError result = kCFSocketError;
  if (BytePtr && Length)
  {
    CFSocketNativeHandle Native = CFSocketGetNative(s);
    if (Length < 3 || BytePtr->sa_family != 1)
    {
LABEL_18:
      int v15 = bind(Native, BytePtr, Length);
      if (v15)
      {
        uint64_t v16 = @"CFSocketSetAddress bind failure: %d";
      }
      else
      {
        if (!listen(Native, 256)) {
          return (uint64_t)v15;
        }
        uint64_t v16 = @"CFSocketSetAddress listen failure: %d";
      }
      int v17 = __error();
      CFLog(7, (uint64_t)v16, v18, v19, v20, v21, v22, v23, *v17);
      return (uint64_t)v15;
    }
    socklen_t Length = strnlen(BytePtr->sa_data, Length - 2) + 2;
    if (Length <= 0xFF)
    {
      if (Length != BytePtr->sa_len)
      {
        CFLog(4, @"WARNING: The sun_len field of a sockaddr_un structure passed to CFSocketSetAddress was not set correctly using the SUN_LEN macro.", v9, v10, v11, v12, v13, v14, v24);
        __memcpy_chk();
        char v25 = Length;
        BytePtr = (const sockaddr *)&v25;
      }
      goto LABEL_18;
    }
    return -1;
  }
  return result;
}

CFSocketError CFSocketConnectToAddress(CFSocketRef s, CFDataRef address, CFTimeInterval timeout)
{
  uint64_t v31 = *(void *)off_1ECE0A5B0;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  __CFCheckCFInfoPACSignature((uint64_t)s);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v6 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v29 = 1;
  int v30 = 0;
  HIDWORD(v28) = 0;
  if (!CFSocketIsValid(s)) {
    return -1;
  }
  BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
  signed int Length = CFDataGetLength(address);
  CFSocketError result = kCFSocketError;
  if (BytePtr && Length >= 1)
  {
    unsigned int Native = CFSocketGetNative(s);
    BOOL v11 = (fcntl(Native, 3, 0) & 0x80000004) == 4 || timeout == 0.0;
    if (!v11) {
      ioctl(Native, 0x8004667EuLL, &v29);
    }
    int v12 = connect(Native, BytePtr, Length);
    if (v12)
    {
      int v13 = *__error();
      BOOL v14 = v13 == 36;
      if (timeout >= 0.0 && v13 == 36)
      {
        LODWORD(v28) = 4;
        HIDWORD(v27) = 0;
        CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
        uint64_t v16 = Mutable;
        if ((Native & 0x80000000) == 0)
        {
          unint64_t v17 = 8 * CFDataGetLength(Mutable);
          if ((uint64_t)v17 <= Native)
          {
            unint64_t v19 = v17 >> 5;
            unint64_t v20 = 4 * ((((unint64_t)Native + 32) >> 5) - (v17 >> 5));
            CFDataIncreaseLength(v16, v20);
            MutableBytePtr = CFDataGetMutableBytePtr(v16);
            bzero(&MutableBytePtr[4 * v19], v20);
          }
          else
          {
            MutableBytePtr = CFDataGetMutableBytePtr(v16);
          }
          unsigned int v21 = Native >> 5;
          if (!__darwin_check_fd_set_overflow(Native, MutableBytePtr, 1)
            || ((*(_DWORD *)&MutableBytePtr[4 * v21] >> Native) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(Native, MutableBytePtr, 1)) {
              *(_DWORD *)&MutableBytePtr[4 * v21] |= 1 << Native;
            }
          }
        }
        BOOL v22 = timeout < 2147483650.0 && timeout > 0.0;
        double v23 = floor(timeout);
        uint64_t v24 = (int)vcvtmd_s64_f64(timeout);
        if (!v22) {
          uint64_t v24 = 0x7FFFFFFFLL;
        }
        uint64_t v26 = v24;
        LODWORD(v27) = vcvtmd_s64_f64((timeout - v23) * 1000000.0);
        CFDataGetLength(v16);
        CFDataGetMutableBytePtr(v16);
        int v25 = select_DARWIN_EXTSN();
        if (v25 < 0)
        {
          int v30 = *__error();
          int v12 = -1;
        }
        else if (v25)
        {
          if (getsockopt(Native, 0xFFFF, 4103, &v30, (socklen_t *)&v28))
          {
            int v12 = 0;
            int v30 = 0;
          }
          else if (v30)
          {
            int v12 = -1;
          }
          else
          {
            int v12 = 0;
          }
        }
        else
        {
          int v12 = -2;
        }
        CFRelease(v16);
        BOOL v14 = 1;
        if (v11) {
          goto LABEL_26;
        }
LABEL_25:
        ioctl(Native, 0x8004667EuLL, (char *)&v28 + 4, v26, v27, v28);
LABEL_26:
        if (timeout < 0.0 && v14) {
          return 0;
        }
        else {
          return (uint64_t)v12;
        }
      }
    }
    else
    {
      BOOL v14 = 0;
    }
    if (v11) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  return result;
}

CFSocketRef CFSocketCreate(CFAllocatorRef allocator, SInt32 protocolFamily, SInt32 socketType, SInt32 protocol, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (protocolFamily >= 1) {
    SInt32 v14 = protocolFamily;
  }
  else {
    SInt32 v14 = 2;
  }
  if (socketType <= 1) {
    SInt32 v15 = 1;
  }
  else {
    SInt32 v15 = socketType;
  }
  if (protocol < 1 && socketType < 2) {
    SInt32 v17 = 6;
  }
  else {
    SInt32 v17 = protocol;
  }
  if (v17 < 1 && v15 == 2) {
    SInt32 v17 = 17;
  }
  if (v14 == 2) {
    SInt32 v19 = v17;
  }
  else {
    SInt32 v19 = protocol;
  }
  if (v14 != 2) {
    SInt32 v15 = socketType;
  }
  if (v15 < 1 && v14 == 1) {
    int v21 = 1;
  }
  else {
    int v21 = v15;
  }
  CFSocketNativeHandle v22 = socket(v14, v21, v19);
  if (v22 == -1) {
    return 0;
  }

  return CFSocketCreateWithNative(allocator, v22, callBackTypes, callout, context);
}

CFSocketRef CFSocketCreateWithSocketSignature(CFAllocatorRef allocator, const CFSocketSignature *signature, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v10 = CFSocketCreate(allocator, signature->protocolFamily, signature->socketType, signature->protocol, callBackTypes, callout, context);
  BOOL v11 = v10;
  if (v10 && (!CFSocketIsValid(v10) || CFSocketSetAddress(v11, signature->address)))
  {
    CFSocketInvalidate(v11);
    CFRelease(v11);
    return 0;
  }
  return v11;
}

CFSocketRef CFSocketCreateConnectedToSocketSignature(CFAllocatorRef allocator, const CFSocketSignature *signature, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context, CFTimeInterval timeout)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if (__CF_FORK_STATE) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v12 = CFSocketCreate(allocator, signature->protocolFamily, signature->socketType, signature->protocol, callBackTypes, callout, context);
  int v13 = v12;
  if (v12 && (!CFSocketIsValid(v12) || CFSocketConnectToAddress(v13, signature->address, timeout)))
  {
    CFSocketInvalidate(v13);
    CFRelease(v13);
    return 0;
  }
  return v13;
}

CFSocketError CFSocketRegisterValue(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFPropertyListRef value)
{
  uint64_t v13 = *(void *)off_1ECE0A5B0;
  CFDataRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v10[2] = 0;
  CFSocketError v11 = kCFSocketError;
  v10[0] = &v11;
  v10[1] = 0;
  CFDictionaryAddValue(Mutable, @"Command", @"Register");
  CFDictionaryAddValue(Mutable, @"Name", name);
  if (value) {
    CFDictionaryAddValue(Mutable, @"Value", value);
  }
  memset(&v12, 0, sizeof(v12));
  __CFSocketValidateSignature((uint64_t)nameServerSignature, (uint64_t)&v12, (unsigned __int16)__CFSocketDefaultNameRegistryPortNumber);
  __CFSocketSendNameRegistryRequest(&v12, Mutable, v10, timeout);
  CFRelease(Mutable);
  CFRelease(v12.address);
  return v11;
}

void *__CFSocketValidateSignature(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v20 = *(void *)off_1ECE0A5B0;
  uint64_t v19 = 0;
  *(_WORD *)bytes = 528;
  __int16 v17 = bswap32((unsigned __int16)__CFSocketDefaultNameRegistryPortNumber) >> 16;
  int v18 = 16777343;
  if (!a1)
  {
    *(void *)a2 = 0x100000002;
    *(_DWORD *)(a2 + 8) = 6;
    goto LABEL_23;
  }
  int v6 = *(_DWORD *)a1;
  *(_DWORD *)a2 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 4) = v7;
  int v8 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 8) = v8;
  if (v6 <= 0)
  {
    *(_DWORD *)a2 = 2;
LABEL_7:
    if (v7 < 1)
    {
      *(_DWORD *)(a2 + 4) = 1;
      if (v8 >= 1) {
        goto LABEL_15;
      }
    }
    else
    {
      if (v8 >= 1) {
        goto LABEL_15;
      }
      if (v7 != 1)
      {
        if (v7 != 2) {
          goto LABEL_15;
        }
        int v9 = 17;
        goto LABEL_14;
      }
    }
    int v9 = 6;
LABEL_14:
    *(_DWORD *)(a2 + 8) = v9;
    goto LABEL_15;
  }
  if (v6 == 2) {
    goto LABEL_7;
  }
LABEL_15:
  CFDataRef v10 = *(const __CFData **)(a1 + 16);
  if (v10)
  {
    BytePtr = CFDataGetBytePtr(v10);
    if (CFDataGetLength(*(CFDataRef *)(a1 + 16)) < 16 || (BytePtr[1] | 2) != 2)
    {
      CFSocketError result = (void *)CFRetain(*(CFTypeRef *)(a1 + 16));
      goto LABEL_25;
    }
    *(_WORD *)bytes = 528;
    __int16 v12 = *((_WORD *)BytePtr + 1);
    __int16 v13 = __rev16(a3);
    if (!v12) {
      __int16 v12 = v13;
    }
    __int16 v17 = v12;
    int v14 = *((_DWORD *)BytePtr + 1);
    if (!v14) {
      int v14 = 16777343;
    }
    int v18 = v14;
  }
LABEL_23:
  CFSocketError result = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, 16);
LABEL_25:
  *(void *)(a2 + 16) = result;
  return result;
}

void __CFSocketSendNameRegistryRequest(const CFSocketSignature *a1, const void *a2, void **a3, CFTimeInterval a4)
{
  uint64_t v14 = *(void *)off_1ECE0A5B0;
  v13.CFIndex version = 0;
  memset(&v13.retain, 0, 24);
  v13.info = a3;
  if (*a3) {
    **a3 = -1;
  }
  CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (Data)
  {
    CFDataRef v8 = Data;
    if (*a3) {
      **a3 = -2;
    }
    int v9 = CFSocketCreateConnectedToSocketSignature((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, 3uLL, (CFSocketCallBack)__CFSocketHandleNameRegistryReply, &v13, a4);
    if (v9)
    {
      CFDataRef v10 = v9;
      if (CFSocketSendData(v9, 0, v8, a4) == kCFSocketSuccess)
      {
        RunLoopSource = CFSocketCreateRunLoopSource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, 0);
        CFAbsoluteTime Current = CFRunLoopGetCurrent();
        CFRunLoopAddSource(Current, RunLoopSource, @"CFSocketRegistryRequest");
        CFRunLoopRunInMode(@"CFSocketRegistryRequest", a4, 0);
        CFRelease(RunLoopSource);
      }
      CFSocketInvalidate(v10);
      CFRelease(v10);
    }
    CFRelease(v8);
  }
}

CFSocketError CFSocketCopyRegisteredValue(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFPropertyListRef *value, CFDataRef *nameServerAddress)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  memset(&v14, 0, sizeof(v14));
  CFDataRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  unint64_t v12[2] = nameServerAddress;
  CFSocketError v13 = kCFSocketError;
  v12[0] = &v13;
  v12[1] = value;
  CFDictionaryAddValue(Mutable, @"Command", @"Retrieve");
  CFDictionaryAddValue(Mutable, @"Name", name);
  __CFSocketValidateSignature((uint64_t)nameServerSignature, (uint64_t)&v14, (unsigned __int16)__CFSocketDefaultNameRegistryPortNumber);
  __CFSocketSendNameRegistryRequest(&v14, Mutable, v12, timeout);
  CFRelease(Mutable);
  CFRelease(v14.address);
  return v13;
}

CFSocketError CFSocketRegisterSocketSignature(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, const CFSocketSignature *signature)
{
  uint64_t v22 = *(void *)off_1ECE0A5B0;
  if (signature)
  {
    long long v19 = 0uLL;
    theCFDataRef Data = 0;
    __CFSocketValidateSignature((uint64_t)signature, (uint64_t)&v19, 0);
    CFDataRef v7 = theData;
    UInt8 v8 = v19;
    UInt8 v9 = BYTE4(v19);
    UInt8 v10 = BYTE8(v19);
    v11.i64[0] = __PAIR64__(v19, DWORD2(v19));
    v11.i64[1] = *(void *)((char *)&v19 + 4);
    __int16 v12 = vmovn_s32(vcgtq_s32(v11, (int32x4_t)xmmword_182DA20F0)).u16[0];
    *(int16x4_t *)v11.i8 = vmovn_s32(vcgtq_s32((int32x4_t)xmmword_182DA20F0, v11));
    v11.i16[0] = v12;
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v11.i8, 0xFuLL))) & 1) != 0
      || (int)v19 > 255
      || !theData
      || SDWORD1(v19) > 255)
    {
      CFSocketError v14 = kCFSocketError;
      if (!theData) {
        return v14;
      }
    }
    else
    {
      CFIndex Length = CFDataGetLength(theData);
      if ((unint64_t)(Length - 256) >= 0xFFFFFFFFFFFFFF01)
      {
        CFIndex v16 = Length;
        CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Length + 4);
        bytes[0] = v8;
        bytes[1] = v9;
        UInt8 bytes[2] = v10;
        bytes[3] = v16;
        CFDataAppendBytes(Mutable, bytes, 4);
        BytePtr = CFDataGetBytePtr(v7);
        CFDataAppendBytes(Mutable, BytePtr, v16);
        CFSocketError v14 = CFSocketRegisterValue(nameServerSignature, timeout, name, Mutable);
        CFRelease(Mutable);
      }
      else
      {
        CFSocketError v14 = kCFSocketError;
      }
    }
    CFRelease(v7);
    return v14;
  }

  return CFSocketRegisterValue(nameServerSignature, timeout, name, 0);
}

CFSocketError CFSocketUnregister(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name)
{
  return CFSocketRegisterValue(nameServerSignature, timeout, name, 0);
}

CFSocketError CFSocketCopyRegisteredSocketSignature(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFSocketSignature *signature, CFDataRef *nameServerAddress)
{
  value[1] = *(CFPropertyListRef *)off_1ECE0A5B0;
  CFTypeRef v22 = 0;
  value[0] = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  CFTypeRef cf = 0;
  CFSocketError v7 = CFSocketCopyRegisteredValue(nameServerSignature, timeout, name, value, (CFDataRef *)&cf);
  if (value[0])
  {
    CFTypeID v8 = CFGetTypeID(value[0]);
    if (v8 == CFDataGetTypeID()
      && (UInt8 v9 = CFDataGetBytePtr((CFDataRef)value[0])) != 0
      && (UInt8 v10 = v9, v11 = CFDataGetLength((CFDataRef)value[0]), v11 >= 4))
    {
      if (signature && v7 == kCFSocketSuccess)
      {
        LODWORD(v2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = *v10;
        HIDWORD(v2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v10[1];
        LODWORD(v21) = v10[2];
        CFTypeRef v22 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10 + 4, v11 - 4);
        __CFSocketValidateSignature((uint64_t)&v20, (uint64_t)signature, 0);
        CFRelease(v22);
        BytePtr = CFDataGetBytePtr(signature->address);
        if (CFDataGetLength(signature->address) >= 16 && BytePtr[1] == 2)
        {
          if (cf)
          {
            if (CFDataGetLength((CFDataRef)cf) >= 16)
            {
              CFSocketError v14 = CFDataGetBytePtr((CFDataRef)cf);
              if (v14)
              {
                uint64_t v15 = v14;
                if (v14[1] == 2)
                {
                  CFIndex Length = CFDataGetLength(signature->address);
                  MutableCFStringRef Copy = CFDataCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Length, signature->address);
                  *((_DWORD *)CFDataGetMutableBytePtr(MutableCopy) + 1) = *((_DWORD *)v15 + 1);
                  CFRelease(signature->address);
                  signature->address = MutableCopy;
                }
              }
            }
          }
        }
        if (nameServerAddress)
        {
          CFDataRef v18 = (const __CFData *)cf;
          if (cf) {
            CFDataRef v18 = (const __CFData *)CFRetain(cf);
          }
          CFSocketError v7 = kCFSocketSuccess;
          *nameServerAddress = v18;
        }
        else
        {
          CFSocketError v7 = kCFSocketSuccess;
        }
      }
    }
    else
    {
      CFSocketError v7 = kCFSocketError;
    }
    if (value[0]) {
      CFRelease(value[0]);
    }
  }
  else
  {
    CFSocketError v7 = kCFSocketError;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

void CFSocketSetDefaultNameRegistryPortNumber(UInt16 port)
{
  __CFSocketDefaultNameRegistryPortNumber = port;
}

UInt16 CFSocketGetDefaultNameRegistryPortNumber(void)
{
  return __CFSocketDefaultNameRegistryPortNumber;
}

uint64_t _CFSocketGetThread()
{
  return __CFSocketManagerThread;
}

void __CFSocketManager(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  pthread_setname_np("com.apple.CFSocket.private");
  uint64_t Typed = (void *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4, 0x100004052888210, 0);
  unsigned int v3 = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4, 0x100004052888210, 0);
  CFDataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v160 = 0;
  CFIndex v4 = 0;
  long long v166 = 0uLL;
  p_superclass = &OBJC_METACLASS___CFPDCloudSource.superclass;
  v165.tv_sec = 0;
  *(void *)&v165.tv_usec = 0;
  uint64_t v156 = 1;
  while (1)
  {
    while (1)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      ++__CFSocketManagerIteration;
      int v6 = 8 * CFDataGetLength((CFDataRef)p_superclass[474]);
      int v7 = 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
      if (v6 <= v7) {
        int v6 = v7;
      }
      unint64_t v8 = v156;
      if (v6 > 32 * (int)v156)
      {
        unint64_t v8 = (unint64_t)(v6 + 31) >> 5;
        uint64_t Typed = (void *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, 4 * (int)v8, 0x100004052888210, 0, 0);
        unsigned int v3 = (char *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v3, 4 * (int)v8, 0x100004052888210, 0, 0);
      }
      uint64_t v156 = v8;
      bzero(Typed, 4 * (int)v8);
      bzero(v3, 4 * (int)v8);
      CFDataRef v9 = (const __CFData *)__CFWriteSocketsFds;
      v173.CFIndex length = CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
      v173.CFIndex location = 0;
      CFDataGetBytes(v9, v173, (UInt8 *)Typed);
      CFDataRef v10 = (const __CFData *)p_superclass[474];
      v174.CFIndex length = CFDataGetLength(v10);
      v174.CFIndex location = 0;
      CFDataGetBytes(v10, v174, (UInt8 *)v3);
      if ((__CFReadSocketsTimeoutInvalid & 1) == 0)
      {
        *(void *)&context[0].sa_leuint64_t n = 0;
        __CFReadSocketsTimeoutInvalid = 1;
        CFArrayRef v11 = (const __CFArray *)__CFReadSockets;
        v175.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
        v175.CFIndex location = 0;
        CFArrayApplyFunction(v11, v175, (CFArrayApplierFunction)_calcMinTimeout_locked, context);
        if (*(void *)&context[0].sa_len)
        {
          long long v166 = *(_OWORD *)*(void *)&context[0].sa_len;
          uint64_t v160 = &v166;
        }
        else
        {
          uint64_t v160 = 0;
        }
      }
      if (v160) {
        gettimeofday(&v165, 0);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
      int v161 = select_DARWIN_EXTSN();
      if (!v161)
      {
        *(void *)&context[0].sa_data[6] = 0;
        *(void *)&context[0].sa_leuint64_t n = 0;
        gettimeofday((timeval *)context, 0);
        os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
        int Count = CFArrayGetCount((CFArrayRef)__CFReadSockets);
        if (Count >= 1)
        {
          CFIndex v13 = 0;
          MutableBytePtr = 0;
          uint64_t v15 = Count;
          do
          {
            unsigned int ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, v13);
            if (*((void *)ValueAtIndex + 34) || ValueAtIndex[70] || *((void *)ValueAtIndex + 41))
            {
              unint64_t v17 = ValueAtIndex[38];
              if ((v17 & 0x80000000) == 0 && (int)v17 < v6)
              {
                CFArraySetValueAtIndex(theArray, v4, ValueAtIndex);
                if (!MutableBytePtr) {
                  MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)p_superclass[474]);
                }
                ++v4;
                if (__darwin_check_fd_set_overflow(v17, MutableBytePtr, 1)) {
                  *(_DWORD *)&MutableBytePtr[(v17 >> 3) & 0x1FFFFFFC] &= ~(1 << v17);
                }
              }
            }
            ++v13;
          }
          while (v15 != v13);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
      }
      if ((v161 & 0x80000000) == 0) {
        break;
      }
      if (*__error() == 9)
      {
        CFDataRef v18 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
        CFIndex v19 = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
        if (v19 >= 1)
        {
          CFIndex v20 = v19;
          for (CFIndex i = 0; i != v20; ++i)
          {
            CFTypeRef v22 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFWriteSockets, i);
            if (!__CFNativeSocketIsValid(v22[38])) {
              CFArrayAppendValue(v18, v22);
            }
          }
        }
        CFIndex v23 = CFArrayGetCount((CFArrayRef)__CFReadSockets);
        if (v23 >= 1)
        {
          CFIndex v24 = v23;
          for (CFIndex j = 0; j != v24; ++j)
          {
            uint64_t v26 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, j);
            if (!__CFNativeSocketIsValid(v26[38])) {
              CFArrayAppendValue(v18, v26);
            }
          }
        }
        CFIndex v27 = CFArrayGetCount(v18);
        if (v27)
        {
          uint64_t v28 = v27;
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
          if (v28 >= 1)
          {
            for (CFIndex k = 0; k != v28; ++k)
            {
              int v30 = (__CFSocket *)CFArrayGetValueAtIndex(v18, k);
              CFSocketInvalidate(v30);
            }
          }
        }
        else
        {
          clearInvalidFileDescriptors((UInt8 *)p_superclass[474]);
          clearInvalidFileDescriptors((UInt8 *)__CFWriteSocketsFds);
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
        }
        CFRelease(v18);
      }
    }
    int v31 = HIDWORD(__CFWakeupSocketPair);
    if (__darwin_check_fd_set_overflow(SHIDWORD(__CFWakeupSocketPair), v3, 1)
      && ((*(_DWORD *)&v3[((unint64_t)v31 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v31) & 1) != 0)
    {
      recv(SHIDWORD(__CFWakeupSocketPair), v167, 0x100uLL, 0);
    }
    uint64_t idx = v4;
    uint64_t v157 = Typed;
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    uint64_t v32 = &OBJC_METACLASS___CFPDCloudSource.superclass;
    int v33 = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
    uint64_t v158 = v3;
    if (v33 < 1)
    {
      CFIndex v36 = 0;
    }
    else
    {
      CFIndex v34 = 0;
      CFDataRef v35 = 0;
      CFIndex v36 = 0;
      uint64_t v37 = v33;
      do
      {
        char v38 = (int *)CFArrayGetValueAtIndex((CFArrayRef)v32[476], v34);
        unint64_t v39 = v38[38];
        if ((v39 & 0x80000000) == 0 && (int)v39 < v6)
        {
          CFTypeRef v40 = v38;
          if (__darwin_check_fd_set_overflow(v38[38], v157, 1))
          {
            if ((v157[v39 >> 5] & (1 << v39)) != 0)
            {
              CFArraySetValueAtIndex(Mutable, v36, v40);
              if (!v35) {
                CFDataRef v35 = CFDataGetMutableBytePtr((CFMutableDataRef)__CFWriteSocketsFds);
              }
              ++v36;
              if (__darwin_check_fd_set_overflow(v39, v35, 1)) {
                *(_DWORD *)&v35[4 * (v39 >> 5)] &= ~(1 << v39);
              }
            }
            unsigned int v3 = v158;
            uint64_t v32 = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
          }
          else
          {
            unsigned int v3 = v158;
          }
        }
        ++v34;
      }
      while (v37 != v34);
    }
    int v41 = CFArrayGetCount((CFArrayRef)__CFReadSockets);
    v164.tv_sec = 0;
    *(void *)&v164.tv_usec = 0;
    if (v160) {
      gettimeofday(&v164, 0);
    }
    if (v41 >= 1)
    {
      CFIndex v42 = 0;
      char v43 = 0;
      do
      {
        CFArrayRef v44 = CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, v42);
        uint64_t v45 = v44;
        unint64_t v46 = *((unsigned int *)v44 + 38);
        BOOL v48 = (v46 & 0x80000000) == 0 && (int)v46 < v6;
        v44[352] = 0;
        if (v161
          && v160
          && v48
          && (!__darwin_check_fd_set_overflow(v46, v3, 1) || ((*(_DWORD *)&v3[(v46 >> 3) & 0x1FFFFFFC] >> v46) & 1) == 0))
        {
          __darwin_time_t v49 = *((void *)v45 + 42);
          if (v49 || *((_DWORD *)v45 + 86))
          {
            BOOL v50 = v164.tv_sec <= v49;
            if (v164.tv_sec == v49) {
              BOOL v50 = v164.tv_usec <= *((_DWORD *)v45 + 86);
            }
            if (!v50) {
              v45[352] = 1;
            }
          }
        }
        if (v48
          && (__darwin_check_fd_set_overflow(v46, v3, 1) && ((*(_DWORD *)&v3[(v46 >> 3) & 0x1FFFFFFC] >> v46) & 1) != 0
           || v45[352]))
        {
          CFArraySetValueAtIndex(theArray, idx, v45);
          if (!v43) {
            char v43 = CFDataGetMutableBytePtr((CFMutableDataRef)__CFReadSocketsFds);
          }
          ++idx;
          if (__darwin_check_fd_set_overflow(v46, v43, 1)) {
            *(_DWORD *)&v43[4 * (v46 >> 5)] &= ~(1 << v46);
          }
        }
        ++v42;
      }
      while (v41 != v42);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    CFArrayRef v51 = theArray;
    if (v36 >= 1)
    {
      CFIndex v52 = 0;
      while (1)
      {
        uint64_t v53 = (__objc2_class **)CFArrayGetValueAtIndex(Mutable, v52);
        if (&__kCFNull != v53) {
          break;
        }
LABEL_104:
        if (++v52 == v36) {
          goto LABEL_122;
        }
      }
      unsigned int v54 = v53;
      *(_DWORD *)&context[0].sa_leuint64_t n = 0;
      *(_DWORD *)&v172[0].sa_leuint64_t n = 4;
      if (!CFSocketIsValid((CFSocketRef)v53))
      {
LABEL_103:
        CFArraySetValueAtIndex(Mutable, v52, &__kCFNull);
        goto LABEL_104;
      }
      if (((_BYTE)v54[2] & 0x40) != 0
        || getsockopt(*((_DWORD *)v54 + 38), 0xFFFF, 4103, context, (socklen_t *)&v172[0].sa_len))
      {
        *(_DWORD *)&context[0].sa_leuint64_t n = 0;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v54 + 3));
      unint64_t v55 = atomic_load((unint64_t *)v54 + 1);
      char v56 = atomic_load((unint64_t *)v54 + 1);
      if ((v56 & 0x10) == 0) {
        goto LABEL_102;
      }
      uint64_t v57 = 8;
      if ((v54[2] & 4) == 0) {
        uint64_t v57 = 12;
      }
      if ((~(*((_DWORD *)v54 + 4) >> 8) & v57 & v55) == 0)
      {
LABEL_102:
        pthread_mutex_unlock((pthread_mutex_t *)(v54 + 3));
        goto LABEL_103;
      }
      *((_DWORD *)v54 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = *(_DWORD *)&context[0].sa_len;
      unint64_t v58 = atomic_load((unint64_t *)v54 + 1);
      unint64_t v59 = v58;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)v54 + 1, &v59, v58 | 0x40);
        BOOL v60 = v59 == v58;
        unint64_t v58 = v59;
      }
      while (!v60);
      CFRunLoopSourceSignal((CFRunLoopSourceRef)v54[24]);
      unsigned int v61 = (__objc2_class *)CFRetain(v54[25]);
      MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFArrayRef)v54[25]);
      int v63 = v54[24];
      if (v63)
      {
        if (CFRunLoopSourceIsValid((CFRunLoopSourceRef)v54[24]))
        {
          CFRetain(v63);
          char v64 = 0;
LABEL_114:
          pthread_mutex_unlock((pthread_mutex_t *)(v54 + 3));
          unsigned __int16 v65 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v63, MutableCopy);
          if ((v64 & 1) == 0) {
            CFRelease(v63);
          }
          if (v65)
          {
            CFRunLoopWakeUp((CFRunLoopRef)v65);
            CFRelease(v65);
          }
          pthread_mutex_lock((pthread_mutex_t *)(v54 + 3));
          unsigned int v3 = v158;
          if (v61 == v54[25])
          {
            v54[25] = (__objc2_class *)MutableCopy;
            CFRelease(v61);
            MutableCFStringRef Copy = 0;
          }
          CFArrayRef v51 = theArray;
          pthread_mutex_unlock((pthread_mutex_t *)(v54 + 3));
          CFRelease(v61);
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
          goto LABEL_103;
        }
        int v63 = 0;
      }
      char v64 = 1;
      goto LABEL_114;
    }
LABEL_122:
    if (idx >= 1) {
      break;
    }
LABEL_270:
    CFIndex v4 = 0;
    uint64_t Typed = v157;
    p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDCloudSource + 8);
  }
  CFIndex v66 = 0;
  while (1)
  {
    uint64_t v67 = (__objc2_class **)CFArrayGetValueAtIndex(v51, v66);
    if (&__kCFNull != v67) {
      break;
    }
LABEL_253:
    if (++v66 == idx) {
      goto LABEL_270;
    }
  }
  unsigned int v68 = v67;
  if (v161) {
    BOOL v69 = *((unsigned char *)v67 + 352) != 0;
  }
  else {
    BOOL v69 = 1;
  }
  if (!CFSocketIsValid((CFSocketRef)v67)) {
    goto LABEL_252;
  }
  char v70 = atomic_load((unint64_t *)v68 + 1);
  if ((~v70 & 3) == 0)
  {
    socklen_t v168 = 256;
    if (*((_DWORD *)v68 + 39) == 1)
    {
      int v71 = *((_DWORD *)v68 + 38);
      uint64_t v72 = context;
      char v73 = context;
      size_t v74 = 0x8000;
    }
    else
    {
      uint64_t v72 = (sockaddr *)malloc_type_malloc(0xFFFFuLL, 0x1B7BAAFAuLL);
      if (!v72)
      {
        int v82 = 0;
        goto LABEL_150;
      }
      int v71 = *((_DWORD *)v68 + 38);
      char v73 = v72;
      size_t v74 = 0xFFFFLL;
    }
    int v82 = recvfrom(v71, v73, v74, 0, &v169, &v168);
    if (v82 > 0)
    {
      CFAllocatorRef v83 = CFGetAllocator(v68);
      CFIndex v84 = v82;
      p_sa_leuint64_t n = &v72->sa_len;
LABEL_151:
      CFDataRef v92 = CFDataCreate(v83, p_sa_len, v84);
      if (v72 && v72 != context) {
        free(v72);
      }
      pthread_mutex_lock((pthread_mutex_t *)(v68 + 3));
      char v93 = atomic_load((unint64_t *)v68 + 1);
      if ((v93 & 0x10) == 0)
      {
        CFRelease(v92);
        char v94 = (pthread_mutex_t *)(v68 + 3);
LABEL_251:
        pthread_mutex_unlock(v94);
        goto LABEL_252;
      }
      unint64_t v95 = atomic_load((unint64_t *)v68 + 1);
      unint64_t v96 = v95;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)v68 + 1, &v96, v95 | 0x20);
        BOOL v60 = v96 == v95;
        unint64_t v95 = v96;
      }
      while (!v60);
      if ((int)v168 >= 1)
      {
        CFAllocatorRef v97 = CFGetAllocator(v68);
        CFDataRef v98 = CFDataCreate(v97, &v169.sa_len, (int)v168);
        goto LABEL_164;
      }
      if (*((_DWORD *)v68 + 39) != 1) {
        goto LABEL_165;
      }
      CFDataRef v99 = (CFDataRef)v68[22];
      if (v99)
      {
LABEL_163:
        CFDataRef v98 = (const __CFData *)CFRetain(v99);
LABEL_164:
        CFDataRef v100 = v98;
        if (v98) {
          goto LABEL_166;
        }
        goto LABEL_165;
      }
      int v171 = 256;
      char v124 = atomic_load((unint64_t *)v68 + 1);
      CFDataRef v99 = (CFDataRef)v68[22];
      if ((v124 & 0x10) != 0)
      {
        if (v99) {
          goto LABEL_163;
        }
        int v129 = *((_DWORD *)v68 + 38);
        if (v129 == -1) {
          goto LABEL_165;
        }
        if (getpeername(v129, v172, (socklen_t *)&v171) || v171 <= 0)
        {
          CFDataRef v99 = (CFDataRef)v68[22];
        }
        else
        {
          CFAllocatorRef v130 = CFGetAllocator(v68);
          CFDataRef v99 = CFDataCreate(v130, &v172[0].sa_len, v171);
          v68[22] = (__objc2_class *)v99;
        }
      }
      if (v99) {
        goto LABEL_163;
      }
LABEL_165:
      CFAllocatorRef v101 = CFGetAllocator(v68);
      CFDataRef v100 = CFDataCreate(v101, 0, 0);
LABEL_166:
      char v102 = (__CFArray *)v68[32];
      if (!v102)
      {
        CFAllocatorRef v103 = CFGetAllocator(v68);
        char v102 = CFArrayCreateMutable(v103, 0, &kCFTypeArrayCallBacks);
        v68[32] = (__objc2_class *)v102;
      }
      if (!v68[33])
      {
        CFAllocatorRef v104 = CFGetAllocator(v68);
        v68[33] = (__objc2_class *)CFArrayCreateMutable(v104, 0, &kCFTypeArrayCallBacks);
        char v102 = (__CFArray *)v68[32];
      }
      CFArrayAppendValue(v102, v92);
      CFRelease(v92);
      CFArrayAppendValue((CFMutableArrayRef)v68[33], v100);
      CFRelease(v100);
      if (v82 >= 1)
      {
        int v105 = *((_DWORD *)v68 + 4);
        if ((v105 & 3) != 0 && (v105 & 0x300) == 0 && *((int *)v68 + 46) >= 1)
        {
          os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
          __CFReadSocketsTimeoutInvalid = 0;
          int64_t v106 = *((unsigned int *)v68 + 38);
          if ((v106 & 0x80000000) != 0) {
            goto LABEL_221;
          }
          char v107 = (__CFData *)__CFReadSocketsFds;
          unint64_t v108 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
          if ((uint64_t)v108 <= v106)
          {
            unint64_t v125 = v108 >> 5;
            unint64_t v126 = 4 * (((unint64_t)(v106 + 32) >> 5) - (v108 >> 5));
            CFDataIncreaseLength(v107, v126);
            uint64_t v109 = CFDataGetMutableBytePtr(v107);
            bzero(&v109[4 * v125], v126);
          }
          else
          {
            uint64_t v109 = CFDataGetMutableBytePtr(v107);
          }
          if (__darwin_check_fd_set_overflow(v106, v109, 1)
            && ((*(_DWORD *)&v109[((unint64_t)v106 >> 3) & 0x1FFFFFFC] >> v106) & 1) != 0)
          {
            goto LABEL_221;
          }
          if (__darwin_check_fd_set_overflow(v106, v109, 1)) {
            *(_DWORD *)&v109[4 * (v106 >> 5)] |= 1 << v106;
          }
          int v127 = __CFWakeupSocketPair;
          if (__CFWakeupSocketPair == -1) {
            goto LABEL_221;
          }
          v172[0].sa_leuint64_t n = 114;
          uint64_t v128 = v172;
LABEL_220:
          send(v127, v128, 1uLL, 0);
LABEL_221:
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
          goto LABEL_222;
        }
      }
      goto LABEL_222;
    }
LABEL_150:
    CFAllocatorRef v83 = CFGetAllocator(v68);
    p_sa_leuint64_t n = 0;
    CFIndex v84 = 0;
    goto LABEL_151;
  }
  char v75 = atomic_load((unint64_t *)v68 + 1);
  if ((v75 & 3) == 2)
  {
    *(_DWORD *)&v172[0].sa_leuint64_t n = 256;
    int v76 = accept(*((_DWORD *)v68 + 38), context, (socklen_t *)&v172[0].sa_len);
    if (v76 != -1)
    {
      int v77 = v76;
      int v78 = *(_DWORD *)&v172[0].sa_len;
      CFAllocatorRef v79 = CFGetAllocator(v68);
      if (v78 < 1)
      {
        uint64_t v81 = 0;
        CFIndex v80 = 0;
      }
      else
      {
        CFIndex v80 = *(int *)&v172[0].sa_len;
        uint64_t v81 = context;
      }
      CFDataRef v110 = CFDataCreate(v79, &v81->sa_len, v80);
      pthread_mutex_lock((pthread_mutex_t *)(v68 + 3));
      char v111 = atomic_load((unint64_t *)v68 + 1);
      if ((v111 & 0x10) != 0)
      {
        unint64_t v112 = atomic_load((unint64_t *)v68 + 1);
        unint64_t v113 = v112;
        do
        {
          atomic_compare_exchange_strong((atomic_ullong *volatile)v68 + 1, &v113, v112 | 0x20);
          BOOL v60 = v113 == v112;
          unint64_t v112 = v113;
        }
        while (!v60);
        unint64_t v114 = (__CFArray *)v68[32];
        if (!v114)
        {
          CFAllocatorRef v115 = CFGetAllocator(v68);
          unint64_t v114 = CFArrayCreateMutable(v115, 0, 0);
          v68[32] = (__objc2_class *)v114;
        }
        if (!v68[33])
        {
          CFAllocatorRef v116 = CFGetAllocator(v68);
          v68[33] = (__objc2_class *)CFArrayCreateMutable(v116, 0, &kCFTypeArrayCallBacks);
          unint64_t v114 = (__CFArray *)v68[32];
        }
        CFArrayAppendValue(v114, (const void *)v77);
        CFArrayAppendValue((CFMutableArrayRef)v68[33], v110);
        CFRelease(v110);
        if ((v68[2] & 0x202) == 2 && *((int *)v68 + 46) >= 1)
        {
          os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
          __CFReadSocketsTimeoutInvalid = 0;
          int64_t v117 = *((unsigned int *)v68 + 38);
          if ((v117 & 0x80000000) != 0) {
            goto LABEL_221;
          }
          unsigned __int8 v118 = (__CFData *)__CFReadSocketsFds;
          unint64_t v119 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
          if ((uint64_t)v119 <= v117)
          {
            unint64_t v131 = v119 >> 5;
            unint64_t v132 = 4 * (((unint64_t)(v117 + 32) >> 5) - (v119 >> 5));
            CFDataIncreaseLength(v118, v132);
            uint64_t v120 = CFDataGetMutableBytePtr(v118);
            bzero(&v120[4 * v131], v132);
          }
          else
          {
            uint64_t v120 = CFDataGetMutableBytePtr(v118);
          }
          if (__darwin_check_fd_set_overflow(v117, v120, 1)
            && ((*(_DWORD *)&v120[((unint64_t)v117 >> 3) & 0x1FFFFFFC] >> v117) & 1) != 0)
          {
            goto LABEL_221;
          }
          if (__darwin_check_fd_set_overflow(v117, v120, 1)) {
            *(_DWORD *)&v120[4 * (v117 >> 5)] |= 1 << v117;
          }
          int v127 = __CFWakeupSocketPair;
          if (__CFWakeupSocketPair == -1) {
            goto LABEL_221;
          }
          v169.sa_leuint64_t n = 114;
          uint64_t v128 = &v169;
          goto LABEL_220;
        }
LABEL_222:
        CFRunLoopSourceSignal((CFRunLoopSourceRef)v68[24]);
        uint64_t v133 = (__objc2_class *)CFRetain(v68[25]);
        CFArrayRef v134 = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFArrayRef)v68[25]);
        uint64_t v135 = v68[24];
        if (v135)
        {
          if (CFRunLoopSourceIsValid((CFRunLoopSourceRef)v68[24]))
          {
            CFRetain(v135);
            char v136 = 0;
LABEL_227:
            pthread_mutex_unlock((pthread_mutex_t *)(v68 + 3));
            uint64_t v137 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v135, v134);
            if ((v136 & 1) == 0) {
              CFRelease(v135);
            }
            if (v137)
            {
              CFRunLoopWakeUp((CFRunLoopRef)v137);
              CFRelease(v137);
            }
            pthread_mutex_lock((pthread_mutex_t *)(v68 + 3));
            CFArrayRef v51 = theArray;
            if (v133 == v68[25])
            {
              v68[25] = (__objc2_class *)v134;
              CFRelease(v133);
              CFArrayRef v134 = 0;
            }
            pthread_mutex_unlock((pthread_mutex_t *)(v68 + 3));
            CFRelease(v133);
            if (v134) {
              CFRelease(v134);
            }
            goto LABEL_252;
          }
          uint64_t v135 = 0;
        }
        char v136 = 1;
        goto LABEL_227;
      }
      close(v77);
      CFRelease(v110);
      pthread_mutex_unlock((pthread_mutex_t *)(v68 + 3));
    }
LABEL_252:
    CFArraySetValueAtIndex(v51, v66, &__kCFNull);
    goto LABEL_253;
  }
  unsigned int v86 = (pthread_mutex_t *)(v68 + 3);
  pthread_mutex_lock((pthread_mutex_t *)(v68 + 3));
  char v87 = atomic_load((unint64_t *)v68 + 1);
  if (v87 & 0x10) == 0 || (*((unsigned char *)v68 + 17))
  {
LABEL_250:
    char v94 = v86;
    goto LABEL_251;
  }
  if (v69)
  {
    if (!v68[38] && !v68[41])
    {
      *((_DWORD *)v68 + 86) = 0;
      v68[42] = 0;
LABEL_146:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      __CFReadSocketsTimeoutInvalid = 0;
      int64_t v88 = *((unsigned int *)v68 + 38);
      if ((v88 & 0x80000000) != 0) {
        goto LABEL_249;
      }
      int32x4_t v89 = (__CFData *)__CFReadSocketsFds;
      unint64_t v90 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
      if ((uint64_t)v90 <= v88)
      {
        unint64_t v142 = v90 >> 5;
        unint64_t v143 = 4 * (((unint64_t)(v88 + 32) >> 5) - (v90 >> 5));
        CFDataIncreaseLength(v89, v143);
        uint64_t v91 = CFDataGetMutableBytePtr(v89);
        bzero(&v91[4 * v142], v143);
      }
      else
      {
        uint64_t v91 = CFDataGetMutableBytePtr(v89);
      }
      if (__darwin_check_fd_set_overflow(v88, v91, 1)
        && ((*(_DWORD *)&v91[((unint64_t)v88 >> 3) & 0x1FFFFFFC] >> v88) & 1) != 0)
      {
        goto LABEL_249;
      }
      if (__darwin_check_fd_set_overflow(v88, v91, 1)) {
        *(_DWORD *)&v91[4 * (v88 >> 5)] |= 1 << v88;
      }
      int v144 = __CFWakeupSocketPair;
      if (__CFWakeupSocketPair == -1) {
        goto LABEL_249;
      }
      context[0].sa_leuint64_t n = 114;
      char v145 = context;
LABEL_248:
      send(v144, v145, 1uLL, 0);
LABEL_249:
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
      goto LABEL_250;
    }
LABEL_194:
    unint64_t v122 = atomic_load((unint64_t *)v68 + 1);
    unint64_t v123 = v122;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)v68 + 1, &v123, v122 | 0x20);
      BOOL v60 = v123 == v122;
      unint64_t v122 = v123;
    }
    while (!v60);
    goto LABEL_222;
  }
  char v121 = v68[37];
  if (!v121) {
    goto LABEL_194;
  }
  if (*((unsigned char *)v68 + 320)) {
    goto LABEL_194;
  }
  int64_t v138 = (char *)v121 - (char *)v68[38];
  if (v138 < 1) {
    goto LABEL_194;
  }
  uint64_t v139 = CFDataGetMutableBytePtr((CFMutableDataRef)v68[36]);
  CFSocketNativeHandle Native = CFSocketGetNative((CFSocketRef)v68);
  ssize_t v141 = read(Native, (char *)v68[38] + (void)v139, v138);
  if (v141)
  {
    if (v141 != -1)
    {
      char v146 = v68[37];
      ssize_t v147 = (ssize_t)v68[38] + v141;
      v68[38] = (__objc2_class *)v147;
      if (v146 != (__objc2_class *)v147)
      {
        *(void *)&context[0].sa_data[6] = 0;
        *(void *)&context[0].sa_leuint64_t n = 0;
        gettimeofday((timeval *)context, 0);
        uint64_t v148 = (char *)v68[34] + *(void *)&context[0].sa_len;
        v68[42] = (__objc2_class *)v148;
        int v149 = *((_DWORD *)v68 + 70) + *(_DWORD *)&context[0].sa_data[6];
        *((_DWORD *)v68 + 86) = v149;
        if (v149 >= 1000000)
        {
          v68[42] = (__objc2_class *)(v148 + 1);
          *((_DWORD *)v68 + 86) = v149 - 1000000;
        }
        os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
        __CFReadSocketsTimeoutInvalid = 0;
        int64_t v150 = *((unsigned int *)v68 + 38);
        if ((v150 & 0x80000000) != 0) {
          goto LABEL_249;
        }
        uint64_t v151 = (__CFData *)__CFReadSocketsFds;
        unint64_t v152 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
        if ((uint64_t)v152 <= v150)
        {
          unint64_t v154 = v152 >> 5;
          unint64_t v155 = 4 * (((unint64_t)(v150 + 32) >> 5) - (v152 >> 5));
          CFDataIncreaseLength(v151, v155);
          uint64_t v153 = CFDataGetMutableBytePtr(v151);
          bzero(&v153[4 * v154], v155);
        }
        else
        {
          uint64_t v153 = CFDataGetMutableBytePtr(v151);
        }
        if (__darwin_check_fd_set_overflow(v150, v153, 1)
          && ((*(_DWORD *)&v153[((unint64_t)v150 >> 3) & 0x1FFFFFFC] >> v150) & 1) != 0)
        {
          goto LABEL_249;
        }
        if (__darwin_check_fd_set_overflow(v150, v153, 1)) {
          *(_DWORD *)&v153[4 * (v150 >> 5)] |= 1 << v150;
        }
        int v144 = __CFWakeupSocketPair;
        if (__CFWakeupSocketPair == -1) {
          goto LABEL_249;
        }
        v172[0].sa_leuint64_t n = 114;
        char v145 = v172;
        goto LABEL_248;
      }
      *((_DWORD *)v68 + 86) = 0;
      v68[42] = 0;
      goto LABEL_194;
    }
    if (*__error() == 35) {
      goto LABEL_146;
    }
    *((_DWORD *)v68 + 81) = *__error();
  }
  *((unsigned char *)v68 + 32_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
  goto LABEL_194;
}

uint64_t _calcMinTimeout_locked(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(void *)(result + 272);
  if (!v2 && !*(_DWORD *)(result + 280)) {
    goto LABEL_7;
  }
  unsigned int v3 = (void *)(result + 272);
  uint64_t v4 = *a2;
  if (*a2)
  {
    BOOL v5 = v2 < *(void *)v4;
    if (v2 == *(void *)v4) {
      BOOL v5 = *(_DWORD *)(result + 280) < *(_DWORD *)(v4 + 8);
    }
    if (!v5)
    {
LABEL_7:
      if (!*(void *)(result + 328)) {
        return result;
      }
      unsigned int v3 = &_calcMinTimeout_locked_sKickerTime;
    }
  }
  *a2 = (uint64_t)v3;
  return result;
}

BOOL __CFNativeSocketIsValid(int a1)
{
  return (fcntl(a1, 3, 0) & 0x80000000) == 0 || *__error() != 9;
}

UInt8 *clearInvalidFileDescriptors(UInt8 *result)
{
  if (result)
  {
    BOOL v1 = (__CFData *)result;
    int v2 = 8 * CFDataGetLength((CFDataRef)result);
    CFSocketError result = CFDataGetMutableBytePtr(v1);
    if (v2 >= 1)
    {
      unsigned int v3 = result;
      for (unsigned int i = 0; i != v2; ++i)
      {
        CFSocketError result = (UInt8 *)__darwin_check_fd_set_overflow(i, v3, 1);
        if (result)
        {
          uint64_t v5 = i >> 5;
          if ((*((_DWORD *)v3 + v5) & (1 << i)) != 0)
          {
            CFSocketError result = (UInt8 *)__CFNativeSocketIsValid(i);
            if (!result)
            {
              CFSocketError result = (UInt8 *)__darwin_check_fd_set_overflow(i, v3, 1);
              if (result) {
                *((_DWORD *)v3 + v5) &= ~(1 << i);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

char *__CFSocketCopyRunLoopToWakeUp(__CFRunLoopSource *a1, CFArrayRef theArray)
{
  if (!a1) {
    return 0;
  }
  int Count = CFArrayGetCount(theArray);
  if (Count < 1) {
    return 0;
  }
  unsigned int ValueAtIndex = (char *)CFArrayGetValueAtIndex(theArray, 0);
  if (ValueAtIndex && Count != 1)
  {
    for (CFIndex i = 1; i < Count; ++i)
    {
      int v7 = (char *)CFArrayGetValueAtIndex(theArray, i);
      if (v7 != ValueAtIndex) {
        break;
      }
    }
    if (v7 != ValueAtIndex) {
      unsigned int ValueAtIndex = 0;
    }
  }
  if (ValueAtIndex)
  {
    CFRetain(ValueAtIndex);
  }
  else
  {
    int v8 = 0;
    int v9 = 0;
    uint64_t v10 = Count;
    do
    {
      CFArrayRef v11 = (__CFRunLoop *)CFArrayGetValueAtIndex(theArray, (CFIndex)ValueAtIndex);
      CFStringRef v12 = CFRunLoopCopyCurrentMode(v11);
      if (v12)
      {
        CFStringRef v13 = v12;
        if (CFRunLoopContainsSource(v11, a1, v12))
        {
          int IsWaiting = CFRunLoopIsWaiting(v11);
          int v15 = v9 ? v8 : (int)ValueAtIndex;
          BOOL v16 = IsWaiting != 0;
          if (IsWaiting)
          {
            int v8 = (int)ValueAtIndex;
          }
          else
          {
            int v9 = 1;
            int v8 = v15;
          }
        }
        else
        {
          BOOL v16 = 0;
        }
        CFRelease(v13);
        if (v16) {
          break;
        }
      }
      ++ValueAtIndex;
    }
    while ((uint64_t)ValueAtIndex < v10);
    unsigned int ValueAtIndex = (char *)CFArrayGetValueAtIndex(theArray, v8);
    CFRetain(ValueAtIndex);
    CFArrayRemoveValueAtIndex(theArray, v8);
    CFArrayAppendValue(theArray, ValueAtIndex);
  }
  return ValueAtIndex;
}

void __CFSocketHandleNameRegistryReply(__CFSocket *a1, int a2, const __CFData *a3, CFDataRef data, uint64_t a5)
{
  CFDictionaryRef v8 = (const __CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, data, 0, 0, 0);
  CFDictionaryRef v9 = v8;
  if (*(void *)a5) {
    **(void **)a5 = -1;
  }
  if (v8)
  {
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFDictionaryGetTypeID())
    {
      CFStringRef Value = CFDictionaryGetValue(v9, @"Result");
      if (Value)
      {
        if (*(void *)a5) {
          **(void **)a5 = 0;
        }
        if (*(void *)(a5 + 8)) {
          **(void **)(a5 + 8) = CFRetain(Value);
        }
        CFStringRef v12 = *(CFDataRef **)(a5 + 16);
        if (v12)
        {
          if (a3)
          {
            CFDataRef Copy = CFDataCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
            CFStringRef v12 = *(CFDataRef **)(a5 + 16);
          }
          else
          {
            CFDataRef Copy = 0;
          }
          *CFStringRef v12 = Copy;
        }
      }
    }
    CFRelease(v9);
  }

  CFSocketInvalidate(a1);
}

uint64_t __CFDateIntervalFormatterDeallocate(void *a1)
{
  int v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  unsigned int v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[5];
  if (v5) {
    CFRelease(v5);
  }
  int v6 = (const void *)a1[6];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t result = a1[7];
  if (result)
  {
    return udtitvfmt_close();
  }
  return result;
}

uint64_t CFDateIntervalFormatterCreate(__objc2_class **a1, const void *a2, unint64_t a3, unint64_t a4)
{
  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1) {
      a1 = &__kCFAllocatorSystemDefault;
    }
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x45uLL, 80, 0);
  uint64_t v8 = Instance;
  if (Instance)
  {
    uint64_t v9 = 2;
    if (a3 >= 5) {
      uint64_t v10 = 2;
    }
    else {
      uint64_t v10 = a3;
    }
    if (a4 < 5) {
      uint64_t v9 = a4;
    }
    *(void *)(Instance + 64) = v10;
    *(void *)(Instance + 72) = v9;
    if (a2) {
      CFTypeRef v11 = CFRetain(a2);
    }
    else {
      CFTypeRef v11 = 0;
    }
    *(void *)(v8 + 16) = v11;
    *(void *)(v8 + 24) = 0;
    *(void *)(v8 + 32) = 0;
    *(void *)(v8 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    *(void *)(v8 + 48) = CFRetain(&stru_1ECE10768);
    *(void *)(v8 + 56) = 0;
    *(void *)(v8 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    *(_DWORD *)(v8 + 88) = 0;
    *(unsigned char *)(v8 + 92) &= 0xFCu;
  }
  return v8;
}

void _CFDateIntervalFormatterInitializeFromCoderValues(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, int a6, int a7, const void *a8, const void *a9, const void *a10)
{
  locCFIndex k = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 64) = a2;
  *(void *)(a1 + 72) = a3;
  CFDataRef v18 = *(const void **)(a1 + 48);
  if (v18 != a4)
  {
    if (v18) {
      CFRelease(v18);
    }
    if (a4) {
      CFRetain(a4);
    }
    *(void *)(a1 + 48) = a4;
  }
  CFIndex v19 = *(const void **)(a1 + 40);
  if (v19 != a5)
  {
    if (v19) {
      CFRelease(v19);
    }
    if (a5) {
      CFRetain(a5);
    }
    *(void *)(a1 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = a5;
  }
  *(unsigned char *)(a1 + 92) = (a6 != 0) | (2 * (a7 != 0)) | *(unsigned char *)(a1 + 92) & 0xFC;
  CFIndex v20 = *(const void **)(a1 + 16);
  if (v20 != a8)
  {
    if (v20) {
      CFRelease(v20);
    }
    if (a8) {
      CFRetain(a8);
    }
    *(void *)(a1 + 16) = a8;
  }
  uint64_t v21 = *(const void **)(a1 + 24);
  if (v21 != a9)
  {
    if (v21) {
      CFRelease(v21);
    }
    if (a9) {
      CFRetain(a9);
    }
    *(void *)(a1 + 24) = a9;
  }
  CFTypeRef v22 = *(const void **)(a1 + 32);
  if (v22 != a10)
  {
    if (v22) {
      CFRelease(v22);
    }
    if (a10) {
      CFRetain(a10);
    }
    *(void *)(a1 + 32) = a10;
  }

  os_unfair_lock_unlock(lock);
}

void _CFDateIntervalFormatterCopyCoderValues(uint64_t a1, void *a2, void *a3, void *a4, void *a5, unsigned char *a6, BOOL *a7, void *a8, void *a9, void *a10)
{
  CFDataRef v18 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v19 = *(void *)(a1 + 72);
  *a2 = *(void *)(a1 + 64);
  *a3 = v19;
  uint64_t v20 = *(void *)(a1 + 48);
  if (v20) {
    CFRetain(*(CFTypeRef *)(a1 + 48));
  }
  *a4 = v20;
  uint64_t v21 = *(void *)(a1 + 40);
  if (v21) {
    CFRetain(*(CFTypeRef *)(a1 + 40));
  }
  *a5 = v21;
  *a6 = *(unsigned char *)(a1 + 92) & 1;
  *a7 = (*(unsigned char *)(a1 + 92) & 2) != 0;
  uint64_t v22 = *(void *)(a1 + 16);
  if (v22) {
    CFRetain(*(CFTypeRef *)(a1 + 16));
  }
  *a8 = v22;
  uint64_t v23 = *(void *)(a1 + 24);
  if (v23) {
    CFRetain(*(CFTypeRef *)(a1 + 24));
  }
  *a9 = v23;
  CFIndex v24 = *(const void **)(a1 + 32);
  if (v24) {
    CFRetain(v24);
  }
  *a10 = v24;

  os_unfair_lock_unlock(v18);
}

uint64_t CFDateIntervalFormatterCreateCopy(__objc2_class **a1, uint64_t a2)
{
  __CFCheckCFInfoPACSignature(a2);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a2);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 88));
  uint64_t v5 = CFDateIntervalFormatterCreate(a1, *(const void **)(a2 + 16), *(void *)(a2 + 64), *(void *)(a2 + 72));
  int v6 = *(void **)(a2 + 24);
  if (v6) {
    *(void *)(v5 + 24) = _CFCalendarCreateCopy((uint64_t)a1, v6);
  }
  int v7 = *(const void **)(a2 + 32);
  if (v7) {
    *(void *)(v5 + 32) = CFRetain(v7);
  }
  CFStringRef v8 = *(const __CFString **)(a2 + 40);
  if (v8) {
    *(void *)(v5 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = CFStringCreateCopy((CFAllocatorRef)a1, v8);
  }
  CFStringRef v9 = *(const __CFString **)(a2 + 48);
  if (v9) {
    *(void *)(v5 + 48) = CFStringCreateCopy((CFAllocatorRef)a1, v9);
  }
  *(_OWORD *)(v5 + 64) = *(_OWORD *)(a2 + 64);
  char v10 = *(unsigned char *)(v5 + 92) & 0xFE | *(unsigned char *)(a2 + 92) & 1;
  *(unsigned char *)(v5 + 92) = v10;
  *(unsigned char *)(v5 + 92) = v10 & 0xFD | *(unsigned char *)(a2 + 92) & 2;
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 88));
  return v5;
}

CFLocaleRef CFDateIntervalFormatterCopyLocale(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  unsigned int v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  unint64_t v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRetain(v4);
    os_unfair_lock_unlock(v3);
    return (CFLocaleRef)v4;
  }
  else
  {
    os_unfair_lock_unlock(v3);
    return CFLocaleCopyCurrent();
  }
}

void CFDateIntervalFormatterSetLocale(uint64_t a1, const __CFLocale *a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFLocaleRef v5 = *(const __CFLocale **)(a1 + 16);
  if (v5 != a2)
  {
    if (v5) {
      CFRelease(v5);
    }
    if (a2) {
      CFLocaleRef Copy = CFLocaleCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
    }
    else {
      CFLocaleRef Copy = 0;
    }
    *(void *)(a1 + 16) = Copy;
    *(unsigned char *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((void *)a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

void updateDateTemplateFromCurrentSettings(void *a1)
{
  CFDateFormatterStyle v2 = a1[8];
  CFDateFormatterStyle v3 = a1[9];
  unint64_t v4 = (const void *)a1[2];
  if (v4) {
    CFLocaleRef v5 = (const __CFLocale *)CFRetain(v4);
  }
  else {
    CFLocaleRef v5 = CFLocaleCopyCurrent();
  }
  CFLocaleRef v6 = v5;
  CFTypeRef Value = (CFTypeRef)a1[3];
  if (!Value) {
    CFTypeRef Value = CFLocaleGetValue(v5, @"kCFLocaleCalendarKey");
  }
  CFStringRef v8 = CFDateFormatterCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, v2, v3);
  CFDateFormatterSetProperty(v8, @"kCFDateFormatterCalendarKey", Value);
  CFRelease(v6);
  CFStringRef Format = CFDateFormatterGetFormat(v8);
  char v10 = (const void *)a1[5];
  if (v10) {
    CFRelease(v10);
  }
  a1[5] = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Format);

  CFRelease(v8);
}

CFCalendarRef CFDateIntervalFormatterCopyCalendar(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFCalendarRef v3 = *(CFCalendarRef *)(a1 + 24);
  if (v3)
  {
    CFTypeRef Value = *(__CFCalendar **)(a1 + 24);
  }
  else
  {
    CFLocaleRef v5 = *(const __CFLocale **)(a1 + 16);
    if (!v5)
    {
      CFCalendarRef v3 = CFCalendarCopyCurrent();
      goto LABEL_7;
    }
    CFTypeRef Value = (__CFCalendar *)CFLocaleGetValue(v5, @"kCFLocaleCalendarKey");
    CFCalendarRef v3 = Value;
  }
  CFRetain(Value);
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  return v3;
}

void CFDateIntervalFormatterSetCalendar(uint64_t a1, void *a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFLocaleRef v5 = *(const void **)(a1 + 24);
  if (v5 != a2)
  {
    if (v5) {
      CFRelease(v5);
    }
    if (a2) {
      uint64_t Copy = _CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, a2);
    }
    else {
      uint64_t Copy = 0;
    }
    *(void *)(a1 + 24) = Copy;
    *(unsigned char *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((void *)a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

CFTimeZoneRef CFDateIntervalFormatterCopyTimeZone(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  unint64_t v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRetain(v4);
    os_unfair_lock_unlock(v3);
    return (CFTimeZoneRef)v4;
  }
  else
  {
    os_unfair_lock_unlock(v3);
    return CFTimeZoneCopyDefault();
  }
}

void CFDateIntervalFormatterSetTimeZone(uint64_t a1, const void *a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFLocaleRef v5 = *(const void **)(a1 + 32);
  if (v5 != a2)
  {
    if (v5) {
      CFRelease(v5);
    }
    if (a2) {
      CFTypeRef v6 = CFRetain(a2);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *(void *)(a1 + 32) = v6;
    *(unsigned char *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((void *)a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

const void *CFDateIntervalFormatterCopyDateTemplate(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFCalendarRef v3 = *(const void **)(a1 + 48);
  if (v3 || (CFCalendarRef v3 = *(const void **)(a1 + 40)) != 0) {
    CFRetain(v3);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  return v3;
}

void CFDateIntervalFormatterSetDateTemplate(uint64_t a1, const __CFString *a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  if (a2) {
    CFStringRef v5 = a2;
  }
  else {
    CFStringRef v5 = &stru_1ECE10768;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (!CFEqual(v5, *(CFTypeRef *)(a1 + 48)))
  {
    CFTypeRef v6 = *(const void **)(a1 + 48);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 48) = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
    *(unsigned char *)(a1 + 92) |= 3u;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t CFDateIntervalFormatterGetDateStyle(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v4 = *(void *)(a1 + 64);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFDateIntervalFormatterSetDateStyle(uint64_t a1, uint64_t a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 64) = a2;
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a1 + 92) & 0xFC | 1;
  updateDateTemplateFromCurrentSettings((void *)a1);

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t CFDateIntervalFormatterGetTimeStyle(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v4 = *(void *)(a1 + 72);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFDateIntervalFormatterSetTimeStyle(uint64_t a1, uint64_t a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 72) = a2;
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a1 + 92) & 0xFC | 1;
  updateDateTemplateFromCurrentSettings((void *)a1);

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t _CFDateIntervalFormatterGetBoundaryStyle(uint64_t a1)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v4 = *(void *)(a1 + 80);
  os_unfair_lock_unlock(v3);
  return v4;
}

void _CFDateIntervalFormatterSetBoundaryStyle(uint64_t a1, uint64_t a2)
{
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = a2;
  *(unsigned char *)(a1 + 92) |= 1u;

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

CFStringRef CFDateIntervalFormatterCreateStringFromDateToDate(uint64_t a1, const __CFDate *a2, const __CFDate *a3)
{
  uint64_t v50 = *(void *)off_1ECE0A5B0;
  __CFCheckCFInfoPACSignature(a1);
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v6 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v6);
  }
  int v7 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v8 = *(void *)(a1 + 56);
  if (*(unsigned char *)(a1 + 92))
  {
    if (v8)
    {
      udtitvfmt_close();
      *(void *)(a1 + 56) = 0;
      *(unsigned char *)(a1 + 92) &= ~1u;
    }
  }
  else if (v8)
  {
    goto LABEL_29;
  }
  CFLocaleRef v9 = *(const __CFLocale **)(a1 + 16);
  if (v9) {
    CFRetain(*(CFTypeRef *)(a1 + 16));
  }
  else {
    CFLocaleRef v9 = CFLocaleCopyCurrent();
  }
  CFTypeRef Value = *(CFTypeRef *)(a1 + 24);
  if (!Value) {
    CFTypeRef Value = CFLocaleGetValue(v9, @"kCFLocaleCalendarKey");
  }
  CFStringRef Identifier = CFLocaleGetIdentifier(v9);
  ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, Identifier);
  Mutableuint64_t Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, ComponentsFromLocaleIdentifier);
  CFRelease(ComponentsFromLocaleIdentifier);
  if (Value) {
    CFDictionarySetValue(MutableCopy, @"kCFLocaleCalendarKey", Value);
  }
  CFStringRef LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy);
  CFRelease(MutableCopy);
  int v49 = 0;
  memset(buffer, 0, sizeof(buffer));
  CFStringGetCString(LocaleIdentifierFromComponents, (char *)buffer, 100, 0x8000100u);
  CFRelease(LocaleIdentifierFromComponents);
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  *(_OWORD *)UniChar chars = 0u;
  long long v34 = 0u;
  CFTimeZoneRef v15 = *(const __CFTimeZone **)(a1 + 32);
  if (v15) {
    CFRetain(*(CFTypeRef *)(a1 + 32));
  }
  else {
    CFTimeZoneRef v15 = CFTimeZoneCopyDefault();
  }
  CFStringRef Name = CFTimeZoneGetName(v15);
  if (CFStringGetLength(Name) > 99) {
    v17.CFIndex length = 100;
  }
  else {
    v17.CFIndex length = CFStringGetLength(Name);
  }
  v17.CFIndex location = 0;
  CFStringGetCharacters(Name, v17, chars);
  uint64_t v18 = 48;
  if ((*(unsigned char *)(a1 + 92) & 2) == 0) {
    uint64_t v18 = 40;
  }
  CFStringRef v19 = *(const __CFString **)(a1 + v18);
  uint64_t v47 = 0;
  memset(v46, 0, sizeof(v46));
  if (CFStringGetLength(v19) > 99) {
    v20.CFIndex length = 100;
  }
  else {
    v20.CFIndex length = CFStringGetLength(v19);
  }
  v20.CFIndex location = 0;
  CFStringGetCharacters(v19, v20, (UniChar *)v46);
  CFStringGetLength(v19);
  CFStringGetLength(Name);
  uint64_t v21 = udtitvfmt_open();
  *(void *)(a1 + 56) = v21;
  if (v21
    || (u_errorName(U_ZERO_ERROR),
        CFLog(3, @"udtitvfmt_open failed!  Formatter is NULL! -- locale: %s, template: %@, timezone: %@, status: %s", v22, v23, v24, v25, v26, v27, (__int16)buffer), *(void *)(a1 + 56)))
  {
    udtitvfmt_setAttribute();
  }
  CFRelease(v9);
  CFRelease(v15);
  if (!*(void *)(a1 + 56))
  {
    CFStringRef v31 = &stru_1ECE10768;
    goto LABEL_33;
  }
LABEL_29:
  CFDateGetAbsoluteTime(a2);
  CFDateGetAbsoluteTime(a3);
  bzero(chars, 0x7D0uLL);
  LODWORD(v46[0]) = 0;
  int v28 = udtitvfmt_format();
  if (v28 < 1001)
  {
    CFStringRef v31 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, v28);
  }
  else
  {
    int v29 = (UniChar *)malloc_type_calloc(v28, 2uLL, 0x1000040BDFB0063uLL);
    LODWORD(v46[0]) = 0;
    int v30 = udtitvfmt_format();
    CFStringRef v31 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v29, v30);
    free(v29);
  }
LABEL_33:
  os_unfair_lock_unlock(v7);
  return v31;
}

CFStringRef CFDateIntervalFormatterCreateStringFromDateInterval(uint64_t a1, uint64_t a2)
{
  CFDateRef started = (const __CFDate *)CFDateIntervalCopyStartDate(a2);
  CFDateRef v5 = CFDateIntervalCopyEndDate(a2);
  CFStringRef StringFromDateToDate = CFDateIntervalFormatterCreateStringFromDateToDate(a1, started, v5);
  CFRelease(started);
  CFRelease(v5);
  return StringFromDateToDate;
}

uint64_t _CFBundleGetLanguageCodeForLocalization(const __CFString *a1)
{
  uint64_t v15 = *(void *)off_1ECE0A5B0;
  CFIndex Length = CFStringGetLength(a1);
  if ((unint64_t)(Length - 2) > 0xFD) {
    return 0xFFFFFFFFLL;
  }
  CFIndex v3 = Length;
  if (!CFStringGetCString(a1, buffer, 255, 0x600u)) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = 0;
  char v14 = 0;
  do
  {
    unint64_t v5 = v4;
    int v6 = strcmp(buffer, __CFBundleLanguageNamesArray[v4]);
    if (!v6) {
      break;
    }
    unint64_t v4 = v5 + 1;
  }
  while (v5 < 0x97);
  BOOL v7 = *(_DWORD *)buffer == 1415538810 && *(unsigned __int16 *)&buffer[4] == 87;
  if (v7 || *(void *)buffer == 0x746E61482D687ALL) {
    return 19;
  }
  BOOL v8 = *(_DWORD *)buffer == 1130326138 && *(unsigned __int16 *)&buffer[4] == 78;
  uint64_t result = 33;
  if (!v8)
  {
    uint64_t result = *(void *)buffer == 0x736E61482D687ALL ? 33 : v5;
    if (*(void *)buffer != 0x736E61482D687ALL && v6)
    {
      if (v3 != 2)
      {
        if (buffer[2] < 0
           ? __maskrune(buffer[2], 0x100uLL)
           : *((_DWORD *)off_1ECE0A578 + buffer[2] + 15) & 0x100)
        {
          return 0xFFFFFFFFLL;
        }
      }
      if (buffer[0] == 110 && buffer[1] == 111)
      {
        return 9;
      }
      else
      {
        unint64_t v11 = 0;
        uint64_t result = 0xFFFFFFFFLL;
        while (buffer[0] != byte_182DA23A7[v11] || buffer[1] != byte_182DA23A7[v11 + 1])
        {
          BOOL v12 = v11 >= 0x1C5;
          v11 += 3;
          if (v12) {
            return result;
          }
        }
        return (unsigned __int16)v11 / 3u;
      }
    }
  }
  return result;
}

uint64_t _CFBundleGetRegionCodeForLocalization(const __CFString *a1)
{
  uint64_t v8 = *(void *)off_1ECE0A5B0;
  if ((unint64_t)(CFStringGetLength(a1) - 2) > 3 || !CFStringGetCString(a1, buffer, 6, 0x600u)) {
    goto LABEL_14;
  }
  unint64_t v2 = 0;
  buffer[5] = 0;
  uint64_t v3 = __CFBundleLocaleAbbreviationsArray;
  do
  {
    if (!strcmp(buffer, (const char *)(v3 + v2))) {
      uint64_t result = (unsigned __int16)v2 / 6u;
    }
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
    if (result != -1) {
      break;
    }
    BOOL v5 = v2 >= 0x288;
    v2 += 6;
  }
  while (!v5);
  if ((int)result <= 27)
  {
    if (result != -1)
    {
      if (result == 25) {
        return 68;
      }
      return result;
    }
LABEL_14:
    unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(a1);
    return _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
  }
  if (result == 28) {
    return 82;
  }
  if (result == 37) {
    return 0;
  }
  return result;
}

uint64_t _CFBundleGetLanguageCodeForRegionCode(unsigned int a1)
{
  if (a1 == 52) {
    return 33;
  }
  if (a1 > 0x6C) {
    return 0xFFFFFFFFLL;
  }
  if (!__CFBundleLocaleAbbreviationsArray) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v2 = (unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + 6 * a1);
  if (!*v2) {
    return 0xFFFFFFFFLL;
  }
  for (unint64_t i = 0; *v2 != byte_182DA23A7[i] || v2[1] != byte_182DA23A7[i + 1]; i += 3)
  {
    if (i >= 0x1C5) {
      return 0xFFFFFFFFLL;
    }
  }
  return (unsigned __int16)i / 3u;
}

uint64_t _CFBundleGetRegionCodeForLanguageCode(unsigned int a1)
{
  if (a1 == 19) {
    return 53;
  }
  if (a1 > 0x97) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v2 = &byte_182DA23A7[3 * a1];
  if (!*v2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = 0;
  while (*(unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + v3) != *v2
       || *(unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + v3 + 1) != v2[1])
  {
    BOOL v4 = v3 >= 0x288;
    v3 += 6;
    if (v4)
    {
      unsigned int v5 = -1;
      goto LABEL_11;
    }
  }
  if ((unsigned __int16)v3 - 150 < 6) {
    return 68;
  }
  unsigned int v5 = (unsigned __int16)v3 / 6;
LABEL_11:
  if (v5 == 28) {
    return 82;
  }
  else {
    return v5;
  }
}

CFStringRef _CFBundleCopyLanguageAbbreviationForLanguageCode(unsigned int a1)
{
  if (a1 <= 0x97 && (BOOL v1 = &byte_182DA23A7[3 * a1], *v1)) {
    return CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
  }
  else {
    return 0;
  }
}

CFArrayRef CFBundleCopyLocalizationsForURL(CFURLRef url)
{
  v15[1] = *(const void **)off_1ECE0A5B0;
  CFBundleRef v2 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, url);
  v15[0] = 0;
  if (v2)
  {
    CFBundleRef v4 = v2;
    CFArrayRef v5 = (const __CFArray *)_CFBundleCopyBundleLocalizations((uint64_t)v2, 0);
    CFRelease(v4);
    return v5;
  }
  else
  {
    CFDictionaryRef v7 = _CFBundleCopyInfoDictionaryInExecutable(url, v3);
    if (!v7) {
      return 0;
    }
    CFDictionaryRef v8 = v7;
    CFTypeRef Value = CFDictionaryGetValue(v7, @"CFBundleLocalizations");
    if (!Value
      || (char v10 = Value, v11 = CFGetTypeID(Value), v11 != CFArrayGetTypeID())
      || (CFStringRef v12 = (const __CFString *)CFRetain(v10)) == 0)
    {
      CFStringRef v12 = (const __CFString *)_copyAppleLocalizations(v8);
      if (!v12)
      {
        CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(v8, @"CFBundleDevelopmentRegion");
        CFStringRef v12 = v13;
        v15[0] = v13;
        if (v13)
        {
          CFTypeID v14 = CFGetTypeID(v13);
          if (v14 == CFStringGetTypeID() && CFStringGetLength(v12) >= 1) {
            CFStringRef v12 = (const __CFString *)CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, 1, &kCFTypeArrayCallBacks);
          }
          else {
            CFStringRef v12 = 0;
          }
        }
      }
    }
    CFRelease(v8);
    return (CFArrayRef)v12;
  }
}

void _CFBundleFlushLanguageCachesAfterEUIDChange()
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  _CFBundleFlushBundleCaches((uint64_t)MainBundle);
  _CFLocaleResetCurrent();
  os_unfair_lock_lock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  if (_CFBundleUserLanguages)
  {
    CFRelease((CFTypeRef)_CFBundleUserLanguages);
    _CFBundleUserLanguages = 0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
}

void _CFBundleSetDefaultLocalization(CFStringRef theString)
{
  if (theString) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
  }
  else {
    CFStringRef Copy = 0;
  }
  if (_defaultLocalization) {
    CFRelease((CFTypeRef)_defaultLocalization);
  }
  _defaultLocalizatiouint64_t n = (uint64_t)Copy;
}

const char *PROEM_SEL_1(const char *a1)
{
  if (a1) {
    return sel_getName(a1);
  }
  else {
    return "(null selector)";
  }
}

void __NSOrderedSetEnumerate(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v45 = *(void *)off_1ECE0A5B0;
  if ([a1 count])
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      uint64_t v6 = [a4 firstIndex];
      unint64_t v30 = [a4 lastIndex];
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v30 = [a1 count] - 1;
    }
    if (v6 != 0x7FFFFFFFFFFFFFFFLL && v30 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (a3)
      {
        uint64_t v7 = __CFActiveProcessorCount();
        if (v7 < 2) {
          a3 &= ~1uLL;
        }
      }
      else
      {
        uint64_t v7 = 1;
      }
      if ((a3 & 3) != 0)
      {
        unint64_t v8 = (v30 - v6 + 1) / v7 / v7;
        if (v8 >= 0x10)
        {
          if (v8 <= 0x1000) {
            unint64_t v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0;
          }
          else {
            unint64_t v9 = 4096;
          }
        }
        else
        {
          unint64_t v9 = 16;
        }
        unint64_t v17 = v9 + v30 - v6;
        uint64_t v36 = 0;
        long long v37 = &v36;
        uint64_t v38 = 0x2020000000;
        uint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
        size_t v18 = v17 / v9;
        if (a3)
        {
          v34[0] = 0;
          v34[1] = v34;
          v34[2] = 0x2020000000;
          char v35 = 0;
          block[0] = off_1ECE0A5A0;
          block[1] = 3221225472;
          block[2] = ____NSOrderedSetEnumerate_block_invoke;
          block[3] = &unk_1ECDB0760;
          void block[10] = v9;
          block[11] = v30;
          block[12] = a3;
          void block[4] = a1;
          void block[5] = a4;
          void block[7] = v34;
          void block[8] = &v36;
          block[6] = a2;
          void block[9] = v6;
          dispatch_apply(v18, 0, block);
          _Block_object_dispose(v34, 8);
        }
        else if (v9 <= v17)
        {
          uint64_t v19 = 0;
          unint64_t v20 = v9 - 1;
          if (v18 <= 1) {
            uint64_t v21 = 1;
          }
          else {
            uint64_t v21 = v17 / v9;
          }
          uint64_t v22 = v21 - 1;
          unint64_t v23 = v6;
          unint64_t v24 = v30;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v20 >= v24 - v6) {
                unint64_t v26 = v6;
              }
              else {
                unint64_t v26 = 1 - v9 + v24;
              }
              unint64_t v25 = v24;
            }
            else
            {
              if (v20 >= v24 - v6) {
                unint64_t v25 = v30;
              }
              else {
                unint64_t v25 = v20 + v19 * v9 + v6;
              }
              unint64_t v26 = v23;
            }
            BOOL v27 = __NSOrderedSetChunkIterate(a1, a3, v26, v25, a4, a2, (unint64_t *)v37 + 3, 0, 0);
            ++v19;
            if (v22) {
              int v28 = v27;
            }
            else {
              int v28 = 1;
            }
            --v22;
            v24 -= v9;
            v23 += v9;
          }
          while (v28 != 1);
        }
        _Block_object_dispose(&v36, 8);
      }
      else
      {
        unint64_t v29 = v6;
        LOBYTE(v34[0]) = 0;
        char v10 = (void *)_CFAutoreleasePoolPush();
        long long v41 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
        if (v11)
        {
          unint64_t v12 = 0;
          uint64_t v13 = 0;
          uint64_t v14 = *(void *)v42;
          do
          {
            for (uint64_t i = 0; i != v11; ++i)
            {
              if (*(void *)v42 != v14) {
                objc_enumerationMutation(a1);
              }
              unint64_t v16 = v13 + i;
              if ((a3 & 0x1000000000000000) == 0
                || v29 <= v16 && v16 <= v30 && [a4 containsIndex:v13 + i])
              {
                __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(a2);
                if (v12 < 0x3FF)
                {
                  ++v12;
                }
                else
                {
                  _CFAutoreleasePoolPop(v10);
                  char v10 = (void *)_CFAutoreleasePoolPush();
                  unint64_t v12 = 0;
                }
              }
            }
            uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
            v13 += i;
          }
          while (v11);
        }
        _CFAutoreleasePoolPop(v10);
      }
    }
  }
}