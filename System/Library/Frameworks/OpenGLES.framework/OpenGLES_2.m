void *writeConstant(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int *Type;
  uint64_t Value;
  char v27;
  char v28;
  char v29;
  uint64_t vars8;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(Constant:", a3, a4, a5, a6, a7, a8, v27);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v28);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v29);
      --v23;
    }
    while (v23);
  }
  Type = (unsigned int *)glpConstantNodeGetType(a2);
  Value = glpConstantNodeGetValue(a2);

  return glpAppendValueDescriptionToStringBuffer(a1, Type, Value);
}

uint64_t writeArrayAccess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ArrayAccess:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFieldAccess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(FieldAccess:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpFieldAccessNodeGetField(a2);
  char v25 = v24;
  glpFieldAccessNodeGetField(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeUndeterminedCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(UndeterminedCall:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFunctionCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(FunctionCall:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpFunctionCallNodeGetName(a2);
  char v25 = v24;
  glpFunctionCallNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeSubroutineArrayCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(SubroutineArrayCall:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeMethodCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(MethodCall:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpMethodCallNodeGetName(a2);
  char v25 = v24;
  glpMethodCallNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeConstructorCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ConstructorCall:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePostincrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Postincrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePostdecrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Postdecrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePreincrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Preincrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePredecrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Predecrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeUnaryPlus(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(UnaryPlus:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeNegate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Negate:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalNot(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LogicalNot:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseNot(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(BitwiseNot:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeMultiply(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Multiply:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeDivide(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Divide:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeModulo(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Modulo:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeAdd(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Add:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeSubtract(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Subtract:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeShiftLeft(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ShiftLeft:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeShiftRight(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ShiftRight:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Less:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLessEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LessEqual:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeGreater(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Greater:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeGreaterEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(GreaterEqual:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Equal:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeNotEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(NotEqual:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalAnd(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LogicalAnd:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalOr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LogicalOr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalXor(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LogicalXor:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseAnd(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(BitwiseAnd:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseOr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(BitwiseOr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseXor(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(BitwiseXor:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeIfExpr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(IfExpr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeAssign(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(Assign:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeOpAssign(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(OpAssign:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeReadInput(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ReadInput:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeWriteOutput(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(WriteOutput:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeCommaExpr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(CommaExpr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeParameterDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(ParameterDeclaration:", a3, a4, a5, a6, a7, a8, v40);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v41);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v42);
      --v23;
    }
    while (v23);
  }
  glpParameterDeclarationNodeGetName(a2);
  char v25 = v24;
  glpParameterDeclarationNodeGetName(a2);
  glpStringBufferAppendFormat(a1, "%.*s -> ", v26, v27, v28, v29, v30, v31, v25);
  uint64_t Extra = glpParameterDeclarationNodeGetExtra(a2);
  glpAppendVariableObjectDescription(a1, Extra, v33, v34, v35, v36, v37, v38);

  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeFunctionPrototype(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = a3;
  glpStringBufferAppendFormat(a1, "(FunctionPrototype:", a3, a4, a5, a6, a7, a8, v76);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v12, v13, v14, v15, v16, v17, v77);
  if (v9 != -1)
  {
    int v24 = v9 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v18, v19, v20, v21, v22, v23, v78);
      --v24;
    }
    while (v24);
  }
  glpFunctionPrototypeNodeGetName(a2);
  char v26 = v25;
  glpFunctionPrototypeNodeGetName(a2);
  glpFunctionPrototypeNodeGetExtra(a2);
  glpStringBufferAppendFormat(a1, "%.*s == %p", v27, v28, v29, v30, v31, v32, v26);
  if (glpFunctionPrototypeNodeGetExtra(a2) && *(void *)(glpFunctionPrototypeNodeGetExtra(a2) + 8))
  {
    glpStringBufferAppendFormat(a1, ";", v33, v34, v35, v36, v37, v38, v79);
    uint64_t Extra = glpFunctionPrototypeNodeGetExtra(a2);
    glpAppendFlagDescription(a1, *(void *)(Extra + 8));
  }
  glpStringBufferAppendFormat(a1, "\n", v33, v34, v35, v36, v37, v38, v79);
  if (glpFunctionPrototypeNodeGetExtra(a2))
  {
    if (v9 != -1)
    {
      int v46 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v40, v41, v42, v43, v44, v45, v80);
        --v46;
      }
      while (v46);
    }
    uint64_t v47 = glpFunctionPrototypeNodeGetExtra(a2);
    glpStringBufferAppendFormat(a1, "  %p\n", v48, v49, v50, v51, v52, v53, *(void *)(v47 + 72));
  }
  uint64_t result = glpFunctionPrototypeNodeGetExtra(a2);
  if (result)
  {
    if (v9 != -1)
    {
      int v61 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v55, v56, v57, v58, v59, v60, v80);
        --v61;
      }
      while (v61);
    }
    glpStringBufferAppendFormat(a1, "  ", v55, v56, v57, v58, v59, v60, v80);
    if (glpFunctionPrototypeNodeGetParameterCount(a2))
    {
      unint64_t v68 = 0;
      do
      {
        uint64_t v69 = glpFunctionPrototypeNodeGetExtra(a2);
        glpStringBufferAppendFormat(a1, "%p ", v70, v71, v72, v73, v74, v75, *(void *)(*(void *)(v69 + 80) + 8 * v68++));
      }
      while (v68 < glpFunctionPrototypeNodeGetParameterCount(a2));
    }
    return glpStringBufferAppendFormat(a1, "\n", v62, v63, v64, v65, v66, v67, a9);
  }
  return result;
}

uint64_t writeVariableDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = a3;
  glpStringBufferAppendFormat(a1, "(VariableDeclaration:", a3, a4, a5, a6, a7, a8, v83);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v12, v13, v14, v15, v16, v17, v84);
  if (v9 != -1)
  {
    int v24 = v9 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v18, v19, v20, v21, v22, v23, v85);
      --v24;
    }
    while (v24);
  }
  glpVariableDeclarationNodeGetName(a2);
  char v26 = v25;
  glpVariableDeclarationNodeGetName(a2);
  glpStringBufferAppendFormat(a1, "%.*s -> ", v27, v28, v29, v30, v31, v32, v26);
  uint64_t Extra = glpVariableDeclarationNodeGetExtra(a2);
  glpAppendVariableObjectDescription(a1, Extra, v34, v35, v36, v37, v38, v39);
  glpStringBufferAppendCString(a1, "\n");
  if (glpVariableDeclarationNodeGetExtra(a2) && *(void *)(glpVariableDeclarationNodeGetExtra(a2) + 64))
  {
    if (v9 != -1)
    {
      int v46 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v40, v41, v42, v43, v44, v45, v86);
        --v46;
      }
      while (v46);
    }
    SaType = (unsigned int *)glpASTNodeGetSaType(a2);
    uint64_t v48 = (uint64_t *)(glpVariableDeclarationNodeGetExtra(a2) + 64);
LABEL_16:
    glpAppendValueDescriptionToStringBuffer(a1, SaType, *v48);
    glpStringBufferAppendFormat(a1, "\n", v56, v57, v58, v59, v60, v61, v86);
    goto LABEL_17;
  }
  if (glpVariableDeclarationNodeGetExtra(a2) && *(void *)(glpVariableDeclarationNodeGetExtra(a2) + 72))
  {
    if (v9 != -1)
    {
      int v55 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v49, v50, v51, v52, v53, v54, v86);
        --v55;
      }
      while (v55);
    }
    SaType = (unsigned int *)glpASTNodeGetSaType(a2);
    uint64_t v48 = (uint64_t *)(glpVariableDeclarationNodeGetExtra(a2) + 72);
    goto LABEL_16;
  }
LABEL_17:
  uint64_t result = glpVariableDeclarationNodeGetExtra(a2);
  if (result)
  {
    uint64_t result = glpVariableDeclarationNodeGetExtra(a2);
    if (*(void *)(result + 8))
    {
      if (v9 != -1)
      {
        int v69 = v9 + 1;
        do
        {
          glpStringBufferAppendFormat(a1, "    ", v63, v64, v65, v66, v67, v68, v86);
          --v69;
        }
        while (v69);
      }
      uint64_t v70 = glpVariableDeclarationNodeGetExtra(a2);
      writeLayoutObject(a1, *(uint64_t ***)(v70 + 8), v71, v72, v73, v74, v75, v76);
      return glpStringBufferAppendFormat(a1, "\n", v77, v78, v79, v80, v81, v82, a9);
    }
  }
  return result;
}

uint64_t writeVariableDeclarationGroup(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(VariableDeclarationGroup:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePrecisionDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(PrecisionDeclaration:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifiedDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(QualifiedDeclaration:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifiedDeclarationGroup(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(QualifiedDeclarationGroup:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFunctionDefinition(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(FunctionDefinition:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifiedType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(QualifiedType:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePrimitiveType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(PrimitiveType:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  unsigned int Type = glpPrimitiveTypeNodeGetType(a2);
  char v25 = glpPrimitiveTypeToString(Type);
  return glpStringBufferAppendFormat(a1, "%s", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeArrayType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ArrayType:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFieldDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(FieldDeclaration:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpFieldDeclarationNodeGetName(a2);
  char v25 = v24;
  glpFieldDeclarationNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeStructType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(StructType:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpStructTypeNodeGetName(a2);
  char v25 = v24;
  glpStructTypeNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

void *writeInterfaceBlock(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(InterfaceBlock:", a3, a4, a5, a6, a7, a8, v52);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v53);
  uint64_t Extra = glpInterfaceBlockNodeGetExtra(a2);
  if (v8 != -1)
  {
    int v24 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v54);
      --v24;
    }
    while (v24);
  }
  uint64_t BlockName = glpInterfaceBlockNodeGetBlockName(a2);
  glpStringBufferAppendString(a1, BlockName, v26);
  if (!glpInterfaceBlockNodeGetHasInstanceName(a2))
  {
    uint64_t result = glpStringBufferAppendCString(a1, "\n");
    if (!Extra) {
      return result;
    }
    goto LABEL_10;
  }
  glpStringBufferAppendCString(a1, " ");
  uint64_t InstanceName = glpInterfaceBlockNodeGetInstanceName(a2);
  glpStringBufferAppendString(a1, InstanceName, v28);
  if (Extra)
  {
    if (glpInterfaceBlockNodeGetDimension(a2))
    {
      char ElementCount = glpBankTypeGetElementCount(*(void *)(Extra + 64));
      glpStringBufferAppendFormat(a1, "[%u]", v30, v31, v32, v33, v34, v35, ElementCount);
    }
    glpStringBufferAppendCString(a1, "\n");
LABEL_10:
    uint64_t result = (void *)glpInterfaceBlockObjectGetVariableObjectCount(Extra);
    if (result)
    {
      uint64_t v43 = 0;
      uint64_t v44 = result;
      do
      {
        if (v8 != -1)
        {
          int v45 = v8 + 1;
          do
          {
            glpStringBufferAppendFormat(a1, "    ", v37, v38, v39, v40, v41, v42, v54);
            --v45;
          }
          while (v45);
        }
        glpStringBufferAppendCString(a1, "  -> ");
        glpAppendVariableObjectDescription(a1, *(void *)(*(void *)(Extra + 72) + 8 * v43), v46, v47, v48, v49, v50, v51);
        uint64_t result = glpStringBufferAppendCString(a1, "\n");
        ++v43;
      }
      while (v43 != v44);
    }
    return result;
  }

  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeLayoutType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LayoutType:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeKeywordQualifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(KeywordQualifier:", a3, a4, a5, a6, a7, a8, v27);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v28);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v29);
      --v23;
    }
    while (v23);
  }
  unsigned int Qualifier = glpKeywordQualifierNodeGetQualifier(a2);
  char v25 = glpQualifierName(Qualifier);

  return glpStringBufferAppendCString(a1, v25);
}

uint64_t writeLayoutQualifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LayoutQualifier:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeSubroutineTypeList(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(SubroutineTypeList:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifierList(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(QualifierList:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeGlobalTypeQualifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = a3;
  glpStringBufferAppendFormat(a1, "(GlobalTypeQualifier:", a3, a4, a5, a6, a7, a8, v39);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v12, v13, v14, v15, v16, v17, v40);
  uint64_t result = glpGlobalTypeQualifierNodeGetLayout(a2);
  if (result)
  {
    if (v9 != -1)
    {
      int v25 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v19, v20, v21, v22, v23, v24, v41);
        --v25;
      }
      while (v25);
    }
    Layout = (uint64_t **)glpGlobalTypeQualifierNodeGetLayout(a2);
    writeLayoutObject(a1, Layout, v27, v28, v29, v30, v31, v32);
    return glpStringBufferAppendFormat(a1, "\n", v33, v34, v35, v36, v37, v38, a9);
  }
  return result;
}

uint64_t writeLayoutPair(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(LayoutPair:", a3, a4, a5, a6, a7, a8, v41);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v42);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v43);
      --v23;
    }
    while (v23);
  }
  uint64_t Identifier = glpLayoutPairNodeGetIdentifier(a2);
  glpStringBufferAppendString(a1, Identifier, v25);
  uint64_t result = glpLayoutPairNodeGetValueKind(a2);
  switch((int)result)
  {
    case 0:
    case 2:
      return result;
    case 1:
      char Value = glpLayoutPairNodeGetValue(a2);
      uint64_t result = glpStringBufferAppendFormat(a1, "=%d", v27, v28, v29, v30, v31, v32, Value);
      break;
    case 3:
      glpLayoutPairNodeGetString(a2);
      char v34 = v33;
      glpLayoutPairNodeGetString(a2);
      uint64_t result = glpStringBufferAppendFormat(a1, "=%.*s", v35, v36, v37, v38, v39, v40, v34);
      break;
    default:
      abort();
  }
  return result;
}

uint64_t writeExpressionStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ExpressionStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeBlock(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(Block:", a3, a4, a5, a6, a7, a8, v26);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v27);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v28);
      --v23;
    }
    while (v23);
  }
  if (glpBlockNodeGetNeedsNewScope(a2)) {
    uint64_t v24 = "--new scope--\n";
  }
  else {
    uint64_t v24 = "no new scope\n";
  }

  return glpStringBufferAppendCString(a1, v24);
}

uint64_t writeIfStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(IfStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLoopStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(LoopStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeSwitchStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(SwitchStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeCaseStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(CaseStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeDefaultStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(DefaultStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBreakStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(BreakStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeContinueStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ContinueStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeDiscardStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(DiscardStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeReturnStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(ReturnStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeTopLevel(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(TopLevel:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeAvailabilityDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(AvailabilityDeclaration:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeRawCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(RawCall:", a3, a4, a5, a6, a7, a8, v27);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v28);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v29);
      --v23;
    }
    while (v23);
  }
  uint64_t v24 = glpRawCallNodeGetName(a2);
  glpStringBufferAppendString(a1, v24, v25);

  return glpStringBufferAppendCString(a1, "\n");
}

void *writeSubroutineRawCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(SubroutineRawCall:", a3, a4, a5, a6, a7, a8, v26);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v27);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v28);
      --v23;
    }
    while (v23);
  }
  uint64_t v24 = (void *)glpSubroutineRawCallNodeGetExtra(a2);
  glpStringBufferAppendString(a1, *v24, v24[1]);

  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeOffset(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(Offset:", a3, a4, a5, a6, a7, a8, v44);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v45);
  int v17 = v8 + 1;
  unsigned int Swizzle = glpOffsetNodeGetSwizzle(a2);
  if (Swizzle)
  {
    uint64_t v25 = Swizzle & 7;
    if ((Swizzle & 7) != 0)
    {
      uint64_t v26 = 0;
      char v27 = v47;
      do
      {
        *v27++ = aXyzw[(Swizzle >> (v26 + 3)) & 3];
        v26 += 2;
      }
      while (2 * (Swizzle & 7) != v26);
    }
    else
    {
      uint64_t v25 = 0;
    }
    v47[v25] = 0;
    if (v8 != -1)
    {
      int v28 = v8 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v19, v20, v21, v22, v23, v24, v46);
        --v28;
      }
      while (v28);
    }
    glpStringBufferAppendFormat(a1, ".%s\n", v19, v20, v21, v22, v23, v24, (char)v47);
  }
  uint64_t result = glpOffsetNodeGetPreSwizzlePrimitiveType(a2);
  if (result)
  {
    unsigned int v36 = result;
    if (v8 != -1)
    {
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v30, v31, v32, v33, v34, v35, v46);
        --v17;
      }
      while (v17);
    }
    char v37 = glpPrimitiveTypeToString(v36);
    return glpStringBufferAppendFormat(a1, "pre-swizzle type: %s\n", v38, v39, v40, v41, v42, v43, v37);
  }
  return result;
}

void *writeLValue(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(LValue:", a3, a4, a5, a6, a7, a8, v40);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v41);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v42);
      --v23;
    }
    while (v23);
  }
  glpLValueNodeGetVariableName(a2);
  char v25 = v24;
  glpLValueNodeGetVariableName(a2);
  glpStringBufferAppendFormat(a1, "%.*s -> ", v26, v27, v28, v29, v30, v31, v25);
  Variableuint64_t Extra = glpLValueNodeGetVariableExtra(a2);
  glpAppendVariableObjectDescription(a1, VariableExtra, v33, v34, v35, v36, v37, v38);

  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeRValue(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(RValue:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeIBPartialDeref(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  glpStringBufferAppendFormat(a1, "(IBPartialDeref:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);

  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePPStreamOp(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(PPStreamOp:", a3, a4, a5, a6, a7, a8, v106);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v107);
  if (v8 == -1)
  {
    ReturnPrimitiveunsigned int Type = glpPPStreamOpNodeGetReturnPrimitiveType(a2);
    char v40 = glpPrimitiveTypeToString(ReturnPrimitiveType);
    glpStringBufferAppendFormat(a1, "returnPrimitiveType: %s\n", v41, v42, v43, v44, v45, v46, v40);
  }
  else
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v108);
      --v23;
    }
    while (v23);
    unsigned int v24 = glpPPStreamOpNodeGetReturnPrimitiveType(a2);
    char v25 = glpPrimitiveTypeToString(v24);
    glpStringBufferAppendFormat(a1, "returnPrimitiveType: %s\n", v26, v27, v28, v29, v30, v31, v25);
    int v38 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v32, v33, v34, v35, v36, v37, v109);
      --v38;
    }
    while (v38);
  }
  int Opcode = glpPPStreamOpNodeGetOpcode(a2);
  glpStringBufferAppendFormat(a1, "opcode: %s\n", v48, v49, v50, v51, v52, v53, (char)(&ppstreamOpString)[Opcode]);
  if (v8 == -1)
  {
    OpPrimitiveunsigned int Type = glpPPStreamOpNodeGetOpPrimitiveType(a2);
    char v77 = glpPrimitiveTypeToString(OpPrimitiveType);
    glpStringBufferAppendFormat(a1, "opPrimitiveType: %s\n", v78, v79, v80, v81, v82, v83, v77);
  }
  else
  {
    int v60 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v54, v55, v56, v57, v58, v59, v110);
      --v60;
    }
    while (v60);
    unsigned int v61 = glpPPStreamOpNodeGetOpPrimitiveType(a2);
    char v62 = glpPrimitiveTypeToString(v61);
    glpStringBufferAppendFormat(a1, "opPrimitiveType: %s\n", v63, v64, v65, v66, v67, v68, v62);
    int v75 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v69, v70, v71, v72, v73, v74, v111);
      --v75;
    }
    while (v75);
  }
  char HasSrctex = glpPPStreamOpNodeGetHasSrctex(a2);
  glpStringBufferAppendFormat(a1, "has_srctex: %d\n", v85, v86, v87, v88, v89, v90, HasSrctex);
  if (v8 != -1)
  {
    int v97 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v91, v92, v93, v94, v95, v96, v112);
      --v97;
    }
    while (v97);
  }
  char HasOffset = glpPPStreamOpNodeGetHasOffset(a2);
  return glpStringBufferAppendFormat(a1, "has_offset: %d\n", v99, v100, v101, v102, v103, v104, HasOffset);
}

void *writeSubroutineUniform(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  glpStringBufferAppendFormat(a1, "(SubroutineUniform:", a3, a4, a5, a6, a7, a8, v26);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v27);
  if (v8 != -1)
  {
    int v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v28);
      --v23;
    }
    while (v23);
  }
  uint64_t Extra = (void *)glpSubroutineUniformNodeGetExtra(a2);
  glpStringBufferAppendString(a1, *Extra, Extra[1]);

  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t *writeSAInfo(uint64_t *a1, uint64_t a2)
{
  Saunsigned int Type = glpASTNodeGetSaType(a2);
  glpDumpTypeToStringBuffer(a1, SaType, v5, v6, v7, v8, v9, v10, v19);
  uint64_t result = (uint64_t *)glpASTNodeGetSaFlags(a2);
  if (result)
  {
    glpStringBufferAppendFormat(a1, ";", v12, v13, v14, v15, v16, v17, v20);
    uint64_t SaFlags = glpASTNodeGetSaFlags(a2);
    return glpAppendFlagDescription(a1, SaFlags);
  }
  return result;
}

uint64_t writeLayoutObject(uint64_t *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = glpStringBufferAppendFormat(a1, "layout:", a3, a4, a5, a6, a7, a8, v26);
  uint64_t v11 = *a2;
  if (*a2)
  {
    do
    {
      uint64_t v12 = (uint64_t *)*v11;
      char v13 = glpLayoutQualifierToString(*((_DWORD *)v11 + 2));
      uint64_t result = glpStringBufferAppendFormat(a1, "%s ", v14, v15, v16, v17, v18, v19, v13);
      if (*((_DWORD *)v11 + 3) == 1) {
        uint64_t result = glpStringBufferAppendFormat(a1, "= %d ", v20, v21, v22, v23, v24, v25, *((_DWORD *)v11 + 4));
      }
      uint64_t v11 = v12;
    }
    while (v12);
  }
  return result;
}

uint64_t phase2AddDef(uint64_t *a1, uint64_t a2)
{
  if (glpIsFunctionDefinitionNode(a2))
  {
    uint64_t Prototype = glpFunctionDefinitionNodeGetPrototype(a2);
    unint64_t Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
    uint64_t v6 = glpPointerHashGet(a1[16], Extra);
    uint64_t v7 = Prototype;
LABEL_3:
    glpFunctionPrototypeNodeSetExtra(v7, v6);
    if (glpPointerHashGet(a1[22], v6)) {
      return 1;
    }
    uint64_t v9 = a1[22];
    goto LABEL_5;
  }
  if (glpIsVariableDeclarationNode(a2))
  {
    unint64_t v11 = glpVariableDeclarationNodeGetExtra(a2);
    uint64_t v12 = glpPointerHashGet(a1[15], v11);
    glpVariableDeclarationNodeSetExtra(a2, v12);
    if (glpPointerHashGet(a1[21], v12)) {
      return 1;
    }
    glpPointerHashPut(a1[21], v12, v12, v13);
    BOOL v10 = (*(unsigned char *)(v12 + 51) & 0x60) != 0;
    goto LABEL_10;
  }
  if (!glpIsInterfaceBlockNode(a2))
  {
    if (glpIsSubroutineUniformNode(a2))
    {
      uint64_t v20 = glpSubroutineUniformNodeGetExtra(a2);
      if (glpStringHashGet(a1[20], *(const char **)v20, *(void *)(v20 + 8))) {
        return 1;
      }
      glpStringHashPut(a1[20], *(const char **)v20, *(void *)(v20 + 8), v20, v21);
      goto LABEL_6;
    }
    unint64_t v22 = glpFunctionPrototypeNodeGetExtra(a2);
    uint64_t v6 = glpPointerHashGet(a1[16], v22);
    uint64_t v7 = a2;
    goto LABEL_3;
  }
  uint64_t v6 = glpInterfaceBlockNodeGetExtra(a2);
  if (glpPointerHashGet(a1[23], v6)) {
    return 1;
  }
  uint64_t v9 = a1[23];
LABEL_5:
  glpPointerHashPut(v9, v6, v6, v8);
LABEL_6:
  BOOL v10 = 0;
LABEL_10:
  uint64_t v14 = phase2Process(a1, a2);
  if (v14 == -1) {
    return 0;
  }
  uint64_t v15 = v14;
  uint64_t v16 = (void *)*a1;
  uint64_t v17 = a1[19];
  if (v10) {
    unsigned int DefCount = 0;
  }
  else {
    unsigned int DefCount = glpTopLevelNodeGetDefCount(v17);
  }
  glpTopLevelNodeInsertDef(v16, v17, v15, DefCount);
  return 1;
}

uint64_t phase2Process(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2)
  {
    if (!glpASTNodeGetChildCount(a2))
    {
LABEL_6:
      switch(glpASTNodeGetKind(v2))
      {
        case 0u:
        case 1u:
        case 2u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x50u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
          return v2;
        case 3u:
          phase2ProcessConstant((uint64_t)a1, v2);
          return v2;
        case 0x2Cu:
          phase2ProcessParameterDeclaration((uint64_t)a1, v2);
          return v2;
        case 0x2Du:
          phase2ProcessFunctionPrototype((uint64_t)a1, v2);
          return v2;
        case 0x2Eu:
          phase2ProcessVariableDeclaration((uint64_t)a1, v2);
          return v2;
        case 0x39u:
          phase2ProcessInterfaceBlock((uint64_t)a1, v2);
          return v2;
        case 0x4Eu:
          return phase2ProcessRawCall((uint64_t)a1, v2);
        case 0x4Fu:
          return phase2ProcessSubroutineRawCall(a1, v2);
        case 0x51u:
          return phase2ProcessLValue((void **)a1, v2);
        case 0x55u:
          return phase2ProcessSubroutineUniform((uint64_t)a1, v2);
        default:
          abort();
      }
    }
    unsigned int v4 = 0;
    while (1)
    {
      uint64_t Child = glpASTNodeGetChild(v2, v4);
      uint64_t v6 = phase2Process(a1, Child);
      if (v6 == -1) {
        return -1;
      }
      glpASTNodeSetChild(v2, v4++, v6);
      if (v4 >= glpASTNodeGetChildCount(v2)) {
        goto LABEL_6;
      }
    }
  }
  return v2;
}

uint64_t phase2ProcessConstant(uint64_t a1, uint64_t a2)
{
  char SaFlags = glpASTNodeGetSaFlags(a2);
  unsigned int Type = (unsigned int *)glpConstantNodeGetType(a2);
  char Value = (char *)glpConstantNodeGetValue(a2);
  uint64_t v7 = glpMergeRemapValue(a1, SaFlags, Type, Value);
  glpConstantNodeSetValue(a2, v7);
  return a2;
}

uint64_t phase2ProcessParameterDeclaration(uint64_t a1, uint64_t a2)
{
  unint64_t Extra = glpParameterDeclarationNodeGetExtra(a2);
  uint64_t v5 = (uint64_t *)glpPointerHashGet(*(void *)(a1 + 120), Extra);
  glpParameterDeclarationNodeSetExtra(a2, (uint64_t)v5);
  lazyPrepareVariableObject(a1, (uint64_t)v5);
  glpASTNodeSetSaType(a2, *v5);
  return a2;
}

uint64_t phase2ProcessFunctionPrototype(uint64_t a1, uint64_t a2)
{
  unint64_t Extra = glpFunctionPrototypeNodeGetExtra(a2);
  uint64_t v5 = glpPointerHashGet(*(void *)(a1 + 128), Extra);
  glpFunctionPrototypeNodeSetExtra(a2, v5);
  return a2;
}

uint64_t phase2ProcessVariableDeclaration(uint64_t a1, uint64_t a2)
{
  unint64_t Extra = (uint64_t *)glpVariableDeclarationNodeGetExtra(a2);
  lazyPrepareVariableObject(a1, (uint64_t)Extra);
  glpASTNodeSetSaType(a2, *Extra);
  return a2;
}

uint64_t phase2ProcessInterfaceBlock(uint64_t a1, uint64_t a2)
{
  uint64_t Extra = glpInterfaceBlockNodeGetExtra(a2);
  uint64_t v6 = *(void *)(**(void **)(Extra + 72) + 48);
  if ((v6 & 0x20000000) != 0)
  {
    uint64_t v7 = (uint64_t *)(a1 + 224);
  }
  else if ((v6 & 0x40000000) != 0)
  {
    uint64_t v7 = (uint64_t *)(a1 + 232);
  }
  else
  {
    if ((v6 & 0x100000000) == 0) {
      goto LABEL_8;
    }
    uint64_t v7 = (uint64_t *)(a1 + 240);
  }
  glpStringHashPut(*v7, *(const char **)Extra, *(void *)(Extra + 8), Extra, v5);
LABEL_8:
  unsigned int VariableObjectCount = glpInterfaceBlockObjectGetVariableObjectCount(Extra);
  if (VariableObjectCount)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 8 * VariableObjectCount;
    do
    {
      lazyPrepareVariableObject(a1, *(void *)(*(void *)(Extra + 72) + v9));
      v9 += 8;
    }
    while (v10 != v9);
  }
  return a2;
}

uint64_t phase2ProcessRawCall(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = glpRawCallNodeGetExtra(a2);
  uint64_t v5 = glpPointerHashGet(*(void *)(a1 + 128), v4);
  if (!v5)
  {
    uint64_t v5 = glpStringHashGet(*(void *)(a1 + 48), *(const char **)(v4 + 40), *(void *)(v4 + 48));
    if (v5) {
      glpPointerHashPut(*(void *)(a1 + 128), v4, v5, v6);
    }
  }
  glpRawCallNodeSetExtra(a2, v5);
  uint64_t v7 = glpPointerHashGet(*(void *)(a1 + 96), v5);
  if (!v7)
  {
    uint64_t v17 = *(uint64_t ***)(a1 + 8);
    unsigned int v18 = *(_DWORD *)(a1 + 24);
    int v19 = *(_DWORD *)(v4 + 32);
    char v27 = "-1";
    uint64_t v28 = 0xEDA00000002;
    uint64_t v29 = 0xFFFFFFFFLL;
    glpLanguageToString(v18);
    glpLogMessage(v17, 0, (uint64_t)&v27, "No definition of %.*s in %s shader", v20, v21, v22, v23, v19);
    return -1;
  }
  if (*(unsigned char *)(v5 + 128))
  {
    double v8 = *(const char **)(v4 + 24);
    unsigned int v9 = *(_DWORD *)(v4 + 32);
    if (v9 >= 0x12) {
      size_t v10 = 18;
    }
    else {
      size_t v10 = v9;
    }
    int v15 = strncmp("$SubroutineStatic$", v8, v10);
    uint64_t v16 = *(uint64_t ***)(a1 + 8);
    char v27 = "-1";
    uint64_t v28 = 0xEDA00000002;
    uint64_t v29 = 0xFFFFFFFFLL;
    if (v15) {
      char v26 = v9;
    }
    else {
      char v26 = v9 - 18;
    }
    glpLogMessage(v16, 0, (uint64_t)&v27, "Recursive function call to %.*s", v11, v12, v13, v14, v26);
    return -1;
  }
  *(unsigned char *)(v5 + 128) = 1;
  int v24 = phase2AddDef(a1, v7);
  *(unsigned char *)(v5 + 128) = 0;
  if (v24) {
    return a2;
  }
  else {
    return -1;
  }
}

uint64_t phase2ProcessSubroutineRawCall(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v4 = glpSubroutineRawCallNodeGetExtra(a2);
  uint64_t v5 = glpPointerHashGet(a1[14], v4);
  if (!v5)
  {
    unsigned int v18 = (uint64_t **)a1[1];
    unsigned int v19 = *((_DWORD *)a1 + 6);
    int v20 = *(_DWORD *)(v4 + 8);
    uint64_t v33 = "-1";
    uint64_t v34 = 0xEDA00000002;
    uint64_t v35 = 0xFFFFFFFFLL;
    glpLanguageToString(v19);
    glpLogMessage(v18, 0, (uint64_t)&v33, "No definition of subroutine uniform %.*s in %s shader", v21, v22, v23, v24, v20);
    return -1;
  }
  uint64_t v6 = v5;
  Elementunsigned int Type = *(unsigned int **)(v4 + 16);
  if (glpTypeGetKind(ElementType) == 2) {
    Elementunsigned int Type = (unsigned int *)glpArrayTypeGetElementType((uint64_t)ElementType);
  }
  uint64_t v8 = *((unsigned int *)a1 + 71);
  if (v8)
  {
    unsigned int v9 = (unsigned int **)a1[36];
    uint64_t v10 = *((unsigned int *)a1 + 71);
    while (ElementType != *v9)
    {
      ++v9;
      if (!--v10) {
        goto LABEL_8;
      }
    }
    uint64_t v25 = (uint64_t **)a1[1];
    unsigned int v26 = *((_DWORD *)a1 + 6);
    int v27 = *(_DWORD *)(v4 + 8);
    uint64_t v33 = "-1";
    uint64_t v34 = 0xEDA00000002;
    uint64_t v35 = 0xFFFFFFFFLL;
    glpLanguageToString(v26);
    glpLogMessage(v25, 0, (uint64_t)&v33, "Potentially recursive subroutine call through subroutine uniform %.*s in %s shader", v28, v29, v30, v31, v27);
    return -1;
  }
LABEL_8:
  int v11 = v8 + 1;
  int v12 = *((_DWORD *)a1 + 70);
  if ((int)v8 + 1 <= v12)
  {
    uint64_t v16 = (char *)a1[36];
    int v17 = *((_DWORD *)a1 + 71);
  }
  else
  {
    if (v12 <= 1) {
      int v12 = 1;
    }
    int v13 = 2 * v12;
    if (v13 <= v11) {
      unsigned int v14 = v8 + 1;
    }
    else {
      unsigned int v14 = v13;
    }
    uint64_t v15 = *a1;
    uint64_t v16 = (char *)(*(uint64_t (**)(void, uint64_t, const char *))(*a1 + 8))(*(void *)*a1, 8 * v14, "Vector Storage (GLPType *, growth)");
    memcpy(v16, (const void *)a1[36], 8 * *((unsigned int *)a1 + 71));
    (*(void (**)(void, uint64_t))(v15 + 24))(*(void *)v15, a1[36]);
    *((_DWORD *)a1 + 70) = v14;
    a1[36] = (uint64_t)v16;
    int v17 = *((_DWORD *)a1 + 71);
  }
  memmove(&v16[8 * v8 + 8], &v16[8 * v8], 8 * (v17 - v8));
  *(void *)(a1[36] + 8 * v8) = ElementType;
  ++*((_DWORD *)a1 + 71);
  if (!phase2AddDef(a1, v6)) {
    return -1;
  }
  memmove((void *)(a1[36] + 8 * v8), (const void *)(a1[36] + 8 * v11), 8 * (*((_DWORD *)a1 + 71) - v11));
  --*((_DWORD *)a1 + 71);
  return v2;
}

uint64_t phase2ProcessLValue(void **a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v60 = *MEMORY[0x263EF8340];
  Variableuint64_t Extra = glpLValueNodeGetVariableExtra(a2);
  unint64_t v5 = VariableExtra;
  if (*((unsigned char *)a1 + 32))
  {
    uint64_t v6 = *(uint64_t **)(VariableExtra + 8);
    if (v6)
    {
      if (glpLayoutObjectFind(v6, 82))
      {
        int v11 = (uint64_t **)a1[1];
        int v12 = *(_DWORD *)(v5 + 40);
        v58.n128_u64[0] = (unint64_t)"-1";
        v58.n128_u64[1] = 0xEDA00000002;
        uint64_t v59 = 0xFFFFFFFFLL;
        glpLogMessage(v11, 0, (uint64_t)&v58, "Built-in variable '%.*s' must be redeclared before use, with separate shader objects.", v7, v8, v9, v10, v12);
        return -1;
      }
    }
  }
  uint64_t v13 = glpPointerHashGet((uint64_t)a1[15], v5);
  if (v13)
  {
    unint64_t v14 = v13;
    glpLValueNodeSetVariableExtra(v2, v13);
    uint64_t v15 = glpPointerHashGet((uint64_t)a1[11], v14);
    if (v15)
    {
      unint64_t v5 = v14;
      if (!phase2AddDef(a1, v15)) {
        return -1;
      }
    }
    else
    {
      unint64_t v5 = v14;
    }
  }
  lazyPrepareVariableObject((uint64_t)a1, v5);
  if (*(void *)(v5 + 120))
  {
    uint64_t Offset = glpDerefNodeGetOffset(v2);
    if (Offset
      && (uint64_t v17 = Offset, (OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset)) != 0)
      && (uint64_t v19 = OffsetExpr, glpIsConstantNode(OffsetExpr)))
    {
      char Value = (unsigned int *)glpConstantNodeGetValue(v19);
      Saunsigned int Type = glpASTNodeGetSaType(v19);
      unsigned int AsSize = glpValueGetAsSize(SaType, Value);
      if (glpOffsetNodeGetPreSwizzlePrimitiveType(v17))
      {
        PreSwizzlePrimitiveunsigned int Type = glpOffsetNodeGetPreSwizzlePrimitiveType(v17);
        Primitiveunsigned int Type = (uint64_t)glpGetPrimitiveType(PreSwizzlePrimitiveType);
      }
      else
      {
        Primitiveunsigned int Type = glpASTNodeGetSaType(v2);
      }
      unsigned int v29 = glpABIGetTypeSize(0, PrimitiveType, 0);
      int Size = glpTypeSizeGetSize(v29);
      unsigned int v31 = Size + AsSize;
      BitSetSetRangeEquals(*(void *)(v5 + 120), AsSize, Size + AsSize, 1);
      unsigned int v32 = *(_DWORD *)(v5 + 128);
      if (v32 <= v31) {
        unsigned int v32 = v31;
      }
      *(_DWORD *)(v5 + 128) = v32;
    }
    else
    {
      Elementunsigned int Type = *(unsigned int **)v5;
      if (glpTypeGetKind(*(unsigned int **)v5) == 3) {
        Elementunsigned int Type = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
      }
      unsigned int v26 = glpABIGetTypeSize(0, (uint64_t)ElementType, 0);
      uint64_t v27 = glpTypeSizeGetSize(v26);
      MEMORY[0x270FA5388](v27);
      glpTypeGetAppleVec4Types(ElementType, (__n128 *)((char *)&v58 - v28), 1, 0, 0, 0, *(void *)(v5 + 120), 0, 0);
      *(_DWORD *)(v5 + 128) = BitSetLastSetBit(*(void *)(v5 + 120)) + 1;
    }
  }
  uint64_t v33 = glpDerefNodeGetOffset(v2);
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t BankIndex = glpOffsetNodeGetBankIndex(v33);
    glpTypeGetKind(*(unsigned int **)v5);
    if (BankIndex)
    {
      int Bank = glpBankTypeGetBank(*(void *)v5);
      if ((Bank - 1) < 2 || Bank == 4)
      {
        glpBankTypeGetElementCount(*(void *)v5);
        uint64_t v37 = glpBankTypeGetElementType(*(void *)v5);
        unsigned int v38 = glpABIGetTypeSize(0, v37, 0);
        uint64_t v39 = glpTypeSizeGetSize(v38);
        uint64_t v40 = glpOffsetNodeGetOffsetExpr(v34);
        if (!v40)
        {
          uint64_t IntConstantNode = makeIntConstantNode((uint64_t *)a1, 0);
          uint64_t v40 = phase2Process(a1, IntConstantNode);
        }
        uint64_t v42 = makeIntConstantNode((uint64_t *)a1, v39);
        uint64_t v43 = phase2Process(a1, v42);
        uint64_t v44 = glpGetPrimitiveType(5u);
        glpASTNodeSetSaType(v43, (uint64_t)v44);
        glpASTNodeSetSaFlags(v43, 96);
        uint64_t v45 = (uint64_t)*a1;
        v58.n128_u64[0] = (unint64_t)"-1";
        v58.n128_u64[1] = 0xEDA00000002;
        uint64_t v59 = 0xFFFFFFFFLL;
        uint64_t PPStreamOpNode = glpMakePPStreamOpNode(v45, &v58, 5, 34, 5, 0, 0);
        glpCallNodeAddArg(*a1, PPStreamOpNode, BankIndex);
        glpCallNodeAddArg(*a1, PPStreamOpNode, v43);
        uint64_t v47 = glpGetPrimitiveType(5u);
        glpASTNodeSetSaType(PPStreamOpNode, (uint64_t)v47);
        uint64_t SaFlags = glpASTNodeGetSaFlags(BankIndex);
        uint64_t v49 = glpASTNodeGetSaFlags(v43);
        glpASTNodeSetSaFlags(PPStreamOpNode, v49 & SaFlags);
        uint64_t v50 = glpConstantFold((uint64_t)*a1, (uint64_t)a1[31], PPStreamOpNode);
        uint64_t v51 = (uint64_t)*a1;
        v58.n128_u64[0] = (unint64_t)"-1";
        v58.n128_u64[1] = 0xEDA00000002;
        uint64_t v59 = 0xFFFFFFFFLL;
        uint64_t v52 = glpMakePPStreamOpNode(v51, &v58, 5, 31, 5, 0, 0);
        glpCallNodeAddArg(*a1, v52, v50);
        glpCallNodeAddArg(*a1, v52, v40);
        uint64_t v53 = glpGetPrimitiveType(5u);
        glpASTNodeSetSaType(v52, (uint64_t)v53);
        uint64_t v54 = glpASTNodeGetSaFlags(v50);
        uint64_t v55 = glpASTNodeGetSaFlags(v40);
        glpASTNodeSetSaFlags(v52, v55 & v54);
        uint64_t v56 = glpConstantFold((uint64_t)*a1, (uint64_t)a1[31], v52);
        glpOffsetNodeSetOffsetExpr(v34, v56);
        glpOffsetNodeSetBankIndex(v34, 0);
      }
      else if (!Bank)
      {
        abort();
      }
    }
  }
  return v2;
}

uint64_t phase2ProcessSubroutineUniform(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t Extra = glpSubroutineUniformNodeGetExtra(a2);
  Elementunsigned int Type = *(unsigned int **)(Extra + 16);
  if (glpTypeGetKind(ElementType) == 2) {
    Elementunsigned int Type = (unsigned int *)glpArrayTypeGetElementType((uint64_t)ElementType);
  }
  uint64_t v6 = glpPointerHashGet(*(void *)(a1 + 144), (unint64_t)ElementType);
  if (v6 && (uint64_t v11 = v6, *(_DWORD *)(v6 + 4)))
  {
    uint64_t v12 = 0;
    while (phase2AddDef(a1, *(void *)(*(void *)(v11 + 8) + 8 * v12)))
    {
      if (++v12 >= (unint64_t)*(unsigned int *)(v11 + 4)) {
        return v2;
      }
    }
  }
  else
  {
    uint64_t v13 = *(uint64_t ***)(a1 + 8);
    int v14 = *(_DWORD *)(Extra + 8);
    v16[0] = "-1";
    v16[1] = 0xEDA00000002;
    v16[2] = 0xFFFFFFFFLL;
    glpLogMessage(v13, 0, (uint64_t)v16, "Subroutine uniform '%.*s' has no possible implementations", v7, v8, v9, v10, v14);
  }
  return -1;
}

uint64_t lazyPrepareVariableObject(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 128) || *(void *)(a2 + 120)) {
    return result;
  }
  uint64_t v3 = result;
  if (!*(_DWORD *)(result + 20)
    && *(_DWORD *)(result + 24) == 3
    && (*(unsigned char *)(a2 + 51) & 0x20) != 0
    && glpTypeGetKind(*(unsigned int **)a2) == 3)
  {
    uint64_t v4 = *(void *)v3;
    Elementunsigned int Type = glpBankTypeGetElementType(*(void *)a2);
    *(void *)a2 = glpMakeBankType(v4, 1, ElementType, *(_DWORD *)(v3 + 28));
  }
  int Kind = glpTypeGetKind(*(unsigned int **)a2);
  uint64_t v7 = *(int **)a2;
  if (Kind == 3)
  {
    uint64_t v8 = (int *)glpBankTypeGetElementType((uint64_t)v7);
    if (!glpTypeIsSized(v8))
    {
      uint64_t v10 = *(void *)v3;
      uint64_t v11 = glpArrayTypeGetElementType((uint64_t)v8);
      Arrayunsigned int Type = glpMakeArrayType(v10, v11, *(_DWORD *)(a2 + 100), -1);
      uint64_t v13 = *(void *)v3;
      int Bank = glpBankTypeGetBank(*(void *)a2);
      int ElementCount = glpBankTypeGetElementCount(*(void *)a2);
      Bankunsigned int Type = glpMakeBankType(v13, Bank, ArrayType, ElementCount);
LABEL_13:
      *(void *)a2 = BankType;
    }
  }
  else if (!glpTypeIsSized(v7))
  {
    uint64_t v17 = *(void *)v3;
    uint64_t v18 = glpArrayTypeGetElementType(*(void *)a2);
    Bankunsigned int Type = glpMakeArrayType(v17, v18, *(_DWORD *)(a2 + 96), -1);
    goto LABEL_13;
  }
  uint64_t v19 = *(void *)(a2 + 48);
  if (*(_DWORD *)(v3 + 24) == 4 && (*(void *)(a2 + 48) & 0x60000000) == 0x60000000)
  {
    glpStringHashPut(*(void *)(v3 + 192), *(const char **)(a2 + 16), *(void *)(a2 + 24), a2, v9);
    goto LABEL_17;
  }
  if ((v19 & 0x20000000) != 0)
  {
    uint64_t v24 = *(void *)(v3 + 192);
    uint64_t v25 = *(const char **)(a2 + 16);
    uint64_t v26 = *(void *)(a2 + 24);
    goto LABEL_25;
  }
  if ((v19 & 0x40000000) != 0)
  {
LABEL_17:
    glpStringHashPut(*(void *)(v3 + 200), *(const char **)(a2 + 16), *(void *)(a2 + 24), a2, v9);
    uint64_t v20 = *(void *)(v3 + 216);
    uint64_t v21 = apiName(*(void **)v3, a2);
    uint64_t v23 = v22;
    uint64_t v24 = v20;
    uint64_t v25 = (const char *)v21;
    uint64_t v26 = v23;
LABEL_25:
    glpStringHashPut(v24, v25, v26, a2, v9);
    BOOL v27 = 1;
    goto LABEL_26;
  }
  if ((v19 & 0x100000000) != 0)
  {
    glpStringHashPut(*(void *)(v3 + 208), *(const char **)(a2 + 16), *(void *)(a2 + 24), a2, v9);
LABEL_34:
    BOOL v27 = *(void *)(a2 + 88) == 0;
    goto LABEL_26;
  }
  if (glpTypeGetKind(*(unsigned int **)a2) == 2
    || glpTypeGetKind(*(unsigned int **)a2) == 1)
  {
    goto LABEL_34;
  }
  BOOL v27 = 0;
LABEL_26:
  uint64_t v28 = *(void *)a2;
  if (glpTypeGetKind(*(unsigned int **)a2) == 3) {
    uint64_t v28 = glpBankTypeGetElementType(v28);
  }
  if (v27)
  {
    uint64_t v29 = *(void *)v3;
    unsigned int v30 = glpABIGetTypeSize(0, v28, 0);
    unsigned int Size = glpTypeSizeGetSize(v30);
    uint64_t v32 = BitSetNewWithAllocator(Size, *(void *)v29, *(uint64_t (**)(uint64_t, uint64_t, const char *))(v29 + 8), *(void *)(v29 + 16), *(void *)(v29 + 24));
    int v33 = 0;
    *(void *)(a2 + 120) = v32;
  }
  else
  {
    unsigned int v34 = glpABIGetTypeSize(0, v28, 0);
    int v33 = glpTypeSizeGetSize(v34);
  }
  *(_DWORD *)(a2 + 128) = v33;
  *(void *)(a2 + 64) = glpMergeRemapValue(v3, *(void *)(a2 + 48), *(unsigned int **)a2, *(char **)(a2 + 64));
  uint64_t result = glpMergeRemapValue(v3, *(void *)(a2 + 48), *(unsigned int **)a2, *(char **)(a2 + 72));
  *(void *)(a2 + 72) = result;
  return result;
}

uint64_t apiName(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 80);
  if (!v3) {
    return *(void *)(a2 + 32);
  }
  if (glpInterfaceBlockObjectGetVariableObjectCount(*(void *)(a2 + 80)))
  {
    unint64_t v5 = 0;
    do
    {
      if (*(void *)(*(void *)(v3 + 72) + 8 * v5) == a2) {
        break;
      }
      ++v5;
    }
    while (v5 < glpInterfaceBlockObjectGetVariableObjectCount(v3));
  }
  else
  {
    LODWORD(v5) = 0;
  }
  Elementunsigned int Type = *(unsigned int **)(v3 + 64);
  if (glpTypeGetKind(ElementType) == 3) {
    Elementunsigned int Type = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
  }
  uint64_t FieldName = glpStructTypeGetFieldName((uint64_t)ElementType, v5);
  if (*(unsigned char *)(v3 + 32))
  {
    StringBuffer = glpMakeStringBuffer(a1);
    glpStringBufferAppendFormat(StringBuffer, "%.*s.%.*s", v9, v10, v11, v12, v13, v14, *(_DWORD *)(v3 + 8));
    return glpStringBufferGetString((uint64_t)StringBuffer);
  }
  return FieldName;
}

uint64_t makeIntConstantNode(uint64_t *a1, uint64_t a2)
{
  Primitiveunsigned int Type = (unsigned int *)glpGetPrimitiveType(5u);
  uint64_t v5 = *a1;
  Mutablechar Value = glpMakeMutableValue(v5, PrimitiveType, 1, v6, v7, v8, v9, v10, a2);
  v15.n128_u64[0] = (unint64_t)"-1";
  v15.n128_u64[1] = 0xEDA00000002;
  uint64_t v16 = 0xFFFFFFFFLL;
  glpMakeConstantNode(v5, &v15, (uint64_t)PrimitiveType, (uint64_t)MutableValue);
  uint64_t v13 = v12;
  glpASTNodeSetSaType(v12, (uint64_t)PrimitiveType);
  glpASTNodeSetSaFlags(v13, 96);
  return v13;
}

uint64_t glpCheckBarrier(uint64_t a1)
{
  int v2 = 0;
  return checkBarrier(a1, 0, &v2);
}

uint64_t checkBarrier(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a1) {
    return 1;
  }
  uint64_t Body = a1;
  while (2)
  {
    int Kind = glpASTNodeGetKind(Body);
    switch(Kind)
    {
      case 'C':
        uint64_t Cond = glpIfStatementNodeGetCond(Body);
        uint64_t result = checkBarrier(Cond, a2, a3);
        if (result)
        {
          uint64_t IfStatement = glpIfStatementNodeGetIfStatement(Body);
          uint64_t result = checkBarrier(IfStatement, 0, a3);
          if (result)
          {
            uint64_t ElseStatement = glpIfStatementNodeGetElseStatement(Body);
            goto LABEL_16;
          }
        }
        return result;
      case 'D':
        uint64_t Body0 = glpLoopStatementNodeGetBody0(Body);
        uint64_t result = checkBarrier(Body0, 0, a3);
        if (result)
        {
          uint64_t ElseStatement = glpLoopStatementNodeGetBody1(Body);
          goto LABEL_16;
        }
        return result;
      case 'E':
        uint64_t Expr = glpSwitchStatementNodeGetExpr(Body);
        uint64_t result = checkBarrier(Expr, a2, a3);
        if (result)
        {
          uint64_t ElseStatement = glpSwitchStatementNodeGetBody(Body);
LABEL_16:
          uint64_t Body = ElseStatement;
          a2 = 0;
          goto LABEL_17;
        }
        return result;
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
        goto LABEL_24;
      case 'K':
        uint64_t result = genericCheckKidsBarrier(Body, a2, (uint64_t)a3);
        if (!result) {
          return result;
        }
        *a3 = 0;
        return 1;
      default:
        if (Kind == 51)
        {
          uint64_t Prototype = glpFunctionDefinitionNodeGetPrototype(Body);
          uint64_t result = checkBarrier(Prototype, a2, a3);
          if (!result) {
            return result;
          }
          uint64_t v12 = glpFunctionDefinitionNodeGetPrototype(Body);
          Name = (char *)glpFunctionPrototypeNodeGetName(v12);
          if (glpStringsEqual("main", 0x83863A00000004, Name, v14))
          {
            a2 = 1;
            *a3 = 1;
          }
          uint64_t Body = glpFunctionDefinitionNodeGetBody(Body);
LABEL_17:
          if (!Body) {
            return 1;
          }
          continue;
        }
        if (Kind == 84 && glpPPStreamOpNodeGetOpcode(Body) == 170)
        {
          return a2 && *a3 != 0;
        }
        else
        {
LABEL_24:
          return genericCheckKidsBarrier(Body, a2, (uint64_t)a3);
        }
    }
  }
}

uint64_t genericCheckKidsBarrier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!glpASTNodeGetChildCount(a1)) {
    return 1;
  }
  unsigned int v6 = 0;
  while (1)
  {
    uint64_t Child = glpASTNodeGetChild(a1, v6);
    uint64_t result = checkBarrier(Child, a2, a3);
    if (!result) {
      break;
    }
    if (++v6 >= glpASTNodeGetChildCount(a1)) {
      return 1;
    }
  }
  return result;
}

uint64_t glpConstantValueFromDecomposedInitializer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int Kind = glpASTNodeGetKind(a3);
  uint64_t result = 0;
  if (Kind > 42)
  {
    if (Kind == 81)
    {
      uint64_t Offset = glpDerefNodeGetOffset(a3);
      if (!Offset) {
        return glpLValueNodeGetVariableExtra(a3) == a1;
      }
      uint64_t v26 = Offset;
      if (!glpOffsetNodeGetBankIndex(Offset)
        || (BankIndex = glpOffsetNodeGetBankIndex(v26), uint64_t result = glpIsConstantNode(BankIndex), result))
      {
        if (!glpOffsetNodeGetVectorElementExpr(v26)
          || (VectorElementuint64_t Expr = glpOffsetNodeGetVectorElementExpr(v26),
              uint64_t result = glpIsConstantNode(VectorElementExpr),
              result))
        {
          if (!glpOffsetNodeGetOffsetExpr(v26)) {
            return glpLValueNodeGetVariableExtra(a3) == a1;
          }
          uint64_t OffsetExpr = glpOffsetNodeGetOffsetExpr(v26);
          uint64_t result = glpIsConstantNode(OffsetExpr);
          if (result) {
            return glpLValueNodeGetVariableExtra(a3) == a1;
          }
        }
      }
    }
    else
    {
      if (Kind != 43) {
        return result;
      }
      int ExprCount = glpCommaExprNodeGetExprCount(a3);
      if (!ExprCount) {
        return 1;
      }
      int v22 = ExprCount;
      unsigned int v23 = 0;
      while (1)
      {
        uint64_t Expr = glpCommaExprNodeGetExpr(a3, v23);
        uint64_t result = glpConstantValueFromDecomposedInitializer(a1, a2, Expr);
        if (!result) {
          break;
        }
        if (v22 == ++v23) {
          return 1;
        }
      }
    }
  }
  else
  {
    if (Kind == 3) {
      return 1;
    }
    if (Kind == 39)
    {
      uint64_t Lhs = glpBinaryOperatorNodeGetLhs(a3);
      uint64_t Rhs = glpBinaryOperatorNodeGetRhs(a3);
      uint64_t result = glpIsLValueNode(Lhs);
      if (result)
      {
        if (glpLValueNodeGetVariableExtra(Lhs) != a1) {
          return 0;
        }
        uint64_t result = glpIsConstantNode(Rhs);
        if (!result) {
          return result;
        }
        uint64_t v10 = glpDerefNodeGetOffset(Lhs);
        if (!v10)
        {
          LODWORD(v13) = 0;
          goto LABEL_38;
        }
        uint64_t v11 = v10;
        if (glpOffsetNodeGetBankIndex(v10) || glpOffsetNodeGetVectorElementExpr(v11)) {
          return 0;
        }
        uint64_t v12 = glpOffsetNodeGetOffsetExpr(v11);
        uint64_t v13 = (unsigned int *)v12;
        if (!v12)
        {
LABEL_14:
          unsigned int Swizzle = glpOffsetNodeGetSwizzle(v11);
          if ((Swizzle & 6) == 0)
          {
            unsigned int v16 = Swizzle;
            if (Swizzle)
            {
              Saunsigned int Type = glpASTNodeGetSaType(Lhs);
              Primitiveunsigned int Type = glpPrimitiveTypeGetPrimitiveType(SaType);
              uint64_t v19 = a2 + 16 * v13;
              unsigned int v20 = (v16 >> 3) & 3;
              if (PrimitiveType <= 8)
              {
                if (PrimitiveType != 1 && PrimitiveType != 5) {
                  goto LABEL_45;
                }
              }
              else if (PrimitiveType != 9 && PrimitiveType != 36)
              {
                if (PrimitiveType == 62)
                {
                  *(void *)(v19 + 8 * v20) = *(void *)glpConstantNodeGetValue(Rhs);
                  return 1;
                }
LABEL_45:
                abort();
              }
              *(_DWORD *)(v19 + 4 * v20) = *(_DWORD *)glpConstantNodeGetValue(Rhs);
              return 1;
            }
LABEL_38:
            uint64_t v30 = glpASTNodeGetSaType(Rhs);
            char Value = (const void *)glpConstantNodeGetValue(Rhs);
            glpCopyValueInto((void *)(a2 + 16 * v13), v30, Value);
            return 1;
          }
          return 0;
        }
        uint64_t result = glpIsConstantNode(v12);
        if (result)
        {
          uint64_t v14 = (unsigned int *)glpASTNodeGetSaType((uint64_t)v13);
          uint64_t v13 = (unsigned int *)glpConstantNodeGetValue((uint64_t)v13);
          uint64_t result = glpValueIsUsableAsSize(v14, v13);
          if (result)
          {
            LODWORD(v13) = glpValueGetAsSize((uint64_t)v14, v13);
            goto LABEL_14;
          }
        }
      }
    }
  }
  return result;
}

uint64_t glpConstantFold(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((unint64_t)(a3 + 1) < 2 || (glpASTNodeGetSaFlags(a3) & 0x80) != 0) {
    return a3;
  }
  switch(glpASTNodeGetKind(a3))
  {
    case 0u:
      return foldTypeConversion(a1, a2, a3);
    case 3u:
      return foldConstant(a1, a2, a3);
    case 0x10u:
      return foldNegate(a1, a2, a3);
    case 0x11u:
      uint64_t v8 = a1;
      uint64_t v9 = a2;
      uint64_t v10 = a3;
      int v11 = 10;
      goto LABEL_17;
    case 0x12u:
      uint64_t v8 = a1;
      uint64_t v9 = a2;
      uint64_t v10 = a3;
      int v11 = 132;
LABEL_17:
      uint64_t result = foldUnaryOperator(v8, v9, v10, v11);
      break;
    case 0x27u:
      foldAssign(a3);
      return a3;
    case 0x2Bu:
      uint64_t result = foldCommaExpr(a3);
      break;
    case 0x2Eu:
      uint64_t result = foldVariableDeclaration(a1, a3);
      break;
    case 0x42u:
      uint64_t result = foldBlock(a3);
      break;
    case 0x43u:
      uint64_t result = foldIfStatement(a3);
      break;
    case 0x45u:
      foldSwitchStatement(a1, a3);
      return a3;
    case 0x51u:
      uint64_t result = foldLValue(a1, a2, a3);
      break;
    case 0x52u:
      uint64_t result = foldRValue(a1, a2, a3);
      break;
    case 0x54u:
      uint64_t result = foldPPStreamOp(a1, a2, a3);
      break;
    default:
      uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
      glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
      return a3;
  }
  return result;
}

uint64_t foldTypeConversion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t Expr = glpUnaryOperatorNodeGetExpr(a3);
  if (glpIsConstantNode(Expr))
  {
    Saunsigned int Type = glpASTNodeGetSaType(Expr);
    Primitiveunsigned int Type = glpPrimitiveTypeGetPrimitiveType(SaType);
    char Value = (const void *)glpConstantNodeGetValue(Expr);
    uint64_t v10 = glpASTNodeGetSaType(v3);
    uint64_t v11 = glpPrimitiveTypeGetPrimitiveType(v10);
    uint64_t v12 = (unsigned int *)glpASTNodeGetSaType(v3);
    Mutablechar Value = glpMakeMutableValue(a1, v12, 0, v13, v14, v15, v16, v17, v30);
    unint64_t v31 = 0;
    uint64_t v19 = glpASTNodeGetSaType(v3);
    uint64_t v20 = glpPrimitiveTypeGetPrimitiveType(v19);
    Scalarunsigned int Type = glpPrimitiveTypeGetScalarType(v20);
    if (ScalarType == 36) {
      int v22 = 3;
    }
    else {
      int v22 = 4;
    }
    if (ScalarType == 9) {
      int v23 = 1;
    }
    else {
      int v23 = v22;
    }
    if (ScalarType == 5) {
      int v24 = 2;
    }
    else {
      int v24 = 4;
    }
    if (ScalarType == 1) {
      int v24 = 0;
    }
    if (ScalarType <= 8) {
      int v25 = v24;
    }
    else {
      int v25 = v23;
    }
    GLVMunsigned int Type = glpGLPTypeGetGLVMType(PrimitiveType);
    glvmChooseDestTypeConversion(v25, GLVMType, &v31);
    if ((v31 & 0x7C0000000000000) != 0)
    {
      glpVecFromValue(v32, PrimitiveType, Value);
      glvmTypeConvertCF((uint64_t)v32, (v31 >> 54) & 0x1F);
      glpMutableValueFromVec(MutableValue, v11, v32);
    }
    else
    {
      uint64_t v28 = glpASTNodeGetSaType(v3);
      glpCopyValueInto(MutableValue, v28, Value);
    }
    return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, v3, MutableValue);
  }
  else
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(v3);
    glpASTNodeSetSaFlags(v3, SaFlags | 0x80);
  }
  return v3;
}

uint64_t foldConstant(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Saunsigned int Type = (unsigned int *)glpASTNodeGetSaType(a3);
  char Value = (const void *)glpConstantNodeGetValue(a3);
  uint64_t v13 = glpCopyValue(a1, SaType, Value, v8, v9, v10, v11, v12);

  return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, a3, v13);
}

uint64_t foldNegate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  v25[17] = *MEMORY[0x263EF8340];
  uint64_t Expr = glpUnaryOperatorNodeGetExpr(a3);
  if (glpIsConstantNode(Expr))
  {
    Saunsigned int Type = glpASTNodeGetSaType(v3);
    Primitiveunsigned int Type = glpPrimitiveTypeGetPrimitiveType(SaType);
    int Category = glpPrimitiveTypeGetCategory(PrimitiveType);
    if ((Category - 1) >= 2)
    {
      if (Category == 3)
      {
        LODWORD(v11) = glpPrimitiveMatrixGetColumns(PrimitiveType);
        Primitiveunsigned int Type = glpPrimitiveMatrixGetColumnType(PrimitiveType);
        int ByteStride = glpPrimitiveTypeGetByteStride(PrimitiveType);
      }
      else
      {
        LODWORD(v11) = 0;
        int ByteStride = 0;
      }
    }
    else
    {
      int ByteStride = 0;
      LODWORD(v11) = 1;
    }
    uint64_t Value = glpConstantNodeGetValue(Expr);
    uint64_t v14 = (unsigned int *)glpASTNodeGetSaType(v3);
    Mutableuint64_t Value = glpMakeMutableValue(a1, v14, 0, v15, v16, v17, v18, v19, v25[0]);
    GLVMunsigned int Type = glpGLPTypeGetGLVMType(PrimitiveType);
    if (v11)
    {
      int v22 = GLVMType;
      unsigned int v23 = 0;
      uint64_t v11 = v11;
      do
      {
        glpVecFromValue((int *)v25, PrimitiveType, (const void *)(Value + v23));
        glvmSourceNegateCF(0, v22, (uint64_t)v25);
        glpMutableValueFromVec(&MutableValue[v23], PrimitiveType, v25);
        v23 += ByteStride;
        --v11;
      }
      while (v11);
    }
    return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, v3, MutableValue);
  }
  else
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(v3);
    glpASTNodeSetSaFlags(v3, SaFlags | 0x80);
  }
  return v3;
}

uint64_t foldAssign(uint64_t a1)
{
  uint64_t Lhs = glpBinaryOperatorNodeGetLhs(a1);
  uint64_t Rhs = glpBinaryOperatorNodeGetRhs(a1);
  if (!glpIsLValueNode(Lhs)) {
    goto LABEL_6;
  }
  Variableuint64_t Extra = glpLValueNodeGetVariableExtra(Lhs);
  uint64_t v5 = *(void *)(VariableExtra + 104);
  if (!v5 || !glpIsConstantNode(Rhs) || !glpConstantValueFromDecomposedInitializer(VariableExtra, v5, a1))
  {
    *(void *)(VariableExtra + 104) = 0;
LABEL_6:
    uint64_t SaFlags = glpASTNodeGetSaFlags(a1);
    glpASTNodeSetSaFlags(a1, SaFlags | 0x80);
  }
  return a1;
}

uint64_t foldCommaExpr(uint64_t a1)
{
  int ChildCount = glpASTNodeGetChildCount(a1);
  if (!ChildCount) {
    return a1;
  }
  int v3 = ChildCount;
  unsigned int v4 = 0;
  LODWORD(v5) = 0;
  do
  {
    uint64_t Child = glpASTNodeGetChild(a1, v4);
    uint64_t v7 = Child;
    if (Child)
    {
      if (v5) {
        LODWORD(v5) = 1;
      }
      else {
        unint64_t v5 = ((unint64_t)glpASTNodeGetSaFlags(Child) >> 7) & 1;
      }
    }
    ++v4;
  }
  while (v3 != v4);
  if (v5)
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(a1);
    glpASTNodeSetSaFlags(a1, SaFlags | 0x80);
    return a1;
  }
  return v7;
}

uint64_t foldVariableDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t Extra = glpVariableDeclarationNodeGetExtra(a2);
  Name = (const char *)glpVariableDeclarationNodeGetName(v2);
  if (v6 && (uint64_t v7 = Name, *Name == 36)) {
    BOOL v8 = v6 < 9 || strncmp("$ib$", Name, 4uLL) || strncmp("$gl_", v7 + 5, 4uLL) != 0;
  }
  else {
    BOOL v8 = 0;
  }
  uint64_t v9 = *(void *)(Extra + 64);
  uint64_t Initializer = glpVariableDeclarationNodeGetInitializer(v2);
  if (v9) {
    BOOL v8 = 1;
  }
  if (!v8 || Initializer != 0)
  {
    uint64_t v12 = Initializer;
    uint64_t SaFlags = glpASTNodeGetSaFlags(v2);
    glpASTNodeSetSaFlags(v2, SaFlags | 0x80);
    if (v12) {
      BOOL v19 = v8;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19)
    {
      Mutableuint64_t Value = glpMakeMutableValue(a1, *(unsigned int **)Extra, 0, v14, v15, v16, v17, v18, v23);
      uint64_t v21 = glpVariableDeclarationNodeGetInitializer(v2);
      if (glpConstantValueFromDecomposedInitializer(Extra, (uint64_t)MutableValue, v21))
      {
        *(void *)(Extra + 64) = MutableValue;
        *(void *)(Extra + 72) = MutableValue;
        glpVariableDeclarationNodeSetInitializer(v2, 0);
        return 0;
      }
    }
  }
  return v2;
}

uint64_t foldBlock(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!glpBlockNodeGetStatementCount(a1)) {
    return 0;
  }
  unsigned int v2 = 0;
  while (1)
  {
    uint64_t Statement = glpBlockNodeGetStatement(v1, v2);
    if (Statement)
    {
      if ((glpASTNodeGetSaFlags(Statement) & 0x80) != 0) {
        break;
      }
    }
    if (++v2 >= glpBlockNodeGetStatementCount(v1)) {
      return 0;
    }
  }
  uint64_t SaFlags = glpASTNodeGetSaFlags(v1);
  glpASTNodeSetSaFlags(v1, SaFlags | 0x80);
  return v1;
}

uint64_t foldIfStatement(uint64_t a1)
{
  uint64_t Cond = glpIfStatementNodeGetCond(a1);
  if (glpIsConstantNode(Cond))
  {
    if (*(_DWORD *)glpConstantNodeGetValue(Cond))
    {
      return glpIfStatementNodeGetIfStatement(a1);
    }
    else
    {
      return glpIfStatementNodeGetElseStatement(a1);
    }
  }
  else
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(a1);
    glpASTNodeSetSaFlags(a1, SaFlags | 0x80);
    return a1;
  }
}

uint64_t foldSwitchStatement(uint64_t a1, uint64_t a2)
{
  if (!glpSwitchStatementNodeGetBody(a2))
  {
    glpASTNodeGetLocation(a2, &v7);
    uint64_t BlockNode = glpMakeBlockNode(a1, &v7, 0);
    glpSwitchStatementNodeSetBody(a2, BlockNode);
  }
  uint64_t SaFlags = glpASTNodeGetSaFlags(a2);
  glpASTNodeSetSaFlags(a2, SaFlags | 0x80);
  return a2;
}

uint64_t foldLValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Variableuint64_t Extra = (uint64_t *)glpLValueNodeGetVariableExtra(a3);
  __n128 v7 = (char *)VariableExtra[8];
  if (v7)
  {
    uint64_t v8 = *VariableExtra;
    return foldDerefNode(a1, a2, a3, v7, v8);
  }
  else
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
}

uint64_t foldRValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Base = glpRValueNodeGetBase(a3);
  if (glpIsConstantNode(Base))
  {
    uint64_t Value = (char *)glpConstantNodeGetValue(Base);
    uint64_t Type = glpConstantNodeGetType(Base);
    return foldDerefNode(a1, a2, a3, Value, Type);
  }
  else
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
}

uint64_t foldPPStreamOp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  ReturnPrimitiveuint64_t Type = glpPPStreamOpNodeGetReturnPrimitiveType(a3);
  unsigned int Opcode = glpPPStreamOpNodeGetOpcode(a3);
  OpPrimitiveuint64_t Type = glpPPStreamOpNodeGetOpPrimitiveType(a3);
  int HasSrctex = glpPPStreamOpNodeGetHasSrctex(a3);
  uint64_t ChildCount = glpASTNodeGetChildCount(a3);
  unsigned int v10 = ChildCount;
  MEMORY[0x270FA5388](ChildCount);
  uint64_t v13 = (uint64_t *)((char *)&v72 - v12);
  if (v11 >= 0x200) {
    size_t v14 = 512;
  }
  else {
    size_t v14 = v11;
  }
  bzero((char *)&v72 - v12, v14);
  uint64_t v15 = v10;
  if (HasSrctex) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = v10 >= 5;
  }
  BOOL v17 = !v16;
  uint64_t v73 = a1;
  unsigned int v75 = ReturnPrimitiveType;
  if (v10)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      uint64_t Child = glpASTNodeGetChild(a3, i);
      v13[i] = Child;
      if (!glpIsConstantNode(Child)) {
        BOOL v17 = 0;
      }
    }
    BOOL v17 = v17;
  }
  if (v17 || Opcode > 0x22 || ((1 << Opcode) & 0x580000000) == 0) {
    goto LABEL_17;
  }
  uint64_t v72 = a2;
  uint64_t v46 = *v13;
  Sauint64_t Type = glpASTNodeGetSaType(*v13);
  uint64_t v44 = v13[1];
  uint64_t v48 = glpASTNodeGetSaType(v44);
  Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(SaType);
  int v50 = glpPrimitiveTypeGetPrimitiveType(v48);
  BOOL IsConstantNode = glpIsConstantNode(v46);
  BOOL v53 = PrimitiveType == 5 || PrimitiveType == 36;
  BOOL v54 = IsConstantNode && v53;
  BOOL v55 = glpIsConstantNode(v44);
  BOOL v57 = v50 == 5 || v50 == 36;
  BOOL v58 = v55 && v57;
  uint64_t v59 = v46;
  if (v54) {
    uint64_t Value = (_DWORD *)glpConstantNodeGetValue(v46);
  }
  else {
    uint64_t Value = 0;
  }
  uint64_t v61 = v72;
  if (v58) {
    char v62 = (_DWORD *)glpConstantNodeGetValue(v44);
  }
  else {
    char v62 = 0;
  }
  uint64_t v63 = v59;
  a2 = v61;
  if (Opcode == 31)
  {
    if (Value && !*Value) {
      return v44;
    }
LABEL_76:
    if (v62)
    {
      uint64_t v44 = v63;
      if (!*v62) {
        return v44;
      }
    }
LABEL_17:
    unsigned int v21 = OpPrimitiveType;
    unsigned int v20 = v75;
    if (v75) {
      BOOL v22 = v17;
    }
    else {
      BOOL v22 = 0;
    }
    if (OpPrimitiveType) {
      BOOL v23 = v22;
    }
    else {
      BOOL v23 = 0;
    }
    if (Opcode - 78 <= 0x28 && ((1 << (Opcode - 78)) & 0x18000000001) != 0 || Opcode == 11) {
      goto LABEL_34;
    }
    if (Opcode != 34) {
      goto LABEL_31;
    }
    goto LABEL_27;
  }
  if (Opcode == 32) {
    goto LABEL_76;
  }
  if (Opcode != 34) {
    goto LABEL_17;
  }
  if (Value && !*Value || v62 && !*v62)
  {
    uint64_t v64 = v75;
    uint64_t v65 = (unsigned int *)glpGetPrimitiveType(v75);
    uint64_t v66 = v73;
    Mutableuint64_t Value = glpMakeMutableValue(v73, v65, 0, v67, v68, v69, v70, v71, v72);
    glpPrimitiveTypeGetScalarCount(v64);
    uint64_t v42 = v66;
    goto LABEL_80;
  }
  if (Value && *Value == 1) {
    return v44;
  }
  if (v62)
  {
    uint64_t v44 = v63;
    if (*v62 == 1) {
      return v44;
    }
  }
  BOOL v23 = 0;
  unsigned int v21 = OpPrimitiveType;
  unsigned int v20 = v75;
LABEL_27:
  uint64_t v24 = glpCallNodeGetArg(a3, 0);
  uint64_t v25 = glpASTNodeGetSaType(v24);
  uint64_t v26 = glpCallNodeGetArg(a3, 1u);
  uint64_t v27 = glpASTNodeGetSaType(v26);
  unsigned int v28 = glpPrimitiveTypeGetPrimitiveType(v25);
  int Category = glpPrimitiveTypeGetCategory(v28);
  unsigned int v30 = glpPrimitiveTypeGetPrimitiveType(v27);
  int v31 = glpPrimitiveTypeGetCategory(v30);
  if (Category == 3 && (v31 & 0xFFFFFFFE) == 2 || Category == 2 && v31 == 3) {
    goto LABEL_34;
  }
LABEL_31:
  if (Opcode - 171 < 4 || !v23)
  {
LABEL_34:
    uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
  uint64_t v32 = (unsigned int *)glpGetPrimitiveType(v20);
  uint64_t v33 = v73;
  Mutableuint64_t Value = glpMakeMutableValue(v73, v32, 0, v34, v35, v36, v37, v38, v72);
  uint64_t v40 = glpGetPrimitiveType(v21);
  uint64_t v41 = glpGetPrimitiveType(v20);
  glvmOp(Opcode, (uint64_t)v40, v15, v13, MutableValue, (uint64_t)v41);
  uint64_t v42 = v33;
LABEL_80:

  return glpMakeConstantNodeFromNodeAndMutableValue(v42, a2, a3, MutableValue);
}

uint64_t glpGLPTypeGetGLVMType(uint64_t a1)
{
  Scalaruint64_t Type = glpPrimitiveTypeGetScalarType(a1);
  if (ScalarType == 36) {
    int v2 = 8;
  }
  else {
    int v2 = 16;
  }
  if (ScalarType == 9) {
    unsigned int v3 = 2;
  }
  else {
    unsigned int v3 = v2;
  }
  if (ScalarType == 5) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = 16;
  }
  if (ScalarType == 1) {
    unsigned int v4 = 4;
  }
  if (ScalarType <= 8) {
    return v4;
  }
  else {
    return v3;
  }
}

uint64_t glpVecFromValue(int *a1, uint64_t a2, const void *a3)
{
  int BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(a2);
  unsigned int ScalarCount = glpPrimitiveTypeGetScalarCount(a2);
  memcpy(a1, a3, ScalarCount * BytesPerComponent);
  uint64_t result = glpPrimitiveTypeGetScalarType(a2);
  if (result == 9 && ScalarCount)
  {
    uint64_t v9 = ScalarCount;
    do
    {
      if (*a1) {
        int v10 = -1;
      }
      else {
        int v10 = 0;
      }
      *a1++ = v10;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t glpMutableValueFromVec(_DWORD *a1, uint64_t a2, const void *a3)
{
  int BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(a2);
  unsigned int ScalarCount = glpPrimitiveTypeGetScalarCount(a2);
  memcpy(a1, a3, ScalarCount * BytesPerComponent);
  uint64_t result = glpPrimitiveTypeGetScalarType(a2);
  if (result == 9 && ScalarCount)
  {
    uint64_t v9 = ScalarCount;
    do
    {
      *a1 = *a1 != 0;
      ++a1;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t glpMakeConstantNodeFromNodeAndMutableValue(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  glpASTNodeGetLocation(a3, &v16);
  Sauint64_t Type = glpASTNodeGetSaType(a3);
  uint64_t v9 = (unsigned int *)glpASTNodeGetSaType(a3);
  uint64_t v10 = glpRemapValue(a2, v9, a4);
  glpMakeConstantNode(a1, &v16, SaType, v10);
  uint64_t v12 = v11;
  uint64_t v13 = glpASTNodeGetSaType(a3);
  glpASTNodeSetSaType(v12, v13);
  uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
  glpASTNodeSetSaFlags(v12, SaFlags);
  return v12;
}

uint64_t foldUnaryOperator(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t Expr = glpUnaryOperatorNodeGetExpr(a3);
  if (glpIsConstantNode(Expr))
  {
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(a3);
    Mutableuint64_t Value = glpMakeMutableValue(a1, SaType, 0, v9, v10, v11, v12, v13, v17);
    glvmOp(a4, (uint64_t)SaType, 1, &Expr, MutableValue, (uint64_t)SaType);
    return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, a3, MutableValue);
  }
  else
  {
    uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
}

uint64_t glvmOp(int a1, uint64_t a2, uint64_t a3, uint64_t *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v72 = a5;
  int v71 = a1;
  uint64_t v83 = *MEMORY[0x263EF8340];
  Constants = glvmGetConstants();
  uint64_t v10 = a3;
  uint64_t v11 = MEMORY[0x270FA5388](Constants);
  uint64_t v13 = (char *)&v69 - ((v12 + 15) & 0x7FFFFFFF0);
  MEMORY[0x270FA5388](v11);
  uint64_t v15 = (char *)&v69 - v14;
  uint64_t v78 = a3;
  uint64_t v77 = a6;
  if (a3)
  {
    unint64_t v80 = a2;
    unsigned int v16 = 0;
    a3 = a3;
    uint64_t v17 = (unsigned int *)((char *)&v69 - v14);
    uint64_t v18 = v13;
    BOOL v19 = a4;
    do
    {
      uint64_t v20 = *v19++;
      uint64_t Type = glpConstantNodeGetType(v20);
      Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(Type);
      *v18++ = PrimitiveType;
      unsigned int ScalarCount = glpPrimitiveTypeGetScalarCount(PrimitiveType);
      *v17++ = ScalarCount;
      if (v16 <= ScalarCount) {
        unsigned int v16 = ScalarCount;
      }
      --a3;
    }
    while (a3);
    v81[0].i32[0] = 0;
    v82.i32[0] = 0;
    if (v78)
    {
      uint64_t v24 = 0;
      do
      {
        uint64_t v25 = *(unsigned int *)&v13[v24 * 4];
        v81[0].i32[v24] = glpPrimitiveTypeGetScalarCount(v25) - 1;
        v82.i32[v24++] = glpGLPTypeGetGLVMType(v25);
      }
      while (v10 != v24);
      v26.i64[0] = 0x1F0000001FLL;
      v26.i64[1] = 0x1F0000001FLL;
      int8x16_t v27 = vandq_s8(v82, v26);
      v28.i64[0] = v27.u32[0];
      v28.i64[1] = v27.u32[1];
      uint64x2_t v29 = (uint64x2_t)v28;
      v28.i64[0] = v27.u32[2];
      v28.i64[1] = v27.u32[3];
      int8x16_t v30 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)v81[0], (uint32x4_t)xmmword_2393D3270), (int8x16_t)xmmword_2393D3280);
      int8x16_t v31 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)xmmword_2393D3260), (int8x16_t)vshlq_u64((uint64x2_t)v28, (uint64x2_t)xmmword_2393D3250));
      *(int8x8_t *)v29.i8 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v28.i64[0] = v29.u32[0];
      v28.i64[1] = v29.u32[1];
      int8x16_t v32 = vorrq_s8(v31, v28);
      unint64_t v33 = (unint64_t)vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    }
    else
    {
      unint64_t v33 = 0;
    }
    a6 = v77;
    a2 = v80;
    if (v77) {
      goto LABEL_14;
    }
  }
  else
  {
    unsigned int v16 = 0;
    unint64_t v33 = 0;
    if (a6)
    {
LABEL_14:
      uint64_t v34 = glpPrimitiveTypeGetPrimitiveType(a6);
      unint64_t v33 = v33 & 0xE0FFFFFFFFFFFFFFLL | (glpGLPTypeGetGLVMType(v34) << 56);
    }
  }
  uint64_t v35 = glpPrimitiveTypeGetPrimitiveType(a6);
  int v36 = glpPrimitiveTypeGetScalarCount(v35);
  unint64_t v37 = v33 & 0xFFFFFFFFFFFFFF0FLL | 0x10;
  if (v36 == 4) {
    unint64_t v37 = v33 | 0xF0;
  }
  if (v36 == 3) {
    unint64_t v37 = v33 & 0xFFFFFFFFFFFFFF0FLL | 0x70;
  }
  if (v36 == 2) {
    unint64_t v38 = v33 & 0xFFFFFFFFFFFFFF0FLL | 0x30;
  }
  else {
    unint64_t v38 = v37;
  }
  uint64_t v39 = glpPrimitiveTypeGetPrimitiveType(a2);
  uint64_t v40 = glpPrimitiveTypeGetScalarCount(v39);
  unint64_t v80 = v38 & 0xFFFFFFFFFF87FFFFLL | ((v40 << 19) + 1572864) & 0x180000;
  MEMORY[0x270FA5388](v40);
  unint64_t v52 = (unint64_t)(&v69 - 16 * v10) & 0xFFFFFFFFFFFFFFE0;
  if (v78)
  {
    uint64_t v53 = 0;
    uint64_t v76 = ((v16 << 17) + 393216) & 0x60000;
    uint64_t v75 = ((v16 << 15) + 98304) & 0x18000;
    uint64_t v74 = (((_WORD)v16 << 13) + 24576) & 0x6000;
    uint64_t v73 = (((_WORD)v16 << 11) + 6144) & 0x1800;
    uint64_t v79 = v13;
    do
    {
      uint64_t Value = (const void *)glpConstantNodeGetValue(a4[v53]);
      uint64_t v55 = *(unsigned int *)&v13[4 * v53];
      uint64_t v56 = (int *)(v52 + (v53 << 7));
      glpVecFromValue(v56, v55, Value);
      unsigned int v57 = *(_DWORD *)&v15[4 * v53];
      if (v57 < v16)
      {
        uint64_t v58 = v10;
        uint64_t v59 = v15;
        uint64_t v60 = a4;
        unint64_t v61 = v52;
        unsigned int v62 = v57 - 1;
        do
        {
          unsigned int BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(v55);
          memcpy((char *)v56 + BytesPerComponent * v57++, (char *)v56 + BytesPerComponent * v62, BytesPerComponent);
        }
        while (v16 != v57);
        unint64_t v52 = v61;
        switch((int)v53)
        {
          case 0:
            unint64_t v64 = v80 & 0xFFFFFFFFFFFFE7FFLL;
            uint64_t v65 = &v85;
            goto LABEL_32;
          case 1:
            unint64_t v64 = v80 & 0xFFFFFFFFFFFF9FFFLL;
            uint64_t v65 = &v86;
            goto LABEL_32;
          case 2:
            unint64_t v64 = v80 & 0xFFFFFFFFFFFE7FFFLL;
            uint64_t v65 = &v87;
            goto LABEL_32;
          case 3:
            unint64_t v64 = v80 & 0xFFFFFFFFFFF9FFFFLL;
            uint64_t v65 = &v88;
LABEL_32:
            unint64_t v80 = v64 | *(v65 - 32);
            break;
          default:
            unint64_t v52 = v61;
            break;
        }
        a4 = v60;
        uint64_t v15 = v59;
        uint64_t v10 = v58;
        uint64_t v13 = v79;
      }
      ++v53;
    }
    while (v53 != v10);
  }
  uint64_t v66 = v77;
  switch(v71)
  {
    case 2:
      glvmOperationABS((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)v81, v80);
      break;
    case 3:
      glvmOperationCEI((uint64_t)Constants, (double *)v52, (uint64_t)v81, v80, v44);
      break;
    case 4:
      glvmOperationFRC((uint64_t)Constants, (float32x4_t *)v52, (double *)v81[0].i64, v80);
      break;
    case 5:
      glvmOperationFLR((uint64_t)Constants, (double *)v52, (uint64_t)v81, v80, v44);
      break;
    case 6:
    case 80:
    case 81:
      glvmOperationZERO((uint64_t)Constants, v81, v80);
      break;
    case 7:
      glvmOperationSSG((int8x16_t)v44, (uint64_t)Constants, v52, (float64_t *)v81[0].i64, v80);
      break;
    case 8:
      glvmOperationANY((uint64_t)Constants, (int32x2_t *)v52, v81, v80);
      break;
    case 9:
      glvmOperationALL((uint64_t)Constants, (int32x2_t *)v52, v81, v80);
      break;
    case 10:
      glvmOperationNOT((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)v81);
      break;
    case 11:
      glvmOperationNSE((uint64_t)Constants, (float *)v52, v81[0].f32, v80);
      break;
    case 12:
      glvmOperationSQT((uint64_t)Constants, (double *)v52, (double *)v81[0].i64, v80);
      break;
    case 16:
      glvmOperationEX2((uint64_t)Constants, (float32x4_t *)v52, (uint64_t)v81, v80);
      break;
    case 18:
      glvmOperationLEN((uint64_t)Constants, v52, (uint64_t)v81, v80, (float32x4_t)v44, v45.f64[0], v46.f64[0], v47.f64[0]);
      break;
    case 19:
      glvmOperationLG2((uint64_t)Constants, (float *)v52, v81, v80);
      break;
    case 21:
      glvmOperationNRM((uint64_t)Constants, (float64x2_t *)v52, (double *)v81[0].i64, v80, (float64x2_t)v44);
      break;
    case 22:
      glvmOperationRAD((uint64_t)Constants, (float32x4_t *)v52, v81);
      break;
    case 23:
      glvmOperationDEG((uint64_t)Constants, (float32x4_t *)v52, v81);
      break;
    case 25:
      glvmOperationSIN(Constants, v52, v81, v80);
      break;
    case 26:
      glvmOperationCOS((uint64_t)Constants, (float32x4_t *)v52, v81);
      break;
    case 27:
      glvmOperationTAN((uint64_t)Constants, (float32x4_t *)v52, (int8x16_t *)v81);
      break;
    case 28:
      glvmOperationASN((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)v81);
      break;
    case 29:
      glvmOperationACS((uint64_t)Constants, (float32x4_t *)v52, v81);
      break;
    case 30:
      if (v78 == 2) {
        glvmOperationATN2((uint64_t)Constants, (float32x4_t *)v52, (float32x4_t *)(v52 + 128), (uint64_t)v81);
      }
      else {
        glvmOperationATN((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)v81);
      }
      break;
    case 31:
      glvmOperationADD((uint64_t)Constants, v52, v52 + 128, (uint64_t)v81, v80);
      break;
    case 32:
      glvmOperationSUB((uint64_t)Constants, v52, v52 + 128, (uint64_t)v81, v80);
      break;
    case 33:
      glvmOperationMOD((uint64_t)Constants, v52, v52 + 128, (uint64_t)v81, v80);
      break;
    case 34:
      glvmOperationMUL((uint64_t)Constants, v52, v52 + 128, (uint64_t)v81, v80);
      break;
    case 35:
      glvmOperationMLC(Constants, v52, v52 + 128, v81, v80);
      break;
    case 36:
      glvmOperationANL((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)(v52 + 128), (int8x16_t *)v81);
      break;
    case 37:
      glvmOperationORL((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)(v52 + 128), (int8x16_t *)v81);
      break;
    case 38:
      glvmOperationXRL((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)(v52 + 128), (int8x16_t *)v81);
      break;
    case 39:
      glvmOperationDOT(v44.n128_f64[0], (uint64_t)Constants, v52, v52 + 128, v81, v80);
      break;
    case 44:
      glvmOperationMIN((uint64_t)Constants, (int *)v52, (int *)(v52 + 128), (uint64_t)v81, v80);
      break;
    case 45:
      glvmOperationMAX((uint64_t)Constants, (int *)v52, (int *)(v52 + 128), (uint64_t)v81, v80);
      break;
    case 46:
      glvmOperationXPD((uint64_t)Constants, v52, v52 + 128, (uint64_t)v81, v80);
      break;
    case 47:
      glvmOperationRFL((float32x4_t)v44, v45.f64[0], v46.f64[0], v47.f64[0], (uint64_t)Constants, v52, v52 + 128, v81, v80);
      break;
    case 49:
      glvmOperationSEQ((int32x4_t)v44, (uint64_t)Constants, v52, v52 + 128, (int32x4_t *)v81, v80);
      break;
    case 50:
      glvmOperationSGE((uint64_t)Constants, v52, v52 + 128, (int32x4_t *)v81, v80);
      break;
    case 51:
      glvmOperationSGT((uint64_t)Constants, v52, v52 + 128, (int32x4_t *)v81, v80);
      break;
    case 52:
      glvmOperationSLE((uint64_t)Constants, v52, v52 + 128, (int32x4_t *)v81, v80);
      break;
    case 53:
      glvmOperationSLT((uint64_t)Constants, v52, v52 + 128, (int32x4_t *)v81, v80);
      break;
    case 54:
      glvmOperationSNE((int32x4_t)v44, (uint64_t)Constants, v52, v52 + 128, (int32x4_t *)v81, v80);
      break;
    case 56:
      glvmOperationPOW((uint64_t)Constants, (float *)v52, (float32x4_t *)(v52 + 128), (uint64_t)v81, v80);
      break;
    case 58:
      glvmOperationDIV((float64x2_t)v44, (uint64_t)Constants, v52, v52 + 128, (uint64_t)v81, v80);
      break;
    case 59:
      glvmOperationFFW((float32x4_t)v44, v45, v46, v47, (uint64_t)Constants, (int8x16_t *)v52, v52 + 128, v52 + 256, v81, v80);
      break;
    case 60:
      glvmOperationLRP((uint64_t)Constants, v52, (float64x2_t *)(v52 + 128), (float64x2_t *)(v52 + 256), (float64x2_t *)v81, v80);
      break;
    case 61:
      glvmOperationCLM((uint64_t)Constants, (int *)v52, (int *)(v52 + 128), (unsigned int *)(v52 + 256), (uint64_t)v81, v80);
      break;
    case 63:
      glvmOperationMAD((uint64_t)Constants, v52, (float64x2_t *)(v52 + 128), (float64x2_t *)(v52 + 256), (float64x2_t *)v81, v80);
      break;
    case 64:
      glvmOperationSMS((uint64_t)Constants, (float64x2_t *)v52, (float64x2_t *)(v52 + 128), (float64x2_t *)(v52 + 256), (float64x2_t *)v81, v80);
      break;
    case 92:
      glvmOperationPK2H((uint64_t)Constants, (_DWORD *)v52, v81);
      break;
    case 93:
      glvmOperationPK2US((uint64_t)Constants, (float32x2_t *)v52, v81);
      break;
    case 94:
      glvmOperationPK4B((uint64_t)Constants, (float32x4_t *)v52, v81);
      break;
    case 95:
      glvmOperationPK4UB((uint64_t)Constants, (float32x4_t *)v52, v81);
      break;
    case 100:
      glvmOperationUP2H((uint64_t)Constants, (unsigned __int16 *)v52, (int *)v81);
      break;
    case 101:
      glvmOperationUP2US(v44.n128_f32[0], (uint64_t)Constants, (_WORD *)v52, v81);
      break;
    case 102:
      glvmOperationUP4B((int8x8_t)v44.n128_u64[0], (uint64_t)Constants, (__int8 *)v52, v81);
      break;
    case 103:
      glvmOperationUP4UB(v44.n128_f32[0], (uint64_t)Constants, (unsigned char *)v52, v81);
      break;
    case 105:
      glvmOperationRFR((uint64_t)Constants, v52, v52 + 128, (double *)(v52 + 256), (uint64_t)v81, v80, (float32x4_t)v44);
      break;
    case 112:
      glvmOperationEXPE((uint64_t)Constants, (float32x4_t *)v52, (uint64_t)v81, v80);
      break;
    case 113:
      glvmOperationLOGE((uint64_t)Constants, (float *)v52, v81, v80);
      break;
    case 123:
      glvmOperationROUND((uint64_t)Constants, (float *)v52, (uint64_t)v81, v80);
      break;
    case 124:
      glvmOperationTRUNCATE((uint64_t)Constants, (float *)v52, (uint64_t)v81, v80);
      break;
    case 125:
      glvmOperationAND((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)(v52 + 128), (int8x16_t *)v81);
      break;
    case 126:
      glvmOperationOR((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)(v52 + 128), (int8x16_t *)v81);
      break;
    case 127:
      glvmOperationXOR((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)(v52 + 128), (int8x16_t *)v81);
      break;
    case 128:
      glvmOperationSHL((uint64_t)Constants, (_DWORD *)v52, (_DWORD *)(v52 + 128), v81);
      break;
    case 129:
      glvmOperationSHR((uint64_t)Constants, (int *)v52, (_DWORD *)(v52 + 128), v81, v80);
      break;
    case 132:
      glvmOperationCOMP((uint64_t)Constants, (int8x16_t *)v52, (int8x16_t *)v81);
      break;
    case 133:
      glvmOperationDISTANCE((uint64_t)Constants, (float64x2_t *)v52, (float64x2_t *)(v52 + 128), (uint64_t)v81, v80, (float32x4_t)v44, v45.f64[0], v46.f64[0], v47.f64[0], v48, v49, v50, v51);
      break;
    case 134:
      glvmOperationINVERSESQRT((uint64_t)Constants, (double *)v52, (double *)v81[0].i64, v80);
      break;
    case 137:
      glvmOperationROUNDEVEN((uint64_t)Constants, (double *)v52, (double *)v81[0].i64, v80);
      break;
    case 138:
      glvmOperationISNAN((uint64_t)Constants, (float32x4_t *)v52, (int8x16_t *)v81, v80);
      break;
    case 139:
      glvmOperationISINF((uint64_t)Constants, (int8x16_t *)v52, (int32x4_t *)v81, v80);
      break;
    case 144:
      glvmOperationSINH((uint64_t)Constants, (float *)v52, v81[0].f32);
      break;
    case 145:
      glvmOperationCOSH((uint64_t)Constants, (float *)v52, v81[0].f32);
      break;
    case 146:
      glvmOperationTANH((uint64_t)Constants, (float *)v52, v81[0].f32);
      break;
    case 147:
      glvmOperationASINH((uint64_t)Constants, (float *)v52, v81[0].f32);
      break;
    case 148:
      glvmOperationACOSH((uint64_t)Constants, (float *)v52, v81[0].f32);
      break;
    case 149:
      glvmOperationATANH((uint64_t)Constants, (float *)v52, v81[0].f32);
      break;
    case 150:
      glvmOperationTO_BITS((uint64_t)Constants, v52, (uint64_t)v81);
      break;
    case 151:
      glvmOperationFROM_BITS((uint64_t)Constants, v52, (uint64_t)v81);
      break;
    case 154:
      glvmOperationEXTRACT_EXPONENT((uint64_t)Constants, v52, (uint64_t)v81, v80);
      break;
    case 155:
      glvmOperationEXTRACT_SIGNIFICAND((uint64_t)Constants, (float *)v52, (uint64_t)v81, v80);
      break;
    case 156:
      glvmOperationLDEXP((uint64_t)Constants, (float *)v52, (unsigned int *)(v52 + 128), (uint64_t)v81, v80);
      break;
    case 157:
      glvmOperationPK2W((uint64_t)Constants, (void *)v52, v81);
      break;
    case 158:
      glvmOperationUP2W((uint64_t)Constants, (void *)v52, v81);
      break;
    case 159:
      glvmOperationMUL_HB((uint64_t)Constants, (unsigned int *)v52, (unsigned int *)(v52 + 128), v81, v80, v41, v42, v43, (uint64_t)&v84);
      break;
    case 160:
      glvmOperationBITFIELD_REVERSE((uint64_t)Constants, (_DWORD *)v52, v81);
      break;
    case 161:
      glvmOperationBITCOUNT((uint64_t)Constants, (unsigned int *)v52, v81);
      break;
    case 162:
      glvmOperationFIND_LSB((uint64_t)Constants, (_DWORD *)v52, v81);
      break;
    case 163:
      glvmOperationFIND_MSB((int8x16_t)v44, (int8x16_t)v45, (int8x16_t)v46, (int8x16_t)v47, (uint64_t)Constants, (int32x4_t *)v52, (int *)v81, v80);
      break;
    default:
      break;
  }
  uint64_t v67 = glpPrimitiveTypeGetPrimitiveType(v66);
  return glpMutableValueFromVec(v72, v67, v81);
}

uint64_t foldDerefNode(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t Offset = glpDerefNodeGetOffset(a3);
  uint64_t v69 = a2;
  if (Offset)
  {
    uint64_t v11 = Offset;
    uint64_t BankIndex = glpOffsetNodeGetBankIndex(Offset);
    uint64_t OffsetExpr = glpOffsetNodeGetOffsetExpr(v11);
    unsigned int Swizzle = glpOffsetNodeGetSwizzle(v11);
    VectorElementuint64_t Expr = glpOffsetNodeGetVectorElementExpr(v11);
  }
  else
  {
    unsigned int Swizzle = 0;
    uint64_t BankIndex = 0;
    uint64_t OffsetExpr = 0;
    VectorElementuint64_t Expr = 0;
  }
  uint64_t v16 = glpDerefNodeGetOffset(a3);
  Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(a3);
  if (!glpTypeGetKind(SaType) && v16 && glpOffsetNodeGetPreSwizzlePrimitiveType(v16))
  {
    PreSwizzlePrimitiveuint64_t Type = glpOffsetNodeGetPreSwizzlePrimitiveType(v16);
    Sauint64_t Type = (unsigned int *)glpGetPrimitiveType(PreSwizzlePrimitiveType);
  }
  if (BankIndex) {
    goto LABEL_9;
  }
  if (OffsetExpr)
  {
    if (!glpIsConstantNode(OffsetExpr)) {
      goto LABEL_9;
    }
    uint64_t Value = (unsigned int *)glpConstantNodeGetValue(OffsetExpr);
    uint64_t Type = (unsigned int *)glpConstantNodeGetType(OffsetExpr);
    if (!glpValueIsUsableAsSize(Type, Value)) {
      goto LABEL_9;
    }
    unsigned int AsSize = glpValueGetAsSize((uint64_t)Type, Value);
    unsigned int v24 = glpABIGetTypeSize(0, a5, 0);
    if (AsSize >= glpTypeSizeGetSize(v24)) {
      goto LABEL_9;
    }
    int8x16_t v30 = glpCopyValue(a1, SaType, &a4[16 * AsSize], v25, v26, v27, v28, v29);
  }
  else
  {
    int8x16_t v30 = a4;
  }
  if (Swizzle)
  {
    uint64_t v31 = glpASTNodeGetSaType(a3);
    Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(v31);
    Scalaruint64_t Type = glpPrimitiveTypeGetScalarType(PrimitiveType);
    Vectoruint64_t Type = glpGetVectorType(ScalarType, Swizzle & 7);
    uint64_t v35 = (unsigned int *)glpGetPrimitiveType(VectorType);
    Mutableuint64_t Value = glpMakeMutableValue(a1, v35, 0, v36, v37, v38, v39, v40, v68);
    glpCopyValueIntoWithSwizzle((uint64_t)MutableValue, (uint64_t)v35, (uint64_t)v30, Swizzle);
    int8x16_t v30 = MutableValue;
  }
  if (!VectorElementExpr) {
    goto LABEL_23;
  }
  if (!glpIsConstantNode(VectorElementExpr)
    || (uint64_t v42 = (unsigned int *)glpConstantNodeGetValue(VectorElementExpr),
        uint64_t v43 = (unsigned int *)glpConstantNodeGetType(VectorElementExpr),
        !glpValueIsUsableAsSize(v43, v42))
    || (unsigned int v44 = glpValueGetAsSize((uint64_t)v43, v42),
        uint64_t v45 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType),
        v44 >= glpPrimitiveTypeGetScalarCount(v45)))
  {
LABEL_9:
    uint64_t SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
  float64x2_t v46 = (unsigned int *)glpASTNodeGetSaType(a3);
  unint64_t v52 = glpMakeMutableValue(a1, v46, 0, v47, v48, v49, v50, v51, v68);
  uint64_t v53 = glpASTNodeGetSaType(a3);
  unsigned int Swizzle_2 = glpMakeSwizzle_2(v53, v54, v55, v56, v57, v58, v59, v60, v44);
  glpCopyValueIntoWithSwizzle((uint64_t)v52, v53, (uint64_t)v30, Swizzle_2);
  int8x16_t v30 = v52;
LABEL_23:
  if (v30 == a4)
  {
    unsigned int v62 = (unsigned int *)glpASTNodeGetSaType(a3);
    int8x16_t v30 = glpCopyValue(a1, v62, a4, v63, v64, v65, v66, v67);
  }

  return glpMakeConstantNodeFromNodeAndMutableValue(a1, v69, a3, v30);
}

uint64_t glpCopyValueIntoWithSwizzle(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unsigned int v7 = a4 & 7;
  Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(a2);
  uint64_t result = glpPrimitiveTypeGetBytesPerComponent(PrimitiveType);
  if (v7)
  {
    int v10 = result;
    unsigned int v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 2 * v7;
    size_t v14 = result;
    do
    {
      uint64_t result = (uint64_t)memcpy((void *)(a1 + v11), (const void *)(a3 + ((a4 >> (v12 + 3)) & 3) * v10), v14);
      v12 += 2;
      v11 += v10;
    }
    while (v13 != v12);
  }
  return result;
}

uint64_t glpMakeSwizzle_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return (8 * a9) | 1u;
}

uint64_t glpPPTNode(uint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    switch(glpASTNodeGetKind(a2))
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Du:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
        goto LABEL_3;
      case 0x2Eu:
        return glpPPTVariableDeclaration(a1, a2);
      case 0x33u:
        return glpPPTFunctionDefinition(a1, a2);
      case 0x45u:
        glpPPTSwitchStatement(a1, a2);
        return a2;
      case 0x4Cu:
        a1[3] = a2;
LABEL_3:
        transformKids((uint64_t)a1, a2);
        return a2;
      case 0x4Eu:
        return glpPPTRawCall(a1, a2);
      default:
        abort();
    }
  }
  return a2;
}

uint64_t glpPPTVariableDeclaration(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  transformKids((uint64_t)a1, a2);
  if (glpVariableDeclarationNodeGetInitializer(v2) && (glpASTNodeGetSaFlags(v2) & 0x100000000) == 0)
  {
    uint64_t Initializer = glpVariableDeclarationNodeGetInitializer(v2);
    glpVariableDeclarationNodeSetInitializer(v2, 0);
    if ((glpASTNodeGetSaFlags(v2) & 0x80000000) != 0)
    {
      if (glpTopLevelNodeGetDefCount(a1[3]))
      {
        unsigned int v9 = 0;
        while (1)
        {
          uint64_t Def = glpTopLevelNodeGetDef(a1[3], v9);
          if (glpIsFunctionDefinitionNode(Def))
          {
            uint64_t Prototype = glpFunctionDefinitionNodeGetPrototype(Def);
            uint64_t Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
            if (glpStringsEqual("$copy_in", 0x2CF8B77300000008, *(char **)(Extra + 24), *(void *)(Extra + 32))) {
              break;
            }
          }
          if (++v9 >= glpTopLevelNodeGetDefCount(a1[3])) {
            goto LABEL_10;
          }
        }
        uint64_t Body = glpFunctionDefinitionNodeGetBody(Def);
      }
      else
      {
LABEL_10:
        uint64_t Body = 0;
      }
      glpBlockNodeAddStatement((void *)*a1, Body, Initializer);
    }
    else
    {
      uint64_t v5 = *a1;
      glpASTNodeGetLocation(v2, &v15);
      glpMakeCommaExprNode(v5, &v15, 0);
      uint64_t v7 = v6;
      glpCommaExprNodeAddExpr((void *)*a1, v6, v2);
      glpCommaExprNodeAddExpr((void *)*a1, v7, Initializer);
      Sauint64_t Type = glpASTNodeGetSaType(v2);
      glpASTNodeSetSaType(v7, SaType);
      return v7;
    }
  }
  return v2;
}

uint64_t glpPPTFunctionDefinition(uint64_t *a1, uint64_t a2)
{
  transformKids((uint64_t)a1, a2);
  uint64_t Prototype = glpFunctionDefinitionNodeGetPrototype(a2);
  if ((*(unsigned char *)(glpFunctionPrototypeNodeGetExtra(Prototype) + 9) & 0x20) != 0)
  {
    uint64_t Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
    *(void *)(Extra + 64) = a2;
    if ((*(unsigned char *)(Extra + 10) & 2) == 0) {
      return Prototype;
    }
  }
  else
  {
    uint64_t Body = glpFunctionDefinitionNodeGetBody(a2);
    unsigned int StatementCount = glpBlockNodeGetStatementCount(Body);
    do
    {
      if (!StatementCount) {
        goto LABEL_13;
      }
      --StatementCount;
    }
    while (!glpBlockNodeGetStatement(Body, StatementCount));
    uint64_t Statement = glpBlockNodeGetStatement(Body, StatementCount);
    if (!Statement) {
      goto LABEL_13;
    }
    uint64_t Expr = Statement;
    while (glpIsCommaExprNode(Expr))
    {
      int ExprCount = glpCommaExprNodeGetExprCount(Expr);
      uint64_t Expr = glpCommaExprNodeGetExpr(Expr, ExprCount - 1);
      if (!Expr) {
        goto LABEL_13;
      }
    }
    if (!glpIsReturnStatementNode(Expr))
    {
LABEL_13:
      uint64_t v11 = *a1;
      glpASTNodeGetLocation(a2, &v15);
      uint64_t ReturnStatementNode = glpMakeReturnStatementNode(v11, &v15);
      Primitiveuint64_t Type = glpGetPrimitiveType(0);
      glpASTNodeSetSaType(ReturnStatementNode, (uint64_t)PrimitiveType);
      glpBlockNodeAddStatement((void *)*a1, Body, ReturnStatementNode);
    }
  }
  return a2;
}

uint64_t glpPPTSwitchStatement(uint64_t *a1, uint64_t a2)
{
  transformKids((uint64_t)a1, a2);
  uint64_t Body = glpSwitchStatementNodeGetBody(a2);
  unsigned int StatementCount = glpBlockNodeGetStatementCount(Body);
  do
  {
    if (!StatementCount) {
      goto LABEL_10;
    }
    --StatementCount;
  }
  while (!glpBlockNodeGetStatement(Body, StatementCount));
  uint64_t Statement = glpBlockNodeGetStatement(Body, StatementCount);
  if (!Statement) {
    goto LABEL_10;
  }
  uint64_t Expr = Statement;
  while (glpIsCommaExprNode(Expr))
  {
    int ExprCount = glpCommaExprNodeGetExprCount(Expr);
    uint64_t Expr = glpCommaExprNodeGetExpr(Expr, ExprCount - 1);
    if (!Expr) {
      goto LABEL_10;
    }
  }
  if (!glpIsBreakStatementNode(Expr))
  {
LABEL_10:
    uint64_t v9 = *a1;
    glpASTNodeGetLocation(a2, &v13);
    uint64_t BreakStatementNode = glpMakeBreakStatementNode(v9, &v13);
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(BreakStatementNode, (uint64_t)PrimitiveType);
    glpBlockNodeAddStatement((void *)*a1, Body, BreakStatementNode);
  }
  return a2;
}

uint64_t glpPPTRawCall(uint64_t *a1, uint64_t a2)
{
  transformKids((uint64_t)a1, a2);
  uint64_t v4 = *a1;
  glpASTNodeGetLocation(a2, &v14);
  glpMakeCommaExprNode(v4, &v14, 0);
  uint64_t v6 = v5;
  uint64_t v7 = glpRawCallNodeGetExtra(a2);
  unsigned int ExprCount = glpCommaExprNodeGetExprCount(v6);
  glpCommaExprNodeAddExpr((void *)*a1, v6, a2);
  if (*(void *)(v7 + 64) && (*(unsigned char *)(v7 + 9) & 0x20) != 0)
  {
    v13[0] = 0;
    v13[1] = glpMakePointerHash((void *)*a1);
    v13[2] = glpMakePointerHash((void *)*a1);
    uint64_t v9 = (uint64_t *)*a1;
    uint64_t Body = glpFunctionDefinitionNodeGetBody(*(void *)(v7 + 64));
    uint64_t v11 = glpDeepCopyASTNode(v9, Body, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))inliningNodeReplacement, (uint64_t)v13);
    glpCommaExprNodeSetExpr(v6, ExprCount, v11);
  }
  return v6;
}

uint64_t transformKids(uint64_t a1, uint64_t a2)
{
  uint64_t result = glpASTNodeGetChildCount(a2);
  if (result)
  {
    unsigned int v5 = 0;
    do
    {
      uint64_t Child = glpASTNodeGetChild(a2, v5);
      uint64_t v7 = glpPPTNode(a1, Child);
      glpASTNodeSetChild(a2, v5++, v7);
      uint64_t result = glpASTNodeGetChildCount(a2);
    }
    while (v5 < result);
  }
  return result;
}

uint64_t inliningNodeReplacement(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  int Kind = glpASTNodeGetKind(a3);
  if (Kind > 79)
  {
    if (Kind == 80)
    {
      unint64_t Extra = glpOffsetNodeGetExtra(v3);
      uint64_t v20 = *(void *)(a1 + 16);
      v23[0] = MEMORY[0x263EF8330];
      v23[1] = 0x40000000;
      v23[2] = __inliningNodeReplacement_block_invoke;
      v23[3] = &__block_descriptor_tmp_13;
      v23[4] = a2;
      v23[5] = Extra;
      uint64_t v21 = glpPointerHashCache_b(v20, Extra, (uint64_t)v23);
      glpOffsetNodeSetExtra(v3, v21);
    }
    else if (Kind == 81)
    {
      Variableunint64_t Extra = glpLValueNodeGetVariableExtra(v3);
      uint64_t v8 = glpPointerHashGet(*(void *)(a1 + 8), VariableExtra);
      if (v8) {
        glpLValueNodeSetVariableExtra(v3, v8);
      }
    }
  }
  else if (Kind == 46)
  {
    uint64_t v9 = (_OWORD *)glpVariableDeclarationNodeGetExtra(v3);
    int v10 = (_OWORD *)(*(uint64_t (**)(void, uint64_t, const char *))(a2 + 8))(*(void *)a2, 160, "Variable Object (PPT inlining)");
    long long v11 = v9[1];
    *int v10 = *v9;
    v10[1] = v11;
    long long v12 = v9[5];
    long long v14 = v9[2];
    long long v13 = v9[3];
    v10[4] = v9[4];
    v10[5] = v12;
    v10[2] = v14;
    v10[3] = v13;
    long long v15 = v9[8];
    long long v16 = v9[9];
    long long v18 = v9[6];
    long long v17 = v9[7];
    v10[8] = v15;
    v10[9] = v16;
    v10[6] = v18;
    v10[7] = v17;
    glpPointerHashPut(*(void *)(a1 + 8), (unint64_t)v9, (uint64_t)v10, *(double *)&v15);
    glpVariableDeclarationNodeSetExtra(v3, (uint64_t)v10);
  }
  else if (Kind == 75)
  {
    uint64_t v3 = 0;
    *(unsigned char *)a1 = 1;
  }
  return v3;
}

__n128 __inliningNodeReplacement_block_invoke(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void, uint64_t, const char *))(*(void *)(a1 + 32) + 8))(**(void **)(a1 + 32), 32, "Offset Object (PPT inlining)");
  uint64_t v3 = *(void *)(a1 + 40);
  __n128 result = *(__n128 *)(v3 + 16);
  *(_OWORD *)uint64_t v2 = *(_OWORD *)v3;
  *(__n128 *)(v2 + 16) = result;
  return result;
}

uint64_t glpSANode(void *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if ((unint64_t)(a2 + 1) >= 2 && !glpASTNodeGetSaType(a2))
  {
    glpCompilerPushSAContext((uint64_t)a1, v2);
    switch(glpASTNodeGetKind(v2))
    {
      case 0u:
        uint64_t v4 = glpSATypeConversion((uint64_t)a1, v2);
        goto LABEL_84;
      case 1u:
        uint64_t v4 = glpSAVariableIdentifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 2u:
        uint64_t v4 = glpSATypeIdentifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 3u:
        glpSAConstant(v2);
        goto LABEL_85;
      case 4u:
        uint64_t v4 = glpSAArrayAccess((uint64_t)a1, v2);
        goto LABEL_84;
      case 5u:
        uint64_t v4 = glpSAFieldAccess((uint64_t)a1, v2);
        goto LABEL_84;
      case 6u:
        uint64_t v4 = glpSAUndeterminedCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 7u:
        uint64_t v4 = glpSAFunctionCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 8u:
        uint64_t v4 = glpSASubroutineArrayCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 9u:
        uint64_t v4 = glpSAMethodCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xAu:
        uint64_t v4 = glpSAConstructorCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xBu:
        uint64_t v4 = glpSAPostincrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xCu:
        uint64_t v4 = glpSAPostdecrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xDu:
        uint64_t v4 = glpSAPreincrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xEu:
        uint64_t v4 = glpSAPredecrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xFu:
        uint64_t v4 = glpSAUnaryPlus((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x10u:
        uint64_t v4 = glpSANegate((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x11u:
        uint64_t v4 = glpSALogicalNot((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x12u:
        uint64_t v4 = glpSABitwiseNot((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x13u:
        uint64_t v4 = glpSAMultiply((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x14u:
        uint64_t v4 = glpSADivide((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x15u:
        uint64_t v4 = glpSAModulo((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x16u:
        uint64_t v4 = glpSAAdd((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x17u:
        uint64_t v4 = glpSASubtract((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x18u:
        uint64_t v4 = glpSAShiftLeft((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x19u:
        uint64_t v4 = glpSAShiftRight((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Au:
        uint64_t v4 = glpSALess((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Bu:
        uint64_t v4 = glpSALessEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Cu:
        uint64_t v4 = glpSAGreater((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Du:
        uint64_t v4 = glpSAGreaterEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Eu:
        uint64_t v4 = glpSAEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Fu:
        uint64_t v4 = glpSANotEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x20u:
        uint64_t v4 = glpSALogicalAnd((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x21u:
        uint64_t v4 = glpSALogicalOr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x22u:
        uint64_t v4 = glpSALogicalXor((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x23u:
        uint64_t v4 = glpSABitwiseAnd((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x24u:
        uint64_t v4 = glpSABitwiseOr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x25u:
        uint64_t v4 = glpSABitwiseXor((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x26u:
        uint64_t v4 = glpSAIfExpr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x27u:
        uint64_t v4 = glpSAAssign((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x28u:
        uint64_t v4 = glpSAOpAssign((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x29u:
        glpSAReadInput();
      case 0x2Au:
        glpSAWriteOutput();
      case 0x2Bu:
        uint64_t v4 = glpSACommaExpr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x2Cu:
        uint64_t v4 = glpSAParameterDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x2Du:
        uint64_t v4 = glpSAFunctionPrototype(a1, v2);
        goto LABEL_84;
      case 0x2Eu:
        uint64_t v4 = glpSAVariableDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x2Fu:
        uint64_t v4 = glpSAVariableDeclarationGroup((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x30u:
        uint64_t v4 = glpSAPrecisionDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x31u:
        uint64_t v4 = glpSAQualifiedDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x32u:
        uint64_t v4 = glpSAQualifiedDeclarationGroup((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x33u:
        uint64_t v4 = glpSAFunctionDefinition((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x34u:
        uint64_t v4 = glpSAQualifiedType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x35u:
        glpSAPrimitiveType(v2);
        goto LABEL_85;
      case 0x36u:
        uint64_t v4 = glpSAArrayType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x37u:
        uint64_t v4 = glpSAFieldDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x38u:
        uint64_t v4 = glpSAStructType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x39u:
        uint64_t v4 = glpSAInterfaceBlock((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Au:
        uint64_t v4 = glpSALayoutType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Bu:
        glpSAKeywordQualifier();
      case 0x3Cu:
        uint64_t v4 = glpSALayoutQualifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Du:
        uint64_t v4 = glpSASubroutineTypeList((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Eu:
        uint64_t v4 = glpSAQualifierList((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Fu:
        uint64_t v4 = glpSAGlobalTypeQualifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x40u:
        uint64_t v4 = glpSALayoutPair((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x41u:
        uint64_t v4 = glpSAExpressionStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x42u:
        uint64_t v4 = glpSABlock((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x43u:
        uint64_t v4 = glpSAIfStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x44u:
        uint64_t v4 = glpSALoopStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x45u:
        uint64_t v4 = glpSASwitchStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x46u:
        uint64_t v4 = glpSACaseStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x47u:
        uint64_t v4 = glpSADefaultStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x48u:
        uint64_t v4 = glpSABreakStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x49u:
        uint64_t v4 = glpSAContinueStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Au:
        uint64_t v4 = glpSADiscardStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Bu:
        uint64_t v4 = glpSAReturnStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Cu:
        uint64_t v4 = glpSATopLevel((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Du:
        glpSAAvailabilityDeclaration();
      case 0x4Eu:
        glpSARawCall();
      case 0x4Fu:
        uint64_t v4 = glpSASubroutineRawCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x50u:
        uint64_t v4 = glpSAOffset((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x51u:
        uint64_t v4 = glpSALValue((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x52u:
        uint64_t v4 = glpSARValue((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x53u:
        uint64_t v4 = glpSAIBPartialDeref((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x54u:
        uint64_t v4 = glpSAPPStreamOp((uint64_t)a1, v2);
LABEL_84:
        uint64_t v2 = v4;
LABEL_85:
        if ((unint64_t)(v2 + 1) >= 2)
        {
          uint64_t Allocator = glpCompilerGetAllocator(a1);
          uint64_t ValueHash = glpCompilerGetValueHash((uint64_t)a1);
          uint64_t v2 = glpConstantFold(Allocator, ValueHash, v2);
        }
        glpCompilerPopSAContext((uint64_t)a1);
        break;
      case 0x55u:
        glpSASubroutineUniform();
      default:
        abort();
    }
  }
  return v2;
}

uint64_t glpSATypeConversion(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v4 = (_DWORD *)glpTypeConversionNodeGetToType(a2);
    if (glpTypeIsAtomic(v4))
    {
      glpASTNodeSetSaType(a2, (uint64_t)v4);
      uint64_t Expr = glpUnaryOperatorNodeGetExpr(a2);
      char SaFlags = glpASTNodeGetSaFlags(Expr);
      uint64_t v7 = glpTypeConversionNodeGetToPrecision(a2);
      uint64_t v8 = glpUnaryOperatorNodeGetExpr(a2);
      if (glpIsConstantNode(v8)) {
        glpSAValidateConstPrecisionConversion(a1, Expr, v7);
      }
      glpASTNodeSetSaFlags(a2, SaFlags & 0x60 | (unint64_t)v7);
      return a2;
    }
    else
    {
      return glpLowerNonatomicTypeConversion(a1, a2);
    }
  }
}

uint64_t glpSAVariableIdentifier(uint64_t a1, uint64_t LValueForVariableObject)
{
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  uint64_t v56 = 0;
  uint64_t v57 = &v56;
  uint64_t v58 = 0x2000000000;
  int v59 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = &v52;
  uint64_t v54 = 0x2000000000;
  uint64_t v55 = 0;
  Name = (char *)glpVariableIdentifierNodeGetName(LValueForVariableObject);
  v51[0] = MEMORY[0x263EF8330];
  v51[1] = 0x40000000;
  v51[2] = __glpSAVariableIdentifier_block_invoke;
  v51[3] = &unk_264D9C740;
  v51[4] = &v56;
  v51[5] = &v52;
  v51[6] = NameTable;
  glpNameTableGet(NameTable, Name, v6, 0, (uint64_t)v51);
  uint64_t v7 = v53[3];
  if (v7)
  {
    switch(*((_DWORD *)v57 + 6))
    {
      case 0:
        glpASTNodeGetLocation(LValueForVariableObject, &v49);
        unsigned int v24 = &v49;
        uint64_t v25 = a1;
        uint64_t v26 = (uint64_t *)v7;
        goto LABEL_15;
      case 1:
        uint64_t Allocator = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(LValueForVariableObject, &v47);
        glpMakeIBPartialDerefNode(Allocator, &v47, v7);
        LValueForVariableObject = v28;
        glpASTNodeSetSaType(v28, *(void *)(v7 + 64));
        goto LABEL_16;
      case 2:
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(LValueForVariableObject, &v48);
        uint64_t v21 = "You may never refer to an interface block by its block name within a shader";
        BOOL v22 = &v48;
        goto LABEL_5;
      case 3:
        int Representation = glpInterfaceBlockObjectGetRepresentation(v53[3]);
        StructTypeFromIBuint64_t Type = glpGetStructTypeFromIBType(*(unsigned int **)(v7 + 64));
        uint64_t v31 = (const char *)glpVariableIdentifierNodeGetName(LValueForVariableObject);
        uint64_t v33 = v32;
        unsigned int FieldIndex = glpStructTypeGetFieldIndex(StructTypeFromIBType, v31, v32);
        if (Representation == 1)
        {
          unsigned int v39 = FieldIndex;
          glpASTNodeGetLocation(LValueForVariableObject, &v44);
          uint64_t v26 = *(uint64_t **)(*(void *)(v7 + 72) + 8 * v39);
          unsigned int v24 = &v44;
          uint64_t v25 = a1;
LABEL_15:
          LValueForVariableObject = glpMakeLValueForVariableObject(v25, v24, v26);
        }
        else
        {
          if (Representation) {
LABEL_18:
          }
            abort();
          glpASTNodeGetLocation(LValueForVariableObject, &v46);
          uint64_t v35 = glpMakeLValueForVariableObject(a1, &v46, **(uint64_t ***)(v7 + 72));
          uint64_t v36 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(LValueForVariableObject, &v45);
          glpMakeFieldAccessNode(v36, &v45, (uint64_t)v31, v33);
          uint64_t v38 = v37;
          glpFieldAccessNodeSetStructure(v37, v35);
          LValueForVariableObject = glpSAFieldAccessInternal(a1, v38);
          if (LValueForVariableObject == -1) {
            goto LABEL_6;
          }
        }
LABEL_16:
        uint64_t v23 = glpCheckIBDeref(a1, LValueForVariableObject);
        goto LABEL_17;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
        uint64_t v8 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(LValueForVariableObject, &v43);
        glpVariableIdentifierNodeGetName(LValueForVariableObject);
        char v10 = v9;
        glpVariableIdentifierNodeGetName(LValueForVariableObject);
        glpLogMessage(v8, 0, (uint64_t)&v43, "Attempt to use '%.*s' as a variable", v11, v12, v13, v14, v10);
        goto LABEL_6;
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        goto LABEL_18;
      default:
        goto LABEL_16;
    }
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(LValueForVariableObject, &v50);
  glpVariableIdentifierNodeGetName(LValueForVariableObject);
  char v42 = v20;
  glpVariableIdentifierNodeGetName(LValueForVariableObject);
  uint64_t v21 = "Use of undeclared identifier '%.*s'";
  BOOL v22 = &v50;
LABEL_5:
  glpLogMessage(InfoLog, 0, (uint64_t)v22, v21, v16, v17, v18, v19, v42);
LABEL_6:
  uint64_t v23 = glpSAFailed();
LABEL_17:
  uint64_t v40 = v23;
  _Block_object_dispose(&v52, 8);
  _Block_object_dispose(&v56, 8);
  return v40;
}

uint64_t glpSATypeIdentifier(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2000000000;
  int v33 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2000000000;
  uint64_t v29 = 0;
  Name = (char *)glpTypeIdentifierNodeGetName(a2);
  v25[0] = MEMORY[0x263EF8330];
  v25[1] = 0x40000000;
  v25[2] = __glpSATypeIdentifier_block_invoke;
  v25[3] = &unk_264D9C768;
  v25[4] = &v30;
  v25[5] = &v26;
  v25[6] = NameTable;
  glpNameTableGet(NameTable, Name, v6, 0, (uint64_t)v25);
  uint64_t v7 = v27[3];
  if (v7)
  {
    switch(*((_DWORD *)v31 + 6))
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v23);
        glpTypeIdentifierNodeGetName(a2);
        char v10 = v9;
        glpTypeIdentifierNodeGetName(a2);
        glpLogMessage(InfoLog, 0, (uint64_t)&v23, "Attempt to use '%.*s' as a type", v11, v12, v13, v14, v10);
        goto LABEL_5;
      case 6:
      case 8:
        glpASTNodeSetSaType(a2, v7);
        goto LABEL_6;
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        abort();
      default:
        goto LABEL_6;
    }
  }
  long long v15 = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v24);
  glpTypeIdentifierNodeGetName(a2);
  char v17 = v16;
  glpTypeIdentifierNodeGetName(a2);
  glpLogMessage(v15, 0, (uint64_t)&v24, "Use of undeclared type '%.*s'", v18, v19, v20, v21, v17);
LABEL_5:
  a2 = glpSAFailed();
LABEL_6:
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return a2;
}

uint64_t glpSAConstant(uint64_t a1)
{
  uint64_t Type = glpConstantNodeGetType(a1);
  glpASTNodeSetSaType(a1, Type);
  glpASTNodeSetSaFlags(a1, 96);
  return a1;
}

uint64_t glpSAArrayAccess(uint64_t a1, uint64_t a2)
{
  uint64_t Array = glpArrayAccessNodeGetArray(a2);
  uint64_t v5 = glpSANode(a1, Array);
  if (v5 != -1) {
    glpArrayAccessNodeSetArray(a2, v5);
  }
  uint64_t Element = glpArrayAccessNodeGetElement(a2);
  uint64_t v7 = glpSANode(a1, Element);
  if (v7 != -1)
  {
    glpArrayAccessNodeSetElement(a2, v7);
    if (v5 != -1)
    {
      uint64_t v8 = glpArrayAccessNodeGetArray(a2);
      Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v8);
      if (glpIsIBPartialDerefNode(v8) && glpTypeGetKind(SaType) != 3)
      {
        uint64_t Ib = glpIBPartialDerefNodeGetIb(v8);
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v39);
        glpLogMessage(InfoLog, 0, (uint64_t)&v39, "You may not index the non-array interface block '%.*s'", v17, v18, v19, v20, *(_DWORD *)(Ib + 24));
        return glpSAFailed();
      }
      int Kind = glpTypeGetKind(SaType);
      if (Kind == 3)
      {
        if (glpIsIBPartialDerefNode(v8))
        {
          uint64_t NameTable = glpCompilerGetNameTable(a1);
          int v30 = (*(unsigned char *)(**(void **)(glpIBPartialDerefNodeGetIb(v8) + 72) + 52) & 1) != 0
             && glpNameTableGetGLSLVersion(NameTable) <= 7
             && !glpNameTableIsExtensionEnabled(NameTable, 0x13u);
          uint64_t v32 = glpArrayAccessNodeGetElement(a2);
          unsigned int v38 = 0;
          glpASTNodeGetLocation(v32, &v37);
          unsigned int ElementCount = glpBankTypeGetElementCount((uint64_t)SaType);
          uint64_t v34 = glpCheckArrayIndex(a1, (long long *)&v37, v32, v30, 0, ElementCount, &v38);
          if (v34 != -1)
          {
            glpIBPartialDerefNodeSetBankIndex(v8, v34);
            Elementuint64_t Type = glpBankTypeGetElementType((uint64_t)SaType);
            glpASTNodeSetSaType(v8, ElementType);
            return glpCheckIBDeref(a1, v8);
          }
          return glpSAFailed();
        }
        uint64_t v31 = (unsigned int *)glpBankTypeGetElementType((uint64_t)SaType);
      }
      else
      {
        if (Kind != 2)
        {
          if (!Kind)
          {
            Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
            int Category = glpPrimitiveTypeGetCategory(PrimitiveType);
            if (Category == 3)
            {
              uint64_t v13 = glpIndirectMatrixColumn(a1, a2, PrimitiveType);
              goto LABEL_26;
            }
            if (Category == 2)
            {
              uint64_t v13 = glpIndirectVectorElement(a1, a2, PrimitiveType);
LABEL_26:
              uint64_t v8 = v13;
              return glpCheckIBDeref(a1, v8);
            }
          }
          uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
          glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
          char v23 = v22;
          __n128 v24 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v36);
          glpLogMessage(v24, 0, (uint64_t)&v36, "Can't access array element of type '%.*s'", v25, v26, v27, v28, v23);
          return glpSAFailed();
        }
        uint64_t v31 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)SaType);
      }
      uint64_t v13 = glpIndirectArrayElement(a1, a2, v31);
      goto LABEL_26;
    }
  }

  return glpSAFailed();
}

uint64_t glpSAFieldAccess(uint64_t a1, uint64_t a2)
{
  uint64_t Structure = glpFieldAccessNodeGetStructure(a2);
  uint64_t v5 = glpSANode(a1, Structure);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpFieldAccessNodeSetStructure(a2, v5);
    uint64_t v6 = glpSAFieldAccessInternal(a1, a2);
    return glpCheckIBDeref(a1, v6);
  }
}

uint64_t glpSAUndeterminedCall(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (glpSACall(a1, a2) == -1) {
    goto LABEL_21;
  }
  uint64_t v4 = glpUndeterminedCallNodeGetCallee(v2);
  int Kind = glpASTNodeGetKind(v4);
  switch(Kind)
  {
    case 5:
      uint64_t Allocator = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v2, &v73);
      uint64_t Field = glpFieldAccessNodeGetField(v4);
      uint64_t v14 = glpMakeMethodCallNode(Allocator, &v73, Field, v13);
      uint64_t Structure = glpFieldAccessNodeGetStructure(v4);
      glpMethodCallNodeSetReceiver(v14, Structure);
      int v16 = glpCallNodeGetArgCount(v2);
      if (v16)
      {
        int v17 = v16;
        for (unsigned int i = 0; i != v17; ++i)
        {
          uint64_t v19 = (void *)glpCompilerGetAllocator(a1);
          uint64_t v20 = glpCallNodeGetArg(v2, i);
          glpCallNodeAddArg(v19, v14, v20);
        }
      }
      return glpSANode(a1, v14);
    case 4:
      uint64_t Array = glpArrayAccessNodeGetArray(v4);
      if (!glpIsVariableIdentifierNode(Array))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v4, &v71);
        glpLogMessage(InfoLog, 0, (uint64_t)&v71, "Call of element of non-subroutine-uniform array", v44, v45, v46, v47, v69);
        return glpSAFailed();
      }
      uint64_t v22 = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v2, &v72);
      uint64_t Name = glpVariableIdentifierNodeGetName(Array);
      uint64_t v14 = glpMakeSubroutineArrayCallNode(v22, &v72, Name, v24);
      uint64_t Element = glpArrayAccessNodeGetElement(v4);
      glpSubroutineArrayCallNodeSetIndexExpr(v14, Element);
      int v26 = glpCallNodeGetArgCount(v2);
      if (v26)
      {
        int v27 = v26;
        for (unsigned int j = 0; j != v27; ++j)
        {
          uint64_t v29 = (void *)glpCompilerGetAllocator(a1);
          uint64_t v30 = glpCallNodeGetArg(v2, j);
          glpCallNodeAddArg(v29, v14, v30);
        }
      }
      return glpSANode(a1, v14);
    case 1:
      uint64_t v6 = (char *)glpVariableIdentifierNodeGetName(v4);
      uint64_t v8 = v7;
      uint64_t NameTable = glpCompilerGetNameTable(a1);
      if (glpNameTableIsExtensionEnabled(NameTable, 0x24u) && glpStringsEqual("$assert", 0x75B16CFF00000007, v6, v8))
      {
        return glpSASpecialAssert(a1, v2);
      }
      if (glpStringsEqual("$ppstreamop", 0xF8DF7DAF0000000BLL, v6, v8))
      {
        return glpSABuiltinPPStreamOp(a1, v2);
      }
      uint64_t v48 = glpCompilerGetNameTable(a1);
      uint64_t v82 = 0;
      uint64_t v83 = &v82;
      uint64_t v84 = 0x2000000000;
      int v85 = 0;
      uint64_t v78 = 0;
      uint64_t v79 = &v78;
      uint64_t v80 = 0x2000000000;
      uint64_t v81 = 0;
      v77[0] = MEMORY[0x263EF8330];
      v77[1] = 0x40000000;
      v77[2] = __glpSAUndeterminedCall_block_invoke;
      v77[3] = &unk_264D9C790;
      v77[4] = &v82;
      v77[5] = &v78;
      v77[6] = v48;
      v77[7] = a1;
      glpNameTableGet(v48, v6, v8, 0, (uint64_t)v77);
      if (v79[3])
      {
        unsigned int v49 = *((_DWORD *)v83 + 6);
        if (v49 > 0xD)
        {
LABEL_39:
          _Block_object_dispose(&v78, 8);
          _Block_object_dispose(&v82, 8);
          return v2;
        }
        int v50 = 1 << v49;
        if ((v50 & 0x10F) == 0)
        {
          if ((v50 & 0x90) == 0) {
            abort();
          }
          uint64_t v62 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(v2, &v76);
          uint64_t v63 = glpMakeFunctionCallNode(v62, &v76, (uint64_t)v6, v8);
          int v64 = glpCallNodeGetArgCount(v2);
          if (v64)
          {
            int v65 = v64;
            for (unsigned int k = 0; k != v65; ++k)
            {
              uint64_t v67 = (void *)glpCompilerGetAllocator(a1);
              uint64_t v68 = glpCallNodeGetArg(v2, k);
              glpCallNodeAddArg(v67, v63, v68);
            }
          }
          uint64_t v61 = glpSANode(a1, v63);
          goto LABEL_38;
        }
        uint64_t v51 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v4, &v75);
        glpLogMessage(v51, 0, (uint64_t)&v75, "Invalid call of '%.*s' (not a function or subroutine uniform)", v52, v53, v54, v55, v8);
      }
      else
      {
        uint64_t v56 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v4, &v74);
        glpLogMessage(v56, 0, (uint64_t)&v74, "Invalid call of undeclared identifier '%.*s'", v57, v58, v59, v60, v8);
      }
      uint64_t v61 = glpSAFailed();
LABEL_38:
      uint64_t v2 = v61;
      goto LABEL_39;
  }
  uint64_t v32 = glpSANode(a1, v4);
  if (v32 != -1)
  {
    uint64_t v33 = v32;
    Sauint64_t Type = glpASTNodeGetSaType(v32);
    uint64_t v35 = (void *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription(SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v35);
    char v37 = v36;
    unsigned int v38 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v33, &v70);
    glpLogMessage(v38, 0, (uint64_t)&v70, "'%.*s' is not callable", v39, v40, v41, v42, v37);
    return glpSAFailed();
  }
LABEL_21:

  return glpSAFailed();
}

uint64_t glpSAFunctionCall(uint64_t a1, uint64_t a2)
{
  v23[1] = *MEMORY[0x263EF8340];
  if (glpSACall(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v4 = (char *)glpFunctionCallNodeGetName(a2);
    uint64_t v6 = v5;
    uint64_t v7 = glpCallNodeGetArgCount(a2);
    MEMORY[0x270FA5388](v7);
    char v10 = (uint64_t *)((char *)&v21 - v9);
    if (v8 >= 0x200) {
      size_t v11 = 512;
    }
    else {
      size_t v11 = v8;
    }
    bzero((char *)&v21 - v9, v11);
    uint64_t v12 = glpMakeExpectedSignatureFromCall(a1, a2, (uint64_t)v10);
    v23[0] = 0;
    if (glpLookUpAndAnalyzeCall(a1, a2, v4, v6, v12, v10, (uint64_t)v23)
      && (uint64_t v13 = (void *)glpFunctionCallNodeGetExtra(a2),
          unint64_t v14 = glpCalculateCallPrecision(a1, a2, v13),
          glpHandleArgumentConversions(a1, a2, (uint64_t)v13, v14)))
    {
      uint64_t v15 = v13[1];
      if ((v15 & 0x4000) != 0)
      {
        return glpLowerCallToBodilessPPStreamOp(a1, a2, (uint64_t)v13);
      }
      else if ((v15 & 0x10000) != 0)
      {
        return glpHandleSpecialOperatorFunction(a1, a2, (uint64_t)v13);
      }
      else if ((v15 & 0x2000) != 0 && v13[8])
      {
        return glpInlineFunction(a1, a2, (uint64_t)v13, v14);
      }
      else
      {
        uint64_t v17 = v23[0];
        uint64_t Allocator = glpCompilerGetAllocator(a1);
        if (v17)
        {
          glpASTNodeGetLocation(a2, &v22);
          glpMakeSubroutineRawCallNode(Allocator, &v22, v23[0]);
        }
        else
        {
          glpASTNodeGetLocation(a2, &v21);
          uint64_t v20 = glpFunctionCallNodeGetExtra(a2);
          glpMakeRawCallNode(Allocator, &v21, (uint64_t)v4, v6, v20);
        }
        return glpSALowerCallArgsToAssignment(a1, a2, (uint64_t)v13, v19);
      }
    }
    else
    {
      return glpSAFailed();
    }
  }
}

uint64_t glpSASubroutineArrayCall(uint64_t a1, uint64_t a2)
{
  if (glpSACall(a1, a2) != -1)
  {
    uint64_t v4 = glpSubroutineArrayCallNodeGetIndexExpr(a2);
    uint64_t v5 = glpSANode(a1, v4);
    if (v5 != -1)
    {
      glpSubroutineArrayCallNodeSetIndexExpr(a2, v5);
      uint64_t v6 = (char *)glpSubroutineArrayCallNodeGetName(a2);
      uint64_t v8 = v7;
      uint64_t NameTable = glpCompilerGetNameTable(a1);
      uint64_t v52 = 0;
      uint64_t v53 = &v52;
      uint64_t v54 = 0x2000000000;
      int v55 = 0;
      uint64_t v48 = 0;
      unsigned int v49 = &v48;
      uint64_t v50 = 0x2000000000;
      uint64_t v51 = 0;
      v47[0] = MEMORY[0x263EF8330];
      v47[1] = 0x40000000;
      v47[2] = __glpSASubroutineArrayCall_block_invoke;
      v47[3] = &unk_264D9C7B8;
      v47[4] = &v52;
      unsigned char v47[5] = &v48;
      glpNameTableGet(NameTable, v6, v8, 0, (uint64_t)v47);
      uint64_t v10 = v49[3];
      if (v10 && *((_DWORD *)v53 + 6) == 7)
      {
        size_t v11 = *(unsigned int **)(v10 + 16);
        if (glpTypeGetKind(v11) == 2)
        {
          uint64_t v12 = glpSubroutineArrayCallNodeGetIndexExpr(a2);
          unsigned int v44 = 0;
          glpASTNodeGetLocation(v12, &v43);
          unsigned int ElementCount = glpArrayTypeGetElementCount((uint64_t)v11);
          uint64_t v14 = glpCheckArrayIndex(a1, (long long *)&v43, v12, 0, 0, ElementCount, &v44);
          if (v14 != -1)
          {
            uint64_t v15 = v14;
            Elementuint64_t Type = glpArrayTypeGetElementType((uint64_t)v11);
            FunctionObject = (uint64_t *)glpSubroutineTypeGetFunctionObject(ElementType);
            if (glpAnalyzeCallToSubroutineArray(a1, FunctionObject, a2))
            {
              Returnuint64_t Type = glpFunctionTypeGetReturnType(*FunctionObject);
              glpASTNodeSetSaType(a2, ReturnType);
              unint64_t v19 = glpCalculateCallPrecision(a1, a2, FunctionObject);
              if (glpHandleArgumentConversions(a1, a2, (uint64_t)FunctionObject, v19))
              {
                uint64_t Allocator = glpCompilerGetAllocator(a1);
                glpASTNodeGetLocation(a2, &v41);
                glpMakeSubroutineRawCallNode(Allocator, &v41, v10);
                uint64_t v22 = v21;
                glpSubroutineRawCallNodeSetIndexExpr(v21, v15);
                uint64_t v23 = glpSALowerCallArgsToAssignment(a1, a2, (uint64_t)FunctionObject, v22);
LABEL_15:
                uint64_t v30 = v23;
                _Block_object_dispose(&v48, 8);
                _Block_object_dispose(&v52, 8);
                return v30;
              }
            }
            else
            {
              glpSubroutineTypeGetName(ElementType);
              InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
              glpASTNodeGetLocation(a2, &v42);
              glpLogMessage(InfoLog, 0, (uint64_t)&v42, "Arguments of call to subroutine uniform array '%.*s' cannot be converted to match its element type ('%.*s')", v37, v38, v39, v40, *(_DWORD *)(v10 + 8));
            }
          }
        }
        else
        {
          uint64_t v31 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v45);
          glpLogMessage(v31, 0, (uint64_t)&v45, "'%.*s' does not name a subroutine array", v32, v33, v34, v35, v8);
        }
      }
      else
      {
        uint64_t v25 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v46);
        glpLogMessage(v25, 0, (uint64_t)&v46, "'%.*s' does not name a subroutine uniform", v26, v27, v28, v29, v8);
      }
      uint64_t v23 = glpSAFailed();
      goto LABEL_15;
    }
  }

  return glpSAFailed();
}

uint64_t glpSAMethodCall(uint64_t a1, uint64_t a2)
{
  if (glpSACall(a1, a2) != -1)
  {
    __n128 v92 = 0uLL;
    uint64_t v93 = 0;
    glpASTNodeGetLocation(a2, &v92);
    uint64_t v4 = (char *)glpMethodCallNodeGetName(a2);
    uint64_t v6 = v5;
    uint64_t NameTable = glpCompilerGetNameTable(a1);
    if (glpNameTableGetGLSLVersion(NameTable) < 2)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      __n128 v89 = v92;
      uint64_t v90 = v93;
      uint64_t v13 = "Method calls not allowed in this GLSL version";
LABEL_11:
      glpLogMessage(InfoLog, 0, (uint64_t)&v89, v13, v9, v10, v11, v12, v80);
      return glpSAFailed();
    }
    if (!glpStringsEqual("length", 0x9836E88D00000006, v4, v6))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      __n128 v89 = v92;
      uint64_t v90 = v93;
      char v80 = v6;
      uint64_t v13 = "Call of unknown method '%.*s'";
      goto LABEL_11;
    }
    if (glpCallNodeGetArgCount(a2))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      __n128 v89 = v92;
      uint64_t v90 = v93;
      uint64_t v13 = ".length() method takes no arguments";
      goto LABEL_11;
    }
    uint64_t v16 = glpMethodCallNodeGetReceiver(a2);
    if (!glpIsVariableIdentifierNode(v16))
    {
LABEL_27:
      uint64_t v43 = glpMethodCallNodeGetReceiver(a2);
      uint64_t v44 = glpSANode(a1, v43);
      if (v44 != -1)
      {
        glpMethodCallNodeSetReceiver(a2, v44);
        uint64_t v45 = glpMethodCallNodeGetReceiver(a2);
        Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v45);
        if (glpTypeGetKind(SaType) == 2)
        {
          if (glpArrayTypeGetElementCount((uint64_t)SaType) == -1)
          {
            __n128 v70 = (uint64_t **)glpCompilerGetInfoLog(a1);
            __n128 v89 = v92;
            uint64_t v90 = v93;
            glpLogMessage(v70, 0, (uint64_t)&v89, "Call to method '%.*s' of unsized array", v71, v72, v73, v74, v6);
            return glpSAFailed();
          }
          Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(5u);
          uint64_t Allocator = glpCompilerGetAllocator(a1);
          uint64_t ElementCount = glpArrayTypeGetElementCount((uint64_t)SaType);
          Mutableuint64_t Value = glpMakeMutableValue(Allocator, PrimitiveType, 1, v49, v50, v51, v52, v53, ElementCount);
        }
        else
        {
          if (glpTypeGetKind(SaType) != 3)
          {
            int v64 = (void *)glpCompilerGetAllocator(a1);
            glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v64);
            int v65 = (uint64_t **)glpCompilerGetInfoLog(a1);
            __n128 v89 = v92;
            uint64_t v90 = v93;
            glpLogMessage(v65, 0, (uint64_t)&v89, "Call to method '%.*s' of non-array type '%.*s'", v66, v67, v68, v69, v6);
            return glpSAFailed();
          }
          uint64_t v55 = glpBankTypeGetElementCount((uint64_t)SaType);
          if (v55 == -1)
          {
            __n128 v75 = (uint64_t **)glpCompilerGetInfoLog(a1);
            __n128 v89 = v92;
            uint64_t v90 = v93;
            glpLogMessage(v75, 0, (uint64_t)&v89, "Call to method '%.*s' of unsized interface block array", v76, v77, v78, v79, v6);
            return glpSAFailed();
          }
          uint64_t v56 = v55;
          Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(5u);
          uint64_t v57 = glpCompilerGetAllocator(a1);
          Mutableuint64_t Value = glpMakeMutableValue(v57, PrimitiveType, 1, v58, v59, v60, v61, v62, v56);
        }
        uint64_t v63 = glpCompilerRemapValue(a1, PrimitiveType, MutableValue);
        __n128 v89 = v92;
        uint64_t v90 = v93;
        return glpMakeConstantValueFragment(a1, &v89, (uint64_t)PrimitiveType, v63);
      }
      return glpSAFailed();
    }
    v89.n128_u64[0] = 0;
    v89.n128_u64[1] = (unint64_t)&v89;
    uint64_t v90 = 0x2000000000;
    int v91 = 0;
    uint64_t v85 = 0;
    uint64_t v86 = &v85;
    uint64_t v87 = 0x2000000000;
    uint64_t v88 = 0;
    uint64_t v17 = glpCompilerGetNameTable(a1);
    uint64_t Name = (char *)glpVariableIdentifierNodeGetName(v16);
    v84[0] = MEMORY[0x263EF8330];
    v84[1] = 0x40000000;
    v84[2] = __glpSAMethodCall_block_invoke;
    v84[3] = &unk_264D9C7E0;
    v84[4] = &v89;
    v84[5] = &v85;
    glpNameTableGet(v17, Name, v19, 0, (uint64_t)v84);
    uint64_t v20 = v86[3];
    if (!v20 || *(_DWORD *)(v89.n128_u64[1] + 24) != 1)
    {
      int v32 = 1;
      goto LABEL_26;
    }
    if (glpTypeGetKind(*(unsigned int **)(v20 + 64)) == 3)
    {
      if (glpBankTypeGetElementCount(*(void *)(v20 + 64)) != -1)
      {
        uint64_t v21 = (unsigned int *)glpGetPrimitiveType(5u);
        uint64_t v22 = glpCompilerGetAllocator(a1);
        uint64_t v23 = glpBankTypeGetElementCount(*(void *)(v20 + 64));
        uint64_t v29 = glpMakeMutableValue(v22, v21, 1, v24, v25, v26, v27, v28, v23);
        uint64_t v30 = glpCompilerRemapValue(a1, v21, v29);
        __n128 v82 = v92;
        uint64_t v83 = v93;
        uint64_t ConstantValueFragment = glpMakeConstantValueFragment(a1, &v82, (uint64_t)v21, v30);
LABEL_25:
        uint64_t v16 = ConstantValueFragment;
        int v32 = 0;
LABEL_26:
        _Block_object_dispose(&v85, 8);
        _Block_object_dispose(&v89, 8);
        if (!v32) {
          return v16;
        }
        goto LABEL_27;
      }
      uint64_t v38 = (uint64_t **)glpCompilerGetInfoLog(a1);
      __n128 v82 = v92;
      uint64_t v83 = v93;
      glpLogMessage(v38, 0, (uint64_t)&v82, "Call to method '%.*s' of unsized interface block", v39, v40, v41, v42, v6);
    }
    else
    {
      uint64_t v33 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpVariableIdentifierNodeGetName(v16);
      glpVariableIdentifierNodeGetName(v16);
      __n128 v82 = v92;
      uint64_t v83 = v93;
      glpLogMessage(v33, 0, (uint64_t)&v82, "Call to method '%.*s' of non-array interface block '%.*s'", v34, v35, v36, v37, v6);
    }
    uint64_t ConstantValueFragment = glpSAFailed();
    goto LABEL_25;
  }

  return glpSAFailed();
}

uint64_t glpSAConstructorCall(uint64_t a1, uint64_t a2)
{
  if (glpSACall(a1, a2) == -1
    || (v4 = glpConstructorCallNodeGetType(a2), uint64_t v5 = glpSANode(a1, v4), v5 == -1)
    || (glpConstructorCallNodeSetType(a2, v5), uint64_t result = glpCheckAndSanitizeConstructorCall(a1, a2), result == -1))
  {
    return glpSAFailed();
  }
  return result;
}

uint64_t glpSAPostincrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpSAPostIncrementOrDecrement(a1, a2, 1);
  }
}

uint64_t glpSAPostdecrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpSAPostIncrementOrDecrement(a1, a2, 0);
  }
}

uint64_t glpSAPreincrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpSAPreIncrementOrDecrement(a1, a2, 1);
  }
}

uint64_t glpSAPredecrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpSAPreIncrementOrDecrement(a1, a2, 0);
  }
}

uint64_t glpSAUnaryPlus(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeUnaryMathOp(a1, a2);
  }
}

uint64_t glpSANegate(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeUnaryMathOp(a1, a2);
  }
}

uint64_t glpSALogicalNot(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeUnaryMathOp(a1, a2);
  }
}

uint64_t glpSABitwiseNot(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeUnaryMathOp(a1, a2);
  }
}

uint64_t glpSAMultiply(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSADivide(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSAModulo(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSAAdd(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSASubtract(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSAShiftLeft(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSAShiftRight(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSALess(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
    if (glpCompilerDoesTrackPrecision(a1))
    {
      uint64_t SaFlags = glpASTNodeGetSaFlags(v5);
      glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
    }
    return v5;
  }
}

uint64_t glpSALessEqual(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
    if (glpCompilerDoesTrackPrecision(a1))
    {
      uint64_t SaFlags = glpASTNodeGetSaFlags(v5);
      glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
    }
    return v5;
  }
}

uint64_t glpSAGreater(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
    if (glpCompilerDoesTrackPrecision(a1))
    {
      uint64_t SaFlags = glpASTNodeGetSaFlags(v5);
      glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
    }
    return v5;
  }
}

uint64_t glpSAGreaterEqual(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
    if (glpCompilerDoesTrackPrecision(a1))
    {
      uint64_t SaFlags = glpASTNodeGetSaFlags(v5);
      glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
    }
    return v5;
  }
}

uint64_t glpSAEqual(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) != -1)
  {
    uint64_t Lhs = glpBinaryOperatorNodeGetLhs(a2);
    uint64_t Rhs = glpBinaryOperatorNodeGetRhs(a2);
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(Lhs);
    if (glpTypeGetKind(SaType))
    {
      if (glpEqualNodeGetIsFromSource(a2))
      {
        uint64_t v7 = (unsigned int *)glpASTNodeGetSaType(Lhs);
        if (glpTypeGetKind(v7) == 2)
        {
          uint64_t NameTable = glpCompilerGetNameTable(a1);
          if (glpNameTableGetGLSLVersion(NameTable) <= 1)
          {
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v45);
            uint64_t v14 = "'==' disallowed on array types";
            uint64_t v15 = &v45;
LABEL_24:
            glpLogMessage(InfoLog, 0, (uint64_t)v15, v14, v10, v11, v12, v13, v36);
            return glpSAFailed();
          }
        }
      }
      uint64_t v16 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      uint64_t v17 = glpASTNodeGetSaType(Rhs);
      if (!glpTypesEqual(v16, v17))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v44);
        uint64_t v14 = "Incompatible types in '=='";
        uint64_t v15 = &v44;
        goto LABEL_24;
      }
      __n128 v42 = 0uLL;
      uint64_t v43 = 0;
      glpASTNodeGetLocation(a2, &v42);
      uint64_t Allocator = glpCompilerGetAllocator(a1);
      __n128 v40 = v42;
      uint64_t v41 = v43;
      glpMakeCommaExprNode(Allocator, &v40, 0);
      uint64_t v20 = v19;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      glpHandleSideEffectsForExpr(a1, Lhs, &v39, &v38);
      if (v38)
      {
        uint64_t v21 = (void *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v21, v20, v38);
        uint64_t v38 = 0;
      }
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      glpHandleSideEffectsForExpr(a1, Rhs, &v37, &v36);
      if (v36)
      {
        uint64_t v22 = (void *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v22, v20, v36);
        uint64_t v36 = 0;
      }
      int AccessorCount = glpGetAccessorCount(v39);
      if (AccessorCount)
      {
        int v24 = AccessorCount;
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        do
        {
          uint64_t Accessor = glpMakeAccessor(a1, v39, v25);
          uint64_t v28 = glpMakeAccessor(a1, v37, v25);
          __n128 v40 = v42;
          uint64_t v41 = v43;
          uint64_t EqualFragment = glpMakeEqualFragment(a1, &v40, Accessor, v28);
          if (v26)
          {
            __n128 v40 = v42;
            uint64_t v41 = v43;
            uint64_t EqualFragment = glpMakeLogicalAndFragment(a1, &v40, v26, EqualFragment);
          }
          uint64_t v25 = (v25 + 1);
          uint64_t v26 = EqualFragment;
        }
        while (v24 != v25);
      }
      else
      {
        uint64_t EqualFragment = 0;
      }
      uint64_t v34 = (void *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v34, v20, EqualFragment);
      uint64_t v31 = glpSANode(a1, v20);
LABEL_27:
      if (glpCompilerDoesTrackPrecision(a1))
      {
        uint64_t SaFlags = glpASTNodeGetSaFlags(v31);
        glpASTNodeSetSaFlags(v31, SaFlags & 0xFFFFFFFFFFFFFFE0);
      }
      return v31;
    }
    uint64_t v30 = glpAnalyzeBinaryMathOp(a1, a2);
    if (v30 != -1)
    {
      uint64_t v31 = v30;
      Primitiveuint64_t Type = glpGetPrimitiveType(9u);
      glpASTNodeSetSaType(v31, (uint64_t)PrimitiveType);
      goto LABEL_27;
    }
  }

  return glpSAFailed();
}

uint64_t glpSANotEqual(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) != -1)
  {
    uint64_t Lhs = glpBinaryOperatorNodeGetLhs(a2);
    uint64_t Rhs = glpBinaryOperatorNodeGetRhs(a2);
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(Lhs);
    if (glpTypeGetKind(SaType))
    {
      if (glpNotEqualNodeGetIsFromSource(a2))
      {
        uint64_t v7 = (unsigned int *)glpASTNodeGetSaType(Lhs);
        if (glpTypeGetKind(v7) == 2)
        {
          uint64_t NameTable = glpCompilerGetNameTable(a1);
          if (glpNameTableGetGLSLVersion(NameTable) <= 1)
          {
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v45);
            uint64_t v14 = "'!=' disallowed on array types";
            uint64_t v15 = &v45;
LABEL_24:
            glpLogMessage(InfoLog, 0, (uint64_t)v15, v14, v10, v11, v12, v13, v36);
            return glpSAFailed();
          }
        }
      }
      uint64_t v16 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      uint64_t v17 = glpASTNodeGetSaType(Rhs);
      if (!glpTypesEqual(v16, v17))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v44);
        uint64_t v14 = "Incompatible types in '!='";
        uint64_t v15 = &v44;
        goto LABEL_24;
      }
      __n128 v42 = 0uLL;
      uint64_t v43 = 0;
      glpASTNodeGetLocation(a2, &v42);
      uint64_t Allocator = glpCompilerGetAllocator(a1);
      __n128 v40 = v42;
      uint64_t v41 = v43;
      glpMakeCommaExprNode(Allocator, &v40, 0);
      uint64_t v20 = v19;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      glpHandleSideEffectsForExpr(a1, Lhs, &v39, &v38);
      if (v38)
      {
        uint64_t v21 = (void *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v21, v20, v38);
        uint64_t v38 = 0;
      }
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      glpHandleSideEffectsForExpr(a1, Rhs, &v37, &v36);
      if (v36)
      {
        uint64_t v22 = (void *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v22, v20, v36);
        uint64_t v36 = 0;
      }
      int AccessorCount = glpGetAccessorCount(v39);
      if (AccessorCount)
      {
        int v24 = AccessorCount;
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        do
        {
          uint64_t Accessor = glpMakeAccessor(a1, v39, v25);
          uint64_t v28 = glpMakeAccessor(a1, v37, v25);
          __n128 v40 = v42;
          uint64_t v41 = v43;
          Notuint64_t EqualFragment = glpMakeNotEqualFragment(a1, &v40, Accessor, v28);
          if (v26)
          {
            __n128 v40 = v42;
            uint64_t v41 = v43;
            Notuint64_t EqualFragment = glpMakeLogicalOrFragment(a1, &v40, v26, NotEqualFragment);
          }
          uint64_t v25 = (v25 + 1);
          uint64_t v26 = NotEqualFragment;
        }
        while (v24 != v25);
      }
      else
      {
        Notuint64_t EqualFragment = 0;
      }
      uint64_t v34 = (void *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v34, v20, NotEqualFragment);
      uint64_t v31 = glpSANode(a1, v20);
LABEL_27:
      if (glpCompilerDoesTrackPrecision(a1))
      {
        uint64_t SaFlags = glpASTNodeGetSaFlags(v31);
        glpASTNodeSetSaFlags(v31, SaFlags & 0xFFFFFFFFFFFFFFE0);
      }
      return v31;
    }
    uint64_t v30 = glpAnalyzeBinaryMathOp(a1, a2);
    if (v30 != -1)
    {
      uint64_t v31 = v30;
      Primitiveuint64_t Type = glpGetPrimitiveType(9u);
      glpASTNodeSetSaType(v31, (uint64_t)PrimitiveType);
      goto LABEL_27;
    }
  }

  return glpSAFailed();
}

uint64_t glpSALogicalAnd(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v4);
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v5, &v15);
      glpLogMessage(InfoLog, 0, (uint64_t)&v15, "logical operator must be of type BOOL", v9, v10, v11, v12, v14);
      return glpSAFailed();
    }
    return v5;
  }
}

uint64_t glpSALogicalOr(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v4);
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v5, &v15);
      glpLogMessage(InfoLog, 0, (uint64_t)&v15, "logical operator must be of type BOOL", v9, v10, v11, v12, v14);
      return glpSAFailed();
    }
    return v5;
  }
}

uint64_t glpSALogicalXor(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1 || (uint64_t v4 = glpAnalyzeBinaryMathOp(a1, a2), v4 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v5 = v4;
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v4);
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v5, &v15);
      glpLogMessage(InfoLog, 0, (uint64_t)&v15, "logical operator must be of type BOOL", v9, v10, v11, v12, v14);
      return glpSAFailed();
    }
    return v5;
  }
}

uint64_t glpSABitwiseAnd(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSABitwiseOr(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSABitwiseXor(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    return glpAnalyzeBinaryMathOp(a1, a2);
  }
}

uint64_t glpSAIfExpr(uint64_t a1, uint64_t a2)
{
  uint64_t Condition = glpIfExprNodeGetCondition(a2);
  uint64_t v5 = glpSANode(a1, Condition);
  if (v5 == -1)
  {
    int v6 = 0;
  }
  else
  {
    glpIfExprNodeSetCondition(a2, v5);
    int v6 = 1;
  }
  Ifuint64_t Expr = glpIfExprNodeGetIfExpr(a2);
  uint64_t v8 = glpSANode(a1, IfExpr);
  if (v8 == -1) {
    int v6 = 0;
  }
  else {
    glpIfExprNodeSetIfExpr(a2, v8);
  }
  Elseuint64_t Expr = glpIfExprNodeGetElseExpr(a2);
  uint64_t v10 = glpSANode(a1, ElseExpr);
  if (v10 != -1)
  {
    glpIfExprNodeSetElseExpr(a2, v10);
    if (v6)
    {
      uint64_t v11 = glpIfExprNodeGetCondition(a2);
      Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v11);
      Primitiveuint64_t Type = glpGetPrimitiveType(9u);
      if (glpTypesEqual(SaType, (uint64_t)PrimitiveType))
      {
        uint64_t v14 = glpIfExprNodeGetIfExpr(a2);
        uint64_t v15 = glpIfExprNodeGetElseExpr(a2);
        uint64_t v16 = (unsigned int *)glpASTNodeGetSaType(v14);
        uint64_t v17 = (unsigned int *)glpASTNodeGetSaType(v15);
        unint64_t v18 = glpASTNodeGetSaFlags(v14) & 0x1F;
        unint64_t v19 = glpASTNodeGetSaFlags(v15) & 0x1F;
        if (glpTypesEqual(v16, (uint64_t)v17))
        {
LABEL_11:
          if (v18 != v19)
          {
            if (v18 != 31 && v18)
            {
              if (v18 <= v19)
              {
                uint64_t v14 = glpConvert(a1, v14, (uint64_t)v16, v19);
                glpIfExprNodeSetIfExpr(a2, v14);
              }
              else
              {
                uint64_t v15 = glpConvert(a1, v15, (uint64_t)v17, v18);
                glpIfExprNodeSetElseExpr(a2, v15);
              }
            }
            else
            {
              glpPushdownPrecision(a1, v14, v19);
            }
          }
          uint64_t Allocator = glpCompilerGetAllocator(a1);
          uint64_t ValueHash = glpCompilerGetValueHash(a1);
          uint64_t v22 = glpIfExprNodeGetCondition(a2);
          uint64_t v23 = glpConstantFold(Allocator, ValueHash, v22);
          if (glpIsConstantNode(v23))
          {
            if (*(_DWORD *)glpConstantNodeGetValue(v23)) {
              uint64_t v24 = glpIfExprNodeGetIfExpr(a2);
            }
            else {
              uint64_t v24 = glpIfExprNodeGetElseExpr(a2);
            }
            return glpSANode(a1, v24);
          }
          uint64_t v34 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(a2, &v63);
          glpMakeTypeIdentifierNode(v34, &v63, (uint64_t)"<<BUG: placeholder type still exists>>", 0x781A7BE300000026);
          uint64_t v36 = v35;
          uint64_t v37 = glpIfExprNodeGetIfExpr(a2);
          uint64_t v38 = glpASTNodeGetSaType(v37);
          glpASTNodeSetSaType(v36, v38);
          glpASTNodeSetSaFlags(v36, v18);
          uint64_t v39 = glpIfExprNodeGetCondition(a2);
          uint64_t v40 = glpASTNodeGetSaFlags(v39) | 0x1F;
          uint64_t SaFlags = glpASTNodeGetSaFlags(v14);
          uint64_t v42 = v40 & SaFlags & glpASTNodeGetSaFlags(v15);
          glpASTNodeGetLocation(a2, &v62);
          uint64_t v43 = glpCompilerNewTempName(a1);
          uint64_t v45 = v44;
          uint64_t v46 = glpIfExprNodeGetCondition(a2);
          uint64_t v47 = glpIfExprNodeGetIfExpr(a2);
          uint64_t v48 = glpIfExprNodeGetElseExpr(a2);
          uint64_t IfExprFragment = glpMakeIfExprFragment(a1, &v62, (uint64_t)v43, v45, v36, v46, v47, v48);
          glpASTNodeSetSaFlags(v36, v42);
          return IfExprFragment;
        }
        if (!glpTypeGetKind(v16) && !glpTypeGetKind(v17))
        {
          unsigned int ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
          uint64_t v50 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v16);
          uint64_t v51 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v17);
          unsigned int v61 = v51;
          if (glpCanConvert(v51, v50, ImplicitConversionPolicy))
          {
            uint64_t v52 = glpConvert(a1, v15, (uint64_t)v16, v18);
            glpIfExprNodeSetElseExpr(a2, v52);
            goto LABEL_11;
          }
          if (glpCanConvert(v50, v61, ImplicitConversionPolicy))
          {
            uint64_t v53 = glpConvert(a1, v14, (uint64_t)v17, v19);
            glpIfExprNodeSetIfExpr(a2, v53);
            goto LABEL_11;
          }
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v65);
          char v55 = glpPrimitiveTypeToString(v50);
          glpPrimitiveTypeToString(v61);
          glpLogMessage(InfoLog, 0, (uint64_t)&v65, "Types '%s' and '%s' in conditional operator do not match (and no applicable implicit type conversion)", v56, v57, v58, v59, v55);
          return glpSAFailed();
        }
        uint64_t v26 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v64);
        uint64_t v31 = "Types in conditional operator do not match";
        int v32 = &v64;
      }
      else
      {
        uint64_t v26 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v66);
        uint64_t v31 = "Condition must be of type BOOL";
        int v32 = &v66;
      }
      glpLogMessage(v26, 0, (uint64_t)v32, v31, v27, v28, v29, v30, v60);
      return glpSAFailed();
    }
  }

  return glpSAFailed();
}

uint64_t glpSAAssign(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (glpSABinaryOperator(a1, a2) != -1)
  {
    uint64_t Lhs = glpBinaryOperatorNodeGetLhs(v2);
    uint64_t Rhs = glpBinaryOperatorNodeGetRhs(v2);
    if (!glpIsLValueNode(Lhs))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v103);
      uint64_t v11 = "Left-hand-side of assignment must be an lvalue";
      uint64_t v12 = &v103;
      goto LABEL_11;
    }
    if ((glpASTNodeGetSaFlags(Lhs) & 0x60) != 0)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v102);
      uint64_t v11 = "Left-hand-side of assignment must not be const";
      uint64_t v12 = &v102;
LABEL_11:
      glpLogMessage(InfoLog, 0, (uint64_t)v12, v11, v7, v8, v9, v10, v86);
      return glpSAFailed();
    }
    if ((glpASTNodeGetSaFlags(Lhs) & 0x300) != 0)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v101);
      uint64_t v11 = "Left-hand-side of assignment must not be read-only";
      uint64_t v12 = &v101;
      goto LABEL_11;
    }
    if (glpAssignNodeGetIsFromSource(v2))
    {
      Sauint64_t Type = glpASTNodeGetSaType(Lhs);
      if (glpTypeGetSamplerCount(SaType))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v100);
        uint64_t v11 = "Cannot assign samplers";
        uint64_t v12 = &v100;
        goto LABEL_11;
      }
    }
    uint64_t v15 = (unsigned int *)glpASTNodeGetSaType(Lhs);
    if (glpTypeGetKind(v15) != 1)
    {
      uint64_t v16 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      if (glpTypeGetKind(v16) != 2)
      {
        uint64_t v17 = (unsigned int *)glpASTNodeGetSaType(Lhs);
        if (glpTypeGetKind(v17))
        {
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v99);
          uint64_t v11 = "You can't assign non-struct non-primitives directly.";
          uint64_t v12 = &v99;
          goto LABEL_11;
        }
      }
    }
    unint64_t v18 = (unsigned int *)glpASTNodeGetSaType(Lhs);
    uint64_t v19 = glpASTNodeGetSaType(Rhs);
    if (!glpTypesEqual(v18, v19))
    {
      uint64_t v24 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      if (glpTypeGetKind(v24)
        || (uint64_t v25 = (unsigned int *)glpASTNodeGetSaType(Rhs), glpTypeGetKind(v25)))
      {
        uint64_t v26 = glpASTNodeGetSaType(Lhs);
        uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v26, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
        char v29 = v28;
        uint64_t v30 = glpASTNodeGetSaType(Rhs);
        uint64_t v31 = (void *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v30, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v31);
        int v32 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v97);
        glpLogMessage(v32, 0, (uint64_t)&v97, "Incompatible types (%.*s and %.*s) in assignment", v33, v34, v35, v36, v29);
        return glpSAFailed();
      }
      uint64_t v68 = glpASTNodeGetSaType(Lhs);
      Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(v68);
      uint64_t v70 = glpASTNodeGetSaType(Rhs);
      uint64_t v71 = glpPrimitiveTypeGetPrimitiveType(v70);
      unsigned int ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
      LODWORD(v71) = glpCanConvert(v71, PrimitiveType, ImplicitConversionPolicy);
      uint64_t v73 = glpASTNodeGetSaType(Lhs);
      if (!v71)
      {
        uint64_t v76 = (void *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v73, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v76);
        char v78 = v77;
        uint64_t v79 = glpASTNodeGetSaType(Rhs);
        char v80 = (void *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v79, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v80);
        uint64_t v81 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v98);
        glpLogMessage(v81, 0, (uint64_t)&v98, "Incompatible types (%.*s and %.*s) in assignment (and no available implicit conversion)", v82, v83, v84, v85, v78);
        return glpSAFailed();
      }
      char SaFlags = glpASTNodeGetSaFlags(Lhs);
      uint64_t v75 = glpConvert(a1, Rhs, v73, SaFlags & 0x1F);
      glpBinaryOperatorNodeSetRhs(v2, v75);
    }
    uint64_t v20 = glpASTNodeGetSaFlags(Rhs) & 0x1F;
    uint64_t v21 = (_DWORD *)glpASTNodeGetSaType(Lhs);
    if (glpTypeIsAtomic(v21) && (glpASTNodeGetSaFlags(Lhs) & 0x1F) != v20)
    {
      if (v20 != 31 && v20)
      {
        if ((glpASTNodeGetSaFlags(Lhs) & 0x1F) != 0)
        {
          uint64_t v66 = glpASTNodeGetSaType(Lhs);
          char v67 = glpASTNodeGetSaFlags(Lhs);
          uint64_t Rhs = glpConvert(a1, Rhs, v66, v67 & 0x1F);
          glpBinaryOperatorNodeSetRhs(v2, Rhs);
        }
        else
        {
          glpASTNodeGetSaFlags(Rhs);
        }
LABEL_34:
        if (glpDerefNodeGetOffset(Lhs))
        {
          uint64_t Offset = glpDerefNodeGetOffset(Lhs);
          unsigned int Swizzle = glpOffsetNodeGetSwizzle(Offset);
          if (glpSwizzleHasDuplicateComponents(Swizzle))
          {
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v96);
            uint64_t v11 = "Destination swizzle may not have duplicate components";
            uint64_t v12 = &v96;
            goto LABEL_11;
          }
        }
        uint64_t v40 = glpASTNodeGetSaType(Lhs);
        glpASTNodeSetSaType(v2, v40);
        uint64_t v41 = (_DWORD *)glpASTNodeGetSaType(Lhs);
        if (glpTypeIsAtomic(v41))
        {
          if (!*(void *)(glpLValueNodeGetVariableExtra(Lhs) + 8)
            || (Variableunint64_t Extra = glpLValueNodeGetVariableExtra(Lhs),
                !glpLayoutObjectFind(*(uint64_t **)(VariableExtra + 8), 29)))
          {
LABEL_54:
            if (glpIsBinaryOperatorNode(v2))
            {
              uint64_t Expr = glpBinaryOperatorNodeGetLhs(v2);
            }
            else
            {
              if (!glpIsCommaExprNode(v2))
              {
                uint64_t v65 = v2;
                uint64_t v64 = 0;
                goto LABEL_59;
              }
              int ExprCount = glpCommaExprNodeGetExprCount(v2);
              uint64_t Expr = glpCommaExprNodeGetExpr(v2, ExprCount - 1);
            }
            uint64_t v64 = glpASTNodeGetSaFlags(Expr) & 0x1F;
            uint64_t v65 = v2;
LABEL_59:
            glpASTNodeSetSaFlags(v65, v64);
            return v2;
          }
          uint64_t v43 = glpASTNodeGetSaType(Lhs);
          uint64_t v44 = glpDerefNodeGetOffset(Lhs);
          uint64_t OffsetExpr = glpOffsetNodeGetOffsetExpr(v44);
          uint64_t v46 = glpHandleGetterSetter(a1, Lhs, v43, OffsetExpr, Rhs, (uint64_t)"setter", 0x7663306B00000006, 0);
        }
        else
        {
          if (glpAssignNodeGetIsFromSource(v2))
          {
            uint64_t v47 = (unsigned int *)glpASTNodeGetSaType(Lhs);
            if (glpTypeGetKind(v47) == 2)
            {
              uint64_t NameTable = glpCompilerGetNameTable(a1);
              if (glpNameTableGetGLSLVersion(NameTable) <= 1)
              {
                InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(v2, &v95);
                uint64_t v11 = "'=' disallowed on array types";
                uint64_t v12 = &v95;
                goto LABEL_11;
              }
            }
          }
          __n128 v93 = 0uLL;
          uint64_t v94 = 0;
          glpASTNodeGetLocation(v2, &v93);
          uint64_t v49 = glpCompilerGetAllocator(a1);
          __n128 v91 = v93;
          uint64_t v92 = v94;
          glpMakeCommaExprNode(v49, &v91, 0);
          uint64_t v51 = v50;
          uint64_t v89 = 0;
          uint64_t v90 = 0;
          glpHandleSideEffectsForExpr(a1, Lhs, &v90, &v89);
          if (v89)
          {
            uint64_t v52 = (void *)glpCompilerGetAllocator(a1);
            glpCommaExprNodeAddExpr(v52, v51, v89);
            uint64_t v89 = 0;
          }
          uint64_t v87 = 0;
          uint64_t v88 = 0;
          glpHandleSideEffectsForExpr(a1, Rhs, &v88, &v87);
          if (v87)
          {
            uint64_t v53 = (void *)glpCompilerGetAllocator(a1);
            glpCommaExprNodeAddExpr(v53, v51, v87);
            uint64_t v87 = 0;
          }
          int AccessorCount = glpGetAccessorCount(v90);
          if (AccessorCount)
          {
            int v55 = AccessorCount;
            uint64_t v56 = 0;
            do
            {
              uint64_t v57 = (void *)glpCompilerGetAllocator(a1);
              uint64_t Accessor = glpMakeAccessor(a1, v90, v56);
              uint64_t v59 = glpMakeAccessor(a1, v88, v56);
              __n128 v91 = v93;
              uint64_t v92 = v94;
              uint64_t AssignFragment = glpMakeAssignFragment(a1, &v91, Accessor, v59);
              glpCommaExprNodeAddExpr(v57, v51, AssignFragment);
              uint64_t v56 = (v56 + 1);
            }
            while (v55 != v56);
          }
          unsigned int v61 = (void *)glpCompilerGetAllocator(a1);
          glpCommaExprNodeAddExpr(v61, v51, v90);
          uint64_t v46 = glpSANode(a1, v51);
        }
        uint64_t v2 = v46;
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v22 = (_DWORD *)glpASTNodeGetSaType(Lhs);
      if (glpTypeIsAtomic(v22)) {
        goto LABEL_34;
      }
      if (v20) {
        goto LABEL_34;
      }
      uint64_t v23 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      if (!glpCompilerDoesTypeRequirePrecision(a1, v23)) {
        goto LABEL_34;
      }
    }
    char v37 = glpASTNodeGetSaFlags(Lhs);
    glpPushdownPrecision(a1, Rhs, v37);
    goto LABEL_34;
  }

  return glpSAFailed();
}

uint64_t glpSAOpAssign(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) != -1)
  {
    uint64_t Lhs = glpBinaryOperatorNodeGetLhs(a2);
    uint64_t Rhs = glpBinaryOperatorNodeGetRhs(a2);
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(Lhs);
    if (glpCompilerDoesTypeRequirePrecision(a1, SaType) && (glpASTNodeGetSaFlags(Rhs) & 0x1F) == 0)
    {
      char SaFlags = glpASTNodeGetSaFlags(Lhs);
      glpPushdownPrecision(a1, Rhs, SaFlags);
    }
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    glpHandleSideEffectsForExpr(a1, Lhs, &v34, &v33);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    glpHandleSideEffectsForExpr(a1, Rhs, &v32, &v31);
    Desugar = (uint64_t (*)(uint64_t, __n128 *, __n128))glpOpAssignNodeGetDesugar(a2);
    uint64_t Allocator = glpCompilerGetAllocator(a1);
    __n128 Location = glpASTNodeGetLocation(a2, &v30);
    uint64_t v11 = Desugar(Allocator, &v30, Location);
    glpBinaryOperatorNodeSetLhs(v11, v34);
    glpBinaryOperatorNodeSetRhs(v11, v32);
    uint64_t v12 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v29);
    uint64_t AssignNode = glpMakeAssignNode(v12, &v29, 0);
    uint64_t v14 = glpDuplicateDerefOrConstant(a1, v34);
    glpBinaryOperatorNodeSetLhs(AssignNode, v14);
    glpBinaryOperatorNodeSetRhs(AssignNode, v11);
    if (v31 && glpIsCommaExprNode(v31))
    {
      unsigned int v15 = glpCommaExprNodeGetExprCount(v31) - 1;
      glpCommaExprNodeSetExpr(v31, v15, 0);
      uint64_t v16 = v31;
      glpASTNodeSetSaType(v31, 0);
    }
    else
    {
      uint64_t v17 = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(a2, &v28);
      glpMakeCommaExprNode(v17, &v28, 0);
      uint64_t v16 = v18;
      if (v31)
      {
        uint64_t v19 = (void *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v19, v16, v31);
      }
      unsigned int v15 = -1;
    }
    if (v33)
    {
      if (glpIsCommaExprNode(v33))
      {
        int ExprCount = glpCommaExprNodeGetExprCount(v33);
        int v21 = ExprCount - 1;
        if (ExprCount != 1)
        {
          unsigned int v22 = 0;
          do
          {
            uint64_t Expr = glpCommaExprNodeGetExpr(v33, v22);
            if ((v15 & 0x80000000) != 0)
            {
              uint64_t v24 = (void *)glpCompilerGetAllocator(a1);
              glpCommaExprNodeAddExpr(v24, v16, Expr);
            }
            else
            {
              glpCommaExprNodeSetExpr(v16, v15, Expr);
              unsigned int v15 = -1;
            }
            glpCommaExprNodeSetExpr(v33, v22++, 0);
          }
          while (v21 != v22);
        }
        glpASTNodeSetSaType(v16, 0);
      }
      else if (v33)
      {
        if ((v15 & 0x80000000) != 0)
        {
          uint64_t v26 = (void *)glpCompilerGetAllocator(a1);
          glpCommaExprNodeAddExpr(v26, v16, v33);
        }
        else
        {
          glpCommaExprNodeSetExpr(v16, v15, v33);
        }
        goto LABEL_29;
      }
    }
    if ((v15 & 0x80000000) == 0)
    {
      glpCommaExprNodeSetExpr(v16, v15, AssignNode);
      return glpSANode(a1, v16);
    }
LABEL_29:
    uint64_t v27 = (void *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v27, v16, AssignNode);
    return glpSANode(a1, v16);
  }

  return glpSAFailed();
}

void glpSAReadInput()
{
}

void glpSAWriteOutput()
{
}

uint64_t glpSACommaExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!glpCommaExprNodeGetExprCount(a2)) {
    goto LABEL_8;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t Expr = glpCommaExprNodeGetExpr(v2, v4);
    uint64_t v7 = glpSANode(a1, Expr);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpCommaExprNodeSetExpr(v2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpCommaExprNodeGetExprCount(v2));
  if (!v5)
  {
    return glpSAFailed();
  }
  else
  {
LABEL_8:
    int ExprCount = glpCommaExprNodeGetExprCount(v2);
    uint64_t v9 = glpCommaExprNodeGetExpr(v2, ExprCount - 1);
    Sauint64_t Type = glpASTNodeGetSaType(v9);
    glpASTNodeSetSaType(v2, SaType);
    if (glpCommaExprNodeGetExprCount(v2))
    {
      unsigned int v11 = 0;
      uint64_t v12 = 96;
      while (1)
      {
        uint64_t v13 = glpCommaExprNodeGetExpr(v2, v11);
        if (v13)
        {
          uint64_t v14 = v13;
          v12 &= glpASTNodeGetSaFlags(v13);
          if (glpCommaExprNodeGetIsFromSource(v2))
          {
            if (v11 != glpCommaExprNodeGetExprCount(v2) - 1)
            {
              unsigned int v15 = (unsigned int *)glpASTNodeGetSaType(v14);
              if (glpCompilerDoesTypeRequirePrecision(a1, v15) && (glpASTNodeGetSaFlags(v14) & 0x1F) == 0)
              {
                uint64_t v16 = (unsigned int *)glpASTNodeGetSaType(v14);
                DefaultPrecisionForuint64_t Type = glpGetDefaultPrecisionForType(a1, v16);
                if (!DefaultPrecisionForType)
                {
                  uint64_t v22 = glpASTNodeGetSaType(v14);
                  uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
                  glpTypeHumanReadableDescription(v22, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
                  char v25 = v24;
                  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                  glpASTNodeGetLocation(v2, &v31);
                  glpLogMessage(InfoLog, 0, (uint64_t)&v31, "Expression of type '%.*s' - precision can not be inferred and no default precision available", v27, v28, v29, v30, v25);
                  return glpSAFailed();
                }
                glpPushdownPrecision(a1, v14, DefaultPrecisionForType);
              }
            }
          }
        }
        if (++v11 >= glpCommaExprNodeGetExprCount(v2)) {
          goto LABEL_20;
        }
      }
    }
    uint64_t v12 = 96;
LABEL_20:
    int v18 = glpCommaExprNodeGetExprCount(v2);
    uint64_t v19 = glpCommaExprNodeGetExpr(v2, v18 - 1);
    char SaFlags = glpASTNodeGetSaFlags(v19);
    glpASTNodeSetSaFlags(v2, SaFlags & 0x1F | (unint64_t)v12);
    return v2;
  }
}

uint64_t glpSAParameterDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t Type = glpParameterDeclarationNodeGetType(a2);
  uint64_t v5 = glpSANode(a1, Type);
  if (v5 != -1)
  {
    glpParameterDeclarationNodeSetType(a2, v5);
    uint64_t v6 = glpParameterDeclarationNodeGetType(a2);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    glpASTNodeGetLocation(a2, &v30);
    if (glpEvaluateTypeNode(a1, (long long *)&v30, 5u, 1, v6, 0, &v34, (uint64_t)&v33, &v32, &v31))
    {
      if (glpCompilerUsingStyleGuide(a1) && !glpTypeIsAtomic(v34))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v29);
        glpLogMessage(InfoLog, 2u, (uint64_t)&v29, "Passing large objects to functions may result in significant unnecessary copying", v8, v9, v10, v11, v27);
      }
      uint64_t Name = (const char *)glpParameterDeclarationNodeGetName(a2);
      uint64_t v14 = glpCheckName(a1, a2, Name, v13);
      if (v14 != -1)
      {
        uint64_t v15 = v14;
        if (glpTypeGetKind(v34) != 2 || glpArrayTypeGetElementCount((uint64_t)v34) != -1)
        {
          Sauint64_t Type = glpASTNodeGetSaType(v6);
          glpASTNodeSetSaType(v15, SaType);
          if (v32)
          {
            uint64_t v17 = (void *)*v32;
            if (*v32)
            {
              uint64_t v18 = v33;
              while (1)
              {
                int v19 = *((_DWORD *)v17 + 2);
                uint64_t v17 = (void *)*v17;
                if (v19 == 99) {
                  break;
                }
                if (v19 == 98)
                {
                  v18 |= 0x800100uLL;
LABEL_16:
                  uint64_t v33 = v18;
                }
                if (!v17) {
                  goto LABEL_18;
                }
              }
              v18 |= 0x1000000uLL;
              goto LABEL_16;
            }
LABEL_18:
            uint64_t Allocator = glpCompilerGetAllocator(a1);
            glpDestroyLayoutObject(Allocator, (void **)v32);
            uint64_t v32 = 0;
          }
          glpASTNodeSetSaFlags(v15, v33 | 0x400000);
          glpParameterDeclarationNodeSetType(v15, 0);
          return v15;
        }
        uint64_t v22 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v15, &v28);
        glpLogMessage(v22, 0, (uint64_t)&v28, "Unsized arrays are not allowed as parameter or return types.", v23, v24, v25, v26, v27);
      }
    }
    return glpSAFailed();
  }

  return glpSAFailed();
}

uint64_t glpSAFunctionPrototype(void *a1, uint64_t a2)
{
  uint64_t v260 = *MEMORY[0x263EF8340];
  if (glpFunctionPrototypeNodeGetParameterCount(a2) == 1)
  {
    uint64_t Parameter = glpFunctionPrototypeNodeGetParameter(a2, 0);
    uint64_t Type = glpParameterDeclarationNodeGetType(Parameter);
    if (glpIsPrimitiveTypeNode(Type) && !glpPrimitiveTypeNodeGetType(Type)) {
      glpFunctionPrototypeNodeClearParameters(a2);
    }
  }
  Returnuint64_t Type = glpFunctionPrototypeNodeGetReturnType(a2);
  uint64_t v7 = glpSANode(a1, ReturnType);
  if (v7 == -1)
  {
    int v8 = 0;
  }
  else
  {
    glpFunctionPrototypeNodeSetReturnType(a2, v7);
    int v8 = 1;
  }
  uint64_t ReturnOutParam = glpFunctionPrototypeNodeGetReturnOutParam(a2);
  uint64_t v10 = glpSANode(a1, ReturnOutParam);
  if (v10 == -1) {
    int v8 = 0;
  }
  else {
    glpFunctionPrototypeNodeSetReturnOutParam(a2, v10);
  }
  if (glpFunctionPrototypeNodeGetParameterCount(a2))
  {
    unsigned int v11 = 0;
    do
    {
      uint64_t v12 = glpFunctionPrototypeNodeGetParameter(a2, v11);
      uint64_t v13 = glpSANode(a1, v12);
      if (v13 == -1) {
        int v8 = 0;
      }
      else {
        glpFunctionPrototypeNodeSetParameter(a2, v11, v13);
      }
      ++v11;
    }
    while (v11 < glpFunctionPrototypeNodeGetParameterCount(a2));
  }
  if (v8)
  {
    uint64_t Name = (char *)glpFunctionPrototypeNodeGetName(a2);
    uint64_t v16 = v15;
    uint64_t ImmediateSAContext = glpCompilerGetImmediateSAContext((uint64_t)a1);
    if (!glpIsTopLevelNode(ImmediateSAContext) && !glpIsFunctionDefinitionNode(ImmediateSAContext))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
      glpASTNodeGetLocation(a2, &v259);
      glpLogMessage(InfoLog, 0, (uint64_t)&v259, "Prototype for function '%.*s' must occur at the top level", v30, v31, v32, v33, v16);
      return glpSAFailed();
    }
    uint64_t v18 = glpFunctionPrototypeNodeGetReturnType(a2);
    uint64_t v257 = 0;
    v258 = 0;
    uint64_t v255 = 0;
    v256 = 0;
    glpASTNodeGetLocation(a2, &v254);
    if (!glpEvaluateTypeNode((uint64_t)a1, (long long *)&v254, 4u, 1, v18, 0, &v258, (uint64_t)&v257, &v256, &v255))return glpSAFailed(); {
    uint64_t v19 = glpCheckName((uint64_t)a1, a2, Name, v16);
    }
    if (v19 == -1) {
      return glpSAFailed();
    }
    uint64_t v20 = v19;
    if (glpStringsEqual("main", 0x83863A00000004, Name, v16))
    {
      if (glpTypeGetKind(v258) || glpPrimitiveTypeGetPrimitiveType((uint64_t)v258))
      {
        int v21 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v20, &v253);
        uint64_t v26 = "main() must return void";
        char v27 = &v253;
LABEL_26:
        glpLogMessage(v21, 0, (uint64_t)v27, v26, v22, v23, v24, v25, v206[0]);
        return glpSAFailed();
      }
      if (glpFunctionPrototypeNodeGetParameterCount(v20))
      {
        int v21 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v20, &v252);
        uint64_t v26 = "main() may not take any arguments";
        char v27 = &v252;
        goto LABEL_26;
      }
    }
    uint64_t ParameterCount = glpFunctionPrototypeNodeGetParameterCount(v20);
    v206[1] = (uint64_t)v206;
    MEMORY[0x270FA5388](ParameterCount);
    char v37 = (char *)v206 - v36;
    uint64_t v38 = glpFunctionPrototypeNodeGetParameterCount(v20);
    MEMORY[0x270FA5388](v38);
    uint64_t v41 = (char *)v206 - v40;
    uint64_t v208 = v20;
    if (v39 >= 0x200) {
      size_t v42 = 512;
    }
    else {
      size_t v42 = v39;
    }
    bzero((char *)v206 - v40, v42);
    uint64_t v43 = glpFunctionPrototypeNodeGetParameterCount(v208);
    MEMORY[0x270FA5388](v43);
    uint64_t v46 = (char *)v206 - v45;
    if (v44 >= 0x200) {
      size_t v47 = 512;
    }
    else {
      size_t v47 = v44;
    }
    uint64_t v48 = v208;
    bzero((char *)v206 - v45, v47);
    if (glpFunctionPrototypeNodeGetParameterCount(v48))
    {
      unint64_t v49 = 0;
      do
      {
        uint64_t v50 = glpFunctionPrototypeNodeGetParameter(v48, v49);
        *(void *)&v37[8 * v49] = glpASTNodeGetSaFlags(v50);
        *(void *)&v41[8 * v49] = glpASTNodeGetSaType(v50);
        *(void *)&v46[8 * v49++] = 0;
      }
      while (v49 < glpFunctionPrototypeNodeGetParameterCount(v48));
    }
    uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
    uint64_t v52 = v258;
    unsigned int v53 = glpFunctionPrototypeNodeGetParameterCount(v48);
    Functionuint64_t Type = glpMakeFunctionType(Allocator, (uint64_t)v52, v53, (uint64_t)v41, (uint64_t)v37, (uint64_t)v46);
    glpASTNodeSetSaType(v48, FunctionType);
    uint64_t v55 = v257;
    if (v256)
    {
      uint64_t v56 = (void *)*v256;
      if (*v256)
      {
        int v57 = 0;
        while (1)
        {
          uint64_t v58 = v56;
          uint64_t v56 = (void *)*v56;
          int v59 = *((_DWORD *)v58 + 2);
          switch(v59)
          {
            case '[':
              v55 |= 0x2000uLL;
              if (v56) {
                continue;
              }
              goto LABEL_68;
            case '\\':
              v55 |= 0x1000uLL;
              if (v56) {
                continue;
              }
              goto LABEL_68;
            case ']':
              v55 |= 0x800uLL;
              if (v56) {
                continue;
              }
              goto LABEL_68;
            case '^':
              v55 |= 0x8000uLL;
              if (v56) {
                continue;
              }
              goto LABEL_68;
            case '_':
              v55 |= 0x10000uLL;
              if (v56) {
                continue;
              }
              goto LABEL_68;
              v55 |= 0x20000uLL;
              goto LABEL_62;
            case 'a':
              v55 |= 0x40000uLL;
              if (v56) {
                continue;
              }
              goto LABEL_68;
            default:
              if (v59 == 32)
              {
                v55 |= 0x4000uLL;
                int v57 = *((_DWORD *)v58 + 4);
                if (!v56) {
                  goto LABEL_68;
                }
              }
              else
              {
LABEL_62:
                if (!v56) {
                  goto LABEL_68;
                }
              }
              break;
          }
        }
      }
      int v57 = 0;
LABEL_68:
      uint64_t v60 = glpCompilerGetAllocator(a1);
      glpDestroyLayoutObject(v60, (void **)v256);
      v256 = 0;
    }
    else
    {
      int v57 = 0;
    }
    uint64_t NameTable = glpCompilerGetNameTable((uint64_t)a1);
    unsigned int v61 = (void *)glpCompilerGetAllocator(a1);
    __n128 v62 = (char *)glpAggregateTypeMangleName(FunctionType, (uint64_t)Name, v16, v61);
    uint64_t v64 = v63;
    uint64_t v65 = glpCompilerGetAllocator(a1);
    uint64_t v207 = FunctionType;
    glpMakeFunctionObject(v65, FunctionType, v55, (uint64_t)Name, v16, (uint64_t)v62, v64);
    uint64_t FunctionObject = v66;
    *(_DWORD *)(v66 + 92) = v57;
    if (v255) {
      BOOL v68 = (v55 & 0x180000) != 0;
    }
    else {
      BOOL v68 = 0;
    }
    if ((v55 & 0x180000) != 0 && !v68)
    {
      *(void *)(v66 + 8) &= ~0x100000uLL;
      Subroutineuint64_t Type = (unsigned int *)glpCompilerGetSubroutineType(a1, *(const char **)(v66 + 24), *(void *)(v66 + 32), (uint64_t *)v66);
      uint64_t v248 = 0;
      v249 = &v248;
      uint64_t v250 = 0x2000000000;
      int v251 = 0;
      uint64_t v244 = 0;
      v245 = &v244;
      uint64_t v246 = 0x2000000000;
      uint64_t v247 = 0;
      v243[0] = MEMORY[0x263EF8330];
      v243[1] = 0x40000000;
      v243[2] = __glpSAFunctionPrototype_block_invoke;
      v243[3] = &unk_264D9C808;
      v243[4] = &v248;
      v243[5] = &v244;
      glpNameTableGet(NameTable, *(char **)(FunctionObject + 24), *(void *)(FunctionObject + 32), 2, (uint64_t)v243);
      uint64_t v70 = v245[3];
      if (v70)
      {
        uint64_t v71 = v208;
        if (*((_DWORD *)v249 + 6) == 8)
        {
          if (glpTypesEqual(SubroutineType, v70))
          {
            Subroutineuint64_t Type = (unsigned int *)v245[3];
LABEL_92:
            uint64_t FunctionObject = glpSubroutineTypeGetFunctionObject((uint64_t)SubroutineType);
            uint64_t v207 = *(void *)FunctionObject;
            char v91 = 1;
            goto LABEL_97;
          }
          __n128 v102 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v71, &v242);
          glpLogMessage(v102, 0, (uint64_t)&v242, "Redeclaration of subroutine type '%.*s' does not match previous declaration", v103, v104, v105, v106, *(_DWORD *)(FunctionObject + 32));
        }
        else
        {
          uint64_t v92 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v71, &v241);
          glpLogMessage(v92, 0, (uint64_t)&v241, "subroutine type '%.*s' previously declared as another kind of object", v93, v94, v95, v96, *(_DWORD *)(FunctionObject + 32));
        }
        uint64_t NameTable = glpSAFailed();
        char v91 = 0;
LABEL_97:
        _Block_object_dispose(&v244, 8);
        _Block_object_dispose(&v248, 8);
        if ((v91 & 1) == 0) {
          return NameTable;
        }
        goto LABEL_133;
      }
      glpNameTablePut(NameTable, Name, v16, 8, (uint64_t)SubroutineType);
      goto LABEL_92;
    }
    uint64_t v72 = glpCompilerGetImmediateSAContext((uint64_t)a1);
    BOOL IsFunctionDefinitionNode = glpIsFunctionDefinitionNode(v72);
    if (!IsFunctionDefinitionNode && v68)
    {
      uint64_t v75 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
      glpASTNodeGetLocation(v208, &v240);
      glpLogMessage(v75, 0, (uint64_t)&v240, "Subroutine type declaration '%.*s' may not include a list of compatible subroutine types", v76, v77, v78, v79, v16);
      return glpSAFailed();
    }
    BOOL v80 = IsFunctionDefinitionNode;
    *(void *)(FunctionObject + 8) &= ~0x80000uLL;
    *(void *)(FunctionObject + 56) = v255;
    uint64_t v248 = 0;
    v249 = &v248;
    uint64_t v250 = 0x2000000000;
    int v251 = 0;
    uint64_t v244 = 0;
    v245 = &v244;
    uint64_t v246 = 0x2000000000;
    uint64_t v247 = 0;
    uint64_t v236 = 0;
    v237 = &v236;
    uint64_t v238 = 0x2000000000;
    int v239 = 0;
    v235[0] = MEMORY[0x263EF8330];
    v235[1] = 0x40000000;
    v235[2] = __glpSAFunctionPrototype_block_invoke_2;
    v235[3] = &unk_264D9C830;
    v235[4] = &v248;
    v235[5] = &v244;
    v235[7] = NameTable;
    v235[6] = &v236;
    glpNameTableGet(NameTable, Name, v16, 0, (uint64_t)v235);
    uint64_t v231 = 0;
    v232 = &v231;
    uint64_t v233 = 0x2000000000;
    uint64_t v234 = 0;
    uint64_t v227 = 0;
    v228 = &v227;
    uint64_t v229 = 0x2000000000;
    int v230 = 0;
    v226[0] = MEMORY[0x263EF8330];
    v226[1] = 0x40000000;
    v226[2] = __glpSAFunctionPrototype_block_invoke_3;
    v226[3] = &unk_264D9C858;
    v226[4] = &v231;
    v226[5] = &v227;
    glpNameTableGet(NameTable, v62, v64, 0, (uint64_t)v226);
    uint64_t v81 = (uint64_t *)v245[3];
    if (v81)
    {
      if (*((_DWORD *)v249 + 6) != 4)
      {
        __n128 v97 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v208, &v215);
        glpLogMessage(v97, 0, (uint64_t)&v215, "Function '%.*s' previously declared as non-function", v98, v99, v100, v101, v16);
        goto LABEL_130;
      }
      if (!v81[1])
      {
        v206[0] = *v81;
        uint64_t v82 = (void *)glpCompilerGetAllocator(a1);
        uint64_t v83 = (char *)glpAggregateTypeMangleName(v206[0], (uint64_t)Name, v16, v82);
        uint64_t v222 = 0;
        v223 = &v222;
        uint64_t v224 = 0x2000000000;
        uint64_t v225 = 0;
        v221[0] = MEMORY[0x263EF8330];
        v221[1] = 0x40000000;
        v221[2] = __glpSAFunctionPrototype_block_invoke_4;
        v221[3] = &unk_264D9C880;
        v221[4] = &v222;
        glpNameTableGet(NameTable, v83, v84, 0, (uint64_t)v221);
        if ((*(unsigned char *)(v223[3] + 10) & 0x20) != 0)
        {
          v113 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v208, &v220);
          glpLogMessage(v113, 0, (uint64_t)&v220, "Function '%.*s' previously declared as subroutine implementation", v114, v115, v116, v117, v16);
          uint64_t NameTable = glpSAFailed();
          _Block_object_dispose(&v222, 8);
LABEL_131:
          int v135 = 0;
LABEL_132:
          _Block_object_dispose(&v227, 8);
          _Block_object_dispose(&v231, 8);
          _Block_object_dispose(&v236, 8);
          _Block_object_dispose(&v244, 8);
          _Block_object_dispose(&v248, 8);
          if (!v135) {
            return NameTable;
          }
LABEL_133:
          uint64_t v157 = v208;
          glpFunctionPrototypeNodeSetExtra(v208, FunctionObject);
          v258 = (unsigned int *)glpFunctionTypeGetReturnType(v207);
          if (*(unsigned char *)(FunctionObject + 112)
            && ((v257 ^ *(void *)(*(void *)(FunctionObject + 72) + 48)) & 0x8000000001FLL) != 0)
          {
            v158 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v157, &v210);
            glpLogMessage(v158, 0, (uint64_t)&v210, "Qualification of return type in redeclared function '%.*s' differs from previous declaration", v159, v160, v161, v162, v16);
          }
          uint64_t Extra = glpFunctionPrototypeNodeGetExtra(v157);
          uint64_t v164 = glpFunctionPrototypeNodeGetReturnOutParam(v157);
          uint64_t v207 = Extra;
          if (v164)
          {
            uint64_t v165 = v164;
            uint64_t v166 = *(void *)(Extra + 72);
            if (!v166)
            {
              v167 = (void *)glpCompilerGetAllocator(a1);
              StringBuffer = glpMakeStringBuffer(v167);
              glpStringBufferAppendCString(StringBuffer, "<Compiler Temporary ");
              uint64_t v169 = glpParameterDeclarationNodeGetName(v165);
              glpStringBufferAppendString(StringBuffer, v169, v170);
              glpStringBufferAppendCString(StringBuffer, ">");
              uint64_t v171 = glpCompilerGetAllocator(a1);
              v172 = v258;
              uint64_t SaFlags = glpASTNodeGetSaFlags(v165);
              uint64_t v174 = glpParameterDeclarationNodeGetName(v165);
              uint64_t v176 = v175;
              uint64_t String = glpStringBufferGetString((uint64_t)StringBuffer);
              uint64_t v178 = v176;
              uint64_t Extra = v207;
              glpMakeVariableObject(v171, (uint64_t)v172, 0, SaFlags, v174, v178, String, v179, 0, 0, 0);
              uint64_t v166 = v180;
              *(void *)(Extra + 72) = v180;
            }
            glpParameterDeclarationNodeSetExtra(v165, v166);
          }
          uint64_t v181 = *(void *)(Extra + 80);
          if (!v181)
          {
            glpFunctionPrototypeNodeGetParameterCount(v157);
            *(void *)(Extra + 80) = glpCompilerPoolAlloc((uint64_t)a1);
            *(_DWORD *)(Extra + 88) = glpFunctionPrototypeNodeGetParameterCount(v157);
          }
          if (glpFunctionPrototypeNodeGetParameterCount(v157))
          {
            unint64_t v182 = 0;
            do
            {
              uint64_t v183 = glpFunctionPrototypeNodeGetParameter(v157, v182);
              uint64_t v184 = v183;
              if (!v181)
              {
                Sauint64_t Type = glpASTNodeGetSaType(v183);
                uint64_t v186 = glpCompilerGetAllocator(a1);
                uint64_t v187 = glpASTNodeGetSaFlags(v184);
                uint64_t v188 = glpParameterDeclarationNodeGetName(v184);
                uint64_t v190 = v189;
                uint64_t v191 = glpParameterDeclarationNodeGetName(v184);
                uint64_t v193 = v192;
                uint64_t v194 = SaType;
                uint64_t v195 = v190;
                uint64_t Extra = v207;
                uint64_t v157 = v208;
                glpMakeVariableObject(v186, v194, 0, v187, v188, v195, v191, v193, 0, 0, 0);
                *(void *)(*(void *)(Extra + 80) + 8 * v182) = v196;
              }
              glpParameterDeclarationNodeSetExtra(v184, *(void *)(*(void *)(Extra + 80) + 8 * v182++));
            }
            while (v182 < glpFunctionPrototypeNodeGetParameterCount(v157));
          }
          uint64_t v197 = *(unsigned int *)(Extra + 88);
          uint64_t v198 = *(void *)(Extra + 8);
          if (!v197)
          {
LABEL_152:
            uint64_t NameTable = v208;
            glpASTNodeSetSaFlags(v208, v198);
            glpFunctionPrototypeNodeSetReturnType(NameTable, 0);
            return NameTable;
          }
          uint64_t v199 = 0;
          uint64_t v200 = 8 * v197;
          while ((v198 & 0x3800) == 0
               || (*(_DWORD *)(*(void *)(*(void *)(Extra + 80) + v199) + 48) & 0x4800200) != 0)
          {
            v199 += 8;
            if (v200 == v199) {
              goto LABEL_152;
            }
          }
          v201 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v208, &v209);
          glpLogMessage(v201, 0, (uint64_t)&v209, "Inline function '%.*s' argument '%.*s' not foldable/out", v202, v203, v204, v205, *(_DWORD *)(Extra + 32));
          return glpSAFailed();
        }
        _Block_object_dispose(&v222, 8);
      }
      int v85 = *((_DWORD *)v237 + 6);
      if (v68)
      {
        if (v85 != 3)
        {
          char v86 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v208, &v219);
          glpLogMessage(v86, 0, (uint64_t)&v219, "Subroutine implementation '%.*s' previously declared as function", v87, v88, v89, v90, v16);
LABEL_130:
          uint64_t NameTable = glpSAFailed();
          goto LABEL_131;
        }
LABEL_100:
        switch(glpNameTableGetGLSLVersion(NameTable))
        {
          case 0u:
            if (!v232[3]) {
              goto LABEL_109;
            }
            v118 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v208, &v218);
            glpLogMessage(v118, 0, (uint64_t)&v218, "Function '%.*s' redefines a built-in function", v119, v120, v121, v122, v16);
            break;
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 7u:
          case 8u:
          case 9u:
            v245[3] = 0;
            goto LABEL_109;
          case 6u:
            v152 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v208, &v217);
            glpLogMessage(v152, 0, (uint64_t)&v217, "Function '%.*s' overloads or redefines a built-in function", v153, v154, v155, v156, v16);
            goto LABEL_130;
          case 0xAu:
            abort();
          default:
            goto LABEL_109;
        }
        goto LABEL_130;
      }
      if (v85 == 3) {
        goto LABEL_100;
      }
      if (v80)
      {
        uint64_t v107 = v232[3];
        if (v107)
        {
          if (*(void *)(v107 + 64))
          {
            char v108 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v208, &v216);
            glpLogMessage(v108, 0, (uint64_t)&v216, "Function '%.*s' redefines an existing function", v109, v110, v111, v112, v16);
            goto LABEL_130;
          }
        }
      }
    }
LABEL_109:
    uint64_t v123 = v232[3];
    if (v123)
    {
      if (!*((_DWORD *)v228 + 6) && (*(unsigned char *)(FunctionObject + 10) & 0x10) != 0)
      {
        v136 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v208, &v214);
        glpLogMessage(v136, 0, (uint64_t)&v214, "Subroutine implementation '%.*s' previously declared as function", v137, v138, v139, v140, v16);
        goto LABEL_130;
      }
      uint64_t v124 = v208;
      if ((*(unsigned char *)(v123 + 10) & 0x20) != 0)
      {
        v129 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v124, &v213);
        glpLogMessage(v129, 0, (uint64_t)&v213, "Function '%.*s' previously declared as subroutine implementation", v130, v131, v132, v133, v16);
        goto LABEL_130;
      }
      uint64_t v125 = v207;
      if (!glpTypesEqual(*(unsigned int **)v123, v207))
      {
        v141 = (unsigned int *)glpFunctionTypeGetReturnType(*(void *)v232[3]);
        uint64_t v142 = glpFunctionTypeGetReturnType(v125);
        LODWORD(v141) = glpTypesEqual(v141, v142);
        v143 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        if (v141)
        {
          glpASTNodeGetLocation(v124, &v211);
          glpLogMessage(v143, 0, (uint64_t)&v211, "Qualification of arguments in redeclared function '%.*s' differs from previous declaration", v144, v145, v146, v147, v16);
        }
        else
        {
          glpASTNodeGetLocation(v124, &v212);
          glpLogMessage(v143, 0, (uint64_t)&v212, "Return type in redeclared function '%.*s' differs from previous declaration", v148, v149, v150, v151, v16);
        }
        goto LABEL_130;
      }
      if (!*((_DWORD *)v228 + 6)) {
        uint64_t FunctionObject = v232[3];
      }
    }
    v126 = (unsigned int **)v245[3];
    if (v126)
    {
      while (1)
      {
        v127 = v126;
        if (glpTypesEqual(*v126, v207)) {
          break;
        }
        v126 = (unsigned int **)v127[1];
        if (!v126)
        {
          v128 = (unsigned int *)glpCompilerPoolAlloc((uint64_t)a1);
          *(void *)v128 = v207;
          *((void *)v128 + 1) = 0;
          v127[1] = v128;
          goto LABEL_123;
        }
      }
      if (!*((_DWORD *)v228 + 6)) {
        goto LABEL_124;
      }
    }
    else
    {
      v134 = (void *)glpCompilerPoolAlloc((uint64_t)a1);
      void *v134 = v207;
      v134[1] = 0;
      glpNameTablePut(NameTable, Name, v16, 4, (uint64_t)v134);
    }
LABEL_123:
    glpNameTablePut(NameTable, v62, v64, 5, FunctionObject);
LABEL_124:
    int v135 = 1;
    goto LABEL_132;
  }

  return glpSAFailed();
}

uint64_t glpSAVariableDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t v235 = *MEMORY[0x263EF8340];
  uint64_t Type = glpVariableDeclarationNodeGetType(a2);
  uint64_t v5 = glpSANode(a1, Type);
  if (v5 != -1) {
    glpVariableDeclarationNodeSetType(a2, v5);
  }
  uint64_t Initializer = glpVariableDeclarationNodeGetInitializer(a2);
  uint64_t v7 = glpSANode(a1, Initializer);
  if (v7 != -1)
  {
    glpVariableDeclarationNodeSetInitializer(a2, v7);
    if (v5 != -1)
    {
      uint64_t Name = (char *)glpVariableDeclarationNodeGetName(a2);
      uint64_t v10 = v9;
      uint64_t NameTable = glpCompilerGetNameTable(a1);
      uint64_t CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
      uint64_t v231 = 0;
      v232 = &v231;
      uint64_t v233 = 0x2000000000;
      int v234 = 0;
      uint64_t v227 = 0;
      v228 = &v227;
      uint64_t v229 = 0x2000000000;
      uint64_t v230 = 0;
      uint64_t v223 = 0;
      uint64_t v224 = &v223;
      uint64_t v225 = 0x2000000000;
      int v226 = 0;
      v222[0] = MEMORY[0x263EF8330];
      v222[1] = 0x40000000;
      v222[2] = __glpSAVariableDeclaration_block_invoke;
      v222[3] = &unk_264D9C8A8;
      v222[4] = &v231;
      v222[5] = &v227;
      v222[7] = NameTable;
      v222[6] = &v223;
      glpNameTableGet(NameTable, Name, v10, 2 * (CurrentFunction != 0), (uint64_t)v222);
      if (v228[3])
      {
        unsigned int v13 = 10;
        switch(*((_DWORD *)v232 + 6))
        {
          case 1:
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v221);
            glpLogMessage(InfoLog, 0, (uint64_t)&v221, "'%.*s' already declared as an interface block instance", v23, v24, v25, v26, v10);
            goto LABEL_43;
          case 2:
            char v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v220);
            glpLogMessage(v27, 0, (uint64_t)&v220, "'%.*s' already declared as an interface block", v28, v29, v30, v31, v10);
            goto LABEL_43;
          case 3:
            goto LABEL_24;
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            if (*((_DWORD *)v224 + 6))
            {
              v228[3] = 0;
              goto LABEL_9;
            }
            uint64_t v17 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v219);
            glpLogMessage(v17, 0, (uint64_t)&v219, "Attempt to redeclare '%.*s' as a variable", v18, v19, v20, v21, v10);
            break;
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
          case 0xD:
            goto LABEL_137;
          default:
            goto LABEL_9;
        }
        goto LABEL_43;
      }
LABEL_9:
      if (CurrentFunction
        || (v10 & 0xFFFFFFFE) != 0
        && *Name == 36
        && ((unsigned int v15 = Name[1], (v15 & 0x80000000) != 0)
          ? (uint64_t v16 = __maskrune_l(v15, 0x400uLL, 0))
          : (uint64_t v16 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v15 + 60) & 0x400),
            v16))
      {
        unsigned int v13 = 6;
      }
      else
      {
        unsigned int v13 = 1;
      }
LABEL_24:
      uint64_t v32 = glpVariableDeclarationNodeGetType(a2);
      __n128 v218 = 0;
      unint64_t v217 = 0;
      __n128 v216 = 0;
      uint64_t v215 = 0;
      glpASTNodeGetLocation(a2, &v214);
      int v33 = glpVariableDeclarationNodeGetIsFromSource(a2);
      char SaFlags = glpASTNodeGetSaFlags(v32);
      if (!glpEvaluateTypeNode(a1, (long long *)&v214, v13, v33, v32, SaFlags & 0x1F, &v218, (uint64_t)&v217, &v216, &v215))goto LABEL_43; {
      glpASTNodeSetSaType(a2, (uint64_t)v218);
      }
      if (glpCompilerUsingStyleGuide(a1))
      {
        if (glpTypeGetKind(v218) == 2)
        {
          Elementuint64_t Type = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v218);
          if (glpTypeGetKind(ElementType) == 1)
          {
            uint64_t v36 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v213);
            glpLogMessage(v36, 2u, (uint64_t)&v213, "Arrays of structs may be less performant than structs of arrays", v37, v38, v39, v40, v188);
          }
        }
      }
      uint64_t v41 = glpVariableDeclarationNodeGetInitializer(a2);
      if (!v41)
      {
        if ((v217 & 0x60) != 0)
        {
          uint64_t v56 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v209);
          glpVariableDeclarationNodeGetName(a2);
          char v58 = v57;
          glpVariableDeclarationNodeGetName(a2);
          glpLogMessage(v56, 0, (uint64_t)&v209, "Missing initializer for const variable '%.*s'", v59, v60, v61, v62, v58);
          goto LABEL_43;
        }
LABEL_65:
        if (glpNameTableGetGLSLVersion(NameTable) == 6
          && !glpNameTableIsExtensionEnabled(NameTable, 0x23u)
          && glpTypeGetKind(v218) == 2
          && glpArrayTypeGetElementCount((uint64_t)v218) == -1)
        {
          uint64_t v150 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v208);
          glpVariableDeclarationNodeGetName(a2);
          char v152 = v151;
          glpVariableDeclarationNodeGetName(a2);
          glpLogMessage(v150, 0, (uint64_t)&v208, "Unsized array '%.*s' requires sized initializer under GLSL 300", v153, v154, v155, v156, v152);
          goto LABEL_43;
        }
        glpASTNodeSetSaFlags(a2, v217);
        uint64_t v81 = v228[3];
        if (v81)
        {
          int v82 = *((_DWORD *)v232 + 6);
          if (v82)
          {
            if (v82 != 3) {
LABEL_137:
            }
              abort();
            if (glpNameTableGetLanguage(NameTable) == 3
              && glpStringsEqual("gl_ClipDistance", 0xA52D52050000000FLL, Name, v10)
              && (v217 & 0x20000000) != 0)
            {
              uint64_t v83 = glpCompilerGetNameTable(a1);
              v206[0] = MEMORY[0x263EF8330];
              v206[1] = 0x40000000;
              uint64_t v206[2] = __glpSAVariableDeclaration_block_invoke_2;
              v206[3] = &unk_264D9C8D0;
              v206[4] = &v227;
              glpNameTableGet(v83, "gl_in", 0x1057ED5B00000005, 0, (uint64_t)v206);
            }
            uint64_t v84 = v228[3];
            int v85 = *(unsigned int **)(v84 + 64);
            StructTypeFromIBuint64_t Type = glpGetStructTypeFromIBType(v85);
            unsigned int FieldIndex = glpStructTypeGetFieldIndex(StructTypeFromIBType, Name, v10);
            uint64_t v191 = glpAggregateTypeGetElementType(StructTypeFromIBType, FieldIndex);
            uint64_t ElementFlags = glpAggregateTypeGetElementFlags(StructTypeFromIBType, FieldIndex);
            LODWORD(v192) = FieldIndex;
            ElementLayout = (uint64_t *)glpAggregateTypeGetElementLayout(StructTypeFromIBType, FieldIndex);
            uint64_t v190 = v84;
            switch(glpInterfaceBlockObjectGetRepresentation(v84))
            {
              case 0u:
              case 2u:
                uint64_t v90 = *(uint64_t **)(v84 + 72);
                goto LABEL_87;
              case 1u:
              case 3u:
                uint64_t v90 = (uint64_t *)(*(void *)(v84 + 72) + 8 * v192);
LABEL_87:
                uint64_t v100 = *v90;
                break;
              default:
                uint64_t v100 = 0;
                break;
            }
            v200.n128_u64[0] = 0;
            v197.n128_u64[0] = 0;
            uint64_t v205 = 0;
            glpASTNodeGetLocation(a2, &v204);
            if (glpHandleVariableRedeclaration(a1, (long long *)&v204, (uint64_t)Name, v10, (unsigned int *)v191, ElementFlags, ElementLayout, (unsigned int *)(v100 + 96), v218, v217, (void **)v216, (unsigned int **)&v200, v197.n128_u64, &v205))
            {
              uint64_t v189 = v85;
              uint64_t ElementCount = glpAggregateTypeGetElementCount(StructTypeFromIBType);
              unsigned int v102 = ElementCount;
              uint64_t v191 = ElementCount;
              MEMORY[0x270FA5388](ElementCount);
              uint64_t v104 = &v188 - 2 * v103;
              bzero(v104, v105);
              MEMORY[0x270FA5388](v106);
              uint64_t v107 = (uint64_t *)((char *)&v188 - ((8 * v102 + 15) & 0xFFFFFFFF0));
              bzero(v107, 8 * v102);
              MEMORY[0x270FA5388](v108);
              uint64_t v109 = v107;
              bzero(v107, 8 * v102);
              MEMORY[0x270FA5388](v110);
              uint64_t v111 = v107;
              uint64_t v112 = v191;
              bzero(v107, 8 * v102);
              if (v102)
              {
                uint64_t v113 = 0;
                uint64_t v114 = v104 + 1;
                do
                {
                  *(v114 - 1) = glpStructTypeGetFieldName(StructTypeFromIBType, v113);
                  *uint64_t v114 = v115;
                  v107[v113] = glpAggregateTypeGetElementType(StructTypeFromIBType, v113);
                  v107[v113] = glpAggregateTypeGetElementFlags(StructTypeFromIBType, v113);
                  v107[v113] = glpAggregateTypeGetElementLayout(StructTypeFromIBType, v113);
                  ++v113;
                  v114 += 2;
                }
                while (v112 != v113);
              }
              int v116 = v192;
              v107[v192] = v200.n128_u64[0];
              v107[v116] = v197.n128_u64[0];
              v107[v116] = (uint64_t)v205;
              uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
              uint64_t v118 = glpStructTypeGetName(StructTypeFromIBType);
              Structuint64_t Type = glpMakeStructType(Allocator, v118, v119, v112, (uint64_t)v104, (uint64_t)v107, (uint64_t)v107, (uint64_t)v107);
              uint64_t v121 = v190;
              switch(glpInterfaceBlockObjectGetRepresentation(v190))
              {
                case 0u:
                  goto LABEL_94;
                case 1u:
                  goto LABEL_109;
                case 2u:
                  uint64_t v122 = glpCompilerGetAllocator(a1);
                  uint64_t v123 = (uint64_t)v189;
                  int Bank = glpBankTypeGetBank((uint64_t)v189);
                  int v125 = glpBankTypeGetElementCount(v123);
                  Structuint64_t Type = glpMakeBankType(v122, Bank, StructType, v125);
LABEL_94:
                  *(void *)(v121 + 64) = StructType;
                  ***(void ***)(v121 + 72) = StructType;
                  goto LABEL_113;
                case 3u:
                  uint64_t v188 = StructType;
                  uint64_t v133 = (uint64_t)v189;
                  if (v112)
                  {
                    uint64_t v134 = v191;
                    int v135 = v107;
                    do
                    {
                      uint64_t v192 = glpCompilerGetAllocator(a1);
                      int v136 = glpBankTypeGetBank(v133);
                      uint64_t v137 = *v135;
                      int v138 = glpBankTypeGetElementCount(v133);
                      *v135++ = glpMakeBankType(v192, v136, v137, v138);
                      --v134;
                    }
                    while (v134);
                  }
                  uint64_t v139 = glpCompilerGetAllocator(a1);
                  int v140 = glpBankTypeGetBank(v133);
                  int v141 = glpBankTypeGetElementCount(v133);
                  Structuint64_t Type = glpMakeBankType(v139, v140, v188, v141);
                  uint64_t v121 = v190;
                  uint64_t v112 = v191;
LABEL_109:
                  if (v112)
                  {
                    uint64_t v142 = *(void ***)(v121 + 72);
                    uint64_t v143 = *(void *)(v121 + 40);
                    do
                    {
                      uint64_t v144 = *v107++;
                      **uint64_t v142 = v144;
                      uint64_t v145 = *v109++;
                      uint64_t v146 = v145 | v143;
                      uint64_t v148 = *v142++;
                      uint64_t v147 = v148;
                      v148[6] = v146 | 0x80000000;
                      uint64_t v149 = *v111++;
                      v147[1] = v149;
                      --v112;
                    }
                    while (v112);
                  }
                  *(void *)(v121 + 64) = StructType;
                  break;
                default:
                  goto LABEL_113;
              }
              goto LABEL_113;
            }
            v126 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v203);
            glpLogMessage(v126, 0, (uint64_t)&v203, "'%.*s' already declared within an interface block", v127, v128, v129, v130, v10);
          }
          else
          {
            glpASTNodeGetLocation(a2, &v207);
            if (glpHandleVariableRedeclaration(a1, (long long *)&v207, (uint64_t)Name, v10, *(unsigned int **)v81, *(void *)(v81 + 48), *(uint64_t **)(v81 + 8), (unsigned int *)(v81 + 96), v218, v217, (void **)v216, (unsigned int **)v81, (unint64_t *)(v81 + 48), (void **)(v81 + 8)))
            {
LABEL_113:
              uint64_t v63 = 0;
              goto LABEL_44;
            }
          }
LABEL_43:
          uint64_t v63 = glpSAFailed();
LABEL_44:
          _Block_object_dispose(&v223, 8);
          _Block_object_dispose(&v227, 8);
          _Block_object_dispose(&v231, 8);
          return v63;
        }
        uint64_t v91 = glpCheckName(a1, a2, Name, v10);
        if (v91 == -1) {
          goto LABEL_43;
        }
        uint64_t v63 = v91;
        uint64_t v92 = glpVariableDeclarationNodeGetInitializer(v91);
        uint64_t v93 = v92;
        if (v92)
        {
          if (glpIsConstantNode(v92)) {
            uint64_t Value = glpConstantNodeGetValue(v93);
          }
          else {
            uint64_t Value = 0;
          }
          unint64_t v132 = v217;
          if ((v217 & 0x60) != 0)
          {
            if (glpIsConstantNode(v93))
            {
              glpVariableDeclarationNodeSetInitializer(v63, 0);
              unint64_t v132 = v217;
            }
            else
            {
              unint64_t v132 = v217 & 0xFFFFFFFFFFFFFE9FLL | 0x100;
              unint64_t v217 = v132;
            }
            uint64_t v131 = Value;
          }
          else
          {
            uint64_t v131 = 0;
          }
          if ((v132 & 0x100000000) != 0 && glpIsConstantNode(v93)) {
            glpVariableDeclarationNodeSetInitializer(v63, 0);
          }
        }
        else
        {
          uint64_t v131 = 0;
          uint64_t Value = 0;
        }
        uint64_t v157 = glpCompilerGetAllocator(a1);
        glpMakeVariableObject(v157, (uint64_t)v218, (uint64_t)v216, v217, (uint64_t)Name, v10, (uint64_t)Name, v10, v93 != 0, v131, Value);
        v228[3] = v158;
        if ((v217 & 0x200000000) == 0)
        {
          uint64_t v159 = v158;
          if ((v217 & 0x400000000) != 0)
          {
            uint64_t v160 = glpCompilerGetAllocator(a1);
            glpMakeBufferObject(v160, (uint64_t)v218, 0, 1);
            *(void *)(v159 + 88) = v161;
          }
          glpNameTablePut(NameTable, Name, v10, 0, v159);
          if (glpVariableDeclarationNodeGetInitializer(v63) && (v217 & 0x100000000) == 0)
          {
            __n128 v200 = 0uLL;
            uint64_t v201 = 0;
            glpASTNodeGetLocation(v63, &v200);
            uint64_t v162 = glpCompilerGetAllocator(a1);
            __n128 v197 = v200;
            uint64_t v198 = v201;
            glpMakeVariableIdentifierNode(v162, &v197, (uint64_t)Name, v10);
            uint64_t v164 = glpSANode(a1, v163);
            if (v164 == -1) {
              goto LABEL_43;
            }
            uint64_t v165 = v164;
            uint64_t v166 = glpASTNodeGetSaFlags(v164);
            glpASTNodeSetSaFlags(v165, v166 & 0xFFFFFFFFFFFFFEFFLL);
            uint64_t v167 = glpVariableDeclarationNodeGetInitializer(v63);
            __n128 v197 = v200;
            uint64_t v198 = v201;
            uint64_t AssignFragment = glpMakeAssignFragment(a1, &v197, v165, v167);
            glpVariableDeclarationNodeSetInitializer(v63, AssignFragment);
          }
          glpVariableDeclarationNodeSetExtra(v63, v228[3]);
          glpVariableDeclarationNodeSetType(v63, 0);
          goto LABEL_44;
        }
        v200.n128_u64[0] = 0;
        v200.n128_u64[1] = (unint64_t)&v200;
        uint64_t v201 = 0x2000000000;
        int v202 = 0;
        v197.n128_u64[0] = 0;
        v197.n128_u64[1] = (unint64_t)&v197;
        uint64_t v198 = 0x2000000000;
        uint64_t v199 = 0;
        v196[0] = MEMORY[0x263EF8330];
        v196[1] = 0x40000000;
        v196[2] = __glpSAVariableDeclaration_block_invoke_3;
        v196[3] = &unk_264D9C8F8;
        v196[4] = &v200;
        v196[5] = &v197;
        glpNameTableGet(NameTable, Name, v10, 2, (uint64_t)v196);
        uint64_t v169 = *(void *)(v197.n128_u64[1] + 24);
        if (v169)
        {
          if (*(_DWORD *)(v200.n128_u64[1] + 24) != 7)
          {
            uint64_t v183 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v63, &v194);
            glpLogMessage(v183, 0, (uint64_t)&v194, "subroutine uniform '%.*s' previously declared as different kind of object", v184, v185, v186, v187, v10);
            goto LABEL_135;
          }
          if (!glpTypesEqual(*(unsigned int **)(v169 + 16), (uint64_t)v218))
          {
            uint64_t v170 = v218;
            uint64_t v171 = (void *)glpCompilerGetAllocator(a1);
            glpTypeHumanReadableDescription((uint64_t)v170, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v171);
            char v173 = v172;
            uint64_t v174 = *(void *)(v169 + 16);
            uint64_t v175 = (void *)glpCompilerGetAllocator(a1);
            glpTypeHumanReadableDescription(v174, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v175);
            uint64_t v176 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v63, &v195);
            glpLogMessage(v176, 0, (uint64_t)&v195, "Type ('%.*s') of subroutine uniform '%.*s' does not match previous declaration ('%.*s')", v177, v178, v179, v180, v173);
LABEL_135:
            uint64_t v63 = glpSAFailed();
            goto LABEL_136;
          }
        }
        else
        {
          uint64_t v169 = glpCompilerPoolAlloc(a1);
          *(void *)uint64_t v169 = Name;
          *(void *)(v169 + 8) = v10;
          *(void *)(v169 + 16) = v218;
          glpNameTablePut(NameTable, Name, v10, 7, v169);
        }
        uint64_t v181 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v63, &v193);
        glpMakeSubroutineUniformNode(v181, &v193, v169);
        uint64_t v63 = v182;
        glpASTNodeSetSaType(v182, (uint64_t)v218);
        glpASTNodeSetSaFlags(v63, v217);
LABEL_136:
        _Block_object_dispose(&v197, 8);
        _Block_object_dispose(&v200, 8);
        goto LABEL_44;
      }
      uint64_t v42 = v41;
      Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v41);
      if (!glpTypesEqual(SaType, (uint64_t)v218))
      {
        uint64_t v64 = (unsigned int *)glpASTNodeGetSaType(v42);
        if (glpTypeGetKind(v64) || glpTypeGetKind(v218))
        {
          uint64_t v65 = (unsigned int *)glpASTNodeGetSaType(v42);
          if (glpTypeGetKind(v65) != 2
            || glpTypeGetKind(v218) != 2
            || (uint64_t v66 = glpASTNodeGetSaType(v42),
                char v67 = (unsigned int *)glpArrayTypeGetElementType(v66),
                uint64_t v68 = glpArrayTypeGetElementType((uint64_t)v218),
                !glpTypesEqual(v67, v68))
            || glpArrayTypeGetElementCount((uint64_t)v218) != -1)
          {
            uint64_t v69 = glpASTNodeGetSaType(v42);
            uint64_t v70 = (void *)glpCompilerGetAllocator(a1);
            glpTypeHumanReadableDescription(v69, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v70);
            char v72 = v71;
            uint64_t v73 = v218;
            uint64_t v74 = (void *)glpCompilerGetAllocator(a1);
            glpTypeHumanReadableDescription((uint64_t)v73, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v74);
            uint64_t v75 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v211);
            glpLogMessage(v75, 0, (uint64_t)&v211, "Initializer has type incompatible with declaration (got '%.*s', expected '%.*s')", v76, v77, v78, v79, v72);
            goto LABEL_43;
          }
          __n128 v218 = (unsigned int *)glpASTNodeGetSaType(v42);
          glpASTNodeSetSaType(a2, (uint64_t)v218);
        }
        else
        {
          unsigned int ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
          uint64_t v96 = glpASTNodeGetSaType(v42);
          Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(v96);
          uint64_t v98 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v218);
          if (!glpCanConvert(PrimitiveType, v98, ImplicitConversionPolicy))
          {
            unint64_t v49 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v212);
            uint64_t v54 = "Incompatible types in initialization (and no available implicit conversion)";
            uint64_t v55 = &v212;
            goto LABEL_40;
          }
          uint64_t v99 = glpConvert(a1, v42, (uint64_t)v218, v217 & 0x1F);
          glpVariableDeclarationNodeSetInitializer(a2, v99);
        }
      }
      uint64_t v44 = glpCompilerGetNameTable(a1);
      unsigned int GLSLVersion = glpNameTableGetGLSLVersion(v44);
      BOOL v46 = GLSLVersion > 1;
      if ((int)glpCompilerGetIOSVersion(a1) >= 9) {
        BOOL v46 = GLSLVersion > 1 && GLSLVersion != 6;
      }
      char v48 = v217;
      if ((v217 & 0xC20000000) == 0)
      {
        if ((v217 & 0x100000000) == 0
          || (glpASTNodeGetSaFlags(v42) & 0x60) != 0
          && ((char v48 = v217, (v217 & 0x100000000) == 0) ? (v80 = 1) : (v80 = v46), v80 == 1))
        {
          if (((v48 & 0x60) == 0
             || (glpASTNodeGetSaFlags(v42) & 0x60) != 0
             && ((v217 & 0x60) == 0 || (glpASTNodeGetSaFlags(v42) & 0x20) != 0 || GLSLVersion != 1))
            && (glpTypeGetKind(v218) != 2 || GLSLVersion > 1))
          {
            goto LABEL_65;
          }
        }
      }
      unint64_t v49 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v210);
      uint64_t v54 = "Initializer not allowed";
      uint64_t v55 = &v210;
LABEL_40:
      glpLogMessage(v49, 0, (uint64_t)v55, v54, v50, v51, v52, v53, v188);
      goto LABEL_43;
    }
  }

  return glpSAFailed();
}

uint64_t glpSAVariableDeclarationGroup(uint64_t a1, uint64_t a2)
{
  Baseuint64_t Type = glpVariableDeclarationGroupNodeGetBaseType(a2);
  uint64_t v5 = glpSANode(a1, BaseType);
  if (v5 == -1)
  {
    int v6 = 0;
  }
  else
  {
    glpVariableDeclarationGroupNodeSetBaseType(a2, v5);
    int v6 = 1;
  }
  if (glpVariableDeclarationGroupNodeGetDeclarationCount(a2))
  {
    unsigned int v7 = 0;
    do
    {
      uint64_t Declaration = glpVariableDeclarationGroupNodeGetDeclaration(a2, v7);
      uint64_t v9 = glpSANode(a1, Declaration);
      if (v9 == -1) {
        int v6 = 0;
      }
      else {
        glpVariableDeclarationGroupNodeSetDeclaration(a2, v7, v9);
      }
      ++v7;
    }
    while (v7 < glpVariableDeclarationGroupNodeGetDeclarationCount(a2));
  }
  if (v6)
  {
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    uint64_t v11 = glpVariableDeclarationGroupNodeGetBaseType(a2);
    if (!glpIsStructTypeNode(v11))
    {
      if (glpVariableDeclarationGroupNodeGetDeclarationCount(a2) == 1)
      {
        return glpVariableDeclarationGroupNodeGetDeclaration(a2, 0);
      }
      glpVariableDeclarationGroupNodeSetBaseType(a2, 0);
    }
    return a2;
  }

  return glpSAFailed();
}

uint64_t glpSAPrecisionDeclaration(uint64_t a1, uint64_t a2)
{
  if (!glpCompilerDoesTrackPrecision(a1)) {
    return 0;
  }
  uint64_t Type = glpPrecisionDeclarationNodeGetType(a2);
  uint64_t v5 = glpSANode(a1, Type);
  if (v5 != -1)
  {
    uint64_t v6 = v5;
    glpPrecisionDeclarationNodeSetType(a2, v5);
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v6);
    if (glpTypeGetKind(SaType))
    {
      glpPrimitiveTypeGetCategory(0);
LABEL_15:
      uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
      char v14 = v13;
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v24);
      glpLogMessage(InfoLog, 0, (uint64_t)&v24, "Default precision qualifier cannot be applied to type '%.*s'", v16, v17, v18, v19, v14);
      return glpSAFailed();
    }
    Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
    int Category = glpPrimitiveTypeGetCategory(PrimitiveType);
    BOOL v11 = Category == 4 || Category == 1;
    if (!v11 || PrimitiveType == 9 || PrimitiveType == 36) {
      goto LABEL_15;
    }
    uint64_t Qualifier = glpPrecisionDeclarationNodeGetQualifier(a2);
    unsigned int v21 = glpKeywordQualifierNodeGetQualifier(Qualifier) - 20;
    if (v21 >= 5) {
      abort();
    }
    uint64_t v22 = qword_2393D3290[v21];
    uint64_t NameTable = glpCompilerGetNameTable(a1);
    glpNameTablePutPrecision(NameTable, PrimitiveType, v22);
    return 0;
  }

  return glpSAFailed();
}

uint64_t glpSAQualifiedDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  if (!glpNameTableGetCurrentFunction(NameTable))
  {
    uint64_t Name = (char *)glpQualifiedDeclarationNodeGetName(a2);
    uint64_t v13 = v12;
    uint64_t v44 = 0;
    uint64_t v45 = &v44;
    uint64_t v46 = 0x2000000000;
    int v47 = 0;
    uint64_t v40 = 0;
    uint64_t v41 = &v40;
    uint64_t v42 = 0x2000000000;
    uint64_t v43 = 0;
    v39[0] = MEMORY[0x263EF8330];
    v39[1] = 0x40000000;
    v39[2] = __glpSAQualifiedDeclaration_block_invoke;
    v39[3] = &unk_264D9C920;
    v39[4] = &v44;
    v39[5] = &v40;
    glpNameTableGet(NameTable, Name, v12, 0, (uint64_t)v39);
    uint64_t v14 = v41[3];
    if (v14)
    {
      int v15 = *((_DWORD *)v45 + 6);
      if (v15)
      {
        if (v15 != 3)
        {
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v37);
          glpLogMessage(InfoLog, 0, (uint64_t)&v37, "Only variables and interface block fields may retroactively qualified", v27, v28, v29, v30, v33);
          goto LABEL_16;
        }
        uint64_t v16 = *(void *)(v14 + 72);
        StructTypeFromIBuint64_t Type = glpGetStructTypeFromIBType(*(unsigned int **)(v14 + 64));
        uint64_t v14 = *(void *)(v16 + 8 * glpStructTypeGetFieldIndex(StructTypeFromIBType, Name, v13));
        unsigned int v18 = 12;
      }
      else
      {
        unsigned int v18 = 11;
      }
      __n128 v24 = *(uint64_t **)(v14 + 8);
      if (v24) {
        unint64_t v25 = (unint64_t)(glpLayoutObjectFind(v24, 30) != 0) << 28;
      }
      else {
        unint64_t v25 = 0;
      }
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      uint64_t v34 = 0;
      uint64_t Qualifiers = glpQualifiedDeclarationNodeGetQualifiers(a2);
      if (glpParseQualifiers(a1, v18, Qualifiers, *(void *)(v14 + 48) | v25, &v36, &v35, &v34))
      {
        uint64_t v10 = 0;
        *(void *)(v14 + 48) = v36;
LABEL_17:
        _Block_object_dispose(&v40, 8);
        _Block_object_dispose(&v44, 8);
        return v10;
      }
    }
    else
    {
      uint64_t v19 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v38);
      glpLogMessage(v19, 0, (uint64_t)&v38, "Cannot retroactivly qualify undeclared identifier '%.*s'", v20, v21, v22, v23, v13);
    }
LABEL_16:
    uint64_t v10 = glpSAFailed();
    goto LABEL_17;
  }
  uint64_t v5 = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v48);
  glpLogMessage(v5, 0, (uint64_t)&v48, "Retroactive qualifier declarations must appear at global scope", v6, v7, v8, v9, v33);
  return glpSAFailed();
}

uint64_t glpSAQualifiedDeclarationGroup(uint64_t a1, uint64_t a2)
{
  if (!glpQualifiedDeclarationGroupNodeGetDeclarationCount(a2)) {
    return 0;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t Declaration = glpQualifiedDeclarationGroupNodeGetDeclaration(a2, v4);
    uint64_t v7 = glpSANode(a1, Declaration);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpQualifiedDeclarationGroupNodeSetDeclaration(a2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpQualifiedDeclarationGroupNodeGetDeclarationCount(a2));
  if (v5) {
    return 0;
  }

  return glpSAFailed();
}

uint64_t glpSAFunctionDefinition(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t Prototype = glpFunctionDefinitionNodeGetPrototype(a2);
  if (glpSANode(a1, Prototype) == -1)
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
    uint64_t v6 = Extra;
    if ((*(unsigned char *)(Extra + 10) & 8) != 0)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, v113);
      int v100 = *(_DWORD *)(v6 + 32);
      uint64_t v39 = "Subroutine function definition '%.*s' must include a list of compatible subroutine types";
      uint64_t v40 = v113;
      goto LABEL_14;
    }
    uint64_t v7 = *(void *)(Extra + 56);
    uint64_t v102 = Extra;
    if (v7)
    {
      int TypeCount = glpSubroutineTypeListNodeGetTypeCount(v7);
      uint64_t v9 = (uint64_t *)glpCompilerPoolAlloc(a1);
      if (glpSubroutineTypeListNodeGetTypeCount(v7))
      {
        unint64_t v10 = 0;
        while (1)
        {
          uint64_t Type = glpSubroutineTypeListNodeGetType(v7, v10);
          Sauint64_t Type = glpASTNodeGetSaType(Type);
          uint64_t v13 = (unsigned int *)glpASTNodeGetSaType(Prototype);
          uint64_t FunctionObject = (uint64_t *)glpSubroutineTypeGetFunctionObject(SaType);
          if (!glpTypesEqual(v13, *FunctionObject)) {
            break;
          }
          v9[v10++] = SaType;
          if (v10 >= glpSubroutineTypeListNodeGetTypeCount(v7)) {
            goto LABEL_8;
          }
        }
        glpSubroutineTypeGetName(SaType);
        char v42 = v41;
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v112);
        LOBYTE(v100) = v42;
        uint64_t v39 = "Subroutine type '%.*s' is incompatible with definition of subroutine '%.*s'";
        uint64_t v40 = &v112;
LABEL_14:
        glpLogMessage(InfoLog, 0, (uint64_t)v40, v39, v35, v36, v37, v38, v100);
        return glpSAFailed();
      }
LABEL_8:
      uint64_t v15 = glpSubroutineTypeListNodeGetType(v7, 0);
      glpASTNodeGetSaType(v15);
      uint64_t v110 = 0;
      uint64_t v111 = 0;
      uint64_t v109 = 0;
      uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
      v107.n128_u64[0] = (unint64_t)"-1";
      v107.n128_u64[1] = 0xEDA00000002;
      uint64_t v108 = 0xFFFFFFFFLL;
      uint64_t SubroutineImplementationFragment = glpMakeSubroutineImplementationFragment(Allocator, &v107, &v111, *(void *)(v6 + 24), *(void *)(v6 + 32), &v110, &v109, v17, *(void *)(v6 + 24), *(void *)(v6 + 32));
      uint64_t v19 = glpCompilerPoolAlloc(a1);
      uint64_t v20 = glpSubroutineTypeGetFunctionObject(*v9);
      long long v22 = *(_OWORD *)(v20 + 48);
      long long v21 = *(_OWORD *)(v20 + 64);
      long long v23 = *(_OWORD *)(v20 + 80);
      *(_OWORD *)(v19 + 96) = *(_OWORD *)(v20 + 96);
      long long v24 = *(_OWORD *)(v20 + 16);
      long long v25 = *(_OWORD *)(v20 + 32);
      *(_OWORD *)uint64_t v19 = *(_OWORD *)v20;
      *(_OWORD *)(v19 + 16) = v24;
      *(_OWORD *)(v19 + 32) = v25;
      *(_OWORD *)(v19 + 48) = v22;
      *(_OWORD *)(v19 + 64) = v21;
      *(_OWORD *)(v19 + 80) = v23;
      long long v26 = *(_OWORD *)(v20 + 112);
      long long v27 = *(_OWORD *)(v20 + 128);
      long long v28 = *(_OWORD *)(v20 + 144);
      *(void *)(v19 + 160) = *(void *)(v20 + 160);
      *(_OWORD *)(v19 + 128) = v27;
      *(_OWORD *)(v19 + 144) = v28;
      *(_OWORD *)(v19 + 112) = v26;
      *(_DWORD *)(v19 + 96) = TypeCount;
      *(void *)(v19 + 104) = v9;
      *(void *)(v19 + 8) = *(void *)(v19 + 8) & 0xFFFFFFFFFFE7FFFFLL | 0x100000;
      *(_OWORD *)(v19 + 24) = *(_OWORD *)(v6 + 24);
      *(_OWORD *)(v19 + 40) = *(_OWORD *)(v6 + 40);
      glpFunctionPrototypeNodeSetExtra(v111, v19);
      glpASTNodeSetSaType(v111, *(void *)v19);
      glpASTNodeSetSaFlags(v111, *(void *)(v19 + 8));
      uint64_t v29 = *(void *)(v19 + 72);
      uint64_t v30 = glpCompilerGetAllocator(a1);
      uint64_t v31 = v30;
      uint64_t v101 = SubroutineImplementationFragment;
      if (v29)
      {
        glpASTNodeGetLocation(v2, &v106);
        uint64_t SubroutineParameterFragment = glpMakeSubroutineParameterFragment(v31, &v106, *(void *)(*(void *)(v19 + 72) + 32), *(void *)(*(void *)(v19 + 72) + 40));
        glpASTNodeSetSaType(SubroutineParameterFragment, **(void **)(v19 + 72));
        glpASTNodeSetSaFlags(SubroutineParameterFragment, *(void *)(*(void *)(v19 + 72) + 48));
        glpParameterDeclarationNodeSetExtra(SubroutineParameterFragment, *(void *)(v19 + 72));
        glpFunctionPrototypeNodeSetReturnOutParam(v111, SubroutineParameterFragment);
      }
      else
      {
        v107.n128_u64[0] = (unint64_t)"-1";
        v107.n128_u64[1] = 0xEDA00000002;
        uint64_t v108 = 0xFFFFFFFFLL;
        uint64_t ExpressionStatementNode = glpMakeExpressionStatementNode(v30, &v107);
        glpExpressionStatementNodeSetExpr(ExpressionStatementNode, v109);
        glpBlockNodeSetStatement(v110, 0, ExpressionStatementNode);
      }
      if (*(_DWORD *)(v19 + 88))
      {
        unint64_t v44 = 0;
        do
        {
          uint64_t v45 = (void *)glpCompilerGetAllocator(a1);
          StringBuffer = glpMakeStringBuffer(v45);
          glpStringBufferAppendFormat(StringBuffer, "$subroutine$implementation_parameter$%u", v47, v48, v49, v50, v51, v52, v44);
          uint64_t String = glpStringBufferGetString((uint64_t)StringBuffer);
          uint64_t v55 = v54;
          uint64_t v56 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(v2, &v105);
          uint64_t v57 = glpMakeSubroutineParameterFragment(v56, &v105, String, v55);
          glpASTNodeSetSaType(v57, **(void **)(*(void *)(v19 + 80) + 8 * v44));
          glpASTNodeSetSaFlags(v57, *(void *)(*(void *)(*(void *)(v19 + 80) + 8 * v44) + 48));
          glpParameterDeclarationNodeSetExtra(v57, *(void *)(*(void *)(v19 + 80) + 8 * v44));
          char v58 = (void *)glpCompilerGetAllocator(a1);
          glpFunctionPrototypeNodeAddParameter(v58, v111, v57);
          uint64_t v59 = glpCompilerGetAllocator(a1);
          v107.n128_u64[0] = (unint64_t)"-1";
          v107.n128_u64[1] = 0xEDA00000002;
          uint64_t v108 = 0xFFFFFFFFLL;
          glpMakeVariableIdentifierNode(v59, &v107, String, v55);
          uint64_t v61 = v60;
          uint64_t v62 = (void *)glpCompilerGetAllocator(a1);
          glpCallNodeAddArg(v62, v109, v61);
          ++v44;
        }
        while (v44 < *(unsigned int *)(v19 + 88));
      }
      uint64_t v63 = (void *)glpCompilerGetAllocator(a1);
      uint64_t v64 = glpMakeStringBuffer(v63);
      glpStringBufferAppendCString(v64, "$SubroutineStatic$");
      uint64_t v6 = v102;
      glpStringBufferAppendString(v64, *(void *)(v102 + 24), *(void *)(v102 + 32));
      uint64_t v65 = glpStringBufferGetString((uint64_t)v64);
      uint64_t v67 = v66;
      *(void *)(v102 + 24) = v65;
      *(void *)(v102 + 32) = v66;
      uint64_t v68 = *(void *)v102;
      uint64_t v69 = (void *)glpCompilerGetAllocator(a1);
      *(void *)(v102 + 40) = glpAggregateTypeMangleName(v68, v65, v67, v69);
      *(void *)(v102 + 48) = v70;
      uint64_t SaFlags = glpASTNodeGetSaFlags(Prototype);
      glpASTNodeSetSaFlags(Prototype, SaFlags & 0xFFFFFFFFFFCFFFFFLL | 0x200000);
      *(void *)(v102 + 8) = *(void *)(v102 + 8) & 0xFFFFFFFFFFCFFFFFLL | 0x200000;
    }
    else
    {
      uint64_t v101 = 0;
    }
    uint64_t NameTable = (void *)glpCompilerGetNameTable(a1);
    uint64_t Body = glpFunctionDefinitionNodeGetBody(v2);
    uint64_t v74 = glpFunctionDefinitionNodeGetPrototype(v2);
    uint64_t v75 = glpFunctionPrototypeNodeGetExtra(v74);
    glpNameTablePushForFunction(NameTable, Body, v75);
    uint64_t v76 = glpCompilerGetNameTable(a1);
    *(void *)(v6 + 64) = v2;
    if (glpFunctionPrototypeNodeGetParameterCount(Prototype))
    {
      for (unsigned int i = 0; i < glpFunctionPrototypeNodeGetParameterCount(Prototype); ++i)
      {
        uint64_t Parameter = glpFunctionPrototypeNodeGetParameter(Prototype, i);
        uint64_t Name = (char *)glpParameterDeclarationNodeGetName(Parameter);
        uint64_t v81 = v80;
        if (!glpStringsEqual("<<unnamed>>", 0x725D7890000000BLL, Name, v80))
        {
          if (glpNameTableGet(v76, Name, v81, 2, (uint64_t)&__block_literal_global_4))
          {
            uint64_t v89 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(Parameter, &v104);
            glpLogMessage(v89, 0, (uint64_t)&v104, "'%.*s': Duplicate parameter name", v90, v91, v92, v93, v81);
            return glpSAFailed();
          }
          uint64_t v82 = glpParameterDeclarationNodeGetExtra(Parameter);
          glpNameTablePut(v76, Name, v81, 0, v82);
        }
      }
    }
    uint64_t v83 = glpFunctionDefinitionNodeGetBody(v2);
    if (glpSANode(a1, v83) == -1)
    {
      uint64_t v88 = (void *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v88);
      *(void *)(v102 + 64) = 0;
      return glpSAFailed();
    }
    glpFunctionDefinitionNodeGetBody(v2);
    if (*(void *)(v102 + 72) && !*(unsigned char *)(v102 + 112))
    {
      uint64_t v94 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v103);
      glpLogMessage(v94, 0, (uint64_t)&v103, "Missing return for function '%.*s'", v95, v96, v97, v98, *(_DWORD *)(v102 + 32));
      uint64_t v99 = (void *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v99);
      *(void *)(v102 + 64) = 0;
      return glpSAFailed();
    }
    else
    {
      uint64_t v84 = glpFunctionDefinitionNodeGetPrototype(v2);
      uint64_t v85 = glpASTNodeGetSaType(v84);
      glpASTNodeSetSaType(v2, v85);
      char v86 = (void *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v86);
      if (v101)
      {
        uint64_t v87 = glpSANode(a1, v101);
        glpCompilerInsertDef(a1, v87);
      }
    }
    return v2;
  }
}

uint64_t glpSAQualifiedType(uint64_t a1, uint64_t a2)
{
  uint64_t Type = glpQualifiedTypeNodeGetType(a2);
  uint64_t v5 = glpSANode(a1, Type);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpQualifiedTypeNodeSetType(a2, v5);
    uint64_t v6 = glpQualifiedTypeNodeGetType(a2);
    Sauint64_t Type = glpASTNodeGetSaType(v6);
    glpASTNodeSetSaType(a2, SaType);
    glpASTNodeSetSaFlags(a2, 0);
    return a2;
  }
}

uint64_t glpSAPrimitiveType(uint64_t a1)
{
  unsigned int Type = glpPrimitiveTypeNodeGetType(a1);
  Primitiveunsigned int Type = glpGetPrimitiveType(Type);
  glpASTNodeSetSaType(a1, (uint64_t)PrimitiveType);
  return a1;
}

uint64_t glpSAArrayType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  Elementuint64_t Type = glpArrayTypeNodeGetElementType(a2);
  uint64_t v5 = glpSANode(a1, ElementType);
  if (v5 != -1) {
    glpArrayTypeNodeSetElementType(v2, v5);
  }
  uint64_t Dimension = glpArrayTypeNodeGetDimension(v2);
  uint64_t v7 = glpSANode(a1, Dimension);
  if (v7 == -1 || (glpArrayTypeNodeSetDimension(v2, v7), v5 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    int v25 = 0;
    glpASTNodeGetLocation(v2, &v24);
    uint64_t v8 = glpArrayTypeNodeGetDimension(v2);
    int v9 = glpEvaluateArraySize(a1, (long long *)&v24, v8, &v25);
    if (!v9) {
      return glpSAFailed();
    }
    int v10 = v9;
    uint64_t v11 = glpArrayTypeNodeGetElementType(v2);
    uint64_t SaFlags = glpASTNodeGetSaFlags(v11);
    uint64_t Allocator = glpCompilerGetAllocator(a1);
    Sauint64_t Type = glpASTNodeGetSaType(v11);
    Arrayuint64_t Type = glpMakeArrayType(Allocator, SaType, v25, -1);
    glpASTNodeSetSaType(v2, ArrayType);
    if (glpIsQualifiedTypeNode(v11))
    {
      uint64_t v16 = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v2, &v23);
      glpMakeQualifiedTypeNode(v16, &v23);
      uint64_t v18 = v17;
      glpQualifiedTypeNodeSetType(v17, v2);
      uint64_t Type = glpQualifiedTypeNodeGetType(v11);
      glpArrayTypeNodeSetElementType(v2, Type);
      uint64_t Qualifiers = glpQualifiedTypeNodeGetQualifiers(v11);
      glpQualifiedTypeNodeSetQualifiers(v18, Qualifiers);
      glpASTNodeSetSaType(v18, ArrayType);
      uint64_t v2 = v18;
    }
    if (v10 == 3) {
      uint64_t v21 = SaFlags | 0x8000000;
    }
    else {
      uint64_t v21 = SaFlags;
    }
    glpASTNodeSetSaFlags(v2, v21);
    return v2;
  }
}

uint64_t glpSAFieldDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t Type = glpFieldDeclarationNodeGetType(a2);
  uint64_t v5 = glpSANode(a1, Type);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpFieldDeclarationNodeSetType(a2, v5);
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    return a2;
  }
}

uint64_t glpSAStructType(uint64_t a1, uint64_t a2)
{
  v83[1] = *(uint64_t **)MEMORY[0x263EF8340];
  if (glpSAStructure(a1, a2) != -1)
  {
    uint64_t Name = (const char *)glpStructTypeNodeGetName(a2);
    uint64_t v6 = v5;
    uint64_t v7 = glpCheckName(a1, a2, Name, v5);
    if (v7 != -1)
    {
      uint64_t v8 = v7;
      uint64_t v62 = (char *)Name;
      uint64_t v63 = v6;
      uint64_t FieldCount = glpStructureNodeGetFieldCount(v7);
      uint64_t v64 = &v60;
      MEMORY[0x270FA5388](FieldCount);
      uint64_t v11 = &v60 - 2 * v10;
      uint64_t v12 = glpStructureNodeGetFieldCount(v8);
      MEMORY[0x270FA5388](v12);
      if (v13 >= 0x200) {
        size_t v15 = 512;
      }
      else {
        size_t v15 = v13;
      }
      uint64_t v67 = (uint64_t)&v60 - v14;
      bzero((char *)&v60 - v14, v15);
      uint64_t v16 = glpStructureNodeGetFieldCount(v8);
      MEMORY[0x270FA5388](v16);
      uint64_t v66 = (uint64_t)&v60 - v17;
      uint64_t v18 = glpStructureNodeGetFieldCount(v8);
      MEMORY[0x270FA5388](v18);
      if (v19 >= 0x200) {
        size_t v21 = 512;
      }
      else {
        size_t v21 = v19;
      }
      uint64_t v65 = (uint64_t)&v60 - v20;
      bzero((char *)&v60 - v20, v21);
      if (glpStructureNodeGetFieldCount(v8))
      {
        unint64_t v22 = 0;
        uint64_t v61 = v11 + 1;
        do
        {
          uint64_t Field = glpStructureNodeGetField(v8, v22);
          uint64_t v75 = 0;
          uint64_t v71 = 0;
          uint64_t v82 = 0;
          v83[0] = 0;
          glpASTNodeGetLocation(Field, &v81);
          uint64_t Type = glpFieldDeclarationNodeGetType(Field);
          if (!glpEvaluateTypeNode(a1, (long long *)&v81, 8u, 1, Type, 0, &v75, (uint64_t)&v71, v83, &v82))return glpSAFailed(); {
          int v25 = (char *)glpFieldDeclarationNodeGetName(Field);
          }
          uint64_t v27 = v26;
          if (v22)
          {
            unint64_t v28 = v22;
            uint64_t v29 = v61;
            while (!glpStringsEqual((const char *)*(v29 - 1), *v29, v25, v27))
            {
              v29 += 2;
              if (!--v28) {
                goto LABEL_16;
              }
            }
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(Field, &v80);
            glpLogMessage(InfoLog, 0, (uint64_t)&v80, "Duplicate field name '%.*s' in struct type '%.*s'", v40, v41, v42, v43, v27);
            return glpSAFailed();
          }
LABEL_16:
          if (glpTypeGetKind(v75) == 2 && glpArrayTypeGetElementCount((uint64_t)v75) == -1)
          {
            uint64_t v55 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v8, &v79);
            glpLogMessage(v55, 0, (uint64_t)&v79, "Unsized array field '%.*s' in struct type '%.*s'", v56, v57, v58, v59, v27);
            return glpSAFailed();
          }
          uint64_t v30 = (char **)&v11[2 * v22];
          *uint64_t v30 = v25;
          v30[1] = (char *)v27;
          *(void *)(v67 + 8 * v22) = v75;
          *(void *)(v66 + 8 * v22) = v71 | 0x2000000;
          *(void *)(v65 + 8 * v22++) = 0;
        }
        while (v22 < glpStructureNodeGetFieldCount(v8));
      }
      uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
      unsigned int v32 = glpStructureNodeGetFieldCount(v8);
      uint64_t v34 = v62;
      uint64_t v33 = v63;
      Structuint64_t Type = (unsigned int *)glpMakeStructType(Allocator, (uint64_t)v62, v63, v32, (uint64_t)v11, v67, v66, v65);
      glpASTNodeSetSaType(v8, (uint64_t)StructType);
      if (glpStringsEqual("<<unnamed>>", 0x725D7890000000BLL, v34, v33)) {
        goto LABEL_35;
      }
      uint64_t NameTable = glpCompilerGetNameTable(a1);
      uint64_t v75 = 0;
      uint64_t v76 = &v75;
      uint64_t v77 = 0x2000000000;
      int v78 = 0;
      uint64_t v71 = 0;
      char v72 = &v71;
      uint64_t v73 = 0x2000000000;
      uint64_t v74 = 0;
      v70[0] = MEMORY[0x263EF8330];
      v70[1] = 0x40000000;
      v70[2] = __glpSAStructType_block_invoke;
      v70[3] = &unk_264D9C968;
      v70[5] = &v71;
      v70[6] = NameTable;
      v70[4] = &v75;
      glpNameTableGet(NameTable, v34, v33, 2, (uint64_t)v70);
      uint64_t v37 = v72[3];
      if (v37)
      {
        if (*((_DWORD *)v76 + 6) == 6)
        {
          if (glpTypesEqual(StructType, v37))
          {
            glpASTNodeSetSaType(v8, v72[3]);
LABEL_30:
            int v44 = 1;
            goto LABEL_34;
          }
          uint64_t v50 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v8, &v69);
          glpLogMessage(v50, 0, (uint64_t)&v69, "Redeclaration of struct '%.*s' does not match previous declaration", v51, v52, v53, v54, v33);
        }
        else
        {
          uint64_t v45 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v8, &v68);
          glpLogMessage(v45, 0, (uint64_t)&v68, "Attempt to redeclare '%.*s' as a struct", v46, v47, v48, v49, v33);
        }
        Structuint64_t Type = (unsigned int *)glpSAFailed();
        int v44 = 0;
LABEL_34:
        _Block_object_dispose(&v71, 8);
        _Block_object_dispose(&v75, 8);
        if (!v44) {
          return (uint64_t)StructType;
        }
LABEL_35:
        glpStructureNodeClearFields(v8);
        return v8;
      }
      glpNameTablePut(NameTable, v34, v33, 6, (uint64_t)StructType);
      goto LABEL_30;
    }
  }

  return glpSAFailed();
}

uint64_t glpSAInterfaceBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v205 = *MEMORY[0x263EF8340];
  if (glpSAStructure(a1, a2) != -1)
  {
    uint64_t Dimension = glpInterfaceBlockNodeGetDimension(v2);
    uint64_t v5 = glpSANode(a1, Dimension);
    if (v5 != -1)
    {
      glpInterfaceBlockNodeSetDimension(v2, v5);
      uint64_t ImmediateSAContext = glpCompilerGetImmediateSAContext(a1);
      if (glpIsTopLevelNode(ImmediateSAContext))
      {
        Primitiveuint64_t Type = glpGetPrimitiveType(0);
        glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
        uint64_t NameTable = glpCompilerGetNameTable(a1);
        unsigned int Language = glpNameTableGetLanguage(NameTable);
        int v202 = 0;
        uint64_t v203 = 0;
        uint64_t v201 = 0;
        uint64_t Qualifiers = glpInterfaceBlockNodeGetQualifiers(v2);
        if (glpParseQualifiers(a1, 7u, Qualifiers, 0, &v203, &v202, &v201))
        {
          uint64_t TopLevelNode = glpCompilerGetTopLevelNode(a1);
          GlobalTypeuint64_t Qualifier = glpTopLevelNodeGetGlobalTypeQualifier(TopLevelNode, 0x100000000);
          uint64_t Allocator = glpCompilerGetAllocator(a1);
          uint64_t v14 = (void *)Allocator;
          if (GlobalTypeQualifier)
          {
            Layout = (void **)glpGlobalTypeQualifierNodeGetLayout(GlobalTypeQualifier);
            LayoutObject = glpCopyLayoutObject(v14, Layout);
          }
          else
          {
            LayoutObject = glpMakeLayoutObject(Allocator);
          }
          __n128 v23 = (void **)LayoutObject;
          if (!v202
            || (uint64_t v24 = glpCompilerGetAllocator(a1),
                glpASTNodeGetLocation(v2, &v200),
                glpLayoutObjectAppendMany(v24, a1, (uint64_t)&v200, v23, (void **)v202)))
          {
            if ((v203 & 0x100000000) != 0)
            {
              char v25 = 117;
              uint64_t v26 = "uniform";
            }
            else if ((v203 & 0x20000000) != 0)
            {
              char v25 = 105;
              uint64_t v26 = "in";
            }
            else
            {
              if ((v203 & 0x40000000) == 0) {
                goto LABEL_107;
              }
              char v25 = 111;
              uint64_t v26 = "out";
            }
            uint64_t v167 = (uint64_t)v26;
            uint64_t BlockName = (char *)glpInterfaceBlockNodeGetBlockName(v2);
            uint64_t v29 = v28;
            uint64_t v30 = (void *)glpCompilerGetAllocator(a1);
            StringBuffer = glpMakeStringBuffer(v30);
            glpStringBufferAppendFormat(StringBuffer, "$IB$%c$5%.*s", v32, v33, v34, v35, v36, v37, v25);
            uint64_t v196 = 0;
            __n128 v197 = &v196;
            uint64_t v198 = 0x2000000000;
            LODWORD(v199) = 0;
            uint64_t v192 = 0;
            __n128 v193 = &v192;
            uint64_t v194 = 0x2000000000;
            uint64_t v195 = 0;
            v191[0] = MEMORY[0x263EF8330];
            v191[1] = 0x40000000;
            v191[2] = __glpSAInterfaceBlock_block_invoke;
            v191[3] = &unk_264D9C990;
            v191[4] = &v196;
            v191[5] = &v192;
            BOOL v38 = glpNameTableGet(NameTable, BlockName, v29, 2, (uint64_t)v191);
            if (!v193[3] || *((_DWORD *)v197 + 6) == 2)
            {
              BOOL v166 = v38;
              _Block_object_dispose(&v192, 8);
              _Block_object_dispose(&v196, 8);
              uint64_t v196 = 0;
              __n128 v197 = &v196;
              uint64_t v198 = 0x2000000000;
              uint64_t v199 = 0;
              uint64_t String = (char *)glpStringBufferGetString((uint64_t)StringBuffer);
              v189[0] = MEMORY[0x263EF8330];
              v189[1] = 0x40000000;
              v189[2] = __glpSAInterfaceBlock_block_invoke_2;
              v189[3] = &unk_264D9C9B8;
              v189[4] = &v196;
              glpNameTableGet(NameTable, String, v40, 0, (uint64_t)v189);
              uint64_t v41 = v197[3];
              if (v41)
              {
                uint64_t v42 = *(uint64_t **)(v41 + 56);
                if (!v42 || !glpLayoutObjectFind(v42, 82) && !glpLayoutObjectFind(*(uint64_t **)(v197[3] + 56), 81))
                {
                  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                  glpASTNodeGetLocation(v2, &v188);
                  glpLogMessage(InfoLog, 0, (uint64_t)&v188, "Cannot redeclare interface block '%s %.*s'", v44, v45, v46, v47, v167);
                  uint64_t v2 = -1;
LABEL_112:
                  _Block_object_dispose(&v196, 8);
                  return v2;
                }
              }
              else
              {
                uint64_t v2 = glpCheckName(a1, v2, BlockName, v29);
                if (v2 == -1) {
                  goto LABEL_111;
                }
              }
              uint64_t v160 = StringBuffer;
              uint64_t v164 = v29;
              uint64_t v165 = BlockName;
              unsigned int v161 = Language;
              char v172 = v23;
              uint64_t FieldCount = glpStructureNodeGetFieldCount(v2);
              unsigned int v54 = FieldCount;
              uint64_t v55 = MEMORY[0x270FA5388](FieldCount);
              uint64_t v173 = v56;
              uint64_t v57 = (uint64_t *)&(&v160)[-2 * v56];
              unint64_t v58 = 8 * v54;
              MEMORY[0x270FA5388](v55);
              uint64_t v59 = (v58 + 15) & 0xFFFFFFFF0;
              if (v58 >= 0x200) {
                size_t v60 = 512;
              }
              else {
                size_t v60 = 8 * v54;
              }
              uint64_t v171 = (uint64_t)&v160 - v59;
              bzero((char *)&v160 - v59, v60);
              uint64_t v62 = MEMORY[0x270FA5388](v61);
              uint64_t v170 = (uint64_t)&v160 - v59;
              MEMORY[0x270FA5388](v62);
              uint64_t v169 = (uint64_t)&v160 - v59;
              bzero((char *)&v160 - v59, v60);
              if (v54)
              {
                uint64_t v168 = NameTable;
                uint64_t v162 = (uint64_t *)&v160;
                uint64_t v163 = v57;
                uint64_t v63 = 0;
                uint64_t v64 = v57 + 1;
                do
                {
                  uint64_t Field = glpStructureNodeGetField(v2, v63);
                  uint64_t Name = (const char *)glpFieldDeclarationNodeGetName(Field);
                  uint64_t v68 = v66;
                  uint64_t v69 = v197[3];
                  if (v69)
                  {
                    StructTypeFromIBuint64_t Type = glpGetStructTypeFromIBType(*(unsigned int **)(v69 + 64));
                    unsigned int FieldIndex = glpStructTypeGetFieldIndex(StructTypeFromIBType, Name, v68);
                    if (FieldIndex == -1)
                    {
                      uint64_t v113 = (uint64_t **)glpCompilerGetInfoLog(a1);
                      glpASTNodeGetLocation(v2, &v187);
                      glpLogMessage(v113, 0, (uint64_t)&v187, "Field name '%.*s' in redeclaration of '%s %.*s' was not in previous declaration", v114, v115, v116, v117, v68);
                      goto LABEL_111;
                    }
                    ElementLayout = (void **)glpAggregateTypeGetElementLayout(StructTypeFromIBType, FieldIndex);
                  }
                  else
                  {
                    uint64_t v73 = glpCheckName(a1, Field, Name, v66);
                    if (v73 == -1) {
                      goto LABEL_111;
                    }
                    uint64_t Field = v73;
                    ElementLayout = 0;
                  }
                  uint64_t v192 = 0;
                  uint64_t v185 = 0;
                  uint64_t v186 = 0;
                  uint64_t v184 = 0;
                  glpASTNodeGetLocation(v2, &v183);
                  uint64_t Type = glpFieldDeclarationNodeGetType(Field);
                  if (!glpEvaluateTypeNode(a1, (long long *)&v183, 9u, 1, Type, v203, &v192, (uint64_t)&v186, &v185, &v184))goto LABEL_111; {
                  uint64_t v75 = (void *)glpCompilerGetAllocator(a1);
                  }
                  uint64_t v76 = glpCopyLayoutObject(v75, v172);
                  if (v197[3])
                  {
                    uint64_t v77 = glpCompilerGetAllocator(a1);
                    glpASTNodeGetLocation(v2, &v182);
                    if (!glpLayoutObjectAppendMany(v77, a1, (uint64_t)&v182, v76, ElementLayout)) {
                      goto LABEL_111;
                    }
                    uint64_t v78 = glpCompilerGetAllocator(a1);
                    glpLayoutObjectRemove(v78, v76, 82);
                  }
                  uint64_t v79 = glpCompilerGetAllocator(a1);
                  glpASTNodeGetLocation(v2, &v181);
                  if (!glpLayoutObjectAppendMany(v79, a1, (uint64_t)&v181, v76, (void **)v185)) {
                    goto LABEL_111;
                  }
                  if (v76)
                  {
                    __n128 v80 = glpLayoutObjectFind(v76, 24);
                    uint64_t v81 = v186;
                    if (v80)
                    {
                      uint64_t v81 = v186 | 0x400;
                      v186 |= 0x400uLL;
                    }
                  }
                  else
                  {
                    uint64_t v81 = v186;
                  }
                  *(v64 - 1) = (uint64_t)Name;
                  *uint64_t v64 = v68;
                  *(void *)(v171 + 8 * v63) = v192;
                  *(void *)(v170 + 8 * v63) = v203 | v81;
                  uint64_t v82 = v168;
                  *(void *)(v169 + 8 * v63) = v76;
                  if (glpNameTableGetGLSLVersion(v82) == 6
                    && glpTypeGetKind(v192) == 2
                    && glpArrayTypeGetElementCount((uint64_t)v192) == -1)
                  {
                    uint64_t v133 = (uint64_t **)glpCompilerGetInfoLog(a1);
                    glpASTNodeGetLocation(v2, &v180);
                    glpLogMessage(v133, 0, (uint64_t)&v180, "Unsized array '%.*s' not allowed under GLSL 300", v134, v135, v136, v137, *(_DWORD *)v64);
                    goto LABEL_111;
                  }
                  ++v63;
                  v64 += 2;
                }
                while (v173 != v63);
                Hasuint64_t InstanceName = glpInterfaceBlockNodeGetHasInstanceName(v2);
                uint64_t v57 = v163;
                uint64_t NameTable = v168;
                if (!HasInstanceName)
                {
                  uint64_t v84 = v173;
                  if (v173)
                  {
                    uint64_t v85 = v163 + 1;
                    uint64_t v86 = v173;
                    while (!glpNameTableGet(NameTable, (char *)*(v85 - 1), *v85, 2, (uint64_t)&__block_literal_global_140))
                    {
                      v85 += 2;
                      if (!--v86)
                      {
                        uint64_t v167 = 0xDFA3F2CD0000004BLL;
                        char v87 = 1;
                        uint64_t InstanceName = "<<BUG: printing instance name of interface block without an instance name>>";
                        goto LABEL_67;
                      }
                    }
                    uint64_t v155 = (uint64_t **)glpCompilerGetInfoLog(a1);
                    glpASTNodeGetLocation(v2, &v178);
                    glpLogMessage(v155, 0, (uint64_t)&v178, "Field name '%.*s' of interface block without instance name '%.*s' would shadow a previous declaration", v156, v157, v158, v159, *(_DWORD *)v85);
                    goto LABEL_111;
                  }
                  uint64_t v167 = 0xDFA3F2CD0000004BLL;
                  uint64_t InstanceName = "<<BUG: printing instance name of interface block without an instance name>>";
                  char v87 = 1;
                  goto LABEL_67;
                }
              }
              else if (!glpInterfaceBlockNodeGetHasInstanceName(v2))
              {
                uint64_t v163 = v57;
                uint64_t v167 = 0xDFA3F2CD0000004BLL;
                uint64_t InstanceName = "<<BUG: printing instance name of interface block without an instance name>>";
                char v87 = 1;
                uint64_t v84 = v173;
                goto LABEL_67;
              }
              uint64_t InstanceName = (char *)glpInterfaceBlockNodeGetInstanceName(v2);
              uint64_t v90 = v89;
              uint64_t v84 = v173;
              if (!v197[3])
              {
                uint64_t v2 = glpCheckName(a1, v2, InstanceName, v89);
                if (v2 == -1)
                {
LABEL_111:
                  uint64_t v2 = glpSAFailed();
                  goto LABEL_112;
                }
              }
              if (glpNameTableGet(NameTable, InstanceName, v90, 2, (uint64_t)&__block_literal_global_136))
              {
                uint64_t v91 = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(v2, &v179);
                glpLogMessage(v91, 0, (uint64_t)&v179, "Interface block instance name '%.*s' would shadow a previous declaration", v92, v93, v94, v95, v90);
                uint64_t v2 = -1;
                goto LABEL_112;
              }
              uint64_t v167 = v90;
              uint64_t v163 = v57;
              char v87 = 0;
LABEL_67:
              uint64_t v96 = (void *)glpCompilerGetAllocator(a1);
              uint64_t v97 = glpMakeStringBuffer(v96);
              glpStringBufferAppendFormat(v97, "$InterfaceBlockStruct$%.*s", v98, v99, v100, v101, v102, v103, v164);
              __n128 v104 = (void *)glpCompilerGetAllocator(a1);
              uint64_t v105 = glpStringBufferGetString((uint64_t)v97);
              Structuint64_t Type = (unsigned int *)glpMakeStructType(v104, v105, v106, v84, (uint64_t)v163, v171, v170, v169);
              uint64_t v108 = v203;
              Isuint64_t Array = glpInterfaceBlockNodeGetIsArray(v2);
              LODWORD(v192) = 1;
              if (!IsArray)
              {
LABEL_91:
                uint64_t v144 = (void *)glpCompilerGetAllocator(a1);
                if (v87)
                {
                  uint64_t UnnamedInterfaceBlockObject = glpMakeUnnamedInterfaceBlockObject(v144, (uint64_t)v165, v164, v203, 1, StructType);
                  if (v84)
                  {
                    uint64_t v146 = v163 + 1;
                    do
                    {
                      glpNameTablePut(NameTable, (const char *)*(v146 - 1), *v146, 3, UnnamedInterfaceBlockObject);
                      v146 += 2;
                      --v84;
                    }
                    while (v84);
                  }
                }
                else
                {
                  uint64_t UnnamedInterfaceBlockObject = glpMakeNamedInterfaceBlockObject(v144, (uint64_t)v165, v164, (uint64_t)InstanceName, v167, v203, 1, StructType);
                }
                *(void *)(UnnamedInterfaceBlockObject + 56) = v172;
                if (!v166) {
                  glpNameTablePut(NameTable, v165, v164, 2, UnnamedInterfaceBlockObject);
                }
                uint64_t v147 = (const char *)glpStringBufferGetString((uint64_t)v160);
                glpNameTablePut(NameTable, v147, v148, 2, UnnamedInterfaceBlockObject);
                if ((v87 & 1) == 0) {
                  glpNameTablePut(NameTable, InstanceName, v167, 1, UnnamedInterfaceBlockObject);
                }
                glpInterfaceBlockNodeSetExtra(v2, UnnamedInterfaceBlockObject);
                glpInterfaceBlockNodeSetQualifiers(v2, 0);
                glpInterfaceBlockNodeSetDimension(v2, 0);
                glpStructureNodeClearFields(v2);
                if (!v197[3]) {
                  goto LABEL_112;
                }
                uint64_t v149 = glpCompilerGetTopLevelNode(a1);
                int DefCount = glpTopLevelNodeGetDefCount(v149);
                if (DefCount)
                {
                  int v151 = DefCount;
                  unsigned int v152 = 0;
                  while (1)
                  {
                    uint64_t Def = glpTopLevelNodeGetDef(v149, v152);
                    if (glpIsInterfaceBlockNode(Def))
                    {
                      uint64_t Extra = glpInterfaceBlockNodeGetExtra(Def);
                      if (Extra == v197[3]) {
                        break;
                      }
                    }
                    if (v151 == ++v152) {
                      goto LABEL_107;
                    }
                  }
                  glpTopLevelNodeSetDef(v149, v152, v2);
                  uint64_t v2 = 0;
                  goto LABEL_112;
                }
LABEL_107:
                abort();
              }
              uint64_t v110 = v108 & 0x160000000;
              uint64_t v111 = InstanceName;
              switch(v110)
              {
                case 0x100000000:
                  int v118 = 5;
LABEL_76:
                  glpASTNodeGetLocation(v2, &v176);
                  uint64_t v119 = glpInterfaceBlockNodeGetDimension(v2);
                  if (!glpEvaluateArraySize(a1, (long long *)&v176, v119, (int *)&v192)) {
                    goto LABEL_111;
                  }
                  ImpliedBankunsigned int Size = glpCompilerGetImpliedBankSize(a1, v118);
                  if (v192 == -1)
                  {
                    LODWORD(v192) = ImpliedBankSize;
                    if (v118 == 5 && ImpliedBankSize == -1)
                    {
                      int v138 = (uint64_t **)glpCompilerGetInfoLog(a1);
                      glpASTNodeGetLocation(v2, &v174);
                      glpLogMessage(v138, 0, (uint64_t)&v174, "Uniform interface block arrays must be sized", v139, v140, v141, v142, (char)v160);
                      goto LABEL_111;
                    }
                  }
                  else if (ImpliedBankSize != -1 && v192 != ImpliedBankSize)
                  {
                    uint64_t v121 = (uint64_t **)glpCompilerGetInfoLog(a1);
                    glpASTNodeGetLocation(v2, &v175);
                    char v122 = (char)v192;
                    glpLanguageToString(v161);
                    glpLogMessage(v121, 0, (uint64_t)&v175, "Declared size (%u) of %s interface block array in the %s shader is incompatible with earlier declarations (expected %u)", v123, v124, v125, v126, v122);
                    goto LABEL_111;
                  }
                  uint64_t v143 = glpCompilerGetAllocator(a1);
                  Structuint64_t Type = (unsigned int *)glpMakeBankType(v143, v118, (uint64_t)StructType, (int)v192);
                  uint64_t v84 = v173;
                  uint64_t InstanceName = v111;
                  goto LABEL_91;
                case 0x40000000:
                  int v112 = glpBankForOutputsInLanguage(v161);
                  break;
                case 0x20000000:
                  int v112 = glpBankForInputsInLanguage(v161);
                  break;
                default:
LABEL_81:
                  uint64_t v127 = (uint64_t **)glpCompilerGetInfoLog(a1);
                  glpASTNodeGetLocation(v2, &v177);
                  if ((v203 & 0x20000000) != 0) {
                    uint64_t v128 = "in";
                  }
                  else {
                    uint64_t v128 = "out";
                  }
                  glpLanguageToString(v161);
                  glpLogMessage(v127, 0, (uint64_t)&v177, "Interface block array not allowed as %s in %s shader", v129, v130, v131, v132, (char)v128);
                  goto LABEL_111;
              }
              int v118 = v112;
              if (v112) {
                goto LABEL_76;
              }
              goto LABEL_81;
            }
            uint64_t v48 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v190);
            glpLogMessage(v48, 0, (uint64_t)&v190, "Interface block name '%.*s' would shadow a previous declaration", v49, v50, v51, v52, v29);
            _Block_object_dispose(&v192, 8);
            _Block_object_dispose(&v196, 8);
            return -1;
          }
        }
      }
      else
      {
        uint64_t v18 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v204);
        glpLogMessage(v18, 0, (uint64_t)&v204, "Interface blocks may only be declared at global scope", v19, v20, v21, v22, (char)v160);
      }
      return glpSAFailed();
    }
  }

  return glpSAFailed();
}

uint64_t glpSALayoutType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v94 = *MEMORY[0x263EF8340];
  if (!glpLayoutTypeNodeGetLayoutPairCount(a2)) {
    goto LABEL_8;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t LayoutPair = glpLayoutTypeNodeGetLayoutPair(v2, v4);
    uint64_t v7 = glpSANode(a1, LayoutPair);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpLayoutTypeNodeSetLayoutPair(v2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpLayoutTypeNodeGetLayoutPairCount(v2));
  if (v5)
  {
LABEL_8:
    uint64_t LayoutPairCount = glpLayoutTypeNodeGetLayoutPairCount(v2);
    uint64_t v86 = &v73;
    Sauint64_t Type = 16 * LayoutPairCount;
    uint64_t v9 = MEMORY[0x270FA5388](LayoutPairCount);
    uint64_t v11 = &v73 - 2 * v10;
    unint64_t v12 = 8 * LayoutPairCount;
    MEMORY[0x270FA5388](v9);
    uint64_t v13 = (v12 + 15) & 0xFFFFFFFF0;
    uint64_t v14 = (char *)&v73 - v13;
    if (v12 >= 0x200) {
      size_t v15 = 512;
    }
    else {
      size_t v15 = 8 * LayoutPairCount;
    }
    bzero((char *)&v73 - v13, v15);
    uint64_t v17 = MEMORY[0x270FA5388](v16);
    uint64_t v18 = (char *)&v73 - v13;
    MEMORY[0x270FA5388](v17);
    uint64_t v19 = (char *)&v73 - v13;
    uint64_t v20 = LayoutPairCount;
    bzero(v19, v15);
    bzero(v11, SaType);
    __n128 v80 = v14;
    bzero(v14, 8 * LayoutPairCount);
    uint64_t v79 = v18;
    bzero(v18, 8 * LayoutPairCount);
    uint64_t v78 = v19;
    bzero(v19, 8 * LayoutPairCount);
    if (LayoutPairCount)
    {
      Sauint64_t Type = 0;
      unsigned int v21 = 0;
      signed int v22 = 0;
      uint64_t v85 = 0;
      uint64_t v81 = 0;
      uint64_t v82 = 0;
      uint64_t v74 = v11;
      uint64_t v76 = v11 + 1;
      int v75 = v20 - 1;
      int v23 = -1;
      int v83 = -1;
      int Value = -1;
      uint64_t v77 = v20;
      while (2)
      {
        uint64_t v24 = glpLayoutTypeNodeGetLayoutPair(v2, v21);
        uint64_t Identifier = (const void *)glpLayoutPairNodeGetIdentifier(v24);
        unsigned int v27 = v26;
        int v93 = 0;
        uint64_t Allocator = glpCompilerGetAllocator(a1);
        uint64_t v29 = glpLowerCaseCopyOfString(Allocator, Identifier, v27);
        if (!glpLayoutQualifierFromString(v29, v30, &v93))
        {
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v92);
          glpLogMessage(InfoLog, 0, (uint64_t)&v92, "Unknown identifier '%.*s' in layout", v48, v49, v50, v51, v27);
          return glpSAFailed();
        }
        int v31 = glpLayoutQualifierValueBehavior(v93);
        Valueint Kind = glpLayoutPairNodeGetValueKind(v24);
        switch(v31)
        {
          case 0:
            if (!ValueKind) {
              goto LABEL_22;
            }
            uint64_t v53 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v91);
            glpLogMessage(v53, 0, (uint64_t)&v91, "Identifier '%.*s' in layout must not have a value", v54, v55, v56, v57, v27);
            return glpSAFailed();
          case 1:
            if (ValueKind == 1) {
              goto LABEL_22;
            }
            unint64_t v58 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v90);
            glpLogMessage(v58, 0, (uint64_t)&v90, "Identifier '%.*s' in layout must have a value", v59, v60, v61, v62, v27);
            return glpSAFailed();
          case 2:
            if (ValueKind == 2) {
              goto LABEL_22;
            }
            uint64_t v63 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v89);
            glpLogMessage(v63, 0, (uint64_t)&v89, "Identifier '%.*s' in layout must have a type", v64, v65, v66, v67, v27);
            return glpSAFailed();
          case 3:
            if (ValueKind != 3)
            {
              uint64_t v68 = (uint64_t **)glpCompilerGetInfoLog(a1);
              glpASTNodeGetLocation(v2, &v88);
              glpLogMessage(v68, 0, (uint64_t)&v88, "Identifier '%.*s' in layout must have a string", v69, v70, v71, v72, v27);
              return glpSAFailed();
            }
LABEL_22:
            switch(v93)
            {
              case 'U':
                uint64_t Type = glpLayoutPairNodeGetType(v24);
                Sauint64_t Type = glpASTNodeGetSaType(Type);
                goto LABEL_32;
              case 'V':
                uint64_t v34 = glpLayoutPairNodeGetType(v24);
                uint64_t v85 = glpASTNodeGetSaType(v34);
                int v23 = 2;
                goto LABEL_32;
              case 'W':
                int Value = glpLayoutPairNodeGetValue(v24);
                goto LABEL_32;
              case 'X':
                int v83 = glpLayoutPairNodeGetValue(v24);
                goto LABEL_32;
              case 'Y':
                if (v21 + 1 >= v20)
                {
                  int v23 = 1;
                  uint64_t v82 = 0x725D7890000000BLL;
                  uint64_t v81 = "<<unnamed>>";
                  ++v21;
                }
                else
                {
                  uint64_t v35 = 0;
                  uint64_t v36 = &v76[2 * v22];
                  uint64_t v37 = &v80[8 * v22];
                  BOOL v38 = &v79[8 * v22];
                  LODWORD(v82) = v22;
                  uint64_t v39 = &v78[8 * v22];
                  int v40 = v75 - v21;
                  do
                  {
                    uint64_t v41 = glpLayoutTypeNodeGetLayoutPair(v2, v21 + v35 + 1);
                    *(v36 - 1) = glpLayoutPairNodeGetIdentifier(v41);
                    *uint64_t v36 = v42;
                    uint64_t v43 = glpLayoutPairNodeGetType(v41);
                    *(void *)&v37[8 * v35] = glpASTNodeGetSaType(v43);
                    *(void *)&v38[8 * v35] = 0;
                    *(void *)&v39[8 * v35] = 0;
                    v36 += 2;
                    ++v35;
                  }
                  while (v40 != v35);
                  signed int v22 = v82 + v35;
                  int v23 = 1;
                  uint64_t v82 = 0x725D7890000000BLL;
                  uint64_t v81 = "<<unnamed>>";
                  LODWORD(v20) = v77;
                  unsigned int v21 = v77;
                }
LABEL_32:
                if (++v21 < v20) {
                  continue;
                }
                if (v23 == 2)
                {
                  uint64_t v52 = glpCompilerGetAllocator(a1);
                  Arrayuint64_t Type = glpMakeArrayType(v52, v85, Value, v83);
                }
                else
                {
                  Arrayuint64_t Type = SaType;
                  if (v23 == 1)
                  {
                    uint64_t v45 = (void *)glpCompilerGetAllocator(a1);
                    Arrayuint64_t Type = glpMakeStructType(v45, (uint64_t)v81, v82, v22, (uint64_t)v74, (uint64_t)v80, (uint64_t)v79, (uint64_t)v78);
                  }
                }
                break;
              default:
                goto LABEL_46;
            }
            break;
          default:
LABEL_46:
            abort();
        }
        break;
      }
    }
    else
    {
      Arrayuint64_t Type = 0;
    }
    glpASTNodeSetSaType(v2, ArrayType);
    glpASTNodeSetSaFlags(v2, 0);
    return v2;
  }

  return glpSAFailed();
}

void glpSAKeywordQualifier()
{
}

uint64_t glpSALayoutQualifier(uint64_t a1, uint64_t a2)
{
  if (!glpLayoutQualifierNodeGetLayoutPairCount(a2)) {
    goto LABEL_11;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t LayoutPair = glpLayoutQualifierNodeGetLayoutPair(a2, v4);
    uint64_t v7 = glpSANode(a1, LayoutPair);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpLayoutQualifierNodeSetLayoutPair(a2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpLayoutQualifierNodeGetLayoutPairCount(a2));
  if (v5) {
LABEL_11:
  }
    abort();

  return glpSAFailed();
}

uint64_t glpSASubroutineTypeList(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!glpSubroutineTypeListNodeGetTypeCount(a2)) {
    goto LABEL_20;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t Type = glpSubroutineTypeListNodeGetType(v2, v4);
    uint64_t v7 = glpSANode(a1, Type);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpSubroutineTypeListNodeSetType(v2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpSubroutineTypeListNodeGetTypeCount(v2));
  if (!v5)
  {
    return glpSAFailed();
  }
  else
  {
LABEL_20:
    if (glpSubroutineTypeListNodeGetTypeCount(v2))
    {
      unsigned int v8 = 0;
      while (1)
      {
        uint64_t v9 = glpSubroutineTypeListNodeGetType(v2, v8);
        Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v9);
        if (glpTypeGetKind(SaType) != 5) {
          break;
        }
        if (++v8 >= glpSubroutineTypeListNodeGetTypeCount(v2)) {
          goto LABEL_12;
        }
      }
      glpTypeIdentifierNodeGetName(v9);
      char v14 = v13;
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v20);
      glpLogMessage(InfoLog, 0, (uint64_t)&v20, "Non-subroutine type '%.*s' in subroutine type list", v16, v17, v18, v19, v14);
      return glpSAFailed();
    }
    else
    {
LABEL_12:
      Primitiveuint64_t Type = glpGetPrimitiveType(0);
      glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
    }
    return v2;
  }
}

uint64_t glpSAQualifierList(uint64_t a1, uint64_t a2)
{
  if (!glpQualifierListNodeGetQualifierCount(a2)) {
    goto LABEL_11;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t Qualifier = glpQualifierListNodeGetQualifier(a2, v4);
    uint64_t v7 = glpSANode(a1, Qualifier);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpQualifierListNodeSetQualifier(a2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpQualifierListNodeGetQualifierCount(a2));
  if (v5) {
LABEL_11:
  }
    abort();

  return glpSAFailed();
}

uint64_t glpSAGlobalTypeQualifier(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t QualifierList = glpGlobalTypeQualifierNodeGetQualifierList(a2);
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  if (!glpParseQualifiers(a1, 2u, QualifierList, 0, &v25, &v24, &v23)) {
    return glpSAFailed();
  }
  if (v24)
  {
    uint64_t NameTable = glpCompilerGetNameTable(a1);
    if (!glpNameTableGetCurrentFunction(NameTable))
    {
      uint64_t TopLevelNode = glpCompilerGetTopLevelNode(a1);
      GlobalTypeuint64_t Qualifier = glpTopLevelNodeGetGlobalTypeQualifier(TopLevelNode, v25);
      if (GlobalTypeQualifier)
      {
        uint64_t v14 = GlobalTypeQualifier;
        uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
        Layout = (void **)glpGlobalTypeQualifierNodeGetLayout(v14);
        uint64_t v17 = glpCopyLayoutObject(Allocator, Layout);
        uint64_t v18 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v2, &v22);
        if (!glpLayoutObjectAppendMany(v18, a1, (uint64_t)&v22, v17, (void **)v24)) {
          return glpSAFailed();
        }
        uint64_t v2 = 0;
        uint64_t v24 = v17;
      }
      else
      {
        Primitiveuint64_t Type = glpGetPrimitiveType(0);
        glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
        glpASTNodeSetSaFlags(v2, v25);
        glpGlobalTypeQualifierNodeSetQualifierList(v2, 0);
        uint64_t v17 = v24;
        uint64_t v14 = v2;
      }
      glpGlobalTypeQualifierNodeSetLayout(v14, (uint64_t)v17);
      if (glpCompilerApplyImplictRulesForGlobalTypeQualifier(a1, v14)) {
        return v2;
      }
      return glpSAFailed();
    }
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(v2, &v21);
  glpLogMessage(InfoLog, 0, (uint64_t)&v21, "Invalid non-global or non-layout type-qualifier", v7, v8, v9, v10, v20);
  return glpSAFailed();
}

uint64_t glpSALayoutPair(uint64_t a1, uint64_t a2)
{
  uint64_t Type = glpLayoutPairNodeGetType(a2);
  uint64_t v5 = glpSANode(a1, Type);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpLayoutPairNodeSetType(a2, v5);
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    return a2;
  }
}

uint64_t glpSAExpressionStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t Expr = glpExpressionStatementNodeGetExpr(v2);
  uint64_t v5 = glpSANode(a1, Expr);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpExpressionStatementNodeSetExpr(v2, v5);
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
    uint64_t v7 = glpExpressionStatementNodeGetExpr(v2);
    if (v7)
    {
      uint64_t v8 = v7;
      Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v7);
      if (glpCompilerDoesTypeRequirePrecision(a1, SaType) && (glpASTNodeGetSaFlags(v8) & 0x1F) == 0)
      {
        uint64_t v10 = (unsigned int *)glpASTNodeGetSaType(v8);
        DefaultPrecisionForuint64_t Type = glpGetDefaultPrecisionForType(a1, v10);
        if (DefaultPrecisionForType)
        {
          glpPushdownPrecision(a1, v8, DefaultPrecisionForType);
        }
        else
        {
          uint64_t v13 = glpASTNodeGetSaType(v8);
          uint64_t Allocator = (void *)glpCompilerGetAllocator(a1);
          glpTypeHumanReadableDescription(v13, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
          char v16 = v15;
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v22);
          glpLogMessage(InfoLog, 0, (uint64_t)&v22, "Expression of type '%.*s' - precision can not be inferred and no default precision available", v18, v19, v20, v21, v16);
          return glpSAFailed();
        }
      }
    }
    return v2;
  }
}

uint64_t glpSABlock(uint64_t a1, uint64_t a2)
{
  glpSAStatement(a2);
  if (glpBlockNodeGetNeedsNewScope(a2))
  {
    uint64_t NameTable = glpCompilerGetNameTable(a1);
    glpNameTablePush(NameTable, a2);
  }
  int StatementCount = glpBlockNodeGetStatementCount(a2);
  if (!StatementCount) {
    goto LABEL_17;
  }
  int v6 = -StatementCount;
  int v7 = 1;
  do
  {
    unsigned int v8 = glpBlockNodeGetStatementCount(a2) + v6;
    uint64_t Statement = glpBlockNodeGetStatement(a2, v8);
    if (Statement)
    {
      uint64_t v10 = Statement;
      uint64_t v11 = glpCompilerGetNameTable(a1);
      glpNameTableSetStatementIndex(v11, v8);
      uint64_t v12 = glpSANode(a1, v10);
      int v13 = glpBlockNodeGetStatementCount(a2);
      if (v12 != -1) {
        glpBlockNodeSetStatement(a2, v13 + v6, v12);
      }
      if (v7) {
        BOOL v14 = v12 == -1;
      }
      else {
        BOOL v14 = 1;
      }
      int v7 = !v14;
    }
  }
  while (!__CFADD__(v6++, 1));
  if (!v7)
  {
    if (glpBlockNodeGetNeedsNewScope(a2))
    {
      uint64_t v25 = (void *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v25);
    }
    return glpSAFailed();
  }
  else
  {
LABEL_17:
    int v16 = glpBlockNodeGetStatementCount(a2);
    if (v16)
    {
      int v17 = v16;
      unsigned int v18 = 0;
      Isuint64_t ReturnStatementNode = 0;
      do
      {
        uint64_t v20 = glpBlockNodeGetStatement(a2, v18);
        if (v20)
        {
          uint64_t v21 = v20;
          if (IsReturnStatementNode && !glpIsCaseStatementNode(v20) && !glpIsDefaultStatementNode(v21))
          {
            glpBlockNodeSetStatement(a2, v18, 0);
LABEL_28:
            Isuint64_t ReturnStatementNode = 1;
            goto LABEL_29;
          }
          if (glpIsDiscardStatementNode(v21) || glpIsBreakStatementNode(v21) || glpIsContinueStatementNode(v21)) {
            goto LABEL_28;
          }
          Isuint64_t ReturnStatementNode = glpIsReturnStatementNode(v21);
        }
LABEL_29:
        ++v18;
      }
      while (v17 != v18);
    }
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    if (glpBlockNodeGetNeedsNewScope(a2))
    {
      uint64_t v23 = (void *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v23);
    }
    return a2;
  }
}

uint64_t glpSAIfStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t Cond = glpIfStatementNodeGetCond(v2);
  uint64_t v5 = glpSANode(a1, Cond);
  if (v5 == -1)
  {
    int v6 = 0;
  }
  else
  {
    glpIfStatementNodeSetCond(v2, v5);
    int v6 = 1;
  }
  uint64_t IfStatement = glpIfStatementNodeGetIfStatement(v2);
  uint64_t v8 = glpSANode(a1, IfStatement);
  if (v8 == -1) {
    int v6 = 0;
  }
  else {
    glpIfStatementNodeSetIfStatement(v2, v8);
  }
  uint64_t ElseStatement = glpIfStatementNodeGetElseStatement(v2);
  uint64_t v10 = glpSANode(a1, ElseStatement);
  if (v10 == -1 || (glpIfStatementNodeSetElseStatement(v2, v10), !v6))
  {
    return glpSAFailed();
  }
  else
  {
    uint64_t v11 = glpIfStatementNodeGetCond(v2);
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v11);
    Primitiveuint64_t Type = glpGetPrimitiveType(9u);
    if (glpTypesEqual(SaType, (uint64_t)PrimitiveType))
    {
      BOOL v14 = glpGetPrimitiveType(0);
      glpASTNodeSetSaType(v2, (uint64_t)v14);
    }
    else
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v22);
      glpLogMessage(InfoLog, 0, (uint64_t)&v22, "Condition must be of type BOOL", v17, v18, v19, v20, v21);
      return glpSAFailed();
    }
    return v2;
  }
}

uint64_t glpSALoopStatement(uint64_t a1, uint64_t a2)
{
  glpSAStatement(a2);
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  uint64_t CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  ++*(_DWORD *)(CurrentFunction + 120);
  uint64_t Body0 = glpLoopStatementNodeGetBody0(a2);
  uint64_t v7 = glpSANode(a1, Body0);
  if (v7 != -1) {
    glpLoopStatementNodeSetBody0(a2, v7);
  }
  uint64_t Body1 = glpLoopStatementNodeGetBody1(a2);
  uint64_t v9 = glpSANode(a1, Body1);
  if (v9 == -1 || (glpLoopStatementNodeSetBody1(a2, v9), v7 == -1))
  {
    return glpSAFailed();
  }
  else
  {
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    --*(_DWORD *)(CurrentFunction + 120);
    return a2;
  }
}

uint64_t glpSASwitchStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  uint64_t CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  ++*(_DWORD *)(CurrentFunction + 124);
  uint64_t Expr = glpSwitchStatementNodeGetExpr(v2);
  uint64_t v7 = glpSANode(a1, Expr);
  if (v7 == -1)
  {
    return glpSAFailed();
  }
  uint64_t v8 = v7;
  Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(v7);
  if (glpTypeGetKind(SaType)
    || glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 5
    && glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 36)
  {
    uint64_t InfoLog = glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, v75);
    char v15 = "Switch expression must be of type int or uint";
    int v16 = v75;
    goto LABEL_4;
  }
  if (glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 5)
  {
    uint64_t Allocator = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(v8, &v74);
    Primitiveuint64_t Type = glpGetPrimitiveType(5u);
    char SaFlags = glpASTNodeGetSaFlags(v8);
    uint64_t TypeConversionNode = glpMakeTypeConversionNode(Allocator, &v74, (uint64_t)PrimitiveType, SaFlags & 0x1F);
    glpUnaryOperatorNodeSetExpr(TypeConversionNode, v8);
    uint64_t v8 = glpSANode(a1, TypeConversionNode);
    if (v8 == -1) {
      return glpSAFailed();
    }
  }
  glpSwitchStatementNodeSetExpr(v2, v8);
  if (!glpCompilerDoesTypeRequirePrecision(a1, SaType))
  {
    uint64_t v23 = 0;
    goto LABEL_20;
  }
  uint64_t v23 = glpASTNodeGetSaFlags(v8) & 0x1F;
  if (!v23)
  {
    DefaultPrecisionForuint64_t Type = glpGetDefaultPrecisionForType(a1, SaType);
    if (DefaultPrecisionForType)
    {
      uint64_t v23 = DefaultPrecisionForType;
      glpPushdownPrecision(a1, v8, DefaultPrecisionForType);
      goto LABEL_20;
    }
    uint64_t v53 = (void *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v53);
    char v55 = v54;
    uint64_t InfoLog = glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v73);
    char v58 = v55;
    char v15 = "Switch condition of type '%.*s' - precision can not be inferred and no default precision available";
    int v16 = &v73;
LABEL_4:
    uint64_t v17 = (uint64_t **)InfoLog;
    goto LABEL_5;
  }
LABEL_20:
  uint64_t Body = glpSwitchStatementNodeGetBody(v2);
  unsigned int v26 = (void *)glpCompilerGetAllocator(a1);
  uint64_t IntHash = glpMakeIntHash(v26);
  if (glpBlockNodeGetStatementCount(Body))
  {
    uint64_t v59 = SaType;
    uint64_t v60 = v23;
    uint64_t v61 = IntHash;
    unsigned int v28 = 0;
    uint64_t v29 = 0;
    char v30 = 0;
    uint64_t v31 = IntHash;
    while (1)
    {
      uint64_t Statement = glpBlockNodeGetStatement(Body, v28);
      int Kind = glpASTNodeGetKind(Statement);
      if (Kind == 70)
      {
        Constint Value = glpCaseStatementNodeGetConstValue(Statement);
        uint64_t v36 = glpSANode(a1, ConstValue);
        if (v36 == -1) {
          return glpSAFailed();
        }
        uint64_t v37 = v36;
        uint64_t v38 = glpCompilerGetNameTable(a1);
        if (glpNameTableGetGLSLVersion(v38) == 6)
        {
          uint64_t v39 = glpASTNodeGetSaType(v37);
          if (!glpTypesEqual(v59, v39))
          {
            uint64_t v56 = glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(Statement, &v69);
            char v15 = "Type of 'case' expressions must match type of 'switch' expression";
            int v16 = &v69;
            goto LABEL_50;
          }
        }
        uint64_t v40 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v37, &v68);
        uint64_t v41 = glpGetPrimitiveType(5u);
        uint64_t v42 = glpMakeTypeConversionNode(v40, &v68, (uint64_t)v41, v60);
        glpUnaryOperatorNodeSetExpr(v42, v37);
        uint64_t v43 = glpSANode(a1, v42);
        if (v43 == -1) {
          return glpSAFailed();
        }
        uint64_t v44 = v43;
        glpCaseStatementNodeSetConstValue(Statement, v43);
        if (!glpIsConstantNode(v44))
        {
          uint64_t v56 = glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Statement, &v67);
          char v15 = "Value of 'case' expression must be constant";
          int v16 = &v67;
          goto LABEL_50;
        }
        unsigned int v45 = *(_DWORD *)glpConstantNodeGetValue(v44);
        uint64_t v46 = glpIntHashGet(v31, v45);
        if (v46)
        {
          uint64_t v57 = v46;
          uint64_t v56 = glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Statement, &v66);
          glpASTNodeGetLocation(v57, &v64);
          char v58 = v65;
          char v15 = "Duplicate case value found.  Previous occurrence on line %d";
          int v16 = &v66;
          goto LABEL_50;
        }
        glpIntHashPut(v31, v45, Statement, v47);
        glpCaseStatementNodeSetIsStray(Statement, 0);
        char v34 = 0;
      }
      else
      {
        if (Kind == 71)
        {
          if (v29)
          {
            uint64_t v56 = glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(Statement, &v72);
            glpASTNodeGetLocation(v29, &v70);
            char v58 = v71;
            char v15 = "Multiple default statements in switch see line %d";
            int v16 = &v72;
            goto LABEL_50;
          }
          glpDefaultStatementNodeSetIsStray(Statement, 0);
          char v34 = 0;
          goto LABEL_36;
        }
        if ((v30 & 1) == 0)
        {
          uint64_t v56 = glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Statement, &v63);
          char v15 = "First statement in switch is not case/default";
          int v16 = &v63;
          goto LABEL_50;
        }
        char v34 = 1;
      }
      uint64_t Statement = v29;
LABEL_36:
      ++v28;
      char v30 = 1;
      uint64_t v29 = Statement;
      if (v28 >= glpBlockNodeGetStatementCount(Body))
      {
        uint64_t IntHash = v61;
        if (v34) {
          break;
        }
        uint64_t v56 = glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(Body, &v62);
        char v15 = "Expected statement after final 'case'/'default'";
        int v16 = &v62;
LABEL_50:
        uint64_t v17 = (uint64_t **)v56;
LABEL_5:
        glpLogMessage(v17, 0, (uint64_t)v16, v15, v11, v12, v13, v14, v58);
        return glpSAFailed();
      }
    }
  }
  glpDestroyIntHash(IntHash);
  uint64_t v48 = glpSwitchStatementNodeGetExpr(v2);
  uint64_t v49 = glpSANode(a1, v48);
  if (v49 != -1) {
    glpSwitchStatementNodeSetExpr(v2, v49);
  }
  uint64_t v50 = glpSwitchStatementNodeGetBody(v2);
  uint64_t v51 = glpSANode(a1, v50);
  if (v51 == -1) {
    return glpSAFailed();
  }
  glpSwitchStatementNodeSetBody(v2, v51);
  if (v49 == -1) {
    return glpSAFailed();
  }
  uint64_t v52 = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(v2, (uint64_t)v52);
  --*(_DWORD *)(CurrentFunction + 124);
  return v2;
}

uint64_t glpSACaseStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  Constint Value = glpCaseStatementNodeGetConstValue(v2);
  uint64_t v5 = glpSANode(a1, ConstValue);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpCaseStatementNodeSetConstValue(v2, v5);
    if (glpCaseStatementNodeGetIsStray(v2))
    {
      uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v14);
      glpLogMessage(InfoLog, 0, (uint64_t)&v14, "case disallowed outside switch body", v7, v8, v9, v10, v13);
      return glpSAFailed();
    }
    else
    {
      Primitiveuint64_t Type = glpGetPrimitiveType(0);
      glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
    }
    return v2;
  }
}

uint64_t glpSADefaultStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  if (glpDefaultStatementNodeGetIsStray(v2))
  {
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v12);
    glpLogMessage(InfoLog, 0, (uint64_t)&v12, "default disallowed outside switch body", v5, v6, v7, v8, v11);
    return glpSAFailed();
  }
  else
  {
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  return v2;
}

uint64_t glpSABreakStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  uint64_t CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  if (*(_DWORD *)(CurrentFunction + 124) || *(_DWORD *)(CurrentFunction + 120))
  {
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  else
  {
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v14);
    glpLogMessage(InfoLog, 0, (uint64_t)&v14, "break disallowed outside switch/loop body", v9, v10, v11, v12, v13);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSAContinueStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  if (*(_DWORD *)(glpNameTableGetCurrentFunction(NameTable) + 120))
  {
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  else
  {
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v13);
    glpLogMessage(InfoLog, 0, (uint64_t)&v13, "continue disallowed outside loop body", v7, v8, v9, v10, v12);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSADiscardStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  if (glpNameTableGetLanguage(NameTable) == 4)
  {
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  else
  {
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v13);
    glpLogMessage(InfoLog, 0, (uint64_t)&v13, "'discard' is only meaningful in the fragment shader.", v7, v8, v9, v10, v12);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSAReturnStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  glpSAStatement(a2);
  uint64_t Expr = glpReturnStatementNodeGetExpr(v2);
  uint64_t v5 = glpSANode(a1, Expr);
  if (v5 != -1)
  {
    glpReturnStatementNodeSetExpr(v2, v5);
    if (glpReturnStatementNodeGetExpr(v2))
    {
      uint64_t v6 = glpReturnStatementNodeGetExpr(v2);
      Sauint64_t Type = glpASTNodeGetSaType(v6);
    }
    else
    {
      Sauint64_t Type = (uint64_t)glpGetPrimitiveType(0);
    }
    uint64_t v9 = (unsigned int *)SaType;
    uint64_t NameTable = glpCompilerGetNameTable(a1);
    uint64_t CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
    uint64_t v12 = CurrentFunction;
    if ((*(unsigned char *)(CurrentFunction + 9) & 0x20) != 0 && *(unsigned char *)(CurrentFunction + 112))
    {
      uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v43);
      int v37 = *(_DWORD *)(v12 + 32);
      uint64_t v18 = "Inline function '%.*s' can only have 1 return";
      uint64_t v19 = &v43;
LABEL_11:
      glpLogMessage(InfoLog, 0, (uint64_t)v19, v18, v14, v15, v16, v17, v37);
      return glpSAFailed();
    }
    *(unsigned char *)(CurrentFunction + 112) = 1;
    Returnuint64_t Type = (unsigned int *)glpFunctionTypeGetReturnType(*(void *)CurrentFunction);
    if (!glpTypesEqual(v9, (uint64_t)ReturnType)
      && !glpTypeGetKind(v9)
      && !glpTypeGetKind(ReturnType))
    {
      unsigned int ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
      Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType((uint64_t)v9);
      uint64_t v24 = glpPrimitiveTypeGetPrimitiveType((uint64_t)ReturnType);
      if (!glpCanConvert(PrimitiveType, v24, ImplicitConversionPolicy))
      {
        uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v42);
        uint64_t v18 = "Expression in 'return' statement must match return type of function (and no available implicit conversion)";
        uint64_t v19 = &v42;
        goto LABEL_11;
      }
      uint64_t v25 = glpReturnStatementNodeGetExpr(v2);
      uint64_t v26 = glpConvert(a1, v25, (uint64_t)ReturnType, 0);
      glpReturnStatementNodeSetExpr(v2, v26);
    }
    glpASTNodeSetSaType(v2, (uint64_t)v9);
    glpReturnStatementNodeSetExtra(v2, v12);
    if (!glpReturnStatementNodeGetExpr(v2)) {
      return v2;
    }
    __n128 v40 = 0uLL;
    uint64_t v41 = 0;
    glpASTNodeGetLocation(v2, &v40);
    unsigned int v27 = *(uint64_t **)(glpReturnStatementNodeGetExtra(v2) + 72);
    __n128 v38 = v40;
    uint64_t v39 = v41;
    uint64_t LValueForVariableObject = glpMakeLValueForVariableObject(a1, &v38, v27);
    uint64_t Allocator = glpCompilerGetAllocator(a1);
    __n128 v38 = v40;
    uint64_t v39 = v41;
    glpMakeCommaExprNode(Allocator, &v38, 0);
    uint64_t v31 = v30;
    uint64_t v32 = (void *)glpCompilerGetAllocator(a1);
    uint64_t v33 = glpReturnStatementNodeGetExpr(v2);
    __n128 v38 = v40;
    uint64_t v39 = v41;
    uint64_t AssignFragment = glpMakeAssignFragment(a1, &v38, LValueForVariableObject, v33);
    glpCommaExprNodeAddExpr(v32, v31, AssignFragment);
    uint64_t v35 = (void *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v35, v31, v2);
    glpReturnStatementNodeSetExpr(v2, 0);
    uint64_t v36 = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)v36);
    return glpSANode(a1, v31);
  }

  return glpSAFailed();
}

uint64_t glpSATopLevel(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable = glpCompilerGetNameTable(a1);
  glpNameTableSetTopLevelBlock(NameTable, a2);
  int DefCount = glpTopLevelNodeGetDefCount(a2);
  if (!DefCount) {
    goto LABEL_14;
  }
  int v6 = -DefCount;
  int v7 = 1;
  do
  {
    unsigned int v8 = glpTopLevelNodeGetDefCount(a2) + v6;
    uint64_t Def = glpTopLevelNodeGetDef(a2, v8);
    uint64_t v10 = glpCompilerGetNameTable(a1);
    glpNameTableSetStatementIndex(v10, v8);
    uint64_t v11 = glpSANode(a1, Def);
    int v12 = glpTopLevelNodeGetDefCount(a2);
    if (v11 != -1) {
      glpTopLevelNodeSetDef(a2, v12 + v6, v11);
    }
    if (v7) {
      BOOL v13 = v11 == -1;
    }
    else {
      BOOL v13 = 1;
    }
    int v7 = !v13;
  }
  while (!__CFADD__(v6++, 1));
  if ((v7 & 1) == 0)
  {
    return glpSAFailed();
  }
  else
  {
LABEL_14:
    Primitiveuint64_t Type = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    uint64_t v16 = glpCompilerGetNameTable(a1);
    if (glpNameTableGetLanguage(v16) == 1 && !glpCheckBarrier(a2))
    {
      uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v24[0] = "-1";
      v24[1] = 0xEDA00000002;
      v24[2] = 0xFFFFFFFFLL;
      glpLogMessage(InfoLog, 0, (uint64_t)v24, "You can't call barrier() outside main, within control flow, or after a return statement.", v18, v19, v20, v21, v23);
      return glpSAFailed();
    }
    return a2;
  }
}

void glpSAAvailabilityDeclaration()
{
}

void glpSARawCall()
{
}

uint64_t glpSASubroutineRawCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = glpSubroutineRawCallNodeGetIndexExpr(a2);
  uint64_t v5 = glpSANode(a1, v4);
  if (v5 != -1)
  {
    glpSubroutineRawCallNodeSetIndexExpr(a2, v5);
    abort();
  }

  return glpSAFailed();
}

uint64_t glpSAOffset(uint64_t a1, uint64_t a2)
{
  uint64_t BankIndex = glpOffsetNodeGetBankIndex(a2);
  uint64_t v5 = glpSANode(a1, BankIndex);
  if (v5 == -1)
  {
    int v6 = 0;
  }
  else
  {
    glpOffsetNodeSetBankIndex(a2, v5);
    int v6 = 1;
  }
  uint64_t OffsetExpr = glpOffsetNodeGetOffsetExpr(a2);
  uint64_t v8 = glpSANode(a1, OffsetExpr);
  if (v8 == -1) {
    int v6 = 0;
  }
  else {
    glpOffsetNodeSetOffsetExpr(a2, v8);
  }
  VectorElementuint64_t Expr = glpOffsetNodeGetVectorElementExpr(a2);
  uint64_t v10 = glpSANode(a1, VectorElementExpr);
  if (v10 != -1)
  {
    glpOffsetNodeSetVectorElementExpr(a2, v10);
    if (v6) {
      abort();
    }
  }

  return glpSAFailed();
}

uint64_t glpSALValue(uint64_t a1, uint64_t a2)
{
  if (glpSADeref(a1, a2) != -1) {
    abort();
  }

  return glpSAFailed();
}

uint64_t glpSARValue(uint64_t a1, uint64_t a2)
{
  if (glpSADeref(a1, a2) != -1)
  {
    uint64_t Base = glpRValueNodeGetBase(a2);
    uint64_t v5 = glpSANode(a1, Base);
    if (v5 != -1)
    {
      glpRValueNodeSetBase(a2, v5);
      abort();
    }
  }

  return glpSAFailed();
}

uint64_t glpSAIBPartialDeref(uint64_t a1, uint64_t a2)
{
  uint64_t BankIndex = glpIBPartialDerefNodeGetBankIndex(a2);
  uint64_t v5 = glpSANode(a1, BankIndex);
  if (v5 != -1)
  {
    glpIBPartialDerefNodeSetBankIndex(a2, v5);
    abort();
  }

  return glpSAFailed();
}

uint64_t glpSAPPStreamOp(uint64_t a1, uint64_t a2)
{
  if (glpSACall(a1, a2) != -1) {
    abort();
  }

  return glpSAFailed();
}

void glpSASubroutineUniform()
{
}

uint64_t glpSAUnaryOperator(uint64_t a1, uint64_t a2)
{
  uint64_t Expr = glpUnaryOperatorNodeGetExpr(a2);
  uint64_t v5 = glpSANode(a1, Expr);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpUnaryOperatorNodeSetExpr(a2, v5);
    uint64_t v6 = glpUnaryOperatorNodeGetExpr(a2);
    char SaFlags = glpASTNodeGetSaFlags(v6);
    glpASTNodeSetSaFlags(a2, SaFlags & 0x7F);
    return a2;
  }
}

void *__glpSAVariableIdentifier_block_invoke(void *result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(result[4] + 8) + 24) = a2;
  *(void *)(*(void *)(result[5] + 8) + 24) = a3;
  int v6 = *(_DWORD *)(*(void *)(result[4] + 8) + 24);
  if (v6) {
    BOOL v7 = v6 == 6;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || (uint64_t result = (void *)glpNameTableGetGLSLVersion(result[6]), result != 1)) {
    *a5 = 1;
  }
  return result;
}

void *__glpSATypeIdentifier_block_invoke(void *result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(result[4] + 8) + 24) = a2;
  *(void *)(*(void *)(result[5] + 8) + 24) = a3;
  int v6 = *(_DWORD *)(*(void *)(result[4] + 8) + 24);
  if (v6) {
    BOOL v7 = v6 == 6;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || (uint64_t result = (void *)glpNameTableGetGLSLVersion(result[6]), result != 1)) {
    *a5 = 1;
  }
  return result;
}

uint64_t glpSACall(uint64_t a1, uint64_t a2)
{
  if (glpIsUndeterminedCallNode(a2))
  {
    uint64_t v4 = glpUndeterminedCallNodeGetCallee(a2);
    if (glpIsVariableIdentifierNode(v4))
    {
      uint64_t NameTable = glpCompilerGetNameTable(a1);
      if (glpNameTableIsExtensionEnabled(NameTable, 0x24u))
      {
        uint64_t v6 = glpUndeterminedCallNodeGetCallee(a2);
        uint64_t Name = (char *)glpVariableIdentifierNodeGetName(v6);
        if (glpStringsEqual("$assert", 0x75B16CFF00000007, Name, v8)) {
          return a2;
        }
      }
    }
  }
  if (!glpCallNodeGetArgCount(a2)) {
    return a2;
  }
  unsigned int v9 = 0;
  int v10 = 1;
  do
  {
    uint64_t v11 = glpCallNodeGetArg(a2, v9);
    uint64_t v12 = glpSANode(a1, v11);
    if (v12 == -1) {
      int v10 = 0;
    }
    else {
      glpCallNodeSetArg(a2, v9, v12);
    }
    ++v9;
  }
  while (v9 < glpCallNodeGetArgCount(a2));
  if (v10) {
    return a2;
  }

  return glpSAFailed();
}

uint64_t __glpSAUndeterminedCall_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8 = (void *)result;
  if (a2 == 4
    || a2 == 7
    || (uint64_t result = glpNameTableGetGLSLVersion(*(void *)(result + 48)), result != 1)
    && (uint64_t result = glpCompilerGetIOSVersion(v8[7]), (int)result >= 9))
  {
    *(_DWORD *)(*(void *)(v8[4] + 8) + 24) = a2;
    *(void *)(*(void *)(v8[5] + 8) + 24) = a3;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSASubroutineArrayCall_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAMethodCall_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t glpSAIncrementOperator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (glpSAUnaryOperator(a1, a2) != -1)
  {
    uint64_t Expr = glpUnaryOperatorNodeGetExpr(v2);
    Sauint64_t Type = (unsigned int *)glpASTNodeGetSaType(Expr);
    if (glpTypeGetKind(SaType))
    {
      uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v19);
      uint64_t v11 = "Pre- or post- -increment or -decrement of nonprimitive type";
      uint64_t v12 = &v19;
    }
    else
    {
      uint64_t v14 = glpASTNodeGetSaType(Expr);
      Primitiveuint64_t Type = glpPrimitiveTypeGetPrimitiveType(v14);
      if (glpPrimitiveTypeGetCategory(PrimitiveType) - 1 >= 3)
      {
        uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v18);
        uint64_t v11 = "Pre- or post- -increment or -decrement of nonscalar nonvector nonmatrix type";
        uint64_t v12 = &v18;
      }
      else if (glpIsLValueNode(Expr))
      {
        if ((glpASTNodeGetSaFlags(Expr) & 0x360) == 0) {
          return v2;
        }
        uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v16);
        uint64_t v11 = "Pre- or post- -increment or -decrement of read-only variable";
        uint64_t v12 = &v16;
      }
      else
      {
        uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v17);
        uint64_t v11 = "Pre- or post- -increment or -decrement of non-lvalue";
        uint64_t v12 = &v17;
      }
    }
    glpLogMessage(InfoLog, 0, (uint64_t)v12, v11, v7, v8, v9, v10, v16.n128_i8[0]);
    return glpSAFailed();
  }

  return glpSAFailed();
}

uint64_t glpSABinaryOperator(uint64_t a1, uint64_t a2)
{
  uint64_t Lhs = glpBinaryOperatorNodeGetLhs(a2);
  uint64_t v5 = glpSANode(a1, Lhs);
  if (v5 != -1) {
    glpBinaryOperatorNodeSetLhs(a2, v5);
  }
  uint64_t Rhs = glpBinaryOperatorNodeGetRhs(a2);
  uint64_t v7 = glpSANode(a1, Rhs);
  if (v7 != -1)
  {
    glpBinaryOperatorNodeSetRhs(a2, v7);
    if (v5 != -1)
    {
      uint64_t v8 = glpBinaryOperatorNodeGetLhs(a2);
      uint64_t v9 = glpBinaryOperatorNodeGetRhs(a2);
      unsigned __int8 SaFlags = glpASTNodeGetSaFlags(v8);
      unsigned __int8 v11 = glpASTNodeGetSaFlags(v9);
      if (glpCompilerDoesTrackPrecision(a1))
      {
        unint64_t v12 = SaFlags & 0x1F;
        unint64_t v13 = v11 & 0x1F;
        if (v12 != v13 && !glpIsAssignNode(a2) && !glpIsOpAssignNode(a2))
        {
          if (v12 == 31 || (SaFlags & 0x1F) == 0)
          {
            uint64_t v15 = glpBinaryOperatorNodeGetLhs(a2);
            glpPushdownPrecision(a1, v15, v11 & 0x1F);
            goto LABEL_14;
          }
          if (v13 != 31 && (v11 & 0x1F) != 0)
          {
            if (v12 <= v13)
            {
              Sauint64_t Type = glpASTNodeGetSaType(v8);
              uint64_t v20 = glpConvert(a1, v8, SaType, v11 & 0x1F);
              glpBinaryOperatorNodeSetLhs(a2, v20);
              goto LABEL_14;
            }
            uint64_t v17 = glpASTNodeGetSaType(v9);
            uint64_t v18 = glpConvert(a1, v9, v17, SaFlags & 0x1F);
            glpBinaryOperatorNodeSetRhs(a2, v18);
          }
          else
          {
            uint64_t v16 = glpBinaryOperatorNodeGetRhs(a2);
            glpPushdownPrecision(a1, v16, SaFlags & 0x1F);
          }
        }
        unint64_t v13 = SaFlags & 0x1F;
      }
      else
      {
        unint64_t v13 = 0;
      }
LABEL_14:
      glpASTNodeSetSaFlags(a2, v13 | SaFlags & v11 & 0x60);
      return a2;
    }
  }

  return glpSAFailed();
}

uint64_t glpSwizzleHasDuplicateComponents(unsigned int a1)
{
  unsigned int v1 = a1 & 7;
  if ((a1 & 7) == 0) {
    return 0;
  }
  int v2 = 0;
  unsigned int v3 = v1 - 1;
  char v4 = 5;
  while (1)
  {
    int v5 = v2 + 1;
    if (v2 + 1 < v1) {
      break;
    }
LABEL_7:
    v4 += 2;
    --v3;
    int v2 = v5;
    if (v5 == v1) {
      return 0;
    }
  }
  unsigned int v6 = a1 >> (2 * v2 + 3);
  unsigned int v7 = v3;
  char v8 = v4;
  while ((((a1 >> v8) ^ v6) & 3) != 0)
  {
    v8 += 2;
    if (!--v7) {
      goto LABEL_7;
    }
  }
  return 1;
}

uint64_t __glpSAFunctionPrototype_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAFunctionPrototype_block_invoke_2(uint64_t result, int a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v9 = (void *)result;
  if (a2 == 4 || (uint64_t result = glpNameTableGetGLSLVersion(*(void *)(result + 56)), result != 1))
  {
    *(_DWORD *)(*(void *)(v9[4] + 8) + 24) = a2;
    *(void *)(*(void *)(v9[5] + 8) + 24) = a3;
    *(_DWORD *)(*(void *)(v9[6] + 8) + 24) = a4;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSAFunctionPrototype_block_invoke_3(uint64_t result, uint64_t a2, uint64_t a3, int a4, _DWORD *a5)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a4 == 3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAFunctionPrototype_block_invoke_4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAVariableDeclaration_block_invoke(uint64_t result, int a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v9 = (void *)result;
  if (!a2 || a2 == 6 || (uint64_t result = glpNameTableGetGLSLVersion(*(void *)(result + 56)), result != 1))
  {
    *(_DWORD *)(*(void *)(v9[4] + 8) + 24) = a2;
    *(void *)(*(void *)(v9[5] + 8) + 24) = a3;
    *(_DWORD *)(*(void *)(v9[6] + 8) + 24) = a4 == 3;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSAVariableDeclaration_block_invoke_2(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a2 == 1) {
    *a5 = 1;
  }
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  return result;
}

uint64_t __glpSAVariableDeclaration_block_invoke_3(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAQualifiedDeclaration_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

void __glpSAFunctionDefinition_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
}

uint64_t glpSAStructure(uint64_t a1, uint64_t a2)
{
  if (!glpStructureNodeGetFieldCount(a2)) {
    return a2;
  }
  unsigned int v4 = 0;
  int v5 = 1;
  do
  {
    uint64_t Field = glpStructureNodeGetField(a2, v4);
    uint64_t v7 = glpSANode(a1, Field);
    if (v7 == -1) {
      int v5 = 0;
    }
    else {
      glpStructureNodeSetField(a2, v4, v7);
    }
    ++v4;
  }
  while (v4 < glpStructureNodeGetFieldCount(a2));
  if (v5) {
    return a2;
  }

  return glpSAFailed();
}

uint64_t __glpSAStructType_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8 = result;
  if (!a2 || a2 == 6 || (uint64_t result = glpNameTableGetGLSLVersion(*(void *)(result + 48)), result != 1))
  {
    *(_DWORD *)(*(void *)(*(void *)(v8 + 32) + 8) + 24) = a2;
    *(void *)(*(void *)(*(void *)(v8 + 40) + 8) + 24) = a3;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSAInterfaceBlock_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAInterfaceBlock_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

void __glpSAInterfaceBlock_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
}

void __glpSAInterfaceBlock_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
}

uint64_t glpSAStatement(uint64_t a1)
{
  return a1;
}

uint64_t glpSADeref(uint64_t a1, uint64_t a2)
{
  uint64_t Offset = glpDerefNodeGetOffset(a2);
  uint64_t v5 = glpSANode(a1, Offset);
  if (v5 == -1)
  {
    return glpSAFailed();
  }
  else
  {
    glpDerefNodeSetOffset(a2, v5);
    return a2;
  }
}

uint64_t glpSetLineNumber(uint64_t result, int a2)
{
  *(_DWORD *)(result + 300) = a2;
  return result;
}

char *glpSetFilename(uint64_t a1, char *__s)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 784);
  strlen(__s);
  uint64_t v5 = (char *)glpCompilerPoolAlloc(v4);
  uint64_t result = strcpy(v5, __s);
  *(void *)(a1 + 304) = result;
  return result;
}

char *glpSetFileNumber(uint64_t a1, int a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  snprintf_l(__s, 0x100uLL, 0, "%d", a2);
  return glpSetFilename(a1, __s);
}

uint64_t glpGetFilename(uint64_t a1)
{
  return *(void *)(a1 + 304);
}

uint64_t glpGetLineNumber(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t glpIncLineNumber(uint64_t result)
{
  return result;
}

uint64_t glpDecLineNumber(uint64_t result)
{
  return result;
}

void glpLexerFatalError()
{
}

uint64_t yylex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (!*(_DWORD *)(a3 + 80))
  {
    *(_DWORD *)(a3 + 80) = 1;
    if (!*(_DWORD *)(a3 + 84)) {
      *(_DWORD *)(a3 + 84) = 1;
    }
    if (!*(void *)(a3 + 8)) {
      *(void *)(a3 + 8) = *MEMORY[0x263EF8350];
    }
    if (!*(void *)(a3 + 16)) {
      *(void *)(a3 + 16) = *MEMORY[0x263EF8358];
    }
    uint64_t v5 = *(void *)(a3 + 40);
    if (!v5 || (uint64_t v6 = *(void *)(a3 + 24), (v7 = *(void *)(v5 + 8 * v6)) == 0))
    {
      yyensure_buffer_stack((void *)a3);
      uint64_t buffer = yy_create_buffer(*(void *)(a3 + 8), 0x4000, a3);
      uint64_t v4 = a1;
      uint64_t v6 = *(void *)(a3 + 24);
      *(void *)(*(void *)(a3 + 40) + 8 * v6) = buffer;
      uint64_t v5 = *(void *)(a3 + 40);
      uint64_t v7 = *(void *)(v5 + 8 * v6);
    }
    *(void *)(a3 + 56) = *(void *)(v7 + 32);
    uint64_t v10 = *(unsigned char **)(v7 + 16);
    *(void *)(a3 + 72) = v10;
    *(void *)(a3 + 136) = v10;
    *(void *)(a3 + 8) = **(void **)(v5 + 8 * v6);
    *(unsigned char *)(a3 + 48) = *v10;
  }
  unsigned __int8 v11 = (void *)(a3 + 72);
  unint64_t v12 = (unsigned char **)(a3 + 120);
  unint64_t v13 = (_DWORD *)(v4 + 16);
  while (1)
  {
LABEL_13:
    uint64_t v14 = *(unsigned __int8 **)(a3 + 72);
    *uint64_t v14 = *(unsigned char *)(a3 + 48);
    int v15 = *(_DWORD *)(a3 + 84);
    uint64_t v16 = v14;
    do
    {
LABEL_14:
      uint64_t v17 = yy_ec[*v16];
      if (yy_accept[v15])
      {
        *(_DWORD *)(a3 + 112) = v15;
        *(void *)(a3 + 120) = v16;
      }
      uint64_t v18 = v15;
      uint64_t v19 = yy_base[v15] + v17;
      if (v15 != (__int16)yy_chk[v19])
      {
        do
        {
          uint64_t v18 = yy_def[v18];
          if (v18 >= 876) {
            uint64_t v17 = *((unsigned __int8 *)&yy_meta + v17);
          }
          uint64_t v19 = yy_base[v18] + v17;
        }
        while (yy_chk[v19] != (unsigned __int16)v18);
      }
      int v15 = yy_nxt[v19];
      ++v16;
    }
    while (v15 != 875);
    while (2)
    {
      int v20 = *(_DWORD *)(a3 + 112);
      uint64_t v21 = v12;
LABEL_22:
      __n128 v22 = *v21;
      int v23 = (__int16)yy_accept[v20];
      *(void *)(a3 + 136) = v14;
      *(void *)(a3 + 64) = v22 - v14;
      *(unsigned char *)(a3 + 48) = *v22;
      *__n128 v22 = 0;
      *(void *)(a3 + 72) = v22;
LABEL_23:
      switch(v23)
      {
        case 0:
          *__n128 v22 = *(unsigned char *)(a3 + 48);
          continue;
        case 1:
          if (*(_DWORD *)(*(void *)a3 + 756) == 3) {
            return 0;
          }
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 310;
        case 2:
          if (*(_DWORD *)(*(void *)a3 + 756) == 3) {
            return 0;
          }
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 309;
        case 3:
          if (*(_DWORD *)(*(void *)a3 + 756) == 3) {
            return 0;
          }
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 428;
        case 4:
          if (*(_DWORD *)(*(void *)a3 + 756) == 3) {
            return 0;
          }
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 429;
        case 5:
          if (*(_DWORD *)(*(void *)a3 + 756) == 3) {
            return 0;
          }
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 431;
        case 6:
          if (*(_DWORD *)(*(void *)a3 + 756) == 3) {
            return 0;
          }
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 430;
        case 7:
        case 10:
        case 20:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 46:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 86:
        case 87:
        case 90:
        case 91:
        case 92:
        case 94:
        case 96:
        case 118:
        case 122:
        case 123:
        case 124:
        case 128:
        case 130:
        case 131:
        case 136:
        case 137:
        case 143:
        case 145:
        case 146:
        case 150:
        case 153:
        case 159:
        case 160:
        case 161:
        case 162:
        case 163:
        case 164:
        case 165:
        case 170:
        case 171:
        case 174:
        case 175:
        case 176:
        case 178:
        case 180:
        case 205:
          uint64_t v41 = *(void *)a3;
          goto LABEL_47;
        case 8:
        case 17:
        case 19:
        case 38:
        case 39:
        case 40:
        case 41:
        case 43:
        case 44:
        case 45:
        case 47:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 57:
        case 58:
        case 59:
        case 80:
        case 82:
        case 84:
        case 101:
        case 116:
        case 117:
        case 120:
        case 126:
        case 139:
        case 142:
        case 148:
        case 149:
        case 151:
        case 154:
        case 156:
        case 157:
        case 158:
        case 168:
        case 169:
        case 181:
        case 190:
          uint64_t v50 = *(void *)a3;
          goto LABEL_54;
        case 9:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 258;
        case 11:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 260;
        case 12:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 263;
        case 13:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 271;
        case 14:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 272;
        case 15:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 273;
        case 16:
          unsigned int v59 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          if (v59 <= 5) {
            goto LABEL_49;
          }
          return 342;
        case 18:
          unsigned int v60 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          if (v60 <= 5) {
            goto LABEL_49;
          }
          return 290;
        case 21:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 259;
        case 22:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 264;
        case 23:
          unsigned int v61 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          if (v61 <= 5) {
            goto LABEL_49;
          }
          return 343;
        case 24:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 269;
        case 37:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 265;
        case 42:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 266;
        case 48:
          uint64_t v50 = *(void *)a3;
          if (*(_DWORD *)(*(void *)a3 + 40) < 6u) {
            goto LABEL_54;
          }
          *(void *)(v4 + 8) = *(void *)(v50 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 339;
        case 49:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 261;
        case 50:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 267;
        case 56:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 306;
        case 60:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 268;
        case 79:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 291;
        case 81:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 293;
        case 83:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 262;
        case 85:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 289;
        case 88:
          unsigned int v62 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v62 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 322;
        case 89:
          unsigned int v63 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v63 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 327;
        case 93:
          unsigned int v64 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v64 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 323;
        case 95:
          unsigned int v65 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v65 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 324;
        case 97:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 274;
        case 98:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 275;
        case 99:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 276;
        case 100:
          uint64_t v41 = *(void *)a3;
          if (*(_DWORD *)(*(void *)a3 + 756) == 3 && *(_DWORD *)(v41 + 620) == 3 && *(_DWORD *)(v41 + 40) < 6u) {
            goto LABEL_47;
          }
          *(void *)(v4 + 8) = *(void *)(v41 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 347;
        case 102:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 308;
        case 103:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          goto LABEL_121;
        case 104:
          unsigned int v66 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v66 < 6) {
            goto LABEL_50;
          }
LABEL_121:
          *(_DWORD *)(v43 + 20) = 1;
          return 280;
        case 105:
          unsigned int v67 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v67 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 281;
        case 106:
          unsigned int v68 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v68 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 282;
        case 107:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          goto LABEL_130;
        case 108:
          unsigned int v69 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v69 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 283;
        case 109:
          unsigned int v70 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v70 < 6) {
            goto LABEL_50;
          }
LABEL_130:
          *(_DWORD *)(v43 + 20) = 1;
          return 284;
        case 110:
          unsigned int v71 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v71 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 285;
        case 111:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          goto LABEL_139;
        case 112:
          unsigned int v72 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v72 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 286;
        case 113:
          unsigned int v73 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v73 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 287;
        case 114:
          unsigned int v74 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v74 < 6) {
            goto LABEL_50;
          }
LABEL_139:
          *(_DWORD *)(v43 + 20) = 1;
          return 288;
        case 115:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 307;
        case 119:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 292;
        case 121:
          uint64_t v50 = *(void *)a3;
          if (*(_DWORD *)(*(void *)a3 + 40) < 6u) {
            goto LABEL_54;
          }
          uint64_t v42 = *(void *)(v50 + 344);
          goto LABEL_48;
        case 125:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 305;
        case 127:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 270;
        case 129:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 299;
        case 132:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 303;
        case 133:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 300;
        case 134:
          unsigned int v75 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v75 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 317;
        case 135:
          unsigned int v76 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v76 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 320;
        case 138:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 345;
        case 140:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 304;
        case 141:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 301;
        case 144:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 302;
        case 147:
          unsigned int v77 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v77 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 315;
        case 152:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 296;
        case 155:
          uint64_t v50 = *(void *)a3;
          if (*(_DWORD *)(*(void *)a3 + 40) < 6u)
          {
LABEL_54:
            glpPaReservedWord(v50);
            return 0;
          }
          else
          {
            *(void *)(v4 + 8) = *(void *)(v50 + 344);
            *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
            return 341;
          }
        case 166:
          unsigned int v78 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v78 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 340;
        case 167:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 294;
        case 172:
          unsigned int v79 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v79 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 330;
        case 173:
          unsigned int v80 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v80 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 335;
        case 177:
          unsigned int v81 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v81 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 331;
        case 179:
          unsigned int v82 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v82 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 332;
        case 182:
          unsigned int v83 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v83 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 312;
        case 183:
          unsigned int v84 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v84 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 313;
        case 184:
          unsigned int v85 = *(_DWORD *)(*(void *)a3 + 40);
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          uint64_t v43 = *(void *)a3;
          if (v85 < 6) {
            goto LABEL_50;
          }
          *(_DWORD *)(v43 + 20) = 1;
          return 314;
        case 185:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 295;
        case 186:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 277;
        case 187:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 278;
        case 188:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 279;
        case 189:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          *(_DWORD *)(*(void *)a3 + 20) = 1;
          return 297;
        case 191:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 298;
        case 192:
          *(_DWORD *)uint64_t v4 = 1;
          goto LABEL_187;
        case 193:
          *(_DWORD *)uint64_t v4 = 0;
LABEL_187:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 381;
        case 194:
        case 195:
        case 197:
          uint64_t v51 = *(const char **)(a3 + 136);
          uint64_t v52 = v4;
          int v53 = v51[strlen(v51) - 1] & 0xDF;
          *(_DWORD *)uint64_t v52 = strtoul_l(v51, 0, 0, 0);
          *(void *)(v52 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v52 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          if (v53 == 85) {
            return 337;
          }
          else {
            return 380;
          }
        case 196:
          uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(*(void *)a3 + 784));
          uint64_t v87 = *(void *)a3;
          StringZ = glpMakeStringZ(*(const char **)(*(void *)a3 + 344));
          glpMakeSourceLocation((uint64_t)StringZ, v89, *(_DWORD *)(v87 + 340), v119);
          glpLogMessage(InfoLog, 0, (uint64_t)v119, "'%s' : Invalid Octal number. ", v90, v91, v92, v93, *(void *)(a3 + 136));
          glpParseRecover(*(void *)a3);
          return 0;
        case 198:
        case 199:
        case 200:
          uint64_t v54 = v4;
          *(float *)uint64_t v4 = strtof_l(*(const char **)(a3 + 136), 0, 0);
          *(void *)(v54 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v54 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 379;
        case 201:
        case 202:
        case 203:
          uint64_t v55 = v4;
          *(double *)uint64_t v4 = strtod_l(*(const char **)(a3 + 136), 0, 0);
          *(void *)(v55 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v55 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 354;
        case 204:
          uint64_t v41 = *(void *)a3;
          if (*(_DWORD *)(*(void *)a3 + 756) == 3 && *(_DWORD *)(v41 + 760) == 3) {
            return 0;
          }
LABEL_47:
          uint64_t v42 = *(void *)(v41 + 344);
LABEL_48:
          *(void *)(v4 + 8) = v42;
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
LABEL_49:
          uint64_t v43 = *(void *)a3;
LABEL_50:
          uint64_t v44 = *(void *)(v43 + 784);
          unsigned int v45 = (char **)v4;
          strlen(*(const char **)(a3 + 136));
          uint64_t v46 = (char *)glpCompilerPoolAlloc(v44);
          *unsigned int v45 = v46;
          strcpy(v46, *(const char **)(a3 + 136));
          uint64_t v47 = *(void *)a3;
          uint64_t v48 = *v45;
          return glpPaIdentOrType(v47, v48);
        case 206:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 393;
        case 207:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 425;
        case 208:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 401;
        case 209:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 386;
        case 210:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 416;
        case 211:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 403;
        case 212:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 412;
        case 213:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 415;
        case 214:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 390;
        case 215:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 427;
        case 216:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 419;
        case 217:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 394;
        case 218:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 420;
        case 219:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 395;
        case 220:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 426;
        case 221:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 391;
        case 222:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 400;
        case 223:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 421;
        case 224:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 397;
        case 225:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 418;
        case 226:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 385;
        case 227:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 396;
        case 228:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 422;
        case 229:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 383;
        case 230:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 398;
        case 231:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 387;
        case 232:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 389;
        case 233:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 423;
        case 234:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 388;
        case 235:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 384;
        case 236:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 399;
        case 237:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 424;
        case 238:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 402;
        case 239:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 392;
        case 240:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 417;
        case 241:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 406;
        case 242:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 407;
        case 243:
          *(void *)(v4 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 409;
        case 244:
        case 254:
        case 255:
          goto LABEL_13;
        case 245:
          int v37 = v13;
          uint64_t v115 = v4;
          uint64_t v117 = v12;
          __n128 v38 = v11;
          glpPaParseComment(*(void *)a3, v13);
          unint64_t v13 = v37;
          uint64_t v4 = v115;
          unint64_t v12 = v117;
          unsigned __int8 v11 = v38;
          goto LABEL_13;
        case 246:
          uint64_t v94 = *(void *)a3;
          *(_DWORD *)(v94 + 20) = 0;
          *(void *)(v4 + 8) = *(void *)(v94 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 414;
        case 247:
          uint64_t v95 = *(void *)a3;
          *(_DWORD *)(v95 + 20) = 0;
          *(void *)(v4 + 8) = *(void *)(v95 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 408;
        case 248:
          uint64_t v96 = *(void *)a3;
          *(_DWORD *)(v96 + 20) = 0;
          *(void *)(v4 + 8) = *(void *)(v96 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 413;
        case 249:
          uint64_t v97 = *(void *)a3;
          *(_DWORD *)(v97 + 20) = 0;
          *(_DWORD *)(v97 + 4) = 1;
          *(void *)(v4 + 8) = *(void *)(v97 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 404;
        case 250:
          uint64_t v98 = *(void *)a3;
          *(_DWORD *)(v98 + 20) = 0;
          *(_DWORD *)(v98 + 4) = 0;
          *(void *)(v4 + 8) = *(void *)(v98 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 405;
        case 251:
          uint64_t v99 = *(void *)a3;
          if (*(_DWORD *)(*(void *)a3 + 4)) {
            *(_DWORD *)(v99 + 20) = 0;
          }
          *(void *)(v4 + 8) = *(void *)(v99 + 344);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 411;
        case 252:
          *(_DWORD *)(a3 + 84) = 3;
          return 410;
        case 253:
          *(_DWORD *)(a3 + 84) = 1;
          uint64_t v100 = v4;
          strlen(*(const char **)(a3 + 136));
          uint64_t v101 = (char *)glpCompilerPoolAlloc(*(void *)(*(void *)a3 + 784));
          *(void *)uint64_t v100 = v101;
          strcpy(v101, *(const char **)(a3 + 136));
          *(void *)(v100 + 8) = *(void *)(*(void *)a3 + 344);
          *(_DWORD *)(v100 + 16) = *(_DWORD *)(*(void *)a3 + 340);
          return 382;
        case 256:
          uint64_t v102 = glpCompilerGetInfoLog(*(void *)(*(void *)a3 + 784));
          StringBuffer = (uint64_t *)glpLogGetStringBuffer(v102);
          glpStringBufferAppendFormat(StringBuffer, "FLEX: Unknown char %s\n", v104, v105, v106, v107, v108, v109, *(void *)(a3 + 136));
          return 0;
        case 257:
          uint64_t v113 = v13;
          uint64_t v39 = v4;
          __n128 v40 = v11;
          int v118 = v12;
          fwrite(*(const void **)(a3 + 136), *(void *)(a3 + 64), 1uLL, *(FILE **)(a3 + 16));
          unint64_t v13 = v113;
          unint64_t v12 = v118;
          unsigned __int8 v11 = v40;
          uint64_t v4 = v39;
          goto LABEL_13;
        case 258:
          uint64_t v24 = *(void *)(a3 + 136);
          *__n128 v22 = *(unsigned char *)(a3 + 48);
          uint64_t v25 = *(void *)(a3 + 40);
          uint64_t v26 = *(void *)(a3 + 24);
          uint64_t v27 = *(void *)(v25 + 8 * v26);
          if (*(_DWORD *)(v27 + 64))
          {
            uint64_t v28 = *(void *)(a3 + 56);
          }
          else
          {
            uint64_t v28 = *(void *)(v27 + 32);
            *(void *)(a3 + 56) = v28;
            *(void *)uint64_t v27 = *(void *)(a3 + 8);
            uint64_t v27 = *(void *)(v25 + 8 * v26);
            *(_DWORD *)(v27 + 64) = 1;
          }
          int v112 = v13;
          uint64_t v114 = v4;
          uint64_t v116 = v12;
          uint64_t v111 = v11;
          if (*v11 <= (unint64_t)(*(void *)(v27 + 8) + v28))
          {
            *(void *)(a3 + 72) = *(void *)(a3 + 136) + ~v24 + (int)v22;
            int previous_state = yy_get_previous_state(a3);
            if (yy_accept[previous_state])
            {
              uint64_t v32 = *(void *)(a3 + 72);
              *(_DWORD *)(a3 + 112) = previous_state;
              *(void *)(a3 + 120) = v32;
            }
            uint64_t v33 = previous_state;
            uint64_t v34 = yy_base[previous_state] + 1;
            uint64_t v4 = v114;
            unint64_t v12 = v116;
            unsigned __int8 v11 = v111;
            unint64_t v13 = v112;
            if (previous_state != (__int16)yy_chk[v34])
            {
              do
              {
                int v35 = (unsigned __int16)yy_def[v33];
                uint64_t v33 = (__int16)v35;
                uint64_t v34 = yy_base[(__int16)v35] + 1;
              }
              while (v35 != yy_chk[v34]);
            }
            int v36 = (unsigned __int16)yy_nxt[v34];
            uint64_t v14 = *(unsigned __int8 **)(a3 + 136);
            if (yy_nxt[v34] && v36 != 875)
            {
              int v15 = (__int16)v36;
              uint64_t v16 = (unsigned __int8 *)(*v111 + 1);
              *uint64_t v111 = v16;
              goto LABEL_14;
            }
            continue;
          }
          int v110 = v24;
          next_uint64_t buffer = yy_get_next_buffer((void *)a3);
          if (next_buffer == 1)
          {
            *(_DWORD *)(a3 + 88) = 0;
            *(void *)(a3 + 72) = *(void *)(a3 + 136);
            int v30 = *(_DWORD *)(a3 + 84);
            if (v30 >= 1) {
              --v30;
            }
            int v23 = (v30 >> 1) + 259;
            uint64_t v4 = v114;
            unint64_t v12 = v116;
            unsigned __int8 v11 = v111;
            unint64_t v13 = v112;
            goto LABEL_23;
          }
          uint64_t v4 = v114;
          unint64_t v12 = v116;
          unint64_t v13 = v112;
          if (next_buffer == 2)
          {
            *(void *)(a3 + 72) = *(void *)(*(void *)(*(void *)(a3 + 40) + 8 * *(void *)(a3 + 24)) + 8)
                                 + *(void *)(a3 + 56);
            int v20 = yy_get_previous_state(a3);
            unint64_t v13 = v112;
            uint64_t v4 = v114;
            unint64_t v12 = v116;
            uint64_t v14 = *(unsigned __int8 **)(a3 + 136);
            unsigned __int8 v11 = v111;
            uint64_t v21 = (unsigned char **)v111;
            goto LABEL_22;
          }
          unsigned __int8 v11 = v111;
          if (!next_buffer)
          {
            *(void *)(a3 + 72) = *(void *)(a3 + 136) + ~v110 + (int)v22;
            int v15 = yy_get_previous_state(a3);
            unsigned __int8 v11 = v111;
            unint64_t v13 = v112;
            uint64_t v4 = v114;
            unint64_t v12 = v116;
            uint64_t v16 = *(unsigned __int8 **)(a3 + 72);
            uint64_t v14 = *(unsigned __int8 **)(a3 + 136);
            goto LABEL_14;
          }
          break;
        case 259:
        case 260:
          uint64_t v56 = *(void *)a3;
          *(_DWORD *)(*(void *)a3 + 16) = 1;
          uint64_t v57 = *(void *)(a3 + 40);
          if (v57) {
            char v58 = *(void ***)(v57 + 8 * *(void *)(a3 + 24));
          }
          else {
            char v58 = 0;
          }
          yy_delete_buffer(v58, *(void *)(v56 + 24));
          return 0;
        default:
          glpLexerFatalError();
      }
      break;
    }
  }
}

double yyensure_buffer_stack(void *a1)
{
  int v2 = (void *)a1[5];
  if (v2)
  {
    uint64_t v3 = a1[4];
    if (a1[3] >= (unint64_t)(v3 - 1))
    {
      uint64_t v4 = v3 + 8;
      uint64_t v5 = (char *)malloc_type_realloc(v2, 8 * (v3 + 8), 0x2BDC8648uLL);
      if (v5)
      {
        a1[5] = v5;
        uint64_t v6 = &v5[8 * a1[4]];
        double result = 0.0;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *(_OWORD *)uint64_t v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        a1[4] = v4;
        return result;
      }
LABEL_8:
      abort();
    }
  }
  else
  {
    uint64_t v8 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
    if (!v8) {
      goto LABEL_8;
    }
    a1[5] = v8;
    *uint64_t v8 = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 3) = xmmword_2393D2C80;
  }
  return result;
}

uint64_t yy_create_buffer(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = malloc_type_malloc(0x48uLL, 0x7081ABB9uLL);
  if (!v6 || (v7 = (uint64_t)v6, v6[6] = a2, (uint64_t v8 = malloc_type_malloc(a2 + 2, 0x7081ABB9uLL)) == 0)) {
    abort();
  }
  *(void *)(v7 + 8) = v8;
  *(_DWORD *)(v7 + 40) = 1;
  yy_init_buffer(v7, a1, a3);
  return v7;
}

BOOL glpIsExtensionEnabled(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 616) != 3;
}

uint64_t glpPaIdentOrType(uint64_t a1, char *__s)
{
  if (*(_DWORD *)(a1 + 20)) {
    return 377;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  unsigned int v6 = strlen(__s);
  if (v6 >> 5 >= v6)
  {
    unsigned int v8 = v6;
  }
  else
  {
    unsigned int v7 = v6;
    unsigned int v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + __s[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  if (!glpStringHashGet(v5, __s, v6 | ((unint64_t)v8 << 32))) {
    return 377;
  }
  *(_DWORD *)(a1 + 20) = 1;
  return 378;
}

uint64_t glpPaReservedWord(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a1 + 784));
  uint64_t v4 = *(const char **)(a1 + 344);
  unsigned int v5 = strlen(v4);
  if (v5 >> 5 >= v5)
  {
    unsigned int v7 = v5;
  }
  else
  {
    unsigned int v6 = v5;
    unsigned int v7 = v5;
    do
    {
      v7 ^= 32 * v7 + (v7 >> 2) + v4[v6 - 1];
      v6 += ~(v5 >> 5);
    }
    while (v6 > v5 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v4, v5 | ((unint64_t)v7 << 32), *(_DWORD *)(a1 + 340), v13);
  glpLogMessage(InfoLog, 0, (uint64_t)v13, "'%s' : Reserved word. ", v8, v9, v10, v11, *(void *)(v2 + 136));
  return glpParseRecover(a1);
}

const char *glpMakeStringZ(const char *a1)
{
  unsigned int v2 = strlen(a1);
  if (v2 >> 5 < v2)
  {
    unsigned int v3 = v2;
    unsigned int v4 = v2;
    do
    {
      v4 ^= 32 * v4 + (v4 >> 2) + a1[v3 - 1];
      v3 += ~(v2 >> 5);
    }
    while (v3 > v2 >> 5);
  }
  return a1;
}

uint64_t glpPaParseComment(uint64_t a1, _DWORD *a2)
{
void yy_delete_buffer(void **a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a2 + 40);
    if (v3) {
      char v4 = *(void ***)(v3 + 8 * *(void *)(a2 + 24));
    }
    else {
      char v4 = 0;
    }
    if (v4 == a1) {
      *(void *)(v3 + 8 * *(void *)(a2 + 24)) = 0;
    }
    if (*((_DWORD *)a1 + 10)) {
      free(a1[1]);
    }
    free(a1);
  }
}

uint64_t yy_get_previous_state(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 84);
  unsigned int v2 = *(unsigned char **)(a1 + 136);
  uint64_t v3 = *(unsigned char **)(a1 + 72);
  if (v2 < v3)
  {
    do
    {
      if (*v2) {
        uint64_t v4 = yy_ec[*v2];
      }
      else {
        uint64_t v4 = 1u;
      }
      if (yy_accept[(int)v1])
      {
        *(_DWORD *)(a1 + 112) = v1;
        *(void *)(a1 + 120) = v2;
      }
      uint64_t v5 = (int)v1;
      uint64_t v6 = yy_base[(int)v1] + v4;
      if (v1 != (__int16)yy_chk[v6])
      {
        do
        {
          uint64_t v5 = yy_def[v5];
          if (v5 >= 876) {
            uint64_t v4 = *((unsigned __int8 *)&yy_meta + v4);
          }
          uint64_t v6 = yy_base[v5] + v4;
        }
        while (yy_chk[v6] != (unsigned __int16)v5);
      }
      uint64_t v1 = yy_nxt[v6];
      ++v2;
    }
    while (v2 != v3);
  }
  return v1;
}

uint64_t yy_get_next_buffer(void *a1)
{
  uint64_t v1 = *(void *)(a1[5] + 8 * a1[3]);
  unsigned int v2 = *(unsigned char **)(v1 + 8);
  unint64_t v3 = a1[9];
  if (v3 > (unint64_t)&v2[a1[7] + 1]) {
    goto LABEL_38;
  }
  uint64_t v5 = (char *)a1[17];
  if (*(_DWORD *)(v1 + 60))
  {
    int v6 = ~v5 + v3;
    if (v6 >= 1)
    {
      int v7 = ~v5 + v3;
      do
      {
        char v8 = *v5++;
        *v2++ = v8;
        --v7;
      }
      while (v7);
      uint64_t v1 = *(void *)(a1[5] + 8 * a1[3]);
    }
    uint64_t v9 = v6;
    if (*(_DWORD *)(v1 + 64) == 2)
    {
      a1[7] = 0;
    }
    else
    {
      int v11 = ~v6;
      int v12 = *(_DWORD *)(v1 + 24);
      unsigned int v13 = v12 + ~v6;
      if (!v13)
      {
        uint64_t v14 = (char *)a1[9];
        while (*(_DWORD *)(v1 + 40))
        {
          int v15 = *(void **)(v1 + 8);
          int v16 = 2 * v12;
          *(_DWORD *)(v1 + 24) = v16;
          uint64_t v17 = (char *)malloc_type_realloc(v15, v16 + 2, 0x2BDC8648uLL);
          if (!v17) {
            goto LABEL_36;
          }
          *(void *)(v1 + 8) = v17;
          uint64_t v14 = &v17[(int)v14 - (int)v15];
          a1[9] = v14;
          uint64_t v1 = *(void *)(a1[5] + 8 * a1[3]);
          int v12 = *(_DWORD *)(v1 + 24);
          unsigned int v13 = v12 + v11;
          if (v12 + v11) {
            goto LABEL_17;
          }
        }
        *(void *)(v1 + 8) = 0;
        goto LABEL_38;
      }
LABEL_17:
      if (v13 >= 0x2000) {
        unint64_t v18 = 0x2000;
      }
      else {
        unint64_t v18 = v13;
      }
      unint64_t v19 = yylex_CPP(*a1 + 40, *(void *)(v1 + 8) + v6, v18);
      a1[7] = v19;
      if (v19)
      {
        if (v19 >= v18) {
          goto LABEL_38;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1[5] + 8 * a1[3]) + 8) + v6 + v19) = 32;
        uint64_t v20 = a1[7];
        BOOL v21 = __CFADD__(v20, 1);
        unint64_t v22 = v20 + 1;
        a1[7] = v22;
        uint64_t v1 = *(void *)(a1[5] + 8 * a1[3]);
        *(void *)(v1 + 32) = v22;
        if (!v21)
        {
          uint64_t v10 = 0;
LABEL_29:
          unint64_t v23 = v22 + v6;
          if (v23 <= *(int *)(v1 + 24))
          {
            uint64_t v29 = *(void *)(v1 + 8);
            goto LABEL_34;
          }
          size_t v24 = v23 + (v22 >> 1);
          uint64_t v25 = malloc_type_realloc(*(void **)(v1 + 8), v24, 0x2BDC8648uLL);
          if (!v25) {
LABEL_36:
          }
            abort();
          uint64_t v26 = a1[5];
          uint64_t v27 = a1[3];
          *(void *)(*(void *)(v26 + 8 * v27) + 8) = v25;
          uint64_t v28 = *(void *)(v26 + 8 * v27);
          uint64_t v29 = *(void *)(v28 + 8);
          if (v29)
          {
            *(_DWORD *)(v28 + 24) = v24 - 2;
            unint64_t v23 = a1[7] + v9;
LABEL_34:
            a1[7] = v23;
            *(unsigned char *)(v29 + v23) = 0;
            *(unsigned char *)(a1[7] + *(void *)(*(void *)(a1[5] + 8 * a1[3]) + 8) + 1) = 0;
            a1[17] = *(void *)(*(void *)(a1[5] + 8 * a1[3]) + 8);
            return v10;
          }
LABEL_38:
          glpLexerFatalError();
        }
LABEL_26:
        if (v6)
        {
          unint64_t v22 = 0;
          uint64_t v10 = 2;
          *(_DWORD *)(v1 + 64) = 2;
        }
        else
        {
          yyrestart(a1[1], (uint64_t)a1);
          unint64_t v22 = a1[7];
          uint64_t v1 = *(void *)(a1[5] + 8 * a1[3]);
          uint64_t v10 = 1;
        }
        goto LABEL_29;
      }
      a1[7] = 0;
      uint64_t v1 = *(void *)(a1[5] + 8 * a1[3]);
    }
    *(void *)(v1 + 32) = 0;
    goto LABEL_26;
  }
  if (v3 - (void)v5 == 1) {
    return 1;
  }
  else {
    return 2;
  }
}

int *yyrestart(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4 && (uint64_t v5 = *(void *)(a2 + 24), *(void *)(v4 + 8 * v5))
    || (yyensure_buffer_stack((void *)a2),
        uint64_t buffer = yy_create_buffer(*(void *)(a2 + 8), 0x4000, a2),
        uint64_t v5 = *(void *)(a2 + 24),
        *(void *)(*(void *)(a2 + 40) + 8 * v5) = buffer,
        (uint64_t v4 = *(void *)(a2 + 40)) != 0))
  {
    uint64_t v7 = *(void *)(v4 + 8 * v5);
  }
  else
  {
    uint64_t v7 = 0;
  }
  double result = yy_init_buffer(v7, a1, a2);
  uint64_t v9 = *(void *)(a2 + 40);
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = *(void *)(v9 + 8 * v10);
  *(void *)(a2 + 56) = *(void *)(v11 + 32);
  int v12 = *(unsigned char **)(v11 + 16);
  *(void *)(a2 + 72) = v12;
  *(void *)(a2 + 136) = v12;
  *(void *)(a2 + 8) = **(void **)(v9 + 8 * v10);
  *(unsigned char *)(a2 + 48) = *v12;
  return result;
}

int *yy_init_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *__error();
  yy_flush_buffer(a1, a3);
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 1;
  uint64_t v7 = *(void *)(a3 + 40);
  if (v7) {
    uint64_t v7 = *(void *)(v7 + 8 * *(void *)(a3 + 24));
  }
  if (v7 != a1) {
    *(void *)(a1 + 52) = 1;
  }
  *(_DWORD *)(a1 + 44) = 0;
  double result = __error();
  *double result = v6;
  return result;
}

uint64_t yy_flush_buffer(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(void *)(result + 32) = 0;
    **(unsigned char **)(result + 8) = 0;
    *(unsigned char *)(*(void *)(result + 8) + 1) = 0;
    *(void *)(result + 16) = *(void *)(result + 8);
    *(_DWORD *)(result + 48) = 1;
    *(_DWORD *)(result + 64) = 0;
    uint64_t v2 = *(void *)(a2 + 40);
    if (v2) {
      uint64_t v3 = *(void *)(v2 + 8 * *(void *)(a2 + 24));
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3 == result)
    {
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t v5 = *(void *)(v2 + 8 * v4);
      *(void *)(a2 + 56) = *(void *)(v5 + 32);
      int v6 = *(unsigned char **)(v5 + 16);
      *(void *)(a2 + 72) = v6;
      *(void *)(a2 + 136) = v6;
      *(void *)(a2 + 8) = **(void **)(v2 + 8 * v4);
      *(unsigned char *)(a2 + 48) = *v6;
    }
  }
  return result;
}

void yypop_buffer_state(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void ***)(v1 + 8 * *(void *)(a1 + 24));
    if (v3)
    {
      yy_delete_buffer(v3, a1);
      uint64_t v4 = *(void *)(a1 + 24);
      *(void *)(*(void *)(a1 + 40) + 8 * v4) = 0;
      if (v4) {
        *(void *)(a1 + 24) = --v4;
      }
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 8 * v4);
        if (v6)
        {
          *(void *)(a1 + 56) = *(void *)(v6 + 32);
          uint64_t v7 = *(unsigned char **)(v6 + 16);
          *(void *)(a1 + 72) = v7;
          *(void *)(a1 + 136) = v7;
          *(void *)(a1 + 8) = **(void **)(v5 + 8 * v4);
          *(unsigned char *)(a1 + 48) = *v7;
          *(_DWORD *)(a1 + 88) = 1;
        }
      }
    }
  }
}

uint64_t yylex_init(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = malloc_type_malloc(0x98uLL, 0x7081ABB9uLL);
    if (!v2) {
      abort();
    }
    uint64_t v3 = v2;
    uint64_t result = 0;
    *a1 = (uint64_t)v3;
    v3[18] = 0;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *(_OWORD *)uint64_t v3 = 0u;
    uint64_t v5 = *a1;
    *(_DWORD *)(v5 + 92) = 0;
    *(_DWORD *)(v5 + 96) = 0;
    *(void *)(v5 + 104) = 0;
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    *(void *)(v5 + 40) = 0;
    *(void *)(v5 + 72) = 0;
    *(void *)(v5 + 80) = 0;
  }
  else
  {
    *__error() = 22;
    return 1;
  }
  return result;
}

uint64_t yylex_destroy(uint64_t a1)
{
  for (unsigned int i = *(void **)(a1 + 40); i; unsigned int i = *(void **)(a1 + 40))
  {
    if (!i[*(void *)(a1 + 24)]) {
      break;
    }
    yy_delete_buffer((void **)i[*(void *)(a1 + 24)], a1);
    *(void *)(*(void *)(a1 + 40) + 8 * *(void *)(a1 + 24)) = 0;
    yypop_buffer_state(a1);
  }
  free(i);
  *(void *)(a1 + 40) = 0;
  free(*(void **)(a1 + 104));
  free((void *)a1);
  return 0;
}

uint64_t glpPaParseStrings(uint64_t a1, uint64_t *a2, int *a3, int a4, int a5)
{
  ScanFromString(a1 + 40, *a2);
  if (a4)
  {
    int v25 = 0;
    if (a4 < 1)
    {
LABEL_6:
      if (!a3)
      {
        int v25 = strlen((const char *)*a2);
        a3 = &v25;
      }
      yyrestart(0, *(void *)(a1 + 24));
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 364) = 0;
      *(void *)(a1 + 384) = a2;
      *(_DWORD *)(a1 + 376) = a4;
      *(void *)(a1 + 368) = a3;
      *(_DWORD *)(a1 + 68) = 0;
      uint64_t NameTable = glpCompilerGetNameTable(*(void *)(a1 + 784));
      *(_DWORD *)(a1 + 40) = glpNameTableGetGLSLVersion(NameTable);
      *(_DWORD *)(a1 + 44) = 0;
      glpInitializeExtensionBehavior(a1);
      if ((**(_DWORD **)(a1 + 368) & 0x80000000) != 0) {
        return 0;
      }
      yyparse(a1);
      if (*(_DWORD *)(a1 + 360) != 1 && !*(_DWORD *)(a1 + 8) && *(int *)(a1 + 12) < 1) {
        return 0;
      }
      if (a5)
      {
        while (1)
        {
          unsigned int v13 = *(void **)(a1 + 56);
          if (!v13) {
            break;
          }
          *(void *)(a1 + 56) = v13[1];
          free(v13);
        }
      }
    }
    else
    {
      uint64_t v10 = a4;
      uint64_t v11 = a2;
      while (*v11)
      {
        ++v11;
        if (!--v10) {
          goto LABEL_6;
        }
      }
      uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a1 + 784));
      int v15 = *(const char **)(a1 + 344);
      unsigned int v16 = strlen(v15);
      if (v16 >> 5 >= v16)
      {
        unsigned int v18 = v16;
      }
      else
      {
        unsigned int v17 = v16;
        unsigned int v18 = v16;
        do
        {
          v18 ^= 32 * v18 + (v18 >> 2) + v15[v17 - 1];
          v17 += ~(v16 >> 5);
        }
        while (v17 > v16 >> 5);
      }
      glpMakeSourceLocation((uint64_t)v15, v16 | ((unint64_t)v18 << 32), *(_DWORD *)(a1 + 340), v24);
      glpLogMessage(InfoLog, 0, (uint64_t)v24, "'' : NULL shader source string ", v20, v21, v22, v23, v24[0]);
      glpParseRecover(a1);
    }
  }
  return 1;
}

void yyerror(uint64_t a1, uint64_t a2, char a3)
{
  if (*(_DWORD *)(a2 + 16))
  {
    if ((*(unsigned char *)(a2 + 392) & 1) == 0) {
      return;
    }
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a2 + 784));
    uint64_t v6 = *(const char **)(a2 + 344);
    unsigned int v7 = strlen(v6);
    if (v7 >> 5 >= v7)
    {
      unsigned int v9 = v7;
    }
    else
    {
      unsigned int v8 = v7;
      unsigned int v9 = v7;
      do
      {
        v9 ^= 32 * v9 + (v9 >> 2) + v6[v8 - 1];
        v8 += ~(v7 >> 5);
      }
      while (v8 > v7 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v6, v7 | ((unint64_t)v9 << 32), *(_DWORD *)(a2 + 340), v25);
    glpLogMessage(InfoLog, 0, (uint64_t)v25, "'premature EOF' : syntax error %s", v20, v21, v22, v23, a3);
  }
  else
  {
    uint64_t v10 = *(void *)(a2 + 24);
    uint64_t v11 = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a2 + 784));
    int v12 = *(const char **)(a2 + 344);
    unsigned int v13 = strlen(v12);
    if (v13 >> 5 >= v13)
    {
      unsigned int v15 = v13;
    }
    else
    {
      unsigned int v14 = v13;
      unsigned int v15 = v13;
      do
      {
        v15 ^= 32 * v15 + (v15 >> 2) + v12[v14 - 1];
        v14 += ~(v13 >> 5);
      }
      while (v14 > v13 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v12, v13 | ((unint64_t)v15 << 32), *(_DWORD *)(a2 + 340), v24);
    glpLogMessage(v11, 0, (uint64_t)v24, "'%s' : syntax error: %s", v16, v17, v18, v19, *(void *)(v10 + 136));
  }
  glpParseRecover(a2);
}

uint64_t **glpCPPWarningToInfoLog(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(v3 + 784));
  uint64_t v5 = *(const char **)(v3 + 344);
  unsigned int v6 = strlen(v5);
  if (v6 >> 5 >= v6)
  {
    unsigned int v8 = v6;
  }
  else
  {
    unsigned int v7 = v6;
    unsigned int v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + v5[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v5, v6 | ((unint64_t)v8 << 32), *(_DWORD *)(v3 + 340), v14);
  return glpLogMessage(InfoLog, 1u, (uint64_t)v14, "%s", v9, v10, v11, v12, a2);
}

uint64_t glpCPPShInfoLogMsg(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(v3 + 784));
  uint64_t v5 = *(const char **)(v3 + 344);
  unsigned int v6 = strlen(v5);
  if (v6 >> 5 >= v6)
  {
    unsigned int v8 = v6;
  }
  else
  {
    unsigned int v7 = v6;
    unsigned int v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + v5[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v5, v6 | ((unint64_t)v8 << 32), *(_DWORD *)(v3 + 340), v14);
  glpLogMessage(InfoLog, 0, (uint64_t)v14, "'' :  %s", v9, v10, v11, v12, a2);
  return glpParseRecover(v3);
}

uint64_t glpCPPErrorToInfoLog(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(v3 + 784));
  uint64_t v5 = *(const char **)(v3 + 344);
  unsigned int v6 = strlen(v5);
  if (v6 >> 5 >= v6)
  {
    unsigned int v8 = v6;
  }
  else
  {
    unsigned int v7 = v6;
    unsigned int v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + v5[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v5, v6 | ((unint64_t)v8 << 32), *(_DWORD *)(v3 + 340), v14);
  glpLogMessage(InfoLog, 0, (uint64_t)v14, "'' : syntax error: %s", v9, v10, v11, v12, a2);
  return glpParseRecover(v3);
}

uint64_t glpHandlePragma(uint64_t a1, const char **a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  unsigned int v7 = *a2;
  if (!strcmp(*a2, "optimize"))
  {
    if (a3 == 4)
    {
      if (!strcmp(a2[1], "("))
      {
        uint64_t v10 = a2[2];
        if (!strcmp(v10, "on"))
        {
          int v12 = 1;
        }
        else
        {
          if (strcmp(v10, "off"))
          {
            uint64_t v9 = "\"on\" or \"off\" expected after '(' for 'optimize' pragma";
            goto LABEL_15;
          }
          int v12 = 0;
        }
        *(_DWORD *)(v6 + 608) = v12;
        uint64_t result = strcmp(a2[3], ")");
        if (!result) {
          return result;
        }
        uint64_t v9 = "\")\" expected to end 'optimize' pragma";
        goto LABEL_15;
      }
      uint64_t v9 = "\"(\" expected after 'optimize' keyword";
    }
    else
    {
      uint64_t v9 = "optimize pragma syntax is incorrect";
    }
LABEL_15:
    return glpCPPShInfoLogMsg(a1, (char)v9);
  }
  if (!strcmp(v7, "debug"))
  {
    if (a3 == 4)
    {
      if (!strcmp(a2[1], "("))
      {
        uint64_t v11 = a2[2];
        if (!strcmp(v11, "on"))
        {
          int v13 = 1;
        }
        else
        {
          if (strcmp(v11, "off"))
          {
            uint64_t v9 = "\"on\" or \"off\" expected after '(' for 'debug' pragma";
            goto LABEL_15;
          }
          int v13 = 0;
        }
        *(_DWORD *)(v6 + 612) = v13;
        uint64_t result = strcmp(a2[3], ")");
        if (!result) {
          return result;
        }
        uint64_t v9 = "\")\" expected to end 'debug' pragma";
        goto LABEL_15;
      }
      uint64_t v9 = "\"(\" expected after 'debug' keyword";
    }
    else
    {
      uint64_t v9 = "debug pragma syntax is incorrect";
    }
    goto LABEL_15;
  }
  uint64_t result = strcmp(v7, "STDGL");
  if (a3 < 2) {
    return result;
  }
  if (result) {
    return result;
  }
  uint64_t result = strcmp(a2[1], "invariant");
  if (result) {
    return result;
  }
  if (*(_DWORD *)(v6 + 40) && *(_DWORD *)v6 == 4)
  {
    uint64_t v9 = "'STDGL invariant' pragma is not allowed in fragment shader except in OpenGL ES 2";
    goto LABEL_15;
  }
  if (a3 != 5)
  {
    uint64_t v9 = "'STDGL invariant' pragma syntax is incorrect";
    goto LABEL_15;
  }
  if (strcmp(a2[2], "("))
  {
    uint64_t v9 = "\"(\" expected after 'invariant' keyword";
    goto LABEL_15;
  }
  if (strcmp(a2[3], "all"))
  {
    uint64_t v9 = "\"all\" expected after '(' for 'STDGL invariant' pragma";
    goto LABEL_15;
  }
  if (strcmp(a2[4], ")"))
  {
    uint64_t v9 = "\")\" expected to end 'STDGL invariant' pragma";
    goto LABEL_15;
  }
  uint64_t v14 = *(void *)(v6 + 784);

  return glpCompilerForceAllOutputsToBeInvariant(v14);
}

uint64_t glpStoreErrMsg(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  StringBuffer = *(uint64_t **)(a1 + 312);
  if (!StringBuffer)
  {
    StringBuffer = glpMakeStringBuffer(&GLP_MALLOC_ALLOCATOR);
    *(void *)(a1 + 312) = StringBuffer;
  }
  return glpStringBufferAppendFormat(StringBuffer, " %s", a3, a4, a5, a6, a7, a8, a2);
}

uint64_t glpGetErrMsg(uint64_t a1)
{
  return glpStringBufferGetCString(*(uint64_t **)(a1 + 312));
}

uint64_t glpResetErrMsg(uint64_t a1)
{
  uint64_t result = glpDestroyStringBuffer(*(uint64_t ***)(a1 + 312));
  *(void *)(a1 + 312) = 0;
  return result;
}

uint64_t **glpUpdateExtensionBehavior(uint64_t a1, char *a2, char *__s1)
{
  int v6 = strcmp(__s1, "require");
  if (!v6)
  {
    int v12 = 0;
    char v13 = 1;
    goto LABEL_15;
  }
  if (!strcmp(__s1, "enable"))
  {
    char v13 = 1;
    int v12 = 1;
    goto LABEL_15;
  }
  if (strcmp(__s1, "disable"))
  {
    if (!strcmp(__s1, "warn"))
    {
      char v13 = 0;
      int v12 = 2;
      goto LABEL_15;
    }
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a1 + 784));
    unsigned int v8 = *(const char **)(a1 + 344);
    unsigned int v9 = strlen(v8);
    if (v9 >> 5 >= v9)
    {
      unsigned int v11 = v9;
    }
    else
    {
      unsigned int v10 = v9;
      unsigned int v11 = v9;
      do
      {
        v11 ^= 32 * v11 + (v11 >> 2) + v8[v10 - 1];
        v10 += ~(v9 >> 5);
      }
      while (v10 > v9 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v8, v9 | ((unint64_t)v11 << 32), *(_DWORD *)(a1 + 340), v43);
    glpLogMessage(InfoLog, 0, (uint64_t)v43, "'' :  behavior '%s' is not supported", v14, v15, v16, v17, (char)__s1);
    glpParseRecover(a1);
  }
  char v13 = 0;
  int v12 = 3;
LABEL_15:
  if (!strcmp(a2, "all"))
  {
    if (v13)
    {
      return (uint64_t **)glpCPPShInfoLogMsg(a1 + 40, (char)"extension 'all' cannot have 'require' or 'enable' behavior");
    }
    else
    {
      for (uint64_t i = 0; i != 38; ++i)
      {
        uint64_t result = (uint64_t **)glpExtensionAllowed(*(void *)(a1 + 784), i);
        if (result)
        {
          *(_DWORD *)(a1 + 616 + 4 * i) = v12;
          uint64_t NameTable = glpCompilerGetNameTable(*(void *)(a1 + 784));
          uint64_t result = (uint64_t **)glpNameTableSetGLSLExtensionBehavior(NameTable, i, v12);
        }
      }
    }
  }
  else
  {
    int v18 = glpExtensionFromString(a2);
    if (v18 == 38 || (unsigned int v19 = v18, !glpExtensionAllowed(*(void *)(a1 + 784), v18)))
    {
      uint64_t v22 = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a1 + 784));
      uint64_t v23 = *(const char **)(a1 + 344);
      unsigned int v24 = strlen(v23);
      unsigned int v25 = v24 >> 5;
      int v26 = ~(v24 >> 5);
      if (v6)
      {
        if (v25 >= v24)
        {
          unsigned int v28 = v24;
        }
        else
        {
          unsigned int v27 = v24;
          unsigned int v28 = v24;
          do
          {
            v28 ^= 32 * v28 + (v28 >> 2) + v23[v27 - 1];
            v27 += v26;
          }
          while (v27 > v25);
        }
        glpMakeSourceLocation((uint64_t)v23, v24 | ((unint64_t)v28 << 32), *(_DWORD *)(a1 + 340), v41);
        return glpLogMessage(v22, 1u, (uint64_t)v41, "extension '%s' is not supported", v33, v34, v35, v36, (char)a2);
      }
      else
      {
        if (v25 >= v24)
        {
          unsigned int v32 = v24;
        }
        else
        {
          unsigned int v31 = v24;
          unsigned int v32 = v24;
          do
          {
            v32 ^= 32 * v32 + (v32 >> 2) + v23[v31 - 1];
            v31 += v26;
          }
          while (v31 > v25);
        }
        glpMakeSourceLocation((uint64_t)v23, v24 | ((unint64_t)v32 << 32), *(_DWORD *)(a1 + 340), v42);
        glpLogMessage(v22, 0, (uint64_t)v42, "'' :  extension '%s' is not supported", v37, v38, v39, v40, (char)a2);
        return (uint64_t **)glpParseRecover(a1);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4 * v19 + 616) = v12;
      uint64_t v20 = glpCompilerGetNameTable(*(void *)(a1 + 784));
      return (uint64_t **)glpNameTableSetGLSLExtensionBehavior(v20, v19, v12);
    }
  }
  return result;
}

uint64_t glpParseContextSetGLSLVersion(uint64_t a1, int a2)
{
  char v2 = a2;
  int v4 = glpGLSLVersionFromInt(a2);
  if (v4 == 10 || (int v5 = v4, !glpGLSLVersionAllowed(*(void *)(a1 + 784), v4)))
  {
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a1 + 784));
    unsigned int v9 = *(const char **)(a1 + 344);
    unsigned int v10 = strlen(v9);
    if (v10 >> 5 >= v10)
    {
      unsigned int v12 = v10;
    }
    else
    {
      unsigned int v11 = v10;
      unsigned int v12 = v10;
      do
      {
        v12 ^= 32 * v12 + (v12 >> 2) + v9[v11 - 1];
        v11 += ~(v10 >> 5);
      }
      while (v11 > v10 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v9, v10 | ((unint64_t)v12 << 32), *(_DWORD *)(a1 + 340), v17);
    glpLogMessage(InfoLog, 0, (uint64_t)v17, "'' :  version '%d' is not supported", v13, v14, v15, v16, v2);
    return glpParseRecover(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 40) = v5;
    *(_DWORD *)(a1 + 44) = 1;
    uint64_t NameTable = glpCompilerGetNameTable(*(void *)(a1 + 784));
    return glpNameTableSetGLSLVersion(NameTable, v5);
  }
}

uint64_t glpParseContextValidateGLSLVersion(uint64_t a1)
{
  uint64_t result = glpGLSLVersionRequired(*(void *)(a1 + 784), *(_DWORD *)(a1 + 40));
  if (result && !*(_DWORD *)(a1 + 44))
  {
    uint64_t InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(void *)(a1 + 784));
    int v4 = *(const char **)(a1 + 344);
    unsigned int v5 = strlen(v4);
    if (v5 >> 5 >= v5)
    {
      unsigned int v7 = v5;
    }
    else
    {
      unsigned int v6 = v5;
      unsigned int v7 = v5;
      do
      {
        v7 ^= 32 * v7 + (v7 >> 2) + v4[v6 - 1];
        v6 += ~(v5 >> 5);
      }
      while (v6 > v5 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v4, v5 | ((unint64_t)v7 << 32), *(_DWORD *)(a1 + 340), v13);
    glpLogMessage(InfoLog, 0, (uint64_t)v13, "'' :  #version required and missing.", v8, v9, v10, v11, v12);
    return glpParseRecover(a1);
  }
  return result;
}

uint64_t glpLexerNew(uint64_t a1)
{
  uint64_t result = yylex_init((uint64_t *)(a1 + 24));
  **(void **)(a1 + 24) = a1;
  return result;
}

uint64_t glpLexerFree(uint64_t a1)
{
  return yylex_destroy(*(void *)(a1 + 24));
}

uint64_t yyparse(uint64_t a1)
{
  *(_OWORD *)uint64_t v86 = 0u;
  *(_OWORD *)unsigned int v84 = 0u;
  memset(v83, 0, sizeof(v83));
  memset(v80, 0, sizeof(v80));
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  memset(v75, 0, sizeof(v75));
  *(_OWORD *)&v81[16] = 0uLL;
  *((void *)&v82 + 1) = 1;
  *(void *)&long long v82 = 1;
  *(_OWORD *)unsigned int v81 = 0xFFFFFFFE00000000;
  long long v85 = 0xC8uLL;
  char v2 = malloc_type_malloc(0x3840uLL, 0x7081ABB9uLL);
  if (!v2) {
    goto LABEL_140;
  }
  v84[0] = v2;
  v84[1] = v2;
  *((void *)&v85 + 1) = 0;
  v86[0] = 0;
  unint64_t v88 = 1;
  uint64_t v89 = 16;
  uint64_t v3 = malloc_type_malloc(0x80uLL, 0x7081ABB9uLL);
  if (!v3) {
    goto LABEL_140;
  }
  v86[1] = v3;
  *uint64_t v3 = 0;
  int v4 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
  if (!v4) {
    goto LABEL_140;
  }
  uint64_t v87 = v4;
  uint64_t v5 = setjmp((int *)v83);
  if (v5 == 2)
  {
    yyerror((uint64_t)&v82, a1, (char)"memory exhausted");
    uint64_t v5 = 2;
    goto LABEL_12;
  }
  if (v5 == 1) {
    goto LABEL_12;
  }
  if (v5) {
    goto LABEL_140;
  }
  unsigned int v6 = (char *)v84[1];
  v84[1] = (char *)v84[1] + 72;
  *(void *)&long long v85 = v85 - 1;
  *((_DWORD *)v6 + 1) = 0;
  *unsigned int v6 = 1;
  *((void *)v6 + 2) = 0;
  v6[1] = 1;
  *((void *)v6 + 1) = *(void *)v86[1];
  long long v7 = *(_OWORD *)&v81[8];
  *((void *)v6 + 5) = *(void *)&v81[24];
  *(_OWORD *)(v6 + 24) = v7;
  *((_OWORD *)v6 + 3) = v82;
  *(void *)v86[1] = v6;
  if ((unint64_t)v85 <= 1) {
    yyexpandGLRStack((uint64_t)v75);
  }
  int v8 = *(_DWORD *)(*(void *)v86[1] + 4);
  if (v8 == 161) {
    goto LABEL_10;
  }
  uint64_t v14 = 0;
  while (1)
  {
    int v15 = yypact[v8];
    uint64_t v16 = v8;
    if (v15 == -400)
    {
      if (yydefact[v8])
      {
        yyglrReduce(v75, 0, yydefact[v8], 1);
        goto LABEL_121;
      }
      long long v76 = v82;
      int v21 = v75[0];
      if (!LODWORD(v75[0])) {
        goto LABEL_32;
      }
LABEL_73:
      if (v21 == 3)
      {
        int v44 = *(_DWORD *)&v81[4];
        while (1)
        {
          if (v44 != -2)
          {
            if (!v44) {
              goto LABEL_139;
            }
            *(void *)(*(void *)v86[1] + 56) = *((void *)&v82 + 1);
          }
          int v45 = yylex((uint64_t)&v81[8], (uint64_t)&v82, *(void *)(a1 + 24));
          int v44 = v45;
          *(_DWORD *)&v81[4] = v45;
          if (v45 < 1) {
            int v46 = 0;
          }
          else {
            int v46 = v45 > 0x1AF ? 2 : yytranslate[v45];
          }
          uint64_t v47 = *(void *)v86[1];
          uint64_t v48 = *(int *)(*(void *)v86[1] + 4);
          int v49 = yypact[v48];
          if (v49 == -400) {
            break;
          }
          uint64_t v50 = (v46 + v49);
          if (v50 >> 1 <= 0x81A && v46 == yycheck[v50])
          {
            if (yytable[v50]) {
              break;
            }
          }
          else if (yydefact[v48])
          {
            break;
          }
        }
      }
      else
      {
        unint64_t v51 = v88;
        if (!v88) {
          goto LABEL_139;
        }
        uint64_t v52 = 0;
        while (1)
        {
          unint64_t v53 = v52 + 1;
          if (*((void *)v86[1] + v52)) {
            break;
          }
          ++v52;
          if (v88 == v53) {
            goto LABEL_139;
          }
        }
        uint64_t v54 = v52 + 1;
        if (v53 < v88)
        {
          do
          {
            if (*((void *)v86[1] + v54)) {
              v86[0] = *((void **)v86[1] + v54);
            }
            *((void *)v86[1] + v54++) = 0;
          }
          while (v51 != v54);
        }
        unint64_t v55 = v51;
        uint64_t v56 = 0;
        unint64_t v57 = 0;
        do
        {
          uint64_t v58 = *((void *)v86[1] + v56);
          if (v58)
          {
            *((void *)v86[1] + v57) = v58;
            *((unsigned char *)v87 + v57++) = *((unsigned char *)v87 + v56);
            unint64_t v55 = v88;
          }
          else
          {
            unint64_t v88 = --v55;
          }
          ++v56;
        }
        while (v57 < v55);
        yycompressStack((uint64_t)v75);
        LODWORD(v75[0]) = 3;
        uint64_t v59 = *(void *)v86[1];
        if (*(void *)v86[1])
        {
          uint64_t v60 = v85 - 1;
          unsigned int v61 = v86[1];
          while (1)
          {
            uint64_t v62 = yypact[*(int *)(v59 + 4)];
            if (v62 >= -1)
            {
              uint64_t v63 = v62 + 1;
              if (yycheck[v63] == 1)
              {
                int v64 = yytable[v63];
                if (v64 >= 1) {
                  break;
                }
              }
            }
            long long v76 = *(_OWORD *)(v59 + 48);
            yydestroyGLRState(v59);
            *unsigned int v61 = *(void *)(v59 + 8);
            v84[1] = (char *)v84[1] - 72;
            *(void *)&long long v85 = v60 + 2;
            uint64_t v59 = *(void *)v86[1];
            ++v60;
            unsigned int v61 = v86[1];
            if (!*(void *)v86[1]) {
              goto LABEL_110;
            }
          }
          *(_OWORD *)((char *)v80 + 8) = v82;
          *(void *)&long long v67 = v76;
          uint64_t v68 = *((void *)&v82 + 1);
          uint64_t v69 = *(void *)(v59 + 16);
          unsigned int v70 = (char *)v84[1];
          v84[1] = (char *)v84[1] + 72;
          *(void *)&long long v85 = v60;
          *unsigned int v70 = 1;
          *((_DWORD *)v70 + 1) = (unsigned __int16)v64;
          *((void *)v70 + 2) = v69;
          v70[1] = 1;
          *((void *)v70 + 1) = *(void *)v86[1];
          long long v71 = *(_OWORD *)&v81[8];
          *((void *)v70 + 5) = *(void *)&v81[24];
          *((void *)&v67 + 1) = v68;
          *(_OWORD *)(v70 + 24) = v71;
          *((_OWORD *)v70 + 3) = v67;
          *(void *)v86[1] = v70;
          if ((unint64_t)v85 <= 1) {
            yyexpandGLRStack((uint64_t)v75);
          }
        }
LABEL_110:
        uint64_t v47 = *(void *)v86[1];
        if (!*(void *)v86[1]) {
LABEL_139:
        }
          longjmp((int *)v83, 1);
      }
      uint64_t v37 = *(void *)(v47 + 16);
LABEL_112:
      uint64_t v5 = 0;
      uint64_t v14 = v37;
      goto LABEL_122;
    }
    int v17 = *(_DWORD *)&v81[4];
    if (*(_DWORD *)&v81[4] == -2)
    {
      int v18 = yylex((uint64_t)&v81[8], (uint64_t)&v82, *(void *)(a1 + 24));
      int v17 = v18;
      *(_DWORD *)&v81[4] = v18;
      if (v18 < 1) {
        goto LABEL_33;
      }
      int v19 = v18;
      if (v18 < 0x1B0) {
        goto LABEL_29;
      }
    }
    else
    {
      int v19 = *(_DWORD *)&v81[4];
      if (*(int *)&v81[4] < 1)
      {
LABEL_33:
        int v20 = 0;
        goto LABEL_34;
      }
      if (*(_DWORD *)&v81[4] <= 0x1AFu)
      {
LABEL_29:
        int v20 = yytranslate[v19];
        goto LABEL_30;
      }
    }
    int v20 = 2;
LABEL_30:
    int v17 = 1;
LABEL_34:
    uint64_t v22 = (v20 + v15);
    if (v22 >> 1 <= 0x81A && yycheck[v22] == v20)
    {
      uint64_t v23 = &yyconfl[yyconflp[v22]];
      int v24 = yytable[v22];
      unsigned int v25 = v23;
    }
    else
    {
      int v24 = -yydefact[v16];
      unsigned int v25 = yyconfl;
    }
    if (*v25) {
      break;
    }
    if (v24 >= 1)
    {
      if (v17) {
        *(_DWORD *)&v81[4] = -2;
      }
      unsigned int v65 = (char *)v84[1];
      v84[1] = (char *)v84[1] + 72;
      *(void *)&long long v85 = v85 - 1;
      *unsigned int v65 = 1;
      *((_DWORD *)v65 + 1) = v24;
      *((void *)v65 + 2) = v14 + 1;
      v65[1] = 1;
      *((void *)v65 + 1) = *(void *)v86[1];
      long long v66 = *(_OWORD *)&v81[8];
      *((void *)v65 + 5) = *(void *)&v81[24];
      *(_OWORD *)(v65 + 24) = v66;
      *((_OWORD *)v65 + 3) = v82;
      *(void *)v86[1] = v65;
      if ((unint64_t)v85 <= 1) {
        yyexpandGLRStack((uint64_t)v75);
      }
      if (SLODWORD(v75[0]) >= 1) {
        --LODWORD(v75[0]);
      }
      ++v14;
      goto LABEL_121;
    }
    if (!v24)
    {
      long long v76 = v82;
      if (!LODWORD(v75[0])) {
        goto LABEL_32;
      }
LABEL_72:
      int v21 = v75[0];
      goto LABEL_73;
    }
    yyglrReduce(v75, 0, -v24, 1);
LABEL_121:
    uint64_t v5 = 0;
LABEL_122:
    int v8 = *(_DWORD *)(*(void *)v86[1] + 4);
    if (v8 == 161) {
      goto LABEL_12;
    }
  }
  unint64_t v26 = v88;
LABEL_40:
  if (!v26) {
    goto LABEL_128;
  }
  uint64_t v27 = v14;
  unint64_t v28 = 0;
  do
    *((unsigned char *)v87 + v28++) = *(_DWORD *)&v81[4] != -2;
  while (v28 < v88);
  if (!v88)
  {
LABEL_128:
    if (!v86[0]) {
      yyFail((uint64_t)v75, (uint64_t)&v82, a1, (uint64_t)"syntax error");
    }
    *(void *)v86[1] = v86[0];
    unint64_t v88 = 1;
    v86[0] = 0;
    yyresolveStack((uint64_t)v75, a1);
    long long v76 = v82;
    int v21 = v75[0];
    if (!LODWORD(v75[0]))
    {
LABEL_32:
      yyerror((uint64_t)&v82, a1, (char)"syntax error");
      ++*(_DWORD *)v81;
      goto LABEL_72;
    }
    goto LABEL_73;
  }
  unint64_t v29 = 0;
  while (1)
  {
    int v30 = yyprocessOneStack((uint64_t)v75, v29, a1);
    if (v30) {
      break;
    }
    ++v29;
    unint64_t v31 = v88;
    if (v29 >= v88)
    {
      if (!v88) {
        goto LABEL_128;
      }
      uint64_t v32 = 0;
      unint64_t v33 = 0;
      do
      {
        unint64_t v34 = v33;
        uint64_t v35 = *((void *)v86[1] + v32);
        if (v35)
        {
          *((void *)v86[1] + v33) = v35;
          *((unsigned char *)v87 + v33) = *((unsigned char *)v87 + v32);
          unint64_t v34 = v33 + 1;
          unint64_t v31 = v88;
        }
        else
        {
          unint64_t v88 = --v31;
        }
        ++v32;
        unint64_t v33 = v34;
      }
      while (v34 < v31);
      if (!v31) {
        goto LABEL_128;
      }
      if (*(int *)&v81[4] < 1)
      {
        int v36 = 0;
      }
      else if (*(_DWORD *)&v81[4] > 0x1AFu)
      {
        int v36 = 2;
      }
      else
      {
        int v36 = yytranslate[*(unsigned int *)&v81[4]];
      }
      *(_DWORD *)&v81[4] = -2;
      uint64_t v37 = v27 + 1;
      unint64_t v38 = 0;
      do
      {
        uint64_t v39 = *(int *)(*((void *)v86[1] + v38) + 4);
        unsigned int v40 = v36 + yypact[v39];
        if (v40 >> 1 <= 0x81A && v36 == yycheck[v40]) {
          int v41 = yytable[v36 + yypact[v39]];
        }
        else {
          int v41 = -yydefact[v39];
        }
        uint64_t v42 = (char *)v84[1];
        v84[1] = (char *)v84[1] + 72;
        *(void *)&long long v85 = v85 - 1;
        *uint64_t v42 = 1;
        *((_DWORD *)v42 + 1) = v41;
        *((void *)v42 + 2) = v37;
        v42[1] = 1;
        *((void *)v42 + 1) = *((void *)v86[1] + v38);
        long long v43 = *(_OWORD *)&v81[8];
        *((void *)v42 + 5) = *(void *)&v81[24];
        *(_OWORD *)(v42 + 24) = v43;
        *((_OWORD *)v42 + 3) = v82;
        *((void *)v86[1] + v38) = v42;
        if ((unint64_t)v85 <= 1) {
          yyexpandGLRStack((uint64_t)v75);
        }
        ++v38;
      }
      while (v38 < v88);
      unint64_t v26 = v88;
      uint64_t v14 = v37;
      if (v88 == 1)
      {
        yyresolveStack((uint64_t)v75, a1);
        yycompressStack((uint64_t)v75);
        goto LABEL_112;
      }
      goto LABEL_40;
    }
  }
  if (v30 == 1)
  {
LABEL_10:
    uint64_t v5 = 0;
    goto LABEL_12;
  }
  if (v30 != 2)
  {
    if (v30 == 3) {
      goto LABEL_72;
    }
LABEL_140:
    abort();
  }
  uint64_t v5 = 1;
LABEL_12:
  uint64_t v9 = v5;
  uint64_t v10 = v84[0];
  if (v84[0])
  {
    if (v86[1] && v88)
    {
      uint64_t v11 = (uint64_t *)v86[1];
      unint64_t v12 = v88;
      while (1)
      {
        uint64_t v13 = *v11;
        if (*v11) {
          break;
        }
        ++v11;
        if (!--v12) {
          goto LABEL_136;
        }
      }
      uint64_t v72 = v85 + 1;
      do
      {
        uint64_t v73 = v72;
        long long v76 = *(_OWORD *)(v13 + 48);
        yydestroyGLRState(v13);
        *uint64_t v11 = *(void *)(v13 + 8);
        v84[1] = (char *)v84[1] - 72;
        *(void *)&long long v85 = v73;
        uint64_t v13 = *v11;
        uint64_t v72 = v73 + 1;
      }
      while (*v11);
      uint64_t v10 = v84[0];
    }
LABEL_136:
    free(v10);
    free(v86[1]);
    free(v87);
  }
  return v9;
}

uint64_t yyglrReduce(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v5 = a3;
  int v8 = (void *)a1[63];
  unint64_t v9 = v8[a2];
  unint64_t v10 = *(void *)(v9 + 16);
  unint64_t v11 = a1[61];
  if (!a4 && v11)
  {
    unint64_t v13 = v8[a2];
    if (yyr2[(int)a3])
    {
      int v14 = yyr2[(int)a3] + 1;
      unint64_t v13 = v8[a2];
      do
      {
        unint64_t v13 = *(void *)(v13 + 8);
        if (!v13) {
          goto LABEL_61;
        }
      }
      while (--v14 >= 2);
    }
    if (v11 > v13)
    {
      a1[61] = v13;
      unint64_t v11 = v13;
    }
    int v15 = *(_DWORD *)(v13 + 4);
    uint64_t v16 = yyr1[(int)a3] - 177;
    uint64_t v17 = (v15 + yypgoto[v16]);
    if (v17 >> 1 <= 0x81A && v15 == yycheck[v17]) {
      int v18 = (char *)&yytable + 2 * v17;
    }
    else {
      int v18 = (char *)&yydefgoto + 2 * v16;
    }
    int v29 = *(__int16 *)v18;
    uint64_t v30 = a1[65];
    if (v30)
    {
      for (uint64_t i = 0; i != v30; ++i)
      {
        if (i != a2)
        {
          uint64_t v32 = v8[i];
          BOOL v33 = !v32 || v32 == v13;
          if (!v33 && v32 != v11)
          {
            while (*(void *)(v32 + 16) >= v10)
            {
              uint64_t v35 = *(void *)(v32 + 8);
              if (*(_DWORD *)(v32 + 4) == v29 && v35 == v13)
              {
                yyaddDeferredAction((uint64_t)a1, a2, v32, v9, v5);
                uint64_t v40 = a1[63];
                uint64_t v41 = *(void *)(v40 + 8 * a2);
                if (v41) {
                  a1[62] = v41;
                }
                uint64_t result = 0;
                *(void *)(v40 + 8 * a2) = 0;
                return result;
              }
              BOOL v37 = v35 == v13 || v35 == v11;
              uint64_t v32 = *(void *)(v32 + 8);
              if (v37) {
                break;
              }
            }
          }
        }
      }
    }
    v8[a2] = v13;
    uint64_t v38 = a1[59];
    uint64_t v39 = a1[60] - 1;
    a1[59] = v38 + 72;
    a1[60] = v39;
    *(unsigned char *)uint64_t v38 = 1;
    *(_DWORD *)(v38 + 4) = v29;
    *(void *)(v38 + 16) = v10;
    *(unsigned char *)(v38 + 1) = 0;
    *(void *)(v38 + 8) = *(void *)(a1[63] + 8 * a2);
    *(void *)(v38 + 24) = 0;
    *(void *)(a1[63] + 8 * a2) = v38;
    yyaddDeferredAction((uint64_t)a1, a2, v38, v9, v5);
    return 0;
  }
  if (v11)
  {
    if (yyr2[(int)a3])
    {
      int v12 = yyr2[(int)a3];
      while (1)
      {
        unint64_t v9 = *(void *)(v9 + 8);
        if (!v9) {
          break;
        }
        if (!--v12) {
          goto LABEL_20;
        }
      }
LABEL_61:
      abort();
    }
LABEL_20:
    if (v11 > v9) {
      a1[61] = v9;
    }
    v8[a2] = v9;
  }
  else
  {
    if (a2) {
      goto LABEL_61;
    }
    uint64_t v19 = a1[59] + 72 * -yyr2[(int)a3];
    uint64_t v20 = a1[60] + yyr2[(int)a3];
    a1[59] = v19;
    a1[60] = v20;
    *int v8 = v19 - 72;
  }
  uint64_t result = yyuserAction(a3);
  if (!result)
  {
    int v22 = *(_DWORD *)(*(void *)(a1[63] + 8 * a2) + 4);
    uint64_t v23 = yyr1[v5] - 177;
    uint64_t v24 = (v22 + yypgoto[v23]);
    if (v24 >> 1 <= 0x81A && v22 == yycheck[v24]) {
      unsigned int v25 = (char *)&yytable + 2 * v24;
    }
    else {
      unsigned int v25 = (char *)&yydefgoto + 2 * v23;
    }
    int v26 = *(__int16 *)v25;
    uint64_t v27 = a1[59];
    uint64_t v28 = a1[60] - 1;
    a1[59] = v27 + 72;
    a1[60] = v28;
    *(unsigned char *)uint64_t v27 = 1;
    *(_DWORD *)(v27 + 4) = v26;
    *(void *)(v27 + 16) = v10;
    *(unsigned char *)(v27 + 1) = 1;
    *(void *)(v27 + 8) = *(void *)(a1[63] + 8 * a2);
    *(_OWORD *)(v27 + 24) = 0uLL;
    *(void *)(v27 + 40) = 0;
    *(_OWORD *)(v27 + 48) = 0uLL;
    *(void *)(a1[63] + 8 * a2) = v27;
    if (a1[60] <= 1uLL) {
      yyexpandGLRStack((uint64_t)a1);
    }
    return 0;
  }
  return result;
}

uint64_t yyprocessOneStack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 504);
  uint64_t v4 = *(void *)(v3 + 8 * a2);
  if (!v4) {
    return 0;
  }
  uint64_t v27 = a1 + 256;
  uint64_t v28 = a1 + 232;
  int v8 = &yyconfl;
  while (1)
  {
    uint64_t v9 = *(int *)(v4 + 4);
    if (v9 == 161) {
LABEL_43:
    }
      abort();
    int v10 = yypact[v9];
    if (v10 != -400) {
      break;
    }
    if (!yydefact[v9])
    {
      int v26 = (uint64_t *)(v3 + 8 * a2);
      goto LABEL_41;
    }
    uint64_t result = yyglrReduce((void *)a1, a2, yydefact[v9], 0);
    if (result) {
      return result;
    }
LABEL_36:
    uint64_t v3 = *(void *)(a1 + 504);
    uint64_t v4 = *(void *)(v3 + 8 * a2);
    if (!v4) {
      return 0;
    }
  }
  *(unsigned char *)(*(void *)(a1 + 512) + a2) = 1;
  int v12 = *(_DWORD *)(a1 + 228);
  if (v12 != -2)
  {
    if (v12 >= 1)
    {
      if (v12 > 0x1AF) {
        goto LABEL_11;
      }
LABEL_14:
      int v13 = yytranslate[v12];
      goto LABEL_16;
    }
LABEL_15:
    int v13 = 0;
    goto LABEL_16;
  }
  int v12 = yylex(v28, v27, *(void *)(a3 + 24));
  *(_DWORD *)(a1 + 228) = v12;
  if (v12 < 1) {
    goto LABEL_15;
  }
  if (v12 < 0x1B0) {
    goto LABEL_14;
  }
LABEL_11:
  int v13 = 2;
LABEL_16:
  uint64_t v14 = (v13 + v10);
  if (v14 >> 1 <= 0x81A && yycheck[v14] == v13)
  {
    int v15 = yytable[v14];
    uint64_t v16 = v8;
    uint64_t v17 = &v8[yyconflp[v14]];
  }
  else
  {
    int v15 = -yydefact[v9];
    uint64_t v16 = v8;
    uint64_t v17 = v8;
  }
  __int16 v18 = *v17;
  if (*v17)
  {
    uint64_t v19 = (unsigned __int16 *)(v17 + 1);
    do
    {
      if (!*(void *)(a1 + 488))
      {
        if (a2) {
          goto LABEL_43;
        }
        *(void *)(a1 + 488) = **(void **)(a1 + 504);
      }
      unint64_t v20 = *(void *)(a1 + 520);
      unint64_t v21 = *(void *)(a1 + 528);
      if (v20 >= v21)
      {
        if (v21 >> 60) {
          yyMemoryExhausted(a1);
        }
        *(void *)(a1 + 528) = 2 * v21;
        int v22 = malloc_type_realloc(*(void **)(a1 + 504), 16 * v21, 0x2BDC8648uLL);
        if (!v22) {
          goto LABEL_43;
        }
        *(void *)(a1 + 504) = v22;
        uint64_t v23 = malloc_type_realloc(*(void **)(a1 + 512), *(void *)(a1 + 528), 0x2BDC8648uLL);
        if (!v23) {
          goto LABEL_43;
        }
        *(void *)(a1 + 512) = v23;
        unint64_t v20 = *(void *)(a1 + 520);
      }
      *(void *)(*(void *)(a1 + 504) + 8 * v20) = *(void *)(*(void *)(a1 + 504) + 8 * a2);
      *(unsigned char *)(*(void *)(a1 + 512) + v20) = *(unsigned char *)(*(void *)(a1 + 512) + a2);
      uint64_t v24 = *(void *)(a1 + 520);
      *(void *)(a1 + 520) = v24 + 1;
      uint64_t result = yyglrReduce((void *)a1, v24, v18, 0);
      if (result) {
        return result;
      }
      uint64_t result = yyprocessOneStack(a1, v24, a3);
      if (result) {
        return result;
      }
      int v25 = *v19++;
      __int16 v18 = v25;
    }
    while (v25);
  }
  if (v15 > 0) {
    return 0;
  }
  if (v15)
  {
    uint64_t result = yyglrReduce((void *)a1, a2, -v15, 0);
    int v8 = v16;
    if (result) {
      return result;
    }
    goto LABEL_36;
  }
  int v26 = (uint64_t *)(*(void *)(a1 + 504) + 8 * a2);
  uint64_t v4 = *v26;
  if (!*v26) {
    goto LABEL_42;
  }
LABEL_41:
  *(void *)(a1 + 496) = v4;
LABEL_42:
  uint64_t result = 0;
  *int v26 = 0;
  return result;
}

void yyFail(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    yyerror(a2, a3, a4);
  }
  longjmp((int *)(a1 + 272), 1);
}

uint64_t yyresolveStack(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 488);
  if (!v2) {
    return 0;
  }
  uint64_t v5 = **(void **)(a1 + 504);
  if (v5 == v2)
  {
    int v6 = 0;
  }
  else
  {
    int v6 = 0;
    uint64_t v7 = v5;
    do
    {
      ++v6;
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != v2);
  }
  uint64_t result = yyresolveStates(v5, v6, a1, a2);
  if (!result) {
    return 0;
  }
  return result;
}

__n128 yycompressStack(uint64_t a1)
{
  if (*(void *)(a1 + 520) == 1)
  {
    uint64_t v1 = *(void *)(a1 + 488);
    if (v1)
    {
      uint64_t v2 = **(void **)(a1 + 504);
      if (v2 == v1)
      {
        uint64_t v4 = 0;
      }
      else
      {
        uint64_t v3 = 0;
        do
        {
          uint64_t v4 = v2;
          uint64_t v2 = *(void *)(v2 + 8);
          *(void *)(v4 + 8) = v3;
          uint64_t v3 = v4;
        }
        while (v2 != v1);
      }
      uint64_t v5 = v1 + 72;
      uint64_t v6 = *(void *)(a1 + 480)
         - 0x71C71C71C71C71C7 * ((uint64_t)(*(void *)(a1 + 472) - *(void *)(a1 + 464)) >> 3)
         + 0x71C71C71C71C71C7 * ((v5 - *(void *)(a1 + 464)) >> 3);
      *(void *)(a1 + 472) = v5;
      *(void *)(a1 + 480) = v6;
      *(void *)(a1 + 488) = 0;
      for (*(void *)(a1 + 496) = 0; v4; *(void *)(a1 + 480) = v10 - 1)
      {
        __n128 result = *(__n128 *)v4;
        long long v8 = *(_OWORD *)(v4 + 16);
        long long v9 = *(_OWORD *)(v4 + 48);
        *(_OWORD *)(v5 + 32) = *(_OWORD *)(v4 + 32);
        *(_OWORD *)(v5 + 48) = v9;
        *(__n128 *)uint64_t v5 = result;
        *(_OWORD *)(v5 + 16) = v8;
        uint64_t v4 = *(void *)(v4 + 8);
        *(void *)(*(void *)(a1 + 472) + 8) = *(void *)(a1 + 472) - 72;
        uint64_t v10 = *(void *)(a1 + 480);
        **(void **)(a1 + 504) = *(void *)(a1 + 472);
        uint64_t v5 = *(void *)(a1 + 472) + 72;
        *(void *)(a1 + 472) = v5;
      }
    }
  }
  return result;
}

uint64_t yydestroyGLRState(uint64_t result)
{
  if (!*(unsigned char *)(result + 1))
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1)
    {
      int v2 = yyr2[*(int *)(v1 + 4)];
      if (yyr2[*(int *)(v1 + 4)])
      {
        uint64_t v3 = (void *)(v1 + 8);
        unsigned int v4 = v2 + 1;
        do
        {
          uint64_t v5 = *v3;
          __n128 result = yydestroyGLRState(*v3);
          uint64_t v3 = (void *)(v5 + 8);
          --v4;
        }
        while (v4 > 1);
      }
    }
  }
  return result;
}

void yyexpandGLRStack(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 464);
  uint64_t v2 = *(void *)(a1 + 472);
  unint64_t v4 = 0x8E38E38E38E38E39 * ((v2 - v3) >> 3);
  if (v4 >= 0x270F) {
    yyMemoryExhausted(a1);
  }
  if ((unint64_t)(0x1C71C71C71C71C72 * ((v2 - v3) >> 3)) >= 0x2710) {
    uint64_t v5 = 10000;
  }
  else {
    uint64_t v5 = 0x1C71C71C71C71C72 * ((v2 - v3) >> 3);
  }
  uint64_t v6 = (char *)malloc_type_malloc(72 * v5, 0x7081ABB9uLL);
  if (!v6) {
    abort();
  }
  uint64_t v7 = v6;
  if (v2 != v3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 464);
    unint64_t v10 = 0x8E38E38E38E38E39 * ((v2 - v3) >> 3);
    do
    {
      unint64_t v11 = &v6[v8];
      uint64_t v12 = v9 + v8;
      *(_OWORD *)unint64_t v11 = *(_OWORD *)(v9 + v8);
      long long v13 = *(_OWORD *)(v9 + v8 + 16);
      long long v14 = *(_OWORD *)(v9 + v8 + 32);
      long long v15 = *(_OWORD *)(v9 + v8 + 48);
      *((void *)v11 + 8) = *(void *)(v9 + v8 + 64);
      *((_OWORD *)v11 + 2) = v14;
      *((_OWORD *)v11 + 3) = v15;
      *((_OWORD *)v11 + 1) = v13;
      if (*(unsigned char *)(v9 + v8))
      {
        uint64_t v16 = *(void *)(v12 + 8);
        if (v16)
        {
          uint64_t v17 = (unsigned __int128)((v9 + v8 - v16) * (__int128)(uint64_t)0xF1C71C71C71C71C7) >> 64;
          *(void *)&v6[v8 + 8] = &v6[72 * (v17 >> 2) + 72 * ((unint64_t)v17 >> 63) + v8];
        }
        if (!*(unsigned char *)(v9 + v8 + 1))
        {
          uint64_t v18 = *(void *)(v9 + v8 + 24);
          if (v18)
          {
            uint64_t v19 = (unsigned __int128)((v9 + v8 - v18) * (__int128)(uint64_t)0xF1C71C71C71C71C7) >> 64;
            *(void *)&v6[v8 + 24] = &v6[72 * (v19 >> 2) + 72 * ((unint64_t)v19 >> 63) + v8];
          }
        }
      }
      else
      {
        uint64_t v20 = *(void *)(v12 + 8);
        if (v20)
        {
          uint64_t v21 = (unsigned __int128)((v9 + v8 - v20) * (__int128)(uint64_t)0xF1C71C71C71C71C7) >> 64;
          *(void *)&v6[v8 + 8] = &v6[72 * (v21 >> 2) + 72 * ((unint64_t)v21 >> 63) + v8];
        }
        uint64_t v22 = *(void *)(v9 + v8 + 64);
        if (v22) {
          *(void *)&v6[v8 + 64] = &v6[72 * ((v9 + v8 - v22) / -72) + v8];
        }
      }
      v8 += 72;
      --v10;
    }
    while (v10);
  }
  uint64_t v23 = *(void *)(a1 + 488);
  if (v23) {
    *(void *)(a1 + 488) = &v6[v23 - *(void *)(a1 + 464)];
  }
  uint64_t v24 = *(void *)(a1 + 520);
  if (v24)
  {
    for (uint64_t i = 0; i != v24; ++i)
    {
      uint64_t v26 = *(void *)(a1 + 504);
      uint64_t v27 = *(void *)(v26 + 8 * i);
      if (v27) {
        *(void *)(v26 + 8 * i) = &v6[v27 - *(void *)(a1 + 464)];
      }
    }
  }
  free(*(void **)(a1 + 464));
  *(void *)(a1 + 464) = v7;
  *(void *)(a1 + 472) = &v7[8 * ((v2 - v3) >> 3)];
  *(void *)(a1 + 480) = v5 - v4;
}

void yyMemoryExhausted(uint64_t a1)
{
}

void yyaddDeferredAction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = *(void *)(a1 + 472);
  uint64_t v6 = *(void *)(a1 + 480) - 1;
  *(void *)(a1 + 472) = v5 + 72;
  *(void *)(a1 + 480) = v6;
  *(unsigned char *)uint64_t v5 = 0;
  *(void *)(v5 + 8) = a4;
  *(_DWORD *)(v5 + 4) = a5;
  if (*(unsigned char *)(*(void *)(a1 + 512) + a2))
  {
    *(_DWORD *)(v5 + 16) = *(_DWORD *)(a1 + 228);
    long long v7 = *(_OWORD *)(a1 + 232);
    *(void *)(v5 + 40) = *(void *)(a1 + 248);
    *(_OWORD *)(v5 + 24) = v7;
    *(_OWORD *)(v5 + 48) = *(_OWORD *)(a1 + 256);
  }
  else
  {
    *(_DWORD *)(v5 + 16) = -2;
  }
  *(void *)(v5 + 64) = *(void *)(a3 + 24);
  *(void *)(a3 + 24) = v5;
  if (*(void *)(a1 + 480) <= 1uLL) {
    yyexpandGLRStack(a1);
  }
}

uint64_t yyuserAction(uint64_t a1)
{
  int v1 = MEMORY[0x270FA5388](a1);
  uint64_t v8 = v7;
  uint64_t v9 = (_DWORD *)v6;
  unint64_t v10 = v4;
  uint64_t v11 = v3;
  uint64_t v12 = *(void *)(v6 + 488);
  v1331[0] = 1;
  if (v2)
  {
    if (v2 >= 1 && v12)
    {
      uint64_t v13 = *(void *)(v3 + 80);
      int v14 = 1 - v2;
      uint64_t v15 = v3 + 24;
      uint64_t v16 = 1;
      do
      {
        if (!*(unsigned char *)(v13 + 1)) {
LABEL_381:
        }
          abort();
        --v16;
        *(unsigned char *)(v15 - 23) = 1;
        long long v17 = *(_OWORD *)(v13 + 24);
        *(void *)(v15 + 16) = *(void *)(v13 + 40);
        *(_OWORD *)uint64_t v15 = v17;
        *(_OWORD *)(v15 + 24) = *(_OWORD *)(v13 + 48);
        uint64_t v13 = *(void *)(v13 + 8);
        *(void *)(v15 - 16) = v13;
        v15 -= 72;
      }
      while (v16 > 1 - v2);
      v1331[0] = 1 - v2;
    }
    else
    {
      int v14 = 1 - v2;
    }
    uint64_t v20 = v3 + 72 * v14;
    long long v21 = *(_OWORD *)(v20 + 24);
    v4[2] = *(void *)(v20 + 40);
    *(_OWORD *)unint64_t v4 = v21;
    uint64_t v22 = v3 - 72 * v2;
    *uint64_t v5 = *(_DWORD *)(v22 + 120);
    v5[1] = *(_DWORD *)(v22 + 124);
    v5[2] = *(_DWORD *)(v3 + 56);
    v5[3] = *(_DWORD *)(v3 + 60);
  }
  else
  {
    *unint64_t v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    int v18 = *(_DWORD *)(v3 + 56);
    v5[2] = v18;
    *uint64_t v5 = v18;
    int v19 = *(_DWORD *)(v3 + 60);
    v5[3] = v19;
    v5[1] = v19;
  }
  *(_OWORD *)(v6 + 128) = *(_OWORD *)v5;
  switch(v1)
  {
    case 2:
      uint64_t Allocator = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      StringZ_0 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v28 = v27;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)StringZ_0, v28, *(_DWORD *)(v11 + 40), &v1330);
      yyfill(v11, v1331, 0, v12 == 0);
      int v29 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeVariableIdentifierNode(Allocator, &v1330, (uint64_t)v29, v30);
      goto LABEL_279;
    case 3:
    case 10:
    case 12:
    case 16:
    case 17:
    case 18:
    case 22:
    case 29:
    case 37:
    case 41:
    case 44:
    case 47:
    case 52:
    case 55:
    case 57:
    case 59:
    case 61:
    case 63:
    case 65:
    case 67:
    case 69:
    case 82:
    case 84:
    case 98:
    case 99:
    case 106:
    case 109:
    case 120:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 163:
    case 249:
    case 251:
    case 259:
    case 267:
    case 269:
    case 270:
    case 271:
    case 272:
    case 273:
    case 274:
    case 275:
    case 276:
    case 277:
    case 280:
    case 281:
    case 291:
    case 295:
    case 301:
    case 302:
    case 303:
    case 314:
    case 315:
      goto LABEL_12;
    case 4:
      Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(5u);
      uint64_t v33 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      unint64_t v34 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v36 = v35;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v34, v36, *(_DWORD *)(v11 + 40), v1329);
      uint64_t v37 = *(void *)(v8 + 784);
      uint64_t v38 = glpCompilerGetAllocator(v37);
      yyfill(v11, v1331, 0, v12 == 0);
      Mutableint Value = glpMakeMutableValue(v38, PrimitiveType, 1, v39, v40, v41, v42, v43, *(unsigned int *)(v11 + 24));
      uint64_t v45 = glpCompilerRemapValue(v37, PrimitiveType, MutableValue);
      int v46 = (__n128 *)v1329;
      goto LABEL_20;
    case 5:
      Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(0x24u);
      uint64_t v33 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v47 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v49 = v48;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v47, v49, *(_DWORD *)(v11 + 40), v1328);
      uint64_t v50 = *(void *)(v8 + 784);
      uint64_t v51 = glpCompilerGetAllocator(v50);
      yyfill(v11, v1331, 0, v12 == 0);
      unint64_t v57 = glpMakeMutableValue(v51, PrimitiveType, 1, v52, v53, v54, v55, v56, *(unsigned int *)(v11 + 24));
      uint64_t v45 = glpCompilerRemapValue(v50, PrimitiveType, v57);
      int v46 = (__n128 *)v1328;
      goto LABEL_20;
    case 6:
      Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(1u);
      uint64_t v33 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v58 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v60 = v59;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v58, v60, *(_DWORD *)(v11 + 40), v1327);
      uint64_t v61 = *(void *)(v8 + 784);
      uint64_t v62 = glpCompilerGetAllocator(v61);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v68 = glpMakeMutableValue(v62, PrimitiveType, 1, v63, v64, v65, v66, v67, COERCE__INT64(*(float *)(v11 + 24)));
      uint64_t v45 = glpCompilerRemapValue(v61, PrimitiveType, v68);
      int v46 = (__n128 *)v1327;
      goto LABEL_20;
    case 7:
      Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(9u);
      uint64_t v33 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v69 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v71 = v70;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v69, v71, *(_DWORD *)(v11 + 40), v1326);
      uint64_t v72 = *(void *)(v8 + 784);
      uint64_t v73 = glpCompilerGetAllocator(v72);
      yyfill(v11, v1331, 0, v12 == 0);
      long long v79 = glpMakeMutableValue(v73, PrimitiveType, 1, v74, v75, v76, v77, v78, *(unsigned int *)(v11 + 24));
      uint64_t v45 = glpCompilerRemapValue(v72, PrimitiveType, v79);
      int v46 = (__n128 *)v1326;
      goto LABEL_20;
    case 8:
      Primitiveuint64_t Type = (unsigned int *)glpGetPrimitiveType(0x3Eu);
      uint64_t v33 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      unsigned int v80 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v82 = v81;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v80, v82, *(_DWORD *)(v11 + 40), v1325);
      uint64_t v83 = *(void *)(v8 + 784);
      uint64_t v84 = glpCompilerGetAllocator(v83);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v90 = glpMakeMutableValue(v84, PrimitiveType, 1, v85, v86, v87, v88, v89, *(void *)(v11 + 24));
      uint64_t v45 = glpCompilerRemapValue(v83, PrimitiveType, v90);
      int v46 = (__n128 *)v1325;
LABEL_20:
      uint64_t v91 = v33;
      uint64_t v92 = (uint64_t)PrimitiveType;
      goto LABEL_21;
    case 9:
    case 19:
    case 20:
    case 21:
    case 25:
    case 85:
    case 86:
    case 126:
    case 129:
    case 155:
    case 283:
      goto LABEL_315;
    case 11:
      uint64_t v93 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 192), &v1324);
      glpMakeArrayAccessNode(v93, &v1324);
      uint64_t v95 = v94;
      *unint64_t v10 = v94;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpArrayAccessNodeSetArray(v95, *(void *)(v11 - 192));
      uint64_t v96 = *v10;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpArrayAccessNodeSetElement(v96, *(void *)(v11 - 48));
      return 0;
    case 13:
      uint64_t v97 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1323);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v98 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeFieldAccessNode(v97, &v1323, (uint64_t)v98, v99);
      uint64_t v101 = v100;
      *unint64_t v10 = v100;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpFieldAccessNodeSetStructure(v101, *(void *)(v11 - 120));
      return 0;
    case 14:
      uint64_t v102 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1322);
      uint64_t PostincrementNode = glpMakePostincrementNode(v102, &v1322);
      goto LABEL_26;
    case 15:
      uint64_t v104 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1321);
      uint64_t PostincrementNode = glpMakePostdecrementNode(v104, &v1321);
LABEL_26:
      uint64_t v105 = PostincrementNode;
      *unint64_t v10 = PostincrementNode;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v106 = *(void *)(v11 - 48);
      goto LABEL_38;
    case 23:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v107 = *(void *)(v11 - 48);
      goto LABEL_29;
    case 24:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      uint64_t v107 = *(void *)(v11 - 120);
LABEL_29:
      *unint64_t v10 = v107;
      uint64_t v108 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v109 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpCallNodeAddArg(v108, v109, *(void *)(v11 + 24));
      return 0;
    case 26:
      uint64_t v110 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1320);
      uint64_t v111 = &v1320;
      goto LABEL_360;
    case 27:
      if ((int)glpCompilerGetIOSVersion(*(void *)(v7 + 784)) >= 9)
      {
        int v112 = "Constructor calls may not have precision";
        goto LABEL_378;
      }
      uint64_t v110 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1319);
      uint64_t v111 = &v1319;
LABEL_360:
      uint64_t v1068 = glpMakeConstructorCallNode(v110, v111);
      *unint64_t v10 = v1068;
      yyfill(v11, v1331, 0, v12 == 0);
      glpConstructorCallNodeSetType(v1068, *(void *)(v11 + 24));
      return 0;
    case 28:
      uint64_t v113 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1318);
      uint64_t v114 = glpMakeUndeterminedCallNode(v113, &v1318);
      *unint64_t v10 = v114;
      yyfill(v11, v1331, 0, v12 == 0);
      glpUndeterminedCallNodeSetCallee(v114, *(void *)(v11 + 24));
      return 0;
    case 30:
      uint64_t v115 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v116 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v118 = v117;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v116, v118, *(_DWORD *)(v11 - 32), &v1317);
      uint64_t PreincrementNode = glpMakePreincrementNode(v115, &v1317);
      goto LABEL_37;
    case 31:
      uint64_t v120 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v121 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v123 = v122;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v121, v123, *(_DWORD *)(v11 - 32), &v1316);
      uint64_t PreincrementNode = glpMakePredecrementNode(v120, &v1316);
      goto LABEL_37;
    case 32:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v124 = *(uint64_t (**)(uint64_t, __n128 *, __n128))(v11 - 48);
      uint64_t v125 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      __n128 Location = glpASTNodeGetLocation(*(void *)(v11 + 24), &v1315);
      uint64_t PreincrementNode = v124(v125, &v1315, Location);
LABEL_37:
      uint64_t v105 = PreincrementNode;
      *unint64_t v10 = PreincrementNode;
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v106 = *(void *)(v11 + 24);
LABEL_38:
      glpUnaryOperatorNodeSetExpr(v105, v106);
      return 0;
    case 33:
      uint64_t result = 0;
      uint64_t v127 = glpMakeUnaryPlusNode;
      goto LABEL_75;
    case 34:
      uint64_t result = 0;
      uint64_t v127 = glpMakeNegateNode;
      goto LABEL_75;
    case 35:
      uint64_t result = 0;
      uint64_t v127 = glpMakeLogicalNotNode;
      goto LABEL_75;
    case 36:
      uint64_t result = 0;
      uint64_t v127 = glpMakeBitwiseNotNode;
      goto LABEL_75;
    case 38:
      uint64_t v128 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1314);
      uint64_t MultiplyNode = glpMakeMultiplyNode(v128, &v1314);
      goto LABEL_365;
    case 39:
      uint64_t v130 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1313);
      uint64_t MultiplyNode = glpMakeDivideNode(v130, &v1313);
      goto LABEL_365;
    case 40:
      uint64_t v131 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1312);
      uint64_t MultiplyNode = glpMakeModuloNode(v131, &v1312);
      goto LABEL_365;
    case 42:
      uint64_t v132 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1311);
      uint64_t MultiplyNode = glpMakeAddNode(v132, &v1311);
      goto LABEL_365;
    case 43:
      uint64_t v133 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1310);
      uint64_t MultiplyNode = glpMakeSubtractNode(v133, &v1310);
      goto LABEL_365;
    case 45:
      uint64_t v134 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1309);
      uint64_t MultiplyNode = glpMakeShiftLeftNode(v134, &v1309);
      goto LABEL_365;
    case 46:
      uint64_t v135 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1308);
      uint64_t MultiplyNode = glpMakeShiftRightNode(v135, &v1308);
      goto LABEL_365;
    case 48:
      uint64_t v136 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1307);
      uint64_t MultiplyNode = glpMakeLessNode(v136, &v1307);
      goto LABEL_365;
    case 49:
      uint64_t v137 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1306);
      uint64_t MultiplyNode = glpMakeGreaterNode(v137, &v1306);
      goto LABEL_365;
    case 50:
      uint64_t v138 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1305);
      uint64_t MultiplyNode = glpMakeLessEqualNode(v138, &v1305);
      goto LABEL_365;
    case 51:
      uint64_t v139 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1304);
      uint64_t MultiplyNode = glpMakeGreaterEqualNode(v139, &v1304);
      goto LABEL_365;
    case 53:
      uint64_t v140 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1303);
      uint64_t MultiplyNode = glpMakeEqualNode(v140, &v1303, 1);
      goto LABEL_365;
    case 54:
      uint64_t v141 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1302);
      uint64_t MultiplyNode = glpMakeNotEqualNode(v141, &v1302, 1);
      goto LABEL_365;
    case 56:
      uint64_t v142 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1301);
      uint64_t MultiplyNode = glpMakeBitwiseAndNode(v142, &v1301);
      goto LABEL_365;
    case 58:
      uint64_t v143 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1300);
      uint64_t MultiplyNode = glpMakeBitwiseXorNode(v143, &v1300);
      goto LABEL_365;
    case 60:
      uint64_t v144 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1299);
      uint64_t MultiplyNode = glpMakeBitwiseOrNode(v144, &v1299);
      goto LABEL_365;
    case 62:
      uint64_t v145 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1298);
      uint64_t MultiplyNode = glpMakeLogicalAndNode(v145, &v1298);
      goto LABEL_365;
    case 64:
      uint64_t v146 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1297);
      uint64_t MultiplyNode = glpMakeLogicalXorNode(v146, &v1297);
      goto LABEL_365;
    case 66:
      uint64_t v147 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1296);
      uint64_t MultiplyNode = glpMakeLogicalOrNode(v147, &v1296);
      goto LABEL_365;
    case 68:
      uint64_t v148 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 264), &v1295);
      glpMakeIfExprNode(v148, &v1295);
      uint64_t v150 = v149;
      *unint64_t v10 = v149;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpIfExprNodeSetCondition(v150, *(void *)(v11 - 264));
      uint64_t v151 = *v10;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpIfExprNodeSetIfExpr(v151, *(void *)(v11 - 120));
      uint64_t v152 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpIfExprNodeSetElseExpr(v152, *(void *)(v11 + 24));
      return 0;
    case 70:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v153 = *(void *)(v11 - 48);
      uint64_t v154 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v155 = *(void *)(v11 - 120);
      if (v153)
      {
        glpASTNodeGetLocation(v155, &v1294);
        yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
        uint64_t MultiplyNode = glpMakeOpAssignNode(v154, &v1294, *(void *)(v11 - 48));
      }
      else
      {
        glpASTNodeGetLocation(v155, &v1293);
        uint64_t MultiplyNode = glpMakeAssignNode(v154, &v1293, 1);
      }
LABEL_365:
      uint64_t v1080 = MultiplyNode;
      *unint64_t v10 = MultiplyNode;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpBinaryOperatorNodeSetLhs(v1080, *(void *)(v11 - 120));
      uint64_t v1081 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpBinaryOperatorNodeSetRhs(v1081, *(void *)(v11 + 24));
      return 0;
    case 71:
    case 286:
      uint64_t result = 0;
      *unint64_t v4 = 0;
      return result;
    case 72:
      uint64_t result = 0;
      uint64_t v127 = glpMakeMultiplyNode;
      goto LABEL_75;
    case 73:
      uint64_t result = 0;
      uint64_t v127 = glpMakeDivideNode;
      goto LABEL_75;
    case 74:
      uint64_t result = 0;
      uint64_t v127 = glpMakeModuloNode;
      goto LABEL_75;
    case 75:
      uint64_t result = 0;
      uint64_t v127 = glpMakeAddNode;
      goto LABEL_75;
    case 76:
      uint64_t result = 0;
      uint64_t v127 = glpMakeSubtractNode;
      goto LABEL_75;
    case 77:
      uint64_t result = 0;
      uint64_t v127 = glpMakeShiftLeftNode;
      goto LABEL_75;
    case 78:
      uint64_t result = 0;
      uint64_t v127 = glpMakeShiftRightNode;
      goto LABEL_75;
    case 79:
      uint64_t result = 0;
      uint64_t v127 = glpMakeBitwiseAndNode;
      goto LABEL_75;
    case 80:
      uint64_t result = 0;
      uint64_t v127 = glpMakeBitwiseXorNode;
      goto LABEL_75;
    case 81:
      uint64_t result = 0;
      uint64_t v127 = glpMakeBitwiseOrNode;
LABEL_75:
      *unint64_t v4 = (uint64_t)v127;
      return result;
    case 83:
      uint64_t v156 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1292);
      glpMakeCommaExprNode(v156, &v1292, 1);
      *unint64_t v10 = v157;
      uint64_t v158 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v159 = *v10;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpCommaExprNodeAddExpr(v158, v159, *(void *)(v11 - 120));
      uint64_t v160 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v161 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpCommaExprNodeAddExpr(v160, v161, *(void *)(v11 + 24));
      return 0;
    case 87:
      uint64_t v162 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      uint64_t v163 = glpMakeStringZ_0(*(const char **)(v11 - 184));
      uint64_t v165 = v164;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpMakeSourceLocation((uint64_t)v163, v165, *(_DWORD *)(v11 - 176), &v1291);
      glpMakePrecisionDeclarationNode(v162, &v1291);
      uint64_t v167 = v166;
      *unint64_t v10 = v166;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpPrecisionDeclarationNodeSetQualifier(v167, *(void *)(v11 - 120));
      uint64_t v168 = *v10;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpPrecisionDeclarationNodeSetType(v168, *(void *)(v11 - 48));
      return 0;
    case 88:
      uint64_t v169 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967291, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 336), &v1290);
      yyfill(v11, v1331, 4294967292, v12 == 0);
      uint64_t v170 = glpMakeStringZ_0(*(const char **)(v11 - 264));
      Interfaceuint64_t BlockNode = glpMakeInterfaceBlockNode(v169, &v1290, (uint64_t)v170, v171, (uint64_t)"<<BUG: printing instance name of interface block without an instance name>>", 0xDFA3F2CD0000004BLL, 0, 0, 0);
      *unint64_t v10 = InterfaceBlockNode;
      yyfill(v11, v1331, 4294967291, v12 == 0);
      glpInterfaceBlockNodeSetQualifiers(InterfaceBlockNode, *(void *)(v11 - 336));
      uint64_t v173 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v174 = *v10;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      __n128 v175 = *(uint64_t **)(v11 - 120);
      goto LABEL_284;
    case 89:
      uint64_t NameTable = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (glpNameTableGetGLSLVersion(NameTable) <= 4) {
        goto LABEL_82;
      }
      uint64_t v177 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967290, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 408), &v1289);
      yyfill(v11, v1331, 4294967291, v12 == 0);
      __n128 v178 = glpMakeStringZ_0(*(const char **)(v11 - 336));
      uint64_t v180 = v179;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      __n128 v181 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      uint64_t v183 = glpMakeInterfaceBlockNode(v177, &v1289, (uint64_t)v178, v180, (uint64_t)v181, v182, 1, 0, 0);
      *unint64_t v10 = v183;
      yyfill(v11, v1331, 4294967290, v12 == 0);
      glpInterfaceBlockNodeSetQualifiers(v183, *(void *)(v11 - 408));
      uint64_t v173 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v174 = *v10;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      __n128 v175 = *(uint64_t **)(v11 - 192);
      goto LABEL_284;
    case 90:
      uint64_t v184 = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (glpNameTableGetGLSLVersion(v184) <= 4)
      {
LABEL_82:
        int v112 = "Uniform blocks may not have identifiers in GLSL 140";
        goto LABEL_378;
      }
      uint64_t v1069 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967289, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 480), &v1288);
      yyfill(v11, v1331, 4294967290, v12 == 0);
      v1070 = glpMakeStringZ_0(*(const char **)(v11 - 408));
      uint64_t v1072 = v1071;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v1073 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      uint64_t v1075 = glpMakeInterfaceBlockNode(v1069, &v1288, (uint64_t)v1070, v1072, (uint64_t)v1073, v1074, 1, 1, 0);
      *unint64_t v10 = v1075;
      yyfill(v11, v1331, 4294967289, v12 == 0);
      glpInterfaceBlockNodeSetQualifiers(v1075, *(void *)(v11 - 480));
      v1076 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v1077 = *v10;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      addFields(v1076, v1077, *(uint64_t **)(v11 - 264));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      if (glpArrayTypeNodeGetElementType(*(void *)(v11 - 48)))
      {
        int v112 = "Interface blocks may not be multidimensional arrays";
        goto LABEL_378;
      }
      uint64_t v1098 = *v10;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t Dimension = glpArrayTypeNodeGetDimension(*(void *)(v11 - 48));
      glpInterfaceBlockNodeSetDimension(v1098, Dimension);
      return 0;
    case 91:
      uint64_t v185 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1287);
      glpMakeGlobalTypeQualifierNode(v185, &v1287, 0);
      uint64_t v187 = v186;
      *unint64_t v10 = v186;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpGlobalTypeQualifierNodeSetQualifierList(v187, *(void *)(v11 - 48));
      return 0;
    case 92:
      uint64_t v188 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v189 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v191 = v190;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v189, v191, *(_DWORD *)(v11 - 32), &v1286);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v192 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      glpMakeQualifiedDeclarationNode(v188, &v1286, (uint64_t)v192, v193);
      uint64_t v195 = v194;
      *unint64_t v10 = v194;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpQualifiedDeclarationNodeSetQualifiers(v195, *(void *)(v11 - 120));
      return 0;
    case 93:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 48);
      uint64_t v196 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v197 = *v10;
      uint64_t v198 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v199 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v201 = v200;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v199, v201, *(_DWORD *)(v11 - 104), &v1285);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      int v202 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      glpMakeQualifiedDeclarationNode(v198, &v1285, (uint64_t)v202, v203);
      glpQualifiedDeclarationGroupNodeInsertDeclaration(v196, v197, v204, 0);
      uint64_t result = glpQualifiedDeclarationGroupNodeGetDeclarationCount(*v10);
      if (!result) {
        return result;
      }
      int v205 = result;
      for (unsigned int i = 0; i != v205; ++i)
      {
        uint64_t Declaration = glpQualifiedDeclarationGroupNodeGetDeclaration(*v10, i);
        if (v12 && v1331[0] >= -2)
        {
          uint64_t v208 = *(void *)(v11 + 72 * v1331[0] + 8);
          uint64_t v209 = v1331[0] + 1;
          uint64_t v210 = v11 - 71 + 72 * v1331[0];
          do
          {
            if (!*(unsigned char *)(v208 + 1)) {
              goto LABEL_381;
            }
            *(unsigned char *)uint64_t v210 = 1;
            long long v211 = *(_OWORD *)(v208 + 24);
            *(void *)(v210 + 39) = *(void *)(v208 + 40);
            *(_OWORD *)(v210 + 23) = v211;
            *(_OWORD *)(v210 + 47) = *(_OWORD *)(v208 + 48);
            uint64_t v208 = *(void *)(v208 + 8);
            *(void *)(v210 + 7) = v208;
            --v209;
            v210 -= 72;
          }
          while (v209 > -2);
          v1331[0] = -3;
        }
        glpQualifiedDeclarationNodeSetQualifiers(Declaration, *(void *)(v11 - 192));
        uint64_t result = 0;
      }
      return result;
    case 94:
      uint64_t v212 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      __n128 v213 = glpMakeStringZ_0(*(const char **)(v11 - 256));
      uint64_t v215 = v214;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpMakeSourceLocation((uint64_t)v213, v215, *(_DWORD *)(v11 - 248), &v1284);
      glpMakeAvailabilityDeclarationNode(v212, &v1284);
      uint64_t v217 = v216;
      *unint64_t v10 = v216;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpAvailabilityDeclarationNodeSetExpr(v217, *(void *)(v11 - 120));
      return 0;
    case 95:
      uint64_t v218 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      __n128 v219 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v221 = v220;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v219, v221, *(_DWORD *)(v11 + 40), &v1283);
      glpMakeQualifiedDeclarationGroupNode(v218, &v1283);
      *unint64_t v10 = v222;
      uint64_t v223 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v224 = *v10;
      uint64_t v225 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      int v226 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v228 = v227;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v226, v228, *(_DWORD *)(v11 + 40), v1282);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v229 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      uint64_t v231 = v230;
      v232 = (__n128 *)v1282;
      goto LABEL_98;
    case 96:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 120);
      uint64_t v223 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v224 = *v10;
      uint64_t v225 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v233 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v235 = v234;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v233, v235, *(_DWORD *)(v11 + 40), v1281);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v229 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      uint64_t v231 = v236;
      v232 = (__n128 *)v1281;
LABEL_98:
      glpMakeQualifiedDeclarationNode(v225, v232, (uint64_t)v229, v231);
      glpQualifiedDeclarationGroupNodeAddDeclaration(v223, v224, v237);
      return 0;
    case 97:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v238 = *(void *)(v11 - 48);
      *unint64_t v10 = v238;
      Returnuint64_t Type = glpFunctionPrototypeNodeGetReturnType(v238);
      uint64_t result = glpIsQualifiedTypeNode(ReturnType);
      if (!result) {
        return result;
      }
      uint64_t Qualifiers = glpQualifiedTypeNodeGetQualifiers(ReturnType);
      v1280[0] = MEMORY[0x263EF8330];
      v1280[1] = 0x40000000;
      v1280[2] = __yyuserAction_block_invoke;
      v1280[3] = &__block_descriptor_tmp_15;
      v1280[4] = v8;
      v1280[5] = v238;
      iterateQualifiers(Qualifiers, (uint64_t)v1280);
      return 0;
    case 100:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v241 = *(void *)(v11 - 48);
      goto LABEL_103;
    case 101:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      uint64_t v241 = *(void *)(v11 - 120);
LABEL_103:
      *unint64_t v10 = v241;
      __n128 v242 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v243 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpFunctionPrototypeNodeAddParameter(v242, v243, *(void *)(v11 + 24));
      return 0;
    case 102:
      uint64_t v244 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1279);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v245 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      glpMakeFunctionPrototypeNode(v244, &v1279, (uint64_t)v245, v246);
      *unint64_t v10 = v247;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      BOOL IsQualifiedTypeNode = glpIsQualifiedTypeNode(*(void *)(v11 - 120));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t Type = *(void *)(v11 - 120);
      if (IsQualifiedTypeNode) {
        uint64_t Type = glpQualifiedTypeNodeGetType(*(void *)(v11 - 120));
      }
      yyfill(v11, v1331, 4294967294, v12 == 0);
      if (glpIsQualifiedTypeNode(*(void *)(v11 - 120)))
      {
        yyfill(v11, v1331, 4294967294, v12 == 0);
        uint64_t v250 = glpQualifiedTypeNodeGetQualifiers(*(void *)(v11 - 120));
      }
      else
      {
        uint64_t v250 = 0;
      }
      v1276.n128_u64[0] = 0;
      v1276.n128_u64[1] = (unint64_t)&v1276;
      uint64_t v1277 = 0x2000000000;
      uint64_t v1278 = 0;
      v1275[0] = MEMORY[0x263EF8330];
      v1275[1] = 0x40000000;
      v1275[2] = __yyuserAction_block_invoke_2;
      v1275[3] = &unk_264D9CA40;
      v1275[4] = &v1276;
      v1275[5] = v8;
      v1275[6] = Type;
      uint64_t v1271 = 0;
      v1272 = &v1271;
      uint64_t v1273 = 0x2000000000;
      uint64_t v1274 = 0;
      v1266[0] = MEMORY[0x263EF8330];
      v1266[1] = 0x40000000;
      v1267 = __yyuserAction_block_invoke_3;
      v1268 = &unk_264D9CA68;
      v1269 = &v1271;
      uint64_t v1270 = v8;
      v1265[0] = MEMORY[0x263EF8330];
      v1265[1] = 0x40000000;
      v1265[2] = __yyuserAction_block_invoke_4;
      v1265[3] = &unk_264D9CA90;
      v1265[4] = v1275;
      v1265[5] = v1266;
      iterateQualifiers(v250, (uint64_t)v1265);
      uint64_t v1082 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1264);
      glpMakeQualifiedTypeNode(v1082, &v1264);
      uint64_t v1084 = v1083;
      glpQualifiedTypeNodeSetType(v1083, Type);
      glpQualifiedTypeNodeSetQualifiers(v1084, *(void *)(v1276.n128_u64[1] + 24));
      glpFunctionPrototypeNodeSetReturnType(*v10, v1084);
      if (!glpIsPrimitiveTypeNode(Type) || glpPrimitiveTypeNodeGetType(Type))
      {
        uint64_t v1085 = glpCompilerGetAllocator(*(void *)(v8 + 784));
        yyfill(v11, v1331, 4294967294, v12 == 0);
        glpASTNodeGetLocation(*(void *)(v11 - 120), &v1263);
        uint64_t KeywordQualifierNode = glpMakeKeywordQualifierNode(v1085, &v1263, 14);
        v1267((uint64_t)v1266, KeywordQualifierNode);
        qsort_b(*(void **)(v1272[3] + 8), *(unsigned int *)(v1272[3] + 4), 8uLL, &__block_literal_global_5);
        uint64_t v1087 = glpCompilerGetAllocator(*(void *)(v8 + 784));
        glpASTNodeGetLocation(Type, &v1262);
        glpMakeQualifierListNode(v1087, &v1262);
        uint64_t v1089 = v1088;
        if (*(_DWORD *)(v1272[3] + 4))
        {
          unint64_t v1090 = 0;
          do
          {
            v1091 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
            glpQualifierListNodeAddQualifier(v1091, v1089, *(void *)(*(void *)(v1272[3] + 8) + 8 * v1090++));
          }
          while (v1090 < *(unsigned int *)(v1272[3] + 4));
        }
        uint64_t v1092 = glpCompilerGetAllocator(*(void *)(v8 + 784));
        yyfill(v11, v1331, 4294967294, v12 == 0);
        glpASTNodeGetLocation(*(void *)(v11 - 120), &v1261);
        glpMakeQualifiedTypeNode(v1092, &v1261);
        uint64_t v1094 = v1093;
        glpQualifiedTypeNodeSetType(v1093, Type);
        glpQualifiedTypeNodeSetQualifiers(v1094, v1089);
        uint64_t v1095 = glpCompilerGetAllocator(*(void *)(v8 + 784));
        yyfill(v11, v1331, 4294967294, v12 == 0);
        glpASTNodeGetLocation(*(void *)(v11 - 120), &v1260);
        glpMakeParameterDeclarationNode(v1095, &v1260, (uint64_t)"$return_value", 0xE306948F0000000DLL);
        uint64_t v1097 = v1096;
        glpParameterDeclarationNodeSetType(v1096, v1094);
        glpFunctionPrototypeNodeSetReturnOutParam(*v10, v1097);
      }
      _Block_object_dispose(&v1271, 8);
      _Block_object_dispose(&v1276, 8);
      return 0;
    case 103:
      uint64_t v251 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1259);
      yyfill(v11, v1331, 0, v12 == 0);
      __n128 v252 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeParameterDeclarationNode(v251, &v1259, (uint64_t)v252, v253);
      uint64_t v255 = v254;
      *unint64_t v10 = v254;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v256 = *(void *)(v11 - 48);
      goto LABEL_113;
    case 104:
      uint64_t v257 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1258);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v258 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      glpMakeParameterDeclarationNode(v257, &v1258, (uint64_t)v258, v259);
      uint64_t v261 = v260;
      *unint64_t v10 = v260;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v262 = *(void *)(v11 - 120);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v263 = *(void *)(v11 + 24);
      arrayify(v262, v263);
      uint64_t v264 = v261;
      uint64_t v256 = v263;
      goto LABEL_114;
    case 105:
      yyfill(v3, v1331, 0, v12 == 0);
      *unint64_t v10 = *(void *)(v11 + 24);
      uint64_t v265 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1257);
      glpMakeQualifiedTypeNode(v265, &v1257);
      uint64_t v267 = v266;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpQualifiedTypeNodeSetQualifiers(v267, *(void *)(v11 - 48));
      uint64_t v268 = glpParameterDeclarationNodeGetType(*v10);
      glpQualifiedTypeNodeSetType(v267, v268);
      uint64_t v264 = *v10;
      uint64_t v256 = v267;
      goto LABEL_114;
    case 107:
      uint64_t v269 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1256);
      glpMakeQualifiedTypeNode(v269, &v1256);
      uint64_t v271 = v270;
      yyfill(v11, v1331, 0, v12 == 0);
      glpQualifiedTypeNodeSetType(v271, *(void *)(v11 + 24));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpQualifiedTypeNodeSetQualifiers(v271, *(void *)(v11 - 48));
      uint64_t v272 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1255);
      glpMakeParameterDeclarationNode(v272, &v1255, (uint64_t)"<<unnamed>>", 0x725D7890000000BLL);
      *unint64_t v10 = v264;
      uint64_t v256 = v271;
      goto LABEL_114;
    case 108:
      uint64_t v273 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1254);
      glpMakeParameterDeclarationNode(v273, &v1254, (uint64_t)"<<unnamed>>", 0x725D7890000000BLL);
      uint64_t v255 = v274;
      *unint64_t v10 = v274;
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v256 = *(void *)(v11 + 24);
LABEL_113:
      uint64_t v264 = v255;
LABEL_114:
      glpParameterDeclarationNodeSetType(v264, v256);
      return 0;
    case 110:
      uint64_t v275 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1253);
      glpMakeVariableDeclarationGroupNode(v275, &v1253);
      uint64_t v277 = v276;
      *unint64_t v10 = v276;
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationGroupNodeSetBaseType(v277, *(void *)(v11 + 32));
      yyfill(v11, v1331, 0, v12 == 0);
      unsigned int Kind = glpASTNodeGetKind(*(void *)(v11 + 24));
      if (Kind > 0x38) {
        goto LABEL_381;
      }
      unsigned int v279 = Kind;
      uint64_t result = 0;
      if (((1 << v279) & 0x170000000000004) != 0) {
        return result;
      }
      if (v279 != 46) {
        goto LABEL_381;
      }
      v280 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v281 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationGroupNodeAddDeclaration(v280, v281, *(void *)(v11 + 24));
      return 0;
    case 111:
      uint64_t v282 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v283 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v285 = v284;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v283, v285, *(_DWORD *)(v11 + 40), &v1252);
      yyfill(v11, v1331, 0, v12 == 0);
      v286 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeVariableDeclarationNode(v282, &v1252, (uint64_t)v286, v287, 1);
      uint64_t v289 = v288;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      Baseuint64_t Type = glpVariableDeclarationGroupNodeGetBaseType(*(void *)(v11 - 120));
      glpVariableDeclarationNodeSetType(v289, BaseType);
      v291 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpVariableDeclarationGroupNodeAddDeclaration(v291, *(void *)(v11 - 120), v289);
      goto LABEL_186;
    case 112:
      uint64_t v292 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v293 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v295 = v294;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v293, v295, *(_DWORD *)(v11 - 32), &v1251);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v296 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      glpMakeVariableDeclarationNode(v292, &v1251, (uint64_t)v296, v297, 1);
      uint64_t v299 = v298;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      uint64_t v300 = glpVariableDeclarationGroupNodeGetBaseType(*(void *)(v11 - 192));
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v301 = *(void *)(v11 + 24);
      arrayify(v300, v301);
      glpVariableDeclarationNodeSetType(v299, v301);
      v302 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpVariableDeclarationGroupNodeAddDeclaration(v302, *(void *)(v11 - 192), v299);
      goto LABEL_188;
    case 113:
      uint64_t v303 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      v304 = glpMakeStringZ_0(*(const char **)(v11 - 184));
      uint64_t v306 = v305;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpMakeSourceLocation((uint64_t)v304, v306, *(_DWORD *)(v11 - 176), &v1250);
      yyfill(v11, v1331, 4294967293, v12 == 0);
      v307 = glpMakeStringZ_0(*(const char **)(v11 - 192));
      glpMakeVariableDeclarationNode(v303, &v1250, (uint64_t)v307, v308, 1);
      uint64_t v310 = v309;
      yyfill(v11, v1331, 4294967291, v12 == 0);
      v311 = (uint64_t *)(v11 - 336);
      uint64_t v312 = glpVariableDeclarationGroupNodeGetBaseType(*(void *)(v11 - 336));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v313 = *(void *)(v11 - 120);
      arrayify(v312, v313);
      glpVariableDeclarationNodeSetType(v310, v313);
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationNodeSetInitializer(v310, *(void *)(v11 + 24));
      v314 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967291, v12 == 0);
      glpVariableDeclarationGroupNodeAddDeclaration(v314, *(void *)(v11 - 336), v310);
      uint64_t v315 = v11;
      uint64_t v316 = 4294967291;
      goto LABEL_123;
    case 114:
      uint64_t v317 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v318 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v320 = v319;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v318, v320, *(_DWORD *)(v11 - 104), &v1249);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v321 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      glpMakeVariableDeclarationNode(v317, &v1249, (uint64_t)v321, v322, 1);
      uint64_t v324 = v323;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      v311 = (uint64_t *)(v11 - 264);
      uint64_t v325 = glpVariableDeclarationGroupNodeGetBaseType(*(void *)(v11 - 264));
      glpVariableDeclarationNodeSetType(v324, v325);
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationNodeSetInitializer(v324, *(void *)(v11 + 24));
      v326 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpVariableDeclarationGroupNodeAddDeclaration(v326, *(void *)(v11 - 264), v324);
      uint64_t v315 = v11;
      uint64_t v316 = 4294967292;
LABEL_123:
      yyfill(v315, v1331, v316, v12 == 0);
      uint64_t result = 0;
      uint64_t v24 = *v311;
      goto LABEL_280;
    case 115:
      yyfill(v3, v1331, 0, v12 == 0);
      uint64_t v327 = *(void *)(v11 + 24);
      goto LABEL_349;
    case 116:
      uint64_t v328 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1248);
      yyfill(v11, v1331, 0, v12 == 0);
      v329 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeVariableDeclarationNode(v328, &v1248, (uint64_t)v329, v330, 1);
      uint64_t v332 = v331;
      *unint64_t v10 = v331;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpVariableDeclarationNodeSetType(v332, *(void *)(v11 - 48));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t result = 0;
      uint64_t v333 = *(void *)(v11 - 48);
      goto LABEL_350;
    case 117:
      uint64_t v334 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 120), &v1247);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v335 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      glpMakeVariableDeclarationNode(v334, &v1247, (uint64_t)v335, v336, 1);
      uint64_t v338 = v337;
      *unint64_t v10 = v337;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v339 = *(void *)(v11 - 120);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v340 = *(void *)(v11 + 24);
      arrayify(v339, v340);
      glpVariableDeclarationNodeSetType(v338, v340);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t result = 0;
      uint64_t v333 = *(void *)(v11 - 120);
      goto LABEL_350;
    case 118:
      uint64_t v341 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 264), &v1246);
      yyfill(v11, v1331, 4294967293, v12 == 0);
      v342 = glpMakeStringZ_0(*(const char **)(v11 - 192));
      glpMakeVariableDeclarationNode(v341, &v1246, (uint64_t)v342, v343, 1);
      uint64_t v345 = v344;
      *unint64_t v10 = v344;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      uint64_t v346 = *(void *)(v11 - 264);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v347 = *(void *)(v11 - 120);
      arrayify(v346, v347);
      glpVariableDeclarationNodeSetType(v345, v347);
      uint64_t v348 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationNodeSetInitializer(v348, *(void *)(v11 + 24));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      uint64_t result = 0;
      uint64_t v333 = *(void *)(v11 - 264);
      goto LABEL_350;
    case 119:
      uint64_t v349 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 192), &v1245);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v350 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      glpMakeVariableDeclarationNode(v349, &v1245, (uint64_t)v350, v351, 1);
      uint64_t v353 = v352;
      *unint64_t v10 = v352;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpVariableDeclarationNodeSetType(v353, *(void *)(v11 - 192));
      uint64_t v354 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationNodeSetInitializer(v354, *(void *)(v11 + 24));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      uint64_t result = 0;
      uint64_t v333 = *(void *)(v11 - 192);
      goto LABEL_350;
    case 121:
      uint64_t v355 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1244);
      glpMakeQualifiedTypeNode(v355, &v1244);
      uint64_t v357 = v356;
      *unint64_t v10 = v356;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpQualifiedTypeNodeSetQualifiers(v357, *(void *)(v11 - 48));
      uint64_t v358 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpQualifiedTypeNodeSetType(v358, *(void *)(v11 + 24));
      return 0;
    case 122:
      uint64_t v359 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v360 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v362 = v361;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v360, v362, *(_DWORD *)(v11 + 40), v1243);
      v363 = (__n128 *)v1243;
      uint64_t v364 = v359;
      int v365 = 1;
      goto LABEL_278;
    case 123:
      uint64_t v366 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v367 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v369 = v368;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v367, v369, *(_DWORD *)(v11 + 40), v1242);
      v363 = (__n128 *)v1242;
      uint64_t v364 = v366;
      int v365 = 2;
      goto LABEL_278;
    case 124:
      uint64_t v370 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v371 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v373 = v372;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v371, v373, *(_DWORD *)(v11 + 40), v1241);
      v363 = (__n128 *)v1241;
      uint64_t v364 = v370;
      int v365 = 3;
      goto LABEL_278;
    case 125:
      uint64_t v374 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v375 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v377 = v376;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v375, v377, *(_DWORD *)(v11 + 40), v1240);
      v363 = (__n128 *)v1240;
      uint64_t v364 = v374;
      int v365 = 4;
      goto LABEL_278;
    case 127:
      uint64_t v378 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1239);
      glpMakeLayoutTypeNode(v378, &v1239);
      *unint64_t v10 = v379;
      goto LABEL_136;
    case 128:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 120);
LABEL_136:
      v380 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v381 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpLayoutTypeNodeAddLayoutPair(v380, v381, *(void *)(v11 + 24));
      return 0;
    case 130:
      uint64_t v382 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1238);
      *unint64_t v10 = glpMakeLayoutQualifierNode(v382, &v1238);
      goto LABEL_139;
    case 131:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 120);
LABEL_139:
      v383 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v384 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpLayoutQualifierNodeAddLayoutPair(v383, v384, *(void *)(v11 + 24));
      return 0;
    case 132:
      uint64_t v385 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v386 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v388 = v387;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v386, v388, *(_DWORD *)(v11 + 40), v1237);
      yyfill(v11, v1331, 0, v12 == 0);
      v389 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      uint64_t v391 = v390;
      v392 = "<<BUG: printing string of non-string layout>>";
      v393 = (__n128 *)v1237;
      uint64_t v394 = v385;
      int v395 = 0;
      int v396 = 0;
      goto LABEL_154;
    case 133:
      uint64_t v397 = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (glpNameTableGetGLSLVersion(v397) <= 4)
      {
        uint64_t v398 = glpCompilerGetNameTable(*(void *)(v8 + 784));
        if (!glpNameTableIsExtensionEnabled(v398, 0x23u))
        {
          uint64_t v399 = glpCompilerGetNameTable(*(void *)(v8 + 784));
          if (!glpNameTableIsExtensionEnabled(v399, 1u))
          {
            uint64_t v400 = glpCompilerGetNameTable(*(void *)(v8 + 784));
            if (!glpNameTableIsExtensionEnabled(v400, 0x15u))
            {
              uint64_t v401 = glpCompilerGetNameTable(*(void *)(v8 + 784));
              if (!glpNameTableIsExtensionEnabled(v401, 0x11u)) {
                goto LABEL_380;
              }
            }
          }
        }
      }
      uint64_t v402 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v403 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v405 = v404;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v403, v405, *(_DWORD *)(v11 - 104), v1236);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v406 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      uint64_t v408 = v407;
      yyfill(v11, v1331, 0, v12 == 0);
      int v396 = *(_DWORD *)(v11 + 24);
      v392 = "<<BUG: printing string of non-string layout>>";
      v393 = (__n128 *)v1236;
      goto LABEL_153;
    case 134:
      uint64_t v409 = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (glpNameTableGetGLSLVersion(v409) <= 4)
      {
        uint64_t v410 = glpCompilerGetNameTable(*(void *)(v8 + 784));
        if (!glpNameTableIsExtensionEnabled(v410, 0x23u))
        {
          uint64_t v411 = glpCompilerGetNameTable(*(void *)(v8 + 784));
          if (!glpNameTableIsExtensionEnabled(v411, 1u))
          {
            uint64_t v412 = glpCompilerGetNameTable(*(void *)(v8 + 784));
            if (!glpNameTableIsExtensionEnabled(v412, 0x15u))
            {
              uint64_t v413 = glpCompilerGetNameTable(*(void *)(v8 + 784));
              if (!glpNameTableIsExtensionEnabled(v413, 0x11u))
              {
LABEL_380:
                int v112 = "integers in layouts require GLSL 140 or later";
                goto LABEL_378;
              }
            }
          }
        }
      }
      uint64_t v402 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v414 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v416 = v415;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v414, v416, *(_DWORD *)(v11 - 104), v1235);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v406 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      uint64_t v408 = v417;
      yyfill(v11, v1331, 0, v12 == 0);
      int v396 = *(_DWORD *)(v11 + 24);
      v392 = "<<BUG: printing string of non-string layout>>";
      v393 = (__n128 *)v1235;
LABEL_153:
      uint64_t v394 = v402;
      v389 = v406;
      uint64_t v391 = v408;
      int v395 = 1;
LABEL_154:
      uint64_t v418 = 0x4FE9A940000002DLL;
      goto LABEL_155;
    case 135:
      uint64_t v419 = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (!glpNameTableIsExtensionEnabled(v419, 0x23u))
      {
        int v112 = "types in layouts is an unsupported extension";
        goto LABEL_378;
      }
      uint64_t v420 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v421 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v423 = v422;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v421, v423, *(_DWORD *)(v11 - 104), &v1234);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v424 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      glpMakeLayoutPairNode(v420, &v1234, (uint64_t)v424, v425, 2, 0, (uint64_t)"<<BUG: printing string of non-string layout>>", 0x4FE9A940000002DLL);
      uint64_t v427 = v426;
      *unint64_t v10 = v426;
      yyfill(v11, v1331, 0, v12 == 0);
      glpLayoutPairNodeSetType(v427, *(void *)(v11 + 24));
      return 0;
    case 136:
      uint64_t v428 = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (!glpNameTableIsExtensionEnabled(v428, 0x23u))
      {
        int v112 = "identifiers in layouts is an unsupported extension";
        goto LABEL_378;
      }
      uint64_t v429 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v430 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v432 = v431;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v430, v432, *(_DWORD *)(v11 - 104), v1233);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v433 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      uint64_t v435 = v434;
      yyfill(v11, v1331, 0, v12 == 0);
      v392 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      uint64_t v418 = v436;
      v393 = (__n128 *)v1233;
      uint64_t v394 = v429;
      v389 = v433;
      uint64_t v391 = v435;
      int v395 = 3;
      int v396 = 0;
LABEL_155:
      glpMakeLayoutPairNode(v394, v393, (uint64_t)v389, v391, v395, v396, (uint64_t)v392, v418);
LABEL_279:
      uint64_t v24 = BlockNode;
      uint64_t result = 0;
      goto LABEL_280;
    case 137:
      uint64_t v437 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v438 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v440 = v439;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v438, v440, *(_DWORD *)(v11 + 40), v1232);
      v363 = (__n128 *)v1232;
      uint64_t v364 = v437;
      int v365 = 0;
      goto LABEL_278;
    case 138:
      uint64_t v441 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1231);
      glpMakeQualifierListNode(v441, &v1231);
      *unint64_t v10 = v442;
      goto LABEL_163;
    case 139:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 48);
LABEL_163:
      v443 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v444 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpQualifierListNodeAddQualifier(v443, v444, *(void *)(v11 + 24));
      return 0;
    case 146:
      uint64_t v445 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v446 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v448 = v447;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v446, v448, *(_DWORD *)(v11 + 40), v1230);
      v363 = (__n128 *)v1230;
      uint64_t v364 = v445;
      int v365 = 5;
      goto LABEL_278;
    case 147:
      uint64_t v449 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v450 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v452 = v451;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v450, v452, *(_DWORD *)(v11 + 40), v1229);
      v363 = (__n128 *)v1229;
      uint64_t v364 = v449;
      int v365 = 15;
      goto LABEL_278;
    case 148:
      uint64_t v453 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v454 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v456 = v455;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v454, v456, *(_DWORD *)(v11 + 40), v1228);
      v363 = (__n128 *)v1228;
      uint64_t v364 = v453;
      int v365 = 13;
      goto LABEL_278;
    case 149:
      uint64_t v457 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v458 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v460 = v459;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v458, v460, *(_DWORD *)(v11 + 40), v1227);
      v363 = (__n128 *)v1227;
      uint64_t v364 = v457;
      int v365 = 14;
      goto LABEL_278;
    case 150:
      uint64_t v461 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v462 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v464 = v463;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v462, v464, *(_DWORD *)(v11 + 40), v1226);
      v363 = (__n128 *)v1226;
      uint64_t v364 = v461;
      int v365 = 6;
      goto LABEL_278;
    case 151:
      uint64_t v465 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v466 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v468 = v467;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v466, v468, *(_DWORD *)(v11 + 40), v1225);
      v363 = (__n128 *)v1225;
      uint64_t v364 = v465;
      int v365 = 7;
      goto LABEL_278;
    case 152:
      uint64_t v469 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v470 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v472 = v471;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v470, v472, *(_DWORD *)(v11 + 40), v1224);
      v363 = (__n128 *)v1224;
      uint64_t v364 = v469;
      int v365 = 8;
      goto LABEL_278;
    case 153:
      uint64_t v473 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v474 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v476 = v475;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v474, v476, *(_DWORD *)(v11 + 40), v1223);
      v363 = (__n128 *)v1223;
      uint64_t v364 = v473;
      int v365 = 16;
      goto LABEL_278;
    case 154:
      uint64_t v477 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v478 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v480 = v479;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v478, v480, *(_DWORD *)(v11 + 40), v1222);
      v363 = (__n128 *)v1222;
      uint64_t v364 = v477;
      int v365 = 10;
      goto LABEL_278;
    case 156:
      uint64_t v481 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v482 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v484 = v483;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v482, v484, *(_DWORD *)(v11 + 40), v1221);
      v363 = (__n128 *)v1221;
      uint64_t v364 = v481;
      int v365 = 17;
      goto LABEL_278;
    case 157:
      uint64_t v485 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v486 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v488 = v487;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v486, v488, *(_DWORD *)(v11 + 40), v1220);
      v363 = (__n128 *)v1220;
      uint64_t v364 = v485;
      int v365 = 18;
      goto LABEL_278;
    case 158:
      uint64_t v489 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v490 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v492 = v491;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v490, v492, *(_DWORD *)(v11 + 40), v1219);
      v363 = (__n128 *)v1219;
      uint64_t v364 = v489;
      int v365 = 9;
      goto LABEL_278;
    case 159:
      uint64_t v493 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v494 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v496 = v495;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v494, v496, *(_DWORD *)(v11 + 40), v1218);
      v363 = (__n128 *)v1218;
      uint64_t v364 = v493;
      int v365 = 11;
      goto LABEL_278;
    case 160:
      uint64_t v497 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v498 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v500 = v499;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v498, v500, *(_DWORD *)(v11 + 40), v1217);
      v363 = (__n128 *)v1217;
      uint64_t v364 = v497;
      int v365 = 12;
      goto LABEL_278;
    case 161:
      uint64_t v501 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v502 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v504 = v503;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v502, v504, *(_DWORD *)(v11 + 40), &v1216);
      *unint64_t v10 = glpMakeSubroutineTypeListNode(v501, &v1216);
      v505 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v506 = *v10;
      uint64_t v507 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v508 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v510 = v509;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v508, v510, *(_DWORD *)(v11 + 40), v1215);
      yyfill(v11, v1331, 0, v12 == 0);
      v511 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      uint64_t v513 = v512;
      v514 = (__n128 *)v1215;
      goto LABEL_180;
    case 162:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 120);
      v505 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v506 = *v10;
      uint64_t v507 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v515 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v517 = v516;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v515, v517, *(_DWORD *)(v11 + 40), v1214);
      yyfill(v11, v1331, 0, v12 == 0);
      v511 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      uint64_t v513 = v518;
      v514 = (__n128 *)v1214;
LABEL_180:
      glpMakeTypeIdentifierNode(v507, v514, (uint64_t)v511, v513);
      glpSubroutineTypeListNodeAddType(v505, v506, v519);
      return 0;
    case 164:
      uint64_t v520 = glpCompilerGetNameTable(*(void *)(v7 + 784));
      if (glpNameTableGetGLSLVersion(v520) > 1)
      {
        yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
        uint64_t v1078 = *(void *)(v11 - 48);
        yyfill(v11, v1331, 0, v12 == 0);
        uint64_t v1079 = *(void *)(v11 + 24);
        arrayify(v1078, v1079);
        uint64_t result = 0;
        *unint64_t v10 = v1079;
      }
      else
      {
        int v112 = "Array size must appear after variable name";
LABEL_378:
        yyerror(0, v8, (char)v112);
        *uint64_t v9 = 0;
        return 3;
      }
      return result;
    case 165:
      uint64_t v521 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v522 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v524 = v523;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v522, v524, *(_DWORD *)(v11 - 32), &v1213);
      glpMakeArrayTypeNode(v521, &v1213);
      goto LABEL_279;
    case 166:
      uint64_t v525 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v526 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v528 = v527;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v526, v528, *(_DWORD *)(v11 - 104), &v1212);
      glpMakeArrayTypeNode(v525, &v1212);
      uint64_t v530 = v529;
      *unint64_t v10 = v529;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpArrayTypeNodeSetDimension(v530, *(void *)(v11 - 48));
      return 0;
    case 167:
      uint64_t v531 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v532 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v534 = v533;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v532, v534, *(_DWORD *)(v11 - 32), &v1211);
      glpMakeArrayTypeNode(v531, &v1211);
      uint64_t v536 = v535;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpArrayTypeNodeSetElementType(*(void *)(v11 - 120), v536);
LABEL_186:
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t result = 0;
      uint64_t v24 = *(void *)(v11 - 120);
      goto LABEL_280;
    case 168:
      uint64_t v537 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v538 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v540 = v539;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v538, v540, *(_DWORD *)(v11 - 104), &v1210);
      glpMakeArrayTypeNode(v537, &v1210);
      uint64_t v542 = v541;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpArrayTypeNodeSetDimension(v542, *(void *)(v11 - 48));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpArrayTypeNodeSetElementType(*(void *)(v11 - 192), v542);
LABEL_188:
      yyfill(v11, v1331, 4294967293, v12 == 0);
      uint64_t result = 0;
      uint64_t v24 = *(void *)(v11 - 192);
      goto LABEL_280;
    case 169:
      uint64_t v543 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v544 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v546 = v545;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v544, v546, *(_DWORD *)(v11 + 40), v1209);
      v547 = (__n128 *)v1209;
      uint64_t v548 = v543;
      int v549 = 0;
      goto LABEL_271;
    case 170:
      uint64_t v550 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v551 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v553 = v552;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v551, v553, *(_DWORD *)(v11 + 40), v1208);
      v547 = (__n128 *)v1208;
      uint64_t v548 = v550;
      int v549 = 1;
      goto LABEL_271;
    case 171:
      uint64_t v554 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v555 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v557 = v556;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v555, v557, *(_DWORD *)(v11 + 40), v1207);
      v558 = (__n128 *)v1207;
      uint64_t v559 = v554;
      int v560 = 62;
      goto LABEL_230;
    case 172:
      uint64_t v561 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v562 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v564 = v563;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v562, v564, *(_DWORD *)(v11 + 40), v1206);
      v547 = (__n128 *)v1206;
      uint64_t v548 = v561;
      int v549 = 5;
      goto LABEL_271;
    case 173:
      uint64_t v565 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v566 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v568 = v567;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v566, v568, *(_DWORD *)(v11 + 40), v1205);
      v547 = (__n128 *)v1205;
      goto LABEL_195;
    case 174:
      uint64_t v565 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v569 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v571 = v570;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v569, v571, *(_DWORD *)(v11 - 32), v1204);
      v547 = (__n128 *)v1204;
LABEL_195:
      uint64_t v548 = v565;
      int v549 = 36;
      goto LABEL_271;
    case 175:
      uint64_t v572 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v573 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v575 = v574;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v573, v575, *(_DWORD *)(v11 + 40), v1203);
      v547 = (__n128 *)v1203;
      uint64_t v548 = v572;
      int v549 = 9;
      goto LABEL_271;
    case 176:
      uint64_t v576 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v577 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v579 = v578;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v577, v579, *(_DWORD *)(v11 + 40), v1202);
      v547 = (__n128 *)v1202;
      uint64_t v548 = v576;
      int v549 = 2;
      goto LABEL_271;
    case 177:
      uint64_t v580 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v581 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v583 = v582;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v581, v583, *(_DWORD *)(v11 + 40), v1201);
      v547 = (__n128 *)v1201;
      uint64_t v548 = v580;
      int v549 = 3;
      goto LABEL_271;
    case 178:
      uint64_t v584 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v585 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v587 = v586;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v585, v587, *(_DWORD *)(v11 + 40), v1200);
      v547 = (__n128 *)v1200;
      uint64_t v548 = v584;
      int v549 = 4;
      goto LABEL_271;
    case 179:
      uint64_t v588 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v589 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v591 = v590;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v589, v591, *(_DWORD *)(v11 + 40), v1199);
      v558 = (__n128 *)v1199;
      uint64_t v559 = v588;
      int v560 = 63;
      goto LABEL_230;
    case 180:
      uint64_t v592 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v593 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v595 = v594;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v593, v595, *(_DWORD *)(v11 + 40), v1198);
      v558 = (__n128 *)v1198;
      uint64_t v559 = v592;
      int v560 = 64;
      goto LABEL_230;
    case 181:
      uint64_t v596 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v597 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v599 = v598;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v597, v599, *(_DWORD *)(v11 + 40), v1197);
      v558 = (__n128 *)v1197;
      uint64_t v559 = v596;
      int v560 = 65;
      goto LABEL_230;
    case 182:
      uint64_t v600 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v601 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v603 = v602;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v601, v603, *(_DWORD *)(v11 + 40), v1196);
      v547 = (__n128 *)v1196;
      uint64_t v548 = v600;
      int v549 = 10;
      goto LABEL_271;
    case 183:
      uint64_t v604 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v605 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v607 = v606;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v605, v607, *(_DWORD *)(v11 + 40), v1195);
      v547 = (__n128 *)v1195;
      uint64_t v548 = v604;
      int v549 = 11;
      goto LABEL_271;
    case 184:
      uint64_t v608 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v609 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v611 = v610;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v609, v611, *(_DWORD *)(v11 + 40), v1194);
      v547 = (__n128 *)v1194;
      uint64_t v548 = v608;
      int v549 = 12;
      goto LABEL_271;
    case 185:
      uint64_t v612 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v613 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v615 = v614;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v613, v615, *(_DWORD *)(v11 + 40), v1193);
      v547 = (__n128 *)v1193;
      uint64_t v548 = v612;
      int v549 = 6;
      goto LABEL_271;
    case 186:
      uint64_t v616 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v617 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v619 = v618;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v617, v619, *(_DWORD *)(v11 + 40), v1192);
      v547 = (__n128 *)v1192;
      uint64_t v548 = v616;
      int v549 = 7;
      goto LABEL_271;
    case 187:
      uint64_t v620 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v621 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v623 = v622;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v621, v623, *(_DWORD *)(v11 + 40), v1191);
      v547 = (__n128 *)v1191;
      uint64_t v548 = v620;
      int v549 = 8;
      goto LABEL_271;
    case 188:
      uint64_t v624 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v625 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v627 = v626;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v625, v627, *(_DWORD *)(v11 + 40), v1190);
      v547 = (__n128 *)v1190;
      uint64_t v548 = v624;
      int v549 = 37;
      goto LABEL_271;
    case 189:
      uint64_t v628 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v629 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v631 = v630;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v629, v631, *(_DWORD *)(v11 + 40), v1189);
      v547 = (__n128 *)v1189;
      uint64_t v548 = v628;
      int v549 = 38;
      goto LABEL_271;
    case 190:
      uint64_t v632 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v633 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v635 = v634;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v633, v635, *(_DWORD *)(v11 + 40), v1188);
      v547 = (__n128 *)v1188;
      uint64_t v548 = v632;
      int v549 = 39;
      goto LABEL_271;
    case 191:
      uint64_t v636 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v637 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v639 = v638;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v637, v639, *(_DWORD *)(v11 + 40), v1187);
      v547 = (__n128 *)v1187;
      uint64_t v548 = v636;
      int v549 = 13;
      goto LABEL_271;
    case 192:
      uint64_t v640 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v641 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v643 = v642;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v641, v643, *(_DWORD *)(v11 + 40), v1186);
      v547 = (__n128 *)v1186;
      uint64_t v548 = v640;
      int v549 = 22;
      goto LABEL_271;
    case 193:
      uint64_t v644 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v645 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v647 = v646;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v645, v647, *(_DWORD *)(v11 + 40), v1185);
      v547 = (__n128 *)v1185;
      uint64_t v548 = v644;
      int v549 = 23;
      goto LABEL_271;
    case 194:
      uint64_t v648 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v649 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v651 = v650;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v649, v651, *(_DWORD *)(v11 + 40), v1184);
      v547 = (__n128 *)v1184;
      uint64_t v548 = v648;
      int v549 = 24;
      goto LABEL_271;
    case 195:
      uint64_t v652 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v653 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v655 = v654;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v653, v655, *(_DWORD *)(v11 + 40), v1183);
      v547 = (__n128 *)v1183;
      uint64_t v548 = v652;
      int v549 = 14;
      goto LABEL_271;
    case 196:
      uint64_t v656 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v657 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v659 = v658;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v657, v659, *(_DWORD *)(v11 + 40), v1182);
      v547 = (__n128 *)v1182;
      uint64_t v548 = v656;
      int v549 = 25;
      goto LABEL_271;
    case 197:
      uint64_t v660 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v661 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v663 = v662;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v661, v663, *(_DWORD *)(v11 + 40), v1181);
      v547 = (__n128 *)v1181;
      uint64_t v548 = v660;
      int v549 = 26;
      goto LABEL_271;
    case 198:
      uint64_t v664 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v665 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v667 = v666;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v665, v667, *(_DWORD *)(v11 + 40), v1180);
      v547 = (__n128 *)v1180;
      uint64_t v548 = v664;
      int v549 = 27;
      goto LABEL_271;
    case 199:
      uint64_t v668 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v669 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v671 = v670;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v669, v671, *(_DWORD *)(v11 + 40), v1179);
      v547 = (__n128 *)v1179;
      uint64_t v548 = v668;
      int v549 = 15;
      goto LABEL_271;
    case 200:
      uint64_t v672 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v673 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v675 = v674;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v673, v675, *(_DWORD *)(v11 + 40), v1178);
      v558 = (__n128 *)v1178;
      uint64_t v559 = v672;
      int v560 = 66;
      goto LABEL_230;
    case 201:
      uint64_t v676 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v677 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v679 = v678;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v677, v679, *(_DWORD *)(v11 + 40), v1177);
      v558 = (__n128 *)v1177;
      uint64_t v559 = v676;
      int v560 = 69;
      goto LABEL_230;
    case 202:
      uint64_t v680 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v681 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v683 = v682;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v681, v683, *(_DWORD *)(v11 + 40), v1176);
      v558 = (__n128 *)v1176;
      uint64_t v559 = v680;
      int v560 = 70;
      goto LABEL_230;
    case 203:
      uint64_t v684 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v685 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v687 = v686;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v685, v687, *(_DWORD *)(v11 + 40), v1175);
      v558 = (__n128 *)v1175;
      uint64_t v559 = v684;
      int v560 = 71;
      goto LABEL_230;
    case 204:
      uint64_t v688 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v689 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v691 = v690;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v689, v691, *(_DWORD *)(v11 + 40), v1174);
      v558 = (__n128 *)v1174;
      uint64_t v559 = v688;
      int v560 = 67;
      goto LABEL_230;
    case 205:
      uint64_t v692 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v693 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v695 = v694;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v693, v695, *(_DWORD *)(v11 + 40), v1173);
      v558 = (__n128 *)v1173;
      uint64_t v559 = v692;
      int v560 = 72;
      goto LABEL_230;
    case 206:
      uint64_t v696 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v697 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v699 = v698;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v697, v699, *(_DWORD *)(v11 + 40), v1172);
      v558 = (__n128 *)v1172;
      uint64_t v559 = v696;
      int v560 = 73;
      goto LABEL_230;
    case 207:
      uint64_t v700 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v701 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v703 = v702;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v701, v703, *(_DWORD *)(v11 + 40), v1171);
      v558 = (__n128 *)v1171;
      uint64_t v559 = v700;
      int v560 = 74;
      goto LABEL_230;
    case 208:
      uint64_t v704 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v705 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v707 = v706;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v705, v707, *(_DWORD *)(v11 + 40), v1170);
      v558 = (__n128 *)v1170;
      uint64_t v559 = v704;
      int v560 = 68;
LABEL_230:
      __n128 PrimitiveTypeNode = glpMakePrimitiveTypeNode(v559, v558, v560);
      *unint64_t v10 = v709;
      glpCreateDoublesTelemetry(PrimitiveTypeNode);
      return 0;
    case 209:
      uint64_t v710 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v711 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v713 = v712;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v711, v713, *(_DWORD *)(v11 + 40), v1169);
      v547 = (__n128 *)v1169;
      uint64_t v548 = v710;
      int v549 = 16;
      goto LABEL_271;
    case 210:
      uint64_t v714 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v715 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v717 = v716;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v715, v717, *(_DWORD *)(v11 + 40), v1168);
      v547 = (__n128 *)v1168;
      uint64_t v548 = v714;
      int v549 = 17;
      goto LABEL_271;
    case 211:
      uint64_t v718 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v719 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v721 = v720;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v719, v721, *(_DWORD *)(v11 + 40), v1167);
      v547 = (__n128 *)v1167;
      uint64_t v548 = v718;
      int v549 = 18;
      goto LABEL_271;
    case 212:
      uint64_t v722 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v723 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v725 = v724;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v723, v725, *(_DWORD *)(v11 + 40), v1166);
      v547 = (__n128 *)v1166;
      uint64_t v548 = v722;
      int v549 = 19;
      goto LABEL_271;
    case 213:
      uint64_t v726 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v727 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v729 = v728;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v727, v729, *(_DWORD *)(v11 + 40), v1165);
      v547 = (__n128 *)v1165;
      uint64_t v548 = v726;
      int v549 = 20;
      goto LABEL_271;
    case 214:
      uint64_t v730 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v731 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v733 = v732;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v731, v733, *(_DWORD *)(v11 + 40), v1164);
      v547 = (__n128 *)v1164;
      uint64_t v548 = v730;
      int v549 = 21;
      goto LABEL_271;
    case 215:
      uint64_t v734 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v735 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v737 = v736;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v735, v737, *(_DWORD *)(v11 + 40), v1163);
      v547 = (__n128 *)v1163;
      uint64_t v548 = v734;
      int v549 = 35;
      goto LABEL_271;
    case 216:
      uint64_t v738 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v739 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v741 = v740;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v739, v741, *(_DWORD *)(v11 + 40), v1162);
      v547 = (__n128 *)v1162;
      uint64_t v548 = v738;
      int v549 = 30;
      goto LABEL_271;
    case 217:
      uint64_t v742 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v743 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v745 = v744;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v743, v745, *(_DWORD *)(v11 + 40), v1161);
      v547 = (__n128 *)v1161;
      uint64_t v548 = v742;
      int v549 = 31;
      goto LABEL_271;
    case 218:
      uint64_t v746 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v747 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v749 = v748;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v747, v749, *(_DWORD *)(v11 + 40), v1160);
      v547 = (__n128 *)v1160;
      uint64_t v548 = v746;
      int v549 = 33;
      goto LABEL_271;
    case 219:
      uint64_t v750 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v751 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v753 = v752;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v751, v753, *(_DWORD *)(v11 + 40), v1159);
      v547 = (__n128 *)v1159;
      uint64_t v548 = v750;
      int v549 = 34;
      goto LABEL_271;
    case 220:
      uint64_t v754 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v755 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v757 = v756;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v755, v757, *(_DWORD *)(v11 + 40), v1158);
      v547 = (__n128 *)v1158;
      uint64_t v548 = v754;
      int v549 = 75;
      goto LABEL_271;
    case 221:
      uint64_t v758 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v759 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v761 = v760;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v759, v761, *(_DWORD *)(v11 + 40), v1157);
      v547 = (__n128 *)v1157;
      uint64_t v548 = v758;
      int v549 = 76;
      goto LABEL_271;
    case 222:
      uint64_t v762 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v763 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v765 = v764;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v763, v765, *(_DWORD *)(v11 + 40), v1156);
      v547 = (__n128 *)v1156;
      uint64_t v548 = v762;
      int v549 = 40;
      goto LABEL_271;
    case 223:
      uint64_t v766 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v767 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v769 = v768;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v767, v769, *(_DWORD *)(v11 + 40), v1155);
      v547 = (__n128 *)v1155;
      uint64_t v548 = v766;
      int v549 = 41;
      goto LABEL_271;
    case 224:
      uint64_t v770 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v771 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v773 = v772;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v771, v773, *(_DWORD *)(v11 + 40), v1154);
      v547 = (__n128 *)v1154;
      uint64_t v548 = v770;
      int v549 = 42;
      goto LABEL_271;
    case 225:
      uint64_t v774 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v775 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v777 = v776;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v775, v777, *(_DWORD *)(v11 + 40), v1153);
      v547 = (__n128 *)v1153;
      uint64_t v548 = v774;
      int v549 = 43;
      goto LABEL_271;
    case 226:
      uint64_t v778 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v779 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v781 = v780;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v779, v781, *(_DWORD *)(v11 + 40), v1152);
      v547 = (__n128 *)v1152;
      uint64_t v548 = v778;
      int v549 = 45;
      goto LABEL_271;
    case 227:
      uint64_t v782 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v783 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v785 = v784;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v783, v785, *(_DWORD *)(v11 + 40), v1151);
      v547 = (__n128 *)v1151;
      uint64_t v548 = v782;
      int v549 = 46;
      goto LABEL_271;
    case 228:
      uint64_t v786 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v787 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v789 = v788;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v787, v789, *(_DWORD *)(v11 + 40), v1150);
      v547 = (__n128 *)v1150;
      uint64_t v548 = v786;
      int v549 = 77;
      goto LABEL_271;
    case 229:
      uint64_t v790 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v791 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v793 = v792;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v791, v793, *(_DWORD *)(v11 + 40), v1149);
      v547 = (__n128 *)v1149;
      uint64_t v548 = v790;
      int v549 = 48;
      goto LABEL_271;
    case 230:
      uint64_t v794 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v795 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v797 = v796;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v795, v797, *(_DWORD *)(v11 + 40), v1148);
      v547 = (__n128 *)v1148;
      uint64_t v548 = v794;
      int v549 = 49;
      goto LABEL_271;
    case 231:
      uint64_t v798 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v799 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v801 = v800;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v799, v801, *(_DWORD *)(v11 + 40), v1147);
      v547 = (__n128 *)v1147;
      uint64_t v548 = v798;
      int v549 = 50;
      goto LABEL_271;
    case 232:
      uint64_t v802 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v803 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v805 = v804;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v803, v805, *(_DWORD *)(v11 + 40), v1146);
      v547 = (__n128 *)v1146;
      uint64_t v548 = v802;
      int v549 = 51;
      goto LABEL_271;
    case 233:
      uint64_t v806 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v807 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v809 = v808;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v807, v809, *(_DWORD *)(v11 + 40), v1145);
      v547 = (__n128 *)v1145;
      uint64_t v548 = v806;
      int v549 = 53;
      goto LABEL_271;
    case 234:
      uint64_t v810 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v811 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v813 = v812;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v811, v813, *(_DWORD *)(v11 + 40), v1144);
      v547 = (__n128 *)v1144;
      uint64_t v548 = v810;
      int v549 = 54;
      goto LABEL_271;
    case 235:
      uint64_t v814 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v815 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v817 = v816;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v815, v817, *(_DWORD *)(v11 + 40), v1143);
      v547 = (__n128 *)v1143;
      uint64_t v548 = v814;
      int v549 = 78;
      goto LABEL_271;
    case 236:
      uint64_t v818 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v819 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v821 = v820;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v819, v821, *(_DWORD *)(v11 + 40), v1142);
      v547 = (__n128 *)v1142;
      uint64_t v548 = v818;
      int v549 = 28;
      goto LABEL_271;
    case 237:
      uint64_t v822 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v823 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v825 = v824;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v823, v825, *(_DWORD *)(v11 + 40), v1141);
      v547 = (__n128 *)v1141;
      uint64_t v548 = v822;
      int v549 = 29;
      goto LABEL_271;
    case 238:
      uint64_t v826 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v827 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v829 = v828;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v827, v829, *(_DWORD *)(v11 + 40), v1140);
      v547 = (__n128 *)v1140;
      uint64_t v548 = v826;
      int v549 = 44;
      goto LABEL_271;
    case 239:
      uint64_t v830 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v831 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v833 = v832;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v831, v833, *(_DWORD *)(v11 + 40), v1139);
      v547 = (__n128 *)v1139;
      uint64_t v548 = v830;
      int v549 = 52;
      goto LABEL_271;
    case 240:
      uint64_t v834 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v835 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v837 = v836;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v835, v837, *(_DWORD *)(v11 + 40), v1138);
      v547 = (__n128 *)v1138;
      uint64_t v548 = v834;
      int v549 = 32;
      goto LABEL_271;
    case 241:
      uint64_t v838 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v839 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v841 = v840;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v839, v841, *(_DWORD *)(v11 + 40), v1137);
      v547 = (__n128 *)v1137;
      uint64_t v548 = v838;
      int v549 = 47;
      goto LABEL_271;
    case 242:
      uint64_t v842 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v843 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v845 = v844;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v843, v845, *(_DWORD *)(v11 + 40), v1136);
      v547 = (__n128 *)v1136;
      uint64_t v548 = v842;
      int v549 = 55;
      goto LABEL_271;
    case 243:
      uint64_t v846 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v847 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v849 = v848;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v847, v849, *(_DWORD *)(v11 + 40), v1135);
      v547 = (__n128 *)v1135;
      uint64_t v548 = v846;
      int v549 = 56;
      goto LABEL_271;
    case 244:
      uint64_t v850 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v851 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v853 = v852;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v851, v853, *(_DWORD *)(v11 + 40), v1134);
      v547 = (__n128 *)v1134;
      uint64_t v548 = v850;
      int v549 = 58;
      goto LABEL_271;
    case 245:
      uint64_t v854 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v855 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v857 = v856;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v855, v857, *(_DWORD *)(v11 + 40), v1133);
      v547 = (__n128 *)v1133;
      uint64_t v548 = v854;
      int v549 = 60;
      goto LABEL_271;
    case 246:
      uint64_t v858 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v859 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v861 = v860;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v859, v861, *(_DWORD *)(v11 + 40), v1132);
      v547 = (__n128 *)v1132;
      uint64_t v548 = v858;
      int v549 = 57;
      goto LABEL_271;
    case 247:
      uint64_t v862 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v863 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v865 = v864;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v863, v865, *(_DWORD *)(v11 + 40), v1131);
      v547 = (__n128 *)v1131;
      uint64_t v548 = v862;
      int v549 = 59;
      goto LABEL_271;
    case 248:
      uint64_t v866 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v867 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v869 = v868;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v867, v869, *(_DWORD *)(v11 + 40), v1130);
      v547 = (__n128 *)v1130;
      uint64_t v548 = v866;
      int v549 = 61;
LABEL_271:
      glpMakePrimitiveTypeNode(v548, v547, v549);
      goto LABEL_279;
    case 250:
      uint64_t v870 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v871 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v873 = v872;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v871, v873, *(_DWORD *)(v11 + 40), &v1129);
      yyfill(v11, v1331, 0, v12 == 0);
      v874 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeTypeIdentifierNode(v870, &v1129, (uint64_t)v874, v875);
      goto LABEL_279;
    case 252:
      uint64_t v876 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v877 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v879 = v878;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v877, v879, *(_DWORD *)(v11 + 40), v1128);
      v363 = (__n128 *)v1128;
      uint64_t v364 = v876;
      int v365 = 24;
      goto LABEL_278;
    case 253:
      uint64_t v880 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v881 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v883 = v882;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v881, v883, *(_DWORD *)(v11 + 40), v1127);
      v363 = (__n128 *)v1127;
      uint64_t v364 = v880;
      int v365 = 23;
      goto LABEL_278;
    case 254:
      uint64_t v884 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v885 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v887 = v886;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v885, v887, *(_DWORD *)(v11 + 40), v1126);
      v363 = (__n128 *)v1126;
      uint64_t v364 = v884;
      int v365 = 22;
      goto LABEL_278;
    case 255:
      uint64_t v888 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v889 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v891 = v890;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v889, v891, *(_DWORD *)(v11 + 40), v1125);
      v363 = (__n128 *)v1125;
      uint64_t v364 = v888;
      int v365 = 20;
      goto LABEL_278;
    case 256:
      uint64_t v892 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v893 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v895 = v894;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v893, v895, *(_DWORD *)(v11 + 40), v1124);
      v363 = (__n128 *)v1124;
      uint64_t v364 = v892;
      int v365 = 21;
LABEL_278:
      uint64_t BlockNode = glpMakeKeywordQualifierNode(v364, v363, v365);
      goto LABEL_279;
    case 257:
      uint64_t v896 = *(void *)(v7 + 32);
      yyfill(v3, v1331, 4294967293, v12 == 0);
      v897 = glpMakeStringZ_0(*(const char **)(v11 - 192));
      glpStringHashPut(v896, v897, v898, 1, v899);
      uint64_t v900 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      v901 = glpMakeStringZ_0(*(const char **)(v11 - 256));
      uint64_t v903 = v902;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpMakeSourceLocation((uint64_t)v901, v903, *(_DWORD *)(v11 - 248), v1123);
      yyfill(v11, v1331, 4294967293, v12 == 0);
      v904 = glpMakeStringZ_0(*(const char **)(v11 - 192));
      uint64_t v906 = v905;
      v907 = (__n128 *)v1123;
      uint64_t v908 = v900;
      goto LABEL_283;
    case 258:
      uint64_t v909 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      v910 = glpMakeStringZ_0(*(const char **)(v11 - 184));
      uint64_t v912 = v911;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpMakeSourceLocation((uint64_t)v910, v912, *(_DWORD *)(v11 - 176), v1122);
      v904 = "<<unnamed>>";
      v907 = (__n128 *)v1122;
      uint64_t v908 = v909;
      uint64_t v906 = 0x725D7890000000BLL;
LABEL_283:
      *unint64_t v10 = glpMakeStructTypeNode(v908, v907, (uint64_t)v904, v906);
      uint64_t v173 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v174 = *v10;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      __n128 v175 = *(uint64_t **)(v11 - 48);
LABEL_284:
      addFields(v173, v174, v175);
      return 0;
    case 260:
      yyfill(v3, v1331, 0, v12 == 0);
      uint64_t v913 = *(void *)(v11 + 24);
      do
      {
        uint64_t v914 = v913;
        uint64_t v913 = *(void *)(v913 + 16);
      }
      while (v913);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      *(void *)(v914 + 16) = *(void *)(v11 - 48);
LABEL_12:
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t result = 0;
      uint64_t v24 = *(void *)(v11 + 24);
      goto LABEL_280;
    case 261:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      v915 = *(uint64_t **)(v11 - 48);
      if (!v915) {
        goto LABEL_310;
      }
      int v916 = v1331[0];
      uint64_t v1100 = v11 - 71;
      break;
    case 262:
      uint64_t v934 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 192), &v1121);
      glpMakeQualifiedTypeNode(v934, &v1121);
      uint64_t v936 = v935;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpQualifiedTypeNodeSetType(v936, *(void *)(v11 - 120));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpQualifiedTypeNodeSetQualifiers(v936, *(void *)(v11 - 192));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v937 = *(uint64_t **)(v11 - 48);
      if (v937)
      {
        do
        {
          uint64_t v938 = v937[1];
          v939 = (uint64_t *)v937[2];
          uint64_t v940 = v936;
          if (v938)
          {
            glpArrayTypeNodeSetElementType(v937[1], v936);
            uint64_t v940 = v938;
          }
          glpFieldDeclarationNodeSetType(*v937, v940);
          v937 = v939;
        }
        while (v939);
      }
LABEL_315:
      uint64_t v932 = v11;
      BOOL v933 = v12 == 0;
      goto LABEL_316;
    case 263:
      v941 = (void *)glpCompilerPoolAlloc(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      void *v941 = *(void *)(v11 + 24);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t result = 0;
      v941[1] = *(void *)(v11 + 32);
      v941[2] = 0;
      goto LABEL_319;
    case 264:
      v941 = (void *)glpCompilerPoolAlloc(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      void *v941 = *(void *)(v11 + 24);
      yyfill(v11, v1331, 0, v12 == 0);
      v941[1] = *(void *)(v11 + 32);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t result = 0;
      v941[2] = *(void *)(v11 - 120);
LABEL_319:
      *unint64_t v10 = (uint64_t)v941;
      return result;
    case 265:
      uint64_t v942 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      v943 = glpMakeStringZ_0(*(const char **)(v11 + 32));
      uint64_t v945 = v944;
      yyfill(v11, v1331, 0, v12 == 0);
      glpMakeSourceLocation((uint64_t)v943, v945, *(_DWORD *)(v11 + 40), &v1120);
      yyfill(v11, v1331, 0, v12 == 0);
      v946 = glpMakeStringZ_0(*(const char **)(v11 + 24));
      glpMakeFieldDeclarationNode(v942, &v1120, (uint64_t)v946, v947);
      uint64_t v949 = v948;
      uint64_t result = 0;
      goto LABEL_347;
    case 266:
      uint64_t v950 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v951 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v953 = v952;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v951, v953, *(_DWORD *)(v11 - 32), &v1119);
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v954 = glpMakeStringZ_0(*(const char **)(v11 - 48));
      glpMakeFieldDeclarationNode(v950, &v1119, (uint64_t)v954, v955);
      *unint64_t v10 = v956;
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v957 = *(void *)(v11 + 24);
      arrayify(0, v957);
      uint64_t result = 0;
      v10[1] = v957;
      return result;
    case 268:
      uint64_t v958 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 + 24), &v1118);
      uint64_t ExpressionStatementNode = glpMakeExpressionStatementNode(v958, &v1118);
      *unint64_t v10 = ExpressionStatementNode;
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v960 = *(void *)(v11 + 24);
      goto LABEL_330;
    case 278:
      uint64_t v961 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v962 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v964 = v963;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v962, v964, *(_DWORD *)(v11 - 32), v1117);
      v965 = (__n128 *)v1117;
      uint64_t v966 = v961;
      char v967 = 1;
      goto LABEL_339;
    case 279:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v968 = *(void *)(v11 - 48);
      *unint64_t v10 = v968;
      glpBlockNodeSetNeedsNewScope(v968, 1);
      return 0;
    case 282:
      uint64_t v969 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v970 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v972 = v971;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v970, v972, *(_DWORD *)(v11 - 32), v1116);
      v965 = (__n128 *)v1116;
      uint64_t v966 = v969;
      goto LABEL_338;
    case 284:
      uint64_t v973 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      v1276.n128_u64[0] = (unint64_t)"-1";
      v1276.n128_u64[1] = 0xEDA00000002;
      uint64_t v1277 = 0xFFFFFFFFLL;
      *unint64_t v10 = glpMakeBlockNode(v973, &v1276, 0);
      goto LABEL_328;
    case 285:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 48);
LABEL_328:
      v974 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v975 = *v10;
      goto LABEL_333;
    case 287:
      uint64_t v976 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1115);
      uint64_t ExpressionStatementNode = glpMakeExpressionStatementNode(v976, &v1115);
      *unint64_t v10 = ExpressionStatementNode;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t v960 = *(void *)(v11 - 48);
LABEL_330:
      glpExpressionStatementNodeSetExpr(ExpressionStatementNode, v960);
      return 0;
    case 288:
      uint64_t v977 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      v978 = glpMakeStringZ_0(*(const char **)(v11 - 256));
      uint64_t v980 = v979;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpMakeSourceLocation((uint64_t)v978, v980, *(_DWORD *)(v11 - 248), &v1114);
      uint64_t IfStatementNode = glpMakeIfStatementNode(v977, &v1114);
      *unint64_t v10 = IfStatementNode;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpIfStatementNodeSetCond(IfStatementNode, *(void *)(v11 - 120));
      uint64_t v982 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpIfStatementNodeSetIfStatement(v982, *(void *)(v11 + 24));
      uint64_t v983 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpIfStatementNodeSetElseStatement(v983, *(void *)(v11 + 32));
      return 0;
    case 289:
      uint64_t v984 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      v1276.n128_u64[0] = (unint64_t)"-1";
      v1276.n128_u64[1] = 0xEDA00000002;
      uint64_t v1277 = 0xFFFFFFFFLL;
      *unint64_t v10 = glpMakeBlockNode(v984, &v1276, 1);
      v985 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v986 = *v10;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpBlockNodeAddStatement(v985, v986, *(void *)(v11 - 120));
      uint64_t v987 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      v1276.n128_u64[0] = (unint64_t)"-1";
      v1276.n128_u64[1] = 0xEDA00000002;
      uint64_t v1277 = 0xFFFFFFFFLL;
      v10[1] = glpMakeBlockNode(v987, &v1276, 1);
      v974 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v975 = v10[1];
LABEL_333:
      yyfill(v11, v1331, 0, v12 == 0);
      glpBlockNodeAddStatement(v974, v975, *(void *)(v11 + 24));
      return 0;
    case 290:
      uint64_t v988 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      v1276.n128_u64[0] = (unint64_t)"-1";
      v1276.n128_u64[1] = 0xEDA00000002;
      uint64_t v1277 = 0xFFFFFFFFLL;
      *unint64_t v10 = glpMakeBlockNode(v988, &v1276, 1);
      v989 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v990 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpBlockNodeAddStatement(v989, v990, *(void *)(v11 + 24));
      uint64_t result = 0;
      v10[1] = 0;
      return result;
    case 292:
      uint64_t v991 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 192), &v1113);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v992 = glpMakeStringZ_0(*(const char **)(v11 - 120));
      glpMakeVariableDeclarationNode(v991, &v1113, (uint64_t)v992, v993, 1);
      uint64_t v995 = v994;
      *unint64_t v10 = v994;
      yyfill(v11, v1331, 4294967293, v12 == 0);
      glpVariableDeclarationNodeSetType(v995, *(void *)(v11 - 192));
      uint64_t v996 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpVariableDeclarationNodeSetInitializer(v996, *(void *)(v11 + 24));
      return 0;
    case 293:
      uint64_t v997 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967290, v12 == 0);
      v998 = glpMakeStringZ_0(*(const char **)(v11 - 400));
      uint64_t v1000 = v999;
      yyfill(v11, v1331, 4294967290, v12 == 0);
      glpMakeSourceLocation((uint64_t)v998, v1000, *(_DWORD *)(v11 - 392), &v1112);
      uint64_t SwitchStatementNode = glpMakeSwitchStatementNode(v997, &v1112);
      *unint64_t v10 = SwitchStatementNode;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpSwitchStatementNodeSetExpr(SwitchStatementNode, *(void *)(v11 - 264));
      uint64_t v1002 = *v10;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpSwitchStatementNodeSetBody(v1002, *(void *)(v11 - 48));
      return 0;
    case 294:
      uint64_t v966 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      v1276.n128_u64[0] = (unint64_t)"-1";
      v1276.n128_u64[1] = 0xEDA00000002;
      uint64_t v1277 = 0xFFFFFFFFLL;
      v965 = &v1276;
LABEL_338:
      char v967 = 0;
LABEL_339:
      uint64_t BlockNode = glpMakeBlockNode(v966, v965, v967);
      goto LABEL_279;
    case 296:
      uint64_t v1003 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v1004 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v1006 = v1005;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1004, v1006, *(_DWORD *)(v11 - 104), &v1111);
      uint64_t CaseStatementNode = glpMakeCaseStatementNode(v1003, &v1111, 1);
      *unint64_t v10 = CaseStatementNode;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpCaseStatementNodeSetConstValue(CaseStatementNode, *(void *)(v11 - 48));
      return 0;
    case 297:
      uint64_t v1008 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v1009 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v1011 = v1010;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1009, v1011, *(_DWORD *)(v11 - 32), &v1110);
      uint64_t BlockNode = glpMakeDefaultStatementNode(v1008, &v1110, 1);
      goto LABEL_279;
    case 298:
      v1012 = (void *)glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967292, v12 == 0);
      v1013 = glpMakeStringZ_0(*(const char **)(v11 - 256));
      uint64_t v1015 = v1014;
      yyfill(v11, v1331, 4294967292, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1013, v1015, *(_DWORD *)(v11 - 248), &v1109);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v1016 = *(void *)(v11 - 120);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t BlockNode = glpMakeWhileFragment(v1012, &v1109, v1016, *(void *)(v11 + 24));
      goto LABEL_279;
    case 299:
      v1017 = (void *)glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967290, v12 == 0);
      v1018 = glpMakeStringZ_0(*(const char **)(v11 - 400));
      uint64_t v1020 = v1019;
      yyfill(v11, v1331, 4294967290, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1018, v1020, *(_DWORD *)(v11 - 392), &v1108);
      yyfill(v11, v1331, 4294967291, v12 == 0);
      uint64_t v1021 = *(void *)(v11 - 336);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t BlockNode = glpMakeDoWhileFragment(v1017, &v1108, v1021, *(void *)(v11 - 120));
      goto LABEL_279;
    case 300:
      v1022 = (void *)glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967291, v12 == 0);
      v1023 = glpMakeStringZ_0(*(const char **)(v11 - 328));
      uint64_t v1025 = v1024;
      yyfill(v11, v1331, 4294967291, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1023, v1025, *(_DWORD *)(v11 - 320), &v1107);
      yyfill(v11, v1331, 4294967293, v12 == 0);
      uint64_t v1026 = *(void *)(v11 - 192);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t v1027 = *(void *)(v11 - 120);
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t v1028 = *(void *)(v11 + 24);
      yyfill(v11, v1331, 4294967294, v12 == 0);
      uint64_t BlockNode = glpMakeForFragment(v1022, &v1107, v1026, v1027, v1028, *(void *)(v11 - 112));
      goto LABEL_279;
    case 304:
      v1029 = (unsigned int *)glpGetPrimitiveType(9u);
      uint64_t v1030 = glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v1031 = *(void *)(v8 + 784);
      uint64_t v1032 = glpCompilerGetAllocator(v1031);
      v1038 = glpMakeMutableValue(v1032, v1029, 1, v1033, v1034, v1035, v1036, v1037, 1);
      uint64_t v45 = glpCompilerRemapValue(v1031, v1029, v1038);
      v1276.n128_u64[0] = (unint64_t)"-1";
      v1276.n128_u64[1] = 0xEDA00000002;
      uint64_t v1277 = 0xFFFFFFFFLL;
      int v46 = &v1276;
      uint64_t v91 = v1030;
      uint64_t v92 = (uint64_t)v1029;
LABEL_21:
      glpMakeConstantNode(v91, v46, v92, v45);
      goto LABEL_279;
    case 305:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      uint64_t result = 0;
      uint64_t v949 = *(void *)(v11 - 48);
LABEL_347:
      *unint64_t v10 = v949;
      v10[1] = 0;
      return result;
    case 306:
      yyfill(v3, v1331, 4294967294, v12 == 0);
      uint64_t v327 = *(void *)(v11 - 120);
LABEL_349:
      *unint64_t v10 = v327;
      yyfill(v11, v1331, 0, v12 == 0);
      uint64_t result = 0;
      uint64_t v333 = *(void *)(v11 + 24);
LABEL_350:
      v10[1] = v333;
      return result;
    case 307:
      uint64_t v1039 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v1040 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v1042 = v1041;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1040, v1042, *(_DWORD *)(v11 - 32), &v1106);
      uint64_t BlockNode = glpMakeContinueStatementNode(v1039, &v1106);
      goto LABEL_279;
    case 308:
      uint64_t v1043 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v1044 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v1046 = v1045;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1044, v1046, *(_DWORD *)(v11 - 32), &v1105);
      uint64_t BlockNode = glpMakeBreakStatementNode(v1043, &v1105);
      goto LABEL_279;
    case 309:
      uint64_t v1047 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v1048 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v1050 = v1049;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1048, v1050, *(_DWORD *)(v11 - 32), &v1104);
      uint64_t BlockNode = glpMakeReturnStatementNode(v1047, &v1104);
      goto LABEL_279;
    case 310:
      uint64_t v1051 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 4294967294, v12 == 0);
      v1052 = glpMakeStringZ_0(*(const char **)(v11 - 112));
      uint64_t v1054 = v1053;
      yyfill(v11, v1331, 4294967294, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1052, v1054, *(_DWORD *)(v11 - 104), &v1103);
      uint64_t ReturnStatementNode = glpMakeReturnStatementNode(v1051, &v1103);
      *unint64_t v10 = ReturnStatementNode;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpReturnStatementNodeSetExpr(ReturnStatementNode, *(void *)(v11 - 48));
      return 0;
    case 311:
      uint64_t v1056 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      v1057 = glpMakeStringZ_0(*(const char **)(v11 - 40));
      uint64_t v1059 = v1058;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpMakeSourceLocation((uint64_t)v1057, v1059, *(_DWORD *)(v11 - 32), &v1102);
      uint64_t BlockNode = glpMakeDiscardStatementNode(v1056, &v1102);
      goto LABEL_279;
    case 312:
      *unint64_t v4 = glpCompilerGetTopLevelNode(*(void *)(v7 + 784));
      v1060 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v1061 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpTopLevelNodeAddDef(v1060, v1061, *(void *)(v11 + 24));
      uint64_t result = 0;
      *(void *)(v8 + 792) = *v10;
      return result;
    case 313:
      yyfill(v3, v1331, 0xFFFFFFFFLL, v12 == 0);
      *unint64_t v10 = *(void *)(v11 - 48);
      v1062 = (void *)glpCompilerGetAllocator(*(void *)(v8 + 784));
      uint64_t v1063 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpTopLevelNodeAddDef(v1062, v1063, *(void *)(v11 + 24));
      return 0;
    case 316:
      uint64_t v1064 = glpCompilerGetAllocator(*(void *)(v7 + 784));
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpASTNodeGetLocation(*(void *)(v11 - 48), &v1101);
      glpMakeFunctionDefinitionNode(v1064, &v1101);
      uint64_t v1066 = v1065;
      *unint64_t v10 = v1065;
      yyfill(v11, v1331, 0xFFFFFFFFLL, v12 == 0);
      glpFunctionDefinitionNodeSetPrototype(v1066, *(void *)(v11 - 48));
      uint64_t v1067 = *v10;
      yyfill(v11, v1331, 0, v12 == 0);
      glpFunctionDefinitionNodeSetBody(v1067, *(void *)(v11 + 24));
      return 0;
    default:
      return 0;
  }
  do
  {
    v917 = v915;
    v918 = v915;
    uint64_t v919 = v915[1];
    v915 = (uint64_t *)v915[2];
    v920 = v918 + 1;
    if (v919)
    {
      for (uint64_t j = v919; ; uint64_t j = v923)
      {
        Elementuint64_t Type = glpArrayTypeNodeGetElementType(j);
        if (!ElementType) {
          break;
        }
        uint64_t v923 = ElementType;
        if (!glpIsArrayTypeNode(ElementType)) {
          break;
        }
        uint64_t v919 = v923;
      }
      if (v12 && v916 >= -1)
      {
        uint64_t v924 = *(void *)(v11 + 72 * v916 + 8);
        uint64_t v925 = v916 + 1;
        uint64_t v926 = v1100 + 72 * v916;
        do
        {
          if (!*(unsigned char *)(v924 + 1)) {
            goto LABEL_381;
          }
          *(unsigned char *)uint64_t v926 = 1;
          long long v927 = *(_OWORD *)(v924 + 24);
          *(void *)(v926 + 39) = *(void *)(v924 + 40);
          *(_OWORD *)(v926 + 23) = v927;
          *(_OWORD *)(v926 + 47) = *(_OWORD *)(v924 + 48);
          uint64_t v924 = *(void *)(v924 + 8);
          *(void *)(v926 + 7) = v924;
          --v925;
          v926 -= 72;
        }
        while ((v925 & 0x8000000000000000) == 0);
        int v916 = -2;
        v1331[0] = -2;
      }
      glpArrayTypeNodeSetElementType(v919, *(void *)(v11 - 120));
    }
    else
    {
      if (v12 && v916 >= -1)
      {
        uint64_t v928 = *(void *)(v11 + 72 * v916 + 8);
        uint64_t v929 = v916 + 1;
        uint64_t v930 = v1100 + 72 * v916;
        do
        {
          if (!*(unsigned char *)(v928 + 1)) {
            goto LABEL_381;
          }
          *(unsigned char *)uint64_t v930 = 1;
          long long v931 = *(_OWORD *)(v928 + 24);
          *(void *)(v930 + 39) = *(void *)(v928 + 40);
          *(_OWORD *)(v930 + 23) = v931;
          *(_OWORD *)(v930 + 47) = *(_OWORD *)(v928 + 48);
          uint64_t v928 = *(void *)(v928 + 8);
          *(void *)(v930 + 7) = v928;
          --v929;
          v930 -= 72;
        }
        while ((v929 & 0x8000000000000000) == 0);
        int v916 = -2;
        v1331[0] = -2;
      }
      v920 = (uint64_t *)(v11 - 120);
    }
    glpFieldDeclarationNodeSetType(*v917, *v920);
  }
  while (v915);
LABEL_310:
  uint64_t v932 = v11;
  BOOL v933 = v12 == 0;
LABEL_316:
  yyfill(v932, v1331, 0xFFFFFFFFLL, v933);
  uint64_t result = 0;
  uint64_t v24 = *(void *)(v11 - 48);
LABEL_280:
  *unint64_t v10 = v24;
  return result;
}

uint64_t yyfill(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  if (!a4)
  {
    uint64_t v4 = *a2;
    if ((int)v4 > (int)a3)
    {
      uint64_t v5 = a1 + 72 * (int)v4;
      uint64_t v6 = *(void *)(v5 + 8);
      uint64_t v7 = v5 - 71;
      do
      {
        if (!*(unsigned char *)(v6 + 1)) {
          abort();
        }
        --v4;
        *(unsigned char *)uint64_t v7 = 1;
        long long v8 = *(_OWORD *)(v6 + 24);
        *(void *)(v7 + 39) = *(void *)(v6 + 40);
        *(_OWORD *)(v7 + 23) = v8;
        *(_OWORD *)(v7 + 47) = *(_OWORD *)(v6 + 48);
        uint64_t v6 = *(void *)(v6 + 8);
        *(void *)(v7 + 7) = v6;
        v7 -= 72;
      }
      while (v4 > (int)a3);
      *a2 = a3;
    }
  }
  return a3;
}

const char *glpMakeStringZ_0(const char *a1)
{
  unsigned int v2 = strlen(a1);
  if (v2 >> 5 < v2)
  {
    unsigned int v3 = v2;
    unsigned int v4 = v2;
    do
    {
      v4 ^= 32 * v4 + (v4 >> 2) + a1[v3 - 1];
      v3 += ~(v2 >> 5);
    }
    while (v3 > v2 >> 5);
  }
  return a1;
}

void *addFields(void *a1, uint64_t a2, uint64_t *a3)
{
  if (a3[2]) {
    addFields(a1, a2);
  }
  uint64_t v6 = *a3;

  return glpStructureNodeAddField(a1, a2, v6);
}

uint64_t iterateQualifiers(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    int Kind = glpASTNodeGetKind(result);
    if ((Kind - 59) >= 3)
    {
      if (Kind != 62) {
        abort();
      }
      uint64_t result = glpQualifierListNodeGetQualifierCount(v3);
      if (result)
      {
        int v6 = result;
        for (unsigned int i = 0; i != v6; ++i)
        {
          uint64_t Qualifier = glpQualifierListNodeGetQualifier(v3, i);
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, Qualifier);
        }
      }
    }
    else
    {
      uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);
      return v5(a2, v3);
    }
  }
  return result;
}

uint64_t __yyuserAction_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = glpIsKeywordQualifierNode(a2);
  if (result)
  {
    uint64_t result = glpKeywordQualifierNodeGetQualifier(a2);
    if (result == 10)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 32);
      uint64_t Name = (const char *)glpFunctionPrototypeNodeGetName(v5);
      return glpStringHashPut(v6, Name, v7, 1, v9);
    }
  }
  return result;
}

void *__yyuserAction_block_invoke_2(void *a1, uint64_t a2)
{
  if (!*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    uint64_t Allocator = glpCompilerGetAllocator(*(void *)(a1[5] + 784));
    glpASTNodeGetLocation(a1[6], &v8);
    glpMakeQualifierListNode(Allocator, &v8);
    *(void *)(*(void *)(a1[4] + 8) + 24) = v5;
  }
  uint64_t v6 = (void *)glpCompilerGetAllocator(*(void *)(a1[5] + 784));
  return glpQualifierListNodeAddQualifier(v6, *(void *)(*(void *)(a1[4] + 8) + 24), a2);
}

void *__yyuserAction_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (!v4)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = glpCompilerPoolAlloc(*(void *)(*(void *)(a1 + 40)
                                                                                                 + 784));
    uint64_t Allocator = glpCompilerGetAllocator(*(void *)(*(void *)(a1 + 40) + 784));
    **(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 4;
    *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 4) = 0;
    *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 8) = (*(uint64_t (**)(void, uint64_t, const char *))(Allocator + 8))(*(void *)Allocator, 32, "Vector Storage (GLPASTNode *)");
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  uint64_t v6 = *(unsigned int *)(v4 + 4);
  int v7 = *(_DWORD *)(v4 + 4);
  if ((v6 + 1) > *(_DWORD *)v4)
  {
    if (*(int *)v4 <= 1) {
      int v8 = 1;
    }
    else {
      int v8 = *(_DWORD *)v4;
    }
    int v9 = 2 * v8;
    if (v9 <= (int)v6 + 1) {
      unsigned int v10 = v6 + 1;
    }
    else {
      unsigned int v10 = v9;
    }
    uint64_t v11 = (void *)glpCompilerGetAllocator(*(void *)(*(void *)(a1 + 40) + 784));
    uint64_t v12 = (void *)((uint64_t (*)(void, uint64_t, const char *))v11[1])(*v11, 8 * v10, "Vector Storage (GLPASTNode *, growth)");
    uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    memcpy(v12, *(const void **)(v13 + 8), 8 * *(unsigned int *)(v13 + 4));
    ((void (*)(void, void))v11[3])(*v11, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 8));
    **(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
    *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 8) = v12;
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v7 = *(_DWORD *)(v4 + 4);
  }
  uint64_t result = memmove((void *)(*(void *)(v4 + 8) + 8 * v6 + 8), (const void *)(*(void *)(v4 + 8) + 8 * v6), 8 * (v7 - v6));
  *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 8) + 8 * v6) = a2;
  uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  ++*(_DWORD *)(v15 + 4);
  return result;
}

uint64_t __yyuserAction_block_invoke_4(uint64_t a1, uint64_t a2)
{
  int Kind = glpASTNodeGetKind(a2);
  if ((Kind - 60) < 2)
  {
    uint64_t v5 = a1 + 32;
LABEL_3:
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)v5 + 16);
    return v6();
  }
  if (Kind != 59) {
    abort();
  }
  int Qualifier = glpKeywordQualifierNodeGetQualifier(a2);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (Qualifier != 10)
  {
    uint64_t v5 = a1 + 40;
    goto LABEL_3;
  }
  return result;
}

uint64_t __yyuserAction_block_invoke_5(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  int v4 = glpQualifierKindOfNode(*a2);
  return v4 - glpQualifierKindOfNode(v3);
}

uint64_t arrayify(uint64_t a1, uint64_t a2)
{
  Elementuint64_t Type = a2;
  if (glpArrayTypeNodeGetElementType(a2))
  {
    Elementuint64_t Type = a2;
    do
      Elementuint64_t Type = glpArrayTypeNodeGetElementType(ElementType);
    while (glpArrayTypeNodeGetElementType(ElementType));
  }
  glpArrayTypeNodeSetElementType(ElementType, a1);
  return a2;
}

uint64_t yyresolveStates(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 1) {
    return 0;
  }
  if (!*(void *)(a1 + 8)) {
    abort();
  }
  uint64_t v7 = ((uint64_t (*)(void))yyresolveStates)();
  if (!v7)
  {
    if (*(unsigned char *)(a1 + 1)) {
      return 0;
    }
    unsigned int v10 = (void *)(a1 + 24);
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v13 = (void *)(v11 + 64);
    uint64_t v12 = *(void *)(v11 + 64);
    if (v12)
    {
      while (1)
      {
        uint64_t v14 = *(int *)(v11 + 4);
        uint64_t v15 = *(int *)(v12 + 4);
        if (v14 != v15) {
          goto LABEL_34;
        }
        int v16 = yyr2[v14];
        if (yyr2[v14])
        {
          int v17 = v16 + 1;
          int v18 = (uint64_t *)(v11 + 8);
          int v19 = (uint64_t *)(v12 + 8);
          while (1)
          {
            uint64_t v20 = *v19;
            uint64_t v21 = *v18;
            if (*(void *)(v21 + 16) != *(void *)(v20 + 16)) {
              break;
            }
            int v18 = (uint64_t *)(v21 + 8);
            int v19 = (uint64_t *)(v20 + 8);
            if (--v17 <= 1)
            {
              uint64_t v22 = *(void *)(v11 + 8);
              for (uint64_t i = *(void *)(v12 + 8); v22 != i; uint64_t i = *(void *)(i + 8))
              {
                if (*(unsigned char *)(v22 + 1))
                {
                  *(unsigned char *)(i + 1) = 1;
                  __n128 v8 = *(__n128 *)(v22 + 24);
                  *(void *)(i + 40) = *(void *)(v22 + 40);
                  *(__n128 *)(i + 24) = v8;
                }
                else if (*(unsigned char *)(i + 1))
                {
                  *(unsigned char *)(v22 + 1) = 1;
                  __n128 v8 = *(__n128 *)(i + 24);
                  *(void *)(v22 + 40) = *(void *)(i + 40);
                  *(__n128 *)(v22 + 24) = v8;
                }
                else
                {
                  unint64_t v24 = *(void *)(v22 + 24);
                  unint64_t v25 = *(void *)(i + 24);
                  if (v25) {
                    BOOL v26 = v25 == v24;
                  }
                  else {
                    BOOL v26 = 1;
                  }
                  if (!v26)
                  {
                    uint64_t v27 = (unint64_t *)(v22 + 24);
                    while (v24)
                    {
                      if (v24 < v25)
                      {
                        *uint64_t v27 = v25;
                        unint64_t v28 = *(void *)(v25 + 64);
                        *(void *)(v25 + 64) = v24;
                        unint64_t v24 = *v27;
                        unint64_t v25 = v28;
                      }
                      if (v25)
                      {
                        uint64_t v27 = (unint64_t *)(v24 + 64);
                        unint64_t v24 = *(void *)(v24 + 64);
                        if (v25 != v24) {
                          continue;
                        }
                      }
                      goto LABEL_31;
                    }
                    *uint64_t v27 = v25;
                  }
LABEL_31:
                  *(void *)(i + 24) = *(void *)(v22 + 24);
                }
                if (v16 < 2) {
                  break;
                }
                --v16;
                uint64_t v22 = *(void *)(v22 + 8);
              }
              goto LABEL_45;
            }
          }
LABEL_34:
          unsigned int v29 = yydprec[v14];
          unsigned int v30 = yydprec[v15];
          BOOL v32 = v29 == v30 || v29 == 0 || v30 == 0;
          if (v32 || (uint64_t v33 = v12, v29 >= v30) && (uint64_t v33 = v11, v30 >= v29))
          {
            yyresolveLocations(a1, 1, a3, v8);
            yyerror(a1 + 48, a4, (char)"syntax is ambiguous");
            return 2;
          }
          uint64_t v13 = (void *)(v12 + 64);
          uint64_t v12 = *(void *)(v12 + 64);
          uint64_t v11 = v33;
          if (!v12) {
            break;
          }
        }
        else
        {
LABEL_45:
          uint64_t v12 = *(void *)(v12 + 64);
          *uint64_t v13 = v12;
          if (!v12) {
            break;
          }
        }
      }
    }
    unint64_t v34 = (uint64_t *)(v11 + 8);
    int v35 = yyr2[*(int *)(v11 + 4)];
    uint64_t v36 = yyresolveStates(*(void *)(v11 + 8), yyr2[*(int *)(v11 + 4)], a3, a4);
    if (v36)
    {
      uint64_t v7 = v36;
      if (!v35)
      {
LABEL_54:
        *unsigned int v10 = 0;
        return v7;
      }
      unsigned int v37 = v35 + 1;
      do
      {
        uint64_t v38 = *v34;
        yydestroyGLRState(*v34);
        unint64_t v34 = (uint64_t *)(v38 + 8);
        --v37;
      }
      while (v37 > 1);
    }
    else
    {
      int v39 = *(_DWORD *)(a3 + 228);
      uint64_t v43 = *(void *)(a3 + 248);
      long long v41 = *(_OWORD *)(a3 + 256);
      long long v42 = *(_OWORD *)(a3 + 232);
      *(_DWORD *)(a3 + 228) = *(_DWORD *)(v11 + 16);
      uint64_t v40 = *(void *)(v11 + 40);
      *(_OWORD *)(a3 + 232) = *(_OWORD *)(v11 + 24);
      *(void *)(a3 + 248) = v40;
      *(_OWORD *)(a3 + 256) = *(_OWORD *)(v11 + 48);
      uint64_t v7 = yyuserAction(*(unsigned int *)(v11 + 4));
      *(_DWORD *)(a3 + 228) = v39;
      *(_OWORD *)(a3 + 232) = v42;
      *(void *)(a3 + 248) = v43;
      *(_OWORD *)(a3 + 256) = v41;
    }
    if (!v7)
    {
      *(unsigned char *)(a1 + 1) = 1;
      *(_OWORD *)unsigned int v10 = 0uLL;
      *(void *)(a1 + 40) = 0;
      return v7;
    }
    goto LABEL_54;
  }
  return v7;
}

__n128 yyresolveLocations(uint64_t a1, int a2, uint64_t a3, __n128 result)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (a2 >= 1)
  {
    yyresolveLocations(*(void *)(a1 + 8));
    if (!*(unsigned char *)(a1 + 1))
    {
      uint64_t v6 = *(void *)(a1 + 24);
      if (!v6) {
        abort();
      }
      uint64_t v7 = *(int *)(v6 + 4);
      uint64_t v8 = yyr2[v7];
      if (yyr2[v7])
      {
        int v9 = (uint64_t *)(v6 + 8);
        yyresolveLocations(*(void *)(v6 + 8));
        unint64_t v10 = v8 + 1;
        uint64_t v11 = &v19[9 * v8 + 6];
        do
        {
          uint64_t v12 = *v9;
          *uint64_t v11 = *(_OWORD *)(*v9 + 48);
          uint64_t v11 = (_OWORD *)((char *)v11 - 72);
          int v9 = (uint64_t *)(v12 + 8);
          --v10;
        }
        while (v10 > 1);
      }
      else
      {
        v20[0] = *(_OWORD *)(*(void *)(v6 + 8) + 48);
      }
      int v13 = *(_DWORD *)(a3 + 228);
      uint64_t v18 = *(void *)(a3 + 248);
      __n128 v16 = *(__n128 *)(a3 + 256);
      long long v17 = *(_OWORD *)(a3 + 232);
      *(_DWORD *)(a3 + 228) = *(_DWORD *)(v6 + 16);
      long long v14 = *(_OWORD *)(v6 + 24);
      *(void *)(a3 + 248) = *(void *)(v6 + 40);
      *(_OWORD *)(a3 + 232) = v14;
      if (v8)
      {
        *(void *)&long long v15 = v21;
        *((void *)&v15 + 1) = *((void *)v20 + 9 * v8 + 1);
      }
      else
      {
        *(void *)&long long v15 = *((void *)&v20[0] + 1);
        *((void *)&v15 + 1) = *((void *)&v20[0] + 1);
      }
      *(_OWORD *)(a1 + 48) = v15;
      *(_DWORD *)(a3 + 228) = v13;
      *(_OWORD *)(a3 + 232) = v17;
      *(void *)(a3 + 248) = v18;
      uint64_t result = v16;
      *(__n128 *)(a3 + 256) = v16;
    }
  }
  return result;
}

uint64_t BitSetNew(unsigned int a1)
{
  return BitSetNewWithAllocator(a1, 0, (uint64_t (*)(uint64_t, uint64_t, const char *))glpMallocAlloc_0, (uint64_t)glpMallocRealloc_0, (uint64_t)glpMallocFree_0);
}

uint64_t BitSetNewWithAllocator(unsigned int a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *), uint64_t a4, uint64_t a5)
{
  uint64_t v10 = ((a1 >> 3) & 0x1FFFFFFC) + 4;
  uint64_t v11 = a3(a2, 48, "Bit Set");
  *(void *)uint64_t v11 = a2;
  *(void *)(v11 + 8) = a3;
  *(void *)(v11 + 16) = a4;
  *(void *)(v11 + 24) = a5;
  *(_DWORD *)(v11 + 32) = a1;
  *(_DWORD *)(v11 + 36) = v10;
  *(void *)(v11 + 40) = a3(a2, v10, "Bit Set (packed bits)");

  return BitSetSetRangeEqualsInternal(v11, 0, a1, 0);
}

void *glpMallocAlloc_0(int a1, size_t size)
{
  uint64_t result = malloc_type_malloc(size, 0x7081ABB9uLL);
  if (!result) {
    abort();
  }
  return result;
}

void *glpMallocRealloc_0(int a1, void *ptr, size_t size)
{
  uint64_t result = malloc_type_realloc(ptr, size, 0x2BDC8648uLL);
  if (!result) {
    abort();
  }
  return result;
}

void glpMallocFree_0(int a1, void *a2)
{
}

uint64_t BitSetSetRangeEqualsInternal(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if (a2 < a3)
  {
    int v6 = -1 << a2;
    unsigned int v7 = 0xFFFFFFFF >> -(char)a3;
    unsigned int v8 = a2 >> 5;
    signed int v9 = ~(a2 >> 5) + ((a3 - 1) >> 5);
    if (v9 < 0)
    {
      int v15 = v7 & v6;
      uint64_t v16 = *(void *)(a1 + 40);
      if (a4) {
        int v17 = *(_DWORD *)(v16 + 4 * v8) | v15;
      }
      else {
        int v17 = *(_DWORD *)(v16 + 4 * v8) & ~v15;
      }
      *(_DWORD *)(v16 + 4 * v8) = v17;
    }
    else
    {
      unsigned int v10 = (a3 - 1) >> 5;
      uint64_t v11 = (void *)(*(void *)(a1 + 40) + 4 * (v8 + 1));
      if (a4) {
        int v12 = -1;
      }
      else {
        int v12 = 0;
      }
      memset(v11, v12, (4 * v9));
      uint64_t v13 = *(void *)(a1 + 40);
      if (a4)
      {
        *(_DWORD *)(v13 + 4 * v8) |= v6;
        int v14 = *(_DWORD *)(v13 + 4 * v10) | v7;
      }
      else
      {
        *(_DWORD *)(v13 + 4 * v8) &= ~v6;
        int v14 = *(_DWORD *)(v13 + 4 * v10) & ~v7;
      }
      *(_DWORD *)(v13 + 4 * v10) = v14;
    }
  }
  return a1;
}

uint64_t BitSetClone(uint64_t a1)
{
  uint64_t v2 = BitSetNewWithAllocator(*(_DWORD *)(a1 + 32), *(void *)a1, *(uint64_t (**)(uint64_t, uint64_t, const char *))(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));

  return BitSetCopyEquals(v2, a1);
}

uint64_t BitSetCloneWithAllocator(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *), uint64_t a4, uint64_t a5)
{
  uint64_t v6 = BitSetNewWithAllocator(*(_DWORD *)(a1 + 32), a2, a3, a4, a5);

  return BitSetCopyEquals(v6, a1);
}

uint64_t BitSetCopyEquals(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 32);
  unsigned int v5 = *(_DWORD *)(a1 + 32);
  if (v5 < v4)
  {
    BitSetSetSizeEquals(a1, v4);
    unsigned int v5 = *(_DWORD *)(a1 + 32);
    unsigned int v4 = *(_DWORD *)(a2 + 32);
  }
  if (v4 < v5) {
    BitSetSetSizeEquals(a2, v5);
  }
  unint64_t v6 = *(unsigned int *)(a1 + 36);
  if (v6 >= 4)
  {
    unint64_t v7 = v6 >> 2;
    unsigned int v8 = *(int **)(a2 + 40);
    signed int v9 = *(_DWORD **)(a1 + 40);
    do
    {
      int v10 = *v8++;
      *v9++ = v10;
      --v7;
    }
    while (v7);
  }
  return a1;
}

uint64_t BitSetFree(uint64_t *a1)
{
  ((void (*)(void, uint64_t))a1[3])(*a1, a1[5]);
  uint64_t v2 = (uint64_t (*)(uint64_t, uint64_t *))a1[3];
  uint64_t v3 = *a1;

  return v2(v3, a1);
}

uint64_t BitSetGetSizeInBits(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BitSetGetEquals(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = a2 + 1;
  if (*(_DWORD *)(a1 + 32) < v3) {
    a1 = BitSetSetSizeEquals(a1, v3);
  }
  return (*(_DWORD *)(*(void *)(a1 + 40) + 4 * (a2 >> 5)) >> a2) & 1;
}

uint64_t BitSetSetEquals(uint64_t result, unsigned int a2)
{
  unsigned int v3 = a2 + 1;
  if (*(_DWORD *)(result + 32) < v3) {
    uint64_t result = BitSetSetSizeEquals(result, v3);
  }
  *(_DWORD *)(*(void *)(result + 40) + 4 * (a2 >> 5)) |= 1 << a2;
  return result;
}

uint64_t BitSetClearEquals(uint64_t result, unsigned int a2)
{
  unsigned int v3 = a2 + 1;
  if (*(_DWORD *)(result + 32) < v3) {
    uint64_t result = BitSetSetSizeEquals(result, v3);
  }
  *(_DWORD *)(*(void *)(result + 40) + 4 * (a2 >> 5)) &= ~(1 << a2);
  return result;
}

uint64_t BitSetSetRangeEquals(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if (*(_DWORD *)(a1 + 32) < a3) {
    a1 = BitSetSetSizeEquals(a1, a3);
  }

  return BitSetSetRangeEqualsInternal(a1, a2, a3, a4);
}

uint64_t BitSetSetSizeEquals(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 32);
  if (v4 != a2)
  {
    uint64_t v5 = ((a2 >> 3) & 0x1FFFFFFC) + 4;
    if (v4 < a2)
    {
      *(void *)(a1 + 40) = (*(uint64_t (**)(void, void, uint64_t, const char *))(a1 + 16))(*(void *)a1, *(void *)(a1 + 40), v5, "Bit Set (packed bits, growth)");
      unsigned int v4 = *(_DWORD *)(a1 + 32);
    }
    BitSetSetRangeEqualsInternal(a1, v4, a2, 0);
    *(_DWORD *)(a1 + 32) = a2;
    *(_DWORD *)(a1 + 36) = v5;
  }
  return a1;
}

uint64_t BitSetFirstSetBit(uint64_t a1)
{
  return BitSetNextSetBit(a1, -1);
}

uint64_t BitSetNextSetBit(uint64_t a1, int a2)
{
  uint64_t v2 = (a2 + 1) >> 5;
  unint64_t v3 = (unint64_t)*(unsigned int *)(a1 + 36) >> 2;
  if (v2 >= v3) {
    return 0xFFFFFFFFLL;
  }
  int v4 = ((_BYTE)a2 + 1) & 0x1F;
  for (int i = 32 * v2; ; i += 32)
  {
    unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 40) + 4 * v2);
    if (v6) {
      break;
    }
LABEL_7:
    int v4 = 0;
    if (++v2 == v3) {
      return 0xFFFFFFFFLL;
    }
  }
  while (1)
  {
    if ((v6 >> v4))
    {
      uint64_t v7 = (i + v4);
      if (v7 < *(_DWORD *)(a1 + 32)) {
        return v7;
      }
    }
    if (++v4 == 32) {
      goto LABEL_7;
    }
  }
}

uint64_t BitSetLastSetBit(uint64_t a1)
{
  return BitSetPreviousSetBit(a1, *(_DWORD *)(a1 + 32));
}

uint64_t BitSetPreviousSetBit(uint64_t a1, int a2)
{
  int v2 = (a2 - 1) & 0x1F;
  uint64_t v3 = (a2 - 1) >> 5;
  int v4 = 32 * v3;
  while (1)
  {
    unsigned int v5 = *(_DWORD *)(*(void *)(a1 + 40) + 4 * v3);
    if (v5) {
      break;
    }
LABEL_6:
    v4 -= 32;
    int v2 = 31;
    BOOL v6 = v3-- <= 0;
    if (v6) {
      return 0xFFFFFFFFLL;
    }
  }
  while (((v5 >> v2) & 1) == 0)
  {
    BOOL v6 = v2-- <= 0;
    if (v6) {
      goto LABEL_6;
    }
  }
  return (v4 + v2);
}

uint64_t BitSetOr(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  unsigned int v3 = *(_DWORD *)(a2 + 32);
  if (v2 <= v3) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = a1;
  }
  if (v2 <= v3) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a2;
  }
  uint64_t result = BitSetClone(v4);
  int v7 = *(_DWORD *)(v5 + 32);
  if (v7 >= 1)
  {
    unsigned int v8 = 0;
    uint64_t v9 = *(void *)(v5 + 40);
    uint64_t v10 = *(void *)(v4 + 40);
    do
    {
      uint64_t v11 = v8 >> 5;
      int v12 = 1 << v8;
      uint64_t v13 = *(void *)(result + 40);
      if (((*(_DWORD *)(v10 + 4 * v11) | *(_DWORD *)(v9 + 4 * v11)) & (1 << v8)) != 0) {
        int v14 = *(_DWORD *)(v13 + 4 * v11) | v12;
      }
      else {
        int v14 = *(_DWORD *)(v13 + 4 * v11) & ~v12;
      }
      *(_DWORD *)(v13 + 4 * v11) = v14;
      ++v8;
    }
    while (v7 != v8);
  }
  return result;
}

uint64_t BitSetAndEquals(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 32);
  unsigned int v5 = *(_DWORD *)(a1 + 32);
  if (v5 < v4)
  {
    BitSetSetSizeEquals(a1, v4);
    unsigned int v5 = *(_DWORD *)(a1 + 32);
    unsigned int v4 = *(_DWORD *)(a2 + 32);
  }
  if (v4 < v5) {
    BitSetSetSizeEquals(a2, v5);
  }
  unint64_t v6 = *(unsigned int *)(a1 + 36);
  if (v6 >= 4)
  {
    unint64_t v7 = v6 >> 2;
    unsigned int v8 = *(int **)(a2 + 40);
    uint64_t v9 = *(_DWORD **)(a1 + 40);
    do
    {
      int v10 = *v8++;
      *v9++ &= v10;
      --v7;
    }
    while (v7);
  }
  return a1;
}

uint64_t BitSetAndNotEquals(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 32);
  unsigned int v5 = *(_DWORD *)(a1 + 32);
  if (v5 < v4)
  {
    BitSetSetSizeEquals(a1, v4);
    unsigned int v5 = *(_DWORD *)(a1 + 32);
    unsigned int v4 = *(_DWORD *)(a2 + 32);
  }
  if (v4 < v5) {
    BitSetSetSizeEquals(a2, v5);
  }
  unint64_t v6 = *(unsigned int *)(a1 + 36);
  if (v6 >= 4)
  {
    unint64_t v7 = v6 >> 2;
    unsigned int v8 = *(int **)(a2 + 40);
    uint64_t v9 = *(_DWORD **)(a1 + 40);
    do
    {
      int v10 = *v8++;
      *v9++ &= ~v10;
      --v7;
    }
    while (v7);
  }
  return a1;
}

uint64_t BitSetOrEquals(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 32);
  unsigned int v5 = *(_DWORD *)(a1 + 32);
  if (v5 < v4)
  {
    BitSetSetSizeEquals(a1, v4);
    unsigned int v5 = *(_DWORD *)(a1 + 32);
    unsigned int v4 = *(_DWORD *)(a2 + 32);
  }
  if (v4 < v5) {
    BitSetSetSizeEquals(a2, v5);
  }
  unint64_t v6 = *(unsigned int *)(a1 + 36);
  if (v6 >= 4)
  {
    unint64_t v7 = v6 >> 2;
    unsigned int v8 = *(int **)(a2 + 40);
    uint64_t v9 = *(_DWORD **)(a1 + 40);
    do
    {
      int v10 = *v8++;
      *v9++ |= v10;
      --v7;
    }
    while (v7);
  }
  return a1;
}

uint64_t BitSetEqualsTest(uint64_t a1, uint64_t a2)
{
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  if (v6 < v5)
  {
    BitSetSetSizeEquals(a1, v5);
    unsigned int v6 = *(_DWORD *)(a1 + 32);
    unsigned int v5 = *(_DWORD *)(a2 + 32);
  }
  if (v5 < v6)
  {
    BitSetSetSizeEquals(a2, v6);
    unsigned int v6 = *(_DWORD *)(a1 + 32);
  }
  if ((int)v6 < 1) {
    return 1;
  }
  unsigned int v7 = 0;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a2 + 40);
  int8x16_t v10 = (int8x16_t)xmmword_2393DBD10;
  int32x4_t v11 = (int32x4_t)xmmword_2393D21E0;
  v12.i64[0] = 0x1F0000001FLL;
  v12.i64[1] = 0x1F0000001FLL;
  v13.i64[0] = 0x400000004;
  v13.i64[1] = 0x400000004;
  uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(v6 - 1);
  do
  {
    int8x16_t v15 = v10;
    int32x4_t v16 = (int32x4_t)vcgeq_u32(v14, (uint32x4_t)v11);
    int16x4_t v17 = vmovn_s32(v16);
    uint64_t v18 = v7 >> 5;
    if (v17.i8[0]) {
      v10.i32[0] = *(_DWORD *)(v8 + 4 * v18);
    }
    if (v17.i8[2]) {
      v10.i32[1] = *(_DWORD *)(v8 + 4 * v18);
    }
    if (v17.i8[4]) {
      v10.i32[2] = *(_DWORD *)(v8 + 4 * v18);
    }
    if (v17.i8[6]) {
      v10.i32[3] = *(_DWORD *)(v8 + 4 * v18);
    }
    if (v17.i8[0]) {
      v2.i32[0] = *(_DWORD *)(v9 + 4 * v18);
    }
    if (v17.i8[2]) {
      v2.i32[1] = *(_DWORD *)(v9 + 4 * v18);
    }
    if (v17.i8[4]) {
      v2.i32[2] = *(_DWORD *)(v9 + 4 * v18);
    }
    if (v17.i8[6]) {
      v2.i32[3] = *(_DWORD *)(v9 + 4 * v18);
    }
    int8x16_t v10 = vandq_s8(v15, (int8x16_t)vshlq_u32((uint32x4_t)vmvnq_s8(veorq_s8(v10, v2)), (uint32x4_t)vnegq_s32((int32x4_t)vandq_s8((int8x16_t)v11, v12))));
    v7 += 4;
    int32x4_t v11 = vaddq_s32(v11, v13);
  }
  while (((v6 + 3) & 0xFFFFFFFC) != v7);
  int8x16_t v19 = vbslq_s8((int8x16_t)v16, v10, v15);
  *(int8x8_t *)v19.i8 = vand_s8(*(int8x8_t *)v19.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  return (v19.i32[0] & v19.i32[1]);
}

BOOL PPStreamParamBindingIsEqual(void *a1, void *a2)
{
  return *a1 == *a2;
}

BOOL PPStreamAttribBindingIsEqual(void *a1, void *a2)
{
  return *a1 == *a2;
}

BOOL PPStreamOutputBindingIsEqual(void *a1, void *a2)
{
  return *a1 == *a2;
}

uint64_t PPStreamChunkGetStream(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int *a5)
{
  *a3 = 1;
  uint64_t v5 = 16;
  switch(*(unsigned char *)(a1 + 16))
  {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0xA:
    case 0xC:
      uint64_t v5 = a1 + 24;
      break;
    case 9:
      *a3 = 2;
      uint64_t v5 = a1 + 32;
      uint64_t v7 = a1 + 24;
      BOOL v8 = a4 == 0;
      goto LABEL_7;
    case 0xB:
      uint64_t v5 = a1 + 24;
      int v9 = *(_DWORD *)(a1 + 24) & 7;
      if (a4)
      {
        *a3 = v9 + 2;
        uint64_t v5 = a1 + 8 * (a4 - 2) + 40;
        uint64_t v7 = a1 + 32;
        BOOL v8 = a4 == 1;
LABEL_7:
        if (v8) {
          uint64_t v5 = v7;
        }
      }
      else
      {
        *a5 = v9;
        *a3 = (*(_DWORD *)v5 & 7) + 2;
      }
      break;
    case 0xD:
      *a3 = 2;
      uint64_t v5 = a1 + 4 * (2 * a4) + 24;
      break;
    default:
      return *(void *)v5;
  }
  return *(void *)v5;
}

uint64_t PPStreamChunkCompare(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 16) != *(unsigned __int8 *)(a2 + 16)) {
    return 1;
  }
  switch(*(unsigned char *)(a1 + 16))
  {
    case 0:
    case 1:
    case 7:
    case 8:
    case 0xA:
    case 0xC:
      if (*(void *)(a1 + 24) != *(void *)(a2 + 24)) {
        return 1;
      }
      break;
    case 2:
    case 4:
    case 5:
    case 6:
    case 9:
    case 0xD:
      if (*(void *)(a1 + 24) != *(void *)(a2 + 24) || *(void *)(a1 + 32) != *(void *)(a2 + 32)) {
        return 1;
      }
      break;
    case 3:
      if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
        return 1;
      }
      break;
    case 0xB:
      *(_DWORD *)(a2 + 92) = *(_DWORD *)(a1 + 92);
      *(_DWORD *)(a2 + 96) = *(_DWORD *)(a1 + 96);
      if (memcmp((const void *)(a1 + 24), (const void *)(a2 + 24), 0x50uLL)) {
        return 1;
      }
      break;
    default:
      return 1;
  }
  return 0;
}

void *PPStreamChunkListCreate()
{
  uint64_t result = malloc_type_calloc(0x18uLL, 1uLL, 0xA92C9FCEuLL);
  if (!result) {
    abort();
  }
  return result;
}

void *PPStreamChunkListCreateFromChunkList(uint64_t *a1)
{
  int8x16_t v2 = PPStreamChunkListCreate();
  for (uint64_t i = *a1; i; uint64_t i = *(void *)(i + 8))
  {
    switch(*(unsigned char *)(i + 16))
    {
      case 0:
      case 1:
      case 7:
      case 8:
      case 0xA:
      case 0xC:
        unsigned int v4 = 8;
        break;
      case 2:
      case 4:
      case 5:
      case 6:
      case 9:
      case 0xD:
        unsigned int v4 = 16;
        break;
      case 3:
        unsigned int v4 = 4;
        break;
      case 0xB:
        int v9 = *(_DWORD *)(i + 96);
        if (v9) {
          unsigned int v4 = v9 + 81;
        }
        else {
          unsigned int v4 = 80;
        }
        break;
      case 0xE:
        int v8 = *(_DWORD *)(i + 28);
        if (v8) {
          unsigned int v4 = v8 + 9;
        }
        else {
          unsigned int v4 = 8;
        }
        break;
      default:
        unsigned int v4 = 0;
        break;
    }
    uint64_t v5 = v4;
    unsigned int v6 = PPStreamChunkCreate(v4);
    memmove(v6, (const void *)i, v5 + 24);
    *unsigned int v6 = 0;
    v6[1] = 0;
    if (!*v2) {
      *int8x16_t v2 = v6;
    }
    uint64_t v7 = v2[1];
    if (v7)
    {
      *(void *)(v7 + 8) = v6;
      *unsigned int v6 = v7;
    }
    v6[1] = 0;
    v2[1] = v6;
    ++*((_DWORD *)v2 + 4);
  }
  return v2;
}

uint64_t PPStreamChunkListAddChunk(uint64_t result, void *a2)
{
  if (!*(void *)result)
  {
    *(void *)uint64_t result = a2;
    *a2 = 0;
  }
  uint64_t v2 = *(void *)(result + 8);
  if (v2)
  {
    *(void *)(v2 + 8) = a2;
    *a2 = v2;
  }
  a2[1] = 0;
  *(void *)(result + 8) = a2;
  ++*(_DWORD *)(result + 16);
  return result;
}

void PPStreamChunkListFree(_DWORD *a1)
{
  int v2 = a1[4];
  if (v2 >= 1)
  {
    unsigned int v3 = *(void **)a1;
    do
    {
      unsigned int v4 = (void *)v3[1];
      free(v3);
      unsigned int v3 = v4;
      --v2;
    }
    while (v2);
  }

  free(a1);
}

uint64_t PPStreamChunkListInsertChunkBeforeChunk(uint64_t result, void *a2, uint64_t a3)
{
  if (!a3)
  {
    if (!*(void *)result)
    {
      *(void *)uint64_t result = a2;
      *a2 = 0;
    }
    unsigned int v3 = (void *)(result + 8);
    uint64_t v4 = *(void *)(result + 8);
    if (v4)
    {
      *(void *)(v4 + 8) = a2;
      *a2 = v4;
    }
    a2[1] = 0;
    goto LABEL_11;
  }
  *a2 = *(void *)a3;
  a2[1] = a3;
  if (*(void *)a3) {
    *(void *)(*(void *)a3 + 8) = a2;
  }
  *(void *)a3 = a2;
  unsigned int v3 = (void *)result;
  if (*(void *)result == a3) {
LABEL_11:
  }
    *unsigned int v3 = a2;
  ++*(_DWORD *)(result + 16);
  return result;
}

uint64_t PPStreamChunkListInsertChunkAfterChunk(uint64_t result, void *a2, uint64_t a3)
{
  if (!a3)
  {
    *a2 = 0;
    unsigned int v6 = *(void **)result;
    if (*(void *)result) {
      *unsigned int v6 = a2;
    }
    a2[1] = v6;
    uint64_t v5 = (void *)result;
    goto LABEL_9;
  }
  uint64_t v3 = *(void *)(a3 + 8);
  *a2 = a3;
  a2[1] = v3;
  uint64_t v4 = *(void **)(a3 + 8);
  if (v4) {
    *uint64_t v4 = a2;
  }
  *(void *)(a3 + 8) = a2;
  uint64_t v5 = (void *)(result + 8);
  if (*(void *)(result + 8) == a3) {
LABEL_9:
  }
    *uint64_t v5 = a2;
  ++*(_DWORD *)(result + 16);
  return result;
}

void PPStreamChunkListRemoveChunk(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = (void *)a2[1];
  if (*a2)
  {
    *(void *)(v3 + 8) = v4;
    uint64_t v4 = (void *)a2[1];
  }
  else
  {
    *(void *)a1 = v4;
  }
  if (!v4) {
    uint64_t v4 = (void *)(a1 + 8);
  }
  *uint64_t v4 = v3;
  free(a2);
  --*(_DWORD *)(a1 + 16);
}

void *PPStreamChunkListSort(void *result)
{
  int v1 = (void *)*result;
  if (*result)
  {
    do
    {
      if (!v1) {
        break;
      }
      int v2 = v1 + 1;
      uint64_t v3 = v1[1];
      if (!v3) {
        break;
      }
      int v4 = 0;
      uint64_t v5 = v1;
      do
      {
        unsigned int v6 = (void *)v3;
        if (*((_DWORD *)v5 + 8) > *(_DWORD *)(v3 + 32))
        {
          uint64_t v7 = *(void *)(v3 + 8);
          if (v7) {
            int v8 = (void *)v6[1];
          }
          else {
            int v8 = result + 1;
          }
          *int v8 = v5;
          uint64_t v9 = *v5;
          if (*v5)
          {
            *(void *)(v9 + 8) = v6;
            uint64_t v7 = v6[1];
          }
          else
          {
            *uint64_t result = v6;
            int v1 = v6;
          }
          *int v2 = v7;
          *unsigned int v6 = v9;
          v6[1] = v5;
          int v4 = 1;
          *uint64_t v5 = v6;
        }
        int v2 = v6 + 1;
        uint64_t v3 = v6[1];
        uint64_t v5 = v6;
      }
      while (v3);
    }
    while (v4);
  }
  return result;
}

uint64_t *PPStreamChunkListGetStream(uint64_t *result, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = *result;
  *a3 = 0;
  if (v3)
  {
    int v6 = 0;
    unsigned int v13 = 0;
    uint64_t v7 = v3;
    do
    {
      uint64_t result = (uint64_t *)PPStreamChunkGetStream(v7, a2, &v13, 0, &v11);
      v6 += v13;
      *a3 = v6;
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7);
    if (a2)
    {
      unsigned int v8 = 0;
      do
      {
        uint64_t result = (uint64_t *)PPStreamChunkGetStream(v3, a2, &v13, 0, &v11);
        *(void *)(a2 + 8 * v8) = result;
        unsigned int v9 = v13;
        if (v13 < 2)
        {
          ++v8;
        }
        else
        {
          --v13;
          int v10 = 1;
          do
          {
            uint64_t result = (uint64_t *)PPStreamChunkGetStream(v3, a2, &v12, v10, &v11);
            *(void *)(a2 + 8 * (v8 + v10++)) = result;
          }
          while (v9 != v10);
          v8 += v10;
        }
        uint64_t v3 = *(void *)(v3 + 8);
      }
      while (v3);
    }
  }
  return result;
}

uint64_t PPStreamChunkListChunkAtIndex(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    int v3 = a2;
    while (2)
    {
      uint64_t result = 0;
      switch(*(unsigned char *)(v2 + 16))
      {
        case 0:
        case 1:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xC:
        case 0xD:
          if (v3) {
            goto LABEL_10;
          }
          return v2;
        case 2:
        case 4:
        case 5:
        case 6:
          int v5 = *(_DWORD *)(v2 + 32);
          goto LABEL_9;
        case 3:
          int v5 = *(_DWORD *)(v2 + 24);
          goto LABEL_9;
        case 0xB:
          int v5 = *(_DWORD *)(v2 + 88);
LABEL_9:
          if (v5 != a2) {
            goto LABEL_10;
          }
          return v2;
        case 0xE:
          return result;
        default:
LABEL_10:
          uint64_t v2 = *(void *)(v2 + 8);
          --v3;
          if (!v2) {
            return 0;
          }
          continue;
      }
    }
  }
  return 0;
}

uint64_t PPStreamChunkListCompare(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 1;
  }
  uint64_t v2 = *(void *)a2;
  for (uint64_t i = *(void *)a1; i && v2 != 0; uint64_t i = *(void *)(i + 8))
  {
    if (PPStreamChunkCompare(i, v2)) {
      return 1;
    }
    uint64_t v2 = *(void *)(v2 + 8);
  }
  return 0;
}

uint64_t PPStreamChunkListGetNextIndex(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 0;
  }
  switch(*(unsigned char *)(v1 + 16))
  {
    case 0:
    case 1:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xC:
    case 0xD:
      LODWORD(result) = 0;
      do
      {
        uint64_t result = (result + 1);
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    case 2:
      LODWORD(result) = 0;
      do
      {
        unsigned int v3 = *(_DWORD *)(v1 + 32);
        if (v3 >= result) {
          uint64_t result = v3 + 1;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    case 3:
      LODWORD(result) = 0;
      do
      {
        unsigned int v4 = *(_DWORD *)(v1 + 24);
        if (v4 >= result) {
          uint64_t result = v4 + 1;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    case 4:
      LODWORD(result) = 0;
      do
      {
        unsigned int v5 = *(_DWORD *)(v1 + 32);
        if (v5 >= result) {
          uint64_t result = v5 + 1;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    case 5:
      LODWORD(result) = 0;
      do
      {
        unsigned int v6 = *(_DWORD *)(v1 + 32);
        if (v6 >= result) {
          uint64_t result = v6 + 1;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    case 6:
      LODWORD(result) = 0;
      do
      {
        unsigned int v7 = *(_DWORD *)(v1 + 32);
        if (v7 >= result) {
          uint64_t result = v7 + 1;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    case 0xB:
      LODWORD(result) = 0;
      do
      {
        unsigned int v8 = *(_DWORD *)(v1 + 88);
        if (v8 >= result) {
          uint64_t result = v8 + 1;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v1 = *(void *)(v1 + 8);
      }
      while (v1);
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t PPStreamCreate()
{
  v0 = malloc_type_calloc(0x90uLL, 1uLL, 0xA92C9FCEuLL);
  if (!v0) {
    abort();
  }
  uint64_t v1 = (uint64_t)v0;
  v0[2] = PPStreamChunkListCreate();
  *(void *)(v1 + 24) = PPStreamChunkListCreate();
  *(void *)(v1 + 32) = PPStreamChunkListCreate();
  *(void *)(v1 + 80) = PPStreamChunkListCreate();
  *(void *)(v1 + 40) = PPStreamChunkListCreate();
  *(void *)(v1 + 56) = PPStreamChunkListCreate();
  *(void *)(v1 + 72) = PPStreamChunkListCreate();
  *(void *)(v1 + 48) = PPStreamChunkListCreate();
  *(void *)(v1 + 64) = PPStreamChunkListCreate();
  *(void *)(v1 + 88) = PPStreamChunkListCreate();
  *(void *)(v1 + 104) = PPStreamChunkListCreate();
  *(void *)(v1 + 112) = PPStreamChunkListCreate();
  *(void *)(v1 + 128) = PPStreamChunkListCreate();
  *(void *)(v1 + 120) = PPStreamChunkListCreate();
  *(void *)(v1 + 96) = PPStreamChunkListCreate();
  *(_DWORD *)(v1 + 140) = 0;
  uint64_t v4 = 0;
  PPStreamAddReqs0(v1, &v4);
  uint64_t v3 = 0;
  PPStreamAddReqs1(v1, &v3);
  return v1;
}

unsigned char *PPStreamAddReqs0(uint64_t a1, void *a2)
{
  uint64_t result = PPStreamChunkCreate(8);
  result[16] = 0;
  *((void *)result + 3) = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned char *PPStreamAddReqs1(uint64_t a1, void *a2)
{
  uint64_t result = PPStreamChunkCreate(8);
  result[16] = 1;
  *((void *)result + 3) = *a2;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

void PPStreamFree(_DWORD **a1)
{
  PPStreamChunkListFree(a1[2]);
  PPStreamChunkListFree(a1[3]);
  PPStreamChunkListFree(a1[4]);
  PPStreamChunkListFree(a1[10]);
  PPStreamChunkListFree(a1[5]);
  PPStreamChunkListFree(a1[7]);
  PPStreamChunkListFree(a1[9]);
  PPStreamChunkListFree(a1[6]);
  PPStreamChunkListFree(a1[8]);
  PPStreamChunkListFree(a1[11]);
  PPStreamChunkListFree(a1[13]);
  PPStreamChunkListFree(a1[14]);
  PPStreamChunkListFree(a1[16]);
  PPStreamChunkListFree(a1[15]);
  PPStreamChunkListFree(a1[12]);

  free(a1);
}

void *PPStreamChunkCreate(uint64_t a1)
{
  uint64_t result = malloc_type_calloc(a1 + 24, 1uLL, 0xA92C9FCEuLL);
  if (!result) {
    abort();
  }
  return result;
}

char *PPStreamAddTempUsage(uint64_t a1, _OWORD *a2)
{
  uint64_t result = (char *)PPStreamChunkCreate(16);
  result[16] = 2;
  *(_OWORD *)(result + 24) = *a2;
  uint64_t v5 = *(void *)(a1 + 32);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned char *PPStreamAddTempUsageArray(uint64_t a1, void *a2)
{
  uint64_t result = PPStreamChunkCreate(8);
  result[16] = 8;
  *((void *)result + 3) = *a2;
  uint64_t v5 = *(void *)(a1 + 80);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned char *PPStreamAddAddressUsage(uint64_t a1, _DWORD *a2)
{
  uint64_t result = PPStreamChunkCreate(4);
  result[16] = 3;
  *((_DWORD *)result + 6) = *a2;
  uint64_t v5 = *(void *)(a1 + 40);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

char *PPStreamAddParamBinding(uint64_t a1, _OWORD *a2)
{
  uint64_t result = (char *)PPStreamChunkCreate(16);
  result[16] = 5;
  *(_OWORD *)(result + 24) = *a2;
  uint64_t v5 = *(void *)(a1 + 56);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned char *PPStreamAddParamBindingArray(uint64_t a1, void *a2)
{
  uint64_t result = PPStreamChunkCreate(8);
  result[16] = 7;
  *((void *)result + 3) = *a2;
  uint64_t v5 = *(void *)(a1 + 72);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

char *PPStreamAddAttribBinding(uint64_t a1, _OWORD *a2)
{
  uint64_t result = (char *)PPStreamChunkCreate(16);
  result[16] = 4;
  *(_OWORD *)(result + 24) = *a2;
  uint64_t v5 = *(void *)(a1 + 48);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

char *PPStreamAddOutputBinding(uint64_t a1, _OWORD *a2)
{
  uint64_t result = (char *)PPStreamChunkCreate(16);
  result[16] = 6;
  *(_OWORD *)(result + 24) = *a2;
  uint64_t v5 = *(void *)(a1 + 64);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

char *PPStreamAddTexImage(uint64_t a1, _OWORD *a2)
{
  uint64_t result = (char *)PPStreamChunkCreate(16);
  result[16] = 9;
  *(_OWORD *)(result + 24) = *a2;
  uint64_t v5 = *(void *)(a1 + 88);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

char *PPStreamAddOperation(uint64_t a1, uint64_t a2, const void *a3)
{
  size_t v6 = *(unsigned int *)(a2 + 72);
  if (v6) {
    uint64_t v7 = (v6 + 81);
  }
  else {
    uint64_t v7 = 80;
  }
  unsigned int v8 = (char *)PPStreamChunkCreate(v7);
  unsigned int v9 = v8;
  v8[16] = 11;
  *(_OWORD *)(v8 + 24) = *(_OWORD *)a2;
  long long v10 = *(_OWORD *)(a2 + 48);
  long long v11 = *(_OWORD *)(a2 + 64);
  long long v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v8 + 40) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v8 + 88) = v11;
  *(_OWORD *)(v8 + 72) = v10;
  *(_OWORD *)(v8 + 56) = v12;
  if (a3 && v6)
  {
    memmove(v8 + 104, a3, v6);
    v9[v6 + 104] = 0;
  }
  int v13 = *(_DWORD *)(a1 + 140);
  *(_DWORD *)(a1 + 140) = v13 + 1;
  *((_DWORD *)v9 + 22) = v13;
  uint64_t v14 = *(void *)(a1 + 104);
  if (!*(void *)v14)
  {
    *(void *)uint64_t v14 = v9;
    *(void *)unsigned int v9 = 0;
  }
  uint64_t v15 = *(void *)(v14 + 8);
  if (v15)
  {
    *(void *)(v15 + 8) = v9;
    *(void *)unsigned int v9 = v15;
  }
  *((void *)v9 + 1) = 0;
  *(void *)(v14 + 8) = v9;
  ++*(_DWORD *)(v14 + 16);
  return v9;
}

char *PPStreamInsertOperationBeforeChunk(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  size_t v8 = *(unsigned int *)(a2 + 72);
  if (v8) {
    uint64_t v9 = (v8 + 81);
  }
  else {
    uint64_t v9 = 80;
  }
  long long v10 = (char *)PPStreamChunkCreate(v9);
  long long v11 = v10;
  v10[16] = 11;
  *(_OWORD *)(v10 + 24) = *(_OWORD *)a2;
  long long v12 = *(_OWORD *)(a2 + 48);
  long long v13 = *(_OWORD *)(a2 + 64);
  long long v14 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v10 + 40) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v10 + 88) = v13;
  *(_OWORD *)(v10 + 72) = v12;
  *(_OWORD *)(v10 + 56) = v14;
  if (a3 && v8)
  {
    memmove(v10 + 104, a3, v8);
    v11[v8 + 104] = 0;
  }
  int v15 = *(_DWORD *)(a1 + 140);
  *(_DWORD *)(a1 + 140) = v15 + 1;
  *((_DWORD *)v11 + 22) = v15;
  if (a4)
  {
    uint64_t v16 = *((void *)v11 + 3);
    *((void *)v11 + 3) = v16 & 0xFFFFFFFFFFFFFFC7 | (8 * ((*(void *)(a4 + 24) >> 3) & 7));
    unint64_t v17 = *(void *)(a4 + 24);
    *(void *)(a4 + 24) = v17 & 0xFFFFFFFFFFFFFFC7 | (8 * (v16 & 7));
    *((void *)v11 + 3) = *((void *)v11 + 3) & 0xFFFFFFFFFFFFBFFFLL | (((v17 >> 14) & 1) << 14);
    *(void *)(a4 + 24) &= ~0x4000uLL;
    LODWORD(v17) = *((_DWORD *)v11 + 22);
    *((_DWORD *)v11 + 22) = *(_DWORD *)(a4 + 88);
    *(_DWORD *)(a4 + 88) = v17;
  }
  PPStreamChunkListInsertChunkBeforeChunk(*(void *)(a1 + 104), v11, a4);
  return v11;
}

char *PPStreamInsertOperationAfterChunk(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 8);
  size_t v9 = *(unsigned int *)(a2 + 72);
  if (v9) {
    uint64_t v10 = (v9 + 81);
  }
  else {
    uint64_t v10 = 80;
  }
  long long v11 = (char *)PPStreamChunkCreate(v10);
  long long v12 = v11;
  v11[16] = 11;
  *(_OWORD *)(v11 + 24) = *(_OWORD *)a2;
  long long v13 = *(_OWORD *)(a2 + 48);
  long long v14 = *(_OWORD *)(a2 + 64);
  long long v15 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v11 + 40) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v11 + 88) = v14;
  *(_OWORD *)(v11 + 72) = v13;
  *(_OWORD *)(v11 + 56) = v15;
  if (a3 && v9)
  {
    memmove(v11 + 104, a3, v9);
    v12[v9 + 104] = 0;
  }
  int v16 = *(_DWORD *)(a1 + 140);
  *(_DWORD *)(a1 + 140) = v16 + 1;
  *((_DWORD *)v12 + 22) = v16;
  uint64_t v17 = *((void *)v12 + 3);
  *((void *)v12 + 3) = v17 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a4 + 24) & 7));
  if (v8) {
    *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0xFFFFFFFFFFFFFFC7 | (8 * (v17 & 7));
  }
  PPStreamChunkListInsertChunkAfterChunk(*(void *)(a1 + 104), v12, a4);
  return v12;
}

char *PPStreamAddLabel(uint64_t a1, const void *a2, unsigned int a3)
{
  size_t v6 = a3;
  uint64_t v7 = (char *)PPStreamChunkCreate(a3 + 9);
  v7[16] = 14;
  *((_DWORD *)v7 + 7) = a3;
  *((_DWORD *)v7 + 6) = *(_DWORD *)(a1 + 140);
  memmove(v7 + 32, a2, v6);
  v7[a3 + 32] = 0;
  uint64_t v8 = *(void *)(a1 + 112);
  if (!*(void *)v8)
  {
    *(void *)uint64_t v8 = v7;
    *(void *)uint64_t v7 = 0;
  }
  uint64_t v9 = *(void *)(v8 + 8);
  if (v9)
  {
    *(void *)(v9 + 8) = v7;
    *(void *)uint64_t v7 = v9;
  }
  *((void *)v7 + 1) = 0;
  *(void *)(v8 + 8) = v7;
  ++*(_DWORD *)(v8 + 16);
  return v7;
}

void PPStreamRemoveLabelsAtOperationIndex(uint64_t a1, int a2)
{
  uint64_t v3 = **(void **)(a1 + 112);
  if (v3)
  {
    do
    {
      uint64_t v5 = *(void *)(v3 + 8);
      if (*(_DWORD *)(v3 + 24) == a2) {
        PPStreamChunkListRemoveChunk(*(void *)(a1 + 112), (uint64_t *)v3);
      }
      uint64_t v3 = v5;
    }
    while (v5);
  }
}

unsigned char *PPStreamAddConstant(uint64_t a1, _DWORD *a2)
{
  uint64_t result = PPStreamChunkCreate(16);
  result[16] = 13;
  *((_DWORD *)result + 6) = *a2;
  *((_DWORD *)result + 7) = a2[1];
  *((_DWORD *)result + 8) = a2[2];
  *((_DWORD *)result + 9) = a2[3];
  uint64_t v5 = *(void *)(a1 + 128);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned char *PPStreamAddRasterOp(uint64_t a1, void *a2)
{
  uint64_t result = PPStreamChunkCreate(8);
  result[16] = 12;
  *((void *)result + 3) = *a2;
  uint64_t v5 = *(void *)(a1 + 120);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned char *PPStreamAddOption(uint64_t a1, char a2)
{
  uint64_t result = PPStreamChunkCreate(8);
  result[16] = 10;
  result[27] = a2;
  uint64_t v5 = *(void *)(a1 + 96);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = result;
    *(void *)uint64_t result = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = result;
    *(void *)uint64_t result = v6;
  }
  *((void *)result + 1) = 0;
  *(void *)(v5 + 8) = result;
  ++*(_DWORD *)(v5 + 16);
  return result;
}

unsigned __int16 *PPStreamGetStream(uint64_t a1, _DWORD *a2)
{
  int v29 = 0;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 32), 0, &v29);
  int v4 = v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 48), 0, &v29);
  int v5 = v4 + v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 56), 0, &v29);
  int v6 = v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 64), 0, &v29);
  int v7 = v5 + v6 + v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 72), 0, &v29);
  int v8 = v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 80), 0, &v29);
  int v9 = v8 + v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 88), 0, &v29);
  int v10 = v7 + v9 + v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 96), 0, &v29);
  int v11 = v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 104), 0, &v29);
  int v12 = v11 + v29;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 120), 0, &v29);
  unsigned int v13 = v10 + v12 + v29 + 18 - ((v10 + v12 + v29 + 18) | 0xFFFFFFFE);
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 128), 0, &v29);
  unsigned int v14 = v13 + v29;
  *a2 = v13 + v29;
  long long v15 = (unsigned __int16 *)malloc_type_malloc(8 * v14, 0x7081ABB9uLL);
  if (!v15) {
    abort();
  }
  int v16 = v15;
  bzero(v15, 8 * *a2);
  *(void *)int v16 = *(void *)a1;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 16), (uint64_t)(v16 + 4), &v29);
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 24), (uint64_t)(v16 + 8), &v29);
  *((_DWORD *)v16 + 6) = *a2;
  *((_DWORD *)v16 + 10) = *(_DWORD *)(*(void *)(a1 + 40) + 16);
  *((_DWORD *)v16 + 8) = *(_DWORD *)(*(void *)(a1 + 32) + 16);
  *((_DWORD *)v16 + 9) = 18;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 32), (uint64_t)(v16 + 72), &v29);
  int v17 = v29 + 18;
  *((_DWORD *)v16 + 12) = *(_DWORD *)(*(void *)(a1 + 48) + 16);
  *((_DWORD *)v16 + 13) = v17;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 48), (uint64_t)&v16[4 * v17], &v29);
  int v18 = v29 + v17;
  *((_DWORD *)v16 + 14) = *(_DWORD *)(*(void *)(a1 + 56) + 16);
  *((_DWORD *)v16 + 15) = v18;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 56), (uint64_t)&v16[4 * v18], &v29);
  int v19 = v29 + v18;
  *((_DWORD *)v16 + 16) = *(_DWORD *)(*(void *)(a1 + 64) + 16);
  *((_DWORD *)v16 + 17) = v19;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 64), (uint64_t)&v16[4 * v19], &v29);
  int v20 = v29 + v19;
  *((_DWORD *)v16 + 18) = *(_DWORD *)(*(void *)(a1 + 72) + 16);
  *((_DWORD *)v16 + 19) = v20;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 72), (uint64_t)&v16[4 * v20], &v29);
  int v21 = v29 + v20;
  *((_DWORD *)v16 + 20) = *(_DWORD *)(*(void *)(a1 + 80) + 16);
  *((_DWORD *)v16 + 21) = v21;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 80), (uint64_t)&v16[4 * v21], &v29);
  int v22 = v29 + v21;
  *((_DWORD *)v16 + 22) = *(_DWORD *)(*(void *)(a1 + 88) + 16);
  *((_DWORD *)v16 + 23) = v22;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 88), (uint64_t)&v16[4 * v22], &v29);
  int v23 = v29 + v22;
  *((_DWORD *)v16 + 24) = *(_DWORD *)(*(void *)(a1 + 96) + 16);
  *((_DWORD *)v16 + 25) = v23;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 96), (uint64_t)&v16[4 * v23], &v29);
  int v24 = v29 + v23;
  *((_DWORD *)v16 + 26) = *(_DWORD *)(*(void *)(a1 + 104) + 16);
  *((_DWORD *)v16 + 27) = v24;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 104), (uint64_t)&v16[4 * v24], &v29);
  int v25 = v29 + v24;
  if (v29) {
    *(void *)&v16[4 * v25] = *(void *)&v16[4 * v25] & 0xFFFFFFFFFFFFFFC7 | (8
  }
                                                                                * (*(_DWORD *)(*(void *)(*(void *)(a1 + 104) + 8)
                                                                                             + 24) & 7));
  *((_DWORD *)v16 + 30) = *(_DWORD *)(a1 + 8);
  *((_DWORD *)v16 + 31) = v25;
  *(_DWORD *)(a1 + 12) = v25;
  int v26 = v25 + 1;
  *((_DWORD *)v16 + 32) = *(_DWORD *)(*(void *)(a1 + 120) + 16);
  *((_DWORD *)v16 + 33) = v25 + 1;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 120), (uint64_t)&v16[4 * (v25 + 1)], &v29);
  int v27 = v29 + v26;
  if ((v29 + v26)) {
    *(void *)&v16[4 * v27++] = 0;
  }
  *((_DWORD *)v16 + 34) = *(_DWORD *)(*(void *)(a1 + 128) + 16);
  *((_DWORD *)v16 + 35) = v27;
  PPStreamChunkListGetStream(*(uint64_t **)(a1 + 128), (uint64_t)&v16[4 * v27], &v29);
  PPStreamTokenAddRequirements(v16);
  return v16;
}

unsigned __int16 *PPStreamTokenAddRequirements(unsigned __int16 *result)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  memset(v52, 0, sizeof(v52));
  unint64_t v1 = *((void *)result + 1);
  uint64_t v2 = *((void *)result + 2);
  int v3 = *result;
  BOOL v5 = v3 != 34336 && v3 != 34820;
  uint64_t v6 = *((unsigned int *)result + 27);
  uint64_t v7 = *((unsigned int *)result + 31);
  if (v6 == v7)
  {
LABEL_48:
    int v10 = 0;
    int v8 = *((_DWORD *)result + 27);
    goto LABEL_49;
  }
  int v8 = 0;
  int v9 = 0;
  int v10 = -1;
  int v11 = &result[4 * v7];
  int v12 = (char *)&result[4 * v6];
  do
  {
    uint64_t v13 = *(void *)v12;
    uint64_t v14 = *(void *)v12 & 7;
    if (v3 != 34336 && v3 != 34820 && v14)
    {
      long long v15 = v12 + 16;
      uint64_t v16 = *(void *)v12 & 7;
      int v17 = v52;
      do
      {
        *v17++ = v15++;
        --v16;
      }
      while (v16);
    }
    int v18 = 0;
    unsigned int v19 = (v13 >> 6);
    if (v19 > 0x61)
    {
      uint64_t v22 = v19 - 130;
      if (v22 > 0x24) {
        goto LABEL_21;
      }
      if (((1 << (v19 + 126)) & 0x1800000003) != 0) {
        goto LABEL_22;
      }
      if (v22 != 34)
      {
LABEL_21:
        if (v19 - 98 >= 2)
        {
LABEL_46:
          int v21 = 0;
          goto LABEL_23;
        }
LABEL_22:
        int v21 = -1;
        int v18 = v5;
        goto LABEL_23;
      }
      int v18 = -1;
      BOOL v20 = v5;
LABEL_44:
      int v21 = v18;
      v1 |= 0x1000000uLL;
      int v18 = v20;
    }
    else
    {
      BOOL v20 = 0;
      int v21 = 0;
      switch((v13 >> 6))
      {
        case 'A':
          int v18 = 0;
          int v21 = -1;
          break;
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
          goto LABEL_22;
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'P':
          break;
        case 'O':
          int v18 = 0;
          int v21 = 0;
          v1 |= 2uLL;
          break;
        case 'Q':
          goto LABEL_44;
        default:
          if (v19 == 6) {
            goto LABEL_44;
          }
          goto LABEL_46;
      }
    }
LABEL_23:
    if (v3 != 34336 && v3 != 34820)
    {
      uint64_t v23 = (v21 + v14);
      if (v23)
      {
        int v24 = (unint64_t **)v52;
        while (1)
        {
          unint64_t v25 = **v24;
          unsigned int v26 = (v25 >> 19) & 3;
          if (v26 == 2) {
            goto LABEL_32;
          }
          if (v26 == 1) {
            goto LABEL_31;
          }
          if (!v26) {
            break;
          }
LABEL_33:
          ++v24;
          if (!--v23) {
            goto LABEL_34;
          }
        }
        unint64_t v25 = v25 & 0xFFFFFFFFFFFFE7FFLL | (((v25 >> 9) & 3) << 11);
LABEL_31:
        unint64_t v25 = v25 & 0xFFFFFFFFFFFF9FFFLL | (((v25 >> 11) & 3) << 13);
LABEL_32:
        **int v24 = v25 & 0xFFFFFFFFFFFE7FFFLL | (((v25 >> 13) & 3) << 15);
        goto LABEL_33;
      }
LABEL_34:
      if (v18)
      {
        int v27 = &v12[8 * (v13 & 7)];
        if ((*(void *)v27 & 0x1C0) == 0x80) {
          unint64_t v28 = *((void *)v27 + 1) & 0xFFFFFFFFFFC000FFLL | ((HIDWORD(*(void *)((char *)&result[4 * *((unsigned int *)result + 15)]
        }
                                                                                  + ((*(void *)v27 >> 45) & 0x7FFF8))) & 0x3FFFLL) << 8);
        else {
          unint64_t v28 = *((void *)v27 + 1) | 0x3FFF00;
        }
        *((void *)v27 + 1) = v28;
      }
    }
    v1 |= (*(void *)v12 >> 33) & 1;
    if ((*(void *)v12 & 0x4000) != 0)
    {
      int v10 = v9;
      int v8 = (unint64_t)(v12 - (char *)result) >> 3;
    }
    ++v9;
    v12 += 8 * (*(void *)v12 & 7) + 16;
  }
  while (v12 != (char *)v11);
  if (v10 == -1) {
    goto LABEL_48;
  }
LABEL_49:
  *((_DWORD *)result + 28) = v10;
  *((_DWORD *)result + 29) = v8;
  if (v3 > 35632)
  {
    if ((v3 - 36487) >= 2 && v3 != 35633 && v3 != 36313) {
      goto LABEL_98;
    }
    goto LABEL_86;
  }
  if (v3 == 34336)
  {
LABEL_86:
    uint64_t v43 = *((unsigned int *)result + 16);
    if (v43)
    {
      int v44 = &result[4 * *((unsigned int *)result + 17)];
      uint64_t v45 = 8 * v43;
      do
      {
        unint64_t v46 = *(void *)v44;
        switch((*(void *)v44 >> 8) & 0x1F)
        {
          case 3u:
            v1 |= 0x10uLL;
            break;
          case 4u:
          case 5u:
            v1 |= (v46 >> 27) & 0x20;
            break;
          case 9u:
            v1 |= 4uLL;
            break;
          case 0xAu:
            unint64_t v1 = v1 & 0xFFFFFFFFFFFFFF3FLL | ((64 << SBYTE4(v46)) | v1) & 0xC0;
            break;
          default:
            break;
        }
        uint64_t v47 = (v46 >> 13) & 1;
        if (v3 == 34336) {
          uint64_t v47 = 0;
        }
        v1 |= v47;
        v44 += 4;
        v45 -= 8;
      }
      while (v45);
    }
    goto LABEL_98;
  }
  if (v3 == 34820 || v3 == 35632)
  {
    uint64_t v29 = *((unsigned int *)result + 12);
    if (v29)
    {
      unsigned int v30 = &result[4 * *((unsigned int *)result + 13)];
      uint64_t v31 = 8 * v29;
      while (2)
      {
        unint64_t v32 = *(void *)v30;
        unsigned int v33 = (*(void *)v30 >> 10) & 0x1F;
        switch(v33)
        {
          case 1u:
            unint64_t v1 = v1 & 0xFFFFFFFFFFFFCFFFLL | (v32 >> 20) & 0x3000 | 0x100;
            goto LABEL_72;
          case 2u:
            v1 |= 0x2000000uLL;
            LOBYTE(v34) = 2;
            goto LABEL_61;
          case 3u:
            v1 |= 0x4000000uLL;
            LOBYTE(v34) = 3;
            goto LABEL_61;
          case 4u:
          case 5u:
          case 6u:
          case 7u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xDu:
          case 0xFu:
            goto LABEL_72;
          case 0xBu:
            v1 |= 0x400uLL;
            goto LABEL_72;
          case 0xCu:
            v1 |= 0x200uLL;
            goto LABEL_72;
          case 0xEu:
            unint64_t v1 = v1 & 0xFFFFFFFFFFFFFF3FLL | ((64 << SBYTE4(v32)) | v1) & 0xC0;
            goto LABEL_72;
          case 0x10u:
            v1 |= 0x800uLL;
            goto LABEL_72;
          default:
            if (v33 != 28) {
              goto LABEL_72;
            }
            uint64_t v34 = HIDWORD(v32) & 0x3F;
LABEL_61:
            uint64_t v35 = v2 & ~(0x100000001 << v34);
            if ((v32 & 0x100) != 0) {
              uint64_t v36 = 0x100000000;
            }
            else {
              uint64_t v36 = 0x100000001;
            }
            if ((v32 & 0x8000) != 0) {
              uint64_t v37 = 1;
            }
            else {
              uint64_t v37 = v36;
            }
            uint64_t v2 = v35 | (v37 << v34);
LABEL_72:
            v30 += 4;
            v31 -= 8;
            if (!v31) {
              break;
            }
            continue;
        }
        break;
      }
    }
    uint64_t v38 = *((unsigned int *)result + 16);
    if (v38)
    {
      int v39 = &result[4 * *((unsigned int *)result + 17)];
      uint64_t v40 = 8 * v38;
      while ((*(void *)v39 & 0x1F00) != 0x700)
      {
        v39 += 4;
        v40 -= 8;
        if (!v40) {
          goto LABEL_98;
        }
      }
      v1 |= 8uLL;
    }
  }
LABEL_98:
  uint64_t v48 = *((unsigned int *)result + 8);
  if (v48)
  {
    uint64_t v49 = &result[4 * *((unsigned int *)result + 9)];
    uint64_t v50 = 8 * v48;
    do
    {
      unint64_t v51 = *(void *)v49;
      v49 += 4;
      v1 |= (v51 >> 8) & 1;
      v50 -= 8;
    }
    while (v50);
  }
  *((void *)result + 1) = v1;
  *((void *)result + 2) = v2;
  return result;
}

uint64_t PPStreamTokenAddRasterRequirements(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8) & 0x100;
  uint64_t v2 = *(unsigned int *)(result + 128);
  if (v2)
  {
    int v3 = 0;
    int v4 = (unint64_t *)(result + 8 * *(unsigned int *)(result + 132));
    uint64_t v5 = 8 * v2;
    do
    {
      unint64_t v6 = *v4++;
      int v7 = v6 >> 3;
      uint64_t v8 = v1 | 0x4000;
      uint64_t v9 = (v6 >> 16) & 0xFF0000 | v1;
      unsigned int v10 = ((v6 >> 8) & 0xF) - 9;
      BOOL v11 = v10 >= 2;
      if (v10 >= 2) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = v9 | 0x100;
      }
      if (v11) {
        int v13 = v3;
      }
      else {
        int v13 = 1;
      }
      if (v7 != 19)
      {
        uint64_t v12 = v1;
        int v13 = v3;
      }
      if (v7 == 5)
      {
        uint64_t v12 = v1 | 0x4000;
        int v13 = 1;
      }
      if (v7 == 4) {
        v1 |= 0x8000uLL;
      }
      if (v7 == 1) {
        uint64_t v1 = v8;
      }
      if (v7 > 4)
      {
        uint64_t v1 = v12;
        int v3 = v13;
      }
      v5 -= 8;
    }
    while (v5);
    if (v3)
    {
      uint64_t v14 = *(unsigned int *)(result + 64);
      if (v14)
      {
        long long v15 = (void *)(result + 8 * *(unsigned int *)(result + 68));
        uint64_t v16 = 8 * v14;
        while ((*v15 & 0x1F00) != 0x700)
        {
          ++v15;
          v16 -= 8;
          if (!v16) {
            goto LABEL_27;
          }
        }
        v1 |= 8uLL;
      }
    }
  }
LABEL_27:
  *(void *)(result + 8) = v1 | *(void *)(result + 8) & 0xFFFFFFFFFF003EF7;
  return result;
}

void *PPStreamTokenAlloc(size_t a1)
{
  uint64_t result = malloc_type_malloc(a1, 0x7081ABB9uLL);
  if (!result) {
    abort();
  }
  return result;
}

uint64_t PPStreamGetTexOperationCount(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 104);
  if (!v1) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    uint64_t result = ((*(_DWORD *)(v1 + 24) >> 15) & 1) + result;
    uint64_t v1 = *(void *)(v1 + 8);
  }
  while (v1);
  return result;
}

uint64_t PPStreamAttachStream(uint64_t a1, uint64_t a2)
{
  PPStreamChunkListRemoveChunk(*(void *)(a1 + 16), **(uint64_t ***)(a1 + 16));
  PPStreamChunkListRemoveChunk(*(void *)(a1 + 24), **(uint64_t ***)(a1 + 24));
  *(void *)a1 = *(void *)a2;
  int v4 = PPStreamChunkCreate(8);
  v4[16] = 0;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!*(void *)v5)
  {
    *(void *)uint64_t v5 = v4;
    *(void *)int v4 = 0;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    *(void *)(v6 + 8) = v4;
    *(void *)int v4 = v6;
  }
  *((void *)v4 + 1) = 0;
  *(void *)(v5 + 8) = v4;
  ++*(_DWORD *)(v5 + 16);
  int v7 = PPStreamChunkCreate(8);
  v7[16] = 1;
  uint64_t v8 = *(void *)(a1 + 24);
  if (!*(void *)v8)
  {
    *(void *)uint64_t v8 = v7;
    *(void *)int v7 = 0;
  }
  uint64_t v9 = *(void *)(v8 + 8);
  if (v9)
  {
    *(void *)(v9 + 8) = v7;
    *(void *)int v7 = v9;
  }
  *((void *)v7 + 1) = 0;
  *(void *)(v8 + 8) = v7;
  ++*(_DWORD *)(v8 + 16);
  if (*(_DWORD *)(a2 + 40))
  {
    unsigned int v10 = 0;
    do
    {
      BOOL v11 = PPStreamChunkCreate(4);
      v11[16] = 3;
      *((_DWORD *)v11 + 6) = v10;
      uint64_t v12 = *(void *)(a1 + 40);
      if (!*(void *)v12)
      {
        *(void *)uint64_t v12 = v11;
        *(void *)BOOL v11 = 0;
      }
      uint64_t v13 = *(void *)(v12 + 8);
      if (v13)
      {
        *(void *)(v13 + 8) = v11;
        *(void *)BOOL v11 = v13;
      }
      *((void *)v11 + 1) = 0;
      *(void *)(v12 + 8) = v11;
      ++*(_DWORD *)(v12 + 16);
      ++v10;
    }
    while (v10 < *(_DWORD *)(a2 + 40));
  }
  if (*(_DWORD *)(a2 + 32))
  {
    uint64_t v14 = 0;
    uint64_t v15 = a2 + 8 * *(unsigned int *)(a2 + 36);
    do
    {
      uint64_t v16 = PPStreamChunkCreate(16);
      v16[16] = 2;
      *((void *)v16 + 3) = *(void *)(v15 + 8 * v14);
      *((_DWORD *)v16 + 8) = v14;
      uint64_t v17 = *(void *)(a1 + 32);
      if (!*(void *)v17)
      {
        *(void *)uint64_t v17 = v16;
        *(void *)uint64_t v16 = 0;
      }
      uint64_t v18 = *(void *)(v17 + 8);
      if (v18)
      {
        *(void *)(v18 + 8) = v16;
        *(void *)uint64_t v16 = v18;
      }
      ++v14;
      *((void *)v16 + 1) = 0;
      *(void *)(v17 + 8) = v16;
      ++*(_DWORD *)(v17 + 16);
    }
    while (v14 < *(_DWORD *)(a2 + 32));
  }
  if (*(_DWORD *)(a2 + 48))
  {
    uint64_t v19 = 0;
    uint64_t v20 = a2 + 8 * *(unsigned int *)(a2 + 52);
    do
    {
      int v21 = PPStreamChunkCreate(16);
      v21[16] = 4;
      *((void *)v21 + 3) = *(void *)(v20 + 8 * v19);
      *((_DWORD *)v21 + 8) = v19;
      uint64_t v22 = *(void *)(a1 + 48);
      if (!*(void *)v22)
      {
        *(void *)uint64_t v22 = v21;
        *(void *)int v21 = 0;
      }
      uint64_t v23 = *(void *)(v22 + 8);
      if (v23)
      {
        *(void *)(v23 + 8) = v21;
        *(void *)int v21 = v23;
      }
      ++v19;
      *((void *)v21 + 1) = 0;
      *(void *)(v22 + 8) = v21;
      ++*(_DWORD *)(v22 + 16);
    }
    while (v19 < *(_DWORD *)(a2 + 48));
  }
  if (*(_DWORD *)(a2 + 56))
  {
    uint64_t v24 = 0;
    uint64_t v25 = a2 + 8 * *(unsigned int *)(a2 + 60);
    do
    {
      unsigned int v26 = PPStreamChunkCreate(16);
      v26[16] = 5;
      *((void *)v26 + 3) = *(void *)(v25 + 8 * v24);
      *((_DWORD *)v26 + 8) = v24;
      uint64_t v27 = *(void *)(a1 + 56);
      if (!*(void *)v27)
      {
        *(void *)uint64_t v27 = v26;
        *(void *)unsigned int v26 = 0;
      }
      uint64_t v28 = *(void *)(v27 + 8);
      if (v28)
      {
        *(void *)(v28 + 8) = v26;
        *(void *)unsigned int v26 = v28;
      }
      ++v24;
      *((void *)v26 + 1) = 0;
      *(void *)(v27 + 8) = v26;
      ++*(_DWORD *)(v27 + 16);
    }
    while (v24 < *(_DWORD *)(a2 + 56));
  }
  if (*(_DWORD *)(a2 + 64))
  {
    uint64_t v29 = 0;
    uint64_t v30 = a2 + 8 * *(unsigned int *)(a2 + 68);
    do
    {
      uint64_t v31 = PPStreamChunkCreate(16);
      v31[16] = 6;
      *((void *)v31 + 3) = *(void *)(v30 + 8 * v29);
      *((_DWORD *)v31 + 8) = v29;
      uint64_t v32 = *(void *)(a1 + 64);
      if (!*(void *)v32)
      {
        *(void *)uint64_t v32 = v31;
        *(void *)uint64_t v31 = 0;
      }
      uint64_t v33 = *(void *)(v32 + 8);
      if (v33)
      {
        *(void *)(v33 + 8) = v31;
        *(void *)uint64_t v31 = v33;
      }
      ++v29;
      *((void *)v31 + 1) = 0;
      *(void *)(v32 + 8) = v31;
      ++*(_DWORD *)(v32 + 16);
    }
    while (v29 < *(_DWORD *)(a2 + 64));
  }
  if (*(_DWORD *)(a2 + 72))
  {
    uint64_t v34 = 0;
    uint64_t v35 = a2 + 8 * *(unsigned int *)(a2 + 76);
    do
    {
      uint64_t v36 = PPStreamChunkCreate(8);
      v36[16] = 7;
      *((void *)v36 + 3) = *(void *)(v35 + 8 * v34);
      uint64_t v37 = *(void *)(a1 + 72);
      if (!*(void *)v37)
      {
        *(void *)uint64_t v37 = v36;
        *(void *)uint64_t v36 = 0;
      }
      uint64_t v38 = *(void *)(v37 + 8);
      if (v38)
      {
        *(void *)(v38 + 8) = v36;
        *(void *)uint64_t v36 = v38;
      }
      ++v34;
      *((void *)v36 + 1) = 0;
      *(void *)(v37 + 8) = v36;
      ++*(_DWORD *)(v37 + 16);
    }
    while (v34 < *(_DWORD *)(a2 + 72));
  }
  if (*(_DWORD *)(a2 + 80))
  {
    uint64_t v39 = 0;
    uint64_t v40 = a2 + 8 * *(unsigned int *)(a2 + 84);
    do
    {
      long long v41 = PPStreamChunkCreate(8);
      v41[16] = 8;
      *((void *)v41 + 3) = *(void *)(v40 + 8 * v39);
      uint64_t v42 = *(void *)(a1 + 80);
      if (!*(void *)v42)
      {
        *(void *)uint64_t v42 = v41;
        *(void *)long long v41 = 0;
      }
      uint64_t v43 = *(void *)(v42 + 8);
      if (v43)
      {
        *(void *)(v43 + 8) = v41;
        *(void *)long long v41 = v43;
      }
      ++v39;
      *((void *)v41 + 1) = 0;
      *(void *)(v42 + 8) = v41;
      ++*(_DWORD *)(v42 + 16);
    }
    while (v39 < *(_DWORD *)(a2 + 80));
  }
  if (*(_DWORD *)(a2 + 88))
  {
    unsigned int v44 = 0;
    uint64_t v45 = (void *)(a2 + 8 * *(unsigned int *)(a2 + 92));
    do
    {
      unint64_t v46 = PPStreamChunkCreate(16);
      v46[16] = 9;
      *((void *)v46 + 3) = *v45;
      *((void *)v46 + 4) = v45[1];
      uint64_t v47 = *(void *)(a1 + 88);
      if (!*(void *)v47)
      {
        *(void *)uint64_t v47 = v46;
        *(void *)unint64_t v46 = 0;
      }
      uint64_t v48 = *(void *)(v47 + 8);
      if (v48)
      {
        *(void *)(v48 + 8) = v46;
        *(void *)unint64_t v46 = v48;
      }
      *((void *)v46 + 1) = 0;
      *(void *)(v47 + 8) = v46;
      ++*(_DWORD *)(v47 + 16);
      ++v44;
      v45 += 2;
    }
    while (v44 < *(_DWORD *)(a2 + 88));
  }
  if (*(_DWORD *)(a2 + 96))
  {
    uint64_t v49 = 0;
    uint64_t v50 = a2 + 8 * *(unsigned int *)(a2 + 100);
    do
    {
      unint64_t v51 = PPStreamChunkCreate(8);
      v51[16] = 10;
      *((void *)v51 + 3) = *(void *)(v50 + 8 * v49);
      uint64_t v52 = *(void *)(a1 + 96);
      if (!*(void *)v52)
      {
        *(void *)uint64_t v52 = v51;
        *(void *)unint64_t v51 = 0;
      }
      uint64_t v53 = *(void *)(v52 + 8);
      if (v53)
      {
        *(void *)(v53 + 8) = v51;
        *(void *)unint64_t v51 = v53;
      }
      ++v49;
      *((void *)v51 + 1) = 0;
      *(void *)(v52 + 8) = v51;
      ++*(_DWORD *)(v52 + 16);
    }
    while (v49 < *(_DWORD *)(a2 + 96));
  }
  if (*(_DWORD *)(a2 + 104))
  {
    unsigned int v54 = 0;
    uint64_t v55 = (uint64_t *)(a2 + 8 * *(unsigned int *)(a2 + 108));
    do
    {
      uint64_t v56 = (char *)PPStreamChunkCreate(80);
      v56[16] = 11;
      *((_DWORD *)v56 + 24) = 0;
      uint64_t v57 = *v55;
      *((void *)v56 + 3) = *v55;
      *((_DWORD *)v56 + 22) = v54;
      *((void *)v56 + 4) = v55[1];
      v55 += 2;
      uint64_t v58 = v57 & 7;
      if (v58)
      {
        uint64_t v59 = v56 + 40;
        do
        {
          uint64_t v60 = *v55++;
          *v59++ = v60;
          --v58;
        }
        while (v58);
      }
      uint64_t v61 = *(void *)(a1 + 104);
      if (!*(void *)v61)
      {
        *(void *)uint64_t v61 = v56;
        *(void *)uint64_t v56 = 0;
      }
      uint64_t v62 = *(void *)(v61 + 8);
      if (v62)
      {
        *(void *)(v62 + 8) = v56;
        *(void *)uint64_t v56 = v62;
      }
      *((void *)v56 + 1) = 0;
      *(void *)(v61 + 8) = v56;
      ++*(_DWORD *)(v61 + 16);
      ++v54;
    }
    while (v54 < *(_DWORD *)(a2 + 104));
  }
  else
  {
    unsigned int v54 = 0;
  }
  *(_DWORD *)(a1 + 140) = v54;
  *(void *)(a1 + 8) = *(void *)(a2 + 120);
  if (*(_DWORD *)(a2 + 128))
  {
    uint64_t v63 = 0;
    uint64_t v64 = a2 + 8 * *(unsigned int *)(a2 + 132);
    do
    {
      uint64_t v65 = PPStreamChunkCreate(8);
      v65[16] = 12;
      *((void *)v65 + 3) = *(void *)(v64 + 8 * v63);
      uint64_t v66 = *(void *)(a1 + 120);
      if (!*(void *)v66)
      {
        *(void *)uint64_t v66 = v65;
        *(void *)uint64_t v65 = 0;
      }
      uint64_t v67 = *(void *)(v66 + 8);
      if (v67)
      {
        *(void *)(v67 + 8) = v65;
        *(void *)uint64_t v65 = v67;
      }
      ++v63;
      *((void *)v65 + 1) = 0;
      *(void *)(v66 + 8) = v65;
      ++*(_DWORD *)(v66 + 16);
    }
    while (v63 < *(_DWORD *)(a2 + 128));
  }
  if (*(_DWORD *)(a2 + 136))
  {
    unsigned int v68 = 0;
    uint64_t v69 = (_DWORD *)(a2 + 8 * *(unsigned int *)(a2 + 140));
    do
    {
      uint64_t v70 = PPStreamChunkCreate(16);
      v70[16] = 13;
      *((_DWORD *)v70 + 6) = *v69;
      *((_DWORD *)v70 + 7) = v69[1];
      *((_DWORD *)v70 + 8) = v69[2];
      *((_DWORD *)v70 + 9) = v69[3];
      uint64_t v71 = *(void *)(a1 + 128);
      if (!*(void *)v71)
      {
        *(void *)uint64_t v71 = v70;
        *(void *)uint64_t v70 = 0;
      }
      uint64_t v72 = *(void *)(v71 + 8);
      if (v72)
      {
        *(void *)(v72 + 8) = v70;
        *(void *)uint64_t v70 = v72;
      }
      *((void *)v70 + 1) = 0;
      *(void *)(v71 + 8) = v70;
      ++*(_DWORD *)(v71 + 16);
      ++v68;
      v69 += 4;
    }
    while (v68 < *(_DWORD *)(a2 + 136));
  }
  return 0;
}

BOOL PPStreamCompare(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 != *(void *)a2
      || PPStreamChunkListCompare(*(void *)(a1 + 16), *(void *)(a2 + 16))
      || PPStreamChunkListCompare(*(void *)(a1 + 24), *(void *)(a2 + 24))
      || PPStreamChunkListCompare(*(void *)(a1 + 32), *(void *)(a2 + 32))
      || PPStreamChunkListCompare(*(void *)(a1 + 40), *(void *)(a2 + 40))
      || PPStreamChunkListCompare(*(void *)(a1 + 56), *(void *)(a2 + 56))
      || PPStreamChunkListCompare(*(void *)(a1 + 72), *(void *)(a2 + 72))
      || PPStreamChunkListCompare(*(void *)(a1 + 80), *(void *)(a2 + 80))
      || PPStreamChunkListCompare(*(void *)(a1 + 48), *(void *)(a2 + 48))
      || PPStreamChunkListCompare(*(void *)(a1 + 64), *(void *)(a2 + 64))
      || PPStreamChunkListCompare(*(void *)(a1 + 88), *(void *)(a2 + 88))
      || PPStreamChunkListCompare(*(void *)(a1 + 104), *(void *)(a2 + 104))
      || PPStreamChunkListCompare(*(void *)(a1 + 128), *(void *)(a2 + 128))
      || PPStreamChunkListCompare(*(void *)(a1 + 120), *(void *)(a2 + 120))
      || PPStreamChunkListCompare(*(void *)(a1 + 96), *(void *)(a2 + 96))
      || *(_DWORD *)(a1 + 136) != *(_DWORD *)(a2 + 136);
}

uint64_t PPStreamChangeBranchTargets(uint64_t a1, int a2, uint64_t a3)
{
  for (uint64_t i = **(void **)(a1 + 112); i; uint64_t i = *(void *)(i + 8))
  {
    if (*(_DWORD *)(i + 24) == a2) {
      *(_DWORD *)(i + 24) = a3;
    }
  }
  return renumberTargets(**(void **)(a1 + 104), a2, a3);
}

uint64_t renumberTargets(uint64_t result, int a2, uint64_t a3)
{
  while (result)
  {
    unint64_t v3 = *(void *)(result + 24);
    int v4 = (v3 >> 6);
    uint64_t v5 = (v4 - 75);
    if (v5 <= 0x21)
    {
      if (((1 << (v4 - 75)) & 0x38001BE05) != 0) {
        goto LABEL_4;
      }
      if (v5 == 1)
      {
        if ((*(void *)(result + 24) & 7) == 1 || v3 >> 46 != a2) {
          goto LABEL_6;
        }
LABEL_5:
        *(void *)(result + 24) = v3 & 0x3FFFFFFFFFFFLL | (a3 << 46);
        goto LABEL_6;
      }
    }
    if (v4 != 140) {
      goto LABEL_6;
    }
LABEL_4:
    if (v3 >> 46 == a2) {
      goto LABEL_5;
    }
LABEL_6:
    uint64_t result = *(void *)(result + 8);
  }
  return result;
}

void PPStreamPackIndices(void *a1)
{
  uint64_t v2 = *(unsigned int *)(a1[4] + 16);
  unint64_t v3 = (char *)malloc_type_malloc(4 * v2, 0x7081ABB9uLL);
  if (!v3) {
    goto LABEL_78;
  }
  int v4 = v3;
  uint64_t v5 = *(void *)a1[4];
  if (v5)
  {
    int v6 = 0;
    do
    {
      int v7 = *(_DWORD *)(v5 + 32);
      int v8 = v7 + 1;
      if (v2 < v7 + 1)
      {
        uint64_t v9 = (char *)malloc_type_realloc(v4, 4 * (v7 + 1), 0x2BDC8648uLL);
        if (!v9) {
          goto LABEL_78;
        }
        int v4 = v9;
        int v7 = *(_DWORD *)(v5 + 32);
        LODWORD(v2) = v8;
      }
      *(_DWORD *)&v4[4 * v7] = v6;
      *(_DWORD *)(v5 + 32) = v6++;
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5);
  }
  uint64_t v10 = *(unsigned int *)(a1[5] + 16);
  BOOL v11 = (char *)malloc_type_malloc(4 * v10, 0x7081ABB9uLL);
  if (!v11) {
    goto LABEL_78;
  }
  uint64_t v12 = v11;
  uint64_t v13 = *(void *)a1[5];
  if (v13)
  {
    int v14 = 0;
    do
    {
      int v15 = *(_DWORD *)(v13 + 24);
      int v16 = v15 + 1;
      if (v10 < v15 + 1)
      {
        uint64_t v17 = (char *)malloc_type_realloc(v12, 4 * (v15 + 1), 0x2BDC8648uLL);
        if (!v17) {
          goto LABEL_78;
        }
        uint64_t v12 = v17;
        int v15 = *(_DWORD *)(v13 + 24);
        LODWORD(v10) = v16;
      }
      *(_DWORD *)&v12[4 * v15] = v14;
      *(_DWORD *)(v13 + 24) = v14++;
      uint64_t v13 = *(void *)(v13 + 8);
    }
    while (v13);
  }
  uint64_t v18 = *(unsigned int *)(a1[7] + 16);
  uint64_t v19 = (char *)malloc_type_malloc(4 * v18, 0x7081ABB9uLL);
  if (!v19) {
    goto LABEL_78;
  }
  uint64_t v20 = v19;
  uint64_t v21 = *(void *)a1[7];
  if (v21)
  {
    int v22 = 0;
    do
    {
      int v23 = *(_DWORD *)(v21 + 32);
      int v24 = v23 + 1;
      if (v18 < v23 + 1)
      {
        uint64_t v25 = (char *)malloc_type_realloc(v20, 4 * (v23 + 1), 0x2BDC8648uLL);
        if (!v25) {
          goto LABEL_78;
        }
        uint64_t v20 = v25;
        int v23 = *(_DWORD *)(v21 + 32);
        LODWORD(v18) = v24;
      }
      *(_DWORD *)&v20[4 * v23] = v22;
      *(_DWORD *)(v21 + 32) = v22++;
      uint64_t v21 = *(void *)(v21 + 8);
    }
    while (v21);
  }
  uint64_t v26 = *(unsigned int *)(a1[6] + 16);
  uint64_t v27 = (char *)malloc_type_malloc(4 * v26, 0x7081ABB9uLL);
  if (!v27) {
    goto LABEL_78;
  }
  uint64_t v28 = v27;
  uint64_t v29 = *(void *)a1[6];
  if (v29)
  {
    int v30 = 0;
    do
    {
      int v31 = *(_DWORD *)(v29 + 32);
      int v32 = v31 + 1;
      if (v26 < v31 + 1)
      {
        uint64_t v33 = (char *)malloc_type_realloc(v28, 4 * (v31 + 1), 0x2BDC8648uLL);
        if (!v33) {
          goto LABEL_78;
        }
        uint64_t v28 = v33;
        int v31 = *(_DWORD *)(v29 + 32);
        LODWORD(v26) = v32;
      }
      *(_DWORD *)&v28[4 * v31] = v30;
      *(_DWORD *)(v29 + 32) = v30++;
      uint64_t v29 = *(void *)(v29 + 8);
    }
    while (v29);
  }
  uint64_t v34 = *(unsigned int *)(a1[8] + 16);
  uint64_t v35 = (char *)malloc_type_malloc(4 * v34, 0x7081ABB9uLL);
  if (!v35) {
    goto LABEL_78;
  }
  uint64_t v36 = v35;
  uint64_t v37 = *(void *)a1[8];
  if (v37)
  {
    int v38 = 0;
    do
    {
      int v39 = *(_DWORD *)(v37 + 32);
      int v40 = v39 + 1;
      if (v34 < v39 + 1)
      {
        long long v41 = (char *)malloc_type_realloc(v36, 4 * (v39 + 1), 0x2BDC8648uLL);
        if (!v41) {
          goto LABEL_78;
        }
        uint64_t v36 = v41;
        int v39 = *(_DWORD *)(v37 + 32);
        LODWORD(v34) = v40;
      }
      *(_DWORD *)&v36[4 * v39] = v38;
      *(_DWORD *)(v37 + 32) = v38++;
      uint64_t v37 = *(void *)(v37 + 8);
    }
    while (v37);
  }
  uint64_t v42 = a1;
  uint64_t v43 = *(unsigned int *)(a1[13] + 16);
  unsigned int v44 = (char *)malloc_type_malloc(4 * v43, 0x7081ABB9uLL);
  if (!v44) {
LABEL_78:
  }
    abort();
  uint64_t v45 = v44;
  unsigned int v68 = (void **)v42;
  uint64_t v46 = *(void *)v42[13];
  if (v46)
  {
    int v47 = 0;
    do
    {
      int v48 = *(_DWORD *)(v46 + 88);
      int v49 = v48 + 1;
      if (v43 < v48 + 1)
      {
        uint64_t v50 = (char *)malloc_type_realloc(v45, 4 * (v48 + 1), 0x2BDC8648uLL);
        if (!v50) {
          goto LABEL_78;
        }
        uint64_t v45 = v50;
        int v48 = *(_DWORD *)(v46 + 88);
        LODWORD(v43) = v49;
      }
      *(_DWORD *)&v45[4 * v48] = v47;
      *(_DWORD *)(v46 + 88) = v47++;
      uint64_t v46 = *(void *)(v46 + 8);
    }
    while (v46);
  }
  for (uint64_t i = *v68[14]; i; uint64_t i = *(void *)(i + 8))
    *(_DWORD *)(i + 24) = *(_DWORD *)&v45[4 * *(unsigned int *)(i + 24)];
  for (uint64_t j = *v68[10]; j; uint64_t j = *(void *)(j + 8))
  {
    unint64_t v53 = *(void *)(j + 24);
    unint64_t v54 = v53 & 0xFFFFFFFF0000FFFFLL | (*(_DWORD *)&v4[4 * WORD1(v53)] << 16);
    *(void *)(j + 24) = v54;
    *(void *)(j + 24) = v54 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*(_DWORD *)&v4[(v53 >> 46) & 0x3FFFC] << 48);
  }
  for (uint64_t k = *v68[9]; k; uint64_t k = *(void *)(k + 8))
  {
    unint64_t v56 = *(void *)(k + 24);
    unint64_t v57 = v56 & 0xFFFFFFFF0000FFFFLL | (*(_DWORD *)&v20[4 * WORD1(v56)] << 16);
    *(void *)(k + 24) = v57;
    *(void *)(k + 24) = v57 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*(_DWORD *)&v20[(v56 >> 46) & 0x3FFFC] << 48);
  }
  uint64_t v58 = (void *)*v68[13];
  if (v58)
  {
    while (1)
    {
      unint64_t v59 = v58[3];
      if ((v59 & 7) + ((__int16)v59 >> 15))
      {
        unint64_t v60 = 0;
        uint64_t v61 = v58 + 5;
        do
        {
          unint64_t v62 = v61[v60];
          uint64_t v63 = v36;
          switch((v62 >> 6) & 7)
          {
            case 1u:
              uint64_t v63 = v4;
              break;
            case 2u:
              uint64_t v63 = v20;
              break;
            case 3u:
            case 5u:
              break;
            case 4u:
              uint64_t v63 = v12;
              break;
            default:
              uint64_t v63 = v28;
              break;
          }
          v61[v60++] = v62 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*(_DWORD *)&v63[(v62 >> 46) & 0x3FFFC] << 48);
        }
        while (v60 < ((__int16)v59 >> 15) + (v59 & 7));
      }
      if ((v59 & 0x100000000) != 0)
      {
        unint64_t v64 = v58[4];
        uint64_t v65 = v36;
        switch((v64 >> 12) & 7)
        {
          case 1u:
            uint64_t v65 = v4;
            break;
          case 2u:
            uint64_t v65 = v20;
            break;
          case 3u:
          case 5u:
            break;
          case 4u:
            uint64_t v65 = v12;
            break;
          default:
            uint64_t v65 = v28;
            break;
        }
        v58[4] = v64 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*(_DWORD *)&v65[(v64 >> 46) & 0x3FFFC] << 48);
      }
      int v66 = (v59 >> 6);
      uint64_t v67 = (v66 - 75);
      if (v67 > 0x21) {
        goto LABEL_73;
      }
      if (((1 << (v66 - 75)) & 0x38001BE05) == 0) {
        break;
      }
LABEL_67:
      v58[3] = v59 & 0x3FFFFFFFFFFFLL | ((unint64_t)*(unsigned int *)&v45[(v59 >> 44) & 0xFFFFC] << 46);
LABEL_68:
      uint64_t v58 = (void *)v58[1];
      if (!v58) {
        goto LABEL_75;
      }
    }
    if (v67 == 1)
    {
      if ((v59 & 7) == 1) {
        goto LABEL_68;
      }
      goto LABEL_67;
    }
LABEL_73:
    if (v66 != 140) {
      goto LABEL_68;
    }
    goto LABEL_67;
  }
LABEL_75:
  free(v4);
  free(v12);
  free(v20);
  free(v28);
  free(v36);

  free(v45);
}

uint64_t PPStreamResolveBranches(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 104);
  uint64_t v2 = *(uint64_t **)(a1 + 112);
  uint64_t v3 = *v1;
  if (*v1)
  {
    uint64_t v4 = 0;
    do
    {
      size_t v5 = *(unsigned int *)(v3 + 96);
      if (v5)
      {
        uint64_t v6 = *(void *)(v3 + 24);
        *(void *)(v3 + 24) = v6 & 0x3FFFFFFFFFFFLL | ((unint64_t)(*((_DWORD *)v1 + 4) + 1) << 46);
        uint64_t v7 = *v2;
        if (*v2)
        {
          uint64_t v8 = v6 & 0x3FFFFFFFFFFFLL;
          while (v5 != *(_DWORD *)(v7 + 28) || strncmp((const char *)(v3 + 104), (const char *)(v7 + 32), v5))
          {
            uint64_t v7 = *(void *)(v7 + 8);
            if (!v7) {
              goto LABEL_9;
            }
          }
          *(void *)(v3 + 24) = v8 | ((unint64_t)*(unsigned int *)(v7 + 24) << 46);
        }
        else
        {
LABEL_9:
          uint64_t v4 = 1;
        }
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3);
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v9 = *v2;
  if (*v2)
  {
    while (strcmp("main(", (const char *)(v9 + 32)))
    {
      uint64_t v9 = *(void *)(v9 + 8);
      if (!v9) {
        return v4;
      }
    }
    uint64_t v10 = *v1;
    if (*v1)
    {
      while (*(_DWORD *)(v9 + 24) != *(_DWORD *)(v10 + 88))
      {
        uint64_t v10 = *(void *)(v10 + 8);
        if (!v10) {
          return v4;
        }
      }
      *(void *)(v10 + 24) |= 0x4000uLL;
    }
  }
  return v4;
}

uint64_t PPStreamRemoveOperation(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[1];
  if (v4)
  {
    unint64_t v5 = *(void *)(v4 + 24) & 0xFFFFFFFFFFFFFFC7 | (8 * ((a2[3] >> 3) & 7));
    *(void *)(v4 + 24) = v5;
    if ((*((unsigned char *)a2 + 25) & 0x40) != 0) {
      *(void *)(v4 + 24) = v5 | 0x4000;
    }
    int v6 = *((_DWORD *)a2 + 22);
    uint64_t v7 = *(unsigned int *)(v4 + 88);
    for (uint64_t i = **(void **)(a1 + 112); i; uint64_t i = *(void *)(i + 8))
    {
      if (*(_DWORD *)(i + 24) == v6) {
        *(_DWORD *)(i + 24) = v7;
      }
    }
    renumberTargets(**(void **)(a1 + 104), v6, v7);
  }
  PPStreamChunkListRemoveChunk(*(void *)(a1 + 104), a2);
  return v4;
}

uint64_t glpDisassemble1Op(int a1, uint64_t a2, FILE *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9, int *a10, int a11)
{
  unint64_t v37 = *(void *)a2;
  unsigned int v17 = (*(void *)a2 >> 6);
  if (*a10 >= 1)
  {
    unsigned int v18 = 0;
    do
    {
      fprintf_l(a3, 0, "  ");
      if (v18 > 0x30) {
        break;
      }
      ++v18;
    }
    while ((int)v18 < *a10);
  }
  fprintf_l(a3, 0, "%s", (&ppstreamOpString)[v17]);
  unint64_t v19 = *(void *)a2;
  if ((*(void *)a2 & 0x40000) != 0)
  {
    fprintf_l(a3, 0, " OFFSET");
    unint64_t v19 = *(void *)a2;
  }
  if ((v19 & 0x200000000) != 0) {
    fprintf_l(a3, 0, " INVARIANT");
  }
  int v35 = v37 & 7;
  if (v17 <= 0xAA)
  {
    switch((v37 >> 6))
    {
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x4Eu:
      case 0x52u:
      case 0x6Eu:
      case 0x76u:
      case 0x7Au:
      case 0x7Du:
      case 0x7Eu:
      case 0x7Fu:
      case 0x80u:
      case 0x81u:
      case 0x85u:
      case 0x9Cu:
      case 0x9Fu:
      case 0xA8u:
      case 0xA9u:
        unint64_t v24 = *(void *)a2;
        uint64_t v25 = ((*(void *)a2 >> 19) & 7) - 1;
        if (v25 <= 2)
        {
          fprintf_l(a3, 0, (&off_264D9D230)[v25]);
          unint64_t v24 = *(void *)a2;
        }
        glpWriteClampSat(a3, (v24 >> 41) & 1, (v24 >> 42) & 1, (v24 >> 43) & 1);
        int v22 = a4;
        if (a11) {
          glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        }
        fprintf_l(a3, 0, " ");
        glpWriteDestinationOperand((FILE *)a2, a3, a7, a8, a11);
        fprintf_l(a3, 0, ", ");
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 0);
        fprintf_l(a3, 0, ", ");
        goto LABEL_22;
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x53u:
      case 0x68u:
      case 0x69u:
      case 0x98u:
      case 0x99u:
        unint64_t v28 = *(void *)a2;
        uint64_t v29 = ((*(void *)a2 >> 19) & 7) - 1;
        if (v29 <= 2)
        {
          fprintf_l(a3, 0, (&off_264D9D230)[v29]);
          unint64_t v28 = *(void *)a2;
        }
        glpWriteClampSat(a3, (v28 >> 41) & 1, (v28 >> 42) & 1, (v28 >> 43) & 1);
        int v22 = a4;
        if (a11) {
          glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        }
        fprintf_l(a3, 0, " ");
        if (v17 != 153)
        {
          glpWriteDestinationOperand((FILE *)a2, a3, a7, a8, a11);
          fprintf_l(a3, 0, ", ");
        }
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 0);
        fprintf_l(a3, 0, ", ");
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 3, a11, 0);
        fprintf_l(a3, 0, ", ");
        int v23 = 4;
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 4, a11, 0);
        goto LABEL_68;
      case 0x41u:
        glpWriteClampSat(a3, (*(void *)a2 >> 41) & 1, (*(void *)a2 >> 42) & 1, (*(void *)a2 >> 43) & 1);
        if (a11) {
          glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        }
        fprintf_l(a3, 0, " ");
        glpWriteDestinationOperand((FILE *)a2, a3, a7, a8, a11);
        fprintf_l(a3, 0, ", ");
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 1);
        int v23 = 3;
        goto LABEL_67;
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x62u:
      case 0x63u:
      case 0x82u:
      case 0x83u:
      case 0xA4u:
      case 0xA5u:
      case 0xA6u:
        glpWriteClampSat(a3, (*(void *)a2 >> 41) & 1, (*(void *)a2 >> 42) & 1, (*(void *)a2 >> 43) & 1);
        if (a11) {
          glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        }
        fprintf_l(a3, 0, " ");
        glpWriteDestinationOperand((FILE *)a2, a3, a7, a8, a11);
        int v26 = ((int)(v37 << 14) >> 31) + v35;
        if (v26 < 2)
        {
          int v26 = 1;
        }
        else
        {
          for (int i = 1; i != v26; glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, i, a11, 0))
          {
            fprintf_l(a3, 0, ", ");
            ++i;
          }
        }
        fprintf_l(a3, 0, ", ");
        unsigned int v30 = v26 + 1;
        fprintf_l(a3, 0, "texture[");
        if (a11)
        {
          glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, v26 + 1, 1, 0);
          uint64_t v31 = (v26 + 2);
        }
        else
        {
          fprintf_l(a3, 0, "%d", *(_DWORD *)(a2 + 8 * v30 + 4) & 0x7F);
          uint64_t v31 = (v26 + 1);
        }
        fprintf_l(a3, 0, "], ");
        uint64_t v32 = *(void *)(a2 + 8 * v31);
        if ((v32 & 0x1Eu) <= 0x11uLL) {
          fprintf_l(a3, 0, (&off_264D9D248)[v32 & 0x1F]);
        }
        if (a11) {
          int v23 = v30 + 1;
        }
        else {
          int v23 = v30;
        }
        goto LABEL_67;
      case 0x48u:
      case 0x49u:
      case 0x4Au:
        if (a11) {
          glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        }
        fprintf_l(a3, 0, " ");
        glpWriteAddressOperand(a2, a3, a11);
        fprintf_l(a3, 0, ", ");
        goto LABEL_55;
      case 0x4Bu:
        goto LABEL_65;
      case 0x4Cu:
        if (v35 == 1) {
          goto LABEL_54;
        }
LABEL_65:
        fprintf_l(a3, 0, " ");
        glpWriteBranchOperand((void *)a2, a3, a9);
        goto LABEL_66;
      case 0x4Du:
      case 0x54u:
        fprintf_l(a3, 0, (&off_264D9D330)[(*(void *)(a2 + 8) >> 1) & 7]);
        if (*(unsigned char *)(a2 + 8)) {
          fprintf_l(a3, 0, "1");
        }
        fprintf_l(a3, 0, ".");
        fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 4) + 1) & 3u) + 119);
        fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 6) + 1) & 3u) + 119);
        fprintf_l(a3, 0, "%c", ((BYTE1(*(_DWORD *)(a2 + 8)) + 1) & 3u) + 119);
        fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 10) + 1) & 3u) + 119);
        fprintf_l(a3, 0, ")");
        goto LABEL_66;
      case 0x4Fu:
        if (a11 && (v37 & 7) == 0)
        {
          int v23 = 1;
          goto LABEL_82;
        }
        if ((v37 & 7) == 0)
        {
          fprintf_l(a3, 0, (&off_264D9D1F0)[(*(void *)(a2 + 8) >> 1) & 7]);
          if (*(unsigned char *)(a2 + 8)) {
            fprintf_l(a3, 0, "1");
          }
          fprintf_l(a3, 0, ".");
          fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 4) + 1) & 3u) + 119);
          fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 6) + 1) & 3u) + 119);
          fprintf_l(a3, 0, "%c", ((BYTE1(*(_DWORD *)(a2 + 8)) + 1) & 3u) + 119);
          fprintf_l(a3, 0, "%c");
LABEL_66:
          int v23 = 1;
          goto LABEL_67;
        }
LABEL_58:
        fprintf_l(a3, 0, " ");
        int v23 = 2;
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 0);
        int v22 = a4;
        if (v35 == 2)
        {
LABEL_16:
          fprintf_l(a3, 0, ", ");
LABEL_22:
          int v23 = 3;
          glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 3, a11, 0);
        }
        goto LABEL_68;
      case 0x55u:
      case 0x8Cu:
        ++*a10;
        if (!a11)
        {
          fprintf_l(a3, 0, (&off_264D9D1F0)[(*(void *)(a2 + 8) >> 1) & 7]);
          int v22 = a4;
          if (*(unsigned char *)(a2 + 8)) {
            fprintf_l(a3, 0, "1");
          }
          fprintf_l(a3, 0, ".");
          fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 4) + 1) & 3u) + 119);
          fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 6) + 1) & 3u) + 119);
          fprintf_l(a3, 0, "%c", ((BYTE1(*(_DWORD *)(a2 + 8)) + 1) & 3u) + 119);
          fprintf_l(a3, 0, "%c", (((*(_DWORD *)(a2 + 8) >> 10) + 1) & 3u) + 119);
          fprintf_l(a3, 0, ";");
          int v23 = 1;
          goto LABEL_78;
        }
        glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        fprintf_l(a3, 0, " ");
        int v23 = 2;
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 0);
LABEL_82:
        int v22 = a4;
        fprintf_l(a3, 0, ";");
        break;
      case 0x56u:
      case 0x57u:
        ++*a10;
        goto LABEL_54;
      case 0x58u:
      case 0x6Bu:
        ++*a10;
        goto LABEL_66;
      case 0x59u:
      case 0x5Au:
      case 0x5Bu:
      case 0x6Au:
      case 0x6Cu:
      case 0x6Fu:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x87u:
      case 0x88u:
      case 0x8Eu:
      case 0x8Fu:
      case 0xAAu:
        goto LABEL_66;
      case 0x60u:
      case 0x61u:
LABEL_54:
        fprintf_l(a3, 0, " ");
LABEL_55:
        int v23 = 2;
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 0);
        goto LABEL_67;
      case 0x77u:
      case 0x78u:
        if ((v37 & 7) != 0) {
          goto LABEL_58;
        }
        goto LABEL_66;
      case 0x79u:
      case 0x8Du:
        goto LABEL_58;
      default:
        unint64_t v20 = *(void *)a2;
        uint64_t v21 = ((*(void *)a2 >> 19) & 7) - 1;
        if (v21 <= 2)
        {
          fprintf_l(a3, 0, (&off_264D9D230)[v21]);
          unint64_t v20 = *(void *)a2;
        }
        glpWriteClampSat(a3, (v20 >> 41) & 1, (v20 >> 42) & 1, (v20 >> 43) & 1);
        int v22 = a4;
        if (a11) {
          glpWriteSizeType(a3, (*(void *)a2 >> 36) & 3, (*(void *)a2 >> 34) & 3, (*(void *)a2 >> 38) & 7);
        }
        fprintf_l(a3, 0, " ");
        glpWriteDestinationOperand((FILE *)a2, a3, a7, a8, a11);
        fprintf_l(a3, 0, ", ");
        int v23 = 2;
        glpWriteSourceOperand((FILE *)a2, a3, a5, a6, a7, a8, 2, a11, 0);
        if (v35 != 2) {
          goto LABEL_68;
        }
        goto LABEL_16;
    }
LABEL_69:
    uint64_t v33 = v17 - 75;
    if (v33 <= 0x3D)
    {
      if (((1 << (v17 - 75)) & 0x38001BE05) != 0) {
        goto LABEL_77;
      }
      if (((1 << (v17 - 75)) & 0x3000039000004000) != 0)
      {
        fprintf_l(a3, 0, "    # Index: %d");
        goto LABEL_78;
      }
      if (v33 == 1)
      {
        if (v35 == 1) {
          goto LABEL_78;
        }
        goto LABEL_77;
      }
    }
    if (v17 - 140 >= 4) {
      goto LABEL_78;
    }
LABEL_77:
    fprintf_l(a3, 0, "    # Target: %d Index: %d");
    goto LABEL_78;
  }
  int v23 = 0;
LABEL_67:
  int v22 = a4;
LABEL_68:
  fprintf_l(a3, 0, ";");
  if (a11) {
    goto LABEL_69;
  }
LABEL_78:
  uint64_t result = fprintf_l(a3, 0, "\n");
  *int v22 = v23;
  return result;
}

uint64_t glpWriteSizeType(FILE *a1, int a2, int a3, unsigned int a4)
{
  uint64_t result = fprintf_l(a1, 0, ":%d", a2 + 1);
  if (a3) {
    uint64_t result = fprintf_l(a1, 0, ":%d", a3 + 1);
  }
  if (a4 <= 4)
  {
    uint64_t v8 = (&off_264D9D5B8)[a4];
    return fprintf_l(a1, 0, v8);
  }
  return result;
}

FILE *glpWriteSourceOperand(FILE *result, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, int a9)
{
  int v14 = result;
  uint64_t v15 = a7;
  unint64_t v16 = *((void *)&result->_p + a7);
  if ((v16 & 0x10) != 0)
  {
    uint64_t result = (FILE *)fprintf_l(a2, 0, "-");
    unint64_t v16 = *((void *)&v14->_p + v15);
  }
  if ((v16 & 0x20) != 0)
  {
    uint64_t result = (FILE *)fprintf_l(a2, 0, "|");
    unint64_t v16 = *((void *)&v14->_p + v15);
  }
  switch((v16 >> 6) & 7)
  {
    case 0u:
      uint64_t result = (FILE *)fprintf_l(a2, 0, "att%d");
      break;
    case 1u:
      fprintf_l(a2, 0, "tmp");
      uint64_t v17 = HIWORD(*((void *)&v14->_p + v15));
      if (a5) {
        LODWORD(v17) = *(_DWORD *)(a5 + 4 * v17);
      }
      uint64_t result = (FILE *)fprintf_l(a2, 0, "%d", v17);
      if (a6)
      {
        unint64_t v20 = *((void *)&v14->_p + v15);
        if ((v20 & 1) == 0)
        {
          int v19 = *(_DWORD *)(a6 + ((v20 >> 46) & 0x3FFFC));
          goto LABEL_17;
        }
      }
      break;
    case 2u:
      uint64_t result = (FILE *)fprintf_l(a2, 0, "prm%d", *(_DWORD *)(a3 + ((v16 >> 46) & 0x3FFFC)));
      unint64_t v18 = *((void *)&v14->_p + v15);
      if ((v18 & 1) == 0)
      {
        int v19 = *(_DWORD *)(a4 + ((v18 >> 46) & 0x3FFFC));
LABEL_17:
        if (v19 != -1) {
          uint64_t result = (FILE *)fprintf_l(a2, 0, "[%d]");
        }
      }
      break;
    case 3u:
      uint64_t result = (FILE *)fprintf_l(a2, 0, "res%d");
      break;
    case 4u:
      uint64_t result = (FILE *)fprintf_l(a2, 0, "adr%d");
      break;
    case 5u:
      uint64_t result = (FILE *)fprintf_l(a2, 0, "shr%d");
      break;
    default:
      break;
  }
  uint64_t v21 = *((void *)&v14->_p + v15);
  if (v21)
  {
    fprintf_l(a2, 0, "[adr%d", (v21 >> 1) & 1);
    fprintf_l(a2, 0, (&off_264D9D370)[(*((void *)&v14->_p + v15) >> 2) & 3]);
    unint64_t v22 = *((void *)&v14->_p + v15);
    uint64_t v23 = v22 & 0x1C0;
    if (a6 && v23 == 64)
    {
      int v24 = *(_DWORD *)(a6 + ((v22 >> 46) & 0x3FFFC));
    }
    else
    {
      int v24 = 0;
      if (!a4 || v23 != 128)
      {
LABEL_28:
        int v25 = v24 + ((int)v22 >> 24);
        if (v25)
        {
          if (v25 >= 1) {
            fprintf_l(a2, 0, "+");
          }
          fprintf_l(a2, 0, "%d", v25);
        }
        uint64_t result = (FILE *)fprintf_l(a2, 0, "]");
        uint64_t v21 = *((void *)&v14->_p + v15);
        goto LABEL_33;
      }
      int v24 = *(_DWORD *)(a4 + ((v22 >> 46) & 0x3FFFC));
    }
    if (v24 == -1) {
      int v24 = 0;
    }
    goto LABEL_28;
  }
LABEL_33:
  if ((v21 & 0x1C0) == 0x100) {
    goto LABEL_59;
  }
  if (a9)
  {
    unsigned int v26 = 0;
    int v27 = 0;
    uint64_t v28 = v15 + 1;
    uint64_t v29 = 8 * (v15 + 1);
    do
    {
      switch(v27)
      {
        case 0:
          unsigned int v26 = *((_WORD *)&v14->_p + 4 * v28 + 1) & 0xF;
          uint64_t result = (FILE *)fprintf_l(a2, 0, ", ");
          break;
        case 1:
          unsigned int v26 = (*(_DWORD *)((char *)&v14->_p + v29) >> 20) & 0xF;
          goto LABEL_41;
        case 2:
          unsigned int v26 = *((unsigned char *)&v14->_p + 8 * v28 + 3) & 0xF;
          goto LABEL_41;
        case 3:
          unsigned int v26 = *(_DWORD *)((char *)&v14->_p + v29) >> 28;
LABEL_41:
          uint64_t result = (FILE *)fprintf_l(a2, 0, ",");
          break;
        default:
          break;
      }
      if (v26 <= 0xA) {
        uint64_t result = (FILE *)fprintf_l(a2, 0, (&off_264D9D2D8)[v26]);
      }
      ++v27;
    }
    while (v27 != 4);
LABEL_59:
    uint64_t v21 = *((void *)&v14->_p + v15);
    if (!a8) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  if (!a8)
  {
    if ((v21 & 0x1FE00) == 0x1C800) {
      goto LABEL_61;
    }
    fprintf_l(a2, 0, ".");
    unsigned int v31 = *((_DWORD *)&v14->_p + 2 * v15);
    unsigned int v30 = v31 >> 9;
    int v32 = (v31 >> 9) & 3;
    if (v32 != ((v31 >> 11) & 3) || v32 != ((v31 >> 13) & 3) || v32 != ((v31 >> 15) & 3))
    {
      fprintf_l(a2, 0, "%c", (((_BYTE)v30 + 1) & 3u) + 119);
      fprintf_l(a2, 0, "%c", (((*((_DWORD *)&v14->_p + 2 * v15) >> 11) + 1) & 3u) + 119);
      fprintf_l(a2, 0, "%c", (((*((_DWORD *)&v14->_p + 2 * v15) >> 13) + 1) & 3u) + 119);
      unsigned int v30 = *((_DWORD *)&v14->_p + 2 * v15) >> 15;
    }
    goto LABEL_58;
  }
  fprintf_l(a2, 0, ".");
  fprintf_l(a2, 0, "%c", (((*((_DWORD *)&v14->_p + 2 * v15) >> 9) + 1) & 3u) + 119);
  uint64_t v21 = *((void *)&v14->_p + v15);
  if ((v21 & 0x180000) != 0)
  {
    fprintf_l(a2, 0, "%c", (((v21 >> 11) + 1) & 3u) + 119);
    uint64_t v21 = *((void *)&v14->_p + v15);
  }
  if ((v21 & 0x100000) != 0)
  {
    fprintf_l(a2, 0, "%c", (((v21 >> 13) + 1) & 3u) + 119);
    uint64_t v21 = *((void *)&v14->_p + v15);
  }
  if ((~v21 & 0x180000) == 0)
  {
    unsigned int v30 = v21 >> 15;
LABEL_58:
    uint64_t result = (FILE *)fprintf_l(a2, 0, "%c", (((_BYTE)v30 + 1) & 3u) + 119);
    goto LABEL_59;
  }
LABEL_60:
  uint64_t result = glpWriteOperandSize(a2, (v21 >> 19) & 3, (v21 >> 17) & 3);
  uint64_t v21 = *((void *)&v14->_p + v15);
LABEL_61:
  if ((v21 & 0x20) != 0)
  {
    return (FILE *)fprintf_l(a2, 0, "|");
  }
  return result;
}

uint64_t glpWriteBranchOperand(void *a1, FILE *a2, int *a3)
{
  if (a3)
  {
    int v5 = -1;
    do
    {
      int v6 = *a3++;
      ++v5;
    }
    while (v6 != *a1 >> 46);
  }
  else
  {
    int v5 = -1;
  }
  fprintf_l(a2, 0, "label_%i", v5);
  fprintf_l(a2, 0, (&off_264D9D330)[(a1[1] >> 1) & 7]);
  if (a1[1]) {
    fprintf_l(a2, 0, "1");
  }
  fprintf_l(a2, 0, ".");
  fprintf_l(a2, 0, "%c", (((*((_DWORD *)a1 + 2) >> 4) + 1) & 3u) + 119);
  fprintf_l(a2, 0, "%c", (((*((_DWORD *)a1 + 2) >> 6) + 1) & 3u) + 119);
  fprintf_l(a2, 0, "%c", ((BYTE1(*((_DWORD *)a1 + 2)) + 1) & 3u) + 119);
  fprintf_l(a2, 0, "%c", (((*((_DWORD *)a1 + 2) >> 10) + 1) & 3u) + 119);

  return fprintf_l(a2, 0, ")");
}

FILE *glpWriteClampSat(FILE *result, int a2, int a3, int a4)
{
  int v5 = result;
  if (a2)
  {
    uint64_t result = (FILE *)fprintf_l(result, 0, "C");
    if (a3 >= 1) {
      uint64_t result = (FILE *)fprintf_l(v5, 0, "1");
    }
  }
  if (a4)
  {
    return (FILE *)fprintf_l(v5, 0, "_SAT");
  }
  return result;
}

FILE *glpWriteDestinationOperand(FILE *result, FILE *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = result;
  unint64_t v9 = *(void *)&result->_r;
  unsigned int v10 = (v9 >> 12) & 7;
  if (v10 == 5)
  {
    uint64_t result = (FILE *)fprintf_l(a2, 0, "shr%d");
  }
  else
  {
    if (v10 == 3)
    {
      unint64_t w_high = HIWORD(v9);
      uint64_t v13 = "res%d";
    }
    else
    {
      if (v10 != 1) {
        goto LABEL_13;
      }
      fprintf_l(a2, 0, "tmp");
      unint64_t w_high = HIWORD(v8->_w);
      uint64_t v13 = "%d";
      if (a3 && a5)
      {
        fprintf_l(a2, 0, "%d", *(_DWORD *)(a3 + 4 * w_high));
        unint64_t v14 = *(void *)&v8->_r;
        if (a4 && (v14 & 0x100000000) == 0 && *(_DWORD *)(a4 + ((v14 >> 46) & 0x3FFFC)) != -1)
        {
          fprintf_l(a2, 0, "[%d]", *(_DWORD *)(a4 + ((v14 >> 46) & 0x3FFFC)));
          unint64_t v14 = *(void *)&v8->_r;
        }
        goto LABEL_14;
      }
    }
    uint64_t result = (FILE *)fprintf_l(a2, 0, v13, w_high);
  }
LABEL_13:
  unint64_t v14 = *(void *)&v8->_r;
  if (!a5)
  {
    if ((~v8->_r & 0x78000) == 0) {
      goto LABEL_46;
    }
    uint64_t result = (FILE *)fprintf_l(a2, 0, ".");
    uint64_t v19 = *(void *)&v8->_r;
    if ((v19 & 0x40000) != 0)
    {
      uint64_t result = (FILE *)fprintf_l(a2, 0, "x");
      uint64_t v19 = *(void *)&v8->_r;
      if ((v19 & 0x20000) == 0)
      {
LABEL_33:
        if ((v19 & 0x10000) == 0) {
          goto LABEL_34;
        }
        goto LABEL_61;
      }
    }
    else if ((v19 & 0x20000) == 0)
    {
      goto LABEL_33;
    }
    uint64_t result = (FILE *)fprintf_l(a2, 0, "y");
    uint64_t v19 = *(void *)&v8->_r;
    if ((v19 & 0x10000) == 0)
    {
LABEL_34:
      if ((v19 & 0x8000) == 0) {
        goto LABEL_46;
      }
LABEL_62:
      uint64_t result = (FILE *)fprintf_l(a2, 0, "w");
      goto LABEL_46;
    }
LABEL_61:
    uint64_t result = (FILE *)fprintf_l(a2, 0, "z");
    if ((*(void *)&v8->_r & 0x8000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_62;
  }
LABEL_14:
  if ((v14 & 0x100000000) != 0)
  {
    fprintf_l(a2, 0, "[adr%d", (v14 >> 33) & 1);
    fprintf_l(a2, 0, (&off_264D9D370)[(*(void *)&v8->_r >> 34) & 3]);
    int v15 = 0;
    unint64_t v16 = *(void *)&v8->_r;
    if (a4)
    {
      if ((*(void *)&v8->_r & 0x7000) == 0x1000)
      {
        int v15 = *(_DWORD *)(a4 + ((v16 >> 46) & 0x3FFFC));
        if (v15 == -1) {
          int v15 = 0;
        }
      }
    }
    int v17 = v15 + ((int)(v16 >> 12) >> 24);
    if (v17)
    {
      if (v17 >= 1) {
        fprintf_l(a2, 0, "+");
      }
      fprintf_l(a2, 0, "%d", v17);
    }
    fprintf_l(a2, 0, "]");
  }
  fprintf_l(a2, 0, ".");
  if ((*(void *)&v8->_r & 0x40000) != 0) {
    fprintf_l(a2, 0, "%c");
  }
  else {
    fprintf_l(a2, 0, "_");
  }
  uint64_t v18 = *(void *)&v8->_r;
  if ((v18 & 0x600000) != 0)
  {
    if ((v18 & 0x20000) != 0) {
      fprintf_l(a2, 0, "%c");
    }
    else {
      fprintf_l(a2, 0, "_");
    }
  }
  uint64_t v20 = *(void *)&v8->_r;
  if ((v20 & 0x400000) != 0)
  {
    if ((v20 & 0x10000) != 0) {
      fprintf_l(a2, 0, "%c");
    }
    else {
      fprintf_l(a2, 0, "_");
    }
  }
  if ((~v8->_r & 0x600000) == 0)
  {
    if ((*(void *)&v8->_r & 0x8000) != 0) {
      fprintf_l(a2, 0, "%c");
    }
    else {
      fprintf_l(a2, 0, "_");
    }
  }
  uint64_t result = glpWriteOperandSize(a2, (v8->_r >> 21) & 3, (v8->_r >> 19) & 3);
LABEL_46:
  uint64_t v21 = " (EQ";
  switch((v8->_r >> 1) & 7)
  {
    case 1u:
      goto LABEL_53;
    case 2u:
      fprintf_l(a2, 0, " (GE");
      goto LABEL_54;
    case 3u:
      fprintf_l(a2, 0, " (GT");
      goto LABEL_54;
    case 4u:
      fprintf_l(a2, 0, " (LE");
      goto LABEL_54;
    case 5u:
      fprintf_l(a2, 0, " (LT");
      goto LABEL_54;
    case 6u:
      fprintf_l(a2, 0, " (NE");
      goto LABEL_54;
    case 7u:
      uint64_t v21 = " (FL";
LABEL_53:
      fprintf_l(a2, 0, v21);
LABEL_54:
      if (v8->_r) {
        fprintf_l(a2, 0, "1");
      }
      fprintf_l(a2, 0, ".");
      fprintf_l(a2, 0, "%c", (((v8->_r >> 4) + 1) & 3u) + 119);
      fprintf_l(a2, 0, "%c", (((v8->_r >> 6) + 1) & 3u) + 119);
      fprintf_l(a2, 0, "%c", ((BYTE1(v8->_r) + 1) & 3u) + 119);
      fprintf_l(a2, 0, "%c", (((v8->_r >> 10) + 1) & 3u) + 119);
      uint64_t result = (FILE *)fprintf_l(a2, 0, ")");
      break;
    default:
      return result;
  }
  return result;
}

uint64_t glpWriteAddressOperand(uint64_t result, FILE *a2, int a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 8);
  if ((v6 & 0x7000) == 0x4000)
  {
    uint64_t result = fprintf_l(a2, 0, "adr%d", HIWORD(v6));
    unint64_t v6 = *(void *)(v5 + 8);
  }
  if ((~v6 & 0x78000) == 0) {
    return result;
  }
  uint64_t result = fprintf_l(a2, 0, ".");
  uint64_t v7 = *(void *)(v5 + 8);
  if (!a3)
  {
    if ((v7 & 0x40000) != 0)
    {
      uint64_t result = fprintf_l(a2, 0, "x");
      uint64_t v7 = *(void *)(v5 + 8);
      if ((v7 & 0x20000) == 0)
      {
LABEL_18:
        if ((v7 & 0x10000) == 0) {
          goto LABEL_19;
        }
        goto LABEL_23;
      }
    }
    else if ((v7 & 0x20000) == 0)
    {
      goto LABEL_18;
    }
    uint64_t result = fprintf_l(a2, 0, "y");
    uint64_t v7 = *(void *)(v5 + 8);
    if ((v7 & 0x10000) == 0)
    {
LABEL_19:
      if ((v7 & 0x8000) == 0) {
        return result;
      }
      goto LABEL_13;
    }
LABEL_23:
    uint64_t result = fprintf_l(a2, 0, "z");
    if ((*(void *)(v5 + 8) & 0x8000) == 0) {
      return result;
    }
    goto LABEL_13;
  }
  if ((v7 & 0x40000) != 0)
  {
    uint64_t result = fprintf_l(a2, 0, "x");
    uint64_t v7 = *(void *)(v5 + 8);
  }
  if ((v7 & 0x600000) != 0 && (v7 & 0x20000) != 0)
  {
    uint64_t result = fprintf_l(a2, 0, "y");
    uint64_t v7 = *(void *)(v5 + 8);
  }
  if ((~v7 & 0x410000) == 0)
  {
    uint64_t result = fprintf_l(a2, 0, "z");
    uint64_t v7 = *(void *)(v5 + 8);
  }
  if ((~v7 & 0x608000) == 0)
  {
LABEL_13:
    return fprintf_l(a2, 0, "w");
  }
  return result;
}

uint64_t glpPPDisassemble(_DWORD *a1)
{
  int v191 = 1;
  v190[0] = 0;
  v190[1] = 0;
  uint64_t v2 = funopen(v190, 0, (int (__cdecl *)(void *, const char *, int))writefn, 0, 0);
  uint64_t v3 = v2;
  uint64_t v4 = 0;
  BOOL v5 = 0;
  int v6 = *(unsigned __int16 *)a1;
  do
    BOOL v5 = v5 || glpPPDisassemble_shaderTargets[v4++] == v6;
  while (v4 != 5);
  int v187 = *(unsigned __int16 *)a1;
  if (v187 <= 0x8B30)
  {
    switch(v6)
    {
      case 34336:
        fprintf_l(v2, 0, "!!ARBvp1.0\n");
        goto LABEL_23;
      case 34820:
        fprintf_l(v2, 0, "!!ARBfp1.0\n");
        goto LABEL_23;
      case 35632:
        fprintf_l(v2, 0, "!!fragmentshader\n");
        goto LABEL_23;
    }
  }
  else if (*(unsigned __int16 *)a1 > 0x8E86u)
  {
    if (v6 == 36487)
    {
      fprintf_l(v2, 0, "!!tessevaluationshader\n");
      goto LABEL_23;
    }
    if (v6 == 36488)
    {
      fprintf_l(v2, 0, "!!tesscontrolshader\n");
      goto LABEL_23;
    }
  }
  else
  {
    if (v6 == 35633)
    {
      fprintf_l(v2, 0, "!!vertexshader\n");
      goto LABEL_23;
    }
    if (v6 == 36313)
    {
      fprintf_l(v2, 0, "!!geometryshader\n");
      goto LABEL_23;
    }
  }
  fprintf_l(v2, 0, "Unknown Target (error)\n");
LABEL_23:
  int v188 = v5;
  if (v5) {
    fprintf_l(v3, 0, "\n");
  }
  int v7 = a1[24];
  if (v7 >= 1)
  {
    uint64_t v8 = (unint64_t *)&a1[2 * a1[25]];
    uint64_t v9 = a1[24];
    do
    {
      fprintf_l(v3, 0, "OPTION ");
      unint64_t v11 = *v8++;
      unint64_t v10 = v11;
      char v12 = BYTE3(v11);
      if (BYTE3(v11) <= 0xDu && ((0x3F31u >> v12) & 1) != 0) {
        fprintf_l(v3, 0, *(char **)((char *)&off_264D9D390 + ((uint64_t)(v10 >> 24 << 56) >> 53)));
      }
      fprintf_l(v3, 0, ";\n");
      --v9;
    }
    while (v9);
  }
  int v13 = v188;
  if (v188 && v7) {
    fprintf_l(v3, 0, "\n");
  }
  int v14 = a1[10];
  char v172 = a1;
  if (!v14)
  {
    int v16 = a1[8];
    int v17 = &a1[2 * a1[9]];
    if (v188) {
      goto LABEL_41;
    }
    uint64_t v19 = 0;
    uint64_t v21 = 0;
    unint64_t v22 = 0;
    goto LABEL_67;
  }
  fprintf_l(v3, 0, "ADDRESS adr0");
  if (v14 >= 2)
  {
    for (int i = 1; i != v14; ++i)
      fprintf_l(v3, 0, ", adr%d", i);
  }
  fprintf_l(v3, 0, ";\n");
  int v13 = v188;
  if ((v188 & 1) == 0)
  {
    uint64_t v19 = 0;
    uint64_t v21 = 0;
    unint64_t v22 = 0;
    int v16 = a1[8];
    int v17 = &a1[2 * a1[9]];
LABEL_67:
    if (v16 < 1) {
      goto LABEL_206;
    }
    uint64_t v173 = v22;
    *(void *)uint64_t v174 = v19;
    int v180 = 0;
    size_t size = (size_t)v21;
    uint64_t v34 = 0;
    int v35 = 0;
    int v36 = 0;
    uint64_t v37 = v16;
    uint64_t v38 = v16 - 1;
    int v39 = 1;
    int v178 = -1;
    unsigned int v176 = -1;
    uint64_t v40 = 0xFFFFFFFFLL;
    int v185 = -1;
    while (1)
    {
      if (v39)
      {
        uint64_t v41 = *(void *)v17;
        if ((*(void *)v17 & 0x100) != 0)
        {
          fprintf_l(v3, 0, "INVARIANT ");
          uint64_t v41 = *(void *)v17;
        }
        uint64_t v42 = (v41 & 7) - 1;
        if (v42 <= 2) {
          fprintf_l(v3, 0, (&off_264D9D418)[v42]);
        }
        fprintf_l(v3, 0, "TEMP ");
        int v36 = (*v17 >> 8) & 1;
        int v35 = *v17 & 7;
      }
      if ((v188 & 1) == 0)
      {
        fprintf_l(v3, 0, "tmp%d", v34);
LABEL_80:
        uint64_t v44 = v40;
        goto LABEL_81;
      }
      int v43 = *(_DWORD *)(size + 4 * v34);
      if (v43)
      {
        uint64_t v44 = v40;
        if (v43 == -1)
        {
          fprintf_l(v3, 0, "tmp%d", *(_DWORD *)(*(void *)v174 + 4 * v34));
          glpWriteSizeTypePrecision(v3, *v17 >> 6, (*v17 >> 3) & 7, *v17 & 7);
          goto LABEL_81;
        }
        int v47 = v185 + 1;
        uint64_t v48 = *(void *)v17;
        if (v40 != *(void *)v17 >> 6
          || v176 != ((*(void *)v17 >> 3) & 7)
          || v178 != (*v17 & 7))
        {
          int v51 = v173[v180];
          if (v185 + 2 == v51) {
            int v52 = v180 + 1;
          }
          else {
            int v52 = v180;
          }
          int v180 = v52;
          if (v185 + 2 == v51) {
            int v53 = -1;
          }
          else {
            int v53 = v185 + 1;
          }
          int v185 = v53;
          uint64_t v44 = 0xFFFFFFFFLL;
          unsigned int v176 = -1;
          int v178 = -1;
          goto LABEL_81;
        }
        uint64_t v45 = v180;
        uint64_t v46 = v173;
      }
      else
      {
        uint64_t v45 = v180;
        uint64_t v46 = v173;
        fprintf_l(v3, 0, "tmp%d[%d]", *(_DWORD *)(*(void *)v174 + 4 * v34), v173[v180]);
        int v47 = 0;
        uint64_t v48 = *(void *)v17;
        uint64_t v40 = *(void *)v17 >> 6;
        unsigned int v176 = (*(void *)v17 >> 3) & 7;
        int v178 = *(void *)v17 & 7;
      }
      int v185 = v47;
      if (v47 + 1 != v46[v45]) {
        goto LABEL_80;
      }
      ++v180;
      uint64_t v44 = v40;
      if (v40 != -1) {
        glpWriteSizeTypePrecision(v3, v48 >> 6, (v48 >> 3) & 7, v48 & 7);
      }
      int v185 = -1;
LABEL_81:
      uint64_t v40 = v44;
      if (v38 == v34)
      {
        int v39 = 0;
      }
      else
      {
        int v39 = 1;
        if (((v17[2] >> 8) & 1) == v36 && (v17[2] & 7) == v35)
        {
          int v39 = 0;
          if (v185 == -1) {
            fprintf_l(v3, 0, ", ");
          }
          goto LABEL_84;
        }
      }
      fprintf_l(v3, 0, ";\n");
LABEL_84:
      ++v34;
      v17 += 2;
      if (v37 == v34)
      {
        int v16 = 1;
        a1 = v172;
        unint64_t v22 = v173;
        uint64_t v19 = *(_DWORD **)v174;
        uint64_t v21 = (_DWORD *)size;
        int v13 = v188;
        if (v173) {
          goto LABEL_112;
        }
        goto LABEL_113;
      }
    }
  }
  fprintf_l(v3, 0, "\n");
  int v16 = a1[8];
  int v17 = &a1[2 * a1[9]];
LABEL_41:
  if (v16)
  {
    uint64_t v18 = malloc_type_malloc(4 * v16, 0x7081ABB9uLL);
    if (!v18) {
      goto LABEL_559;
    }
    uint64_t v19 = v18;
    uint64_t v20 = malloc_type_malloc(4 * v16, 0x7081ABB9uLL);
    if (!v20) {
      goto LABEL_559;
    }
    uint64_t v21 = v20;
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v21 = 0;
  }
  uint64_t v23 = a1[20];
  if (v23)
  {
    unint64_t v22 = malloc_type_malloc(4 * v23, 0x7081ABB9uLL);
    if (!v22) {
      goto LABEL_559;
    }
  }
  else
  {
    unint64_t v22 = 0;
  }
  if (v16 >= 1)
  {
    uint64_t v24 = 0;
    int v25 = 0;
    int v26 = -1;
    uint64_t v27 = 0xFFFFFFFFLL;
    LODWORD(v28) = -1;
    while (v26 != -1)
    {
      if (v24 <= (int)v28)
      {
        v19[v24] = v26;
        uint64_t v29 = (v27 + 1);
LABEL_63:
        v21[v24] = v27;
        if (v24 == v28)
        {
          v22[v25++] = v29;
          LODWORD(v28) = -1;
          uint64_t v27 = 0xFFFFFFFFLL;
          int v26 = -1;
        }
        else
        {
          uint64_t v27 = v29;
        }
      }
      if (++v24 == v16) {
        goto LABEL_67;
      }
    }
    v19[v24] = v24;
    uint64_t v30 = a1[20];
    if ((int)v30 < 1)
    {
LABEL_61:
      int v26 = -1;
      uint64_t v29 = v27;
    }
    else
    {
      unsigned int v31 = (unint64_t *)&a1[2 * a1[21]];
      while (1)
      {
        unint64_t v33 = *v31++;
        unint64_t v32 = v33;
        if (v24 == WORD1(v33)) {
          break;
        }
        if (!--v30) {
          goto LABEL_61;
        }
      }
      LODWORD(v27) = 0;
      unint64_t v28 = HIWORD(v32);
      uint64_t v29 = 1;
      int v26 = v24;
    }
    goto LABEL_63;
  }
LABEL_206:
  int v185 = -1;
  if (v22) {
LABEL_112:
  }
    free(v22);
LABEL_113:
  sizea = v21;
  if (v13 && v16) {
    fprintf_l(v3, 0, "\n");
  }
  uint64_t v54 = a1[12];
  if ((int)v54 >= 1)
  {
    uint64_t v55 = 0;
    unint64_t v56 = &a1[2 * a1[13]];
    do
    {
      uint64_t v57 = *(void *)&v56[2 * v55];
      if ((v57 & 0x200) != 0)
      {
        fprintf_l(v3, 0, "CENTROID ");
        uint64_t v57 = *(void *)&v56[2 * v55];
        if ((v57 & 0x100) == 0)
        {
LABEL_120:
          if ((v57 & 0x8000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_133;
        }
      }
      else if ((v57 & 0x100) == 0)
      {
        goto LABEL_120;
      }
      fprintf_l(v3, 0, "NONPERSPECTIVE ");
      uint64_t v57 = *(void *)&v56[2 * v55];
      if ((v57 & 0x8000) == 0)
      {
LABEL_121:
        if ((v57 & 0x10000) == 0) {
          goto LABEL_122;
        }
        goto LABEL_134;
      }
LABEL_133:
      fprintf_l(v3, 0, "FLAT ");
      uint64_t v57 = *(void *)&v56[2 * v55];
      if ((v57 & 0x10000) == 0)
      {
LABEL_122:
        if ((v57 & 0x20000) == 0) {
          goto LABEL_124;
        }
LABEL_123:
        fprintf_l(v3, 0, "SAMPLE ");
        goto LABEL_124;
      }
LABEL_134:
      fprintf_l(v3, 0, "PATCH ");
      if ((*(void *)&v56[2 * v55] & 0x20000) != 0) {
        goto LABEL_123;
      }
LABEL_124:
      fprintf_l(v3, 0, "ATTRIB att%d", v55);
      if (v13) {
        glpWriteSizeTypePrecision(v3, v56[2 * v55] >> 6, (v56[2 * v55] >> 3) & 7, v56[2 * v55] & 7);
      }
      if (v187 <= 35632)
      {
        uint64_t v58 = " = vertex.";
        if (v187 != 34336)
        {
          if (v187 == 34820 || v187 == 35632) {
            fprintf_l(v3, 0, " = fragment.");
          }
          goto LABEL_145;
        }
      }
      else if (v187 > 36486)
      {
        if (v187 != 36487)
        {
          if (v187 == 36488) {
            fprintf_l(v3, 0, " = control.");
          }
          goto LABEL_145;
        }
        uint64_t v58 = " = evaluation.";
      }
      else
      {
        uint64_t v58 = " = vertex.";
        if (v187 != 35633)
        {
          if (v187 == 36313) {
            fprintf_l(v3, 0, " = geometry.");
          }
          goto LABEL_145;
        }
      }
      fprintf_l(v3, 0, v58);
LABEL_145:
      uint64_t v59 = *(void *)&v56[2 * v55];
      switch((v59 >> 10) & 0x1F)
      {
        case 0u:
          fprintf_l(v3, 0, "none", v168);
          break;
        case 1u:
          fprintf_l(v3, 0, "position");
          uint64_t v60 = *(void *)&v56[2 * v55];
          if ((v60 & 0x100000000) != 0)
          {
            fprintf_l(v3, 0, ".origin_upper_left");
            uint64_t v60 = *(void *)&v56[2 * v55];
          }
          if ((v60 & 0x200000000) != 0) {
            fprintf_l(v3, 0, ".pixel_center_integer", v168);
          }
          break;
        case 2u:
          fprintf_l(v3, 0, "color.primary", v168);
          break;
        case 3u:
          fprintf_l(v3, 0, "color.secondary", v168);
          break;
        case 0xBu:
          fprintf_l(v3, 0, "facing", v168);
          break;
        case 0xCu:
          fprintf_l(v3, 0, "pointCoord", v168);
          break;
        case 0xDu:
          fprintf_l(v3, 0, "clipVertex", v168);
          break;
        case 0xEu:
          fprintf_l(v3, 0, "clipDistance[%d]");
          break;
        case 0xFu:
          fprintf_l(v3, 0, "pointsize", v168);
          break;
        case 0x10u:
          fprintf_l(v3, 0, "primitiveid", v168);
          break;
        case 0x11u:
          fprintf_l(v3, 0, "vertexid", v168);
          break;
        case 0x12u:
          fprintf_l(v3, 0, "instanceid", v168);
          break;
        case 0x13u:
          fprintf_l(v3, 0, "tessLevelOuter", v168);
          break;
        case 0x14u:
          fprintf_l(v3, 0, "tessLevelInner", v168);
          break;
        case 0x15u:
          fprintf_l(v3, 0, "tessCoord", v168);
          break;
        case 0x16u:
          fprintf_l(v3, 0, "sampleMask[%d]");
          break;
        case 0x17u:
          fprintf_l(v3, 0, "sampleID", v168);
          break;
        case 0x18u:
          fprintf_l(v3, 0, "samplePosition", v168);
          break;
        case 0x19u:
          fprintf_l(v3, 0, "invocationID", v168);
          break;
        case 0x1Au:
          fprintf_l(v3, 0, "patchVerticiesIn", v168);
          break;
        case 0x1Bu:
          fprintf_l(v3, 0, "fragdata[%d]");
          break;
        case 0x1Cu:
          if ((v59 & 0x10000000000) != 0)
          {
            fprintf_l(v3, 0, "generic[%d]");
          }
          else
          {
            switch(BYTE4(v59) & 0x3F)
            {
              case 0:
                fprintf_l(v3, 0, "position", v168);
                break;
              case 1:
                fprintf_l(v3, 0, "normal", v168);
                break;
              case 2:
                fprintf_l(v3, 0, "color.primary", v168);
                break;
              case 3:
                fprintf_l(v3, 0, "color.secondary", v168);
                break;
              case 4:
                fprintf_l(v3, 0, "weight[0]", v168);
                break;
              case 5:
                fprintf_l(v3, 0, "fogcoord", v168);
                break;
              case 6:
                fprintf_l(v3, 0, "pointsize", v168);
                break;
              case 7:
                fprintf_l(v3, 0, "matrixindex[0]", v168);
                break;
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
              case 0xD:
              case 0xE:
              case 0xF:
                fprintf_l(v3, 0, "texcoord[%d]");
                break;
              case 0x10:
              case 0x11:
              case 0x12:
              case 0x13:
              case 0x14:
              case 0x15:
              case 0x16:
              case 0x17:
              case 0x18:
              case 0x19:
              case 0x1A:
              case 0x1B:
              case 0x1C:
              case 0x1D:
              case 0x1E:
              case 0x1F:
                fprintf_l(v3, 0, "attrib[%d]");
                break;
              case 0x20:
                fprintf_l(v3, 0, "material.front.ambient", v168);
                break;
              case 0x21:
                fprintf_l(v3, 0, "material.back.ambient", v168);
                break;
              case 0x22:
                fprintf_l(v3, 0, "material.front.diffuse", v168);
                break;
              case 0x23:
                fprintf_l(v3, 0, "material.back.diffuse", v168);
                break;
              case 0x24:
                fprintf_l(v3, 0, "material.front.specular", v168);
                break;
              case 0x25:
                fprintf_l(v3, 0, "material.back.specular", v168);
                break;
              case 0x26:
                fprintf_l(v3, 0, "material.front.emission", v168);
                break;
              case 0x27:
                fprintf_l(v3, 0, "material.back.emission", v168);
                break;
              case 0x28:
                fprintf_l(v3, 0, "material.front.shininess", v168);
                break;
              case 0x29:
                fprintf_l(v3, 0, "material.back.shininess");
                break;
              default:
                break;
            }
          }
          if ((v56[2 * v55 + 1] & 0x80) != 0) {
            fprintf_l(v3, 0, "[%d]");
          }
          break;
        default:
          break;
      }
      fprintf_l(v3, 0, ";\n");
      ++v55;
    }
    while (v54 != v55);
  }
  __n128 v175 = v19;
  if (v13 && v54) {
    fprintf_l(v3, 0, "\n");
  }
  uint64_t v61 = (int)a1[14];
  if (v61)
  {
    uint64_t v62 = a1[15];
    uint64_t v63 = malloc_type_malloc(4 * v61, 0x7081ABB9uLL);
    if (!v63) {
      goto LABEL_559;
    }
    unint64_t v64 = v63;
    uint64_t v65 = malloc_type_malloc(4 * v61, 0x7081ABB9uLL);
    if (!v65) {
      goto LABEL_559;
    }
    uint64_t v66 = a1[18];
    uint64_t v177 = v65;
    uint64_t v179 = v64;
    if (v66)
    {
      uint64_t v67 = malloc_type_malloc(4 * v66, 0x7081ABB9uLL);
      if (!v67) {
        goto LABEL_559;
      }
    }
    else
    {
      uint64_t v67 = 0;
    }
    if ((int)v61 >= 1)
    {
      uint64_t v68 = 0;
      int v69 = 0;
      uint64_t v70 = v61;
      int v71 = -1;
      uint64_t v72 = 0xFFFFFFFFLL;
      LODWORD(v73) = -1;
      uint64_t v74 = &a1[2 * v62];
      uint64_t v76 = v177;
      uint64_t v75 = v179;
      while (1)
      {
        if ((*(void *)&v74[2 * v68] & 0x1F00) != 0)
        {
          if (v71 == -1)
          {
            v179[v68] = v68;
            uint64_t v78 = a1[18];
            if ((int)v78 < 1)
            {
LABEL_220:
              int v71 = -1;
              uint64_t v77 = v72;
            }
            else
            {
              long long v79 = (unint64_t *)&a1[2 * a1[19]];
              while (1)
              {
                unint64_t v81 = *v79++;
                unint64_t v80 = v81;
                if (v68 == WORD1(v81)) {
                  break;
                }
                if (!--v78) {
                  goto LABEL_220;
                }
              }
              LODWORD(v72) = 0;
              unint64_t v73 = HIWORD(v80);
              uint64_t v77 = 1;
              int v71 = v68;
            }
            goto LABEL_222;
          }
          if (v68 <= (int)v73)
          {
            v179[v68] = v71;
            uint64_t v77 = (v72 + 1);
LABEL_222:
            v177[v68] = v72;
            if (v68 == v73)
            {
              v67[v69++] = v77;
              LODWORD(v73) = -1;
              uint64_t v72 = 0xFFFFFFFFLL;
              int v71 = -1;
            }
            else
            {
              uint64_t v72 = v77;
            }
          }
        }
        if (++v68 == v61)
        {
          int v82 = 0;
          __n128 v181 = v67;
          while (1)
          {
            if (*v76)
            {
              if (*v76 == -1)
              {
                fprintf_l(v3, 0, "PARAM prm%d", *v75);
                int v83 = v185;
                if (v188) {
                  glpWriteSizeTypePrecision(v3, *v74 >> 6, (*v74 >> 3) & 7, *v74 & 7);
                }
                fprintf_l(v3, 0, " = ");
              }
              else
              {
                int v83 = v185 + 1;
                fprintf_l(v3, 0, "    ");
              }
            }
            else
            {
              fprintf_l(v3, 0, "PARAM prm%d[%d]", *v75, v67[v82]);
              if (v188) {
                glpWriteSizeTypePrecision(v3, *v74 >> 6, (*v74 >> 3) & 7, *v74 & 7);
              }
              int v83 = 0;
              fprintf_l(v3, 0, " = {\n    ");
            }
            uint64_t v84 = *(void *)v74;
            unsigned int v85 = (*(void *)v74 >> 8) & 0x1F;
            if (v85 - 1 < 5) {
              break;
            }
            if (v85 != 6)
            {
              fprintf_l(v3, 0, "state.");
LABEL_238:
              switch(v85)
              {
                case 0u:
                  fprintf_l(v3, 0, "none", v168, v169, *(void *)v170, v171);
                  break;
                case 1u:
                  fprintf_l(v3, 0, "local[%d]");
                  break;
                case 2u:
                  fprintf_l(v3, 0, "uniform[%d]");
                  break;
                case 3u:
                  fprintf_l(v3, 0, "uniformSubroutine[%d]");
                  break;
                case 4u:
                  fprintf_l(v3, 0, "bindable[%d][%d]");
                  break;
                case 5u:
                  fprintf_l(v3, 0, "env[%d]");
                  break;
                case 6u:
                  uint64_t v84 = *(void *)v74;
                  goto LABEL_241;
                case 7u:
                  fprintf_l(v3, 0, "verticesIn", v168, v169, *(void *)v170, v171);
                  break;
                case 8u:
                  fprintf_l(v3, 0, "verticesOut", v168, v169, *(void *)v170, v171);
                  break;
                case 9u:
                  fprintf_l(v3, 0, "numSamples", v168, v169, *(void *)v170, v171);
                  break;
                case 0xAu:
                  fprintf_l(v3, 0, "tfBuffer[%d][%d][%d]");
                  break;
                case 0xBu:
                  fprintf_l(v3, 0, "tfBase[%d][%d]");
                  break;
                case 0xCu:
                case 0xDu:
                  fprintf_l(v3, 0, "inputs[%d][%d]");
                  break;
                case 0xEu:
                  fprintf_l(v3, 0, "generic[%d]");
                  break;
                case 0xFu:
                  fprintf_l(v3, 0, "matrix.");
                  switch((*(void *)v74 >> 44) & 7)
                  {
                    case 0:
                      fprintf_l(v3, 0, "mvp.", v168);
                      break;
                    case 1:
                      fprintf_l(v3, 0, "projection.", v168);
                      break;
                    case 2:
                      fprintf_l(v3, 0, "color[%d].");
                      break;
                    case 3:
                      fprintf_l(v3, 0, "modelview[%d].");
                      break;
                    case 4:
                      fprintf_l(v3, 0, "texture[%d].");
                      break;
                    case 5:
                      fprintf_l(v3, 0, "program[%d].");
                      break;
                    case 6:
                      fprintf_l(v3, 0, "palette[%d].");
                      break;
                    default:
                      break;
                  }
                  uint64_t v87 = ((*(void *)v74 >> 40) & 3) - 1;
                  if (v87 <= 2) {
                    fprintf_l(v3, 0, (&off_264D9D400)[v87]);
                  }
                  fprintf_l(v3, 0, "row[%d]");
                  break;
                case 0x10u:
                  fprintf_l(v3, 0, "light[%d].", *((unsigned __int8 *)v74 + 4));
                  switch((*(void *)v74 >> 40) & 0xF)
                  {
                    case 0:
                      goto LABEL_278;
                    case 1:
                      goto LABEL_292;
                    case 2:
                      goto LABEL_293;
                    case 3:
                      fprintf_l(v3, 0, "position", v168, v169, *(void *)v170, v171);
                      break;
                    case 4:
                      fprintf_l(v3, 0, "spot.direction", v168, v169, *(void *)v170, v171);
                      break;
                    case 5:
                      fprintf_l(v3, 0, "attenuation", v168, v169, *(void *)v170, v171);
                      break;
                    case 6:
                      fprintf_l(v3, 0, "half", v168, v169, *(void *)v170, v171);
                      break;
                    case 7:
                      fprintf_l(v3, 0, "position_norm", v168, v169, *(void *)v170, v171);
                      break;
                    case 8:
                      fprintf_l(v3, 0, "direction_norm", v168, v169, *(void *)v170, v171);
                      break;
                    case 9:
                      fprintf_l(v3, 0, "spotcutoff");
                      break;
                    default:
                      goto LABEL_309;
                  }
                  break;
                case 0x11u:
                  fprintf_l(v3, 0, "lightprod[%d].", *((unsigned __int8 *)v74 + 4));
                  if ((*(void *)v74 & 0x10000000000) != 0) {
                    fprintf_l(v3, 0, "back.");
                  }
                  else {
                    fprintf_l(v3, 0, "front.");
                  }
                  uint64_t v86 = (*(void *)v74 >> 41) & 3;
                  switch(v86)
                  {
                    case 2:
LABEL_293:
                      fprintf_l(v3, 0, "specular", v168, v169, *(void *)v170, v171);
                      break;
                    case 1:
LABEL_292:
                      fprintf_l(v3, 0, "diffuse", v168, v169, *(void *)v170, v171);
                      break;
                    case 0:
LABEL_278:
                      fprintf_l(v3, 0, "ambient", v168, v169, *(void *)v170, v171);
                      break;
                  }
                  break;
                case 0x12u:
                  if ((*(void *)v74 & 0xE00000000) == 0xA00000000) {
                    fprintf_l(v3, 0, "lightmodel.");
                  }
                  else {
                    fprintf_l(v3, 0, "material.");
                  }
                  if ((*(void *)v74 & 0x100000000) != 0) {
                    fprintf_l(v3, 0, "back.");
                  }
                  else {
                    fprintf_l(v3, 0, "front.");
                  }
                  switch((*(void *)v74 >> 33) & 7)
                  {
                    case 0:
                      goto LABEL_278;
                    case 1:
                      goto LABEL_292;
                    case 2:
                      goto LABEL_293;
                    case 3:
                      fprintf_l(v3, 0, "emission", v168, v169, *(void *)v170, v171);
                      break;
                    case 4:
                      fprintf_l(v3, 0, "shininess", v168, v169, *(void *)v170, v171);
                      break;
                    case 5:
                      fprintf_l(v3, 0, "scenecolor", v168, v169, *(void *)v170, v171);
                      break;
                    default:
                      goto LABEL_309;
                  }
                  break;
                case 0x13u:
                  fprintf_l(v3, 0, "lightmodel.ambient", v168, v169, *(void *)v170, v171);
                  break;
                case 0x14u:
                  fprintf_l(v3, 0, "texgen[%d].eye.", v74[1] & 0x7F);
                  switch((*(void *)v74 >> 39) & 7)
                  {
                    case 0:
                      goto LABEL_282;
                    case 1:
                      goto LABEL_294;
                    case 2:
                      goto LABEL_295;
                    case 3:
                      goto LABEL_296;
                    default:
                      goto LABEL_309;
                  }
                case 0x15u:
                  fprintf_l(v3, 0, "texgen[%d].object.", v74[1] & 0x7F);
                  switch((*(void *)v74 >> 39) & 7)
                  {
                    case 0:
LABEL_282:
                      fprintf_l(v3, 0, "s", v168, v169, *(void *)v170, v171);
                      break;
                    case 1:
LABEL_294:
                      fprintf_l(v3, 0, "t", v168, v169, *(void *)v170, v171);
                      break;
                    case 2:
LABEL_295:
                      fprintf_l(v3, 0, "r", v168, v169, *(void *)v170, v171);
                      break;
                    case 3:
LABEL_296:
                      fprintf_l(v3, 0, "q", v168, v169, *(void *)v170, v171);
                      break;
                    default:
                      goto LABEL_309;
                  }
                  break;
                case 0x16u:
                  fprintf_l(v3, 0, "texenv[%d].color");
                  break;
                case 0x18u:
                  fprintf_l(v3, 0, "clip[%d].plane");
                  break;
                case 0x19u:
                  fprintf_l(v3, 0, "fog.color", v168, v169, *(void *)v170, v171);
                  break;
                case 0x1Au:
                  fprintf_l(v3, 0, "fog.params", v168, v169, *(void *)v170, v171);
                  break;
                case 0x1Bu:
                  fprintf_l(v3, 0, "fog.params_ext", v168, v169, *(void *)v170, v171);
                  break;
                case 0x1Cu:
                  fprintf_l(v3, 0, "point.size", v168, v169, *(void *)v170, v171);
                  break;
                case 0x1Du:
                  fprintf_l(v3, 0, "point.attenuation", v168, v169, *(void *)v170, v171);
                  break;
                case 0x1Eu:
                  fprintf_l(v3, 0, "depth.range", v168, v169, *(void *)v170, v171);
                  break;
                case 0x1Fu:
                  fprintf_l(v3, 0, "normalscale", v168, v169, *(void *)v170, v171);
                  break;
                default:
                  goto LABEL_309;
              }
              goto LABEL_309;
            }
LABEL_241:
            switch((v84 >> 3) & 7)
            {
              case 0u:
                fprintf_l(v3, 0, "{%g, %g, %g, %g}");
                break;
              case 1u:
              case 2u:
                fprintf_l(v3, 0, "{%d, %d, %d, %d}");
                break;
              case 3u:
                fprintf_l(v3, 0, "{%u, %u, %u, %u}");
                break;
              case 4u:
                fprintf_l(v3, 0, "{%g, %g}");
                break;
              default:
                break;
            }
LABEL_309:
            int v185 = v83;
            if (*v76 == -1)
            {
              uint64_t v88 = ";\n";
              uint64_t v67 = v181;
            }
            else
            {
              uint64_t v67 = v181;
              if (v83 + 1 == v181[v82]) {
                uint64_t v88 = "\n};\n";
              }
              else {
                uint64_t v88 = ",\n";
              }
              if (v83 + 1 == v181[v82]) {
                ++v82;
              }
            }
            fprintf_l(v3, 0, v88);
            v74 += 2;
            ++v75;
            ++v76;
            if (!--v70) {
              goto LABEL_325;
            }
          }
          fprintf_l(v3, 0, "program.");
          goto LABEL_238;
        }
      }
    }
LABEL_325:
    if (v67) {
      free(v67);
    }
    fprintf_l(v3, 0, "\n");
  }
  else
  {
    uint64_t v177 = 0;
    uint64_t v179 = 0;
  }
  uint64_t v89 = a1[16];
  if ((int)v89 >= 1)
  {
    uint64_t v90 = 0;
    uint64_t v91 = &a1[2 * a1[17]];
    if (v187 == 36488) {
      uint64_t v92 = "SHARED shr";
    }
    else {
      uint64_t v92 = "OUTPUT res";
    }
    while (1)
    {
      uint64_t v93 = *(void *)&v91[2 * v90];
      if ((v93 & 0x2000) != 0)
      {
        fprintf_l(v3, 0, "INVARIANT ");
        uint64_t v93 = *(void *)&v91[2 * v90];
        if ((v93 & 0x4000) != 0)
        {
LABEL_343:
          fprintf_l(v3, 0, "PATCH ");
          uint64_t v93 = *(void *)&v91[2 * v90];
          if ((v93 & 0x8000) == 0) {
            goto LABEL_336;
          }
LABEL_335:
          fprintf_l(v3, 0, "SAMPLE ");
          uint64_t v93 = *(void *)&v91[2 * v90];
          goto LABEL_336;
        }
      }
      else if ((v93 & 0x4000) != 0)
      {
        goto LABEL_343;
      }
      if ((v93 & 0x8000) != 0) {
        goto LABEL_335;
      }
LABEL_336:
      uint64_t v94 = (v93 & 7) - 1;
      if (v94 <= 2) {
        fprintf_l(v3, 0, (&off_264D9D418)[v94]);
      }
      fprintf_l(v3, 0, v92);
      fprintf_l(v3, 0, "%d", v90);
      if (v188) {
        glpWriteSizeTypePrecision(v3, v91[2 * v90] >> 6, (v91[2 * v90] >> 3) & 7, v91[2 * v90] & 7);
      }
      fprintf_l(v3, 0, " = ");
      unint64_t v95 = *(void *)&v91[2 * v90];
      switch((v95 >> 8) & 0x1F)
      {
        case 0u:
          fprintf_l(v3, 0, "result.none", v168);
          goto LABEL_378;
        case 1u:
          fprintf_l(v3, 0, "result.position", v168);
          goto LABEL_378;
        case 3u:
          fprintf_l(v3, 0, "result.pointsize", v168);
          goto LABEL_378;
        case 4u:
          fprintf_l(v3, 0, "result.color");
          if (v187 <= 35631)
          {
            if (v187 == 34336) {
              goto LABEL_374;
            }
            if (v187 == 34820)
            {
LABEL_371:
              unint64_t v97 = *(void *)&v91[2 * v90];
              if ((v97 & 0x1E00000000) != 0)
              {
                fprintf_l(v3, 0, "[%d]", (v97 >> 33) & 7);
                if ((v91[2 * v90 + 1] & 0x10) != 0) {
                  fprintf_l(v3, 0, "[%d]");
                }
              }
            }
          }
          else
          {
            if (v187 == 35632) {
              goto LABEL_371;
            }
            if (v187 == 36313 || v187 == 35633)
            {
LABEL_374:
              if (v91[2 * v90 + 1]) {
                fprintf_l(v3, 0, ".back.primary", v168);
              }
              else {
                fprintf_l(v3, 0, ".front.primary", v168);
              }
            }
          }
LABEL_378:
          fprintf_l(v3, 0, ";\n");
          if (v89 == ++v90) {
            goto LABEL_382;
          }
          break;
        case 5u:
          fprintf_l(v3, 0, "result.color");
          if (v187 == 35633 || v187 == 34336)
          {
            if (v91[2 * v90 + 1]) {
              fprintf_l(v3, 0, ".back.secondary", v168);
            }
            else {
              fprintf_l(v3, 0, ".front.secondary", v168);
            }
          }
          goto LABEL_378;
        case 7u:
          fprintf_l(v3, 0, "result.depth", v168);
          goto LABEL_378;
        case 9u:
          fprintf_l(v3, 0, "result.clipVertex", v168);
          goto LABEL_378;
        case 0xAu:
          fprintf_l(v3, 0, "result.clipDistance[%d]");
          goto LABEL_378;
        case 0xBu:
          fprintf_l(v3, 0, "result.primitiveid", v168);
          goto LABEL_378;
        case 0xCu:
          fprintf_l(v3, 0, "result.layer", v168);
          goto LABEL_378;
        case 0xDu:
          fprintf_l(v3, 0, "result.tessLevelOuter", v168);
          goto LABEL_378;
        case 0xEu:
          fprintf_l(v3, 0, "result.tessLevelInner", v168);
          goto LABEL_378;
        case 0xFu:
          fprintf_l(v3, 0, "result.sampleMask[%d]");
          goto LABEL_378;
        case 0x10u:
          fprintf_l(v3, 0, "result.viewportIndex", v168);
          goto LABEL_378;
        case 0x11u:
          uint64_t v96 = HIDWORD(v95) & 0x3F;
          if ((v95 & 0x4000000000) != 0)
          {
            fprintf_l(v3, 0, "result.generic[%d]");
          }
          else if ((v96 - 8) >= 8)
          {
            if (v96 == 5) {
              fprintf_l(v3, 0, "result.fogcoord", v168);
            }
          }
          else
          {
            fprintf_l(v3, 0, "result.texcoord[%d]");
          }
          goto LABEL_378;
        default:
          goto LABEL_378;
      }
    }
  }
LABEL_382:
  if (!v188 || v89) {
    fprintf_l(v3, 0, "\n");
  }
  int v98 = a1[26];
  uint64_t v99 = (uint64_t)sizea;
  if (v98 >= 1)
  {
    int v100 = 0;
    int v101 = 0;
    uint64_t v102 = &a1[2 * a1[27]];
    int v103 = a1[26];
    do
    {
      uint64_t v104 = *(void *)&v102[2 * v101];
      int v105 = (v104 >> 6);
      if (v105 == 75 || (v105 == 76 ? (BOOL v106 = (*(void *)&v102[2 * v101] & 7) == 1) : (BOOL v106 = 1), !v106)) {
        ++v100;
      }
      v101 += (v104 & 7) + 2;
      --v103;
    }
    while (v103);
    uint64_t v107 = (uint64_t)v175;
    if (v100)
    {
      uint64_t v108 = (int *)malloc_type_malloc(4 * v100, 0x7081ABB9uLL);
      if (v108)
      {
        uint64_t v109 = v108;
        size_t v110 = v100;
        bzero(v108, v100);
        uint64_t v111 = malloc_type_malloc(4 * v100, 0x7081ABB9uLL);
        if (v111)
        {
          int v112 = v111;
          bzero(v111, v110);
          int v113 = 0;
          unsigned int v114 = 0;
          int v115 = 0;
          uint64_t v116 = v112 + 1;
          uint64_t v117 = v109 + 1;
          uint64_t v107 = (uint64_t)v175;
          while (1)
          {
            uint64_t v118 = v114;
            unint64_t v119 = *(void *)&v102[2 * v114];
            int v120 = (v119 >> 6);
            if (v120 != 75 && (v120 != 76 || (v119 & 7) == 1)) {
              goto LABEL_417;
            }
            unint64_t v122 = v119 >> 46;
            if (v113 < 1)
            {
              LODWORD(v123) = 0;
            }
            else
            {
              uint64_t v123 = 0;
              while (v109[v123] < (int)v122)
              {
                if (v113 == ++v123) {
                  goto LABEL_410;
                }
              }
            }
            if (v123 == v113) {
              break;
            }
            int v126 = v109[v123];
            if (v126 != v122)
            {
              uint64_t v127 = v123;
              v109[v123] = v122;
              int v125 = v112[v123];
              v112[v123] = v115;
              int v124 = v123 + 1;
              if (v124 < v113)
              {
                do
                {
                  int v128 = v126;
                  int v129 = v125;
                  int v126 = v117[v127];
                  v117[v127] = v128;
                  int v125 = v116[v127];
                  v116[v127++] = v129;
                }
                while (v113 > (int)v127 + 1);
                int v124 = v113;
              }
              LODWORD(v122) = v126;
              goto LABEL_416;
            }
LABEL_417:
            unsigned int v114 = v118 + (v119 & 7) + 2;
            if (++v115 == v98) {
              goto LABEL_420;
            }
          }
LABEL_410:
          int v124 = v113;
          int v125 = v115;
LABEL_416:
          ++v113;
          v109[v124] = v122;
          v112[v124] = v125;
          unint64_t v119 = *(void *)&v102[2 * v118];
          goto LABEL_417;
        }
      }
LABEL_559:
      abort();
    }
    uint64_t v109 = 0;
    int v112 = 0;
    int v113 = 0;
LABEL_420:
    uint64_t v182 = v112;
    uint64_t v186 = v102;
    int v130 = 0;
    int v131 = 0;
    for (int j = 0; j != v98; ++j)
    {
      int __ptr = 0;
      uint64_t v133 = &v186[2 * v131];
      if ((*v133 & 0x4000) != 0) {
        fprintf_l(v3, 0, "main:\n");
      }
      if (v113 && v130 < v113 && j == v109[v130])
      {
        int v134 = v191;
        unsigned int v135 = v191 - 2;
        if (v191 >= 2)
        {
          if (v135 >= 0x31) {
            unsigned int v135 = 49;
          }
          unsigned int v136 = v135 + 1;
          do
          {
            fprintf_l(v3, 0, "  ");
            --v136;
          }
          while (v136);
        }
        fprintf_l(v3, 0, "label_%d:\n", v130);
        int v191 = v134;
        ++v130;
        uint64_t v107 = (uint64_t)v175;
        uint64_t v99 = (uint64_t)sizea;
      }
      unsigned int v137 = (*(_DWORD *)v133 >> 6) - 88;
      BOOL v138 = v137 > 0x37;
      uint64_t v139 = (1 << v137) & 0x8000000010000FLL;
      if (!v138 && v139 != 0) {
        --v191;
      }
      glpDisassemble1Op(j, (uint64_t)v133, v3, &__ptr, (uint64_t)v179, (uint64_t)v177, v107, v99, v109, &v191, v188);
      v131 += __ptr + 1;
    }
    a1 = v172;
    if (v113 && v130 < v113 && v98 + 1 == v109[v130])
    {
      fprintf_l(v3, 0, "  label_%d:\n", v130);
    }
    else if (!v113)
    {
      goto LABEL_444;
    }
    free(v109);
    free(v182);
  }
LABEL_444:
  fprintf_l(v3, 0, "END\n");
  uint64_t v141 = a1[32];
  if ((int)v141 >= 1)
  {
    uint64_t v142 = &v172[2 * v172[33]];
    while (2)
    {
      int v143 = *v142 >> 3;
      fprintf_l(v3, 0, "STATE ");
      switch(v143)
      {
        case 0:
          fprintf_l(v3, 0, "APPLY AA", v168, v169);
          goto LABEL_469;
        case 1:
          fprintf_l(v3, 0, "DEPTH BOUNDS TEST", v168, v169);
          goto LABEL_469;
        case 2:
          fprintf_l(v3, 0, "MULTISAMPLE ");
          uint64_t v155 = *(void *)v142;
          if ((*(void *)v142 & 0x1000) != 0)
          {
            fprintf_l(v3, 0, "SAMPLE_ALPHA_TO_COVERAGE ");
            uint64_t v155 = *(void *)v142;
            if ((*(void *)v142 & 0x2000) == 0)
            {
LABEL_475:
              if ((v155 & 0x4000) == 0) {
                goto LABEL_469;
              }
              goto LABEL_506;
            }
          }
          else if ((v155 & 0x2000) == 0)
          {
            goto LABEL_475;
          }
          fprintf_l(v3, 0, "SAMPLE_ALPHA_TO_ONE ");
          if ((*(void *)v142 & 0x4000) == 0) {
            goto LABEL_469;
          }
LABEL_506:
          fprintf_l(v3, 0, "SAMPLE_COVERAGE ", v168, v169);
LABEL_469:
          fprintf_l(v3, 0, ";\n");
          v142 += 2;
          if (!--v141) {
            break;
          }
          continue;
        case 3:
          fprintf_l(v3, 0, "ALPHA_TEST ");
          switch(*v142 >> 29)
          {
            case 0:
              goto LABEL_487;
            case 1:
              goto LABEL_508;
            case 2:
              goto LABEL_509;
            case 3:
              goto LABEL_510;
            case 4:
              goto LABEL_511;
            case 5:
              goto LABEL_512;
            case 6:
              goto LABEL_513;
            default:
              goto LABEL_507;
          }
        case 4:
          fprintf_l(v3, 0, "STENCIL_TEST \n\tfunc = ");
          int v156 = (*v142 >> 17) & 7;
          uint64_t v157 = "PP_ALWAYS ";
          if (v156 != 7) {
            uint64_t v157 = (&off_264D9D580)[v156];
          }
          fprintf_l(v3, 0, v157);
          fprintf_l(v3, 0, "\n\topfail = ");
          fprintf_l(v3, 0, (&off_264D9D540)[(*(void *)v142 >> 14) & 7]);
          fprintf_l(v3, 0, "\n\topzfail = ");
          fprintf_l(v3, 0, (&off_264D9D540)[(*(void *)v142 >> 11) & 7]);
          fprintf_l(v3, 0, "\n\topzpass = ");
          fprintf_l(v3, 0, (&off_264D9D540)[(*(void *)v142 >> 8) & 7]);
          fprintf_l(v3, 0, "\n\tbackfunc = ");
          int v158 = *v142 >> 29;
          uint64_t v159 = "PP_ALWAYS ";
          if (v158 != 7) {
            uint64_t v159 = (&off_264D9D580)[v158];
          }
          fprintf_l(v3, 0, v159);
          fprintf_l(v3, 0, "\n\tbackopfail = ");
          fprintf_l(v3, 0, (&off_264D9D540)[(*(void *)v142 >> 26) & 7]);
          fprintf_l(v3, 0, "\n\tbackopzfail = ");
          fprintf_l(v3, 0, (&off_264D9D540)[(*(void *)v142 >> 23) & 7]);
          fprintf_l(v3, 0, "\n\tbackopzpass = ");
          switch((*v142 >> 20) & 7)
          {
            case 1:
              fprintf_l(v3, 0, "PP_STENCIL_KEEP ", v168, v169);
              break;
            case 2:
              fprintf_l(v3, 0, "PP_STENCIL_REPLACE ", v168, v169);
              break;
            case 3:
              fprintf_l(v3, 0, "PP_STENCIL_INCR ", v168, v169);
              break;
            case 4:
              fprintf_l(v3, 0, "PP_STENCIL_DECR ", v168, v169);
              break;
            case 5:
              fprintf_l(v3, 0, "PP_STENCIL_INVERT ", v168, v169);
              break;
            case 6:
              fprintf_l(v3, 0, "PP_STENCIL_INCR_WRAP ", v168, v169);
              break;
            case 7:
              fprintf_l(v3, 0, "PP_STENCIL_DECR_WRAP ", v168, v169);
              break;
            default:
              fprintf_l(v3, 0, "PP_STENCIL_ZERO ", v168, v169);
              break;
          }
          goto LABEL_469;
        case 5:
          if ((*((unsigned char *)v142 + 3) & 0x10) != 0) {
            fprintf_l(v3, 0, "DEPTH_CLAMP ");
          }
          fprintf_l(v3, 0, "DEPTH_TEST func = ");
          switch(*v142 >> 29)
          {
            case 0:
LABEL_487:
              fprintf_l(v3, 0, "PP_NEVER ", v168, v169);
              break;
            case 1:
LABEL_508:
              fprintf_l(v3, 0, "PP_LESS ", v168, v169);
              break;
            case 2:
LABEL_509:
              fprintf_l(v3, 0, "PP_EQUAL ", v168, v169);
              break;
            case 3:
LABEL_510:
              fprintf_l(v3, 0, "PP_LEQUAL ", v168, v169);
              break;
            case 4:
LABEL_511:
              fprintf_l(v3, 0, "PP_GREATER ", v168, v169);
              break;
            case 5:
LABEL_512:
              fprintf_l(v3, 0, "PP_NOTEQUAL ", v168, v169);
              break;
            case 6:
LABEL_513:
              fprintf_l(v3, 0, "PP_GEQUAL ", v168, v169);
              break;
            default:
LABEL_507:
              fprintf_l(v3, 0, "PP_ALWAYS ", v168, v169);
              break;
          }
          goto LABEL_469;
        case 6:
          fprintf_l(v3, 0, "FRAGMENT_COUNT ENABLED ", v168, v169);
          goto LABEL_469;
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          fprintf_l(v3, 0, "BLENDING \n\talpha equ = ");
          unsigned int v149 = (*v142 >> 8) & 7;
          if (v149 <= 4) {
            fprintf_l(v3, 0, (&off_264D9D430)[v149]);
          }
          fprintf_l(v3, 0, "\n\trgb equ = ");
          unsigned int v150 = (*v142 >> 11) & 7;
          if (v150 <= 4) {
            fprintf_l(v3, 0, (&off_264D9D430)[v150]);
          }
          fprintf_l(v3, 0, "\n\tsrc = ");
          unint64_t v151 = (*(void *)v142 >> 47) & 0x1FLL;
          if (v151 <= 0x12) {
            fprintf_l(v3, 0, (&off_264D9D458)[v151]);
          }
          fprintf_l(v3, 0, "\n\tsrcA = ");
          unint64_t v152 = (*(void *)v142 >> 42) & 0x1FLL;
          if (v152 <= 0x12) {
            fprintf_l(v3, 0, (&off_264D9D458)[v152]);
          }
          fprintf_l(v3, 0, "\n\tdst = ");
          unint64_t v153 = (*(void *)v142 >> 37) & 0x1FLL;
          if (v153 <= 0x12) {
            fprintf_l(v3, 0, (&off_264D9D458)[v153]);
          }
          fprintf_l(v3, 0, "\n\tdstA = ");
          unint64_t v154 = HIDWORD(*(void *)v142) & 0x1FLL;
          if (v154 <= 0x12) {
            fprintf_l(v3, 0, (&off_264D9D458)[v154]);
          }
          fprintf_l(v3, 0, "\n\tBuffer = %d ");
          goto LABEL_469;
        case 16:
          fprintf_l(v3, 0, "DITHERING ENABLED", v168, v169);
          goto LABEL_469;
        case 17:
          fprintf_l(v3, 0, "LOGIC_OP ");
          switch(*v142 >> 28)
          {
            case 1:
              fprintf_l(v3, 0, "PP_LOGIC_SET", v168, v169);
              break;
            case 2:
              fprintf_l(v3, 0, "PP_LOGIC_COPY", v168, v169);
              break;
            case 3:
              fprintf_l(v3, 0, "PP_LOGIC_COPY_INVERTED", v168, v169);
              break;
            case 4:
              fprintf_l(v3, 0, "PP_LOGIC_NOOP", v168, v169);
              break;
            case 5:
              fprintf_l(v3, 0, "PP_LOGIC_INVERT", v168, v169);
              break;
            case 6:
              fprintf_l(v3, 0, "PP_LOGIC_AND", v168, v169);
              break;
            case 7:
              fprintf_l(v3, 0, "PP_LOGIC_NAND", v168, v169);
              break;
            case 8:
              fprintf_l(v3, 0, "PP_LOGIC_OR", v168, v169);
              break;
            case 9:
              fprintf_l(v3, 0, "PP_LOGIC_NOR", v168, v169);
              break;
            case 0xA:
              fprintf_l(v3, 0, "PP_LOGIC_XOR", v168, v169);
              break;
            case 0xB:
              fprintf_l(v3, 0, "PP_LOGIC_EQUIV", v168, v169);
              break;
            case 0xC:
              fprintf_l(v3, 0, "PP_LOGIC_AND_REVERSE", v168, v169);
              break;
            case 0xD:
              fprintf_l(v3, 0, "PP_LOGIC_AND_INVERTED", v168, v169);
              break;
            case 0xE:
              fprintf_l(v3, 0, "PP_LOGIC_OR_REVERSE", v168, v169);
              break;
            case 0xF:
              fprintf_l(v3, 0, "PP_LOGIC_OR_INVERTED");
              break;
            default:
              fprintf_l(v3, 0, "PP_LOGIC_CLEAR", v168, v169);
              break;
          }
          goto LABEL_469;
        case 18:
          fprintf_l(v3, 0, "BUFFER_MASK ");
          uint64_t v160 = *(void *)v142;
          if (HIBYTE(*(void *)v142) != 255)
          {
            fprintf_l(v3, 0, "RED MASK = 0x%0X ", HIBYTE(*(void *)v142));
            uint64_t v160 = *(void *)v142;
          }
          if (BYTE6(v160) != 255)
          {
            fprintf_l(v3, 0, "GREEN MASK = 0x%0X ", BYTE6(v160));
            uint64_t v160 = *(void *)v142;
          }
          if (BYTE5(v160) != 255)
          {
            fprintf_l(v3, 0, "BLUE MASK = 0x%0X ", BYTE5(v160));
            uint64_t v160 = *(void *)v142;
          }
          if (BYTE4(v160) != 255)
          {
            fprintf_l(v3, 0, "ALPHA MASK = 0x%0X ", BYTE4(v160));
            uint64_t v160 = *(void *)v142;
          }
          if ((v160 & 0x1000000) == 0)
          {
            fprintf_l(v3, 0, "DEPTH MASK = 0 ");
            uint64_t v160 = *(void *)v142;
          }
          if ((~v160 & 0xFFFF00) != 0) {
            fprintf_l(v3, 0, "STENCIL MASK = 0x%0X STENCIL BACK MASK = 0x%0X ");
          }
          goto LABEL_469;
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
          fprintf_l(v3, 0, "BUFFER_CONFIG ");
          unint64_t v144 = *(void *)v142;
          if ((*(void *)v142 & 0x4000) != 0)
          {
            fprintf_l(v3, 0, "sRGB ");
            unint64_t v144 = *(void *)v142;
          }
          uint64_t v145 = ((v144 >> 8) & 0xF) - 1;
          uint64_t v146 = "unknown type ";
          if (v145 <= 9) {
            uint64_t v146 = (&off_264D9D4F0)[v145];
          }
          fprintf_l(v3, 0, v146);
          uint64_t v147 = *(void *)v142;
          uint64_t v148 = (*(void *)v142 >> 40) & 3;
          if (v148)
          {
            fprintf_l(v3, 0, "samplescale %d ", v148 + 1);
            uint64_t v147 = *(void *)v142;
          }
          if ((v147 & 0x1000) != 0)
          {
            fprintf_l(v3, 0, "Texture layout ");
            uint64_t v147 = *(void *)v142;
          }
          fprintf_l(v3, 0, "Width %d", v147 >> 15);
          fprintf_l(v3, 0, " Height %d");
          goto LABEL_469;
        default:
          goto LABEL_469;
      }
      break;
    }
  }
  if (v179) {
    free(v179);
  }
  if (v177) {
    free(v177);
  }
  if (v175) {
    free(v175);
  }
  if (sizea) {
    free(sizea);
  }
  int v161 = v172[22];
  if (v161 >= 1)
  {
    uint64_t v162 = 0;
    uint64_t v163 = &v172[2 * v172[23]];
    do
    {
      uint64_t v164 = &v163[2 * v162];
      fprintf_l(v3, 0, "TEXIMAGE[%d] ", *v164 & 0x7F);
      if ((*(void *)v164 & 0x400000000000000) != 0) {
        fprintf_l(v3, 0, "valid; ");
      }
      else {
        fprintf_l(v3, 0, "invalid; ");
      }
      fprintf_l(v3, 0, "mag filter = %s", (&glpPPDisassemble_tex_filters)[(*(void *)v164 >> 44) & 1]);
      fprintf_l(v3, 0, "; min filter = %s", (&glpPPDisassemble_tex_filters)[(*(void *)v164 >> 45) & 7]);
      fprintf_l(v3, 0, "; wrap(s,t,r) = (%s%s%s",
        (&glpPPDisassemble_tex_wraps)[HIWORD(*(void *)v164) & 7],
        (&glpPPDisassemble_tex_wraps)[(*(void *)v164 >> 51) & 7],
        (&glpPPDisassemble_tex_wraps)[(*(void *)v164 >> 54) & 7]);
      fprintf_l(v3, 0, "); border = %d", (*(void *)v164 & 0x200000000000000) != 0);
      fprintf_l(v3, 0, "; compare func = ");
      int v165 = (v164[2] >> 18) & 7;
      uint64_t v166 = "PP_ALWAYS ";
      if (v165 != 7) {
        uint64_t v166 = (&off_264D9D580)[v165];
      }
      fprintf_l(v3, 0, v166);
      fprintf_l(v3, 0, "; depth mode = %s", (&glpPPDisassemble_tex_formats)[(*((void *)v164 + 1) >> 21) & 3]);
      fprintf_l(v3, 0, "; format = ");
      if (((v164[2] >> 23) & 0x1Fu) < 0x1D) {
        fprintf_l(v3, 0, "%s");
      }
      else {
        fprintf_l(v3, 0, "unknown %d");
      }
      fprintf_l(v3, 0, "; type = ");
      if (v164[2] >> 30 == 3) {
        fprintf_l(v3, 0, "unknown %d");
      }
      else {
        fprintf_l(v3, 0, "%s");
      }
      fprintf_l(v3, 0, ";\n");
      v162 += 2;
    }
    while (v161 > (int)v162);
  }
  LOBYTE(__ptr) = 0;
  fwrite(&__ptr, 1uLL, 1uLL, v3);
  fclose(v3);
  return v190[0];
}

uint64_t writefn(char **a1, void *__src, uint64_t a3)
{
  int v6 = *((_DWORD *)a1 + 2);
  unsigned int v7 = *((_DWORD *)a1 + 3);
  int v8 = v6 + a3;
  uint64_t v9 = *a1;
  if (v6 + (int)a3 > v7)
  {
    size_t v10 = (3 * (v7 + a3)) >> 1;
    *((_DWORD *)a1 + 3) = v10;
    uint64_t v9 = (char *)malloc_type_realloc(v9, v10, 0x2BDC8648uLL);
    if (!v9) {
      abort();
    }
    *a1 = v9;
    int v6 = *((_DWORD *)a1 + 2);
  }
  memcpy(&v9[v6], __src, (int)a3);
  *((_DWORD *)a1 + 2) = v8;
  return a3;
}

uint64_t glpWriteSizeTypePrecision(FILE *a1, int a2, unsigned int a3, int a4)
{
  uint64_t result = fprintf_l(a1, 0, ":%d", a2 + 1);
  if (a3 <= 4) {
    uint64_t result = fprintf_l(a1, 0, (&off_264D9D5B8)[a3]);
  }
  if ((a4 - 1) <= 2)
  {
    int v8 = (&off_264D9D5E0)[a4 - 1];
    return fprintf_l(a1, 0, v8);
  }
  return result;
}

FILE *glpWriteOperandSize(FILE *result, int a2, int a3)
{
  uint64_t v4 = result;
  if (a2 != 3 || a3)
  {
    uint64_t result = (FILE *)fprintf_l(result, 0, ":%d", a2 + 1);
    if (a3) {
      return (FILE *)fprintf_l(v4, 0, ":%d", a3 + 1);
    }
  }
  return result;
}

unint64_t defaultHashFunction(unint64_t a1)
{
  return a1 >> 3;
}

uint64_t defaultEqualsFunction(int a1, int a2)
{
  return (a1 - a2);
}

void *HashSetNew(unsigned int a1, unint64_t (*a2)(unint64_t a1), uint64_t (*a3)(int a1, int a2))
{
  int v6 = malloc_type_malloc(0x20uLL, 0x7081ABB9uLL);
  if (!v6) {
    goto LABEL_14;
  }
  unsigned int v7 = v6;
  int v8 = a2 ? a2 : defaultHashFunction;
  uint64_t v9 = a3 ? a3 : defaultEqualsFunction;
  v6[2] = v8;
  v6[3] = v9;
  *((_DWORD *)v6 + 1) = a1;
  size_t v10 = malloc_type_malloc(16 * a1, 0x7081ABB9uLL);
  if (!v10) {
    goto LABEL_14;
  }
  v7[1] = v10;
  if (*((_DWORD *)v7 + 1))
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    while (1)
    {
      uint64_t v13 = v7[1];
      *(_DWORD *)(v13 + v11) = 0;
      int v14 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
      if (!v14) {
        break;
      }
      *(void *)(v13 + v11 + 8) = v14;
      ++v12;
      v11 += 16;
      if (v12 >= *((unsigned int *)v7 + 1)) {
        goto LABEL_13;
      }
    }
LABEL_14:
    abort();
  }
LABEL_13:
  *(_DWORD *)unsigned int v7 = 0;
  return v7;
}

void HashSetFree(void *a1)
{
  unint64_t v2 = *((unsigned int *)a1 + 1);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 8;
    do
    {
      BOOL v5 = *(void **)(a1[1] + v4);
      if (v5)
      {
        free(v5);
        unint64_t v2 = *((unsigned int *)a1 + 1);
      }
      ++v3;
      v4 += 16;
    }
    while (v3 < v2);
  }
  int v6 = (void *)a1[1];
  if (v6) {
    free(v6);
  }

  free(a1);
}

uint64_t HashSetAdd(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(a1 + 16))(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (int)(v4 % *(_DWORD *)(a1 + 4));
  unsigned int v7 = (unsigned int *)(v5 + 16 * v6);
  unsigned int v8 = *v7;
  if (*v7)
  {
    unint64_t v9 = 0;
    size_t v10 = (uint64_t *)(v5 + 16 * v6 + 8);
    int v11 = -1;
    do
    {
      uint64_t v12 = *v10;
      uint64_t v13 = *(void *)(*v10 + 8 * v9);
      if (v13)
      {
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a1 + 24))(v13, a2))
        {
          *(void *)(v12 + 8 * v9) = a2;
          return a1;
        }
        unsigned int v8 = *v7;
      }
      else if (v11 == -1)
      {
        int v11 = v9;
      }
      ++v9;
    }
    while (v9 < v8);
    if (v11 == -1) {
      goto LABEL_11;
    }
    int v14 = (char *)(*v10 + 8 * v11);
  }
  else
  {
LABEL_11:
    unsigned int v15 = v8 + 1;
    *unsigned int v7 = v15;
    uint64_t v16 = v5 + 16 * v6;
    uint64_t v18 = *(void **)(v16 + 8);
    int v17 = (void *)(v16 + 8);
    uint64_t v19 = (char *)malloc_type_realloc(v18, 8 * v15, 0x2BDC8648uLL);
    if (!v19) {
      abort();
    }
    *int v17 = v19;
    int v14 = &v19[8 * *v7 - 8];
  }
  *(void *)int v14 = a2;
  ++*(_DWORD *)a1;
  return a1;
}

uint64_t HashSetGet(uint64_t a1, uint64_t a2)
{
  signed int v4 = (*(unsigned int (**)(uint64_t))(a1 + 16))(a2) % *(_DWORD *)(a1 + 4);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (unsigned int *)(v5 + 16 * v4);
  unint64_t v7 = *v6;
  if (!v7) {
    return 0;
  }
  uint64_t v8 = 0;
  unint64_t v9 = (uint64_t *)(v5 + 16 * v4 + 8);
  while (1)
  {
    uint64_t v10 = *v9;
    uint64_t v11 = *(void *)(*v9 + 8 * v8);
    if (v11) {
      break;
    }
LABEL_6:
    if (++v8 >= v7) {
      return 0;
    }
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 24))(v11, a2))
  {
    unint64_t v7 = *v6;
    goto LABEL_6;
  }
  return *(void *)(v10 + 8 * v8);
}

uint64_t HashSetRemove(uint64_t a1, uint64_t a2)
{
  signed int v4 = (*(unsigned int (**)(uint64_t))(a1 + 16))(a2) % *(_DWORD *)(a1 + 4);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (unsigned int *)(v5 + 16 * v4);
  unint64_t v7 = *v6;
  if (!v7) {
    return 0;
  }
  uint64_t v8 = 0;
  unint64_t v9 = (uint64_t *)(v5 + 16 * v4 + 8);
  while (1)
  {
    uint64_t v10 = *v9;
    uint64_t v11 = *(void *)(*v9 + 8 * v8);
    if (v11) {
      break;
    }
LABEL_6:
    if (++v8 >= v7) {
      return 0;
    }
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 24))(v11, a2))
  {
    unint64_t v7 = *v6;
    goto LABEL_6;
  }
  uint64_t result = *(void *)(v10 + 8 * v8);
  *(void *)(v10 + 8 * v8) = 0;
  --*(_DWORD *)a1;
  return result;
}

uint64_t HashSetIteratorSetup(uint64_t result, void *a2)
{
  *a2 = result;
  a2[1] = 0;
  return result;
}

uint64_t HashSetIteratorNext(unsigned int *a1)
{
  uint64_t v1 = *(unsigned int *)(*(void *)a1 + 4);
  uint64_t v2 = a1[2];
  if (v2 >= v1) {
    return 0;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 8);
  for (unsigned int i = a1[3]; ; unsigned int i = 0)
  {
    unsigned int v5 = *(_DWORD *)(v3 + 16 * v2);
    if (i < v5) {
      break;
    }
LABEL_8:
    *((void *)a1 + 1) = ++v2;
    if (v2 == v1) {
      return 0;
    }
  }
  uint64_t v6 = (uint64_t *)(*(void *)(v3 + 16 * v2 + 8) + 8 * i);
  while (1)
  {
    uint64_t v7 = *v6;
    ++i;
    if (*v6) {
      break;
    }
    ++v6;
    if (v5 == i)
    {
      a1[3] = i;
      goto LABEL_8;
    }
  }
  a1[3] = i;
  return v7;
}

void *HashTableNew(unsigned int a1, unint64_t (*a2)(unint64_t a1), uint64_t (*a3)(int a1, int a2))
{
  uint64_t v6 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
  if (!v6) {
    abort();
  }
  uint64_t v7 = v6;
  *uint64_t v6 = HashSetNew(a1, a2, a3);
  return v7;
}

void HashTableFree(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = *(unsigned int *)(*a1 + 4);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      unsigned int v5 = (unsigned int *)(*(void *)(v2 + 8) + 16 * i);
      unint64_t v6 = *v5;
      if (v6)
      {
        for (unint64_t j = 0; j < v6; ++j)
        {
          uint64_t v8 = *(void **)(*((void *)v5 + 1) + 8 * j);
          if (v8)
          {
            free(v8);
            unint64_t v6 = *v5;
          }
        }
        unint64_t v3 = *(unsigned int *)(v2 + 4);
      }
    }
    uint64_t v2 = *a1;
  }
  HashSetFree((void *)v2);

  free(a1);
}

uint64_t *HashTableAdd(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = a1;
  uint64_t v6 = *a1;
  unsigned int v7 = (*(uint64_t (**)(uint64_t))(*a1 + 16))(a2);
  uint64_t v8 = *(void *)(v6 + 8);
  uint64_t v9 = (int)(v7 % *(_DWORD *)(v6 + 4));
  uint64_t v10 = (unsigned int *)(v8 + 16 * v9);
  unsigned int v11 = *v10;
  if (*v10)
  {
    uint64_t v29 = v5;
    uint64_t v30 = a3;
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    int v14 = (uint64_t *)(v8 + 16 * v9 + 8);
    int v15 = -1;
    do
    {
      uint64_t v16 = *v14;
      int v17 = *(void **)(*v14 + v12);
      if (v17)
      {
        if (!(*(unsigned int (**)(void, uint64_t))(v6 + 24))(*v17, a2))
        {
          uint64_t v20 = (char *)(v16 + v12);
          uint64_t v19 = *(void **)(v16 + v12);
          unsigned int v5 = v29;
          a3 = v30;
          goto LABEL_17;
        }
        unsigned int v11 = *v10;
      }
      else if (v15 == -1)
      {
        int v15 = v13;
      }
      ++v13;
      v12 += 8;
    }
    while (v13 < v11);
    unsigned int v5 = v29;
    a3 = v30;
    if (v15 != -1)
    {
      uint64_t v18 = *v14;
      uint64_t v19 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
      if (v19)
      {
        uint64_t v20 = (char *)(v18 + 8 * v15);
        goto LABEL_15;
      }
LABEL_18:
      abort();
    }
  }
  unsigned int v21 = v11 + 1;
  *uint64_t v10 = v21;
  uint64_t v22 = v8 + 16 * v9;
  uint64_t v24 = *(void **)(v22 + 8);
  uint64_t v23 = (char **)(v22 + 8);
  int v25 = (char *)malloc_type_realloc(v24, 8 * v21, 0x2BDC8648uLL);
  if (!v25) {
    goto LABEL_18;
  }
  int v26 = v25;
  *uint64_t v23 = v25;
  unsigned int v27 = *v10;
  uint64_t v19 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v20 = &v26[8 * v27 - 8];
LABEL_15:
  *(void *)uint64_t v20 = v19;
LABEL_17:
  *uint64_t v19 = a2;
  *(void *)(*(void *)v20 + 8) = a3;
  return v5;
}

uint64_t HashTableGet(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  signed int v4 = (*(unsigned int (**)(uint64_t))(*a1 + 16))(a2) % *(_DWORD *)(v3 + 4);
  uint64_t v5 = *(void *)(v3 + 8);
  uint64_t v6 = (unsigned int *)(v5 + 16 * v4);
  unint64_t v7 = *v6;
  if (!v7) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = (uint64_t *)(v5 + 16 * v4 + 8);
  while (1)
  {
    uint64_t v10 = *v9;
    unsigned int v11 = *(void **)(*v9 + 8 * v8);
    if (v11) {
      break;
    }
LABEL_6:
    if (++v8 >= v7) {
      return 0;
    }
  }
  if ((*(unsigned int (**)(void, uint64_t))(v3 + 24))(*v11, a2))
  {
    unint64_t v7 = *v6;
    goto LABEL_6;
  }
  return *(void *)(*(void *)(v10 + 8 * v8) + 8);
}

uint64_t BuildGenKill(uint64_t result)
{
  if (*(_DWORD *)(result + 32))
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    uint64_t v19 = result;
    do
    {
      uint64_t v3 = *(void *)(v1 + 8);
      uint64_t v20 = v2;
      signed int v4 = (unsigned int *)(v3 + 80 * v2);
      *((void *)v4 + 8) = BitSetNew(*(_DWORD *)(v1 + 36));
      *((void *)v4 + 9) = BitSetNew(*(_DWORD *)(v1 + 36));
      uint64_t v5 = (uint64_t *)(v4 + 18);
      uint64_t result = BitSetNew(*(_DWORD *)(v1 + 36));
      *((void *)v4 + 5) = result;
      if (*v4)
      {
        unint64_t v6 = 0;
        unint64_t v7 = (uint64_t *)(v3 + 80 * v20 + 16);
        do
        {
          uint64_t v8 = *v7;
          uint64_t v9 = (unsigned int *)(*v7 + 40 * v6);
          if (!v9[3])
          {
            unint64_t v10 = *v9;
            if (v10)
            {
              for (unint64_t i = 0; i < v10; ++i)
              {
                uint64_t v12 = *(unsigned int **)(*(void *)(v8 + 40 * v6 + 16) + 8 * i);
                if (!v12[8])
                {
                  uint64_t result = BitSetGetEquals(*v5, *v12);
                  if (!result) {
                    uint64_t result = BitSetSetEquals(*((void *)v4 + 8), *v12);
                  }
                  ++v12[11];
                  unint64_t v10 = *v9;
                }
              }
            }
            uint64_t v13 = v8 + 40 * v6;
            unsigned int v16 = *(_DWORD *)(v13 + 4);
            int v15 = (unsigned int *)(v13 + 4);
            unint64_t v14 = v16;
            if (v16)
            {
              unint64_t v17 = 0;
              do
              {
                uint64_t v18 = *(unsigned int **)(*(void *)(v8 + 40 * v6 + 24) + 8 * v17);
                if (!v18[8])
                {
                  uint64_t result = BitSetSetEquals(*v5, *v18);
                  ++v18[11];
                  unint64_t v14 = *v15;
                }
                ++v17;
              }
              while (v17 < v14);
            }
          }
          ++v6;
        }
        while (v6 < *v4);
      }
      uint64_t v1 = v19;
      uint64_t v2 = v20 + 1;
    }
    while (v20 + 1 < (unint64_t)*(unsigned int *)(v19 + 32));
  }
  return result;
}

uint64_t BuildLiveOut(uint64_t result)
{
  uint64_t v1 = result;
  LODWORD(v2) = *(_DWORD *)(result + 32);
  do
  {
    if (!v2) {
      break;
    }
    unint64_t v3 = 0;
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v1 + 8);
      uint64_t v6 = v5 + 80 * v3;
      unint64_t v7 = (uint64_t *)(v6 + 40);
      uint64_t v8 = (uint64_t *)BitSetClone(*(void *)(v6 + 40));
      int v10 = *(_DWORD *)(v6 + 8);
      uint64_t v9 = (unsigned int *)(v6 + 8);
      if (v10)
      {
        unint64_t v11 = 0;
        uint64_t v12 = (void *)(v5 + 80 * v3 + 32);
        do
        {
          uint64_t v13 = *(uint64_t **)(*v12 + 8 * v11);
          unint64_t v14 = (uint64_t *)BitSetClone(v13[5]);
          BitSetAndNotEquals((uint64_t)v14, v13[9]);
          BitSetOrEquals((uint64_t)v14, v13[8]);
          BitSetOrEquals(*v7, (uint64_t)v14);
          BitSetFree(v14);
          ++v11;
        }
        while (v11 < *v9);
      }
      v4 |= BitSetEqualsTest((uint64_t)v8, *v7) == 0;
      uint64_t result = BitSetFree(v8);
      ++v3;
      unint64_t v2 = *(unsigned int *)(v1 + 32);
    }
    while (v3 < v2);
  }
  while (v4);
  return result;
}

uint64_t BuildInterferenceSets(uint64_t result)
{
  if (*(_DWORD *)(result + 32))
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(v1 + 8);
      uint64_t v26 = v2;
      uint64_t v4 = v3 + 80 * v2;
      uint64_t v5 = (uint64_t *)BitSetClone(*(void *)(v4 + 40));
      unsigned int v6 = *(_DWORD *)v4 - 1;
      if ((v6 & 0x80000000) == 0)
      {
        unint64_t v7 = (void *)(v3 + 80 * v26 + 16);
        unsigned int v27 = v7;
        do
        {
          int v8 = v6;
          uint64_t v9 = (unsigned int *)(*v7 + 40 * v6);
          if (!v9[3])
          {
            uint64_t v28 = *v7;
            unsigned int v29 = v6;
            uint64_t v10 = *v7 + 40 * v6;
            int v12 = *(_DWORD *)(v10 + 4);
            unint64_t v11 = (_DWORD *)(v10 + 4);
            if (v12)
            {
              unint64_t v13 = 0;
              unint64_t v14 = (void *)(v28 + 40 * v6 + 24);
              do
              {
                uint64_t v15 = *(void *)(*v14 + 8 * v13);
                if (!*(_DWORD *)(v15 + 32))
                {
                  for (int i = BitSetFirstSetBit((uint64_t)v5); i != -1; int i = BitSetNextSetBit((uint64_t)v5, v19))
                  {
                    uint64_t v18 = *(void *)(v1 + 16);
                    int v19 = i;
                    if (!*(_DWORD *)(v18 + 56 * i + 32))
                    {
                      uint64_t v20 = v18 + 56 * i;
                      BitSetSetEquals(*(void *)(v15 + 8), *(_DWORD *)v20);
                      BitSetSetEquals(*(void *)(v20 + 8), *(_DWORD *)v15);
                    }
                  }
                }
                ++v13;
                unint64_t v16 = *v11;
              }
              while (v13 < v16);
              unint64_t v7 = v27;
              if (*v11)
              {
                unint64_t v21 = 0;
                do
                {
                  uint64_t v22 = *(unsigned int **)(*v14 + 8 * v21);
                  if (!v22[8])
                  {
                    BitSetClearEquals((uint64_t)v5, *v22);
                    unint64_t v16 = *v11;
                  }
                  ++v21;
                }
                while (v21 < v16);
              }
            }
            unint64_t v23 = *v9;
            int v8 = v29;
            if (v23)
            {
              for (unint64_t j = 0; j < v23; ++j)
              {
                int v25 = *(unsigned int **)(*(void *)(v28 + 40 * v29 + 16) + 8 * j);
                if (!v25[8])
                {
                  BitSetSetEquals((uint64_t)v5, *v25);
                  unint64_t v23 = *v9;
                }
              }
            }
          }
          unsigned int v6 = v8 - 1;
        }
        while (v8 > 0);
      }
      uint64_t result = BitSetFree(v5);
      uint64_t v2 = v26 + 1;
    }
    while (v26 + 1 < (unint64_t)*(unsigned int *)(v1 + 32));
  }
  return result;
}

void RegistersMerge(uint64_t a1)
{
  uint64_t v2 = HashTableNew((*(_DWORD *)(a1 + 36) >> 5) + 1, 0, 0);
  uint64_t v3 = malloc_type_malloc(0x20uLL, 0x7081ABB9uLL);
  if (!v3 || (uint64_t v4 = (char *)malloc_type_realloc(v3, 0x20uLL, 0x2BDC8648uLL)) == 0) {
LABEL_26:
  }
    abort();
  uint64_t v5 = v4;
  uint64_t v6 = 0;
  for (uint64_t i = 0; i != 32; i += 8)
  {
    *(void *)&v4[i] = *(void *)(a1 + 16) + v6;
    v6 += 56;
  }
  uint64_t v28 = v2;
  if (*(_DWORD *)(a1 + 36) >= 5u)
  {
    unint64_t v8 = 4;
    unsigned int v9 = 1;
    do
    {
      int8x16_t v10 = (int8x16_t)vdupq_n_s64(v8);
      int64x2_t v11 = (int64x2_t)vorrq_s8(v10, (int8x16_t)xmmword_2393D2C80);
      v11.i64[0] = 56 * v8;
      v11.i64[1] *= 56;
      int v12 = (const double *)(a1 + 16);
      int64x2_t v13 = (int64x2_t)vld1q_dup_f64(v12);
      int64x2_t v14 = (int64x2_t)vorrq_s8(v10, (int8x16_t)xmmword_2393DBD40);
      v14.i64[0] *= 56;
      v14.i64[1] *= 56;
      int64x2_t v29 = vaddq_s64(v13, v11);
      int64x2_t v30 = vaddq_s64(v13, v14);
      if (RegisterVectorIsFixed(&v29) || !v9)
      {
LABEL_12:
        uint64_t v18 = (char *)malloc_type_realloc(v5, 32 * (v9 + 1), 0x2BDC8648uLL);
        if (!v18) {
          goto LABEL_26;
        }
        uint64_t v5 = v18;
        int64x2_t v19 = v30;
        uint64_t v20 = (int64x2_t *)&v18[32 * v9];
        *uint64_t v20 = v29;
        v20[1] = v19;
        ++v9;
      }
      else
      {
        uint64_t v15 = 0;
        unint64_t v16 = (unsigned int **)v5;
        while (1)
        {
          unint64_t v17 = (uint64_t *)&v5[32 * v15];
          if (RegisterVectorCanMerge(v17, (unsigned int **)&v29)) {
            break;
          }
          ++v15;
          v16 += 4;
          if (v15 == v9) {
            goto LABEL_12;
          }
        }
        for (uint64_t j = 0; j != 4; ++j)
        {
          uint64_t v22 = v29.i64[j];
          BitSetOrEquals(*((void *)*v16 + 1), *(void *)(v22 + 8));
          unint64_t v23 = *v16;
          v23[11] = (*v16)[11] + *(_DWORD *)(v22 + 44);
          *(_DWORD *)(v22 + 32) = 1;
          RegistersReInterfere(a1, v22, v23);
          uint64_t v24 = (uint64_t)*v16++;
          HashTableAdd(v28, v22, v24);
        }
        if (*(_DWORD *)(*v17 + 28) == 1 && *(_DWORD *)(v29.i64[0] + 28) == 1)
        {
          uint64_t v25 = *(void *)(*v17 + 48);
          uint64_t v26 = *(void *)(v25 + 24);
          unsigned int v27 = *(_DWORD *)(*(void *)(v29.i64[0] + 48) + 24) >> 6;
          if (v26 >> 6 > v27) {
            unsigned int v27 = v26 >> 6;
          }
          *(void *)(v25 + 24) = v26 & 0xFFFFFFFFFFFFFF3FLL | (v27 << 6);
        }
      }
      v8 += 4;
    }
    while (v8 < *(unsigned int *)(a1 + 36));
  }
  free(v5);
  RegistersReplace((_DWORD *)a1, v28);

  HashTableFree(v28);
}

BOOL RegisterVectorIsFixed(void *a1)
{
  uint64_t v1 = *a1;
  if (*(_DWORD *)(*a1 + 36)) {
    return 1;
  }
  if (*(_DWORD *)(v1 + 40)) {
    return 1;
  }
  if (*(_DWORD *)(v1 + 20) == 4) {
    return 1;
  }
  uint64_t v2 = (_DWORD *)a1[1];
  if (v2[9]) {
    return 1;
  }
  if (v2[10]) {
    return 1;
  }
  if (v2[5] == 4) {
    return 1;
  }
  uint64_t v3 = (_DWORD *)a1[2];
  if (v3[9]) {
    return 1;
  }
  if (v3[10]) {
    return 1;
  }
  if (v3[5] == 4) {
    return 1;
  }
  uint64_t v4 = (_DWORD *)a1[3];
  return v4[9] || v4[10] || v4[5] == 4;
}

BOOL RegisterVectorCanMerge(uint64_t *a1, unsigned int **a2)
{
  if (!RegisterCanMerge(*a1, *a2) || !RegisterCanMerge(a1[1], a2[1]) || !RegisterCanMerge(a1[2], a2[2])) {
    return 0;
  }
  uint64_t v4 = a1[3];
  uint64_t v5 = a2[3];

  return RegisterCanMerge(v4, v5);
}

uint64_t RegistersReInterfere(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  for (uint64_t result = BitSetFirstSetBit(*(void *)(a2 + 8));
        result != -1;
        uint64_t result = BitSetNextSetBit(*(void *)(a2 + 8), v8))
  {
    uint64_t v7 = *(void *)(a1 + 16);
    int v8 = result;
    if (!*(_DWORD *)(v7 + 56 * (int)result + 32))
    {
      uint64_t v9 = v7 + 56 * (int)result;
      BitSetClearEquals(*(void *)(v9 + 8), *(_DWORD *)a2);
      BitSetSetEquals(*(void *)(v9 + 8), *a3);
    }
  }
  return result;
}

_DWORD *RegistersReplace(_DWORD *result, uint64_t *a2)
{
  uint64_t v40 = result;
  uint64_t v3 = **(void ***)(*(void *)result + 104);
  if (v3)
  {
    uint64_t v4 = result + 15;
    uint64_t v5 = result + 11;
    uint64_t v6 = result + 16;
    uint64_t v38 = result + 14;
    int v39 = result + 20;
    int v36 = result + 12;
    uint64_t v37 = result + 19;
    int v35 = result + 17;
    uint64_t v7 = result + 13;
    int v8 = result + 18;
    do
    {
      uint64_t v9 = v3[3] & 7;
      if (v9)
      {
        uint64_t v10 = 0;
        int64x2_t v11 = v3 + 5;
        do
        {
          if (v10 < (v3[3] & 7) + ((__int16)*((_DWORD *)v3 + 6) >> 15))
          {
            unint64_t v12 = v11[v10];
            int64x2_t v13 = v7;
            int64x2_t v14 = v8;
            switch((v12 >> 6) & 7)
            {
              case 0u:
                goto LABEL_11;
              case 1u:
                int64x2_t v14 = v35;
                int64x2_t v13 = v36;
                goto LABEL_11;
              case 2u:
                int64x2_t v14 = v37;
                int64x2_t v13 = v38;
                goto LABEL_11;
              case 3u:
              case 5u:
                int64x2_t v13 = v5;
                int64x2_t v14 = v6;
                goto LABEL_11;
              case 4u:
                int64x2_t v13 = v4;
                int64x2_t v14 = v39;
LABEL_11:
                unsigned int v15 = *v13 + ((v12 >> 46) & 0x3FFFC);
                if (v15 < *v14)
                {
                  uint64_t v16 = *((void *)v40 + 2);
                  if (v16)
                  {
                    uint64_t result = (_DWORD *)HashTableGet(a2, v16 + 56 * v15);
                    if (result)
                    {
                      unint64_t v17 = v11[v10] & 0xFFFFFFFFFFFFFE3FLL | ((unint64_t)(result[7] & 7) << 6);
                      v11[v10] = v17;
                      v11[v10] = v17 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)result[1] << 48);
                    }
                  }
                }
                break;
              default:
                break;
            }
          }
          ++v10;
        }
        while (v9 != v10);
      }
      unint64_t v18 = v3[4];
      int64x2_t v19 = v7;
      uint64_t v20 = v8;
      switch((v18 >> 12) & 7)
      {
        case 0u:
          goto LABEL_21;
        case 1u:
          uint64_t v20 = v35;
          int64x2_t v19 = v36;
          goto LABEL_21;
        case 2u:
          uint64_t v20 = v37;
          int64x2_t v19 = v38;
          goto LABEL_21;
        case 3u:
        case 5u:
          int64x2_t v19 = v5;
          uint64_t v20 = v6;
          goto LABEL_21;
        case 4u:
          int64x2_t v19 = v4;
          uint64_t v20 = v39;
LABEL_21:
          unsigned int v21 = *v19 + ((v18 >> 46) & 0x3FFFC);
          if (v21 < *v20)
          {
            uint64_t v22 = *((void *)v40 + 2);
            if (v22)
            {
              uint64_t result = (_DWORD *)HashTableGet(a2, v22 + 56 * v21);
              if (result)
              {
                unint64_t v23 = v3[4] & 0xFFFFFFFFFFFF8FFFLL | ((unint64_t)(result[7] & 7) << 12);
                v3[4] = v23;
                v3[4] = v23 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)result[1] << 48);
              }
            }
          }
          break;
        default:
          break;
      }
      uint64_t v3 = (void *)v3[1];
    }
    while (v3);
  }
  unint64_t v24 = v40[8];
  if (v24)
  {
    for (unint64_t i = 0; i < v24; ++i)
    {
      uint64_t v26 = *((void *)v40 + 1);
      unsigned int v27 = (_DWORD *)(v26 + 80 * i);
      if (*v27)
      {
        unint64_t v28 = 0;
        int64x2_t v29 = (void *)(v26 + 80 * i + 16);
        do
        {
          if (!*(_DWORD *)(*v29 + 40 * v28 + 12))
          {
            int64x2_t v30 = (unsigned int *)(*v29 + 40 * v28);
            uint64_t v31 = *v30;
            uint64_t v32 = v30[1];
            unint64_t v33 = (uint64_t *)*((void *)v30 + 3);
            if (v31)
            {
              uint64_t v34 = (uint64_t *)*((void *)v30 + 2);
              do
              {
                uint64_t result = (_DWORD *)HashTableGet(a2, *v34);
                if (result) {
                  *uint64_t v34 = (uint64_t)result;
                }
                ++v34;
                --v31;
              }
              while (v31);
            }
            if (v32)
            {
              do
              {
                uint64_t result = (_DWORD *)HashTableGet(a2, *v33);
                if (result) {
                  *unint64_t v33 = (uint64_t)result;
                }
                ++v33;
                --v32;
              }
              while (v32);
            }
          }
          ++v28;
        }
        while (v28 < *v27);
        unint64_t v24 = v40[8];
      }
    }
  }
  return result;
}

uint64_t DeadCodeEliminationSimple(uint64_t result)
{
  if (*(_DWORD *)(result + 32))
  {
    uint64_t v1 = 0;
    uint64_t v24 = result;
    do
    {
      uint64_t v2 = *(void *)(result + 8);
      uint64_t v23 = v1;
      uint64_t v3 = v2 + 80 * v1;
      uint64_t v4 = (uint64_t *)BitSetClone(*(void *)(v3 + 40));
      int v5 = *(_DWORD *)v3 - 1;
      if (v5 >= 0)
      {
        uint64_t v6 = (uint64_t *)(v2 + 80 * v23 + 16);
        do
        {
          uint64_t v7 = *v6;
          unsigned int v8 = v5;
          uint64_t v9 = (unsigned int *)(*v6 + 40 * v5);
          if (!v9[3])
          {
            uint64_t v10 = v7 + 40 * v5;
            unint64_t v11 = *(unsigned int *)(v10 + 4);
            int v12 = *(_DWORD *)(v10 + 8);
            int64x2_t v13 = (unsigned int *)(v10 + 4);
            BOOL v14 = v12 == 0;
            if (v11) {
              BOOL v15 = v12 == 0;
            }
            else {
              BOOL v15 = 0;
            }
            if (v15)
            {
              unint64_t v16 = 0;
              do
              {
                unint64_t v17 = *(unsigned int **)(*(void *)(v7 + 40 * v8 + 24) + 8 * v16);
                if (v17[8])
                {
                  BOOL v14 = 1;
                }
                else
                {
                  BOOL v14 = BitSetGetEquals((uint64_t)v4, *v17) == 0;
                  unint64_t v11 = *v13;
                }
                ++v16;
              }
              while (v16 < v11 && v14);
            }
            if (v14)
            {
              PPStreamRemoveOperation(*(void *)v24, *(void **)(v7 + 40 * v8 + 32));
              v9[3] = 1;
            }
            else
            {
              if (v11)
              {
                for (unint64_t i = 0; i < v11; ++i)
                {
                  int64x2_t v19 = *(unsigned int **)(*(void *)(v7 + 40 * v8 + 24) + 8 * i);
                  if (!v19[8])
                  {
                    BitSetClearEquals((uint64_t)v4, *v19);
                    unint64_t v11 = *v13;
                  }
                }
              }
              unint64_t v20 = *v9;
              if (v20)
              {
                for (unint64_t j = 0; j < v20; ++j)
                {
                  uint64_t v22 = *(unsigned int **)(*(void *)(v7 + 40 * v8 + 16) + 8 * j);
                  if (!v22[8])
                  {
                    BitSetSetEquals((uint64_t)v4, *v22);
                    unint64_t v20 = *v9;
                  }
                }
              }
            }
          }
          int v5 = v8 - 1;
        }
        while ((int)v8 > 0);
      }
      BitSetFree(v4);
      uint64_t result = v24;
      uint64_t v1 = v23 + 1;
    }
    while (v23 + 1 < (unint64_t)*(unsigned int *)(v24 + 32));
  }
  return result;
}

uint64_t BackCopyPropagationSimple(uint64_t result)
{
  uint64_t v172 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 32))
  {
    uint64_t v1 = 0;
    uint64_t v151 = result;
    do
    {
      uint64_t v2 = *(void *)(result + 8);
      uint64_t v150 = v1;
      uint64_t v3 = v2 + 80 * v1;
      uint64_t v4 = (uint64_t *)BitSetClone(*(void *)(v3 + 40));
      unsigned int v5 = *(_DWORD *)v3 - 1;
      if ((v5 & 0x80000000) == 0)
      {
        unint64_t v154 = (uint64_t *)(v2 + 80 * v150 + 16);
        do
        {
          uint64_t v6 = *v154;
          uint64_t v7 = v5;
          unsigned int v8 = (unsigned int *)(*v154 + 40 * v5);
          uint64_t v155 = v8 + 3;
          if (!v8[3])
          {
            unsigned int v149 = (void **)(v6 + 40 * v5 + 32);
            uint64_t v152 = (*v149)[3] & 0x3FC0;
            if (v152)
            {
              int v9 = 0;
              *(void *)&long long v156 = 0;
            }
            else
            {
              uint64_t v10 = v6 + 40 * v5;
              unsigned int v13 = *(_DWORD *)(v10 + 4);
              int v12 = (unsigned int *)(v10 + 4);
              unint64_t v11 = v13;
              if (v13)
              {
                unint64_t v14 = 0;
                long long v156 = 0u;
                do
                {
                  uint64_t v15 = *(void *)(*(void *)(v6 + 40 * v7 + 24) + 8 * v14);
                  if (!*(_DWORD *)(v15 + 32))
                  {
                    BitSetGetEquals((uint64_t)v4, *(_DWORD *)v15);
                    *((void *)&v16 + 1) = *((void *)&v156 + 1);
                    *(int8x8_t *)&long long v16 = vorr_s8(*(int8x8_t *)(v15 + 36), *(int8x8_t *)&v156);
                    long long v156 = v16;
                    unint64_t v11 = *v12;
                  }
                  ++v14;
                }
                while (v14 < v11);
              }
              else
              {
                long long v156 = 0u;
              }
              unint64_t v17 = *v8;
              if (v17)
              {
                unint64_t v18 = 0;
                int v9 = 0;
                do
                {
                  uint64_t v19 = *(void *)(*(void *)(v6 + 40 * v7 + 16) + 8 * v18);
                  if (!*(_DWORD *)(v19 + 32))
                  {
                    for (int i = 0; i != 4; ++i)
                      v9 |= BitSetGetEquals((uint64_t)v4, i + (*(_DWORD *)v19 & 0xFFFFFFFC));
                    *((void *)&v21 + 1) = *((void *)&v156 + 1);
                    *(int8x8_t *)&long long v21 = vorr_s8(*(int8x8_t *)(v19 + 36), *(int8x8_t *)&v156);
                    long long v156 = v21;
                    unint64_t v17 = *v8;
                  }
                  ++v18;
                }
                while (v18 < v17);
              }
              else
              {
                int v9 = 0;
              }
            }
            uint64_t v22 = v6 + 40 * v7;
            unsigned int v25 = *(_DWORD *)(v22 + 4);
            uint64_t v24 = (unsigned int *)(v22 + 4);
            unint64_t v23 = v25;
            if (v25)
            {
              unint64_t v26 = 0;
              do
              {
                unsigned int v27 = *(unsigned int **)(*(void *)(v6 + 40 * v7 + 24) + 8 * v26);
                if (!v27[8])
                {
                  BitSetClearEquals((uint64_t)v4, *v27);
                  unint64_t v23 = *v24;
                }
                ++v26;
              }
              while (v26 < v23);
            }
            unint64_t v28 = *v8;
            if (v28)
            {
              unint64_t v29 = 0;
              int64x2_t v30 = (void *)(v6 + 40 * v7 + 16);
              do
              {
                uint64_t v31 = *(unsigned int **)(*v30 + 8 * v29);
                if (!v31[8])
                {
                  BitSetSetEquals((uint64_t)v4, *v31);
                  unint64_t v28 = *v8;
                }
                ++v29;
              }
              while (v29 < v28);
            }
            if (!v152 && !v9)
            {
              int32x2_t v32 = vtst_s32(*(int32x2_t *)&v156, *(int32x2_t *)&v156);
              if ((v32.i8[0] & 1) == 0 && (v32.i8[4] & 1) == 0)
              {
                uint64_t v145 = *(void *)(v151 + 8);
                uint64_t v33 = v145 + 80 * v150;
                uint64_t v35 = *(void *)(v33 + 16);
                uint64_t v34 = (void *)(v33 + 16);
                uint64_t v141 = v35 + 40 * v7;
                uint64_t v36 = *(void *)(v141 + 32);
                int8x16_t v171 = 0uLL;
                unint64_t v37 = *(void *)(v36 + 32);
                unint64_t v38 = *(void *)(v36 + 40);
                if ((((v38 >> 6) ^ (v37 >> 12)) & 7) != 0)
                {
                  int v144 = 0;
                }
                else if (HIWORD(v37) == HIWORD(v38) {
                       && (((v38 >> 17) ^ (v37 >> 19)) & 3) == 0)
                }
                {
                  switch((v38 >> 19) & 3)
                  {
                    case 1u:
                      goto LABEL_183;
                    case 2u:
                      goto LABEL_182;
                    case 3u:
                      unsigned int v136 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v38 >> 15) & 3)));
                      *v136 |= 1u;
LABEL_182:
                      unsigned int v137 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v38 >> 13) & 3)));
                      *v137 |= 1u;
LABEL_183:
                      BOOL v138 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v38 >> 11) & 3)));
                      *v138 |= 1u;
                      break;
                    default:
                      break;
                  }
                  uint64_t v139 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v38 >> 9) & 3)));
                  *v139 |= 1u;
                  int v144 = 1;
                }
                else
                {
                  int v144 = 0;
                }
                v170.i32[0] = (v37 >> 18) & 1;
                v170.i32[1] = (v37 >> 17) & 1;
                v170.i32[2] = WORD1(v37) & 1;
                v170.i32[3] = (v37 >> 15) & 1;
                __int32 v147 = v170.i32[2];
                __int32 v148 = v170.i32[1];
                __int32 v153 = v170.i32[0];
                __int32 v146 = v170.i32[3];
                int v39 = v170.i32[1] | v170.i32[2] | v170.i32[3] | v170.i32[0];
                if ((int)v7 >= 1 && v39)
                {
                  unint64_t v40 = v38 | HIDWORD(v37);
                  uint64_t v142 = (int *)(v145 + 80 * v150 + 12);
                  int v143 = v34;
                  int v39 = 1;
                  uint64_t v41 = v7;
                  do
                  {
                    uint64_t v42 = (unsigned int *)(*v34 + 40 * (v41 - 1));
                    if (v42[3])
                    {
                      char v43 = 0;
                    }
                    else
                    {
                      uint64_t v44 = *(void *)(*v34 + 40 * (v41 - 1) + 32);
                      uint64_t v45 = *(void *)(v44 + 24);
                      int v46 = (v45 >> 6);
                      unsigned int v47 = v46 - 119;
                      BOOL v50 = v46 == 76 || v47 < 3 || v46 == 170;
                      char v51 = v40 & (v46 == 72);
                      if (!v51)
                      {
                        BOOL v52 = v47 > 0x33;
                        uint64_t v53 = (1 << v47) & 0x8000000000007;
                        if ((v52 || v53 == 0) && v46 != 76)
                        {
                          unint64_t v98 = *(void *)(v36 + 40);
                          if ((v98 & 0x10) == 0)
                          {
                            unint64_t v99 = *(void *)(v44 + 32);
                            BOOL v100 = (((v99 >> 12) ^ (v98 >> 6)) & 7) == 0
                                && HIWORD(v99) == HIWORD(v98);
                            if (v100
                              && (((v99 >> 19) ^ (v98 >> 17)) & 3) == 0)
                            {
                              int8x16_t v169 = 0uLL;
                              uint32x4_t v102 = (uint32x4_t)vdupq_n_s32(v99);
                              v103.i64[0] = 0x300000003;
                              v103.i64[1] = 0x300000003;
                              int8x16_t v167 = vandq_s8((int8x16_t)vshlq_u32(v102, (uint32x4_t)xmmword_2393D1D40), v103);
                              long long v168 = xmmword_2393D21E0;
                              int32x4_t v104 = (int32x4_t)vshlq_u32(v102, (uint32x4_t)xmmword_2393DBD50);
                              v105.i64[0] = 0x100000001;
                              v105.i64[1] = 0x100000001;
                              int8x16_t v165 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v98), (uint32x4_t)xmmword_2393D1D30), v103);
                              int8x16_t v166 = vandq_s8((int8x16_t)v104, v105);
                              unint64_t v106 = *(void *)(v36 + 32);
                              int8x16_t v164 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v106), (uint32x4_t)xmmword_2393D1D40), v103);
                              int8x16_t v107 = vandq_s8(vbicq_s8((int8x16_t)vtstq_s32(v104, (int32x4_t)v105), (int8x16_t)vceqzq_s32((int32x4_t)v171)), v105);
                              if (!*(void *)&vorr_s8(vorr_s8((int8x8_t)((v99 >> 19) & 3 | BYTE4(v99) & 1 | ((int)(v99 >> 12) >> 24) | (unint64_t)((v45 & 0x3FC0) == 7040)), *(int8x8_t *)v107.i8), (int8x8_t)*(_OWORD *)&vextq_s8(v107, v107, 8uLL)))
                              {
                                unint64_t v108 = 0;
                                char v109 = 1;
LABEL_143:
                                uint64_t v110 = 3;
                                if (v108 > 3) {
                                  uint64_t v110 = v108;
                                }
                                uint64_t v111 = v110 + 1;
                                unint64_t v112 = v108;
                                do
                                {
                                  if (v170.i32[v112])
                                  {
                                    uint64_t v113 = v165.u32[v164.u32[v112]];
                                    if (v166.i32[v113])
                                    {
                                      char v109 = 0;
                                      v170.i32[v112] = 0;
                                      __int32 v148 = v170.i32[1];
                                      __int32 v153 = v170.i32[0];
                                      __int32 v146 = v170.i32[3];
                                      __int32 v147 = v170.i32[2];
                                      int v39 = v170.i32[1] | v170.i32[0] | v170.i32[2] | v170.i32[3];
                                      v169.i32[v112] = 1;
                                      *((_DWORD *)&v168 + v112) = v167.i32[v113];
                                      unint64_t v108 = v112 + 1;
                                      if (v112 <= 2) {
                                        goto LABEL_143;
                                      }
                                      goto LABEL_153;
                                    }
                                  }
                                  ++v112;
                                }
                                while (v111 != v112);
                                if (v109) {
                                  goto LABEL_64;
                                }
LABEL_153:
                                uint64_t v115 = 0;
                                int v116 = 0;
                                unint64_t v117 = v99 & 0xFFFFFFFEFFFFFFFFLL | ((HIDWORD(v106) & 1) << 32);
                                *(void *)(v44 + 32) = v117;
                                unint64_t v118 = v117 & 0xFFFFFFFDFFFFFFFFLL | (((*(void *)(v36 + 32) >> 33) & 1) << 33);
                                *(void *)(v44 + 32) = v118;
                                unint64_t v119 = v118 & 0xFFFFFFF3FFFFFFFFLL | (((*(void *)(v36 + 32) >> 34) & 3) << 34);
                                *(void *)(v44 + 32) = v119;
                                unint64_t v120 = v119 & 0xFFFFF00FFFFFFFFFLL | ((unint64_t)(*(void *)(v36 + 32) >> 36) << 36);
                                *(void *)(v44 + 32) = v120;
                                unint64_t v121 = v120 & 0xFFFFFFFFFFFF8FFFLL | (((*(void *)(v36 + 32) >> 12) & 7) << 12);
                                *(void *)(v44 + 32) = v121;
                                unint64_t v122 = v121 & 0xFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int16 *)(v36 + 38) << 48);
                                *(void *)(v44 + 32) = v122;
                                unsigned int v123 = (v99 >> 21) & 3;
                                if (v123 <= ((*(_DWORD *)(v36 + 32) >> 21) & 3u)) {
                                  unsigned int v123 = (*(_DWORD *)(v36 + 32) >> 21) & 3;
                                }
                                *(void *)(v44 + 32) = v122 & 0xFFFFFFFF80187FFFLL | ((unint64_t)(v169.i8[0] & 1) << 18) | ((unint64_t)(v169.i8[4] & 1) << 17) | (v123 << 21) | ((unint64_t)(v169.i8[8] & 1) << 16) | ((unint64_t)(v169.i8[12] & 1) << 15) | ((unint64_t)(v168 & 3) << 23) | ((unint64_t)(BYTE4(v168) & 3) << 25) | ((unint64_t)(BYTE8(v168) & 3) << 27) | ((unint64_t)(BYTE12(v168) & 3) << 29);
                                unint64_t v124 = *(void *)(v36 + 32) & 0xFFFFFFFFFFF87FFFLL | ((v153 & 1) << 18) | (unint64_t)((v148 & 1) << 17) | ((v147 & 1) << 16) | ((v146 & 1) << 15);
                                *(void *)(v36 + 32) = v124;
                                v163[0] = 0;
                                v163[1] = 0;
                                do
                                {
                                  if (v170.i32[v115])
                                  {
                                    *((_DWORD *)v163 + v164.u32[v115]) = 1;
                                    ++v116;
                                  }
                                  ++v115;
                                }
                                while (v115 != 4);
                                uint64_t v125 = 0;
                                unsigned int v126 = 0;
                                *(void *)(v36 + 24) = *(void *)(v36 + 24) & 0xFFFFFFCFFFFFFFFFLL | ((unint64_t)(((_BYTE)v116 - 1) & 3) << 36);
                                uint64_t v161 = 0;
                                uint64_t v162 = 0;
                                do
                                {
                                  if (*(_DWORD *)((char *)v163 + v125 * 4)) {
                                    *((_DWORD *)&v161 + v126++) = v165.i32[v125];
                                  }
                                  ++v125;
                                }
                                while (v125 != 4);
                                char v140 = v51;
                                unint64_t v158 = v40;
                                uint64_t v127 = 0;
                                unint64_t v128 = *(void *)(v36 + 40) & 0xFFFFFFFFFFE601FFLL;
                                uint64_t v159 = 0;
                                uint64_t v160 = 0;
                                do
                                {
                                  if (v170.i32[v127])
                                  {
                                    if (v126)
                                    {
                                      uint64_t v129 = 0;
                                      while (v165.i32[v164.u32[v127]] != *((_DWORD *)&v161 + v129))
                                      {
                                        if (v126 == ++v129)
                                        {
                                          LODWORD(v129) = v126;
                                          break;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      LODWORD(v129) = 0;
                                    }
                                    *((_DWORD *)&v159 + v127) = v129;
                                  }
                                  ++v127;
                                }
                                while (v127 != 4);
                                unint64_t v130 = v128 | ((v126 << 19) + 1572864) & 0x180000 | ((unint64_t)(v161 & 3) << 9) | ((unint64_t)(BYTE4(v161) & 3) << 11) | ((unint64_t)(v162 & 3) << 13) | ((unint64_t)(BYTE4(v162) & 3) << 15);
                                *(void *)(v36 + 32) = v124 & 0xFFFFFFFF807FFFFFLL | ((v159 & 3) << 23) & 0x81FFFFFF | ((BYTE4(v159) & 3) << 25) & 0x87FFFFFF | ((v160 & 3) << 27) & 0x9FFFFFFF | ((unint64_t)(BYTE4(v160) & 3) << 29);
                                *(void *)(v36 + 40) = v130;
                                InstructionFree((uint64_t)v42);
                                InstructionInitSourcesTargets(v151, v42, *v142);
                                InstructionFree(v141);
                                InstructionInitSourcesTargets(v151, (unsigned int *)v141, *v142);
                                uint64_t v45 = *(void *)(v44 + 24);
                                uint64_t v34 = v143;
                                unint64_t v40 = v158;
                                char v51 = v140;
                              }
                            }
                          }
                        }
                      }
LABEL_64:
                      uint64_t v55 = v45 & 7;
                      if ((v45 & 7) != 0)
                      {
                        unint64_t v56 = 0;
                        int v57 = 0;
                        do
                        {
                          if (v56 < (v55 + ((__int16)v45 >> 15)))
                          {
                            unint64_t v58 = *(void *)(v44 + 40 + 8 * v56);
                            unint64_t v60 = *(void *)(v36 + 32);
                            unint64_t v59 = *(void *)(v36 + 40);
                            __int16 v61 = v59 ^ v58;
                            BOOL v62 = HIWORD(v58) == HIWORD(v59)
                               && ((v59 ^ v58) & 0x60000) == 0;
                            if ((v61 & 0x1C0) != 0) {
                              BOOL v62 = 0;
                            }
                            unsigned int v63 = (v60 >> 12) ^ (v58 >> 6);
                            unint64_t v64 = HIWORD(v60);
                            BOOL v65 = (((v60 >> 19) ^ (v58 >> 17)) & 3) == 0;
                            if (HIWORD(v58) != v64) {
                              BOOL v65 = 0;
                            }
                            if ((v63 & 7) != 0) {
                              BOOL v65 = 0;
                            }
                            if (v62 || v65)
                            {
                              switch((v58 >> 19) & 3)
                              {
                                case 1u:
                                  goto LABEL_80;
                                case 2u:
                                  goto LABEL_79;
                                case 3u:
                                  uint64_t v66 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v58 >> 15) & 3)));
                                  *v66 |= 1u;
LABEL_79:
                                  uint64_t v67 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v58 >> 13) & 3)));
                                  *v67 |= 1u;
LABEL_80:
                                  uint64_t v68 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v58 >> 11) & 3)));
                                  *v68 |= 1u;
                                  break;
                                default:
                                  break;
                              }
                              int v69 = (_DWORD *)((unint64_t)&v171 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v58 >> 9) & 3)));
                              *v69 |= 1u;
                              int v57 = 1;
                            }
                          }
                          ++v56;
                        }
                        while (v55 != v56);
                      }
                      else
                      {
                        int v57 = 0;
                      }
                      uint64_t v70 = v45 & 0x3FC0;
                      unint64_t v71 = *(void *)(v44 + 32);
                      unint64_t v72 = HIWORD(v71);
                      if (v70 == 7040)
                      {
                        unint64_t v73 = *(void *)(v36 + 40);
                        BOOL v74 = (((v73 >> 6) ^ (v71 >> 12)) & 7) == 0
                           && v72 == HIWORD(v73);
                        int v75 = ((v73 >> 17) ^ (v71 >> 19)) & 3;
                        if (v74 && v75 == 0)
                        {
                          v114.i64[0] = 0x100000001;
                          v114.i64[1] = 0x100000001;
                          int8x16_t v171 = vorrq_s8(v171, vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v71), (uint32x4_t)xmmword_2393DBD50), v114));
                          int v57 = 1;
                        }
                      }
                      unint64_t v77 = *(void *)(v36 + 32);
                      int v78 = v77 ^ v71;
                      uint64_t v79 = (v77 ^ v71) & 0x7000;
                      unint64_t v80 = HIWORD(v77);
                      uint64_t v81 = *(void *)&v78 & 0x180000;
                      if (v79) {
                        BOOL v82 = 0;
                      }
                      else {
                        BOOL v82 = v72 == v80;
                      }
                      if (v82 && v81 == 0)
                      {
                        if (v153) {
                          BOOL v86 = v171.i32[0] == 0;
                        }
                        else {
                          BOOL v86 = 0;
                        }
                        uint64_t v87 = -491521;
                        if (!v86) {
                          uint64_t v87 = -229377;
                        }
                        if (v148) {
                          BOOL v88 = v171.i32[1] == 0;
                        }
                        else {
                          BOOL v88 = 0;
                        }
                        uint64_t v89 = 0x20000;
                        if (v88) {
                          uint64_t v89 = 0;
                        }
                        uint64_t v90 = v89 | v87;
                        if (v147) {
                          BOOL v91 = v171.i32[2] == 0;
                        }
                        else {
                          BOOL v91 = 0;
                        }
                        uint64_t v92 = 0x10000;
                        if (v91) {
                          uint64_t v92 = 0;
                        }
                        if (v146) {
                          BOOL v93 = v171.i32[3] == 0;
                        }
                        else {
                          BOOL v93 = 0;
                        }
                        uint64_t v94 = 0x8000;
                        if (v93) {
                          uint64_t v94 = 0;
                        }
                        *(void *)(v44 + 32) = (v90 | v92 | v94) & v71;
                        int v157 = v39;
                        uint64_t v95 = v7;
                        unint64_t v96 = v40;
                        char v97 = v51;
                        InstructionFree((uint64_t)v42);
                        InstructionInitSourcesTargets(v151, v42, *v142);
                        char v51 = v97;
                        unint64_t v40 = v96;
                        uint64_t v7 = v95;
                        int v39 = v157;
                        uint64_t v34 = v143;
                      }
                      char v43 = v51 | v50;
                      if (v57)
                      {
                        v84.i64[0] = 0x100000001;
                        v84.i64[1] = 0x100000001;
                        int8x16_t v85 = vandq_s8((int8x16_t)vceqzq_s32((int32x4_t)v171), vandq_s8(v170, v84));
                        v43 |= vorr_s8(*(int8x8_t *)v85.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL)) == 0;
                      }
                    }
                    if (v41 < 2) {
                      break;
                    }
                    if (!v39) {
                      break;
                    }
                    --v41;
                  }
                  while ((v43 & 1) == 0);
                }
                if (v144)
                {
                  int v131 = (const float *)(v36 + 40);
                  uint32x4_t v132 = (uint32x4_t)vld1q_dup_f32(v131);
                  v133.i64[0] = 0x300000003;
                  v133.i64[1] = 0x300000003;
                  int8x16_t v169 = vandq_s8((int8x16_t)vshlq_u32(v132, (uint32x4_t)xmmword_2393D1D30), v133);
                  unint64_t v134 = *(void *)(v36 + 32);
                  uint64_t v135 = -491521;
                  if (*(_DWORD *)((unint64_t)&v169 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v134 >> 23) & 3)))) {
                    uint64_t v135 = -229377;
                  }
                  *(void *)(v36 + 32) = (((*(_DWORD *)((unint64_t)&v169 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v134 >> 25) & 3))) != 1) << 17) | (unint64_t)v135 | ((unint64_t)(*(_DWORD *)((unint64_t)&v169 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v134 >> 27) & 3))) != 2) << 16) | ((unint64_t)(*(_DWORD *)((unint64_t)&v169 & 0xFFFFFFFFFFFFFFF3 | (4 * ((v134 >> 29) & 3))) != 3) << 15)) & v134;
                  InstructionFree(v141);
                  InstructionInitSourcesTargets(v151, (unsigned int *)v141, *(_DWORD *)(v145 + 80 * v150 + 12));
                  int v39 = (*(void *)(v36 + 32) & 0x78000) != 0;
                }
                if (!v39)
                {
                  PPStreamRemoveOperation(*(void *)v151, *v149);
                  *uint64_t v155 = 1;
                }
              }
            }
          }
          unsigned int v5 = v7 - 1;
        }
        while ((int)v7 > 0);
      }
      BitSetFree(v4);
      uint64_t result = v151;
      uint64_t v1 = v150 + 1;
    }
    while (v150 + 1 < (unint64_t)*(unsigned int *)(v151 + 32));
  }
  return result;
}

uint64_t GetRegister(uint64_t a1, int a2, int a3, int a4)
{
  switch(a2)
  {
    case 0:
      uint64_t v4 = (_DWORD *)(a1 + 52);
      unsigned int v5 = (unsigned int *)(a1 + 72);
      goto LABEL_7;
    case 1:
      uint64_t v4 = (_DWORD *)(a1 + 48);
      unsigned int v5 = (unsigned int *)(a1 + 68);
      goto LABEL_7;
    case 2:
      uint64_t v4 = (_DWORD *)(a1 + 56);
      unsigned int v5 = (unsigned int *)(a1 + 76);
      goto LABEL_7;
    case 3:
    case 5:
      uint64_t v4 = (_DWORD *)(a1 + 44);
      unsigned int v5 = (unsigned int *)(a1 + 64);
      goto LABEL_7;
    case 4:
      uint64_t v4 = (_DWORD *)(a1 + 60);
      unsigned int v5 = (unsigned int *)(a1 + 80);
LABEL_7:
      unsigned int v6 = a4 + 4 * a3 + *v4;
      if (v6 >= *v5) {
        goto LABEL_9;
      }
      uint64_t result = *(void *)(a1 + 16) + 56 * v6;
      break;
    default:
LABEL_9:
      uint64_t result = 0;
      break;
  }
  return result;
}

void RegistersCleanup(unsigned int *a1)
{
  unint64_t v2 = a1[9];
  if (v2)
  {
    uint64_t v3 = (_DWORD *)(*((void *)a1 + 2) + 32);
    uint64_t v4 = a1[9];
    do
    {
      *uint64_t v3 = 1;
      v3 += 14;
      --v4;
    }
    while (v4);
  }
  uint64_t v5 = a1[8];
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *((void *)a1 + 1);
    do
    {
      uint64_t v8 = *(unsigned int *)(v7 + 80 * v6);
      if (v8)
      {
        uint64_t v9 = 0;
        uint64_t v10 = *(void *)(v7 + 80 * v6 + 16);
        do
        {
          if (!*(_DWORD *)(v10 + 40 * v9 + 12))
          {
            uint64_t v11 = *(unsigned int *)(v10 + 40 * v9);
            if (v11)
            {
              int v12 = *(uint64_t **)(v10 + 40 * v9 + 16);
              do
              {
                uint64_t v13 = *v12++;
                *(_DWORD *)(v13 + 32) = 0;
                --v11;
              }
              while (v11);
            }
            uint64_t v14 = *(unsigned int *)(v10 + 40 * v9 + 4);
            if (v14)
            {
              uint64_t v15 = *(uint64_t **)(v10 + 40 * v9 + 24);
              do
              {
                uint64_t v16 = *v15++;
                *(_DWORD *)(v16 + 32) = 0;
                --v14;
              }
              while (v14);
            }
          }
          ++v9;
        }
        while (v9 != v8);
      }
      ++v6;
    }
    while (v6 != v5);
  }
  uint64_t v17 = **(void **)(*(void *)a1 + 56);
  if (v17)
  {
    unsigned int v18 = 0;
    do
    {
      if ((*(void *)(v17 + 24) & 0x1F00) != 0x600)
      {
        int v19 = *(_DWORD *)(v17 + 32);
        if (v18 <= v19 + 1) {
          unsigned int v18 = v19 + 1;
        }
      }
      uint64_t v17 = *(void *)(v17 + 8);
    }
    while (v17);
    if (!v2) {
      return;
    }
  }
  else
  {
    unsigned int v18 = 0;
    if (!v2) {
      return;
    }
  }
  for (unint64_t i = 0; i < v2; i += 4)
  {
    uint64_t v21 = *((void *)a1 + 2);
    if (*(_DWORD *)(v21 + 56 * i + 32))
    {
      if (*(_DWORD *)(v21 + 56 * (i | 1) + 32))
      {
        if (*(_DWORD *)(v21 + 56 * (i | 2) + 32))
        {
          if (*(_DWORD *)(v21 + 56 * (i | 3) + 32))
          {
            uint64_t v22 = v21 + 56 * i;
            unsigned int v25 = *(uint64_t **)(v22 + 48);
            uint64_t v24 = (uint64_t **)(v22 + 48);
            unint64_t v23 = v25;
            if (v25)
            {
              switch(*(_DWORD *)(v21 + 56 * i + 28))
              {
                case 1:
                  uint64_t v27 = *(void *)a1;
                  unint64_t v28 = *(uint64_t ***)(*(void *)a1 + 80);
                  unint64_t v29 = *v28;
                  if (!*v28) {
                    goto LABEL_53;
                  }
                  unsigned int v30 = *(_DWORD *)(v21 + 56 * i + 4);
                  while (1)
                  {
                    unint64_t v31 = v29[3];
                    if (v30 >= WORD1(v31) && v30 <= HIWORD(v31)) {
                      break;
                    }
                    unint64_t v29 = (uint64_t *)v29[1];
                    if (!v29) {
                      goto LABEL_53;
                    }
                  }
                  PPStreamChunkListRemoveChunk((uint64_t)v28, v29);
                  uint64_t v27 = *(void *)a1;
                  unint64_t v23 = *v24;
LABEL_53:
                  uint64_t v26 = *(void *)(v27 + 32);
                  goto LABEL_55;
                case 2:
                  unsigned int v33 = *(_DWORD *)(v21 + 56 * i + 4);
                  if (v33 < v18) {
                    goto LABEL_56;
                  }
                  uint64_t v34 = *(void *)a1;
                  uint64_t v35 = *(uint64_t ***)(*(void *)a1 + 72);
                  uint64_t v36 = *v35;
                  if (!*v35) {
                    goto LABEL_54;
                  }
                  break;
                case 3:
                case 5:
                  uint64_t v26 = *(void *)(*(void *)a1 + 64);
                  goto LABEL_55;
                case 4:
                  uint64_t v26 = *(void *)(*(void *)a1 + 40);
                  goto LABEL_55;
                default:
                  goto LABEL_56;
              }
              while (1)
              {
                unint64_t v37 = v36[3];
                if (v33 >= WORD1(v37) && v33 <= HIWORD(v37)) {
                  break;
                }
                uint64_t v36 = (uint64_t *)v36[1];
                if (!v36) {
                  goto LABEL_54;
                }
              }
              PPStreamChunkListRemoveChunk((uint64_t)v35, v36);
              uint64_t v34 = *(void *)a1;
              unint64_t v23 = *v24;
LABEL_54:
              uint64_t v26 = *(void *)(v34 + 56);
LABEL_55:
              PPStreamChunkListRemoveChunk(v26, v23);
LABEL_56:
              *uint64_t v24 = 0;
              *(void *)(v21 + 56 * (i | 1) + 48) = 0;
              *(void *)(v21 + 56 * (i | 2) + 48) = 0;
              *(void *)(v21 + 56 * (i | 3) + 48) = 0;
              unint64_t v2 = a1[9];
            }
          }
        }
      }
    }
  }
}

BOOL RegisterCanMerge(uint64_t a1, unsigned int *a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  if (v2 != a2[5]
    || *(_DWORD *)(a1 + 24) != a2[6]
    || *(_DWORD *)(a1 + 16) != a2[4]
    || *(_DWORD *)(a1 + 28) != 1
    || *(_DWORD *)(a1 + 32)
    || a2[7] != 1
    || a2[8])
  {
    return 0;
  }
  if (!*(_DWORD *)(a1 + 36) && v2 != 4 && !*(_DWORD *)(a1 + 40)) {
    return BitSetGetEquals(*(void *)(a1 + 8), *a2) == 0;
  }
  uint64_t v3 = a2[9];
  if (v3) {
    return 0;
  }
  if (v2 != 4 && !a2[10]) {
    return BitSetGetEquals(*(void *)(a1 + 8), *a2) == 0;
  }
  return v3;
}

uint64_t RegisterAdd(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7)
{
  int v14 = a4 + 4 * a5 + 4;
  if (*(_DWORD *)(a1 + 36) < v14)
  {
    uint64_t v15 = (char *)malloc_type_realloc(*(void **)(a1 + 16), 56 * v14, 0x2BDC8648uLL);
    if (!v15) {
      abort();
    }
    *(void *)(a1 + 16) = v15;
    bzero(&v15[56 * *(unsigned int *)(a1 + 36)], 56 * (v14 - *(_DWORD *)(a1 + 36)));
    *(_DWORD *)(a1 + 36) = v14;
  }
  uint64_t v16 = 0;
  uint64_t v17 = *(void *)(a1 + 16);
  int v18 = a4 + 4 * a5;
  do
  {
    uint64_t v19 = v17 + 56 * (v18 + v16);
    *(void *)(v19 + 8) = 0;
    *(_DWORD *)(v19 + 16) = v16;
    *(_DWORD *)(v19 + 20) = a6;
    *(_DWORD *)(v19 + 24) = a7;
    *(_DWORD *)(v19 + 28) = a3;
    *(_DWORD *)uint64_t v19 = v18 + v16;
    *(_DWORD *)(v19 + 4) = a5;
    *(void *)(v19 + 32) = 0;
    *(_DWORD *)(v19 + 40) = 0;
    *(void *)(v19 + 48) = a2;
    ++v16;
  }
  while (v16 != 4);
  return 0;
}

unsigned int *InstructionAdd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = *(_DWORD *)a2 + 1;
  *(_DWORD *)a2 = v6;
  uint64_t v7 = (char *)malloc_type_realloc(*(void **)(a2 + 16), 40 * v6, 0x2BDC8648uLL);
  if (!v7) {
    abort();
  }
  *(void *)(a2 + 16) = v7;
  unsigned int v8 = *(_DWORD *)a2 - 1;
  uint64_t v9 = &v7[40 * v8];
  *((_DWORD *)v9 + 2) = 0;
  uint64_t v10 = v9 + 8;
  *((void *)v10 + 3) = a3;
  int v11 = (*(_DWORD *)(a3 + 24) >> 6);
  BOOL v12 = (v11 - 75) > 0x3D || ((1 << (v11 - 75)) & 0x300073838001FE17) == 0;
  if (!v12 || (unsigned int v13 = v11 - 140, v13 <= 0x1E) && ((1 << v13) & 0x4000200F) != 0) {
    *(_DWORD *)uint64_t v10 = 1;
  }
  int v14 = (unsigned int *)&v7[40 * v8];
  void v14[3] = 0;
  InstructionInitSourcesTargets(a1, v14, *(_DWORD *)(a2 + 12));
  return v14;
}

_DWORD *InstructionInitSourcesTargets(uint64_t a1, unsigned int *a2, int a3)
{
  uint64_t v93 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)a2 + 4);
  int v6 = (*(_DWORD *)(v5 + 24) >> 6);
  BOOL v7 = 1;
  if (v6 == 77)
  {
    BOOL v7 = a3 != 0;
    BOOL v8 = 0;
  }
  else
  {
    BOOL v8 = v6 == 110;
  }
  BOOL v80 = v6 != 76;
  BOOL v9 = v6 != 76 && v7;
  BOOL v10 = v6 != 76 && v8;
  BOOL v79 = v10;
  int v11 = a2[2] | ((*(void *)(v5 + 32) & 0x7000) == 12288);
  a2[2] = v11;
  a2[2] = v11 | ((*(void *)(v5 + 32) & 0x7000) == 20480);
  *a2 = 0;
  BOOL v12 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
  if (!v12) {
    goto LABEL_90;
  }
  BOOL v81 = v9;
  *((void *)a2 + 2) = v12;
  uint64_t v13 = *(void *)(v5 + 24) & 7;
  uint64_t v90 = v5;
  if (v13)
  {
    uint64_t v14 = 0;
    int v87 = 0;
    uint64_t v82 = *(void *)(v5 + 24) & 7;
    do
    {
      if (v14 < (*(_DWORD *)(v5 + 24) & 7) + ((__int16)*(_DWORD *)(v5 + 24) >> 15))
      {
        int8x16_t v92 = 0uLL;
        uint64_t v15 = v5 + 8 * v14;
        unint64_t v18 = *(void *)(v15 + 40);
        uint64_t v17 = (_DWORD *)(v15 + 40);
        unint64_t v16 = v18;
        uint64_t v85 = v14;
        switch((v18 >> 19) & 3)
        {
          case 1u:
            goto LABEL_17;
          case 2u:
            goto LABEL_16;
          case 3u:
            v92.i32[(v16 >> 15) & 3] = 1;
LABEL_16:
            v92.i32[(v16 >> 13) & 3] = 1;
LABEL_17:
            v92.i32[(v16 >> 11) & 3] = 1;
            break;
          default:
            break;
        }
        v92.i32[(v16 >> 9) & 3] = 1;
        uint64_t v91 = 0;
        int v83 = v16 & 1;
        GetRegisterIndicies(*(void *)a1, (unsigned int *)&v91 + 1, (unsigned int *)&v91, (v16 >> 6) & 7, HIWORD(v16), v83, (v16 >> 17) & 3);
        int v19 = HIDWORD(v91);
        int v88 = v91;
        if (SHIDWORD(v91) <= (int)v91)
        {
          do
          {
            for (unint64_t i = 0; i != 4; ++i)
            {
              if (v92.i32[i] && GetRegister(a1, (*v17 >> 6) & 7, v19, i))
              {
                unsigned int v21 = *a2 + 1;
                *a2 = v21;
                uint64_t v22 = malloc_type_realloc(*((void **)a2 + 2), 8 * v21, 0x2BDC8648uLL);
                if (!v22) {
                  goto LABEL_90;
                }
                unint64_t v23 = v22;
                *((void *)a2 + 2) = v22;
                unsigned int v24 = *a2;
                unsigned int v25 = *a2 - 1;
                Register = (_DWORD *)GetRegister(a1, (*v17 >> 6) & 7, v19, i);
                v23[v25] = Register;
                int v27 = Register[10];
                Register[9] |= *v17 & 1;
                Register[10] = (*v17 >> 17) & 3 | v27;
                if (i >= 2 && Register[5] == 4)
                {
                  *a2 = v24 + 1;
                  unint64_t v28 = malloc_type_realloc(*((void **)a2 + 2), 8 * (v24 + 1), 0x2BDC8648uLL);
                  if (!v28) {
                    goto LABEL_90;
                  }
                  unint64_t v29 = v28;
                  *((void *)a2 + 2) = v28;
                  unsigned int v30 = *a2 - 1;
                  uint64_t v31 = GetRegister(a1, (*v17 >> 6) & 7, v19 + 1, (int)i - 2);
                  v29[v30] = v31;
                  int v32 = *(_DWORD *)(v31 + 40);
                  *(_DWORD *)(v31 + 36) |= *v17 & 1;
                  *(_DWORD *)(v31 + 40) = (*v17 >> 17) & 3 | v32;
                }
              }
            }
            BOOL v67 = v19++ == v88;
          }
          while (!v67);
        }
        v87 |= v83;
        uint64_t v5 = v90;
        uint64_t v13 = v82;
        uint64_t v14 = v85;
      }
      ++v14;
    }
    while (v14 != v13);
  }
  else
  {
    int v87 = 0;
  }
  unsigned int v33 = (const float *)(v5 + 32);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v33);
  v35.i64[0] = 0x100000001;
  v35.i64[1] = 0x100000001;
  int8x16_t v92 = vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_2393DBD50), v35);
  a2[1] = 0;
  uint64_t v36 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
  if (!v36) {
    goto LABEL_90;
  }
  *((void *)a2 + 3) = v36;
  unint64_t v37 = *(void *)(v5 + 32);
  uint64_t v91 = 0;
  uint64_t v84 = HIDWORD(v37) & 1;
  uint64_t result = (_DWORD *)GetRegisterIndicies(*(void *)a1, (unsigned int *)&v91 + 1, (unsigned int *)&v91, (v37 >> 12) & 7, HIWORD(v37), BYTE4(v37) & 1, (v37 >> 19) & 3);
  int v39 = HIDWORD(v91);
  int v86 = v91;
  if (SHIDWORD(v91) <= (int)v91)
  {
    do
    {
      unint64_t v40 = 0;
      int v89 = v39 + 1;
      do
      {
        if (v92.i32[v40])
        {
          uint64_t result = (_DWORD *)GetRegister(a1, (*(_DWORD *)(v90 + 32) >> 12) & 7, v39, v40);
          if (result)
          {
            unsigned int v41 = a2[1] + 1;
            a2[1] = v41;
            uint64_t v42 = malloc_type_realloc(*((void **)a2 + 3), 8 * v41, 0x2BDC8648uLL);
            if (!v42) {
              goto LABEL_90;
            }
            char v43 = v42;
            *((void *)a2 + 3) = v42;
            unsigned int v44 = a2[1];
            uint64_t result = (_DWORD *)GetRegister(a1, (*(_DWORD *)(v90 + 32) >> 12) & 7, v39, v40);
            v43[v44 - 1] = result;
            int v45 = result[10];
            result[9] |= *(_DWORD *)(v90 + 36) & 1;
            result[10] = (*(_DWORD *)(v90 + 32) >> 19) & 3 | v45;
            if (v40 >= 2 && result[5] == 4)
            {
              a2[1] = v44 + 1;
              int v46 = malloc_type_realloc(*((void **)a2 + 3), 8 * (v44 + 1), 0x2BDC8648uLL);
              if (!v46) {
                goto LABEL_90;
              }
              unsigned int v47 = v46;
              *((void *)a2 + 3) = v46;
              unsigned int v48 = a2[1] - 1;
              uint64_t result = (_DWORD *)GetRegister(a1, (*(_DWORD *)(v90 + 32) >> 12) & 7, v89, (int)v40 - 2);
              v47[v48] = result;
              int v49 = result[10];
              result[9] |= *(_DWORD *)(v90 + 36) & 1;
              result[10] = (*(_DWORD *)(v90 + 32) >> 19) & 3 | v49;
            }
          }
          if (v84 | v79)
          {
            uint64_t result = (_DWORD *)GetRegister(a1, (*(_DWORD *)(v90 + 32) >> 12) & 7, v39, v40);
            if (result)
            {
              unsigned int v50 = *a2 + 1;
              *a2 = v50;
              char v51 = malloc_type_realloc(*((void **)a2 + 2), 8 * v50, 0x2BDC8648uLL);
              if (!v51) {
                goto LABEL_90;
              }
              BOOL v52 = v51;
              *((void *)a2 + 2) = v51;
              unsigned int v53 = *a2;
              unsigned int v54 = *a2 - 1;
              uint64_t result = (_DWORD *)GetRegister(a1, (*(_DWORD *)(v90 + 32) >> 12) & 7, v39, v40);
              v52[v54] = result;
              if (v40 >= 2 && result[5] == 4)
              {
                *a2 = v53 + 1;
                uint64_t v55 = malloc_type_realloc(*((void **)a2 + 2), 8 * (v53 + 1), 0x2BDC8648uLL);
                if (!v55) {
                  goto LABEL_90;
                }
                unint64_t v56 = v55;
                *((void *)a2 + 2) = v55;
                unsigned int v57 = *a2 - 1;
                uint64_t result = (_DWORD *)GetRegister(a1, (*(_DWORD *)(v90 + 32) >> 12) & 7, v89, (int)v40 - 2);
                v56[v57] = result;
              }
            }
          }
        }
        ++v40;
      }
      while (v40 != 4);
      BOOL v67 = v39++ == v86;
    }
    while (!v67);
  }
  if (v84 | v87 && *(_DWORD *)(a1 + 60) < *(_DWORD *)(a1 + 80) && *(void *)(a1 + 16))
  {
    unsigned int v58 = *a2 + 1;
    *a2 = v58;
    uint64_t result = malloc_type_realloc(*((void **)a2 + 2), 8 * v58, 0x2BDC8648uLL);
    if (!result) {
      goto LABEL_90;
    }
    *((void *)a2 + 2) = result;
    unsigned int v59 = *(_DWORD *)(a1 + 60);
    if (v59 >= *(_DWORD *)(a1 + 80)) {
      uint64_t v60 = 0;
    }
    else {
      uint64_t v60 = *(void *)(a1 + 16) + 56 * v59;
    }
    *(void *)&result[2 * *a2 - 2] = v60;
  }
  if (!v81)
  {
    __int16 v61 = (void *)*((void *)a2 + 2);
    if (v61) {
      free(v61);
    }
    *a2 = 0;
    uint64_t result = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
    if (!result) {
      goto LABEL_90;
    }
    *((void *)a2 + 2) = result;
    unint64_t v62 = *(unsigned int *)(a1 + 36);
    if (v62)
    {
      uint64_t v63 = 0;
      for (unint64_t j = 0; j < v62; ++j)
      {
        uint64_t v65 = *(void *)(a1 + 16) + v63;
        int v66 = *(_DWORD *)(v65 + 28);
        BOOL v67 = v66 == 4 || v66 == 1;
        if (v67)
        {
          unsigned int v68 = *a2 + 1;
          *a2 = v68;
          uint64_t result = malloc_type_realloc(*((void **)a2 + 2), 8 * v68, 0x2BDC8648uLL);
          if (!result) {
            goto LABEL_90;
          }
          *((void *)a2 + 2) = result;
          *(void *)&result[2 * *a2 - 2] = v65;
          unint64_t v62 = *(unsigned int *)(a1 + 36);
        }
        v63 += 56;
      }
    }
  }
  if (v80) {
    return result;
  }
  int v69 = (void *)*((void *)a2 + 3);
  if (v69) {
    free(v69);
  }
  a2[1] = 0;
  uint64_t result = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
  if (!result) {
LABEL_90:
  }
    abort();
  *((void *)a2 + 3) = result;
  unint64_t v70 = *(unsigned int *)(a1 + 36);
  if (v70)
  {
    uint64_t v71 = 0;
    for (unint64_t k = 0; k < v70; ++k)
    {
      uint64_t v73 = *(void *)(a1 + 16) + v71;
      unsigned int v74 = *(_DWORD *)(v73 + 28);
      BOOL v75 = v74 > 5;
      int v76 = (1 << v74) & 0x3A;
      if (!v75 && v76 != 0)
      {
        unsigned int v78 = a2[1] + 1;
        a2[1] = v78;
        uint64_t result = malloc_type_realloc(*((void **)a2 + 3), 8 * v78, 0x2BDC8648uLL);
        if (!result) {
          goto LABEL_90;
        }
        *((void *)a2 + 3) = result;
        *(void *)&result[2 * a2[1] - 2] = v73;
        unint64_t v70 = *(unsigned int *)(a1 + 36);
      }
      v71 += 56;
    }
  }
  return result;
}

void InstructionFree(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    free(v3);
  }
}

char *BlockAdd(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 32) + 1;
  *(_DWORD *)(a1 + 32) = v2;
  uint64_t v3 = (char *)malloc_type_realloc(*(void **)(a1 + 8), 80 * v2, 0x2BDC8648uLL);
  if (!v3) {
    goto LABEL_6;
  }
  uint64_t v4 = v3;
  *(void *)(a1 + 8) = v3;
  unsigned int v5 = *(_DWORD *)(a1 + 32) - 1;
  int v6 = &v3[80 * v5];
  *(_DWORD *)int v6 = 0;
  BOOL v7 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
  if (!v7) {
    goto LABEL_6;
  }
  BOOL v8 = &v4[80 * v5];
  *((void *)v8 + 2) = v7;
  *((_DWORD *)v8 + 1) = 0;
  BOOL v9 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
  if (!v9
    || (BOOL v10 = &v4[80 * v5],
        *((void *)v10 + 3) = v9,
        *((_DWORD *)v10 + 2) = 0,
        (int v11 = malloc_type_malloc(8uLL, 0x7081ABB9uLL)) == 0))
  {
LABEL_6:
    abort();
  }
  BOOL v12 = &v4[80 * v5];
  *((void *)v12 + 4) = v11;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *((void *)v12 + 9) = 0;
  return v6;
}

uint64_t *BlockFree(unsigned int *a1)
{
  if (*a1)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      InstructionFree(*((void *)a1 + 2) + v2);
      ++v3;
      v2 += 40;
    }
    while (v3 < *a1);
  }
  uint64_t v4 = (void *)*((void *)a1 + 2);
  if (v4) {
    free(v4);
  }
  unsigned int v5 = (void *)*((void *)a1 + 3);
  if (v5) {
    free(v5);
  }
  int v6 = (void *)*((void *)a1 + 4);
  if (v6) {
    free(v6);
  }
  BOOL v7 = (uint64_t *)*((void *)a1 + 5);
  if (v7) {
    BitSetFree(v7);
  }
  BOOL v8 = (uint64_t *)*((void *)a1 + 6);
  if (v8) {
    BitSetFree(v8);
  }
  BOOL v9 = (uint64_t *)*((void *)a1 + 7);
  if (v9) {
    BitSetFree(v9);
  }
  BOOL v10 = (uint64_t *)*((void *)a1 + 8);
  if (v10) {
    BitSetFree(v10);
  }
  uint64_t result = (uint64_t *)*((void *)a1 + 9);
  if (result)
  {
    return (uint64_t *)BitSetFree(result);
  }
  return result;
}

unint64_t RegistersInitialize(uint64_t a1)
{
  unint64_t result = *(unsigned int *)(a1 + 36);
  if (result)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 8;
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = BitSetNew(result);
      *(void *)(v5 + v4) = v6;
      BitSetSetEquals(v6, v3++);
      unint64_t result = *(unsigned int *)(a1 + 36);
      v4 += 56;
    }
    while (v3 < result);
  }
  return result;
}

unint64_t Registerify(_DWORD *a1)
{
  int v2 = a1[9];
  a1[11] = v2;
  unint64_t v3 = *(void ***)a1;
  uint64_t v4 = **(void **)(*(void *)a1 + 64);
  if (v4)
  {
    do
    {
      RegisterAdd((uint64_t)a1, v4, 3, a1[11], *(_DWORD *)(v4 + 32), (*(_DWORD *)(v4 + 24) >> 3) & 7, *(_DWORD *)(v4 + 24) & 7);
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4);
    int v2 = a1[9];
    unint64_t v3 = *(void ***)a1;
  }
  a1[16] = v2;
  a1[12] = v2;
  uint64_t v5 = *v3[4];
  if (v5)
  {
    do
    {
      RegisterAdd((uint64_t)a1, v5, 1, a1[12], *(_DWORD *)(v5 + 32), (*(_DWORD *)(v5 + 24) >> 3) & 7, *(_DWORD *)(v5 + 24) & 7);
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5);
    int v2 = a1[9];
    unint64_t v3 = *(void ***)a1;
  }
  a1[17] = v2;
  a1[13] = v2;
  uint64_t v6 = *v3[6];
  if (v6)
  {
    do
    {
      RegisterAdd((uint64_t)a1, v6, 0, a1[13], *(_DWORD *)(v6 + 32), (*(_DWORD *)(v6 + 24) >> 3) & 7, *(_DWORD *)(v6 + 24) & 7);
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while (v6);
    int v2 = a1[9];
    unint64_t v3 = *(void ***)a1;
  }
  a1[18] = v2;
  a1[14] = v2;
  uint64_t v7 = *v3[7];
  if (v7)
  {
    do
    {
      RegisterAdd((uint64_t)a1, v7, 2, a1[14], *(_DWORD *)(v7 + 32), (*(_DWORD *)(v7 + 24) >> 3) & 7, *(_DWORD *)(v7 + 24) & 7);
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7);
    int v2 = a1[9];
    unint64_t v3 = *(void ***)a1;
  }
  a1[19] = v2;
  a1[15] = v2;
  uint64_t v8 = *v3[5];
  if (v8)
  {
    do
    {
      RegisterAdd((uint64_t)a1, v8, 4, a1[15], *(_DWORD *)(v8 + 24), 2, 0);
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8);
    int v2 = a1[9];
  }
  a1[20] = v2;

  return RegistersInitialize((uint64_t)a1);
}

void RegistersFree(uint64_t a1)
{
  unint64_t v2 = *(unsigned int *)(a1 + 36);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 8;
    do
    {
      uint64_t v5 = *(uint64_t **)(*(void *)(a1 + 16) + v4);
      if (v5)
      {
        BitSetFree(v5);
        unint64_t v2 = *(unsigned int *)(a1 + 36);
      }
      ++v3;
      v4 += 56;
    }
    while (v3 < v2);
  }
  uint64_t v6 = *(void **)(a1 + 16);
  if (v6)
  {
    free(v6);
  }
}

void Blockify(uint64_t a1)
{
  bzero(*(void **)(a1 + 24), 8 * *(unsigned int *)(a1 + 40));
  GetOrAddBlock(a1, 0);
  uint64_t v2 = **(void **)(*(void *)a1 + 104);
  if (v2)
  {
    while (1)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (!v3) {
        uint64_t v3 = v2;
      }
      LODWORD(v4) = *(_DWORD *)(v3 + 88);
      int v5 = (*(_DWORD *)(v2 + 24) >> 6);
      char v6 = v5 - 75;
      if ((v5 - 75) > 0x21) {
        goto LABEL_11;
      }
      if (((1 << v6) & 0x38001BE01) == 0) {
        break;
      }
LABEL_6:
      GetOrAddBlock(a1, v4);
      uint64_t v4 = *(void *)(v2 + 24) >> 46;
LABEL_7:
      GetOrAddBlock(a1, v4);
LABEL_8:
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        goto LABEL_14;
      }
    }
    if (((1 << v6) & 0x4004) != 0) {
      goto LABEL_7;
    }
LABEL_11:
    if ((v5 - 141) < 3) {
      goto LABEL_7;
    }
    if (v5 != 140) {
      goto LABEL_8;
    }
    goto LABEL_6;
  }
LABEL_14:
  bzero(*(void **)(a1 + 24), 8 * *(unsigned int *)(a1 + 40));
  unsigned int v7 = *(_DWORD *)(a1 + 40);
  if (v7 && (uint64_t v8 = *(void **)(a1 + 24), !*v8))
  {
    *uint64_t v8 = *(void *)(a1 + 8);
    int v9 = 1;
  }
  else
  {
    int v9 = 0;
  }
  for (uint64_t i = **(void **)(*(void *)a1 + 104); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v11 = *(void *)(i + 8);
    if (!v11) {
      uint64_t v11 = i;
    }
    uint64_t v12 = *(int *)(v11 + 88);
    unint64_t v13 = *(void *)(i + 24);
    int v14 = (v13 >> 6);
    char v15 = v14 - 75;
    if ((v14 - 75) <= 0x21)
    {
      if (((1 << v15) & 0x38001BE01) != 0) {
        goto LABEL_23;
      }
      if (((1 << v15) & 0x4004) != 0) {
        goto LABEL_30;
      }
    }
    if ((v14 - 141) < 3)
    {
LABEL_30:
      if (v7 > v12)
      {
        unint64_t v18 = (void *)(*(void *)(a1 + 24) + 8 * v12);
LABEL_32:
        if (!*v18) {
          *unint64_t v18 = *(void *)(a1 + 8) + 80 * v9++;
        }
      }
    }
    else if (v14 == 140)
    {
LABEL_23:
      if (v7 > v12)
      {
        uint64_t v16 = *(void *)(a1 + 24);
        if (!*(void *)(v16 + 8 * v12))
        {
          *(void *)(v16 + 8 * v12) = *(void *)(a1 + 8) + 80 * v9++;
          unint64_t v13 = *(void *)(i + 24);
        }
      }
      unint64_t v17 = v13 >> 46;
      if (v7 <= v17) {
        continue;
      }
      unint64_t v18 = (void *)(*(void *)(a1 + 24) + 8 * v17);
      goto LABEL_32;
    }
  }
  int v19 = (int *)malloc_type_malloc(4uLL, 0x7081ABB9uLL);
  if (!v19) {
LABEL_118:
  }
    abort();
  unint64_t v20 = v19;
  if (*(_DWORD *)(a1 + 40)) {
    uint64_t v21 = **(void **)(a1 + 24);
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = **(void **)(*(void *)a1 + 104);
  if (v22)
  {
    int v23 = 0;
    int v24 = 0;
    int v25 = 0;
    while (1)
    {
      unsigned int v26 = *(_DWORD *)(v22 + 88);
      uint64_t v27 = *(void *)(v22 + 8);
      if (v27) {
        unsigned int v28 = *(_DWORD *)(v27 + 88);
      }
      else {
        unsigned int v28 = *(_DWORD *)(v22 + 88);
      }
      if ((*(unsigned char *)(v22 + 25) & 0x40) != 0) {
        int v24 = 1;
      }
      if (*(_DWORD *)(a1 + 40) <= v26)
      {
        uint64_t v30 = v21;
      }
      else
      {
        uint64_t v29 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v26);
        if (v29) {
          uint64_t v30 = v29;
        }
        else {
          uint64_t v30 = v21;
        }
      }
      *(_DWORD *)(v30 + 12) = v24;
      InstructionAdd(a1, v30, v22);
      unint64_t v31 = *(void *)(v22 + 24);
      int v32 = (v31 >> 6);
      switch((v31 >> 6))
      {
        case 'K':
        case 'T':
        case 'X':
          goto LABEL_71;
        case 'L':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
          goto LABEL_78;
        case 'M':
          if (*(_DWORD *)(a1 + 40) <= v28) {
            uint64_t v21 = 0;
          }
          else {
            uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v28);
          }
          goto LABEL_89;
        case 'U':
        case 'V':
        case 'W':
        case 'Z':
        case '[':
          goto LABEL_60;
        case 'Y':
          goto LABEL_68;
        default:
          uint64_t v33 = (v32 - 107);
          if (v33 > 0x24) {
            goto LABEL_70;
          }
          if (((1 << (v32 - 107)) & 0x200000003) != 0)
          {
LABEL_60:
            unsigned int v34 = *(_DWORD *)(a1 + 40);
            if (v34 <= v28) {
              uint64_t v21 = 0;
            }
            else {
              uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v28);
            }
            unint64_t v35 = v31 >> 46;
            if (v34 <= v35) {
              uint64_t v36 = 0;
            }
            else {
              uint64_t v36 = *(void *)(*(void *)(a1 + 24) + 8 * v35);
            }
            BlockAddSuccessor((void *)v30, v21);
            unint64_t v37 = (void *)v30;
            uint64_t v38 = v36;
          }
          else
          {
            if (((1 << (v32 - 107)) & 0xC00000000) != 0)
            {
              if (*(_DWORD *)(a1 + 40) <= v28) {
                uint64_t v21 = 0;
              }
              else {
                uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v28);
              }
              BlockAddSuccessor((void *)v30, v21);
              uint64_t v41 = v20[v25 - 1];
              if (*(_DWORD *)(a1 + 40) <= v41) {
                unint64_t v37 = 0;
              }
              else {
                unint64_t v37 = *(void **)(*(void *)(a1 + 24) + 8 * v41);
              }
              goto LABEL_87;
            }
            if (v33 == 36)
            {
LABEL_68:
              if (*(_DWORD *)(a1 + 40) <= v28) {
                uint64_t v21 = 0;
              }
              else {
                uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v28);
              }
              goto LABEL_82;
            }
LABEL_70:
            if (v32 != 106)
            {
LABEL_78:
              if (*(_DWORD *)(a1 + 40) <= v28 || (uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v28)) == 0)
              {
                uint64_t v21 = v30;
                goto LABEL_89;
              }
LABEL_82:
              unint64_t v37 = (void *)v30;
LABEL_87:
              uint64_t v38 = v21;
              goto LABEL_88;
            }
LABEL_71:
            unsigned int v39 = *(_DWORD *)(a1 + 40);
            if (v39 <= v28) {
              uint64_t v21 = 0;
            }
            else {
              uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * (int)v28);
            }
            unint64_t v40 = v31 >> 46;
            if (v39 <= v40) {
              uint64_t v38 = 0;
            }
            else {
              uint64_t v38 = *(void *)(*(void *)(a1 + 24) + 8 * v40);
            }
            unint64_t v37 = (void *)v30;
          }
LABEL_88:
          BlockAddSuccessor(v37, v38);
LABEL_89:
          unsigned int v42 = (*(_DWORD *)(v22 + 24) >> 6);
          if (v42 <= 0x58)
          {
            if (v42 - 85 >= 3)
            {
              if (v23) {
                int v43 = v24;
              }
              else {
                int v43 = 0;
              }
              if (v42 == 77) {
                int v24 = v43;
              }
              goto LABEL_112;
            }
            goto LABEL_111;
          }
          if ((*(_DWORD *)(v22 + 24) >> 6) <= 0x6Au)
          {
            if (v42 - 89 >= 3) {
              goto LABEL_112;
            }
            goto LABEL_108;
          }
          if ((*(_DWORD *)(v22 + 24) >> 6) <= 0x8Bu)
          {
            if (v42 == 107) {
              goto LABEL_111;
            }
            if (v42 != 108) {
              goto LABEL_112;
            }
            goto LABEL_108;
          }
          if (v42 == 140)
          {
            int v45 = (int *)malloc_type_realloc(v20, 4 * (v25 + 1), 0x2BDC8648uLL);
            if (!v45) {
              goto LABEL_118;
            }
            unint64_t v20 = v45;
            v45[v25++] = v28;
LABEL_111:
            ++v23;
            goto LABEL_112;
          }
          if (v42 == 143)
          {
            unsigned int v44 = (int *)malloc_type_realloc(v20, 4 * --v25, 0x2BDC8648uLL);
            if (!v44) {
              goto LABEL_118;
            }
            unint64_t v20 = v44;
LABEL_108:
            --v23;
          }
LABEL_112:
          uint64_t v22 = *(void *)(v22 + 8);
          if (!v22) {
            goto LABEL_115;
          }
          break;
      }
    }
  }
LABEL_115:

  free(v20);
}

void GetOrAddBlock(uint64_t a1, int a2)
{
  int v4 = a2 + 1;
  if (*(_DWORD *)(a1 + 40) < (a2 + 1))
  {
    int v5 = (char *)malloc_type_realloc(*(void **)(a1 + 24), 8 * v4, 0x2BDC8648uLL);
    if (!v5) {
      abort();
    }
    *(void *)(a1 + 24) = v5;
    bzero(&v5[8 * *(unsigned int *)(a1 + 40)], 8 * (v4 - *(_DWORD *)(a1 + 40)));
    *(_DWORD *)(a1 + 40) = v4;
  }
  if (!*(void *)(*(void *)(a1 + 24) + 8 * a2)) {
    *(void *)(*(void *)(a1 + 24) + 8 * a2) = BlockAdd(a1);
  }
}

void *BlockAddSuccessor(void *result, uint64_t a2)
{
  if (result && a2)
  {
    uint64_t v3 = result;
    unsigned int v4 = *(_DWORD *)(a2 + 4) + 1;
    *(_DWORD *)(a2 + 4) = v4;
    int v5 = malloc_type_realloc(*(void **)(a2 + 24), 8 * v4, 0x2BDC8648uLL);
    if (!v5
      || (*(void *)(a2 + 24) = v5,
          v5[*(_DWORD *)(a2 + 4) - 1] = v3,
          unsigned int v6 = *((_DWORD *)v3 + 2) + 1,
          *((_DWORD *)v3 + 2) = v6,
          (unint64_t result = malloc_type_realloc((void *)v3[4], 8 * v6, 0x2BDC8648uLL)) == 0))
    {
      abort();
    }
    v3[4] = result;
    result[*((_DWORD *)v3 + 2) - 1] = a2;
  }
  return result;
}

void BlocksFree(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 32))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      BlockFree((unsigned int *)(*(void *)(a1 + 8) + v2));
      ++v3;
      v2 += 80;
    }
    while (v3 < *(unsigned int *)(a1 + 32));
  }
  unsigned int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    free(v4);
  }
}

_DWORD *ProgramNew(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x58uLL, 0x7081ABB9uLL);
  if (!v2) {
    goto LABEL_6;
  }
  unint64_t v3 = v2;
  *(void *)uint64_t v2 = a1;
  v2[8] = 0;
  unsigned int v4 = malloc_type_malloc(0x50uLL, 0x7081ABB9uLL);
  if (!v4
    || (*((void *)v3 + 1) = v4, v3[9] = 0, (int v5 = malloc_type_malloc(0x38uLL, 0x7081ABB9uLL)) == 0)
    || (*((void *)v3 + 2) = v5, v3[10] = 0, (unsigned int v6 = malloc_type_malloc(8uLL, 0x7081ABB9uLL)) == 0))
  {
LABEL_6:
    abort();
  }
  *((void *)v3 + 3) = v6;
  *(_OWORD *)(v3 + 11) = 0u;
  *(_OWORD *)(v3 + 15) = 0u;
  *(void *)(v3 + 19) = 0;
  return v3;
}

void ProgramFree(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2) {
    free(v2);
  }
  RegistersFree((uint64_t)a1);
  BlocksFree((uint64_t)a1);

  free(a1);
}

void FlattenIfs(uint64_t a1)
{
  uint64_t v1 = **(void ***)(a1 + 104);
  if (!v1) {
    return;
  }
  do
  {
    if ((v1[3] & 0x3FC0) != 0x1540)
    {
LABEL_33:
      unint64_t v18 = (void **)(v1 + 1);
      goto LABEL_34;
    }
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = v1[3] >> 46;
    int v6 = 1;
    unsigned int v7 = v1;
    do
    {
      uint64_t v8 = v7;
      if (v3 && *((_DWORD *)v7 + 22) == v5)
      {
        unint64_t v9 = *(void *)(v3 + 24);
        int v10 = (v9 >> 6);
        if (v10 == 88)
        {
          uint64_t v5 = v9 >> 46;
          uint64_t v4 = v3;
        }
        else if (v10 == 89)
        {
          goto LABEL_30;
        }
      }
      unint64_t v11 = v8[3];
      int v12 = (v11 >> 6);
      char v13 = v12 - 75;
      if ((v12 - 75) > 0x3D) {
        goto LABEL_16;
      }
      if (((1 << v13) & 0x3000738000000006) != 0) {
        goto LABEL_12;
      }
      if (((1 << v13) & 0x80000201) != 0)
      {
        if ((int)v5 <= (int)(v11 >> 46)) {
          int v6 = 0;
        }
      }
      else
      {
LABEL_16:
        if (v12 == 170) {
LABEL_12:
        }
          int v6 = 0;
      }
      if ((v11 & 7) != 0)
      {
        unint64_t v14 = 0;
        do
        {
          if (v14 < (v11 & 7) + ((__int16)v11 >> 15) && (v8[v14 + 5] & 0x60001) != 0) {
            int v6 = 0;
          }
          ++v14;
        }
        while ((v8[3] & 7) != v14);
      }
      uint64_t v15 = v8[4];
      if ((v15 & 0x100180000) != 0 && (v15 & 0x78000) != 0) {
        int v6 = 0;
      }
      unsigned int v7 = (void *)v8[1];
      uint64_t v3 = (uint64_t)v8;
    }
    while (v7);
    uint64_t v3 = 0;
LABEL_30:
    if (!v6) {
      goto LABEL_33;
    }
    uint64_t v17 = *v1;
    FlattenIf(a1, (uint64_t)v1, v4, v3);
    if (v17) {
      unint64_t v18 = (void **)(v17 + 8);
    }
    else {
      unint64_t v18 = *(void ***)(a1 + 104);
    }
LABEL_34:
    uint64_t v1 = *v18;
  }
  while (*v18);
}

void FlattenIf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = 0;
  v120[2] = *MEMORY[0x263EF8340];
  uint64_t v97 = *(void *)(a2 + 40);
  uint64_t v110 = 0;
  memset(v109, 0, sizeof(v109));
  uint64_t v108 = 0;
  memset(v107, 0, sizeof(v107));
  v120[0] = v109;
  v120[1] = v107;
  unint64_t v101 = (unint64_t)((v97 >> 9) & 3) << 9;
  char v7 = 1;
  do
  {
    char v9 = v7;
    memset(&v106[1], 0, 64);
    DWORD1(v106[4]) = *(_DWORD *)(a2 + 92);
    unint64_t v10 = *(void *)(a2 + 24) & 0x1C000380000;
    *(void *)&v106[0] = v10 | ((unint64_t)dword_2393DBDD0[v6] << 6) | 0x100000001;
    unint64_t v11 = ((unint64_t)((v97 >> 9) & 3) << 21) | 0x40000;
    switch((v97 >> 9) & 3)
    {
      case 0u:
        break;
      case 1u:
        unint64_t v11 = (((v97 >> 9) & 3) << 21) | 0x20000;
        break;
      case 2u:
        unint64_t v11 = (((v97 >> 9) & 3) << 21) | 0x10000;
        break;
      case 3u:
        unint64_t v11 = (((v97 >> 9) & 3) << 21) | 0x8000;
        break;
      default:
        JUMPOUT(0);
    }
    *((void *)&v106[0] + 1) = v11 & 0xFFFFFFFFFFFF8FFFLL | 0x1000;
    HIWORD(v106[0]) = AddTempRegister(a1, v10 >> 19, v10 >> 38, v11 >> 21);
    *(void *)&v106[1] = *(void *)&v106[1] & 0xFFFFFFE7F82FLL | *(void *)(a2 + 40) & 0xFFFF0000000001D0 | v101;
    PPStreamInsertOperationBeforeChunk(a1, (uint64_t)v106, 0, a2);
    char v7 = 0;
    int v12 = (_DWORD *)v120[v6];
    v12[1] = (DWORD2(v106[0]) >> 12) & 7;
    *int v12 = HIWORD(v106[0]);
    uint64_t v13 = (*(void *)&v106[0] >> 38) & 7;
    v12[2] = (LODWORD(v106[0]) >> 19) & 7;
    v12[3] = v13;
    v12[4] = (DWORD2(v106[0]) >> 21) & 3;
    uint64_t v6 = 1;
  }
  while ((v9 & 1) != 0);
  unint64_t v14 = HashTableNew((*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
  BOOL v100 = HashTableNew((*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
  if (a3)
  {
    uint64_t v15 = HashTableNew((*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
    uint64_t v16 = HashTableNew((*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
    uint64_t v17 = a3;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = a4;
  }
  uint32x4_t v102 = HashSetNew((*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
  uint64_t v18 = 0;
  v119[0] = v14;
  v119[1] = v15;
  v118[0] = v100;
  v118[1] = v16;
  v117[0] = a2;
  v117[1] = a3;
  v116[0] = v17;
  v116[1] = a4;
  uint64_t v98 = a4;
  char v19 = 1;
  do
  {
    char v99 = v19;
    uint64_t v20 = v117[v18];
    if (v20)
    {
      uint64_t v21 = *(void *)(v20 + 8);
      uint64_t v22 = v116[v18];
      uint64_t v104 = v22;
      while (v21 != v22)
      {
        uint64_t v23 = *(void *)(v21 + 24) & 7;
        if (v23)
        {
          uint64_t v24 = 0;
          uint64_t v25 = v21 + 40;
          do
          {
            if (v24 < (*(_DWORD *)(v21 + 24) & 7) + ((__int16)*(_DWORD *)(v21 + 24) >> 15))
            {
              memset(v106, 0, 40);
              uint64_t v26 = v25 + 8 * v24;
              DWORD1(v106[0]) = (*(void *)v26 >> 6) & 7;
              LODWORD(v106[0]) = *(unsigned __int16 *)(v26 + 6);
              uint64_t v27 = (uint64_t *)v119[v18];
              uint64_t v28 = HashTableGet(v27, (uint64_t)v106);
              if (v28)
              {
                uint64_t v30 = (_DWORD *)v28;
                HashTableGet((uint64_t *)v118[v18], v28);
              }
              else
              {
                GetRegisterTypeInfo((uint64_t **)a1, (uint64_t)v106, v29);
                unint64_t v31 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
                if (!v31) {
                  goto LABEL_89;
                }
                uint64_t v32 = (uint64_t)v31;
                long long v33 = v106[0];
                long long v34 = v106[1];
                v31[4] = *(void *)&v106[2];
                *(_OWORD *)unint64_t v31 = v33;
                *((_OWORD *)v31 + 1) = v34;
                unint64_t v35 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
                if (!v35) {
                  goto LABEL_89;
                }
                uint64_t v30 = v35;
                long long v37 = v106[0];
                long long v36 = v106[1];
                *((void *)v35 + 4) = *(void *)&v106[2];
                *(_OWORD *)unint64_t v35 = v37;
                *((_OWORD *)v35 + 1) = v36;
                v35[1] = 1;
                *unint64_t v35 = AddTempRegister(a1, SBYTE8(v106[0]), SBYTE12(v106[0]), v106[1]);
                HashTableAdd(v27, v32, (uint64_t)v30);
                HashTableAdd((uint64_t *)v118[v18], (uint64_t)v30, v32);
              }
              unint64_t v38 = *(void *)(v25 + 8 * v24) & 0xFFFFFFFFFFFFFE3FLL | ((unint64_t)(v30[1] & 7) << 6);
              *(void *)(v25 + 8 * v24) = v38;
              *(void *)(v25 + 8 * v24) = v38 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*v30 << 48);
            }
            ++v24;
          }
          while (v23 != v24);
        }
        if ((*(_DWORD *)(v21 + 32) & 0x78000) != 0)
        {
          memset(v106, 0, 40);
          unint64_t v39 = *(void *)(v21 + 32);
          LODWORD(v106[0]) = HIWORD(v39);
          DWORD1(v106[0]) = (v39 >> 12) & 7;
          unint64_t v40 = (uint64_t *)v119[v18];
          uint64_t v41 = HashTableGet(v40, (uint64_t)v106);
          if (v41)
          {
            int v43 = (_DWORD *)v41;
            uint64_t v44 = HashTableGet((uint64_t *)v118[v18], v41);
          }
          else
          {
            GetRegisterTypeInfo((uint64_t **)a1, (uint64_t)v106, v42);
            int v45 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
            if (!v45
              || (uint64_t v44 = (uint64_t)v45,
                  long long v46 = v106[0],
                  long long v47 = v106[1],
                  v45[4] = *(void *)&v106[2],
                  *(_OWORD *)int v45 = v46,
                  *((_OWORD *)v45 + 1) = v47,
                  (unsigned int v48 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL)) == 0))
            {
LABEL_89:
              abort();
            }
            int v43 = v48;
            long long v50 = v106[0];
            long long v49 = v106[1];
            *((void *)v48 + 4) = *(void *)&v106[2];
            *(_OWORD *)unsigned int v48 = v50;
            *((_OWORD *)v48 + 1) = v49;
            v48[1] = 1;
            *unsigned int v48 = AddTempRegister(a1, SBYTE8(v106[0]), SBYTE12(v106[0]), v106[1]);
            HashTableAdd(v40, v44, (uint64_t)v43);
            HashTableAdd((uint64_t *)v118[v18], (uint64_t)v43, v44);
          }
          if (v102) {
            HashSetAdd((uint64_t)v102, v44);
          }
          unint64_t v51 = *(void *)(v21 + 32) & 0xFFFFFFFFFFFF8FFFLL | ((unint64_t)(v43[1] & 7) << 12);
          *(void *)(v21 + 32) = v51;
          *(void *)(v21 + 32) = v51 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*v43 << 48);
        }
        if ((*(void *)(v21 + 24) & 0x3FC0) == 0x13C0)
        {
          memset((char *)v106 + 8, 0, 72);
          DWORD1(v106[4]) = *(_DWORD *)(v21 + 92);
          unint64_t v52 = *(void *)(v21 + 24) & 0x1C000380000;
          *(void *)&v106[0] = v52 | 0x100000902;
          unint64_t v53 = ((unint64_t)((v97 >> 9) & 3) << 21) | 0x40000;
          switch((v97 >> 9) & 3)
          {
            case 1u:
              unint64_t v53 = (((v97 >> 9) & 3) << 21) | 0x20000;
              break;
            case 2u:
              unint64_t v53 = (((v97 >> 9) & 3) << 21) | 0x10000;
              break;
            case 3u:
              unint64_t v53 = (((v97 >> 9) & 3) << 21) | 0x8000;
              break;
            default:
              break;
          }
          *((void *)&v106[0] + 1) = v53 & 0xFFFFFFFFFFFF8FFFLL | 0x1000;
          uint64_t v54 = AddTempRegister(a1, v52 >> 19, v52 >> 38, v53 >> 21);
          uint64_t v55 = 0;
          unint64_t v56 = *((void *)&v106[0] + 1);
          HIWORD(v106[0]) = v54;
          unint64_t v57 = *(void *)(v21 + 40);
          LODWORD(v111) = (v57 >> 9) & 3;
          HIDWORD(v111) = (v97 >> 9) & 3;
          unsigned int v58 = (_DWORD *)v120[v18];
          int v59 = v58[1];
          LODWORD(v114[0]) = (v57 >> 6) & 7;
          HIDWORD(v114[0]) = v59;
          LODWORD(v58) = *v58;
          v113.i32[0] = HIWORD(v57);
          v113.i32[1] = (int)v58;
          v115[0] = (v57 & 0x10) == 0;
          v115[1] = 0;
          char v60 = 1;
          do
          {
            char v61 = v60;
            *((void *)&v106[1] + v55) = *((void *)&v106[1] + v55) & 0xFFFFFFE7F82FLL | ((unint64_t)(*((_DWORD *)&v111 + v55) & 3) << 9) | ((unint64_t)(*((_DWORD *)v114 + v55) & 7) << 6) | ((unint64_t)v113.u32[v55] << 48) | (16 * (v115[v55] & 1));
            uint64_t v55 = 1;
            char v60 = 0;
          }
          while ((v61 & 1) != 0);
          *(void *)(v21 + 40) = (v56 >> 6) & 0x1C0 | v101 | (v54 << 48) | *(void *)(v21 + 40) & 0xFFFFFFFFF82FLL | 0x10;
          PPStreamInsertOperationBeforeChunk(a1, (uint64_t)v106, 0, v21);
        }
        uint64_t v21 = *(void *)(v21 + 8);
        uint64_t v22 = v104;
      }
    }
    char v19 = 0;
    uint64_t v18 = 1;
  }
  while ((v99 & 1) != 0);
  uint64_t v62 = 0;
  char v63 = 1;
  unint64_t v64 = (void *)v98;
  uint64_t v65 = a1;
  do
  {
    char v66 = v63;
    uint64_t v67 = v117[v62];
    if (v67)
    {
      uint64_t v111 = 0;
      v112.i64[0] = 0;
      HashSetIteratorSetup(*(void *)v119[v62], &v111);
      while (1)
      {
        uint64_t v68 = HashSetIteratorNext((unsigned int *)&v111);
        if (!v68) {
          break;
        }
        unint64_t v70 = *(unsigned int **)v68;
        int v69 = *(unsigned int **)(v68 + 8);
        memset((char *)v106 + 8, 0, 72);
        DWORD1(v106[4]) = *(_DWORD *)(v67 + 92);
        *(void *)&v106[0] = 0x100000001;
        unint64_t v71 = (unint64_t)(v69[4] & 3) << 21;
        unint64_t v72 = v71 | 0x72000000;
        switch(v69[4] & 3)
        {
          case 1u:
            goto LABEL_50;
          case 2u:
            goto LABEL_49;
          case 3u:
            unint64_t v72 = v71 | 0x72008000;
LABEL_49:
            v72 |= 0x10000uLL;
LABEL_50:
            v72 |= 0x20000uLL;
            break;
          default:
            break;
        }
        *((void *)&v106[0] + 1) = v72 | 0x40000;
        *((void *)&v106[0] + 1) = v72 & 0xFFFFFFFFFFFB8FFFLL | 0x40000 | ((unint64_t)(v69[1] & 7) << 12);
        *((void *)&v106[0] + 1) |= (unint64_t)*v69 << 48;
        *(void *)&v106[1] = (v72 >> 2) & 0x180000 | 0x1C800;
        *(void *)&v106[1] |= (v70[1] & 7) << 6;
        *(void *)&v106[1] |= (unint64_t)*v70 << 48;
        *(void *)&v106[0] = ((unint64_t)(v69[3] & 7) << 38) | ((v69[2] & 7) << 19) | ((unint64_t)(v69[4] & 3) << 36) | 0x100000001;
        PPStreamInsertOperationAfterChunk(a1, (uint64_t)v106, 0, v67);
      }
      PPStreamRemoveOperation(a1, (void *)v67);
    }
    char v63 = 0;
    uint64_t v62 = 1;
  }
  while ((v66 & 1) != 0);
  v114[0] = 0;
  v114[1] = 0;
  HashSetIteratorSetup((uint64_t)v102, v114);
  uint64_t v73 = HashSetIteratorNext((unsigned int *)v114);
  if (v73)
  {
    unsigned int v74 = (unsigned int *)v73;
    do
    {
      uint64_t v75 = 0;
      int8x16_t v113 = 0uLL;
      char v76 = 1;
      do
      {
        char v77 = v76;
        unsigned int v78 = (uint64_t *)v119[v75];
        if (v78) {
          v113.i64[v75] = HashTableGet(v78, (uint64_t)v74);
        }
        char v76 = 0;
        uint64_t v75 = 1;
      }
      while ((v77 & 1) != 0);
      int8x16_t v113 = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)v113), (int8x16_t)vdupq_n_s64((unint64_t)v74), v113);
      unint64_t v64 = (void *)v98;
      uint64_t v65 = a1;
      if (v113.i64[0] != v113.i64[1])
      {
        memset((char *)v106 + 8, 0, 72);
        DWORD1(v106[4]) = *(_DWORD *)(v98 + 92);
        *(void *)&v106[0] = 0x100000F83;
        uint64_t v79 = v74[4] & 3;
        unint64_t v80 = (v79 << 21) | 0x72000000;
        switch(v79)
        {
          case 1:
            goto LABEL_64;
          case 2:
            goto LABEL_63;
          case 3:
            unint64_t v80 = (v79 << 21) | 0x72008000;
LABEL_63:
            v80 |= 0x10000uLL;
LABEL_64:
            v80 |= 0x20000uLL;
            break;
          default:
            break;
        }
        uint64_t v81 = 0;
        *((void *)&v106[0] + 1) = v80 | 0x40000;
        *((void *)&v106[0] + 1) = v80 & 0xFFFFFFFFFFFB8FFFLL | 0x40000 | ((unint64_t)(v74[1] & 7) << 12);
        *((void *)&v106[0] + 1) |= (unint64_t)*v74 << 48;
        uint64_t v111 = v109;
        int8x16_t v112 = v113;
        uint64_t v82 = (v80 >> 2) & 0x180000;
        do
        {
          int v83 = (char *)v106 + 8 * v81;
          if ((v81 - 1) >= 2) {
            uint64_t v84 = v97 & 0x600;
          }
          else {
            uint64_t v84 = 0;
          }
          if ((v81 - 1) >= 2) {
            uint64_t v85 = ((v97 >> 9) & 3) << 11;
          }
          else {
            uint64_t v85 = 2048;
          }
          if ((v81 - 1) >= 2) {
            uint64_t v86 = ((v97 >> 9) & 3) << 13;
          }
          else {
            uint64_t v86 = 0x4000;
          }
          if ((v81 - 1) >= 2) {
            uint64_t v87 = ((v97 >> 9) & 3) << 15;
          }
          else {
            uint64_t v87 = 98304;
          }
          unint64_t v88 = v84 | v82 | v85 | v86 | v87 | *((void *)v83 + 2) & 0xFFFFFFFFFFE601FFLL;
          *((void *)v83 + 2) = v88;
          int v89 = (unsigned int *)*(&v111 + v81);
          unint64_t v90 = v88 & 0xFFFFFFFFFFFFFE3FLL | ((unint64_t)(v89[1] & 7) << 6);
          *((void *)v83 + 2) = v90;
          *((void *)v83 + 2) = v90 & 0xFFFFFFFFFFEFLL | ((unint64_t)*v89 << 48) | (16
                                                                                          * (dword_2393DBDD8[v81++] & 1));
        }
        while (v81 != 3);
        *(void *)&v106[0] = ((v74[2] & 7) << 19) | 0x100000F83 | ((unint64_t)(v74[3] & 7) << 38) | ((unint64_t)(v74[4] & 3) << 36);
        PPStreamInsertOperationAfterChunk(a1, (uint64_t)v106, 0, v98);
      }
      unsigned int v74 = (unsigned int *)HashSetIteratorNext((unsigned int *)v114);
    }
    while (v74);
  }
  PPStreamRemoveOperation(v65, v64);
  uint64_t v91 = 0;
  char v92 = 1;
  do
  {
    char v93 = v92;
    uint64_t v94 = (uint64_t *)v119[v91];
    if (v94)
    {
      v106[0] = 0uLL;
      HashSetIteratorSetup(*v94, v106);
      uint64_t v95 = HashSetIteratorNext((unsigned int *)v106);
      if (v95)
      {
        unint64_t v96 = (void **)v95;
        do
        {
          free(*v96);
          free(v96[1]);
          unint64_t v96 = (void **)HashSetIteratorNext((unsigned int *)v106);
        }
        while (v96);
      }
      HashTableFree(v94);
      HashTableFree((uint64_t *)v118[v91]);
    }
    char v92 = 0;
    uint64_t v91 = 1;
  }
  while ((v93 & 1) != 0);
  HashSetFree(v102);
}

uint64_t AddTempRegister(uint64_t a1, char a2, char a3, char a4)
{
  *((void *)&v9 + 1) = 0;
  DWORD2(v9) = PPStreamChunkListGetNextIndex(*(uint64_t **)(a1 + 32));
  *(void *)&long long v9 = a2 & 7 | (8 * (a3 & 7)) & 0x3F | ((a4 & 3) << 6);
  PPStreamAddTempUsage(a1, &v9);
  return DWORD2(v9);
}

uint64_t regHashFunction(unsigned int *a1)
{
  return *a1;
}

uint64_t regEqualsFunction(_DWORD *a1, _DWORD *a2)
{
  int v3 = a1[1];
  int v4 = a2[1];
  uint64_t result = (v3 - v4);
  if (v3 == v4) {
    return (*a1 - *a2);
  }
  return result;
}

double GetRegisterTypeInfo(uint64_t **a1, uint64_t a2, int32x4_t a3)
{
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      uint64_t v6 = PPStreamChunkListChunkAtIndex(a1[6], *(_DWORD *)a2);
      if (v6) {
        goto LABEL_7;
      }
      goto LABEL_8;
    case 1:
      uint64_t v5 = a1[4];
      goto LABEL_6;
    case 2:
      uint64_t v7 = PPStreamChunkListChunkAtIndex(a1[7], *(_DWORD *)a2);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v7 + 24) & 7;
      *(_DWORD *)(a2 + 12) = (*(_DWORD *)(v7 + 24) >> 3) & 7;
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(v7 + 24) >> 6;
      *(_DWORD *)(a2 + 20) = 0;
      if ((*(void *)(v7 + 24) & 0x1F00) == 0x600)
      {
        *(_DWORD *)(a2 + 20) = 1;
        a3 = *(int32x4_t *)(PPStreamChunkListChunkAtIndex(a1[16], *(unsigned __int16 *)(v7 + 28)) + 24);
        if (*(_DWORD *)(a2 + 12)) {
          a3 = (int32x4_t)vcvtq_f32_s32(a3);
        }
        *(int32x4_t *)(a2 + 24) = a3;
      }
      return *(double *)a3.i64;
    case 3:
    case 5:
      uint64_t v5 = a1[8];
LABEL_6:
      uint64_t v6 = PPStreamChunkListChunkAtIndex(v5, *(_DWORD *)a2);
LABEL_7:
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 24) & 7;
      *(_DWORD *)(a2 + 12) = (*(_DWORD *)(v6 + 24) >> 3) & 7;
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(v6 + 24) >> 6;
LABEL_8:
      *(_DWORD *)(a2 + 20) = 0;
      break;
    case 4:
      a3.i64[0] = 0x200000000;
      *(_OWORD *)(a2 + 8) = xmmword_2393DBD60;
      break;
    default:
      return *(double *)a3.i64;
  }
  return *(double *)a3.i64;
}

void DetectConstantLoopsSimple(uint64_t **a1)
{
  uint64_t v158 = *MEMORY[0x263EF8340];
  uint64_t v1 = (uint64_t *)*a1[13];
  if (!v1) {
    return;
  }
  do
  {
    while (2)
    {
      while ((v1[3] & 0x3FC0) != 0x1AC0)
      {
        uint64_t v1 = (uint64_t *)v1[1];
        if (!v1) {
          return;
        }
      }
      uint64_t v122 = 0;
      long long v120 = 0u;
      long long v121 = 0u;
      memset(v119, 0, 44);
      memset(v118, 0, 44);
      uint64_t v3 = *v1;
      uint64_t v95 = (uint64_t)v1;
      if (*v1 && (*(_WORD *)(v3 + 24) & 0x3FC0) == 0)
      {
        GetOpRegs(a1, v3, &v152, &v120, (int32x4_t)0);
        int v5 = IsBadUsage(v3);
        unsigned int v101 = v120;
        unsigned int v4 = DWORD1(v120);
        int v91 = v121;
        int v92 = HIDWORD(v120);
        v118[0] = v152;
        v118[1] = v153;
        *(void *)&void v118[2] = v154;
        DWORD2(v118[2]) = DWORD2(v118[2]) & 0xFFFFFFFC | (*(_DWORD *)(v3 + 40) >> 9) & 3;
        DWORD2(v118[2]) = DWORD2(v118[2]) & 0xFFFFFFF3 | (4 * ((*(_DWORD *)(v3 + 40) >> 11) & 3));
        DWORD2(v118[2]) = DWORD2(v118[2]) & 0xFFFFFFCF | (16 * ((*(_DWORD *)(v3 + 40) >> 13) & 3));
        DWORD2(v118[2]) = DWORD2(v118[2]) & 0xFFFFFF3F | (((*(_DWORD *)(v3 + 40) >> 15) & 3) << 6);
      }
      else
      {
        unsigned int v101 = 0;
        unsigned int v4 = 0;
        int v91 = 0;
        int v92 = 0;
        int v5 = 1;
      }
      unsigned int v98 = v4;
      memset(v117, 0, 44);
      uint64_t v6 = *(void *)(v95 + 8);
      if ((*(void *)(v6 + 24) & 0x3FC0) == 0x1BC0) {
        uint64_t v6 = *(void *)(v6 + 8);
      }
      uint64_t v7 = *(void *)(v6 + 8);
      unint64_t v96 = *(void **)(v7 + 8);
      GetOpRegs(a1, v6, &v152, &v120, (int32x4_t)0);
      int v8 = IsBadUsage(v6);
      BOOL v10 = v98 == v152.i32[1] && v101 == v152.i32[0];
      int v11 = v10;
      if (v10)
      {
        int32x4_t v9 = v155;
        v117[0] = v155;
        v117[1] = v156;
        *(void *)&void v117[2] = v157;
        unsigned int v12 = DWORD2(v117[2]) & 0xFFFFFF00 | (*(_DWORD *)(v6 + 48) >> 9);
LABEL_23:
        int v13 = v8 | v5;
        DWORD2(v117[2]) = v12;
        int v14 = v11;
        goto LABEL_24;
      }
      int v13 = 1;
      if (v98 != v155.i32[1])
      {
        int v14 = 1;
        goto LABEL_24;
      }
      int v14 = 1;
      if (v101 == v155.i32[0])
      {
        int32x4_t v9 = v152;
        v117[0] = v152;
        v117[1] = v153;
        *(void *)&void v117[2] = v154;
        DWORD2(v117[2]) = DWORD2(v117[2]) & 0xFFFFFFFC | (*(_DWORD *)(v6 + 40) >> 9) & 3;
        DWORD2(v117[2]) = DWORD2(v117[2]) & 0xFFFFFFF3 | (4 * ((*(_DWORD *)(v6 + 40) >> 11) & 3));
        DWORD2(v117[2]) = DWORD2(v117[2]) & 0xFFFFFFCF | (16 * ((*(_DWORD *)(v6 + 40) >> 13) & 3));
        unsigned int v12 = DWORD2(v117[2]) & 0xFFFFFF3F | (((*(_DWORD *)(v6 + 40) >> 15) & 3) << 6);
        goto LABEL_23;
      }
LABEL_24:
      int v15 = 0;
      int v16 = 0;
      int v17 = 1;
      char v18 = 1;
      uint64_t v19 = v95;
      switch((*(_DWORD *)(v6 + 24) >> 6))
      {
        case '2':
          int v17 = 0;
          char v18 = 0;
          int v15 = 1;
          goto LABEL_28;
        case '3':
          int v17 = 0;
          int v16 = 0;
          int v15 = 1;
          break;
        case '4':
          int v15 = 0;
          char v18 = 0;
LABEL_28:
          int v16 = 1;
          break;
        case '5':
          break;
        default:
          int v15 = 0;
          int v16 = 0;
          int v13 = 1;
          int v17 = 1;
          char v18 = 1;
          uint64_t v19 = v95;
          break;
      }
      if (v14) {
        int v20 = v15;
      }
      else {
        int v20 = v17;
      }
      int v90 = v20;
      if (v96) {
        BOOL v21 = (v96[3] & 0x3FC0) != 5440;
      }
      else {
        BOOL v21 = 1;
      }
      char v88 = v18;
      int v89 = v16;
      int v22 = v13 | ((*(void *)(v7 + 24) & 0x3FC0) != 640) | v21;
      if (v22)
      {
        int v23 = 0;
        int v99 = 0;
        uint64_t v94 = 0;
        int v93 = 0;
        uint64_t v24 = 0;
        BOOL v25 = 1;
        goto LABEL_38;
      }
      uint64_t v62 = 0;
      int v93 = 0;
      uint64_t v94 = 0;
      int v99 = 0;
      int v23 = 0;
      uint64_t v63 = 0;
      uint64_t v97 = *(void *)(v19 + 24) >> 46;
      uint64_t v64 = v19;
      while (1)
      {
        uint64_t v65 = (void *)v64;
        if (v62)
        {
          if (*(_DWORD *)(v64 + 88) == v97 && (v62[3] & 0x3FC0) == 0x1B00) {
            break;
          }
        }
        unsigned int v66 = (*(_DWORD *)(v64 + 24) >> 6) - 85;
        int v102 = v23;
        if (v66 <= 0x3A)
        {
          if (((1 << v66) & 0x80000000400007) != 0)
          {
            int v67 = 1;
            goto LABEL_112;
          }
          if (((1 << v66) & 0x400000000800070) != 0)
          {
            int v67 = -1;
LABEL_112:
            uint64_t v68 = (v67 + v63);
            goto LABEL_113;
          }
        }
        uint64_t v68 = v63;
LABEL_113:
        GetOpRegs(a1, v64, &v152, &v120, v9);
        int v69 = IsBadUsage((uint64_t)v65);
        int v70 = DWORD1(v120);
        int v71 = v120;
        unsigned int v72 = v98;
        if (v98 == DWORD1(v120) && v101 == v120)
        {
          uint64_t v63 = v68;
          if (v99)
          {
            int v74 = 1;
            int v99 = 1;
          }
          else
          {
            int v75 = v69;
            uint64_t v76 = v65[3];
            if ((v76 & 0x3FC0) != 0)
            {
              char v77 = v65;
            }
            else
            {
              uint64_t v78 = *v65;
              char v77 = v65;
              if ((*(_DWORD *)(*v65 + 24) >> 6) - 31 <= 1)
              {
                memset(v103, 0, 40);
                uint64_t v100 = v78;
                GetOpRegs(a1, (uint64_t)v65, &v135, v103, (int32x4_t)0);
                uint64_t v125 = 0;
                long long v123 = 0u;
                long long v124 = 0u;
                GetOpRegs(a1, v100, &v152, &v123, (int32x4_t)0);
                uint64_t v63 = v68;
                unsigned int v72 = v98;
                int v79 = DWORD1(v135) - DWORD1(v123);
                if (DWORD1(v135) == DWORD1(v123)) {
                  int v79 = v135 - v123;
                }
                if (v79) {
                  char v77 = v65;
                }
                else {
                  char v77 = (void *)v100;
                }
                uint64_t v76 = v77[3];
              }
            }
            int v74 = v75 | ((int)v68 > 1);
            int v80 = (v76 >> 6);
            if (v80 != 31)
            {
              if (v80 == 32) {
                int v93 = 1;
              }
              else {
                int v74 = 1;
              }
            }
            if (__PAIR64__(v72, v101) == v152.i64[0])
            {
              int32x4_t v9 = v155;
              v119[0] = v155;
              v119[1] = v156;
              *(void *)&void v119[2] = v157;
              BYTE8(v119[2]) = *((_DWORD *)v77 + 12) >> 9;
            }
            else
            {
              int v99 = 1;
              if (__PAIR64__(v72, v101) != v155.i64[0])
              {
                int v74 = 1;
                goto LABEL_141;
              }
              int32x4_t v9 = v152;
              v119[0] = v152;
              v119[1] = v153;
              *(void *)&void v119[2] = v154;
              DWORD2(v119[2]) = DWORD2(v119[2]) & 0xFFFFFFFC | (*((_DWORD *)v77 + 10) >> 9) & 3;
              DWORD2(v119[2]) = DWORD2(v119[2]) & 0xFFFFFFF3 | (4 * ((*((_DWORD *)v77 + 10) >> 11) & 3));
              DWORD2(v119[2]) = DWORD2(v119[2]) & 0xFFFFFFCF | (16 * ((*((_DWORD *)v77 + 10) >> 13) & 3));
              DWORD2(v119[2]) = DWORD2(v119[2]) & 0xFFFFFF3F | (((*((_DWORD *)v77 + 10) >> 15) & 3) << 6);
              v74 |= v93;
            }
            int v99 = 1;
          }
        }
        else
        {
          int v74 = 0;
          uint64_t v63 = v68;
        }
LABEL_141:
        int v81 = DWORD1(v117[0]) - v70;
        if (DWORD1(v117[0]) == v70) {
          int v81 = LODWORD(v117[0]) - v71;
        }
        BOOL v82 = v81 == 0;
        unint64_t v83 = v65[3];
        BOOL v84 = 1;
        unsigned int v85 = (v83 >> 6) - 75;
        if (v85 <= 0x1F) {
          BOOL v84 = ((1 << v85) & 0x80000005) == 0;
        }
        if (v102)
        {
          int v23 = 1;
        }
        else
        {
          int v86 = (v83 >> 6);
          if (v86 == 89)
          {
            int v23 = 1;
            uint64_t v94 = v65;
          }
          else if (v86 == 85)
          {
            int v23 = 0;
            if (v96 != v65) {
              BOOL v84 = 0;
            }
          }
          else
          {
            int v23 = 0;
          }
        }
        uint64_t v24 = 0;
        int v22 = v74 | v82;
        BOOL v25 = v84;
        if (v84)
        {
          uint64_t v64 = v65[1];
          if (v64)
          {
            uint64_t v62 = v65;
            if (!v22) {
              continue;
            }
          }
        }
        goto LABEL_38;
      }
      int v22 = 0;
      BOOL v25 = 1;
      uint64_t v24 = v62;
LABEL_38:
      if (HIDWORD(v119[0]) != 2 || HIDWORD(v117[0]) != 2 || HIDWORD(v118[0]) != 2 || v92 != 2) {
        int v22 = 1;
      }
      if (v91
        || (int v29 = BYTE8(v119[2]) & 3, v29 != ((DWORD2(v119[2]) >> 2) & 3))
        || v29 != ((DWORD2(v119[2]) >> 4) & 3)
        || v29 != BYTE8(v119[2]) >> 6
        || (int v30 = BYTE8(v118[2]) & 3, v30 != ((DWORD2(v118[2]) >> 2) & 3))
        || v30 != ((DWORD2(v118[2]) >> 4) & 3)
        || v30 != BYTE8(v118[2]) >> 6
        || (int v31 = BYTE8(v117[2]) & 3, v31 != ((DWORD2(v117[2]) >> 2) & 3))
        || v31 != ((DWORD2(v117[2]) >> 4) & 3)
        || v31 != BYTE8(v117[2]) >> 6)
      {
        int v22 = 1;
      }
      int v32 = v22 | (DWORD1(v119[1]) == 0);
      if ((SDWORD2(v119[1]) & 0x80000000) == 0) {
        BOOL v33 = v93 != 0;
      }
      else {
        BOOL v33 = v93 == 0;
      }
      if (v32) {
        int v34 = 0;
      }
      else {
        int v34 = (v90 == 0) ^ v33;
      }
      if (!v99) {
        int v34 = 0;
      }
      if (!v23) {
        int v34 = 0;
      }
      if (!v96) {
        int v34 = 0;
      }
      if (!v94) {
        int v34 = 0;
      }
      if ((v25 & v34) != 1)
      {
        uint64_t v1 = *(uint64_t **)(v95 + 8);
        if (!v1) {
          return;
        }
        continue;
      }
      break;
    }
    memset(v116, 0, 44);
    DWORD1(v116[0]) = 1;
    HIDWORD(v116[0]) = 0;
    *((void *)&v135 + 1) = 0;
    DWORD2(v135) = PPStreamChunkListGetNextIndex(a1[4]);
    *(void *)&long long v135 = 0;
    PPStreamAddTempUsage((uint64_t)a1, &v135);
    LODWORD(v116[0]) = DWORD2(v135);
    BYTE8(v116[2]) = -28;
    long long v114 = v116[0];
    v115[0] = v116[1];
    *(_OWORD *)((char *)v115 + 12) = *(_OWORD *)((char *)&v116[1] + 12);
    LODWORD(v114) = AddTempRegister((uint64_t)a1, SBYTE8(v116[0]), SBYTE12(v116[0]), v116[1]);
    long long v112 = v116[0];
    v113[0] = v116[1];
    *(_OWORD *)((char *)v113 + 12) = *(_OWORD *)((char *)&v116[1] + 12);
    LODWORD(v112) = AddTempRegister((uint64_t)a1, SBYTE8(v116[0]), SBYTE12(v116[0]), v116[1]);
    long long v110 = v116[0];
    v111[0] = v116[1];
    *(_OWORD *)((char *)v111 + 12) = *(_OWORD *)((char *)&v116[1] + 12);
    LODWORD(v110) = AddTempRegister((uint64_t)a1, SBYTE8(v116[0]), SBYTE12(v116[0]), v116[1]);
    long long v108 = v116[0];
    v109[0] = v116[1];
    *(_OWORD *)((char *)v109 + 12) = *(_OWORD *)((char *)&v116[1] + 12);
    LODWORD(v108) = AddTempRegister((uint64_t)a1, SBYTE8(v116[0]), SBYTE12(v116[0]), v116[1]);
    memset(v107, 0, 44);
    memset(v106, 0, 44);
    if ((v88 & 1) == 0)
    {
      v107[0] = v116[0];
      v107[1] = v116[1];
      *(_OWORD *)((char *)&v107[1] + 12) = *(_OWORD *)((char *)&v116[1] + 12);
      LODWORD(v107[0]) = AddTempRegister((uint64_t)a1, SBYTE8(v116[0]), SBYTE12(v116[0]), v116[1]);
      v106[0] = v116[0];
      v106[1] = v116[1];
      *(_OWORD *)((char *)&v106[1] + 12) = *(_OWORD *)((char *)&v116[1] + 12);
      LODWORD(v106[0]) = AddTempRegister((uint64_t)a1, SBYTE8(v116[0]), SBYTE12(v116[0]), v116[1]);
    }
    uint64_t v35 = 0;
    *(void *)&long long v36 = 0x100000001;
    *((void *)&v36 + 1) = 0x100000001;
    long long v130 = v36;
    uint64_t v131 = 0x100000001;
    int v132 = v89;
    int v133 = v89;
    int v134 = v89;
    *(void *)&long long v135 = v117;
    *((void *)&v135 + 1) = 0;
    unsigned int v136 = v118;
    uint64_t v137 = 0;
    BOOL v138 = v119;
    uint64_t v139 = 0;
    if (v33) {
      long long v37 = &v110;
    }
    else {
      long long v37 = &v112;
    }
    if (v33) {
      unint64_t v38 = &v112;
    }
    else {
      unint64_t v38 = &v110;
    }
    char v140 = v37;
    uint64_t v141 = v38;
    uint64_t v142 = &v114;
    int v143 = &v108;
    int v144 = v116;
    uint64_t v145 = 0;
    __int32 v146 = v116;
    __int32 v147 = &v108;
    __int32 v148 = v107;
    unsigned int v149 = &v114;
    uint64_t v150 = v116;
    uint64_t v151 = v106;
    *(void *)&long long v123 = &v112;
    *((void *)&v123 + 1) = &v110;
    *(void *)&long long v124 = &v108;
    *((void *)&v124 + 1) = &v114;
    uint64_t v125 = v116;
    unsigned int v126 = v116;
    uint64_t v127 = v107;
    unint64_t v128 = v106;
    unint64_t v39 = &v135;
    uint64_t v129 = v116;
    do
    {
      if (*((_DWORD *)&v130 + v35))
      {
        uint64_t v105 = 0;
        long long v104 = 0u;
        memset(&v103[8], 0, 48);
        HIDWORD(v104) = *(_DWORD *)(v95 + 92);
        unsigned int v40 = dword_2393DBE08[v35] & 7;
        uint64_t v41 = v40 | (dword_2393DBDE4[v35] << 6) | 0x100000000;
        int32x4_t v42 = (unsigned int *)*((void *)&v123 + v35);
        *(void *)int8x16_t v103 = v41;
        uint64_t v43 = v42[4] & 3;
        unint64_t v44 = (v43 << 21) | 0x72000000;
        switch(v43)
        {
          case 1:
            goto LABEL_88;
          case 2:
            goto LABEL_87;
          case 3:
            unint64_t v44 = (v43 << 21) | 0x72008000;
LABEL_87:
            v44 |= 0x10000uLL;
LABEL_88:
            v44 |= 0x20000uLL;
            break;
          default:
            break;
        }
        uint64_t v45 = 0;
        *(void *)&v103[8] = v44 | 0x40000;
        *(void *)&v103[8] = v44 & 0xFFFFFFFFFFFB8FFFLL | 0x40000 | ((unint64_t)(v42[1] & 7) << 12);
        *(void *)&v103[8] |= (unint64_t)*v42 << 48;
        uint64_t v46 = (v44 >> 2) & 0x180000;
        if (v40 <= 1) {
          unsigned int v40 = 1;
        }
        uint64_t v47 = 8 * v40;
        do
        {
          unsigned int v48 = &v103[v45];
          unint64_t v49 = *(void *)&v103[v45 + 16] & 0xFFFFFFFFFFE7FFFFLL | v46;
          long long v50 = *(unsigned int **)((char *)v39 + v45);
          *((void *)v48 + 2) = v49;
          unint64_t v51 = v49 & 0xFFFFFFFFFFFFF9FFLL | ((unint64_t)(v50[10] & 3) << 9);
          *((void *)v48 + 2) = v51;
          unint64_t v52 = v51 & 0xFFFFFFFFFFFFE7FFLL | ((((unint64_t)v50[10] >> 2) & 3) << 11);
          *((void *)v48 + 2) = v52;
          unint64_t v53 = v52 & 0xFFFFFFFFFFFF9FFFLL | ((((unint64_t)v50[10] >> 4) & 3) << 13);
          *((void *)v48 + 2) = v53;
          unint64_t v54 = v53 & 0xFFFFFFFFFFFE7FFFLL | ((((unint64_t)v50[10] >> 6) & 3) << 15);
          *((void *)v48 + 2) = v54;
          unint64_t v55 = v54 & 0xFFFFFFFFFFFFFE3FLL | ((v50[1] & 7) << 6);
          *((void *)v48 + 2) = v55;
          *((void *)v48 + 2) = v55 & 0xFFFFFFFFFFEFLL | ((unint64_t)*v50 << 48);
          v45 += 8;
        }
        while (v47 != v45);
        *(void *)int8x16_t v103 = ((unint64_t)(v42[4] & 3) << 36) | ((unint64_t)(v42[3] & 7) << 38) | v41 | ((v42[2] & 7) << 19);
        PPStreamInsertOperationBeforeChunk((uint64_t)a1, (uint64_t)v103, 0, v95);
      }
      ++v35;
      ++v39;
    }
    while (v35 != 9);
    unint64_t v56 = (void *)v94[1];
    unint64_t v57 = v96;
    if (v96 != v56)
    {
      do
      {
        unsigned int v58 = (void *)v57[1];
        PPStreamRemoveOperation((uint64_t)a1, v57);
        unint64_t v57 = v58;
      }
      while (v58 != v56);
    }
    char v59 = v116[1];
    uint64_t v60 = *(void *)(v95 + 24);
    *(void *)(v95 + 40) = *(void *)(v95 + 40) & 0xFFFFFFE6002FLL | ((unint64_t)(v116[1] & 3) << 19) | ((unint64_t)(BYTE4(v116[0]) & 7) << 6) | ((unint64_t)LODWORD(v116[0]) << 48) | 0x1C800;
    *(void *)(v95 + 24) = v60 & 0xFFFFFE0FFFC7C038 | ((unint64_t)(BYTE8(v116[0]) & 7) << 19) | ((unint64_t)(BYTE12(v116[0]) & 7) << 38) | ((unint64_t)(v59 & 3) << 36) | 0x15C1;
    uint64_t v61 = *(void *)(v95 + 8);
    if (v61) {
      *(void *)(v61 + 24) = *(void *)(v61 + 24) & 0xFFFFFFFFFFFFFFC7 | 8;
    }
    void v24[3] = v24[3] & 0xFFFFFFFFFFFFC03FLL | 0x16C0;
    uint64_t v1 = *(uint64_t **)(v95 + 8);
  }
  while (v1);
}

void GetOpRegs(uint64_t **a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int32x4_t a5)
{
  uint64_t v9 = *(void *)(a2 + 24);
  unsigned int v10 = v9 & 7;
  if ((*(_DWORD *)(a2 + 24) & 7) == 0) {
    goto LABEL_7;
  }
  uint64_t v11 = 0;
  uint64_t v12 = v9 & 7;
  int v13 = a3;
  do
  {
    if (v11 < (*(_DWORD *)(a2 + 24) & 7) + ((__int16)*(_DWORD *)(a2 + 24) >> 15))
    {
      uint64_t v14 = a2 + 40 + 8 * v11;
      v13[1] = (*(void *)v14 >> 6) & 7;
      *int v13 = *(unsigned __int16 *)(v14 + 6);
      *(double *)a5.i64 = GetRegisterTypeInfo(a1, (uint64_t)v13, a5);
    }
    ++v11;
    v13 += 10;
  }
  while (v12 != v11);
  if (v10 <= 3)
  {
LABEL_7:
    uint64_t v15 = (40 * v10) | 4;
    do
    {
      *(_DWORD *)((char *)a3 + v15) = 500;
      v15 += 40;
    }
    while (v15 != 164);
  }
  uint64_t v16 = *(void *)(a2 + 32);
  if ((v16 & 0x78000) != 0)
  {
    a4[1] = (v16 >> 12) & 7;
    *a4 = *(unsigned __int16 *)(a2 + 38);
    GetRegisterTypeInfo(a1, (uint64_t)a4, a5);
  }
  else
  {
    a4[1] = 500;
  }
}

uint64_t IsBadUsage(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if ((*(_DWORD *)(a1 + 24) & 7) != 0)
  {
    unint64_t v2 = 0;
    int v3 = 0;
    do
    {
      if (v2 < (v1 & 7) + ((__int16)v1 >> 15)) {
        v3 |= (*(void *)(a1 + 40 + 8 * v2) >> 17) & 3 | ((*(void *)(a1 + 40 + 8 * v2) & 0x180000) != 0) | ((*(void *)(a1 + 40 + 8 * v2) & 0x11) != 0);
      }
      ++v2;
    }
    while ((v1 & 7) != v2);
  }
  else
  {
    int v3 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  unsigned int v5 = (v4 >> 15) & 1;
  if ((v4 & 0x30000) != 0) {
    unsigned int v5 = 1;
  }
  return (v4 >> 19) & 3 | v3 | ((v4 & 0x600000) != 0) | BYTE4(v4) & 1 | ((v1 & 0x80000000000) != 0) | v5;
}

void UnrollConstantLoopsSimple(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    int v4 = a2[5];
  }
  else {
    int v4 = 0;
  }
  unsigned int v5 = (*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1;
  v15[0] = 0;
  v15[1] = (void *)v5;
  v15[2] = regHashFunction;
  v15[3] = regEqualsFunction;
  uint64_t v6 = HashSetNew(v5, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
  EmulationContext_PushRegisters((uint64_t *)v15, (uint64_t)v6);
  uint64_t v7 = **(void ***)(a1 + 104);
  uint64_t v14 = v7;
  while (v7)
  {
    uint64_t v8 = v7[3] & 0x3FC0;
    if (v8 != 5568 || v4 == 0)
    {
      if (v8 != 5568) {
        goto LABEL_13;
      }
    }
    else
    {
      long long v12 = 0u;
      long long v13 = 0u;
      unint64_t v10 = v7[5];
      v11[0] = HIWORD(v10);
      v11[1] = (v10 >> 6) & 7;
      GetRegisterTypeInfo((uint64_t **)a1, (uint64_t)v11, (int32x4_t)0);
      if (HIDWORD(v12))
      {
LABEL_13:
        EmulateOp((uint64_t **)a1, v7, (uint64_t *)v15);
        uint64_t v7 = (void *)v7[1];
        uint64_t v14 = v7;
        continue;
      }
    }
    UnrollConstantLoopsInner(&v14, (uint64_t *)v15, a1, a2);
    uint64_t v7 = v14;
  }
  while (v15[0])
    EmulationContext_PopRegisters(v15);
}

void UnrollConstantLoopsInner(void **a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  uint64_t v6 = *a1;
  uint64_t v69 = 0;
  int v70 = v6;
  uint64_t v7 = v6[3] >> 46;
  if (a4)
  {
    uint64_t v8 = a4[5];
    if (!*a4)
    {
      if (a4[1])
      {
        uint64_t v9 = v6[1];
        *(void *)&long long v71 = v9;
        if (v9)
        {
          uint64_t v11 = a2;
          do
          {
            if (*(_DWORD *)(v9 + 88) == v7) {
              break;
            }
            if ((*(void *)(v9 + 24) & 0x3FC0) == 0x15C0)
            {
              uint64_t v12 = v8;
              EmulationContext_PushRegistersCopy(v11);
              long long v13 = v11;
              if (v6 != (void *)v9)
              {
                uint64_t v14 = v6;
                do
                {
                  EmulateOp((uint64_t **)a3, v14, v13);
                  uint64_t v14 = (void *)v14[1];
                }
                while (v14 != (void *)v9);
              }
              uint64_t v11 = v13;
              uint64_t v8 = v12;
              if (!v12
                || (long long v76 = 0u,
                    long long v77 = 0u,
                    unint64_t v15 = v6[5],
                    HIDWORD(v75) = (v15 >> 6) & 7,
                    LODWORD(v75) = HIWORD(v15),
                    GetRegisterTypeInfo((uint64_t **)a3, (uint64_t)&v75, (int32x4_t)0),
                    !HIDWORD(v76)))
              {
                UnrollConstantLoopsInner(&v71, v11, a3, a4);
                uint64_t v9 = v71;
              }
              EmulationContext_PopRegisters((void **)v11);
            }
            uint64_t v9 = *(void *)(v9 + 8);
            *(void *)&long long v71 = v9;
          }
          while (v9);
          if (!v6)
          {
            uint64_t v20 = 0;
            int v21 = 0;
            int v19 = 1;
            goto LABEL_36;
          }
        }
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  uint64_t v16 = 0;
  int v17 = 1;
  char v18 = v6;
  int v19 = 1;
  while (1)
  {
    uint64_t v20 = v16;
    uint64_t v16 = (uint64_t)v18;
    int v21 = v17;
    if (v20)
    {
      if (*((_DWORD *)v18 + 22) == v7 && (*(void *)(v20 + 24) & 0x3FC0) == 0x16C0) {
        break;
      }
    }
    unint64_t v22 = v18[3];
    unsigned int v23 = (v22 >> 6) - 75;
    int v24 = 1 << ((v22 >> 6) - 75);
    if (v22 >> 46 >= v7) {
      int v25 = 0;
    }
    else {
      int v25 = v19;
    }
    if ((v24 & 6) != 0) {
      int v26 = 0;
    }
    else {
      int v26 = v19;
    }
    if ((v24 & 0x80000201) == 0) {
      int v25 = v26;
    }
    if (v23 <= 0x1F) {
      int v19 = v25;
    }
    char v18 = *(void **)(v16 + 8);
    int v17 = v21 + 1;
    if (!v18)
    {
      uint64_t v20 = 0;
      goto LABEL_36;
    }
  }
  uint64_t v69 = v20;
LABEL_36:
  long long v68 = 0u;
  long long v67 = 0u;
  unint64_t v27 = v6[5];
  v66[0] = HIWORD(v27);
  v66[1] = (v27 >> 6) & 7;
  uint64_t v28 = HashSetGet(*(void *)(*a2 + 8), (uint64_t)v66);
  if (!v28) {
    goto LABEL_51;
  }
  if (!*(_DWORD *)(v28 + 20) || *(_DWORD *)(v28 + 16) || *(_DWORD *)(v28 + 12))
  {
    int v19 = 0;
    int v29 = -1;
    if (!a4) {
      goto LABEL_42;
    }
  }
  else
  {
    int v29 = (int)*(float *)(v28 + 24);
    if (!a4) {
      goto LABEL_42;
    }
  }
  if (!*a4 && (v29 > a4[2] || v21 > a4[3] || v29 * v21 > a4[4]))
  {
LABEL_51:
    long long v65 = 0u;
    long long v64 = 0u;
    unint64_t v32 = v6[5];
    v63[0] = HIWORD(v32);
    v63[1] = (v32 >> 6) & 7;
    GetRegisterTypeInfo((uint64_t **)a3, (uint64_t)v63, (int32x4_t)0);
    v59[1] = 2;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    long long v62 = xmmword_2393DBD70;
    int v58 = 0;
    v59[0] = AddConstantParam(a3, v64, SDWORD1(v64), 0, 1065353216, 0);
    uint64_t v57 = 0;
    uint64_t v56 = 0;
    long long v55 = xmmword_2393DBD80;
    *(void *)&long long v76 = 0;
    LODWORD(v76) = PPStreamChunkListGetNextIndex(*(uint64_t **)(a3 + 32));
    uint64_t v75 = 8;
    PPStreamAddTempUsage(a3, &v75);
    uint64_t v33 = 0;
    int v54 = v76;
    uint64_t v87 = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    v84[0] = &v70;
    v84[1] = &v85;
    v84[2] = (char *)&v85 + 8;
    v84[3] = &v86;
    v84[4] = 0;
    memset(v82, 0, sizeof(v82));
    unint64_t v83 = &v69;
    uint64_t v75 = (uint64_t)v63;
    *(void *)&long long v76 = v59;
    long long v77 = 0u;
    long long v78 = 0u;
    *((void *)&v76 + 1) = &v54;
    uint64_t v79 = 0;
    int v80 = v63;
    int v34 = &v75;
    int v81 = v59;
    v74[0] = &v54;
    memset(&v74[1], 0, 24);
    v74[4] = v63;
    do
    {
      long long v73 = 0u;
      memset(v72, 0, sizeof(v72));
      long long v71 = 0u;
      uint64_t v35 = (uint64_t *)v84[v33];
      uint64_t v36 = (uint64_t)v35;
      if (!v35) {
        uint64_t v36 = *((void *)v82 + v33);
      }
      DWORD1(v73) = *(_DWORD *)(*(void *)v36 + 92);
      LODWORD(v36) = dword_2393DBE40[v33];
      *(void *)&long long v71 = v36 & 7 | (dword_2393DBE2C[v33] << 6) | ((unint64_t)(dword_2393DBE54[v33] & 1) << 32) | 0x8000000000;
      long long v37 = (unsigned int *)v74[v33];
      if (v37)
      {
        *((void *)&v71 + 1) = 1912864768;
        *((void *)&v71 + 1) = ((v37[1] & 7) << 12) | 0x72040000;
        *((void *)&v71 + 1) |= (unint64_t)*v37 << 48;
      }
      if ((unint64_t)(v33 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if ((int)v36 <= 1) {
          uint64_t v36 = 1;
        }
        else {
          uint64_t v36 = v36;
        }
        unint64_t v38 = v34;
        unint64_t v39 = (unint64_t *)v72;
        do
        {
          unint64_t v40 = *v39 & 0xFFFFFFFFFFE601FFLL | 0x1C800;
          uint64_t v41 = (unsigned int *)*v38++;
          *unint64_t v39 = v40;
          unint64_t v42 = v40 & 0xFFFFFFFFFFFFF83FLL | ((unint64_t)(v41[1] & 7) << 6);
          *unint64_t v39 = v42;
          *v39++ = v42 & 0xFFFFFFFFFFFFLL | ((unint64_t)*v41 << 48);
          --v36;
        }
        while (v36);
      }
      if (v35) {
        inserted = PPStreamInsertOperationAfterChunk(a3, (uint64_t)&v71, 0, *v35);
      }
      else {
        inserted = PPStreamInsertOperationBeforeChunk(a3, (uint64_t)&v71, 0, **((void **)v82 + v33));
      }
      *((void *)&v85 + v33++) = inserted;
      v34 += 2;
    }
    while (v33 != 5);
    uint64_t v44 = 0;
    int v45 = *(_DWORD *)(*(void *)(*((void *)&v86 + 1) + 8) + 88);
    LODWORD(v71) = 0;
    DWORD1(v71) = v45;
    uint64_t v46 = v70;
    uint64_t v47 = v70[3] >> 46;
    LODWORD(v72[0]) = 0;
    *((void *)&v71 + 1) = v47;
    do
    {
      *(void *)(*((void *)&v85 + v44) + 24) = *(void *)(*((void *)&v85 + v44) + 24) & 0x3FFFFFFFFFFFLL | ((unint64_t)*((unsigned int *)&v72[-1] + v44) << 46);
      ++v44;
    }
    while (v44 != 5);
    v46[3] = v46[3] & 0xFFFFFFFFFFFFC038 | 0x1AC0;
    uint64_t v48 = v46[1];
    if (v48) {
      *(void *)(v48 + 24) &= 0xFFFFFFFFFFFFFFC7;
    }
    uint64_t v49 = v69;
    unint64_t v50 = *(void *)(v69 + 24) & 0xFFFFFFFFFFFFC03FLL | 0x1B00;
    *(void *)(v69 + 24) = v50;
    *(void *)(v49 + 24) = v50 & 0x3FFFFFFFFFFFLL | ((unint64_t)*(unsigned int *)(v46[1] + 88) << 46);
    EmulateOp((uint64_t **)a3, v6, a2);
    unint64_t v51 = (void *)v6[1];
    goto LABEL_73;
  }
LABEL_42:
  if (!v19) {
    goto LABEL_51;
  }
  uint64_t v30 = *v6;
  if (!v8 || v29 < 1 || !RepifyConstantLoopSimple(a3, (uint64_t)v6, v20, v29)) {
    UnrollConstantLoopSimple(a3, v6, v20, v29);
  }
  if (v30) {
    int v31 = (void *)(v30 + 8);
  }
  else {
    int v31 = *(void **)(a3 + 104);
  }
  unint64_t v51 = (void *)*v31;
LABEL_73:
  *a1 = v51;
}

void EmulateOp(uint64_t **a1, void *a2, uint64_t *a3)
{
  uint64_t v196 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(*a3 + 8);
  uint64_t v6 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
  if (!v6) {
    goto LABEL_460;
  }
  uint64_t v7 = v6;
  uint64_t v8 = a2[3] & 7;
  if (v8)
  {
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    do
    {
      if (v9 < (a2[3] & 7) + ((__int16)*((_DWORD *)a2 + 6) >> 15))
      {
        uint64_t v11 = malloc_type_realloc(v7, 8 * (v10 + 1), 0x2BDC8648uLL);
        if (!v11) {
          goto LABEL_460;
        }
        uint64_t v7 = v11;
        memset(&v195[8], 0, 32);
        unint64_t v12 = a2[v9 + 5];
        *(_DWORD *)uint64_t v195 = HIWORD(v12);
        *(_DWORD *)&v195[4] = (v12 >> 6) & 7;
        uint64_t v13 = HashSetGet(v5, (uint64_t)v195);
        v7[v10] = v13;
        if (!v13)
        {
          GetRegisterTypeInfo(a1, (uint64_t)v195, v14);
          unint64_t v15 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
          if (!v15) {
            goto LABEL_460;
          }
          v7[v10] = v15;
          long long v16 = *(_OWORD *)v195;
          long long v17 = *(_OWORD *)&v195[16];
          v15[4] = *(void *)&v195[32];
          *(_OWORD *)unint64_t v15 = v16;
          *((_OWORD *)v15 + 1) = v17;
          HashSetAdd(v5, v7[v10]);
        }
        ++v10;
      }
      ++v9;
    }
    while (v8 != v9);
  }
  else
  {
    unsigned int v10 = 0;
  }
  unint64_t v18 = a2[4];
  if ((v18 & 0x78000) == 0)
  {
    uint64_t v19 = 0;
    goto LABEL_18;
  }
  memset(&v195[8], 0, 32);
  *(_DWORD *)uint64_t v195 = HIWORD(v18);
  *(_DWORD *)&v195[4] = (v18 >> 12) & 7;
  uint64_t v19 = HashSetGet(v5, (uint64_t)v195);
  if (!v19)
  {
    GetRegisterTypeInfo(a1, (uint64_t)v195, v20);
    int v21 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
    if (v21)
    {
      uint64_t v19 = (uint64_t)v21;
      long long v22 = *(_OWORD *)v195;
      long long v23 = *(_OWORD *)&v195[16];
      v21[4] = *(void *)&v195[32];
      *(_OWORD *)int v21 = v22;
      *((_OWORD *)v21 + 1) = v23;
      HashSetAdd(v5, (uint64_t)v21);
      goto LABEL_18;
    }
LABEL_460:
    abort();
  }
LABEL_18:
  memset(v195, 0, 24);
  if (!v10) {
    goto LABEL_22;
  }
  uint64_t v24 = *v7 + 24;
  if (!*(_DWORD *)(*v7 + 20)) {
    uint64_t v24 = 0;
  }
  *(void *)uint64_t v195 = v24;
  if (v10 != 1)
  {
    uint64_t v25 = 0;
    uint64_t v41 = v7[1];
    int v42 = *(_DWORD *)(v41 + 20);
    uint64_t v43 = v41 + 24;
    if (!v42) {
      uint64_t v43 = 0;
    }
    *(void *)&v195[8] = v43;
    if (v10 >= 3)
    {
      uint64_t v44 = v7[2];
      int v45 = *(_DWORD *)(v44 + 20);
      uint64_t v25 = v44 + 24;
      if (!v45) {
        uint64_t v25 = 0;
      }
    }
  }
  else
  {
LABEL_22:
    uint64_t v25 = 0;
    *(void *)&v195[8] = 0;
  }
  *(void *)&v195[16] = v25;
  int v26 = (float *)v194;
  unint64_t v27 = (float *)v193;
  uint64_t v189 = (float *)v194;
  uint64_t v190 = (float *)v193;
  uint64_t v28 = (float *)v192;
  int v191 = (float *)v192;
  if (v10 >= 3) {
    unsigned int v29 = 3;
  }
  else {
    unsigned int v29 = v10;
  }
  if (v29)
  {
    unint64_t v30 = 0;
    int v31 = a2 + 5;
    uint64_t v32 = 8 * v29;
    do
    {
      uint64_t v33 = *(void *)&v195[v30];
      if (v33)
      {
        int v34 = (&v189)[v30 / 8];
        *int v34 = *(float *)(v33 + 4 * ((v31[v30 / 8] >> 9) & 3));
        v34[1] = *(float *)(v33 + 4 * ((v31[v30 / 8] >> 11) & 3));
        v34[2] = *(float *)(v33 + 4 * ((v31[v30 / 8] >> 13) & 3));
        v34[3] = *(float *)(v33 + 4 * ((v31[v30 / 8] >> 15) & 3));
      }
      else
      {
        (&v189)[v30 / 8] = 0;
      }
      v30 += 8;
    }
    while (v32 != v30);
    int v26 = v189;
    unint64_t v27 = v190;
    uint64_t v28 = v191;
  }
  if (IsBadUsage((uint64_t)a2))
  {
LABEL_34:
    LODWORD(v36) = 1;
    goto LABEL_35;
  }
  long long v37 = (float *)(v19 + 24);
  if (v10 == 1 && v19 && v26)
  {
    unint64_t v38 = a2[3];
    unsigned int v39 = (v38 >> 6);
    LODWORD(v36) = 1;
    if (v39 <= 0x6C)
    {
      switch((v38 >> 6))
      {
        case 0u:
          goto LABEL_324;
        case 1u:
          *(_DWORD *)(v19 + 24) = 1065353216;
          float v40 = 0.0;
          *(float *)(v19 + 28) = fmaxf(*v26, 0.0);
          if (*v26 > 0.0) {
            float v40 = powf(v26[1], v26[3]);
          }
          goto LABEL_131;
        case 2u:
          *(float *)(v19 + 24) = fabsf(*v26);
          *(float *)(v19 + 28) = fabsf(v26[1]);
          *(float *)(v19 + 32) = fabsf(v26[2]);
          float v50 = fabsf(v26[3]);
          goto LABEL_325;
        case 3u:
          *(float *)(v19 + 24) = ceilf(*v26);
          *(float *)(v19 + 28) = ceilf(v26[1]);
          *(float *)(v19 + 32) = ceilf(v26[2]);
          float v50 = ceilf(v26[3]);
          goto LABEL_325;
        case 4u:
          *(float *)(v19 + 24) = *v26 - floorf(*v26);
          *(float *)(v19 + 28) = v26[1] - floorf(v26[1]);
          *(float *)(v19 + 32) = v26[2] - floorf(v26[2]);
          float v50 = v26[3] - floorf(v26[3]);
          goto LABEL_325;
        case 5u:
          *(float *)(v19 + 24) = floorf(*v26);
          *(float *)(v19 + 28) = floorf(v26[1]);
          *(float *)(v19 + 32) = floorf(v26[2]);
          float v50 = floorf(v26[3]);
          goto LABEL_325;
        case 7u:
          float v50 = 0.0;
          if (*v26 >= 0.0) {
            float v59 = 0.0;
          }
          else {
            float v59 = -1.0;
          }
          if (*v26 > 0.0) {
            float v59 = 1.0;
          }
          *(float *)(v19 + 24) = v59;
          float v60 = v26[1];
          BOOL v61 = v60 <= 0.0;
          if (v60 >= 0.0) {
            float v62 = 0.0;
          }
          else {
            float v62 = -1.0;
          }
          if (!v61) {
            float v62 = 1.0;
          }
          *(float *)(v19 + 28) = v62;
          float v63 = v26[2];
          BOOL v64 = v63 <= 0.0;
          if (v63 >= 0.0) {
            float v65 = 0.0;
          }
          else {
            float v65 = -1.0;
          }
          if (!v64) {
            float v65 = 1.0;
          }
          *(float *)(v19 + 32) = v65;
          float v66 = v26[3];
          if (v66 < 0.0) {
            float v50 = -1.0;
          }
          if (v66 > 0.0) {
            float v50 = 1.0;
          }
          goto LABEL_325;
        case 8u:
          if (*v26 == 0.0 && v26[1] == 0.0 && v26[2] == 0.0) {
            goto LABEL_103;
          }
          goto LABEL_178;
        case 9u:
          if (*v26 == 0.0 || v26[1] == 0.0 || v26[2] == 0.0) {
            LODWORD(v36) = 0;
          }
          else {
LABEL_103:
          }
            LODWORD(v36) = v26[3] != 0.0;
LABEL_178:
          float v50 = (float)v36;
          goto LABEL_179;
        case 0xAu:
          float v50 = 0.0;
          if (*v26 == 0.0) {
            float v67 = 1.0;
          }
          else {
            float v67 = 0.0;
          }
          *(float *)(v19 + 24) = v67;
          if (v26[1] == 0.0) {
            float v68 = 1.0;
          }
          else {
            float v68 = 0.0;
          }
          *(float *)(v19 + 28) = v68;
          if (v26[2] == 0.0) {
            float v69 = 1.0;
          }
          else {
            float v69 = 0.0;
          }
          *(float *)(v19 + 32) = v69;
          if (v26[3] == 0.0) {
            float v50 = 1.0;
          }
          goto LABEL_325;
        case 0xCu:
          float v50 = sqrtf(*v26);
          *long long v37 = v50;
          if ((v38 & 0x3000000000) == 0) {
            break;
          }
          *(float *)(v19 + 28) = sqrtf(v26[1]);
          *(float *)(v19 + 32) = sqrtf(v26[2]);
          float v50 = sqrtf(v26[3]);
          goto LABEL_325;
        case 0xDu:
          float v51 = 1.0;
          float v50 = 1.0 / sqrtf(fabsf(*v26));
          *long long v37 = v50;
          if ((v38 & 0x3000000000) == 0) {
            break;
          }
          *(float *)(v19 + 28) = 1.0 / sqrtf(fabsf(v26[1]));
          *(float *)(v19 + 32) = 1.0 / sqrtf(fabsf(v26[2]));
          float v52 = fabsf(v26[3]);
          goto LABEL_120;
        case 0xEu:
          float v51 = 1.0;
          float v50 = 1.0 / *v26;
          *long long v37 = v50;
          if ((v38 & 0x3000000000) == 0) {
            break;
          }
          *(float *)(v19 + 28) = 1.0 / v26[1];
          *(float *)(v19 + 32) = 1.0 / v26[2];
          float v70 = v26[3];
          goto LABEL_123;
        case 0xFu:
          float v71 = v26[3];
          *(float *)&int v72 = 5.421e-20;
          if (v71 > 1.8447e19) {
            goto LABEL_125;
          }
          if (v71 >= 5.421e-20) {
            goto LABEL_428;
          }
          if (v71 >= 0.0)
          {
            *(float *)&int v72 = 1.8447e19;
            goto LABEL_125;
          }
          *(float *)&int v72 = -1.8447e19;
          if (v71 > -5.421e-20) {
            goto LABEL_125;
          }
          if (v71 < -1.8447e19)
          {
            *(float *)&int v72 = -5.421e-20;
LABEL_125:
            float v50 = *(float *)&v72;
            goto LABEL_179;
          }
LABEL_428:
          float v50 = 1.0 / v71;
LABEL_179:
          *(float *)(v19 + 24) = v50;
          break;
        case 0x10u:
          int v73 = *(unsigned __int16 *)a1;
          if ((v73 - 35632) < 2 || (v73 - 36487) < 2 || v73 == 36313)
          {
            *(float *)(v19 + 24) = exp2f(*v26);
            *(float *)(v19 + 28) = exp2f(v26[1]);
            *(float *)(v19 + 32) = exp2f(v26[2]);
            float v50 = exp2f(v26[3]);
            goto LABEL_325;
          }
          float v50 = exp2f(v26[3]);
          goto LABEL_179;
        case 0x11u:
          float v74 = floorf(v26[3]);
          *(float *)(v19 + 24) = exp2f(v74);
          *(float *)(v19 + 28) = v26[3] - v74;
          float v40 = exp2f(v26[3]);
LABEL_131:
          *(float *)(v19 + 32) = v40;
          goto LABEL_148;
        case 0x12u:
          uint64_t v75 = ((v38 >> 36) & 3) + 1;
          float v76 = 0.0;
          long long v77 = v26;
          do
          {
            float v78 = *v77++;
            float v76 = v76 + (float)(v78 * v78);
            --v75;
          }
          while (v75);
          float v50 = sqrtf(v76);
          goto LABEL_179;
        case 0x13u:
          int v79 = *(unsigned __int16 *)a1;
          if ((v79 - 35632) < 2 || (v79 - 36487) < 2 || v79 == 36313)
          {
            float v80 = *v26;
            if (*v26 < 0.0) {
              float v80 = 0.0;
            }
            *(float *)(v19 + 24) = log2f(v80);
            float v81 = v26[1];
            if (v81 < 0.0) {
              float v81 = 0.0;
            }
            *(float *)(v19 + 28) = log2f(v81);
            float v82 = v26[2];
            if (v82 < 0.0) {
              float v82 = 0.0;
            }
            *(float *)(v19 + 32) = log2f(v82);
            float v83 = v26[3];
            if (v83 < 0.0) {
              float v83 = 0.0;
            }
            float v50 = log2f(v83);
            goto LABEL_325;
          }
          float v187 = v26[3];
          if (v187 < 0.0) {
            float v187 = 0.0;
          }
          float v50 = log2f(v187);
          goto LABEL_179;
        case 0x14u:
          float v84 = fabsf(v26[3]);
          float v85 = log2f(v84);
          float v86 = floorf(v85);
          *(float *)(v19 + 24) = v86;
          *(float *)(v19 + 28) = v84 / exp2f(v86);
          *(float *)(v19 + 32) = v85;
LABEL_148:
          float v50 = 1.0;
          goto LABEL_325;
        case 0x15u:
          uint64_t v87 = ((v38 >> 36) & 3) + 1;
          float v88 = 0.0;
          int v89 = v26;
          do
          {
            float v90 = *v89++;
            float v88 = v88 + (float)(v90 * v90);
            --v87;
          }
          while (v87);
          unint64_t v91 = 0;
          float v92 = sqrtf(v88);
          do
          {
            LODWORD(v36) = 0;
            v37[v91] = v26[v91] / v92;
          }
          while (v91++ < ((a2[3] >> 36) & 3uLL));
          goto LABEL_326;
        case 0x16u:
          float v94 = *v26;
          float v95 = 0.017453;
          goto LABEL_157;
        case 0x17u:
          float v94 = *v26;
          float v95 = 57.296;
LABEL_157:
          *(float *)(v19 + 24) = v94 * v95;
          *(float *)(v19 + 28) = v26[1] * v95;
          *(float *)(v19 + 32) = v26[2] * v95;
          float v50 = v26[3] * v95;
          goto LABEL_325;
        case 0x18u:
          *(float *)(v19 + 24) = cosf(*v26);
          *(float *)(v19 + 28) = sinf(*v26);
          *(_DWORD *)(v19 + 32) = 0;
          float v50 = 0.0;
          goto LABEL_325;
        case 0x19u:
          int v96 = *(unsigned __int16 *)a1;
          if ((v96 - 35632) < 2 || (v96 - 36487) < 2 || v96 == 36313)
          {
            *(float *)(v19 + 24) = sinf(*v26);
            *(float *)(v19 + 28) = sinf(v26[1]);
            *(float *)(v19 + 32) = sinf(v26[2]);
            float v50 = sinf(v26[3]);
            goto LABEL_325;
          }
          float v50 = sinf(v26[3]);
          goto LABEL_179;
        case 0x1Au:
          int v97 = *(unsigned __int16 *)a1;
          if ((v97 - 35632) < 2 || (v97 - 36487) < 2 || v97 == 36313)
          {
            *(float *)(v19 + 24) = cosf(*v26);
            *(float *)(v19 + 28) = cosf(v26[1]);
            *(float *)(v19 + 32) = cosf(v26[2]);
            float v50 = cosf(v26[3]);
            goto LABEL_325;
          }
          float v50 = cosf(v26[3]);
          goto LABEL_179;
        case 0x1Bu:
          *(float *)(v19 + 24) = tanf(*v26);
          *(float *)(v19 + 28) = tanf(v26[1]);
          *(float *)(v19 + 32) = tanf(v26[2]);
          float v50 = tanf(v26[3]);
          goto LABEL_325;
        case 0x1Cu:
          *(float *)(v19 + 24) = asinf(*v26);
          *(float *)(v19 + 28) = asinf(v26[1]);
          *(float *)(v19 + 32) = asinf(v26[2]);
          float v50 = asinf(v26[3]);
          goto LABEL_325;
        case 0x1Du:
          *(float *)(v19 + 24) = acosf(*v26);
          *(float *)(v19 + 28) = acosf(v26[1]);
          *(float *)(v19 + 32) = acosf(v26[2]);
          float v50 = acosf(v26[3]);
          goto LABEL_325;
        case 0x1Eu:
          *(float *)(v19 + 24) = atanf(*v26);
          *(float *)(v19 + 28) = atanf(v26[1]);
          *(float *)(v19 + 32) = atanf(v26[2]);
          float v50 = atanf(v26[3]);
          goto LABEL_325;
        case 0x48u:
          *(float *)(v19 + 24) = *v26;
          *(float *)(v19 + 28) = *v26;
          *(float *)(v19 + 32) = *v26;
          float v50 = *v26;
          goto LABEL_325;
        default:
          goto LABEL_326;
      }
LABEL_180:
      *(float *)(v19 + 28) = v50;
      *(float *)(v19 + 32) = v50;
      goto LABEL_325;
    }
    if ((v38 >> 6) > 0x70u)
    {
      if (v39 == 113)
      {
        *(float *)(v19 + 24) = logf(*v26);
        *(float *)(v19 + 28) = logf(v26[1]);
        *(float *)(v19 + 32) = logf(v26[2]);
        float v50 = logf(v26[3]);
        goto LABEL_325;
      }
      if (v39 == 134)
      {
        float v51 = 1.0;
        float v50 = 1.0 / sqrtf(*v26);
        *long long v37 = v50;
        if ((v38 & 0x3000000000) != 0)
        {
          *(float *)(v19 + 28) = 1.0 / sqrtf(v26[1]);
          *(float *)(v19 + 32) = 1.0 / sqrtf(v26[2]);
          float v52 = v26[3];
LABEL_120:
          float v70 = sqrtf(v52);
LABEL_123:
          float v50 = v51 / v70;
          goto LABEL_325;
        }
        goto LABEL_180;
      }
    }
    else
    {
      if (v39 == 109)
      {
        int v98 = *(_DWORD *)(v19 + 12);
        if (v98 == 1)
        {
          if ((*(_DWORD *)(*v7 + 12) | 2) == 2)
          {
            float v50 = 0.0;
            if (*v26 == 0.0) {
              float v139 = 0.0;
            }
            else {
              float v139 = 1.0;
            }
            *(float *)(v19 + 24) = v139;
            if (v26[1] == 0.0) {
              float v140 = 0.0;
            }
            else {
              float v140 = 1.0;
            }
            *(float *)(v19 + 28) = v140;
            if (v26[2] == 0.0) {
              float v141 = 0.0;
            }
            else {
              float v141 = 1.0;
            }
            *(float *)(v19 + 32) = v141;
            if (v26[3] != 0.0) {
              float v50 = 1.0;
            }
            goto LABEL_325;
          }
        }
        else if (v98 == 2 && !*(_DWORD *)(*v7 + 12))
        {
          *(float *)(v19 + 24) = truncf(*v26);
          *(float *)(v19 + 28) = truncf(v26[1]);
          *(float *)(v19 + 32) = truncf(v26[2]);
          float v50 = truncf(v26[3]);
          goto LABEL_325;
        }
LABEL_324:
        *(float *)(v19 + 24) = *v26;
        *(float *)(v19 + 28) = v26[1];
        *(float *)(v19 + 32) = v26[2];
        float v50 = v26[3];
        goto LABEL_325;
      }
      if (v39 == 112)
      {
        *(float *)(v19 + 24) = expf(*v26);
        *(float *)(v19 + 28) = expf(v26[1]);
        *(float *)(v19 + 32) = expf(v26[2]);
        float v50 = expf(v26[3]);
LABEL_325:
        LODWORD(v36) = 0;
        *(float *)(v19 + 36) = v50;
      }
    }
LABEL_326:
    unsigned int v46 = v27 != 0;
    goto LABEL_327;
  }
  unsigned int v46 = v27 != 0;
  LODWORD(v36) = 1;
  if (v10 == 2 && v19 && v26 && v27)
  {
    unint64_t v47 = a2[3];
    int v48 = (v47 >> 6);
    unsigned int v46 = 1;
    switch((v47 >> 6))
    {
      case 0x1Eu:
        *(float *)(v19 + 24) = atan2f(*v26, *v27);
        *(float *)(v19 + 28) = atan2f(v26[1], v27[1]);
        *(float *)(v19 + 32) = atan2f(v26[2], v27[2]);
        float v99 = atan2f(v26[3], v27[3]);
        goto LABEL_300;
      case 0x1Fu:
        LODWORD(v36) = 0;
        *(float *)(v19 + 24) = *v26 + *v27;
        *(float *)(v19 + 28) = v26[1] + v27[1];
        *(float *)(v19 + 32) = v26[2] + v27[2];
        float v49 = v26[3] + v27[3];
        goto LABEL_450;
      case 0x20u:
        LODWORD(v36) = 0;
        *(float *)(v19 + 24) = *v26 - *v27;
        *(float *)(v19 + 28) = v26[1] - v27[1];
        *(float *)(v19 + 32) = v26[2] - v27[2];
        float v49 = v26[3] - v27[3];
        goto LABEL_450;
      case 0x21u:
        break;
      case 0x22u:
      case 0x23u:
        LODWORD(v36) = 0;
        *(float *)(v19 + 24) = *v26 * *v27;
        *(float *)(v19 + 28) = v26[1] * v27[1];
        *(float *)(v19 + 32) = v26[2] * v27[2];
        float v49 = v26[3] * v27[3];
        goto LABEL_450;
      case 0x24u:
        BOOL v100 = *v26 != 0.0 && *v27 != 0.0;
        *long long v37 = (float)v100;
        BOOL v184 = v26[1] != 0.0 && v27[1] != 0.0;
        *(float *)(v19 + 28) = (float)v184;
        BOOL v186 = v26[2] != 0.0 && v27[2] != 0.0;
        *(float *)(v19 + 32) = (float)v186;
        if (v26[3] != 0.0) {
          goto LABEL_443;
        }
        unsigned int v46 = 0;
        goto LABEL_445;
      case 0x25u:
        if (*v26 == 0.0) {
          LODWORD(v36) = *v27 != 0.0;
        }
        *long long v37 = (float)v36;
        BOOL v101 = v26[1] != 0.0 || v27[1] != 0.0;
        *(float *)(v19 + 28) = (float)v101;
        BOOL v185 = v26[2] != 0.0 || v27[2] != 0.0;
        *(float *)(v19 + 32) = (float)v185;
        if (v26[3] == 0.0) {
LABEL_443:
        }
          unsigned int v46 = v27[3] != 0.0;
LABEL_445:
        LODWORD(v36) = 0;
        goto LABEL_446;
      case 0x26u:
        LODWORD(v36) = 0;
        *(float *)(v19 + 24) = (float)((*v26 != 0.0) ^ (*v27 != 0.0));
        *(float *)(v19 + 28) = (float)((v26[1] != 0.0) ^ (v27[1] != 0.0));
        *(float *)(v19 + 32) = (float)((v26[2] != 0.0) ^ (v27[2] != 0.0));
        unsigned int v46 = (v26[3] != 0.0) ^ (v27[3] != 0.0);
LABEL_446:
        float v99 = (float)v46;
        goto LABEL_447;
      case 0x27u:
        uint64_t v36 = ((v47 >> 36) & 3) + 1;
        int32x2_t v53 = 0;
        int v102 = v26;
        int8x16_t v103 = v27;
        do
        {
          float v104 = *v102++;
          float v105 = v104;
          float v106 = *v103++;
          *(float *)v53.i32 = *(float *)v53.i32 + (float)(v105 * v106);
          --v36;
        }
        while (v36);
        goto LABEL_193;
      case 0x28u:
        LODWORD(v36) = 0;
        *(float *)v35.i32 = (float)((float)(v26[1] * v27[1]) + (float)(*v26 * *v27)) + (float)(v26[2] * v27[2]);
        goto LABEL_197;
      case 0x29u:
        LODWORD(v36) = 0;
        *(float *)v35.i32 = (float)((float)((float)(v26[1] * v27[1]) + (float)(*v26 * *v27)) + (float)(v26[2] * v27[2]))
                          + (float)(v26[3] * v27[3]);
        goto LABEL_197;
      case 0x2Au:
        LODWORD(v36) = 0;
        *(float *)v35.i32 = (float)((float)((float)(v26[1] * v27[1]) + (float)(*v26 * *v27)) + (float)(v26[2] * v27[2]))
                          + v27[3];
LABEL_197:
        _Q0 = vdupq_lane_s32(v35, 0);
        goto LABEL_222;
      case 0x2Bu:
        LODWORD(v36) = 0;
        *(_DWORD *)(v19 + 24) = 1065353216;
        *(float *)(v19 + 28) = v26[1] * v27[1];
        *(float *)(v19 + 32) = v26[2];
        float v99 = v27[3];
        goto LABEL_447;
      case 0x2Cu:
        LODWORD(v36) = 0;
        float v108 = *v26;
        if (*v26 >= *v27) {
          float v108 = *v27;
        }
        *(float *)(v19 + 24) = v108;
        float v109 = v26[1];
        if (v109 >= v27[1]) {
          float v109 = v27[1];
        }
        *(float *)(v19 + 28) = v109;
        float v110 = v26[2];
        if (v110 >= v27[2]) {
          float v110 = v27[2];
        }
        *(float *)(v19 + 32) = v110;
        float v49 = v26[3];
        if (v49 >= v27[3]) {
          float v49 = v27[3];
        }
        goto LABEL_450;
      case 0x2Du:
        LODWORD(v36) = 0;
        float v111 = *v26;
        if (*v26 <= *v27) {
          float v111 = *v27;
        }
        *(float *)(v19 + 24) = v111;
        float v112 = v26[1];
        if (v112 <= v27[1]) {
          float v112 = v27[1];
        }
        *(float *)(v19 + 28) = v112;
        float v113 = v26[2];
        if (v113 <= v27[2]) {
          float v113 = v27[2];
        }
        *(float *)(v19 + 32) = v113;
        float v49 = v26[3];
        if (v49 <= v27[3]) {
          float v49 = v27[3];
        }
        goto LABEL_450;
      case 0x2Eu:
        LODWORD(v36) = 0;
        *(float *)(v19 + 24) = (float)(v26[1] * v27[2]) - (float)(v27[1] * v26[2]);
        *(float *)(v19 + 28) = (float)(v26[2] * *v27) - (float)(v27[2] * *v26);
        *(float *)(v19 + 32) = (float)(*v26 * v27[1]) - (float)(*v27 * v26[1]);
        *(_DWORD *)(v19 + 36) = 0;
        break;
      case 0x2Fu:
        unint64_t v114 = 0;
        float v115 = 0.0;
        do
        {
          float v115 = v115 + (float)(v26[v114 / 4] * v27[v114 / 4]);
          v114 += 4;
        }
        while (4 * ((v47 >> 36) & 3) + 4 != v114);
        LODWORD(v36) = 0;
        float v116 = v115 * -2.0;
        *(float *)(v19 + 24) = *v26 + (float)(v116 * *v27);
        *(float *)(v19 + 28) = v26[1] + (float)(v116 * v27[1]);
        *(float *)(v19 + 32) = v26[2] + (float)(v116 * v27[2]);
        float v99 = v26[3] + (float)(v116 * v27[3]);
        goto LABEL_447;
      case 0x30u:
        LODWORD(v36) = 0;
        __asm { FMOV            V0.4S, #1.0 }
LABEL_222:
        *(int32x4_t *)long long v37 = _Q0;
        break;
      case 0x31u:
        LODWORD(v36) = 0;
        float v49 = 0.0;
        if (*v26 == *v27) {
          float v120 = 1.0;
        }
        else {
          float v120 = 0.0;
        }
        *(float *)(v19 + 24) = v120;
        if (v26[1] == v27[1]) {
          float v121 = 1.0;
        }
        else {
          float v121 = 0.0;
        }
        *(float *)(v19 + 28) = v121;
        if (v26[2] == v27[2]) {
          float v122 = 1.0;
        }
        else {
          float v122 = 0.0;
        }
        *(float *)(v19 + 32) = v122;
        if (v26[3] == v27[3]) {
          float v49 = 1.0;
        }
        goto LABEL_450;
      case 0x32u:
        LODWORD(v36) = 0;
        float v49 = 0.0;
        if (*v26 < *v27) {
          float v123 = 0.0;
        }
        else {
          float v123 = 1.0;
        }
        *(float *)(v19 + 24) = v123;
        if (v26[1] < v27[1]) {
          float v124 = 0.0;
        }
        else {
          float v124 = 1.0;
        }
        *(float *)(v19 + 28) = v124;
        if (v26[2] < v27[2]) {
          float v125 = 0.0;
        }
        else {
          float v125 = 1.0;
        }
        *(float *)(v19 + 32) = v125;
        if (v26[3] >= v27[3]) {
          float v49 = 1.0;
        }
        goto LABEL_450;
      case 0x33u:
        LODWORD(v36) = 0;
        float v49 = 0.0;
        if (*v26 <= *v27) {
          float v126 = 0.0;
        }
        else {
          float v126 = 1.0;
        }
        *(float *)(v19 + 24) = v126;
        if (v26[1] <= v27[1]) {
          float v127 = 0.0;
        }
        else {
          float v127 = 1.0;
        }
        *(float *)(v19 + 28) = v127;
        if (v26[2] <= v27[2]) {
          float v128 = 0.0;
        }
        else {
          float v128 = 1.0;
        }
        *(float *)(v19 + 32) = v128;
        if (v26[3] > v27[3]) {
          float v49 = 1.0;
        }
        goto LABEL_450;
      case 0x34u:
        LODWORD(v36) = 0;
        float v49 = 0.0;
        if (*v26 > *v27) {
          float v129 = 0.0;
        }
        else {
          float v129 = 1.0;
        }
        *(float *)(v19 + 24) = v129;
        if (v26[1] > v27[1]) {
          float v130 = 0.0;
        }
        else {
          float v130 = 1.0;
        }
        *(float *)(v19 + 28) = v130;
        if (v26[2] > v27[2]) {
          float v131 = 0.0;
        }
        else {
          float v131 = 1.0;
        }
        *(float *)(v19 + 32) = v131;
        if (v26[3] <= v27[3]) {
          float v49 = 1.0;
        }
        goto LABEL_450;
      case 0x35u:
        LODWORD(v36) = 0;
        float v49 = 0.0;
        if (*v26 >= *v27) {
          float v132 = 0.0;
        }
        else {
          float v132 = 1.0;
        }
        *(float *)(v19 + 24) = v132;
        if (v26[1] >= v27[1]) {
          float v133 = 0.0;
        }
        else {
          float v133 = 1.0;
        }
        *(float *)(v19 + 28) = v133;
        if (v26[2] >= v27[2]) {
          float v134 = 0.0;
        }
        else {
          float v134 = 1.0;
        }
        *(float *)(v19 + 32) = v134;
        if (v26[3] < v27[3]) {
          float v49 = 1.0;
        }
        goto LABEL_450;
      case 0x36u:
        LODWORD(v36) = 0;
        float v49 = 0.0;
        if (*v26 == *v27) {
          float v135 = 0.0;
        }
        else {
          float v135 = 1.0;
        }
        *(float *)(v19 + 24) = v135;
        if (v26[1] == v27[1]) {
          float v136 = 0.0;
        }
        else {
          float v136 = 1.0;
        }
        *(float *)(v19 + 28) = v136;
        if (v26[2] == v27[2]) {
          float v137 = 0.0;
        }
        else {
          float v137 = 1.0;
        }
        *(float *)(v19 + 32) = v137;
        if (v26[3] != v27[3]) {
          float v49 = 1.0;
        }
        goto LABEL_450;
      case 0x37u:
        LODWORD(v36) = 0;
        *(void *)long long v37 = 0;
        *(void *)(v19 + 32) = 0;
        break;
      case 0x38u:
        int v138 = *(unsigned __int16 *)a1;
        if ((v138 - 35632) >= 2 && (v138 - 36487) >= 2 && v138 != 36313)
        {
          *(float *)v53.i32 = powf(v26[3], v27[3]);
          LODWORD(v36) = 0;
          goto LABEL_193;
        }
        *(float *)(v19 + 24) = powf(*v26, *v27);
        *(float *)(v19 + 28) = powf(v26[1], v27[1]);
        *(float *)(v19 + 32) = powf(v26[2], v27[2]);
        float v99 = powf(v26[3], v27[3]);
LABEL_300:
        LODWORD(v36) = 0;
LABEL_447:
        *(float *)(v19 + 36) = v99;
        goto LABEL_448;
      case 0x39u:
        LODWORD(v36) = 0;
        *(float *)(v19 + 24) = v26[*v27];
        *(float *)(v19 + 28) = v26[*v27];
        *(float *)(v19 + 32) = v26[*v27];
        float v99 = v26[*v27];
        goto LABEL_447;
      case 0x3Au:
        LODWORD(v36) = *(_DWORD *)(v19 + 12);
        if (v36 == 2)
        {
          LODWORD(v36) = 0;
          *(float *)(v19 + 24) = truncf(*v26 / *v27);
          *(float *)(v19 + 28) = truncf(v26[1] / v27[1]);
          *(float *)(v19 + 32) = truncf(v26[2] / v27[2]);
          float v49 = truncf(v26[3] / v27[3]);
        }
        else
        {
          if (v36)
          {
            LODWORD(v36) = 0;
            break;
          }
          *(float *)(v19 + 24) = *v26 / *v27;
          *(float *)(v19 + 28) = v26[1] / v27[1];
          *(float *)(v19 + 32) = v26[2] / v27[2];
          float v49 = v26[3] / v27[3];
        }
LABEL_450:
        *(float *)(v19 + 36) = v49;
        break;
      default:
        if (v48 == 110)
        {
          LODWORD(v36) = 0;
          v37[*v27] = v26[*v27];
        }
        else
        {
          if (v48 != 133) {
            break;
          }
          uint64_t v36 = ((v47 >> 36) & 3) + 1;
          int32x2_t v53 = 0;
          int v54 = v26;
          long long v55 = v27;
          do
          {
            float v56 = *v54++;
            float v57 = v56;
            float v58 = *v55++;
            *(float *)v53.i32 = *(float *)v53.i32 + (float)((float)(v57 - v58) * (float)(v57 - v58));
            --v36;
          }
          while (v36);
          *(float *)v53.i32 = sqrtf(*(float *)v53.i32);
LABEL_193:
          *(int32x4_t *)long long v37 = vdupq_lane_s32(v53, 0);
        }
LABEL_448:
        unsigned int v46 = 1;
        break;
    }
  }
LABEL_327:
  if (v19 && v36 && v10 == 3 && v26 && v46 && v28)
  {
    unint64_t v142 = a2[3];
    switch((v142 >> 6))
    {
      case ';':
        uint64_t v143 = ((v142 >> 36) & 3) + 1;
        float v144 = 0.0;
        do
        {
          float v145 = *v28++;
          float v146 = v145;
          float v147 = *v27++;
          float v144 = v144 + (float)(v146 * v147);
          --v143;
        }
        while (v143);
        float v148 = *v26;
        if (v144 >= 0.0)
        {
          *(float *)(v19 + 24) = -v148;
          *(float *)(v19 + 28) = -v26[1];
          *(float *)(v19 + 32) = -v26[2];
          float v149 = -v26[3];
        }
        else
        {
          *(float *)(v19 + 24) = v148;
          *(float *)(v19 + 28) = v26[1];
          *(float *)(v19 + 32) = v26[2];
          float v149 = v26[3];
        }
        goto LABEL_408;
      case '<':
        *(float *)(v19 + 24) = (float)((float)(1.0 - *v26) * *v28) + (float)(*v26 * *v27);
        *(float *)(v19 + 28) = (float)((float)(1.0 - v26[1]) * v28[1]) + (float)(v26[1] * v27[1]);
        *(float *)(v19 + 32) = (float)((float)(1.0 - v26[2]) * v28[2]) + (float)(v26[2] * v27[2]);
        float v158 = v26[3];
        float v159 = v27[3];
        float v160 = (float)(1.0 - v158) * v28[3];
        goto LABEL_362;
      case '=':
        float v155 = *v26;
        if (*v26 <= *v27) {
          float v155 = *v27;
        }
        if (v155 >= *v28) {
          float v155 = *v28;
        }
        *(float *)(v19 + 24) = v155;
        float v156 = v26[1];
        if (v156 <= v27[1]) {
          float v156 = v27[1];
        }
        if (v156 >= v28[1]) {
          float v156 = v28[1];
        }
        *(float *)(v19 + 28) = v156;
        float v157 = v26[2];
        if (v157 <= v27[2]) {
          float v157 = v27[2];
        }
        if (v157 >= v28[2]) {
          float v157 = v28[2];
        }
        *(float *)(v19 + 32) = v157;
        float v149 = v26[3];
        if (v149 <= v27[3]) {
          float v149 = v27[3];
        }
        if (v149 >= v28[3]) {
          float v149 = v28[3];
        }
        goto LABEL_408;
      case '>':
        if (*v26 >= 0.0) {
          uint64_t v161 = v28;
        }
        else {
          uint64_t v161 = v27;
        }
        *(float *)(v19 + 24) = *v161;
        if (v26[1] >= 0.0) {
          uint64_t v162 = v28;
        }
        else {
          uint64_t v162 = v27;
        }
        *(float *)(v19 + 28) = v162[1];
        if (v26[2] >= 0.0) {
          uint64_t v163 = v28;
        }
        else {
          uint64_t v163 = v27;
        }
        *(float *)(v19 + 32) = v163[2];
        if (v26[3] >= 0.0) {
          int8x16_t v164 = v28;
        }
        else {
          int8x16_t v164 = v27;
        }
        float v149 = v164[3];
        goto LABEL_408;
      case '?':
        *(float *)(v19 + 24) = *v28 + (float)(*v26 * *v27);
        *(float *)(v19 + 28) = v28[1] + (float)(v26[1] * v27[1]);
        *(float *)(v19 + 32) = v28[2] + (float)(v26[2] * v27[2]);
        float v158 = v26[3];
        float v159 = v27[3];
        float v160 = v28[3];
LABEL_362:
        float v149 = v160 + (float)(v158 * v159);
        goto LABEL_408;
      case '@':
        float v165 = 0.0;
        float v166 = fminf(fmaxf((float)(*v28 - *v26) / (float)(*v27 - *v26), 0.0), 1.0);
        *(float *)(v19 + 24) = (float)(v166 * v166) * (float)((float)(v166 * -2.0) + 3.0);
        float v167 = (float)(v28[1] - v26[1]) / (float)(v27[1] - v26[1]);
        BOOL v168 = v167 <= 0.0;
        BOOL v169 = v167 < 1.0 || v167 <= 0.0;
        if (v167 >= 1.0) {
          BOOL v168 = 1;
        }
        if (v169) {
          float v170 = 0.0;
        }
        else {
          float v170 = 1.0;
        }
        if (v168) {
          float v167 = v170;
        }
        *(float *)(v19 + 28) = (float)(v167 * v167) * (float)((float)(v167 * -2.0) + 3.0);
        float v171 = (float)(v28[2] - v26[2]) / (float)(v27[2] - v26[2]);
        BOOL v172 = v171 <= 0.0;
        BOOL v173 = v171 < 1.0 || v171 <= 0.0;
        if (v171 >= 1.0) {
          BOOL v172 = 1;
        }
        if (v173) {
          float v174 = 0.0;
        }
        else {
          float v174 = 1.0;
        }
        if (v172) {
          float v171 = v174;
        }
        *(float *)(v19 + 32) = (float)(v171 * v171) * (float)((float)(v171 * -2.0) + 3.0);
        float v175 = (float)(v28[3] - v26[3]) / (float)(v27[3] - v26[3]);
        BOOL v176 = v175 <= 0.0;
        BOOL v177 = v175 < 1.0 || v175 <= 0.0;
        if (v175 >= 1.0) {
          BOOL v176 = 1;
        }
        if (!v177) {
          float v165 = 1.0;
        }
        if (v176) {
          float v175 = v165;
        }
        float v149 = (float)(v175 * v175) * (float)((float)(v175 * -2.0) + 3.0);
        goto LABEL_408;
      default:
        if ((v142 >> 6) != 105) {
          goto LABEL_34;
        }
        unint64_t v150 = 0;
        uint64_t v151 = 4 * ((v142 >> 36) & 3) + 4;
        float v152 = 0.0;
        do
        {
          float v152 = v152 + (float)(v26[v150 / 4] * v27[v150 / 4]);
          v150 += 4;
        }
        while (v151 != v150);
        float v153 = *v28;
        float v154 = (float)((float)-(float)(v153 * v153) * (float)(1.0 - (float)(v152 * v152))) + 1.0;
        if (v154 >= 0.0)
        {
          float v178 = sqrtf(v154) + (float)(v153 * v152);
          *(float *)(v19 + 24) = (float)(v153 * *v26) - (float)(v178 * *v27);
          *(float *)(v19 + 28) = (float)(*v28 * v26[1]) - (float)(v178 * v27[1]);
          *(float *)(v19 + 32) = (float)(*v28 * v26[2]) - (float)(v178 * v27[2]);
          float v149 = (float)(*v28 * v26[3]) - (float)(v178 * v27[3]);
LABEL_408:
          *(float *)(v19 + 36) = v149;
        }
        else
        {
          *(void *)long long v37 = 0;
          *(void *)(v19 + 32) = 0;
        }
        break;
    }
LABEL_409:
    *(_DWORD *)(v19 + 20) = 1;
    goto LABEL_410;
  }
LABEL_35:
  if (v19 && v36)
  {
    ClearDestedOpRegisters((uint64_t)a1, v5, (uint64_t)a2, 0);
    goto LABEL_410;
  }
  if (v19) {
    goto LABEL_409;
  }
LABEL_410:
  unint64_t v179 = a2[3];
  int v180 = (v179 >> 6);
  switch((v179 >> 6))
  {
    case 'K':
    case 'L':
    case 'M':
    case 'T':
    case 'j':
    case 'r':
    case 's':
    case 't':
      goto LABEL_416;
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
      break;
    case 'U':
      EmulationContext_PushRegistersCopy(a3);
      uint64_t v183 = *(void **)PPStreamChunkListChunkAtIndex(a1[13], a2[3] >> 46);
      if (v183 && (v183[3] & 0x3FC0) == 0x1600)
      {
        uint64_t v183 = *(void **)PPStreamChunkListChunkAtIndex(a1[13], v183[3] >> 46);
        EmulationContext_PushRegistersCopy(a3);
      }
      for (; a2 != v183; a2 = (void *)a2[1])
        ClearDestedOpRegisters((uint64_t)a1, v5, (uint64_t)a2, 1);
      break;
    case 'V':
    case 'W':
    case 'k':
      for (uint64_t i = *(void **)PPStreamChunkListChunkAtIndex(a1[13], v179 >> 46); a2 != i; a2 = (void *)a2[1])
        ClearDestedOpRegisters((uint64_t)a1, v5, (uint64_t)a2, 1);
      break;
    case 'X':
    case 'Y':
      EmulationContext_PopRegisters((void **)a3);
      break;
    case 'Z':
    case '[':
    case 'l':
      for (uint64_t j = *(void *)PPStreamChunkListChunkAtIndex(a1[13], v179 >> 46); (void *)j != a2; uint64_t j = *(void *)(j + 8))
        ClearDestedOpRegisters((uint64_t)a1, v5, j, 1);
      break;
    default:
      if ((v180 - 135) <= 8 && ((1 << (v180 + 121)) & 0x1E3) != 0) {
LABEL_416:
      }
        ClearRegisterState(v5);
      break;
  }
  free(v7);
}

void UnrollConstantLoopSimple(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v7 = (char *)a3;
  if (a4 >= 1)
  {
    int v8 = a4;
    uint64_t v9 = HashTableNew((*(_DWORD *)(*(void *)(a1 + 104) + 16) >> 5) + 1, (unint64_t (*)(unint64_t))instructionIndexHashFunction, instructionIndexEqualsFunction);
    uint64_t v7 = (char *)a3;
    do
    {
      uint64_t v10 = a2[1];
      BOOL v11 = v10 == 0;
      unint64_t v12 = 0;
      while (!v11 && v10 != a3)
      {
        inserted = PPStreamInsertOperationAfterChunk(a1, v10 + 24, 0, (uint64_t)v7);
        uint64_t v7 = inserted;
        if (!v12) {
          unint64_t v12 = inserted;
        }
        HashTableAdd(v9, (*(_DWORD *)(v10 + 88) + 1), (*((_DWORD *)inserted + 22) + 1));
        uint64_t v10 = *(void *)(v10 + 8);
        BOOL v11 = v10 == 0;
      }
      uint64_t v30 = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      uint64_t v25 = 7104;
      uint64_t v7 = PPStreamInsertOperationAfterChunk(a1, (uint64_t)&v25, 0, (uint64_t)v7);
      HashTableAdd(v9, (*(_DWORD *)(a3 + 88) + 1), (*((_DWORD *)v7 + 22) + 1));
      if (v12) {
        unint64_t v15 = v12;
      }
      else {
        unint64_t v15 = v7;
      }
      if (v15 && v15 != v7)
      {
        do
        {
          uint64_t v16 = HashTableGet(v9, (*((void *)v15 + 3) >> 46) + 1);
          if (v16) {
            *((void *)v15 + 3) = (*((void *)v15 + 3) & 0x3FFFFFFFFFFFLL | ((unint64_t)v16 << 46))
          }
                                 - 0x400000000000;
          unint64_t v15 = (char *)*((void *)v15 + 1);
          if (v15) {
            BOOL v17 = v15 == v7;
          }
          else {
            BOOL v17 = 1;
          }
        }
        while (!v17);
      }
      BOOL v18 = __OFSUB__(v8--, 1);
    }
    while (!((v8 < 0) ^ v18 | (v8 == 0)));
    HashTableFree(v9);
  }
  uint64_t v19 = *(void **)(a3 + 8);
  int32x4_t v20 = (void *)*((void *)v7 + 1);
  if (v19 != v20)
  {
    do
    {
      int v21 = (void *)v19[1];
      int v22 = (*((_DWORD *)v19 + 6) >> 6);
      if (v22 == 115 || v22 == 111) {
        PPStreamRemoveOperation(a1, v19);
      }
      uint64_t v19 = v21;
    }
    while (v21 != v20);
  }
  if ((v20[3] & 0x3FC0) == 0x1D00) {
    PPStreamRemoveOperation(a1, v20);
  }
  long long v23 = *(void **)(a3 + 8);
  if (v23 != a2)
  {
    do
    {
      uint64_t v24 = (void *)a2[1];
      PPStreamRemoveOperation(a1, a2);
      a2 = v24;
    }
    while (v24 != v23);
  }
}

uint64_t instructionIndexEqualsFunction(int a1, int a2)
{
  return (a1 - a2);
}

uint64_t RepifyConstantLoopSimple(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v8 = (*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1;
  v21[0] = 0;
  v21[1] = (void *)v8;
  v21[2] = regHashFunction;
  v21[3] = regEqualsFunction;
  uint64_t v9 = HashSetNew(v8, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
  EmulationContext_PushRegisters((uint64_t *)v21, (uint64_t)v9);
  char v10 = 0;
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = 1;
  if (v11 && v11 != a3)
  {
    uint64_t v13 = v21[0][1];
    while (1)
    {
      int v14 = (*(_DWORD *)(v11 + 24) >> 6);
      if (v14 == 87 || v14 == 72)
      {
        long long v19 = 0u;
        long long v20 = 0u;
        unint64_t v15 = *(void *)(v11 + 40);
        v18[0] = HIWORD(v15);
        v18[1] = (v15 >> 6) & 7;
        uint64_t v16 = HashSetGet(v13, (uint64_t)v18);
        if (!v16 || !*(_DWORD *)(v16 + 20)) {
          break;
        }
      }
      EmulateOp((uint64_t **)a1, (void *)v11, (uint64_t *)v21);
      char v10 = 0;
      uint64_t v11 = *(void *)(v11 + 8);
      if (!v11 || v11 == a3) {
        goto LABEL_13;
      }
    }
    uint64_t v12 = 0;
    char v10 = 1;
  }
LABEL_13:
  while (v21[0])
    EmulationContext_PopRegisters(v21);
  if ((v10 & 1) == 0)
  {
    *(void *)(a2 + 40) = *(void *)(a2 + 40) & 0xFFFFFFFFFFFFFE3FLL | 0x80;
    *(_WORD *)(a2 + 46) = AddConstantParam(a1, 0, 0, 0, COERCE_UNSIGNED_INT((float)a4), 0);
  }
  return v12;
}

uint64_t AddConstantParam(uint64_t a1, int a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (a3)
  {
    LODWORD(v20) = (int)*(float *)&a5;
    HIDWORD(v20) = (int)*((float *)&a5 + 1);
    LODWORD(v21) = (int)*(float *)&a6;
    HIDWORD(v21) = (int)*((float *)&a6 + 1);
  }
  else
  {
    uint64_t v20 = a5;
    uint64_t v21 = a6;
  }
  if (a4 <= 2) {
    bzero((char *)&v20 + 4 * a4 + 4, 4 * (2 - a4) + 4);
  }
  char v10 = *(uint64_t **)(a1 + 56);
  uint64_t v11 = *v10;
  if (*v10)
  {
    while (1)
    {
      uint64_t v12 = *(void *)(v11 + 24);
      BOOL v13 = (v12 & 0x1F00) == 0x600 && ((v12 >> 3) & 7) == a3;
      BOOL v14 = v13 && (v12 & 7) == a2;
      if (v14 && v12 >> 6 == a4)
      {
        uint64_t v16 = PPStreamChunkListChunkAtIndex(*(uint64_t **)(a1 + 128), WORD2(v12));
        if (v20 == *(void *)(v16 + 24) && v21 == *(void *)(v16 + 32)) {
          return *(unsigned int *)(v11 + 32);
        }
      }
      uint64_t v11 = *(void *)(v11 + 8);
      if (!v11)
      {
        char v10 = *(uint64_t **)(a1 + 56);
        goto LABEL_25;
      }
    }
  }
  else
  {
LABEL_25:
    *((void *)&v19 + 1) = PPStreamChunkListGetNextIndex(v10);
    *(void *)&long long v19 = a2 & 7 | (8 * (a3 & 7)) & 0x3F | ((a4 & 3) << 6) | 0x600u | ((unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 128) + 16) << 32);
    PPStreamAddConstant(a1, &v20);
    PPStreamAddParamBinding(a1, &v19);
    return DWORD2(v19);
  }
}

void ConstantPropagateFold(uint64_t a1)
{
  unsigned int v2 = (*(_DWORD *)(*(void *)(a1 + 32) + 16) >> 5) + 1;
  v24[0] = 0;
  v24[1] = (void *)v2;
  v24[2] = regHashFunction;
  void v24[3] = regEqualsFunction;
  int v3 = HashSetNew(v2, (unint64_t (*)(unint64_t))regHashFunction, (uint64_t (*)(int, int))regEqualsFunction);
  EmulationContext_PushRegisters((uint64_t *)v24, (uint64_t)v3);
  for (uint64_t i = **(void **)(a1 + 104); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v5 = v24[0][1];
    uint64_t v6 = *(void *)(i + 24) & 7;
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = i + 40;
      do
      {
        if (v7 < (*(_DWORD *)(i + 24) & 7) + ((__int16)*(_DWORD *)(i + 24) >> 15))
        {
          uint64_t v9 = *(void *)(v8 + 8 * v7);
          if (v9)
          {
            memset((char *)v23 + 8, 0, 32);
            *(void *)&v23[0] = 0x400000000;
            uint64_t v10 = HashSetGet(v5, (uint64_t)v23);
            if (v10)
            {
              if (*(_DWORD *)(v10 + 20))
              {
                unint64_t v11 = *(void *)(v8 + 8 * v7);
                int v12 = (int)*(float *)(v10 + 24);
                int v13 = HIWORD(v11) + ((int)v11 >> 24);
                uint64_t v14 = (v13 + v12);
                if (GetRegChunk((uint64_t **)a1, (v11 >> 6) & 7, v13 + v12)) {
                  *(void *)(v8 + 8 * v7) = *(void *)(v8 + 8 * v7) & 0xFFFF00FFFFFELL | (v14 << 48);
                }
              }
            }
            uint64_t v9 = *(void *)(v8 + 8 * v7);
          }
          if ((v9 & 0x1E0611) == 0)
          {
            memset(v23, 0, 40);
            uint64_t v15 = v8 + 8 * v7;
            DWORD1(v23[0]) = (*(_DWORD *)v15 >> 6) & 7;
            LODWORD(v23[0]) = *(unsigned __int16 *)(v15 + 6);
            uint64_t v16 = HashSetGet(v5, (uint64_t)v23);
            if (v16)
            {
              if (*(_DWORD *)(v16 + 20))
              {
                uint64_t v17 = v8 + 8 * v7;
                *(void *)uint64_t v17 = *(void *)v17 & 0xFFFFFFFFFFFFFE3FLL | 0x80;
                *(_WORD *)(v17 + 6) = AddConstantParam(a1, *(_DWORD *)(v16 + 8), *(_DWORD *)(v16 + 12), *(_DWORD *)(v16 + 16), *(void *)(v16 + 24), *(void *)(v16 + 32));
              }
            }
          }
        }
        ++v7;
      }
      while (v6 != v7);
    }
    if (*(unsigned char *)(i + 36))
    {
      memset((char *)v23 + 8, 0, 32);
      *(void *)&v23[0] = 0x400000000;
      uint64_t v18 = HashSetGet(v5, (uint64_t)v23);
      if (v18)
      {
        if (*(_DWORD *)(v18 + 20))
        {
          unint64_t v19 = *(void *)(i + 32);
          int v20 = (int)*(float *)(v18 + 24);
          int v21 = HIWORD(v19) + ((int)(v19 >> 12) >> 24);
          uint64_t v22 = (v21 + v20);
          if (GetRegChunk((uint64_t **)a1, (v19 >> 12) & 7, v21 + v20)) {
            *(void *)(i + 32) = *(void *)(i + 32) & 0xF00EFFFFFFFFLL | (v22 << 48);
          }
        }
      }
    }
    EmulateOp((uint64_t **)a1, (void *)i, (uint64_t *)v24);
  }
  while (v24[0])
    EmulationContext_PopRegisters(v24);
}

uint64_t GetRegChunk(uint64_t **a1, int a2, int a3)
{
  switch(a2)
  {
    case 0:
      int v3 = a1 + 6;
      goto LABEL_7;
    case 1:
      int v3 = a1 + 4;
      goto LABEL_7;
    case 2:
      int v3 = a1 + 7;
      goto LABEL_7;
    case 3:
    case 5:
      int v3 = a1 + 8;
LABEL_7:
      uint64_t result = PPStreamChunkListChunkAtIndex(*v3, a3);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t DecomposeMatrixOps(uint64_t result, int a2)
{
  int v129 = a2;
  uint64_t v152 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(void **)(result + 104);
  if (v2)
  {
    uint64_t v3 = result;
    float v134 = (unint64_t *)&v143;
    int8x16_t v133 = (int8x16_t)xmmword_2393DBD90;
    int8x16_t v132 = (int8x16_t)xmmword_2393DBDA0;
    uint64_t v128 = 0xFFFFFFE6003ELL;
    uint64_t v137 = result;
    do
    {
      long long v4 = *(_OWORD *)(v2 + 40);
      long long v147 = *(_OWORD *)(v2 + 24);
      long long v148 = v4;
      long long v5 = *(_OWORD *)(v2 + 72);
      long long v149 = *(_OWORD *)(v2 + 56);
      long long v150 = v5;
      long long v151 = *(_OWORD *)(v2 + 88);
      unint64_t v6 = v147;
      *(void *)&long long v147 = v147 & 0xFFFFFFFFFFFFBFFFLL;
      unsigned int v7 = (v6 >> 6);
      if (v7 > 0x39)
      {
        if ((v6 >> 6) > 0x74u)
        {
          if (v7 == 117)
          {
            if ((BYTE10(v147) & 0x18) == 0) {
              goto LABEL_135;
            }
            v136.i64[0] = (uint64_t)&v128;
            unint64_t v77 = ((unint64_t)v148 >> 19) & 3;
            inserted = (char *)v2;
            unsigned int v78 = v148 >> 17;
            MEMORY[0x270FA5388](result);
            float v80 = (unsigned int *)((char *)&v128 - v79);
            uint64_t v81 = 0;
            uint64_t v83 = ((v82 >> 17) & 3) + 1;
            float v131 = inserted;
            do
            {
              unsigned int v84 = AddTempRegister(v3, (v147 >> 19) & 7, ((unint64_t)v147 >> 38) & 7, (DWORD2(v147) >> 21) & 3);
              int v85 = 0;
              uint64_t v86 = 0;
              v80[v81] = v84;
              do
              {
                long long v142 = v147;
                long long v143 = v148;
                unint64_t v87 = *((void *)&v147 + 1) & 0xFFFF80600FFFLL | ((unint64_t)v80[v81] << 48);
                long long v144 = v149;
                long long v145 = v150;
                long long v146 = v151;
                *(void *)&long long v142 = v147 & 0xFFFFFFC3FFFFC03FLL;
                *((void *)&v142 + 1) = v87 | 0x1000;
                if (v86 <= 3) {
                  *((void *)&v142 + 1) = v87 | 0x1000 | qword_2393DBE88[v86];
                }
                unint64_t v88 = (v86 + WORD3(v143)) << 48;
                if (v143) {
                  uint64_t v89 = (v85 + v143) & 0xFF000000;
                }
                else {
                  uint64_t v89 = v143 & 0xFFFFFFE1FFFFLL;
                }
                if (v143) {
                  unint64_t v88 = v143 & 0xFFFFFFFF00E1FFFFLL;
                }
                unint64_t v90 = v88 | v89;
                switch((int)v81)
                {
                  case 0:
                    uint64_t v91 = (v90 >> 9) & 3;
                    break;
                  case 1:
                    uint64_t v91 = (v90 >> 11) & 3;
                    break;
                  case 2:
                    uint64_t v91 = (v90 >> 13) & 3;
                    break;
                  case 3:
                    uint64_t v91 = (v90 >> 15) & 3;
                    break;
                  default:
                    uint64_t v91 = 0;
                    break;
                }
                *(void *)&long long v143 = v90 & 0xFFFFFFFFFFFE01FFLL | (v91 << 15) | (v91 << 13) | (v91 << 11) | (v91 << 9);
                inserted = PPStreamInsertOperationAfterChunk(v137, (uint64_t)&v142, 0, (uint64_t)inserted);
                ++v86;
                v85 += 0x1000000;
              }
              while (v83 != v86);
              BOOL v31 = v81++ == v77;
              uint64_t v3 = v137;
            }
            while (!v31);
            uint64_t v92 = 0;
            uint64_t v93 = (v77 << 48) + 0x1000000000000;
            do
            {
              long long v142 = v147;
              long long v143 = v148;
              unsigned int v94 = *v80++;
              *(void *)&long long v143 = v148 & 0xFFFFFFE0003ELL | ((v78 & 3) << 19) | 0x40 | ((unint64_t)v94 << 48) | 0x1C800;
              long long v144 = v149;
              long long v145 = v150;
              long long v146 = v151;
              *(void *)&long long v142 = v147 & 0xFFFFFFF3FFFFC038 | 1;
              *((void *)&v142 + 1) = (v92 + *((void *)&v147 + 1)) & 0xFFFF000000000000 | *((void *)&v147 + 1) & 0xFFFFFFE7FFFFLL;
              inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
              v92 += 0x1000000000000;
            }
            while (v93 != v92);
            goto LABEL_112;
          }
          if (v7 != 118)
          {
            if (v7 != 122) {
              goto LABEL_135;
            }
            unsigned int v44 = DWORD2(v147);
            if ((*((void *)&v147 + 1) & 0x180000) == 0) {
              goto LABEL_135;
            }
            *((void *)&v142 + 1) = 0;
            inserted = (char *)v2;
            DWORD2(v142) = PPStreamChunkListGetNextIndex(*(uint64_t **)(v3 + 32));
            *(void *)&long long v142 = 16;
            PPStreamAddTempUsage(v3, &v142);
            unsigned int v45 = 0;
            int v46 = (v44 >> 19) & 3;
            unint64_t v47 = (unint64_t)DWORD2(v142) << 48;
            int v48 = v46 + 1;
            float v131 = (char *)v2;
            do
            {
              *(void *)&long long v143 = v148;
              long long v144 = v149;
              long long v145 = v150;
              long long v146 = v151;
              *(void *)&long long v142 = v147 & 0xFFFFFE03FFFFC03FLL | 0x80000007C0;
              *((void *)&v142 + 1) = v47 | *((void *)&v147 + 1) & 0xFFFFFF878FFFLL | 0x1000;
              *((void *)&v143 + 1) = v148 & 0xFFFFFFFFFFFFFE3FLL | 0x80;
              HIWORD(v143) = AddConstantParam(v3, 0, 2, 0, COERCE_UNSIGNED_INT((float)v45), 0);
              float v49 = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
              *((void *)&v143 + 1) = *((void *)&v148 + 1);
              long long v144 = v149;
              long long v145 = v150;
              long long v146 = v151;
              *(void *)&long long v142 = v147 & 0xFFFFFFF3FFFFFFFFLL;
              *((void *)&v142 + 1) = *((void *)&v147 + 1) & 0xFFFFFFE7FFFFLL | ((unint64_t)(v45 + HIWORD(*((void *)&v147 + 1))) << 48);
              *(void *)&long long v143 = v47 | v148 & 0xFFFFFFF9FE3FLL | 0x40;
              inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)v49);
              ++v45;
            }
            while (v48 != v45);
            goto LABEL_71;
          }
        }
        else
        {
          if (v7 == 58) {
            goto LABEL_49;
          }
          if (v7 != 78)
          {
            if (v7 != 109) {
              goto LABEL_135;
            }
LABEL_13:
            int v8 = (DWORD2(v147) >> 19) & 3;
            if (!v8) {
              goto LABEL_135;
            }
            inserted = (char *)v2;
            int v10 = 0;
            int v11 = 0;
            int v12 = v8 + 1;
            float v131 = (char *)v2;
            do
            {
              long long v143 = v148;
              long long v144 = v149;
              long long v145 = v150;
              long long v146 = v151;
              *(void *)&long long v142 = v147 & 0xFFFFFFF3FFFFFFFFLL;
              *((void *)&v142 + 1) = *((void *)&v147 + 1) & 0xFFFFFFE7FFFFLL | ((unint64_t)(v11 + HIWORD(*((void *)&v147 + 1))) << 48);
              unint64_t v13 = (unint64_t)(v11 + WORD3(v148)) << 48;
              if (v148) {
                uint64_t v14 = (v10 + v148) & 0xFF000000;
              }
              else {
                uint64_t v14 = v148 & 0xFFFFFFF9FFFFLL;
              }
              if (v148) {
                unint64_t v13 = v148 & 0xFFFFFFFF00F9FFFFLL;
              }
              *(void *)&long long v143 = v13 | v14;
              inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
              ++v11;
              v10 += 0x1000000;
            }
            while (v12 != v11);
LABEL_71:
            uint64_t v42 = v3;
            uint64_t v43 = v131;
LABEL_72:
            uint64_t result = PPStreamRemoveOperation(v42, v43);
            goto LABEL_136;
          }
          if (v129) {
            goto LABEL_135;
          }
        }
      }
      else
      {
        if ((v6 >> 6) > 0x22u)
        {
          if (v7 == 35)
          {
LABEL_49:
            int v34 = (DWORD2(v147) >> 19) & 3;
            if (!v34) {
              goto LABEL_135;
            }
            int v35 = 0;
            int v36 = 0;
            int v37 = v34 + 1;
            inserted = (char *)v2;
            do
            {
              long long v142 = v147;
              long long v143 = v148;
              long long v144 = v149;
              long long v145 = v150;
              long long v146 = v151;
              uint64_t v38 = v147 & 0x3FC0;
              if (v38 == 2240) {
                uint64_t v38 = 2176;
              }
              *(void *)&long long v142 = v38 | v147 & 0xFFFFFFF3FFFFC03FLL;
              *((void *)&v142 + 1) = *((void *)&v147 + 1) & 0xFFFFFFE7FFFFLL | ((unint64_t)(v36 + HIWORD(*((void *)&v147 + 1))) << 48);
              if ((v143 & 0x60000) != 0)
              {
                if (v143) {
                  unint64_t v39 = v143 & 0xFFFFFFFF00F9FFFFLL | (v35 + v143) & 0xFF000000;
                }
                else {
                  unint64_t v39 = v143 & 0xFFFFFFF9FFFFLL | ((unint64_t)(v36 + WORD3(v143)) << 48);
                }
              }
              else
              {
                unint64_t v39 = v143 & 0xFFFFFFFFFFE607FFLL | *((void *)&v143 + 1) & 0x180000 | ((((unint64_t)v143 >> 9) & 3) << 15) | ((((unint64_t)v143 >> 9) & 3) << 13) | ((((unint64_t)v143 >> 9) & 3) << 11);
              }
              unint64_t v40 = *((void *)&v143 + 1) & 0xFFFFFFF9FFFFLL | ((unint64_t)(v36
                                                                                  + HIWORD(*((void *)&v143 + 1))) << 48);
              if (BYTE8(v143)) {
                unint64_t v40 = *((void *)&v143 + 1) & 0xFFFFFFFF00F9FFFFLL | (v35 + DWORD2(v143)) & 0xFF000000;
              }
              if ((*((void *)&v143 + 1) & 0x60000) != 0) {
                unint64_t v41 = v40;
              }
              else {
                unint64_t v41 = *((void *)&v143 + 1) & 0xFFFFFFFFFFE607FFLL | v39 & 0x180000 | (((*((void *)&v143 + 1) >> 9) & 3) << 15) | (((*((void *)&v143 + 1) >> 9) & 3) << 13) | (((*((void *)&v143 + 1) >> 9) & 3) << 11);
              }
              *(void *)&long long v143 = v39;
              *((void *)&v143 + 1) = v41;
              inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
              ++v36;
              v35 += 0x1000000;
            }
            while (v37 != v36);
          }
          else
          {
            if (v7 != 49 && v7 != 54 || ((DWORD2(v148) | v148) & 0x60000) == 0)
            {
LABEL_135:
              inserted = (char *)v2;
              goto LABEL_136;
            }
            int v15 = (*(_DWORD *)(((unint64_t)&v147 | (8 * ((v148 & 0x60000) == 0))) + 0x10) >> 17) & 3;
            unsigned int v16 = (v6 >> 19) & 7;
            uint64_t v17 = (v6 >> 38) & 7;
            uint64_t v18 = (v6 >> 36) & 3;
            unsigned int v19 = AddTempRegister(v3, (v6 >> 19) & 7, (v6 >> 38) & 7, (v6 >> 36) & 3);
            unsigned int v20 = AddTempRegister(v3, v16, v17, v18);
            int v21 = 0;
            unsigned int v22 = v20;
            v23.i64[0] = v19;
            v23.i64[1] = v20;
            int8x16_t v136 = (int8x16_t)vshlq_n_s64(v23, 0x30uLL);
            uint64_t v24 = v136.i64[0];
            inserted = (char *)v2;
            do
            {
              long long v142 = v147;
              long long v143 = v148;
              long long v144 = v149;
              long long v145 = v150;
              long long v146 = v151;
              if (v21) {
                uint64_t v25 = v22;
              }
              else {
                uint64_t v25 = v19;
              }
              *(void *)&long long v142 = v147 & 0xFFFFFFF3FFFFFFFFLL;
              *((void *)&v142 + 1) = *((void *)&v142 + 1) & 0xFFFE80180FFFLL | (v25 << 48) | 0x72041000;
              uint64_t v26 = v147 & 7;
              if ((v147 & 7) != 0)
              {
                long long v27 = v134;
                do
                {
                  unint64_t v28 = *v27;
                  if ((*v27 & 0x60000) != 0)
                  {
                    unint64_t v29 = (unint64_t)(v21 + HIWORD(v28)) << 48;
                    unint64_t v30 = v28 & 0xFFFFFFFF00F9FFFFLL;
                    BOOL v31 = (v28 & 1) == 0;
                    if (v28) {
                      uint64_t v32 = ((v21 << 24) + v28) & 0xFF000000;
                    }
                    else {
                      uint64_t v32 = v28 & 0xFFFFFFF9FFFFLL;
                    }
                    if (!v31) {
                      unint64_t v29 = v30;
                    }
                    *long long v27 = v29 | v32;
                  }
                  ++v27;
                  --v26;
                }
                while (v26);
              }
              inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
              if (v21)
              {
                v138[0] = v147;
                v138[1] = v148;
                long long v139 = v149;
                long long v140 = v150;
                long long v141 = v151;
                uint64_t v33 = 2368;
                if ((v147 & 0x3FC0) == 0xC40) {
                  uint64_t v33 = 2304;
                }
                *(void *)&v138[0] = v33 | v147 & 0xFFFFFFFFFFFFC03FLL;
                *((void *)&v138[1] + 1) = v24 | 0x1C840 | *((void *)&v138[1] + 1) & 0xFFFFFFE0002ELL;
                *(int8x16_t *)((char *)v138 + 8) = vorrq_s8(vorrq_s8(v136, v132), vandq_s8(*(int8x16_t *)((char *)v138 + 8), v133));
                inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)v138, 0, (uint64_t)inserted);
              }
              if (v21 == v15)
              {
                *((void *)&v138[0] + 1) = *((void *)&v147 + 1);
                *((void *)&v138[1] + 1) = *((void *)&v148 + 1);
                long long v139 = v149;
                long long v140 = v150;
                long long v141 = v151;
                *(void *)&v138[0] = v147 & 0xFFFFFFFFFFFFC038 | 1;
                *(void *)&v138[1] = v148 & 0xFFFFFFE0002ELL | v24 | 0x1C840;
                inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)v138, 0, (uint64_t)inserted);
              }
              BOOL v31 = v21++ == v15;
            }
            while (!v31);
          }
          goto LABEL_64;
        }
        if (v7 - 31 < 2) {
          goto LABEL_49;
        }
        if (!(v6 >> 6)) {
          goto LABEL_13;
        }
        if (v7 != 34) {
          goto LABEL_135;
        }
      }
      v136.i64[0] = v6 & 0x3FC0;
      if (v136.i64[0] == 7552)
      {
        float v131 = (char *)v2;
        LODWORD(v50) = DWORD2(v148);
LABEL_79:
        float v130 = &v128;
        MEMORY[0x270FA5388](result);
        long long v55 = (unsigned int *)((char *)&v128 - v54);
        uint64_t v56 = 0;
        if (v136.i64[0] == 7552) {
          uint64_t v57 = ((v50 >> 19) & 3) + 1;
        }
        else {
          uint64_t v57 = (v53 + 1);
        }
        int v58 = v52 + 1;
        inserted = v131;
        uint64_t v135 = v57;
        do
        {
          unsigned int v59 = AddTempRegister(v3, (v147 >> 19) & 7, ((unint64_t)v147 >> 38) & 7, (DWORD2(v147) >> 21) & 3);
          int v60 = 0;
          int v61 = 0;
          v55[v56] = v59;
          do
          {
            long long v144 = v149;
            long long v145 = v150;
            long long v146 = v151;
            long long v142 = v147;
            long long v143 = v148;
            if ((v148 & 0x60000) != 0)
            {
              if (v148)
              {
                uint64_t v63 = (v60 + v148) & 0xFF000000;
                unint64_t v62 = v148 & 0xFFFFFFFF00F9FFFFLL;
              }
              else
              {
                unint64_t v62 = (unint64_t)(v61 + WORD3(v148)) << 48;
                uint64_t v63 = v148 & 0xFFFFFFF9FFFFLL;
              }
              *(void *)&long long v143 = v62 | v63;
            }
            unint64_t v64 = *((void *)&v143 + 1);
            unint64_t v65 = (v64 + (v56 << 48)) & 0xFFFF000000000000 | v64 & 0xFFFFFFF9FFFFLL;
            if (BYTE8(v143)) {
              unint64_t v65 = *((void *)&v143 + 1) & 0xFFFFFFFF00F9FFFFLL | ((v56 << 24) + DWORD2(v143)) & 0xFF000000;
            }
            if ((*((void *)&v143 + 1) & 0x60000) != 0) {
              unint64_t v64 = v65;
            }
            if (v136.i64[0] == 7552) {
              int v66 = v56;
            }
            else {
              int v66 = v61;
            }
            switch(v66)
            {
              case 0:
                uint64_t v67 = (v64 >> 9) & 3;
                break;
              case 1:
                uint64_t v67 = (v64 >> 11) & 3;
                break;
              case 2:
                uint64_t v67 = (v64 >> 13) & 3;
                break;
              case 3:
                uint64_t v67 = (v64 >> 15) & 3;
                break;
              default:
                uint64_t v67 = 0;
                break;
            }
            unint64_t v68 = v64 & 0xFFFFFFFFFFE601FFLL | (v67 << 15) | (v67 << 13) | (v67 << 11);
            uint64_t v69 = (*((void *)&v142 + 1) >> 2) & 0x180000;
            *((void *)&v143 + 1) = v68 | (v67 << 9) | v69;
            unint64_t v70 = 0xFFFFFFF3FFFFC03FLL;
            if (v60) {
              unint64_t v70 = 0xFFFFFFF3FFFFC038;
            }
            uint64_t v71 = 2176;
            if (v60) {
              uint64_t v71 = 4035;
            }
            unint64_t v72 = v142 & v70;
            uint64_t v73 = v55[v56];
            *(void *)&long long v142 = v72 | v71;
            *((void *)&v142 + 1) = *((void *)&v142 + 1) & 0xFFFEFFE78FFFLL | ((unint64_t)(unsigned __int16)v73 << 48) | 0x1000;
            if (v60) {
              *(void *)&long long v144 = v69 | *((void *)&v148 + 1) & 0xFFFFFFE0003ELL | (v73 << 48) | 0x1C840;
            }
            inserted = PPStreamInsertOperationAfterChunk(v137, (uint64_t)&v142, 0, (uint64_t)inserted);
            ++v61;
            v60 += 0x1000000;
          }
          while (v58 != v61);
          ++v56;
          uint64_t v74 = v135;
          uint64_t v3 = v137;
        }
        while (v56 != v135);
        uint64_t v75 = 0;
        do
        {
          long long v142 = v147;
          long long v143 = v148;
          unsigned int v76 = *v55++;
          long long v144 = v149;
          long long v145 = v150;
          long long v146 = v151;
          *(void *)&long long v142 = v147 & 0xFFFFFFF3FFFFC038 | 1;
          *((void *)&v142 + 1) = (v75 + *((void *)&v147 + 1)) & 0xFFFF000000000000 | *((void *)&v147 + 1) & 0xFFFFFFE7FFFFLL;
          *(void *)&long long v143 = v148 & 0xFFFFFFF8003ELL | ((unint64_t)v76 << 48) | 0x1C840;
          inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
          v75 += 0x1000000000000;
          --v74;
        }
        while (v74);
LABEL_112:
        uint64_t result = PPStreamRemoveOperation(v3, v131);
        goto LABEL_136;
      }
      uint64_t v50 = *((void *)&v148 + 1);
      uint64_t v51 = *((void *)&v148 + 1) & 0x60000;
      if ((v148 & 0x60000) != 0 && v51)
      {
        float v131 = (char *)v2;
        goto LABEL_79;
      }
      uint64_t v95 = v148 & 0x180000;
      if ((v148 & 0x180000) == 0 && v51 || (v148 & 0x60000) != 0 && (*((void *)&v148 + 1) & 0x180000) == 0)
      {
        int v96 = 0;
        int v97 = 0;
        int v98 = ((DWORD2(v147) >> 19) & 3) + 1;
        inserted = (char *)v2;
        do
        {
          long long v143 = v148;
          long long v144 = v149;
          long long v145 = v150;
          long long v146 = v151;
          *(void *)&long long v142 = v147 & 0xFFFFFFF3FFFFFFFFLL;
          *((void *)&v142 + 1) = *((void *)&v147 + 1) & 0xFFFFFFE7FFFFLL | ((unint64_t)(v97
                                                                                                 + HIWORD(*((void *)&v147 + 1))) << 48);
          if ((v148 & 0x60000) != 0)
          {
            if (v148) {
              unint64_t v99 = v148 & 0xFFFFFFFF00F9FFFFLL | (v96 + v148) & 0xFF000000;
            }
            else {
              unint64_t v99 = v148 & 0xFFFFFFF9FFFFLL | ((unint64_t)(v97 + WORD3(v148)) << 48);
            }
          }
          else
          {
            unint64_t v99 = v148 & 0xFFFFFFFFFFE607FFLL | *((void *)&v143 + 1) & 0x180000 | ((((unint64_t)v148 >> 9) & 3) << 15) | ((((unint64_t)v148 >> 9) & 3) << 13) | ((((unint64_t)v148 >> 9) & 3) << 11);
          }
          unint64_t v100 = *((void *)&v143 + 1) & 0xFFFFFFF9FFFFLL | ((unint64_t)(v97
                                                                               + HIWORD(*((void *)&v143 + 1))) << 48);
          if (BYTE8(v143)) {
            unint64_t v100 = *((void *)&v143 + 1) & 0xFFFFFFFF00F9FFFFLL | (v96 + DWORD2(v143)) & 0xFF000000;
          }
          if ((*((void *)&v143 + 1) & 0x60000) != 0) {
            unint64_t v101 = v100;
          }
          else {
            unint64_t v101 = *((void *)&v143 + 1) & 0xFFFFFFFFFFE607FFLL | v99 & 0x180000 | (((*((void *)&v143 + 1) >> 9) & 3) << 15) | (((*((void *)&v143 + 1) >> 9) & 3) << 13) | (((*((void *)&v143 + 1) >> 9) & 3) << 11);
          }
          *(void *)&long long v143 = v99;
          *((void *)&v143 + 1) = v101;
          inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
          ++v97;
          v96 += 0x1000000;
        }
        while (v98 != v97);
LABEL_64:
        uint64_t v42 = v3;
        uint64_t v43 = (char *)v2;
        goto LABEL_72;
      }
      unsigned int v102 = (v148 >> 17) & 3;
      if (v102)
      {
        uint64_t v103 = AddTempRegister(v3, (v6 >> 19) & 7, (v6 >> 38) & 7, (DWORD2(v147) >> 21) & 3);
        int v104 = 0;
        uint64_t v105 = v103 << 48;
        unint64_t v106 = v50 & 0xFFFFFFE6002ELL | ((unint64_t)(unsigned __int16)v103 << 48) | v95 | 0x1C840;
        inserted = (char *)v2;
        do
        {
          long long v144 = v149;
          long long v145 = v150;
          long long v146 = v151;
          long long v142 = v147;
          long long v143 = v148;
          unint64_t v107 = (unint64_t)(v104 + WORD3(v148)) << 48;
          if (v148) {
            uint64_t v108 = (v148 + (v104 << 24)) & 0xFF000000;
          }
          else {
            uint64_t v108 = v148 & 0xFFFFFFF9FFFFLL;
          }
          if (v148) {
            unint64_t v107 = v148 & 0xFFFFFFFF00F9FFFFLL;
          }
          *(void *)&long long v143 = v107 | v108;
          switch(v104)
          {
            case 0:
              uint64_t v109 = *((void *)&v143 + 1);
              uint64_t v110 = (*((void *)&v143 + 1) >> 9) & 3;
              break;
            case 1:
              uint64_t v109 = *((void *)&v143 + 1);
              uint64_t v110 = (*((void *)&v143 + 1) >> 11) & 3;
              break;
            case 2:
              uint64_t v109 = *((void *)&v143 + 1);
              uint64_t v110 = (*((void *)&v143 + 1) >> 13) & 3;
              break;
            case 3:
              uint64_t v109 = *((void *)&v143 + 1);
              uint64_t v110 = (*((void *)&v143 + 1) >> 15) & 3;
              break;
            default:
              uint64_t v110 = 0;
              uint64_t v109 = *((void *)&v143 + 1);
              break;
          }
          unint64_t v111 = v109 & 0xFFFFFFFFFFE601FFLL | (v110 << 15) | (v110 << 13) | (v110 << 11) | (v110 << 9) | v95;
          unint64_t v112 = 0xFFFFFFF3FFFFC03FLL;
          if (v104) {
            unint64_t v112 = 0xFFFFFFF3FFFFC038;
          }
          unint64_t v113 = v142 & v112;
          uint64_t v114 = 2176;
          if (v104) {
            uint64_t v114 = 4035;
          }
          *((void *)&v143 + 1) = v111;
          *(void *)&long long v142 = v113 | v114;
          if (v104 != v102)
          {
            uint64_t v115 = *((void *)&v142 + 1) & 0xFFFE80780FFFLL | v105;
            uint64_t v116 = v115 | 0x72001000;
            switch((DWORD2(v142) >> 21) & 3)
            {
              case 1u:
                goto LABEL_176;
              case 2u:
                goto LABEL_175;
              case 3u:
                uint64_t v116 = v115 | 0x72009000;
LABEL_175:
                v116 |= 0x10000uLL;
LABEL_176:
                v116 |= 0x20000uLL;
                break;
              default:
                break;
            }
            *((void *)&v142 + 1) = v116 | 0x40000;
          }
          if (v104) {
            *(void *)&long long v144 = v106;
          }
          inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)inserted);
          BOOL v31 = v104++ == v102;
        }
        while (!v31);
      }
      else
      {
        if (((DWORD2(v148) >> 17) & 3) == 0)
        {
          inserted = (char *)v2;
          goto LABEL_136;
        }
        v136.i64[0] = DWORD2(v148) >> 17;
        unint64_t v117 = *((void *)&v148 + 1);
        int v118 = 0;
        uint64_t v119 = 0;
        uint64_t v120 = AddTempRegister(v3, (v6 >> 19) & 7, (v6 >> 38) & 7, (DWORD2(v147) >> 21) & 3) << 48;
        uint64_t v121 = (v50 << 17) & 0x3000000000;
        uint64_t v122 = ((v117 >> 17) & 3) + 1;
        float v123 = (char *)v2;
        do
        {
          long long v144 = v149;
          long long v145 = v150;
          long long v146 = v151;
          long long v142 = v147;
          long long v143 = v148;
          uint64_t v124 = *((void *)&v148 + 1) & 0xFFFFFFF9FFFFLL;
          unint64_t v125 = *((void *)&v148 + 1) & 0xFFFFFFFF00F9FFFFLL;
          if (BYTE8(v148)) {
            uint64_t v124 = (v118 + DWORD2(v148)) & 0xFF000000;
          }
          else {
            unint64_t v125 = (unint64_t)(v119 + HIWORD(*((void *)&v148 + 1))) << 48;
          }
          unint64_t v126 = v125 | v124;
          uint64_t v127 = *((void *)&v147 + 1) & 0xFFFE80780FFFLL | v120;
          *((void *)&v143 + 1) = v126;
          *((void *)&v142 + 1) = v127 | 0x72001000;
          if (v119 <= 3) {
            *((void *)&v142 + 1) = v127 | qword_2393DBE68[v119];
          }
          *(void *)&long long v142 = v121 | 0x9C0 | v142 & 0xFFFFFFC3FFFFC03FLL;
          float v123 = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)v123);
          ++v119;
          v118 += 0x1000000;
        }
        while (v122 != v119);
        *((void *)&v142 + 1) = *((void *)&v147 + 1);
        *((void *)&v143 + 1) = *((void *)&v148 + 1);
        long long v144 = v149;
        long long v145 = v150;
        long long v146 = v151;
        *(void *)&long long v142 = v147 & 0xFFFFFFFFFFFFC038 | 1;
        *(void *)&long long v143 = v148 & v128 | ((v136.i8[0] & 3) << 19) | (unint64_t)v120 | 0x1C840;
        inserted = PPStreamInsertOperationAfterChunk(v3, (uint64_t)&v142, 0, (uint64_t)v123);
      }
      uint64_t result = PPStreamRemoveOperation(v3, (void *)v2);
LABEL_136:
      uint64_t v2 = *((void *)inserted + 1);
    }
    while (v2);
  }
  return result;
}

void SwitchTexOps(uint64_t **a1)
{
  uint64_t v2 = HashTableNew(0x10u, 0, 0);
  uint64_t v3 = *a1[7];
  if (v3)
  {
    int v4 = 0;
    do
    {
      if ((*(void *)(v3 + 24) & 0x400000001F00) == 0x400000000200)
      {
        HashTableAdd(v2, (*(_DWORD *)(v3 + 32) + 1), v3 + 24);
        ++v4;
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3);
    if (v4)
    {
      int NextIndex = PPStreamChunkListGetNextIndex(a1[4]);
      long long v71 = xmmword_2393DBDB0;
      DWORD2(v71) = NextIndex;
      PPStreamAddTempUsage((uint64_t)a1, &v71);
      inserted = (char *)*a1[13];
      if (inserted)
      {
        unint64_t v47 = (((unint64_t)WORD4(v71) << 48) | 0x1C880) - 64;
        unint64_t v48 = ((unint64_t)WORD4(v71) << 48) | 0x72041000;
        unsigned int v45 = v2;
        do
        {
          long long v7 = *(_OWORD *)(inserted + 40);
          long long v71 = *(_OWORD *)(inserted + 24);
          long long v72 = v7;
          long long v8 = *(_OWORD *)(inserted + 72);
          long long v73 = *(_OWORD *)(inserted + 56);
          long long v74 = v8;
          long long v75 = *(_OWORD *)(inserted + 88);
          unsigned int v9 = v71;
          *(void *)&long long v71 = v71 & 0xFFFFFFFFFFFFBFFFLL;
          int v10 = (v9 >> 6);
          BOOL v11 = (v10 - 66) > 0x21 || ((1 << (v10 - 66)) & 0x30000003FLL) == 0;
          if (!v11
            || ((unsigned int v12 = v10 - 130, v13 = v12 > 0x24, v14 = (1 << v12) & 0x1C00000003, !v13)
              ? (BOOL v15 = v14 == 0)
              : (BOOL v15 = 1),
                !v15))
          {
            int v16 = v9 & 7;
            uint64_t v17 = (char *)&v71 + 8 * (v16 - 2);
            unint64_t v20 = *((void *)v17 + 2);
            unsigned int v19 = v17 + 16;
            unint64_t v18 = v20;
            uint64_t v21 = (uint64_t)(int)v20 >> 24;
            BOOL v22 = (v20 & 0x1C1) == 0x80 && v21 == 0;
            if (!v22 || !HashTableGet(v2, HIWORD(v18) + 1))
            {
              uint64_t v49 = (v16 - 2);
              uint64_t v51 = v19;
              int v46 = inserted;
              int64x2_t v23 = (uint64_t *)malloc_type_malloc(8uLL, 0x7081ABB9uLL);
              if (!v23) {
LABEL_49:
              }
                abort();
              uint64_t v24 = v23;
              uint64_t v25 = *((void *)&v71 + (v16 - 1) + 2);
              v70[0] = 0;
              v70[1] = 0;
              HashSetIteratorSetup(*v2, v70);
              uint64_t v26 = HashSetIteratorNext((unsigned int *)v70);
              if (v26)
              {
                unsigned int v27 = 0;
                do
                {
                  unint64_t v28 = *(void **)(v26 + 8);
                  if ((((v25 >> 5) ^ (*v28 >> 52)) & 7) == 0
                    && (((*v28 >> 47) ^ v25) & 0x1F) == 0)
                  {
                    unint64_t v30 = (uint64_t *)malloc_type_realloc(v24, 8 * (v27 + 1), 0x2BDC8648uLL);
                    if (!v30) {
                      goto LABEL_49;
                    }
                    uint64_t v24 = v30;
                    v30[v27++] = (uint64_t)v28;
                  }
                  uint64_t v26 = HashSetIteratorNext((unsigned int *)v70);
                }
                while (v26);
                if (v27 == 1)
                {
                  uint64_t v32 = *v24;
                  long long v67 = v73;
                  long long v68 = v74;
                  long long v69 = v75;
                  long long v65 = v71;
                  long long v66 = v72;
                  unint64_t v33 = *((void *)&v66 + v49) & 0xFFFFFFFFFFFFFE3FLL | 0x80;
                  *((void *)&v66 + v49) = v33;
                  *((void *)&v66 + v49) = v33 & 0xFFFF00FFFEBELL | ((unint64_t)*(unsigned int *)(v32 + 8) << 48);
                  BOOL v31 = v46;
                  inserted = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)&v65, 0, (uint64_t)v46);
                }
                else if (v27)
                {
                  uint64_t v34 = 0;
                  inserted = 0;
                  int v35 = 0;
                  int v36 = DWORD1(v75);
                  int v37 = (unint64_t *)&v59[1] + v49;
                  uint64_t v50 = v27;
                  uint64_t v52 = *(void *)v51;
                  uint64_t v38 = (uint64_t)v46;
                  long long v39 = 0uLL;
                  do
                  {
                    uint64_t v40 = v24[v34];
                    long long v68 = v39;
                    long long v69 = v39;
                    long long v67 = v39;
                    DWORD1(v69) = v36;
                    *(void *)&long long v65 = 0x4100000C42;
                    *((void *)&v65 + 1) = v48;
                    *(void *)&long long v66 = v52;
                    *((void *)&v66 + 1) = 116864;
                    *((void *)&v66 + 1) = ((unint64_t)*(unsigned int *)(v40 + 8) << 48) | 0x1C880;
                    unint64_t v41 = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)&v65, 0, v38);
                    if (v35 && inserted) {
                      *((void *)v35 + 3) = *((void *)v35 + 3) & 0x3FFFFFFFFFFFLL | ((unint64_t)*((unsigned int *)v41 + 22) << 46);
                    }
                    uint64_t v64 = 0;
                    long long v62 = 0u;
                    long long v63 = 0u;
                    v60[1] = 0;
                    long long v61 = 0u;
                    HIDWORD(v63) = v36;
                    v60[0] = 0x4000001541;
                    v60[2] = v47;
                    int v35 = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)v60, 0, (uint64_t)v41);
                    _DWORD v59[2] = v73;
                    v59[3] = v74;
                    v59[4] = v75;
                    v59[0] = v71;
                    v59[1] = v72;
                    unint64_t v42 = *v37 & 0xFFFFFFFFFFFFFE3FLL | 0x80;
                    *int v37 = v42;
                    *int v37 = v42 & 0xFFFF00FFFEBELL | ((unint64_t)*(unsigned int *)(v40 + 8) << 48);
                    uint64_t v43 = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)v59, 0, (uint64_t)v35);
                    uint64_t v58 = 0;
                    long long v56 = 0u;
                    long long v57 = 0u;
                    long long v54 = 0u;
                    long long v55 = 0u;
                    HIDWORD(v57) = v36;
                    uint64_t v53 = 5696;
                    unsigned int v44 = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)&v53, 0, (uint64_t)v43);
                    long long v39 = 0uLL;
                    inserted = v44;
                    ++v34;
                    uint64_t v38 = (uint64_t)v44;
                  }
                  while (v50 != v34);
                  *((void *)v35 + 3) = *((void *)v35 + 3) & 0x3FFFFFFFFFFFLL | ((unint64_t)*(unsigned int *)(*((void *)v44 + 1) + 88) << 46);
                  uint64_t v2 = v45;
                  BOOL v31 = v46;
                }
                else
                {
                  BOOL v31 = v46;
                  inserted = v46;
                }
              }
              else
              {
                BOOL v31 = inserted;
              }
              PPStreamRemoveOperation((uint64_t)a1, v31);
              free(v24);
            }
          }
          inserted = (char *)*((void *)inserted + 1);
        }
        while (inserted);
      }
    }
  }
  HashTableFree(v2);
}

uint64_t GetRegisterIndicies(uint64_t result, unsigned int *a2, unsigned int *a3, int a4, unsigned int a5, int a6, int a7)
{
  *a2 = 0;
  *a3 = -1;
  if (a6)
  {
    if (a4 == 2)
    {
      for (uint64_t i = **(void **)(result + 72); i; uint64_t i = *(void *)(i + 8))
      {
        unint64_t v12 = *(void *)(i + 24);
        unsigned int v9 = WORD1(v12);
        unint64_t v13 = HIWORD(v12);
        if (v9 <= a5 && v13 >= a5) {
          goto LABEL_21;
        }
      }
    }
    else if (a4 == 1)
    {
      uint64_t i = **(void **)(result + 80);
      if (i)
      {
        while (1)
        {
          unint64_t v8 = *(void *)(i + 24);
          unsigned int v9 = WORD1(v8);
          unint64_t v10 = HIWORD(v8);
          if (v9 <= a5 && v10 >= a5) {
            break;
          }
          uint64_t i = *(void *)(i + 8);
          if (!i) {
            goto LABEL_17;
          }
        }
LABEL_21:
        *a2 = v9;
        a5 = *(unsigned __int16 *)(i + 30);
        goto LABEL_20;
      }
    }
  }
LABEL_17:
  if (!a7 || (*a2 = a5, *a3 = a7 + a5, a7 + a5 == -1))
  {
    *a2 = a5;
LABEL_20:
    *a3 = a5;
  }
  return result;
}

void *EmulationContext_PushRegisters(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t result = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
  if (!result) {
    abort();
  }
  *uint64_t result = v4;
  result[1] = a2;
  *a1 = (uint64_t)result;
  return result;
}

void *EmulationContext_PushRegistersCopy(uint64_t *a1)
{
  uint64_t v2 = *(void *)(*a1 + 8);
  uint64_t v3 = HashSetNew(*(_DWORD *)(v2 + 4), *(unint64_t (**)(unint64_t))(v2 + 16), *(uint64_t (**)(int, int))(v2 + 24));
  v10[0] = 0;
  v10[1] = 0;
  HashSetIteratorSetup(v2, v10);
  uint64_t v4 = HashSetIteratorNext((unsigned int *)v10);
  if (v4)
  {
    uint64_t v5 = v4;
    do
    {
      unint64_t v6 = malloc_type_malloc(0x28uLL, 0x7081ABB9uLL);
      if (!v6) {
        abort();
      }
      long long v7 = *(_OWORD *)v5;
      long long v8 = *(_OWORD *)(v5 + 16);
      v6[4] = *(void *)(v5 + 32);
      *(_OWORD *)unint64_t v6 = v7;
      *((_OWORD *)v6 + 1) = v8;
      HashSetAdd((uint64_t)v3, (uint64_t)v6);
      uint64_t v5 = HashSetIteratorNext((unsigned int *)v10);
    }
    while (v5);
  }
  return EmulationContext_PushRegisters(a1, (uint64_t)v3);
}

void EmulationContext_PopRegisters(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v2 = v1[1];
    *a1 = (void *)*v1;
    if (v2)
    {
      ClearRegisterState(v2);
      HashSetFree((void *)v1[1]);
    }
    free(v1);
  }
}

uint64_t ClearRegisterState(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  HashSetIteratorSetup(a1, v4);
  uint64_t result = HashSetIteratorNext((unsigned int *)v4);
  if (result)
  {
    uint64_t v3 = (void *)result;
    do
    {
      HashSetRemove(a1, (uint64_t)v3);
      free(v3);
      uint64_t result = HashSetIteratorNext((unsigned int *)v4);
      uint64_t v3 = (void *)result;
    }
    while (result);
  }
  return result;
}

void ClearDestedOpRegisters(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v4 = *(void *)(a3 + 32);
  if ((v4 & 0x78000) != 0)
  {
    uint64_t v16 = 0;
    GetRegisterIndicies(a1, (unsigned int *)&v16 + 1, (unsigned int *)&v16, (v4 >> 12) & 7, HIWORD(v4), BYTE4(v4) & 1, (v4 >> 19) & 3);
    int v8 = HIDWORD(v16);
    if (SHIDWORD(v16) <= (int)v16)
    {
      int v9 = v16 + 1;
      do
      {
        long long v14 = 0u;
        long long v15 = 0u;
        int v10 = (*(_DWORD *)(a3 + 32) >> 12) & 7;
        v13[0] = v8;
        v13[1] = v10;
        uint64_t v11 = HashSetGet(a2, (uint64_t)v13);
        if (v11)
        {
          unint64_t v12 = (void *)v11;
          if (a4)
          {
            HashSetRemove(a2, v11);
            free(v12);
          }
          else
          {
            *(_DWORD *)(v11 + 20) = 0;
          }
        }
        ++v8;
      }
      while (v9 != v8);
    }
  }
}

void glpPPShaderLinearizeStreamMgr(uint64_t **a1, __int16 a2)
{
}

void glpPPShaderLinearizeStreamMgrEx(uint64_t **a1, __int16 a2, _DWORD *a3)
{
  __int16 v4 = a2;
  if ((a2 & 0x600) != 0) {
    DecomposeMatrixOps((uint64_t)a1, a2 & 0x400);
  }
  __int16 v119 = v4;
  if ((v4 & 1) == 0) {
    goto LABEL_132;
  }
  float v123 = 0;
  uint64_t v6 = *a1[13];
  if (!v6) {
    goto LABEL_132;
  }
  uint64_t v115 = a3;
  int v7 = 0;
  uint64_t v8 = 0;
  do
  {
    unint64_t v9 = *(void *)(v6 + 24);
    if ((v9 & 0x4000) != 0)
    {
      int v7 = *(_DWORD *)(v6 + 88);
      uint64_t v8 = RecordFunctionCall(v7, &v123, v8, 1);
      unint64_t v9 = *(void *)(v6 + 24);
    }
    if ((v9 & 0x3FC7) == 0x1300) {
      uint64_t v8 = RecordFunctionCall(v9 >> 46, &v123, v8, 0);
    }
    uint64_t v6 = *(void *)(v6 + 8);
  }
  while (v6);
  uint64_t v10 = *a1[13];
  uint64_t v11 = (int *)v123;
  uint64_t v12 = v8;
  if (v10)
  {
    int v13 = 0;
    unsigned int v14 = -1;
    while (1)
    {
      int v15 = *(_DWORD *)(v10 + 88);
      if (v8) {
        break;
      }
LABEL_17:
      if ((v14 & 0x80000000) == 0) {
        goto LABEL_18;
      }
LABEL_19:
      uint64_t v10 = *(void *)(v10 + 8);
      int v13 = v15;
      if (!v10) {
        goto LABEL_26;
      }
    }
    uint64_t v16 = 0;
    uint64_t v17 = v11;
    while (1)
    {
      int v18 = *v17;
      v17 += 12;
      if (v18 == v15) {
        break;
      }
      if (v8 == ++v16) {
        goto LABEL_17;
      }
    }
    if ((v14 & 0x80000000) == 0) {
      v11[12 * v14 + 1] = v13;
    }
    unsigned int v14 = v16;
    if ((v16 & 0x80000000) != 0) {
      goto LABEL_19;
    }
LABEL_18:
    AddOpToJumpTable((void *)(v10 + 24), (uint64_t)&v11[12 * v14]);
    goto LABEL_19;
  }
  int v15 = 0;
  unsigned int v14 = -1;
LABEL_26:
  if (!v8)
  {
    a3 = v115;
    if (v11) {
      goto LABEL_131;
    }
    goto LABEL_132;
  }
  uint64_t v19 = 0;
  while (v11[v19] != v7)
  {
    v19 += 12;
    if (12 * v8 == v19) {
      goto LABEL_35;
    }
  }
  if ((v14 & 0x80000000) == 0) {
    v11[12 * v14 + 1] = v15;
  }
LABEL_35:
  if (v8 < 2)
  {
    LODWORD(v8) = 1;
    goto LABEL_128;
  }
  unint64_t v20 = *a1[13];
  if (!v20)
  {
LABEL_128:
    a3 = v115;
    goto LABEL_129;
  }
  do
  {
    uint64_t v21 = 0;
    BOOL v22 = v11;
    while (1)
    {
      int v23 = *v22;
      v22 += 12;
      if (v23 == *(_DWORD *)(v20 + 88)) {
        break;
      }
      if (v8 == ++v21)
      {
        LODWORD(v21) = -1;
        break;
      }
    }
    int v24 = v21;
    unint64_t v129 = v20;
    uint64_t v25 = (char *)&v11[12 * (int)v21];
    uint64_t v26 = (int *)(v25 + 4);
    if (*((_DWORD *)v25 + 8))
    {
      int v27 = *v26;
      int v28 = 1;
    }
    else
    {
      int v28 = RemoveConditionalReturns((uint64_t)a1, (char **)&v129, 0, (_DWORD *)v25 + 1);
      int v27 = *v26;
      int v29 = 1;
      do
      {
        if (*(_DWORD *)(v20 + 88) == v27) {
          break;
        }
        unint64_t v20 = *(void *)(v20 + 8);
        ++v29;
      }
      while (v20);
      unsigned int v30 = v11[12 * v24 + 10];
      if (v30 >= 2)
      {
        BOOL v32 = v29 <= 40;
        unsigned int v31 = v30 * (v29 - 1);
        BOOL v32 = !v32 || v31 > 0xC8;
        if (v32) {
          int v28 = 0;
        }
      }
    }
    v11[12 * v24 + 11] = v28;
    do
    {
      int v33 = *(_DWORD *)(v20 + 88);
      unint64_t v20 = *(void *)(v20 + 8);
    }
    while (v33 != v27);
  }
  while (v20);
  uint64_t v34 = *a1[13];
  if (!v34) {
    goto LABEL_213;
  }
  int v113 = v8;
  do
  {
    uint64_t v35 = 0;
    int v36 = *(_DWORD *)(v34 + 88);
    int v37 = v11;
    while (1)
    {
      int v38 = *v37;
      v37 += 12;
      if (v38 == v36) {
        break;
      }
      if (v12 == ++v35)
      {
        LODWORD(v35) = v12;
        break;
      }
    }
    if (v35 != v8) {
      unsigned int v14 = v35;
    }
    if ((*(void *)(v34 + 24) & 0x3FC7) == 0x1300)
    {
      uint64_t v39 = 0;
      uint64_t v40 = v11;
      do
      {
        int v41 = *v40;
        v40 += 12;
        if (v41 == *(void *)(v34 + 24) >> 46) {
          goto LABEL_68;
        }
        ++v39;
      }
      while (v12 != v39);
      LODWORD(v39) = v12;
LABEL_68:
      int v42 = v39;
      if (!v11[12 * (int)v39 + 11])
      {
        v11[12 * (int)v39 + 9] = 1;
        goto LABEL_103;
      }
      unsigned int v116 = v14;
      uint64_t v134 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      long long v130 = 0u;
      long long v131 = 0u;
      unint64_t v129 = 7296;
      int v118 = (void *)v34;
      uint64_t v8 = v34;
      inserted = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)&v129, 0, v34);
      uint64_t v43 = *(unsigned int *)(*(void *)(v34 + 8) + 88);
      uint64_t v44 = (uint64_t)a1[13];
      uint64_t v122 = &v11[12 * v42];
      do
      {
        uint64_t v45 = *(void *)v44;
        int v46 = *(_DWORD *)(*(void *)v44 + 88);
        uint64_t v44 = *(void *)v44 + 8;
      }
      while (*v122 != v46);
      int v47 = 0;
      int v48 = 0;
      unint64_t v117 = v11;
      uint64_t v49 = &v11[12 * v42 + 1];
      uint64_t v120 = v43 << 46;
      int v121 = 1;
      uint64_t v50 = 0xFFFFFFFFLL;
      while (1)
      {
        long long v127 = 0u;
        long long v128 = 0u;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v51 = *(_OWORD *)(v45 + 40);
        long long v52 = *(_OWORD *)(v45 + 56);
        long long v53 = *(_OWORD *)(v45 + 88);
        long long v127 = *(_OWORD *)(v45 + 72);
        long long v128 = v53;
        long long v125 = v51;
        long long v126 = v52;
        long long v124 = *(_OWORD *)(v45 + 24);
        v48 += OperationBlockBoundary(&v124);
        if ((v124 & 0x3FC0) != 0x1340 || v48 < 1) {
          break;
        }
        if (v128 == *v49) {
          goto LABEL_77;
        }
        int v121 = 0;
        BOOL v54 = 0;
        *(void *)&long long v124 = v124 & 0x3FFFFFFFC03FLL | v120 | 0x12C0;
LABEL_79:
        long long v55 = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)&v124, (const void *)(v45 + 104), v8);
        uint64_t v8 = (uint64_t)v55;
        unint64_t v56 = *((void *)v55 + 3);
        if (v56 >> 46)
        {
          uint64_t v57 = (uint64_t)a1[13];
          do
          {
            uint64_t v58 = *(void *)v57;
            int v59 = *(_DWORD *)(*(void *)v57 + 88);
            uint64_t v57 = *(void *)v57 + 8;
          }
          while (*v122 != v59);
          int v60 = v47;
          while (1)
          {
            int v61 = *(_DWORD *)(v58 + 88);
            if (v61 == v56 >> 46) {
              break;
            }
            uint64_t v58 = *(void *)(v58 + 8);
            ++v60;
            if (v61 == *v49) {
              goto LABEL_87;
            }
          }
          *((void *)v55 + 3) = v56 & 0x3FFFFFFFFFFFLL | ((unint64_t)(*((_DWORD *)v55 + 22) + v60) << 46);
        }
LABEL_87:
        if (v50 == -1) {
          uint64_t v50 = *((unsigned int *)v55 + 22);
        }
        int v62 = *(_DWORD *)(v45 + 88);
        uint64_t v45 = *(void *)(v45 + 8);
        --v47;
        if (v62 == *v49 || v54)
        {
          uint64_t v34 = *(void *)PPStreamRemoveOperation((uint64_t)a1, v118);
          unsigned int v14 = v116;
          if (v121) {
            PPStreamRemoveOperation((uint64_t)a1, inserted);
          }
          int v64 = *(_DWORD *)(v8 + 88);
          PPStreamChangeBranchTargets((uint64_t)a1, v36, v50);
          long long v65 = v117 + 1;
          uint64_t v66 = v12;
          LODWORD(v8) = v113;
          do
          {
            if (*(v65 - 1) == v36) {
              *(v65 - 1) = v50;
            }
            if (*v65 == v36) {
              *long long v65 = v64;
            }
            v65 += 12;
            --v66;
          }
          while (v66);
          uint64_t v11 = (int *)v123;
          goto LABEL_103;
        }
      }
      if ((v124 & 0x3FC0) != 0x1340)
      {
        BOOL v54 = 0;
        goto LABEL_79;
      }
LABEL_77:
      *(void *)&long long v124 = v124 & 0xFFFFFFFFFFFFC03FLL | 0x1BC0;
      BOOL v54 = v48 == 0;
      goto LABEL_79;
    }
LABEL_103:
    uint64_t v67 = *a1[13];
    long long v68 = &v11[12 * v14];
    ClearJumpTable((uint64_t)v68);
    int v69 = *v68;
    while (v69 != *(_DWORD *)(v67 + 88))
      uint64_t v67 = *(void *)(v67 + 8);
    unint64_t v70 = (char *)&v11[12 * v14];
    int v72 = *((_DWORD *)v70 + 1);
    long long v71 = v70 + 4;
    long long v73 = (void *)(v67 + 24);
    if (v72 != v69)
    {
      do
      {
        AddOpToJumpTable(v73, (uint64_t)v68);
        uint64_t v67 = *(void *)(v67 + 8);
        long long v73 = (void *)(v67 + 24);
      }
      while (*v71 != *(_DWORD *)(v67 + 88));
    }
    AddOpToJumpTable(v73, (uint64_t)v68);
    if (v34) {
      long long v74 = (uint64_t *)(v34 + 8);
    }
    else {
      long long v74 = a1[13];
    }
    uint64_t v34 = *v74;
  }
  while (*v74);
  uint64_t v75 = *a1[13];
  uint64_t v11 = (int *)v123;
  if (!v75)
  {
LABEL_213:
    __int16 v4 = v119;
    a3 = v115;
    if (v11) {
      goto LABEL_129;
    }
    goto LABEL_132;
  }
  BOOL v76 = 0;
  LODWORD(v77) = 0;
  unsigned int v78 = (int *)v123;
  uint64_t v79 = (char *)v123 + 36;
  do
  {
    uint64_t v80 = *(void *)(v75 + 8);
    if (v76)
    {
      int v81 = *(_DWORD *)(v75 + 88);
    }
    else
    {
      uint64_t v77 = 0;
      uint64_t v83 = v79;
      while (1)
      {
        if (!*(v83 - 1) && !*v83)
        {
          int v81 = *(v83 - 9);
          if (v81 == *(_DWORD *)(v75 + 88)) {
            break;
          }
        }
        ++v77;
        v83 += 12;
        if (v8 == v77)
        {
          BOOL v82 = 0;
          BOOL v76 = 0;
          LODWORD(v77) = v8;
          if ((*(void *)(v75 + 24) & 0x3FC0) == 0x1BC0) {
            goto LABEL_117;
          }
          goto LABEL_118;
        }
      }
    }
    BOOL v82 = v78[12 * (int)v77 + 1] != v81;
    PPStreamRemoveLabelsAtOperationIndex((uint64_t)a1, v81);
LABEL_117:
    PPStreamRemoveOperation((uint64_t)a1, (void *)v75);
    BOOL v76 = v82;
LABEL_118:
    uint64_t v75 = v80;
  }
  while (v80);
  __int16 v4 = v119;
  a3 = v115;
  uint64_t v11 = v78;
LABEL_129:
  uint64_t v84 = v8;
  uint64_t v85 = (uint64_t)v11;
  do
  {
    ClearJumpTable(v85);
    v85 += 48;
    --v84;
  }
  while (v84);
LABEL_131:
  free(v11);
LABEL_132:
  if ((v4 & 0x2000) != 0)
  {
    if ((v4 & 8) != 0) {
      LocalCopyPropagator((uint64_t)a1);
    }
    SwitchTexOps(a1);
  }
  if ((v4 & 0x102) != 0)
  {
    DetectConstantLoopsSimple(a1);
    if (a3) {
      uint64_t v86 = a3;
    }
    else {
      uint64_t v86 = 0;
    }
    UnrollConstantLoopsSimple((uint64_t)a1, v86);
  }
  if ((v4 & 4) != 0)
  {
    PPStreamPackIndices(a1);
    FlattenIfs((uint64_t)a1);
  }
  if ((v4 & 0x106) != 0)
  {
    for (uint64_t i = *a1[8]; i; uint64_t i = *(void *)(i + 8))
    {
      unint64_t v88 = (void *)*a1[13];
      if (v88)
      {
        int v89 = 0;
        uint64_t v90 = *(unsigned int *)(i + 32);
        while (2)
        {
          while (1)
          {
            uint64_t v91 = v88[3];
            uint64_t v92 = v91 & 7;
            if ((v91 & 7) != 0) {
              break;
            }
LABEL_167:
            unint64_t v88 = (void *)v88[1];
            if (!v88)
            {
              if (v89)
              {
                long long v124 = 0uLL;
                DWORD2(v124) = PPStreamChunkListGetNextIndex(a1[4]);
                LOBYTE(v124) = *(void *)(i + 24);
                PPStreamAddTempUsage((uint64_t)a1, &v124);
                unint64_t v100 = (void *)*a1[13];
                if (v100)
                {
                  do
                  {
                    unint64_t v101 = v100[4];
                    if ((v101 & 0x7000) == 0x3000 && v90 == HIWORD(v101)) {
                      v100[4] = v101 & 0xFFFFFFFF8FFFLL | ((unint64_t)DWORD2(v124) << 48) | 0x1000;
                    }
                    uint64_t v103 = v100[3] & 7;
                    if (v103)
                    {
                      int v104 = v100 + 5;
                      do
                      {
                        if ((*v104 & 0x1C0) == 0xC0 && v90 == HIWORD(*v104))
                        {
                          unint64_t v106 = *v104 & 0xFFFFFFFFFFFFFE3FLL | 0x40;
                          *int v104 = v106;
                          *int v104 = v106 & 0xFFFFFFFFFFFFLL | ((unint64_t)DWORD2(v124) << 48);
                        }
                        ++v104;
                        --v103;
                      }
                      while (v103);
                    }
                    unint64_t v100 = (void *)v100[1];
                  }
                  while (v100);
                  uint64_t v107 = *a1[13];
                  if (v107)
                  {
                    uint64_t v108 = v90 << 48;
                    do
                    {
                      if ((*(void *)(v107 + 24) & 0x3FC0) == 0x1340)
                      {
                        uint64_t v134 = 0;
                        long long v132 = 0u;
                        long long v133 = 0u;
                        long long v131 = 0u;
                        HIDWORD(v133) = *(_DWORD *)(v107 + 92);
                        unint64_t v109 = (v124 << 15);
                        unint64_t v110 = ((unint64_t)(v124 >> 6) << 21) | 0x72000000;
                        switch((v109 >> 21) & 3)
                        {
                          case 1uLL:
                            goto LABEL_192;
                          case 2uLL:
                            goto LABEL_191;
                          case 3uLL:
                            unint64_t v110 = v109 & 0x600000 | 0x72008000;
LABEL_191:
                            v110 |= 0x10000uLL;
LABEL_192:
                            v110 |= 0x20000uLL;
                            break;
                          default:
                            break;
                        }
                        *(void *)&long long v130 = v110 & 0xFFFFFFFB8FFFLL | v108 | 0x43000;
                        *((void *)&v130 + 1) = (v124 << 13) & 0x180000 | ((unint64_t)DWORD2(v124) << 48) | 0x1C840;
                        unint64_t v129 = ((void)v124 << 30) & 0x3000000000 | ((((unint64_t)v124 >> 3) & 7) << 38) | ((unint64_t)(v124 & 7) << 19) | 0x100000001;
                        unint64_t v111 = PPStreamInsertOperationAfterChunk((uint64_t)a1, (uint64_t)&v129, 0, *(void *)v107);
                        PPStreamChangeBranchTargets((uint64_t)a1, *(_DWORD *)(v107 + 88), *((unsigned int *)v111 + 22));
                      }
                      uint64_t v107 = *(void *)(v107 + 8);
                    }
                    while (v107);
                  }
                }
              }
              goto LABEL_195;
            }
          }
          uint64_t v93 = v91 & 0x3FC0;
          unsigned int v94 = v88 + 5;
          do
          {
            unint64_t v95 = *v94++;
            unint64_t v96 = HIWORD(v95);
            if ((v95 & 0x1C0) == 0xC0 && v90 == v96)
            {
LABEL_166:
              int v89 = 1;
              goto LABEL_167;
            }
            if (v93 == 7040)
            {
              if (v90 == HIWORD(v88[4]) && (v88[4] & 0x7000) == 12288 || v89 != 0) {
                goto LABEL_166;
              }
            }
            else if (v89)
            {
              goto LABEL_166;
            }
            --v92;
          }
          while (v92);
          int v89 = 0;
          unint64_t v88 = (void *)v88[1];
          if (v88) {
            continue;
          }
          break;
        }
      }
LABEL_195:
      ;
    }
  }
  if ((v119 & 0x80) != 0) {
    ConstantPropagateFold((uint64_t)a1);
  }
  if ((v119 & 8) != 0) {
    LocalCopyPropagator((uint64_t)a1);
  }
  if ((v119 & 0x4060) != 0)
  {
    PPStreamPackIndices(a1);
    unint64_t v112 = ProgramNew((uint64_t)a1);
    Registerify(v112);
    Blockify((uint64_t)v112);
    BuildGenKill((uint64_t)v112);
    BuildLiveOut((uint64_t)v112);
    if ((v119 & 0x40) != 0) {
      goto LABEL_202;
    }
  }
  else
  {
    unint64_t v112 = 0;
    if ((v119 & 0x40) != 0) {
LABEL_202:
    }
      DeadCodeEliminationSimple((uint64_t)v112);
  }
  if ((v119 & 0x4000) == 0)
  {
    if ((v119 & 0x20) == 0) {
      goto LABEL_205;
    }
LABEL_209:
    BuildInterferenceSets((uint64_t)v112);
    RegistersMerge((uint64_t)v112);
    if ((v119 & 0x4060) == 0) {
      goto LABEL_207;
    }
LABEL_206:
    RegistersCleanup(v112);
    ProgramFree(v112);
    goto LABEL_207;
  }
  BackCopyPropagationSimple((uint64_t)v112);
  if ((v119 & 0x20) != 0) {
    goto LABEL_209;
  }
LABEL_205:
  if ((v119 & 0x4060) != 0) {
    goto LABEL_206;
  }
LABEL_207:
  PPStreamPackIndices(a1);
}

void LocalCopyPropagator(uint64_t a1)
{
  uint64_t v2 = **(void ***)(a1 + 104);
  uint64_t v3 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
  if (!v3) {
LABEL_157:
  }
    abort();
  uint64_t v4 = (uint64_t)v3;
  v3[2] = 0;
  *(void *)uint64_t v3 = 0;
  if (v2)
  {
    uint64_t v107 = a1;
    while (1)
    {
      uint64_t v6 = v2 + 3;
      uint64_t v5 = v2[3];
      int v7 = (v5 >> 6);
      BOOL v8 = (v7 - 75) > 0x3D || ((1 << (v7 - 75)) & 0x300043838001FE07) == 0;
      if (!v8
        || ((v9 = v7 - 140, v10 = v9 > 0x1E, int v11 = (1 << v9) & 0x4000000F, !v10) ? (v12 = v11 == 0) : (v12 = 1), !v12))
      {
        uint64_t v13 = v107;
        if (!*(_DWORD *)(v4 + 8)) {
          goto LABEL_21;
        }
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        while (1)
        {
          uint64_t v16 = *(void *)v4;
          uint64_t v17 = *(void *)v4 + v14;
          if (*(_DWORD *)(v17 + 12) != 2) {
            goto LABEL_18;
          }
          if ((*(void *)(PPStreamChunkListChunkAtIndex(*(uint64_t **)(v107 + 56), *(_DWORD *)(v17 + 16)) + 24) & 0x400000001F00) != 0x400000000200) {
            break;
          }
LABEL_19:
          ++v15;
          v14 += 72;
          if (v15 >= *(unsigned int *)(v4 + 8))
          {
            uint64_t v5 = *v6;
            goto LABEL_21;
          }
        }
        uint64_t v16 = *(void *)v4;
LABEL_18:
        *(_DWORD *)(v16 + v14) = 0;
        goto LABEL_19;
      }
      uint64_t v13 = v107;
LABEL_21:
      uint64_t v18 = (v5 & 7) + ((__int16)v5 >> 15);
      if ((int)v18 >= 1)
      {
        for (uint64_t i = 0; i != v18; ++i)
        {
          unint64_t v20 = *(unsigned int *)(v4 + 8);
          if (v20)
          {
            uint64_t v21 = &v6[i];
            unint64_t v24 = v21[2];
            BOOL v22 = (unint64_t *)(v21 + 2);
            unint64_t v23 = v24;
            unsigned int v25 = (v24 >> 6) & 7;
            unint64_t v26 = HIWORD(v24);
            unsigned int v27 = (v24 >> 17) & 3;
            uint64_t v28 = (v24 >> 19) & 3;
            uint64_t v29 = 4 * ((v24 >> 15) & 3) + 40;
            uint64_t v30 = 4 * ((v24 >> 13) & 3) + 40;
            uint64_t v31 = 4 * ((v24 >> 11) & 3) + 40;
            uint64_t v32 = *(void *)v4;
            uint64_t v33 = 4 * ((v24 >> 9) & 3) + 40;
            unint64_t v34 = 0xFFFFFFFF00000000;
            unint64_t v35 = 1;
            int v36 = *(int **)v4;
            do
            {
              int v37 = *v36;
              if (*v36)
              {
                if (v36[1] == v25
                  && v36[2] == v26
                  && (v36[15] == v27 ? (BOOL v38 = (v23 & 1) == 0) : (BOOL v38 = 0), v38))
                {
                  switch(v28)
                  {
                    case 1:
                      goto LABEL_39;
                    case 2:
                      goto LABEL_38;
                    case 3:
                      if (*(int *)((char *)v36 + v29) != 1) {
                        goto LABEL_32;
                      }
LABEL_38:
                      if (*(int *)((char *)v36 + v30) != 1) {
                        goto LABEL_32;
                      }
LABEL_39:
                      if (*(int *)((char *)v36 + v31) != 1) {
                        goto LABEL_32;
                      }
LABEL_40:
                      int v37 = *(int *)((char *)v36 + v33) == 1;
                      break;
                    default:
                      goto LABEL_40;
                  }
                }
                else
                {
LABEL_32:
                  int v37 = 0;
                }
              }
              v34 += 0x100000000;
              if (v35 >= v20) {
                break;
              }
              v36 += 18;
              ++v35;
            }
            while (!v37);
            if (v37)
            {
              uint64_t v39 = (_DWORD *)(v32 + 72 * SHIDWORD(v34));
              BOOL v8 = (v23 & 0x10) == 0;
              unint64_t v40 = v23 & 0xFFFFFFFFFFFFFE3FLL | ((unint64_t)(v39[3] & 7) << 6);
              *BOOL v22 = v40;
              unint64_t v41 = v40 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v39[4] << 48);
              *BOOL v22 = v41;
              int v42 = 16 * v39[14];
              char v43 = 16 - v42;
              if (v8) {
                char v43 = v42;
              }
              unint64_t v44 = v41 & 0xFFFFFFFFFFFFFFEFLL | v43 & 0x10;
              *BOOL v22 = v44;
              switch((v44 >> 19) & 3)
              {
                case 1u:
                  goto LABEL_57;
                case 2u:
                  goto LABEL_51;
                case 3u:
                  switch((v44 >> 15) & 3)
                  {
                    case 1u:
                      uint64_t v45 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 28);
                      break;
                    case 2u:
                      uint64_t v45 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 32);
                      break;
                    case 3u:
                      uint64_t v45 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 36);
                      break;
                    default:
                      uint64_t v45 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 24);
                      break;
                  }
                  unint64_t v44 = v44 & 0xFFFFFFFFFFFE7FFFLL | ((*v45 & 3) << 15);
                  *BOOL v22 = v44;
LABEL_51:
                  switch((v44 >> 13) & 3)
                  {
                    case 1u:
                      int v46 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 28);
                      break;
                    case 2u:
                      int v46 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 32);
                      break;
                    case 3u:
                      int v46 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 36);
                      break;
                    default:
                      int v46 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 24);
                      break;
                  }
                  unint64_t v44 = v44 & 0xFFFFFFFFFFFF9FFFLL | ((*v46 & 3) << 13);
                  *BOOL v22 = v44;
LABEL_57:
                  switch((v44 >> 11) & 3)
                  {
                    case 1u:
                      int v47 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 28);
                      break;
                    case 2u:
                      int v47 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 32);
                      break;
                    case 3u:
                      int v47 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 36);
                      break;
                    default:
                      int v47 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 24);
                      break;
                  }
                  unint64_t v44 = v44 & 0xFFFFFFFFFFFFE7FFLL | ((*v47 & 3) << 11);
                  *BOOL v22 = v44;
                  break;
                default:
                  break;
              }
              switch((v44 >> 9) & 3)
              {
                case 1u:
                  int v48 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 28);
                  break;
                case 2u:
                  int v48 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 32);
                  break;
                case 3u:
                  int v48 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 36);
                  break;
                default:
                  int v48 = (_DWORD *)(v32 + 72 * SHIDWORD(v34) + 24);
                  break;
              }
              *BOOL v22 = v44 & 0xFFFFFFFFFFFFF9FFLL | ((*v48 & 3) << 9);
            }
          }
        }
      }
      unint64_t v49 = v2[4];
      if ((v49 & 0x180000) == 0x80000)
      {
        CheckRemoveAvailableCopyTable(v49, 0, 1, (uint64_t *)v4, v13);
        int v50 = 2;
      }
      else
      {
        int v50 = 1;
      }
      for (int j = 0; j != v50; CheckRemoveAvailableCopyTable(v2[4], j++, 0, (uint64_t *)v4, v13))
        ;
      if ((*v6 & 0x3FC0) == 0)
      {
        unint64_t v52 = v2[4];
        if ((v52 & 0x100000000) == 0)
        {
          unint64_t v53 = v2[5];
          if ((v53 & 1) == 0)
          {
            int v54 = ((v53 >> 6) ^ (v52 >> 12)) & 7;
            unint64_t v55 = HIWORD(v52);
            unint64_t v56 = HIWORD(v53);
            if (v54 || v55 != v56) {
              break;
            }
          }
        }
      }
LABEL_149:
      uint64_t v2 = (void *)v2[1];
      if (!v2)
      {
        if (*(void *)v4) {
          free(*(void **)v4);
        }
        goto LABEL_154;
      }
    }
    int v58 = 0;
    uint64_t v104 = ((unint64_t)*v6 >> 34) & 3;
    uint64_t v105 = v2;
    while (1)
    {
      uint64_t v59 = 0;
      unsigned int v60 = 0;
      unint64_t v62 = v2[3];
      unint64_t v61 = v2[4];
      unint64_t v63 = v2[5];
      unsigned int v64 = (v63 >> 6) & 7;
      *(_DWORD *)&v110[44] = 0;
      memset(&v110[8], 0, 32);
      uint64_t v65 = (v62 >> 36) & 3;
      LODWORD(v109) = 1;
      DWORD1(v109) = (v61 >> 12) & 7;
      unsigned int v66 = v58 + HIWORD(v61);
      *((void *)&v109 + 1) = __PAIR64__(v64, v66);
      int v108 = v58;
      unsigned int v67 = v58 + HIWORD(v63);
      *(_DWORD *)&v110[40] = (v63 >> 4) & 1;
      *(_DWORD *)unint64_t v110 = v67;
      *(_DWORD *)&v110[4] = (v62 >> 36) & 3;
      do
      {
        if (v60 <= v65)
        {
          char v69 = v61 >> 18;
          char v70 = v61 >> 23;
          switch((int)v59)
          {
            case 0:
              break;
            case 1:
              char v69 = v61 >> 17;
              char v70 = v61 >> 25;
              break;
            case 2:
              char v69 = BYTE2(v61);
              char v70 = v61 >> 27;
              break;
            case 3:
              char v69 = v61 >> 15;
              char v70 = v61 >> 29;
              break;
            default:
              goto LABEL_85;
          }
          *(_DWORD *)&v110[4 * v59 + 24] = v69 & 1;
          v60 += v69 & 1;
          char v68 = v63 >> 9;
          switch(v70 & 3)
          {
            case 1:
              char v68 = v63 >> 11;
              break;
            case 2:
              char v68 = v63 >> 13;
              break;
            case 3:
              char v68 = v63 >> 15;
              break;
            default:
              break;
          }
        }
        else
        {
LABEL_85:
          *(_DWORD *)&v110[4 * v59 + 24] = 0;
          char v68 = v63 >> 9;
        }
        *(_DWORD *)&v110[4 * v59++ + 8] = v68 & 3;
      }
      while (v59 != 4);
      LODWORD(v111) = GetStreamArray((v61 >> 12) & 7, v66, v107);
      Streamuint64_t Array = GetStreamArray(v64, v67, v107);
      HIDWORD(v111) = StreamArray;
      if (!v108 && (v62 & 0xC00000000) != 0)
      {
        *(_DWORD *)&v110[44] = 1;
        MatchingAvailableCopy = FindMatchingAvailableCopy(&v109, v4);
        if (!MatchingAvailableCopy)
        {
          int v98 = *(_DWORD *)(v4 + 8);
          unint64_t v99 = *(char **)v4;
          if ((v98 & 7) == 0)
          {
            unint64_t v100 = (char *)malloc_type_realloc(v99, 72 * (v98 + 8), 0x2BDC8648uLL);
            if (!v100) {
              goto LABEL_157;
            }
            *(void *)uint64_t v4 = v100;
            bzero(&v100[72 * *(unsigned int *)(v4 + 8)], 0x240uLL);
            unint64_t v99 = *(char **)v4;
            int v98 = *(_DWORD *)(v4 + 8);
          }
          unint64_t v101 = &v99[72 * v98];
          long long v102 = *(_OWORD *)&v110[32];
          *((_OWORD *)v101 + 2) = *(_OWORD *)&v110[16];
          *((_OWORD *)v101 + 3) = v102;
          *((void *)v101 + 8) = v111;
          long long v103 = *(_OWORD *)v110;
          *(_OWORD *)unint64_t v101 = v109;
          *((_OWORD *)v101 + 1) = v103;
          unsigned int v75 = *(_DWORD *)(v4 + 8) + 1;
          *(_DWORD *)(v4 + 8) = v75;
          goto LABEL_106;
        }
        uint64_t v73 = 0;
        long long v74 = MatchingAvailableCopy + 10;
        do
        {
          if (*(_DWORD *)&v110[v73 * 4 + 24] == 1)
          {
            if (!v74[v73])
            {
              ++MatchingAvailableCopy[5];
              v74[v73] = 1;
            }
            v74[v73 - 4] = *(_DWORD *)&v110[v73 * 4 + 8];
          }
          ++v73;
        }
        while (v73 != 4);
      }
      unsigned int v75 = *(_DWORD *)(v4 + 8);
LABEL_106:
      *(_DWORD *)&v110[44] = 0;
      unsigned int v106 = v75;
      if (v75)
      {
        uint64_t v76 = *(void *)v4;
        uint64_t v77 = v75;
        while (1)
        {
          uint64_t v78 = 0;
          while (1)
          {
            if (*(_DWORD *)(v76 + 72 * v78)
              && *(_DWORD *)(v76 + 72 * v78 + 4) == v64
              && *(_DWORD *)(v76 + 72 * v78 + 8) == v67)
            {
              unint64_t v79 = 0;
              unsigned int v80 = 0;
              do
              {
                if (v80 <= v65 && (int v81 = &v110[4 * v79 - 16], *((_DWORD *)v81 + 10)))
                {
                  ++v80;
                  BOOL v82 = *(_DWORD *)(v76 + 72 * v78 + 4 * *((unsigned int *)v81 + 6) + 40) == 1;
                }
                else
                {
                  BOOL v82 = 1;
                }
                if (v79 > 2) {
                  break;
                }
                ++v79;
              }
              while (v82);
              if (v82) {
                break;
              }
            }
            if (++v78 == v77) {
              goto LABEL_131;
            }
          }
          uint64_t v83 = 0;
          unsigned int v84 = 0;
          uint64_t v85 = (_DWORD *)(v76 + 72 * v78);
          unsigned int v64 = v85[3];
          unsigned int v67 = v85[4];
          int v86 = v85[14];
          if (*(_DWORD *)&v110[40]) {
            int v86 = 1 - v86;
          }
          *(_DWORD *)&v110[40] = v86;
          do
          {
            if (v84 <= v65 && (unint64_t v87 = &v110[4 * v83 - 16], *((_DWORD *)v87 + 10)))
            {
              ++v84;
              *((_DWORD *)v87 + 6) = *(_DWORD *)(v76 + 72 * v78 + 4 * *((unsigned int *)v87 + 6) + 24);
            }
            else
            {
              *(_DWORD *)&v110[4 * v83 + 8] = v83;
            }
            ++v83;
          }
          while (v83 != 4);
          HIDWORD(v111) = GetStreamArray(v64, v67, v107);
        }
      }
LABEL_131:
      HIDWORD(v109) = v64;
      *(_DWORD *)unint64_t v110 = v67;
      unint64_t v88 = FindMatchingAvailableCopy(&v109, v4);
      uint64_t v2 = v105;
      if (v88)
      {
        uint64_t v89 = 0;
        uint64_t v90 = v88 + 10;
        int v91 = v108;
        do
        {
          if (*(_DWORD *)&v110[v89 * 4 + 24] == 1)
          {
            if (!v90[v89])
            {
              ++v88[5];
              v90[v89] = 1;
            }
            v90[v89 - 4] = *(_DWORD *)&v110[v89 * 4 + 8];
          }
          ++v89;
        }
        while (v89 != 4);
      }
      else
      {
        uint64_t v92 = *(char **)v4;
        unsigned int v93 = v106;
        int v91 = v108;
        if ((v106 & 7) == 0)
        {
          unsigned int v94 = (char *)malloc_type_realloc(v92, 72 * (v106 + 8), 0x2BDC8648uLL);
          if (!v94) {
            goto LABEL_157;
          }
          *(void *)uint64_t v4 = v94;
          bzero(&v94[72 * *(unsigned int *)(v4 + 8)], 0x240uLL);
          uint64_t v92 = *(char **)v4;
          unsigned int v93 = *(_DWORD *)(v4 + 8);
        }
        unint64_t v95 = &v92[72 * v93];
        long long v96 = *(_OWORD *)&v110[32];
        *((_OWORD *)v95 + 2) = *(_OWORD *)&v110[16];
        *((_OWORD *)v95 + 3) = v96;
        *((void *)v95 + 8) = v111;
        long long v97 = *(_OWORD *)v110;
        *(_OWORD *)unint64_t v95 = v109;
        *((_OWORD *)v95 + 1) = v97;
        ++*(_DWORD *)(v4 + 8);
      }
      int v58 = v91 + 1;
      if (v91 == v104) {
        goto LABEL_149;
      }
    }
  }
LABEL_154:

  free((void *)v4);
}

unsigned __int16 *glpPPShaderLinearize(unsigned int *a1, __int16 a2)
{
  return glpPPShaderLinearizeEx(a1, a2, 0);
}

unsigned __int16 *glpPPShaderLinearizeEx(unsigned int *a1, __int16 a2, _DWORD *a3)
{
  __int16 v5 = a2 & 0x67EF;
  if ((a2 & 0x67EF) != 0)
  {
    int v12 = 0;
    int v7 = (uint64_t **)PPStreamCreate();
    PPStreamAttachStream((uint64_t)v7, (uint64_t)a1);
    glpPPShaderLinearizeStreamMgrEx(v7, v5, a3);
    Stream = PPStreamGetStream((uint64_t)v7, &v12);
    PPStreamFree((_DWORD **)v7);
    if ((a2 & 0x800) == 0) {
      return Stream;
    }
    goto LABEL_7;
  }
  if ((a2 & 0x1800) == 0)
  {
    Stream = 0;
    if ((a2 & 0x800) == 0) {
      return Stream;
    }
    goto LABEL_7;
  }
  size_t v9 = 8 * a1[6];
  BOOL v10 = (unsigned __int16 *)malloc_type_malloc(v9, 0x7081ABB9uLL);
  if (!v10) {
    abort();
  }
  Stream = v10;
  memcpy(v10, a1, v9);
  if ((a2 & 0x800) != 0) {
LABEL_7:
  }
    PPStreamTokenConvertParamBindings((unint64_t)Stream);
  return Stream;
}

void glpFreePPShaderLinearize(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t RecordFunctionCall(int a1, void *a2, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  if (a3)
  {
    uint64_t v8 = 0;
    size_t v9 = (_DWORD *)(*a2 + 40);
    while (*(v9 - 10) != a1)
    {
      ++v8;
      v9 += 12;
      if (a3 == v8) {
        goto LABEL_9;
      }
    }
    ++*v9;
  }
  else
  {
    LODWORD(v8) = 0;
  }
  if (v8 == a3)
  {
LABEL_9:
    BOOL v10 = (char *)*a2;
    if ((a3 & 0x7F) != 0)
    {
      int v11 = a3;
    }
    else
    {
      int v12 = (char *)malloc_type_realloc(v10, 48 * (a3 + 128), 0x2BDC8648uLL);
      if (!v12) {
        abort();
      }
      *a2 = v12;
      uint64_t v13 = &v12[48 * v5];
      uint64_t v14 = -6144;
      int v11 = v5;
      do
      {
        unint64_t v15 = &v13[v14];
        *((void *)v15 + 768) = -1;
        uint64_t v16 = &v13[v14 + 6152];
        *((void *)v15 + 773) = 0;
        *(_OWORD *)uint64_t v16 = 0uLL;
        *((_OWORD *)v16 + 1) = 0uLL;
        v14 += 48;
      }
      while (v14);
      BOOL v10 = (char *)*a2;
    }
    uint64_t v17 = &v10[48 * v11];
    *(_DWORD *)uint64_t v17 = a1;
    *((_DWORD *)v17 + 8) = a4;
    *((_DWORD *)v17 + 10) = 1;
    return (v5 + 1);
  }
  return v5;
}

void *AddOpToJumpTable(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  ++*(_DWORD *)(a2 + 8);
  int v4 = (*result >> 6);
  uint64_t v5 = (v4 - 75);
  if (v5 > 0x21) {
    goto LABEL_11;
  }
  if (((1 << (v4 - 75)) & 0x38001BE01) == 0)
  {
    if (v5 == 1)
    {
      if ((*result & 7) == 1) {
        return result;
      }
      goto LABEL_3;
    }
LABEL_11:
    if (v4 != 140) {
      return result;
    }
  }
LABEL_3:
  unsigned int v6 = *(_DWORD *)(a2 + 12);
  if ((v6 & 0x7F) == 0)
  {
    int v7 = (char *)malloc_type_realloc(*(void **)(a2 + 16), 4 * (v6 + 128), 0x2BDC8648uLL);
    if (!v7) {
      goto LABEL_13;
    }
    *(void *)(a2 + 16) = v7;
    uint64_t v8 = &v7[4 * *(unsigned int *)(a2 + 12)];
    *((_OWORD *)v8 + 30) = 0u;
    *((_OWORD *)v8 + 31) = 0u;
    *((_OWORD *)v8 + 28) = 0u;
    *((_OWORD *)v8 + 29) = 0u;
    *((_OWORD *)v8 + 26) = 0u;
    *((_OWORD *)v8 + 27) = 0u;
    *((_OWORD *)v8 + 24) = 0u;
    *((_OWORD *)v8 + 25) = 0u;
    *((_OWORD *)v8 + 22) = 0u;
    *((_OWORD *)v8 + 23) = 0u;
    *((_OWORD *)v8 + 20) = 0u;
    *((_OWORD *)v8 + 21) = 0u;
    *((_OWORD *)v8 + 18) = 0u;
    *((_OWORD *)v8 + 19) = 0u;
    *((_OWORD *)v8 + 16) = 0u;
    *((_OWORD *)v8 + 17) = 0u;
    *((_OWORD *)v8 + 14) = 0u;
    *((_OWORD *)v8 + 15) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 13) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    uint64_t result = malloc_type_realloc(*(void **)(a2 + 24), 4 * (*(_DWORD *)(a2 + 12) + 128), 0x2BDC8648uLL);
    if (!result) {
LABEL_13:
    }
      abort();
    *(void *)(a2 + 24) = result;
    size_t v9 = (_OWORD *)((char *)result + 4 * *(unsigned int *)(a2 + 12));
    v9[30] = 0u;
    v9[31] = 0u;
    v9[28] = 0u;
    v9[29] = 0u;
    v9[26] = 0u;
    v9[27] = 0u;
    v9[24] = 0u;
    v9[25] = 0u;
    v9[22] = 0u;
    v9[23] = 0u;
    v9[20] = 0u;
    v9[21] = 0u;
    v9[18] = 0u;
    v9[19] = 0u;
    v9[16] = 0u;
    v9[17] = 0u;
    v9[14] = 0u;
    v9[15] = 0u;
    v9[12] = 0u;
    v9[13] = 0u;
    v9[10] = 0u;
    v9[11] = 0u;
    v9[8] = 0u;
    v9[9] = 0u;
    v9[6] = 0u;
    v9[7] = 0u;
    v9[4] = 0u;
    v9[5] = 0u;
    v9[2] = 0u;
    v9[3] = 0u;
    *size_t v9 = 0u;
    v9[1] = 0u;
    unsigned int v6 = *(_DWORD *)(a2 + 12);
  }
  uint64_t v10 = *(void *)(a2 + 24);
  *(_DWORD *)(*(void *)(a2 + 16) + 4 * v6) = *((_DWORD *)v3 + 16);
  *(_DWORD *)(v10 + 4 * (*(_DWORD *)(a2 + 12))++) = *v3 >> 46;
  return result;
}

void ClearJumpTable(uint64_t a1)
{
  uint64_t v2 = a1 + 12;
  if (*(_DWORD *)(a1 + 12))
  {
    free(*(void **)(a1 + 16));
    free(*(void **)(a1 + 24));
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = 0;
}

uint64_t RemoveConditionalReturns(uint64_t a1, char **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5 = *a2;
  if (*a2)
  {
    LODWORD(v9) = 0;
    while (*((_DWORD *)v5 + 22) != *a4)
    {
      uint64_t v10 = v5 + 24;
      if (v9 || (*v10 & 0x3FC0) != 0x1540)
      {
        int v11 = OperationBlockBoundary((_DWORD *)v5 + 6);
        if (v11)
        {
          LODWORD(v9) = v11 + v9;
        }
        else if ((int)v9 > (int)a3 && (*v10 & 0x3FC0) == 0x1340)
        {
          return 0;
        }
      }
      else
      {
        uint64_t v13 = v5;
        uint64_t v9 = 0;
        if (!RemoveReturnsFromIfStatement(a1, &v13, a3, 1, a4)) {
          return v9;
        }
        uint64_t v5 = v13;
      }
      uint64_t v5 = (char *)*((void *)v5 + 1);
      if (!v5) {
        break;
      }
    }
  }
  *a2 = v5;
  return 1;
}

uint64_t RemoveReturnsFromIfStatement(uint64_t a1, char **a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *((void *)*a2 + 1);
  if (!v6)
  {
LABEL_29:
    *a2 = (char *)v6;
    return 1;
  }
  unint64_t v34 = a2;
  uint64_t v9 = 0;
  BOOL v10 = 0;
  int v11 = 0;
  int v12 = 0;
  uint64_t v13 = a3;
  do
  {
    uint64_t v14 = *(void *)(v6 + 24);
    if ((v14 & 0x3FC0) == 0x1640) {
      break;
    }
    int v15 = (v14 >> 6);
    switch(v15)
    {
      case 'M':
        if ((int)v13 > 0) {
          return 0;
        }
        uint64_t v13 = 0;
        BOOL v17 = !v10;
        BOOL v10 = v10;
        if (v17) {
          int v12 = 1;
        }
        if (!v17) {
          int v11 = 1;
        }
        break;
      case 'X':
        BOOL v10 = 1;
        uint64_t v9 = (void *)v6;
        break;
      case 'U':
        uint64_t v37 = v6;
        uint64_t result = RemoveReturnsFromIfStatement(a1, &v37, v13, 0, a5);
        if (!result) {
          return result;
        }
        uint64_t v6 = v37;
        break;
      default:
        uint64_t v13 = OperationBlockBoundary((_DWORD *)(v6 + 24)) + v13;
        break;
    }
    uint64_t v6 = *(void *)(v6 + 8);
    if ((int)v13 < (int)a3) {
      break;
    }
  }
  while (v6);
  if (!(v12 | v11))
  {
    a2 = v34;
    goto LABEL_29;
  }
  if (v10)
  {
    if (v12 && v11)
    {
      if (v5)
      {
        uint64_t v18 = (uint64_t *)v34;
        do
        {
          if ((v5[3] & 0x3FC0) == 0x1340) {
            break;
          }
          uint64_t v5 = (void *)v5[1];
        }
        while (v5);
      }
      else
      {
        uint64_t v18 = (uint64_t *)v34;
      }
      for (; v5 != v9; uint64_t v5 = (void *)PPStreamRemoveOperation(a1, v5))
        ;
      if (v9)
      {
        uint64_t v29 = v9;
        do
        {
          if ((v29[3] & 0x3FC0) == 0x1340) {
            break;
          }
          uint64_t v29 = (void *)v29[1];
        }
        while (v29);
      }
      else
      {
        uint64_t v29 = 0;
      }
      for (; v29 != (void *)v6; uint64_t v29 = (void *)PPStreamRemoveOperation(a1, v29))
        ;
      uint64_t v42 = 0;
      long long v41 = 0u;
      long long v40 = 0u;
      long long v39 = 0u;
      long long v38 = 0u;
      uint64_t v37 = 4928;
      v9[3] = v9[3] & 0x3FFFFFFFFFFFLL | ((unint64_t)*((unsigned int *)PPStreamInsertOperationAfterChunk(a1, (uint64_t)&v37, 0, v6)+ 22) << 46);
      *uint64_t v18 = v6;
      return 1;
    }
    uint64_t result = 0;
    if (a4 && v12 && !v11)
    {
      if (v5)
      {
        while ((v5[3] & 0x3FC0) != 0x1340)
        {
          uint64_t v5 = (void *)v5[1];
          if (!v5) {
            goto LABEL_55;
          }
        }
        while (v5 != v9)
        {
          uint64_t v24 = PPStreamRemoveOperation(a1, v5);
          if (!v24) {
            break;
          }
          uint64_t v5 = (void *)v24;
        }
      }
LABEL_55:
      uint64_t v25 = PPStreamRemoveOperation(a1, (void *)v6);
      for (int i = *(_DWORD *)(v25 + 88); i != *a5; int i = *(_DWORD *)(v25 + 88))
        uint64_t v25 = *(void *)(v25 + 8);
      uint64_t v42 = 0;
      long long v41 = 0u;
      long long v40 = 0u;
      long long v39 = 0u;
      long long v38 = 0u;
      uint64_t v37 = 5696;
      uint64_t v27 = *(void *)(v25 + 24);
      if ((v27 & 0x3FC0) == 0x2200)
      {
        uint64_t v25 = *(void *)v25;
        uint64_t v27 = *(void *)(v25 + 24);
      }
      if ((v27 & 0x3FC0) == 0x1340)
      {
        inserted = PPStreamInsertOperationBeforeChunk(a1, (uint64_t)&v37, 0, v25);
        v9[3] = v9[3] & 0x3FFFFFFFFFFFLL | ((unint64_t)*(unsigned int *)(v25 + 88) << 46);
        *unint64_t v34 = inserted;
      }
      else
      {
        uint64_t v31 = PPStreamInsertOperationAfterChunk(a1, (uint64_t)&v37, 0, v25);
        *unint64_t v34 = v31;
        HIDWORD(v41) = 0;
        LODWORD(v42) = 0;
        long long v38 = 0u;
        long long v39 = 0u;
        *(void *)&long long v40 = 0;
        uint64_t v37 = 4928;
        uint64_t v32 = PPStreamInsertOperationAfterChunk(a1, (uint64_t)&v37, 0, (uint64_t)v31);
        v9[3] = v9[3] & 0x3FFFFFFFFFFFLL | ((unint64_t)*((unsigned int *)v32 + 22) << 46);
        *a5 = *((_DWORD *)v32 + 22);
      }
      return 1;
    }
  }
  else
  {
    if (!a4) {
      return 0;
    }
    int v36 = *(char **)(v6 + 8);
    int v19 = RemoveConditionalReturns(a1, &v36, a3, a5);
    if (v19)
    {
      unint64_t v20 = *v34;
      if (*v34)
      {
        do
        {
          if ((v20[3] & 0x3FC0) == 0x1340) {
            break;
          }
          unint64_t v20 = (void *)v20[1];
        }
        while (v20);
      }
      uint64_t v42 = 0;
      long long v41 = 0u;
      long long v40 = 0u;
      long long v39 = 0u;
      long long v38 = 0u;
      uint64_t v37 = 5632;
      for (int j = PPStreamInsertOperationBeforeChunk(a1, (uint64_t)&v37, 0, (uint64_t)v20);
            v20;
            unint64_t v20 = (void *)PPStreamRemoveOperation(a1, v20))
      {
        if (v20 == (void *)v6) {
          break;
        }
      }
      v5[3] = v5[3] & 0x3FFFFFFFFFFFLL | ((unint64_t)*(unsigned int *)(PPStreamRemoveOperation(a1, v20) + 88) << 46);
      HIDWORD(v41) = 0;
      LODWORD(v42) = 0;
      *(void *)&long long v40 = 0;
      long long v38 = 0u;
      long long v39 = 0u;
      uint64_t v37 = 5696;
      BOOL v22 = v36;
      uint64_t v23 = *((void *)v36 + 3);
      if ((v23 & 0x3FC0) == 0x2200)
      {
        BOOL v22 = *(char **)v36;
        uint64_t v23 = *(void *)(*(void *)v36 + 24);
      }
      if ((v23 & 0x3FC0) == 0x1340)
      {
        *unint64_t v34 = PPStreamInsertOperationBeforeChunk(a1, (uint64_t)&v37, 0, (uint64_t)v22);
      }
      else
      {
        uint64_t v30 = PPStreamInsertOperationAfterChunk(a1, (uint64_t)&v37, 0, (uint64_t)v22);
        *unint64_t v34 = v30;
        HIDWORD(v41) = 0;
        LODWORD(v42) = 0;
        long long v38 = 0u;
        long long v39 = 0u;
        *(void *)&long long v40 = 0;
        uint64_t v37 = 4928;
        BOOL v22 = PPStreamInsertOperationAfterChunk(a1, (uint64_t)&v37, 0, (uint64_t)v30);
        *a5 = *((_DWORD *)v22 + 22);
      }
      *((void *)j + 3) = *((void *)j + 3) & 0x3FFFFFFFFFFFLL | ((unint64_t)*((unsigned int *)v22 + 22) << 46);
    }
    return v19 != 0;
  }
  return result;
}

uint64_t OperationBlockBoundary(_DWORD *a1)
{
  unsigned int v1 = (*a1 >> 6) - 85;
  if (v1 <= 0x3A)
  {
    if (((1 << v1) & 0x80000000400007) != 0) {
      return 1;
    }
    if (((1 << v1) & 0x400000000800070) != 0) {
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t CheckRemoveAvailableCopyTable(unint64_t a1, int a2, int a3, uint64_t *a4, uint64_t a5)
{
  unsigned int v8 = a1;
  unint64_t v9 = HIWORD(a1);
  if ((a1 & 0x100000000) != 0) {
    uint64_t result = GetStreamArray((a1 >> 12) & 7, (int)v9 + a2, a5);
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  uint64_t v11 = *((unsigned int *)a4 + 2);
  if (v11)
  {
    uint64_t v12 = 0;
    int v13 = (v8 >> 12) & 7;
    unsigned int v14 = v9 + a2;
    uint64_t v15 = *a4;
    uint64_t v16 = *a4 + 40;
    for (uint64_t i = *a4 + 24; ; i += 72)
    {
      uint64_t v18 = (_DWORD *)(v15 + 72 * v12);
      if (!*v18) {
        goto LABEL_60;
      }
      if ((result & 0x80000000) == 0 && result == *(_DWORD *)(v15 + 72 * v12 + 64)) {
        goto LABEL_32;
      }
      uint64_t v19 = v15 + 72 * v12;
      int v20 = *(_DWORD *)(v19 + 60);
      int v21 = *(_DWORD *)(v19 + 4);
      if (v20 && v21 == v13) {
        break;
      }
      if (v21 == v13) {
        goto LABEL_17;
      }
LABEL_33:
      if ((result & 0x80000000) == 0 && result == *(_DWORD *)(v15 + 72 * v12 + 68)) {
        goto LABEL_59;
      }
      uint64_t v28 = v15 + 72 * v12;
      int v29 = *(_DWORD *)(v28 + 60);
      int v30 = *(_DWORD *)(v28 + 12);
      if (v29) {
        BOOL v31 = v30 == v13;
      }
      else {
        BOOL v31 = 0;
      }
      if (v31)
      {
        unsigned int v32 = *(_DWORD *)(v15 + 72 * v12 + 16);
        if (v32 > v14 || v14 > *(_DWORD *)(v15 + 72 * v12 + 20) + v32)
        {
LABEL_43:
          if (v29 == a3 && *(_DWORD *)(v15 + 72 * v12 + 16) == v14)
          {
            unint64_t v34 = 0;
            BOOL v35 = 1;
            do
            {
              if (*(_DWORD *)(v16 + 4 * v34))
              {
                unsigned int v36 = v8 >> 18;
                switch(*(_DWORD *)(i + 4 * v34))
                {
                  case 0:
                    goto LABEL_54;
                  case 1:
                    if ((v8 & 0x20000) == 0) {
                      break;
                    }
                    goto LABEL_58;
                  case 2:
                    LOBYTE(v36) = BYTE2(v8);
LABEL_54:
                    if ((v36 & 1) == 0) {
                      break;
                    }
                    goto LABEL_58;
                  case 3:
                    if ((v8 & 0x8000) == 0) {
                      break;
                    }
LABEL_58:
                    if (v35) {
                      goto LABEL_59;
                    }
                    goto LABEL_60;
                  default:
                    break;
                }
              }
              BOOL v35 = v34++ < 3;
            }
            while (v34 != 4);
          }
          goto LABEL_60;
        }
LABEL_59:
        *uint64_t v18 = 0;
        goto LABEL_60;
      }
      if (v30 == v13) {
        goto LABEL_43;
      }
LABEL_60:
      ++v12;
      v16 += 72;
      if (v12 == v11) {
        return result;
      }
    }
    unsigned int v23 = *(_DWORD *)(v15 + 72 * v12 + 8);
    if (v23 > v14 || v14 > *(_DWORD *)(v15 + 72 * v12 + 20) + v23)
    {
LABEL_17:
      if (v20 == a3 && *(_DWORD *)(v15 + 72 * v12 + 8) == v14)
      {
        unint64_t v25 = 0;
        BOOL v26 = 1;
        while (2)
        {
          unsigned int v27 = v8 >> 18;
          switch((int)v25)
          {
            case 0:
              goto LABEL_27;
            case 1:
              if ((v8 & 0x20000) != 0) {
                goto LABEL_31;
              }
              goto LABEL_28;
            case 2:
              LOBYTE(v27) = BYTE2(v8);
LABEL_27:
              if ((v27 & 1) == 0) {
                goto LABEL_28;
              }
              goto LABEL_31;
            case 3:
              if ((v8 & 0x8000) == 0) {
                goto LABEL_28;
              }
LABEL_31:
              if (v26) {
                goto LABEL_32;
              }
              goto LABEL_33;
            default:
LABEL_28:
              BOOL v26 = v25++ < 3;
              if (v25 == 4) {
                goto LABEL_33;
              }
              continue;
          }
        }
      }
      goto LABEL_33;
    }
LABEL_32:
    *uint64_t v18 = 0;
    goto LABEL_33;
  }
  return result;
}

uint64_t GetStreamArray(int a1, unsigned int a2, uint64_t a3)
{
  if (a1 != 2)
  {
    if (a1 == 1)
    {
      uint64_t v3 = **(void **)(a3 + 80);
      if (v3)
      {
        uint64_t result = 0;
        while (1)
        {
          unint64_t v5 = *(void *)(v3 + 24);
          if (a2 >= WORD1(v5) && HIWORD(v5) >= a2) {
            break;
          }
          uint64_t result = (result + 1);
          uint64_t v3 = *(void *)(v3 + 8);
          if (!v3) {
            return 0xFFFFFFFFLL;
          }
        }
        return result;
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = **(void **)(a3 + 72);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  while (1)
  {
    unint64_t v8 = *(void *)(v7 + 24);
    if (a2 >= WORD1(v8) && HIWORD(v8) >= a2) {
      break;
    }
    uint64_t result = (result + 1);
    uint64_t v7 = *(void *)(v7 + 8);
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

_DWORD *FindMatchingAvailableCopy(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 8);
  if (!v2) {
    return 0;
  }
  for (uint64_t result = *(_DWORD **)a2;
        !*result
     || result[1] != a1[1]
     || result[2] != a1[2]
     || result[3] != a1[3]
     || result[4] != a1[4]
     || result[14] != a1[14]
     || result[15] != a1[15];
        result += 18)
  {
    if (!--v2) {
      return 0;
    }
  }
  return result;
}

uint64_t gleAttribBindingSize(int a1)
{
  return (8 * a1 + 8);
}

void *gleCopyParamBindings(_DWORD *a1, void *a2)
{
  size_t v4 = (16 * a1[1] + 8 * *a1);
  unint64_t v5 = malloc_type_malloc(v4 + 16, 0x7081ABB9uLL);
  if (!v5) {
    abort();
  }
  *a2 = v5;
  *(void *)unint64_t v5 = *(void *)a1;
  v5[2] = a1[2];
  uint64_t v6 = v5 + 4;

  return memcpy(v6, a1 + 4, v4);
}

void *gleCopyAttribBindings(_DWORD *a1, void *a2)
{
  size_t v4 = 8 * *a1 + 8;
  unint64_t v5 = malloc_type_malloc(v4, 0x7081ABB9uLL);
  if (!v5) {
    abort();
  }
  *a2 = v5;

  return memcpy(v5, a1, v4);
}

char *glpCallVertexStateToLLVMIR(long long *a1, void *a2, void *a3, void *a4, void *a5, _DWORD *a6)
{
  uint64_t v11 = *((void *)a1 + 4);
  unint64_t v12 = *(void *)a1;
  uint64_t v13 = *((void *)a1 + 1);
  *(void *)a1 &= ~0x2000000000000000uLL;
  bzero(v38, 0x7E8uLL);
  *(void *)&long long v14 = -1;
  *((void *)&v14 + 1) = -1;
  *(_OWORD *)((char *)v43 + 14) = v14;
  long long v42 = v14;
  v43[0] = v14;
  long long v40 = v14;
  long long v41 = v14;
  long long v39 = v14;
  memset(&v38[2], 255, 0x754uLL);
  unsigned int v48 = ((v11 >> 1) & 0x800 | (((v11 >> 8) & 3) << 9) | (v13 >> 21) & 0x1F8) ^ 0x401;
  v37[0] = 0;
  v37[1] = &v49;
  v38[824] = 4096;
  int v46 = gleVStateProgram_IgnoreOption;
  gleVStateProgram_AllocateOutputs((uint64_t *)a1, (uint64_t)v37);
  if ((v12 & 0x100) == 0) {
    gleVStateProgram_GetAttrib((uint64_t)v37, 0);
  }
  gleVStateProgram_Core((unint64_t *)a1, (uint64_t)v37);
  char v15 = v48;
  if ((v48 & 1) == 0)
  {
    uint64_t v16 = **(void **)(v37[0] + 104);
    if (v16)
    {
      *(void *)(v16 + 24) |= 0x4000uLL;
      char v15 = v48;
    }
  }
  int v46 = gleVStateProgram_LLVMAddOperation;
  if ((v15 & 1) == 0) {
    gleVStateProgram_AllocateOutputs((uint64_t *)a1, (uint64_t)v37);
  }
  if ((*(void *)a1 & 0x100) == 0) {
    gleVStateProgram_GetAttrib((uint64_t)v37, 0);
  }
  gleVStateProgram_Core((unint64_t *)a1, (uint64_t)v37);
  if ((v48 & 1) == 0)
  {
    uint64_t v17 = **(void **)(v37[0] + 104);
    if (v17) {
      *(void *)(v17 + 24) |= 0x4000uLL;
    }
  }
  uint64_t v18 = 8 * v45 + 64;
  int v19 = v18 + 8 * v44 + 8;
  int v20 = malloc_type_malloc(v18 + 8 * v44 + 8, 0x7081ABB9uLL);
  if (!v20) {
    goto LABEL_18;
  }
  int v21 = v20;
  *(void *)int v20 = 0x3000000030;
  v20[2] = v18;
  v20[3] = v19;
  _OWORD v20[4] = 0;
  *((void *)v20 + 3) = 0;
  int v47 = v20;
  uint64_t v22 = 0x2000000020;
  if ((v48 & 4) == 0) {
    uint64_t v22 = 0;
  }
  *((void *)v20 + 4) = ((*(void *)a1 >> 60) | (8 * v48)) & 0x14;
  *((void *)v47 + 5) = v22;
  v47[4] = (*(void *)a1 & 0x100) == 0;
  gleVStateProgram_AddParams((char *)v37);
  gleVStateProgram_AddAttribs((uint64_t)v37);
  unsigned int v23 = (char *)malloc_type_malloc(0xE8uLL, 0x7081ABB9uLL);
  if (!v23) {
LABEL_18:
  }
    abort();
  uint64_t v24 = v23;
  *(void *)unsigned int v23 = 0x1000000E4;
  long long v25 = *a1;
  *(_OWORD *)(v23 + 24) = a1[1];
  *(_OWORD *)(v23 + 8) = v25;
  long long v26 = a1[2];
  long long v27 = a1[3];
  long long v28 = a1[4];
  *(_OWORD *)(v23 + 88) = a1[5];
  *(_OWORD *)(v23 + 72) = v28;
  *(_OWORD *)(v23 + 56) = v27;
  *(_OWORD *)(v23 + 40) = v26;
  long long v29 = a1[6];
  long long v30 = a1[7];
  long long v31 = a1[8];
  *(_OWORD *)(v23 + 152) = a1[9];
  *(_OWORD *)(v23 + 136) = v31;
  *(_OWORD *)(v23 + 120) = v30;
  *(_OWORD *)(v23 + 104) = v29;
  long long v32 = a1[10];
  long long v33 = a1[11];
  long long v34 = a1[12];
  *(_OWORD *)(v23 + 216) = a1[13];
  *(_OWORD *)(v23 + 200) = v34;
  *(_OWORD *)(v23 + 184) = v33;
  *(_OWORD *)(v23 + 168) = v32;
  gleCopyParamBindings((void *)((char *)v21 + *((unsigned int *)v21 + 1)), a2);
  gleCopyAttribBindings((void *)((char *)v21 + *((unsigned int *)v21 + 2)), a3);
  *a4 = v21[4];
  *a5 = v21[5];
  *a6 = *((_DWORD *)v21 + 4);
  free(v21);
  *(void *)a1 = *(void *)a1 & 0xDFFFFFFFFFFFFFFFLL | (((v12 >> 61) & 1) << 61);
  return v24;
}

unsigned __int16 *glpVertexStateToPPStream(uint64_t a1, void *a2, void *a3, _DWORD *a4)
{
  int v22 = 0;
  bzero(v24, 0x7E8uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *(_OWORD *)((char *)v29 + 14) = v5;
  long long v28 = v5;
  v29[0] = v5;
  long long v26 = v5;
  long long v27 = v5;
  long long v25 = v5;
  memset(&v24[4], 255, 0x754uLL);
  v23[1] = 0;
  v23[0] = (_DWORD **)PPStreamCreate();
  *(_WORD *)v23[0] = -31200;
  long long v33 = gleVStateProgram_AddPPStreamOperation;
  if ((*(void *)a1 & 0x100) == 0) {
    gleVStateProgram_GetAttrib((uint64_t)v23, 0);
  }
  gleVStateProgram_Core((unint64_t *)a1, (uint64_t)v23);
  if ((v34 & 1) == 0)
  {
    uint64_t v6 = **((void **)v23[0] + 13);
    if (v6) {
      *(void *)(v6 + 24) |= 0x4000uLL;
    }
  }
  gleVStateProgram_AddAttribs((uint64_t)v23);
  gleVStateProgram_AddParams((char *)v23);
  if (v30 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 1694;
    do
    {
      int v9 = *(__int16 *)((char *)v23 + v8);
      *(void *)&v35[0] = 0;
      *((void *)&v35[0] + 1) = v7;
      if ((v9 - 3) > 3)
      {
        uint64_t v11 = 192;
      }
      else
      {
        long long v10 = *(_OWORD *)(a1 + 24);
        uint64_t v11 = (v10 >> 57) & 0x10000 | (v10 >> 55) & 0x20000 | 0xC0;
      }
      if (v9 <= 46)
      {
        switch(v9)
        {
          case 0:
            unint64_t v12 = v11 & 0xFFFFFFFFFFFFE0FFLL | 0x100;
            break;
          case 1:
            unint64_t v13 = v11 & 0xFFFFFFFFFFFFE07FLL;
            uint64_t v14 = 0x500001140;
            goto LABEL_28;
          case 2:
            unint64_t v12 = v11 & 0xFFFFFFFFFFFFE03FLL | 0x300;
            break;
          case 3:
            unint64_t v12 = v11 & 0xFFFFFFFEFFFFE0FFLL | 0x400;
            break;
          case 4:
            unint64_t v13 = v11 & 0xFFFFFFFEFFFFE0FFLL;
            uint64_t v14 = 0x100000400;
            goto LABEL_28;
          case 5:
            unint64_t v13 = v11 & 0xFFFFFFFEFFFFE0FFLL;
            uint64_t v14 = 1280;
            goto LABEL_28;
          case 6:
            unint64_t v13 = v11 & 0xFFFFFFFEFFFFE0FFLL;
            uint64_t v14 = 0x100000500;
            goto LABEL_28;
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            unint64_t v12 = v11 & 0xFFFFFF80FFFFE0FFLL | ((unint64_t)(v9 + 1) << 32) | 0x1100;
            break;
          default:
            goto LABEL_27;
        }
        goto LABEL_29;
      }
      if ((v9 - 48) < 2)
      {
        unint64_t v12 = v11 & 0xFFFFFFFFFFFFE0FFLL | ((unint64_t)(((_BYTE)v9 + 16) & 0x1F) << 32) | 0xA00;
      }
      else
      {
        if (v9 == 47)
        {
          unint64_t v13 = v11 & 0xFFFFFFFFFFFFE1FFLL;
          uint64_t v14 = 2304;
LABEL_28:
          unint64_t v12 = v13 | v14;
          goto LABEL_29;
        }
        if (v9 != 50)
        {
LABEL_27:
          unint64_t v13 = v11 & 0xFFFFFF80FFFFE0FFLL | ((unint64_t)(((_BYTE)v9 + 49) & 0x3F) << 32);
          uint64_t v14 = 0x4000001100;
          goto LABEL_28;
        }
        unint64_t v12 = v11 & 0xFFFFFFFEFFFFE0FFLL | 0x100000100;
      }
LABEL_29:
      *(void *)&v35[0] = v12;
      PPStreamAddOutputBinding((uint64_t)v23[0], v35);
      ++v7;
      v8 += 4;
    }
    while (v7 < v30);
  }
  if (v31)
  {
    for (unsigned int i = 0; i < v31; ++i)
    {
      LODWORD(v35[0]) = i;
      PPStreamAddAddressUsage((uint64_t)v23[0], v35);
    }
  }
  if (v32)
  {
    for (unsigned int j = 0; j < v32; ++j)
    {
      v35[0] = xmmword_2393D1160;
      DWORD2(v35[0]) = j;
      PPStreamAddTempUsage((uint64_t)v23[0], v35);
    }
  }
  if ((*(void *)a1 & 0x100) == 0) {
    PPStreamAddOption((uint64_t)v23[0], 0);
  }
  Stream = PPStreamGetStream((uint64_t)v23[0], &v22);
  PPStreamFree(v23[0]);
  *a4 = PPStreamTokenGetProgramOptions((uint64_t)Stream);
  *a2 = *((void *)Stream + 1);
  *a3 = *((void *)Stream + 2);
  return Stream;
}

char *gleVStateProgram_AddPPStreamOperation(uint64_t *a1, uint64_t a2)
{
  return PPStreamAddOperation(*a1, a2, 0);
}

unint64_t *gleVStateProgram_Core(unint64_t *result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  unint64_t v5 = *result;
  uint64_t v325 = result;
  if ((*result & 0x200) == 0)
  {
    if ((v5 & 0x400) != 0) {
      goto LABEL_138;
    }
LABEL_3:
    if ((v5 & 0x100) == 0) {
      goto LABEL_263;
    }
LABEL_259:
    if ((v5 & 0xFF0000000000) != 0)
    {
      uint64_t result = (unint64_t *)gleVStateProgram_MultMatrix4x4(a2, 0, 0, 0, 23, 0, 0, 1, HIBYTE(v5) & 1);
      goto LABEL_263;
    }
    if ((v5 & 4) == 0)
    {
      uint64_t result = (unint64_t *)gleVStateProgram_MultMatrix4x4(a2, 0, 8, 0, 23, 1, 0, 1, HIBYTE(v5) & 1);
      goto LABEL_263;
    }
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
    if ((*v3 & 0x8000) != 0)
    {
      uint64_t v174 = *(unsigned __int16 *)(a2 + 1892);
      if (v174 == 0xFFFF)
      {
        uint64_t v174 = *(unsigned __int16 *)(a2 + 2000);
        *(_WORD *)(a2 + 1892) = v174;
        __int16 v175 = 50;
        goto LABEL_299;
      }
    }
    else
    {
      uint64_t v174 = *(unsigned __int16 *)(a2 + 1692);
      if (v174 == 0xFFFF)
      {
        __int16 v175 = 0;
        uint64_t v174 = *(unsigned __int16 *)(a2 + 2000);
        *(_WORD *)(a2 + 1692) = v174;
LABEL_299:
        *(_WORD *)(a2 + 4 * (__int16)v174 + 1694) = v175;
        *(_WORD *)(a2 + 2000) = v174 + 1;
      }
    }
    *((void *)&v326[0] + 1) = ((v174 << 48) | 0x72679000) + 0x2000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    goto LABEL_263;
  }
  unint64_t v6 = result[2];
  memset(v326, 0, sizeof(v326));
  if (!v6) {
    goto LABEL_35;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 900;
  do
  {
    unsigned int v9 = v6 >> v7;
    if (((v6 >> v7) & 0x1010101) == 0) {
      goto LABEL_33;
    }
    if (v9)
    {
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
      *(_DWORD *)(a2 + 16) = 2;
      *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
      uint64_t v10 = *(unsigned __int16 *)(a2 + v8);
      if (v10 == 0xFFFF)
      {
        uint64_t v11 = *(__int16 *)(a2 + 1998);
        uint64_t v10 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + v8) = v11;
        *(_WORD *)(a2 + 4 * v11 + 262) = 4 * v7 + 160;
        *(_WORD *)(a2 + 1998) = v11 + 1;
      }
      *((void *)&v326[1] + 1) = ((v10 << 48) | 0x19C840) + 64;
      uint64_t v12 = a2 + 2 * v7;
      uint64_t v13 = *(unsigned __int16 *)(v12 + 1978);
      if (v13 == 0xFFFF)
      {
        uint64_t v13 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(v12 + 1978) = v13;
        *(_WORD *)(a2 + 2004) = v13 + 1;
      }
      *((void *)&v326[0] + 1) = (v13 << 48) | 0x72641000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      if ((v9 & 0x100) == 0)
      {
LABEL_10:
        if ((v9 & 0x10000) == 0) {
          goto LABEL_11;
        }
        goto LABEL_23;
      }
    }
    else if ((v9 & 0x100) == 0)
    {
      goto LABEL_10;
    }
    memset(&v326[2], 0, 48);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a2 + 16) = 2;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
    uint64_t v14 = *(unsigned __int16 *)(a2 + v8 + 4);
    if (v14 == 0xFFFF)
    {
      uint64_t v15 = *(__int16 *)(a2 + 1998);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + v8 + 4) = v15;
      *(_WORD *)(a2 + 4 * v15 + 262) = 4 * v7 + 161;
      *(_WORD *)(a2 + 1998) = v15 + 1;
    }
    *((void *)&v326[1] + 1) = ((v14 << 48) | 0x19C840) + 64;
    uint64_t v16 = a2 + 2 * v7;
    uint64_t v17 = *(unsigned __int16 *)(v16 + 1978);
    if (v17 == 0xFFFF)
    {
      uint64_t v17 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(v16 + 1978) = v17;
      *(_WORD *)(a2 + 2004) = v17 + 1;
    }
    *((void *)&v326[0] + 1) = (v17 << 48) | 0x72621000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    if ((v9 & 0x10000) == 0)
    {
LABEL_11:
      if ((v9 & 0x1000000) == 0) {
        goto LABEL_33;
      }
LABEL_28:
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
      *(_DWORD *)(a2 + 16) = 2;
      *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
      uint64_t v22 = *(unsigned __int16 *)(a2 + v8 + 12);
      if (v22 == 0xFFFF)
      {
        uint64_t v23 = *(__int16 *)(a2 + 1998);
        uint64_t v22 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + v8 + 12) = v23;
        *(_WORD *)(a2 + 4 * v23 + 262) = 4 * v7 + 163;
        *(_WORD *)(a2 + 1998) = v23 + 1;
      }
      *((void *)&v326[1] + 1) = ((v22 << 48) | 0x19C840) + 64;
      uint64_t v24 = a2 + 2 * v7;
      uint64_t v25 = *(unsigned __int16 *)(v24 + 1978);
      if (v25 == 0xFFFF)
      {
        uint64_t v25 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(v24 + 1978) = v25;
        *(_WORD *)(a2 + 2004) = v25 + 1;
      }
      *((void *)&v326[0] + 1) = (v25 << 48) | 0x72609000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      goto LABEL_33;
    }
LABEL_23:
    memset(&v326[2], 0, 48);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a2 + 16) = 2;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
    uint64_t v18 = *(unsigned __int16 *)(a2 + v8 + 8);
    if (v18 == 0xFFFF)
    {
      uint64_t v19 = *(__int16 *)(a2 + 1998);
      uint64_t v18 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + v8 + 8) = v19;
      *(_WORD *)(a2 + 4 * v19 + 262) = 4 * v7 + 162;
      *(_WORD *)(a2 + 1998) = v19 + 1;
    }
    *((void *)&v326[1] + 1) = ((v18 << 48) | 0x19C840) + 64;
    uint64_t v20 = a2 + 2 * v7;
    uint64_t v21 = *(unsigned __int16 *)(v20 + 1978);
    if (v21 == 0xFFFF)
    {
      uint64_t v21 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(v20 + 1978) = v21;
      *(_WORD *)(a2 + 2004) = v21 + 1;
    }
    *((void *)&v326[0] + 1) = (v21 << 48) | 0x72611000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    if ((v9 & 0x1000000) != 0) {
      goto LABEL_28;
    }
LABEL_33:
    ++v7;
    v8 += 16;
  }
  while (v7 != 8);
  uint64_t v3 = v325;
  unint64_t v4 = v325[4];
  unint64_t v5 = *v325;
LABEL_35:
  if ((v5 & 0xFF0000000000) == 0)
  {
    if ((v5 & 0x40) != 0)
    {
      if ((v5 & 8) == 0)
      {
        uint64_t result = (unint64_t *)gleVStateProgram_MultMatrix4x4(a2, 0, 16, 0, 0, 1, 0, 0, HIBYTE(v5) & 1);
        goto LABEL_99;
      }
    }
    else
    {
      if ((v5 & 0x80) == 0) {
        goto LABEL_99;
      }
      if ((v5 & 8) == 0)
      {
        memset(&v326[2], 0, 48);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
        *(_DWORD *)(a2 + 16) = 2;
        *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
        uint64_t v29 = *(unsigned __int16 *)(a2 + 348);
        if (v29 == 0xFFFF)
        {
          uint64_t v30 = *(__int16 *)(a2 + 1998);
          uint64_t v29 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 348) = v30;
          *(_WORD *)(a2 + 4 * v30 + 262) = 22;
          *(_WORD *)(a2 + 1998) = v30 + 1;
        }
        *((void *)&v326[1] + 1) = ((v29 << 48) | 0x19C840) + 64;
        uint64_t v31 = *(unsigned __int16 *)(a2 + 1900);
        if (v31 == 0xFFFF)
        {
          uint64_t v31 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1900) = v31;
          *(_WORD *)(a2 + 2004) = v31 + 1;
        }
        uint64_t v32 = (v31 << 48) | 0x72679000;
LABEL_98:
        *((void *)&v326[0] + 1) = v32;
        uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        goto LABEL_99;
      }
    }
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 0) << 48) | 0x19C800;
    uint64_t v57 = *(unsigned __int16 *)(a2 + 1900);
    if (v57 == 0xFFFF)
    {
      uint64_t v57 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v57;
      *(_WORD *)(a2 + 2004) = v57 + 1;
    }
    uint64_t v32 = (v57 << 48) | 0x72679000;
    goto LABEL_98;
  }
  if ((v5 & 2) != 0)
  {
    memset(&v326[2], 0, 48);
    int v26 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 2;
    *(void *)&v326[0] = (8 * (v26 & 7)) | 0x3100011042;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 4) << 48) | 0x19C800;
    unsigned int v27 = *((unsigned __int8 *)v3 + 5) - 1;
    if (v27 > 2) {
      uint64_t v28 = 2182086656;
    }
    else {
      uint64_t v28 = qword_2393DBED0[(char)v27];
    }
    *((void *)&v326[1] + 1) = v28;
    uint64_t v33 = *(unsigned __int16 *)(a2 + 1944);
    if (v33 == 0xFFFF)
    {
      uint64_t v33 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1944) = v33;
      *(_WORD *)(a2 + 2004) = v33 + 1;
    }
    *((void *)&v326[0] + 1) = (v33 << 48) | 0x72679000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    unint64_t v4 = v3[4];
    unint64_t v5 = *v3;
  }
  if ((v5 & 0xFF0000000000) != 0)
  {
    unsigned int v34 = 0;
    int v35 = 16;
    do
    {
      if ((v4 & 0x400) != 0)
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100001201;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t Attrib = gleVStateProgram_GetAttrib(a2, 7);
        *(_WORD *)(a2 + 2002) = 1;
        *((void *)&v326[0] + 1) = 1919172608;
        *(void *)&v326[1] = ((unint64_t)(v34 & 3) << 9) | (Attrib << 48) | ((unint64_t)(v34 & 3) << 11) | ((unint64_t)(v34 & 3) << 13) | ((unint64_t)(v34 & 3) << 15);
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        unsigned int v36 = v325;
        gleVStateProgram_MultMatrix4x4(a2, 0, 144, 23, 23, 1, 1, 0, *((unsigned char *)v325 + 7) & 1);
      }
      else
      {
        gleVStateProgram_MultMatrix4x4(a2, 0, v35, 23, 23, 1, 0, 0, HIBYTE(v5) & 1);
        unsigned int v36 = v325;
      }
      if ((*v36 & 2) != 0)
      {
        if (v34 < ((unsigned __int16)WORD2(*v36) >> 8) - 1)
        {
          memset(&v326[1], 0, 64);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000802;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v40 = *(unsigned __int16 *)(a2 + 1944);
          if (v40 == 0xFFFF)
          {
            uint64_t v44 = *(unsigned __int16 *)(a2 + 2004);
            int v45 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1944) = v44;
            int v46 = v45 + 1;
            *(_WORD *)(a2 + 2004) = v46;
            *(void *)&v326[1] = ((unint64_t)(unsigned __int16)v44 << 48) | 0x19C840;
            if ((v46 & 0x10000) != 0)
            {
              uint64_t v41 = 0;
              *(_WORD *)(a2 + 1944) = v46;
              *(_WORD *)(a2 + 2004) = 1;
            }
            else
            {
              uint64_t v41 = v44 << 48;
            }
          }
          else
          {
            uint64_t v41 = v40 << 48;
            *(void *)&v326[1] = ((unint64_t)(unsigned __int16)v40 << 48) | 0x19C840;
          }
          *((void *)&v326[1] + 1) = v41 | (43520 * (v34 & 3)) | 0x40;
          *((void *)&v326[0] + 1) = v41 | 0x72601000;
          unsigned int v47 = *((unsigned __int8 *)v325 + 5) - 2;
          if (v47 <= 2) {
            *((void *)&v326[0] + 1) = qword_2393DBEE8[(char)v47] | v41;
          }
          (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        }
        if (!v34)
        {
          memset(&v326[2], 0, 48);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v55 = *(unsigned __int16 *)(a2 + 1946);
          if (v55 == 0xFFFF)
          {
            uint64_t v55 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v55;
            *(_WORD *)(a2 + 2004) = v55 + 1;
          }
          *(void *)&v326[1] = (v55 << 48) | 0x19C840;
          uint64_t v56 = *(unsigned __int16 *)(a2 + 1944);
          if (v56 == 0xFFFF)
          {
            uint64_t v56 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1944) = v56;
            *(_WORD *)(a2 + 2004) = v56 + 1;
          }
          uint64_t v43 = (v56 << 48) | 0x40;
          goto LABEL_90;
        }
        memset((char *)v326 + 8, 0, 72);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v48 = *(unsigned __int16 *)(a2 + 1946);
        if (v48 == 0xFFFF)
        {
          uint64_t v48 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v48;
          *(_WORD *)(a2 + 2004) = v48 + 1;
        }
        *(void *)&v326[1] = (v48 << 48) | 0x19C840;
        uint64_t v49 = *(unsigned __int16 *)(a2 + 1944);
        if (v49 == 0xFFFF)
        {
          uint64_t v49 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1944) = v49;
          *(_WORD *)(a2 + 2004) = v49 + 1;
        }
        unint64_t v39 = ((unint64_t)(v34 & 3) << 9) | (v49 << 48) | ((unint64_t)(v34 & 3) << 11) | ((unint64_t)(v34 & 3) << 13) | ((unint64_t)(v34 & 3) << 15) | 0x40;
      }
      else
      {
        if (!v34)
        {
          memset(&v326[2], 0, 48);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v42 = *(unsigned __int16 *)(a2 + 1946);
          if (v42 == 0xFFFF)
          {
            uint64_t v42 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v42;
            *(_WORD *)(a2 + 2004) = v42 + 1;
          }
          *(void *)&v326[1] = (v42 << 48) | 0x19C840;
          uint64_t v43 = gleVStateProgram_GetAttrib(a2, 4) << 48;
LABEL_90:
          *((void *)&v326[1] + 1) = v43;
          uint64_t v52 = *(unsigned __int16 *)(a2 + 1900);
          if (v52 == 0xFFFF)
          {
            uint64_t v52 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1900) = v52;
            *(_WORD *)(a2 + 2004) = v52 + 1;
          }
LABEL_92:
          uint64_t v51 = v52 << 48;
          goto LABEL_93;
        }
        memset((char *)v326 + 8, 0, 72);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v38 = *(unsigned __int16 *)(a2 + 1946);
        if (v38 == 0xFFFF)
        {
          uint64_t v38 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v38;
          *(_WORD *)(a2 + 2004) = v38 + 1;
        }
        *(void *)&v326[1] = (v38 << 48) | 0x19C840;
        unint64_t v39 = ((unint64_t)(v34 & 3) << 9) | (gleVStateProgram_GetAttrib(a2, 4) << 48) | ((unint64_t)(v34 & 3) << 11) | ((unint64_t)(v34 & 3) << 13) | ((unint64_t)(v34 & 3) << 15);
      }
      *((void *)&v326[1] + 1) = v39;
      uint64_t v50 = *(unsigned __int16 *)(a2 + 1900);
      if (v50 == 0xFFFF)
      {
        uint64_t v52 = *(unsigned __int16 *)(a2 + 2004);
        int v53 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v52;
        int v54 = v53 + 1;
        *(_WORD *)(a2 + 2004) = v54;
        *(void *)&v326[2] = ((unint64_t)(unsigned __int16)v52 << 48) | 0x19C840;
        if ((v54 & 0x10000) == 0) {
          goto LABEL_92;
        }
        uint64_t v51 = 0;
        *(_WORD *)(a2 + 1900) = v54;
        *(_WORD *)(a2 + 2004) = 1;
      }
      else
      {
        uint64_t v51 = v50 << 48;
        *(void *)&v326[2] = ((unint64_t)(unsigned __int16)v50 << 48) | 0x19C840;
      }
LABEL_93:
      *((void *)&v326[0] + 1) = v51 | 0x72679000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      ++v34;
      unint64_t v4 = v325[4];
      unint64_t v5 = *v325;
      v35 += 8;
    }
    while (v34 < ((unsigned __int16)WORD2(*v325) >> 8));
  }
LABEL_99:
  uint64_t v3 = v325;
  unint64_t v58 = v325[2];
  if ((v58 & 0xFFFFFFFF00000000) == 0) {
    goto LABEL_137;
  }
  uint64_t v59 = 0;
  unint64_t v60 = HIDWORD(v58);
  uint64_t v61 = 1028;
  while (2)
  {
    unsigned int v62 = v60 >> v59;
    if (((v60 >> v59) & 0x1010101) == 0) {
      goto LABEL_135;
    }
    if ((v62 & 1) == 0)
    {
      if ((v62 & 0x100) == 0) {
        goto LABEL_104;
      }
LABEL_114:
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v68 = *(unsigned __int16 *)(a2 + 1900);
      if (v68 == 0xFFFF)
      {
        uint64_t v68 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v68;
        *(_WORD *)(a2 + 2004) = v68 + 1;
      }
      *(void *)&v326[1] = (v68 << 48) | 0x19C840;
      uint64_t v69 = *(unsigned __int16 *)(a2 + v61 + 4);
      if (v69 == 0xFFFF)
      {
        uint64_t v70 = *(__int16 *)(a2 + 1998);
        uint64_t v69 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + v61 + 4) = v70;
        *(_WORD *)(a2 + 4 * v70 + 262) = 4 * v59 + 193;
        *(_WORD *)(a2 + 1998) = v70 + 1;
      }
      *((void *)&v326[1] + 1) = ((v69 << 48) | 0x19C840) + 64;
      uint64_t v71 = a2 + 2 * v59;
      uint64_t v72 = *(unsigned __int16 *)(v71 + 1978);
      if (v72 == 0xFFFF)
      {
        uint64_t v72 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(v71 + 1978) = v72;
        *(_WORD *)(a2 + 2004) = v72 + 1;
      }
      *((void *)&v326[0] + 1) = (v72 << 48) | 0x72621000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      if ((v62 & 0x10000) != 0) {
        goto LABEL_121;
      }
LABEL_105:
      if ((v62 & 0x1000000) == 0) {
        goto LABEL_135;
      }
LABEL_128:
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v78 = *(unsigned __int16 *)(a2 + 1900);
      if (v78 == 0xFFFF)
      {
        uint64_t v78 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v78;
        *(_WORD *)(a2 + 2004) = v78 + 1;
      }
      *(void *)&v326[1] = (v78 << 48) | 0x19C840;
      uint64_t v79 = *(unsigned __int16 *)(a2 + v61 + 12);
      if (v79 == 0xFFFF)
      {
        uint64_t v80 = *(__int16 *)(a2 + 1998);
        uint64_t v79 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + v61 + 12) = v80;
        *(_WORD *)(a2 + 4 * v80 + 262) = 4 * v59 + 195;
        *(_WORD *)(a2 + 1998) = v80 + 1;
      }
      *((void *)&v326[1] + 1) = ((v79 << 48) | 0x19C840) + 64;
      uint64_t v81 = a2 + 2 * v59;
      uint64_t v82 = *(unsigned __int16 *)(v81 + 1978);
      if (v82 == 0xFFFF)
      {
        uint64_t v82 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(v81 + 1978) = v82;
        *(_WORD *)(a2 + 2004) = v82 + 1;
      }
      *((void *)&v326[0] + 1) = (v82 << 48) | 0x72609000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      goto LABEL_135;
    }
    memset(&v326[2], 0, 48);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v63 = *(unsigned __int16 *)(a2 + 1900);
    if (v63 == 0xFFFF)
    {
      uint64_t v63 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v63;
      *(_WORD *)(a2 + 2004) = v63 + 1;
    }
    *(void *)&v326[1] = (v63 << 48) | 0x19C840;
    uint64_t v64 = *(unsigned __int16 *)(a2 + v61);
    if (v64 == 0xFFFF)
    {
      uint64_t v65 = *(__int16 *)(a2 + 1998);
      uint64_t v64 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + v61) = v65;
      *(_WORD *)(a2 + 4 * v65 + 262) = 4 * v59 + 192;
      *(_WORD *)(a2 + 1998) = v65 + 1;
    }
    *((void *)&v326[1] + 1) = ((v64 << 48) | 0x19C840) + 64;
    uint64_t v66 = a2 + 2 * v59;
    uint64_t v67 = *(unsigned __int16 *)(v66 + 1978);
    if (v67 == 0xFFFF)
    {
      uint64_t v67 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(v66 + 1978) = v67;
      *(_WORD *)(a2 + 2004) = v67 + 1;
    }
    *((void *)&v326[0] + 1) = (v67 << 48) | 0x72641000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    if ((v62 & 0x100) != 0) {
      goto LABEL_114;
    }
LABEL_104:
    if ((v62 & 0x10000) == 0) {
      goto LABEL_105;
    }
LABEL_121:
    memset(&v326[2], 0, 48);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v73 = *(unsigned __int16 *)(a2 + 1900);
    if (v73 == 0xFFFF)
    {
      uint64_t v73 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v73;
      *(_WORD *)(a2 + 2004) = v73 + 1;
    }
    *(void *)&v326[1] = (v73 << 48) | 0x19C840;
    uint64_t v74 = *(unsigned __int16 *)(a2 + v61 + 8);
    if (v74 == 0xFFFF)
    {
      uint64_t v75 = *(__int16 *)(a2 + 1998);
      uint64_t v74 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + v61 + 8) = v75;
      *(_WORD *)(a2 + 4 * v75 + 262) = 4 * v59 + 194;
      *(_WORD *)(a2 + 1998) = v75 + 1;
    }
    *((void *)&v326[1] + 1) = ((v74 << 48) | 0x19C840) + 64;
    uint64_t v76 = a2 + 2 * v59;
    uint64_t v77 = *(unsigned __int16 *)(v76 + 1978);
    if (v77 == 0xFFFF)
    {
      uint64_t v77 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(v76 + 1978) = v77;
      *(_WORD *)(a2 + 2004) = v77 + 1;
    }
    *((void *)&v326[0] + 1) = (v77 << 48) | 0x72611000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    if ((v62 & 0x1000000) != 0) {
      goto LABEL_128;
    }
LABEL_135:
    ++v59;
    v61 += 16;
    if (v59 != 8) {
      continue;
    }
    break;
  }
  uint64_t v3 = v325;
LABEL_137:
  unint64_t v4 = v3[4];
  unint64_t v5 = *v3;
  if ((*v3 & 0x400) == 0) {
    goto LABEL_3;
  }
LABEL_138:
  memset(v326, 0, sizeof(v326));
  if ((v5 & 0xFF0000000000) != 0)
  {
    unsigned int v83 = 0;
    int v84 = 48;
    while (1)
    {
      if ((v4 & 0x400) != 0)
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100001201;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v86 = gleVStateProgram_GetAttrib(a2, 7);
        *(_WORD *)(a2 + 2002) = 1;
        *((void *)&v326[0] + 1) = 1919172608;
        *(void *)&v326[1] = ((unint64_t)(v83 & 3) << 9) | (v86 << 48) | ((unint64_t)(v83 & 3) << 11) | ((unint64_t)(v83 & 3) << 13) | ((unint64_t)(v83 & 3) << 15);
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        uint64_t v85 = v325;
        gleVStateProgram_MultMatrix3x3(a2, 152, 23, 23, 1, (*v325 & 0x200000000000000) != 0);
      }
      else
      {
        gleVStateProgram_MultMatrix3x3(a2, v84, 23, 23, 0, (v5 & 0x200000000000000) != 0);
        uint64_t v85 = v325;
      }
      if ((*v85 & 2) != 0)
      {
        if (!v83)
        {
          memset(&v326[2], 0, 48);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v98 = *(unsigned __int16 *)(a2 + 1946);
          if (v98 == 0xFFFF)
          {
            uint64_t v98 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v98;
            *(_WORD *)(a2 + 2004) = v98 + 1;
          }
          *(void *)&v326[1] = (v98 << 48) | 0x19C840;
          uint64_t v99 = *(unsigned __int16 *)(a2 + 1944);
          if (v99 == 0xFFFF)
          {
            uint64_t v99 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1944) = v99;
            *(_WORD *)(a2 + 2004) = v99 + 1;
          }
          uint64_t v97 = (v99 << 48) | 0x40;
          goto LABEL_166;
        }
        memset((char *)v326 + 8, 0, 72);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v89 = *(unsigned __int16 *)(a2 + 1946);
        if (v89 == 0xFFFF)
        {
          uint64_t v89 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v89;
          *(_WORD *)(a2 + 2004) = v89 + 1;
        }
        *(void *)&v326[1] = (v89 << 48) | 0x19C840;
        uint64_t v90 = *(unsigned __int16 *)(a2 + 1944);
        if (v90 == 0xFFFF)
        {
          uint64_t v90 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1944) = v90;
          *(_WORD *)(a2 + 2004) = v90 + 1;
        }
        unint64_t v88 = ((unint64_t)(v83 & 3) << 9) | (v90 << 48) | ((unint64_t)(v83 & 3) << 11) | ((unint64_t)(v83 & 3) << 13) | ((unint64_t)(v83 & 3) << 15) | 0x40;
      }
      else
      {
        if (!v83)
        {
          memset(&v326[2], 0, 48);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v96 = *(unsigned __int16 *)(a2 + 1946);
          if (v96 == 0xFFFF)
          {
            uint64_t v96 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v96;
            *(_WORD *)(a2 + 2004) = v96 + 1;
          }
          *(void *)&v326[1] = (v96 << 48) | 0x19C840;
          uint64_t v97 = gleVStateProgram_GetAttrib(a2, 4) << 48;
LABEL_166:
          *((void *)&v326[1] + 1) = v97;
          uint64_t v93 = *(unsigned __int16 *)(a2 + 1902);
          if (v93 == 0xFFFF)
          {
            uint64_t v93 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1902) = v93;
            *(_WORD *)(a2 + 2004) = v93 + 1;
          }
LABEL_168:
          uint64_t v92 = v93 << 48;
          goto LABEL_169;
        }
        memset((char *)v326 + 8, 0, 72);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v87 = *(unsigned __int16 *)(a2 + 1946);
        if (v87 == 0xFFFF)
        {
          uint64_t v87 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v87;
          *(_WORD *)(a2 + 2004) = v87 + 1;
        }
        *(void *)&v326[1] = (v87 << 48) | 0x19C840;
        unint64_t v88 = ((unint64_t)(v83 & 3) << 9) | (gleVStateProgram_GetAttrib(a2, 4) << 48) | ((unint64_t)(v83 & 3) << 11) | ((unint64_t)(v83 & 3) << 13) | ((unint64_t)(v83 & 3) << 15);
      }
      *((void *)&v326[1] + 1) = v88;
      uint64_t v91 = *(unsigned __int16 *)(a2 + 1902);
      if (v91 == 0xFFFF)
      {
        uint64_t v93 = *(unsigned __int16 *)(a2 + 2004);
        int v94 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1902) = v93;
        int v95 = v94 + 1;
        *(_WORD *)(a2 + 2004) = v95;
        *(void *)&v326[2] = ((unint64_t)(unsigned __int16)v93 << 48) | 0x19C840;
        if ((v95 & 0x10000) == 0) {
          goto LABEL_168;
        }
        uint64_t v92 = 0;
        *(_WORD *)(a2 + 1902) = v95;
        *(_WORD *)(a2 + 2004) = 1;
      }
      else
      {
        uint64_t v92 = v91 << 48;
        *(void *)&v326[2] = ((unint64_t)(unsigned __int16)v91 << 48) | 0x19C840;
      }
LABEL_169:
      *((void *)&v326[0] + 1) = v92 | 0x72679000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      ++v83;
      unint64_t v4 = v325[4];
      unint64_t v5 = *v325;
      v84 += 8;
      if (v83 >= ((unsigned __int16)WORD2(*v325) >> 8)) {
        goto LABEL_176;
      }
    }
  }
  if ((v5 & 0x10) != 0)
  {
    *((void *)&v326[4] + 1) = 0;
    *(_OWORD *)((char *)&v326[3] + 8) = 0uLL;
    *(_OWORD *)((char *)&v326[2] + 8) = 0uLL;
    *(_OWORD *)((char *)&v326[1] + 8) = 0uLL;
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 1) << 48) | 0x19C800;
    uint64_t v100 = *(unsigned __int16 *)(a2 + 1902);
    if (v100 == 0xFFFF)
    {
      uint64_t v100 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1902) = v100;
      *(_WORD *)(a2 + 2004) = v100 + 1;
    }
    *((void *)&v326[0] + 1) = (v100 << 48) | 0x72679000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
  }
  else
  {
    uint64_t result = (unint64_t *)gleVStateProgram_MultMatrix3x3(a2, 48, 1, 1, 0, (v5 & 0x200000000000000) != 0);
  }
LABEL_176:
  uint64_t v3 = v325;
  unint64_t v5 = *v325;
  if ((*v325 & 0x20) != 0)
  {
    uint64_t result = (unint64_t *)gleVStateProgram_NormalizeVector(a2, 1, 1, 23, 23);
    unint64_t v5 = *v325;
  }
  unint64_t v101 = v325[3];
  if (v101)
  {
    unsigned int v102 = HIDWORD(v101) & v101;
    if (HIDWORD(v101))
    {
      gleVStateProgram_NormalizeVector(a2, 0, 23, 27, 27);
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v103 = *(unsigned __int16 *)(a2 + 1902);
      if (v103 == 0xFFFF)
      {
        uint64_t v103 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1902) = v103;
        *(_WORD *)(a2 + 2004) = v103 + 1;
      }
      *(void *)&v326[1] = (v103 << 48) | 0x19C840;
      uint64_t v104 = *(unsigned __int16 *)(a2 + 1946);
      if (v104 == 0xFFFF)
      {
        uint64_t v104 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v104;
        *(_WORD *)(a2 + 2004) = v104 + 1;
      }
      *((void *)&v326[1] + 1) = (v104 << 48) | 0x19C840;
      uint64_t v105 = *(unsigned __int16 *)(a2 + 1954);
      if (v105 == 0xFFFF)
      {
        uint64_t v105 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v105;
        *(_WORD *)(a2 + 2004) = v105 + 1;
      }
      *((void *)&v326[0] + 1) = (v105 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset(&v326[1], 0, 64);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v106 = *(unsigned __int16 *)(a2 + 1954);
      if (v106 == 0xFFFF)
      {
        uint64_t v109 = *(unsigned __int16 *)(a2 + 2004);
        int v110 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v109;
        int v111 = v110 + 1;
        *(_WORD *)(a2 + 2004) = v110 + 1;
        unint64_t v108 = ((unint64_t)(unsigned __int16)v109 << 48) | 0x19C840;
        *(void *)&v326[1] = v108;
        if ((v111 & 0x10000) != 0)
        {
          uint64_t v107 = 0;
          *(_WORD *)(a2 + 1954) = v111;
          *(_WORD *)(a2 + 2004) = 1;
          unint64_t v108 = 1689664;
        }
        else
        {
          uint64_t v107 = v109 << 48;
        }
      }
      else
      {
        uint64_t v107 = v106 << 48;
        unint64_t v108 = ((unint64_t)(unsigned __int16)v106 << 48) | 0x19C840;
        *(void *)&v326[1] = v108;
      }
      *((void *)&v326[1] + 1) = v108;
      *((void *)&v326[0] + 1) = v107 | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset((char *)v326 + 8, 0, 72);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v112 = *(unsigned __int16 *)(a2 + 1954);
      if (v112 == 0xFFFF)
      {
        uint64_t v112 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v112;
        *(_WORD *)(a2 + 2004) = v112 + 1;
      }
      *(void *)&v326[1] = (v112 << 48) | 0x19C840;
      uint64_t v113 = *(unsigned __int16 *)(a2 + 1902);
      if (v113 == 0xFFFF)
      {
        uint64_t v113 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1902) = v113;
        *(_WORD *)(a2 + 2004) = v113 + 1;
      }
      *((void *)&v326[1] + 1) = ((v113 << 48) | 0x19C840) + 16;
      uint64_t v114 = *(unsigned __int16 *)(a2 + 1946);
      if (v114 == 0xFFFF)
      {
        uint64_t v116 = *(unsigned __int16 *)(a2 + 2004);
        int v117 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v116;
        int v118 = v117 + 1;
        *(_WORD *)(a2 + 2004) = v118;
        *(void *)&v326[2] = ((unint64_t)(unsigned __int16)v116 << 48) | 0x19C840;
        if ((v118 & 0x10000) != 0)
        {
          uint64_t v115 = 0;
          *(_WORD *)(a2 + 1946) = v118;
          *(_WORD *)(a2 + 2004) = 1;
        }
        else
        {
          uint64_t v115 = v116 << 48;
        }
      }
      else
      {
        uint64_t v115 = v114 << 48;
        *(void *)&v326[2] = ((unint64_t)(unsigned __int16)v114 << 48) | 0x19C840;
      }
      *((void *)&v326[0] + 1) = v115 | 0x72679000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      if (v102)
      {
        memset(&v326[2], 0, 48);
        char v119 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = 2;
        *(void *)&v326[0] = (8 * (v119 & 7)) | 0x3100011042;
        uint64_t v120 = *(unsigned __int16 *)(a2 + 1946);
        if (v120 == 0xFFFF)
        {
          uint64_t v120 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v120;
          *(_WORD *)(a2 + 2004) = v120 + 1;
        }
        *(void *)&v326[1] = (v120 << 48) | 0x19C840;
        *((void *)&v326[1] + 1) = 2560163840;
        uint64_t v121 = *(unsigned __int16 *)(a2 + 1954);
        if (v121 == 0xFFFF)
        {
          uint64_t v121 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v121;
          *(_WORD *)(a2 + 2004) = v121 + 1;
        }
        *((void *)&v326[0] + 1) = (v121 << 48) | 0x72679000;
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        memset((char *)v326 + 8, 0, 72);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v122 = *(unsigned __int16 *)(a2 + 1946);
        if (v122 == 0xFFFF)
        {
          uint64_t v122 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v122;
          *(_WORD *)(a2 + 2004) = v122 + 1;
        }
        *(void *)&v326[1] = (v122 << 48) | 0x19C840;
        uint64_t v123 = *(unsigned __int16 *)(a2 + 1954);
        if (v123 == 0xFFFF)
        {
          uint64_t v125 = *(unsigned __int16 *)(a2 + 2004);
          int v126 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v125;
          int v127 = v126 + 1;
          *(_WORD *)(a2 + 2004) = v127;
          *((void *)&v326[1] + 1) = ((unint64_t)(unsigned __int16)v125 << 48) | 0x19C840;
          if ((v127 & 0x10000) != 0)
          {
            uint64_t v124 = 0;
            *(_WORD *)(a2 + 1954) = v127;
            *(_WORD *)(a2 + 2004) = 1;
          }
          else
          {
            uint64_t v124 = v125 << 48;
          }
        }
        else
        {
          uint64_t v124 = v123 << 48;
          *((void *)&v326[1] + 1) = ((unint64_t)(unsigned __int16)v123 << 48) | 0x19C840;
        }
        *((void *)&v326[0] + 1) = v124 | 0x72679000;
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        memset(&v326[1], 0, 64);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v128 = *(unsigned __int16 *)(a2 + 1954);
        if (v128 == 0xFFFF)
        {
          uint64_t v131 = *(unsigned __int16 *)(a2 + 2004);
          int v132 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v131;
          int v133 = v132 + 1;
          *(_WORD *)(a2 + 2004) = v132 + 1;
          unint64_t v130 = ((unint64_t)(unsigned __int16)v131 << 48) | 0x19C840;
          *(void *)&v326[1] = v130;
          if ((v133 & 0x10000) != 0)
          {
            uint64_t v129 = 0;
            *(_WORD *)(a2 + 1954) = v133;
            *(_WORD *)(a2 + 2004) = 1;
            unint64_t v130 = 1689664;
          }
          else
          {
            uint64_t v129 = v131 << 48;
          }
        }
        else
        {
          uint64_t v129 = v128 << 48;
          unint64_t v130 = ((unint64_t)(unsigned __int16)v128 << 48) | 0x19C840;
          *(void *)&v326[1] = v130;
        }
        *((void *)&v326[1] + 1) = v130;
        *((void *)&v326[0] + 1) = v129 | 0x72679000;
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        memset(&v326[1], 0, 64);
        char v134 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = 1;
        *(void *)&v326[0] = (8 * (v134 & 7)) | 0x100100341;
        uint64_t v135 = *(unsigned __int16 *)(a2 + 1954);
        if (v135 == 0xFFFF)
        {
          uint64_t v137 = *(unsigned __int16 *)(a2 + 2004);
          int v138 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v137;
          int v139 = v138 + 1;
          *(_WORD *)(a2 + 2004) = v139;
          *(void *)&v326[1] = ((unint64_t)(unsigned __int16)v137 << 48) | 0x19C840;
          if ((v139 & 0x10000) != 0)
          {
            uint64_t v136 = 0;
            *(_WORD *)(a2 + 1954) = v139;
            *(_WORD *)(a2 + 2004) = 1;
          }
          else
          {
            uint64_t v136 = v137 << 48;
          }
        }
        else
        {
          uint64_t v136 = v135 << 48;
          *(void *)&v326[1] = ((unint64_t)(unsigned __int16)v135 << 48) | 0x19C840;
        }
        *((void *)&v326[0] + 1) = v136 | 0x72679000;
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        memset(&v326[2], 0, 48);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v140 = *(unsigned __int16 *)(a2 + 1954);
        if (v140 == 0xFFFF)
        {
          uint64_t v140 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v140;
          *(_WORD *)(a2 + 2004) = v140 + 1;
        }
        *(void *)&v326[1] = (v140 << 48) | 0x19C840;
        uint64_t v141 = *(unsigned __int16 *)(a2 + 1664);
        if (v141 == 0xFFFF)
        {
          uint64_t v142 = *(__int16 *)(a2 + 1998);
          uint64_t v141 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1664) = v142;
          *(_WORD *)(a2 + 4 * v142 + 262) = 351;
          *(_WORD *)(a2 + 1998) = v142 + 1;
          uint64_t v140 = *(unsigned __int16 *)(a2 + 1954);
        }
        *((void *)&v326[1] + 1) = (v141 << 48) | 0x80;
        if (v140 == 0xFFFF)
        {
          uint64_t v140 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v140;
          *(_WORD *)(a2 + 2004) = v140 + 1;
        }
        *((void *)&v326[0] + 1) = (v140 << 48) | 0x72679000;
        (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        memset((char *)v326 + 8, 0, 72);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v143 = *(unsigned __int16 *)(a2 + 1946);
        if (v143 == 0xFFFF)
        {
          uint64_t v143 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v143;
          *(_WORD *)(a2 + 2004) = v143 + 1;
        }
        *(void *)&v326[1] = (v143 << 48) | 0x19C840;
        uint64_t v144 = *(unsigned __int16 *)(a2 + 1954);
        if (v144 == 0xFFFF)
        {
          uint64_t v144 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v144;
          *(_WORD *)(a2 + 2004) = v144 + 1;
        }
        *((void *)&v326[1] + 1) = (v144 << 48) | 0x19C840;
        uint64_t v145 = *(unsigned __int16 *)(a2 + 1664);
        if (v145 == 0xFFFF)
        {
          uint64_t v146 = *(__int16 *)(a2 + 1998);
          uint64_t v145 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1664) = v146;
          *(_WORD *)(a2 + 4 * v146 + 262) = 351;
          *(_WORD *)(a2 + 1998) = v146 + 1;
          uint64_t v144 = *(unsigned __int16 *)(a2 + 1954);
        }
        *(void *)&v326[2] = (v145 << 48) | 0x80;
        if (v144 == 0xFFFF)
        {
          uint64_t v144 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v144;
          *(_WORD *)(a2 + 2004) = v144 + 1;
        }
        *((void *)&v326[0] + 1) = (v144 << 48) | 0x72679000;
        uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      }
    }
    uint64_t v147 = 0;
    unsigned int v148 = v102 ^ v101;
    unsigned int v149 = v102 ^ HIDWORD(v101);
    do
    {
      if (((v148 >> v147) & 0x1010101) != 0)
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v150 = *(unsigned __int16 *)(a2 + 1902);
        if (v150 == 0xFFFF)
        {
          uint64_t v150 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1902) = v150;
          *(_WORD *)(a2 + 2004) = v150 + 1;
        }
        *(void *)&v326[1] = (v150 << 48) | 0x19C840;
        uint64_t v151 = a2 + 2 * v147;
        uint64_t v152 = *(unsigned __int16 *)(v151 + 1978);
        if (v152 == 0xFFFF)
        {
          uint64_t v152 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(v151 + 1978) = v152;
          *(_WORD *)(a2 + 2004) = v152 + 1;
        }
        *((void *)&v326[0] + 1) = (((v148 >> v147) & 1) << 18) | (unint64_t)(v152 << 48) | (v148 >> v147 << 9) & 0x20000 | (unint64_t)((v148 >> v147) & 0x10000) | (v148 >> v147 >> 9) & 0x8000 | 0x72601000;
        uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      }
      if (((v149 >> v147) & 0x1010101) != 0)
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v153 = *(unsigned __int16 *)(a2 + 1946);
        if (v153 == 0xFFFF)
        {
          uint64_t v153 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v153;
          *(_WORD *)(a2 + 2004) = v153 + 1;
        }
        *(void *)&v326[1] = (v153 << 48) | 0x19C840;
        uint64_t v154 = a2 + 2 * v147;
        uint64_t v155 = *(unsigned __int16 *)(v154 + 1978);
        if (v155 == 0xFFFF)
        {
          uint64_t v155 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(v154 + 1978) = v155;
          *(_WORD *)(a2 + 2004) = v155 + 1;
        }
        *((void *)&v326[0] + 1) = (((v149 >> v147) & 1) << 18) | (unint64_t)(v155 << 48) | (v149 >> v147 << 9) & 0x20000 | (unint64_t)((v149 >> v147) & 0x10000) | (v149 >> v147 >> 9) & 0x8000 | 0x72601000;
        uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      }
      if (((v102 >> v147) & 0x1010101) != 0)
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v156 = *(unsigned __int16 *)(a2 + 1954);
        if (v156 == 0xFFFF)
        {
          uint64_t v156 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v156;
          *(_WORD *)(a2 + 2004) = v156 + 1;
        }
        *(void *)&v326[1] = (v156 << 48) | 0x19C840;
        uint64_t v157 = a2 + 2 * v147;
        uint64_t v158 = *(unsigned __int16 *)(v157 + 1978);
        if (v158 == 0xFFFF)
        {
          uint64_t v158 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(v157 + 1978) = v158;
          *(_WORD *)(a2 + 2004) = v158 + 1;
        }
        *((void *)&v326[0] + 1) = (((v102 >> v147) & 1) << 18) | (unint64_t)(v158 << 48) | (v102 >> v147 << 9) & 0x20000 | (unint64_t)((v102 >> v147) & 0x10000) | (v102 >> v147 >> 9) & 0x8000 | 0x72601000;
        uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      }
      ++v147;
    }
    while (v147 != 8);
    uint64_t v3 = v325;
    unint64_t v5 = *v325;
  }
  if ((v5 & 0x100) != 0) {
    goto LABEL_259;
  }
LABEL_263:
  unint64_t v159 = *v3;
  if ((*v3 & 0x1000) == 0) {
    goto LABEL_267;
  }
  memset((char *)&v326[1] + 8, 0, 56);
  *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
  *(_DWORD *)(a2 + 16) = 1;
  *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
  uint64_t v160 = *(unsigned __int16 *)(a2 + 1704);
  if (v160 == 0xFFFF)
  {
    uint64_t v161 = *(__int16 *)(a2 + 2000);
    uint64_t v160 = *(unsigned __int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1704) = v161;
    *(_WORD *)(a2 + 4 * v161 + 1694) = 3;
    *(_WORD *)(a2 + 2000) = v161 + 1;
  }
  *((void *)&v326[0] + 1) = ((v160 << 48) | 0x72679000) + 0x2000;
  uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
  unint64_t v159 = *v3;
  if ((*v3 & 0x1000000000000) != 0)
  {
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v166 = *(unsigned __int16 *)(a2 + 1708);
    if (v166 == 0xFFFF)
    {
      uint64_t v167 = *(__int16 *)(a2 + 2000);
      uint64_t v166 = *(unsigned __int16 *)(a2 + 2000);
      *(_WORD *)(a2 + 1708) = v167;
      *(_WORD *)(a2 + 4 * v167 + 1694) = 4;
      *(_WORD *)(a2 + 2000) = v167 + 1;
    }
    *((void *)&v326[0] + 1) = ((v166 << 48) | 0x72679000) + 0x2000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    unint64_t v163 = v3[3];
    unint64_t v162 = v3[4];
    unint64_t v164 = v3[1];
    unint64_t v165 = v3[2];
    unint64_t v159 = *v3;
    if ((*v3 & 0x2000) == 0)
    {
LABEL_276:
      if ((v159 & 0x4000) == 0) {
        goto LABEL_277;
      }
      goto LABEL_282;
    }
  }
  else
  {
LABEL_267:
    unint64_t v163 = v3[3];
    unint64_t v162 = v3[4];
    unint64_t v164 = v3[1];
    unint64_t v165 = v3[2];
    if ((v159 & 0x2000) == 0) {
      goto LABEL_276;
    }
  }
  memset((char *)&v326[1] + 8, 0, 56);
  *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
  *(_DWORD *)(a2 + 16) = 1;
  *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 3) << 48) | 0x19C800;
  uint64_t v168 = *(unsigned __int16 *)(a2 + 1712);
  if (v168 == 0xFFFF)
  {
    uint64_t v169 = *(__int16 *)(a2 + 2000);
    uint64_t v168 = *(unsigned __int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1712) = v169;
    *(_WORD *)(a2 + 4 * v169 + 1694) = 5;
    *(_WORD *)(a2 + 2000) = v169 + 1;
  }
  *((void *)&v326[0] + 1) = ((v168 << 48) | 0x72679000) + 0x2000;
  uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
  unint64_t v159 = *v3;
  if ((*v3 & 0x1000000000000) == 0)
  {
    unint64_t v163 = v3[3];
    unint64_t v162 = v3[4];
    unint64_t v164 = v3[1];
    unint64_t v165 = v3[2];
    goto LABEL_276;
  }
  memset((char *)&v326[1] + 8, 0, 56);
  *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
  *(_DWORD *)(a2 + 16) = 1;
  *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 3) << 48) | 0x19C800;
  uint64_t v170 = *(unsigned __int16 *)(a2 + 1716);
  if (v170 == 0xFFFF)
  {
    uint64_t v171 = *(__int16 *)(a2 + 2000);
    uint64_t v170 = *(unsigned __int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1716) = v171;
    *(_WORD *)(a2 + 4 * v171 + 1694) = 6;
    *(_WORD *)(a2 + 2000) = v171 + 1;
  }
  *((void *)&v326[0] + 1) = ((v170 << 48) | 0x72679000) + 0x2000;
  uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
  unint64_t v163 = v3[3];
  unint64_t v162 = v3[4];
  unint64_t v164 = v3[1];
  unint64_t v165 = v3[2];
  unint64_t v159 = *v3;
  if ((*v3 & 0x4000) == 0)
  {
LABEL_277:
    if ((v159 & 0x800) == 0) {
      goto LABEL_513;
    }
    goto LABEL_512;
  }
LABEL_282:
  if ((v162 & 0x40) != 0 || (v164 & 0xC0000000) == 0xC0000000)
  {
    memset(&v326[1], 0, 64);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v172 = *(unsigned __int16 *)(a2 + 1900);
    if (v172 == 0xFFFF)
    {
      uint64_t v176 = *(unsigned __int16 *)(a2 + 2004);
      int v177 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v176;
      int v178 = v177 + 1;
      *(_WORD *)(a2 + 2004) = v178;
      uint64_t v173 = (v176 << 48) | 0x19C840;
      *(void *)&v326[1] = v173;
      if ((v178 & 0x10000) != 0)
      {
        *(_WORD *)(a2 + 1900) = v178;
        *(_WORD *)(a2 + 2004) = 1;
        uint64_t v173 = 1689664;
      }
    }
    else
    {
      uint64_t v173 = (v172 << 48) | 0x19C840;
      *(void *)&v326[1] = v173;
    }
    *((void *)&v326[1] + 1) = v173;
    uint64_t v179 = *(unsigned __int16 *)(a2 + 1946);
    if (v179 == 0xFFFF)
    {
      uint64_t v179 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v179;
      *(_WORD *)(a2 + 2004) = v179 + 1;
    }
    *((void *)&v326[0] + 1) = (v179 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    unint64_t v180 = *v3;
    memset(&v326[1], 0, 64);
    uint64_t v181 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    *(_DWORD *)(a2 + 16) = 1;
    if ((v180 & 0x1000000000000000) != 0)
    {
      uint64_t v184 = 0x100100301;
    }
    else
    {
      *(void *)&v326[0] = v181 | 0x100100341;
      uint64_t v182 = *(unsigned __int16 *)(a2 + 1946);
      if (v182 == 0xFFFF)
      {
        uint64_t v185 = *(unsigned __int16 *)(a2 + 2004);
        int v186 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v185;
        int v187 = v186 + 1;
        *(_WORD *)(a2 + 2004) = v187;
        *(void *)&v326[1] = ((unint64_t)(unsigned __int16)v185 << 48) | 0x19C840;
        if ((v187 & 0x10000) != 0)
        {
          uint64_t v183 = 0;
          *(_WORD *)(a2 + 1946) = v187;
          *(_WORD *)(a2 + 2004) = 1;
        }
        else
        {
          uint64_t v183 = v185 << 48;
        }
      }
      else
      {
        uint64_t v183 = v182 << 48;
        *(void *)&v326[1] = ((unint64_t)(unsigned __int16)v182 << 48) | 0x19C840;
      }
      *((void *)&v326[0] + 1) = v183 | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset((char *)&v326[1] + 8, 0, 56);
      uint64_t v181 = 8 * (*(_DWORD *)(a2 + 16) & 7);
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v184 = 0x100100381;
    }
    *(void *)&v326[0] = v181 | v184;
    uint64_t v188 = *(unsigned __int16 *)(a2 + 1946);
    if (v188 == 0xFFFF)
    {
      uint64_t v188 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v188;
      *(_WORD *)(a2 + 2004) = v188 + 1;
    }
    *(void *)&v326[1] = (v188 << 48) | 0x19C840;
    uint64_t v189 = *(unsigned __int16 *)(a2 + 1962);
    if (v189 == 0xFFFF)
    {
      uint64_t v189 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1962) = v189;
      *(_WORD *)(a2 + 2004) = v189 + 1;
    }
    *((void *)&v326[0] + 1) = (v189 << 48) | 0x72679000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    unint64_t v162 = v3[4];
    unint64_t v159 = *v3;
    unint64_t v164 = v3[1];
  }
  if ((v162 & 0x40) != 0)
  {
    memset((char *)v326 + 8, 0, 72);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v193 = *(unsigned __int16 *)(a2 + 1962);
    if (v193 == 0xFFFF)
    {
      uint64_t v193 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1962) = v193;
      *(_WORD *)(a2 + 2004) = v193 + 1;
    }
    *(void *)&v326[1] = (v193 << 48) | 0x19C840;
    uint64_t v194 = *(unsigned __int16 *)(a2 + 1648);
    if (v194 == 0xFFFF)
    {
      uint64_t v196 = *(__int16 *)(a2 + 1998);
      int v197 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1648) = v196;
      *(_WORD *)(a2 + 4 * v196 + 262) = 347;
      int v198 = v197 + 1;
      *(_WORD *)(a2 + 1998) = v198;
      *((void *)&v326[1] + 1) = ((unint64_t)(unsigned __int16)v196 << 48) | 0x15480;
      if ((v198 & 0x10000) != 0)
      {
        uint64_t v195 = 0;
        *(_WORD *)(a2 + 1648) = v198;
        *(_WORD *)(a2 + 4 * (unsigned __int16)v198 + 262) = 347;
        *(_WORD *)(a2 + 1998) = 1;
      }
      else
      {
        uint64_t v195 = v196 << 48;
      }
    }
    else
    {
      uint64_t v195 = v194 << 48;
      *((void *)&v326[1] + 1) = ((unint64_t)(unsigned __int16)v194 << 48) | 0x15480;
    }
    *(void *)&v326[2] = v195 | 0xAA80;
    uint64_t v202 = *(unsigned __int16 *)(a2 + 1954);
    if (v202 == 0xFFFF)
    {
      uint64_t v202 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v202;
      *(_WORD *)(a2 + 2004) = v202 + 1;
    }
    *((void *)&v326[0] + 1) = (v202 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset((char *)v326 + 8, 0, 72);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v203 = *(unsigned __int16 *)(a2 + 1962);
    if (v203 == 0xFFFF)
    {
      uint64_t v203 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1962) = v203;
      *(_WORD *)(a2 + 2004) = v203 + 1;
    }
    *(void *)&v326[1] = (v203 << 48) | 0x19C840;
    uint64_t v204 = *(unsigned __int16 *)(a2 + 1954);
    if (v204 == 0xFFFF)
    {
      uint64_t v204 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v204;
      *(_WORD *)(a2 + 2004) = v204 + 1;
    }
    *((void *)&v326[1] + 1) = (v204 << 48) | 0x19C840;
    uint64_t v205 = *(unsigned __int16 *)(a2 + 1648);
    if (v205 == 0xFFFF)
    {
      uint64_t v206 = *(__int16 *)(a2 + 1998);
      uint64_t v205 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1648) = v206;
      *(_WORD *)(a2 + 4 * v206 + 262) = 347;
      *(_WORD *)(a2 + 1998) = v206 + 1;
      uint64_t v204 = *(unsigned __int16 *)(a2 + 1954);
    }
    *(void *)&v326[2] = ((v205 << 48) | 0x19C840) + 64;
    if (v204 == 0xFFFF)
    {
      uint64_t v204 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v204;
      *(_WORD *)(a2 + 2004) = v204 + 1;
    }
    *((void *)&v326[0] + 1) = (v204 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset((char *)&v326[1] + 8, 0, 56);
    char v207 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 1;
    *(void *)&v326[0] = (8 * (v207 & 7)) | 0x100100341;
    uint64_t v208 = *(unsigned __int16 *)(a2 + 1954);
    if (v208 == 0xFFFF)
    {
      uint64_t v208 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v208;
      *(_WORD *)(a2 + 2004) = v208 + 1;
    }
    *(void *)&v326[1] = (v208 << 48) | 0x19C840;
    uint64_t v209 = *(unsigned __int16 *)(a2 + 1946);
    if (v209 == 0xFFFF)
    {
      uint64_t v209 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v209;
      *(_WORD *)(a2 + 2004) = v209 + 1;
    }
    *((void *)&v326[0] + 1) = (v209 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset((char *)v326 + 8, 0, 72);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v210 = *(unsigned __int16 *)(a2 + 1946);
    if (v210 == 0xFFFF)
    {
      uint64_t v210 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v210;
      *(_WORD *)(a2 + 2004) = v210 + 1;
    }
    *(void *)&v326[1] = (v210 << 48) | 0x19C840;
    if ((v3[4] & 0x20) != 0)
    {
      uint64_t v213 = gleVStateProgram_GetAttrib(a2, 6) << 48;
    }
    else
    {
      uint64_t v211 = *(unsigned __int16 *)(a2 + 1652);
      if (v211 == 0xFFFF)
      {
        uint64_t v212 = *(__int16 *)(a2 + 1998);
        uint64_t v211 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1652) = v212;
        *(_WORD *)(a2 + 4 * v212 + 262) = 348;
        *(_WORD *)(a2 + 1998) = v212 + 1;
      }
      uint64_t v213 = ((v211 << 48) | 0x19C840) + 64;
    }
    *((void *)&v326[1] + 1) = v213;
    uint64_t v214 = *(unsigned __int16 *)(a2 + 1946);
    if (v214 == 0xFFFF)
    {
      uint64_t v214 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v214;
      *(_WORD *)(a2 + 2004) = v214 + 1;
    }
    *((void *)&v326[0] + 1) = (v214 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B42;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v215 = *(unsigned __int16 *)(a2 + 1946);
    if (v215 == 0xFFFF)
    {
      uint64_t v215 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v215;
      *(_WORD *)(a2 + 2004) = v215 + 1;
    }
    *(void *)&v326[1] = (v215 << 48) | 0x19C840;
    uint64_t v216 = *(unsigned __int16 *)(a2 + 1652);
    if (v216 == 0xFFFF)
    {
      uint64_t v217 = *(__int16 *)(a2 + 1998);
      uint64_t v216 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1652) = v217;
      *(_WORD *)(a2 + 4 * v217 + 262) = 348;
      *(_WORD *)(a2 + 1998) = v217 + 1;
      uint64_t v215 = *(unsigned __int16 *)(a2 + 1946);
    }
    *((void *)&v326[1] + 1) = (v216 << 48) | 0xAA80;
    if (v215 == 0xFFFF)
    {
      uint64_t v215 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v215;
      *(_WORD *)(a2 + 2004) = v215 + 1;
    }
    *((void *)&v326[0] + 1) = (v215 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B02;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v218 = *(unsigned __int16 *)(a2 + 1946);
    if (v218 == 0xFFFF)
    {
      uint64_t v218 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v218;
      *(_WORD *)(a2 + 2004) = v218 + 1;
    }
    *(void *)&v326[1] = (v218 << 48) | 0x19C840;
    uint64_t v219 = *(unsigned __int16 *)(a2 + 1652);
    if (v219 == 0xFFFF)
    {
      uint64_t v220 = *(__int16 *)(a2 + 1998);
      uint64_t v219 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1652) = v220;
      *(_WORD *)(a2 + 4 * v220 + 262) = 348;
      *(_WORD *)(a2 + 1998) = v220 + 1;
    }
    *((void *)&v326[1] + 1) = (v219 << 48) | 0x15480;
  }
  else
  {
    if ((v162 & 0x80) == 0) {
      goto LABEL_366;
    }
    if ((v162 & 0x800) != 0)
    {
      memset((char *)v326 + 8, 0, 72);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
      *(_DWORD *)(a2 + 16) = 2;
      if ((v3[4] & 0x20) != 0)
      {
        uint64_t v201 = gleVStateProgram_GetAttrib(a2, 6) << 48;
      }
      else
      {
        uint64_t v199 = *(unsigned __int16 *)(a2 + 1652);
        if (v199 == 0xFFFF)
        {
          uint64_t v200 = *(__int16 *)(a2 + 1998);
          uint64_t v199 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1652) = v200;
          *(_WORD *)(a2 + 4 * v200 + 262) = 348;
          *(_WORD *)(a2 + 1998) = v200 + 1;
        }
        uint64_t v201 = ((v199 << 48) | 0x19C840) + 64;
      }
      *(void *)&v326[1] = v201;
      uint64_t v266 = *(unsigned __int16 *)(a2 + 1664);
      if (v266 == 0xFFFF)
      {
        uint64_t v267 = *(__int16 *)(a2 + 1998);
        uint64_t v266 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1664) = v267;
        *(_WORD *)(a2 + 4 * v267 + 262) = 351;
        *(_WORD *)(a2 + 1998) = v267 + 1;
      }
      *((void *)&v326[1] + 1) = (v266 << 48) | 0x15480;
      uint64_t v268 = *(unsigned __int16 *)(a2 + 1946);
      if (v268 == 0xFFFF)
      {
        uint64_t v268 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v268;
        *(_WORD *)(a2 + 2004) = v268 + 1;
      }
      *((void *)&v326[0] + 1) = (v268 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset((char *)&v326[1] + 8, 0, 56);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v269 = *(unsigned __int16 *)(a2 + 1946);
      if (v269 == 0xFFFF)
      {
        uint64_t v269 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v269;
        *(_WORD *)(a2 + 2004) = v269 + 1;
      }
      *(void *)&v326[1] = (v269 << 48) | 0x19C840;
      uint64_t v270 = *(unsigned __int16 *)(a2 + 1700);
      if (v270 == 0xFFFF)
      {
        uint64_t v271 = *(__int16 *)(a2 + 2000);
        uint64_t v270 = *(unsigned __int16 *)(a2 + 2000);
        *(_WORD *)(a2 + 1700) = v271;
        *(_WORD *)(a2 + 4 * v271 + 1694) = 2;
        *(_WORD *)(a2 + 2000) = v271 + 1;
      }
      uint64_t v223 = (v270 << 48) | 0x72643000;
      goto LABEL_365;
    }
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    if ((v3[4] & 0x20) != 0)
    {
      uint64_t v192 = gleVStateProgram_GetAttrib(a2, 6) << 48;
    }
    else
    {
      uint64_t v190 = *(unsigned __int16 *)(a2 + 1652);
      if (v190 == 0xFFFF)
      {
        uint64_t v191 = *(__int16 *)(a2 + 1998);
        uint64_t v190 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1652) = v191;
        *(_WORD *)(a2 + 4 * v191 + 262) = 348;
        *(_WORD *)(a2 + 1998) = v191 + 1;
      }
      uint64_t v192 = ((v190 << 48) | 0x19C840) + 64;
    }
    *(void *)&v326[1] = v192;
  }
  uint64_t v221 = *(unsigned __int16 *)(a2 + 1700);
  if (v221 == 0xFFFF)
  {
    uint64_t v222 = *(__int16 *)(a2 + 2000);
    uint64_t v221 = *(unsigned __int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1700) = v222;
    *(_WORD *)(a2 + 4 * v222 + 1694) = 2;
    *(_WORD *)(a2 + 2000) = v222 + 1;
  }
  uint64_t v223 = (v221 << 48) | 0x72643000;
LABEL_365:
  *((void *)&v326[0] + 1) = v223;
  uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
  *(_DWORD *)(a2 + 2032) |= 2u;
  unint64_t v162 = v3[4];
  unint64_t v159 = *v3;
  unint64_t v164 = v3[1];
LABEL_366:
  if ((v162 & 2) != 0)
  {
    unsigned int v228 = v164 >> 30;
    if (v228 == 2)
    {
      memset((char *)&v326[1] + 8, 0, 56);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v230 = *(unsigned __int16 *)(a2 + 1900);
      if (v230 == 0xFFFF)
      {
        uint64_t v230 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v230;
        *(_WORD *)(a2 + 2004) = v230 + 1;
      }
      uint64_t v231 = (v230 << 48) | 0x15440;
    }
    else
    {
      if (v228 == 1)
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        *(void *)&v326[1] = gleVStateProgram_GetAttrib(a2, 5) << 48;
        uint64_t v229 = *(unsigned __int16 *)(a2 + 1970);
        goto LABEL_383;
      }
      memset((char *)&v326[1] + 8, 0, 56);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v232 = *(unsigned __int16 *)(a2 + 1962);
      if (v232 == 0xFFFF)
      {
        uint64_t v232 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1962) = v232;
        *(_WORD *)(a2 + 2004) = v232 + 1;
      }
      uint64_t v231 = (v232 << 48) | 0x19C840;
    }
    *(void *)&v326[1] = v231;
    uint64_t v229 = *(unsigned __int16 *)(a2 + 1970);
LABEL_383:
    if (v229 == 0xFFFF)
    {
      uint64_t v229 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1970) = v229;
      *(_WORD *)(a2 + 2004) = v229 + 1;
    }
    *((void *)&v326[0] + 1) = (v229 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    unint64_t v233 = v3[4];
    if (v233)
    {
      memset((char *)&v326[1] + 8, 0, 56);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v234 = *(unsigned __int16 *)(a2 + 1970);
      if (v234 == 0xFFFF)
      {
        uint64_t v234 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v234;
        *(_WORD *)(a2 + 2004) = v234 + 1;
      }
      *(void *)&v326[1] = (v234 << 48) | 0x19C840;
      uint64_t v235 = *(unsigned __int16 *)(a2 + 1696);
      if (v235 == 0xFFFF)
      {
        uint64_t v236 = *(__int16 *)(a2 + 2000);
        uint64_t v235 = *(unsigned __int16 *)(a2 + 2000);
        *(_WORD *)(a2 + 1696) = v236;
        *(_WORD *)(a2 + 4 * v236 + 1694) = 1;
        *(_WORD *)(a2 + 2000) = v236 + 1;
      }
      *((void *)&v326[0] + 1) = (v235 << 48) | 0x72643000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      unint64_t v233 = v3[4];
    }
    unsigned int v237 = (v233 >> 2) & 3;
    if (v237 == 2)
    {
      if ((v233 & 0x10) != 0)
      {
        memset(&v326[2], 0, 48);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B42;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v258 = *(unsigned __int16 *)(a2 + 1970);
        if (v258 == 0xFFFF)
        {
          uint64_t v258 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v258;
          *(_WORD *)(a2 + 2004) = v258 + 1;
        }
        *(void *)&v326[1] = (v258 << 48) | 0x40;
        uint64_t v259 = *(unsigned __int16 *)(a2 + 1664);
        if (v259 == 0xFFFF)
        {
          uint64_t v260 = *(__int16 *)(a2 + 1998);
          uint64_t v259 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1664) = v260;
          *(_WORD *)(a2 + 4 * v260 + 262) = 351;
          *(_WORD *)(a2 + 1998) = v260 + 1;
        }
        *((void *)&v326[1] + 1) = (v259 << 48) | 0xAA80;
        uint64_t v244 = *(unsigned __int16 *)(a2 + 1954);
      }
      else
      {
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000081;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v243 = *(unsigned __int16 *)(a2 + 1970);
        if (v243 == 0xFFFF)
        {
          uint64_t v243 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v243;
          *(_WORD *)(a2 + 2004) = v243 + 1;
        }
        *(void *)&v326[1] = (v243 << 48) | 0x40;
        uint64_t v244 = *(unsigned __int16 *)(a2 + 1954);
      }
      if (v244 == 0xFFFF)
      {
        uint64_t v244 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v244;
        *(_WORD *)(a2 + 2004) = v244 + 1;
      }
      *((void *)&v326[0] + 1) = (v244 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v261 = *(unsigned __int16 *)(a2 + 1954);
      if (v261 == 0xFFFF)
      {
        uint64_t v261 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v261;
        *(_WORD *)(a2 + 2004) = v261 + 1;
      }
      *(void *)&v326[1] = (v261 << 48) | 0x19C840;
      uint64_t v262 = *(unsigned __int16 *)(a2 + 1660);
      if (v262 == 0xFFFF)
      {
        uint64_t v263 = *(__int16 *)(a2 + 1998);
        uint64_t v262 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1660) = v263;
        *(_WORD *)(a2 + 4 * v263 + 262) = 350;
        *(_WORD *)(a2 + 1998) = v263 + 1;
        uint64_t v261 = *(unsigned __int16 *)(a2 + 1954);
      }
      *((void *)&v326[1] + 1) = (v262 << 48) | 0x80;
      if (v261 == 0xFFFF)
      {
        uint64_t v261 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v261;
        *(_WORD *)(a2 + 2004) = v261 + 1;
      }
      *((void *)&v326[0] + 1) = (v261 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset((char *)&v326[1] + 8, 0, 56);
      char v264 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 1;
      *(void *)&v326[0] = (8 * (v264 & 7)) | 0x100000401;
      uint64_t v265 = *(unsigned __int16 *)(a2 + 1954);
      if (v265 == 0xFFFF)
      {
        uint64_t v265 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v265;
        *(_WORD *)(a2 + 2004) = v265 + 1;
      }
      *(void *)&v326[1] = (v265 << 48) | 0x50;
      goto LABEL_474;
    }
    if (v237 != 1)
    {
      memset(&v326[2], 0, 48);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v245 = *(unsigned __int16 *)(a2 + 1970);
      if (v245 == 0xFFFF)
      {
        uint64_t v245 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v245;
        *(_WORD *)(a2 + 2004) = v245 + 1;
      }
      *(void *)&v326[1] = (v245 << 48) | 0x40;
      uint64_t v246 = *(unsigned __int16 *)(a2 + 1660);
      if (v246 == 0xFFFF)
      {
        uint64_t v247 = *(__int16 *)(a2 + 1998);
        uint64_t v246 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1660) = v247;
        *(_WORD *)(a2 + 4 * v247 + 262) = 350;
        *(_WORD *)(a2 + 1998) = v247 + 1;
      }
      *((void *)&v326[1] + 1) = (v246 << 48) | 0xAA80;
      uint64_t v248 = *(unsigned __int16 *)(a2 + 1954);
      if (v248 == 0xFFFF)
      {
        uint64_t v248 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v248;
        *(_WORD *)(a2 + 2004) = v248 + 1;
      }
      *((void *)&v326[0] + 1) = (v248 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset(&v326[1], 0, 64);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v249 = *(unsigned __int16 *)(a2 + 1954);
      if (v249 == 0xFFFF)
      {
        uint64_t v272 = *(unsigned __int16 *)(a2 + 2004);
        int v273 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v272;
        int v274 = v273 + 1;
        *(_WORD *)(a2 + 2004) = v273 + 1;
        unint64_t v251 = ((unint64_t)(unsigned __int16)v272 << 48) | 0x19C840;
        *(void *)&v326[1] = v251;
        if ((v274 & 0x10000) != 0)
        {
          uint64_t v250 = 0;
          *(_WORD *)(a2 + 1954) = v274;
          *(_WORD *)(a2 + 2004) = 1;
          unint64_t v251 = 1689664;
        }
        else
        {
          uint64_t v250 = v272 << 48;
        }
      }
      else
      {
        uint64_t v250 = v249 << 48;
        unint64_t v251 = ((unint64_t)(unsigned __int16)v249 << 48) | 0x19C840;
        *(void *)&v326[1] = v251;
      }
      *((void *)&v326[1] + 1) = v251;
      *((void *)&v326[0] + 1) = v250 | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      memset((char *)&v326[1] + 8, 0, 56);
      char v288 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 1;
      *(void *)&v326[0] = (8 * (v288 & 7)) | 0x100000401;
      uint64_t v289 = *(unsigned __int16 *)(a2 + 1954);
      if (v289 == 0xFFFF)
      {
        uint64_t v289 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v289;
        *(_WORD *)(a2 + 2004) = v289 + 1;
      }
      *(void *)&v326[1] = (v289 << 48) | 0x50;
      uint64_t v255 = *(unsigned __int16 *)(a2 + 1696);
      if (v255 == 0xFFFF)
      {
        uint64_t v290 = *(__int16 *)(a2 + 2000);
        uint64_t v255 = *(unsigned __int16 *)(a2 + 2000);
        *(_WORD *)(a2 + 1696) = v290;
        *(_WORD *)(a2 + 4 * v290 + 1694) = 1;
        *(_WORD *)(a2 + 2000) = v290 + 1;
      }
      uint64_t v257 = 1919037440;
      goto LABEL_484;
    }
    if ((v233 & 0x10) == 0)
    {
      memset((char *)&v326[1] + 8, 0, 56);
      *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000081;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v238 = *(unsigned __int16 *)(a2 + 1970);
      if (v238 == 0xFFFF)
      {
        uint64_t v238 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v238;
        *(_WORD *)(a2 + 2004) = v238 + 1;
      }
      *(void *)&v326[1] = (v238 << 48) | 0x40;
      uint64_t v239 = *(unsigned __int16 *)(a2 + 1954);
      if (v239 == 0xFFFF)
      {
        uint64_t v239 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v239;
        *(_WORD *)(a2 + 2004) = v239 + 1;
      }
      *((void *)&v326[0] + 1) = (v239 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    }
    memset((char *)v326 + 8, 0, 72);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    if ((v3[4] & 0x10) != 0)
    {
      uint64_t v240 = *(unsigned __int16 *)(a2 + 1970);
      if (v240 == 0xFFFF)
      {
        __n128 v242 = (_WORD *)(a2 + 2004);
        uint64_t v240 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v240;
        uint64_t v241 = 64;
        goto LABEL_456;
      }
      uint64_t v241 = 64;
    }
    else
    {
      uint64_t v240 = *(unsigned __int16 *)(a2 + 1954);
      uint64_t v241 = 1689664;
      if (v240 == 0xFFFF)
      {
        __n128 v242 = (_WORD *)(a2 + 2004);
        uint64_t v240 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v240;
        uint64_t v241 = 1689664;
LABEL_456:
        *__n128 v242 = v240 + 1;
      }
    }
    *(void *)&v326[1] = v241 | (v240 << 48) | 0x10;
    uint64_t v275 = *(unsigned __int16 *)(a2 + 1656);
    if (v275 == 0xFFFF)
    {
      uint64_t v276 = *(__int16 *)(a2 + 1998);
      uint64_t v275 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1656) = v276;
      *(_WORD *)(a2 + 4 * v276 + 262) = 349;
      *(_WORD *)(a2 + 1998) = v276 + 1;
    }
    *((void *)&v326[1] + 1) = (v275 << 48) | 0x1FE80;
    uint64_t v277 = *(unsigned __int16 *)(a2 + 1660);
    if (v277 == 0xFFFF)
    {
      uint64_t v278 = *(__int16 *)(a2 + 1998);
      uint64_t v277 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1660) = v278;
      *(_WORD *)(a2 + 4 * v278 + 262) = 350;
      *(_WORD *)(a2 + 1998) = v278 + 1;
    }
    *(void *)&v326[2] = (v277 << 48) | 0x1FE80;
    uint64_t v279 = *(unsigned __int16 *)(a2 + 1954);
    if (v279 == 0xFFFF)
    {
      uint64_t v279 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v279;
      *(_WORD *)(a2 + 2004) = v279 + 1;
    }
    *((void *)&v326[0] + 1) = (v279 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset(&v326[2], 0, 48);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B42;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v280 = *(unsigned __int16 *)(a2 + 1954);
    if (v280 == 0xFFFF)
    {
      uint64_t v280 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v280;
      *(_WORD *)(a2 + 2004) = v280 + 1;
    }
    *(void *)&v326[1] = (v280 << 48) | 0x19C840;
    uint64_t v281 = *(unsigned __int16 *)(a2 + 1664);
    if (v281 == 0xFFFF)
    {
      uint64_t v282 = *(__int16 *)(a2 + 1998);
      uint64_t v281 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1664) = v282;
      *(_WORD *)(a2 + 4 * v282 + 262) = 351;
      *(_WORD *)(a2 + 1998) = v282 + 1;
      uint64_t v280 = *(unsigned __int16 *)(a2 + 1954);
    }
    *((void *)&v326[1] + 1) = (v281 << 48) | 0xAA80;
    if (v280 == 0xFFFF)
    {
      uint64_t v280 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v280;
      *(_WORD *)(a2 + 2004) = v280 + 1;
    }
    *((void *)&v326[0] + 1) = (v280 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    memset(&v326[2], 0, 48);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B02;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v283 = *(unsigned __int16 *)(a2 + 1954);
    if (v283 == 0xFFFF)
    {
      uint64_t v283 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v283;
      *(_WORD *)(a2 + 2004) = v283 + 1;
    }
    *(void *)&v326[1] = (v283 << 48) | 0x19C840;
    uint64_t v284 = *(unsigned __int16 *)(a2 + 1664);
    if (v284 == 0xFFFF)
    {
      uint64_t v285 = *(__int16 *)(a2 + 1998);
      uint64_t v284 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1664) = v285;
      *(_WORD *)(a2 + 4 * v285 + 262) = 351;
      *(_WORD *)(a2 + 1998) = v285 + 1;
    }
    *((void *)&v326[1] + 1) = (v284 << 48) | 0x15480;
LABEL_474:
    uint64_t v225 = *(unsigned __int16 *)(a2 + 1696);
    if (v225 == 0xFFFF)
    {
      uint64_t v286 = *(__int16 *)(a2 + 2000);
      uint64_t v225 = *(unsigned __int16 *)(a2 + 2000);
      *(_WORD *)(a2 + 1696) = v286;
      *(_WORD *)(a2 + 4 * v286 + 1694) = 1;
      *(_WORD *)(a2 + 2000) = v286 + 1;
    }
    uint64_t v227 = 1919037440;
    goto LABEL_477;
  }
  if ((v162 & 1) == 0) {
    goto LABEL_486;
  }
  unsigned int v224 = v164 >> 30;
  if (v224 == 3)
  {
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v252 = *(unsigned __int16 *)(a2 + 1962);
    if (v252 == 0xFFFF)
    {
      uint64_t v252 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1962) = v252;
      *(_WORD *)(a2 + 2004) = v252 + 1;
    }
    uint64_t v253 = (v252 << 48) | 0x19C840;
    goto LABEL_420;
  }
  if (v224 != 1)
  {
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v254 = *(unsigned __int16 *)(a2 + 1900);
    if (v254 == 0xFFFF)
    {
      uint64_t v254 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v254;
      *(_WORD *)(a2 + 2004) = v254 + 1;
    }
    uint64_t v253 = (v254 << 48) | 0x15440;
LABEL_420:
    *(void *)&v326[1] = v253;
    uint64_t v255 = *(unsigned __int16 *)(a2 + 1696);
    if (v255 == 0xFFFF)
    {
      uint64_t v256 = *(__int16 *)(a2 + 2000);
      uint64_t v255 = *(unsigned __int16 *)(a2 + 2000);
      *(_WORD *)(a2 + 1696) = v256;
      *(_WORD *)(a2 + 4 * v256 + 1694) = 1;
      *(_WORD *)(a2 + 2000) = v256 + 1;
    }
    uint64_t v257 = 1919168512;
LABEL_484:
    uint64_t v287 = v257 | (v255 << 48);
    goto LABEL_485;
  }
  memset((char *)&v326[1] + 8, 0, 56);
  *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
  *(_DWORD *)(a2 + 16) = 1;
  *(void *)&v326[1] = gleVStateProgram_GetAttrib(a2, 5) << 48;
  uint64_t v225 = *(unsigned __int16 *)(a2 + 1696);
  if (v225 == 0xFFFF)
  {
    uint64_t v226 = *(__int16 *)(a2 + 2000);
    uint64_t v225 = *(unsigned __int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1696) = v226;
    *(_WORD *)(a2 + 4 * v226 + 1694) = 1;
    *(_WORD *)(a2 + 2000) = v226 + 1;
  }
  uint64_t v227 = 1919168512;
LABEL_477:
  uint64_t v287 = v227 | (v225 << 48);
LABEL_485:
  *((void *)&v326[0] + 1) = v287;
  uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
  unint64_t v159 = *v3;
  unint64_t v164 = v3[1];
LABEL_486:
  if ((v159 & 0x4000000000000000) != 0)
  {
    memset((char *)&v326[1] + 8, 0, 56);
    *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v291 = *(unsigned __int16 *)(a2 + 1900);
    if (v291 == 0xFFFF)
    {
      uint64_t v291 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v291;
      *(_WORD *)(a2 + 2004) = v291 + 1;
    }
    *(void *)&v326[1] = (v291 << 48) | 0x19C840;
    uint64_t v292 = *(unsigned __int16 *)(a2 + 1880);
    if (v292 == 0xFFFF)
    {
      uint64_t v293 = *(__int16 *)(a2 + 2000);
      uint64_t v292 = *(unsigned __int16 *)(a2 + 2000);
      *(_WORD *)(a2 + 1880) = v293;
      *(_WORD *)(a2 + 4 * v293 + 1694) = 47;
      *(_WORD *)(a2 + 2000) = v293 + 1;
    }
    *((void *)&v326[0] + 1) = ((v292 << 48) | 0x72679000) + 0x2000;
    uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
    unint64_t v159 = *v3;
    unint64_t v164 = v3[1];
  }
  if ((v164 & 0x3F000000) != 0)
  {
    if ((v159 & 0x40) != 0)
    {
      uint64_t v299 = 0;
      uint64_t v300 = 1668;
      do
      {
        if (((1 << v299) & *(_DWORD *)((unsigned char *)v325 + 11) & 0x3F) != 0)
        {
          memset(&v326[2], 0, 48);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A42;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v301 = *(unsigned __int16 *)(a2 + 1900);
          if (v301 == 0xFFFF)
          {
            uint64_t v301 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1900) = v301;
            *(_WORD *)(a2 + 2004) = v301 + 1;
          }
          *(void *)&v326[1] = (v301 << 48) | 0x19C840;
          uint64_t v302 = *(unsigned __int16 *)(a2 + v300);
          if (v302 == 0xFFFF)
          {
            uint64_t v303 = *(__int16 *)(a2 + 1998);
            *(_WORD *)(a2 + v--*(_DWORD *)(result + 300) = v303;
            uint64_t v302 = (unsigned __int16)v303;
            *(_WORD *)(a2 + 4 * v303 + 262) = v299 + 352;
            *(_WORD *)(a2 + 1998) = v303 + 1;
          }
          *((void *)&v326[1] + 1) = ((v302 << 48) | 0x19C840) + 64;
          unsigned int v304 = (v299 >> 2) + 48;
          uint64_t v305 = a2 + 4 * v304;
          uint64_t v306 = *(unsigned __int16 *)(v305 + 1692);
          if (v306 == 0xFFFF)
          {
            uint64_t v307 = *(__int16 *)(a2 + 2000);
            uint64_t v306 = *(unsigned __int16 *)(a2 + 2000);
            *(_WORD *)(v305 + 1692) = v307;
            *(_WORD *)(a2 + 4 * v307 + 1694) = v304;
            *(_WORD *)(a2 + 2000) = v307 + 1;
          }
          *((void *)&v326[0] + 1) = ((unint64_t)((v299 & 3) == 0) << 18) | (v306 << 48) | ((unint64_t)((v299 & 3) == 1) << 17) | ((unint64_t)((v299 & 3) == 2) << 16) | ((unint64_t)((v299 & 3) == 3) << 15) | 0x72603000;
          uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        }
        ++v299;
        v300 += 4;
      }
      while (v299 != 6);
    }
    else
    {
      char v294 = 0;
      char v295 = 1;
      do
      {
        char v296 = v295;
        if ((*(_DWORD *)((char *)v325 + 11) >> v294))
        {
          memset((char *)&v326[1] + 8, 0, 56);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
          *(_DWORD *)(a2 + 16) = 1;
          *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, 58) << 48) | 0x19C800;
          uint64_t v297 = *(unsigned __int16 *)(a2 + 1884);
          if (v297 == 0xFFFF)
          {
            uint64_t v298 = *(__int16 *)(a2 + 2000);
            uint64_t v297 = *(unsigned __int16 *)(a2 + 2000);
            *(_WORD *)(a2 + 1884) = v298;
            *(_WORD *)(a2 + 4 * v298 + 1694) = 48;
            *(_WORD *)(a2 + 2000) = v298 + 1;
          }
          *((void *)&v326[0] + 1) = ((v297 << 48) | 0x72679000) + 0x2000;
          uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        }
        char v295 = 0;
        char v294 = 1;
      }
      while ((v296 & 1) != 0);
    }
  }
  uint64_t v3 = v325;
  unint64_t v165 = v325[2];
  unint64_t v163 = v325[3];
  unint64_t v159 = *v325;
  unint64_t v164 = v325[1];
  if ((*v325 & 0x800) != 0)
  {
LABEL_512:
    uint64_t result = (unint64_t *)gleVStateProgram_LightingStage(v3, a2);
    unint64_t v165 = v3[2];
    unint64_t v163 = v3[3];
    unint64_t v159 = *v3;
    unint64_t v164 = v3[1];
  }
LABEL_513:
  if ((v159 & 0xFF0000) != 0)
  {
    unsigned int v308 = BYTE2(v159);
    if (BYTE2(v159))
    {
      unsigned int v324 = v165 | v163 | HIDWORD(v165) | HIDWORD(v163);
      int v309 = 80;
      uint64_t v310 = 989;
      uint64_t v311 = 1720;
      memset(v326, 0, sizeof(v326));
      while ((v308 & 1) == 0)
      {
LABEL_533:
        ++v310;
        v311 += 4;
        v309 += 8;
        BOOL v318 = v308 > 1;
        v308 >>= 1;
        if (!v318)
        {
          unint64_t v164 = v325[1];
          goto LABEL_535;
        }
      }
      char v312 = v310 + 35;
      unsigned int v313 = v324 >> (v310 + 35);
      if ((v313 & 0x1010101) != 0)
      {
        if ((v313 & 0x1010101) != 0x1010101)
        {
          memset((char *)&v326[1] + 8, 0, 56);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
          *(_DWORD *)(a2 + 16) = 1;
          *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, (int)v310 - 981) << 48) | 0x19C800;
          uint64_t v314 = *(unsigned __int16 *)(a2 + 2 * v310);
          if (v314 == 0xFFFF)
          {
            uint64_t v314 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 2 * v310) = v314;
            *(_WORD *)(a2 + 2004) = v314 + 1;
          }
          *((void *)&v326[0] + 1) = ~(v313 << 18) & 0x40000 | (unint64_t)(v314 << 48) | ~(v313 << 9) & 0x20000 | (unint64_t)(~v313 & 0x10000) | ~(v313 >> 9) & 0x8000 | 0x72601000;
          (*(void (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        }
        if (((1 << v312) & BYTE3(*v325)) == 0)
        {
          uint64_t result = (unint64_t *)gleVStateProgram_MultMatrix4x4(a2, (int)v310 - 950, v309, (int)v310 - 982, 23, 0, 0, 1, HIBYTE(*v325) & 1);
          goto LABEL_533;
        }
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v315 = *(unsigned __int16 *)(a2 + 2 * v310);
        if (v315 == 0xFFFF)
        {
          uint64_t v315 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 2 * v310) = v315;
          *(_WORD *)(a2 + 2004) = v315 + 1;
        }
        *(void *)&v326[1] = (v315 << 48) | 0x19C840;
        uint64_t v316 = *(unsigned __int16 *)(a2 + v311);
        if (v316 != 0xFFFF) {
          goto LABEL_527;
        }
      }
      else
      {
        if (((1 << v312) & BYTE3(*v325)) == 0)
        {
          uint64_t result = (unint64_t *)gleVStateProgram_MultMatrix4x4(a2, (int)v310 - 981, v309, (int)v310 - 982, 23, 1, 0, 1, HIBYTE(*v325) & 1);
          goto LABEL_533;
        }
        memset((char *)&v326[1] + 8, 0, 56);
        *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, (int)v310 - 981) << 48) | 0x19C800;
        uint64_t v316 = *(unsigned __int16 *)(a2 + v311);
        if (v316 != 0xFFFF) {
          goto LABEL_527;
        }
      }
      uint64_t v317 = *(__int16 *)(a2 + 2000);
      *(_WORD *)(a2 + v311) = v317;
      uint64_t v316 = (unsigned __int16)v317;
      *(_WORD *)(a2 + 4 * v317 + 1694) = v310 - 982;
      *(_WORD *)(a2 + 2000) = v317 + 1;
LABEL_527:
      *((void *)&v326[0] + 1) = ((v316 << 48) | 0x72679000) + 0x2000;
      uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
      goto LABEL_533;
    }
  }
LABEL_535:
  if ((v164 & 0xFFFFFFFF00000000) != 0)
  {
    unint64_t v319 = HIDWORD(v164);
    if (HIDWORD(v164))
    {
      int v320 = 0;
      uint64_t v321 = 1752;
      do
      {
        if (v319)
        {
          memset((char *)&v326[1] + 8, 0, 56);
          *(void *)&v326[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
          *(_DWORD *)(a2 + 16) = 1;
          *(void *)&v326[1] = (gleVStateProgram_GetAttrib(a2, v320 + 16) << 48) | 0x19C800;
          uint64_t v322 = *(unsigned __int16 *)(a2 + v321);
          if (v322 == 0xFFFF)
          {
            uint64_t v323 = *(__int16 *)(a2 + 2000);
            uint64_t v322 = *(unsigned __int16 *)(a2 + 2000);
            *(_WORD *)(a2 + v321) = v323;
            *(_WORD *)(a2 + 4 * v323 + 1694) = v320 + 15;
            *(_WORD *)(a2 + 2000) = v323 + 1;
          }
          *((void *)&v326[0] + 1) = ((v322 << 48) | 0x72679000) + 0x2000;
          uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 2016))(a2, v326);
        }
        ++v320;
        v321 += 4;
        BOOL v318 = v319 > 1;
        LODWORD(v319) = v319 >> 1;
      }
      while (v318);
    }
  }
  return result;
}

void gleVStateProgram_AddAttribs(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 2024);
  if (v2)
  {
    uint64_t v3 = (_DWORD *)(v2 + *(int *)(v2 + 8));
    bzero(v3, (8 * *(__int16 *)(a1 + 1996) + 8));
    __int16 v4 = *(_WORD *)(a1 + 1996);
    *uint64_t v3 = v4;
  }
  else
  {
    uint64_t v3 = 0;
    __int16 v4 = *(_WORD *)(a1 + 1996);
  }
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(__int16 *)(a1 + 2 * v5 + 22);
      long long v12 = xmmword_2393D1150;
      DWORD2(v12) = v6;
      switch((int)v7)
      {
        case 1:
          uint64_t v8 = 0x1000070C0;
          goto LABEL_13;
        case 2:
          uint64_t v8 = 0x2000070C0;
          goto LABEL_13;
        case 3:
          uint64_t v8 = 0x3000070C0;
          goto LABEL_13;
        case 4:
          uint64_t v8 = 0x44000070C0;
          goto LABEL_13;
        case 5:
          uint64_t v8 = 0x5000070C0;
          goto LABEL_13;
        case 6:
          uint64_t v8 = 0x6000070C0;
          goto LABEL_13;
        case 7:
          uint64_t v8 = 0x7000070C0;
          goto LABEL_13;
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          goto LABEL_12;
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
          uint64_t v8 = ((unint64_t)(((_BYTE)v7 + 48) & 0x3F) << 32) | 0x100000070C0;
          goto LABEL_13;
        case 48:
        case 49:
          char v9 = v7 + 54;
          goto LABEL_11;
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
          char v9 = v7 + 46;
          goto LABEL_11;
        case 56:
        case 57:
          char v9 = v7 + 48;
LABEL_11:
          uint64_t v7 = v9 & 0x3F;
LABEL_12:
          uint64_t v8 = (v7 << 32) | 0x70C0;
          goto LABEL_13;
        case 58:
        case 59:
          uint64_t v8 = ((unint64_t)(((_BYTE)v7 + 6) & 0x1F) << 32) | 0x38C0;
LABEL_13:
          *(void *)&long long v12 = v8;
          break;
        default:
          uint64_t v8 = 28864;
          break;
      }
      if (*(void *)a1)
      {
        PPStreamAddAttribBinding(*(void *)a1, &v12);
      }
      else
      {
        uint64_t v10 = &v3[v5];
        void v10[2] = v10[2] & 0xFFFFC000 | v8 & 0x3F | (v8 >> 2) & 0x3F00 | 0xC0;
        unsigned int v11 = (v8 >> 10) & 0x1F;
        if (v11 == 14)
        {
          v10[3] = BYTE4(v8) & 0x1F | (32 * (v10[3] >> 5));
        }
        else if (v11 == 28)
        {
          v3[v5 + 3] = v3[v5 + 3] & 0xFFFFFE00 | HIDWORD(v8);
        }
      }
      ++v6;
      v5 += 2;
    }
    while (v6 < *(__int16 *)(a1 + 1996));
  }
}

char *gleVStateProgram_AddParams(char *result)
{
  unsigned int v1 = result;
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)result + 253);
  if (v2)
  {
    uint64_t v3 = v2 + *(int *)(v2 + 4);
    unsigned int v4 = *((__int16 *)result + 999);
    __int16 v5 = *((_WORD *)result + 999);
    *(void *)uint64_t v3 = v4;
    *(_DWORD *)(v3 + 8) = v4;
  }
  else
  {
    uint64_t v3 = 0;
    __int16 v5 = *((_WORD *)result + 999);
  }
  if (v5 >= 1)
  {
    LODWORD(v6) = 0;
    do
    {
      unsigned int v7 = *(__int16 *)&v1[4 * (int)v6 + 262];
      long long v20 = xmmword_2393D1160;
      DWORD2(v20) = v6;
      if (v7 - 144 > 0x10)
      {
        switch(v7)
        {
          case 0u:
          case 1u:
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 6u:
          case 7u:
            unint64_t v13 = ((unint64_t)(v7 & 3) << 42) | ((unint64_t)((v7 >> 2) ^ 1) << 40);
            uint64_t v14 = 0x100000000FC0;
            goto LABEL_34;
          case 8u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
          case 0xDu:
          case 0xEu:
          case 0xFu:
            unint64_t v16 = ((unint64_t)(v7 & 3) << 42) | ((unint64_t)(((v7 >> 2) & 1) == 0) << 40) | 0xFC0;
            goto LABEL_51;
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
          case 0x20u:
          case 0x21u:
          case 0x22u:
          case 0x23u:
          case 0x24u:
          case 0x25u:
          case 0x26u:
          case 0x27u:
          case 0x28u:
          case 0x29u:
          case 0x2Au:
          case 0x2Bu:
          case 0x2Cu:
          case 0x2Du:
          case 0x2Eu:
          case 0x2Fu:
            unint64_t v13 = ((unint64_t)(v7 & 3) << 42) | ((unint64_t)(((v7 >> 2) & 1) == 0) << 40) | ((unint64_t)((v7 + 2032) >> 3) << 32);
            uint64_t v14 = 0x300000000FC0;
            goto LABEL_34;
          case 0x30u:
          case 0x31u:
          case 0x32u:
          case 0x33u:
          case 0x34u:
          case 0x35u:
          case 0x36u:
          case 0x37u:
          case 0x38u:
          case 0x39u:
          case 0x3Au:
          case 0x3Bu:
          case 0x3Cu:
          case 0x3Du:
          case 0x3Eu:
          case 0x3Fu:
          case 0x40u:
          case 0x41u:
          case 0x42u:
          case 0x43u:
          case 0x44u:
          case 0x45u:
          case 0x46u:
          case 0x47u:
          case 0x48u:
          case 0x49u:
          case 0x4Au:
          case 0x4Bu:
          case 0x4Cu:
          case 0x4Du:
          case 0x4Eu:
          case 0x4Fu:
            uint64_t v15 = 0x300000000C0;
            if ((v7 & 4) == 0) {
              uint64_t v15 = 0x200000000C0;
            }
            unint64_t v13 = v15 | ((unint64_t)(v7 & 3) << 42) | ((unint64_t)((v7 + 2000) >> 3) << 32);
            uint64_t v14 = 0x300000000F00;
            goto LABEL_34;
          case 0x50u:
          case 0x51u:
          case 0x52u:
          case 0x53u:
          case 0x54u:
          case 0x55u:
          case 0x56u:
          case 0x57u:
          case 0x58u:
          case 0x59u:
          case 0x5Au:
          case 0x5Bu:
          case 0x5Cu:
          case 0x5Du:
          case 0x5Eu:
          case 0x5Fu:
          case 0x60u:
          case 0x61u:
          case 0x62u:
          case 0x63u:
          case 0x64u:
          case 0x65u:
          case 0x66u:
          case 0x67u:
          case 0x68u:
          case 0x69u:
          case 0x6Au:
          case 0x6Bu:
          case 0x6Cu:
          case 0x6Du:
          case 0x6Eu:
          case 0x6Fu:
          case 0x70u:
          case 0x71u:
          case 0x72u:
          case 0x73u:
          case 0x74u:
          case 0x75u:
          case 0x76u:
          case 0x77u:
          case 0x78u:
          case 0x79u:
          case 0x7Au:
          case 0x7Bu:
          case 0x7Cu:
          case 0x7Du:
          case 0x7Eu:
          case 0x7Fu:
          case 0x80u:
          case 0x81u:
          case 0x82u:
          case 0x83u:
          case 0x84u:
          case 0x85u:
          case 0x86u:
          case 0x87u:
          case 0x88u:
          case 0x89u:
          case 0x8Au:
          case 0x8Bu:
          case 0x8Cu:
          case 0x8Du:
          case 0x8Eu:
          case 0x8Fu:
            unint64_t v13 = ((unint64_t)(v7 & 3) << 42) | ((unint64_t)(((v7 >> 2) & 1) == 0) << 40) | ((unint64_t)((v7 + 1968) >> 3) << 32);
            uint64_t v14 = 0x400000000FC0;
            goto LABEL_34;
          case 0xA0u:
          case 0xA1u:
          case 0xA2u:
          case 0xA3u:
          case 0xA4u:
          case 0xA5u:
          case 0xA6u:
          case 0xA7u:
          case 0xA8u:
          case 0xA9u:
          case 0xAAu:
          case 0xABu:
          case 0xACu:
          case 0xADu:
          case 0xAEu:
          case 0xAFu:
          case 0xB0u:
          case 0xB1u:
          case 0xB2u:
          case 0xB3u:
          case 0xB4u:
          case 0xB5u:
          case 0xB6u:
          case 0xB7u:
          case 0xB8u:
          case 0xB9u:
          case 0xBAu:
          case 0xBBu:
          case 0xBCu:
          case 0xBDu:
          case 0xBEu:
          case 0xBFu:
            unint64_t v13 = ((unint64_t)(v7 & 3) << 39) | ((unint64_t)(((v7 + 352) >> 2) & 0x7F) << 32);
            uint64_t v14 = 5568;
            goto LABEL_34;
          case 0xC0u:
          case 0xC1u:
          case 0xC2u:
          case 0xC3u:
          case 0xC4u:
          case 0xC5u:
          case 0xC6u:
          case 0xC7u:
          case 0xC8u:
          case 0xC9u:
          case 0xCAu:
          case 0xCBu:
          case 0xCCu:
          case 0xCDu:
          case 0xCEu:
          case 0xCFu:
          case 0xD0u:
          case 0xD1u:
          case 0xD2u:
          case 0xD3u:
          case 0xD4u:
          case 0xD5u:
          case 0xD6u:
          case 0xD7u:
          case 0xD8u:
          case 0xD9u:
          case 0xDAu:
          case 0xDBu:
          case 0xDCu:
          case 0xDDu:
          case 0xDEu:
          case 0xDFu:
            unint64_t v13 = ((unint64_t)(v7 & 3) << 39) | ((unint64_t)(((v7 + 320) >> 2) & 0x7F) << 32);
            uint64_t v14 = 5312;
            goto LABEL_34;
          case 0xE0u:
          case 0xE1u:
          case 0xE2u:
          case 0xE3u:
          case 0xE4u:
          case 0xE5u:
          case 0xE6u:
          case 0xE7u:
          case 0xE8u:
          case 0xE9u:
          case 0xEAu:
          case 0xEBu:
          case 0xECu:
          case 0xEDu:
          case 0xEEu:
          case 0xEFu:
            unint64_t v13 = ((unint64_t)(v7 & 1) << 40) | ((unint64_t)((v7 + 288) >> 1) << 32);
            uint64_t v14 = 4544;
            goto LABEL_34;
          case 0xF0u:
          case 0xF1u:
          case 0xF2u:
          case 0xF3u:
          case 0xF4u:
          case 0xF5u:
          case 0xF6u:
          case 0xF7u:
          case 0xF8u:
          case 0xF9u:
          case 0xFAu:
          case 0xFBu:
          case 0xFCu:
          case 0xFDu:
          case 0xFEu:
          case 0xFFu:
            unint64_t v13 = ((unint64_t)(v7 & 1) << 40) | ((unint64_t)((v7 + 272) >> 1) << 32);
            uint64_t v14 = 0x200000011C0;
            goto LABEL_34;
          case 0x100u:
          case 0x101u:
          case 0x102u:
          case 0x103u:
          case 0x104u:
          case 0x105u:
          case 0x106u:
          case 0x107u:
          case 0x108u:
          case 0x109u:
          case 0x10Au:
          case 0x10Bu:
          case 0x10Cu:
          case 0x10Du:
          case 0x10Eu:
          case 0x10Fu:
            unint64_t v13 = ((unint64_t)(v7 & 1) << 40) | ((unint64_t)((v7 + 256) >> 1) << 32);
            uint64_t v14 = 0x400000011C0;
LABEL_34:
            unint64_t v16 = v13 | v14;
            goto LABEL_51;
          case 0x110u:
          case 0x111u:
          case 0x112u:
          case 0x113u:
          case 0x114u:
          case 0x115u:
          case 0x116u:
          case 0x117u:
            uint64_t v17 = (v7 - 16);
            uint64_t v18 = 4288;
            goto LABEL_50;
          case 0x118u:
          case 0x119u:
          case 0x11Au:
          case 0x11Bu:
          case 0x11Cu:
          case 0x11Du:
          case 0x11Eu:
          case 0x11Fu:
            uint64_t v17 = (v7 - 24);
            uint64_t v18 = 0x100000010C0;
            goto LABEL_50;
          case 0x120u:
          case 0x121u:
          case 0x122u:
          case 0x123u:
          case 0x124u:
          case 0x125u:
          case 0x126u:
          case 0x127u:
            uint64_t v17 = (v7 - 32);
            uint64_t v18 = 0x200000010C0;
            goto LABEL_50;
          case 0x128u:
          case 0x129u:
          case 0x12Au:
          case 0x12Bu:
          case 0x12Cu:
          case 0x12Du:
          case 0x12Eu:
          case 0x12Fu:
            uint64_t v17 = (v7 - 40);
            uint64_t v18 = 0x400000010C0;
            goto LABEL_50;
          case 0x130u:
          case 0x131u:
          case 0x132u:
          case 0x133u:
          case 0x134u:
          case 0x135u:
          case 0x136u:
          case 0x137u:
            uint64_t v17 = (v7 - 48);
            uint64_t v18 = 0x600000010C0;
            goto LABEL_50;
          case 0x138u:
          case 0x139u:
          case 0x13Au:
          case 0x13Bu:
          case 0x13Cu:
          case 0x13Du:
          case 0x13Eu:
          case 0x13Fu:
            uint64_t v17 = (v7 - 56);
            uint64_t v18 = 0x500000010C0;
            goto LABEL_50;
          case 0x140u:
          case 0x141u:
          case 0x142u:
          case 0x143u:
          case 0x144u:
          case 0x145u:
          case 0x146u:
          case 0x147u:
            uint64_t v17 = (v7 - 64);
            uint64_t v18 = 0x700000010C0;
            goto LABEL_50;
          case 0x148u:
          case 0x149u:
          case 0x14Au:
          case 0x14Bu:
          case 0x14Cu:
          case 0x14Du:
          case 0x14Eu:
          case 0x14Fu:
            uint64_t v17 = (v7 - 72);
            uint64_t v18 = 0x800000010C0;
            goto LABEL_50;
          case 0x150u:
          case 0x151u:
            uint64_t v17 = v7 & 1;
            uint64_t v18 = 0x6000012C0;
            goto LABEL_50;
          case 0x152u:
          case 0x153u:
            uint64_t v17 = v7 & 1;
            uint64_t v18 = 4800;
            goto LABEL_50;
          case 0x154u:
          case 0x155u:
            uint64_t v17 = v7 & 1;
            uint64_t v18 = 0x2000012C0;
            goto LABEL_50;
          case 0x156u:
          case 0x157u:
            uint64_t v17 = v7 & 1;
            uint64_t v18 = 0x8000012C0;
            goto LABEL_50;
          case 0x158u:
          case 0x159u:
            uint64_t v17 = v7 & 1;
            uint64_t v18 = 0xA000012C0;
            goto LABEL_50;
          case 0x15Au:
            unint64_t v16 = 5056;
            goto LABEL_51;
          case 0x15Bu:
            unint64_t v16 = 7616;
            goto LABEL_51;
          case 0x15Cu:
            unint64_t v16 = 7360;
            goto LABEL_51;
          case 0x15Du:
            unint64_t v16 = 6848;
            goto LABEL_51;
          case 0x15Eu:
            unint64_t v16 = 7104;
            goto LABEL_51;
          case 0x15Fu:
            uint64_t result = *(char **)v1;
            if (!*(void *)v1) {
              goto LABEL_54;
            }
            long long v21 = xmmword_2393DBEC0;
            uint64_t v19 = *((void *)result + 16);
            PPStreamAddConstant((uint64_t)result, &v21);
            unint64_t v16 = v20 & 0xFFFF0000FFFFE0FFLL | ((unint64_t)(unsigned __int16)(*(_DWORD *)(v19 + 16) - 1) << 32) | 0x600;
            goto LABEL_51;
          case 0x160u:
          case 0x161u:
          case 0x162u:
          case 0x163u:
          case 0x164u:
          case 0x165u:
            uint64_t v17 = (v7 - 96);
            uint64_t v18 = 6336;
LABEL_50:
            unint64_t v16 = v18 | (v17 << 32);
LABEL_51:
            *(void *)&long long v20 = v16;
            break;
          default:
            break;
        }
        uint64_t result = *(char **)v1;
        if (*(void *)v1) {
          uint64_t result = PPStreamAddParamBinding((uint64_t)result, &v20);
        }
LABEL_54:
        if (v3) {
          *(void *)(v3 + 8 * (int)v6 + 16) = v20;
        }
      }
      else
      {
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        uint64_t v10 = 0x30000000000;
        if (v7 < 0x98) {
          uint64_t v10 = 0;
        }
        uint64_t v11 = 0x20000000000;
        if (v7 < 0x98) {
          uint64_t v11 = 0x10000000000;
        }
        if ((v7 & 4) == 0) {
          uint64_t v10 = v11;
        }
        *(void *)&long long v21 = 0;
        *(void *)&long long v20 = v10 | ((unint64_t)(v7 & 3) << 42) | 0x600000000FC0;
        do
        {
          DWORD2(v20) = v6 + v9;
          *(void *)&long long v20 = v20 & 0xFFFFFF00FFFFFFFFLL | v8;
          if (*(void *)v1) {
            PPStreamAddParamBinding(*(void *)v1, &v20);
          }
          if (v3) {
            *(void *)(v3 + 16 + 8 * (int)v6 + 8 * v9) = v20;
          }
          ++v9;
          v8 += 0x100000000;
        }
        while (v9 != 11);
        uint64_t result = *(char **)v1;
        if (*(void *)v1)
        {
          uint64_t v12 = (v6 << 16);
          uint64_t v6 = (v6 + 10);
          *(void *)&long long v21 = v12 | (v6 << 48);
          uint64_t result = PPStreamAddParamBindingArray((uint64_t)result, &v21);
        }
        else
        {
          LODWORD(v6) = v6 + 10;
        }
      }
      LODWORD(v6) = v6 + 1;
    }
    while ((int)v6 < *((__int16 *)v1 + 999));
  }
  return result;
}

uint64_t *gleVStateProgram_AllocateOutputs(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if ((*result & 0x1800) == 0
    || (uint64_t v3 = *(__int16 *)(a2 + 2000),
        *(_WORD *)(a2 + 1704) = v3,
        *(_WORD *)(a2 + 4 * v3 + 1694) = 3,
        __int16 v4 = v3 + 1,
        *(_WORD *)(a2 + 2000) = v3 + 1,
        uint64_t v2 = *result,
        (*result & 0x1000000000000) == 0))
  {
    uint64_t v5 = result[4];
    unint64_t v6 = result[1];
    if ((v2 & 0x2000) != 0) {
      goto LABEL_7;
    }
LABEL_6:
    if ((v2 & 0x8000000000000800) != 0x8000000000000800) {
      goto LABEL_11;
    }
    goto LABEL_7;
  }
  *(_WORD *)(a2 + 1708) = v4;
  *(_WORD *)(a2 + 4 * v4 + 1694) = 4;
  *(_WORD *)(a2 + 2000) = v3 + 2;
  uint64_t v5 = result[4];
  uint64_t v2 = *result;
  unint64_t v6 = result[1];
  if ((*result & 0x2000) == 0) {
    goto LABEL_6;
  }
LABEL_7:
  uint64_t v7 = *(__int16 *)(a2 + 2000);
  *(_WORD *)(a2 + 1712) = v7;
  *(_WORD *)(a2 + 4 * v7 + 1694) = 5;
  __int16 v8 = v7 + 1;
  *(_WORD *)(a2 + 2000) = v7 + 1;
  uint64_t v2 = *result;
  if ((*result & 0x1000000000000) != 0)
  {
    *(_WORD *)(a2 + 1716) = v8;
    *(_WORD *)(a2 + 4 * v8 + 1694) = 6;
    *(_WORD *)(a2 + 2000) = v7 + 2;
    uint64_t v5 = result[4];
    uint64_t v2 = *result;
  }
  else
  {
    uint64_t v5 = result[4];
  }
  unint64_t v6 = result[1];
LABEL_11:
  if ((v5 & 3) != 0)
  {
    uint64_t v2 = *(__int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1696) = v2;
    *(_WORD *)(a2 + 4 * v2 + 1694) = 1;
    *(_WORD *)(a2 + 2000) = v2 + 1;
    LODWORD(v2) = *(_DWORD *)result;
    LODWORD(v9) = *((_DWORD *)result + 3);
  }
  else
  {
    unint64_t v9 = HIDWORD(v6);
  }
  unsigned int v10 = BYTE2(v2);
  if (v10)
  {
    __int16 v11 = 0;
    uint64_t v12 = (_WORD *)(a2 + 1720);
    do
    {
      if (v10)
      {
        uint64_t v13 = *(__int16 *)(a2 + 2000);
        *uint64_t v12 = v13;
        *(_WORD *)(a2 + 4 * v13 + 1694) = v11 + 7;
        *(_WORD *)(a2 + 2000) = v13 + 1;
      }
      ++v11;
      v12 += 2;
      BOOL v14 = v10 > 1;
      v10 >>= 1;
    }
    while (v14);
    LODWORD(v9) = *((_DWORD *)result + 3);
  }
  if (v9)
  {
    int v15 = 0;
    unint64_t v16 = (_WORD *)(a2 + 1752);
    do
    {
      if (v9)
      {
        uint64_t v17 = *(__int16 *)(a2 + 2000);
        *unint64_t v16 = v17;
        *(_WORD *)(a2 + 4 * v17 + 1694) = v15 + 15;
        *(_WORD *)(a2 + 2000) = v17 + 1;
      }
      ++v15;
      v16 += 2;
      BOOL v14 = v9 > 1;
      LODWORD(v9) = v9 >> 1;
    }
    while (v14);
  }
  if ((*(unsigned char *)(a2 + 2032) & 1) == 0)
  {
    uint64_t v18 = *(__int16 *)(a2 + 2000);
    uint64_t v19 = a2 + 1692;
    *(_WORD *)(a2 + 1692) = v18;
    *(_WORD *)(a2 + 1692 + 4 * v18 + 2) = 0;
    *(_WORD *)(a2 + 1892) = v18 + 1;
    *(_WORD *)(a2 + 1692 + 4 * (__int16)(v18 + 1) + 2) = 50;
    *(_WORD *)(a2 + 1700) = v18 + 2;
    *(_WORD *)(a2 + 1692 + 4 * (__int16)(v18 + 2) + 2) = 2;
    __int16 v20 = v18 + 3;
    *(_WORD *)(a2 + 2000) = v18 + 3;
    if ((*result & 0x4000000000000000) != 0)
    {
      *(_WORD *)(a2 + 1880) = v20;
      *(_WORD *)(a2 + 4 * v20 + 1694) = 47;
      __int16 v20 = v18 + 4;
    }
    *(_WORD *)(a2 + 1884) = v20;
    *(_WORD *)(v19 + 4 * v20 + 2) = 48;
    *(_WORD *)(a2 + 1888) = v20 + 1;
    *(_WORD *)(v19 + 4 * (__int16)(v20 + 1) + 2) = 49;
    *(_WORD *)(a2 + 2000) = v20 + 2;
  }
  return result;
}

uint64_t gleVStateProgram_GetAttrib(uint64_t a1, signed int a2)
{
  uint64_t v2 = a1 + 4 * a2;
  int v5 = *(unsigned __int16 *)(v2 + 20);
  __int16 v4 = (_WORD *)(v2 + 20);
  int v3 = v5;
  if (*(void *)a1)
  {
    if (v3 == 0xFFFF)
    {
      uint64_t v6 = *(__int16 *)(a1 + 1996);
      LOWORD(v3) = *(_WORD *)(a1 + 1996);
      *__int16 v4 = v6;
      *(_WORD *)(a1 + 4 * v6 + 22) = a2;
      *(_WORD *)(a1 + 1996) = v6 + 1;
    }
    return (__int16)v3;
  }
  else
  {
    if (v3 == 0xFFFF)
    {
      uint64_t v8 = *(__int16 *)(a1 + 1996);
      LOWORD(v3) = *(_WORD *)(a1 + 1996);
      *__int16 v4 = v8;
      *(_WORD *)(a1 + 4 * v8 + 22) = a2;
      *(_WORD *)(a1 + 1996) = v8 + 1;
    }
    uint64_t v7 = (__int16)v3;
    int v9 = *(_DWORD *)(a1 + 2032);
    if (a2 == 5)
    {
      v9 |= 4u;
      *(_DWORD *)(a1 + 2032) = v9;
    }
    if ((v9 & 1) == 0)
    {
      if a2 < 0x3C && ((0xFFF00000000FFFFuLL >> a2)) {
        return dword_2393DBF00[a2];
      }
      else {
        return (a2 - 16);
      }
    }
  }
  return v7;
}

uint64_t gleVStateProgram_LightingStage(unint64_t *a1, uint64_t a2)
{
  uint64_t v1146 = *MEMORY[0x263EF8340];
  unint64_t v3 = *a1;
  uint64_t v4 = (*a1 >> 52) & 0xF;
  unint64_t v1124 = v4 & ((uint64_t)(*a1 << 13) >> 63);
  if (*a1 & 0x2000000000000 | *((unsigned __int8 *)a1 + 8))
  {
    memset((char *)v1145 + 8, 0, 64);
    uint64_t v5 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v1144 = v5 | 0x100080381;
    uint64_t v6 = *(unsigned __int16 *)(a2 + 1900);
    if (v6 == 0xFFFF)
    {
      uint64_t v8 = *(unsigned __int16 *)(a2 + 2004);
      int v9 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v8;
      *(_WORD *)(a2 + 2004) = ++v9;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v8 << 48) | 0x1FE40;
      if ((v9 & 0x10000) != 0)
      {
        uint64_t v8 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v8;
        *(_WORD *)(a2 + 2004) = v8 + 1;
      }
      uint64_t v7 = v8 << 48;
    }
    else
    {
      uint64_t v7 = v6 << 48;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v6 << 48) | 0x1FE40;
    }
    *(void *)&v1145[0] = v7 | 0x72609000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  }
  uint64_t v10 = v3 << 12;
  if (v1124)
  {
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v14 = *(unsigned __int16 *)(a2 + 1644);
    if (v14 == 0xFFFF)
    {
      uint64_t v15 = *(__int16 *)(a2 + 1998);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1644) = v15;
      *(_WORD *)(a2 + 4 * v15 + 262) = 346;
      *(_WORD *)(a2 + 1998) = v15 + 1;
    }
    *((void *)&v1145[0] + 1) = ((v14 << 48) | 0x19C840) + 64;
    uint64_t v16 = *(unsigned __int16 *)(a2 + 1612);
    if (v16 == 0xFFFF)
    {
      uint64_t v17 = *(__int16 *)(a2 + 1998);
      uint64_t v16 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1612) = v17;
      *(_WORD *)(a2 + 4 * v17 + 262) = 338;
      *(_WORD *)(a2 + 1998) = v17 + 1;
    }
    *(void *)&v1145[1] = ((v16 << 48) | 0x19C840) + 64;
    *((void *)&v1145[1] + 1) = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v13 = *(unsigned __int16 *)(a2 + 1904);
LABEL_18:
    if (v13 != 0xFFFF) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if ((v1124 & 2) == 0)
  {
    memset(&v1145[1], 0, 56);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v11 = *(unsigned __int16 *)(a2 + 1636);
    if (v11 == 0xFFFF)
    {
      uint64_t v12 = *(__int16 *)(a2 + 1998);
      uint64_t v11 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1636) = v12;
      *(_WORD *)(a2 + 4 * v12 + 262) = 344;
      *(_WORD *)(a2 + 1998) = v12 + 1;
    }
    *((void *)&v1145[0] + 1) = ((v11 << 48) | 0x19C840) + 64;
    uint64_t v13 = *(unsigned __int16 *)(a2 + 1904);
    goto LABEL_18;
  }
  memset(v1145, 0, 72);
  uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
  *(_DWORD *)(a2 + 16) = 3;
  uint64_t v21 = *(unsigned __int16 *)(a2 + 1644);
  if (v21 == 0xFFFF)
  {
    uint64_t v22 = *(__int16 *)(a2 + 1998);
    uint64_t v21 = *(unsigned __int16 *)(a2 + 1998);
    *(_WORD *)(a2 + 1644) = v22;
    *(_WORD *)(a2 + 4 * v22 + 262) = 346;
    *(_WORD *)(a2 + 1998) = v22 + 1;
  }
  *((void *)&v1145[0] + 1) = ((v21 << 48) | 0x19C840) + 64;
  *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
  uint64_t v23 = *(unsigned __int16 *)(a2 + 1604);
  if (v23 == 0xFFFF)
  {
    uint64_t v24 = *(__int16 *)(a2 + 1998);
    uint64_t v23 = *(unsigned __int16 *)(a2 + 1998);
    *(_WORD *)(a2 + 1604) = v24;
    *(_WORD *)(a2 + 4 * v24 + 262) = 336;
    *(_WORD *)(a2 + 1998) = v24 + 1;
  }
  *((void *)&v1145[1] + 1) = ((v23 << 48) | 0x19C840) + 64;
  uint64_t v13 = *(unsigned __int16 *)(a2 + 1904);
  if (v13 == 0xFFFF)
  {
LABEL_19:
    uint64_t v13 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1904) = v13;
    *(_WORD *)(a2 + 2004) = v13 + 1;
  }
LABEL_20:
  unint64_t v1121 = v4 & (v10 >> 63);
  *(void *)&v1145[0] = (v13 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  unint64_t v18 = *a1;
  if (!(*a1 & 0x2000000000000 | a1[1])) {
    goto LABEL_36;
  }
  memset((char *)v1145 + 8, 0, 64);
  uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
  *(_DWORD *)(a2 + 16) = 2;
  uint64_t v19 = *(unsigned __int16 *)(a2 + 1900);
  if (v19 == 0xFFFF)
  {
    uint64_t v25 = *(unsigned __int16 *)(a2 + 2004);
    int v26 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1900) = v25;
    *(_WORD *)(a2 + 2004) = ++v26;
    *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v25 << 48) | 0x19C840;
    if ((v26 & 0x10000) != 0)
    {
      uint64_t v27 = *(unsigned __int16 *)(a2 + 2004);
      int v28 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v27;
      *(_WORD *)(a2 + 2004) = ++v28;
      *(void *)&v1145[1] = (((unint64_t)(unsigned __int16)v27 << 48) | 0x1FE40) + 16;
      if ((v28 & 0x10000) != 0)
      {
        uint64_t v27 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v27;
        *(_WORD *)(a2 + 2004) = v27 + 1;
      }
      uint64_t v20 = v27 << 48;
      goto LABEL_35;
    }
    uint64_t v20 = v25 << 48;
  }
  else
  {
    uint64_t v20 = v19 << 48;
    *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v19 << 48) | 0x19C840;
  }
  *(void *)&v1145[1] = v20 | 0x1FE50;
LABEL_35:
  *(void *)&v1145[0] = v20 | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  unint64_t v18 = *a1;
LABEL_36:
  if ((v18 & 0x1000000000000) == 0) {
    goto LABEL_56;
  }
  if (v1121)
  {
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v32 = *(unsigned __int16 *)(a2 + 1644);
    if (v32 == 0xFFFF)
    {
      uint64_t v33 = *(__int16 *)(a2 + 1998);
      uint64_t v32 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1644) = v33;
      *(_WORD *)(a2 + 4 * v33 + 262) = 346;
      *(_WORD *)(a2 + 1998) = v33 + 1;
    }
    *((void *)&v1145[0] + 1) = ((v32 << 48) | 0x19C840) + 64;
    uint64_t v34 = *(unsigned __int16 *)(a2 + 1616);
    if (v34 == 0xFFFF)
    {
      uint64_t v35 = *(__int16 *)(a2 + 1998);
      uint64_t v34 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1616) = v35;
      *(_WORD *)(a2 + 4 * v35 + 262) = 339;
      *(_WORD *)(a2 + 1998) = v35 + 1;
    }
    *(void *)&v1145[1] = ((v34 << 48) | 0x19C840) + 64;
    uint64_t v36 = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
  }
  else
  {
    if ((v1121 & 2) == 0)
    {
      memset(&v1145[1], 0, 56);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v29 = *(unsigned __int16 *)(a2 + 1640);
      if (v29 == 0xFFFF)
      {
        uint64_t v30 = *(__int16 *)(a2 + 1998);
        uint64_t v29 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1640) = v30;
        *(_WORD *)(a2 + 4 * v30 + 262) = 345;
        *(_WORD *)(a2 + 1998) = v30 + 1;
      }
      *((void *)&v1145[0] + 1) = ((v29 << 48) | 0x19C840) + 64;
      uint64_t v31 = *(unsigned __int16 *)(a2 + 1906);
      goto LABEL_53;
    }
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v37 = *(unsigned __int16 *)(a2 + 1644);
    if (v37 == 0xFFFF)
    {
      uint64_t v38 = *(__int16 *)(a2 + 1998);
      uint64_t v37 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1644) = v38;
      *(_WORD *)(a2 + 4 * v38 + 262) = 346;
      *(_WORD *)(a2 + 1998) = v38 + 1;
    }
    *((void *)&v1145[0] + 1) = ((v37 << 48) | 0x19C840) + 64;
    *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v39 = *(unsigned __int16 *)(a2 + 1608);
    if (v39 == 0xFFFF)
    {
      uint64_t v40 = *(__int16 *)(a2 + 1998);
      uint64_t v39 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1608) = v40;
      *(_WORD *)(a2 + 4 * v40 + 262) = 337;
      *(_WORD *)(a2 + 1998) = v40 + 1;
    }
    uint64_t v36 = ((v39 << 48) | 0x19C840) + 64;
  }
  *((void *)&v1145[1] + 1) = v36;
  uint64_t v31 = *(unsigned __int16 *)(a2 + 1906);
LABEL_53:
  if (v31 == 0xFFFF)
  {
    uint64_t v31 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1906) = v31;
    *(_WORD *)(a2 + 2004) = v31 + 1;
  }
  *(void *)&v1145[0] = (v31 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_56:
  unint64_t v41 = *a1;
  if ((*a1 & 0x2000000000000) == 0) {
    goto LABEL_66;
  }
  memset((char *)v1145 + 8, 0, 64);
  uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
  *(_DWORD *)(a2 + 16) = 2;
  uint64_t v42 = *(unsigned __int16 *)(a2 + 1900);
  if (v42 == 0xFFFF)
  {
    uint64_t v45 = *(unsigned __int16 *)(a2 + 2004);
    int v46 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1900) = v45;
    int v47 = v46 + 1;
    *(_WORD *)(a2 + 2004) = v46 + 1;
    unint64_t v44 = ((unint64_t)(unsigned __int16)v45 << 48) | 0x19C840;
    *((void *)&v1145[0] + 1) = v44;
    if ((v47 & 0x10000) != 0)
    {
      uint64_t v48 = *(unsigned __int16 *)(a2 + 2004);
      int v49 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v48;
      *(_WORD *)(a2 + 2004) = ++v49;
      *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v48 << 48) | 0x19C840;
      if ((v49 & 0x10000) != 0)
      {
        uint64_t v48 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v48;
        *(_WORD *)(a2 + 2004) = v48 + 1;
      }
      uint64_t v43 = v48 << 48;
      goto LABEL_65;
    }
    uint64_t v43 = v45 << 48;
  }
  else
  {
    uint64_t v43 = v42 << 48;
    unint64_t v44 = ((unint64_t)(unsigned __int16)v42 << 48) | 0x19C840;
    *((void *)&v1145[0] + 1) = v44;
  }
  *(void *)&v1145[1] = v44;
LABEL_65:
  *(void *)&v1145[0] = v43 | 0x72609000;
  (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  unint64_t v41 = *a1;
LABEL_66:
  unsigned int v50 = BYTE4(v41);
  if ((v41 & 0x800000000000000) != 0)
  {
    if (!BYTE4(v41)) {
      goto LABEL_1660;
    }
    unsigned int v54 = 0;
    int v55 = 0;
    do
    {
      if (v50) {
        *((_DWORD *)&v1145[4] + v54++ + 2) = v55;
      }
      ++v55;
      BOOL v56 = v50 >= 2;
      v50 >>= 1;
    }
    while (v56);
    if (!v54) {
      goto LABEL_1660;
    }
    int v57 = 0;
    unsigned int v58 = 0;
    uint64_t v59 = (_WORD *)(a2 + 2004);
    uint64_t v1136 = a2 + 1924;
    uint64_t v1130 = a2 + 1932;
    v1138 = (_WORD *)(a2 + 2004);
    while (1)
    {
      int v1122 = v57;
      unsigned int v1123 = v54;
      v1140 = (char *)&v1145[4] + 4 * v58 + 8;
      unint64_t v60 = v54 - v58 >= 4 ? 4 : v54 - v58;
      unsigned int v1125 = v58;
      unint64_t v1142 = v60;
      if (!v60) {
        break;
      }
      unint64_t v61 = 0;
      int v62 = 0;
      unsigned int v63 = 0;
      unsigned int v64 = 0;
      int v65 = *((_DWORD *)a1 + 2);
      unsigned int v66 = BYTE1(v65);
      unsigned int v67 = BYTE2(v65);
      do
      {
        char v68 = *(_DWORD *)&v1140[4 * v61];
        v64 |= ((*((_DWORD *)a1 + 2) >> v68) & 1) << v61;
        v63 |= ((v66 >> v68) & 1) << v61;
        v62 |= ((v67 >> v68) & 1) << v61++;
      }
      while (v61 < v60);
      BOOL v1120 = (~v64 & 0xF) == 0;
      unsigned int v1131 = ~v64 & 0xF;
      if (v1131)
      {
        for (unint64_t i = 0; i < v60; ++i)
        {
          if ((v1131 >> i))
          {
            int v70 = *(_DWORD *)&v1140[4 * i];
            memset(&v1145[1], 0, 56);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
            *(_DWORD *)(a2 + 16) = 1;
            int v71 = v70 + 320;
            uint64_t v72 = a2 + 4 * (v70 + 320);
            uint64_t v73 = *(unsigned __int16 *)(v72 + 260);
            if (v73 == 0xFFFF)
            {
              uint64_t v74 = *(__int16 *)(a2 + 1998);
              uint64_t v73 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v72 + 260) = v74;
              *(_WORD *)(a2 + 4 * v74 + 262) = v71;
              BOOL v75 = (v71 & 0xFFFFFFF0) == 144;
              __int16 v76 = v74 + 11;
              if (!v75) {
                __int16 v76 = v74 + 1;
              }
              *(_WORD *)(a2 + 1998) = v76;
            }
            *((void *)&v1145[0] + 1) = ((v73 << 48) | 0x19C840) + 64;
            uint64_t v77 = a2 + 2 * i;
            uint64_t v78 = *(unsigned __int16 *)(v77 + 1924);
            if (v78 == 0xFFFF)
            {
              uint64_t v78 = (unsigned __int16)*v1138;
              *(_WORD *)(v77 + 1924) = v78;
              _WORD *v1138 = v78 + 1;
            }
            *(void *)&v1145[0] = (v78 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            unint64_t v60 = v1142;
          }
        }
        uint64_t v59 = (_WORD *)(a2 + 2004);
      }
      else
      {
        unsigned int v1131 = 0;
      }
      unsigned int v1128 = v62 & v64;
      unsigned int v1134 = v62 & v64 | v63;
      if (v64)
      {
        unint64_t v79 = 0;
        do
        {
          if ((v64 >> v79))
          {
            int v80 = *(_DWORD *)&v1140[4 * v79];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
            *(_DWORD *)(a2 + 16) = 2;
            int v81 = v80 + 320;
            uint64_t v82 = a2 + 4 * (v80 + 320);
            uint64_t v83 = *(unsigned __int16 *)(v82 + 260);
            if (v83 == 0xFFFF)
            {
              uint64_t v84 = *(__int16 *)(a2 + 1998);
              uint64_t v83 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v82 + 260) = v84;
              *(_WORD *)(a2 + 4 * v84 + 262) = v81;
              BOOL v75 = (v81 & 0xFFFFFFF0) == 144;
              __int16 v85 = v84 + 11;
              if (!v75) {
                __int16 v85 = v84 + 1;
              }
              *(_WORD *)(a2 + 1998) = v85;
            }
            *((void *)&v1145[0] + 1) = ((v83 << 48) | 0x19C840) + 64;
            uint64_t v86 = *(unsigned __int16 *)(a2 + 1900);
            if (v86 == 0xFFFF)
            {
              uint64_t v86 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1900) = v86;
              *(_WORD *)(a2 + 2004) = v86 + 1;
            }
            *(void *)&v1145[1] = (v86 << 48) | 0x19C840;
            uint64_t v87 = a2 + 2 * v79;
            uint64_t v88 = *(unsigned __int16 *)(v87 + 1924);
            if (v88 == 0xFFFF)
            {
              uint64_t v88 = (unsigned __int16)*v59;
              *(_WORD *)(v87 + 1924) = v88;
              *uint64_t v59 = v88 + 1;
            }
            *(void *)&v1145[0] = (v88 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            unint64_t v60 = v1142;
          }
          ++v79;
        }
        while (v79 < v60);
        unint64_t v89 = 0;
        int v90 = 0;
        do
        {
          if ((v64 >> v89))
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
            *(_DWORD *)(a2 + 16) = 2;
            uint64_t v91 = *(unsigned __int16 *)(v1136 + 2 * v89);
            if (v91 == 0xFFFF)
            {
              uint64_t v92 = (unsigned __int16)*v59;
              *(_WORD *)(v1136 + 2 * v89) = v92;
              *uint64_t v59 = v92 + 1;
              uint64_t v91 = *(unsigned __int16 *)(v1136 + 2 * v89);
              *((void *)&v1145[0] + 1) = (v92 << 48) | 0x19C840;
              if (v91 == 0xFFFF)
              {
                uint64_t v91 = (unsigned __int16)*v59;
                *(_WORD *)(v1136 + 2 * v89) = v91;
                *uint64_t v59 = v91 + 1;
              }
            }
            else
            {
              *((void *)&v1145[0] + 1) = (v91 << 48) | 0x19C840;
            }
            *(void *)&v1145[1] = (v91 << 48) | 0x19C840;
            uint64_t v93 = *(unsigned __int16 *)(a2 + 1946);
            if (v90)
            {
              if (v93 == 0xFFFF)
              {
                uint64_t v93 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1946) = v93;
                *(_WORD *)(a2 + 2004) = v93 + 1;
              }
              unint64_t v94 = ((unint64_t)(v89 == 1) << 17) | (v93 << 48) | ((unint64_t)(v89 == 2) << 16) | ((unint64_t)(v89 == 3) << 15) | 0x72601000;
            }
            else
            {
              if (v93 == 0xFFFF)
              {
                uint64_t v93 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1946) = v93;
                *(_WORD *)(a2 + 2004) = v93 + 1;
              }
              unint64_t v94 = (v93 << 48) | 0x72679000;
            }
            *(void *)&v1145[0] = v94;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            int v90 = 1;
            unint64_t v60 = v1142;
          }
          ++v89;
        }
        while (v89 < v60);
        int v1126 = 0;
      }
      else
      {
        int v1126 = 1;
      }
      unsigned int v58 = v1125;
      if (!v1125) {
        goto LABEL_129;
      }
LABEL_136:
      if ((v1126 & 1) == 0)
      {
        memset(&v1145[1], 0, 56);
        uint64_t v100 = 8 * (*(_DWORD *)(a2 + 16) & 7);
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v1144 = v100 | 0x3100080341;
        uint64_t v101 = *(unsigned __int16 *)(a2 + 1946);
        if (v101 == 0xFFFF)
        {
          uint64_t v101 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v101;
          *(_WORD *)(a2 + 2004) = v101 + 1;
        }
        *((void *)&v1145[0] + 1) = (v101 << 48) | 0x19C840;
        uint64_t v102 = *(unsigned __int16 *)(a2 + 1954);
        if (v102 == 0xFFFF)
        {
          uint64_t v102 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v102;
          *(_WORD *)(a2 + 2004) = v102 + 1;
        }
        *(void *)&v1145[0] = (v102 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        unint64_t v60 = v1142;
      }
      if (!v58 && (*a1 & 0x2000000000000) != 0)
      {
        memset((char *)v1145 + 8, 0, 64);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v103 = *(unsigned __int16 *)(a2 + 1900);
        if (v103 == 0xFFFF)
        {
          uint64_t v105 = *(unsigned __int16 *)(a2 + 2004);
          int v106 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1900) = v105;
          *(_WORD *)(a2 + 2004) = ++v106;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v105 << 48) | 0x19C840;
          if ((v106 & 0x10000) != 0)
          {
            uint64_t v105 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1900) = v105;
            *(_WORD *)(a2 + 2004) = v105 + 1;
          }
          uint64_t v104 = v105 << 48;
        }
        else
        {
          uint64_t v104 = v103 << 48;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v103 << 48) | 0x19C840;
        }
        *(void *)&v1145[1] = v104 | 0x1FE40;
        uint64_t v107 = *(unsigned __int16 *)(a2 + 1942);
        if (v107 == 0xFFFF)
        {
          uint64_t v107 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1942) = v107;
          *(_WORD *)(a2 + 2004) = v107 + 1;
        }
        *(void *)&v1145[0] = (v107 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        unint64_t v60 = v1142;
      }
      if ((v1126 & 1) == 0)
      {
        if (v60)
        {
          uint64_t v108 = 0;
          uint64_t v109 = 0;
          uint64_t v110 = 0;
          uint64_t v111 = 0;
          unint64_t v112 = 0;
          do
          {
            if ((v64 >> v112))
            {
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v113 = a2 + 2 * v112;
              uint64_t v114 = *(unsigned __int16 *)(v113 + 1924);
              if (v114 == 0xFFFF)
              {
                uint64_t v114 = (unsigned __int16)*v1138;
                *(_WORD *)(v113 + 1924) = v114;
                _WORD *v1138 = v114 + 1;
              }
              *((void *)&v1145[0] + 1) = (v114 << 48) | 0x19C840;
              uint64_t v115 = *(unsigned __int16 *)(a2 + 1954);
              if (v115 == 0xFFFF)
              {
                uint64_t v115 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1954) = v115;
                *(_WORD *)(a2 + 2004) = v115 + 1;
              }
              *(void *)&v1145[1] = v108 | (v115 << 48) | v109 | v110 | v111 | 0x40;
              uint64_t v116 = *(unsigned __int16 *)(v113 + 1924);
              if (v116 == 0xFFFF)
              {
                uint64_t v116 = (unsigned __int16)*v1138;
                *(_WORD *)(v113 + 1924) = v116;
                _WORD *v1138 = v116 + 1;
              }
              *(void *)&v1145[0] = (v116 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v60 = v1142;
            }
            ++v112;
            v111 += 0x8000;
            v110 += 0x2000;
            v109 += 2048;
            v108 += 512;
          }
          while (v112 < v60);
        }
        uint64_t v59 = (_WORD *)(a2 + 2004);
        if (v1128)
        {
          memset((char *)&v1145[1] + 8, 0, 48);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v117 = *(unsigned __int16 *)(a2 + 1946);
          if (v117 == 0xFFFF)
          {
            uint64_t v117 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v117;
            *(_WORD *)(a2 + 2004) = v117 + 1;
          }
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v117 << 48) | 0x19C840;
          uint64_t v118 = *(unsigned __int16 *)(a2 + 1954);
          if (v118 == 0xFFFF)
          {
            uint64_t v118 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1954) = v118;
            *(_WORD *)(a2 + 2004) = v118 + 1;
          }
          *(void *)&v1145[1] = (v118 << 48) | 0x19C840;
          if (v117 == 0xFFFF)
          {
            uint64_t v117 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v117;
            *(_WORD *)(a2 + 2004) = v117 + 1;
          }
          *(void *)&v1145[0] = (v117 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          unint64_t v119 = v1142;
          if (v1142)
          {
            unint64_t v120 = 0;
            int v121 = 0;
            do
            {
              if ((v1128 >> v120))
              {
                int v122 = *(_DWORD *)&v1140[4 * v120];
                memset(&v1145[1], 0, 56);
                uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
                *(_DWORD *)(a2 + 16) = 1;
                int v123 = v122 + 312;
                uint64_t v124 = (_WORD *)(a2 + 4 * (v122 + 312) + 260);
                uint64_t v125 = (unsigned __int16)*v124;
                if (v125 == 0xFFFF)
                {
                  uint64_t v126 = *(__int16 *)(a2 + 1998);
                  uint64_t v125 = *(unsigned __int16 *)(a2 + 1998);
                  *uint64_t v124 = v126;
                  *(_WORD *)(a2 + 4 * v126 + 262) = v123;
                  if ((v123 & 0xFFFFFFF0) == 0x90) {
                    __int16 v127 = v126 + 11;
                  }
                  else {
                    __int16 v127 = v126 + 1;
                  }
                  *(_WORD *)(a2 + 1998) = v127;
                }
                *((void *)&v1145[0] + 1) = ((v125 << 48) | 0x15440) + 64;
                uint64_t v128 = *(unsigned __int16 *)(a2 + 1954);
                if (v121)
                {
                  if (v128 == 0xFFFF)
                  {
                    uint64_t v128 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1954) = v128;
                    *(_WORD *)(a2 + 2004) = v128 + 1;
                  }
                  unint64_t v129 = ((unint64_t)(v120 == 1) << 17) | (v128 << 48) | ((unint64_t)(v120 == 2) << 16) | ((unint64_t)(v120 == 3) << 15) | 0x72601000;
                }
                else
                {
                  if (v128 == 0xFFFF)
                  {
                    uint64_t v128 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1954) = v128;
                    *(_WORD *)(a2 + 2004) = v128 + 1;
                  }
                  unint64_t v129 = (v128 << 48) | 0x72679000;
                }
                *(void *)&v1145[0] = v129;
                (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
                memset(&v1145[1], 0, 56);
                uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
                *(_DWORD *)(a2 + 16) = 1;
                uint64_t v130 = (unsigned __int16)*v124;
                if (v130 == 0xFFFF)
                {
                  uint64_t v131 = *(__int16 *)(a2 + 1998);
                  uint64_t v130 = *(unsigned __int16 *)(a2 + 1998);
                  *uint64_t v124 = v131;
                  *(_WORD *)(a2 + 4 * v131 + 262) = v123;
                  if ((v123 & 0xFFFFFFF0) == 0x90) {
                    __int16 v132 = v131 + 11;
                  }
                  else {
                    __int16 v132 = v131 + 1;
                  }
                  *(_WORD *)(a2 + 1998) = v132;
                }
                *((void *)&v1145[0] + 1) = (v130 << 48) | 0xAA80;
                uint64_t v133 = *(unsigned __int16 *)(a2 + 1962);
                if (v121)
                {
                  if (v133 == 0xFFFF)
                  {
                    uint64_t v133 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1962) = v133;
                    *(_WORD *)(a2 + 2004) = v133 + 1;
                  }
                  unint64_t v134 = ((unint64_t)(v120 == 1) << 17) | (v133 << 48) | ((unint64_t)(v120 == 2) << 16) | ((unint64_t)(v120 == 3) << 15) | 0x72601000;
                }
                else
                {
                  if (v133 == 0xFFFF)
                  {
                    uint64_t v133 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1962) = v133;
                    *(_WORD *)(a2 + 2004) = v133 + 1;
                  }
                  unint64_t v134 = (v133 << 48) | 0x72679000;
                }
                *(void *)&v1145[0] = v134;
                (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
                memset(&v1145[1], 0, 56);
                uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
                *(_DWORD *)(a2 + 16) = 1;
                uint64_t v135 = (unsigned __int16)*v124;
                if (v135 == 0xFFFF)
                {
                  uint64_t v136 = *(__int16 *)(a2 + 1998);
                  uint64_t v135 = *(unsigned __int16 *)(a2 + 1998);
                  *uint64_t v124 = v136;
                  *(_WORD *)(a2 + 4 * v136 + 262) = v123;
                  if ((v123 & 0xFFFFFFF0) == 0x90) {
                    __int16 v137 = v136 + 11;
                  }
                  else {
                    __int16 v137 = v136 + 1;
                  }
                  *(_WORD *)(a2 + 1998) = v137;
                }
                *((void *)&v1145[0] + 1) = (v135 << 48) | 0x80;
                uint64_t v138 = *(unsigned __int16 *)(a2 + 1970);
                if (v121)
                {
                  if (v138 == 0xFFFF)
                  {
                    uint64_t v138 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1970) = v138;
                    *(_WORD *)(a2 + 2004) = v138 + 1;
                  }
                  unint64_t v139 = ((unint64_t)(v120 == 1) << 17) | (v138 << 48) | ((unint64_t)(v120 == 2) << 16) | ((unint64_t)(v120 == 3) << 15) | 0x72601000;
                }
                else
                {
                  if (v138 == 0xFFFF)
                  {
                    uint64_t v138 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1970) = v138;
                    *(_WORD *)(a2 + 2004) = v138 + 1;
                  }
                  unint64_t v139 = (v138 << 48) | 0x72679000;
                }
                *(void *)&v1145[0] = v139;
                (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
                int v121 = 1;
                unint64_t v119 = v1142;
              }
              ++v120;
            }
            while (v120 < v119);
          }
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
          *(_DWORD *)(a2 + 16) = 3;
          uint64_t v140 = *(unsigned __int16 *)(a2 + 1946);
          if (v140 == 0xFFFF)
          {
            uint64_t v140 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v140;
            *(_WORD *)(a2 + 2004) = v140 + 1;
          }
          *((void *)&v1145[0] + 1) = (v140 << 48) | 0x19C840;
          uint64_t v141 = *(unsigned __int16 *)(a2 + 1954);
          if (v141 == 0xFFFF)
          {
            uint64_t v141 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1954) = v141;
            *(_WORD *)(a2 + 2004) = v141 + 1;
          }
          *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v141 << 48) | 0x19C840;
          uint64_t v142 = *(unsigned __int16 *)(a2 + 1962);
          if (v142 == 0xFFFF)
          {
            uint64_t v142 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1962) = v142;
            *(_WORD *)(a2 + 2004) = v142 + 1;
          }
          *((void *)&v1145[1] + 1) = (v142 << 48) | 0x19C840;
          uint64_t v59 = (_WORD *)(a2 + 2004);
          if (v141 == 0xFFFF)
          {
            uint64_t v141 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1954) = v141;
            *(_WORD *)(a2 + 2004) = v141 + 1;
          }
          *(void *)&v1145[0] = (v141 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
          *(_DWORD *)(a2 + 16) = 3;
          uint64_t v143 = *(unsigned __int16 *)(a2 + 1946);
          if (v143 == 0xFFFF)
          {
            uint64_t v143 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v143;
            *(_WORD *)(a2 + 2004) = v143 + 1;
          }
          *((void *)&v1145[0] + 1) = (v143 << 48) | 0x19C840;
          uint64_t v144 = *(unsigned __int16 *)(a2 + 1954);
          if (v144 == 0xFFFF)
          {
            uint64_t v144 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1954) = v144;
            *(_WORD *)(a2 + 2004) = v144 + 1;
          }
          *(void *)&v1145[1] = (v144 << 48) | 0x19C840;
          uint64_t v145 = *(unsigned __int16 *)(a2 + 1970);
          if (v145 == 0xFFFF)
          {
            uint64_t v145 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1970) = v145;
            *(_WORD *)(a2 + 2004) = v145 + 1;
          }
          *((void *)&v1145[1] + 1) = (v145 << 48) | 0x19C840;
          uint64_t v146 = *(unsigned __int16 *)(a2 + 1940);
          if (v146 == 0xFFFF)
          {
            uint64_t v146 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1940) = v146;
            *(_WORD *)(a2 + 2004) = v146 + 1;
          }
          *(void *)&v1145[0] = (v146 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          memset((char *)v1145 + 8, 0, 64);
          int v147 = *(_DWORD *)(a2 + 16);
          *(_DWORD *)(a2 + 16) = 1;
          uint64_t v1144 = (8 * (v147 & 7)) | 0x3100100381;
          uint64_t v148 = *(unsigned __int16 *)(a2 + 1940);
          if (v148 == 0xFFFF)
          {
            uint64_t v150 = *(unsigned __int16 *)(a2 + 2004);
            int v151 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1940) = v150;
            *(_WORD *)(a2 + 2004) = ++v151;
            *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v150 << 48) | 0x19C840;
            if ((v151 & 0x10000) != 0)
            {
              uint64_t v150 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1940) = v150;
              *(_WORD *)(a2 + 2004) = v150 + 1;
            }
            uint64_t v149 = v150 << 48;
          }
          else
          {
            uint64_t v149 = v148 << 48;
            *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v148 << 48) | 0x19C840;
          }
          *(void *)&v1145[0] = v149 | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          LODWORD(v60) = v1142;
        }
      }
      if (v60)
      {
        unint64_t v152 = 0;
        char v153 = 1;
        do
        {
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v154 = *(unsigned __int16 *)(a2 + 1902);
          if (v154 == 0xFFFF)
          {
            uint64_t v154 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1902) = v154;
            *(_WORD *)(a2 + 2004) = v154 + 1;
          }
          *((void *)&v1145[0] + 1) = (v154 << 48) | 0x19C840;
          uint64_t v155 = *(unsigned __int16 *)(v1136 + 2 * v152);
          if (v155 == 0xFFFF)
          {
            uint64_t v155 = (unsigned __int16)*v59;
            *(_WORD *)(v1136 + 2 * v152) = v155;
            *uint64_t v59 = v155 + 1;
          }
          *(void *)&v1145[1] = (v155 << 48) | 0x19C840;
          uint64_t v156 = *(unsigned __int16 *)(a2 + 1920);
          if (v153)
          {
            if (v156 == 0xFFFF)
            {
              uint64_t v156 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1920) = v156;
              *(_WORD *)(a2 + 2004) = v156 + 1;
            }
            unint64_t v157 = (v156 << 48) | 0x72679000;
          }
          else
          {
            if (v156 == 0xFFFF)
            {
              uint64_t v156 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1920) = v156;
              *(_WORD *)(a2 + 2004) = v156 + 1;
            }
            unint64_t v157 = ((unint64_t)(v152 == 1) << 17) | (v156 << 48) | ((unint64_t)(v152 == 2) << 16) | ((unint64_t)(v152 == 3) << 15) | 0x72601000;
          }
          *(void *)&v1145[0] = v157;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          char v153 = 0;
          ++v152;
          unint64_t v60 = v1142;
        }
        while (v152 < v1142);
        if (!v63) {
          goto LABEL_335;
        }
        unint64_t v158 = 0;
        int v159 = 0;
        do
        {
          if ((v63 >> v158))
          {
            int v160 = *(_DWORD *)&v1140[4 * v158];
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
            *(_DWORD *)(a2 + 16) = 2;
            int v161 = v160 + 328;
            uint64_t v162 = a2 + 4 * (v160 + 328);
            uint64_t v163 = *(unsigned __int16 *)(v162 + 260);
            if (v163 == 0xFFFF)
            {
              uint64_t v164 = *(__int16 *)(a2 + 1998);
              uint64_t v163 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v162 + 260) = v164;
              *(_WORD *)(a2 + 4 * v164 + 262) = v161;
              BOOL v75 = (v161 & 0xFFFFFFF0) == 144;
              __int16 v165 = v164 + 11;
              if (!v75) {
                __int16 v165 = v164 + 1;
              }
              *(_WORD *)(a2 + 1998) = v165;
            }
            *((void *)&v1145[0] + 1) = ((v163 << 48) | 0x19C840) + 64;
            uint64_t v166 = *(unsigned __int16 *)(v1136 + 2 * v158);
            if (v166 == 0xFFFF)
            {
              uint64_t v166 = (unsigned __int16)*v59;
              *(_WORD *)(v1136 + 2 * v158) = v166;
              *uint64_t v59 = v166 + 1;
            }
            *(void *)&v1145[1] = ((v166 << 48) | 0x19C840) + 16;
            uint64_t v167 = *(unsigned __int16 *)(a2 + 1954);
            if (v159)
            {
              if (v167 == 0xFFFF)
              {
                uint64_t v167 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1954) = v167;
                *(_WORD *)(a2 + 2004) = v167 + 1;
              }
              unint64_t v168 = ((unint64_t)(v158 == 1) << 17) | (v167 << 48) | ((unint64_t)(v158 == 2) << 16) | ((unint64_t)(v158 == 3) << 15) | 0x72601000;
            }
            else
            {
              if (v167 == 0xFFFF)
              {
                uint64_t v167 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1954) = v167;
                *(_WORD *)(a2 + 2004) = v167 + 1;
              }
              unint64_t v168 = (v167 << 48) | 0x72679000;
            }
            *(void *)&v1145[0] = v168;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            int v159 = 1;
            unint64_t v60 = v1142;
          }
          ++v158;
        }
        while (v158 < v60);
        unint64_t v169 = 0;
        int v170 = 0;
        do
        {
          if ((v63 >> v169))
          {
            int v171 = *(_DWORD *)&v1140[4 * v169];
            memset(&v1145[1], 0, 56);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
            *(_DWORD *)(a2 + 16) = 1;
            int v172 = v171 + 296;
            uint64_t v173 = a2 + 4 * (v171 + 296);
            uint64_t v174 = *(unsigned __int16 *)(v173 + 260);
            if (v174 == 0xFFFF)
            {
              uint64_t v175 = *(__int16 *)(a2 + 1998);
              uint64_t v174 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v173 + 260) = v175;
              *(_WORD *)(a2 + 4 * v175 + 262) = v172;
              BOOL v75 = (v172 & 0xFFFFFFF0) == 144;
              __int16 v176 = v175 + 11;
              if (!v75) {
                __int16 v176 = v175 + 1;
              }
              *(_WORD *)(a2 + 1998) = v176;
            }
            *((void *)&v1145[0] + 1) = ((v174 << 48) | 0x1FE40) + 64;
            uint64_t v177 = *(unsigned __int16 *)(a2 + 1946);
            if (v170)
            {
              if (v177 == 0xFFFF)
              {
                uint64_t v177 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1946) = v177;
                *(_WORD *)(a2 + 2004) = v177 + 1;
              }
              unint64_t v178 = ((unint64_t)(v169 == 1) << 17) | (v177 << 48) | ((unint64_t)(v169 == 2) << 16) | ((unint64_t)(v169 == 3) << 15) | 0x72601000;
            }
            else
            {
              if (v177 == 0xFFFF)
              {
                uint64_t v177 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1946) = v177;
                *(_WORD *)(a2 + 2004) = v177 + 1;
              }
              unint64_t v178 = (v177 << 48) | 0x72679000;
            }
            *(void *)&v1145[0] = v178;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            memset(&v1145[1], 0, 56);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
            *(_DWORD *)(a2 + 16) = 1;
            int v179 = v171 + 312;
            uint64_t v180 = a2 + 4 * (v171 + 312);
            uint64_t v181 = *(unsigned __int16 *)(v180 + 260);
            if (v181 == 0xFFFF)
            {
              uint64_t v182 = *(__int16 *)(a2 + 1998);
              uint64_t v181 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v180 + 260) = v182;
              *(_WORD *)(a2 + 4 * v182 + 262) = v179;
              BOOL v75 = (v179 & 0xFFFFFFF0) == 144;
              __int16 v183 = v182 + 11;
              if (!v75) {
                __int16 v183 = v182 + 1;
              }
              *(_WORD *)(a2 + 1998) = v183;
            }
            *((void *)&v1145[0] + 1) = ((v181 << 48) | 0x1FE40) + 64;
            uint64_t v184 = *(unsigned __int16 *)(a2 + 1962);
            if (v170)
            {
              if (v184 == 0xFFFF)
              {
                uint64_t v184 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1962) = v184;
                *(_WORD *)(a2 + 2004) = v184 + 1;
              }
              unint64_t v185 = ((unint64_t)(v169 == 1) << 17) | (v184 << 48) | ((unint64_t)(v169 == 2) << 16) | ((unint64_t)(v169 == 3) << 15) | 0x72601000;
            }
            else
            {
              if (v184 == 0xFFFF)
              {
                uint64_t v184 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1962) = v184;
                *(_WORD *)(a2 + 2004) = v184 + 1;
              }
              unint64_t v185 = (v184 << 48) | 0x72679000;
            }
            *(void *)&v1145[0] = v185;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            int v170 = 1;
            unint64_t v60 = v1142;
          }
          ++v169;
        }
        while (v169 < v60);
      }
      else if (!v63)
      {
        uint64_t v59 = (_WORD *)(a2 + 2004);
        if ((*a1 & 0x400000000000000) != 0) {
          goto LABEL_435;
        }
        if ((*a1 & 0x2000000000000) == 0) {
          goto LABEL_402;
        }
        goto LABEL_451;
      }
      if ((v63 & ~v1128) != 0)
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000C82;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v186 = *(unsigned __int16 *)(a2 + 1954);
        if (v186 == 0xFFFF)
        {
          uint64_t v186 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v186;
          *(_WORD *)(a2 + 2004) = v186 + 1;
        }
        *((void *)&v1145[0] + 1) = (v186 << 48) | 0x19C840;
        uint64_t v187 = *(unsigned __int16 *)(a2 + 1946);
        if (v187 == 0xFFFF)
        {
          uint64_t v187 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v187;
          *(_WORD *)(a2 + 2004) = v187 + 1;
        }
        *(void *)&v1145[1] = (v187 << 48) | 0x19C840;
        uint64_t v188 = *(unsigned __int16 *)(a2 + 1940);
        if (v1126)
        {
          if (v188 == 0xFFFF)
          {
            uint64_t v188 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1940) = v188;
            *(_WORD *)(a2 + 2004) = v188 + 1;
          }
          uint64_t v189 = (v188 << 48) | 0x72679000;
        }
        else
        {
          if (v188 == 0xFFFF)
          {
            uint64_t v188 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1940) = v188;
            *(_WORD *)(a2 + 2004) = v188 + 1;
          }
          int8x16_t v190 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v63 & ~v1128), (uint32x4_t)xmmword_2393DBEB0), (int8x16_t)xmmword_2393D2760);
          *(int8x8_t *)v190.i8 = vorr_s8(*(int8x8_t *)v190.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v190, v190, 8uLL));
          v191.i64[0] = v190.u32[0];
          v191.i64[1] = v190.u32[1];
          uint64_t v189 = *(void *)&vorr_s8((int8x8_t)v190.u32[0], (int8x8_t)*(_OWORD *)&vextq_s8(v191, v191, 8uLL)) | (v188 << 48) | 0x72601000;
        }
        *(void *)&v1145[0] = v189;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      }
      if ((v1128 & v63) != 0)
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000C82;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v192 = *(unsigned __int16 *)(a2 + 1954);
        if (v192 == 0xFFFF)
        {
          uint64_t v192 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v192;
          *(_WORD *)(a2 + 2004) = v192 + 1;
        }
        *((void *)&v1145[0] + 1) = (v192 << 48) | 0x19C840;
        uint64_t v193 = *(unsigned __int16 *)(a2 + 1946);
        if (v193 == 0xFFFF)
        {
          uint64_t v195 = *(unsigned __int16 *)(a2 + 2004);
          int v196 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v195;
          *(_WORD *)(a2 + 2004) = ++v196;
          *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v195 << 48) | 0x19C840;
          if ((v196 & 0x10000) != 0)
          {
            uint64_t v195 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v195;
            *(_WORD *)(a2 + 2004) = v195 + 1;
          }
          uint64_t v194 = v195 << 48;
        }
        else
        {
          uint64_t v194 = v193 << 48;
          *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v193 << 48) | 0x19C840;
        }
        *(void *)&v1145[0] = v194 | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v197 = *(unsigned __int16 *)(a2 + 1940);
        if (v197 == 0xFFFF)
        {
          uint64_t v197 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v197;
          *(_WORD *)(a2 + 2004) = v197 + 1;
        }
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v197 << 48) | 0x19C840;
        uint64_t v198 = *(unsigned __int16 *)(a2 + 1946);
        if (v198 == 0xFFFF)
        {
          uint64_t v198 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v198;
          *(_WORD *)(a2 + 2004) = v198 + 1;
        }
        *(void *)&v1145[1] = (v198 << 48) | 0x19C840;
        if (v197 == 0xFFFF)
        {
          uint64_t v197 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v197;
          *(_WORD *)(a2 + 2004) = v197 + 1;
        }
        int8x16_t v199 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v1128 & v63), (uint32x4_t)xmmword_2393DBEB0), (int8x16_t)xmmword_2393D2760);
        *(int8x8_t *)v199.i8 = vorr_s8(*(int8x8_t *)v199.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v199, v199, 8uLL));
        v200.i64[0] = v199.u32[0];
        v200.i64[1] = v199.u32[1];
        *(void *)&v1145[0] = *(void *)&vorr_s8((int8x8_t)v199.u32[0], (int8x8_t)*(_OWORD *)&vextq_s8(v200, v200, 8uLL)) | (v197 << 48) | 0x72601000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      }
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000E02;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v201 = *(unsigned __int16 *)(a2 + 1954);
      if (v201 == 0xFFFF)
      {
        uint64_t v201 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v201;
        *(_WORD *)(a2 + 2004) = v201 + 1;
      }
      *((void *)&v1145[0] + 1) = (v201 << 48) | 0x19C840;
      uint64_t v202 = *(unsigned __int16 *)(a2 + 1962);
      uint64_t v59 = (_WORD *)(a2 + 2004);
      if (v202 == 0xFFFF)
      {
        uint64_t v202 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1962) = v202;
        *(_WORD *)(a2 + 2004) = v202 + 1;
      }
      *(void *)&v1145[1] = (v202 << 48) | 0x19C840;
      uint64_t v203 = *(unsigned __int16 *)(a2 + 1946);
      if (v203 == 0xFFFF)
      {
        uint64_t v203 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v203;
        *(_WORD *)(a2 + 2004) = v203 + 1;
      }
      *(void *)&v1145[0] = (v203 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v204 = *(unsigned __int16 *)(a2 + 1940);
      if (v204 == 0xFFFF)
      {
        uint64_t v204 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v204;
        *(_WORD *)(a2 + 2004) = v204 + 1;
      }
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v204 << 48) | 0x19C840;
      uint64_t v205 = *(unsigned __int16 *)(a2 + 1946);
      if (v205 == 0xFFFF)
      {
        uint64_t v205 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v205;
        *(_WORD *)(a2 + 2004) = v205 + 1;
      }
      *(void *)&v1145[1] = (v205 << 48) | 0x19C840;
      if (v204 == 0xFFFF)
      {
        uint64_t v204 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v204;
        *(_WORD *)(a2 + 2004) = v204 + 1;
      }
      int8x16_t v206 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v63), (uint32x4_t)xmmword_2393DBEB0), (int8x16_t)xmmword_2393D2760);
      *(int8x8_t *)v206.i8 = vorr_s8(*(int8x8_t *)v206.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v206, v206, 8uLL));
      v207.i64[0] = v206.u32[0];
      v207.i64[1] = v206.u32[1];
      *(void *)&v1145[0] = *(void *)&vorr_s8((int8x8_t)v206.u32[0], (int8x8_t)*(_OWORD *)&vextq_s8(v207, v207, 8uLL)) | (v204 << 48) | 0x72601000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      unint64_t v60 = v1142;
LABEL_335:
      if ((*a1 & 0x400000000000000) != 0)
      {
        if (!v60)
        {
LABEL_435:
          if ((*a1 & 0x2000000000000) != 0)
          {
            if (v60)
            {
              unint64_t v272 = 0;
              do
              {
                memset((char *)&v1145[1] + 8, 0, 48);
                uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
                *(_DWORD *)(a2 + 16) = 2;
                uint64_t v273 = a2 + 2 * v272;
                uint64_t v274 = *(unsigned __int16 *)(v273 + 1932);
                if (v274 == 0xFFFF)
                {
                  uint64_t v274 = (unsigned __int16)*v59;
                  *(_WORD *)(v273 + 1932) = v274;
                  *uint64_t v59 = v274 + 1;
                }
                *((void *)&v1145[0] + 1) = (v274 << 48) | 0x19C840;
                uint64_t v275 = *(unsigned __int16 *)(v273 + 1924);
                if (v275 == 0xFFFF)
                {
                  uint64_t v275 = (unsigned __int16)*v59;
                  *(_WORD *)(v273 + 1924) = v275;
                  *uint64_t v59 = v275 + 1;
                }
                *(void *)&v1145[1] = (v275 << 48) | 0x19C840;
                uint64_t v276 = *(unsigned __int16 *)(v273 + 1932);
                if (v276 == 0xFFFF)
                {
                  uint64_t v276 = (unsigned __int16)*v59;
                  *(_WORD *)(v273 + 1932) = v276;
                  *uint64_t v59 = v276 + 1;
                }
                *(void *)&v1145[0] = (v276 << 48) | 0x72679000;
                (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
                ++v272;
              }
              while (v272 < v1142);
              unint64_t v277 = 0;
              char v278 = 1;
              do
              {
                memset(v1145, 0, 72);
                uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
                *(_DWORD *)(a2 + 16) = 2;
                uint64_t v279 = *(unsigned __int16 *)(v1130 + 2 * v277);
                if (v279 == 0xFFFF)
                {
                  uint64_t v279 = (unsigned __int16)*v59;
                  *(_WORD *)(v1130 + 2 * v277) = v279;
                  *uint64_t v59 = v279 + 1;
                }
                *((void *)&v1145[0] + 1) = (v279 << 48) | 0x19C840;
                uint64_t v280 = *(unsigned __int16 *)(a2 + 1942);
                if (v280 == 0xFFFF)
                {
                  uint64_t v280 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1942) = v280;
                  *(_WORD *)(a2 + 2004) = v280 + 1;
                }
                *(void *)&v1145[1] = (v280 << 48) | 0x19C840;
                uint64_t v281 = *(unsigned __int16 *)(a2 + 1922);
                if (v278)
                {
                  if (v281 == 0xFFFF)
                  {
                    uint64_t v281 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1922) = v281;
                    *(_WORD *)(a2 + 2004) = v281 + 1;
                  }
                  unint64_t v282 = (v281 << 48) | 0x72679000;
                }
                else
                {
                  if (v281 == 0xFFFF)
                  {
                    uint64_t v281 = *(unsigned __int16 *)(a2 + 2004);
                    *(_WORD *)(a2 + 1922) = v281;
                    *(_WORD *)(a2 + 2004) = v281 + 1;
                  }
                  unint64_t v282 = ((unint64_t)(v277 == 1) << 17) | (v281 << 48) | ((unint64_t)(v277 == 2) << 16) | ((unint64_t)(v277 == 3) << 15) | 0x72601000;
                }
                *(void *)&v1145[0] = v282;
                (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
                char v278 = 0;
                ++v277;
              }
              while (v277 < v1142);
            }
          }
          else if (v60)
          {
            unint64_t v262 = 0;
            char v263 = 1;
            char v264 = (_WORD *)(a2 + 1932);
            do
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v265 = (unsigned __int16)*v264;
              if (v265 == 0xFFFF)
              {
                uint64_t v265 = (unsigned __int16)*v59;
                *char v264 = v265;
                *uint64_t v59 = v265 + 1;
              }
              *((void *)&v1145[0] + 1) = (v265 << 48) | 0x15440;
              uint64_t v266 = (unsigned __int16)*(v264 - 4);
              if (v266 == 0xFFFF)
              {
                uint64_t v266 = (unsigned __int16)*v59;
                *(v264 - 4) = v266;
                *uint64_t v59 = v266 + 1;
              }
              *(void *)&v1145[1] = (v266 << 48) | 0x15440;
              uint64_t v267 = *(unsigned __int16 *)(a2 + 1922);
              if (v263)
              {
                if (v267 == 0xFFFF)
                {
                  uint64_t v267 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1922) = v267;
                  *(_WORD *)(a2 + 2004) = v267 + 1;
                }
                unint64_t v268 = (v267 << 48) | 0x72679000;
              }
              else
              {
                if (v267 == 0xFFFF)
                {
                  uint64_t v267 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1922) = v267;
                  *(_WORD *)(a2 + 2004) = v267 + 1;
                }
                unint64_t v268 = ((unint64_t)(v262 == 1) << 17) | (v267 << 48) | ((unint64_t)(v262 == 2) << 16) | ((unint64_t)(v262 == 3) << 15) | 0x72601000;
              }
              *(void *)&v1145[0] = v268;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              char v263 = 0;
              ++v262;
              ++v264;
            }
            while (v262 < v1142);
          }
          goto LABEL_517;
        }
        unint64_t v218 = 0;
        do
        {
          memset((char *)&v1145[1] + 8, 0, 48);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B82;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v219 = *(unsigned __int16 *)(a2 + 1902);
          if (v219 == 0xFFFF)
          {
            uint64_t v219 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1902) = v219;
            *(_WORD *)(a2 + 2004) = v219 + 1;
          }
          *((void *)&v1145[0] + 1) = (v219 << 48) | 0x19C840;
          uint64_t v220 = a2 + 2 * v218;
          uint64_t v221 = *(unsigned __int16 *)(v220 + 1924);
          if (v221 == 0xFFFF)
          {
            uint64_t v221 = (unsigned __int16)*v59;
            *(_WORD *)(v220 + 1924) = v221;
            *uint64_t v59 = v221 + 1;
          }
          *(void *)&v1145[1] = (v221 << 48) | 0x19C840;
          uint64_t v222 = *(unsigned __int16 *)(v220 + 1932);
          if (v222 == 0xFFFF)
          {
            uint64_t v222 = (unsigned __int16)*v59;
            *(_WORD *)(v220 + 1932) = v222;
            *uint64_t v59 = v222 + 1;
          }
          *(void *)&v1145[0] = (v222 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          ++v218;
        }
        while (v218 < v1142);
        uint64_t v223 = 966;
        do
        {
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B82;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v224 = *(unsigned __int16 *)(a2 + 1902);
          if (v224 == 0xFFFF)
          {
            uint64_t v224 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1902) = v224;
            *(_WORD *)(a2 + 2004) = v224 + 1;
          }
          *((void *)&v1145[0] + 1) = (v224 << 48) | 0x19C840;
          uint64_t v225 = *(unsigned __int16 *)(a2 + 2 * v223);
          if (v225 == 0xFFFF)
          {
            uint64_t v226 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 2 * v223) = v226;
            *(_WORD *)(a2 + 2004) = v226 + 1;
            uint64_t v225 = *(unsigned __int16 *)(a2 + 2 * v223);
            *(void *)&v1145[1] = (v226 << 48) | 0x19C840;
            if (v225 == 0xFFFF)
            {
              uint64_t v225 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 2 * v223) = v225;
              *(_WORD *)(a2 + 2004) = v225 + 1;
            }
          }
          else
          {
            *(void *)&v1145[1] = (v225 << 48) | 0x19C840;
          }
          *(void *)&v1145[0] = (v225 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          unint64_t v227 = v223 - 965;
          ++v223;
        }
        while (v227 < v1142);
        uint64_t v228 = 966;
        while (2)
        {
          memset((char *)v1145 + 8, 0, 64);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v229 = *(unsigned __int16 *)(a2 + 2 * v228);
          if (v229 != 0xFFFF)
          {
            *((void *)&v1145[0] + 1) = (v229 << 48) | 0x19C840;
            goto LABEL_372;
          }
          uint64_t v230 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 2 * v228) = v230;
          *(_WORD *)(a2 + 2004) = v230 + 1;
          uint64_t v229 = *(unsigned __int16 *)(a2 + 2 * v228);
          *((void *)&v1145[0] + 1) = (v230 << 48) | 0x19C840;
          if (v229 == 0xFFFF)
          {
            uint64_t v232 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 2 * v228) = v232;
            *(_WORD *)(a2 + 2004) = v232 + 1;
            uint64_t v229 = *(unsigned __int16 *)(a2 + 2 * v228);
            *(void *)&v1145[1] = (v232 << 48) | 0x19C840;
            if (v229 == 0xFFFF)
            {
              uint64_t v229 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 2 * v228) = v229;
              *(_WORD *)(a2 + 2004) = v229 + 1;
            }
          }
          else
          {
LABEL_372:
            *(void *)&v1145[1] = (v229 << 48) | 0x19C840;
          }
          *(void *)&v1145[0] = (v229 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          unint64_t v231 = v228 - 965;
          ++v228;
          LODWORD(v60) = v1142;
          if (v231 >= v1142) {
            goto LABEL_435;
          }
          continue;
        }
      }
      if ((*a1 & 0x2000000000000) == 0)
      {
        char v208 = v1120;
        if (!v60) {
          char v208 = 1;
        }
        if ((v208 & 1) == 0)
        {
          unint64_t v209 = 0;
          do
          {
            if ((v1131 >> v209))
            {
              int v210 = *(_DWORD *)&v1140[4 * v209];
              memset(&v1145[1], 0, 56);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
              *(_DWORD *)(a2 + 16) = 1;
              int v211 = v210 + 304;
              uint64_t v212 = a2 + 4 * (v210 + 304);
              uint64_t v213 = *(unsigned __int16 *)(v212 + 260);
              if (v213 == 0xFFFF)
              {
                uint64_t v214 = *(__int16 *)(a2 + 1998);
                uint64_t v213 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v212 + 260) = v214;
                *(_WORD *)(a2 + 4 * v214 + 262) = v211;
                BOOL v75 = (v211 & 0xFFFFFFF0) == 144;
                __int16 v215 = v214 + 11;
                if (!v75) {
                  __int16 v215 = v214 + 1;
                }
                *(_WORD *)(a2 + 1998) = v215;
              }
              *((void *)&v1145[0] + 1) = ((v213 << 48) | 0x19C840) + 64;
              uint64_t v216 = a2 + 2 * v209;
              uint64_t v217 = *(unsigned __int16 *)(v216 + 1932);
              if (v217 == 0xFFFF)
              {
                uint64_t v217 = (unsigned __int16)*v59;
                *(_WORD *)(v216 + 1932) = v217;
                *uint64_t v59 = v217 + 1;
              }
              *(void *)&v1145[0] = (v217 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v60 = v1142;
            }
            ++v209;
          }
          while (v209 < v60);
        }
LABEL_402:
        if (v1126) {
          goto LABEL_503;
        }
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v244 = 8 * (*(_DWORD *)(a2 + 16) & 7);
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1144 = v244 | 0x3100011042;
        uint64_t v245 = *(unsigned __int16 *)(a2 + 1904);
        if (v245 == 0xFFFF)
        {
          uint64_t v245 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1904) = v245;
          *(_WORD *)(a2 + 2004) = v245 + 1;
        }
        *((void *)&v1145[0] + 1) = (v245 << 48) | 0x19C840;
        *(void *)&v1145[1] = 2560163840;
        uint64_t v246 = *(unsigned __int16 *)(a2 + 1946);
        if (v246 == 0xFFFF)
        {
          uint64_t v246 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v246;
          *(_WORD *)(a2 + 2004) = v246 + 1;
        }
        *(void *)&v1145[0] = (v246 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        unint64_t v247 = v1142;
        if (v1142)
        {
          unint64_t v248 = 0;
          do
          {
            if ((v64 >> v248))
            {
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v249 = *(unsigned __int16 *)(a2 + 1946);
              if (v249 == 0xFFFF)
              {
                uint64_t v249 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1946) = v249;
                *(_WORD *)(a2 + 2004) = v249 + 1;
              }
              *((void *)&v1145[0] + 1) = (v249 << 48) | 0x19C840;
              uint64_t v250 = a2 + 2 * v248;
              uint64_t v251 = *(unsigned __int16 *)(v250 + 1924);
              if (v251 == 0xFFFF)
              {
                uint64_t v251 = (unsigned __int16)*v1138;
                *(_WORD *)(v250 + 1924) = v251;
                _WORD *v1138 = v251 + 1;
              }
              *(void *)&v1145[1] = (v251 << 48) | 0x19C840;
              uint64_t v252 = *(unsigned __int16 *)(v250 + 1932);
              if (v252 == 0xFFFF)
              {
                uint64_t v252 = (unsigned __int16)*v1138;
                *(_WORD *)(v250 + 1932) = v252;
                _WORD *v1138 = v252 + 1;
              }
              *(void *)&v1145[0] = (v252 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v247 = v1142;
            }
            ++v248;
          }
          while (v248 < v247);
          unint64_t v253 = 0;
          int v254 = 0;
          do
          {
            if ((v64 >> v253))
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v255 = *(unsigned __int16 *)(v1130 + 2 * v253);
              if (v255 == 0xFFFF)
              {
                uint64_t v256 = (unsigned __int16)*v1138;
                *(_WORD *)(v1130 + 2 * v253) = v256;
                _WORD *v1138 = v256 + 1;
                uint64_t v255 = *(unsigned __int16 *)(v1130 + 2 * v253);
                *((void *)&v1145[0] + 1) = (v256 << 48) | 0x19C840;
                if (v255 == 0xFFFF)
                {
                  uint64_t v255 = (unsigned __int16)*v1138;
                  *(_WORD *)(v1130 + 2 * v253) = v255;
                  _WORD *v1138 = v255 + 1;
                }
              }
              else
              {
                *((void *)&v1145[0] + 1) = (v255 << 48) | 0x19C840;
              }
              *(void *)&v1145[1] = (v255 << 48) | 0x19C840;
              uint64_t v257 = *(unsigned __int16 *)(a2 + 1946);
              if (v254)
              {
                if (v257 == 0xFFFF)
                {
                  uint64_t v257 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1946) = v257;
                  *(_WORD *)(a2 + 2004) = v257 + 1;
                }
                unint64_t v258 = ((unint64_t)(v253 == 1) << 17) | (v257 << 48) | ((unint64_t)(v253 == 2) << 16) | ((unint64_t)(v253 == 3) << 15) | 0x72601000;
              }
              else
              {
                if (v257 == 0xFFFF)
                {
                  uint64_t v257 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1946) = v257;
                  *(_WORD *)(a2 + 2004) = v257 + 1;
                }
                unint64_t v258 = (v257 << 48) | 0x72679000;
              }
              *(void *)&v1145[0] = v258;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              int v254 = 1;
              unint64_t v247 = v1142;
            }
            ++v253;
          }
          while (v253 < v247);
        }
        memset((char *)v1145 + 8, 0, 64);
        uint64_t v259 = 8 * (*(_DWORD *)(a2 + 16) & 7);
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v1144 = v259 | 0x3100080341;
        uint64_t v260 = *(unsigned __int16 *)(a2 + 1946);
        if (v260 == 0xFFFF)
        {
          uint64_t v294 = *(unsigned __int16 *)(a2 + 2004);
          int v295 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v294;
          *(_WORD *)(a2 + 2004) = ++v295;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v294 << 48) | 0x19C840;
          if ((v295 & 0x10000) != 0)
          {
            uint64_t v294 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v294;
            *(_WORD *)(a2 + 2004) = v294 + 1;
          }
          uint64_t v261 = v294 << 48;
        }
        else
        {
          uint64_t v261 = v260 << 48;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v260 << 48) | 0x19C840;
        }
        *(void *)&v1145[0] = v261 | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        unint64_t v60 = v1142;
        if (v1142)
        {
          uint64_t v296 = 0;
          uint64_t v297 = 0;
          uint64_t v298 = 0;
          uint64_t v299 = 0;
          unint64_t v300 = 0;
          do
          {
            if ((v64 >> v300))
            {
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v301 = a2 + 2 * v300;
              uint64_t v302 = *(unsigned __int16 *)(v301 + 1932);
              if (v302 == 0xFFFF)
              {
                uint64_t v302 = (unsigned __int16)*v1138;
                *(_WORD *)(v301 + 1932) = v302;
                _WORD *v1138 = v302 + 1;
              }
              *((void *)&v1145[0] + 1) = (v302 << 48) | 0x19C840;
              uint64_t v303 = *(unsigned __int16 *)(a2 + 1946);
              if (v303 == 0xFFFF)
              {
                uint64_t v303 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1946) = v303;
                *(_WORD *)(a2 + 2004) = v303 + 1;
              }
              *(void *)&v1145[1] = v296 | (v303 << 48) | v297 | v298 | v299 | 0x40;
              uint64_t v304 = *(unsigned __int16 *)(v301 + 1932);
              if (v304 == 0xFFFF)
              {
                uint64_t v304 = (unsigned __int16)*v1138;
                *(_WORD *)(v301 + 1932) = v304;
                _WORD *v1138 = v304 + 1;
              }
              *(void *)&v1145[0] = (v304 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v60 = v1142;
            }
            ++v300;
            v299 += 0x8000;
            v298 += 0x2000;
            v297 += 2048;
            v296 += 512;
          }
          while (v300 < v60);
LABEL_503:
          if (v60)
          {
            unint64_t v305 = 0;
            char v306 = 1;
            do
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v307 = *(unsigned __int16 *)(a2 + 1902);
              if (v307 == 0xFFFF)
              {
                uint64_t v307 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1902) = v307;
                *(_WORD *)(a2 + 2004) = v307 + 1;
              }
              *((void *)&v1145[0] + 1) = (v307 << 48) | 0x19C840;
              uint64_t v308 = *(unsigned __int16 *)(v1130 + 2 * v305);
              if (v308 == 0xFFFF)
              {
                uint64_t v308 = (unsigned __int16)*v1138;
                *(_WORD *)(v1130 + 2 * v305) = v308;
                _WORD *v1138 = v308 + 1;
              }
              *(void *)&v1145[1] = (v308 << 48) | 0x19C840;
              uint64_t v309 = *(unsigned __int16 *)(a2 + 1922);
              if (v306)
              {
                if (v309 == 0xFFFF)
                {
                  uint64_t v309 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1922) = v309;
                  *(_WORD *)(a2 + 2004) = v309 + 1;
                }
                unint64_t v310 = (v309 << 48) | 0x72679000;
              }
              else
              {
                if (v309 == 0xFFFF)
                {
                  uint64_t v309 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1922) = v309;
                  *(_WORD *)(a2 + 2004) = v309 + 1;
                }
                unint64_t v310 = ((unint64_t)(v305 == 1) << 17) | (v309 << 48) | ((unint64_t)(v305 == 2) << 16) | ((unint64_t)(v305 == 3) << 15) | 0x72601000;
              }
              *(void *)&v1145[0] = v310;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              char v306 = 0;
              ++v305;
            }
            while (v305 < v1142);
          }
          goto LABEL_517;
        }
        goto LABEL_517;
      }
      if (v60)
      {
        unint64_t v233 = 0;
        do
        {
          memset((char *)&v1145[1] + 8, 0, 48);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v234 = *(unsigned __int16 *)(a2 + 1942);
          if (v234 == 0xFFFF)
          {
            uint64_t v234 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1942) = v234;
            *(_WORD *)(a2 + 2004) = v234 + 1;
          }
          *((void *)&v1145[0] + 1) = (v234 << 48) | 0x19C840;
          uint64_t v235 = a2 + 2 * v233;
          uint64_t v236 = *(unsigned __int16 *)(v235 + 1924);
          if (v236 == 0xFFFF)
          {
            uint64_t v236 = (unsigned __int16)*v59;
            *(_WORD *)(v235 + 1924) = v236;
            *uint64_t v59 = v236 + 1;
          }
          *(void *)&v1145[1] = (v236 << 48) | 0x19C840;
          uint64_t v237 = *(unsigned __int16 *)(v235 + 1932);
          if (v237 == 0xFFFF)
          {
            uint64_t v237 = (unsigned __int16)*v59;
            *(_WORD *)(v235 + 1932) = v237;
            *uint64_t v59 = v237 + 1;
          }
          *(void *)&v1145[0] = (v237 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          ++v233;
        }
        while (v233 < v1142);
        unint64_t v238 = 0;
        char v239 = 1;
        do
        {
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v240 = *(unsigned __int16 *)(v1130 + 2 * v238);
          if (v240 == 0xFFFF)
          {
            uint64_t v241 = (unsigned __int16)*v59;
            *(_WORD *)(v1130 + 2 * v238) = v241;
            *uint64_t v59 = v241 + 1;
            uint64_t v240 = *(unsigned __int16 *)(v1130 + 2 * v238);
            *((void *)&v1145[0] + 1) = (v241 << 48) | 0x19C840;
            if (v240 == 0xFFFF)
            {
              uint64_t v240 = (unsigned __int16)*v59;
              *(_WORD *)(v1130 + 2 * v238) = v240;
              *uint64_t v59 = v240 + 1;
            }
          }
          else
          {
            *((void *)&v1145[0] + 1) = (v240 << 48) | 0x19C840;
          }
          *(void *)&v1145[1] = (v240 << 48) | 0x19C840;
          uint64_t v242 = *(unsigned __int16 *)(a2 + 1946);
          if (v239)
          {
            if (v242 == 0xFFFF)
            {
              uint64_t v242 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1946) = v242;
              *(_WORD *)(a2 + 2004) = v242 + 1;
            }
            unint64_t v243 = (v242 << 48) | 0x72679000;
          }
          else
          {
            if (v242 == 0xFFFF)
            {
              uint64_t v242 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1946) = v242;
              *(_WORD *)(a2 + 2004) = v242 + 1;
            }
            unint64_t v243 = ((unint64_t)(v238 == 1) << 17) | (v242 << 48) | ((unint64_t)(v238 == 2) << 16) | ((unint64_t)(v238 == 3) << 15) | 0x72601000;
          }
          *(void *)&v1145[0] = v243;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          char v239 = 0;
          ++v238;
        }
        while (v238 < v1142);
      }
LABEL_451:
      memset((char *)v1145 + 8, 0, 64);
      uint64_t v269 = 8 * (*(_DWORD *)(a2 + 16) & 7);
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v1144 = v269 | 0x3100080341;
      uint64_t v270 = *(unsigned __int16 *)(a2 + 1946);
      if (v270 == 0xFFFF)
      {
        uint64_t v283 = *(unsigned __int16 *)(a2 + 2004);
        int v284 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v283;
        *(_WORD *)(a2 + 2004) = ++v284;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v283 << 48) | 0x19C840;
        if ((v284 & 0x10000) != 0)
        {
          uint64_t v283 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v283;
          *(_WORD *)(a2 + 2004) = v283 + 1;
        }
        uint64_t v271 = v283 << 48;
      }
      else
      {
        uint64_t v271 = v270 << 48;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v270 << 48) | 0x19C840;
      }
      *(void *)&v1145[0] = v271 | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if (v1142)
      {
        uint64_t v285 = 0;
        uint64_t v286 = 0;
        uint64_t v287 = 0;
        uint64_t v288 = 0;
        uint64_t v289 = 966;
        do
        {
          memset((char *)&v1145[1] + 8, 0, 48);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v290 = *(unsigned __int16 *)(a2 + 2 * v289);
          if (v290 == 0xFFFF)
          {
            uint64_t v290 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 2 * v289) = v290;
            *(_WORD *)(a2 + 2004) = v290 + 1;
          }
          *((void *)&v1145[0] + 1) = (v290 << 48) | 0x19C840;
          uint64_t v291 = *(unsigned __int16 *)(a2 + 1946);
          if (v291 == 0xFFFF)
          {
            uint64_t v291 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1946) = v291;
            *(_WORD *)(a2 + 2004) = v291 + 1;
          }
          *(void *)&v1145[1] = v285 | (v291 << 48) | v286 | v287 | v288 | 0x40;
          uint64_t v292 = *(unsigned __int16 *)(a2 + 2 * v289);
          if (v292 == 0xFFFF)
          {
            uint64_t v292 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 2 * v289) = v292;
            *(_WORD *)(a2 + 2004) = v292 + 1;
          }
          *(void *)&v1145[0] = (v292 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          v288 += 0x8000;
          v287 += 0x2000;
          v286 += 2048;
          v285 += 512;
          unint64_t v293 = v289 - 965;
          ++v289;
          LODWORD(v60) = v1142;
        }
        while (v293 < v1142);
        goto LABEL_503;
      }
LABEL_517:
      if ((*a1 & 0x1000000000000) == 0) {
        goto LABEL_529;
      }
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v311 = *(unsigned __int16 *)(a2 + 1920);
      if (v311 == 0xFFFF)
      {
        uint64_t v311 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1920) = v311;
        *(_WORD *)(a2 + 2004) = v311 + 1;
      }
      *((void *)&v1145[0] + 1) = (v311 << 48) | 0x19C840;
      uint64_t v312 = *(unsigned __int16 *)(a2 + 1922);
      if (v312 == 0xFFFF)
      {
        uint64_t v314 = *(unsigned __int16 *)(a2 + 2004);
        int v315 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1922) = v314;
        *(_WORD *)(a2 + 2004) = ++v315;
        *(void *)&v1145[1] = (((unint64_t)(unsigned __int16)v314 << 48) | 0x19C840) + 16;
        if ((v315 & 0x10000) != 0)
        {
          uint64_t v316 = *(unsigned __int16 *)(a2 + 2004);
          int v317 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v316;
          *(_WORD *)(a2 + 2004) = ++v317;
          *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v316 << 48) | 0x19C840;
          if ((v317 & 0x10000) != 0)
          {
            uint64_t v316 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1922) = v316;
            *(_WORD *)(a2 + 2004) = v316 + 1;
          }
          uint64_t v313 = v316 << 48;
          goto LABEL_528;
        }
        uint64_t v313 = v314 << 48;
      }
      else
      {
        uint64_t v313 = v312 << 48;
        *(void *)&v1145[1] = (((unint64_t)(unsigned __int16)v312 << 48) | 0x19C840) + 16;
      }
      *((void *)&v1145[1] + 1) = v313 | 0x19C840;
LABEL_528:
      *(void *)&v1145[0] = v313 | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_529:
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B42;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v318 = *(unsigned __int16 *)(a2 + 1922);
      if (v318 == 0xFFFF)
      {
        uint64_t v318 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1922) = v318;
        *(_WORD *)(a2 + 2004) = v318 + 1;
      }
      *((void *)&v1145[0] + 1) = (v318 << 48) | 0x19C840;
      uint64_t v319 = *(unsigned __int16 *)(a2 + 1664);
      if (v319 == 0xFFFF)
      {
        uint64_t v320 = *(__int16 *)(a2 + 1998);
        uint64_t v319 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1664) = v320;
        *(_WORD *)(a2 + 4 * v320 + 262) = 351;
        *(_WORD *)(a2 + 1998) = v320 + 1;
        uint64_t v318 = *(unsigned __int16 *)(a2 + 1922);
      }
      *(void *)&v1145[1] = (v319 << 48) | 0xAA80;
      if (v318 == 0xFFFF)
      {
        uint64_t v318 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1922) = v318;
        *(_WORD *)(a2 + 2004) = v318 + 1;
      }
      *(void *)&v1145[0] = (v318 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x1000000000000) != 0)
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v325 = *(unsigned __int16 *)(a2 + 1920);
        if (v325 == 0xFFFF)
        {
          uint64_t v325 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1920) = v325;
          *(_WORD *)(a2 + 2004) = v325 + 1;
        }
        *((void *)&v1145[0] + 1) = (v325 << 48) | 0x19C840;
        uint64_t v326 = *(unsigned __int16 *)(a2 + 1632);
        if (v326 == 0xFFFF)
        {
          uint64_t v327 = *(__int16 *)(a2 + 1998);
          uint64_t v326 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1632) = v327;
          *(_WORD *)(a2 + 4 * v327 + 262) = 343;
          *(_WORD *)(a2 + 1998) = v327 + 1;
        }
        *(void *)&v1145[1] = (v326 << 48) | 0x80;
        uint64_t v328 = *(unsigned __int16 *)(a2 + 1628);
        if (v328 == 0xFFFF)
        {
          uint64_t v329 = *(__int16 *)(a2 + 1998);
          uint64_t v328 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1628) = v329;
          *(_WORD *)(a2 + 4 * v329 + 262) = 342;
          *(_WORD *)(a2 + 1998) = v329 + 1;
        }
        *((void *)&v1145[1] + 1) = (v328 << 48) | 0x80;
        uint64_t v330 = *(unsigned __int16 *)(a2 + 1946);
        if (v330 == 0xFFFF)
        {
          uint64_t v330 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v330;
          *(_WORD *)(a2 + 2004) = v330 + 1;
        }
        *(void *)&v1145[0] = (v330 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000E02;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v322 = *(unsigned __int16 *)(a2 + 1922);
        if (v322 == 0xFFFF)
        {
          uint64_t v322 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v322;
          *(_WORD *)(a2 + 2004) = v322 + 1;
        }
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v322 << 48) | 0x19C840;
        uint64_t v331 = *(unsigned __int16 *)(a2 + 1946);
        if (v331 == 0xFFFF)
        {
          uint64_t v331 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v331;
          *(_WORD *)(a2 + 2004) = v331 + 1;
        }
        *(void *)&v1145[1] = (v331 << 48) | 0x19C840;
        if (v322 == 0xFFFF)
        {
          uint64_t v322 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v322;
          *(_WORD *)(a2 + 2004) = v322 + 1;
        }
      }
      else
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        char v321 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1144 = (8 * (v321 & 7)) | 0x100000E02;
        uint64_t v322 = *(unsigned __int16 *)(a2 + 1922);
        if (v322 == 0xFFFF)
        {
          uint64_t v322 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v322;
          *(_WORD *)(a2 + 2004) = v322 + 1;
        }
        *((void *)&v1145[0] + 1) = (v322 << 48) | 0x19C840;
        uint64_t v323 = *(unsigned __int16 *)(a2 + 1628);
        if (v323 == 0xFFFF)
        {
          uint64_t v324 = *(__int16 *)(a2 + 1998);
          uint64_t v323 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1628) = v324;
          *(_WORD *)(a2 + 4 * v324 + 262) = 342;
          *(_WORD *)(a2 + 1998) = v324 + 1;
          uint64_t v322 = *(unsigned __int16 *)(a2 + 1922);
        }
        *(void *)&v1145[1] = (v323 << 48) | 0x80;
        if (v322 == 0xFFFF)
        {
          uint64_t v322 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v322;
          *(_WORD *)(a2 + 2004) = v322 + 1;
        }
      }
      *(void *)&v1145[0] = (v322 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v332 = *(unsigned __int16 *)(a2 + 1920);
      if (v332 == 0xFFFF)
      {
        uint64_t v334 = *(unsigned __int16 *)(a2 + 2004);
        int v335 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1920) = v334;
        *(_WORD *)(a2 + 2004) = ++v335;
        *((void *)&v1145[0] + 1) = (((unint64_t)(unsigned __int16)v334 << 48) | 0x19C840) + 16;
        if ((v335 & 0x10000) != 0)
        {
          uint64_t v334 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1920) = v334;
          *(_WORD *)(a2 + 2004) = v334 + 1;
        }
        uint64_t v333 = v334 << 48;
      }
      else
      {
        uint64_t v333 = v332 << 48;
        *((void *)&v1145[0] + 1) = (((unint64_t)(unsigned __int16)v332 << 48) | 0x19C840) + 16;
      }
      *(void *)&v1145[1] = v333 | 0x19C840;
      uint64_t v336 = *(unsigned __int16 *)(a2 + 1664);
      if (v336 == 0xFFFF)
      {
        uint64_t v337 = *(__int16 *)(a2 + 1998);
        uint64_t v336 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1664) = v337;
        *(_WORD *)(a2 + 4 * v337 + 262) = 351;
        *(_WORD *)(a2 + 1998) = v337 + 1;
      }
      *((void *)&v1145[1] + 1) = (v336 << 48) | 0xAA80;
      uint64_t v338 = *(unsigned __int16 *)(a2 + 1916);
      if (v338 == 0xFFFF)
      {
        uint64_t v338 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1916) = v338;
        *(_WORD *)(a2 + 2004) = v338 + 1;
      }
      *(void *)&v1145[0] = (v338 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x1000000000000) != 0)
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v339 = *(unsigned __int16 *)(a2 + 1920);
        if (v339 == 0xFFFF)
        {
          uint64_t v341 = *(unsigned __int16 *)(a2 + 2004);
          LODWORD(v339) = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1920) = v341;
          *(_WORD *)(a2 + 2004) = v339 + 1;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v341 << 48) | 0x19C840;
          if (((v339 + 1) & 0x10000) != 0)
          {
            uint64_t v341 = *(unsigned __int16 *)(a2 + 2004);
            LODWORD(v339) = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1920) = v341;
            *(_WORD *)(a2 + 2004) = v341 + 1;
          }
          uint64_t v340 = v341 << 48;
        }
        else
        {
          uint64_t v340 = v339 << 48;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v339 << 48) | 0x19C840;
        }
        *(void *)&v1145[1] = v340 | 0x19C850;
        uint64_t v342 = *(unsigned __int16 *)(a2 + 1664);
        if (v342 == 0xFFFF)
        {
          uint64_t v343 = *(__int16 *)(a2 + 1998);
          uint64_t v342 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1664) = v343;
          *(_WORD *)(a2 + 4 * v343 + 262) = 351;
          *(_WORD *)(a2 + 1998) = v343 + 1;
        }
        *((void *)&v1145[1] + 1) = (v342 << 48) | 0xAA80;
        if (v339 == 0xFFFF)
        {
          uint64_t v344 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1920) = v344;
          *(_WORD *)(a2 + 2004) = v344 + 1;
          uint64_t v340 = v344 << 48;
        }
        *(void *)&v1145[0] = v340 | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      }
      int v345 = v1142;
      if ((v1124 & 6) == 6)
      {
        if (v1142)
        {
          for (unint64_t j = 0; j < v1142; ++j)
          {
            int v347 = *(_DWORD *)&v1140[4 * j];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            int v348 = v347 + 272;
            uint64_t v349 = a2 + 4 * (v347 + 272);
            uint64_t v350 = *(unsigned __int16 *)(v349 + 260);
            if (v350 == 0xFFFF)
            {
              uint64_t v351 = *(__int16 *)(a2 + 1998);
              uint64_t v350 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v349 + 260) = v351;
              *(_WORD *)(a2 + 4 * v351 + 262) = v348;
              BOOL v75 = (v348 & 0xFFFFFFF0) == 144;
              __int16 v352 = v351 + 11;
              if (!v75) {
                __int16 v352 = v351 + 1;
              }
              *(_WORD *)(a2 + 1998) = v352;
            }
            *((void *)&v1145[0] + 1) = ((v350 << 48) | 0x19C840) + 64;
            *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
            uint64_t v353 = a2 + 2 * j;
            uint64_t v354 = *(unsigned __int16 *)(v353 + 1946);
            if (v354 == 0xFFFF)
            {
              uint64_t v354 = (unsigned __int16)*v1138;
              *(_WORD *)(v353 + 1946) = v354;
              _WORD *v1138 = v354 + 1;
            }
            *(void *)&v1145[0] = (v354 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          }
          for (unint64_t k = 0; k < v1142; ++k)
          {
            int v356 = *(_DWORD *)&v1140[4 * k];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            int v357 = v356 + 280;
            uint64_t v358 = a2 + 4 * (v356 + 280);
            uint64_t v359 = *(unsigned __int16 *)(v358 + 260);
            if (v359 == 0xFFFF)
            {
              uint64_t v360 = *(__int16 *)(a2 + 1998);
              uint64_t v359 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v358 + 260) = v360;
              *(_WORD *)(a2 + 4 * v360 + 262) = v357;
              BOOL v75 = (v357 & 0xFFFFFFF0) == 144;
              __int16 v361 = v360 + 11;
              if (!v75) {
                __int16 v361 = v360 + 1;
              }
              *(_WORD *)(a2 + 1998) = v361;
            }
            *((void *)&v1145[0] + 1) = ((v359 << 48) | 0x19C840) + 64;
            *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
            uint64_t v362 = a2 + 2 * k;
            uint64_t v363 = *(unsigned __int16 *)(v362 + 1962);
            if (v363 == 0xFFFF)
            {
              uint64_t v363 = (unsigned __int16)*v1138;
              *(_WORD *)(v362 + 1962) = v363;
              _WORD *v1138 = v363 + 1;
            }
            *(void *)&v1145[0] = (v363 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          }
          uint64_t v364 = 0;
          uint64_t v365 = 0;
          uint64_t v366 = 0;
          uint64_t v367 = 0;
          unint64_t v368 = 0;
          do
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v369 = *(unsigned __int16 *)(a2 + 1916);
            if (v369 == 0xFFFF)
            {
              uint64_t v369 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1916) = v369;
              *(_WORD *)(a2 + 2004) = v369 + 1;
            }
            *((void *)&v1145[0] + 1) = v364 | (v369 << 48) | v365 | v366 | v367 | 0x40;
            uint64_t v370 = a2 + 2 * v368;
            uint64_t v371 = *(unsigned __int16 *)(v370 + 1962);
            if (v371 == 0xFFFF)
            {
              uint64_t v371 = (unsigned __int16)*v1138;
              *(_WORD *)(v370 + 1962) = v371;
              _WORD *v1138 = v371 + 1;
            }
            *(void *)&v1145[1] = (v371 << 48) | 0x19C840;
            uint64_t v372 = *(unsigned __int16 *)(v370 + 1946);
            if (v372 == 0xFFFF)
            {
              uint64_t v373 = (unsigned __int16)*v1138;
              *(_WORD *)(v370 + 1946) = v373;
              _WORD *v1138 = v373 + 1;
              uint64_t v372 = *(unsigned __int16 *)(v370 + 1946);
              *((void *)&v1145[1] + 1) = (v373 << 48) | 0x19C840;
              if (v372 == 0xFFFF)
              {
                uint64_t v372 = (unsigned __int16)*v1138;
                *(_WORD *)(v370 + 1946) = v372;
                _WORD *v1138 = v372 + 1;
              }
            }
            else
            {
              *((void *)&v1145[1] + 1) = (v372 << 48) | 0x19C840;
            }
            *(void *)&v1145[0] = (v372 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            ++v368;
            v367 += 0x8000;
            v366 += 0x2000;
            v365 += 2048;
            v364 += 512;
            int v345 = v1142;
          }
          while (v368 < v1142);
        }
      }
      else if ((v1124 & 2) != 0)
      {
        if (v1142)
        {
          for (unint64_t m = 0; m < v1142; ++m)
          {
            int v395 = *(_DWORD *)&v1140[4 * m];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            int v396 = v395 + 272;
            uint64_t v397 = a2 + 4 * (v395 + 272);
            uint64_t v398 = *(unsigned __int16 *)(v397 + 260);
            if (v398 == 0xFFFF)
            {
              uint64_t v399 = *(__int16 *)(a2 + 1998);
              uint64_t v398 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v397 + 260) = v399;
              *(_WORD *)(a2 + 4 * v399 + 262) = v396;
              BOOL v75 = (v396 & 0xFFFFFFF0) == 144;
              __int16 v400 = v399 + 11;
              if (!v75) {
                __int16 v400 = v399 + 1;
              }
              *(_WORD *)(a2 + 1998) = v400;
            }
            *((void *)&v1145[0] + 1) = ((v398 << 48) | 0x19C840) + 64;
            *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
            uint64_t v401 = a2 + 2 * m;
            uint64_t v402 = *(unsigned __int16 *)(v401 + 1946);
            if (v402 == 0xFFFF)
            {
              uint64_t v402 = (unsigned __int16)*v1138;
              *(_WORD *)(v401 + 1946) = v402;
              _WORD *v1138 = v402 + 1;
            }
            *(void *)&v1145[0] = (v402 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          }
          uint64_t v403 = 0;
          uint64_t v404 = 0;
          uint64_t v405 = 0;
          uint64_t v406 = 0;
          unint64_t v407 = 0;
          do
          {
            int v408 = *(_DWORD *)&v1140[4 * v407];
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v409 = *(unsigned __int16 *)(a2 + 1916);
            if (v409 == 0xFFFF)
            {
              uint64_t v409 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1916) = v409;
              *(_WORD *)(a2 + 2004) = v409 + 1;
            }
            *((void *)&v1145[0] + 1) = v403 | (v409 << 48) | v404 | v405 | v406 | 0x40;
            int v410 = 2 * v408 + 240;
            uint64_t v411 = a2 + 4 * v410;
            uint64_t v412 = *(unsigned __int16 *)(v411 + 260);
            if (v412 == 0xFFFF)
            {
              uint64_t v413 = *(__int16 *)(a2 + 1998);
              uint64_t v412 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v411 + 260) = v413;
              *(_WORD *)(a2 + 4 * v413 + 262) = v410;
              BOOL v75 = (v410 & 0xFFFFFFF0) == 144;
              __int16 v414 = v413 + 11;
              if (!v75) {
                __int16 v414 = v413 + 1;
              }
              *(_WORD *)(a2 + 1998) = v414;
            }
            *(void *)&v1145[1] = ((v412 << 48) | 0x19C840) + 64;
            uint64_t v415 = a2 + 2 * v407;
            uint64_t v416 = *(unsigned __int16 *)(v415 + 1946);
            if (v416 == 0xFFFF)
            {
              uint64_t v417 = (unsigned __int16)*v1138;
              *(_WORD *)(v415 + 1946) = v417;
              _WORD *v1138 = v417 + 1;
              uint64_t v416 = *(unsigned __int16 *)(v415 + 1946);
              *((void *)&v1145[1] + 1) = (v417 << 48) | 0x19C840;
              if (v416 == 0xFFFF)
              {
                uint64_t v416 = (unsigned __int16)*v1138;
                *(_WORD *)(v415 + 1946) = v416;
                _WORD *v1138 = v416 + 1;
              }
            }
            else
            {
              *((void *)&v1145[1] + 1) = (v416 << 48) | 0x19C840;
            }
            *(void *)&v1145[0] = (v416 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            ++v407;
            v406 += 0x8000;
            v405 += 0x2000;
            v404 += 2048;
            v403 += 512;
            int v345 = v1142;
          }
          while (v407 < v1142);
        }
      }
      else if ((v1124 & 4) != 0)
      {
        if (v1142)
        {
          for (unint64_t n = 0; n < v1142; ++n)
          {
            int v419 = *(_DWORD *)&v1140[4 * n];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            int v420 = v419 + 280;
            uint64_t v421 = a2 + 4 * (v419 + 280);
            uint64_t v422 = *(unsigned __int16 *)(v421 + 260);
            if (v422 == 0xFFFF)
            {
              uint64_t v423 = *(__int16 *)(a2 + 1998);
              uint64_t v422 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v421 + 260) = v423;
              *(_WORD *)(a2 + 4 * v423 + 262) = v420;
              BOOL v75 = (v420 & 0xFFFFFFF0) == 144;
              __int16 v424 = v423 + 11;
              if (!v75) {
                __int16 v424 = v423 + 1;
              }
              *(_WORD *)(a2 + 1998) = v424;
            }
            *((void *)&v1145[0] + 1) = ((v422 << 48) | 0x19C840) + 64;
            *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
            uint64_t v425 = a2 + 2 * n;
            uint64_t v426 = *(unsigned __int16 *)(v425 + 1962);
            if (v426 == 0xFFFF)
            {
              uint64_t v426 = (unsigned __int16)*v1138;
              *(_WORD *)(v425 + 1962) = v426;
              _WORD *v1138 = v426 + 1;
            }
            *(void *)&v1145[0] = (v426 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          }
          uint64_t v427 = 0;
          uint64_t v428 = 0;
          uint64_t v429 = 0;
          uint64_t v430 = 0;
          unint64_t v431 = 0;
          do
          {
            int v432 = *(_DWORD *)&v1140[4 * v431];
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v433 = *(unsigned __int16 *)(a2 + 1916);
            if (v433 == 0xFFFF)
            {
              uint64_t v433 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1916) = v433;
              *(_WORD *)(a2 + 2004) = v433 + 1;
            }
            *((void *)&v1145[0] + 1) = v427 | (v433 << 48) | v428 | v429 | v430 | 0x40;
            uint64_t v434 = a2 + 2 * v431;
            uint64_t v435 = *(unsigned __int16 *)(v434 + 1962);
            if (v435 == 0xFFFF)
            {
              uint64_t v435 = (unsigned __int16)*v1138;
              *(_WORD *)(v434 + 1962) = v435;
              _WORD *v1138 = v435 + 1;
            }
            *(void *)&v1145[1] = (v435 << 48) | 0x19C840;
            int v436 = 2 * v432 + 224;
            uint64_t v437 = a2 + 4 * v436;
            uint64_t v438 = *(unsigned __int16 *)(v437 + 260);
            if (v438 == 0xFFFF)
            {
              uint64_t v439 = *(__int16 *)(a2 + 1998);
              uint64_t v438 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v437 + 260) = v439;
              *(_WORD *)(a2 + 4 * v439 + 262) = v436;
              BOOL v75 = (v436 & 0xFFFFFFF0) == 144;
              __int16 v440 = v439 + 11;
              if (!v75) {
                __int16 v440 = v439 + 1;
              }
              *(_WORD *)(a2 + 1998) = v440;
            }
            *((void *)&v1145[1] + 1) = ((v438 << 48) | 0x19C840) + 64;
            uint64_t v441 = a2 + 2 * v431;
            uint64_t v442 = *(unsigned __int16 *)(v441 + 1946);
            if (v442 == 0xFFFF)
            {
              uint64_t v442 = (unsigned __int16)*v1138;
              *(_WORD *)(v441 + 1946) = v442;
              _WORD *v1138 = v442 + 1;
            }
            *(void *)&v1145[0] = (v442 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            ++v431;
            v430 += 0x8000;
            v429 += 0x2000;
            v428 += 2048;
            v427 += 512;
            int v345 = v1142;
          }
          while (v431 < v1142);
        }
      }
      else if (v1142)
      {
        uint64_t v374 = 0;
        uint64_t v375 = 0;
        uint64_t v376 = 0;
        uint64_t v377 = 0;
        unint64_t v378 = 0;
        do
        {
          int v379 = *(_DWORD *)&v1140[4 * v378];
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
          *(_DWORD *)(a2 + 16) = 3;
          uint64_t v380 = *(unsigned __int16 *)(a2 + 1916);
          if (v380 == 0xFFFF)
          {
            uint64_t v380 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1916) = v380;
            *(_WORD *)(a2 + 2004) = v380 + 1;
          }
          *((void *)&v1145[0] + 1) = v374 | (v380 << 48) | v375 | v376 | v377 | 0x40;
          int v381 = 2 * v379;
          int v382 = v381 + 240;
          uint64_t v383 = a2 + 4 * (v381 + 240);
          uint64_t v384 = *(unsigned __int16 *)(v383 + 260);
          if (v384 == 0xFFFF)
          {
            uint64_t v385 = *(__int16 *)(a2 + 1998);
            uint64_t v384 = *(unsigned __int16 *)(a2 + 1998);
            *(_WORD *)(v383 + 260) = v385;
            *(_WORD *)(a2 + 4 * v385 + 262) = v382;
            BOOL v75 = (v382 & 0xFFFFFFF0) == 144;
            __int16 v386 = v385 + 11;
            if (!v75) {
              __int16 v386 = v385 + 1;
            }
            *(_WORD *)(a2 + 1998) = v386;
          }
          *(void *)&v1145[1] = ((v384 << 48) | 0x19C840) + 64;
          int v387 = v381 + 224;
          uint64_t v388 = a2 + 4 * (v381 + 224);
          uint64_t v389 = *(unsigned __int16 *)(v388 + 260);
          if (v389 == 0xFFFF)
          {
            uint64_t v390 = *(__int16 *)(a2 + 1998);
            uint64_t v389 = *(unsigned __int16 *)(a2 + 1998);
            *(_WORD *)(v388 + 260) = v390;
            *(_WORD *)(a2 + 4 * v390 + 262) = v387;
            BOOL v75 = (v387 & 0xFFFFFFF0) == 144;
            __int16 v391 = v390 + 11;
            if (!v75) {
              __int16 v391 = v390 + 1;
            }
            *(_WORD *)(a2 + 1998) = v391;
          }
          *((void *)&v1145[1] + 1) = ((v389 << 48) | 0x19C840) + 64;
          uint64_t v392 = a2 + 2 * v378;
          uint64_t v393 = *(unsigned __int16 *)(v392 + 1946);
          if (v393 == 0xFFFF)
          {
            uint64_t v393 = (unsigned __int16)*v1138;
            *(_WORD *)(v392 + 1946) = v393;
            _WORD *v1138 = v393 + 1;
          }
          *(void *)&v1145[0] = (v393 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          ++v378;
          v377 += 0x8000;
          v376 += 0x2000;
          v375 += 2048;
          v374 += 512;
          int v345 = v1142;
        }
        while (v378 < v1142);
      }
      if ((*a1 & 0x1000000000000) != 0)
      {
        if ((v1121 & 6) == 6)
        {
          if (v345)
          {
            unint64_t v443 = 0;
            do
            {
              int v444 = *(_DWORD *)&v1140[4 * v443];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v445 = v444 + 272;
              uint64_t v446 = a2 + 4 * (v444 + 272);
              uint64_t v447 = *(unsigned __int16 *)(v446 + 260);
              if (v447 == 0xFFFF)
              {
                uint64_t v448 = *(__int16 *)(a2 + 1998);
                uint64_t v447 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v446 + 260) = v448;
                *(_WORD *)(a2 + 4 * v448 + 262) = v445;
                BOOL v75 = (v445 & 0xFFFFFFF0) == 144;
                __int16 v449 = v448 + 11;
                if (!v75) {
                  __int16 v449 = v448 + 1;
                }
                *(_WORD *)(a2 + 1998) = v449;
              }
              *((void *)&v1145[0] + 1) = ((v447 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v450 = a2 + 2 * v443;
              uint64_t v451 = *(unsigned __int16 *)(v450 + 1954);
              if (v451 == 0xFFFF)
              {
                uint64_t v451 = (unsigned __int16)*v1138;
                *(_WORD *)(v450 + 1954) = v451;
                _WORD *v1138 = v451 + 1;
              }
              *(void *)&v1145[0] = (v451 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v443;
            }
            while (v443 < v1142);
            unint64_t v452 = 0;
            do
            {
              int v453 = *(_DWORD *)&v1140[4 * v452];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v454 = v453 + 280;
              uint64_t v455 = a2 + 4 * (v453 + 280);
              uint64_t v456 = *(unsigned __int16 *)(v455 + 260);
              if (v456 == 0xFFFF)
              {
                uint64_t v457 = *(__int16 *)(a2 + 1998);
                uint64_t v456 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v455 + 260) = v457;
                *(_WORD *)(a2 + 4 * v457 + 262) = v454;
                BOOL v75 = (v454 & 0xFFFFFFF0) == 144;
                __int16 v458 = v457 + 11;
                if (!v75) {
                  __int16 v458 = v457 + 1;
                }
                *(_WORD *)(a2 + 1998) = v458;
              }
              *((void *)&v1145[0] + 1) = ((v456 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v459 = a2 + 2 * v452;
              uint64_t v460 = *(unsigned __int16 *)(v459 + 1970);
              if (v460 == 0xFFFF)
              {
                uint64_t v460 = (unsigned __int16)*v1138;
                *(_WORD *)(v459 + 1970) = v460;
                _WORD *v1138 = v460 + 1;
              }
              *(void *)&v1145[0] = (v460 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v452;
            }
            while (v452 < v1142);
            uint64_t v461 = 0;
            uint64_t v462 = 0;
            uint64_t v463 = 0;
            uint64_t v464 = 0;
            unint64_t v465 = 0;
            do
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v466 = *(unsigned __int16 *)(a2 + 1920);
              if (v466 == 0xFFFF)
              {
                uint64_t v466 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1920) = v466;
                *(_WORD *)(a2 + 2004) = v466 + 1;
              }
              *((void *)&v1145[0] + 1) = v461 | (v466 << 48) | v462 | v463 | v464 | 0x40;
              uint64_t v467 = a2 + 2 * v465;
              uint64_t v468 = *(unsigned __int16 *)(v467 + 1970);
              if (v468 == 0xFFFF)
              {
                uint64_t v468 = (unsigned __int16)*v1138;
                *(_WORD *)(v467 + 1970) = v468;
                _WORD *v1138 = v468 + 1;
              }
              *(void *)&v1145[1] = (v468 << 48) | 0x19C840;
              uint64_t v469 = *(unsigned __int16 *)(v467 + 1954);
              if (v469 == 0xFFFF)
              {
                uint64_t v470 = (unsigned __int16)*v1138;
                *(_WORD *)(v467 + 1954) = v470;
                _WORD *v1138 = v470 + 1;
                uint64_t v469 = *(unsigned __int16 *)(v467 + 1954);
                *((void *)&v1145[1] + 1) = (v470 << 48) | 0x19C840;
                if (v469 == 0xFFFF)
                {
                  uint64_t v469 = (unsigned __int16)*v1138;
                  *(_WORD *)(v467 + 1954) = v469;
                  _WORD *v1138 = v469 + 1;
                }
              }
              else
              {
                *((void *)&v1145[1] + 1) = (v469 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = (v469 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v465;
              v464 += 0x8000;
              v463 += 0x2000;
              v462 += 2048;
              v461 += 512;
            }
            while (v465 < v1142);
          }
        }
        else if ((v1121 & 2) != 0)
        {
          if (v345)
          {
            unint64_t v491 = 0;
            do
            {
              int v492 = *(_DWORD *)&v1140[4 * v491];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v493 = v492 + 272;
              uint64_t v494 = a2 + 4 * (v492 + 272);
              uint64_t v495 = *(unsigned __int16 *)(v494 + 260);
              if (v495 == 0xFFFF)
              {
                uint64_t v496 = *(__int16 *)(a2 + 1998);
                uint64_t v495 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v494 + 260) = v496;
                *(_WORD *)(a2 + 4 * v496 + 262) = v493;
                BOOL v75 = (v493 & 0xFFFFFFF0) == 144;
                __int16 v497 = v496 + 11;
                if (!v75) {
                  __int16 v497 = v496 + 1;
                }
                *(_WORD *)(a2 + 1998) = v497;
              }
              *((void *)&v1145[0] + 1) = ((v495 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v498 = a2 + 2 * v491;
              uint64_t v499 = *(unsigned __int16 *)(v498 + 1954);
              if (v499 == 0xFFFF)
              {
                uint64_t v499 = (unsigned __int16)*v1138;
                *(_WORD *)(v498 + 1954) = v499;
                _WORD *v1138 = v499 + 1;
              }
              *(void *)&v1145[0] = (v499 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v491;
            }
            while (v491 < v1142);
            uint64_t v500 = 0;
            uint64_t v501 = 0;
            uint64_t v502 = 0;
            uint64_t v503 = 0;
            unint64_t v504 = 0;
            do
            {
              int v505 = *(_DWORD *)&v1140[4 * v504];
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v506 = *(unsigned __int16 *)(a2 + 1920);
              if (v506 == 0xFFFF)
              {
                uint64_t v506 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1920) = v506;
                *(_WORD *)(a2 + 2004) = v506 + 1;
              }
              *((void *)&v1145[0] + 1) = v500 | (v506 << 48) | v501 | v502 | v503 | 0x40;
              int v507 = 2 * v505 + 241;
              uint64_t v508 = a2 + 4 * v507;
              uint64_t v509 = *(unsigned __int16 *)(v508 + 260);
              if (v509 == 0xFFFF)
              {
                uint64_t v510 = *(__int16 *)(a2 + 1998);
                uint64_t v509 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v508 + 260) = v510;
                *(_WORD *)(a2 + 4 * v510 + 262) = v507;
                BOOL v75 = (v507 & 0xFFFFFFF0) == 144;
                __int16 v511 = v510 + 11;
                if (!v75) {
                  __int16 v511 = v510 + 1;
                }
                *(_WORD *)(a2 + 1998) = v511;
              }
              *(void *)&v1145[1] = ((v509 << 48) | 0x19C840) + 64;
              uint64_t v512 = a2 + 2 * v504;
              uint64_t v513 = *(unsigned __int16 *)(v512 + 1954);
              if (v513 == 0xFFFF)
              {
                uint64_t v514 = (unsigned __int16)*v1138;
                *(_WORD *)(v512 + 1954) = v514;
                _WORD *v1138 = v514 + 1;
                uint64_t v513 = *(unsigned __int16 *)(v512 + 1954);
                *((void *)&v1145[1] + 1) = (v514 << 48) | 0x19C840;
                if (v513 == 0xFFFF)
                {
                  uint64_t v513 = (unsigned __int16)*v1138;
                  *(_WORD *)(v512 + 1954) = v513;
                  _WORD *v1138 = v513 + 1;
                }
              }
              else
              {
                *((void *)&v1145[1] + 1) = (v513 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = (v513 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v504;
              v503 += 0x8000;
              v502 += 0x2000;
              v501 += 2048;
              v500 += 512;
            }
            while (v504 < v1142);
          }
        }
        else if ((v1121 & 4) != 0)
        {
          if (v345)
          {
            unint64_t v515 = 0;
            do
            {
              int v516 = *(_DWORD *)&v1140[4 * v515];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v517 = v516 + 280;
              uint64_t v518 = a2 + 4 * (v516 + 280);
              uint64_t v519 = *(unsigned __int16 *)(v518 + 260);
              if (v519 == 0xFFFF)
              {
                uint64_t v520 = *(__int16 *)(a2 + 1998);
                uint64_t v519 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v518 + 260) = v520;
                *(_WORD *)(a2 + 4 * v520 + 262) = v517;
                BOOL v75 = (v517 & 0xFFFFFFF0) == 144;
                __int16 v521 = v520 + 11;
                if (!v75) {
                  __int16 v521 = v520 + 1;
                }
                *(_WORD *)(a2 + 1998) = v521;
              }
              *((void *)&v1145[0] + 1) = ((v519 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v522 = a2 + 2 * v515;
              uint64_t v523 = *(unsigned __int16 *)(v522 + 1970);
              if (v523 == 0xFFFF)
              {
                uint64_t v523 = (unsigned __int16)*v1138;
                *(_WORD *)(v522 + 1970) = v523;
                _WORD *v1138 = v523 + 1;
              }
              *(void *)&v1145[0] = (v523 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v515;
            }
            while (v515 < v1142);
            uint64_t v524 = 0;
            uint64_t v525 = 0;
            uint64_t v526 = 0;
            uint64_t v527 = 0;
            unint64_t v528 = 0;
            do
            {
              int v529 = *(_DWORD *)&v1140[4 * v528];
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v530 = *(unsigned __int16 *)(a2 + 1920);
              if (v530 == 0xFFFF)
              {
                uint64_t v530 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1920) = v530;
                *(_WORD *)(a2 + 2004) = v530 + 1;
              }
              *((void *)&v1145[0] + 1) = v524 | (v530 << 48) | v525 | v526 | v527 | 0x40;
              uint64_t v531 = a2 + 2 * v528;
              uint64_t v532 = *(unsigned __int16 *)(v531 + 1970);
              if (v532 == 0xFFFF)
              {
                uint64_t v532 = (unsigned __int16)*v1138;
                *(_WORD *)(v531 + 1970) = v532;
                _WORD *v1138 = v532 + 1;
              }
              *(void *)&v1145[1] = (v532 << 48) | 0x19C840;
              int v533 = 2 * v529 + 225;
              uint64_t v534 = a2 + 4 * v533;
              uint64_t v535 = *(unsigned __int16 *)(v534 + 260);
              if (v535 == 0xFFFF)
              {
                uint64_t v536 = *(__int16 *)(a2 + 1998);
                uint64_t v535 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v534 + 260) = v536;
                *(_WORD *)(a2 + 4 * v536 + 262) = v533;
                BOOL v75 = (v533 & 0xFFFFFFF0) == 144;
                __int16 v537 = v536 + 11;
                if (!v75) {
                  __int16 v537 = v536 + 1;
                }
                *(_WORD *)(a2 + 1998) = v537;
              }
              *((void *)&v1145[1] + 1) = ((v535 << 48) | 0x19C840) + 64;
              uint64_t v538 = a2 + 2 * v528;
              uint64_t v539 = *(unsigned __int16 *)(v538 + 1954);
              if (v539 == 0xFFFF)
              {
                uint64_t v539 = (unsigned __int16)*v1138;
                *(_WORD *)(v538 + 1954) = v539;
                _WORD *v1138 = v539 + 1;
              }
              *(void *)&v1145[0] = (v539 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v528;
              v527 += 0x8000;
              v526 += 0x2000;
              v525 += 2048;
              v524 += 512;
            }
            while (v528 < v1142);
          }
        }
        else if (v345)
        {
          uint64_t v471 = 0;
          uint64_t v472 = 0;
          uint64_t v473 = 0;
          uint64_t v474 = 0;
          unint64_t v475 = 0;
          do
          {
            int v476 = *(_DWORD *)&v1140[4 * v475];
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v477 = *(unsigned __int16 *)(a2 + 1920);
            if (v477 == 0xFFFF)
            {
              uint64_t v477 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1920) = v477;
              *(_WORD *)(a2 + 2004) = v477 + 1;
            }
            *((void *)&v1145[0] + 1) = v471 | (v477 << 48) | v472 | v473 | v474 | 0x40;
            int v478 = 2 * v476;
            int v479 = v478 + 241;
            uint64_t v480 = a2 + 4 * (v478 + 241);
            uint64_t v481 = *(unsigned __int16 *)(v480 + 260);
            if (v481 == 0xFFFF)
            {
              uint64_t v482 = *(__int16 *)(a2 + 1998);
              uint64_t v481 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v480 + 260) = v482;
              *(_WORD *)(a2 + 4 * v482 + 262) = v479;
              BOOL v75 = (v479 & 0xFFFFFFF0) == 144;
              __int16 v483 = v482 + 11;
              if (!v75) {
                __int16 v483 = v482 + 1;
              }
              *(_WORD *)(a2 + 1998) = v483;
            }
            *(void *)&v1145[1] = ((v481 << 48) | 0x19C840) + 64;
            int v484 = v478 + 225;
            uint64_t v485 = a2 + 4 * (v478 + 225);
            uint64_t v486 = *(unsigned __int16 *)(v485 + 260);
            if (v486 == 0xFFFF)
            {
              uint64_t v487 = *(__int16 *)(a2 + 1998);
              uint64_t v486 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v485 + 260) = v487;
              *(_WORD *)(a2 + 4 * v487 + 262) = v484;
              BOOL v75 = (v484 & 0xFFFFFFF0) == 144;
              __int16 v488 = v487 + 11;
              if (!v75) {
                __int16 v488 = v487 + 1;
              }
              *(_WORD *)(a2 + 1998) = v488;
            }
            *((void *)&v1145[1] + 1) = ((v486 << 48) | 0x19C840) + 64;
            uint64_t v489 = a2 + 2 * v475;
            uint64_t v490 = *(unsigned __int16 *)(v489 + 1954);
            if (v490 == 0xFFFF)
            {
              uint64_t v490 = (unsigned __int16)*v1138;
              *(_WORD *)(v489 + 1954) = v490;
              _WORD *v1138 = v490 + 1;
            }
            *(void *)&v1145[0] = (v490 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            ++v475;
            v474 += 0x8000;
            v473 += 0x2000;
            v472 += 2048;
            v471 += 512;
          }
          while (v475 < v1142);
        }
      }
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v540 = *(unsigned __int16 *)(a2 + 1916);
      if (v540 == 0xFFFF)
      {
        uint64_t v540 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1916) = v540;
        *(_WORD *)(a2 + 2004) = v540 + 1;
      }
      *((void *)&v1145[0] + 1) = ((v540 << 48) | 0x19C840) + 16;
      uint64_t v541 = *(unsigned __int16 *)(a2 + 1922);
      if (v541 == 0xFFFF)
      {
        uint64_t v541 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1922) = v541;
        *(_WORD *)(a2 + 2004) = v541 + 1;
      }
      *(void *)&v1145[1] = (v541 << 48) | 0x19C840;
      uint64_t v542 = *(unsigned __int16 *)(a2 + 1664);
      if (v542 == 0xFFFF)
      {
        uint64_t v543 = *(__int16 *)(a2 + 1998);
        uint64_t v542 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1664) = v543;
        *(_WORD *)(a2 + 4 * v543 + 262) = 351;
        *(_WORD *)(a2 + 1998) = v543 + 1;
      }
      *((void *)&v1145[1] + 1) = (v542 << 48) | 0xAA80;
      uint64_t v544 = *(unsigned __int16 *)(a2 + 1918);
      if (v544 == 0xFFFF)
      {
        uint64_t v544 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1918) = v544;
        *(_WORD *)(a2 + 2004) = v544 + 1;
      }
      *(void *)&v1145[0] = (v544 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      unint64_t v545 = *a1;
      if ((*a1 & 0x1000000000000) != 0)
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v546 = *(unsigned __int16 *)(a2 + 1920);
        if (v546 == 0xFFFF)
        {
          uint64_t v546 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1920) = v546;
          *(_WORD *)(a2 + 2004) = v546 + 1;
        }
        *((void *)&v1145[0] + 1) = ((v546 << 48) | 0x19C840) + 16;
        uint64_t v547 = *(unsigned __int16 *)(a2 + 1922);
        if (v547 == 0xFFFF)
        {
          uint64_t v547 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v547;
          *(_WORD *)(a2 + 2004) = v547 + 1;
        }
        *(void *)&v1145[1] = (v547 << 48) | 0x19C840;
        uint64_t v548 = *(unsigned __int16 *)(a2 + 1664);
        if (v548 == 0xFFFF)
        {
          uint64_t v549 = *(__int16 *)(a2 + 1998);
          uint64_t v548 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1664) = v549;
          *(_WORD *)(a2 + 4 * v549 + 262) = 351;
          *(_WORD *)(a2 + 1998) = v549 + 1;
          uint64_t v547 = *(unsigned __int16 *)(a2 + 1922);
        }
        *((void *)&v1145[1] + 1) = (v548 << 48) | 0xAA80;
        if (v547 == 0xFFFF)
        {
          uint64_t v547 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1922) = v547;
          *(_WORD *)(a2 + 2004) = v547 + 1;
        }
        *(void *)&v1145[0] = (v547 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        unint64_t v545 = *a1;
      }
      unint64_t v550 = v1142;
      if ((v545 & 0x8000000000000000) != 0)
      {
        if (v1124 >= 8)
        {
          if (v1142)
          {
            for (iunint64_t i = 0; ii < v1142; ++ii)
            {
              int v600 = *(_DWORD *)&v1140[4 * ii];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v601 = v600 + 288;
              uint64_t v602 = a2 + 4 * (v600 + 288);
              uint64_t v603 = *(unsigned __int16 *)(v602 + 260);
              if (v603 == 0xFFFF)
              {
                uint64_t v604 = *(__int16 *)(a2 + 1998);
                uint64_t v603 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v602 + 260) = v604;
                *(_WORD *)(a2 + 4 * v604 + 262) = v601;
                BOOL v75 = (v601 & 0xFFFFFFF0) == 144;
                __int16 v605 = v604 + 11;
                if (!v75) {
                  __int16 v605 = v604 + 1;
                }
                *(_WORD *)(a2 + 1998) = v605;
              }
              *((void *)&v1145[0] + 1) = ((v603 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v606 = a2 + 2 * ii;
              uint64_t v607 = *(unsigned __int16 *)(v606 + 1962);
              if (v607 == 0xFFFF)
              {
                uint64_t v607 = (unsigned __int16)*v1138;
                *(_WORD *)(v606 + 1962) = v607;
                _WORD *v1138 = v607 + 1;
              }
              *(void *)&v1145[0] = (v607 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            }
            uint64_t v608 = 0;
            uint64_t v609 = 0;
            uint64_t v610 = 0;
            uint64_t v611 = 0;
            uint64_t v612 = 981;
            do
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v613 = *(unsigned __int16 *)(a2 + 1918);
              if (v613 == 0xFFFF)
              {
                uint64_t v613 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1918) = v613;
                *(_WORD *)(a2 + 2004) = v613 + 1;
              }
              *((void *)&v1145[0] + 1) = v608 | (v613 << 48) | v609 | v610 | v611 | 0x40;
              uint64_t v614 = *(unsigned __int16 *)(a2 + 2 * v612);
              if (v614 == 0xFFFF)
              {
                uint64_t v615 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 2 * v612) = v615;
                *(_WORD *)(a2 + 2004) = v615 + 1;
                uint64_t v614 = *(unsigned __int16 *)(a2 + 2 * v612);
                *(void *)&v1145[1] = (v615 << 48) | 0x19C840;
                if (v614 == 0xFFFF)
                {
                  uint64_t v614 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 2 * v612) = v614;
                  *(_WORD *)(a2 + 2004) = v614 + 1;
                }
              }
              else
              {
                *(void *)&v1145[1] = (v614 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = (v614 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              v611 += 0x8000;
              v610 += 0x2000;
              v609 += 2048;
              v608 += 512;
              unint64_t v616 = v612 - 980;
              ++v612;
              unint64_t v550 = v1142;
            }
            while (v616 < v1142);
          }
        }
        else if (v1142)
        {
          uint64_t v566 = 0;
          uint64_t v567 = 0;
          uint64_t v568 = 0;
          uint64_t v569 = 0;
          unint64_t v570 = 0;
          do
          {
            int v571 = *(_DWORD *)&v1140[4 * v570];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            uint64_t v572 = *(unsigned __int16 *)(a2 + 1918);
            if (v572 == 0xFFFF)
            {
              uint64_t v572 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1918) = v572;
              *(_WORD *)(a2 + 2004) = v572 + 1;
            }
            *((void *)&v1145[0] + 1) = v566 | (v572 << 48) | v567 | v568 | v569 | 0x40;
            int v573 = 2 * v571 + 256;
            uint64_t v574 = a2 + 4 * v573;
            uint64_t v575 = *(unsigned __int16 *)(v574 + 260);
            if (v575 == 0xFFFF)
            {
              uint64_t v576 = *(__int16 *)(a2 + 1998);
              uint64_t v575 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v574 + 260) = v576;
              *(_WORD *)(a2 + 4 * v576 + 262) = v573;
              BOOL v75 = (v573 & 0xFFFFFFF0) == 144;
              __int16 v577 = v576 + 11;
              if (!v75) {
                __int16 v577 = v576 + 1;
              }
              *(_WORD *)(a2 + 1998) = v577;
            }
            *(void *)&v1145[1] = ((v575 << 48) | 0x19C840) + 64;
            uint64_t v578 = a2 + 2 * v570;
            uint64_t v579 = *(unsigned __int16 *)(v578 + 1962);
            if (v579 == 0xFFFF)
            {
              uint64_t v579 = (unsigned __int16)*v1138;
              *(_WORD *)(v578 + 1962) = v579;
              _WORD *v1138 = v579 + 1;
            }
            *(void *)&v1145[0] = (v579 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            ++v570;
            v569 += 0x8000;
            v568 += 0x2000;
            v567 += 2048;
            v566 += 512;
            unint64_t v550 = v1142;
          }
          while (v570 < v1142);
        }
      }
      else if (v1124 >= 8)
      {
        if (v1142)
        {
          for (junint64_t j = 0; jj < v1142; ++jj)
          {
            int v581 = *(_DWORD *)&v1140[4 * jj];
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            int v582 = v581 + 288;
            uint64_t v583 = a2 + 4 * (v581 + 288);
            uint64_t v584 = *(unsigned __int16 *)(v583 + 260);
            if (v584 == 0xFFFF)
            {
              uint64_t v585 = *(__int16 *)(a2 + 1998);
              uint64_t v584 = *(unsigned __int16 *)(a2 + 1998);
              *(_WORD *)(v583 + 260) = v585;
              *(_WORD *)(a2 + 4 * v585 + 262) = v582;
              BOOL v75 = (v582 & 0xFFFFFFF0) == 144;
              __int16 v586 = v585 + 11;
              if (!v75) {
                __int16 v586 = v585 + 1;
              }
              *(_WORD *)(a2 + 1998) = v586;
            }
            *((void *)&v1145[0] + 1) = ((v584 << 48) | 0x19C840) + 64;
            *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
            uint64_t v587 = a2 + 2 * jj;
            uint64_t v588 = *(unsigned __int16 *)(v587 + 1962);
            if (v588 == 0xFFFF)
            {
              uint64_t v588 = (unsigned __int16)*v1138;
              *(_WORD *)(v587 + 1962) = v588;
              _WORD *v1138 = v588 + 1;
            }
            *(void *)&v1145[0] = (v588 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          }
          uint64_t v589 = 0;
          uint64_t v590 = 0;
          uint64_t v591 = 0;
          uint64_t v592 = 0;
          unint64_t v593 = 0;
          do
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v594 = *(unsigned __int16 *)(a2 + 1918);
            if (v594 == 0xFFFF)
            {
              uint64_t v594 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1918) = v594;
              *(_WORD *)(a2 + 2004) = v594 + 1;
            }
            *((void *)&v1145[0] + 1) = v589 | (v594 << 48) | v590 | v591 | v592 | 0x40;
            uint64_t v595 = a2 + 2 * v593;
            uint64_t v596 = *(unsigned __int16 *)(v595 + 1962);
            if (v596 == 0xFFFF)
            {
              uint64_t v596 = (unsigned __int16)*v1138;
              *(_WORD *)(v595 + 1962) = v596;
              _WORD *v1138 = v596 + 1;
            }
            *(void *)&v1145[1] = (v596 << 48) | 0x19C840;
            uint64_t v597 = *(unsigned __int16 *)(v595 + 1946);
            if (v597 == 0xFFFF)
            {
              uint64_t v598 = (unsigned __int16)*v1138;
              *(_WORD *)(v595 + 1946) = v598;
              _WORD *v1138 = v598 + 1;
              uint64_t v597 = *(unsigned __int16 *)(v595 + 1946);
              *((void *)&v1145[1] + 1) = (v598 << 48) | 0x19C840;
              if (v597 == 0xFFFF)
              {
                uint64_t v597 = (unsigned __int16)*v1138;
                *(_WORD *)(v595 + 1946) = v597;
                _WORD *v1138 = v597 + 1;
              }
            }
            else
            {
              *((void *)&v1145[1] + 1) = (v597 << 48) | 0x19C840;
            }
            *(void *)&v1145[0] = (v597 << 48) | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            ++v593;
            v592 += 0x8000;
            v591 += 0x2000;
            v590 += 2048;
            v589 += 512;
            unint64_t v550 = v1142;
          }
          while (v593 < v1142);
        }
      }
      else if (v1142)
      {
        uint64_t v551 = 0;
        uint64_t v552 = 0;
        uint64_t v553 = 0;
        uint64_t v554 = 0;
        unint64_t v555 = 0;
        do
        {
          int v556 = *(_DWORD *)&v1140[4 * v555];
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
          *(_DWORD *)(a2 + 16) = 3;
          uint64_t v557 = *(unsigned __int16 *)(a2 + 1918);
          if (v557 == 0xFFFF)
          {
            uint64_t v557 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1918) = v557;
            *(_WORD *)(a2 + 2004) = v557 + 1;
          }
          *((void *)&v1145[0] + 1) = v551 | (v557 << 48) | v552 | v553 | v554 | 0x40;
          int v558 = 2 * v556 + 256;
          uint64_t v559 = a2 + 4 * v558;
          uint64_t v560 = *(unsigned __int16 *)(v559 + 260);
          if (v560 == 0xFFFF)
          {
            uint64_t v561 = *(__int16 *)(a2 + 1998);
            uint64_t v560 = *(unsigned __int16 *)(a2 + 1998);
            *(_WORD *)(v559 + 260) = v561;
            *(_WORD *)(a2 + 4 * v561 + 262) = v558;
            BOOL v75 = (v558 & 0xFFFFFFF0) == 144;
            __int16 v562 = v561 + 11;
            if (!v75) {
              __int16 v562 = v561 + 1;
            }
            *(_WORD *)(a2 + 1998) = v562;
          }
          *(void *)&v1145[1] = ((v560 << 48) | 0x19C840) + 64;
          uint64_t v563 = a2 + 2 * v555;
          uint64_t v564 = *(unsigned __int16 *)(v563 + 1946);
          if (v564 == 0xFFFF)
          {
            uint64_t v565 = (unsigned __int16)*v1138;
            *(_WORD *)(v563 + 1946) = v565;
            _WORD *v1138 = v565 + 1;
            uint64_t v564 = *(unsigned __int16 *)(v563 + 1946);
            *((void *)&v1145[1] + 1) = (v565 << 48) | 0x19C840;
            if (v564 == 0xFFFF)
            {
              uint64_t v564 = (unsigned __int16)*v1138;
              *(_WORD *)(v563 + 1946) = v564;
              _WORD *v1138 = v564 + 1;
            }
          }
          else
          {
            *((void *)&v1145[1] + 1) = (v564 << 48) | 0x19C840;
          }
          *(void *)&v1145[0] = (v564 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          ++v555;
          v554 += 0x8000;
          v553 += 0x2000;
          v552 += 2048;
          v551 += 512;
          unint64_t v550 = v1142;
        }
        while (v555 < v1142);
      }
      if ((*a1 & 0x1000000000000) != 0)
      {
        if ((*a1 & 0x8000000000000000) != 0)
        {
          uint64_t v59 = (_WORD *)(a2 + 2004);
          if (v1121 >= 8)
          {
            if (!v550)
            {
LABEL_927:
              int v1129 = 0;
              BOOL v617 = 0;
              goto LABEL_928;
            }
            unint64_t v678 = 0;
            do
            {
              int v679 = *(_DWORD *)&v1140[4 * v678];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v680 = v679 + 288;
              uint64_t v681 = a2 + 4 * (v679 + 288);
              uint64_t v682 = *(unsigned __int16 *)(v681 + 260);
              if (v682 == 0xFFFF)
              {
                uint64_t v683 = *(__int16 *)(a2 + 1998);
                uint64_t v682 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v681 + 260) = v683;
                *(_WORD *)(a2 + 4 * v683 + 262) = v680;
                BOOL v75 = (v680 & 0xFFFFFFF0) == 144;
                __int16 v684 = v683 + 11;
                if (!v75) {
                  __int16 v684 = v683 + 1;
                }
                *(_WORD *)(a2 + 1998) = v684;
              }
              *((void *)&v1145[0] + 1) = ((v682 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v685 = a2 + 2 * v678;
              uint64_t v686 = *(unsigned __int16 *)(v685 + 1970);
              if (v686 == 0xFFFF)
              {
                uint64_t v686 = (unsigned __int16)*v1138;
                *(_WORD *)(v685 + 1970) = v686;
                _WORD *v1138 = v686 + 1;
              }
              *(void *)&v1145[0] = (v686 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v678;
            }
            while (v678 < v1142);
            uint64_t v687 = 0;
            uint64_t v688 = 0;
            uint64_t v689 = 0;
            uint64_t v690 = 0;
            uint64_t v691 = 985;
            do
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v692 = *(unsigned __int16 *)(a2 + 1922);
              if (v692 == 0xFFFF)
              {
                uint64_t v692 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1922) = v692;
                *(_WORD *)(a2 + 2004) = v692 + 1;
              }
              *((void *)&v1145[0] + 1) = v687 | (v692 << 48) | v688 | v689 | v690 | 0x40;
              uint64_t v693 = *(unsigned __int16 *)(a2 + 2 * v691);
              if (v693 == 0xFFFF)
              {
                uint64_t v694 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 2 * v691) = v694;
                *(_WORD *)(a2 + 2004) = v694 + 1;
                uint64_t v693 = *(unsigned __int16 *)(a2 + 2 * v691);
                *(void *)&v1145[1] = (v694 << 48) | 0x19C840;
                if (v693 == 0xFFFF)
                {
                  uint64_t v693 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 2 * v691) = v693;
                  *(_WORD *)(a2 + 2004) = v693 + 1;
                }
              }
              else
              {
                *(void *)&v1145[1] = (v693 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = (v693 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              v690 += 0x8000;
              v689 += 0x2000;
              v688 += 2048;
              v687 += 512;
              unint64_t v695 = v691 - 984;
              ++v691;
              unint64_t v550 = v1142;
            }
            while (v695 < v1142);
          }
          else
          {
            if (!v550) {
              goto LABEL_927;
            }
            uint64_t v645 = 0;
            uint64_t v646 = 0;
            uint64_t v647 = 0;
            uint64_t v648 = 0;
            unint64_t v649 = 0;
            do
            {
              int v650 = *(_DWORD *)&v1140[4 * v649];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v651 = *(unsigned __int16 *)(a2 + 1922);
              if (v651 == 0xFFFF)
              {
                uint64_t v651 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1922) = v651;
                *(_WORD *)(a2 + 2004) = v651 + 1;
              }
              *((void *)&v1145[0] + 1) = v645 | (v651 << 48) | v646 | v647 | v648 | 0x40;
              int v652 = 2 * v650 + 257;
              uint64_t v653 = a2 + 4 * v652;
              uint64_t v654 = *(unsigned __int16 *)(v653 + 260);
              if (v654 == 0xFFFF)
              {
                uint64_t v655 = *(__int16 *)(a2 + 1998);
                uint64_t v654 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v653 + 260) = v655;
                *(_WORD *)(a2 + 4 * v655 + 262) = v652;
                BOOL v75 = (v652 & 0xFFFFFFF0) == 144;
                __int16 v656 = v655 + 11;
                if (!v75) {
                  __int16 v656 = v655 + 1;
                }
                *(_WORD *)(a2 + 1998) = v656;
              }
              *(void *)&v1145[1] = ((v654 << 48) | 0x19C840) + 64;
              uint64_t v657 = a2 + 2 * v649;
              uint64_t v658 = *(unsigned __int16 *)(v657 + 1970);
              if (v658 == 0xFFFF)
              {
                uint64_t v658 = (unsigned __int16)*v1138;
                *(_WORD *)(v657 + 1970) = v658;
                _WORD *v1138 = v658 + 1;
              }
              *(void *)&v1145[0] = (v658 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v649;
              v648 += 0x8000;
              v647 += 0x2000;
              v646 += 2048;
              v645 += 512;
              unint64_t v550 = v1142;
            }
            while (v649 < v1142);
          }
        }
        else
        {
          uint64_t v59 = (_WORD *)(a2 + 2004);
          if (v1121 >= 8)
          {
            if (!v550) {
              goto LABEL_927;
            }
            unint64_t v659 = 0;
            do
            {
              int v660 = *(_DWORD *)&v1140[4 * v659];
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              int v661 = v660 + 288;
              uint64_t v662 = a2 + 4 * (v660 + 288);
              uint64_t v663 = *(unsigned __int16 *)(v662 + 260);
              if (v663 == 0xFFFF)
              {
                uint64_t v664 = *(__int16 *)(a2 + 1998);
                uint64_t v663 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v662 + 260) = v664;
                *(_WORD *)(a2 + 4 * v664 + 262) = v661;
                BOOL v75 = (v661 & 0xFFFFFFF0) == 144;
                __int16 v665 = v664 + 11;
                if (!v75) {
                  __int16 v665 = v664 + 1;
                }
                *(_WORD *)(a2 + 1998) = v665;
              }
              *((void *)&v1145[0] + 1) = ((v663 << 48) | 0x19C840) + 64;
              *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
              uint64_t v666 = a2 + 2 * v659;
              uint64_t v667 = *(unsigned __int16 *)(v666 + 1970);
              if (v667 == 0xFFFF)
              {
                uint64_t v667 = (unsigned __int16)*v1138;
                *(_WORD *)(v666 + 1970) = v667;
                _WORD *v1138 = v667 + 1;
              }
              *(void *)&v1145[0] = (v667 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v659;
            }
            while (v659 < v1142);
            uint64_t v668 = 0;
            uint64_t v669 = 0;
            uint64_t v670 = 0;
            uint64_t v671 = 0;
            unint64_t v672 = 0;
            do
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v673 = *(unsigned __int16 *)(a2 + 1922);
              if (v673 == 0xFFFF)
              {
                uint64_t v673 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1922) = v673;
                *(_WORD *)(a2 + 2004) = v673 + 1;
              }
              *((void *)&v1145[0] + 1) = v668 | (v673 << 48) | v669 | v670 | v671 | 0x40;
              uint64_t v674 = a2 + 2 * v672;
              uint64_t v675 = *(unsigned __int16 *)(v674 + 1970);
              if (v675 == 0xFFFF)
              {
                uint64_t v675 = (unsigned __int16)*v1138;
                *(_WORD *)(v674 + 1970) = v675;
                _WORD *v1138 = v675 + 1;
              }
              *(void *)&v1145[1] = (v675 << 48) | 0x19C840;
              uint64_t v676 = *(unsigned __int16 *)(v674 + 1954);
              if (v676 == 0xFFFF)
              {
                uint64_t v677 = (unsigned __int16)*v1138;
                *(_WORD *)(v674 + 1954) = v677;
                _WORD *v1138 = v677 + 1;
                uint64_t v676 = *(unsigned __int16 *)(v674 + 1954);
                *((void *)&v1145[1] + 1) = (v677 << 48) | 0x19C840;
                if (v676 == 0xFFFF)
                {
                  uint64_t v676 = (unsigned __int16)*v1138;
                  *(_WORD *)(v674 + 1954) = v676;
                  _WORD *v1138 = v676 + 1;
                }
              }
              else
              {
                *((void *)&v1145[1] + 1) = (v676 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = (v676 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v672;
              v671 += 0x8000;
              v670 += 0x2000;
              v669 += 2048;
              v668 += 512;
              unint64_t v550 = v1142;
            }
            while (v672 < v1142);
          }
          else
          {
            if (!v550) {
              goto LABEL_927;
            }
            uint64_t v630 = 0;
            uint64_t v631 = 0;
            uint64_t v632 = 0;
            uint64_t v633 = 0;
            unint64_t v634 = 0;
            do
            {
              int v635 = *(_DWORD *)&v1140[4 * v634];
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v636 = *(unsigned __int16 *)(a2 + 1922);
              if (v636 == 0xFFFF)
              {
                uint64_t v636 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1922) = v636;
                *(_WORD *)(a2 + 2004) = v636 + 1;
              }
              *((void *)&v1145[0] + 1) = v630 | (v636 << 48) | v631 | v632 | v633 | 0x40;
              int v637 = 2 * v635 + 257;
              uint64_t v638 = a2 + 4 * v637;
              uint64_t v639 = *(unsigned __int16 *)(v638 + 260);
              if (v639 == 0xFFFF)
              {
                uint64_t v640 = *(__int16 *)(a2 + 1998);
                uint64_t v639 = *(unsigned __int16 *)(a2 + 1998);
                *(_WORD *)(v638 + 260) = v640;
                *(_WORD *)(a2 + 4 * v640 + 262) = v637;
                BOOL v75 = (v637 & 0xFFFFFFF0) == 144;
                __int16 v641 = v640 + 11;
                if (!v75) {
                  __int16 v641 = v640 + 1;
                }
                *(_WORD *)(a2 + 1998) = v641;
              }
              *(void *)&v1145[1] = ((v639 << 48) | 0x19C840) + 64;
              uint64_t v642 = a2 + 2 * v634;
              uint64_t v643 = *(unsigned __int16 *)(v642 + 1954);
              if (v643 == 0xFFFF)
              {
                uint64_t v644 = (unsigned __int16)*v1138;
                *(_WORD *)(v642 + 1954) = v644;
                _WORD *v1138 = v644 + 1;
                uint64_t v643 = *(unsigned __int16 *)(v642 + 1954);
                *((void *)&v1145[1] + 1) = (v644 << 48) | 0x19C840;
                if (v643 == 0xFFFF)
                {
                  uint64_t v643 = (unsigned __int16)*v1138;
                  *(_WORD *)(v642 + 1954) = v643;
                  _WORD *v1138 = v643 + 1;
                }
              }
              else
              {
                *((void *)&v1145[1] + 1) = (v643 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = (v643 << 48) | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              ++v634;
              v633 += 0x8000;
              v632 += 0x2000;
              v631 += 2048;
              v630 += 512;
              unint64_t v550 = v1142;
            }
            while (v634 < v1142);
          }
        }
      }
      int v1129 = 0;
      BOOL v617 = v550 != 0;
      if (v1134)
      {
        uint64_t v59 = (_WORD *)(a2 + 2004);
        if (!v550) {
          goto LABEL_928;
        }
        uint64_t v618 = 0;
        uint64_t v619 = 0;
        uint64_t v620 = 0;
        uint64_t v621 = 0;
        unint64_t v622 = 0;
        do
        {
          if ((v1134 >> v622))
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v623 = *(unsigned __int16 *)(a2 + 1940);
            if (v623 == 0xFFFF)
            {
              uint64_t v623 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1940) = v623;
              *(_WORD *)(a2 + 2004) = v623 + 1;
            }
            *((void *)&v1145[0] + 1) = v618 | (v623 << 48) | v619 | v620 | v621 | 0x40;
            uint64_t v624 = a2 + 2 * v622;
            uint64_t v625 = *(unsigned __int16 *)(v624 + 1946);
            if (v625 == 0xFFFF)
            {
              uint64_t v625 = (unsigned __int16)*v1138;
              *(_WORD *)(v624 + 1946) = v625;
              _WORD *v1138 = v625 + 1;
            }
            *(void *)&v1145[1] = (v625 << 48) | 0x19C840;
            uint64_t v626 = *(unsigned __int16 *)(a2 + 1904);
            if (v626 == 0xFFFF)
            {
              uint64_t v628 = *(unsigned __int16 *)(a2 + 2004);
              int v629 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1904) = v628;
              *(_WORD *)(a2 + 2004) = ++v629;
              *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v628 << 48) | 0x19C840;
              if ((v629 & 0x10000) != 0)
              {
                uint64_t v628 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1904) = v628;
                *(_WORD *)(a2 + 2004) = v628 + 1;
              }
              uint64_t v627 = v628 << 48;
            }
            else
            {
              uint64_t v627 = v626 << 48;
              *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v626 << 48) | 0x19C840;
            }
            *(void *)&v1145[0] = v627 | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            unint64_t v550 = v1142;
          }
          ++v622;
          v621 += 0x8000;
          v620 += 0x2000;
          v619 += 2048;
          v618 += 512;
        }
        while (v622 < v550);
        BOOL v617 = 1;
        int v1129 = 1;
      }
      uint64_t v59 = (_WORD *)(a2 + 2004);
LABEL_928:
      unsigned int v696 = ~v1134 & 0xF;
      if (!v696) {
        BOOL v617 = 0;
      }
      BOOL v1127 = v617;
      if (v617)
      {
        unint64_t v697 = 0;
        do
        {
          if ((v696 >> v697))
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
            *(_DWORD *)(a2 + 16) = 2;
            uint64_t v698 = a2 + 2 * v697;
            uint64_t v699 = *(unsigned __int16 *)(v698 + 1946);
            if (v699 == 0xFFFF)
            {
              uint64_t v699 = (unsigned __int16)*v59;
              *(_WORD *)(v698 + 1946) = v699;
              *uint64_t v59 = v699 + 1;
            }
            *((void *)&v1145[0] + 1) = (v699 << 48) | 0x19C840;
            uint64_t v700 = *(unsigned __int16 *)(a2 + 1904);
            if (v700 == 0xFFFF)
            {
              uint64_t v702 = *(unsigned __int16 *)(a2 + 2004);
              int v703 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1904) = v702;
              *(_WORD *)(a2 + 2004) = ++v703;
              *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v702 << 48) | 0x19C840;
              if ((v703 & 0x10000) != 0)
              {
                uint64_t v702 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1904) = v702;
                *(_WORD *)(a2 + 2004) = v702 + 1;
              }
              uint64_t v701 = v702 << 48;
            }
            else
            {
              uint64_t v701 = v700 << 48;
              *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v700 << 48) | 0x19C840;
            }
            *(void *)&v1145[0] = v701 | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            unint64_t v550 = v1142;
          }
          ++v697;
        }
        while (v697 < v550);
      }
      if ((*a1 & 0x8000000000000000) != 0)
      {
        if (v1129)
        {
          uint64_t v704 = 0;
          uint64_t v705 = -v1125;
          uint64_t v706 = (_WORD *)(a2 + 2 * v705 + 1962);
          while (((v1134 >> v704) & 1) == 0)
          {
LABEL_961:
            if (++v704 >= v550) {
              goto LABEL_965;
            }
          }
          if (v704 == v705)
          {
            memset((char *)&v1145[1] + 8, 0, 48);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
            *(_DWORD *)(a2 + 16) = 2;
            uint64_t v707 = *(unsigned __int16 *)(a2 + 1940);
            if (v707 == 0xFFFF)
            {
              uint64_t v707 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1940) = v707;
              *(_WORD *)(a2 + 2004) = v707 + 1;
            }
            *((void *)&v1145[0] + 1) = ((unint64_t)-v1125 << 9) | (v707 << 48) | ((unint64_t)-v1125 << 11) | ((unint64_t)-v1125 << 13) | ((unint64_t)-v1125 << 15) | 0x40;
            uint64_t v708 = (unsigned __int16)*v706;
            if (v708 == 0xFFFF)
            {
              uint64_t v708 = (unsigned __int16)*v1138;
              *uint64_t v706 = v708;
              _WORD *v1138 = v708 + 1;
            }
            *(void *)&v1145[1] = (v708 << 48) | 0x19C840;
            uint64_t v709 = *(unsigned __int16 *)(a2 + 1908);
            if (v709 != 0xFFFF) {
              goto LABEL_953;
            }
          }
          else
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
            *(_DWORD *)(a2 + 16) = 3;
            uint64_t v711 = *(unsigned __int16 *)(a2 + 1940);
            if (v711 == 0xFFFF)
            {
              uint64_t v711 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1940) = v711;
              *(_WORD *)(a2 + 2004) = v711 + 1;
            }
            *((void *)&v1145[0] + 1) = (v711 << 48) | (v704 << 9) | (v704 << 11) | (v704 << 13) | (v704 << 15) | 0x40;
            uint64_t v712 = a2 + 2 * v704;
            uint64_t v713 = *(unsigned __int16 *)(v712 + 1962);
            if (v713 == 0xFFFF)
            {
              uint64_t v713 = (unsigned __int16)*v1138;
              *(_WORD *)(v712 + 1962) = v713;
              _WORD *v1138 = v713 + 1;
            }
            *(void *)&v1145[1] = (v713 << 48) | 0x19C840;
            uint64_t v714 = *(unsigned __int16 *)(a2 + 1908);
            if (v714 != 0xFFFF)
            {
              uint64_t v710 = v714 << 48;
              *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v714 << 48) | 0x19C840;
              goto LABEL_960;
            }
            uint64_t v709 = *(unsigned __int16 *)(a2 + 2004);
            int v715 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1908) = v709;
            *(_WORD *)(a2 + 2004) = ++v715;
            *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v709 << 48) | 0x19C840;
            if ((v715 & 0x10000) == 0)
            {
LABEL_953:
              uint64_t v710 = v709 << 48;
LABEL_960:
              *(void *)&v1145[0] = v710 | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v550 = v1142;
              goto LABEL_961;
            }
          }
          uint64_t v709 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1908) = v709;
          *(_WORD *)(a2 + 2004) = v709 + 1;
          goto LABEL_953;
        }
LABEL_965:
        uint64_t v59 = (_WORD *)(a2 + 2004);
        if (v1127)
        {
          uint64_t v716 = 0;
          uint64_t v717 = (_WORD *)(a2 + 2 * -v1125 + 1962);
          while (((v696 >> v716) & 1) == 0)
          {
LABEL_979:
            if (++v716 >= v550) {
              goto LABEL_983;
            }
          }
          if (v1122 == v716)
          {
            memset(&v1145[1], 0, 56);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
            *(_DWORD *)(a2 + 16) = 1;
            uint64_t v718 = (unsigned __int16)*v717;
            if (v718 == 0xFFFF)
            {
              uint64_t v718 = (unsigned __int16)*v1138;
              *uint64_t v717 = v718;
              _WORD *v1138 = v718 + 1;
            }
            *((void *)&v1145[0] + 1) = (v718 << 48) | 0x19C840;
            uint64_t v719 = *(unsigned __int16 *)(a2 + 1908);
            if (v719 == 0xFFFF)
            {
LABEL_972:
              uint64_t v719 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1908) = v719;
              *(_WORD *)(a2 + 2004) = v719 + 1;
            }
LABEL_973:
            uint64_t v720 = v719 << 48;
          }
          else
          {
            memset(v1145, 0, 72);
            uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
            *(_DWORD *)(a2 + 16) = 2;
            uint64_t v721 = a2 + 2 * v716;
            uint64_t v722 = *(unsigned __int16 *)(v721 + 1962);
            if (v722 == 0xFFFF)
            {
              uint64_t v722 = (unsigned __int16)*v1138;
              *(_WORD *)(v721 + 1962) = v722;
              _WORD *v1138 = v722 + 1;
            }
            *((void *)&v1145[0] + 1) = (v722 << 48) | 0x19C840;
            uint64_t v723 = *(unsigned __int16 *)(a2 + 1908);
            if (v723 == 0xFFFF)
            {
              uint64_t v719 = *(unsigned __int16 *)(a2 + 2004);
              int v724 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1908) = v719;
              *(_WORD *)(a2 + 2004) = ++v724;
              *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v719 << 48) | 0x19C840;
              if ((v724 & 0x10000) != 0) {
                goto LABEL_972;
              }
              goto LABEL_973;
            }
            uint64_t v720 = v723 << 48;
            *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v723 << 48) | 0x19C840;
          }
          *(void *)&v1145[0] = v720 | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
          unint64_t v550 = v1142;
          goto LABEL_979;
        }
      }
LABEL_983:
      if ((*a1 & 0x1000000000000) != 0)
      {
        if (v1129)
        {
          uint64_t v725 = 0;
          uint64_t v726 = 0;
          uint64_t v727 = 0;
          uint64_t v728 = 0;
          unint64_t v729 = 0;
          do
          {
            if ((v1134 >> v729))
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v730 = *(unsigned __int16 *)(a2 + 1940);
              if (v730 == 0xFFFF)
              {
                uint64_t v730 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1940) = v730;
                *(_WORD *)(a2 + 2004) = v730 + 1;
              }
              *((void *)&v1145[0] + 1) = v725 | (v730 << 48) | v726 | v727 | v728 | 0x40;
              uint64_t v731 = a2 + 2 * v729;
              uint64_t v732 = *(unsigned __int16 *)(v731 + 1954);
              if (v732 == 0xFFFF)
              {
                uint64_t v732 = (unsigned __int16)*v1138;
                *(_WORD *)(v731 + 1954) = v732;
                _WORD *v1138 = v732 + 1;
              }
              *(void *)&v1145[1] = (v732 << 48) | 0x19C840;
              uint64_t v733 = *(unsigned __int16 *)(a2 + 1906);
              if (v733 == 0xFFFF)
              {
                uint64_t v735 = *(unsigned __int16 *)(a2 + 2004);
                int v736 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1906) = v735;
                *(_WORD *)(a2 + 2004) = ++v736;
                *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v735 << 48) | 0x19C840;
                if ((v736 & 0x10000) != 0)
                {
                  uint64_t v735 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1906) = v735;
                  *(_WORD *)(a2 + 2004) = v735 + 1;
                }
                uint64_t v734 = v735 << 48;
              }
              else
              {
                uint64_t v734 = v733 << 48;
                *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v733 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = v734 | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v550 = v1142;
            }
            ++v729;
            v728 += 0x8000;
            v727 += 0x2000;
            v726 += 2048;
            v725 += 512;
          }
          while (v729 < v550);
        }
        uint64_t v59 = (_WORD *)(a2 + 2004);
        if (v1127)
        {
          unint64_t v737 = 0;
          do
          {
            if ((v696 >> v737))
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v738 = a2 + 2 * v737;
              uint64_t v739 = *(unsigned __int16 *)(v738 + 1954);
              if (v739 == 0xFFFF)
              {
                uint64_t v739 = (unsigned __int16)*v1138;
                *(_WORD *)(v738 + 1954) = v739;
                _WORD *v1138 = v739 + 1;
              }
              *((void *)&v1145[0] + 1) = (v739 << 48) | 0x19C840;
              uint64_t v740 = *(unsigned __int16 *)(a2 + 1906);
              if (v740 == 0xFFFF)
              {
                uint64_t v742 = *(unsigned __int16 *)(a2 + 2004);
                int v743 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1906) = v742;
                *(_WORD *)(a2 + 2004) = ++v743;
                *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v742 << 48) | 0x19C840;
                if ((v743 & 0x10000) != 0)
                {
                  uint64_t v742 = *(unsigned __int16 *)(a2 + 2004);
                  *(_WORD *)(a2 + 1906) = v742;
                  *(_WORD *)(a2 + 2004) = v742 + 1;
                }
                uint64_t v741 = v742 << 48;
              }
              else
              {
                uint64_t v741 = v740 << 48;
                *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v740 << 48) | 0x19C840;
              }
              *(void *)&v1145[0] = v741 | 0x72679000;
              (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
              unint64_t v550 = v1142;
            }
            ++v737;
          }
          while (v737 < v550);
        }
        if ((*a1 & 0x8000000000000000) != 0)
        {
          if (v1129)
          {
            uint64_t v744 = 0;
            uint64_t v745 = -v1125;
            uint64_t v746 = (_WORD *)(a2 + 2 * v745 + 1970);
            while (((v1134 >> v744) & 1) == 0)
            {
LABEL_1029:
              if (++v744 >= v550) {
                goto LABEL_1033;
              }
            }
            if (v744 == v745)
            {
              memset((char *)&v1145[1] + 8, 0, 48);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v747 = *(unsigned __int16 *)(a2 + 1940);
              if (v747 == 0xFFFF)
              {
                uint64_t v747 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1940) = v747;
                *(_WORD *)(a2 + 2004) = v747 + 1;
              }
              *((void *)&v1145[0] + 1) = ((unint64_t)-v1125 << 9) | (v747 << 48) | ((unint64_t)-v1125 << 11) | ((unint64_t)-v1125 << 13) | ((unint64_t)-v1125 << 15) | 0x40;
              uint64_t v748 = (unsigned __int16)*v746;
              if (v748 == 0xFFFF)
              {
                uint64_t v748 = (unsigned __int16)*v1138;
                *uint64_t v746 = v748;
                _WORD *v1138 = v748 + 1;
              }
              *(void *)&v1145[1] = (v748 << 48) | 0x19C840;
              uint64_t v749 = *(unsigned __int16 *)(a2 + 1910);
              if (v749 != 0xFFFF) {
                goto LABEL_1021;
              }
            }
            else
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
              *(_DWORD *)(a2 + 16) = 3;
              uint64_t v751 = *(unsigned __int16 *)(a2 + 1940);
              if (v751 == 0xFFFF)
              {
                uint64_t v751 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1940) = v751;
                *(_WORD *)(a2 + 2004) = v751 + 1;
              }
              *((void *)&v1145[0] + 1) = (v751 << 48) | (v744 << 9) | (v744 << 11) | (v744 << 13) | (v744 << 15) | 0x40;
              uint64_t v752 = a2 + 2 * v744;
              uint64_t v753 = *(unsigned __int16 *)(v752 + 1970);
              if (v753 == 0xFFFF)
              {
                uint64_t v753 = (unsigned __int16)*v1138;
                *(_WORD *)(v752 + 1970) = v753;
                _WORD *v1138 = v753 + 1;
              }
              *(void *)&v1145[1] = (v753 << 48) | 0x19C840;
              uint64_t v754 = *(unsigned __int16 *)(a2 + 1910);
              if (v754 != 0xFFFF)
              {
                uint64_t v750 = v754 << 48;
                *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v754 << 48) | 0x19C840;
                goto LABEL_1028;
              }
              uint64_t v749 = *(unsigned __int16 *)(a2 + 2004);
              int v755 = *(unsigned __int16 *)(a2 + 2004);
              *(_WORD *)(a2 + 1910) = v749;
              *(_WORD *)(a2 + 2004) = ++v755;
              *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v749 << 48) | 0x19C840;
              if ((v755 & 0x10000) == 0)
              {
LABEL_1021:
                uint64_t v750 = v749 << 48;
LABEL_1028:
                *(void *)&v1145[0] = v750 | 0x72679000;
                (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
                unint64_t v550 = v1142;
                goto LABEL_1029;
              }
            }
            uint64_t v749 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1910) = v749;
            *(_WORD *)(a2 + 2004) = v749 + 1;
            goto LABEL_1021;
          }
LABEL_1033:
          uint64_t v59 = (_WORD *)(a2 + 2004);
          if (v1127)
          {
            uint64_t v756 = 0;
            uint64_t v757 = (_WORD *)(a2 + 2 * -v1125 + 1970);
            while (((v696 >> v756) & 1) == 0)
            {
LABEL_1047:
              if (++v756 >= v550) {
                goto LABEL_1051;
              }
            }
            if (v1122 == v756)
            {
              memset(&v1145[1], 0, 56);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
              *(_DWORD *)(a2 + 16) = 1;
              uint64_t v758 = (unsigned __int16)*v757;
              if (v758 == 0xFFFF)
              {
                uint64_t v758 = (unsigned __int16)*v1138;
                *uint64_t v757 = v758;
                _WORD *v1138 = v758 + 1;
              }
              *((void *)&v1145[0] + 1) = (v758 << 48) | 0x19C840;
              uint64_t v759 = *(unsigned __int16 *)(a2 + 1910);
              if (v759 == 0xFFFF)
              {
LABEL_1040:
                uint64_t v759 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1910) = v759;
                *(_WORD *)(a2 + 2004) = v759 + 1;
              }
LABEL_1041:
              uint64_t v760 = v759 << 48;
            }
            else
            {
              memset(v1145, 0, 72);
              uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
              *(_DWORD *)(a2 + 16) = 2;
              uint64_t v761 = a2 + 2 * v756;
              uint64_t v762 = *(unsigned __int16 *)(v761 + 1970);
              if (v762 == 0xFFFF)
              {
                uint64_t v762 = (unsigned __int16)*v1138;
                *(_WORD *)(v761 + 1970) = v762;
                _WORD *v1138 = v762 + 1;
              }
              *((void *)&v1145[0] + 1) = (v762 << 48) | 0x19C840;
              uint64_t v763 = *(unsigned __int16 *)(a2 + 1910);
              if (v763 == 0xFFFF)
              {
                uint64_t v759 = *(unsigned __int16 *)(a2 + 2004);
                int v764 = *(unsigned __int16 *)(a2 + 2004);
                *(_WORD *)(a2 + 1910) = v759;
                *(_WORD *)(a2 + 2004) = ++v764;
                *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v759 << 48) | 0x19C840;
                if ((v764 & 0x10000) != 0) {
                  goto LABEL_1040;
                }
                goto LABEL_1041;
              }
              uint64_t v760 = v763 << 48;
              *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v763 << 48) | 0x19C840;
            }
            *(void *)&v1145[0] = v760 | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            unint64_t v550 = v1142;
            goto LABEL_1047;
          }
        }
      }
LABEL_1051:
      unsigned int v58 = v1125 + 4;
      int v57 = v1122 - 4;
      unsigned int v54 = v1123;
      if (v1125 + 4 >= v1123) {
        goto LABEL_1665;
      }
    }
    unsigned int v64 = 0;
    unsigned int v63 = 0;
    unsigned int v1134 = 0;
    BOOL v1120 = 0;
    unsigned int v1131 = 15;
    int v1126 = 1;
    unsigned int v1128 = 0;
    if (v58) {
      goto LABEL_136;
    }
LABEL_129:
    if ((*a1 & 0x2000000000000) != 0)
    {
      memset((char *)v1145 + 8, 0, 64);
      uint64_t v95 = 8 * (*(_DWORD *)(a2 + 16) & 7);
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v1144 = v95 | 0x100080341;
      uint64_t v96 = *(unsigned __int16 *)(a2 + 1900);
      if (v96 == 0xFFFF)
      {
        uint64_t v98 = *(unsigned __int16 *)(a2 + 2004);
        int v99 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v98;
        *(_WORD *)(a2 + 2004) = ++v99;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v98 << 48) | 0x1FE40;
        if ((v99 & 0x10000) != 0)
        {
          uint64_t v98 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1900) = v98;
          *(_WORD *)(a2 + 2004) = v98 + 1;
        }
        uint64_t v97 = v98 << 48;
      }
      else
      {
        uint64_t v97 = v96 << 48;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v96 << 48) | 0x1FE40;
      }
      *(void *)&v1145[0] = v97 | 0x72609000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      unint64_t v60 = v1142;
    }
    goto LABEL_136;
  }
  if ((v41 & 0x2000000000000) != 0)
  {
    memset((char *)v1145 + 8, 0, 64);
    uint64_t v51 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v1144 = v51 | 0x100080341;
    uint64_t v52 = *(unsigned __int16 *)(a2 + 1900);
    if (v52 == 0xFFFF)
    {
      uint64_t v765 = *(unsigned __int16 *)(a2 + 2004);
      int v766 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v765;
      *(_WORD *)(a2 + 2004) = ++v766;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v765 << 48) | 0x1FE40;
      if ((v766 & 0x10000) != 0)
      {
        uint64_t v765 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v765;
        *(_WORD *)(a2 + 2004) = v765 + 1;
      }
      uint64_t v53 = v765 << 48;
    }
    else
    {
      uint64_t v53 = v52 << 48;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v52 << 48) | 0x1FE40;
    }
    *(void *)&v1145[0] = v53 | 0x72609000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset((char *)v1145 + 8, 0, 64);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v767 = *(unsigned __int16 *)(a2 + 1900);
    if (v767 == 0xFFFF)
    {
      uint64_t v769 = *(unsigned __int16 *)(a2 + 2004);
      int v770 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v769;
      *(_WORD *)(a2 + 2004) = ++v770;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v769 << 48) | 0x19C840;
      if ((v770 & 0x10000) != 0)
      {
        uint64_t v769 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1900) = v769;
        *(_WORD *)(a2 + 2004) = v769 + 1;
      }
      uint64_t v768 = v769 << 48;
    }
    else
    {
      uint64_t v768 = v767 << 48;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v767 << 48) | 0x19C840;
    }
    *(void *)&v1145[1] = v768 | 0x1FE40;
    uint64_t v771 = *(unsigned __int16 *)(a2 + 1942);
    if (v771 == 0xFFFF)
    {
      uint64_t v771 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1942) = v771;
      *(_WORD *)(a2 + 2004) = v771 + 1;
    }
    *(void *)&v1145[0] = (v771 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  }
  if (!v50)
  {
LABEL_1660:
    memset(&v1145[1], 0, 56);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v1097 = *(unsigned __int16 *)(a2 + 1664);
    if (v1097 == 0xFFFF)
    {
      uint64_t v1098 = *(__int16 *)(a2 + 1998);
      uint64_t v1097 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1664) = v1098;
      *(_WORD *)(a2 + 4 * v1098 + 262) = 351;
      *(_WORD *)(a2 + 1998) = v1098 + 1;
    }
    *((void *)&v1145[0] + 1) = (v1097 << 48) | 0xAA80;
    uint64_t v1099 = *(unsigned __int16 *)(a2 + 1908);
    if (v1099 == 0xFFFF)
    {
      uint64_t v1099 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1908) = v1099;
      *(_WORD *)(a2 + 2004) = v1099 + 1;
    }
    *(void *)&v1145[0] = (v1099 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    goto LABEL_1665;
  }
  uint64_t v772 = 0;
  int v773 = 0;
  int v1135 = 0;
  uint64_t v774 = (unsigned __int16 *)(a2 + 1348);
  v775 = (_WORD *)(a2 + 1288);
  do
  {
    if ((v50 & 1) == 0) {
      goto LABEL_1653;
    }
    v1143 = v775;
    uint64_t v1141 = v772;
    unint64_t v776 = a1[1];
    int v777 = (1 << v773);
    int v778 = v777 & (v776 >> 16);
    if (v778) {
      BOOL v779 = (v777 & v776) != 0;
    }
    else {
      BOOL v779 = 0;
    }
    BOOL v1139 = v779;
    int v780 = v773 + 320;
    int v1132 = v777 & v776;
    if ((v777 & v776) == 0)
    {
      memset(&v1145[1], 0, 56);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v792 = v774[96];
      if (v792 == 0xFFFF)
      {
        uint64_t v793 = *(__int16 *)(a2 + 1998);
        uint64_t v792 = *(unsigned __int16 *)(a2 + 1998);
        v774[96] = v793;
        *(_WORD *)(a2 + 4 * v793 + 262) = v773 + 320;
        BOOL v75 = (v780 & 0xFFFFFFF0) == 144;
        __int16 v794 = v793 + 11;
        if (!v75) {
          __int16 v794 = v793 + 1;
        }
        *(_WORD *)(a2 + 1998) = v794;
      }
      *((void *)&v1145[0] + 1) = ((v792 << 48) | 0x19C840) + 64;
      uint64_t v795 = *(unsigned __int16 *)(a2 + 1924);
      if (v795 != 0xFFFF) {
        goto LABEL_1120;
      }
      uint64_t v795 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1924) = v795;
      goto LABEL_1119;
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v781 = v774[96];
    if (v781 == 0xFFFF)
    {
      uint64_t v782 = *(__int16 *)(a2 + 1998);
      uint64_t v781 = *(unsigned __int16 *)(a2 + 1998);
      v774[96] = v782;
      *(_WORD *)(a2 + 4 * v782 + 262) = v773 + 320;
      BOOL v75 = (v780 & 0xFFFFFFF0) == 144;
      __int16 v783 = v782 + 11;
      if (!v75) {
        __int16 v783 = v782 + 1;
      }
      *(_WORD *)(a2 + 1998) = v783;
    }
    *((void *)&v1145[0] + 1) = ((v781 << 48) | 0x19C840) + 64;
    uint64_t v784 = *(unsigned __int16 *)(a2 + 1900);
    if (v784 == 0xFFFF)
    {
      uint64_t v784 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1900) = v784;
      *(_WORD *)(a2 + 2004) = v784 + 1;
    }
    *(void *)&v1145[1] = (v784 << 48) | 0x19C840;
    uint64_t v785 = *(unsigned __int16 *)(a2 + 1924);
    if (v785 == 0xFFFF)
    {
      uint64_t v785 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1924) = v785;
      *(_WORD *)(a2 + 2004) = v785 + 1;
    }
    *(void *)&v1145[0] = (v785 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    gleVStateProgram_NormalizeVector(a2, 12, 12, 23, 27);
    if (v778)
    {
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v786 = *(unsigned __int16 *)(a2 + 1946);
      if (v786 == 0xFFFF)
      {
        uint64_t v786 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v786;
        *(_WORD *)(a2 + 2004) = v786 + 1;
      }
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v786 << 48) | 0x19C840;
      uint64_t v787 = *(unsigned __int16 *)(a2 + 1954);
      if (v787 == 0xFFFF)
      {
        uint64_t v787 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v787;
        *(_WORD *)(a2 + 2004) = v787 + 1;
      }
      *(void *)&v1145[1] = (v787 << 48) | 0x19C840;
      if (v786 == 0xFFFF)
      {
        uint64_t v786 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v786;
        *(_WORD *)(a2 + 2004) = v786 + 1;
      }
      *(void *)&v1145[0] = (v786 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v788 = *(unsigned __int16 *)(a2 + 1946);
      if (v788 == 0xFFFF)
      {
        uint64_t v788 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v788;
        *(_WORD *)(a2 + 2004) = v788 + 1;
      }
      *((void *)&v1145[0] + 1) = (v788 << 48) | 0x19C840;
      int v789 = v773 + 312;
      uint64_t v790 = v774[80];
      if (v790 == 0xFFFF)
      {
        uint64_t v796 = *(__int16 *)(a2 + 1998);
        v774[80] = v796;
        *(_WORD *)(a2 + 4 * v796 + 262) = v789;
        if ((v789 & 0xFFFFFFF0) == 0x90) {
          __int16 v797 = 11;
        }
        else {
          __int16 v797 = 1;
        }
        *(_WORD *)(a2 + 1998) = v796 + v797;
        *(void *)&v1145[1] = (((unint64_t)(unsigned __int16)v796 << 48) | 0x15440) + 64;
        if (v796 == -1)
        {
          uint64_t v796 = *(__int16 *)(a2 + 1998);
          v774[80] = v796;
          *(_WORD *)(a2 + 4 * v796 + 262) = v789;
          *(_WORD *)(a2 + 1998) = v796 + v797;
        }
        uint64_t v791 = v796 << 48;
      }
      else
      {
        uint64_t v791 = v790 << 48;
        *(void *)&v1145[1] = (((unint64_t)(unsigned __int16)v790 << 48) | 0x15440) + 64;
      }
      *((void *)&v1145[1] + 1) = v791 | 0xAA80;
      uint64_t v798 = *(unsigned __int16 *)(a2 + 1954);
      if (v798 == 0xFFFF)
      {
        uint64_t v798 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v798;
        *(_WORD *)(a2 + 2004) = v798 + 1;
      }
      *(void *)&v1145[0] = (v798 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v799 = *(unsigned __int16 *)(a2 + 1946);
      if (v799 == 0xFFFF)
      {
        uint64_t v799 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v799;
        *(_WORD *)(a2 + 2004) = v799 + 1;
      }
      *((void *)&v1145[0] + 1) = (v799 << 48) | 0x19C840;
      uint64_t v800 = *(unsigned __int16 *)(a2 + 1954);
      if (v800 == 0xFFFF)
      {
        uint64_t v800 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v800;
        *(_WORD *)(a2 + 2004) = v800 + 1;
      }
      *(void *)&v1145[1] = (v800 << 48) | 0x19C840;
      uint64_t v801 = v774[80];
      if (v801 == 0xFFFF)
      {
        uint64_t v802 = *(__int16 *)(a2 + 1998);
        uint64_t v801 = *(unsigned __int16 *)(a2 + 1998);
        v774[80] = v802;
        *(_WORD *)(a2 + 4 * v802 + 262) = v789;
        if ((v789 & 0xFFFFFFF0) == 0x90) {
          __int16 v803 = v802 + 11;
        }
        else {
          __int16 v803 = v802 + 1;
        }
        *(_WORD *)(a2 + 1998) = v803;
        uint64_t v800 = *(unsigned __int16 *)(a2 + 1954);
      }
      *((void *)&v1145[1] + 1) = (v801 << 48) | 0x80;
      if (v800 == 0xFFFF)
      {
        uint64_t v800 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v800;
        *(_WORD *)(a2 + 2004) = v800 + 1;
      }
      *(void *)&v1145[0] = (v800 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(&v1145[1], 0, 56);
      char v804 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v1144 = (8 * (v804 & 7)) | 0x100100381;
      uint64_t v805 = *(unsigned __int16 *)(a2 + 1954);
      if (v805 == 0xFFFF)
      {
        uint64_t v805 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v805;
        *(_WORD *)(a2 + 2004) = v805 + 1;
      }
      *((void *)&v1145[0] + 1) = (v805 << 48) | 0x19C840;
      uint64_t v795 = *(unsigned __int16 *)(a2 + 1940);
      if (v795 != 0xFFFF) {
        goto LABEL_1120;
      }
      uint64_t v795 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1940) = v795;
LABEL_1119:
      *(_WORD *)(a2 + 2004) = v795 + 1;
LABEL_1120:
      *(void *)&v1145[0] = (v795 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v806 = *(unsigned __int16 *)(a2 + 1902);
    if (v806 == 0xFFFF)
    {
      uint64_t v806 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1902) = v806;
      *(_WORD *)(a2 + 2004) = v806 + 1;
    }
    *((void *)&v1145[0] + 1) = (v806 << 48) | 0x19C840;
    uint64_t v807 = *(unsigned __int16 *)(a2 + 1924);
    if (v807 == 0xFFFF)
    {
      uint64_t v807 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1924) = v807;
      *(_WORD *)(a2 + 2004) = v807 + 1;
    }
    *(void *)&v1145[1] = (v807 << 48) | 0x19C840;
    uint64_t v808 = *(unsigned __int16 *)(a2 + 1912);
    if (v808 == 0xFFFF)
    {
      uint64_t v808 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v808;
      *(_WORD *)(a2 + 2004) = v808 + 1;
    }
    *(void *)&v1145[0] = (v808 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    int v1137 = BYTE1(v776) >> v773;
    if (v1137)
    {
      memset(&v1145[1], 0, 56);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v809 = v774[112];
      if (v809 == 0xFFFF)
      {
        uint64_t v810 = *(__int16 *)(a2 + 1998);
        uint64_t v809 = *(unsigned __int16 *)(a2 + 1998);
        v774[112] = v810;
        *(_WORD *)(a2 + 4 * v810 + 262) = v773 + 328;
        __int16 v811 = v810 + 11;
        if (((v773 + 328) & 0xFFFFFFF0) != 0x90) {
          __int16 v811 = v810 + 1;
        }
        *(_WORD *)(a2 + 1998) = v811;
      }
      *((void *)&v1145[0] + 1) = ((v809 << 48) | 0x19C840) + 64;
      uint64_t v812 = *(unsigned __int16 *)(a2 + 1946);
      if (v812 == 0xFFFF)
      {
        uint64_t v812 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v812;
        *(_WORD *)(a2 + 2004) = v812 + 1;
      }
      *(void *)&v1145[0] = (v812 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v813 = *(unsigned __int16 *)(a2 + 1946);
      if (v813 == 0xFFFF)
      {
        uint64_t v813 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v813;
        *(_WORD *)(a2 + 2004) = v813 + 1;
      }
      *((void *)&v1145[0] + 1) = (v813 << 48) | 0x19C840;
      uint64_t v814 = *(unsigned __int16 *)(a2 + 1924);
      if (v814 == 0xFFFF)
      {
        uint64_t v814 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1924) = v814;
        *(_WORD *)(a2 + 2004) = v814 + 1;
      }
      *(void *)&v1145[1] = ((v814 << 48) | 0x19C840) + 16;
      uint64_t v815 = *(unsigned __int16 *)(a2 + 1954);
      if (v815 == 0xFFFF)
      {
        uint64_t v815 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v815;
        *(_WORD *)(a2 + 2004) = v815 + 1;
      }
      *(void *)&v1145[0] = (v815 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000C82;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v816 = *(unsigned __int16 *)(a2 + 1954);
      if (v1139)
      {
        if (v816 == 0xFFFF)
        {
          uint64_t v816 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v816;
          *(_WORD *)(a2 + 2004) = v816 + 1;
        }
        *((void *)&v1145[0] + 1) = (v816 << 48) | 0x19C840;
        uint64_t v817 = v774[48];
        if (v817 == 0xFFFF)
        {
          uint64_t v818 = *(__int16 *)(a2 + 1998);
          uint64_t v817 = *(unsigned __int16 *)(a2 + 1998);
          v774[48] = v818;
          *(_WORD *)(a2 + 4 * v818 + 262) = v773 + 296;
          __int16 v819 = v818 + 11;
          if (((v773 + 296) & 0xFFFFFFF0) != 0x90) {
            __int16 v819 = v818 + 1;
          }
          *(_WORD *)(a2 + 1998) = v819;
        }
        *(void *)&v1145[1] = ((v817 << 48) | 0x1FE40) + 64;
        uint64_t v820 = *(unsigned __int16 *)(a2 + 1946);
        if (v820 == 0xFFFF)
        {
          uint64_t v820 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v820;
          *(_WORD *)(a2 + 2004) = v820 + 1;
        }
        *(void *)&v1145[0] = (v820 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v821 = *(unsigned __int16 *)(a2 + 1940);
        if (v821 == 0xFFFF)
        {
          uint64_t v821 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v821;
          *(_WORD *)(a2 + 2004) = v821 + 1;
        }
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v821 << 48) | 0x19C840;
        uint64_t v822 = *(unsigned __int16 *)(a2 + 1946);
        if (v822 == 0xFFFF)
        {
          uint64_t v822 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v822;
          *(_WORD *)(a2 + 2004) = v822 + 1;
        }
        *(void *)&v1145[1] = (v822 << 48) | 0x19C840;
      }
      else
      {
        if (v816 == 0xFFFF)
        {
          uint64_t v816 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v816;
          *(_WORD *)(a2 + 2004) = v816 + 1;
        }
        *((void *)&v1145[0] + 1) = (v816 << 48) | 0x19C840;
        uint64_t v823 = v774[48];
        if (v823 == 0xFFFF)
        {
          uint64_t v824 = *(__int16 *)(a2 + 1998);
          uint64_t v823 = *(unsigned __int16 *)(a2 + 1998);
          v774[48] = v824;
          *(_WORD *)(a2 + 4 * v824 + 262) = v773 + 296;
          __int16 v825 = v824 + 11;
          if (((v773 + 296) & 0xFFFFFFF0) != 0x90) {
            __int16 v825 = v824 + 1;
          }
          *(_WORD *)(a2 + 1998) = v825;
        }
        *(void *)&v1145[1] = ((v823 << 48) | 0x1FE40) + 64;
        uint64_t v821 = *(unsigned __int16 *)(a2 + 1940);
      }
      if (v821 == 0xFFFF)
      {
        uint64_t v821 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v821;
        *(_WORD *)(a2 + 2004) = v821 + 1;
      }
      *(void *)&v1145[0] = (v821 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x2000000000000000) != 0)
      {
        memset(&v1145[1], 0, 56);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v835 = v774[80];
        if (v835 == 0xFFFF)
        {
          uint64_t v836 = *(__int16 *)(a2 + 1998);
          uint64_t v835 = *(unsigned __int16 *)(a2 + 1998);
          v774[80] = v836;
          *(_WORD *)(a2 + 4 * v836 + 262) = v773 + 312;
          __int16 v837 = v836 + 11;
          if (((v773 + 312) & 0xFFFFFFF0) != 0x90) {
            __int16 v837 = v836 + 1;
          }
          *(_WORD *)(a2 + 1998) = v837;
        }
        *((void *)&v1145[0] + 1) = ((v835 << 48) | 0x19C840) + 64;
        uint64_t v838 = *(unsigned __int16 *)(a2 + 1954);
        if (v838 == 0xFFFF)
        {
          uint64_t v838 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v838;
          *(_WORD *)(a2 + 2004) = v838 + 1;
        }
        *(void *)&v1145[0] = (v838 << 48) | 0x72609000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)v1145 + 8, 0, 64);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000041;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v839 = *(unsigned __int16 *)(a2 + 1954);
        if (v839 == 0xFFFF)
        {
          uint64_t v841 = *(unsigned __int16 *)(a2 + 2004);
          int v842 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v841;
          *(_WORD *)(a2 + 2004) = ++v842;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v841 << 48) | 0x19C840;
          if ((v842 & 0x10000) != 0)
          {
            uint64_t v841 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1954) = v841;
            *(_WORD *)(a2 + 2004) = v841 + 1;
          }
          uint64_t v840 = v841 << 48;
        }
        else
        {
          uint64_t v840 = v839 << 48;
          *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v839 << 48) | 0x19C840;
        }
        *(void *)&v1145[0] = v840 | 0x72611000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v832 = *(unsigned __int16 *)(a2 + 1940);
        if (v832 == 0xFFFF)
        {
          uint64_t v832 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v832;
          *(_WORD *)(a2 + 2004) = v832 + 1;
        }
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v832 << 48) | 0x19C840;
        uint64_t v843 = *(unsigned __int16 *)(a2 + 1954);
        if (v843 == 0xFFFF)
        {
          uint64_t v843 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v843;
          *(_WORD *)(a2 + 2004) = v843 + 1;
        }
        uint64_t v834 = (v843 << 48) | 0x15440;
      }
      else
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        char v826 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1144 = (8 * (v826 & 7)) | 0x100000E02;
        uint64_t v827 = *(unsigned __int16 *)(a2 + 1954);
        if (v827 == 0xFFFF)
        {
          uint64_t v827 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1954) = v827;
          *(_WORD *)(a2 + 2004) = v827 + 1;
        }
        *((void *)&v1145[0] + 1) = (v827 << 48) | 0x19C840;
        uint64_t v828 = v774[80];
        if (v828 == 0xFFFF)
        {
          uint64_t v829 = *(__int16 *)(a2 + 1998);
          uint64_t v828 = *(unsigned __int16 *)(a2 + 1998);
          v774[80] = v829;
          *(_WORD *)(a2 + 4 * v829 + 262) = v773 + 312;
          __int16 v830 = v829 + 11;
          if (((v773 + 312) & 0xFFFFFFF0) != 0x90) {
            __int16 v830 = v829 + 1;
          }
          *(_WORD *)(a2 + 1998) = v830;
        }
        *(void *)&v1145[1] = ((v828 << 48) | 0x1FE40) + 64;
        uint64_t v831 = *(unsigned __int16 *)(a2 + 1946);
        if (v831 == 0xFFFF)
        {
          uint64_t v831 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v831;
          *(_WORD *)(a2 + 2004) = v831 + 1;
        }
        *(void *)&v1145[0] = (v831 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v832 = *(unsigned __int16 *)(a2 + 1940);
        if (v832 == 0xFFFF)
        {
          uint64_t v832 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v832;
          *(_WORD *)(a2 + 2004) = v832 + 1;
        }
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v832 << 48) | 0x19C840;
        uint64_t v833 = *(unsigned __int16 *)(a2 + 1946);
        if (v833 == 0xFFFF)
        {
          uint64_t v833 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v833;
          *(_WORD *)(a2 + 2004) = v833 + 1;
        }
        uint64_t v834 = (v833 << 48) | 0x19C840;
      }
      *(void *)&v1145[1] = v834;
      if (v832 == 0xFFFF)
      {
        uint64_t v832 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v832;
        *(_WORD *)(a2 + 2004) = v832 + 1;
      }
      *(void *)&v1145[0] = (v832 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    }
    if ((*a1 & 0x400000000000000) == 0)
    {
      if ((*a1 & 0x2000000000000) != 0)
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v847 = *(unsigned __int16 *)(a2 + 1942);
        if (v847 == 0xFFFF)
        {
          uint64_t v847 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1942) = v847;
          goto LABEL_1217;
        }
      }
      else
      {
        if (!v1132)
        {
          memset(&v1145[1], 0, 56);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
          *(_DWORD *)(a2 + 16) = 1;
          uint64_t v869 = v774[64];
          if (v869 == 0xFFFF)
          {
            uint64_t v870 = *(__int16 *)(a2 + 1998);
            uint64_t v869 = *(unsigned __int16 *)(a2 + 1998);
            v774[64] = v870;
            *(_WORD *)(a2 + 4 * v870 + 262) = v773 + 304;
            __int16 v871 = v870 + 11;
            if (((v773 + 304) & 0xFFFFFFF0) != 0x90) {
              __int16 v871 = v870 + 1;
            }
            *(_WORD *)(a2 + 1998) = v871;
          }
          *((void *)&v1145[0] + 1) = ((v869 << 48) | 0x19C840) + 64;
          uint64_t v872 = *(unsigned __int16 *)(a2 + 1932);
          if (v872 == 0xFFFF)
          {
            uint64_t v872 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1932) = v872;
            *(_WORD *)(a2 + 2004) = v872 + 1;
          }
          *(void *)&v1145[0] = (v872 << 48) | 0x72679000;
          (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_1223:
          memset((char *)&v1145[1] + 8, 0, 48);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v856 = *(unsigned __int16 *)(a2 + 1902);
          if (v856 == 0xFFFF)
          {
            uint64_t v856 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1902) = v856;
            *(_WORD *)(a2 + 2004) = v856 + 1;
          }
          uint64_t v857 = 1689664;
          *((void *)&v1145[0] + 1) = (v856 << 48) | 0x19C840;
          uint64_t v858 = *(unsigned __int16 *)(a2 + 1932);
          if (v858 == 0xFFFF)
          {
            uint64_t v858 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1932) = v858;
LABEL_1260:
            *(_WORD *)(a2 + 2004) = v858 + 1;
            goto LABEL_1261;
          }
          goto LABEL_1261;
        }
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v844 = 8 * (*(_DWORD *)(a2 + 16) & 7);
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1144 = v844 | 0x3100011042;
        uint64_t v845 = *(unsigned __int16 *)(a2 + 1904);
        if (v845 == 0xFFFF)
        {
          uint64_t v845 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1904) = v845;
          *(_WORD *)(a2 + 2004) = v845 + 1;
        }
        *((void *)&v1145[0] + 1) = (v845 << 48) | 0x19C840;
        *(void *)&v1145[1] = 2560163840;
        uint64_t v846 = *(unsigned __int16 *)(a2 + 1946);
        if (v846 == 0xFFFF)
        {
          uint64_t v846 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v846;
          *(_WORD *)(a2 + 2004) = v846 + 1;
        }
        *(void *)&v1145[0] = (v846 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v847 = *(unsigned __int16 *)(a2 + 1946);
        if (v847 == 0xFFFF)
        {
          uint64_t v847 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1946) = v847;
LABEL_1217:
          *(_WORD *)(a2 + 2004) = v847 + 1;
        }
      }
      *((void *)&v1145[0] + 1) = (v847 << 48) | 0x19C840;
      uint64_t v854 = *(unsigned __int16 *)(a2 + 1924);
      if (v854 == 0xFFFF)
      {
        uint64_t v854 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1924) = v854;
        *(_WORD *)(a2 + 2004) = v854 + 1;
      }
      *(void *)&v1145[1] = (v854 << 48) | 0x19C840;
      uint64_t v855 = *(unsigned __int16 *)(a2 + 1932);
      if (v855 == 0xFFFF)
      {
        uint64_t v855 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1932) = v855;
        *(_WORD *)(a2 + 2004) = v855 + 1;
      }
      *(void *)&v1145[0] = (v855 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      gleVStateProgram_NormalizeVector(a2, 16, 16, 23, 23);
      goto LABEL_1223;
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B82;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v848 = *(unsigned __int16 *)(a2 + 1902);
    if (v848 == 0xFFFF)
    {
      uint64_t v848 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1902) = v848;
      *(_WORD *)(a2 + 2004) = v848 + 1;
    }
    *((void *)&v1145[0] + 1) = (v848 << 48) | 0x19C840;
    uint64_t v849 = *(unsigned __int16 *)(a2 + 1924);
    if (v849 == 0xFFFF)
    {
      uint64_t v849 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1924) = v849;
      *(_WORD *)(a2 + 2004) = v849 + 1;
    }
    *(void *)&v1145[1] = (v849 << 48) | 0x19C840;
    uint64_t v850 = *(unsigned __int16 *)(a2 + 1932);
    if (v850 == 0xFFFF)
    {
      uint64_t v850 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1932) = v850;
      *(_WORD *)(a2 + 2004) = v850 + 1;
    }
    *(void *)&v1145[0] = (v850 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B82;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v851 = *(unsigned __int16 *)(a2 + 1902);
    if (v851 == 0xFFFF)
    {
      uint64_t v851 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1902) = v851;
      *(_WORD *)(a2 + 2004) = v851 + 1;
    }
    *((void *)&v1145[0] + 1) = (v851 << 48) | 0x19C840;
    uint64_t v852 = *(unsigned __int16 *)(a2 + 1932);
    if (v852 == 0xFFFF)
    {
      uint64_t v859 = *(unsigned __int16 *)(a2 + 2004);
      int v860 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1932) = v859;
      *(_WORD *)(a2 + 2004) = ++v860;
      *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v859 << 48) | 0x19C840;
      if ((v860 & 0x10000) != 0)
      {
        uint64_t v859 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1932) = v859;
        *(_WORD *)(a2 + 2004) = v859 + 1;
      }
      uint64_t v853 = v859 << 48;
    }
    else
    {
      uint64_t v853 = v852 << 48;
      *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v852 << 48) | 0x19C840;
    }
    *(void *)&v1145[0] = v853 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset((char *)v1145 + 8, 0, 64);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v861 = *(unsigned __int16 *)(a2 + 1932);
    if (v861 != 0xFFFF)
    {
      uint64_t v862 = v861 << 48;
      unint64_t v863 = ((unint64_t)(unsigned __int16)v861 << 48) | 0x19C840;
      *((void *)&v1145[0] + 1) = v863;
LABEL_1244:
      *(void *)&v1145[1] = v863;
      goto LABEL_1245;
    }
    uint64_t v864 = *(unsigned __int16 *)(a2 + 2004);
    int v865 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1932) = v864;
    int v866 = v865 + 1;
    *(_WORD *)(a2 + 2004) = v865 + 1;
    unint64_t v863 = ((unint64_t)(unsigned __int16)v864 << 48) | 0x19C840;
    *((void *)&v1145[0] + 1) = v863;
    if ((v866 & 0x10000) == 0)
    {
      uint64_t v862 = v864 << 48;
      goto LABEL_1244;
    }
    uint64_t v867 = *(unsigned __int16 *)(a2 + 2004);
    int v868 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1932) = v867;
    *(_WORD *)(a2 + 2004) = ++v868;
    *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v867 << 48) | 0x19C840;
    if ((v868 & 0x10000) != 0)
    {
      uint64_t v867 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1932) = v867;
      *(_WORD *)(a2 + 2004) = v867 + 1;
    }
    uint64_t v862 = v867 << 48;
LABEL_1245:
    *(void *)&v1145[0] = v862 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    unint64_t v873 = *a1;
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v874 = *(unsigned __int16 *)(a2 + 1932);
    if ((v873 & 0x2000000000000) != 0)
    {
      if (v874 == 0xFFFF)
      {
        uint64_t v874 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1932) = v874;
        *(_WORD *)(a2 + 2004) = v874 + 1;
      }
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v874 << 48) | 0x19C840;
      uint64_t v875 = *(unsigned __int16 *)(a2 + 1924);
      if (v875 == 0xFFFF)
      {
        uint64_t v875 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1924) = v875;
        *(_WORD *)(a2 + 2004) = v875 + 1;
      }
      *(void *)&v1145[1] = (v875 << 48) | 0x19C840;
      if (v874 == 0xFFFF)
      {
        uint64_t v874 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1932) = v874;
        *(_WORD *)(a2 + 2004) = v874 + 1;
      }
      *(void *)&v1145[0] = (v874 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000A02;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v876 = *(unsigned __int16 *)(a2 + 1932);
      if (v876 == 0xFFFF)
      {
        uint64_t v876 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1932) = v876;
        *(_WORD *)(a2 + 2004) = v876 + 1;
      }
      uint64_t v857 = 1689664;
      *((void *)&v1145[0] + 1) = (v876 << 48) | 0x19C840;
      uint64_t v858 = *(unsigned __int16 *)(a2 + 1942);
      if (v858 == 0xFFFF)
      {
        uint64_t v858 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1942) = v858;
        goto LABEL_1260;
      }
    }
    else
    {
      if (v874 == 0xFFFF)
      {
        uint64_t v874 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1932) = v874;
        *(_WORD *)(a2 + 2004) = v874 + 1;
      }
      uint64_t v857 = 87104;
      *((void *)&v1145[0] + 1) = (v874 << 48) | 0x15440;
      uint64_t v858 = *(unsigned __int16 *)(a2 + 1924);
      if (v858 == 0xFFFF)
      {
        uint64_t v858 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1924) = v858;
        *(_WORD *)(a2 + 2004) = v858 + 1;
      }
    }
LABEL_1261:
    *(void *)&v1145[1] = v857 | (v858 << 48);
    uint64_t v877 = *(unsigned __int16 *)(a2 + 1912);
    if (v877 == 0xFFFF)
    {
      uint64_t v877 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v877;
      *(_WORD *)(a2 + 2004) = v877 + 1;
    }
    *(void *)&v1145[0] = (v877 << 48) | 0x72621000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    unint64_t v878 = *a1;
    if ((*a1 & 0x2000000000000000) != 0)
    {
      memset(&v1145[1], 0, 56);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v879 = *(unsigned __int16 *)(a2 + 1628);
      if (v879 == 0xFFFF)
      {
        uint64_t v880 = *(__int16 *)(a2 + 1998);
        uint64_t v879 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1628) = v880;
        *(_WORD *)(a2 + 4 * v880 + 262) = 342;
        *(_WORD *)(a2 + 1998) = v880 + 1;
      }
      *((void *)&v1145[0] + 1) = (v879 << 48) | 0x80;
      uint64_t v881 = *(unsigned __int16 *)(a2 + 1912);
      if (v881 == 0xFFFF)
      {
        uint64_t v881 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1912) = v881;
        *(_WORD *)(a2 + 2004) = v881 + 1;
      }
      *(void *)&v1145[0] = (v881 << 48) | 0x72609000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      unint64_t v878 = *a1;
    }
    if ((v878 & 0x1000000000000) != 0)
    {
      memset(&v1145[1], 0, 56);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v882 = *(unsigned __int16 *)(a2 + 1912);
      if (v882 == 0xFFFF)
      {
        uint64_t v882 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1912) = v882;
        *(_WORD *)(a2 + 2004) = v882 + 1;
      }
      *((void *)&v1145[0] + 1) = ((v882 << 48) | 0x19C840) + 16;
      uint64_t v883 = *(unsigned __int16 *)(a2 + 1914);
      if (v883 == 0xFFFF)
      {
        uint64_t v883 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v883;
        *(_WORD *)(a2 + 2004) = v883 + 1;
      }
      *(void *)&v1145[0] = (v883 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      unint64_t v878 = *a1;
      if ((*a1 & 0x2000000000000000) != 0)
      {
        memset(&v1145[1], 0, 56);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v884 = *(unsigned __int16 *)(a2 + 1632);
        if (v884 == 0xFFFF)
        {
          uint64_t v885 = *(__int16 *)(a2 + 1998);
          uint64_t v884 = *(unsigned __int16 *)(a2 + 1998);
          *(_WORD *)(a2 + 1632) = v885;
          *(_WORD *)(a2 + 4 * v885 + 262) = 343;
          *(_WORD *)(a2 + 1998) = v885 + 1;
        }
        *((void *)&v1145[0] + 1) = (v884 << 48) | 0x80;
        uint64_t v886 = *(unsigned __int16 *)(a2 + 1914);
        if (v886 == 0xFFFF)
        {
          uint64_t v886 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1914) = v886;
          *(_WORD *)(a2 + 2004) = v886 + 1;
        }
        *(void *)&v1145[0] = (v886 << 48) | 0x72609000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        unint64_t v878 = *a1;
      }
    }
    if ((v878 & 0x2000000000000000) != 0)
    {
      memset((char *)v1145 + 8, 0, 64);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000041;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v896 = *(unsigned __int16 *)(a2 + 1912);
      if (v896 != 0xFFFF)
      {
        uint64_t v895 = v896 << 48;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v896 << 48) | 0x19C840;
        goto LABEL_1307;
      }
      uint64_t v900 = *(unsigned __int16 *)(a2 + 2004);
      int v901 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v900;
      *(_WORD *)(a2 + 2004) = ++v901;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v900 << 48) | 0x19C840;
      if ((v901 & 0x10000) != 0)
      {
LABEL_1305:
        uint64_t v900 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1912) = v900;
        *(_WORD *)(a2 + 2004) = v900 + 1;
      }
      uint64_t v895 = v900 << 48;
      goto LABEL_1307;
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B42;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v887 = *(unsigned __int16 *)(a2 + 1912);
    if (v887 == 0xFFFF)
    {
      uint64_t v887 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v887;
      *(_WORD *)(a2 + 2004) = v887 + 1;
    }
    *((void *)&v1145[0] + 1) = (v887 << 48) | 0x19C240;
    uint64_t v888 = *(unsigned __int16 *)(a2 + 1664);
    if (v888 == 0xFFFF)
    {
      uint64_t v889 = *(__int16 *)(a2 + 1998);
      uint64_t v888 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1664) = v889;
      *(_WORD *)(a2 + 4 * v889 + 262) = 351;
      *(_WORD *)(a2 + 1998) = v889 + 1;
    }
    *(void *)&v1145[1] = (v888 << 48) | 0xAA80;
    if (v887 == 0xFFFF)
    {
      uint64_t v887 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v887;
      *(_WORD *)(a2 + 2004) = v887 + 1;
    }
    *(void *)&v1145[0] = (v887 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset((char *)&v1145[1] + 8, 0, 48);
    char v890 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v1144 = (8 * (v890 & 7)) | 0x100000E02;
    uint64_t v891 = *(unsigned __int16 *)(a2 + 1912);
    if (v891 == 0xFFFF)
    {
      uint64_t v891 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v891;
      *(_WORD *)(a2 + 2004) = v891 + 1;
    }
    *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v891 << 48) | 0x40;
    uint64_t v892 = *(unsigned __int16 *)(a2 + 1628);
    if (v892 == 0xFFFF)
    {
      uint64_t v893 = *(__int16 *)(a2 + 1998);
      uint64_t v892 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1628) = v893;
      *(_WORD *)(a2 + 4 * v893 + 262) = 342;
      *(_WORD *)(a2 + 1998) = v893 + 1;
    }
    *(void *)&v1145[1] = (v892 << 48) | 0x80;
    if (v891 == 0xFFFF)
    {
      uint64_t v891 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v891;
      *(_WORD *)(a2 + 2004) = v891 + 1;
    }
    *(void *)&v1145[0] = (v891 << 48) | 0x72611000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v894 = *(unsigned __int16 *)(a2 + 1912);
    if (v894 == 0xFFFF)
    {
      uint64_t v897 = *(unsigned __int16 *)(a2 + 2004);
      LODWORD(v894) = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v897;
      *(_WORD *)(a2 + 2004) = v894 + 1;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v897 << 48) | 0xAA50;
      if (((v894 + 1) & 0x10000) != 0)
      {
        uint64_t v897 = *(unsigned __int16 *)(a2 + 2004);
        LODWORD(v894) = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1912) = v897;
        *(_WORD *)(a2 + 2004) = v897 + 1;
      }
      uint64_t v895 = v897 << 48;
    }
    else
    {
      uint64_t v895 = v894 << 48;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v894 << 48) | 0xAA50;
    }
    *(void *)&v1145[1] = v895 | 0x19C840;
    uint64_t v898 = *(unsigned __int16 *)(a2 + 1664);
    if (v898 == 0xFFFF)
    {
      uint64_t v899 = *(__int16 *)(a2 + 1998);
      uint64_t v898 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1664) = v899;
      *(_WORD *)(a2 + 4 * v899 + 262) = 351;
      *(_WORD *)(a2 + 1998) = v899 + 1;
    }
    *((void *)&v1145[1] + 1) = (v898 << 48) | 0xAA80;
    if (v894 == 0xFFFF) {
      goto LABEL_1305;
    }
LABEL_1307:
    *(void *)&v1145[0] = v895 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    if ((*a1 & 0x1000000000000) == 0) {
      goto LABEL_1334;
    }
    if ((*a1 & 0x2000000000000000) == 0)
    {
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000B42;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v902 = *(unsigned __int16 *)(a2 + 1914);
      if (v902 == 0xFFFF)
      {
        uint64_t v902 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v902;
        *(_WORD *)(a2 + 2004) = v902 + 1;
      }
      *((void *)&v1145[0] + 1) = (v902 << 48) | 0x19C240;
      uint64_t v903 = *(unsigned __int16 *)(a2 + 1664);
      if (v903 == 0xFFFF)
      {
        uint64_t v904 = *(__int16 *)(a2 + 1998);
        uint64_t v903 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1664) = v904;
        *(_WORD *)(a2 + 4 * v904 + 262) = 351;
        *(_WORD *)(a2 + 1998) = v904 + 1;
        uint64_t v902 = *(unsigned __int16 *)(a2 + 1914);
      }
      *(void *)&v1145[1] = (v903 << 48) | 0xAA80;
      if (v902 == 0xFFFF)
      {
        uint64_t v902 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v902;
        *(_WORD *)(a2 + 2004) = v902 + 1;
      }
      *(void *)&v1145[0] = (v902 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      char v905 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v1144 = (8 * (v905 & 7)) | 0x100000E02;
      uint64_t v906 = *(unsigned __int16 *)(a2 + 1914);
      if (v906 == 0xFFFF)
      {
        uint64_t v906 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v906;
        *(_WORD *)(a2 + 2004) = v906 + 1;
      }
      *((void *)&v1145[0] + 1) = (v906 << 48) | 0x40;
      uint64_t v907 = *(unsigned __int16 *)(a2 + 1632);
      if (v907 == 0xFFFF)
      {
        uint64_t v908 = *(__int16 *)(a2 + 1998);
        uint64_t v907 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1632) = v908;
        *(_WORD *)(a2 + 4 * v908 + 262) = 343;
        *(_WORD *)(a2 + 1998) = v908 + 1;
        uint64_t v906 = *(unsigned __int16 *)(a2 + 1914);
      }
      *(void *)&v1145[1] = (v907 << 48) | 0x80;
      if (v906 == 0xFFFF)
      {
        uint64_t v906 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v906;
        *(_WORD *)(a2 + 2004) = v906 + 1;
      }
      *(void *)&v1145[0] = (v906 << 48) | 0x72611000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000F83;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v909 = *(unsigned __int16 *)(a2 + 1914);
      if (v909 == 0xFFFF)
      {
        uint64_t v913 = *(unsigned __int16 *)(a2 + 2004);
        uint64_t v909 = v913;
        *(_WORD *)(a2 + 1914) = v913;
        *(_WORD *)(a2 + 2004) = v913 + 1;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v913 << 48) | 0xAA50;
        if (((v913 + 1) & 0x10000) != 0)
        {
          uint64_t v913 = *(unsigned __int16 *)(a2 + 2004);
          uint64_t v909 = v913;
          *(_WORD *)(a2 + 1914) = v913;
          *(_WORD *)(a2 + 2004) = v913 + 1;
        }
        uint64_t v910 = v913 << 48;
      }
      else
      {
        uint64_t v910 = v909 << 48;
        *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v909 << 48) | 0xAA50;
      }
      *(void *)&v1145[1] = v910 | 0x19C840;
      uint64_t v914 = *(unsigned __int16 *)(a2 + 1664);
      if (v914 == 0xFFFF)
      {
        uint64_t v915 = *(__int16 *)(a2 + 1998);
        uint64_t v914 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1664) = v915;
        *(_WORD *)(a2 + 4 * v915 + 262) = 351;
        *(_WORD *)(a2 + 1998) = v915 + 1;
        uint64_t v909 = *(unsigned __int16 *)(a2 + 1914);
      }
      *((void *)&v1145[1] + 1) = (v914 << 48) | 0xAA80;
      if (v909 != 0xFFFF) {
        goto LABEL_1332;
      }
LABEL_1331:
      uint64_t v909 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1914) = v909;
      *(_WORD *)(a2 + 2004) = v909 + 1;
LABEL_1332:
      uint64_t v912 = v909 << 48;
      goto LABEL_1333;
    }
    memset((char *)v1145 + 8, 0, 64);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000041;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v911 = *(unsigned __int16 *)(a2 + 1914);
    if (v911 == 0xFFFF)
    {
      uint64_t v909 = *(unsigned __int16 *)(a2 + 2004);
      int v1013 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1914) = v909;
      *(_WORD *)(a2 + 2004) = ++v1013;
      *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v909 << 48) | 0x19C840;
      if ((v1013 & 0x10000) == 0) {
        goto LABEL_1332;
      }
      goto LABEL_1331;
    }
    uint64_t v912 = v911 << 48;
    *((void *)&v1145[0] + 1) = ((unint64_t)(unsigned __int16)v911 << 48) | 0x19C840;
LABEL_1333:
    *(void *)&v1145[0] = v912 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_1334:
    if ((v1124 & 6) == 6)
    {
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v916 = *v774;
      int v917 = v1141;
      if (v916 == 0xFFFF)
      {
        uint64_t v918 = *(__int16 *)(a2 + 1998);
        uint64_t v916 = *(unsigned __int16 *)(a2 + 1998);
        *uint64_t v774 = v918;
        *(_WORD *)(a2 + 4 * v918 + 262) = v773 + 272;
        __int16 v919 = v918 + 11;
        if (((v773 + 272) & 0xFFFFFFF0) != 0x90) {
          __int16 v919 = v918 + 1;
        }
        *(_WORD *)(a2 + 1998) = v919;
      }
      *((void *)&v1145[0] + 1) = ((v916 << 48) | 0x19C840) + 64;
      *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
      uint64_t v920 = *(unsigned __int16 *)(a2 + 1946);
      if (v920 == 0xFFFF)
      {
        uint64_t v920 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v920;
        *(_WORD *)(a2 + 2004) = v920 + 1;
      }
      *(void *)&v1145[0] = (v920 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v921 = v774[16];
      if (v921 == 0xFFFF)
      {
        uint64_t v922 = *(__int16 *)(a2 + 1998);
        uint64_t v921 = *(unsigned __int16 *)(a2 + 1998);
        v774[16] = v922;
        *(_WORD *)(a2 + 4 * v922 + 262) = v773 + 280;
        __int16 v923 = v922 + 11;
        if (((v773 + 280) & 0xFFFFFFF0) != 0x90) {
          __int16 v923 = v922 + 1;
        }
        *(_WORD *)(a2 + 1998) = v923;
      }
      *((void *)&v1145[0] + 1) = ((v921 << 48) | 0x19C840) + 64;
      *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
      uint64_t v924 = *(unsigned __int16 *)(a2 + 1962);
      if (v924 == 0xFFFF)
      {
        uint64_t v924 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1962) = v924;
        *(_WORD *)(a2 + 2004) = v924 + 1;
      }
      *(void *)&v1145[0] = (v924 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v925 = *(unsigned __int16 *)(a2 + 1912);
      if (v925 == 0xFFFF)
      {
        uint64_t v925 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1912) = v925;
        *(_WORD *)(a2 + 2004) = v925 + 1;
      }
      *((void *)&v1145[0] + 1) = (v925 << 48) | 0xAA40;
      uint64_t v926 = *(unsigned __int16 *)(a2 + 1962);
      if (v926 == 0xFFFF)
      {
        uint64_t v926 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1962) = v926;
        *(_WORD *)(a2 + 2004) = v926 + 1;
      }
      uint64_t v927 = (v926 << 48) | 0x19C840;
      goto LABEL_1375;
    }
    int v917 = v1141;
    if ((v1124 & 2) == 0)
    {
      if ((v1124 & 4) != 0)
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v969 = v774[16];
        if (v969 == 0xFFFF)
        {
          uint64_t v970 = *(__int16 *)(a2 + 1998);
          uint64_t v969 = *(unsigned __int16 *)(a2 + 1998);
          v774[16] = v970;
          *(_WORD *)(a2 + 4 * v970 + 262) = v773 + 280;
          __int16 v971 = v970 + 11;
          if (((v773 + 280) & 0xFFFFFFF0) != 0x90) {
            __int16 v971 = v970 + 1;
          }
          *(_WORD *)(a2 + 1998) = v971;
        }
        *((void *)&v1145[0] + 1) = ((v969 << 48) | 0x19C840) + 64;
        *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
        uint64_t v972 = *(unsigned __int16 *)(a2 + 1962);
        if (v972 == 0xFFFF)
        {
          uint64_t v972 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1962) = v972;
          *(_WORD *)(a2 + 2004) = v972 + 1;
        }
        *(void *)&v1145[0] = (v972 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v973 = *(unsigned __int16 *)(a2 + 1912);
        if (v973 == 0xFFFF)
        {
          uint64_t v973 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1912) = v973;
          *(_WORD *)(a2 + 2004) = v973 + 1;
        }
        *((void *)&v1145[0] + 1) = (v973 << 48) | 0xAA40;
        uint64_t v974 = *(unsigned __int16 *)(a2 + 1962);
        if (v974 == 0xFFFF)
        {
          uint64_t v974 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1962) = v974;
          *(_WORD *)(a2 + 2004) = v974 + 1;
        }
        *(void *)&v1145[1] = (v974 << 48) | 0x19C840;
        uint64_t v933 = (unsigned __int16)*(v1143 - 66);
        if (v933 == 0xFFFF)
        {
          int v934 = v1141 + 224;
          uint64_t v935 = *(__int16 *)(a2 + 1998);
          uint64_t v933 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 66) = v935;
          __int16 v936 = 2 * v773 + 224;
LABEL_1421:
          *(_WORD *)(a2 + 4 * v935 + 262) = v936;
          BOOL v75 = (v934 & 0xFFFFFFF0) == 144;
          __int16 v975 = v935 + 11;
          if (!v75) {
            __int16 v975 = v935 + 1;
          }
          *(_WORD *)(a2 + 1998) = v975;
        }
      }
      else
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v928 = *(unsigned __int16 *)(a2 + 1912);
        if (v928 == 0xFFFF)
        {
          uint64_t v928 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1912) = v928;
          *(_WORD *)(a2 + 2004) = v928 + 1;
        }
        *((void *)&v1145[0] + 1) = (v928 << 48) | 0xAA40;
        uint64_t v929 = v1143;
        uint64_t v930 = (unsigned __int16)*(v1143 - 34);
        if (v930 == 0xFFFF)
        {
          uint64_t v931 = *(__int16 *)(a2 + 1998);
          uint64_t v930 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 34) = v931;
          *(_WORD *)(a2 + 4 * v931 + 262) = v1141 + 240;
          __int16 v932 = v931 + 11;
          if (((v1141 + 240) & 0xFFFFFFF0) != 0x90) {
            __int16 v932 = v931 + 1;
          }
          *(_WORD *)(a2 + 1998) = v932;
          uint64_t v929 = v1143;
        }
        *(void *)&v1145[1] = ((v930 << 48) | 0x19C840) + 64;
        uint64_t v933 = (unsigned __int16)*(v929 - 66);
        if (v933 == 0xFFFF)
        {
          int v934 = v1141 + 224;
          uint64_t v935 = *(__int16 *)(a2 + 1998);
          uint64_t v933 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 66) = v935;
          __int16 v936 = v1141 + 224;
          goto LABEL_1421;
        }
      }
      *((void *)&v1145[1] + 1) = ((v933 << 48) | 0x19C840) + 64;
      uint64_t v947 = *(unsigned __int16 *)(a2 + 1946);
      if (v947 != 0xFFFF) {
        goto LABEL_1379;
      }
LABEL_1378:
      uint64_t v947 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v947;
      *(_WORD *)(a2 + 2004) = v947 + 1;
      goto LABEL_1379;
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v937 = *v774;
    if (v937 == 0xFFFF)
    {
      uint64_t v938 = *(__int16 *)(a2 + 1998);
      uint64_t v937 = *(unsigned __int16 *)(a2 + 1998);
      *uint64_t v774 = v938;
      *(_WORD *)(a2 + 4 * v938 + 262) = v773 + 272;
      __int16 v939 = v938 + 11;
      if (((v773 + 272) & 0xFFFFFFF0) != 0x90) {
        __int16 v939 = v938 + 1;
      }
      *(_WORD *)(a2 + 1998) = v939;
    }
    *((void *)&v1145[0] + 1) = ((v937 << 48) | 0x19C840) + 64;
    *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v940 = *(unsigned __int16 *)(a2 + 1946);
    if (v940 == 0xFFFF)
    {
      uint64_t v940 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v940;
      *(_WORD *)(a2 + 2004) = v940 + 1;
    }
    *(void *)&v1145[0] = (v940 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v941 = *(unsigned __int16 *)(a2 + 1912);
    if (v941 == 0xFFFF)
    {
      uint64_t v941 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v941;
      *(_WORD *)(a2 + 2004) = v941 + 1;
    }
    *((void *)&v1145[0] + 1) = (v941 << 48) | 0xAA40;
    uint64_t v942 = (unsigned __int16)*(v1143 - 34);
    if (v942 == 0xFFFF)
    {
      uint64_t v943 = *(__int16 *)(a2 + 1998);
      uint64_t v942 = *(unsigned __int16 *)(a2 + 1998);
      *(v1143 - 34) = v943;
      *(_WORD *)(a2 + 4 * v943 + 262) = 2 * v773 + 240;
      __int16 v944 = v943 + 11;
      if (((v1141 + 240) & 0xFFFFFFF0) != 0x90) {
        __int16 v944 = v943 + 1;
      }
      *(_WORD *)(a2 + 1998) = v944;
    }
    uint64_t v927 = ((v942 << 48) | 0x19C840) + 64;
LABEL_1375:
    *(void *)&v1145[1] = v927;
    uint64_t v945 = *(unsigned __int16 *)(a2 + 1946);
    if (v945 != 0xFFFF)
    {
      uint64_t v946 = v945 << 48;
      *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v945 << 48) | 0x19C840;
      goto LABEL_1380;
    }
    uint64_t v947 = *(unsigned __int16 *)(a2 + 2004);
    int v948 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1946) = v947;
    *(_WORD *)(a2 + 2004) = ++v948;
    *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v947 << 48) | 0x19C840;
    if ((v948 & 0x10000) != 0) {
      goto LABEL_1378;
    }
LABEL_1379:
    uint64_t v946 = v947 << 48;
LABEL_1380:
    *(void *)&v1145[0] = v946 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    if ((*a1 & 0x1000000000000) == 0) {
      goto LABEL_1445;
    }
    if ((v1121 & 6) == 6)
    {
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v949 = *v774;
      if (v949 == 0xFFFF)
      {
        uint64_t v950 = *(__int16 *)(a2 + 1998);
        uint64_t v949 = *(unsigned __int16 *)(a2 + 1998);
        *uint64_t v774 = v950;
        *(_WORD *)(a2 + 4 * v950 + 262) = v773 + 272;
        __int16 v951 = v950 + 11;
        if (((v773 + 272) & 0xFFFFFFF0) != 0x90) {
          __int16 v951 = v950 + 1;
        }
        *(_WORD *)(a2 + 1998) = v951;
      }
      *((void *)&v1145[0] + 1) = ((v949 << 48) | 0x19C840) + 64;
      *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
      uint64_t v952 = *(unsigned __int16 *)(a2 + 1954);
      if (v952 == 0xFFFF)
      {
        uint64_t v952 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v952;
        *(_WORD *)(a2 + 2004) = v952 + 1;
      }
      *(void *)&v1145[0] = (v952 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v953 = v774[16];
      if (v953 == 0xFFFF)
      {
        uint64_t v954 = *(__int16 *)(a2 + 1998);
        uint64_t v953 = *(unsigned __int16 *)(a2 + 1998);
        v774[16] = v954;
        *(_WORD *)(a2 + 4 * v954 + 262) = v773 + 280;
        __int16 v955 = v954 + 11;
        if (((v773 + 280) & 0xFFFFFFF0) != 0x90) {
          __int16 v955 = v954 + 1;
        }
        *(_WORD *)(a2 + 1998) = v955;
      }
      *((void *)&v1145[0] + 1) = ((v953 << 48) | 0x19C840) + 64;
      *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
      uint64_t v956 = *(unsigned __int16 *)(a2 + 1970);
      if (v956 == 0xFFFF)
      {
        uint64_t v956 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v956;
        *(_WORD *)(a2 + 2004) = v956 + 1;
      }
      *(void *)&v1145[0] = (v956 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v957 = *(unsigned __int16 *)(a2 + 1914);
      if (v957 == 0xFFFF)
      {
        uint64_t v957 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v957;
        *(_WORD *)(a2 + 2004) = v957 + 1;
      }
      *((void *)&v1145[0] + 1) = (v957 << 48) | 0xAA40;
      uint64_t v958 = *(unsigned __int16 *)(a2 + 1970);
      if (v958 == 0xFFFF)
      {
        uint64_t v958 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v958;
        *(_WORD *)(a2 + 2004) = v958 + 1;
      }
      uint64_t v959 = (v958 << 48) | 0x19C840;
      goto LABEL_1439;
    }
    if ((v1121 & 2) == 0)
    {
      if ((v1121 & 4) != 0)
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1040 = v774[16];
        if (v1040 == 0xFFFF)
        {
          uint64_t v1041 = *(__int16 *)(a2 + 1998);
          uint64_t v1040 = *(unsigned __int16 *)(a2 + 1998);
          v774[16] = v1041;
          *(_WORD *)(a2 + 4 * v1041 + 262) = v773 + 280;
          __int16 v1042 = v1041 + 11;
          if (((v773 + 280) & 0xFFFFFFF0) != 0x90) {
            __int16 v1042 = v1041 + 1;
          }
          *(_WORD *)(a2 + 1998) = v1042;
        }
        *((void *)&v1145[0] + 1) = ((v1040 << 48) | 0x19C840) + 64;
        *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
        uint64_t v1043 = *(unsigned __int16 *)(a2 + 1970);
        if (v1043 == 0xFFFF)
        {
          uint64_t v1043 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v1043;
          *(_WORD *)(a2 + 2004) = v1043 + 1;
        }
        *(void *)&v1145[0] = (v1043 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v1044 = *(unsigned __int16 *)(a2 + 1914);
        if (v1044 == 0xFFFF)
        {
          uint64_t v1044 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1914) = v1044;
          *(_WORD *)(a2 + 2004) = v1044 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1044 << 48) | 0xAA40;
        uint64_t v1045 = *(unsigned __int16 *)(a2 + 1970);
        if (v1045 == 0xFFFF)
        {
          uint64_t v1045 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v1045;
          *(_WORD *)(a2 + 2004) = v1045 + 1;
        }
        *(void *)&v1145[1] = (v1045 << 48) | 0x19C840;
        uint64_t v965 = (unsigned __int16)*(v1143 - 64);
        if (v965 == 0xFFFF)
        {
          int v966 = v917 + 225;
          uint64_t v967 = *(__int16 *)(a2 + 1998);
          uint64_t v965 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 64) = v967;
          __int16 v968 = 2 * v773 + 225;
LABEL_1550:
          *(_WORD *)(a2 + 4 * v967 + 262) = v968;
          BOOL v75 = (v966 & 0xFFFFFFF0) == 144;
          __int16 v1046 = v967 + 11;
          if (!v75) {
            __int16 v1046 = v967 + 1;
          }
          *(_WORD *)(a2 + 1998) = v1046;
        }
      }
      else
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v960 = *(unsigned __int16 *)(a2 + 1914);
        if (v960 == 0xFFFF)
        {
          uint64_t v960 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1914) = v960;
          *(_WORD *)(a2 + 2004) = v960 + 1;
        }
        *((void *)&v1145[0] + 1) = (v960 << 48) | 0xAA40;
        uint64_t v961 = v1143;
        uint64_t v962 = (unsigned __int16)*(v1143 - 32);
        if (v962 == 0xFFFF)
        {
          uint64_t v963 = *(__int16 *)(a2 + 1998);
          uint64_t v962 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 32) = v963;
          *(_WORD *)(a2 + 4 * v963 + 262) = v917 + 241;
          __int16 v964 = v963 + 11;
          if (((v917 + 241) & 0xFFFFFFF0) != 0x90) {
            __int16 v964 = v963 + 1;
          }
          *(_WORD *)(a2 + 1998) = v964;
          uint64_t v961 = v1143;
        }
        *(void *)&v1145[1] = ((v962 << 48) | 0x19C840) + 64;
        uint64_t v965 = (unsigned __int16)*(v961 - 64);
        if (v965 == 0xFFFF)
        {
          int v966 = v917 + 225;
          uint64_t v967 = *(__int16 *)(a2 + 1998);
          uint64_t v965 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 64) = v967;
          __int16 v968 = v917 + 225;
          goto LABEL_1550;
        }
      }
      *((void *)&v1145[1] + 1) = ((v965 << 48) | 0x19C840) + 64;
      uint64_t v986 = *(unsigned __int16 *)(a2 + 1954);
      if (v986 != 0xFFFF) {
        goto LABEL_1443;
      }
      goto LABEL_1442;
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v976 = *v774;
    if (v976 == 0xFFFF)
    {
      uint64_t v977 = *(__int16 *)(a2 + 1998);
      uint64_t v976 = *(unsigned __int16 *)(a2 + 1998);
      *uint64_t v774 = v977;
      *(_WORD *)(a2 + 4 * v977 + 262) = v773 + 272;
      __int16 v978 = v977 + 11;
      if (((v773 + 272) & 0xFFFFFFF0) != 0x90) {
        __int16 v978 = v977 + 1;
      }
      *(_WORD *)(a2 + 1998) = v978;
    }
    *((void *)&v1145[0] + 1) = ((v976 << 48) | 0x19C840) + 64;
    *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v979 = *(unsigned __int16 *)(a2 + 1954);
    if (v979 == 0xFFFF)
    {
      uint64_t v979 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v979;
      *(_WORD *)(a2 + 2004) = v979 + 1;
    }
    *(void *)&v1145[0] = (v979 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a2 + 16) = 3;
    uint64_t v980 = *(unsigned __int16 *)(a2 + 1914);
    if (v980 == 0xFFFF)
    {
      uint64_t v980 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1914) = v980;
      *(_WORD *)(a2 + 2004) = v980 + 1;
    }
    *((void *)&v1145[0] + 1) = (v980 << 48) | 0xAA40;
    uint64_t v981 = (unsigned __int16)*(v1143 - 32);
    if (v981 == 0xFFFF)
    {
      uint64_t v982 = *(__int16 *)(a2 + 1998);
      uint64_t v981 = *(unsigned __int16 *)(a2 + 1998);
      *(v1143 - 32) = v982;
      *(_WORD *)(a2 + 4 * v982 + 262) = 2 * v773 + 241;
      __int16 v983 = v982 + 11;
      if (((v917 + 241) & 0xFFFFFFF0) != 0x90) {
        __int16 v983 = v982 + 1;
      }
      *(_WORD *)(a2 + 1998) = v983;
    }
    uint64_t v959 = ((v981 << 48) | 0x19C840) + 64;
LABEL_1439:
    *(void *)&v1145[1] = v959;
    uint64_t v984 = *(unsigned __int16 *)(a2 + 1954);
    if (v984 == 0xFFFF)
    {
      uint64_t v986 = *(unsigned __int16 *)(a2 + 2004);
      int v987 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v986;
      *(_WORD *)(a2 + 2004) = ++v987;
      *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v986 << 48) | 0x19C840;
      if ((v987 & 0x10000) == 0)
      {
LABEL_1443:
        uint64_t v985 = v986 << 48;
        goto LABEL_1444;
      }
LABEL_1442:
      uint64_t v986 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v986;
      *(_WORD *)(a2 + 2004) = v986 + 1;
      goto LABEL_1443;
    }
    uint64_t v985 = v984 << 48;
    *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v984 << 48) | 0x19C840;
LABEL_1444:
    *(void *)&v1145[0] = v985 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_1445:
    if ((*a1 & 0x8000000000000000) == 0)
    {
      if (v1124 >= 8)
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v998 = v774[32];
        if (v998 == 0xFFFF)
        {
          uint64_t v999 = *(__int16 *)(a2 + 1998);
          uint64_t v998 = *(unsigned __int16 *)(a2 + 1998);
          v774[32] = v999;
          *(_WORD *)(a2 + 4 * v999 + 262) = v773 + 288;
          __int16 v1000 = v999 + 11;
          if (((v773 + 288) & 0xFFFFFFF0) != 0x90) {
            __int16 v1000 = v999 + 1;
          }
          *(_WORD *)(a2 + 1998) = v1000;
        }
        *((void *)&v1145[0] + 1) = ((v998 << 48) | 0x19C840) + 64;
        *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
        uint64_t v1001 = *(unsigned __int16 *)(a2 + 1962);
        if (v1001 == 0xFFFF)
        {
          uint64_t v1001 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1962) = v1001;
          *(_WORD *)(a2 + 2004) = v1001 + 1;
        }
        *(void *)&v1145[0] = (v1001 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v1002 = *(unsigned __int16 *)(a2 + 1912);
        if (v1002 == 0xFFFF)
        {
          uint64_t v1002 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1912) = v1002;
          *(_WORD *)(a2 + 2004) = v1002 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1002 << 48) | 0x15440;
        uint64_t v1003 = *(unsigned __int16 *)(a2 + 1962);
        if (v1003 == 0xFFFF)
        {
          uint64_t v1003 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1962) = v1003;
          *(_WORD *)(a2 + 2004) = v1003 + 1;
        }
        uint64_t v992 = (v1003 << 48) | 0x19C840;
      }
      else
      {
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
        *(_DWORD *)(a2 + 16) = 3;
        uint64_t v988 = *(unsigned __int16 *)(a2 + 1912);
        if (v988 == 0xFFFF)
        {
          uint64_t v988 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1912) = v988;
          *(_WORD *)(a2 + 2004) = v988 + 1;
        }
        *((void *)&v1145[0] + 1) = (v988 << 48) | 0x15440;
        uint64_t v989 = (unsigned __int16)*(v1143 - 2);
        if (v989 == 0xFFFF)
        {
          uint64_t v990 = *(__int16 *)(a2 + 1998);
          uint64_t v989 = *(unsigned __int16 *)(a2 + 1998);
          *(v1143 - 2) = v990;
          *(_WORD *)(a2 + 4 * v990 + 262) = 2 * v773 + 256;
          __int16 v991 = v990 + 11;
          if (((v917 + 256) & 0xFFFFFFF0) != 0x90) {
            __int16 v991 = v990 + 1;
          }
          *(_WORD *)(a2 + 1998) = v991;
        }
        uint64_t v992 = ((v989 << 48) | 0x19C840) + 64;
      }
      *(void *)&v1145[1] = v992;
      uint64_t v1004 = *(unsigned __int16 *)(a2 + 1946);
      if (v1004 != 0xFFFF)
      {
        uint64_t v1005 = v1004 << 48;
        *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1004 << 48) | 0x19C840;
        goto LABEL_1494;
      }
      uint64_t v997 = *(unsigned __int16 *)(a2 + 2004);
      int v1012 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v997;
      *(_WORD *)(a2 + 2004) = ++v1012;
      *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v997 << 48) | 0x19C840;
      if ((v1012 & 0x10000) == 0) {
        goto LABEL_1493;
      }
      uint64_t v997 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1946) = v997;
      goto LABEL_1492;
    }
    memset((char *)&v1145[1] + 8, 0, 48);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
    *(_DWORD *)(a2 + 16) = 2;
    if (v1124 < 8)
    {
      uint64_t v993 = *(unsigned __int16 *)(a2 + 1912);
      if (v993 == 0xFFFF)
      {
        uint64_t v993 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1912) = v993;
        *(_WORD *)(a2 + 2004) = v993 + 1;
      }
      *((void *)&v1145[0] + 1) = (v993 << 48) | 0x15440;
      uint64_t v994 = (unsigned __int16)*(v1143 - 2);
      if (v994 == 0xFFFF)
      {
        uint64_t v995 = *(__int16 *)(a2 + 1998);
        uint64_t v994 = *(unsigned __int16 *)(a2 + 1998);
        *(v1143 - 2) = v995;
        *(_WORD *)(a2 + 4 * v995 + 262) = 2 * v773 + 256;
        __int16 v996 = v995 + 11;
        if (((v917 + 256) & 0xFFFFFFF0) != 0x90) {
          __int16 v996 = v995 + 1;
        }
        *(_WORD *)(a2 + 1998) = v996;
      }
      *(void *)&v1145[1] = ((v994 << 48) | 0x19C840) + 64;
      uint64_t v997 = *(unsigned __int16 *)(a2 + 1962);
      if (v997 != 0xFFFF) {
        goto LABEL_1493;
      }
LABEL_1491:
      uint64_t v997 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1962) = v997;
LABEL_1492:
      *(_WORD *)(a2 + 2004) = v997 + 1;
      goto LABEL_1493;
    }
    uint64_t v1006 = v774[32];
    if (v1006 == 0xFFFF)
    {
      uint64_t v1007 = *(__int16 *)(a2 + 1998);
      uint64_t v1006 = *(unsigned __int16 *)(a2 + 1998);
      v774[32] = v1007;
      *(_WORD *)(a2 + 4 * v1007 + 262) = v773 + 288;
      __int16 v1008 = v1007 + 11;
      if (((v773 + 288) & 0xFFFFFFF0) != 0x90) {
        __int16 v1008 = v1007 + 1;
      }
      *(_WORD *)(a2 + 1998) = v1008;
    }
    *((void *)&v1145[0] + 1) = ((v1006 << 48) | 0x19C840) + 64;
    *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v1009 = *(unsigned __int16 *)(a2 + 1962);
    if (v1009 == 0xFFFF)
    {
      uint64_t v1009 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1962) = v1009;
      *(_WORD *)(a2 + 2004) = v1009 + 1;
    }
    *(void *)&v1145[0] = (v1009 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset(v1145, 0, 72);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v1010 = *(unsigned __int16 *)(a2 + 1912);
    if (v1010 == 0xFFFF)
    {
      uint64_t v1010 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1912) = v1010;
      *(_WORD *)(a2 + 2004) = v1010 + 1;
    }
    *((void *)&v1145[0] + 1) = (v1010 << 48) | 0x15440;
    uint64_t v1011 = *(unsigned __int16 *)(a2 + 1962);
    if (v1011 != 0xFFFF)
    {
      uint64_t v1005 = v1011 << 48;
      *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1011 << 48) | 0x19C840;
      goto LABEL_1494;
    }
    uint64_t v997 = *(unsigned __int16 *)(a2 + 2004);
    int v1014 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1962) = v997;
    *(_WORD *)(a2 + 2004) = ++v1014;
    *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v997 << 48) | 0x19C840;
    if ((v1014 & 0x10000) != 0) {
      goto LABEL_1491;
    }
LABEL_1493:
    uint64_t v1005 = v997 << 48;
LABEL_1494:
    *(void *)&v1145[0] = v1005 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    if ((*a1 & 0x1000000000000) == 0) {
      goto LABEL_1560;
    }
    if ((*a1 & 0x8000000000000000) != 0)
    {
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      if (v1121 >= 8)
      {
        uint64_t v1033 = v774[32];
        if (v1033 == 0xFFFF)
        {
          uint64_t v1034 = *(__int16 *)(a2 + 1998);
          uint64_t v1033 = *(unsigned __int16 *)(a2 + 1998);
          v774[32] = v1034;
          *(_WORD *)(a2 + 4 * v1034 + 262) = v773 + 288;
          __int16 v1035 = v1034 + 11;
          if (((v773 + 288) & 0xFFFFFFF0) != 0x90) {
            __int16 v1035 = v1034 + 1;
          }
          *(_WORD *)(a2 + 1998) = v1035;
        }
        *((void *)&v1145[0] + 1) = ((v1033 << 48) | 0x19C840) + 64;
        *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
        uint64_t v1036 = *(unsigned __int16 *)(a2 + 1970);
        if (v1036 == 0xFFFF)
        {
          uint64_t v1036 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v1036;
          *(_WORD *)(a2 + 2004) = v1036 + 1;
        }
        *(void *)&v1145[0] = (v1036 << 48) | 0x72679000;
        (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
        memset(v1145, 0, 72);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1037 = *(unsigned __int16 *)(a2 + 1914);
        if (v1037 == 0xFFFF)
        {
          uint64_t v1037 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1914) = v1037;
          *(_WORD *)(a2 + 2004) = v1037 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1037 << 48) | 0x15440;
        uint64_t v1038 = *(unsigned __int16 *)(a2 + 1970);
        if (v1038 != 0xFFFF)
        {
          uint64_t v1032 = v1038 << 48;
          *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1038 << 48) | 0x19C840;
          goto LABEL_1559;
        }
        uint64_t v1024 = *(unsigned __int16 *)(a2 + 2004);
        int v1047 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v1024;
        *(_WORD *)(a2 + 2004) = ++v1047;
        *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1024 << 48) | 0x19C840;
        if ((v1047 & 0x10000) == 0) {
          goto LABEL_1558;
        }
      }
      else
      {
        uint64_t v1020 = *(unsigned __int16 *)(a2 + 1914);
        if (v1020 == 0xFFFF)
        {
          uint64_t v1020 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1914) = v1020;
          *(_WORD *)(a2 + 2004) = v1020 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1020 << 48) | 0x15440;
        uint64_t v1021 = (unsigned __int16)*v1143;
        if (v1021 == 0xFFFF)
        {
          uint64_t v1022 = *(__int16 *)(a2 + 1998);
          uint64_t v1021 = *(unsigned __int16 *)(a2 + 1998);
          _WORD *v1143 = v1022;
          *(_WORD *)(a2 + 4 * v1022 + 262) = 2 * v773 + 257;
          __int16 v1023 = v1022 + 11;
          if (((v917 + 257) & 0xFFFFFFF0) != 0x90) {
            __int16 v1023 = v1022 + 1;
          }
          *(_WORD *)(a2 + 1998) = v1023;
        }
        *(void *)&v1145[1] = ((v1021 << 48) | 0x19C840) + 64;
        uint64_t v1024 = *(unsigned __int16 *)(a2 + 1970);
        if (v1024 != 0xFFFF) {
          goto LABEL_1558;
        }
      }
      uint64_t v1024 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1970) = v1024;
      goto LABEL_1557;
    }
    if (v1121 >= 8)
    {
      memset((char *)&v1145[1] + 8, 0, 48);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v1025 = v774[32];
      if (v1025 == 0xFFFF)
      {
        uint64_t v1026 = *(__int16 *)(a2 + 1998);
        uint64_t v1025 = *(unsigned __int16 *)(a2 + 1998);
        v774[32] = v1026;
        *(_WORD *)(a2 + 4 * v1026 + 262) = v773 + 288;
        __int16 v1027 = v1026 + 11;
        if (((v773 + 288) & 0xFFFFFFF0) != 0x90) {
          __int16 v1027 = v1026 + 1;
        }
        *(_WORD *)(a2 + 1998) = v1027;
      }
      *((void *)&v1145[0] + 1) = ((v1025 << 48) | 0x19C840) + 64;
      *(void *)&v1145[1] = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
      uint64_t v1028 = *(unsigned __int16 *)(a2 + 1970);
      if (v1028 == 0xFFFF)
      {
        uint64_t v1028 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v1028;
        *(_WORD *)(a2 + 2004) = v1028 + 1;
      }
      *(void *)&v1145[0] = (v1028 << 48) | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v1029 = *(unsigned __int16 *)(a2 + 1914);
      if (v1029 == 0xFFFF)
      {
        uint64_t v1029 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v1029;
        *(_WORD *)(a2 + 2004) = v1029 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1029 << 48) | 0x15440;
      uint64_t v1030 = *(unsigned __int16 *)(a2 + 1970);
      if (v1030 == 0xFFFF)
      {
        uint64_t v1030 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v1030;
        *(_WORD *)(a2 + 2004) = v1030 + 1;
      }
      uint64_t v1019 = (v1030 << 48) | 0x19C840;
    }
    else
    {
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v1015 = *(unsigned __int16 *)(a2 + 1914);
      if (v1015 == 0xFFFF)
      {
        uint64_t v1015 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1914) = v1015;
        *(_WORD *)(a2 + 2004) = v1015 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1015 << 48) | 0x15440;
      uint64_t v1016 = (unsigned __int16)*v1143;
      if (v1016 == 0xFFFF)
      {
        uint64_t v1017 = *(__int16 *)(a2 + 1998);
        uint64_t v1016 = *(unsigned __int16 *)(a2 + 1998);
        _WORD *v1143 = v1017;
        *(_WORD *)(a2 + 4 * v1017 + 262) = 2 * v773 + 257;
        __int16 v1018 = v1017 + 11;
        if (((v917 + 257) & 0xFFFFFFF0) != 0x90) {
          __int16 v1018 = v1017 + 1;
        }
        *(_WORD *)(a2 + 1998) = v1018;
      }
      uint64_t v1019 = ((v1016 << 48) | 0x19C840) + 64;
    }
    *(void *)&v1145[1] = v1019;
    uint64_t v1031 = *(unsigned __int16 *)(a2 + 1954);
    if (v1031 == 0xFFFF)
    {
      uint64_t v1024 = *(unsigned __int16 *)(a2 + 2004);
      int v1039 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1954) = v1024;
      *(_WORD *)(a2 + 2004) = ++v1039;
      *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1024 << 48) | 0x19C840;
      if ((v1039 & 0x10000) != 0)
      {
        uint64_t v1024 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v1024;
LABEL_1557:
        *(_WORD *)(a2 + 2004) = v1024 + 1;
      }
LABEL_1558:
      uint64_t v1032 = v1024 << 48;
      goto LABEL_1559;
    }
    uint64_t v1032 = v1031 << 48;
    *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1031 << 48) | 0x19C840;
LABEL_1559:
    *(void *)&v1145[0] = v1032 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_1560:
    memset(v1145, 0, 72);
    uint64_t v1048 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    if ((v1139 | v1137))
    {
      uint64_t v1144 = v1048 | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v1049 = *(unsigned __int16 *)(a2 + 1940);
      if (v1049 == 0xFFFF)
      {
        uint64_t v1049 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v1049;
        *(_WORD *)(a2 + 2004) = v1049 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1049 << 48) | 0x19C840;
      uint64_t v1050 = *(unsigned __int16 *)(a2 + 1946);
      if (v1050 == 0xFFFF)
      {
        uint64_t v1050 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v1050;
        *(_WORD *)(a2 + 2004) = v1050 + 1;
      }
      *(void *)&v1145[1] = (v1050 << 48) | 0x19C840;
      uint64_t v1051 = *(unsigned __int16 *)(a2 + 1904);
      if (v1051 == 0xFFFF)
      {
        uint64_t v1056 = *(unsigned __int16 *)(a2 + 2004);
        int v1057 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1904) = v1056;
        *(_WORD *)(a2 + 2004) = ++v1057;
        *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1056 << 48) | 0x19C840;
        if ((v1057 & 0x10000) != 0)
        {
          uint64_t v1056 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1904) = v1056;
          *(_WORD *)(a2 + 2004) = v1056 + 1;
        }
        uint64_t v1052 = v1056 << 48;
      }
      else
      {
        uint64_t v1052 = v1051 << 48;
        *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1051 << 48) | 0x19C840;
      }
      *(void *)&v1145[0] = v1052 | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x8000000000000000) != 0)
      {
        if (v1135)
        {
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
          *(_DWORD *)(a2 + 16) = 3;
          uint64_t v1058 = *(unsigned __int16 *)(a2 + 1940);
          if (v1058 == 0xFFFF)
          {
            uint64_t v1058 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1940) = v1058;
            *(_WORD *)(a2 + 2004) = v1058 + 1;
          }
          *((void *)&v1145[0] + 1) = (v1058 << 48) | 0x19C840;
          uint64_t v1059 = *(unsigned __int16 *)(a2 + 1962);
          if (v1059 == 0xFFFF)
          {
            uint64_t v1059 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1962) = v1059;
            *(_WORD *)(a2 + 2004) = v1059 + 1;
          }
          *(void *)&v1145[1] = (v1059 << 48) | 0x19C840;
          uint64_t v1060 = *(unsigned __int16 *)(a2 + 1908);
          if (v1060 != 0xFFFF)
          {
            uint64_t v1061 = v1060 << 48;
            *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1060 << 48) | 0x19C840;
LABEL_1602:
            *(void *)&v1145[0] = v1061 | 0x72679000;
            (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
            goto LABEL_1603;
          }
          uint64_t v1069 = *(unsigned __int16 *)(a2 + 2004);
          int v1088 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1908) = v1069;
          *(_WORD *)(a2 + 2004) = ++v1088;
          *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1069 << 48) | 0x19C840;
          if ((v1088 & 0x10000) == 0) {
            goto LABEL_1601;
          }
          goto LABEL_1600;
        }
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1066 = *(unsigned __int16 *)(a2 + 1940);
        if (v1066 == 0xFFFF)
        {
          uint64_t v1066 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v1066;
          *(_WORD *)(a2 + 2004) = v1066 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1066 << 48) | 0x19C840;
        uint64_t v1067 = *(unsigned __int16 *)(a2 + 1962);
        if (v1067 == 0xFFFF)
        {
          uint64_t v1067 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1962) = v1067;
          *(_WORD *)(a2 + 2004) = v1067 + 1;
        }
        *(void *)&v1145[1] = (v1067 << 48) | 0x19C840;
        goto LABEL_1599;
      }
    }
    else
    {
      uint64_t v1144 = v1048 | 0x31000007C2;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v1053 = *(unsigned __int16 *)(a2 + 1946);
      if (v1053 == 0xFFFF)
      {
        uint64_t v1053 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1946) = v1053;
        *(_WORD *)(a2 + 2004) = v1053 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1053 << 48) | 0x19C840;
      uint64_t v1054 = *(unsigned __int16 *)(a2 + 1904);
      if (v1054 == 0xFFFF)
      {
        uint64_t v1062 = *(unsigned __int16 *)(a2 + 2004);
        int v1063 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1904) = v1062;
        *(_WORD *)(a2 + 2004) = ++v1063;
        *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1062 << 48) | 0x19C840;
        if ((v1063 & 0x10000) != 0)
        {
          uint64_t v1062 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1904) = v1062;
          *(_WORD *)(a2 + 2004) = v1062 + 1;
        }
        uint64_t v1055 = v1062 << 48;
      }
      else
      {
        uint64_t v1055 = v1054 << 48;
        *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1054 << 48) | 0x19C840;
      }
      *(void *)&v1145[0] = v1055 | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x8000000000000000) != 0)
      {
        if (v1135)
        {
          memset(v1145, 0, 72);
          uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
          *(_DWORD *)(a2 + 16) = 2;
          uint64_t v1064 = *(unsigned __int16 *)(a2 + 1962);
          if (v1064 == 0xFFFF)
          {
            uint64_t v1064 = *(unsigned __int16 *)(a2 + 2004);
            *(_WORD *)(a2 + 1962) = v1064;
            *(_WORD *)(a2 + 2004) = v1064 + 1;
          }
          *((void *)&v1145[0] + 1) = (v1064 << 48) | 0x19C840;
          uint64_t v1065 = *(unsigned __int16 *)(a2 + 1908);
          if (v1065 != 0xFFFF)
          {
            uint64_t v1061 = v1065 << 48;
            *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1065 << 48) | 0x19C840;
            goto LABEL_1602;
          }
          uint64_t v1069 = *(unsigned __int16 *)(a2 + 2004);
          int v1089 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1908) = v1069;
          *(_WORD *)(a2 + 2004) = ++v1089;
          *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1069 << 48) | 0x19C840;
          if ((v1089 & 0x10000) == 0)
          {
LABEL_1601:
            uint64_t v1061 = v1069 << 48;
            goto LABEL_1602;
          }
LABEL_1600:
          uint64_t v1069 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1908) = v1069;
          *(_WORD *)(a2 + 2004) = v1069 + 1;
          goto LABEL_1601;
        }
        memset(&v1145[1], 0, 56);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v1068 = *(unsigned __int16 *)(a2 + 1962);
        if (v1068 == 0xFFFF)
        {
          uint64_t v1068 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1962) = v1068;
          *(_WORD *)(a2 + 2004) = v1068 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1068 << 48) | 0x19C840;
LABEL_1599:
        uint64_t v1069 = *(unsigned __int16 *)(a2 + 1908);
        if (v1069 != 0xFFFF) {
          goto LABEL_1601;
        }
        goto LABEL_1600;
      }
    }
LABEL_1603:
    v775 = v1143;
    if ((*a1 & 0x1000000000000) == 0)
    {
      int v1135 = 1;
      uint64_t v772 = v1141;
      goto LABEL_1653;
    }
    memset(v1145, 0, 72);
    uint64_t v1070 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    if ((v1139 | v1137))
    {
      uint64_t v1144 = v1070 | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v1071 = *(unsigned __int16 *)(a2 + 1940);
      if (v1071 == 0xFFFF)
      {
        uint64_t v1071 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v1071;
        *(_WORD *)(a2 + 2004) = v1071 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1071 << 48) | 0x19C840;
      uint64_t v1072 = *(unsigned __int16 *)(a2 + 1954);
      uint64_t v772 = v1141;
      if (v1072 == 0xFFFF)
      {
        uint64_t v1072 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v1072;
        *(_WORD *)(a2 + 2004) = v1072 + 1;
      }
      *(void *)&v1145[1] = (v1072 << 48) | 0x19C840;
      uint64_t v1073 = *(unsigned __int16 *)(a2 + 1906);
      if (v1073 == 0xFFFF)
      {
        uint64_t v1078 = *(unsigned __int16 *)(a2 + 2004);
        int v1079 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1906) = v1078;
        *(_WORD *)(a2 + 2004) = ++v1079;
        *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1078 << 48) | 0x19C840;
        if ((v1079 & 0x10000) != 0)
        {
          uint64_t v1078 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1906) = v1078;
          *(_WORD *)(a2 + 2004) = v1078 + 1;
        }
        uint64_t v1074 = v1078 << 48;
      }
      else
      {
        uint64_t v1074 = v1073 << 48;
        *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1073 << 48) | 0x19C840;
      }
      *(void *)&v1145[0] = v1074 | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x8000000000000000) == 0) {
        goto LABEL_1652;
      }
      if (!v1135)
      {
        memset((char *)&v1145[1] + 8, 0, 48);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000882;
        *(_DWORD *)(a2 + 16) = 2;
        uint64_t v1090 = *(unsigned __int16 *)(a2 + 1940);
        if (v1090 == 0xFFFF)
        {
          uint64_t v1090 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1940) = v1090;
          *(_WORD *)(a2 + 2004) = v1090 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1090 << 48) | 0x19C840;
        uint64_t v1091 = *(unsigned __int16 *)(a2 + 1970);
        if (v1091 == 0xFFFF)
        {
          uint64_t v1091 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v1091;
          *(_WORD *)(a2 + 2004) = v1091 + 1;
        }
        *(void *)&v1145[1] = (v1091 << 48) | 0x19C840;
        goto LABEL_1648;
      }
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000FC3;
      *(_DWORD *)(a2 + 16) = 3;
      uint64_t v1080 = *(unsigned __int16 *)(a2 + 1940);
      if (v1080 == 0xFFFF)
      {
        uint64_t v1080 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1940) = v1080;
        *(_WORD *)(a2 + 2004) = v1080 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1080 << 48) | 0x19C840;
      uint64_t v1081 = *(unsigned __int16 *)(a2 + 1970);
      if (v1081 == 0xFFFF)
      {
        uint64_t v1081 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v1081;
        *(_WORD *)(a2 + 2004) = v1081 + 1;
      }
      *(void *)&v1145[1] = (v1081 << 48) | 0x19C840;
      uint64_t v1082 = *(unsigned __int16 *)(a2 + 1910);
      if (v1082 == 0xFFFF)
      {
        uint64_t v1093 = *(unsigned __int16 *)(a2 + 2004);
        int v1095 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1910) = v1093;
        *(_WORD *)(a2 + 2004) = ++v1095;
        *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1093 << 48) | 0x19C840;
        if ((v1095 & 0x10000) == 0) {
          goto LABEL_1650;
        }
LABEL_1649:
        uint64_t v1093 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1910) = v1093;
        *(_WORD *)(a2 + 2004) = v1093 + 1;
LABEL_1650:
        uint64_t v1083 = v1093 << 48;
        goto LABEL_1651;
      }
      uint64_t v1083 = v1082 << 48;
      *((void *)&v1145[1] + 1) = ((unint64_t)(unsigned __int16)v1082 << 48) | 0x19C840;
    }
    else
    {
      uint64_t v1144 = v1070 | 0x31000007C2;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v1075 = *(unsigned __int16 *)(a2 + 1954);
      if (v1075 == 0xFFFF)
      {
        uint64_t v1075 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1954) = v1075;
        *(_WORD *)(a2 + 2004) = v1075 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1075 << 48) | 0x19C840;
      uint64_t v1076 = *(unsigned __int16 *)(a2 + 1906);
      uint64_t v772 = v1141;
      if (v1076 == 0xFFFF)
      {
        uint64_t v1084 = *(unsigned __int16 *)(a2 + 2004);
        int v1085 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1906) = v1084;
        *(_WORD *)(a2 + 2004) = ++v1085;
        *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1084 << 48) | 0x19C840;
        if ((v1085 & 0x10000) != 0)
        {
          uint64_t v1084 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1906) = v1084;
          *(_WORD *)(a2 + 2004) = v1084 + 1;
        }
        uint64_t v1077 = v1084 << 48;
      }
      else
      {
        uint64_t v1077 = v1076 << 48;
        *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1076 << 48) | 0x19C840;
      }
      *(void *)&v1145[0] = v1077 | 0x72679000;
      (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
      if ((*a1 & 0x8000000000000000) == 0) {
        goto LABEL_1652;
      }
      if (!v1135)
      {
        memset(&v1145[1], 0, 56);
        uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v1092 = *(unsigned __int16 *)(a2 + 1970);
        if (v1092 == 0xFFFF)
        {
          uint64_t v1092 = *(unsigned __int16 *)(a2 + 2004);
          *(_WORD *)(a2 + 1970) = v1092;
          *(_WORD *)(a2 + 2004) = v1092 + 1;
        }
        *((void *)&v1145[0] + 1) = (v1092 << 48) | 0x19C840;
LABEL_1648:
        uint64_t v1093 = *(unsigned __int16 *)(a2 + 1910);
        if (v1093 == 0xFFFF) {
          goto LABEL_1649;
        }
        goto LABEL_1650;
      }
      memset(v1145, 0, 72);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x31000007C2;
      *(_DWORD *)(a2 + 16) = 2;
      uint64_t v1086 = *(unsigned __int16 *)(a2 + 1970);
      if (v1086 == 0xFFFF)
      {
        uint64_t v1086 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1970) = v1086;
        *(_WORD *)(a2 + 2004) = v1086 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1086 << 48) | 0x19C840;
      uint64_t v1087 = *(unsigned __int16 *)(a2 + 1910);
      if (v1087 == 0xFFFF)
      {
        uint64_t v1093 = *(unsigned __int16 *)(a2 + 2004);
        int v1096 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1910) = v1093;
        *(_WORD *)(a2 + 2004) = ++v1096;
        *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1093 << 48) | 0x19C840;
        if ((v1096 & 0x10000) == 0) {
          goto LABEL_1650;
        }
        goto LABEL_1649;
      }
      uint64_t v1083 = v1087 << 48;
      *(void *)&v1145[1] = ((unint64_t)(unsigned __int16)v1087 << 48) | 0x19C840;
    }
LABEL_1651:
    *(void *)&v1145[0] = v1083 | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
LABEL_1652:
    int v1135 = 1;
    v775 = v1143;
LABEL_1653:
    ++v773;
    v772 += 2;
    v774 += 2;
    v775 += 4;
    BOOL v1094 = v50 > 1;
    v50 >>= 1;
  }
  while (v1094);
  if (!v1135) {
    goto LABEL_1660;
  }
LABEL_1665:
  memset(&v1145[1], 0, 56);
  uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
  *(_DWORD *)(a2 + 16) = 1;
  if ((v1124 & 4) != 0)
  {
    *((void *)&v1145[0] + 1) = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
    uint64_t v1102 = *(unsigned __int16 *)(a2 + 1904);
  }
  else
  {
    uint64_t v1100 = *(unsigned __int16 *)(a2 + 1636);
    if (v1100 == 0xFFFF)
    {
      uint64_t v1101 = *(__int16 *)(a2 + 1998);
      uint64_t v1100 = *(unsigned __int16 *)(a2 + 1998);
      *(_WORD *)(a2 + 1636) = v1101;
      *(_WORD *)(a2 + 4 * v1101 + 262) = 344;
      *(_WORD *)(a2 + 1998) = v1101 + 1;
    }
    *((void *)&v1145[0] + 1) = ((v1100 << 48) | 0x19C840) + 64;
    uint64_t v1102 = *(unsigned __int16 *)(a2 + 1904);
  }
  if (v1102 == 0xFFFF)
  {
    uint64_t v1102 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1904) = v1102;
    *(_WORD *)(a2 + 2004) = v1102 + 1;
  }
  *(void *)&v1145[0] = (v1102 << 48) | 0x72609000;
  (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  memset(&v1145[1], 0, 56);
  uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
  *(_DWORD *)(a2 + 16) = 1;
  uint64_t v1103 = *(unsigned __int16 *)(a2 + 1904);
  if (v1103 == 0xFFFF)
  {
    uint64_t v1103 = *(unsigned __int16 *)(a2 + 2004);
    *(_WORD *)(a2 + 1904) = v1103;
    *(_WORD *)(a2 + 2004) = v1103 + 1;
  }
  *((void *)&v1145[0] + 1) = (v1103 << 48) | 0x19C840;
  uint64_t v1104 = *(unsigned __int16 *)(a2 + 1704);
  if (v1104 == 0xFFFF)
  {
    uint64_t v1105 = *(__int16 *)(a2 + 2000);
    uint64_t v1104 = *(unsigned __int16 *)(a2 + 2000);
    *(_WORD *)(a2 + 1704) = v1105;
    *(_WORD *)(a2 + 4 * v1105 + 1694) = 3;
    *(_WORD *)(a2 + 2000) = v1105 + 1;
  }
  *(void *)&v1145[0] = ((v1104 << 48) | 0x72679000) + 0x2000;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
  unint64_t v1107 = *a1;
  if ((*a1 & 0x8000000000000000) != 0)
  {
    memset(&v1145[1], 0, 56);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v1108 = *(unsigned __int16 *)(a2 + 1908);
    if (v1108 == 0xFFFF)
    {
      uint64_t v1108 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1908) = v1108;
      *(_WORD *)(a2 + 2004) = v1108 + 1;
    }
    *((void *)&v1145[0] + 1) = (v1108 << 48) | 0x19C840;
    uint64_t v1109 = *(unsigned __int16 *)(a2 + 1712);
    if (v1109 == 0xFFFF)
    {
      uint64_t v1110 = *(__int16 *)(a2 + 2000);
      uint64_t v1109 = *(unsigned __int16 *)(a2 + 2000);
      *(_WORD *)(a2 + 1712) = v1110;
      *(_WORD *)(a2 + 4 * v1110 + 1694) = 5;
      *(_WORD *)(a2 + 2000) = v1110 + 1;
    }
    *(void *)&v1145[0] = ((v1109 << 48) | 0x72679000) + 0x2000;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    unint64_t v1107 = *a1;
  }
  if ((v1107 & 0x1000000000000) != 0)
  {
    memset(&v1145[1], 0, 56);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    if ((v1121 & 4) != 0)
    {
      *((void *)&v1145[0] + 1) = (gleVStateProgram_GetAttrib(a2, 2) << 48) | 0x19C800;
      uint64_t v1113 = *(unsigned __int16 *)(a2 + 1906);
    }
    else
    {
      uint64_t v1111 = *(unsigned __int16 *)(a2 + 1640);
      if (v1111 == 0xFFFF)
      {
        uint64_t v1112 = *(__int16 *)(a2 + 1998);
        uint64_t v1111 = *(unsigned __int16 *)(a2 + 1998);
        *(_WORD *)(a2 + 1640) = v1112;
        *(_WORD *)(a2 + 4 * v1112 + 262) = 345;
        *(_WORD *)(a2 + 1998) = v1112 + 1;
      }
      *((void *)&v1145[0] + 1) = ((v1111 << 48) | 0x19C840) + 64;
      uint64_t v1113 = *(unsigned __int16 *)(a2 + 1906);
    }
    if (v1113 == 0xFFFF)
    {
      uint64_t v1113 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1906) = v1113;
      *(_WORD *)(a2 + 2004) = v1113 + 1;
    }
    *(void *)&v1145[0] = (v1113 << 48) | 0x72609000;
    (*(void (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    memset(&v1145[1], 0, 56);
    uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v1114 = *(unsigned __int16 *)(a2 + 1906);
    if (v1114 == 0xFFFF)
    {
      uint64_t v1114 = *(unsigned __int16 *)(a2 + 2004);
      *(_WORD *)(a2 + 1906) = v1114;
      *(_WORD *)(a2 + 2004) = v1114 + 1;
    }
    *((void *)&v1145[0] + 1) = (v1114 << 48) | 0x19C840;
    uint64_t v1115 = *(unsigned __int16 *)(a2 + 1708);
    if (v1115 == 0xFFFF)
    {
      uint64_t v1116 = *(__int16 *)(a2 + 2000);
      uint64_t v1115 = *(unsigned __int16 *)(a2 + 2000);
      *(_WORD *)(a2 + 1708) = v1116;
      *(_WORD *)(a2 + 4 * v1116 + 1694) = 4;
      *(_WORD *)(a2 + 2000) = v1116 + 1;
    }
    *(void *)&v1145[0] = ((v1115 << 48) | 0x72679000) + 0x2000;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    if ((*a1 & 0x8000000000000000) != 0)
    {
      memset(&v1145[1], 0, 56);
      uint64_t v1144 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x3100000001;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v1117 = *(unsigned __int16 *)(a2 + 1910);
      if (v1117 == 0xFFFF)
      {
        uint64_t v1117 = *(unsigned __int16 *)(a2 + 2004);
        *(_WORD *)(a2 + 1910) = v1117;
        *(_WORD *)(a2 + 2004) = v1117 + 1;
      }
      *((void *)&v1145[0] + 1) = (v1117 << 48) | 0x19C840;
      uint64_t v1118 = *(unsigned __int16 *)(a2 + 1716);
      if (v1118 == 0xFFFF)
      {
        uint64_t v1119 = *(__int16 *)(a2 + 2000);
        uint64_t v1118 = *(unsigned __int16 *)(a2 + 2000);
        *(_WORD *)(a2 + 1716) = v1119;
        *(_WORD *)(a2 + 4 * v1119 + 1694) = 6;
        *(_WORD *)(a2 + 2000) = v1119 + 1;
      }
      *(void *)&v1145[0] = ((v1118 << 48) | 0x72679000) + 0x2000;
      return (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 2016))(a2, &v1144);
    }
  }
  return result;
}

uint64_t gleVStateProgram_MultMatrix4x4(uint64_t a1, signed int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  uint64_t v142 = 0;
  long long v141 = 0u;
  long long v140 = 0u;
  long long v139 = 0u;
  long long v138 = 0u;
  uint64_t v16 = 8 * (*(_DWORD *)(a1 + 16) & 7);
  if (a9)
  {
    uint64_t v137 = v16 | 0x3100000A42;
    *(_DWORD *)(a1 + 16) = 2;
    if (a6)
    {
      uint64_t Attrib = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
      uint64_t v18 = 1689600;
    }
    else
    {
      uint64_t v21 = a1 + 2 * a2;
      LODWORD(Attrib) = *(unsigned __int16 *)(v21 + 1900);
      if (Attrib == 0xFFFF)
      {
        LODWORD(Attrib) = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v21 + 1900) = Attrib;
        *(_WORD *)(a1 + 2004) = Attrib + 1;
      }
      uint64_t Attrib = Attrib;
      uint64_t v18 = 1689664;
    }
    *((void *)&v138 + 1) = v18 | (Attrib << 48);
    int v22 = a3 + 7;
    uint64_t v23 = (_WORD *)(a1 + 4 * (a3 + 7) + 260);
    uint64_t v24 = (unsigned __int16)*v23;
    if (a7)
    {
      if (v24 == 0xFFFF)
      {
        uint64_t v25 = *(__int16 *)(a1 + 1998);
        uint64_t v24 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v23 = v25;
        *(_WORD *)(a1 + 4 * v25 + 262) = v22;
        BOOL v26 = (v22 & 0xFFFFFFF0) == 144;
        __int16 v27 = v25 + 11;
        if (!v26) {
          __int16 v27 = v25 + 1;
        }
        *(_WORD *)(a1 + 1998) = v27;
      }
      uint64_t v28 = ((v24 << 48) | 0x19C840) + 65;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v24 == 0xFFFF)
      {
        uint64_t v29 = *(__int16 *)(a1 + 1998);
        uint64_t v24 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v23 = v29;
        *(_WORD *)(a1 + 4 * v29 + 262) = v22;
        BOOL v26 = (v22 & 0xFFFFFFF0) == 144;
        __int16 v30 = v29 + 11;
        if (!v26) {
          __int16 v30 = v29 + 1;
        }
        *(_WORD *)(a1 + 1998) = v30;
      }
      uint64_t v28 = ((v24 << 48) | 0x19C840) + 64;
    }
    *(void *)&long long v139 = v28;
    if (a8)
    {
      uint64_t v31 = a1 + 4 * a4;
      uint64_t v32 = *(unsigned __int16 *)(v31 + 1692);
      uint64_t v33 = 1918939136;
      if (v32 == 0xFFFF)
      {
        uint64_t v34 = *(__int16 *)(a1 + 2000);
        uint64_t v32 = *(unsigned __int16 *)(a1 + 2000);
        *(_WORD *)(v31 + 1692) = v34;
        *(_WORD *)(a1 + 4 * v34 + 1694) = a4;
        *(_WORD *)(a1 + 2000) = v34 + 1;
      }
    }
    else
    {
      uint64_t v35 = a1 + 2 * a4;
      uint64_t v32 = *(unsigned __int16 *)(v35 + 1900);
      uint64_t v33 = 1918930944;
      if (v32 == 0xFFFF)
      {
        uint64_t v32 = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v35 + 1900) = v32;
        *(_WORD *)(a1 + 2004) = v32 + 1;
      }
    }
    *(void *)&long long v138 = v33 | (v32 << 48);
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
    uint64_t v142 = 0;
    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    uint64_t v137 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a1 + 16) = 2;
    if (a6)
    {
      uint64_t v36 = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
      uint64_t v37 = 1689600;
    }
    else
    {
      uint64_t v38 = a1 + 2 * a2;
      LODWORD(v36) = *(unsigned __int16 *)(v38 + 1900);
      if (v36 == 0xFFFF)
      {
        LODWORD(v36) = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v38 + 1900) = v36;
        *(_WORD *)(a1 + 2004) = v36 + 1;
      }
      uint64_t v36 = v36;
      uint64_t v37 = 1689664;
    }
    *((void *)&v138 + 1) = v37 | (v36 << 48);
    int v39 = a3 + 6;
    uint64_t v40 = (_WORD *)(a1 + 4 * (a3 + 6) + 260);
    uint64_t v41 = (unsigned __int16)*v40;
    if (a7)
    {
      if (v41 == 0xFFFF)
      {
        uint64_t v42 = *(__int16 *)(a1 + 1998);
        uint64_t v41 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v40 = v42;
        *(_WORD *)(a1 + 4 * v42 + 262) = v39;
        BOOL v26 = (v39 & 0xFFFFFFF0) == 144;
        __int16 v43 = v42 + 11;
        if (!v26) {
          __int16 v43 = v42 + 1;
        }
        *(_WORD *)(a1 + 1998) = v43;
      }
      uint64_t v44 = ((v41 << 48) | 0x19C840) + 65;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v41 == 0xFFFF)
      {
        uint64_t v45 = *(__int16 *)(a1 + 1998);
        uint64_t v41 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v40 = v45;
        *(_WORD *)(a1 + 4 * v45 + 262) = v39;
        BOOL v26 = (v39 & 0xFFFFFFF0) == 144;
        __int16 v46 = v45 + 11;
        if (!v26) {
          __int16 v46 = v45 + 1;
        }
        *(_WORD *)(a1 + 1998) = v46;
      }
      uint64_t v44 = ((v41 << 48) | 0x19C840) + 64;
    }
    *(void *)&long long v139 = v44;
    if (a8)
    {
      uint64_t v47 = a1 + 4 * a4;
      uint64_t v48 = *(unsigned __int16 *)(v47 + 1692);
      uint64_t v49 = 1918971904;
      if (v48 == 0xFFFF)
      {
        uint64_t v50 = *(__int16 *)(a1 + 2000);
        uint64_t v48 = *(unsigned __int16 *)(a1 + 2000);
        *(_WORD *)(v47 + 1692) = v50;
        *(_WORD *)(a1 + 4 * v50 + 1694) = a4;
        *(_WORD *)(a1 + 2000) = v50 + 1;
      }
    }
    else
    {
      uint64_t v51 = a1 + 2 * a4;
      uint64_t v48 = *(unsigned __int16 *)(v51 + 1900);
      uint64_t v49 = 1918963712;
      if (v48 == 0xFFFF)
      {
        uint64_t v48 = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v51 + 1900) = v48;
        *(_WORD *)(a1 + 2004) = v48 + 1;
      }
    }
    *(void *)&long long v138 = v49 | (v48 << 48);
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
    uint64_t v142 = 0;
    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    uint64_t v137 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a1 + 16) = 2;
    if (a6)
    {
      uint64_t v52 = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
      uint64_t v53 = 1689600;
    }
    else
    {
      uint64_t v54 = a1 + 2 * a2;
      LODWORD(v52) = *(unsigned __int16 *)(v54 + 1900);
      if (v52 == 0xFFFF)
      {
        LODWORD(v52) = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v54 + 1900) = v52;
        *(_WORD *)(a1 + 2004) = v52 + 1;
      }
      uint64_t v52 = v52;
      uint64_t v53 = 1689664;
    }
    *((void *)&v138 + 1) = v53 | (v52 << 48);
    int v55 = a3 + 5;
    BOOL v56 = (_WORD *)(a1 + 4 * (a3 + 5) + 260);
    uint64_t v57 = (unsigned __int16)*v56;
    if (a7)
    {
      if (v57 == 0xFFFF)
      {
        uint64_t v58 = *(__int16 *)(a1 + 1998);
        uint64_t v57 = *(unsigned __int16 *)(a1 + 1998);
        *BOOL v56 = v58;
        *(_WORD *)(a1 + 4 * v58 + 262) = v55;
        BOOL v26 = (v55 & 0xFFFFFFF0) == 144;
        __int16 v59 = v58 + 11;
        if (!v26) {
          __int16 v59 = v58 + 1;
        }
        *(_WORD *)(a1 + 1998) = v59;
      }
      uint64_t v60 = ((v57 << 48) | 0x19C840) + 65;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v57 == 0xFFFF)
      {
        uint64_t v61 = *(__int16 *)(a1 + 1998);
        uint64_t v57 = *(unsigned __int16 *)(a1 + 1998);
        *BOOL v56 = v61;
        *(_WORD *)(a1 + 4 * v61 + 262) = v55;
        BOOL v26 = (v55 & 0xFFFFFFF0) == 144;
        __int16 v62 = v61 + 11;
        if (!v26) {
          __int16 v62 = v61 + 1;
        }
        *(_WORD *)(a1 + 1998) = v62;
      }
      uint64_t v60 = ((v57 << 48) | 0x19C840) + 64;
    }
    *(void *)&long long v139 = v60;
    if (a8)
    {
      uint64_t v63 = a1 + 4 * a4;
      uint64_t v64 = *(unsigned __int16 *)(v63 + 1692);
      uint64_t v65 = 1919037440;
      if (v64 == 0xFFFF)
      {
        uint64_t v66 = *(__int16 *)(a1 + 2000);
        uint64_t v64 = *(unsigned __int16 *)(a1 + 2000);
        *(_WORD *)(v63 + 1692) = v66;
        *(_WORD *)(a1 + 4 * v66 + 1694) = a4;
        *(_WORD *)(a1 + 2000) = v66 + 1;
      }
    }
    else
    {
      uint64_t v67 = a1 + 2 * a4;
      uint64_t v64 = *(unsigned __int16 *)(v67 + 1900);
      uint64_t v65 = 1919029248;
      if (v64 == 0xFFFF)
      {
        uint64_t v64 = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v67 + 1900) = v64;
        *(_WORD *)(a1 + 2004) = v64 + 1;
      }
    }
    *(void *)&long long v138 = v65 | (v64 << 48);
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
    uint64_t v142 = 0;
    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    uint64_t v137 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000A42;
    *(_DWORD *)(a1 + 16) = 2;
    if (a6)
    {
      uint64_t v68 = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
      uint64_t v69 = 1689600;
    }
    else
    {
      uint64_t v70 = a1 + 2 * a2;
      LODWORD(v68) = *(unsigned __int16 *)(v70 + 1900);
      if (v68 == 0xFFFF)
      {
        LODWORD(v68) = *(unsigned __int16 *)(a1 + 2004);
        *(_WORD *)(v70 + 1900) = v68;
        *(_WORD *)(a1 + 2004) = v68 + 1;
      }
      uint64_t v68 = v68;
      uint64_t v69 = 1689664;
    }
    *((void *)&v138 + 1) = v69 | (v68 << 48);
    int v71 = a3 + 4;
    uint64_t v72 = (_WORD *)(a1 + 4 * (a3 + 4) + 260);
    uint64_t v73 = (unsigned __int16)*v72;
    if (a7)
    {
      if (v73 == 0xFFFF)
      {
        uint64_t v74 = *(__int16 *)(a1 + 1998);
        uint64_t v73 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v72 = v74;
        *(_WORD *)(a1 + 4 * v74 + 262) = v71;
        BOOL v26 = (v71 & 0xFFFFFFF0) == 144;
        __int16 v75 = v74 + 11;
        if (!v26) {
          __int16 v75 = v74 + 1;
        }
        *(_WORD *)(a1 + 1998) = v75;
      }
      uint64_t v76 = ((v73 << 48) | 0x19C840) + 65;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v73 == 0xFFFF)
      {
        uint64_t v77 = *(__int16 *)(a1 + 1998);
        uint64_t v73 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v72 = v77;
        *(_WORD *)(a1 + 4 * v77 + 262) = v71;
        BOOL v26 = (v71 & 0xFFFFFFF0) == 144;
        __int16 v78 = v77 + 11;
        if (!v26) {
          __int16 v78 = v77 + 1;
        }
        *(_WORD *)(a1 + 1998) = v78;
      }
      uint64_t v76 = ((v73 << 48) | 0x19C840) + 64;
    }
    *(void *)&long long v139 = v76;
    if (a8)
    {
      uint64_t v79 = a1 + 4 * a4;
      uint64_t v80 = *(unsigned __int16 *)(v79 + 1692);
      uint64_t v81 = 1919168512;
      if (v80 == 0xFFFF)
      {
        uint64_t v82 = *(__int16 *)(a1 + 2000);
        uint64_t v80 = *(unsigned __int16 *)(a1 + 2000);
        *(_WORD *)(v79 + 1692) = v82;
        *(_WORD *)(a1 + 4 * v82 + 1694) = a4;
LABEL_164:
        *(_WORD *)(a1 + 2000) = v82 + 1;
        goto LABEL_168;
      }
      goto LABEL_168;
    }
    uint64_t v83 = a1 + 2 * a4;
    uint64_t v80 = *(unsigned __int16 *)(v83 + 1900);
    uint64_t v81 = 1919160320;
LABEL_166:
    if (v80 == 0xFFFF)
    {
      uint64_t v80 = *(unsigned __int16 *)(a1 + 2004);
      *(_WORD *)(v83 + 1900) = v80;
      *(_WORD *)(a1 + 2004) = v80 + 1;
    }
    goto LABEL_168;
  }
  uint64_t v137 = v16 | 0x3100000882;
  *(_DWORD *)(a1 + 16) = 2;
  if (a6)
  {
    uint64_t v20 = gleVStateProgram_GetAttrib(a1, a2) << 48;
  }
  else
  {
    uint64_t v84 = a1 + 2 * a2;
    uint64_t v85 = *(unsigned __int16 *)(v84 + 1900);
    if (v85 == 0xFFFF)
    {
      uint64_t v85 = *(unsigned __int16 *)(a1 + 2004);
      *(_WORD *)(v84 + 1900) = v85;
      *(_WORD *)(a1 + 2004) = v85 + 1;
    }
    uint64_t v20 = (v85 << 48) | 0x40;
  }
  *((void *)&v138 + 1) = v20;
  uint64_t v86 = (_WORD *)(a1 + 4 * a3 + 260);
  uint64_t v87 = (unsigned __int16)*v86;
  if (a7)
  {
    if (v87 == 0xFFFF)
    {
      uint64_t v88 = *(__int16 *)(a1 + 1998);
      uint64_t v87 = *(unsigned __int16 *)(a1 + 1998);
      *uint64_t v86 = v88;
      *(_WORD *)(a1 + 4 * v88 + 262) = a3;
      __int16 v89 = v88 + 11;
      if ((a3 & 0xFFFFFFF0) != 0x90) {
        __int16 v89 = v88 + 1;
      }
      *(_WORD *)(a1 + 1998) = v89;
    }
    uint64_t v90 = ((v87 << 48) | 0x19C840) + 65;
    *(_WORD *)(a1 + 2002) = 1;
  }
  else
  {
    if (v87 == 0xFFFF)
    {
      uint64_t v91 = *(__int16 *)(a1 + 1998);
      uint64_t v87 = *(unsigned __int16 *)(a1 + 1998);
      *uint64_t v86 = v91;
      *(_WORD *)(a1 + 4 * v91 + 262) = a3;
      __int16 v92 = v91 + 11;
      if ((a3 & 0xFFFFFFF0) != 0x90) {
        __int16 v92 = v91 + 1;
      }
      *(_WORD *)(a1 + 1998) = v92;
    }
    uint64_t v90 = ((v87 << 48) | 0x19C840) + 64;
  }
  *(void *)&long long v139 = v90;
  uint64_t v93 = (_WORD *)(a1 + 2 * a5 + 1900);
  uint64_t v94 = (unsigned __int16)*v93;
  if (v94 == 0xFFFF)
  {
    uint64_t v94 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v93 = v94;
    *(_WORD *)(a1 + 2004) = v94 + 1;
  }
  uint64_t v81 = 1919389696;
  *(void *)&long long v138 = (v94 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
  uint64_t v142 = 0;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  uint64_t v137 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000FC3;
  *(_DWORD *)(a1 + 16) = 3;
  if (a6)
  {
    uint64_t v95 = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
    uint64_t v96 = 43520;
  }
  else
  {
    uint64_t v97 = a1 + 2 * a2;
    LODWORD(v95) = *(unsigned __int16 *)(v97 + 1900);
    if (v95 == 0xFFFF)
    {
      LODWORD(v95) = *(unsigned __int16 *)(a1 + 2004);
      *(_WORD *)(v97 + 1900) = v95;
      *(_WORD *)(a1 + 2004) = v95 + 1;
    }
    uint64_t v95 = v95;
    uint64_t v96 = 43584;
  }
  *((void *)&v138 + 1) = v96 | (v95 << 48);
  int v98 = a3 + 1;
  int v99 = (_WORD *)(a1 + 4 * (a3 + 1) + 260);
  uint64_t v100 = (unsigned __int16)*v99;
  if (a7)
  {
    if (v100 == 0xFFFF)
    {
      uint64_t v101 = *(__int16 *)(a1 + 1998);
      uint64_t v100 = *(unsigned __int16 *)(a1 + 1998);
      *int v99 = v101;
      *(_WORD *)(a1 + 4 * v101 + 262) = v98;
      BOOL v26 = (v98 & 0xFFFFFFF0) == 144;
      __int16 v102 = v101 + 11;
      if (!v26) {
        __int16 v102 = v101 + 1;
      }
      *(_WORD *)(a1 + 1998) = v102;
    }
    uint64_t v103 = ((v100 << 48) | 0x19C840) + 65;
    *(_WORD *)(a1 + 2002) = 1;
  }
  else
  {
    if (v100 == 0xFFFF)
    {
      uint64_t v104 = *(__int16 *)(a1 + 1998);
      uint64_t v100 = *(unsigned __int16 *)(a1 + 1998);
      *int v99 = v104;
      *(_WORD *)(a1 + 4 * v104 + 262) = v98;
      BOOL v26 = (v98 & 0xFFFFFFF0) == 144;
      __int16 v105 = v104 + 11;
      if (!v26) {
        __int16 v105 = v104 + 1;
      }
      *(_WORD *)(a1 + 1998) = v105;
    }
    uint64_t v103 = ((v100 << 48) | 0x19C840) + 64;
  }
  int v136 = a8;
  *(void *)&long long v139 = v103;
  uint64_t v106 = (unsigned __int16)*v93;
  int v107 = a4;
  if (v106 == 0xFFFF)
  {
    uint64_t v108 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v93 = v108;
    *(_WORD *)(a1 + 2004) = v108 + 1;
    uint64_t v106 = (unsigned __int16)*v93;
    *((void *)&v139 + 1) = (v108 << 48) | 0x19C840;
    if (v106 == 0xFFFF)
    {
      uint64_t v106 = *(unsigned __int16 *)(a1 + 2004);
      *uint64_t v93 = v106;
      *(_WORD *)(a1 + 2004) = v106 + 1;
    }
  }
  else
  {
    *((void *)&v139 + 1) = (v106 << 48) | 0x19C840;
  }
  uint64_t v109 = 87040;
  *(void *)&long long v138 = (v106 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
  uint64_t v142 = 0;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  uint64_t v137 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000FC3;
  *(_DWORD *)(a1 + 16) = 3;
  if (a6)
  {
    uint64_t v110 = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
  }
  else
  {
    uint64_t v111 = a1 + 2 * a2;
    LODWORD(v110) = *(unsigned __int16 *)(v111 + 1900);
    if (v110 == 0xFFFF)
    {
      LODWORD(v110) = *(unsigned __int16 *)(a1 + 2004);
      *(_WORD *)(v111 + 1900) = v110;
      *(_WORD *)(a1 + 2004) = v110 + 1;
    }
    uint64_t v110 = v110;
    uint64_t v109 = 87104;
  }
  *((void *)&v138 + 1) = v109 | (v110 << 48);
  int v112 = a3 + 2;
  uint64_t v113 = (_WORD *)(a1 + 4 * (a3 + 2) + 260);
  uint64_t v114 = (unsigned __int16)*v113;
  if (a7)
  {
    if (v114 == 0xFFFF)
    {
      uint64_t v115 = *(__int16 *)(a1 + 1998);
      uint64_t v114 = *(unsigned __int16 *)(a1 + 1998);
      *uint64_t v113 = v115;
      *(_WORD *)(a1 + 4 * v115 + 262) = v112;
      BOOL v26 = (v112 & 0xFFFFFFF0) == 144;
      __int16 v116 = v115 + 11;
      if (!v26) {
        __int16 v116 = v115 + 1;
      }
      *(_WORD *)(a1 + 1998) = v116;
    }
    uint64_t v117 = ((v114 << 48) | 0x19C840) + 65;
    *(_WORD *)(a1 + 2002) = 1;
  }
  else
  {
    if (v114 == 0xFFFF)
    {
      uint64_t v118 = *(__int16 *)(a1 + 1998);
      uint64_t v114 = *(unsigned __int16 *)(a1 + 1998);
      *uint64_t v113 = v118;
      *(_WORD *)(a1 + 4 * v118 + 262) = v112;
      BOOL v26 = (v112 & 0xFFFFFFF0) == 144;
      __int16 v119 = v118 + 11;
      if (!v26) {
        __int16 v119 = v118 + 1;
      }
      *(_WORD *)(a1 + 1998) = v119;
    }
    uint64_t v117 = ((v114 << 48) | 0x19C840) + 64;
  }
  *(void *)&long long v139 = v117;
  uint64_t v120 = (unsigned __int16)*v93;
  if (v120 == 0xFFFF)
  {
    uint64_t v121 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v93 = v121;
    *(_WORD *)(a1 + 2004) = v121 + 1;
    uint64_t v120 = (unsigned __int16)*v93;
    *((void *)&v139 + 1) = (v121 << 48) | 0x19C840;
    if (v120 == 0xFFFF)
    {
      uint64_t v120 = *(unsigned __int16 *)(a1 + 2004);
      *uint64_t v93 = v120;
      *(_WORD *)(a1 + 2004) = v120 + 1;
    }
  }
  else
  {
    *((void *)&v139 + 1) = (v120 << 48) | 0x19C840;
  }
  *(void *)&long long v138 = (v120 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
  uint64_t v142 = 0;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  uint64_t v137 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000FC3;
  *(_DWORD *)(a1 + 16) = 3;
  if (a6)
  {
    uint64_t v122 = (unsigned __int16)gleVStateProgram_GetAttrib(a1, a2);
    uint64_t v123 = 130560;
  }
  else
  {
    uint64_t v124 = a1 + 2 * a2;
    LODWORD(v122) = *(unsigned __int16 *)(v124 + 1900);
    if (v122 == 0xFFFF)
    {
      LODWORD(v122) = *(unsigned __int16 *)(a1 + 2004);
      *(_WORD *)(v124 + 1900) = v122;
      *(_WORD *)(a1 + 2004) = v122 + 1;
    }
    uint64_t v122 = v122;
    uint64_t v123 = 130624;
  }
  *((void *)&v138 + 1) = v123 | (v122 << 48);
  int v125 = a3 + 3;
  uint64_t v126 = (_WORD *)(a1 + 4 * (a3 + 3) + 260);
  uint64_t v127 = (unsigned __int16)*v126;
  if (a7)
  {
    if (v127 == 0xFFFF)
    {
      uint64_t v128 = *(__int16 *)(a1 + 1998);
      uint64_t v127 = *(unsigned __int16 *)(a1 + 1998);
      *uint64_t v126 = v128;
      *(_WORD *)(a1 + 4 * v128 + 262) = v125;
      BOOL v26 = (v125 & 0xFFFFFFF0) == 144;
      __int16 v129 = v128 + 11;
      if (!v26) {
        __int16 v129 = v128 + 1;
      }
      *(_WORD *)(a1 + 1998) = v129;
    }
    uint64_t v130 = ((v127 << 48) | 0x19C840) + 65;
    *(_WORD *)(a1 + 2002) = 1;
  }
  else
  {
    if (v127 == 0xFFFF)
    {
      uint64_t v131 = *(__int16 *)(a1 + 1998);
      uint64_t v127 = *(unsigned __int16 *)(a1 + 1998);
      *uint64_t v126 = v131;
      *(_WORD *)(a1 + 4 * v131 + 262) = v125;
      BOOL v26 = (v125 & 0xFFFFFFF0) == 144;
      __int16 v132 = v131 + 11;
      if (!v26) {
        __int16 v132 = v131 + 1;
      }
      *(_WORD *)(a1 + 1998) = v132;
    }
    uint64_t v130 = ((v127 << 48) | 0x19C840) + 64;
  }
  *(void *)&long long v139 = v130;
  uint64_t v133 = (unsigned __int16)*v93;
  if (v133 == 0xFFFF)
  {
    uint64_t v133 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v93 = v133;
    *(_WORD *)(a1 + 2004) = v133 + 1;
  }
  *((void *)&v139 + 1) = (v133 << 48) | 0x19C840;
  if (!v136)
  {
    uint64_t v83 = a1 + 2 * v107;
    uint64_t v80 = *(unsigned __int16 *)(v83 + 1900);
    goto LABEL_166;
  }
  uint64_t v134 = a1 + 4 * v107;
  uint64_t v80 = *(unsigned __int16 *)(v134 + 1692);
  uint64_t v81 = 1919397888;
  if (v80 == 0xFFFF)
  {
    uint64_t v82 = *(__int16 *)(a1 + 2000);
    uint64_t v80 = *(unsigned __int16 *)(a1 + 2000);
    *(_WORD *)(v134 + 1692) = v82;
    *(_WORD *)(a1 + 4 * v82 + 1694) = v107;
    goto LABEL_164;
  }
LABEL_168:
  *(void *)&long long v138 = v81 | (v80 << 48);
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v137);
}

uint64_t gleVStateProgram_MultMatrix3x3(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v79 = 0;
  long long v78 = 0u;
  long long v77 = 0u;
  long long v76 = 0u;
  uint64_t v10 = 8 * (*(_DWORD *)(a1 + 16) & 7);
  if (a6)
  {
    uint64_t v74 = v10 | 0x3100000A02;
    *(_DWORD *)(a1 + 16) = 2;
    *((void *)&v75 + 1) = ((gleVStateProgram_GetAttrib(a1, 1) << 48) | 0x19C880) - 128;
    uint64_t v11 = a2 + 4;
    uint64_t v12 = (_WORD *)(a1 + 4 * v11 + 260);
    uint64_t v13 = (unsigned __int16)*v12;
    if (a5)
    {
      if (v13 == 0xFFFF)
      {
        uint64_t v14 = *(__int16 *)(a1 + 1998);
        uint64_t v13 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v12 = v14;
        *(_WORD *)(a1 + 4 * v14 + 262) = v11;
        BOOL v15 = (v11 & 0xFFFFFFF0) == 144;
        __int16 v16 = v14 + 11;
        if (!v15) {
          __int16 v16 = v14 + 1;
        }
        *(_WORD *)(a1 + 1998) = v16;
      }
      uint64_t v17 = ((v13 << 48) | 0x19C880) + 1;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v13 == 0xFFFF)
      {
        uint64_t v24 = *(__int16 *)(a1 + 1998);
        uint64_t v13 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v12 = v24;
        *(_WORD *)(a1 + 4 * v24 + 262) = v11;
        BOOL v15 = (v11 & 0xFFFFFFF0) == 144;
        __int16 v25 = v24 + 11;
        if (!v15) {
          __int16 v25 = v24 + 1;
        }
        *(_WORD *)(a1 + 1998) = v25;
      }
      uint64_t v17 = (v13 << 48) | 0x19C880;
    }
    *(void *)&long long v76 = v17;
    BOOL v26 = (_WORD *)(a1 + 2 * a3 + 1900);
    uint64_t v27 = (unsigned __int16)*v26;
    if (v27 == 0xFFFF)
    {
      uint64_t v27 = *(unsigned __int16 *)(a1 + 2004);
      *BOOL v26 = v27;
      *(_WORD *)(a1 + 2004) = v27 + 1;
    }
    *(void *)&long long v75 = ((v27 << 48) | 0x72679000) - 229376;
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v74);
    uint64_t v79 = 0;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v76 = 0u;
    uint64_t v74 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000A02;
    *(_DWORD *)(a1 + 16) = 2;
    *((void *)&v75 + 1) = (gleVStateProgram_GetAttrib(a1, 1) << 48) | 0x19C800;
    int v28 = a2 + 5;
    uint64_t v29 = (_WORD *)(a1 + 4 * (a2 + 5) + 260);
    uint64_t v30 = (unsigned __int16)*v29;
    if (a5)
    {
      if (v30 == 0xFFFF)
      {
        uint64_t v31 = *(__int16 *)(a1 + 1998);
        uint64_t v30 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v29 = v31;
        *(_WORD *)(a1 + 4 * v31 + 262) = v28;
        BOOL v15 = (v28 & 0xFFFFFFF0) == 144;
        __int16 v32 = v31 + 11;
        if (!v15) {
          __int16 v32 = v31 + 1;
        }
        *(_WORD *)(a1 + 1998) = v32;
      }
      uint64_t v33 = ((v30 << 48) | 0x19C880) + 1;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v30 == 0xFFFF)
      {
        uint64_t v34 = *(__int16 *)(a1 + 1998);
        uint64_t v30 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v29 = v34;
        *(_WORD *)(a1 + 4 * v34 + 262) = v28;
        BOOL v15 = (v28 & 0xFFFFFFF0) == 144;
        __int16 v35 = v34 + 11;
        if (!v15) {
          __int16 v35 = v34 + 1;
        }
        *(_WORD *)(a1 + 1998) = v35;
      }
      uint64_t v33 = (v30 << 48) | 0x19C880;
    }
    *(void *)&long long v76 = v33;
    uint64_t v36 = (unsigned __int16)*v26;
    if (v36 == 0xFFFF)
    {
      uint64_t v36 = *(unsigned __int16 *)(a1 + 2004);
      *BOOL v26 = v36;
      *(_WORD *)(a1 + 2004) = v36 + 1;
    }
    *(void *)&long long v75 = (v36 << 48) | 0x72621000;
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v74);
    uint64_t v79 = 0;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v76 = 0u;
    uint64_t v74 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000A02;
    *(_DWORD *)(a1 + 16) = 2;
    *((void *)&v75 + 1) = (gleVStateProgram_GetAttrib(a1, 1) << 48) | 0x19C800;
    int v37 = a2 + 6;
    uint64_t v38 = (_WORD *)(a1 + 4 * (a2 + 6) + 260);
    uint64_t v39 = (unsigned __int16)*v38;
    if (a5)
    {
      if (v39 == 0xFFFF)
      {
        uint64_t v40 = *(__int16 *)(a1 + 1998);
        uint64_t v39 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v38 = v40;
        *(_WORD *)(a1 + 4 * v40 + 262) = v37;
        BOOL v15 = (v37 & 0xFFFFFFF0) == 144;
        __int16 v41 = v40 + 11;
        if (!v15) {
          __int16 v41 = v40 + 1;
        }
        *(_WORD *)(a1 + 1998) = v41;
      }
      uint64_t v42 = ((v39 << 48) | 0x19C880) + 1;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v39 == 0xFFFF)
      {
        uint64_t v43 = *(__int16 *)(a1 + 1998);
        uint64_t v39 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v38 = v43;
        *(_WORD *)(a1 + 4 * v43 + 262) = v37;
        BOOL v15 = (v37 & 0xFFFFFFF0) == 144;
        __int16 v44 = v43 + 11;
        if (!v15) {
          __int16 v44 = v43 + 1;
        }
        *(_WORD *)(a1 + 1998) = v44;
      }
      uint64_t v42 = (v39 << 48) | 0x19C880;
    }
    *(void *)&long long v76 = v42;
    uint64_t v45 = (unsigned __int16)*v26;
    uint64_t v46 = 1918996480;
    if (v45 == 0xFFFF)
    {
      uint64_t v47 = (_WORD *)(a1 + 2004);
      uint64_t v45 = *(unsigned __int16 *)(a1 + 2004);
      *BOOL v26 = v45;
LABEL_84:
      *uint64_t v47 = v45 + 1;
    }
  }
  else
  {
    uint64_t v74 = v10 | 0x3100000882;
    *(_DWORD *)(a1 + 16) = 2;
    *((void *)&v75 + 1) = gleVStateProgram_GetAttrib(a1, 1) << 48;
    uint64_t v19 = (_WORD *)(a1 + 4 * a2 + 260);
    uint64_t v20 = (unsigned __int16)*v19;
    if (a5)
    {
      if (v20 == 0xFFFF)
      {
        uint64_t v21 = *(__int16 *)(a1 + 1998);
        uint64_t v20 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v19 = v21;
        *(_WORD *)(a1 + 4 * v21 + 262) = a2;
        __int16 v22 = v21 + 11;
        if ((a2 & 0xFFFFFFF0) != 0x90) {
          __int16 v22 = v21 + 1;
        }
        *(_WORD *)(a1 + 1998) = v22;
      }
      uint64_t v23 = ((v20 << 48) | 0x19C880) + 1;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v20 == 0xFFFF)
      {
        uint64_t v48 = *(__int16 *)(a1 + 1998);
        uint64_t v20 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v19 = v48;
        *(_WORD *)(a1 + 4 * v48 + 262) = a2;
        __int16 v49 = v48 + 11;
        if ((a2 & 0xFFFFFFF0) != 0x90) {
          __int16 v49 = v48 + 1;
        }
        *(_WORD *)(a1 + 1998) = v49;
      }
      uint64_t v23 = (v20 << 48) | 0x19C880;
    }
    uint64_t v50 = a2;
    *(void *)&long long v76 = v23;
    uint64_t v51 = (_WORD *)(a1 + 2 * a4 + 1900);
    uint64_t v52 = (unsigned __int16)*v51;
    if (v52 == 0xFFFF)
    {
      uint64_t v52 = *(unsigned __int16 *)(a1 + 2004);
      *uint64_t v51 = v52;
      *(_WORD *)(a1 + 2004) = v52 + 1;
    }
    uint64_t v46 = 1919389696;
    *(void *)&long long v75 = (v52 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v74);
    uint64_t v79 = 0;
    long long v78 = 0u;
    long long v77 = 0u;
    long long v76 = 0u;
    long long v75 = 0u;
    uint64_t v74 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a1 + 16) = 3;
    *((void *)&v75 + 1) = (gleVStateProgram_GetAttrib(a1, 1) << 48) | 0xAA00;
    int v53 = v50 + 1;
    uint64_t v54 = (_WORD *)(a1 + 4 * (v50 + 1) + 260);
    uint64_t v55 = (unsigned __int16)*v54;
    if (a5)
    {
      if (v55 == 0xFFFF)
      {
        uint64_t v56 = *(__int16 *)(a1 + 1998);
        uint64_t v55 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v54 = v56;
        *(_WORD *)(a1 + 4 * v56 + 262) = v53;
        BOOL v15 = (v53 & 0xFFFFFFF0) == 144;
        __int16 v57 = v56 + 11;
        if (!v15) {
          __int16 v57 = v56 + 1;
        }
        *(_WORD *)(a1 + 1998) = v57;
      }
      uint64_t v58 = ((v55 << 48) | 0x19C880) + 1;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v55 == 0xFFFF)
      {
        uint64_t v59 = *(__int16 *)(a1 + 1998);
        uint64_t v55 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v54 = v59;
        *(_WORD *)(a1 + 4 * v59 + 262) = v53;
        BOOL v15 = (v53 & 0xFFFFFFF0) == 144;
        __int16 v60 = v59 + 11;
        if (!v15) {
          __int16 v60 = v59 + 1;
        }
        *(_WORD *)(a1 + 1998) = v60;
      }
      uint64_t v58 = (v55 << 48) | 0x19C880;
    }
    *(void *)&long long v76 = v58;
    uint64_t v61 = (unsigned __int16)*v51;
    if (v61 == 0xFFFF)
    {
      uint64_t v62 = *(unsigned __int16 *)(a1 + 2004);
      *uint64_t v51 = v62;
      *(_WORD *)(a1 + 2004) = v62 + 1;
      uint64_t v61 = (unsigned __int16)*v51;
      *((void *)&v76 + 1) = (v62 << 48) | 0x19C840;
      if (v61 == 0xFFFF)
      {
        uint64_t v61 = *(unsigned __int16 *)(a1 + 2004);
        *uint64_t v51 = v61;
        *(_WORD *)(a1 + 2004) = v61 + 1;
      }
    }
    else
    {
      *((void *)&v76 + 1) = (v61 << 48) | 0x19C840;
    }
    *(void *)&long long v75 = (v61 << 48) | 0x72679000;
    (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v74);
    uint64_t v79 = 0;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    uint64_t v74 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000FC3;
    *(_DWORD *)(a1 + 16) = 3;
    *((void *)&v75 + 1) = (gleVStateProgram_GetAttrib(a1, 1) << 48) | 0x15400;
    int v63 = v50 + 2;
    uint64_t v64 = (_WORD *)(a1 + 4 * (v50 + 2) + 260);
    uint64_t v65 = (unsigned __int16)*v64;
    if (a5)
    {
      if (v65 == 0xFFFF)
      {
        uint64_t v66 = *(__int16 *)(a1 + 1998);
        uint64_t v65 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v64 = v66;
        *(_WORD *)(a1 + 4 * v66 + 262) = v63;
        BOOL v15 = (v63 & 0xFFFFFFF0) == 144;
        __int16 v67 = v66 + 11;
        if (!v15) {
          __int16 v67 = v66 + 1;
        }
        *(_WORD *)(a1 + 1998) = v67;
      }
      uint64_t v68 = ((v65 << 48) | 0x19C880) + 1;
      *(_WORD *)(a1 + 2002) = 1;
    }
    else
    {
      if (v65 == 0xFFFF)
      {
        uint64_t v69 = *(__int16 *)(a1 + 1998);
        uint64_t v65 = *(unsigned __int16 *)(a1 + 1998);
        *uint64_t v64 = v69;
        *(_WORD *)(a1 + 4 * v69 + 262) = v63;
        BOOL v15 = (v63 & 0xFFFFFFF0) == 144;
        __int16 v70 = v69 + 11;
        if (!v15) {
          __int16 v70 = v69 + 1;
        }
        *(_WORD *)(a1 + 1998) = v70;
      }
      uint64_t v68 = (v65 << 48) | 0x19C880;
    }
    *(void *)&long long v76 = v68;
    uint64_t v71 = (unsigned __int16)*v51;
    if (v71 == 0xFFFF)
    {
      uint64_t v71 = *(unsigned __int16 *)(a1 + 2004);
      *uint64_t v51 = v71;
      *(_WORD *)(a1 + 2004) = v71 + 1;
    }
    *((void *)&v76 + 1) = (v71 << 48) | 0x19C840;
    uint64_t v72 = a1 + 2 * a3;
    uint64_t v45 = *(unsigned __int16 *)(v72 + 1900);
    if (v45 == 0xFFFF)
    {
      uint64_t v47 = (_WORD *)(a1 + 2004);
      uint64_t v45 = *(unsigned __int16 *)(a1 + 2004);
      *(_WORD *)(v72 + 1900) = v45;
      goto LABEL_84;
    }
  }
  *(void *)&long long v75 = v46 | (v45 << 48);
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v74);
}

uint64_t gleVStateProgram_NormalizeVector(uint64_t a1, int a2, int a3, int a4, int a5)
{
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v22 = ((8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000882) + 384;
  *(_DWORD *)(a1 + 16) = 2;
  uint64_t v8 = (_WORD *)(a1 + 2 * a2 + 1900);
  uint64_t v9 = (unsigned __int16)*v8;
  if (v9 == 0xFFFF)
  {
    uint64_t v10 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v8 = v10;
    *(_WORD *)(a1 + 2004) = v10 + 1;
    uint64_t v9 = (unsigned __int16)*v8;
    *(void *)&long long v24 = (v10 << 48) | 0x19C840;
    if (v9 == 0xFFFF)
    {
      uint64_t v9 = *(unsigned __int16 *)(a1 + 2004);
      *uint64_t v8 = v9;
      *(_WORD *)(a1 + 2004) = v9 + 1;
    }
  }
  else
  {
    *(void *)&long long v24 = (v9 << 48) | 0x19C840;
  }
  *((void *)&v24 + 1) = (v9 << 48) | 0x19C840;
  uint64_t v11 = (_WORD *)(a1 + 2 * a4 + 1900);
  uint64_t v12 = (unsigned __int16)*v11;
  if (v12 == 0xFFFF)
  {
    uint64_t v12 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v11 = v12;
    *(_WORD *)(a1 + 2004) = v12 + 1;
  }
  uint64_t v23 = (v12 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v22);
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  char v13 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = 1;
  uint64_t v22 = (8 * (v13 & 7)) | 0x100080341;
  uint64_t v14 = (unsigned __int16)*v11;
  if (v14 == 0xFFFF)
  {
    uint64_t v14 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v11 = v14;
    *(_WORD *)(a1 + 2004) = v14 + 1;
  }
  *(void *)&long long v24 = (v14 << 48) | 0x19C840;
  BOOL v15 = (_WORD *)(a1 + 2 * a5 + 1900);
  uint64_t v16 = (unsigned __int16)*v15;
  if (v16 == 0xFFFF)
  {
    uint64_t v16 = *(unsigned __int16 *)(a1 + 2004);
    *BOOL v15 = v16;
    *(_WORD *)(a1 + 2004) = v16 + 1;
  }
  uint64_t v23 = (v16 << 48) | 0x72679000;
  (*(void (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v22);
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v22 = (8 * (*(_DWORD *)(a1 + 16) & 7)) | 0x3100000882;
  *(_DWORD *)(a1 + 16) = 2;
  uint64_t v17 = (unsigned __int16)*v8;
  if (v17 == 0xFFFF)
  {
    uint64_t v17 = *(unsigned __int16 *)(a1 + 2004);
    *uint64_t v8 = v17;
    *(_WORD *)(a1 + 2004) = v17 + 1;
  }
  *(void *)&long long v24 = (v17 << 48) | 0x19C840;
  uint64_t v18 = (unsigned __int16)*v15;
  if (v18 == 0xFFFF)
  {
    uint64_t v18 = *(unsigned __int16 *)(a1 + 2004);
    *BOOL v15 = v18;
    *(_WORD *)(a1 + 2004) = v18 + 1;
  }
  *((void *)&v24 + 1) = (v18 << 48) | 0x19C840;
  uint64_t v19 = a1 + 2 * a3;
  uint64_t v20 = *(unsigned __int16 *)(v19 + 1900);
  if (v20 == 0xFFFF)
  {
    uint64_t v20 = *(unsigned __int16 *)(a1 + 2004);
    *(_WORD *)(v19 + 1900) = v20;
    *(_WORD *)(a1 + 2004) = v20 + 1;
  }
  uint64_t v23 = (v20 << 48) | 0x72679000;
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a1 + 2016))(a1, &v22);
}

char *glpCallFragmentStateToLLVMIR(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, _DWORD *a6)
{
  long long v55 = 0u;
  long long v56 = 0u;
  *(_OWORD *)&v53[12] = 0u;
  long long v54 = 0u;
  long long v40 = 0u;
  int v41 = 0;
  *(void *)&long long v11 = -1;
  *((void *)&v11 + 1) = -1;
  long long v50 = v11;
  v51[0] = v11;
  *(void *)&v53[14] = -1;
  *(_OWORD *)int v53 = v11;
  long long v52 = v11;
  v51[1] = v11;
  long long v49 = v11;
  long long v48 = v11;
  long long v47 = v11;
  long long v46 = v11;
  long long v45 = v11;
  long long v44 = v11;
  long long v43 = v11;
  long long v42 = v11;
  uint64_t v12 = *(void *)a1;
  DWORD2(v56) = (*(void *)a1 >> 38) & 8 | 1;
  *((void *)&v40 + 1) = &v57;
  BYTE12(v54) = BYTE3(v12) & 1;
  WORD6(v50) = 4096;
  LOWORD(v51[0]) = 4097;
  WORD2(v51[0]) = 4098;
  *(void *)&long long v55 = gleFStateProgram_LLVMAddOperation;
  *((void *)&v55 + 1) = a1;
  gleFStateProgram_Start((uint64_t *)a1, (uint64_t)&v40);
  if (BYTE8(v56))
  {
    gleFStateProgram_AllocateAttribs((uint64_t *)a1, (uint64_t)&v40);
    uint64_t v13 = *(void *)a1;
    if ((*(void *)a1 & 0x40000) != 0)
    {
      __int16 v16 = WORD2(v54);
      WORD4(v51[0]) = WORD2(v54);
      *((_WORD *)v51 + 2 * SWORD2(v54) + 5) = 0;
      WORD2(v54) = v16 + 1;
      if ((v13 & 0x200) == 0) {
        goto LABEL_12;
      }
      WORD4(v52) = v16 + 1;
      *((_WORD *)v51 + 2 * (__int16)(v16 + 1) + 5) = 8;
      __int16 v15 = v16 + 2;
      goto LABEL_7;
    }
    if ((v13 & 0x20000) == 0)
    {
      __int16 v14 = WORD2(v54);
      WORD4(v51[0]) = WORD2(v54);
      *((_WORD *)v51 + 2 * SWORD2(v54) + 5) = 0;
      __int16 v15 = v14 + 1;
LABEL_7:
      WORD2(v54) = v15;
      goto LABEL_12;
    }
    uint64_t v17 = 0;
    unint64_t v18 = BYTE1(v13);
    int v19 = WORD2(v54);
    uint64_t v20 = (_WORD *)v51 + 4;
    do
    {
      if ((v18 >> v17))
      {
        *uint64_t v20 = v19;
        *((_WORD *)v51 + 2 * (__int16)v19++ + 5) = v17;
        WORD2(v54) = v19;
      }
      ++v17;
      v20 += 2;
    }
    while (v17 != 8);
  }
LABEL_12:
  if ((BYTE8(v56) & 1) == 0) {
    gleFStateProgram_AllocateAttribs((uint64_t *)a1, (uint64_t)&v40);
  }
  gleFStateProgram_Core(a1, (uint64_t)&v40);
  gleFStateProgram_End(a1, (uint64_t)&v40);
  int v21 = 8 * SWORD1(v54) + 64;
  int v22 = v21 + gleAttribBindingSize((__int16)v54);
  uint64_t v23 = malloc_type_malloc(v22, 0x7081ABB9uLL);
  if (!v23) {
    goto LABEL_31;
  }
  long long v24 = v23;
  *(void *)uint64_t v23 = 0x3000000030;
  uint64_t v23[2] = v21;
  _OWORD v23[3] = v22;
  v23[4] = 0;
  *((void *)v23 + 3) = 0;
  *(void *)&long long v56 = v23;
  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void *)a1 & 1 ^ 0x100000001;
  if ((*(void *)a1 & 0x2000000) != 0) {
    uint64_t v26 = 1;
  }
  uint64_t v27 = 4 * v26;
  if ((BYTE8(v56) & 2) == 0) {
    uint64_t v27 = 0;
  }
  uint64_t v28 = 8 * v26;
  if ((BYTE8(v56) & 4) == 0) {
    uint64_t v28 = 0;
  }
  uint64_t v29 = v27 | v28;
  if ((v25 & 0x40) != 0) {
    v29 |= 0x2000000020uLL;
  }
  if ((v25 & 0xE0000) == 0)
  {
    unsigned int v30 = BYTE1(v25);
    if (BYTE1(v25))
    {
      char v31 = 0;
      do
      {
        uint64_t v32 = 0x10000000100 << v31;
        if ((v30 & 1) == 0) {
          uint64_t v32 = 0;
        }
        v29 |= v32;
        ++v31;
        BOOL v33 = v30 > 1;
        v30 >>= 1;
      }
      while (v33);
    }
  }
  *((void *)v23 + 4) = (unint64_t)((v25 & 0xFF00000000) != 0) << 9;
  *(void *)(v56 + 40) = v29;
  gleFStateProgram_AddParams((char *)&v40);
  gleFStateProgram_AddAttribs((int *)a1, (uint64_t)&v40);
  uint64_t v34 = (char *)malloc_type_malloc(0x50uLL, 0x7081ABB9uLL);
  if (!v34) {
LABEL_31:
  }
    abort();
  __int16 v35 = v34;
  *(void *)uint64_t v34 = 0x20000004CLL;
  *(_OWORD *)(v34 + 8) = *(_OWORD *)a1;
  long long v36 = *(_OWORD *)(a1 + 16);
  long long v37 = *(_OWORD *)(a1 + 32);
  long long v38 = *(_OWORD *)(a1 + 48);
  *((void *)v34 + 9) = *(void *)(a1 + 64);
  *(_OWORD *)(v34 + 56) = v38;
  *(_OWORD *)(v34 + 40) = v37;
  *(_OWORD *)(v34 + 24) = v36;
  gleCopyParamBindings((void *)((char *)v24 + *((unsigned int *)v24 + 1)), a2);
  *a4 = v24[4];
  *a5 = v24[5];
  *a6 = *((_DWORD *)v24 + 4);
  free(v24);
  return v35;
}

unsigned __int16 *glpFragmentStateToPPStream(uint64_t a1, void *a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  int v24 = 0;
  long long v36 = 0u;
  *(_OWORD *)uint64_t v26 = 0u;
  *(_OWORD *)&v33[20] = 0u;
  uint64_t v34 = 0;
  uint64_t v37 = 0;
  *(void *)&v33[14] = -1;
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  *(_OWORD *)BOOL v33 = v9;
  v32[5] = v9;
  v32[4] = v9;
  v32[3] = v9;
  v32[2] = v9;
  v32[1] = v9;
  v32[0] = v9;
  long long v31 = v9;
  long long v30 = v9;
  long long v29 = v9;
  long long v28 = v9;
  long long v27 = v9;
  *(_OWORD *)&v26[12] = v9;
  uint64_t v10 = (_DWORD **)PPStreamCreate();
  uint64_t v25 = v10;
  *(_WORD *)uint64_t v10 = -30716;
  __int16 v35 = gleFStateProgram_AddPPStreamOperation;
  if (*(unsigned char *)(a1 + 2)) {
    PPStreamAddOption((uint64_t)v10, 12);
  }
  gleFStateProgram_Start((uint64_t *)a1, (uint64_t)&v25);
  gleFStateProgram_Core(a1, (uint64_t)&v25);
  gleFStateProgram_End(a1, (uint64_t)&v25);
  gleFStateProgram_AddAttribs((int *)a1, (uint64_t)&v25);
  gleFStateProgram_AddParams((char *)&v25);
  if (*(__int16 *)&v33[32] >= 1)
  {
    uint64_t v11 = 0;
    if (BYTE3(v34)) {
      uint64_t v12 = 3;
    }
    else {
      uint64_t v12 = 1;
    }
    uint64_t v13 = 174;
    do
    {
      uint64_t v14 = *(unsigned __int16 *)&v26[v13 - 8];
      *(void *)&long long v38 = v12;
      *((void *)&v38 + 1) = v11;
      if (v14 == 8)
      {
        *(void *)&long long v38 = 1793;
      }
      else if (v14 <= 7)
      {
        *(void *)&long long v38 = v12 | (v14 << 33) | 0x4C0;
      }
      PPStreamAddOutputBinding((uint64_t)v25, &v38);
      ++v11;
      v13 += 4;
    }
    while (v11 < *(__int16 *)&v33[32]);
  }
  if (*(_WORD *)&v33[34])
  {
    unsigned int v15 = 0;
    int v16 = BYTE3(v34);
    do
    {
      if (v16) {
        BOOL v17 = v15 == *(__int16 *)&v33[20];
      }
      else {
        BOOL v17 = 1;
      }
      if (v17 || v15 == *(__int16 *)&v33[18] || v15 == *(__int16 *)&v33[16]) {
        uint64_t v20 = 193;
      }
      else {
        uint64_t v20 = 195;
      }
      *(void *)&long long v38 = v20;
      *((void *)&v38 + 1) = v15;
      PPStreamAddTempUsage((uint64_t)v25, &v38);
      ++v15;
    }
    while (v15 < *(__int16 *)&v33[34]);
  }
  Streaunint64_t m = PPStreamGetStream((uint64_t)v25, &v24);
  PPStreamFree(v25);
  *a2 = *((void *)Stream + 1);
  *a3 = *((void *)Stream + 2);
  *a4 = PPStreamTokenGetProgramOptions((uint64_t)Stream);
  *a5 = PPStreamTokenIsTrivialPassThrough((uint64_t)Stream);
  return Stream;
}

char *gleFStateProgram_AddPPStreamOperation(uint64_t *a1, uint64_t a2)
{
  return PPStreamAddOperation(*a1, a2, 0);
}

uint64_t *gleFStateProgram_Start(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  BOOL v4 = (*result & 0x20000000000) == 0 && gEnablePrecision != 0;
  *(unsigned char *)(a2 + 251) = v4;
  if ((v2 & 0xFF00) != 0)
  {
    unint64_t v5 = *((unsigned __int8 *)result + 1);
    float v6 = 0.0;
    uint64_t v7 = 1;
    do
    {
      if ((v5 >> (v7 - 1)))
      {
        unint64_t v8 = result[v7];
        if ((v8 & 0x70000000) == 0x50000000)
        {
          float v9 = v6;
          switch((v8 >> 21) & 0xF)
          {
            case 0u:
            case 1u:
            case 2u:
              float v9 = v6 + 1.0;
              break;
            case 3u:
            case 8u:
            case 9u:
            case 0xAu:
              float v9 = v6 + 2.0;
              break;
            case 4u:
              float v9 = (float)(v6 + 1.0) + (float)(v6 + 1.0);
              break;
            case 5u:
            case 6u:
              float v9 = (float)(v6 + 1.0) * 12.0;
              break;
            default:
              break;
          }
          switch((v8 >> 50) & 0xF)
          {
            case 0uLL:
            case 1uLL:
            case 2uLL:
              float v6 = v6 + 1.0;
              break;
            case 3uLL:
            case 8uLL:
            case 9uLL:
            case 0xAuLL:
              float v6 = v6 + 2.0;
              break;
            case 4uLL:
              float v6 = (float)(v6 + 1.0) + (float)(v6 + 1.0);
              break;
            case 5uLL:
            case 6uLL:
              float v6 = (float)(v6 + 1.0) * 12.0;
              break;
            default:
              break;
          }
          float v10 = (float)v9;
          float v11 = (float)v6;
          if (v10 >= v11) {
            float v11 = v10;
          }
          unsigned int v12 = (v8 >> 25) & 3;
          float v13 = v11 + v11;
          if (v12 == 2) {
            float v14 = v11 * 4.0;
          }
          else {
            float v14 = v11 + v11;
          }
          if (v12 == 1) {
            float v14 = v11;
          }
          float v15 = (float)v14;
          uint64_t v16 = (v8 >> 54) & 3;
          if (v16 == 2) {
            float v13 = v11 * 4.0;
          }
          if (v16 != 1) {
            float v11 = v13;
          }
          float v6 = (float)v11;
          if (v15 >= v6) {
            float v6 = v15;
          }
        }
        else
        {
          float v6 = v6 + 1.0;
        }
      }
    }
    while (v5 >> v7++);
    if (v6 > 48.0) {
      *(unsigned char *)(a2 + 251) = 0;
    }
  }
  return result;
}

uint64_t gleFStateProgram_Core(uint64_t result, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)result;
  uint64_t v4 = *(void *)result;
  if ((*(void *)result & 0x20000) != 0)
  {
    uint64_t v33 = 0;
    uint64_t v34 = (_WORD *)(a2 + 172);
    do
    {
      if (((unint64_t)*v3 >> 8 >> v33))
      {
        memset((char *)&v452[1] + 8, 0, 56);
        if (*(unsigned char *)(a2 + 251)) {
          uint64_t v35 = 0x3100180000;
        }
        else {
          uint64_t v35 = 0x3100080000;
        }
        *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v35 | 1;
        *(_DWORD *)(a2 + 16) = 1;
        uint64_t v36 = (unsigned __int16)*(v34 - 68);
        if (v36 == 0xFFFF)
        {
          uint64_t v37 = *(__int16 *)(a2 + 240);
          uint64_t v36 = *(unsigned __int16 *)(a2 + 240);
          *(v34 - 68) = v37;
          *(_WORD *)(a2 + 4 * v37 + 22) = v33 + 4;
          *(_WORD *)(a2 + 240) = v37 + 1;
        }
        *(void *)&v452[1] = (v36 << 48) | 0x19C800;
        uint64_t v38 = (unsigned __int16)*v34;
        if (v38 == 0xFFFF)
        {
          uint64_t v39 = *(__int16 *)(a2 + 244);
          uint64_t v38 = *(unsigned __int16 *)(a2 + 244);
          *uint64_t v34 = v39;
          *(_WORD *)(a2 + 4 * v39 + 174) = v33;
          *(_WORD *)(a2 + 244) = v39 + 1;
        }
        *((void *)&v452[0] + 1) = ((v38 << 48) | 0x72679000) + 0x2000;
        uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      }
      ++v33;
      v34 += 2;
    }
    while (v33 != 8);
    goto LABEL_135;
  }
  if ((v4 & 0x40000) == 0)
  {
    if ((v4 & 0x80000) == 0)
    {
      unsigned int v5 = BYTE1(v4);
      if (!BYTE1(v4)) {
        goto LABEL_135;
      }
      unsigned int v6 = (v4 >> 8) & 0x7F;
      if (!v6)
      {
        unsigned int v32 = 7;
        goto LABEL_210;
      }
      int v7 = 128;
      uint64_t v8 = 8;
      unsigned int v9 = v5;
      while (1)
      {
        unsigned int v10 = v9;
        unsigned int v9 = v6;
        if ((v10 & v7) == 0) {
          goto LABEL_51;
        }
        unint64_t v11 = v3[v8];
        uint64_t v12 = (v11 >> 28) & 7;
        if (v12 == 5) {
          break;
        }
        if (v12 == 3)
        {
          uint64_t v13 = v11 & 0x3000000000000000;
          uint64_t v14 = v11 & 0x3800000000000000;
          BOOL v15 = v13 == 0x1000000000000000 || v14 == 0x2800000000000000;
          if (v15) {
            goto LABEL_52;
          }
        }
LABEL_51:
        int v7 = 1 << (v8 - 2);
        unsigned int v6 = v9 & ~v7;
        --v8;
        if (!v6) {
          goto LABEL_52;
        }
      }
      unsigned int v16 = v11 & 0x1F;
      unsigned int v17 = (v11 >> 5) & 0x1F;
      BOOL v18 = v16 == 3 || v17 == 3;
      unsigned int v19 = (v11 >> 10) & 0x1F;
      BOOL v20 = v18 || v19 == 3;
      uint64_t v21 = HIDWORD(v11) & 0x1F;
      BOOL v22 = v20 || v21 == 3;
      uint64_t result = (v11 >> 37) & 0x1F;
      BOOL v23 = v22 || result == 3;
      uint64_t v24 = (v11 >> 42) & 0x1F;
      if (v23
        || v24 > 5
        || result > 5
        || v21 > 5
        || v19 > 5
        || v17 > 5
        || v16 > 5
        || v24 == 3)
      {
        goto LABEL_51;
      }
LABEL_52:
      unsigned int v32 = v8 - 1;
      if ((v32 & 0x80000000) != 0) {
        goto LABEL_135;
      }
LABEL_210:
      uint64_t v136 = v32;
      uint64_t v137 = 4 * v32 + 84;
      while (2)
      {
        uint64_t v138 = v136 + 1;
        unsigned int v139 = v5 >> (v136 + 1);
        if (((v5 >> v136) & 1) == 0)
        {
LABEL_734:
          v137 += 4;
          uint64_t v136 = v138;
          if (!v139) {
            goto LABEL_135;
          }
          continue;
        }
        break;
      }
      long long v140 = &v3[v136];
      unint64_t v141 = v140[1];
      unint64_t v142 = (v141 >> 59) & 7;
      uint64_t v143 = (v141 >> 28) & 7;
      if (v143 == 1)
      {
        BOOL v145 = v142 < 4;
        if (!v139) {
          goto LABEL_225;
        }
      }
      else if (v143 == 3)
      {
        BOOL v145 = (v141 & 0x3000000000000000) == 0x1000000000000000 || v142 == 5;
        if (!v139)
        {
LABEL_225:
          if ((*(unsigned char *)v3 & 0x48) != 0) {
            goto LABEL_226;
          }
          *(unsigned char *)(a2 + 248) = 1;
          *(unsigned char *)(a2 + 250) = 0;
          if (!v145)
          {
LABEL_234:
            unsigned int v444 = v5 >> (v136 + 1);
            uint64_t v150 = *(unsigned __int16 *)(a2 + 210);
            if (v150 == 0xFFFF)
            {
              uint64_t v150 = *(unsigned __int16 *)(a2 + 246);
              *(_WORD *)(a2 + 210) = v150;
              *(_WORD *)(a2 + 246) = v150 + 1;
            }
            gleStateProgram_TextureSampleOp(v3, a2, (v150 << 48) | 0x72679000, v136);
            if (v143 != 5)
            {
              switch(v142)
              {
                case 0uLL:
                  uint64_t v154 = &gleStateProgram_ApplyFuncsA;
                  break;
                case 1uLL:
                  uint64_t v154 = &gleStateProgram_ApplyFuncsL;
                  break;
                case 2uLL:
                  uint64_t v154 = &gleStateProgram_ApplyFuncsLA;
                  break;
                case 3uLL:
                  uint64_t v154 = &gleStateProgram_ApplyFuncsI;
                  break;
                case 4uLL:
                  uint64_t v154 = &gleStateProgram_ApplyFuncsRGB;
                  break;
                default:
                  uint64_t v154 = &gleStateProgram_ApplyFuncsRGBA;
                  break;
              }
              uint64_t result = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))v154[v143])(v3, a2, v136);
LABEL_732:
              unsigned int v139 = v444;
LABEL_733:
              *(_WORD *)(a2 + 249) = 257;
              goto LABEL_734;
            }
            long long v151 = 0uLL;
            memset(v452, 0, 80);
            unint64_t v152 = v140[1];
            BOOL v153 = (((v152 >> 50) ^ (v152 >> 21)) & 0xF) != 0
                || (((v152 >> 54) ^ (v152 >> 25)) & 3) != 0;
            int v155 = v152 & 0x1F;
            BOOL v439 = v153;
            switch(v152 & 0x1F)
            {
              case 0uLL:
                uint64_t v156 = *(unsigned __int16 *)(a2 + 210);
                unint64_t v157 = 1689664;
                if (v156 == 0xFFFF)
                {
                  uint64_t v156 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 210) = v156;
                  goto LABEL_260;
                }
                goto LABEL_269;
              case 1uLL:
                uint64_t v156 = *(unsigned __int16 *)(a2 + v137);
                unint64_t v157 = 1689728;
                if (v156 == 0xFFFF)
                {
                  uint64_t v159 = *(__int16 *)(a2 + 242);
                  uint64_t v156 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + v137) = v159;
                  *(_WORD *)(a2 + 4 * v159 + 86) = v136;
                  goto LABEL_268;
                }
                goto LABEL_269;
              case 2uLL:
                goto LABEL_261;
              case 3uLL:
                if (*(unsigned char *)(a2 + 249))
                {
                  uint64_t v156 = *(unsigned __int16 *)(a2 + 208);
                  unint64_t v157 = 1689664;
                  if (v156 == 0xFFFF)
                  {
                    uint64_t v156 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 208) = v156;
LABEL_260:
                    *(_WORD *)(a2 + 246) = v156 + 1;
                    unint64_t v157 = 1689664;
                  }
                }
                else
                {
LABEL_261:
                  uint64_t v156 = *(unsigned __int16 *)(a2 + 24);
                  unint64_t v157 = 1689600;
                  if (v156 == 0xFFFF)
                  {
                    uint64_t v160 = *(__int16 *)(a2 + 240);
                    uint64_t v156 = *(unsigned __int16 *)(a2 + 240);
                    *(_WORD *)(a2 + 24) = v160;
                    *(_WORD *)(a2 + 4 * v160 + 22) = 1;
                    *(_WORD *)(a2 + 240) = v160 + 1;
                  }
                }
LABEL_269:
                unint64_t v162 = v157 | (v156 << 48);
                switch((*((_DWORD *)v140 + 2) >> 15) & 3)
                {
                  case 1:
                    long long v450 = v151;
                    long long v451 = v151;
                    long long v449 = v151;
                    uint64_t v163 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v163 = 0x3100080000;
                    }
                    uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v163;
                    *(_DWORD *)(a2 + 16) = 2;
                    uint64_t v164 = *(unsigned __int16 *)(a2 + 160);
                    if (v164 == 0xFFFF)
                    {
                      uint64_t v165 = *(__int16 *)(a2 + 242);
                      uint64_t v164 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v165;
                      *(_WORD *)(a2 + 4 * v165 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v165 + 1;
                    }
                    uint64_t v447 = (v164 << 48) | 0x80;
                    unint64_t v448 = v162 & 0xFFFF0000000180C0 | (((v157 >> 15) & 3) << 13) | (((v157 >> 15) & 3) << 11) | (((v157 >> 15) & 3) << 9);
                    goto LABEL_281;
                  case 2:
                    break;
                  case 3:
                    long long v450 = v151;
                    long long v451 = v151;
                    long long v449 = v151;
                    uint64_t v166 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v166 = 0x3100080000;
                    }
                    uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v166;
                    *(_DWORD *)(a2 + 16) = 2;
                    uint64_t v167 = *(unsigned __int16 *)(a2 + 160);
                    if (v167 == 0xFFFF)
                    {
                      uint64_t v168 = *(__int16 *)(a2 + 242);
                      uint64_t v167 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v168;
                      *(_WORD *)(a2 + 4 * v168 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v168 + 1;
                    }
                    uint64_t v447 = (v167 << 48) | 0x80;
                    unint64_t v448 = v162;
LABEL_281:
                    uint64_t v169 = *(unsigned __int16 *)(a2 + 212);
                    if (v169 == 0xFFFF)
                    {
                      uint64_t v169 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 212) = v169;
                      *(_WORD *)(a2 + 246) = v169 + 1;
                    }
                    uint64_t v446 = (v169 << 48) | 0x72679000;
                    (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                    uint64_t v170 = *(unsigned __int16 *)(a2 + 212);
                    if (v170 == 0xFFFF)
                    {
                      uint64_t v170 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 212) = v170;
                      *(_WORD *)(a2 + 246) = v170 + 1;
                    }
                    unint64_t v162 = (v170 << 48) | 0x19C840;
                    long long v151 = 0uLL;
                    break;
                  default:
                    unint64_t v162 = v157 & 0xFFFF0000000180C0 | (v156 << 48) | (((v157 >> 15) & 3) << 13) | (((v157 >> 15) & 3) << 11) | (((v157 >> 15) & 3) << 9);
                    break;
                }
                uint64_t v171 = v140[1];
                if ((v171 & 0x1E00000) == 0xE00000)
                {
                  unint64_t v172 = 0;
                }
                else
                {
                  unsigned int v173 = (v171 >> 5) & 0x1F;
                  switch(v173)
                  {
                    case 0u:
                      uint64_t v174 = *(unsigned __int16 *)(a2 + 210);
                      unint64_t v175 = 1689664;
                      if (v174 == 0xFFFF)
                      {
                        uint64_t v174 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 210) = v174;
                        goto LABEL_300;
                      }
                      goto LABEL_309;
                    case 1u:
                      uint64_t v174 = *(unsigned __int16 *)(a2 + v137);
                      unint64_t v175 = 1689728;
                      if (v174 == 0xFFFF)
                      {
                        uint64_t v178 = *(__int16 *)(a2 + 242);
                        uint64_t v174 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + v137) = v178;
                        *(_WORD *)(a2 + 4 * v178 + 86) = v136;
                        goto LABEL_308;
                      }
                      goto LABEL_309;
                    case 2u:
                      goto LABEL_301;
                    case 3u:
                      if (*(unsigned char *)(a2 + 249))
                      {
                        uint64_t v174 = *(unsigned __int16 *)(a2 + 208);
                        unint64_t v175 = 1689664;
                        if (v174 == 0xFFFF)
                        {
                          uint64_t v174 = *(unsigned __int16 *)(a2 + 246);
                          *(_WORD *)(a2 + 208) = v174;
LABEL_300:
                          *(_WORD *)(a2 + 246) = v174 + 1;
                          unint64_t v175 = 1689664;
                        }
                      }
                      else
                      {
LABEL_301:
                        uint64_t v174 = *(unsigned __int16 *)(a2 + 24);
                        unint64_t v175 = 1689600;
                        if (v174 == 0xFFFF)
                        {
                          uint64_t v179 = *(__int16 *)(a2 + 240);
                          uint64_t v174 = *(unsigned __int16 *)(a2 + 240);
                          *(_WORD *)(a2 + 24) = v179;
                          *(_WORD *)(a2 + 4 * v179 + 22) = 1;
                          *(_WORD *)(a2 + 240) = v179 + 1;
                        }
                      }
LABEL_309:
                      unint64_t v172 = v175 | (v174 << 48);
                      switch((*((_DWORD *)v140 + 2) >> 17) & 3)
                      {
                        case 1:
                          long long v450 = v151;
                          long long v451 = v151;
                          long long v449 = v151;
                          uint64_t v181 = 0x3100180000;
                          if (!*(unsigned char *)(a2 + 251)) {
                            uint64_t v181 = 0x3100080000;
                          }
                          uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v181;
                          *(_DWORD *)(a2 + 16) = 2;
                          uint64_t v182 = *(unsigned __int16 *)(a2 + 160);
                          if (v182 == 0xFFFF)
                          {
                            uint64_t v183 = *(__int16 *)(a2 + 242);
                            uint64_t v182 = *(unsigned __int16 *)(a2 + 242);
                            *(_WORD *)(a2 + 160) = v183;
                            *(_WORD *)(a2 + 4 * v183 + 86) = 19;
                            *(_WORD *)(a2 + 242) = v183 + 1;
                          }
                          unint64_t v184 = v162;
                          uint64_t v447 = (v182 << 48) | 0x80;
                          unint64_t v448 = v172 & 0xFFFF0000000180C0 | (((v175 >> 15) & 3) << 13) | (((v175 >> 15) & 3) << 11) | (((v175 >> 15) & 3) << 9);
                          goto LABEL_321;
                        case 2:
                          goto LABEL_326;
                        case 3:
                          long long v450 = v151;
                          long long v451 = v151;
                          long long v449 = v151;
                          uint64_t v185 = 0x3100180000;
                          if (!*(unsigned char *)(a2 + 251)) {
                            uint64_t v185 = 0x3100080000;
                          }
                          uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v185;
                          *(_DWORD *)(a2 + 16) = 2;
                          uint64_t v186 = *(unsigned __int16 *)(a2 + 160);
                          if (v186 == 0xFFFF)
                          {
                            uint64_t v187 = *(__int16 *)(a2 + 242);
                            uint64_t v186 = *(unsigned __int16 *)(a2 + 242);
                            *(_WORD *)(a2 + 160) = v187;
                            *(_WORD *)(a2 + 4 * v187 + 86) = 19;
                            *(_WORD *)(a2 + 242) = v187 + 1;
                          }
                          unint64_t v184 = v162;
                          uint64_t v447 = (v186 << 48) | 0x80;
                          unint64_t v448 = v172;
LABEL_321:
                          uint64_t v188 = *(unsigned __int16 *)(a2 + 214);
                          if (v188 == 0xFFFF)
                          {
                            uint64_t v188 = *(unsigned __int16 *)(a2 + 246);
                            *(_WORD *)(a2 + 214) = v188;
                            *(_WORD *)(a2 + 246) = v188 + 1;
                          }
                          uint64_t v446 = (v188 << 48) | 0x72679000;
                          (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                          uint64_t v189 = *(unsigned __int16 *)(a2 + 214);
                          if (v189 == 0xFFFF)
                          {
                            uint64_t v189 = *(unsigned __int16 *)(a2 + 246);
                            *(_WORD *)(a2 + 214) = v189;
                            *(_WORD *)(a2 + 246) = v189 + 1;
                          }
                          unint64_t v172 = (v189 << 48) | 0x19C840;
                          long long v151 = 0uLL;
                          unint64_t v162 = v184;
                          break;
                        default:
                          unint64_t v172 = v175 & 0xFFFF0000000180C0 | (v174 << 48) | (((v175 >> 15) & 3) << 13) | (((v175 >> 15) & 3) << 11) | (((v175 >> 15) & 3) << 9);
                          break;
                      }
                      break;
                    case 4u:
                      uint64_t v174 = *(unsigned __int16 *)(a2 + 160);
                      if (v174 == 0xFFFF)
                      {
                        uint64_t v180 = *(__int16 *)(a2 + 242);
                        uint64_t v174 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 160) = v180;
                        *(_WORD *)(a2 + 4 * v180 + 86) = 19;
                        *(_WORD *)(a2 + 242) = v180 + 1;
                      }
                      unint64_t v175 = 128;
                      goto LABEL_309;
                    case 5u:
                      uint64_t v174 = *(unsigned __int16 *)(a2 + 164);
                      unint64_t v175 = 1689728;
                      if (v174 == 0xFFFF)
                      {
                        uint64_t v178 = *(__int16 *)(a2 + 242);
                        uint64_t v174 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 164) = v178;
                        *(_WORD *)(a2 + 4 * v178 + 86) = 20;
LABEL_308:
                        *(_WORD *)(a2 + 242) = v178 + 1;
                      }
                      goto LABEL_309;
                    default:
                      unint64_t v176 = v162;
                      uint64_t v177 = *(unsigned __int16 *)(a2 + 224);
                      if (v177 == 0xFFFF)
                      {
                        uint64_t v177 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 224) = v177;
                        *(_WORD *)(a2 + 246) = v177 + 1;
                      }
                      gleStateProgram_TextureSampleOp(v3, a2, (v177 << 48) | 0x72679000, v173 - 6);
                      uint64_t v174 = *(unsigned __int16 *)(a2 + 224);
                      unint64_t v175 = 1689664;
                      long long v151 = 0uLL;
                      unint64_t v162 = v176;
                      if (v174 != 0xFFFF) {
                        goto LABEL_309;
                      }
                      uint64_t v174 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 224) = v174;
                      goto LABEL_300;
                  }
                }
LABEL_326:
                unint64_t v190 = v140[1];
                unsigned int v191 = (v190 >> 21) & 0xF;
                uint64_t v441 = v172;
                int v192 = 0;
                unint64_t v193 = 0;
                BOOL v194 = 0;
                int v442 = 1;
                switch(v191)
                {
                  case 0u:
                    goto LABEL_328;
                  case 1u:
                  case 2u:
                  case 3u:
                  case 5u:
                    unsigned int v191 = 1;
LABEL_328:
                    if (v439
                      || ((BYTE4(v190) ^ v190) & 0x1F) != 0
                      || (((v190 >> 37) ^ (v190 >> 5)) & 0x1F) != 0
                      || (unsigned int v195 = (v190 >> 15) & 3, v196 = (v190 >> 47) & 1, v195 != v196)
                      && v195 != (v196 | 2))
                    {
                      unint64_t v193 = 0;
                      BOOL v194 = 1;
                    }
                    else
                    {
                      unsigned int v310 = (v190 >> 17) & 3;
                      uint64_t v311 = HIWORD(v190) & 1;
                      unint64_t v193 = 0;
                      BOOL v194 = v310 != v311 && v310 != (v311 | 2);
                    }
                    int v442 = v191;
                    goto LABEL_391;
                  case 4u:
                    goto LABEL_336;
                  case 6u:
                    goto LABEL_391;
                  case 8u:
                  case 9u:
                  case 0xAu:
                    int v192 = 1;
LABEL_336:
                    unsigned int v197 = (v190 >> 10) & 0x1F;
                    switch(v197)
                    {
                      case 0u:
                        uint64_t v198 = *(unsigned __int16 *)(a2 + 210);
                        unint64_t v199 = 1689664;
                        if (v198 == 0xFFFF)
                        {
                          uint64_t v198 = *(unsigned __int16 *)(a2 + 246);
                          *(_WORD *)(a2 + 210) = v198;
                          goto LABEL_351;
                        }
                        goto LABEL_360;
                      case 1u:
                        uint64_t v198 = *(unsigned __int16 *)(a2 + v137);
                        unint64_t v199 = 1689728;
                        if (v198 == 0xFFFF)
                        {
                          uint64_t v202 = *(__int16 *)(a2 + 242);
                          uint64_t v198 = *(unsigned __int16 *)(a2 + 242);
                          *(_WORD *)(a2 + v137) = v202;
                          *(_WORD *)(a2 + 4 * v202 + 86) = v136;
                          goto LABEL_359;
                        }
                        goto LABEL_360;
                      case 2u:
                        goto LABEL_352;
                      case 3u:
                        if (*(unsigned char *)(a2 + 249))
                        {
                          uint64_t v198 = *(unsigned __int16 *)(a2 + 208);
                          unint64_t v199 = 1689664;
                          if (v198 == 0xFFFF)
                          {
                            uint64_t v198 = *(unsigned __int16 *)(a2 + 246);
                            *(_WORD *)(a2 + 208) = v198;
LABEL_351:
                            *(_WORD *)(a2 + 246) = v198 + 1;
                            unint64_t v199 = 1689664;
                          }
                        }
                        else
                        {
LABEL_352:
                          uint64_t v198 = *(unsigned __int16 *)(a2 + 24);
                          unint64_t v199 = 1689600;
                          if (v198 == 0xFFFF)
                          {
                            uint64_t v203 = *(__int16 *)(a2 + 240);
                            uint64_t v198 = *(unsigned __int16 *)(a2 + 240);
                            *(_WORD *)(a2 + 24) = v203;
                            *(_WORD *)(a2 + 4 * v203 + 22) = 1;
                            *(_WORD *)(a2 + 240) = v203 + 1;
                          }
                        }
LABEL_360:
                        unint64_t v193 = v199 | (v198 << 48);
                        switch((*((_DWORD *)v140 + 2) >> 19) & 3)
                        {
                          case 1:
                            long long v450 = v151;
                            long long v451 = v151;
                            long long v449 = v151;
                            uint64_t v205 = 0x3100180000;
                            if (!*(unsigned char *)(a2 + 251)) {
                              uint64_t v205 = 0x3100080000;
                            }
                            uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v205;
                            *(_DWORD *)(a2 + 16) = 2;
                            uint64_t v206 = *(unsigned __int16 *)(a2 + 160);
                            if (v206 == 0xFFFF)
                            {
                              uint64_t v207 = *(__int16 *)(a2 + 242);
                              uint64_t v206 = *(unsigned __int16 *)(a2 + 242);
                              *(_WORD *)(a2 + 160) = v207;
                              *(_WORD *)(a2 + 4 * v207 + 86) = 19;
                              *(_WORD *)(a2 + 242) = v207 + 1;
                            }
                            unint64_t v443 = v162;
                            uint64_t v447 = (v206 << 48) | 0x80;
                            unint64_t v448 = v193 & 0xFFFF0000000180C0 | (((v199 >> 15) & 3) << 13) | (((v199 >> 15) & 3) << 11) | (((v199 >> 15) & 3) << 9);
                            uint64_t v208 = *(unsigned __int16 *)(a2 + 216);
                            if (v208 == 0xFFFF)
                            {
                              uint64_t v208 = *(unsigned __int16 *)(a2 + 246);
                              *(_WORD *)(a2 + 216) = v208;
                              *(_WORD *)(a2 + 246) = v208 + 1;
                            }
                            uint64_t v446 = (v208 << 48) | 0x72679000;
                            (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                            uint64_t v209 = *(unsigned __int16 *)(a2 + 216);
                            if (v209 == 0xFFFF)
                            {
                              uint64_t v209 = *(unsigned __int16 *)(a2 + 246);
                              *(_WORD *)(a2 + 216) = v209;
                              *(_WORD *)(a2 + 246) = v209 + 1;
                            }
                            unint64_t v193 = (v209 << 48) | 0x19C840;
                            goto LABEL_380;
                          case 2:
                            break;
                          case 3:
                            long long v450 = v151;
                            long long v451 = v151;
                            long long v449 = v151;
                            uint64_t v210 = 0x3100180000;
                            if (!*(unsigned char *)(a2 + 251)) {
                              uint64_t v210 = 0x3100080000;
                            }
                            uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v210;
                            *(_DWORD *)(a2 + 16) = 2;
                            uint64_t v211 = *(unsigned __int16 *)(a2 + 160);
                            if (v211 == 0xFFFF)
                            {
                              uint64_t v212 = *(__int16 *)(a2 + 242);
                              uint64_t v211 = *(unsigned __int16 *)(a2 + 242);
                              *(_WORD *)(a2 + 160) = v212;
                              *(_WORD *)(a2 + 4 * v212 + 86) = 19;
                              *(_WORD *)(a2 + 242) = v212 + 1;
                            }
                            unint64_t v443 = v162;
                            uint64_t v447 = (v211 << 48) | 0x80;
                            unint64_t v448 = v193;
                            uint64_t v213 = *(unsigned __int16 *)(a2 + 216);
                            if (v213 == 0xFFFF)
                            {
                              uint64_t v213 = *(unsigned __int16 *)(a2 + 246);
                              *(_WORD *)(a2 + 216) = v213;
                              *(_WORD *)(a2 + 246) = v213 + 1;
                            }
                            uint64_t v446 = (v213 << 48) | 0x72679000;
                            (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                            uint64_t v214 = *(unsigned __int16 *)(a2 + 216);
                            if (v214 == 0xFFFF)
                            {
                              uint64_t v214 = *(unsigned __int16 *)(a2 + 246);
                              *(_WORD *)(a2 + 216) = v214;
                              *(_WORD *)(a2 + 246) = v214 + 1;
                            }
                            unint64_t v193 = (v214 << 48) | 0x19C840;
LABEL_380:
                            long long v151 = 0uLL;
                            unint64_t v172 = v441;
                            unint64_t v162 = v443;
                            break;
                          default:
                            unint64_t v193 = v199 & 0xFFFF0000000180C0 | (v198 << 48) | (((v199 >> 15) & 3) << 13) | (((v199 >> 15) & 3) << 11) | (((v199 >> 15) & 3) << 9);
                            break;
                        }
                        unint64_t v190 = v140[1];
                        if (!v439
                          && ((BYTE4(v190) ^ v190) & 0x1F) == 0
                          && (((v190 >> 37) ^ (v190 >> 5)) & 0x1F) == 0
                          && (((v190 >> 42) ^ (v190 >> 10)) & 0x1F) == 0
                          && ((unsigned int v215 = (v190 >> 15) & 3, v216 = (v190 >> 47) & 1, v215 == v216)
                           || v215 == (v216 | 2))
                          && ((unsigned int v217 = (v190 >> 17) & 3, v218 = HIWORD(v190) & 1, v217 == v218)
                           || v217 == (v218 | 2)))
                        {
                          unsigned int v418 = (v190 >> 19) & 3;
                          uint64_t v419 = (v190 >> 49) & 1;
                          BOOL v194 = v418 != v419 && v418 != (v419 | 2);
                        }
                        else
                        {
                          BOOL v194 = 1;
                        }
                        int v442 = v192;
                        break;
                      case 4u:
                        uint64_t v198 = *(unsigned __int16 *)(a2 + 160);
                        if (v198 == 0xFFFF)
                        {
                          uint64_t v204 = *(__int16 *)(a2 + 242);
                          uint64_t v198 = *(unsigned __int16 *)(a2 + 242);
                          *(_WORD *)(a2 + 160) = v204;
                          *(_WORD *)(a2 + 4 * v204 + 86) = 19;
                          *(_WORD *)(a2 + 242) = v204 + 1;
                        }
                        unint64_t v199 = 128;
                        goto LABEL_360;
                      case 5u:
                        uint64_t v198 = *(unsigned __int16 *)(a2 + 164);
                        unint64_t v199 = 1689728;
                        if (v198 == 0xFFFF)
                        {
                          uint64_t v202 = *(__int16 *)(a2 + 242);
                          uint64_t v198 = *(unsigned __int16 *)(a2 + 242);
                          *(_WORD *)(a2 + 164) = v202;
                          *(_WORD *)(a2 + 4 * v202 + 86) = 20;
LABEL_359:
                          *(_WORD *)(a2 + 242) = v202 + 1;
                        }
                        goto LABEL_360;
                      default:
                        unint64_t v200 = v162;
                        uint64_t v201 = *(unsigned __int16 *)(a2 + 226);
                        if (v201 == 0xFFFF)
                        {
                          uint64_t v201 = *(unsigned __int16 *)(a2 + 246);
                          *(_WORD *)(a2 + 226) = v201;
                          *(_WORD *)(a2 + 246) = v201 + 1;
                        }
                        gleStateProgram_TextureSampleOp(v3, a2, (v201 << 48) | 0x72679000, v197 - 6);
                        uint64_t v198 = *(unsigned __int16 *)(a2 + 226);
                        unint64_t v199 = 1689664;
                        long long v151 = 0uLL;
                        unint64_t v172 = v441;
                        unint64_t v162 = v200;
                        if (v198 != 0xFFFF) {
                          goto LABEL_360;
                        }
                        uint64_t v198 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 226) = v198;
                        goto LABEL_351;
                    }
                    break;
                  default:
                    if (v439 || ((BYTE4(v190) ^ v190) & 0x1F) != 0)
                    {
                      unint64_t v193 = 0;
                      int v442 = 0;
                      BOOL v194 = 1;
                    }
                    else
                    {
                      unsigned int v308 = (v190 >> 15) & 3;
                      uint64_t v309 = (v190 >> 47) & 1;
                      unint64_t v193 = 0;
                      if (v308 == v309)
                      {
                        BOOL v194 = 0;
                        int v442 = 0;
                      }
                      else
                      {
                        int v442 = 0;
                        BOOL v194 = v308 != (v309 | 2);
                      }
                    }
                    break;
                }
                break;
              case 4uLL:
                uint64_t v156 = *(unsigned __int16 *)(a2 + 160);
                if (v156 == 0xFFFF)
                {
                  uint64_t v161 = *(__int16 *)(a2 + 242);
                  uint64_t v156 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 160) = v161;
                  *(_WORD *)(a2 + 4 * v161 + 86) = 19;
                  *(_WORD *)(a2 + 242) = v161 + 1;
                }
                unint64_t v157 = 128;
                goto LABEL_269;
              case 5uLL:
                uint64_t v156 = *(unsigned __int16 *)(a2 + 164);
                unint64_t v157 = 1689728;
                if (v156 == 0xFFFF)
                {
                  uint64_t v159 = *(__int16 *)(a2 + 242);
                  uint64_t v156 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 164) = v159;
                  *(_WORD *)(a2 + 4 * v159 + 86) = 20;
LABEL_268:
                  *(_WORD *)(a2 + 242) = v159 + 1;
                }
                goto LABEL_269;
              default:
                uint64_t v158 = *(unsigned __int16 *)(a2 + 222);
                if (v158 == 0xFFFF)
                {
                  uint64_t v158 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 222) = v158;
                  *(_WORD *)(a2 + 246) = v158 + 1;
                }
                gleStateProgram_TextureSampleOp(v3, a2, (v158 << 48) | 0x72679000, v155 - 6);
                uint64_t v156 = *(unsigned __int16 *)(a2 + 222);
                unint64_t v157 = 1689664;
                long long v151 = 0uLL;
                if (v156 != 0xFFFF) {
                  goto LABEL_269;
                }
                uint64_t v156 = *(unsigned __int16 *)(a2 + 246);
                *(_WORD *)(a2 + 222) = v156;
                goto LABEL_260;
            }
LABEL_391:
            unint64_t v440 = v193;
            BOOL v438 = v194;
            switch((v190 >> 21) & 0xF)
            {
              case 0u:
                v452[3] = v151;
                v452[4] = v151;
                v452[2] = v151;
                uint64_t v231 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                uint64_t v232 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v232 = 0x3100080000;
                }
                uint64_t v233 = 2178;
                goto LABEL_413;
              case 1u:
                v452[3] = v151;
                v452[4] = v151;
                v452[2] = v151;
                uint64_t v231 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                uint64_t v232 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v232 = 0x3100080000;
                }
                uint64_t v233 = 1986;
                goto LABEL_413;
              case 2u:
                v452[3] = v151;
                v452[4] = v151;
                v452[2] = v151;
                uint64_t v231 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                uint64_t v232 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v232 = 0x3100080000;
                }
                uint64_t v233 = 2050;
LABEL_413:
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = v231 | v233 | v232;
                *(void *)&v452[1] = v162;
                *((void *)&v452[1] + 1) = v172;
                goto LABEL_452;
              case 3u:
                v452[3] = v151;
                v452[4] = v151;
                v452[2] = v151;
                uint64_t v234 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v234 = 0x3100080000;
                }
                uint64_t v235 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x7C2 | v234;
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = v235;
                *(void *)&v452[1] = v162;
                *((void *)&v452[1] + 1) = v172;
                uint64_t v236 = *(unsigned __int16 *)(a2 + 220);
                if (v236 == 0xFFFF)
                {
                  uint64_t v236 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 220) = v236;
                  *(_WORD *)(a2 + 246) = v236 + 1;
                }
                *((void *)&v452[0] + 1) = (v236 << 48) | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                memset(&v452[2], 0, 48);
                uint64_t v237 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v237 = 0x3100080000;
                }
                *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v237;
                *(_DWORD *)(a2 + 16) = 2;
                uint64_t v238 = *(unsigned __int16 *)(a2 + 220);
                if (v238 == 0xFFFF)
                {
                  uint64_t v238 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 220) = v238;
                  *(_WORD *)(a2 + 246) = v238 + 1;
                }
                *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v238 << 48) | 0x19C840;
                uint64_t v239 = *(unsigned __int16 *)(a2 + 160);
                if (v239 == 0xFFFF)
                {
                  uint64_t v240 = *(__int16 *)(a2 + 242);
                  uint64_t v239 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 160) = v240;
                  *(_WORD *)(a2 + 4 * v240 + 86) = 19;
                  *(_WORD *)(a2 + 242) = v240 + 1;
                }
                *((void *)&v452[1] + 1) = (v239 << 48) | 0xAA80;
                if (v238 == 0xFFFF) {
                  goto LABEL_475;
                }
                goto LABEL_476;
              case 4u:
                *((void *)&v452[4] + 1) = 0;
                *(_OWORD *)((char *)&v452[2] + 8) = v151;
                *(_OWORD *)((char *)&v452[3] + 8) = v151;
                uint64_t v241 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v241 = 0x3100080000;
                }
                uint64_t v242 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03 | v241;
                *(_DWORD *)(a2 + 16) = 3;
                *(void *)&v452[0] = v242;
                *(void *)&v452[1] = v193;
                *((void *)&v452[1] + 1) = v162;
                goto LABEL_435;
              case 5u:
              case 6u:
                v452[3] = v151;
                v452[4] = v151;
                v452[2] = v151;
                char v219 = *(_DWORD *)(a2 + 16);
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = (8 * (v219 & 7)) | 0x3100080802;
                *(void *)&v452[1] = v162;
                uint64_t v220 = *(unsigned __int16 *)(a2 + 168);
                if (v220 == 0xFFFF)
                {
                  uint64_t v221 = *(__int16 *)(a2 + 242);
                  uint64_t v220 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 168) = v221;
                  *(_WORD *)(a2 + 4 * v221 + 86) = 21;
                  *(_WORD *)(a2 + 242) = v221 + 1;
                }
                *((void *)&v452[1] + 1) = (v220 << 48) | 0xAA80;
                uint64_t v222 = *(unsigned __int16 *)(a2 + 228);
                if (v222 == 0xFFFF)
                {
                  uint64_t v222 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 228) = v222;
                  *(_WORD *)(a2 + 246) = v222 + 1;
                }
                *((void *)&v452[0] + 1) = (v222 << 48) | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                memset(&v452[2], 0, 48);
                char v223 = *(_DWORD *)(a2 + 16);
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = (8 * (v223 & 7)) | 0x3100080802;
                *(void *)&v452[1] = v441;
                uint64_t v224 = *(unsigned __int16 *)(a2 + 168);
                if (v224 == 0xFFFF)
                {
                  uint64_t v225 = *(__int16 *)(a2 + 242);
                  uint64_t v224 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 168) = v225;
                  *(_WORD *)(a2 + 4 * v225 + 86) = 21;
                  *(_WORD *)(a2 + 242) = v225 + 1;
                }
                *((void *)&v452[1] + 1) = (v224 << 48) | 0xAA80;
                uint64_t v226 = *(unsigned __int16 *)(a2 + 230);
                if (v226 == 0xFFFF)
                {
                  uint64_t v226 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 230) = v226;
                  *(_WORD *)(a2 + 246) = v226 + 1;
                }
                *((void *)&v452[0] + 1) = (v226 << 48) | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                memset((char *)v452 + 8, 0, 72);
                char v227 = *(_DWORD *)(a2 + 16);
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = (8 * (v227 & 7)) | 0x3100080A02;
                uint64_t v228 = *(unsigned __int16 *)(a2 + 230);
                if (v228 == 0xFFFF)
                {
                  uint64_t v228 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 230) = v228;
                  *(_WORD *)(a2 + 246) = v228 + 1;
                }
                *(void *)&v452[1] = (v228 << 48) | 0x19C840;
                uint64_t v229 = *(unsigned __int16 *)(a2 + 228);
                if (v229 == 0xFFFF)
                {
                  uint64_t v260 = *(unsigned __int16 *)(a2 + 246);
                  int v261 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 228) = v260;
                  int v262 = v261 + 1;
                  *(_WORD *)(a2 + 246) = v262;
                  *((void *)&v452[1] + 1) = ((unint64_t)(unsigned __int16)v260 << 48) | 0x19C840;
                  if ((v262 & 0x10000) != 0)
                  {
                    uint64_t v230 = 0;
                    *(_WORD *)(a2 + 228) = v262;
                    *(_WORD *)(a2 + 246) = 1;
                  }
                  else
                  {
                    uint64_t v230 = v260 << 48;
                  }
                }
                else
                {
                  uint64_t v230 = v229 << 48;
                  *((void *)&v452[1] + 1) = ((unint64_t)(unsigned __int16)v229 << 48) | 0x19C840;
                }
                *((void *)&v452[0] + 1) = v230 | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                uint64_t v263 = *(void *)a2;
                memset(&v452[2], 0, 48);
                char v264 = *(_DWORD *)(a2 + 16);
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = (8 * (v264 & 7)) | 0x3100080882;
                uint64_t v265 = *(unsigned __int16 *)(a2 + 228);
                if (v263)
                {
                  if (v265 == 0xFFFF)
                  {
                    uint64_t v265 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 228) = v265;
                    *(_WORD *)(a2 + 246) = v265 + 1;
                  }
                  *(void *)&v452[1] = (v265 << 48) | 0x19C840;
                  uint64_t v266 = *(unsigned __int16 *)(a2 + 168);
                  if (v266 == 0xFFFF)
                  {
                    uint64_t v267 = *(__int16 *)(a2 + 242);
                    uint64_t v266 = *(unsigned __int16 *)(a2 + 242);
                    *(_WORD *)(a2 + 168) = v267;
                    *(_WORD *)(a2 + 4 * v267 + 86) = 21;
                    *(_WORD *)(a2 + 242) = v267 + 1;
                  }
                  *((void *)&v452[1] + 1) = (v266 << 48) | 0x15480;
                }
                else
                {
                  if (v265 == 0xFFFF)
                  {
                    uint64_t v265 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 228) = v265;
                    *(_WORD *)(a2 + 246) = v265 + 1;
                  }
                  *(void *)&v452[1] = (v265 << 48) | 0x19C840;
                  uint64_t v268 = *(unsigned __int16 *)(a2 + 168);
                  if (v268 == 0xFFFF)
                  {
                    uint64_t v269 = *(__int16 *)(a2 + 242);
                    uint64_t v268 = *(unsigned __int16 *)(a2 + 242);
                    *(_WORD *)(a2 + 168) = v269;
                    *(_WORD *)(a2 + 4 * v269 + 86) = 21;
                    *(_WORD *)(a2 + 242) = v269 + 1;
                  }
                  *((void *)&v452[1] + 1) = (v268 << 48) | 0x15480;
                  uint64_t v270 = *(unsigned __int16 *)(a2 + 232);
                  if (v270 == 0xFFFF)
                  {
                    uint64_t v270 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 232) = v270;
                    *(_WORD *)(a2 + 246) = v270 + 1;
                  }
                  *((void *)&v452[0] + 1) = (v270 << 48) | 0x72679000;
                  (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                  memset((char *)&v452[1] + 8, 0, 56);
                  uint64_t v271 = 0x3100180000;
                  if (!*(unsigned char *)(a2 + 251)) {
                    uint64_t v271 = 0x3100080000;
                  }
                  *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x1B41 | v271;
                  *(_DWORD *)(a2 + 16) = 1;
                  uint64_t v272 = *(unsigned __int16 *)(a2 + 232);
                  if (v272 == 0xFFFF)
                  {
                    uint64_t v272 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 232) = v272;
                    *(_WORD *)(a2 + 246) = v272 + 1;
                  }
                  *(void *)&v452[1] = (v272 << 48) | 0x19C840;
                }
                uint64_t v238 = *(unsigned __int16 *)(a2 + 220);
                goto LABEL_474;
              case 8u:
                *((void *)&v452[4] + 1) = 0;
                *(_OWORD *)((char *)&v452[2] + 8) = v151;
                *(_OWORD *)((char *)&v452[3] + 8) = v151;
                uint64_t v245 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v245 = 0x3100080000;
                }
                uint64_t v246 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xFC3 | v245;
                *(_DWORD *)(a2 + 16) = 3;
                *(void *)&v452[0] = v246;
                *(void *)&v452[1] = v162;
                *((void *)&v452[1] + 1) = v193;
LABEL_435:
                *(void *)&v452[2] = v172;
                goto LABEL_452;
              case 9u:
                v452[3] = v151;
                v452[4] = v151;
                v452[2] = v151;
                uint64_t v247 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v247 = 0x3100080000;
                }
                uint64_t v248 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v247;
                *(_DWORD *)(a2 + 16) = 2;
                *(void *)&v452[0] = v248;
                *(void *)&v452[1] = v172;
                uint64_t v249 = *(unsigned __int16 *)(a2 + 160);
                if (v249 == 0xFFFF)
                {
                  uint64_t v250 = *(__int16 *)(a2 + 242);
                  uint64_t v249 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 160) = v250;
                  *(_WORD *)(a2 + 4 * v250 + 86) = 19;
                  *(_WORD *)(a2 + 242) = v250 + 1;
                }
                unint64_t v251 = v162;
                *((void *)&v452[1] + 1) = (v249 << 48) | 0xAA80;
                uint64_t v252 = *(unsigned __int16 *)(a2 + 214);
                if (v252 == 0xFFFF)
                {
                  uint64_t v252 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 214) = v252;
                  *(_WORD *)(a2 + 246) = v252 + 1;
                }
                *((void *)&v452[0] + 1) = (v252 << 48) | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                memset((char *)&v452[2] + 8, 0, 40);
                uint64_t v253 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v253 = 0x3100080000;
                }
                uint64_t v254 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xFC3 | v253;
                *(_DWORD *)(a2 + 16) = 3;
                *(void *)&v452[0] = v254;
                *(void *)&v452[1] = v251;
                *((void *)&v452[1] + 1) = v440;
                uint64_t v255 = *(unsigned __int16 *)(a2 + 214);
                if (v255 == 0xFFFF)
                {
                  uint64_t v255 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 214) = v255;
                  *(_WORD *)(a2 + 246) = v255 + 1;
                }
                *(void *)&v452[2] = (v255 << 48) | 0x19C840;
                uint64_t v256 = *(unsigned __int16 *)(a2 + 220);
                if (v256 == 0xFFFF)
                {
                  uint64_t v256 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 220) = v256;
                  *(_WORD *)(a2 + 246) = v256 + 1;
                }
                uint64_t v257 = v256 << 48;
                goto LABEL_477;
              case 0xAu:
                *((void *)&v452[4] + 1) = 0;
                *(_OWORD *)((char *)&v452[2] + 8) = v151;
                *(_OWORD *)((char *)&v452[3] + 8) = v151;
                uint64_t v258 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v258 = 0x3100080000;
                }
                uint64_t v259 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xFC3 | v258;
                *(_DWORD *)(a2 + 16) = 3;
                *(void *)&v452[0] = v259;
                *(void *)&v452[1] = v162;
                *((void *)&v452[1] + 1) = v193;
                *(void *)&v452[2] = v172 | 0x10;
                goto LABEL_452;
              default:
                *((void *)&v452[4] + 1) = 0;
                *(_OWORD *)((char *)&v452[2] + 8) = v151;
                *(_OWORD *)((char *)&v452[3] + 8) = v151;
                *(_OWORD *)((char *)&v452[1] + 8) = v151;
                uint64_t v243 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v243 = 0x3100080000;
                }
                uint64_t v244 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v243 | 1;
                *(_DWORD *)(a2 + 16) = 1;
                *(void *)&v452[0] = v244;
                *(void *)&v452[1] = v162;
LABEL_452:
                uint64_t v238 = *(unsigned __int16 *)(a2 + 220);
LABEL_474:
                if (v238 == 0xFFFF)
                {
LABEL_475:
                  uint64_t v238 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 220) = v238;
                  *(_WORD *)(a2 + 246) = v238 + 1;
                }
LABEL_476:
                uint64_t v257 = v238 << 48;
LABEL_477:
                *((void *)&v452[0] + 1) = v257 | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                int v273 = (*((_DWORD *)v140 + 2) >> 25) & 3;
                if (v273 == 1) {
                  goto LABEL_501;
                }
                BOOL v15 = v273 == 2;
                uint64_t v274 = 2;
                if (v15)
                {
                  if (gEnablePrecision)
                  {
                    uint64_t v275 = *(void *)a2;
                    *(_OWORD *)((char *)v452 + 8) = 0uLL;
                    *(_OWORD *)((char *)&v452[1] + 8) = 0uLL;
                    *(_OWORD *)((char *)&v452[2] + 8) = 0uLL;
                    *(_OWORD *)((char *)&v452[3] + 8) = 0uLL;
                    *((void *)&v452[4] + 1) = 0;
                    uint64_t v276 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v276 = 0x3100080000;
                    }
                    uint64_t v277 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v276;
                    if (v275)
                    {
                      *(_DWORD *)(a2 + 16) = 2;
                      *(void *)&v452[0] = v277 & 0x31000808BALL;
                      uint64_t v278 = *(unsigned __int16 *)(a2 + 168);
                      if (v278 == 0xFFFF)
                      {
                        uint64_t v279 = *(__int16 *)(a2 + 242);
                        uint64_t v278 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 168) = v279;
                        uint64_t v280 = a2 + 4 * v279;
                        __int16 v281 = 21;
                        goto LABEL_493;
                      }
                    }
                    else
                    {
                      *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v276;
                      *(_DWORD *)(a2 + 16) = 2;
                      uint64_t v278 = *(unsigned __int16 *)(a2 + 160);
                      if (v278 == 0xFFFF)
                      {
                        uint64_t v279 = *(__int16 *)(a2 + 242);
                        uint64_t v278 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 160) = v279;
                        uint64_t v280 = a2 + 4 * v279;
                        __int16 v281 = 19;
LABEL_493:
                        *(_WORD *)(v280 + 86) = v281;
                        *(_WORD *)(a2 + 242) = v279 + 1;
                      }
                    }
                    uint64_t v285 = (v278 << 48) | 0x15480;
                    goto LABEL_495;
                  }
                }
                else
                {
                  uint64_t v274 = 3;
                }
                *((void *)&v452[4] + 1) = 0;
                *(_OWORD *)((char *)&v452[2] + 8) = 0uLL;
                *(_OWORD *)((char *)&v452[3] + 8) = 0uLL;
                *(_OWORD *)((char *)v452 + 8) = 0uLL;
                *(_OWORD *)((char *)&v452[1] + 8) = 0uLL;
                uint64_t v282 = 0x3100180000;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v282 = 0x3100080000;
                }
                *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v282;
                *(_DWORD *)(a2 + 16) = 2;
                uint64_t v283 = *(unsigned __int16 *)(a2 + 160);
                if (v283 == 0xFFFF)
                {
                  uint64_t v284 = *(__int16 *)(a2 + 242);
                  uint64_t v283 = *(unsigned __int16 *)(a2 + 242);
                  *(_WORD *)(a2 + 160) = v284;
                  *(_WORD *)(a2 + 4 * v284 + 86) = 19;
                  *(_WORD *)(a2 + 242) = v284 + 1;
                }
                uint64_t v285 = (v283 << 48) | (v274 << 9) | (v274 << 11) | (v274 << 13) | (v274 << 15) | 0x80;
LABEL_495:
                *((void *)&v452[1] + 1) = v285;
                uint64_t v286 = *(unsigned __int16 *)(a2 + 220);
                if (v286 == 0xFFFF)
                {
                  uint64_t v288 = *(unsigned __int16 *)(a2 + 246);
                  int v289 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 220) = v288;
                  int v290 = v289 + 1;
                  *(_WORD *)(a2 + 246) = v290;
                  *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v288 << 48) | 0x19C840;
                  if ((v290 & 0x10000) != 0)
                  {
                    uint64_t v287 = 0;
                    *(_WORD *)(a2 + 220) = v290;
                    *(_WORD *)(a2 + 246) = 1;
                  }
                  else
                  {
                    uint64_t v287 = v288 << 48;
                  }
                }
                else
                {
                  uint64_t v287 = v286 << 48;
                  *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v286 << 48) | 0x19C840;
                }
                *((void *)&v452[0] + 1) = v287 | 0x72679000;
                (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                int v442 = 1;
LABEL_501:
                long long v291 = 0uLL;
                if (!v438) {
                  goto LABEL_719;
                }
                int v292 = *((_DWORD *)v140 + 3) & 0x1F;
                switch(v292)
                {
                  case 0:
                    uint64_t v293 = *(unsigned __int16 *)(a2 + 210);
                    uint64_t v294 = v440;
                    if (v293 == 0xFFFF)
                    {
                      uint64_t v293 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 210) = v293;
                      *(_WORD *)(a2 + 246) = v293 + 1;
                    }
                    uint64_t v295 = 130624;
                    goto LABEL_524;
                  case 1:
                    uint64_t v299 = *(unsigned __int16 *)(a2 + v137);
                    uint64_t v294 = v440;
                    if (v299 == 0xFFFF)
                    {
                      uint64_t v300 = *(__int16 *)(a2 + 242);
                      uint64_t v299 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + v137) = v300;
                      *(_WORD *)(a2 + 4 * v300 + 86) = v136;
                      *(_WORD *)(a2 + 242) = v300 + 1;
                    }
                    uint64_t v301 = (v299 << 48) | 0x1FE40;
                    goto LABEL_528;
                  case 2:
                    uint64_t v293 = *(unsigned __int16 *)(a2 + 24);
                    uint64_t v294 = v440;
                    if (v293 == 0xFFFF)
                    {
                      uint64_t v302 = *(__int16 *)(a2 + 240);
                      uint64_t v293 = *(unsigned __int16 *)(a2 + 240);
                      *(_WORD *)(a2 + 24) = v302;
                      *(_WORD *)(a2 + 4 * v302 + 22) = 1;
                      *(_WORD *)(a2 + 240) = v302 + 1;
                    }
                    uint64_t v295 = 130560;
                    goto LABEL_524;
                  case 3:
                    uint64_t v294 = v440;
                    if (*(unsigned char *)(a2 + 249))
                    {
                      uint64_t v303 = *(unsigned __int16 *)(a2 + 208);
                      if (v303 == 0xFFFF)
                      {
                        uint64_t v303 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 208) = v303;
                        *(_WORD *)(a2 + 246) = v303 + 1;
                      }
                      uint64_t v304 = 64;
                    }
                    else
                    {
                      uint64_t v303 = *(unsigned __int16 *)(a2 + 24);
                      uint64_t v304 = 0;
                      if (v303 == 0xFFFF)
                      {
                        uint64_t v312 = *(__int16 *)(a2 + 240);
                        uint64_t v303 = *(unsigned __int16 *)(a2 + 240);
                        *(_WORD *)(a2 + 24) = v312;
                        *(_WORD *)(a2 + 4 * v312 + 22) = 1;
                        *(_WORD *)(a2 + 240) = v312 + 1;
                      }
                    }
                    uint64_t v298 = v304 | (v303 << 48) | 0x1FE00;
                    break;
                  case 4:
                    uint64_t v293 = *(unsigned __int16 *)(a2 + 160);
                    uint64_t v294 = v440;
                    if (v293 == 0xFFFF)
                    {
                      uint64_t v305 = *(__int16 *)(a2 + 242);
                      uint64_t v293 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v305;
                      *(_WORD *)(a2 + 4 * v305 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v305 + 1;
                    }
                    uint64_t v295 = 128;
LABEL_524:
                    uint64_t v298 = v295 | (v293 << 48);
                    break;
                  case 5:
                    uint64_t v306 = *(unsigned __int16 *)(a2 + 164);
                    uint64_t v294 = v440;
                    if (v306 == 0xFFFF)
                    {
                      uint64_t v307 = *(__int16 *)(a2 + 242);
                      uint64_t v306 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 164) = v307;
                      *(_WORD *)(a2 + 4 * v307 + 86) = 20;
                      *(_WORD *)(a2 + 242) = v307 + 1;
                    }
                    uint64_t v301 = (v306 << 48) | 0x19C840;
LABEL_528:
                    uint64_t v298 = v301 + 64;
                    break;
                  default:
                    uint64_t v296 = *(unsigned __int16 *)(a2 + 222);
                    if (v296 == 0xFFFF)
                    {
                      uint64_t v296 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 222) = v296;
                      *(_WORD *)(a2 + 246) = v296 + 1;
                    }
                    gleStateProgram_TextureSampleOp(v3, a2, (v296 << 48) | 0x72679000, v292 - 6);
                    uint64_t v297 = *(unsigned __int16 *)(a2 + 222);
                    if (v297 == 0xFFFF)
                    {
                      uint64_t v297 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 222) = v297;
                      *(_WORD *)(a2 + 246) = v297 + 1;
                    }
                    uint64_t v298 = (v297 << 48) | 0x1FE40;
                    long long v291 = 0uLL;
                    uint64_t v294 = v440;
                    break;
                }
                unint64_t v313 = v140[1];
                if ((v313 & 0x800000000000) != 0)
                {
                  long long v450 = v291;
                  long long v451 = v291;
                  long long v449 = v291;
                  uint64_t v314 = 0x3100180000;
                  if (!*(unsigned char *)(a2 + 251)) {
                    uint64_t v314 = 0x3100080000;
                  }
                  uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v314;
                  *(_DWORD *)(a2 + 16) = 2;
                  uint64_t v315 = *(unsigned __int16 *)(a2 + 160);
                  if (v315 == 0xFFFF)
                  {
                    uint64_t v316 = *(__int16 *)(a2 + 242);
                    uint64_t v315 = *(unsigned __int16 *)(a2 + 242);
                    *(_WORD *)(a2 + 160) = v316;
                    *(_WORD *)(a2 + 4 * v316 + 86) = 19;
                    *(_WORD *)(a2 + 242) = v316 + 1;
                  }
                  uint64_t v447 = (v315 << 48) | 0x80;
                  unint64_t v448 = v298;
                  uint64_t v317 = *(unsigned __int16 *)(a2 + 212);
                  if (v317 == 0xFFFF)
                  {
                    uint64_t v317 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 212) = v317;
                    *(_WORD *)(a2 + 246) = v317 + 1;
                  }
                  uint64_t v446 = (v317 << 48) | 0x72679000;
                  (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                  uint64_t v318 = *(unsigned __int16 *)(a2 + 212);
                  if (v318 == 0xFFFF)
                  {
                    uint64_t v318 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 212) = v318;
                    *(_WORD *)(a2 + 246) = v318 + 1;
                  }
                  uint64_t v298 = (v318 << 48) | 0x19C840;
                  unint64_t v313 = v140[1];
                  long long v291 = 0uLL;
                  uint64_t v294 = v440;
                }
                if ((v313 & 0x3C000000000000) != 0x1C000000000000)
                {
                  uint64_t v319 = (v313 >> 37) & 0x1F;
                  switch((int)v319)
                  {
                    case 0:
                      uint64_t v320 = *(unsigned __int16 *)(a2 + 210);
                      if (v320 == 0xFFFF)
                      {
                        uint64_t v320 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 210) = v320;
                        *(_WORD *)(a2 + 246) = v320 + 1;
                      }
                      uint64_t v321 = 130624;
                      goto LABEL_570;
                    case 1:
                      uint64_t v324 = *(unsigned __int16 *)(a2 + v137);
                      if (v324 == 0xFFFF)
                      {
                        uint64_t v325 = *(__int16 *)(a2 + 242);
                        uint64_t v324 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + v137) = v325;
                        *(_WORD *)(a2 + 4 * v325 + 86) = v136;
                        *(_WORD *)(a2 + 242) = v325 + 1;
                      }
                      uint64_t v326 = (v324 << 48) | 0x1FE40;
                      goto LABEL_574;
                    case 2:
                      uint64_t v320 = *(unsigned __int16 *)(a2 + 24);
                      if (v320 == 0xFFFF)
                      {
                        uint64_t v327 = *(__int16 *)(a2 + 240);
                        uint64_t v320 = *(unsigned __int16 *)(a2 + 240);
                        *(_WORD *)(a2 + 24) = v327;
                        *(_WORD *)(a2 + 4 * v327 + 22) = 1;
                        *(_WORD *)(a2 + 240) = v327 + 1;
                      }
                      uint64_t v321 = 130560;
                      goto LABEL_570;
                    case 3:
                      if (*(unsigned char *)(a2 + 249))
                      {
                        uint64_t v328 = *(unsigned __int16 *)(a2 + 208);
                        if (v328 == 0xFFFF)
                        {
                          uint64_t v328 = *(unsigned __int16 *)(a2 + 246);
                          *(_WORD *)(a2 + 208) = v328;
                          *(_WORD *)(a2 + 246) = v328 + 1;
                        }
                        uint64_t v329 = 64;
                      }
                      else
                      {
                        uint64_t v328 = *(unsigned __int16 *)(a2 + 24);
                        uint64_t v329 = 0;
                        if (v328 == 0xFFFF)
                        {
                          uint64_t v334 = *(__int16 *)(a2 + 240);
                          uint64_t v328 = *(unsigned __int16 *)(a2 + 240);
                          *(_WORD *)(a2 + 24) = v334;
                          *(_WORD *)(a2 + 4 * v334 + 22) = 1;
                          *(_WORD *)(a2 + 240) = v334 + 1;
                        }
                      }
                      uint64_t v331 = v329 | (v328 << 48) | 0x1FE00;
                      goto LABEL_581;
                    case 4:
                      uint64_t v320 = *(unsigned __int16 *)(a2 + 160);
                      if (v320 == 0xFFFF)
                      {
                        uint64_t v330 = *(__int16 *)(a2 + 242);
                        uint64_t v320 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 160) = v330;
                        *(_WORD *)(a2 + 4 * v330 + 86) = 19;
                        *(_WORD *)(a2 + 242) = v330 + 1;
                      }
                      uint64_t v321 = 128;
LABEL_570:
                      uint64_t v331 = v321 | (v320 << 48);
                      goto LABEL_581;
                    case 5:
                      uint64_t v332 = *(unsigned __int16 *)(a2 + 164);
                      if (v332 == 0xFFFF)
                      {
                        uint64_t v333 = *(__int16 *)(a2 + 242);
                        uint64_t v332 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 164) = v333;
                        *(_WORD *)(a2 + 4 * v333 + 86) = 20;
                        *(_WORD *)(a2 + 242) = v333 + 1;
                      }
                      uint64_t v326 = (v332 << 48) | 0x19C840;
LABEL_574:
                      uint64_t v331 = v326 + 64;
LABEL_581:
                      uint64_t v441 = v331;
                      break;
                    default:
                      uint64_t v322 = *(unsigned __int16 *)(a2 + 224);
                      if (v322 == 0xFFFF)
                      {
                        uint64_t v322 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 224) = v322;
                        *(_WORD *)(a2 + 246) = v322 + 1;
                      }
                      gleStateProgram_TextureSampleOp(v3, a2, (v322 << 48) | 0x72679000, v319 - 6);
                      uint64_t v323 = *(unsigned __int16 *)(a2 + 224);
                      if (v323 == 0xFFFF)
                      {
                        uint64_t v323 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 224) = v323;
                        *(_WORD *)(a2 + 246) = v323 + 1;
                      }
                      uint64_t v441 = (v323 << 48) | 0x1FE40;
                      long long v291 = 0uLL;
                      uint64_t v294 = v440;
                      break;
                  }
                  unint64_t v313 = v140[1];
                  if ((v313 & 0x1000000000000) != 0)
                  {
                    long long v450 = v291;
                    long long v451 = v291;
                    long long v449 = v291;
                    uint64_t v335 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v335 = 0x3100080000;
                    }
                    uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v335;
                    *(_DWORD *)(a2 + 16) = 2;
                    uint64_t v336 = *(unsigned __int16 *)(a2 + 160);
                    if (v336 == 0xFFFF)
                    {
                      uint64_t v337 = *(__int16 *)(a2 + 242);
                      uint64_t v336 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v337;
                      *(_WORD *)(a2 + 4 * v337 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v337 + 1;
                    }
                    uint64_t v447 = (v336 << 48) | 0x80;
                    unint64_t v448 = v441;
                    uint64_t v338 = *(unsigned __int16 *)(a2 + 214);
                    if (v338 == 0xFFFF)
                    {
                      uint64_t v338 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 214) = v338;
                      *(_WORD *)(a2 + 246) = v338 + 1;
                    }
                    uint64_t v446 = (v338 << 48) | 0x72679000;
                    (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                    uint64_t v339 = *(unsigned __int16 *)(a2 + 214);
                    if (v339 == 0xFFFF)
                    {
                      uint64_t v339 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 214) = v339;
                      *(_WORD *)(a2 + 246) = v339 + 1;
                    }
                    uint64_t v441 = (v339 << 48) | 0x19C840;
                    unint64_t v313 = v140[1];
                    long long v291 = 0uLL;
                    uint64_t v294 = v440;
                  }
                }
                uint64_t v340 = (v313 >> 50) & 0xF;
                if ((v340 - 1) < 3)
                {
                  int v442 = 1;
                }
                else
                {
                  if ((v340 - 8) >= 3)
                  {
                    if (v340 != 4) {
                      goto LABEL_634;
                    }
                  }
                  else
                  {
                    int v442 = 1;
                  }
                  uint64_t v341 = (v313 >> 42) & 0x1F;
                  switch((int)v341)
                  {
                    case 0:
                      uint64_t v342 = *(unsigned __int16 *)(a2 + 210);
                      if (v342 == 0xFFFF)
                      {
                        uint64_t v342 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 210) = v342;
                        *(_WORD *)(a2 + 246) = v342 + 1;
                      }
                      uint64_t v294 = (v342 << 48) | 0x1FE40;
                      break;
                    case 1:
                      uint64_t v345 = *(unsigned __int16 *)(a2 + v137);
                      if (v345 == 0xFFFF)
                      {
                        uint64_t v346 = *(__int16 *)(a2 + 242);
                        uint64_t v345 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + v137) = v346;
                        *(_WORD *)(a2 + 4 * v346 + 86) = v136;
                        *(_WORD *)(a2 + 242) = v346 + 1;
                      }
                      uint64_t v294 = ((v345 << 48) | 0x1FE40) + 64;
                      break;
                    case 2:
                      uint64_t v347 = *(unsigned __int16 *)(a2 + 24);
                      if (v347 == 0xFFFF)
                      {
                        uint64_t v348 = *(__int16 *)(a2 + 240);
                        uint64_t v347 = *(unsigned __int16 *)(a2 + 240);
                        *(_WORD *)(a2 + 24) = v348;
                        *(_WORD *)(a2 + 4 * v348 + 22) = 1;
                        *(_WORD *)(a2 + 240) = v348 + 1;
                      }
                      uint64_t v349 = 130560;
                      goto LABEL_619;
                    case 3:
                      if (*(unsigned char *)(a2 + 249))
                      {
                        uint64_t v350 = *(unsigned __int16 *)(a2 + 208);
                        if (v350 == 0xFFFF)
                        {
                          uint64_t v350 = *(unsigned __int16 *)(a2 + 246);
                          *(_WORD *)(a2 + 208) = v350;
                          *(_WORD *)(a2 + 246) = v350 + 1;
                        }
                        uint64_t v351 = 64;
                      }
                      else
                      {
                        uint64_t v350 = *(unsigned __int16 *)(a2 + 24);
                        uint64_t v351 = 0;
                        if (v350 == 0xFFFF)
                        {
                          uint64_t v417 = *(__int16 *)(a2 + 240);
                          uint64_t v350 = *(unsigned __int16 *)(a2 + 240);
                          *(_WORD *)(a2 + 24) = v417;
                          *(_WORD *)(a2 + 4 * v417 + 22) = 1;
                          *(_WORD *)(a2 + 240) = v417 + 1;
                        }
                      }
                      uint64_t v355 = v441;
                      uint64_t v294 = v351 | (v350 << 48) | 0x1FE00;
                      goto LABEL_624;
                    case 4:
                      uint64_t v347 = *(unsigned __int16 *)(a2 + 160);
                      if (v347 == 0xFFFF)
                      {
                        uint64_t v352 = *(__int16 *)(a2 + 242);
                        uint64_t v347 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 160) = v352;
                        *(_WORD *)(a2 + 4 * v352 + 86) = 19;
                        *(_WORD *)(a2 + 242) = v352 + 1;
                      }
                      uint64_t v349 = 128;
LABEL_619:
                      uint64_t v294 = v349 | (v347 << 48);
                      break;
                    case 5:
                      uint64_t v353 = *(unsigned __int16 *)(a2 + 164);
                      if (v353 == 0xFFFF)
                      {
                        uint64_t v354 = *(__int16 *)(a2 + 242);
                        uint64_t v353 = *(unsigned __int16 *)(a2 + 242);
                        *(_WORD *)(a2 + 164) = v354;
                        *(_WORD *)(a2 + 4 * v354 + 86) = 20;
                        *(_WORD *)(a2 + 242) = v354 + 1;
                      }
                      uint64_t v294 = ((v353 << 48) | 0x19C840) + 64;
                      break;
                    default:
                      uint64_t v343 = *(unsigned __int16 *)(a2 + 226);
                      if (v343 == 0xFFFF)
                      {
                        uint64_t v343 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 226) = v343;
                        *(_WORD *)(a2 + 246) = v343 + 1;
                      }
                      gleStateProgram_TextureSampleOp(v3, a2, (v343 << 48) | 0x72679000, v341 - 6);
                      uint64_t v344 = *(unsigned __int16 *)(a2 + 226);
                      if (v344 == 0xFFFF)
                      {
                        uint64_t v344 = *(unsigned __int16 *)(a2 + 246);
                        *(_WORD *)(a2 + 226) = v344;
                        *(_WORD *)(a2 + 246) = v344 + 1;
                      }
                      uint64_t v294 = (v344 << 48) | 0x1FE40;
                      long long v291 = 0uLL;
                      break;
                  }
                  uint64_t v355 = v441;
LABEL_624:
                  unint64_t v313 = v140[1];
                  if ((v313 & 0x2000000000000) == 0) {
                    goto LABEL_635;
                  }
                  long long v450 = v291;
                  long long v451 = v291;
                  long long v449 = v291;
                  uint64_t v356 = 0x3100180000;
                  if (!*(unsigned char *)(a2 + 251)) {
                    uint64_t v356 = 0x3100080000;
                  }
                  uint64_t v445 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v356;
                  *(_DWORD *)(a2 + 16) = 2;
                  uint64_t v357 = *(unsigned __int16 *)(a2 + 160);
                  if (v357 == 0xFFFF)
                  {
                    uint64_t v358 = *(__int16 *)(a2 + 242);
                    uint64_t v357 = *(unsigned __int16 *)(a2 + 242);
                    *(_WORD *)(a2 + 160) = v358;
                    *(_WORD *)(a2 + 4 * v358 + 86) = 19;
                    *(_WORD *)(a2 + 242) = v358 + 1;
                  }
                  uint64_t v447 = (v357 << 48) | 0x80;
                  unint64_t v448 = v294;
                  uint64_t v359 = *(unsigned __int16 *)(a2 + 216);
                  if (v359 == 0xFFFF)
                  {
                    uint64_t v359 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 216) = v359;
                    *(_WORD *)(a2 + 246) = v359 + 1;
                  }
                  uint64_t v446 = (v359 << 48) | 0x72679000;
                  (*(void (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v445);
                  uint64_t v360 = *(unsigned __int16 *)(a2 + 216);
                  if (v360 == 0xFFFF)
                  {
                    uint64_t v360 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 216) = v360;
                    *(_WORD *)(a2 + 246) = v360 + 1;
                  }
                  uint64_t v294 = (v360 << 48) | 0x19C840;
                  unint64_t v313 = v140[1];
                  long long v291 = 0uLL;
                }
LABEL_634:
                uint64_t v355 = v441;
LABEL_635:
                switch((v313 >> 50) & 0xF)
                {
                  case 0uLL:
                    v452[3] = v291;
                    v452[4] = v291;
                    v452[2] = v291;
                    uint64_t v361 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                    uint64_t v362 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v362 = 0x3100080000;
                    }
                    uint64_t v363 = 2178;
                    goto LABEL_645;
                  case 1uLL:
                    v452[3] = v291;
                    v452[4] = v291;
                    v452[2] = v291;
                    uint64_t v361 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                    uint64_t v362 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v362 = 0x3100080000;
                    }
                    uint64_t v363 = 1986;
                    goto LABEL_645;
                  case 2uLL:
                    v452[3] = v291;
                    v452[4] = v291;
                    v452[2] = v291;
                    uint64_t v361 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                    uint64_t v362 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v362 = 0x3100080000;
                    }
                    uint64_t v363 = 2050;
LABEL_645:
                    *(_DWORD *)(a2 + 16) = 2;
                    *(void *)&v452[0] = v361 | v363 | v362;
                    *(void *)&v452[1] = v298;
                    *((void *)&v452[1] + 1) = v355;
                    goto LABEL_683;
                  case 3uLL:
                    v452[3] = v291;
                    v452[4] = v291;
                    v452[2] = v291;
                    uint64_t v364 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                    uint64_t v365 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v365 = 0x3100080000;
                    }
                    *(_DWORD *)(a2 + 16) = 2;
                    *(void *)&v452[0] = v364 | 0x7C2 | v365;
                    *(void *)&v452[1] = v298;
                    *((void *)&v452[1] + 1) = v355;
                    uint64_t v366 = *(unsigned __int16 *)(a2 + 218);
                    if (v366 == 0xFFFF)
                    {
                      uint64_t v366 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 218) = v366;
                      *(_WORD *)(a2 + 246) = v366 + 1;
                    }
                    *((void *)&v452[0] + 1) = (v366 << 48) | 0x72679000;
                    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                    memset(&v452[2], 0, 48);
                    uint64_t v367 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v367 = 0x3100080000;
                    }
                    *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x802 | v367;
                    *(_DWORD *)(a2 + 16) = 2;
                    uint64_t v368 = *(unsigned __int16 *)(a2 + 218);
                    if (v368 == 0xFFFF)
                    {
                      uint64_t v368 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 218) = v368;
                      *(_WORD *)(a2 + 246) = v368 + 1;
                    }
                    *(void *)&v452[1] = (v368 << 48) | 0x19C840;
                    uint64_t v369 = *(unsigned __int16 *)(a2 + 160);
                    if (v369 == 0xFFFF)
                    {
                      uint64_t v370 = *(__int16 *)(a2 + 242);
                      uint64_t v369 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v370;
                      *(_WORD *)(a2 + 4 * v370 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v370 + 1;
                      uint64_t v368 = *(unsigned __int16 *)(a2 + 218);
                    }
                    *((void *)&v452[1] + 1) = (v369 << 48) | 0xAA80;
                    uint64_t v371 = v368;
                    if (v368 == 0xFFFF) {
                      goto LABEL_684;
                    }
                    goto LABEL_685;
                  case 4uLL:
                    *((void *)&v452[4] + 1) = 0;
                    *(_OWORD *)((char *)&v452[2] + 8) = v291;
                    *(_OWORD *)((char *)&v452[3] + 8) = v291;
                    uint64_t v372 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v372 = 0x3100080000;
                    }
                    uint64_t v373 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03 | v372;
                    *(_DWORD *)(a2 + 16) = 3;
                    *(void *)&v452[0] = v373;
                    *(void *)&v452[1] = v294;
                    *((void *)&v452[1] + 1) = v298;
                    goto LABEL_667;
                  case 8uLL:
                    *((void *)&v452[4] + 1) = 0;
                    *(_OWORD *)((char *)&v452[2] + 8) = v291;
                    *(_OWORD *)((char *)&v452[3] + 8) = v291;
                    uint64_t v376 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v376 = 0x3100080000;
                    }
                    uint64_t v377 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xFC3 | v376;
                    *(_DWORD *)(a2 + 16) = 3;
                    *(void *)&v452[0] = v377;
                    *(void *)&v452[1] = v298;
                    *((void *)&v452[1] + 1) = v294;
LABEL_667:
                    *(void *)&v452[2] = v355;
                    goto LABEL_683;
                  case 9uLL:
                    v452[3] = v291;
                    v452[4] = v291;
                    v452[2] = v291;
                    uint64_t v378 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                    uint64_t v379 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v379 = 0x3100080000;
                    }
                    *(_DWORD *)(a2 + 16) = 2;
                    *(void *)&v452[0] = v378 | 0x802 | v379;
                    *(void *)&v452[1] = v355;
                    uint64_t v380 = *(unsigned __int16 *)(a2 + 160);
                    if (v380 == 0xFFFF)
                    {
                      uint64_t v381 = *(__int16 *)(a2 + 242);
                      uint64_t v380 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v381;
                      *(_WORD *)(a2 + 4 * v381 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v381 + 1;
                    }
                    uint64_t v382 = v294;
                    *((void *)&v452[1] + 1) = (v380 << 48) | 0xAA80;
                    uint64_t v383 = *(unsigned __int16 *)(a2 + 214);
                    if (v383 == 0xFFFF)
                    {
                      uint64_t v383 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 214) = v383;
                      *(_WORD *)(a2 + 246) = v383 + 1;
                    }
                    *((void *)&v452[0] + 1) = (v383 << 48) | 0x72679000;
                    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                    memset((char *)&v452[2] + 8, 0, 40);
                    uint64_t v384 = 8 * (*(_DWORD *)(a2 + 16) & 7);
                    uint64_t v385 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v385 = 0x3100080000;
                    }
                    *(_DWORD *)(a2 + 16) = 3;
                    *(void *)&v452[0] = v384 | 0xFC3 | v385;
                    *(void *)&v452[1] = v298;
                    *((void *)&v452[1] + 1) = v382;
                    uint64_t v386 = *(unsigned __int16 *)(a2 + 214);
                    if (v386 == 0xFFFF)
                    {
                      uint64_t v386 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 214) = v386;
                      *(_WORD *)(a2 + 246) = v386 + 1;
                    }
                    *(void *)&v452[2] = (v386 << 48) | 0x19C840;
                    uint64_t v371 = *(unsigned __int16 *)(a2 + 218);
                    if (v371 == 0xFFFF) {
                      goto LABEL_684;
                    }
                    goto LABEL_685;
                  case 0xAuLL:
                    *((void *)&v452[4] + 1) = 0;
                    *(_OWORD *)((char *)&v452[2] + 8) = v291;
                    *(_OWORD *)((char *)&v452[3] + 8) = v291;
                    uint64_t v387 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v387 = 0x3100080000;
                    }
                    uint64_t v388 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xFC3 | v387;
                    *(_DWORD *)(a2 + 16) = 3;
                    *(void *)&v452[0] = v388;
                    *(void *)&v452[1] = v298;
                    *((void *)&v452[1] + 1) = v294;
                    *(void *)&v452[2] = v355 | 0x10;
                    goto LABEL_683;
                  default:
                    *((void *)&v452[4] + 1) = 0;
                    *(_OWORD *)((char *)&v452[2] + 8) = v291;
                    *(_OWORD *)((char *)&v452[3] + 8) = v291;
                    *(_OWORD *)((char *)&v452[1] + 8) = v291;
                    uint64_t v374 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v374 = 0x3100080000;
                    }
                    uint64_t v375 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v374 | 1;
                    *(_DWORD *)(a2 + 16) = 1;
                    *(void *)&v452[0] = v375;
                    *(void *)&v452[1] = v298;
LABEL_683:
                    uint64_t v371 = *(unsigned __int16 *)(a2 + 218);
                    if (v371 == 0xFFFF)
                    {
LABEL_684:
                      uint64_t v371 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 218) = v371;
                      *(_WORD *)(a2 + 246) = v371 + 1;
                    }
LABEL_685:
                    *((void *)&v452[0] + 1) = (v371 << 48) | 0x72679000;
                    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                    uint64_t v389 = ((unint64_t)v140[1] >> 54) & 3;
                    if (v389 == 1) {
                      goto LABEL_712;
                    }
                    BOOL v390 = v389 == 2;
                    if (v389 == 2) {
                      uint64_t v391 = 2;
                    }
                    else {
                      uint64_t v391 = 3;
                    }
                    if (v390 && gEnablePrecision)
                    {
                      uint64_t v392 = *(void *)a2;
                      *(_OWORD *)((char *)v452 + 8) = 0uLL;
                      *(_OWORD *)((char *)&v452[1] + 8) = 0uLL;
                      *(_OWORD *)((char *)&v452[2] + 8) = 0uLL;
                      *(_OWORD *)((char *)&v452[3] + 8) = 0uLL;
                      *((void *)&v452[4] + 1) = 0;
                      uint64_t v393 = 0x3100180000;
                      if (!*(unsigned char *)(a2 + 251)) {
                        uint64_t v393 = 0x3100080000;
                      }
                      uint64_t v394 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v393;
                      if (v392)
                      {
                        *(_DWORD *)(a2 + 16) = 2;
                        *(void *)&v452[0] = v394 & 0x31000808BALL;
                        uint64_t v395 = *(unsigned __int16 *)(a2 + 168);
                        if (v395 == 0xFFFF)
                        {
                          uint64_t v396 = *(__int16 *)(a2 + 242);
                          uint64_t v395 = *(unsigned __int16 *)(a2 + 242);
                          *(_WORD *)(a2 + 168) = v396;
                          uint64_t v397 = a2 + 4 * v396;
                          __int16 v398 = 21;
                          goto LABEL_704;
                        }
                      }
                      else
                      {
                        *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v393;
                        *(_DWORD *)(a2 + 16) = 2;
                        uint64_t v395 = *(unsigned __int16 *)(a2 + 160);
                        if (v395 == 0xFFFF)
                        {
                          uint64_t v396 = *(__int16 *)(a2 + 242);
                          uint64_t v395 = *(unsigned __int16 *)(a2 + 242);
                          *(_WORD *)(a2 + 160) = v396;
                          uint64_t v397 = a2 + 4 * v396;
                          __int16 v398 = 19;
LABEL_704:
                          *(_WORD *)(v397 + 86) = v398;
                          *(_WORD *)(a2 + 242) = v396 + 1;
                        }
                      }
                      uint64_t v402 = (v395 << 48) | 0x15480;
                      goto LABEL_706;
                    }
                    *((void *)&v452[4] + 1) = 0;
                    *(_OWORD *)((char *)&v452[2] + 8) = 0uLL;
                    *(_OWORD *)((char *)&v452[3] + 8) = 0uLL;
                    *(_OWORD *)((char *)v452 + 8) = 0uLL;
                    *(_OWORD *)((char *)&v452[1] + 8) = 0uLL;
                    uint64_t v399 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v399 = 0x3100080000;
                    }
                    *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v399;
                    *(_DWORD *)(a2 + 16) = 2;
                    uint64_t v400 = *(unsigned __int16 *)(a2 + 160);
                    if (v400 == 0xFFFF)
                    {
                      uint64_t v401 = *(__int16 *)(a2 + 242);
                      uint64_t v400 = *(unsigned __int16 *)(a2 + 242);
                      *(_WORD *)(a2 + 160) = v401;
                      *(_WORD *)(a2 + 4 * v401 + 86) = 19;
                      *(_WORD *)(a2 + 242) = v401 + 1;
                    }
                    uint64_t v402 = (v400 << 48) | (v391 << 9) | (v391 << 11) | (v391 << 13) | (v391 << 15) | 0x80;
LABEL_706:
                    *((void *)&v452[1] + 1) = v402;
                    uint64_t v403 = *(unsigned __int16 *)(a2 + 218);
                    if (v403 == 0xFFFF)
                    {
                      uint64_t v405 = *(unsigned __int16 *)(a2 + 246);
                      int v406 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 218) = v405;
                      int v407 = v406 + 1;
                      *(_WORD *)(a2 + 246) = v407;
                      *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v405 << 48) | 0x19C840;
                      if ((v407 & 0x10000) != 0)
                      {
                        uint64_t v404 = 0;
                        *(_WORD *)(a2 + 218) = v407;
                        *(_WORD *)(a2 + 246) = 1;
                      }
                      else
                      {
                        uint64_t v404 = v405 << 48;
                      }
                    }
                    else
                    {
                      uint64_t v404 = v403 << 48;
                      *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v403 << 48) | 0x19C840;
                    }
                    *((void *)&v452[0] + 1) = v404 | 0x72679000;
                    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                    int v442 = 1;
LABEL_712:
                    memset((char *)&v452[1] + 8, 0, 56);
                    uint64_t v408 = 0x3100180000;
                    if (!*(unsigned char *)(a2 + 251)) {
                      uint64_t v408 = 0x3100080000;
                    }
                    *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v408 | 1;
                    *(_DWORD *)(a2 + 16) = 1;
                    uint64_t v409 = *(unsigned __int16 *)(a2 + 218);
                    if (v409 == 0xFFFF)
                    {
                      uint64_t v409 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 218) = v409;
                      *(_WORD *)(a2 + 246) = v409 + 1;
                    }
                    *(void *)&v452[1] = (v409 << 48) | 0x19C840;
                    uint64_t v410 = *(unsigned __int16 *)(a2 + 220);
                    if (v410 == 0xFFFF)
                    {
                      uint64_t v410 = *(unsigned __int16 *)(a2 + 246);
                      *(_WORD *)(a2 + 220) = v410;
                      *(_WORD *)(a2 + 246) = v410 + 1;
                    }
                    *((void *)&v452[0] + 1) = (v410 << 48) | 0x72609000;
                    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                    long long v291 = 0uLL;
                    break;
                }
LABEL_719:
                *((void *)&v452[4] + 1) = 0;
                *(_OWORD *)((char *)&v452[2] + 8) = v291;
                *(_OWORD *)((char *)&v452[3] + 8) = v291;
                *(_OWORD *)((char *)v452 + 8) = v291;
                *(_OWORD *)((char *)&v452[1] + 8) = v291;
                uint64_t v411 = 1572864;
                if (!*(unsigned char *)(a2 + 251)) {
                  uint64_t v411 = 0x80000;
                }
                unint64_t v412 = v411 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7));
                *(void *)&v452[0] = v412 | 0x3100000001;
                *(_DWORD *)(a2 + 16) = 1;
                if ((*(unsigned char *)v3 & 0x10) != 0 && v442) {
                  *(void *)&v452[0] = v412 | 0x83100000001;
                }
                uint64_t v413 = *(unsigned __int16 *)(a2 + 220);
                if (v413 == 0xFFFF)
                {
                  uint64_t v413 = *(unsigned __int16 *)(a2 + 246);
                  *(_WORD *)(a2 + 220) = v413;
                  *(_WORD *)(a2 + 246) = v413 + 1;
                }
                *(void *)&v452[1] = (v413 << 48) | 0x19C840;
                if (*(unsigned char *)(a2 + 248))
                {
                  uint64_t v414 = *(unsigned __int16 *)(a2 + 172);
                  uint64_t v415 = 1919397888;
                  if (v414 == 0xFFFF)
                  {
                    uint64_t v416 = *(__int16 *)(a2 + 244);
                    uint64_t v414 = *(unsigned __int16 *)(a2 + 244);
                    *(_WORD *)(a2 + 172) = v416;
                    *(_WORD *)(a2 + 172 + 4 * v416 + 2) = 0;
                    *(_WORD *)(a2 + 244) = v416 + 1;
                  }
                }
                else
                {
                  uint64_t v414 = *(unsigned __int16 *)(a2 + 208);
                  uint64_t v415 = 1919389696;
                  if (v414 == 0xFFFF)
                  {
                    uint64_t v414 = *(unsigned __int16 *)(a2 + 246);
                    *(_WORD *)(a2 + 208) = v414;
                    *(_WORD *)(a2 + 246) = v414 + 1;
                    uint64_t v415 = 1919389696;
                  }
                }
                *((void *)&v452[0] + 1) = v415 | (v414 << 48);
                uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
                goto LABEL_732;
            }
          }
LABEL_227:
          if (*(unsigned char *)(a2 + 248))
          {
            uint64_t v146 = *(unsigned __int16 *)(a2 + 172);
            uint64_t v147 = 1919397888;
            unsigned int v148 = v5 >> (v136 + 1);
            if (v146 == 0xFFFF)
            {
              uint64_t v149 = *(__int16 *)(a2 + 244);
              uint64_t v146 = *(unsigned __int16 *)(a2 + 244);
              *(_WORD *)(a2 + 172) = v149;
              *(_WORD *)(a2 + 172 + 4 * v149 + 2) = 0;
              *(_WORD *)(a2 + 244) = v149 + 1;
            }
          }
          else
          {
            unsigned int v148 = v5 >> (v136 + 1);
            uint64_t v146 = *(unsigned __int16 *)(a2 + 208);
            uint64_t v147 = 1919389696;
            if (v146 == 0xFFFF)
            {
              uint64_t v146 = *(unsigned __int16 *)(a2 + 246);
              *(_WORD *)(a2 + 208) = v146;
              *(_WORD *)(a2 + 246) = v146 + 1;
              uint64_t v147 = 1919389696;
            }
          }
          uint64_t result = gleStateProgram_TextureSampleOp(v3, a2, v147 | (v146 << 48), v136);
          unsigned int v139 = v148;
          goto LABEL_733;
        }
      }
      else
      {
        BOOL v145 = 0;
        if (!v139) {
          goto LABEL_225;
        }
      }
LABEL_226:
      if (!v145) {
        goto LABEL_234;
      }
      goto LABEL_227;
    }
    *(unsigned char *)(a2 + 248) = 1;
    memset(&v452[2], 0, 48);
    uint64_t v41 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    if (*(unsigned char *)(a2 + 251)) {
      uint64_t v42 = 0x3100188000;
    }
    else {
      uint64_t v42 = 0x3100088000;
    }
    *(_DWORD *)(a2 + 16) = 2;
    *(void *)&v452[0] = v41 | 0x1082 | v42;
    uint64_t v43 = *(unsigned __int16 *)(a2 + 36);
    if (v43 == 0xFFFF)
    {
      uint64_t v44 = *(__int16 *)(a2 + 240);
      uint64_t v43 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 36) = v44;
      *(_WORD *)(a2 + 4 * v44 + 22) = 4;
      *(_WORD *)(a2 + 240) = v44 + 1;
    }
    *(void *)&v452[1] = (v43 << 48) | 0x19C800;
    *((void *)&v452[1] + 1) = 2;
    uint64_t v45 = *(unsigned __int16 *)(a2 + 210);
    if (v45 == 0xFFFF)
    {
      uint64_t v45 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 210) = v45;
      *(_WORD *)(a2 + 246) = v45 + 1;
    }
    *((void *)&v452[0] + 1) = (v45 << 48) | 0x72679000;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
    memset((char *)v452 + 8, 0, 72);
    if (*(unsigned char *)(a2 + 251)) {
      uint64_t v46 = 0x3000180000;
    }
    else {
      uint64_t v46 = 0x3000080000;
    }
    unint64_t v47 = v46 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x13C1;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v48 = *(unsigned __int16 *)(a2 + 210);
    if (v48 == 0xFFFF)
    {
      uint64_t v48 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 210) = v48;
      *(_WORD *)(a2 + 246) = v48 + 1;
    }
    *(void *)&v452[1] = (v48 << 48) | 0x1FE50;
    *(void *)&v452[0] = v47;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
    memset((char *)&v452[1] + 8, 0, 56);
    if (*(unsigned char *)(a2 + 251)) {
      uint64_t v49 = 0x3100180000;
    }
    else {
      uint64_t v49 = 0x3100080000;
    }
    *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v49 | 1;
    *(_DWORD *)(a2 + 16) = 1;
    uint64_t v50 = *(unsigned __int16 *)(a2 + 24);
    if (v50 == 0xFFFF)
    {
      uint64_t v51 = *(__int16 *)(a2 + 240);
      uint64_t v50 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v51;
      *(_WORD *)(a2 + 4 * v51 + 22) = 1;
      *(_WORD *)(a2 + 240) = v51 + 1;
    }
    *(void *)&v452[1] = (v50 << 48) | 0x19C800;
    goto LABEL_132;
  }
  *(unsigned char *)(a2 + 248) = 1;
  uint64_t v40 = *(void *)result;
  if ((*(void *)result & 0x100) != 0)
  {
    memset(&v452[2], 0, 48);
    uint64_t v52 = 8 * (*(_DWORD *)(a2 + 16) & 7);
    if (*(unsigned char *)(a2 + 251)) {
      uint64_t v53 = 0x3100188000;
    }
    else {
      uint64_t v53 = 0x3100088000;
    }
    *(_DWORD *)(a2 + 16) = 2;
    *(void *)&v452[0] = v52 | 0x1082 | v53;
    uint64_t v54 = *(unsigned __int16 *)(a2 + 36);
    if (v54 == 0xFFFF)
    {
      uint64_t v55 = *(__int16 *)(a2 + 240);
      uint64_t v54 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 36) = v55;
      *(_WORD *)(a2 + 4 * v55 + 22) = 4;
      *(_WORD *)(a2 + 240) = v55 + 1;
    }
    *(void *)&v452[1] = (v54 << 48) | 0x19C800;
    *((void *)&v452[1] + 1) = 2;
    if ((*(unsigned char *)(result + 1) & 0x10) != 0)
    {
      uint64_t v56 = *(unsigned __int16 *)(a2 + 210);
      uint64_t v57 = 1919389696;
      if (v56 == 0xFFFF)
      {
        uint64_t v56 = *(unsigned __int16 *)(a2 + 246);
        *(_WORD *)(a2 + 210) = v56;
        *(_WORD *)(a2 + 246) = v56 + 1;
        uint64_t v57 = 1919389696;
      }
    }
    else
    {
      uint64_t v56 = *(unsigned __int16 *)(a2 + 172);
      uint64_t v57 = 1919397888;
      if (v56 == 0xFFFF)
      {
        uint64_t v58 = *(__int16 *)(a2 + 244);
        uint64_t v56 = *(unsigned __int16 *)(a2 + 244);
        *(_WORD *)(a2 + 172) = v58;
        *(_WORD *)(a2 + 172 + 4 * v58 + 2) = 0;
        *(_WORD *)(a2 + 244) = v58 + 1;
      }
    }
    *((void *)&v452[0] + 1) = v57 | (v56 << 48);
    uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
    uint64_t v40 = *v3;
    if ((*v3 & 0x200) == 0)
    {
LABEL_68:
      if ((v40 & 0x400) == 0) {
        goto LABEL_69;
      }
LABEL_108:
      memset((char *)&v452[1] + 8, 0, 56);
      if (*(unsigned char *)(a2 + 251)) {
        uint64_t v66 = 0x3100180000;
      }
      else {
        uint64_t v66 = 0x3100080000;
      }
      *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v66 | 1;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v67 = *(unsigned __int16 *)(a2 + 24);
      if (v67 == 0xFFFF)
      {
        uint64_t v68 = *(__int16 *)(a2 + 240);
        uint64_t v67 = *(unsigned __int16 *)(a2 + 240);
        *(_WORD *)(a2 + 24) = v68;
        *(_WORD *)(a2 + 4 * v68 + 22) = 1;
        *(_WORD *)(a2 + 240) = v68 + 1;
      }
      *(void *)&v452[1] = (v67 << 48) | 0x19C800;
      uint64_t v69 = *(unsigned __int16 *)(a2 + 172);
      if (v69 == 0xFFFF)
      {
        uint64_t v70 = *(__int16 *)(a2 + 244);
        uint64_t v69 = *(unsigned __int16 *)(a2 + 244);
        *(_WORD *)(a2 + 172) = v70;
        *(_WORD *)(a2 + 172 + 4 * v70 + 2) = 0;
        *(_WORD *)(a2 + 244) = v70 + 1;
      }
      *((void *)&v452[0] + 1) = ((v69 << 48) | 0x72679000) + 0x2000;
      uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      uint64_t v40 = *v3;
      if ((*v3 & 0x800) == 0)
      {
LABEL_70:
        if ((v40 & 0x1000) == 0) {
          goto LABEL_135;
        }
        goto LABEL_124;
      }
      goto LABEL_116;
    }
  }
  else if ((v40 & 0x200) == 0)
  {
    goto LABEL_68;
  }
  memset(&v452[2], 0, 48);
  char v59 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 2;
  *(void *)&v452[0] = (8 * (v59 & 7)) | 0x3100089082;
  uint64_t v60 = *(unsigned __int16 *)(a2 + 36);
  if (v60 == 0xFFFF)
  {
    uint64_t v61 = *(__int16 *)(a2 + 240);
    uint64_t v60 = *(unsigned __int16 *)(a2 + 240);
    *(_WORD *)(a2 + 36) = v61;
    *(_WORD *)(a2 + 4 * v61 + 22) = 4;
    *(_WORD *)(a2 + 240) = v61 + 1;
  }
  uint64_t v62 = (v60 << 48) | 0x19C800;
  uint64_t v63 = 2;
  if ((*v3 & 0x400) == 0) {
    uint64_t v63 = 0x100000002;
  }
  *(void *)&v452[1] = v62;
  *((void *)&v452[1] + 1) = v63;
  uint64_t v64 = *(unsigned __int16 *)(a2 + 204);
  if (v64 == 0xFFFF)
  {
    uint64_t v65 = *(__int16 *)(a2 + 244);
    uint64_t v64 = *(unsigned __int16 *)(a2 + 244);
    *(_WORD *)(a2 + 204) = v65;
    *(_WORD *)(a2 + 4 * v65 + 174) = 8;
    *(_WORD *)(a2 + 244) = v65 + 1;
  }
  *((void *)&v452[0] + 1) = ((v64 << 48) | 0x72679000) + 0x2000;
  uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
  uint64_t v40 = *v3;
  if ((*v3 & 0x400) != 0) {
    goto LABEL_108;
  }
LABEL_69:
  if ((v40 & 0x800) == 0) {
    goto LABEL_70;
  }
LABEL_116:
  memset((char *)&v452[1] + 8, 0, 56);
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v71 = 0x3100180000;
  }
  else {
    uint64_t v71 = 0x3100080000;
  }
  *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | v71 | 1;
  *(_DWORD *)(a2 + 16) = 1;
  uint64_t v72 = *(unsigned __int16 *)(a2 + 40);
  if (v72 == 0xFFFF)
  {
    uint64_t v73 = *(__int16 *)(a2 + 240);
    uint64_t v72 = *(unsigned __int16 *)(a2 + 240);
    *(_WORD *)(a2 + 40) = v73;
    *(_WORD *)(a2 + 4 * v73 + 22) = 5;
    *(_WORD *)(a2 + 240) = v73 + 1;
  }
  *(void *)&v452[1] = (v72 << 48) | 0x19C800;
  uint64_t v74 = *(unsigned __int16 *)(a2 + 172);
  if (v74 == 0xFFFF)
  {
    uint64_t v75 = *(__int16 *)(a2 + 244);
    uint64_t v74 = *(unsigned __int16 *)(a2 + 244);
    *(_WORD *)(a2 + 172) = v75;
    *(_WORD *)(a2 + 172 + 4 * v75 + 2) = 0;
    *(_WORD *)(a2 + 244) = v75 + 1;
  }
  *((void *)&v452[0] + 1) = ((v74 << 48) | 0x72679000) + 0x2000;
  uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
  if ((*v3 & 0x1000) != 0)
  {
LABEL_124:
    memset(&v452[2], 0, 48);
    if (*(unsigned char *)(a2 + 251)) {
      uint64_t v76 = 0x3100180000;
    }
    else {
      uint64_t v76 = 0x3100080000;
    }
    *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882 | v76;
    *(_DWORD *)(a2 + 16) = 2;
    uint64_t v77 = *(unsigned __int16 *)(a2 + 40);
    if (v77 == 0xFFFF)
    {
      uint64_t v78 = *(__int16 *)(a2 + 240);
      uint64_t v77 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 40) = v78;
      *(_WORD *)(a2 + 4 * v78 + 22) = 5;
      *(_WORD *)(a2 + 240) = v78 + 1;
    }
    *(void *)&v452[1] = (v77 << 48) | 0x19C800;
    uint64_t v79 = *(unsigned __int16 *)(a2 + 210);
    if (v79 == 0xFFFF)
    {
      uint64_t v79 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 210) = v79;
      *(_WORD *)(a2 + 246) = v79 + 1;
    }
    *((void *)&v452[1] + 1) = (v79 << 48) | 0x19C840;
LABEL_132:
    uint64_t v80 = *(unsigned __int16 *)(a2 + 172);
    if (v80 == 0xFFFF)
    {
      uint64_t v81 = *(__int16 *)(a2 + 244);
      uint64_t v80 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v81;
      *(_WORD *)(a2 + 172 + 4 * v81 + 2) = 0;
      *(_WORD *)(a2 + 244) = v81 + 1;
    }
    *((void *)&v452[0] + 1) = ((v80 << 48) | 0x72679000) + 0x2000;
    uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
  }
LABEL_135:
  uint64_t v82 = *v3;
  if ((*v3 & 8) == 0)
  {
    if ((v82 & 0x40) == 0) {
      return result;
    }
LABEL_157:
    *(unsigned char *)(a2 + 248) = 1;
    *(unsigned char *)(a2 + 250) = 0;
    gleStateProgram_CheckDestInit(a2);
    uint64_t v93 = *v3;
    if ((*v3 & 0x80) != 0)
    {
LABEL_751:
      memset((char *)v452 + 8, 0, 72);
      if (*(unsigned char *)(a2 + 251)) {
        uint64_t v426 = 0x3100180000;
      }
      else {
        uint64_t v426 = 0x3100080000;
      }
      *(void *)&v452[0] = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03 | v426;
      *(_DWORD *)(a2 + 16) = 3;
      if ((*(unsigned char *)v3 & 0x80) != 0)
      {
        uint64_t v427 = *(unsigned __int16 *)(a2 + 32);
        if (v427 == 0xFFFF)
        {
          uint64_t v429 = *(__int16 *)(a2 + 240);
          uint64_t v427 = *(unsigned __int16 *)(a2 + 240);
          *(_WORD *)(a2 + 32) = v429;
          *(_WORD *)(a2 + 4 * v429 + 22) = 3;
          *(_WORD *)(a2 + 240) = v429 + 1;
        }
        uint64_t v428 = 43520;
      }
      else
      {
        uint64_t v427 = *(unsigned __int16 *)(a2 + 228);
        uint64_t v428 = 1689664;
        if (v427 == 0xFFFF)
        {
          uint64_t v427 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 228) = v427;
          *(_WORD *)(a2 + 246) = v427 + 1;
          uint64_t v428 = 1689664;
        }
      }
      *(void *)&v452[1] = v428 | (v427 << 48);
      if (*(unsigned char *)(a2 + 249))
      {
        uint64_t v430 = *(unsigned __int16 *)(a2 + 208);
        uint64_t v431 = 1689664;
        if (v430 == 0xFFFF)
        {
          uint64_t v430 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 208) = v430;
          *(_WORD *)(a2 + 246) = v430 + 1;
          uint64_t v431 = 1689664;
        }
      }
      else
      {
        uint64_t v430 = *(unsigned __int16 *)(a2 + 24);
        uint64_t v431 = 1689600;
        if (v430 == 0xFFFF)
        {
          uint64_t v432 = *(__int16 *)(a2 + 240);
          uint64_t v430 = *(unsigned __int16 *)(a2 + 240);
          *(_WORD *)(a2 + 24) = v432;
          *(_WORD *)(a2 + 4 * v432 + 22) = 1;
          *(_WORD *)(a2 + 240) = v432 + 1;
        }
      }
      *((void *)&v452[1] + 1) = v431 | (v430 << 48);
      uint64_t v433 = *(unsigned __int16 *)(a2 + 156);
      if (v433 == 0xFFFF)
      {
        uint64_t v434 = *(__int16 *)(a2 + 242);
        uint64_t v433 = *(unsigned __int16 *)(a2 + 242);
        *(_WORD *)(a2 + 156) = v434;
        *(_WORD *)(a2 + 4 * v434 + 86) = 18;
        *(_WORD *)(a2 + 242) = v434 + 1;
      }
      *(void *)&v452[2] = ((v433 << 48) | 0x19C840) + 64;
      if (*(unsigned char *)(a2 + 248))
      {
        uint64_t v435 = *(unsigned __int16 *)(a2 + 172);
        uint64_t v436 = 1918906368;
        if (v435 == 0xFFFF)
        {
          uint64_t v437 = *(__int16 *)(a2 + 244);
          uint64_t v435 = *(unsigned __int16 *)(a2 + 244);
          *(_WORD *)(a2 + 172) = v437;
          *(_WORD *)(a2 + 172 + 4 * v437 + 2) = 0;
          *(_WORD *)(a2 + 244) = v437 + 1;
        }
      }
      else
      {
        uint64_t v435 = *(unsigned __int16 *)(a2 + 208);
        uint64_t v436 = 1918898176;
        if (v435 == 0xFFFF)
        {
          uint64_t v435 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 208) = v435;
          *(_WORD *)(a2 + 246) = v435 + 1;
        }
      }
      *((void *)&v452[0] + 1) = v436 | (v435 << 48) | 0x70000;
      uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      *(_WORD *)(a2 + 249) = 257;
      return result;
    }
    unsigned int v94 = (v93 >> 1) & 3;
    if (v94 == 2)
    {
      if ((v93 & 0x20) == 0)
      {
        memset((char *)&v452[1] + 8, 0, 56);
        char v102 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = 1;
        *(void *)&v452[0] = (8 * (v102 & 7)) | 0x3100080081;
        uint64_t v103 = *(unsigned __int16 *)(a2 + 32);
        if (v103 == 0xFFFF)
        {
          uint64_t v104 = *(__int16 *)(a2 + 240);
          uint64_t v103 = *(unsigned __int16 *)(a2 + 240);
          *(_WORD *)(a2 + 32) = v104;
          *(_WORD *)(a2 + 4 * v104 + 22) = 3;
          *(_WORD *)(a2 + 240) = v104 + 1;
        }
        *(void *)&v452[1] = v103 << 48;
        uint64_t v105 = *(unsigned __int16 *)(a2 + 228);
        if (v105 == 0xFFFF)
        {
          uint64_t v105 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 228) = v105;
          *(_WORD *)(a2 + 246) = v105 + 1;
        }
        *((void *)&v452[0] + 1) = (v105 << 48) | 0x72679000;
        (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      }
      memset((char *)v452 + 8, 0, 72);
      char v106 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 2;
      *(void *)&v452[0] = (8 * (v106 & 7)) | 0x3100080882;
      if ((*(unsigned char *)v3 & 0x20) != 0)
      {
        uint64_t v127 = *(unsigned __int16 *)(a2 + 32);
        if (v127 == 0xFFFF)
        {
          uint64_t v128 = *(__int16 *)(a2 + 240);
          uint64_t v127 = *(unsigned __int16 *)(a2 + 240);
          *(_WORD *)(a2 + 32) = v128;
          *(_WORD *)(a2 + 4 * v128 + 22) = 3;
          *(_WORD *)(a2 + 240) = v128 + 1;
        }
        uint64_t v108 = v127 << 48;
      }
      else
      {
        uint64_t v107 = *(unsigned __int16 *)(a2 + 228);
        if (v107 == 0xFFFF)
        {
          uint64_t v107 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 228) = v107;
          *(_WORD *)(a2 + 246) = v107 + 1;
        }
        uint64_t v108 = (v107 << 48) | 0x19C840;
      }
      *(void *)&v452[1] = v108;
      uint64_t v129 = *(unsigned __int16 *)(a2 + 152);
      if (v129 == 0xFFFF)
      {
        uint64_t v130 = *(__int16 *)(a2 + 242);
        uint64_t v129 = *(unsigned __int16 *)(a2 + 242);
        *(_WORD *)(a2 + 152) = v130;
        *(_WORD *)(a2 + 4 * v130 + 86) = 17;
        *(_WORD *)(a2 + 242) = v130 + 1;
      }
      *((void *)&v452[1] + 1) = (v129 << 48) | 0x80;
      uint64_t v131 = *(unsigned __int16 *)(a2 + 228);
      if (v131 == 0xFFFF)
      {
        uint64_t v131 = *(unsigned __int16 *)(a2 + 246);
        *(_WORD *)(a2 + 228) = v131;
        *(_WORD *)(a2 + 246) = v131 + 1;
      }
      *((void *)&v452[0] + 1) = (v131 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      memset(&v452[1], 0, 64);
      int v132 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 1;
      *(void *)&v452[0] = (8 * (v132 & 7)) | 0x100080401;
      if ((*(unsigned char *)v3 & 0x20) != 0) {
        *(void *)&v452[0] = (8 * (v132 & 7)) | 0x80100080401;
      }
    }
    else
    {
      if (v94 == 1)
      {
        if ((v93 & 0x20) == 0)
        {
          memset((char *)&v452[1] + 8, 0, 56);
          char v95 = *(_DWORD *)(a2 + 16);
          *(_DWORD *)(a2 + 16) = 1;
          *(void *)&v452[0] = (8 * (v95 & 7)) | 0x3100080081;
          uint64_t v96 = *(unsigned __int16 *)(a2 + 32);
          if (v96 == 0xFFFF)
          {
            uint64_t v97 = *(__int16 *)(a2 + 240);
            uint64_t v96 = *(unsigned __int16 *)(a2 + 240);
            *(_WORD *)(a2 + 32) = v97;
            *(_WORD *)(a2 + 4 * v97 + 22) = 3;
            *(_WORD *)(a2 + 240) = v97 + 1;
          }
          *(void *)&v452[1] = v96 << 48;
          uint64_t v98 = *(unsigned __int16 *)(a2 + 228);
          if (v98 == 0xFFFF)
          {
            uint64_t v98 = *(unsigned __int16 *)(a2 + 246);
            *(_WORD *)(a2 + 228) = v98;
            *(_WORD *)(a2 + 246) = v98 + 1;
          }
          *((void *)&v452[0] + 1) = (v98 << 48) | 0x72679000;
          (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
        }
        memset((char *)v452 + 8, 0, 72);
        char v99 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = 3;
        *(void *)&v452[0] = (8 * (v99 & 7)) | 0x83100080FC3;
        if ((*(unsigned char *)v3 & 0x20) != 0)
        {
          uint64_t v119 = *(unsigned __int16 *)(a2 + 32);
          if (v119 == 0xFFFF)
          {
            uint64_t v120 = *(__int16 *)(a2 + 240);
            uint64_t v119 = *(unsigned __int16 *)(a2 + 240);
            *(_WORD *)(a2 + 32) = v120;
            *(_WORD *)(a2 + 4 * v120 + 22) = 3;
            *(_WORD *)(a2 + 240) = v120 + 1;
          }
          uint64_t v101 = v119 << 48;
        }
        else
        {
          uint64_t v100 = *(unsigned __int16 *)(a2 + 228);
          if (v100 == 0xFFFF)
          {
            uint64_t v100 = *(unsigned __int16 *)(a2 + 246);
            *(_WORD *)(a2 + 228) = v100;
            *(_WORD *)(a2 + 246) = v100 + 1;
          }
          uint64_t v101 = (v100 << 48) | 0x19C840;
        }
        *(void *)&v452[1] = v101 | 0x10;
        uint64_t v121 = *(unsigned __int16 *)(a2 + 148);
        if (v121 == 0xFFFF)
        {
          uint64_t v122 = *(__int16 *)(a2 + 242);
          uint64_t v121 = *(unsigned __int16 *)(a2 + 242);
          *(_WORD *)(a2 + 148) = v122;
          *(_WORD *)(a2 + 4 * v122 + 86) = 16;
          *(_WORD *)(a2 + 242) = v122 + 1;
        }
        *((void *)&v452[1] + 1) = ((v121 << 48) | 0x1FE40) + 64;
        uint64_t v123 = *(unsigned __int16 *)(a2 + 152);
        if (v123 == 0xFFFF)
        {
          uint64_t v124 = *(__int16 *)(a2 + 242);
          uint64_t v123 = *(unsigned __int16 *)(a2 + 242);
          *(_WORD *)(a2 + 152) = v124;
          *(_WORD *)(a2 + 4 * v124 + 86) = 17;
          *(_WORD *)(a2 + 242) = v124 + 1;
        }
        *(void *)&v452[2] = ((v123 << 48) | 0x1FE40) + 64;
        uint64_t v125 = *(unsigned __int16 *)(a2 + 228);
        if (v125 == 0xFFFF)
        {
          uint64_t v125 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 228) = v125;
          *(_WORD *)(a2 + 246) = v125 + 1;
        }
        uint64_t v126 = (v125 << 48) | 0x72679000;
        goto LABEL_750;
      }
      memset(&v452[2], 0, 48);
      char v109 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 2;
      *(void *)&v452[0] = (8 * (v109 & 7)) | 0x3100080882;
      uint64_t v110 = *(unsigned __int16 *)(a2 + 32);
      if (v110 == 0xFFFF)
      {
        uint64_t v111 = *(__int16 *)(a2 + 240);
        uint64_t v110 = *(unsigned __int16 *)(a2 + 240);
        *(_WORD *)(a2 + 32) = v111;
        *(_WORD *)(a2 + 4 * v111 + 22) = 3;
        *(_WORD *)(a2 + 240) = v111 + 1;
      }
      *(void *)&v452[1] = v110 << 48;
      uint64_t v112 = *(unsigned __int16 *)(a2 + 152);
      if (v112 == 0xFFFF)
      {
        uint64_t v113 = *(__int16 *)(a2 + 242);
        uint64_t v112 = *(unsigned __int16 *)(a2 + 242);
        *(_WORD *)(a2 + 152) = v113;
        *(_WORD *)(a2 + 4 * v113 + 86) = 17;
        *(_WORD *)(a2 + 242) = v113 + 1;
      }
      *((void *)&v452[1] + 1) = (v112 << 48) | 0xAA80;
      uint64_t v114 = *(unsigned __int16 *)(a2 + 228);
      if (v114 == 0xFFFF)
      {
        uint64_t v114 = *(unsigned __int16 *)(a2 + 246);
        *(_WORD *)(a2 + 228) = v114;
        *(_WORD *)(a2 + 246) = v114 + 1;
      }
      *((void *)&v452[0] + 1) = (v114 << 48) | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      memset(&v452[1], 0, 64);
      char v115 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 2;
      *(void *)&v452[0] = (8 * (v115 & 7)) | 0x3100080882;
      uint64_t v116 = *(unsigned __int16 *)(a2 + 228);
      if (v116 == 0xFFFF)
      {
        uint64_t v133 = *(unsigned __int16 *)(a2 + 246);
        int v134 = *(unsigned __int16 *)(a2 + 246);
        *(_WORD *)(a2 + 228) = v133;
        int v135 = v134 + 1;
        *(_WORD *)(a2 + 246) = v134 + 1;
        unint64_t v118 = ((unint64_t)(unsigned __int16)v133 << 48) | 0x19C840;
        *(void *)&v452[1] = v118;
        if ((v135 & 0x10000) != 0)
        {
          uint64_t v117 = 0;
          *(_WORD *)(a2 + 228) = v135;
          *(_WORD *)(a2 + 246) = 1;
          unint64_t v118 = 1689664;
        }
        else
        {
          uint64_t v117 = v133 << 48;
        }
      }
      else
      {
        uint64_t v117 = v116 << 48;
        unint64_t v118 = ((unint64_t)(unsigned __int16)v116 << 48) | 0x19C840;
        *(void *)&v452[1] = v118;
      }
      *((void *)&v452[1] + 1) = v118;
      *((void *)&v452[0] + 1) = v117 | 0x72679000;
      (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
      memset(&v452[1], 0, 64);
      int v420 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 1;
      *(void *)&v452[0] = (8 * (v420 & 7)) | 0x100080401;
    }
    uint64_t v421 = *(unsigned __int16 *)(a2 + 228);
    if (v421 == 0xFFFF)
    {
      uint64_t v423 = *(unsigned __int16 *)(a2 + 246);
      int v424 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 228) = v423;
      int v425 = v424 + 1;
      *(_WORD *)(a2 + 246) = v425;
      *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v423 << 48) | 0x50;
      if ((v425 & 0x10000) != 0)
      {
        uint64_t v422 = 0;
        *(_WORD *)(a2 + 228) = v425;
        *(_WORD *)(a2 + 246) = 1;
      }
      else
      {
        uint64_t v422 = v423 << 48;
      }
    }
    else
    {
      uint64_t v422 = v421 << 48;
      *(void *)&v452[1] = ((unint64_t)(unsigned __int16)v421 << 48) | 0x50;
    }
    uint64_t v126 = v422 | 0x72679000;
LABEL_750:
    *((void *)&v452[0] + 1) = v126;
    (*(void (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
    goto LABEL_751;
  }
  *(unsigned char *)(a2 + 248) = (*v3 & 0x40) == 0;
  if ((v82 & 0x40) == 0) {
    *(unsigned char *)(a2 + 250) = 0;
  }
  gleStateProgram_CheckDestInit(a2);
  memset((char *)v452 + 8, 0, 72);
  uint64_t v83 = 1572864;
  if (!*(unsigned char *)(a2 + 251)) {
    uint64_t v83 = 0x80000;
  }
  unint64_t v84 = v83 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7));
  *(void *)&v452[0] = v84 | 0x31000007C2;
  *(_DWORD *)(a2 + 16) = 2;
  if ((*(unsigned char *)v3 & 0x10) != 0) {
    *(void *)&v452[0] = v84 | 0x831000007C2;
  }
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v85 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v86 = 1689664;
    if (v85 == 0xFFFF)
    {
      uint64_t v85 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v85;
      *(_WORD *)(a2 + 246) = v85 + 1;
      uint64_t v86 = 1689664;
    }
  }
  else
  {
    uint64_t v85 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v86 = 1689600;
    if (v85 == 0xFFFF)
    {
      uint64_t v87 = *(__int16 *)(a2 + 240);
      uint64_t v85 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v87;
      *(_WORD *)(a2 + 4 * v87 + 22) = 1;
      *(_WORD *)(a2 + 240) = v87 + 1;
    }
  }
  *(void *)&v452[1] = v86 | (v85 << 48);
  uint64_t v88 = *(unsigned __int16 *)(a2 + 28);
  if (v88 == 0xFFFF)
  {
    uint64_t v89 = *(__int16 *)(a2 + 240);
    uint64_t v88 = *(unsigned __int16 *)(a2 + 240);
    *(_WORD *)(a2 + 28) = v89;
    *(_WORD *)(a2 + 4 * v89 + 22) = 2;
    *(_WORD *)(a2 + 240) = v89 + 1;
  }
  *((void *)&v452[1] + 1) = (v88 << 48) | 0x19C800;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v90 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v91 = 1918906368;
    if (v90 == 0xFFFF)
    {
      uint64_t v92 = *(__int16 *)(a2 + 244);
      uint64_t v90 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v92;
      *(_WORD *)(a2 + 172 + 4 * v92 + 2) = 0;
      *(_WORD *)(a2 + 244) = v92 + 1;
    }
  }
  else
  {
    uint64_t v90 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v91 = 1918898176;
    if (v90 == 0xFFFF)
    {
      uint64_t v90 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v90;
      *(_WORD *)(a2 + 246) = v90 + 1;
    }
  }
  *((void *)&v452[0] + 1) = v91 | (v90 << 48) | 0x70000;
  uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 256))(a2, v452);
  *(_WORD *)(a2 + 249) = 257;
  if ((*v3 & 0x40) != 0) {
    goto LABEL_157;
  }
  return result;
}

uint64_t gleFStateProgram_End(uint64_t result, uint64_t a2)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  if (!*(unsigned char *)(a2 + 248))
  {
    *(unsigned char *)(a2 + 248) = 1;
    if ((*(unsigned char *)(result + 2) & 2) == 0)
    {
      uint64_t v3 = 1689600;
      long long v13 = 0uLL;
      long long v14 = 0uLL;
      long long v11 = 0uLL;
      long long v12 = 0uLL;
      if (*(unsigned char *)(a2 + 251)) {
        uint64_t v4 = 0x3100180000;
      }
      else {
        uint64_t v4 = 0x3100080000;
      }
      *(void *)&long long v10 = v4 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 1;
      *(_DWORD *)(a2 + 16) = 1;
      if (*(unsigned char *)(a2 + 249))
      {
        uint64_t v5 = *(unsigned __int16 *)(a2 + 208);
        uint64_t v3 = 1689664;
        if (v5 == 0xFFFF)
        {
          uint64_t v5 = *(unsigned __int16 *)(a2 + 246);
          *(_WORD *)(a2 + 208) = v5;
          *(_WORD *)(a2 + 246) = v5 + 1;
        }
      }
      else
      {
        uint64_t v5 = *(unsigned __int16 *)(a2 + 24);
        if (v5 == 0xFFFF)
        {
          uint64_t v6 = *(__int16 *)(a2 + 240);
          uint64_t v5 = *(unsigned __int16 *)(a2 + 240);
          *(_WORD *)(a2 + 24) = v6;
          *(_WORD *)(a2 + 4 * v6 + 22) = 1;
          *(_WORD *)(a2 + 240) = v6 + 1;
        }
      }
      *(void *)&long long v11 = v3 | (v5 << 48);
      uint64_t v7 = *(unsigned __int16 *)(a2 + 172);
      if (v7 == 0xFFFF)
      {
        uint64_t v8 = *(__int16 *)(a2 + 244);
        uint64_t v7 = *(unsigned __int16 *)(a2 + 244);
        *(_WORD *)(a2 + 172) = v8;
        *(_WORD *)(a2 + 172 + 4 * v8 + 2) = 0;
        *(_WORD *)(a2 + 244) = v8 + 1;
      }
      *((void *)&v10 + 1) = (v7 << 48) | 0x7267B000;
      uint64_t result = (*(uint64_t (**)(uint64_t, long long *))(a2 + 256))(a2, &v10);
    }
    *(unsigned char *)(a2 + 250) = 1;
  }
  if ((*(unsigned char *)(a2 + 280) & 1) == 0)
  {
    uint64_t v9 = **(void **)(*(void *)a2 + 104);
    if (v9) {
      *(void *)(v9 + 24) |= 0x4000uLL;
    }
  }
  return result;
}

void gleFStateProgram_AddAttribs(int *a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 251);
  int v5 = *a1;
  uint64_t v6 = *(void *)(a2 + 272);
  if (v6)
  {
    uint64_t v7 = (_DWORD *)(v6 + *(int *)(v6 + 8));
    unsigned int v8 = gleAttribBindingSize(*(__int16 *)(a2 + 240));
    bzero(v7, v8);
    __int16 v9 = *(_WORD *)(a2 + 240);
    *uint64_t v7 = v9;
  }
  else
  {
    uint64_t v7 = 0;
    __int16 v9 = *(_WORD *)(a2 + 240);
  }
  if (v9 >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    unint64_t v12 = (unint64_t)(v5 & 1) << 8;
    uint64_t v13 = 195;
    if (!v4) {
      uint64_t v13 = 193;
    }
    uint64_t v14 = v13 | 0xC00;
    uint64_t v15 = v13 | 0x800;
    uint64_t v16 = v13 & 3 | 0x2C08;
    uint64_t v17 = v13 & 3 | 0x3040;
    uint64_t v28 = v13;
    uint64_t v29 = v13 | 0x3000;
    do
    {
      int v18 = *(__int16 *)(a2 + 2 * v10 + 22);
      *(void *)&long long v30 = 0;
      *((void *)&v30 + 1) = v11;
      switch(v18)
      {
        case 0:
          *(void *)&long long v30 = 1217;
          uint64_t v19 = 1217;
          goto LABEL_23;
        case 1:
          uint64_t v20 = (*(void *)a1 >> 10) & 0x8000;
          unint64_t v21 = v15 | v12;
          goto LABEL_12;
        case 2:
          uint64_t v20 = (*(void *)a1 >> 10) & 0x8000;
          unint64_t v21 = v12 | v14;
LABEL_12:
          uint64_t v19 = v21 | v20;
          break;
        case 3:
          uint64_t v19 = 0x500007041;
          break;
        case 12:
          *(void *)&long long v30 = v17;
          uint64_t v19 = v17;
          goto LABEL_23;
        case 13:
          *(void *)&long long v30 = v16;
          uint64_t v19 = v16;
          goto LABEL_23;
        case 14:
          uint64_t v23 = (*(void *)a1 >> 10) & 0x8000;
          unint64_t v24 = v15 | v12;
          goto LABEL_21;
        case 15:
          uint64_t v23 = (*(void *)a1 >> 10) & 0x8000;
          unint64_t v24 = v14 | v12;
LABEL_21:
          uint64_t v19 = v24 | v23 | 0x100000000;
          break;
        default:
          unint64_t v22 = v29;
          if (((1 << (v18 - 4)) & a1[1]) == 0) {
            unint64_t v22 = v28 | ((unint64_t)(((_BYTE)v18 + 4) & 0x3F) << 32) | 0x7000;
          }
          uint64_t v19 = v22 & 0x3FFFFFFEF8 | 1;
          break;
      }
      *(void *)&long long v30 = v19;
LABEL_23:
      if (*(void *)a2)
      {
        PPStreamAddAttribBinding(*(void *)a2, &v30);
      }
      else
      {
        v7[v10 + 2] = (v19 >> 2) & 0x3F00 | v7[v10 + 2] & 0xFFFFC000 | v19;
        unsigned int v25 = (v19 >> 10) & 0x1F;
        if (v25 > 0xD)
        {
          if (v25 != 14)
          {
            if (v25 == 28) {
              v7[v10 + 3] = v7[v10 + 3] & 0xFFFFFE00 | HIDWORD(v19);
            }
            goto LABEL_34;
          }
          uint64_t v26 = &v7[v10];
          int v27 = BYTE4(v19) & 0x1F | (32 * (v26[3] >> 5));
        }
        else
        {
          if (v25 != 2 && v25 != 3) {
            goto LABEL_34;
          }
          uint64_t v26 = &v7[v10];
          int v27 = BYTE4(v19) & 1 | (2 * (v26[3] >> 1));
        }
        v26[3] = v27;
      }
LABEL_34:
      ++v11;
      v10 += 2;
    }
    while (v11 < *(__int16 *)(a2 + 240));
  }
}

char *gleFStateProgram_AddParams(char *result)
{
  unsigned int v1 = result;
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)result + 34);
  if (v2)
  {
    uint64_t v3 = v2 + *(int *)(v2 + 4);
    unsigned int v4 = *((__int16 *)result + 121);
    __int16 v5 = *((_WORD *)result + 121);
    *(void *)uint64_t v3 = v4;
    *(_DWORD *)(v3 + 8) = v4;
  }
  else
  {
    uint64_t v3 = 0;
    __int16 v5 = *((_WORD *)result + 121);
  }
  if (v5 >= 1)
  {
    uint64_t v6 = 0;
    if (result[251]) {
      uint64_t v7 = 195;
    }
    else {
      uint64_t v7 = 193;
    }
    uint64_t v8 = 86;
    do
    {
      unsigned int v9 = *(unsigned __int16 *)&v1[v8];
      *(void *)&long long v13 = v7;
      *((void *)&v13 + 1) = v6;
      if (v9 > 7)
      {
        if ((v9 & 0xFFF8) == 8)
        {
          unint64_t v10 = v7 | ((unint64_t)(((_BYTE)v9 + 120) & 0x7F) << 32) | 0x1700;
        }
        else
        {
          switch(v9)
          {
            case 0x10u:
              unint64_t v10 = 6849;
              break;
            case 0x11u:
              unint64_t v10 = 7105;
              break;
            case 0x12u:
              *(void *)&long long v13 = v7 | 0x1900;
              goto LABEL_14;
            case 0x13u:
              uint64_t result = *(char **)v1;
              if (!*(void *)v1) {
                goto LABEL_16;
              }
              long long v14 = xmmword_2393DC000;
              goto LABEL_28;
            case 0x14u:
              uint64_t result = *(char **)v1;
              if (!*(void *)v1) {
                goto LABEL_16;
              }
              long long v14 = 0uLL;
LABEL_28:
              uint64_t v11 = *((void *)result + 16);
              PPStreamAddConstant((uint64_t)result, &v14);
              unint64_t v10 = v13 & 0xFFFF0000FFFFE0FFLL | ((unint64_t)(unsigned __int16)(*(_DWORD *)(v11 + 16) - 1) << 32) | 0x600;
              break;
            case 0x15u:
              uint64_t result = *(char **)v1;
              if (!*(void *)v1) {
                goto LABEL_16;
              }
              long long v14 = xmmword_2393DC000;
              uint64_t v12 = *((void *)result + 16);
              PPStreamAddConstant((uint64_t)result, &v14);
              unint64_t v10 = v13 & 0xFFFF0000FFFFE0F8 | ((unint64_t)(unsigned __int16)(*(_DWORD *)(v12 + 16) - 1) << 32) | 0x601;
              break;
            default:
              goto LABEL_14;
          }
        }
      }
      else
      {
        unint64_t v10 = v7 | ((unint64_t)(v9 & 0x7F) << 32) | 0x1600;
      }
      *(void *)&long long v13 = v10;
LABEL_14:
      uint64_t result = *(char **)v1;
      if (*(void *)v1) {
        uint64_t result = PPStreamAddParamBinding((uint64_t)result, &v13);
      }
LABEL_16:
      if (v3) {
        *(void *)(v3 + 16 + 8 * v6) = v13;
      }
      ++v6;
      v8 += 4;
    }
    while (v6 < *((__int16 *)v1 + 121));
  }
  return result;
}

uint64_t *gleFStateProgram_AllocateAttribs(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if ((*result & 0x20000) != 0)
  {
    if ((v2 & 0x40) != 0)
    {
      uint64_t v7 = *(__int16 *)(a2 + 240);
      *(_WORD *)(a2 + 32) = v7;
      *(_WORD *)(a2 + 4 * v7 + 22) = 3;
      *(_WORD *)(a2 + 240) = v7 + 1;
    }
    uint64_t v8 = 0;
    unsigned int v9 = (_WORD *)(a2 + 36);
    do
    {
      if (((1 << v8) & *((unsigned char *)result + 1)) != 0)
      {
        uint64_t v10 = *(__int16 *)(a2 + 240);
        *unsigned int v9 = v10;
        *(_WORD *)(a2 + 4 * v10 + 22) = v8 + 4;
        *(_WORD *)(a2 + 240) = v10 + 1;
      }
      ++v8;
      v9 += 2;
    }
    while (v8 != 8);
  }
  else if ((v2 & 0x40000) != 0)
  {
    if ((v2 & 0x400) != 0)
    {
      uint64_t v11 = *(__int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v11;
      *(_WORD *)(a2 + 4 * v11 + 22) = 1;
      __int16 v12 = v11 + 1;
      *(_WORD *)(a2 + 240) = v11 + 1;
      uint64_t v2 = *result;
      if ((*result & 0x1000000) != 0)
      {
        *(_WORD *)(a2 + 76) = v12;
        *(_WORD *)(a2 + 4 * v12 + 22) = 14;
        *(_WORD *)(a2 + 240) = v11 + 2;
        uint64_t v2 = *result;
      }
    }
    if ((v2 & 0x300) != 0)
    {
      uint64_t v13 = *(__int16 *)(a2 + 240);
      *(_WORD *)(a2 + 36) = v13;
      *(_WORD *)(a2 + 4 * v13 + 22) = 4;
      *(_WORD *)(a2 + 240) = v13 + 1;
      uint64_t v2 = *result;
    }
    if ((v2 & 0x1800) != 0)
    {
      LOWORD(v14) = *(_WORD *)(a2 + 240);
      *(_WORD *)(a2 + 40) = v14;
      __int16 v15 = 5;
LABEL_38:
      *(_WORD *)(a2 + 4 * (__int16)v14 + 22) = v15;
      *(_WORD *)(a2 + 240) = v14 + 1;
    }
  }
  else
  {
    if ((v2 & 0x80000) != 0)
    {
      uint64_t v16 = *(__int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v16;
      *(_WORD *)(a2 + 4 * v16 + 22) = 1;
      LOWORD(v14) = v16 + 1;
      *(_WORD *)(a2 + 240) = v16 + 1;
      if (*((unsigned char *)result + 3))
      {
        *(_WORD *)(a2 + 76) = v14;
        *(_WORD *)(a2 + 4 * (__int16)v14 + 22) = 14;
        LOWORD(v14) = v16 + 2;
      }
      *(_WORD *)(a2 + 36) = v14;
      __int16 v15 = 4;
      goto LABEL_38;
    }
    uint64_t v3 = *(__int16 *)(a2 + 240);
    *(_WORD *)(a2 + 24) = v3;
    *(_WORD *)(a2 + 4 * v3 + 22) = 1;
    int v4 = v3 + 1;
    *(_WORD *)(a2 + 240) = v3 + 1;
    uint64_t v5 = *result;
    if ((*result & 0x1000000) != 0)
    {
      *(_WORD *)(a2 + 76) = v4;
      *(_WORD *)(a2 + 4 * (__int16)v4 + 22) = 14;
      int v4 = (unsigned __int16)v3 + 2;
      *(_WORD *)(a2 + 240) = v3 + 2;
      uint64_t v5 = *result;
    }
    if ((v5 & 8) != 0)
    {
      *(_WORD *)(a2 + 28) = v4;
      *(_WORD *)(a2 + 4 * (__int16)v4 + 22) = 2;
      __int16 v6 = v4 + 1;
      *(_WORD *)(a2 + 240) = v4 + 1;
      uint64_t v5 = *result;
      if ((*result & 0x1000000) != 0)
      {
        *(_WORD *)(a2 + 80) = v6;
        *(_WORD *)(a2 + 4 * v6 + 22) = 15;
        v4 += 2;
        *(_WORD *)(a2 + 240) = v4;
        uint64_t v5 = *result;
      }
      else
      {
        ++v4;
      }
    }
    unsigned int v17 = BYTE1(v2);
    if ((v5 & 0x40) != 0)
    {
      *(_WORD *)(a2 + 32) = v4;
      *(_WORD *)(a2 + 4 * (__int16)v4 + 22) = 3;
      int v14 = v4 + 1;
      *(_WORD *)(a2 + 240) = v4 + 1;
    }
    else
    {
      int v14 = v4;
    }
    if (v17)
    {
      __int16 v18 = 0;
      uint64_t v19 = (_WORD *)(a2 + 36);
      do
      {
        if (v17)
        {
          *uint64_t v19 = v14;
          *(_WORD *)(a2 + 4 * (__int16)v14++ + 22) = v18 + 4;
          *(_WORD *)(a2 + 240) = v14;
        }
        ++v18;
        v19 += 2;
        BOOL v20 = v17 > 1;
        v17 >>= 1;
      }
      while (v20);
    }
    if ((*(unsigned char *)(a2 + 280) & 1) != 0 && *(unsigned char *)(a2 + 252))
    {
      *(_WORD *)(a2 + 72) = v14;
      __int16 v15 = 13;
      goto LABEL_38;
    }
  }
  if (*(unsigned char *)(a2 + 280))
  {
    unsigned int v21 = *((unsigned __int8 *)result + 1);
    if (*((unsigned char *)result + 1))
    {
      char v22 = 0;
      do
      {
        if ((v21 & 1) != 0 && ((1 << v22) & *(unsigned __int8 *)(*(void *)(a2 + 264) + 4)) != 0)
        {
          uint64_t v23 = *(__int16 *)(a2 + 240);
          *(_WORD *)(a2 + 68) = v23;
          *(_WORD *)(a2 + 4 * v23 + 22) = 12;
          *(_WORD *)(a2 + 240) = v23 + 1;
        }
        ++v22;
        BOOL v20 = v21 > 1;
        v21 >>= 1;
      }
      while (v20);
    }
  }
  return result;
}

uint64_t gleStateProgram_TextureSampleOp(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = a1[a4 + 1];
  uint64_t v5 = 0;
  switch(HIBYTE(v4) & 7)
  {
    case 1:
      goto LABEL_14;
    case 2:
      uint64_t v5 = 1;
      goto LABEL_14;
    case 3:
      BOOL v9 = (v4 & 0x4000000000000000) == 0;
      uint64_t v5 = 5;
      uint64_t v10 = 2;
      goto LABEL_12;
    case 4:
      BOOL v9 = (v4 & 0x4000000000000000) == 0;
      uint64_t v5 = 6;
      uint64_t v10 = 3;
      goto LABEL_12;
    case 5:
      BOOL v9 = (v4 & 0x4000000000000000) == 0;
      uint64_t v5 = 7;
      uint64_t v10 = 4;
LABEL_12:
      if (v9) {
        uint64_t v5 = v10;
      }
LABEL_14:
      uint64_t v11 = 0x3100000002;
      uint64_t v12 = *a1;
      uint64_t v13 = 4288;
      if ((int)v4 < 0) {
        uint64_t v13 = 4224;
      }
      BOOL v14 = (int)v4 < 0;
      uint64_t v15 = 4352;
      uint64_t v16 = 4416;
      if (v14) {
        uint64_t v16 = 4352;
      }
      if ((v12 & 0x10000000000) != 0) {
        int v17 = 3;
      }
      else {
        int v17 = 2;
      }
      if ((v12 & 0x10000000000) != 0) {
        uint64_t v11 = 0x3100000003;
      }
      else {
        uint64_t v15 = 4224;
      }
      if ((v12 & 0x10000000000) != 0) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = v13;
      }
      if (((1 << a4) & BYTE4(v12)) == 0) {
        uint64_t v15 = v18;
      }
      uint64_t v39 = 0;
      long long v38 = 0u;
      long long v37 = 0u;
      long long v36 = 0u;
      long long v35 = 0u;
      uint64_t v19 = v11 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | v15;
      *(_DWORD *)(a2 + 16) = v17;
      char v20 = v19;
      unint64_t v34 = v19 | 0x88000;
      uint64_t v21 = *a1;
      if ((*a1 & 0x10) != 0)
      {
        char v20 = v19;
        unint64_t v34 = v19 | 0x80000088000;
      }
      uint64_t v22 = a2 + 4 * (a4 + 4);
      unsigned int v25 = *(unsigned __int16 *)(v22 + 20);
      unint64_t v24 = (_WORD *)(v22 + 20);
      uint64_t v23 = v25;
      if (v25 == 0xFFFF)
      {
        uint64_t v26 = *(__int16 *)(a2 + 240);
        uint64_t v23 = *(unsigned __int16 *)(a2 + 240);
        *unint64_t v24 = v26;
        *(_WORD *)(a2 + 4 * v26 + 22) = a4 + 4;
        *(_WORD *)(a2 + 240) = v26 + 1;
        uint64_t v21 = *a1;
      }
      *((void *)&v35 + 1) = ((v23 << 48) | 0x19C880) - 128;
      if ((v21 & 0x10000000000) != 0)
      {
        uint64_t v27 = a4 + 8;
        uint64_t v28 = a2 + 4 * v27;
        unsigned int v31 = *(unsigned __int16 *)(v28 + 84);
        long long v30 = (_WORD *)(v28 + 84);
        uint64_t v29 = v31;
        if (v31 == 0xFFFF)
        {
          uint64_t v32 = *(__int16 *)(a2 + 242);
          uint64_t v29 = *(unsigned __int16 *)(a2 + 242);
          *long long v30 = v32;
          *(_WORD *)(a2 + 4 * v32 + 86) = v27;
          *(_WORD *)(a2 + 242) = v32 + 1;
        }
        *(void *)&long long v36 = (v29 << 48) | 0x19C880;
      }
      *(&v34 + (v20 & 7) + 1) = *(&v34 + (v20 & 7) + 1) & 0xFFFFFF80FFFFFFE0 | ((unint64_t)(a4 & 0x7F) << 32) | v5;
      break;
    default:
      uint64_t v39 = 0;
      long long v38 = 0u;
      long long v37 = 0u;
      long long v36 = 0u;
      if (*(unsigned char *)(a2 + 251)) {
        uint64_t v6 = 0x3100180000;
      }
      else {
        uint64_t v6 = 0x3100080000;
      }
      unint64_t v34 = v6 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 1;
      *(_DWORD *)(a2 + 16) = 1;
      uint64_t v7 = *(unsigned __int16 *)(a2 + 164);
      if (v7 == 0xFFFF)
      {
        uint64_t v8 = *(__int16 *)(a2 + 242);
        uint64_t v7 = *(unsigned __int16 *)(a2 + 242);
        *(_WORD *)(a2 + 164) = v8;
        *(_WORD *)(a2 + 4 * v8 + 86) = 20;
        *(_WORD *)(a2 + 242) = v8 + 1;
      }
      *((void *)&v35 + 1) = (v7 << 48) | 0x19C880;
      break;
  }
  *(void *)&long long v35 = a3;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v34);
}

uint64_t gleStateProgram_A_MODULATE(uint64_t a1, uint64_t a2)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v3 = 0x3100180000;
  }
  else {
    uint64_t v3 = 0x3100080000;
  }
  unint64_t v12 = v3 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882;
  *(_DWORD *)(a2 + 16) = 2;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v5 = 1689664;
    if (v4 == 0xFFFF)
    {
      uint64_t v4 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v4;
      *(_WORD *)(a2 + 246) = v4 + 1;
      uint64_t v5 = 1689664;
    }
  }
  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v5 = 1689600;
    if (v4 == 0xFFFF)
    {
      uint64_t v6 = *(__int16 *)(a2 + 240);
      uint64_t v4 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v6;
      *(_WORD *)(a2 + 4 * v6 + 22) = 1;
      *(_WORD *)(a2 + 240) = v6 + 1;
    }
  }
  *((void *)&v13 + 1) = v5 | (v4 << 48);
  uint64_t v7 = *(unsigned __int16 *)(a2 + 210);
  if (v7 == 0xFFFF)
  {
    uint64_t v7 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v7;
    *(_WORD *)(a2 + 246) = v7 + 1;
  }
  uint64_t v8 = 1918898176;
  *(void *)&long long v14 = (v7 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v8 = 1918906368;
    if (v9 == 0xFFFF)
    {
      uint64_t v10 = *(__int16 *)(a2 + 244);
      uint64_t v9 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v10;
      *(_WORD *)(a2 + 172 + 4 * v10 + 2) = 0;
      *(_WORD *)(a2 + 244) = v10 + 1;
    }
  }
  else
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 208);
    if (v9 == 0xFFFF)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v9;
      *(_WORD *)(a2 + 246) = v9 + 1;
    }
  }
  *(void *)&long long v13 = v8 | (v9 << 48) | 0x8000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v12);
}

uint64_t gleStateProgram_A_REPLACE(uint64_t a1, uint64_t a2)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v14 = 0;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v3 = 0x3100180000;
  }
  else {
    uint64_t v3 = 0x3100080000;
  }
  unint64_t v9 = v3 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 1;
  *(_DWORD *)(a2 + 16) = 1;
  uint64_t v4 = *(unsigned __int16 *)(a2 + 210);
  if (v4 == 0xFFFF)
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v4;
    *(_WORD *)(a2 + 246) = v4 + 1;
  }
  uint64_t v5 = 1918898176;
  *((void *)&v10 + 1) = (v4 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v5 = 1918906368;
    if (v6 == 0xFFFF)
    {
      uint64_t v7 = *(__int16 *)(a2 + 244);
      uint64_t v6 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v7;
      *(_WORD *)(a2 + 172 + 4 * v7 + 2) = 0;
      *(_WORD *)(a2 + 244) = v7 + 1;
    }
  }
  else
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 208);
    if (v6 == 0xFFFF)
    {
      uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v6;
      *(_WORD *)(a2 + 246) = v6 + 1;
    }
  }
  *(void *)&long long v10 = v5 | (v6 << 48) | 0x8000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v9);
}

uint64_t gleStateProgram_CheckDestInit(uint64_t result)
{
  if (!*(unsigned char *)(result + 250))
  {
    uint64_t v1 = 1689600;
    uint64_t v13 = 0;
    long long v12 = 0u;
    long long v11 = 0u;
    long long v10 = 0u;
    long long v9 = 0u;
    if (*(unsigned char *)(result + 251)) {
      uint64_t v2 = 0x3100180000;
    }
    else {
      uint64_t v2 = 0x3100080000;
    }
    unint64_t v8 = v2 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(result + 16) & 7)) | 1;
    *(_DWORD *)(result + 16) = 1;
    if (*(unsigned char *)(result + 249))
    {
      uint64_t v3 = *(unsigned __int16 *)(result + 208);
      uint64_t v1 = 1689664;
      if (v3 == 0xFFFF)
      {
        uint64_t v3 = *(unsigned __int16 *)(result + 246);
        *(_WORD *)(result + 208) = v3;
        *(_WORD *)(result + 246) = v3 + 1;
      }
    }
    else
    {
      uint64_t v3 = *(unsigned __int16 *)(result + 24);
      if (v3 == 0xFFFF)
      {
        uint64_t v4 = *(__int16 *)(result + 240);
        uint64_t v3 = *(unsigned __int16 *)(result + 240);
        *(_WORD *)(result + 24) = v4;
        *(_WORD *)(result + 4 * v4 + 22) = 1;
        *(_WORD *)(result + 240) = v4 + 1;
      }
    }
    uint64_t v5 = 1919389696;
    *((void *)&v9 + 1) = v1 | (v3 << 48);
    if (*(unsigned char *)(result + 248))
    {
      uint64_t v6 = *(unsigned __int16 *)(result + 172);
      uint64_t v5 = 1919397888;
      if (v6 == 0xFFFF)
      {
        uint64_t v7 = *(__int16 *)(result + 244);
        uint64_t v6 = *(unsigned __int16 *)(result + 244);
        *(_WORD *)(result + 172) = v7;
        *(_WORD *)(result + 172 + 4 * v7 + 2) = 0;
        *(_WORD *)(result + 244) = v7 + 1;
      }
    }
    else
    {
      uint64_t v6 = *(unsigned __int16 *)(result + 208);
      if (v6 == 0xFFFF)
      {
        uint64_t v6 = *(unsigned __int16 *)(result + 246);
        *(_WORD *)(result + 208) = v6;
        *(_WORD *)(result + 246) = v6 + 1;
      }
    }
    *(void *)&long long v9 = v5 | (v6 << 48);
    return (*(uint64_t (**)(uint64_t, unint64_t *))(result + 256))(result, &v8);
  }
  return result;
}

uint64_t gleStateProgram_RGB_MODULATE(uint64_t a1, uint64_t a2)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v3 = 0x3100180000;
  }
  else {
    uint64_t v3 = 0x3100080000;
  }
  unint64_t v12 = v3 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882;
  *(_DWORD *)(a2 + 16) = 2;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v5 = 1689664;
    if (v4 == 0xFFFF)
    {
      uint64_t v4 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v4;
      *(_WORD *)(a2 + 246) = v4 + 1;
      uint64_t v5 = 1689664;
    }
  }
  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v5 = 1689600;
    if (v4 == 0xFFFF)
    {
      uint64_t v6 = *(__int16 *)(a2 + 240);
      uint64_t v4 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v6;
      *(_WORD *)(a2 + 4 * v6 + 22) = 1;
      *(_WORD *)(a2 + 240) = v6 + 1;
    }
  }
  *((void *)&v13 + 1) = v5 | (v4 << 48);
  uint64_t v7 = *(unsigned __int16 *)(a2 + 210);
  if (v7 == 0xFFFF)
  {
    uint64_t v7 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v7;
    *(_WORD *)(a2 + 246) = v7 + 1;
  }
  uint64_t v8 = 1918898176;
  *(void *)&long long v14 = (v7 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v8 = 1918906368;
    if (v9 == 0xFFFF)
    {
      uint64_t v10 = *(__int16 *)(a2 + 244);
      uint64_t v9 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v10;
      *(_WORD *)(a2 + 172 + 4 * v10 + 2) = 0;
      *(_WORD *)(a2 + 244) = v10 + 1;
    }
  }
  else
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 208);
    if (v9 == 0xFFFF)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v9;
      *(_WORD *)(a2 + 246) = v9 + 1;
    }
  }
  *(void *)&long long v13 = v8 | (v9 << 48) | 0x70000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v12);
}

uint64_t gleStateProgram_RGB_BLEND(uint64_t a1, uint64_t a2, int a3)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v24 = 0;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v5 = 0x3100180000;
  }
  else {
    uint64_t v5 = 0x3100080000;
  }
  unint64_t v19 = v5 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03;
  *(_DWORD *)(a2 + 16) = 3;
  uint64_t v6 = *(unsigned __int16 *)(a2 + 210);
  if (v6 == 0xFFFF)
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v6;
    *(_WORD *)(a2 + 246) = v6 + 1;
  }
  uint64_t v7 = 1689664;
  *((void *)&v20 + 1) = (v6 << 48) | 0x19C840;
  uint64_t v8 = a2 + 4 * a3;
  unsigned int v11 = *(unsigned __int16 *)(v8 + 84);
  uint64_t v10 = (_WORD *)(v8 + 84);
  uint64_t v9 = v11;
  if (v11 == 0xFFFF)
  {
    uint64_t v12 = *(__int16 *)(a2 + 242);
    uint64_t v9 = *(unsigned __int16 *)(a2 + 242);
    *uint64_t v10 = v12;
    *(_WORD *)(a2 + 4 * v12 + 86) = a3;
    *(_WORD *)(a2 + 242) = v12 + 1;
  }
  *(void *)&long long v21 = ((v9 << 48) | 0x19C840) + 64;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v13 = *(unsigned __int16 *)(a2 + 208);
    if (v13 == 0xFFFF)
    {
      uint64_t v13 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v13;
      *(_WORD *)(a2 + 246) = v13 + 1;
    }
  }
  else
  {
    uint64_t v13 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v7 = 1689600;
    if (v13 == 0xFFFF)
    {
      uint64_t v14 = *(__int16 *)(a2 + 240);
      uint64_t v13 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v14;
      *(_WORD *)(a2 + 4 * v14 + 22) = 1;
      *(_WORD *)(a2 + 240) = v14 + 1;
    }
  }
  uint64_t v15 = 1918898176;
  *((void *)&v21 + 1) = v7 | (v13 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v16 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v15 = 1918906368;
    if (v16 == 0xFFFF)
    {
      uint64_t v17 = *(__int16 *)(a2 + 244);
      uint64_t v16 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v17;
      *(_WORD *)(a2 + 172 + 4 * v17 + 2) = 0;
      *(_WORD *)(a2 + 244) = v17 + 1;
    }
  }
  else
  {
    uint64_t v16 = *(unsigned __int16 *)(a2 + 208);
    if (v16 == 0xFFFF)
    {
      uint64_t v16 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v16;
      *(_WORD *)(a2 + 246) = v16 + 1;
    }
  }
  *(void *)&long long v20 = v15 | (v16 << 48) | 0x70000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v19);
}

uint64_t gleStateProgram_RGB_REPLACE(uint64_t a1, uint64_t a2)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v14 = 0;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v3 = 0x3100180000;
  }
  else {
    uint64_t v3 = 0x3100080000;
  }
  unint64_t v9 = v3 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 1;
  *(_DWORD *)(a2 + 16) = 1;
  uint64_t v4 = *(unsigned __int16 *)(a2 + 210);
  if (v4 == 0xFFFF)
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v4;
    *(_WORD *)(a2 + 246) = v4 + 1;
  }
  uint64_t v5 = 1918898176;
  *((void *)&v10 + 1) = (v4 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v5 = 1918906368;
    if (v6 == 0xFFFF)
    {
      uint64_t v7 = *(__int16 *)(a2 + 244);
      uint64_t v6 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v7;
      *(_WORD *)(a2 + 172 + 4 * v7 + 2) = 0;
      *(_WORD *)(a2 + 244) = v7 + 1;
    }
  }
  else
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 208);
    if (v6 == 0xFFFF)
    {
      uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v6;
      *(_WORD *)(a2 + 246) = v6 + 1;
    }
  }
  *(void *)&long long v10 = v5 | (v6 << 48) | 0x70000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v9);
}

uint64_t gleStateProgram_RGB_ADD(unsigned char *a1, uint64_t a2)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  uint64_t v4 = 1572864;
  if (!*(unsigned char *)(a2 + 251)) {
    uint64_t v4 = 0x80000;
  }
  unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7));
  uint64_t v14 = v5 | 0x31000007C2;
  *(_DWORD *)(a2 + 16) = 2;
  if ((*a1 & 0x10) != 0) {
    uint64_t v14 = v5 | 0x831000007C2;
  }
  uint64_t v6 = *(unsigned __int16 *)(a2 + 210);
  if (v6 == 0xFFFF)
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v6;
    *(_WORD *)(a2 + 246) = v6 + 1;
  }
  uint64_t v7 = 1689664;
  *((void *)&v15 + 1) = (v6 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v8 = *(unsigned __int16 *)(a2 + 208);
    if (v8 == 0xFFFF)
    {
      uint64_t v8 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v8;
      *(_WORD *)(a2 + 246) = v8 + 1;
    }
  }
  else
  {
    uint64_t v8 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v7 = 1689600;
    if (v8 == 0xFFFF)
    {
      uint64_t v9 = *(__int16 *)(a2 + 240);
      uint64_t v8 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v9;
      *(_WORD *)(a2 + 4 * v9 + 22) = 1;
      *(_WORD *)(a2 + 240) = v9 + 1;
    }
  }
  uint64_t v10 = 1918898176;
  *(void *)&long long v16 = v7 | (v8 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v11 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v10 = 1918906368;
    if (v11 == 0xFFFF)
    {
      uint64_t v12 = *(__int16 *)(a2 + 244);
      uint64_t v11 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v12;
      *(_WORD *)(a2 + 172 + 4 * v12 + 2) = 0;
      *(_WORD *)(a2 + 244) = v12 + 1;
    }
  }
  else
  {
    uint64_t v11 = *(unsigned __int16 *)(a2 + 208);
    if (v11 == 0xFFFF)
    {
      uint64_t v11 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v11;
      *(_WORD *)(a2 + 246) = v11 + 1;
    }
  }
  *(void *)&long long v15 = v10 | (v11 << 48) | 0x70000;
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v14);
}

uint64_t gleStateProgram_RGBA_MODULATE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = 0;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v8 = 0x3100180000;
  }
  else {
    uint64_t v8 = 0x3100080000;
  }
  unint64_t v17 = v8 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882;
  *(_DWORD *)(a2 + 16) = 2;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v10 = 1689664;
    if (v9 == 0xFFFF)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v9;
      *(_WORD *)(a2 + 246) = v9 + 1;
      uint64_t v10 = 1689664;
    }
  }
  else
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v10 = 1689600;
    if (v9 == 0xFFFF)
    {
      uint64_t v11 = *(__int16 *)(a2 + 240);
      uint64_t v9 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v11;
      *(_WORD *)(a2 + 4 * v11 + 22) = 1;
      *(_WORD *)(a2 + 240) = v11 + 1;
    }
  }
  *((void *)&v18 + 1) = v10 | (v9 << 48);
  uint64_t v12 = *(unsigned __int16 *)(a2 + 210);
  if (v12 == 0xFFFF)
  {
    uint64_t v12 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v12;
    *(_WORD *)(a2 + 246) = v12 + 1;
  }
  uint64_t v13 = 1919389696;
  *(void *)&long long v19 = (v12 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v14 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v13 = 1919397888;
    if (v14 == 0xFFFF)
    {
      uint64_t v15 = *(__int16 *)(a2 + 244);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v15;
      *(_WORD *)(a2 + 172 + 4 * v15 + 2) = 0;
      *(_WORD *)(a2 + 244) = v15 + 1;
    }
  }
  else
  {
    uint64_t v14 = *(unsigned __int16 *)(a2 + 208);
    if (v14 == 0xFFFF)
    {
      uint64_t v14 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v14;
      *(_WORD *)(a2 + 246) = v14 + 1;
    }
  }
  *(void *)&long long v18 = v13 | (v14 << 48);
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 256))(a2, &v17, a3, a4, a5, a6, a7, a8);
}

uint64_t gleStateProgram_RGBA_BLEND(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v33 = 0;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v5 = 0x3100180000;
  }
  else {
    uint64_t v5 = 0x3100080000;
  }
  unint64_t v28 = v5 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882;
  *(_DWORD *)(a2 + 16) = 2;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 208);
    if (v6 == 0xFFFF)
    {
      uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v6;
      *(_WORD *)(a2 + 246) = v6 + 1;
    }
    uint64_t v7 = (v6 << 48) | 0x40;
  }
  else
  {
    uint64_t v8 = *(unsigned __int16 *)(a2 + 24);
    if (v8 == 0xFFFF)
    {
      uint64_t v9 = *(__int16 *)(a2 + 240);
      uint64_t v8 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v9;
      *(_WORD *)(a2 + 4 * v9 + 22) = 1;
      *(_WORD *)(a2 + 240) = v9 + 1;
    }
    uint64_t v7 = v8 << 48;
  }
  *((void *)&v29 + 1) = v7 | 0x1FE00;
  uint64_t v10 = *(unsigned __int16 *)(a2 + 210);
  if (v10 == 0xFFFF)
  {
    uint64_t v10 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v10;
    *(_WORD *)(a2 + 246) = v10 + 1;
  }
  uint64_t v11 = 1918898176;
  *(void *)&long long v30 = (v10 << 48) | 0x1FE40;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v12 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v13 = 1918906368;
    if (v12 == 0xFFFF)
    {
      uint64_t v14 = *(__int16 *)(a2 + 244);
      uint64_t v12 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v14;
      *(_WORD *)(a2 + 172 + 4 * v14 + 2) = 0;
      *(_WORD *)(a2 + 244) = v14 + 1;
    }
  }
  else
  {
    uint64_t v12 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v13 = 1918898176;
    if (v12 == 0xFFFF)
    {
      uint64_t v12 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v12;
      *(_WORD *)(a2 + 246) = v12 + 1;
      uint64_t v13 = 1918898176;
    }
  }
  *(void *)&long long v29 = v13 | (v12 << 48) | 0x8000;
  (*(void (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v28);
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v15 = 0x3100180000;
  }
  else {
    uint64_t v15 = 0x3100080000;
  }
  unint64_t v28 = (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03 | v15;
  *(_DWORD *)(a2 + 16) = 3;
  uint64_t v16 = *(unsigned __int16 *)(a2 + 210);
  if (v16 == 0xFFFF)
  {
    uint64_t v16 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v16;
    *(_WORD *)(a2 + 246) = v16 + 1;
  }
  uint64_t v17 = 1689664;
  *((void *)&v29 + 1) = (v16 << 48) | 0x19C840;
  uint64_t v18 = a2 + 4 * a3;
  unsigned int v21 = *(unsigned __int16 *)(v18 + 84);
  long long v20 = (_WORD *)(v18 + 84);
  uint64_t v19 = v21;
  if (v21 == 0xFFFF)
  {
    uint64_t v22 = *(__int16 *)(a2 + 242);
    uint64_t v19 = *(unsigned __int16 *)(a2 + 242);
    *long long v20 = v22;
    *(_WORD *)(a2 + 4 * v22 + 86) = a3;
    *(_WORD *)(a2 + 242) = v22 + 1;
  }
  *(void *)&long long v30 = ((v19 << 48) | 0x19C840) + 64;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v23 = *(unsigned __int16 *)(a2 + 208);
    if (v23 == 0xFFFF)
    {
      uint64_t v23 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v23;
      *(_WORD *)(a2 + 246) = v23 + 1;
    }
  }
  else
  {
    uint64_t v23 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v17 = 1689600;
    if (v23 == 0xFFFF)
    {
      uint64_t v24 = *(__int16 *)(a2 + 240);
      uint64_t v23 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v24;
      *(_WORD *)(a2 + 4 * v24 + 22) = 1;
      *(_WORD *)(a2 + 240) = v24 + 1;
    }
  }
  *((void *)&v30 + 1) = v17 | (v23 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v25 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v11 = 1918906368;
    if (v25 == 0xFFFF)
    {
      uint64_t v26 = *(__int16 *)(a2 + 244);
      uint64_t v25 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v26;
      *(_WORD *)(a2 + 172 + 4 * v26 + 2) = 0;
      *(_WORD *)(a2 + 244) = v26 + 1;
    }
  }
  else
  {
    uint64_t v25 = *(unsigned __int16 *)(a2 + 208);
    if (v25 == 0xFFFF)
    {
      uint64_t v25 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v25;
      *(_WORD *)(a2 + 246) = v25 + 1;
    }
  }
  *(void *)&long long v29 = v11 | (v25 << 48) | 0x70000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v28);
}

uint64_t gleStateProgram_RGBA_ADD(unsigned char *a1, uint64_t a2)
{
  uint64_t v26 = 0;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  uint64_t v3 = 1572864;
  if (!*(unsigned char *)(a2 + 251)) {
    uint64_t v3 = 0x80000;
  }
  unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7));
  unint64_t v21 = v4 | 0x31000007C2;
  *(_DWORD *)(a2 + 16) = 2;
  if ((*a1 & 0x10) != 0) {
    unint64_t v21 = v4 | 0x831000007C2;
  }
  uint64_t v5 = *(unsigned __int16 *)(a2 + 210);
  if (v5 == 0xFFFF)
  {
    uint64_t v5 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v5;
    *(_WORD *)(a2 + 246) = v5 + 1;
  }
  *((void *)&v22 + 1) = (v5 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v7 = 1689664;
    if (v6 == 0xFFFF)
    {
      uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v6;
      *(_WORD *)(a2 + 246) = v6 + 1;
      uint64_t v7 = 1689664;
    }
  }
  else
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v7 = 1689600;
    if (v6 == 0xFFFF)
    {
      uint64_t v8 = *(__int16 *)(a2 + 240);
      uint64_t v6 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v8;
      *(_WORD *)(a2 + 4 * v8 + 22) = 1;
      *(_WORD *)(a2 + 240) = v8 + 1;
    }
  }
  uint64_t v9 = 1918898176;
  *(void *)&long long v23 = v7 | (v6 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v10 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v11 = 1918906368;
    if (v10 == 0xFFFF)
    {
      uint64_t v12 = *(__int16 *)(a2 + 244);
      uint64_t v10 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v12;
      *(_WORD *)(a2 + 172 + 4 * v12 + 2) = 0;
      *(_WORD *)(a2 + 244) = v12 + 1;
    }
  }
  else
  {
    uint64_t v10 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v11 = 1918898176;
    if (v10 == 0xFFFF)
    {
      uint64_t v10 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v10;
      *(_WORD *)(a2 + 246) = v10 + 1;
      uint64_t v11 = 1918898176;
    }
  }
  *(void *)&long long v22 = v11 | (v10 << 48) | 0x70000;
  (*(void (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v21);
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v13 = 0x3100180000;
  }
  else {
    uint64_t v13 = 0x3100080000;
  }
  unint64_t v21 = v13 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0x882;
  *(_DWORD *)(a2 + 16) = 2;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v14 = *(unsigned __int16 *)(a2 + 208);
    uint64_t v15 = 1689664;
    if (v14 == 0xFFFF)
    {
      uint64_t v14 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v14;
      *(_WORD *)(a2 + 246) = v14 + 1;
      uint64_t v15 = 1689664;
    }
  }
  else
  {
    uint64_t v14 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v15 = 1689600;
    if (v14 == 0xFFFF)
    {
      uint64_t v16 = *(__int16 *)(a2 + 240);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v16;
      *(_WORD *)(a2 + 4 * v16 + 22) = 1;
      *(_WORD *)(a2 + 240) = v16 + 1;
    }
  }
  *((void *)&v22 + 1) = v15 | (v14 << 48);
  uint64_t v17 = *(unsigned __int16 *)(a2 + 210);
  if (v17 == 0xFFFF)
  {
    uint64_t v17 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v17;
    *(_WORD *)(a2 + 246) = v17 + 1;
  }
  *(void *)&long long v23 = (v17 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v18 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v9 = 1918906368;
    if (v18 == 0xFFFF)
    {
      uint64_t v19 = *(__int16 *)(a2 + 244);
      uint64_t v18 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v19;
      *(_WORD *)(a2 + 172 + 4 * v19 + 2) = 0;
      *(_WORD *)(a2 + 244) = v19 + 1;
    }
  }
  else
  {
    uint64_t v18 = *(unsigned __int16 *)(a2 + 208);
    if (v18 == 0xFFFF)
    {
      uint64_t v18 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v18;
      *(_WORD *)(a2 + 246) = v18 + 1;
    }
  }
  *(void *)&long long v22 = v9 | (v18 << 48) | 0x8000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v21);
}

uint64_t gleStateProgram_I_BLEND(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = 0;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v8 = 0x3100180000;
  }
  else {
    uint64_t v8 = 0x3100080000;
  }
  unint64_t v22 = v8 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03;
  *(_DWORD *)(a2 + 16) = 3;
  uint64_t v9 = *(unsigned __int16 *)(a2 + 210);
  if (v9 == 0xFFFF)
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v9;
    *(_WORD *)(a2 + 246) = v9 + 1;
  }
  uint64_t v10 = 1689664;
  *((void *)&v23 + 1) = (v9 << 48) | 0x19C840;
  uint64_t v11 = a2 + 4 * (int)a3;
  unsigned int v14 = *(unsigned __int16 *)(v11 + 84);
  uint64_t v13 = (_WORD *)(v11 + 84);
  uint64_t v12 = v14;
  if (v14 == 0xFFFF)
  {
    uint64_t v15 = *(__int16 *)(a2 + 242);
    uint64_t v12 = *(unsigned __int16 *)(a2 + 242);
    *uint64_t v13 = v15;
    *(_WORD *)(a2 + 4 * v15 + 86) = a3;
    *(_WORD *)(a2 + 242) = v15 + 1;
  }
  *(void *)&long long v24 = ((v12 << 48) | 0x19C840) + 64;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v16 = *(unsigned __int16 *)(a2 + 208);
    if (v16 == 0xFFFF)
    {
      uint64_t v16 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v16;
      *(_WORD *)(a2 + 246) = v16 + 1;
    }
  }
  else
  {
    uint64_t v16 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v10 = 1689600;
    if (v16 == 0xFFFF)
    {
      uint64_t v17 = *(__int16 *)(a2 + 240);
      uint64_t v16 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v17;
      *(_WORD *)(a2 + 4 * v17 + 22) = 1;
      *(_WORD *)(a2 + 240) = v17 + 1;
    }
  }
  uint64_t v18 = 1919389696;
  *((void *)&v24 + 1) = v10 | (v16 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v19 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v18 = 1919397888;
    if (v19 == 0xFFFF)
    {
      uint64_t v20 = *(__int16 *)(a2 + 244);
      uint64_t v19 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v20;
      *(_WORD *)(a2 + 172 + 4 * v20 + 2) = 0;
      *(_WORD *)(a2 + 244) = v20 + 1;
    }
  }
  else
  {
    uint64_t v19 = *(unsigned __int16 *)(a2 + 208);
    if (v19 == 0xFFFF)
    {
      uint64_t v19 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v19;
      *(_WORD *)(a2 + 246) = v19 + 1;
    }
  }
  *(void *)&long long v23 = v18 | (v19 << 48);
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 256))(a2, &v22, a3, a4, a5, a6, a7, a8);
}

uint64_t gleStateProgram_I_ADD(unsigned char *a1, uint64_t a2)
{
  uint64_t v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  uint64_t v2 = 1572864;
  if (!*(unsigned char *)(a2 + 251)) {
    uint64_t v2 = 0x80000;
  }
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7));
  uint64_t v12 = v3 | 0x31000007C2;
  *(_DWORD *)(a2 + 16) = 2;
  if ((*a1 & 0x10) != 0) {
    uint64_t v12 = v3 | 0x831000007C2;
  }
  uint64_t v4 = *(unsigned __int16 *)(a2 + 210);
  if (v4 == 0xFFFF)
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v4;
    *(_WORD *)(a2 + 246) = v4 + 1;
  }
  uint64_t v5 = 1689664;
  *((void *)&v13 + 1) = (v4 << 48) | 0x19C840;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 208);
    if (v6 == 0xFFFF)
    {
      uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v6;
      *(_WORD *)(a2 + 246) = v6 + 1;
    }
  }
  else
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v5 = 1689600;
    if (v6 == 0xFFFF)
    {
      uint64_t v7 = *(__int16 *)(a2 + 240);
      uint64_t v6 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v7;
      *(_WORD *)(a2 + 4 * v7 + 22) = 1;
      *(_WORD *)(a2 + 240) = v7 + 1;
    }
  }
  uint64_t v8 = 1919389696;
  *(void *)&long long v14 = v5 | (v6 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v8 = 1919397888;
    if (v9 == 0xFFFF)
    {
      uint64_t v10 = *(__int16 *)(a2 + 244);
      uint64_t v9 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v10;
      *(_WORD *)(a2 + 172 + 4 * v10 + 2) = 0;
      *(_WORD *)(a2 + 244) = v10 + 1;
    }
  }
  else
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 208);
    if (v9 == 0xFFFF)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v9;
      *(_WORD *)(a2 + 246) = v9 + 1;
    }
  }
  *(void *)&long long v13 = v8 | (v9 << 48);
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 256))(a2, &v12);
}

uint64_t gleStateProgram_RGBA_DECAL(uint64_t a1, uint64_t a2)
{
  gleStateProgram_CheckDestInit(a2);
  uint64_t v20 = 0;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  if (*(unsigned char *)(a2 + 251)) {
    uint64_t v3 = 0x3100180000;
  }
  else {
    uint64_t v3 = 0x3100080000;
  }
  unint64_t v15 = v3 & 0xFFFFFFFFFFFFFFC7 | (8 * (*(_DWORD *)(a2 + 16) & 7)) | 0xF03;
  *(_DWORD *)(a2 + 16) = 3;
  uint64_t v4 = *(unsigned __int16 *)(a2 + 210);
  if (v4 == 0xFFFF)
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
    int v7 = *(unsigned __int16 *)(a2 + 246);
    *(_WORD *)(a2 + 210) = v6;
    *(_WORD *)(a2 + 246) = ++v7;
    *((void *)&v16 + 1) = ((unint64_t)(unsigned __int16)v6 << 48) | 0x1FE40;
    if ((v7 & 0x10000) != 0)
    {
      uint64_t v6 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 210) = v6;
      *(_WORD *)(a2 + 246) = v6 + 1;
    }
    uint64_t v5 = v6 << 48;
  }
  else
  {
    uint64_t v5 = v4 << 48;
    *((void *)&v16 + 1) = ((unint64_t)(unsigned __int16)v4 << 48) | 0x1FE40;
  }
  uint64_t v8 = 1689664;
  *(void *)&long long v17 = v5 | 0x19C840;
  if (*(unsigned char *)(a2 + 249))
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 208);
    if (v9 == 0xFFFF)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v9;
      *(_WORD *)(a2 + 246) = v9 + 1;
    }
  }
  else
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 24);
    uint64_t v8 = 1689600;
    if (v9 == 0xFFFF)
    {
      uint64_t v10 = *(__int16 *)(a2 + 240);
      uint64_t v9 = *(unsigned __int16 *)(a2 + 240);
      *(_WORD *)(a2 + 24) = v10;
      *(_WORD *)(a2 + 4 * v10 + 22) = 1;
      *(_WORD *)(a2 + 240) = v10 + 1;
    }
  }
  uint64_t v11 = 1918898176;
  *((void *)&v17 + 1) = v8 | (v9 << 48);
  if (*(unsigned char *)(a2 + 248))
  {
    uint64_t v12 = *(unsigned __int16 *)(a2 + 172);
    uint64_t v11 = 1918906368;
    if (v12 == 0xFFFF)
    {
      uint64_t v13 = *(__int16 *)(a2 + 244);
      uint64_t v12 = *(unsigned __int16 *)(a2 + 244);
      *(_WORD *)(a2 + 172) = v13;
      *(_WORD *)(a2 + 172 + 4 * v13 + 2) = 0;
      *(_WORD *)(a2 + 244) = v13 + 1;
    }
  }
  else
  {
    uint64_t v12 = *(unsigned __int16 *)(a2 + 208);
    if (v12 == 0xFFFF)
    {
      uint64_t v12 = *(unsigned __int16 *)(a2 + 246);
      *(_WORD *)(a2 + 208) = v12;
      *(_WORD *)(a2 + 246) = v12 + 1;
    }
  }
  *(void *)&long long v16 = v11 | (v12 << 48) | 0x70000;
  return (*(uint64_t (**)(uint64_t, unint64_t *))(a2 + 256))(a2, &v15);
}

void glpPrimitiveTypeToLLVMType_cold_1(unsigned int a1)
{
  uint64_t v1 = glpPrimitiveTypeToString(a1);
  printf("unhandled primitive type: %s\n", v1);
  abort();
}

void _glpSetCrashLogMessage_cold_1(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = a1;
  _os_log_fault_impl(&dword_239293000, &_os_log_internal, OS_LOG_TYPE_FAULT, "%s", (uint8_t *)&v1, 0xCu);
}

uint64_t appendTypeName_cold_1(uint64_t a1, uint64_t a2)
{
  return glpStringBufferAppendString(a2, *(void *)(a1 + 16), *(void *)(a1 + 24));
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x270ED7AF0](data, *(void *)&len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B30](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B38](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B40](c, data, *(void *)&len);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x270EE45E8](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x270EE4600]();
}

uint64_t CFCopySearchPathForDirectoriesInDomains()
{
  return MEMORY[0x270EE47A0]();
}

void CFRelease(CFTypeRef cf)
{
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x270EE5178](theString, buffer, bufferSize, *(void *)&encoding);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x270EE5328](anURL, pathStyle);
}

void *__cdecl IOSurfaceGetBaseAddressOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return (void *)MEMORY[0x270EF4C80](buffer, planeIndex);
}

size_t IOSurfaceGetBytesPerRowOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x270EF4CC0](buffer, planeIndex);
}

uint64_t IOSurfaceGetSeedOfPlane()
{
  return MEMORY[0x270EF4DA8]();
}

uint64_t IOSurfaceLockPlane()
{
  return MEMORY[0x270EF4E20]();
}

uint64_t IOSurfaceUnlockPlane()
{
  return MEMORY[0x270EF4E90]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t a1, locale_t a2)
{
  return MEMORY[0x270ED7D78](*(void *)&a1, a2);
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

int __maskrune_l(__darwin_ct_rune_t a1, unint64_t a2, locale_t a3)
{
  return MEMORY[0x270ED7E30](*(void *)&a1, a2, a3);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

uint64_t __strcpy_chk()
{
  return MEMORY[0x270ED7ED0]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x270ED7ED8]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x270ED7EE8]();
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x270ED7EF0]();
}

void _longjmp(jmp_buf a1, int a2)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int _setjmp(jmp_buf a1)
{
  return MEMORY[0x270ED8158](a1);
}

void abort(void)
{
}

float acosf(float a1)
{
  MEMORY[0x270ED8598](a1);
  return result;
}

float asinf(float a1)
{
  MEMORY[0x270ED8618](a1);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

float atanf(float a1)
{
  MEMORY[0x270ED86C0](a1);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x270ED9610](a1, a2);
}

float exp2f(float a1)
{
  MEMORY[0x270ED9868](a1);
  return result;
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x270ED9A10](a1, a2, a3);
}

void free(void *a1)
{
}

uint64_t fscache_element_get_data()
{
  return MEMORY[0x270EF9BF8]();
}

uint64_t fscache_find_and_retain()
{
  return MEMORY[0x270EF9C00]();
}

uint64_t fscache_insert_and_retain()
{
  return MEMORY[0x270EF9C10]();
}

uint64_t fscache_open()
{
  return MEMORY[0x270EF9C18]();
}

uint64_t fscache_release()
{
  return MEMORY[0x270EF9C28]();
}

uint64_t fscache_remove_and_release()
{
  return MEMORY[0x270EF9C30]();
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  return (FILE *)MEMORY[0x270ED9B78](a1, a2, a3, a4, a5);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x270ED9BE8](a1);
}

uint8_t *__cdecl getsectiondata(const mach_header_64 *mhp, const char *segname, const char *sectname, unint64_t *size)
{
  return (uint8_t *)MEMORY[0x270ED9D60](mhp, segname, sectname, size);
}

uint64_t glgConvertPixelWidthToBlocks()
{
  return MEMORY[0x270EF9DA0]();
}

uint64_t glgConvertType()
{
  return MEMORY[0x270EF9DA8]();
}

uint64_t glgGetCompressedBlockBytes()
{
  return MEMORY[0x270EF9DC0]();
}

uint64_t glgGetCompressedBlockHeight()
{
  return MEMORY[0x270EF9DC8]();
}

uint64_t glgGetCompressedImageBytes()
{
  return MEMORY[0x270EF9DD8]();
}

uint64_t glgGetPixelSize()
{
  return MEMORY[0x270EF9DE0]();
}

uint64_t glgProcessPixelsWithProcessor()
{
  return MEMORY[0x270EF9DE8]();
}

float log2f(float a1)
{
  MEMORY[0x270EDA0E0](a1);
  return result;
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

void longjmp(jmp_buf a1, int a2)
{
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA3A0](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA518](a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x270EDA598](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int mprotect(void *a1, size_t a2, int a3)
{
  return MEMORY[0x270EDA5C0](a1, a2, *(void *)&a3);
}

int msync(void *a1, size_t a2, int a3)
{
  return MEMORY[0x270EDA5E0](a1, a2, *(void *)&a3);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x270EDA5F8](a1, a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF60](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF70](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
}

int setjmp(jmp_buf a1)
{
  return MEMORY[0x270EDB3F8](a1);
}

float sinf(float a1)
{
  MEMORY[0x270EDB4F0](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x270EDB518](a1, a2, a3, a4);
}

int sprintf_l(char *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x270EDB538](a1, a2, a3);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB560](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDB568](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x270EDB5A0](__s1, __s2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x270EDB5C0](__dst, __src);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x270EDB648](__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return (char *)MEMORY[0x270EDB650](__s1, __n);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  MEMORY[0x270EDB6B0](a1, a2, a3);
  return result;
}

float strtof_l(const char *a1, char **a2, locale_t a3)
{
  MEMORY[0x270EDB6C0](a1, a2, a3);
  return result;
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x270EDB6E0](a1, a2, *(void *)&a3, a4);
}

uint64_t strtoll_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x270EDB6F0](a1, a2, *(void *)&a3, a4);
}

unint64_t strtoul_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x270EDB710](a1, a2, *(void *)&a3, a4);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x270EDB7C8](*(void *)&a1);
}

void syslog(int a1, const char *a2, ...)
{
}

float tanf(float a1)
{
  MEMORY[0x270EDB818](a1);
  return result;
}

int vsnprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, va_list a5)
{
  return MEMORY[0x270EDBB20](a1, a2, a3, a4, a5);
}