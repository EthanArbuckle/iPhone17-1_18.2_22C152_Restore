void sub_183331E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,void *a21,uint64_t a22,void *a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

void nw_protocol_transform_append_protocol(void *a1, int a2, void *a3)
{
  *(void *)&v48[13] = *MEMORY[0x1E4F143B8];
  v5 = a1;
  id v6 = a3;
  v7 = v6;
  if (!v5)
  {
    v24 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_transform_append_protocol";
    v25 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v25, &type, &v43)) {
      goto LABEL_86;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v46 = "nw_protocol_transform_append_protocol";
          __int16 v47 = 2082;
          *(void *)v48 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v31, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_86:
        if (!v25) {
          goto LABEL_36;
        }
        goto LABEL_87;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_1830D4000, v26, v31, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v26 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_1830D4000, v26, v38, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_85:

    goto LABEL_86;
  }
  if (!v6)
  {
    v28 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_transform_append_protocol";
    v25 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v25, &type, &v43)) {
      goto LABEL_86;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null protocol_parameters", buf, 0xCu);
      }
      goto LABEL_85;
    }
    if (!v43)
    {
      v26 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_1830D4000, v26, v39, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_85;
    }
    v33 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    os_log_type_t v34 = type;
    BOOL v35 = os_log_type_enabled(v26, type);
    if (!v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_1830D4000, v26, v34, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_85;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_transform_append_protocol";
      __int16 v47 = 2082;
      *(void *)v48 = v33;
      _os_log_impl(&dword_1830D4000, v26, v34, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_72;
  }
  v8 = (void *)v5[7];
  if (!v8)
  {
    v9 = objc_alloc_init(NWConcrete_nw_protocol_stack);
    if (v9)
    {
      if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
      }
      options = nw_protocol_create_options((void *)g_ip_definition);
      internet_protocol = v9->internet_protocol;
      v9->internet_protocol = (OS_nw_protocol_options *)options;
    }
    v12 = (void *)v5[7];
    v5[7] = v9;

    v8 = (void *)v5[7];
    if (!v8)
    {
      v36 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_transform_append_protocol";
      v25 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (!__nwlog_fault(v25, &type, &v43)) {
        goto LABEL_86;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        v26 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v46 = "nw_protocol_transform_append_protocol";
          _os_log_impl(&dword_1830D4000, v26, v37, "%{public}s called with null transform->transform_stack", buf, 0xCu);
        }
        goto LABEL_85;
      }
      if (!v43)
      {
        v26 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v46 = "nw_protocol_transform_append_protocol";
          _os_log_impl(&dword_1830D4000, v26, v42, "%{public}s called with null transform->transform_stack, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_85;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      os_log_type_t v40 = type;
      BOOL v41 = os_log_type_enabled(v26, type);
      if (!v33)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v46 = "nw_protocol_transform_append_protocol";
          _os_log_impl(&dword_1830D4000, v26, v40, "%{public}s called with null transform->transform_stack, no backtrace", buf, 0xCu);
        }
        goto LABEL_85;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v46 = "nw_protocol_transform_append_protocol";
        __int16 v47 = 2082;
        *(void *)v48 = v33;
        _os_log_impl(&dword_1830D4000, v26, v40, "%{public}s called with null transform->transform_stack, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_72:

      free(v33);
      if (!v25) {
        goto LABEL_36;
      }
LABEL_87:
      v23 = (char *)v25;
      goto LABEL_35;
    }
  }
  switch(a2)
  {
    case 2:
      v13 = v8;
      id v14 = v7;
      objc_storeStrong(v13 + 6, a3);
LABEL_15:

      goto LABEL_36;
    case 3:
      v13 = v8;
      id v14 = v7;
      objc_storeStrong(v13 + 3, a3);
      goto LABEL_15;
    case 4:
      nw_protocol_stack_append_application_protocol(v8, v7);
      goto LABEL_36;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v15 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v46 = "nw_protocol_transform_append_protocol";
  __int16 v47 = 1024;
  *(_DWORD *)v48 = a2;
  v16 = (const char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (!__nwlog_fault(v16, &type, &v43)) {
    goto LABEL_33;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_transform_append_protocol";
      __int16 v47 = 1024;
      *(_DWORD *)v48 = a2;
      _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Unsupported protocol level %u", buf, 0x12u);
    }
LABEL_32:

LABEL_33:
    if (!v16) {
      goto LABEL_36;
    }
    goto LABEL_34;
  }
  if (!v43)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_transform_append_protocol";
      __int16 v47 = 1024;
      *(_DWORD *)v48 = a2;
      _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s Unsupported protocol level %u, backtrace limit exceeded", buf, 0x12u);
    }
    goto LABEL_32;
  }
  v19 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = (id)gLogObj;
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v17, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_transform_append_protocol";
      __int16 v47 = 1024;
      *(_DWORD *)v48 = a2;
      _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s Unsupported protocol level %u, no backtrace", buf, 0x12u);
    }
    goto LABEL_32;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446722;
    v46 = "nw_protocol_transform_append_protocol";
    __int16 v47 = 1024;
    *(_DWORD *)v48 = a2;
    v48[2] = 2082;
    *(void *)&v48[3] = v19;
    _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s Unsupported protocol level %u, dumping backtrace:%{public}s", buf, 0x1Cu);
  }

  free(v19);
  if (v16)
  {
LABEL_34:
    v23 = (char *)v16;
LABEL_35:
    free(v23);
  }
LABEL_36:
}

void sub_18333297C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_stack_append_application_protocol(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  v3 = a1;
  id v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
    v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
          __int16 v30 = 2082;
          os_log_type_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v13) {
          goto LABEL_8;
        }
LABEL_43:
        free(v13);
        goto LABEL_8;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v14 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
        _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (v4)
  {
    if (nw_protocol_options_are_persistent(v4))
    {
      combined_array = nw_array_create_combined_array(v3[1], v3[2]);
      v7 = v3[1];
      v3[1] = combined_array;

      nw_array_append((uint64_t)v3[1], v5);
      v8 = v3[2];
      v3[2] = 0;
    }
    else
    {
      uint64_t v9 = (uint64_t)v3[2];
      if (!v9)
      {
        BOOL v10 = nw_array_create();
        v11 = v3[2];
        v3[2] = (void *)v10;

        uint64_t v9 = (uint64_t)v3[2];
      }
      nw_array_append(v9, v5);
    }
    goto LABEL_8;
  }
  v16 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
  v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v13, &type, &v26)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v14 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null protocol", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v26)
  {
    id v14 = __nwlog_obj();
    os_log_type_t v25 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
      _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  BOOL v21 = (char *)__nw_create_backtrace_string();
  id v14 = __nwlog_obj();
  os_log_type_t v22 = type;
  BOOL v23 = os_log_type_enabled(v14, type);
  if (!v21)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
      _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v29 = "nw_protocol_stack_append_application_protocol";
    __int16 v30 = 2082;
    os_log_type_t v31 = v21;
    _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v21);
  if (v13) {
    goto LABEL_43;
  }
LABEL_8:
}

BOOL nw_protocol_options_are_persistent(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_protocol_options_copy_definition";
    v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v8, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_protocol_options_copy_definition";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }
      }
      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            char v26 = "nw_protocol_options_copy_definition";
            __int16 v27 = 2082;
            v28 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_protocol_options_copy_definition";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_protocol_options_copy_definition";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v8) {
      free(v8);
    }
    goto LABEL_23;
  }
  id v3 = v1[1];

  if (v3)
  {
    id v4 = v3;

    BOOL v5 = v4[10] == 5;
    goto LABEL_4;
  }
LABEL_23:
  os_log_type_t v15 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_protocol_options_are_persistent";
  v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_options_are_persistent";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v23)
    {
      os_log_type_t v19 = (char *)__nw_create_backtrace_string();
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_protocol_options_are_persistent";
          __int16 v27 = 2082;
          v28 = v19;
          _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v19);
        goto LABEL_39;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_options_are_persistent";
        _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_options_are_persistent";
        _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_39:
  if (v16) {
    free(v16);
  }
  id v4 = 0;
  BOOL v5 = 0;
LABEL_4:

  return v5;
}

void nw_quic_connection_set_sec_protocol_options(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_sec_protocol_options_block_invoke;
    v13[3] = &unk_1E5248F68;
    id v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_quic_connection_set_sec_protocol_options";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_quic_connection_set_sec_protocol_options";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_quic_connection_set_sec_protocol_options";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_quic_connection_set_sec_protocol_options";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_quic_connection_set_sec_protocol_options";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_183333690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_protocol_options_set_prohibit_joining(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  v2 = v1;
  if (v1)
  {
    *((unsigned char *)v1 + 153) = 1;
    goto LABEL_3;
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v14 = "nw_protocol_options_set_prohibit_joining";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        id v14 = "nw_protocol_options_set_prohibit_joining";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          id v14 = "nw_protocol_options_set_prohibit_joining";
          __int16 v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        id v14 = "nw_protocol_options_set_prohibit_joining";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        id v14 = "nw_protocol_options_set_prohibit_joining";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

void nw_protocol_http2_transport_frame_input_finalizer(nw_frame *a1, int a2, void *a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    char v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v62 = "nw_protocol_http2_transport_frame_input_finalizer";
      _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v6, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_http2_transport_frame_input_finalizer";
          BOOL v9 = "%{public}s called with null frame";
          goto LABEL_33;
        }
      }
      else if (v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v45 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v63 = 2082;
            uint64_t v64 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_http2_transport_frame_input_finalizer";
          BOOL v9 = "%{public}s called with null frame, no backtrace";
          goto LABEL_33;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_http2_transport_frame_input_finalizer";
          BOOL v9 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_33;
        }
      }
    }
    goto LABEL_35;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v6, &type, &v59)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      v62 = "nw_protocol_http2_transport_frame_input_finalizer";
      BOOL v9 = "%{public}s http2_transport input frames should no longer have nonnull context";
    }
    else
    {
      if (v59)
      {
        __int16 v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v15)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v63 = 2082;
            uint64_t v64 = (uint64_t)v15;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s http2_transport input frames should no longer have nonnull context, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v15);
          if (v6) {
            goto LABEL_36;
          }
          return;
        }
        if (!v18) {
          goto LABEL_35;
        }
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s http2_transport input frames should no longer have nonnull context, no backtrace";
        os_log_type_t v22 = v16;
        os_log_type_t v23 = v17;
        goto LABEL_34;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      v62 = "nw_protocol_http2_transport_frame_input_finalizer";
      BOOL v9 = "%{public}s http2_transport input frames should no longer have nonnull context, backtrace limit exceeded";
    }
LABEL_33:
    os_log_type_t v22 = v7;
    os_log_type_t v23 = v8;
LABEL_34:
    _os_log_impl(&dword_1830D4000, v22, v23, v9, buf, 0xCu);
    goto LABEL_35;
  }
  if ((*((_WORD *)a1 + 102) & 4) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v6, &type, &v59)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null input_frame_context";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    if (!v59)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null input_frame_context, backtrace limit exceeded";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    __int16 v47 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v48 = os_log_type_enabled(v7, type);
    if (!v47)
    {
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null input_frame_context, no backtrace";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    if (!v48) {
      goto LABEL_125;
    }
    *(_DWORD *)buf = 136446466;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    __int16 v63 = 2082;
    uint64_t v64 = (uint64_t)v47;
    v49 = "%{public}s called with null input_frame_context, dumping backtrace:%{public}s";
LABEL_124:
    _os_log_impl(&dword_1830D4000, v7, v8, v49, buf, 0x16u);
    goto LABEL_125;
  }
  uint64_t v10 = *((void *)a1 + 26);
  if (!v10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v6, &type, &v59)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null http2_transport";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    if (!v59)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    __int16 v47 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v54 = os_log_type_enabled(v7, type);
    if (!v47)
    {
      if (v54)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    if (!v54) {
      goto LABEL_125;
    }
    *(_DWORD *)buf = 136446466;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    __int16 v63 = 2082;
    uint64_t v64 = (uint64_t)v47;
    v49 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_124;
  }
  uint64_t v11 = *((void *)a1 + 27);
  if (v11)
  {
    if (gLogDatapath)
    {
      v46 = __nwlog_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        __int16 v63 = 2082;
        uint64_t v64 = v10 + 205;
        _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s finalizing input frame", buf, 0x16u);
      }
    }
    uint64_t v12 = *((void *)a1 + 2);
    BOOL v13 = (void *)*((void *)a1 + 3);
    id v14 = (void *)((char *)a1 + 16);
    if (v12)
    {
      *(void *)(v12 + 24) = v13;
      BOOL v13 = (void *)*((void *)a1 + 3);
    }
    else
    {
      *(void *)(v10 + 152) = v13;
    }
    void *v13 = v12;
    *id v14 = 0;
    *((void *)a1 + 3) = 0;
    if (!a2)
    {
      if (gLogDatapath)
      {
        v50 = __nwlog_obj();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v62 = "nw_protocol_http2_transport_frame_input_finalizer";
          __int16 v63 = 2082;
          uint64_t v64 = v10 + 205;
          _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disposing of input frame, finalizer called with success == false", buf, 0x16u);
        }
      }
      if ((*((_WORD *)a1 + 102) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(a1, *((void *)a1 + 11)))
      {
        uint64_t v21 = (void *)*((void *)a1 + 14);
        if (v21) {
          free(v21);
        }
      }
      nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
      os_release(a1);
      return;
    }
    int v19 = *((_DWORD *)a1 + 13);
    if (v19) {
      int v20 = v19 - (*((_DWORD *)a1 + 14) + *((_DWORD *)a1 + 15));
    }
    else {
      int v20 = 0;
    }
    if (!nghttp2_session_consume_stream())
    {
LABEL_57:
      if (gLogDatapath)
      {
        v51 = __nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          int v52 = *(_DWORD *)(v11 + 32);
          *(_DWORD *)buf = 136446978;
          v62 = "nw_protocol_http2_transport_frame_input_finalizer";
          __int16 v63 = 2082;
          uint64_t v64 = v10 + 205;
          __int16 v65 = 1024;
          *(_DWORD *)v66 = v20;
          *(_WORD *)&v66[4] = 1024;
          *(_DWORD *)&v66[6] = v52;
          _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s consumed %u bytes on stream %d", buf, 0x22u);
        }
        if (gLogDatapath)
        {
          v53 = __nwlog_obj();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v62 = "http2_transport_cache_input_frame";
            __int16 v63 = 2082;
            uint64_t v64 = v10 + 205;
            __int16 v65 = 2048;
            *(void *)v66 = a1;
            _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s caching input frame %p", buf, 0x20u);
          }
        }
      }
      if ((http2_transport_input_frame_context_reset((uint64_t)a1, 0, 0) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v41 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v62 = "http2_transport_cache_input_frame";
          __int16 v63 = 2082;
          uint64_t v64 = v10 + 205;
          __int16 v65 = 2048;
          *(void *)v66 = a1;
          _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_ERROR, "%{public}s %{public}s ERROR: unable to clear metadata for input frame %p, freeing", buf, 0x20u);
        }
        if ((*((_WORD *)a1 + 102) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(a1, *((void *)a1 + 11)))
        {
          os_log_type_t v42 = (void *)*((void *)a1 + 14);
          if (v42) {
            free(v42);
          }
        }
        nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
        os_release(a1);
        goto LABEL_76;
      }
      if ((*((_WORD *)a1 + 102) & 0x100) != 0
        && g_channel_check_validity
        && !g_channel_check_validity(a1, *((void *)a1 + 11)))
      {
        int v35 = 0;
        uint64_t v36 = 0;
        if (!gLogDatapath) {
          goto LABEL_63;
        }
      }
      else
      {
        int v35 = *((_DWORD *)a1 + 12);
        uint64_t v36 = *((void *)a1 + 14);
        if (!gLogDatapath)
        {
LABEL_63:
          nw_frame_reset((uint64_t)a1, v36, v35, (uint64_t)nw_protocol_http2_transport_frame_input_finalizer, 0);
          int v38 = *(_DWORD *)(v10 + 192);
          uint64_t v39 = *(void *)(v10 + 160);
          *((void *)a1 + 2) = v39;
          if (v39) {
            os_log_type_t v40 = (void *)(v39 + 24);
          }
          else {
            os_log_type_t v40 = (void *)(v10 + 168);
          }
          *os_log_type_t v40 = v14;
          *(void *)(v10 + 160) = a1;
          *((void *)a1 + 3) = v10 + 160;
          *(_DWORD *)(v10 + 192) = v38 + 1;
          if (gLogDatapath)
          {
            v56 = __nwlog_obj();
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              v62 = "http2_transport_cache_input_frame";
              __int16 v63 = 2082;
              uint64_t v64 = v10 + 205;
              __int16 v65 = 1024;
              *(_DWORD *)v66 = v35;
              _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reset input frame of length %u, eligible for reuse", buf, 0x1Cu);
            }
          }
          http2_transport_purge_frame_cache_if_necessary((nw_frame_array_s *)(v10 + 160), (int *)(v10 + 192), v37);
LABEL_76:
          nw_http2_transport_session_send(v10);
          return;
        }
      }
      v57 = __nwlog_obj();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        v62 = "http2_transport_cache_input_frame";
        __int16 v63 = 2082;
        uint64_t v64 = v10 + 205;
        __int16 v65 = 2048;
        *(void *)v66 = a1;
        *(_WORD *)&v66[8] = 2048;
        uint64_t v67 = v36;
        __int16 v68 = 1024;
        int v69 = v35;
        _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s resetting input frame %p to buffer %p, length %u", buf, 0x30u);
      }
      goto LABEL_63;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v24 = nghttp2_strerror();
    *(_DWORD *)buf = 136446466;
    v62 = "nw_protocol_http2_transport_frame_input_finalizer";
    __int16 v63 = 2082;
    uint64_t v64 = v24;
    os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v25, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v26 = gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_55;
        }
        uint64_t v28 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        __int16 v63 = 2082;
        uint64_t v64 = v28;
        uint64_t v29 = "%{public}s nghttp2_session_consume_stream: %{public}s failed";
        goto LABEL_54;
      }
      if (!v59)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v26 = gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_55;
        }
        uint64_t v33 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        __int16 v63 = 2082;
        uint64_t v64 = v33;
        uint64_t v29 = "%{public}s nghttp2_session_consume_stream: %{public}s failed, backtrace limit exceeded";
        goto LABEL_54;
      }
      int v58 = v20;
      __int16 v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v26 = gLogObj;
      os_log_type_t v27 = type;
      BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v30)
      {
        if (v31)
        {
          uint64_t v32 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          v62 = "nw_protocol_http2_transport_frame_input_finalizer";
          __int16 v63 = 2082;
          uint64_t v64 = v32;
          __int16 v65 = 2082;
          *(void *)v66 = v30;
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s nghttp2_session_consume_stream: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v30);
        int v20 = v58;
        goto LABEL_55;
      }
      int v20 = v58;
      if (v31)
      {
        uint64_t v34 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        __int16 v63 = 2082;
        uint64_t v64 = v34;
        uint64_t v29 = "%{public}s nghttp2_session_consume_stream: %{public}s failed, no backtrace";
LABEL_54:
        _os_log_impl(&dword_1830D4000, v26, v27, v29, buf, 0x16u);
      }
    }
LABEL_55:
    if (v25) {
      free(v25);
    }
    goto LABEL_57;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v62 = "nw_protocol_http2_transport_frame_input_finalizer";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v59 = 0;
  if (__nwlog_fault(v6, &type, &v59))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null stream";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    if (!v59)
    {
      v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    __int16 v47 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v55 = os_log_type_enabled(v7, type);
    if (!v47)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_http2_transport_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null stream, no backtrace";
        goto LABEL_33;
      }
      goto LABEL_35;
    }
    if (v55)
    {
      *(_DWORD *)buf = 136446466;
      v62 = "nw_protocol_http2_transport_frame_input_finalizer";
      __int16 v63 = 2082;
      uint64_t v64 = (uint64_t)v47;
      v49 = "%{public}s called with null stream, dumping backtrace:%{public}s";
      goto LABEL_124;
    }
LABEL_125:
    free(v47);
    if (v6) {
      goto LABEL_36;
    }
    return;
  }
LABEL_35:
  if (v6) {
LABEL_36:
  }
    free(v6);
}

uint64_t http2_transport_input_frame_context_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "__nw_frame_get_metadata";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v12, &type, &v18)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_get_metadata";
      __int16 v15 = "%{public}s called with null frame";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v21 = "__nw_frame_get_metadata";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_39;
      }
      if (!v17)
      {
LABEL_39:
        if (v12) {
          free(v12);
        }
        goto LABEL_3;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_get_metadata";
      __int16 v15 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_get_metadata";
      __int16 v15 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
    goto LABEL_39;
  }
  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(void *)(a1 + 208) = a2;
    *(void *)(a1 + 216) = a3;
    return 1;
  }
LABEL_3:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2) {
    id v4 = (const char *)(a2 + 205);
  }
  else {
    id v4 = "";
  }
  *(_DWORD *)buf = 136446466;
  uint64_t v21 = "http2_transport_input_frame_context_reset";
  __int16 v22 = 2082;
  os_log_type_t v23 = (void *)v4;
  BOOL v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18)) {
    goto LABEL_21;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = gLogObj;
    os_log_type_t v7 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "http2_transport_input_frame_context_reset";
      __int16 v22 = 2082;
      os_log_type_t v23 = (void *)v4;
      os_log_type_t v8 = "%{public}s %{public}s frame has no metadata";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x16u);
    }
  }
  else if (v18)
  {
    uint64_t v10 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = gLogObj;
    os_log_type_t v7 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v21 = "http2_transport_input_frame_context_reset";
        __int16 v22 = 2082;
        os_log_type_t v23 = (void *)v4;
        __int16 v24 = 2082;
        os_log_type_t v25 = v10;
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s %{public}s frame has no metadata, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v10);
      goto LABEL_21;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "http2_transport_input_frame_context_reset";
      __int16 v22 = 2082;
      os_log_type_t v23 = (void *)v4;
      os_log_type_t v8 = "%{public}s %{public}s frame has no metadata, no backtrace";
      goto LABEL_20;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = gLogObj;
    os_log_type_t v7 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "http2_transport_input_frame_context_reset";
      __int16 v22 = 2082;
      os_log_type_t v23 = (void *)v4;
      os_log_type_t v8 = "%{public}s %{public}s frame has no metadata, backtrace limit exceeded";
      goto LABEL_20;
    }
  }
LABEL_21:
  if (v5) {
    free(v5);
  }
  return 0;
}

void nw_http2_transport_session_send(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    os_log_type_t v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v28 = "nw_http2_transport_session_send";
      __int16 v29 = 2082;
      *(void *)__int16 v30 = a1 + 205;
      _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  if (nghttp2_session_want_write())
  {
    if (gLogDatapath)
    {
      v2 = __nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 2082;
        *(void *)__int16 v30 = a1 + 205;
        id v3 = "%{public}s %{public}s nghttp2 wants to write";
LABEL_45:
        _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEBUG, v3, buf, 0x16u);
      }
    }
  }
  else if (gLogDatapath)
  {
    v2 = __nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v28 = "nw_http2_transport_session_send";
      __int16 v29 = 2082;
      *(void *)__int16 v30 = a1 + 205;
      id v3 = "%{public}s %{public}s nghttp2 does not want to write";
      goto LABEL_45;
    }
  }
  if ((*(unsigned char *)(a1 + 204) & 0x20) == 0)
  {
    int stream_remote_window_size = nghttp2_session_get_stream_remote_window_size();
    if (stream_remote_window_size >= (int)nghttp2_session_get_remote_window_size()) {
      int remote_window_size = nghttp2_session_get_remote_window_size();
    }
    else {
      int remote_window_size = nghttp2_session_get_stream_remote_window_size();
    }
    int v7 = remote_window_size;
    if (gLogDatapath)
    {
      __int16 v24 = __nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 2082;
        *(void *)__int16 v30 = a1 + 205;
        *(_WORD *)&v30[8] = 2048;
        *(void *)&v30[10] = v7;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s window size that we can send is %llu bytes", buf, 0x20u);
      }
    }
    *(unsigned char *)(a1 + 204) |= 0x20u;
    int v8 = nghttp2_session_send();
    if (!v8) {
      goto LABEL_37;
    }
    int v9 = v8;
    char v10 = *(unsigned char *)(a1 + 204);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = gLogObj;
    if (v9 == -902 && (v10 & 8) != 0)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 2082;
        *(void *)__int16 v30 = a1 + 205;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s tunnel error, send failed, closing", buf, 0x16u);
      }
LABEL_36:
      nw_http2_transport_connection_close(a1);
LABEL_37:
      *(unsigned char *)(a1 + 204) &= ~0x20u;
      return;
    }
    uint64_t v12 = nghttp2_strerror();
    *(_DWORD *)buf = 136446722;
    uint64_t v28 = "nw_http2_transport_session_send";
    __int16 v29 = 1024;
    *(_DWORD *)__int16 v30 = v9;
    *(_WORD *)&v30[4] = 2082;
    *(void *)&v30[6] = v12;
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_34;
        }
        uint64_t v16 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        uint64_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 1024;
        *(_DWORD *)__int16 v30 = v9;
        *(_WORD *)&v30[4] = 2082;
        *(void *)&v30[6] = v16;
        BOOL v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed";
        goto LABEL_33;
      }
      if (!v25)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_34;
        }
        uint64_t v21 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        uint64_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 1024;
        *(_DWORD *)__int16 v30 = v9;
        *(_WORD *)&v30[4] = 2082;
        *(void *)&v30[6] = v21;
        BOOL v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, backtrace limit exceeded";
        goto LABEL_33;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v14 = gLogObj;
      os_log_type_t v15 = type;
      BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v19)
        {
          uint64_t v20 = nghttp2_strerror();
          *(_DWORD *)buf = 136446978;
          uint64_t v28 = "nw_http2_transport_session_send";
          __int16 v29 = 1024;
          *(_DWORD *)__int16 v30 = v9;
          *(_WORD *)&v30[4] = 2082;
          *(void *)&v30[6] = v20;
          *(_WORD *)&v30[14] = 2082;
          *(void *)&v30[16] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, dumping backtrace:%{public}s", buf, 0x26u);
        }
        free(backtrace_string);
        goto LABEL_34;
      }
      if (v19)
      {
        uint64_t v22 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        uint64_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 1024;
        *(_DWORD *)__int16 v30 = v9;
        *(_WORD *)&v30[4] = 2082;
        *(void *)&v30[6] = v22;
        BOOL v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, no backtrace";
LABEL_33:
        _os_log_impl(&dword_1830D4000, v14, v15, v17, buf, 0x1Cu);
      }
    }
LABEL_34:
    if (v13) {
      free(v13);
    }
    goto LABEL_36;
  }
  if (gLogDatapath)
  {
    os_log_type_t v6 = __nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v28 = "nw_http2_transport_session_send";
      __int16 v29 = 2082;
      *(void *)__int16 v30 = a1 + 205;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s already in session send, skipping", buf, 0x16u);
    }
  }
}

void http2_transport_purge_frame_cache_if_necessary(nw_frame_array_s *a1, int *a2, unsigned int *a3)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "http2_transport_purge_frame_cache_if_necessary";
    int v69 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v69, &type, &v79)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      v72 = "%{public}s called with null frame_cache";
      goto LABEL_135;
    }
    if (!v79)
    {
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      v72 = "%{public}s called with null frame_cache, backtrace limit exceeded";
      goto LABEL_135;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v70 = __nwlog_obj();
    os_log_type_t v71 = type;
    BOOL v76 = os_log_type_enabled(v70, type);
    if (!backtrace_string)
    {
      if (!v76) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      v72 = "%{public}s called with null frame_cache, no backtrace";
      goto LABEL_135;
    }
    if (v76)
    {
      *(_DWORD *)buf = 136446466;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v83 = 2082;
      *(void *)v84 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s called with null frame_cache, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_136:
    if (!v69) {
      return;
    }
    goto LABEL_137;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "http2_transport_purge_frame_cache_if_necessary";
    int v69 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v69, &type, &v79)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      v72 = "%{public}s called with null frame_cache_count";
      goto LABEL_135;
    }
    if (!v79)
    {
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      v72 = "%{public}s called with null frame_cache_count, backtrace limit exceeded";
      goto LABEL_135;
    }
    v77 = (char *)__nw_create_backtrace_string();
    uint64_t v70 = __nwlog_obj();
    os_log_type_t v71 = type;
    BOOL v78 = os_log_type_enabled(v70, type);
    if (v77)
    {
      if (v78)
      {
        *(_DWORD *)buf = 136446466;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        __int16 v83 = 2082;
        *(void *)v84 = v77;
        _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s called with null frame_cache_count, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v77);
      if (!v69) {
        return;
      }
LABEL_137:
      free(v69);
      return;
    }
    if (v78)
    {
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      v72 = "%{public}s called with null frame_cache_count, no backtrace";
LABEL_135:
      _os_log_impl(&dword_1830D4000, v70, v71, v72, buf, 0xCu);
      goto LABEL_136;
    }
    goto LABEL_136;
  }
  if (gLogDatapath)
  {
    v73 = __nwlog_obj();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      int v74 = *a2;
      *(_DWORD *)buf = 136446466;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v83 = 1024;
      *(_DWORD *)v84 = v74;
      _os_log_impl(&dword_1830D4000, v73, OS_LOG_TYPE_DEBUG, "%{public}s total %u empty frames in cache (initial)", buf, 0x12u);
    }
  }
  if (*a2 >= 0x15)
  {
    while (1)
    {
      if (gLogDatapath)
      {
        uint64_t v21 = __nwlog_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          int v22 = *a2;
          *(_DWORD *)buf = 136446722;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          __int16 v83 = 1024;
          *(_DWORD *)v84 = v22;
          *(_WORD *)&v84[4] = 1024;
          *(_DWORD *)&v84[6] = 20;
          _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s too many frames in frame cache (%u > %u), pruning", buf, 0x18u);
        }
      }
      uint64_t v5 = **((void **)a1->tqh_last + 1);
      if (!v5)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v43 = *a2;
        *(_DWORD *)buf = 136446466;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        __int16 v83 = 1024;
        *(_DWORD *)v84 = v43;
        v44 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v79 = 0;
        if (!__nwlog_fault(v44, &type, &v79)) {
          goto LABEL_102;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v45 = gLogObj;
          os_log_type_t v46 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_102;
          }
          int v47 = *a2;
          *(_DWORD *)buf = 136446466;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          __int16 v83 = 1024;
          *(_DWORD *)v84 = v47;
          BOOL v48 = "%{public}s no more frames in frame cache, we thought we had %u frames";
          goto LABEL_97;
        }
        if (v79)
        {
          v53 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v45 = gLogObj;
          os_log_type_t v46 = type;
          BOOL v54 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v53)
          {
            if (v54)
            {
              int v55 = *a2;
              *(_DWORD *)buf = 136446722;
              v82 = "http2_transport_purge_frame_cache_if_necessary";
              __int16 v83 = 1024;
              *(_DWORD *)v84 = v55;
              *(_WORD *)&v84[4] = 2082;
              *(void *)&v84[6] = v53;
              v56 = "%{public}s no more frames in frame cache, we thought we had %u frames, dumping backtrace:%{public}s";
              v57 = v45;
              os_log_type_t v58 = v46;
              uint32_t v59 = 28;
              goto LABEL_89;
            }
            goto LABEL_90;
          }
          if (!v54) {
            goto LABEL_102;
          }
          int v64 = *a2;
          *(_DWORD *)buf = 136446466;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          __int16 v83 = 1024;
          *(_DWORD *)v84 = v64;
          BOOL v48 = "%{public}s no more frames in frame cache, we thought we had %u frames, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v45 = gLogObj;
          os_log_type_t v46 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_102;
          }
          int v62 = *a2;
          *(_DWORD *)buf = 136446466;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          __int16 v83 = 1024;
          *(_DWORD *)v84 = v62;
          BOOL v48 = "%{public}s no more frames in frame cache, we thought we had %u frames, backtrace limit exceeded";
        }
LABEL_97:
        __int16 v65 = v45;
        os_log_type_t v66 = v46;
        uint32_t v67 = 18;
        goto LABEL_101;
      }
      uint64_t v6 = *(void *)(v5 + 16);
      int v7 = *(nw_frame ***)(v5 + 24);
      if (v6)
      {
        *(void *)(v6 + 24) = v7;
        int v7 = *(nw_frame ***)(v5 + 24);
      }
      else
      {
        a1->tqh_last = v7;
      }
      NSObject *v7 = (nw_frame *)v6;
      *(void *)(v5 + 16) = 0;
      *(void *)(v5 + 24) = 0;
      if (!*a2) {
        break;
      }
      --*a2;
LABEL_30:
      if ((*(_WORD *)(v5 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || ((uint64_t (*)(uint64_t, void, unsigned int *))g_channel_check_validity)(v5, *(void *)(v5 + 88), a3))
      {
        uint64_t v20 = *(void **)(v5 + 112);
        if (v20) {
          free(v20);
        }
      }
      nw_frame_reset(v5, 0, 0, 0, 0);
      os_release((void *)v5);
      if (*a2 <= 0x14) {
        goto LABEL_37;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v82 = "http2_transport_purge_frame_cache_if_necessary";
    int v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (__nwlog_fault(v8, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)buf = 136446210;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        BOOL v11 = v9;
        os_log_type_t v12 = v10;
        BOOL v13 = "%{public}s http2_transport count attempted to decrement below zero";
        goto LABEL_27;
      }
      if (!v79)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = gLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)buf = 136446210;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        BOOL v11 = v18;
        os_log_type_t v12 = v19;
        BOOL v13 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
        goto LABEL_27;
      }
      os_log_type_t v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v14)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          __int16 v83 = 2082;
          *(void *)v84 = v14;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v14);
        goto LABEL_28;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        BOOL v11 = v15;
        os_log_type_t v12 = v16;
        BOOL v13 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_27:
        _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      }
    }
LABEL_28:
    if (v8) {
      free(v8);
    }
    goto LABEL_30;
  }
LABEL_37:
  *(_DWORD *)buf = 0;
  nw_frame_array_get_frame_count((uint64_t *)a1, 0, buf);
  int v23 = *(_DWORD *)buf;
  if (*(_DWORD *)buf < 0x1000001u)
  {
LABEL_38:
    if (gLogDatapath)
    {
      __int16 v24 = __nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        int v25 = *a2;
        *(_DWORD *)buf = 136446466;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        __int16 v83 = 1024;
        *(_DWORD *)v84 = v25;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s total %u empty frames in cache (final)", buf, 0x12u);
      }
    }
    return;
  }
  while (1)
  {
    if (gLogDatapath)
    {
      os_log_type_t v42 = __nwlog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        __int16 v83 = 1024;
        *(_DWORD *)v84 = v23;
        *(_WORD *)&v84[4] = 1024;
        *(_DWORD *)&v84[6] = 0x1000000;
        _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEBUG, "%{public}s too many bytes in frame cache (%u > %u), pruning", buf, 0x18u);
      }
    }
    uint64_t v26 = **((void **)a1->tqh_last + 1);
    if (!v26) {
      break;
    }
    uint64_t v27 = *(void *)(v26 + 16);
    uint64_t v28 = *(nw_frame ***)(v26 + 24);
    if (v27)
    {
      *(void *)(v27 + 24) = v28;
      uint64_t v28 = *(nw_frame ***)(v26 + 24);
    }
    else
    {
      a1->tqh_last = v28;
    }
    const char *v28 = (nw_frame *)v27;
    *(void *)(v26 + 16) = 0;
    *(void *)(v26 + 24) = 0;
    if (!*a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v29 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v79 = 0;
      if (!__nwlog_fault(v29, &type, &v79)) {
        goto LABEL_64;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v30 = gLogObj;
        os_log_type_t v31 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          uint64_t v32 = v30;
          os_log_type_t v33 = v31;
          uint64_t v34 = "%{public}s http2_transport count attempted to decrement below zero";
          goto LABEL_63;
        }
        goto LABEL_64;
      }
      if (v79)
      {
        int v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v36 = gLogObj;
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v35)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            v82 = "http2_transport_purge_frame_cache_if_necessary";
            __int16 v83 = 2082;
            *(void *)v84 = v35;
            _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v35);
          goto LABEL_64;
        }
        if (!v38)
        {
LABEL_64:
          if (v29) {
            free(v29);
          }
          goto LABEL_66;
        }
        *(_DWORD *)buf = 136446210;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        uint64_t v32 = v36;
        os_log_type_t v33 = v37;
        uint64_t v34 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v39 = gLogObj;
        os_log_type_t v40 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_64;
        }
        *(_DWORD *)buf = 136446210;
        v82 = "http2_transport_purge_frame_cache_if_necessary";
        uint64_t v32 = v39;
        os_log_type_t v33 = v40;
        uint64_t v34 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
      }
LABEL_63:
      _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0xCu);
      goto LABEL_64;
    }
    --*a2;
LABEL_66:
    if ((*(_WORD *)(v26 + 204) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(v26, *(void *)(v26 + 88)))
    {
      BOOL v41 = *(void **)(v26 + 112);
      if (v41) {
        free(v41);
      }
    }
    nw_frame_reset(v26, 0, 0, 0, 0);
    os_release((void *)v26);
    *(_DWORD *)buf = 0;
    nw_frame_array_get_frame_count((uint64_t *)a1, 0, buf);
    int v23 = *(_DWORD *)buf;
    if (*(_DWORD *)buf < 0x1000001u) {
      goto LABEL_38;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v49 = *a2;
  *(_DWORD *)buf = 136446722;
  v82 = "http2_transport_purge_frame_cache_if_necessary";
  __int16 v83 = 1024;
  *(_DWORD *)v84 = v23;
  *(_WORD *)&v84[4] = 1024;
  *(_DWORD *)&v84[6] = v49;
  v44 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v79 = 0;
  if (!__nwlog_fault(v44, &type, &v79)) {
    goto LABEL_102;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v79)
    {
      v53 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v50 = gLogObj;
      os_log_type_t v51 = type;
      BOOL v60 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v53)
      {
        if (v60)
        {
          int v61 = *a2;
          *(_DWORD *)buf = 136446978;
          v82 = "http2_transport_purge_frame_cache_if_necessary";
          __int16 v83 = 1024;
          *(_DWORD *)v84 = v23;
          *(_WORD *)&v84[4] = 1024;
          *(_DWORD *)&v84[6] = v61;
          *(_WORD *)&v84[10] = 2082;
          *(void *)&v84[12] = v53;
          v56 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames, dumping backtrace:%{public}s";
          v57 = v50;
          os_log_type_t v58 = v51;
          uint32_t v59 = 34;
LABEL_89:
          _os_log_impl(&dword_1830D4000, v57, v58, v56, buf, v59);
        }
LABEL_90:
        free(v53);
        goto LABEL_102;
      }
      if (!v60) {
        goto LABEL_102;
      }
      int v68 = *a2;
      *(_DWORD *)buf = 136446722;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v83 = 1024;
      *(_DWORD *)v84 = v23;
      *(_WORD *)&v84[4] = 1024;
      *(_DWORD *)&v84[6] = v68;
      BOOL v48 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v50 = gLogObj;
      os_log_type_t v51 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_102;
      }
      int v63 = *a2;
      *(_DWORD *)buf = 136446722;
      v82 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v83 = 1024;
      *(_DWORD *)v84 = v23;
      *(_WORD *)&v84[4] = 1024;
      *(_DWORD *)&v84[6] = v63;
      BOOL v48 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames, backtrace limit exceeded";
    }
LABEL_100:
    __int16 v65 = v50;
    os_log_type_t v66 = v51;
    uint32_t v67 = 24;
LABEL_101:
    _os_log_impl(&dword_1830D4000, v65, v66, v48, buf, v67);
    goto LABEL_102;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v50 = gLogObj;
  os_log_type_t v51 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    int v52 = *a2;
    *(_DWORD *)buf = 136446722;
    v82 = "http2_transport_purge_frame_cache_if_necessary";
    __int16 v83 = 1024;
    *(_DWORD *)v84 = v23;
    *(_WORD *)&v84[4] = 1024;
    *(_DWORD *)&v84[6] = v52;
    BOOL v48 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames";
    goto LABEL_100;
  }
LABEL_102:
  if (v44) {
    free(v44);
  }
  *a2 = 0;
}

uint64_t nw_frame_array_get_frame_count(uint64_t *a1, int a2, _DWORD *a3)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v79 = "nw_frame_array_get_frame_count";
    int v69 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v76 = 0;
    if (__nwlog_fault(v69, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v70 = __nwlog_obj();
        os_log_type_t v71 = type;
        if (os_log_type_enabled(v70, type))
        {
          *(_DWORD *)buf = 136446210;
          char v79 = "nw_frame_array_get_frame_count";
          v72 = "%{public}s called with null array";
LABEL_112:
          _os_log_impl(&dword_1830D4000, v70, v71, v72, buf, 0xCu);
        }
      }
      else if (v76)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v70 = __nwlog_obj();
        os_log_type_t v71 = type;
        BOOL v74 = os_log_type_enabled(v70, type);
        if (backtrace_string)
        {
          if (v74)
          {
            *(_DWORD *)buf = 136446466;
            char v79 = "nw_frame_array_get_frame_count";
            __int16 v80 = 2082;
            v81 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_113;
        }
        if (v74)
        {
          *(_DWORD *)buf = 136446210;
          char v79 = "nw_frame_array_get_frame_count";
          v72 = "%{public}s called with null array, no backtrace";
          goto LABEL_112;
        }
      }
      else
      {
        uint64_t v70 = __nwlog_obj();
        os_log_type_t v71 = type;
        if (os_log_type_enabled(v70, type))
        {
          *(_DWORD *)buf = 136446210;
          char v79 = "nw_frame_array_get_frame_count";
          v72 = "%{public}s called with null array, backtrace limit exceeded";
          goto LABEL_112;
        }
      }
    }
LABEL_113:
    if (v69) {
      free(v69);
    }
    return 0;
  }
  uint64_t v3 = *a1;
  if (a2)
  {
    if (v3)
    {
      LODWORD(v4) = 0;
      uint64_t v5 = 0;
      while (1)
      {
        int v6 = *(_DWORD *)(v3 + 52);
        unsigned int v7 = v6 ? v6 - (*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60)) : 0;
        uint64_t v3 = *(void *)(v3 + 32);
        uint64_t v8 = (v5 << 31 >> 31) + 1;
        uint64_t v9 = v8 << 31 >> 31;
        if (v9 != v8 || v9 < 0) {
          break;
        }
        uint64_t v5 = v8;
        BOOL v10 = __CFADD__(v4, v7);
        uint64_t v4 = v4 + v7;
        if (v10) {
          goto LABEL_33;
        }
LABEL_6:
        if (!v3) {
          goto LABEL_96;
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = v9;
      *(_DWORD *)buf = 136446978;
      char v79 = "nw_frame_array_get_frame_count";
      __int16 v80 = 2082;
      v81 = "frame_count";
      __int16 v82 = 2048;
      uint64_t v83 = 1;
      __int16 v84 = 2048;
      uint64_t v85 = v9;
      os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v76 = 0;
      if (__nwlog_fault(v12, &type, &v76))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v13 = gLogObj;
          os_log_type_t v14 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_29;
          }
          *(_DWORD *)buf = 136446978;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "frame_count";
          __int16 v82 = 2048;
          uint64_t v83 = 1;
          __int16 v84 = 2048;
          uint64_t v85 = v11;
          os_log_type_t v15 = v13;
          os_log_type_t v16 = v14;
          BOOL v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_28:
          _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0x2Au);
          goto LABEL_29;
        }
        if (!v76)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v22 = gLogObj;
          os_log_type_t v23 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_29;
          }
          *(_DWORD *)buf = 136446978;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "frame_count";
          __int16 v82 = 2048;
          uint64_t v83 = 1;
          __int16 v84 = 2048;
          uint64_t v85 = v11;
          os_log_type_t v15 = v22;
          os_log_type_t v16 = v23;
          BOOL v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_28;
        }
        uint64_t v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v19 = gLogObj;
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v18)
        {
          if (!v21) {
            goto LABEL_29;
          }
          *(_DWORD *)buf = 136446978;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "frame_count";
          __int16 v82 = 2048;
          uint64_t v83 = 1;
          __int16 v84 = 2048;
          uint64_t v85 = v11;
          os_log_type_t v15 = v19;
          os_log_type_t v16 = v20;
          BOOL v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_28;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136447234;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "frame_count";
          __int16 v82 = 2048;
          uint64_t v83 = 1;
          __int16 v84 = 2048;
          uint64_t v85 = v11;
          __int16 v86 = 2082;
          v87 = v18;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v18);
      }
LABEL_29:
      if (v12) {
        free(v12);
      }
      uint64_t v5 = 0xFFFFFFFFLL;
      BOOL v10 = __CFADD__(v4, v7);
      uint64_t v4 = v4 + v7;
      if (!v10) {
        goto LABEL_6;
      }
LABEL_33:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446978;
      uint64_t v24 = v7;
      char v79 = "nw_frame_array_get_frame_count";
      __int16 v80 = 2082;
      v81 = "byte_count";
      __int16 v82 = 2048;
      uint64_t v83 = v7;
      __int16 v84 = 2048;
      uint64_t v85 = v4;
      int v25 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v76 = 0;
      if (__nwlog_fault(v25, &type, &v76))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = gLogObj;
          os_log_type_t v27 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446978;
            char v79 = "nw_frame_array_get_frame_count";
            __int16 v80 = 2082;
            v81 = "byte_count";
            __int16 v82 = 2048;
            uint64_t v83 = v7;
            __int16 v84 = 2048;
            uint64_t v85 = v4;
            uint64_t v28 = v26;
            os_log_type_t v29 = v27;
            uint64_t v30 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_46:
            _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0x2Au);
          }
        }
        else if (v76)
        {
          os_log_type_t v31 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v32 = gLogObj;
          os_log_type_t v33 = type;
          BOOL v34 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v31)
          {
            if (v34)
            {
              *(_DWORD *)buf = 136447234;
              char v79 = "nw_frame_array_get_frame_count";
              __int16 v80 = 2082;
              v81 = "byte_count";
              __int16 v82 = 2048;
              uint64_t v83 = v24;
              __int16 v84 = 2048;
              uint64_t v85 = v4;
              __int16 v86 = 2082;
              v87 = v31;
              _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v31);
            goto LABEL_47;
          }
          if (v34)
          {
            *(_DWORD *)buf = 136446978;
            char v79 = "nw_frame_array_get_frame_count";
            __int16 v80 = 2082;
            v81 = "byte_count";
            __int16 v82 = 2048;
            uint64_t v83 = v24;
            __int16 v84 = 2048;
            uint64_t v85 = v4;
            uint64_t v28 = v32;
            os_log_type_t v29 = v33;
            uint64_t v30 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_46;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v35 = gLogObj;
          os_log_type_t v36 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446978;
            char v79 = "nw_frame_array_get_frame_count";
            __int16 v80 = 2082;
            v81 = "byte_count";
            __int16 v82 = 2048;
            uint64_t v83 = v7;
            __int16 v84 = 2048;
            uint64_t v85 = v4;
            uint64_t v28 = v35;
            os_log_type_t v29 = v36;
            uint64_t v30 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_46;
          }
        }
      }
LABEL_47:
      if (v25) {
        free(v25);
      }
      LODWORD(v4) = -1;
      goto LABEL_6;
    }
    goto LABEL_95;
  }
  if (v3)
  {
    LODWORD(v37) = 0;
    uint64_t v5 = 0;
    while (1)
    {
      int v38 = *(_DWORD *)(v3 + 52);
      unsigned int v39 = v38 ? v38 - (*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60)) : 0;
      uint64_t v3 = *(void *)(v3 + 16);
      uint64_t v40 = (v5 << 31 >> 31) + 1;
      uint64_t v41 = v40 << 31 >> 31;
      if (v41 != v40 || v41 < 0) {
        break;
      }
      uint64_t v5 = v40;
      BOOL v10 = __CFADD__(v37, v39);
      uint64_t v37 = v37 + v39;
      if (v10) {
        goto LABEL_79;
      }
LABEL_52:
      LODWORD(v4) = v37;
      if (!v3) {
        goto LABEL_96;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v42 = v41;
    *(_DWORD *)buf = 136446978;
    char v79 = "nw_frame_array_get_frame_count";
    __int16 v80 = 2082;
    v81 = "frame_count";
    __int16 v82 = 2048;
    uint64_t v83 = 1;
    __int16 v84 = 2048;
    uint64_t v85 = v41;
    int v43 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v76 = 0;
    if (__nwlog_fault(v43, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v44 = gLogObj;
        os_log_type_t v45 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446978;
        char v79 = "nw_frame_array_get_frame_count";
        __int16 v80 = 2082;
        v81 = "frame_count";
        __int16 v82 = 2048;
        uint64_t v83 = 1;
        __int16 v84 = 2048;
        uint64_t v85 = v42;
        os_log_type_t v46 = v44;
        os_log_type_t v47 = v45;
        BOOL v48 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_74:
        _os_log_impl(&dword_1830D4000, v46, v47, v48, buf, 0x2Au);
        goto LABEL_75;
      }
      if (!v76)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v53 = gLogObj;
        os_log_type_t v54 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446978;
        char v79 = "nw_frame_array_get_frame_count";
        __int16 v80 = 2082;
        v81 = "frame_count";
        __int16 v82 = 2048;
        uint64_t v83 = 1;
        __int16 v84 = 2048;
        uint64_t v85 = v42;
        os_log_type_t v46 = v53;
        os_log_type_t v47 = v54;
        BOOL v48 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_74;
      }
      int v49 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v50 = gLogObj;
      os_log_type_t v51 = type;
      BOOL v52 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v49)
      {
        if (!v52) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446978;
        char v79 = "nw_frame_array_get_frame_count";
        __int16 v80 = 2082;
        v81 = "frame_count";
        __int16 v82 = 2048;
        uint64_t v83 = 1;
        __int16 v84 = 2048;
        uint64_t v85 = v42;
        os_log_type_t v46 = v50;
        os_log_type_t v47 = v51;
        BOOL v48 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_74;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136447234;
        char v79 = "nw_frame_array_get_frame_count";
        __int16 v80 = 2082;
        v81 = "frame_count";
        __int16 v82 = 2048;
        uint64_t v83 = 1;
        __int16 v84 = 2048;
        uint64_t v85 = v42;
        __int16 v86 = 2082;
        v87 = v49;
        _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
      }
      free(v49);
    }
LABEL_75:
    if (v43) {
      free(v43);
    }
    uint64_t v5 = 0xFFFFFFFFLL;
    BOOL v10 = __CFADD__(v37, v39);
    uint64_t v37 = v37 + v39;
    if (!v10) {
      goto LABEL_52;
    }
LABEL_79:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    uint64_t v55 = v39;
    char v79 = "nw_frame_array_get_frame_count";
    __int16 v80 = 2082;
    v81 = "byte_count";
    __int16 v82 = 2048;
    uint64_t v83 = v39;
    __int16 v84 = 2048;
    uint64_t v85 = v37;
    v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v76 = 0;
    if (__nwlog_fault(v56, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v57 = gLogObj;
        os_log_type_t v58 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "byte_count";
          __int16 v82 = 2048;
          uint64_t v83 = v39;
          __int16 v84 = 2048;
          uint64_t v85 = v37;
          uint32_t v59 = v57;
          os_log_type_t v60 = v58;
          int v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_92:
          _os_log_impl(&dword_1830D4000, v59, v60, v61, buf, 0x2Au);
        }
      }
      else if (v76)
      {
        int v62 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v63 = gLogObj;
        os_log_type_t v64 = type;
        BOOL v65 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v62)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136447234;
            char v79 = "nw_frame_array_get_frame_count";
            __int16 v80 = 2082;
            v81 = "byte_count";
            __int16 v82 = 2048;
            uint64_t v83 = v55;
            __int16 v84 = 2048;
            uint64_t v85 = v37;
            __int16 v86 = 2082;
            v87 = v62;
            _os_log_impl(&dword_1830D4000, v63, v64, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v62);
          goto LABEL_93;
        }
        if (v65)
        {
          *(_DWORD *)buf = 136446978;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "byte_count";
          __int16 v82 = 2048;
          uint64_t v83 = v55;
          __int16 v84 = 2048;
          uint64_t v85 = v37;
          uint32_t v59 = v63;
          os_log_type_t v60 = v64;
          int v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_92;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v66 = gLogObj;
        os_log_type_t v67 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          char v79 = "nw_frame_array_get_frame_count";
          __int16 v80 = 2082;
          v81 = "byte_count";
          __int16 v82 = 2048;
          uint64_t v83 = v39;
          __int16 v84 = 2048;
          uint64_t v85 = v37;
          uint32_t v59 = v66;
          os_log_type_t v60 = v67;
          int v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_92;
        }
      }
    }
LABEL_93:
    if (v56) {
      free(v56);
    }
    LODWORD(v37) = -1;
    goto LABEL_52;
  }
LABEL_95:
  uint64_t v5 = 0;
  LODWORD(v4) = 0;
LABEL_96:
  if (a3) {
    *a3 = v4;
  }
  return v5;
}

BOOL nw_protocol_register_extended(void *a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v4 = &g_registration_list;
  while (1)
  {
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      int v25 = "nw_protocol_register_extended";
      __int16 v26 = 2082;
      uint64_t v27 = (uint64_t)a1;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v22 = 0;
      if (!__nwlog_fault(v9, &type, &v22)) {
        goto LABEL_35;
      }
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v22)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v10 = gLogObj;
          os_log_type_t v11 = type;
          BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136446722;
              int v25 = "nw_protocol_register_extended";
              __int16 v26 = 2082;
              uint64_t v27 = (uint64_t)a1;
              __int16 v28 = 2082;
              uint64_t v29 = (uint64_t)backtrace_string;
              _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s Protocol identifier %{public}s is already registered, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_35;
          }
          if (!v18) {
            goto LABEL_35;
          }
          *(_DWORD *)buf = 136446466;
          int v25 = "nw_protocol_register_extended";
          __int16 v26 = 2082;
          uint64_t v27 = (uint64_t)a1;
          os_log_type_t v12 = "%{public}s Protocol identifier %{public}s is already registered, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v10 = gLogObj;
          os_log_type_t v11 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_35;
          }
          *(_DWORD *)buf = 136446466;
          int v25 = "nw_protocol_register_extended";
          __int16 v26 = 2082;
          uint64_t v27 = (uint64_t)a1;
          os_log_type_t v12 = "%{public}s Protocol identifier %{public}s is already registered, backtrace limit exceeded";
        }
LABEL_34:
        _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0x16u);
        goto LABEL_35;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        int v25 = "nw_protocol_register_extended";
        __int16 v26 = 2082;
        uint64_t v27 = (uint64_t)a1;
        os_log_type_t v12 = "%{public}s Protocol identifier %{public}s is already registered";
        goto LABEL_34;
      }
LABEL_35:
      if (v9) {
        free(v9);
      }
LABEL_37:
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      return v4 == 0;
    }
  }
  uint64_t v13 = malloc_type_calloc(1uLL, 0x78uLL, 0xEAFB8F1AuLL);
  if (v13)
  {
LABEL_22:
    long long v14 = *(_OWORD *)a1;
    long long v15 = *((_OWORD *)a1 + 1);
    v13[8] = a1[4];
    *((_OWORD *)v13 + 2) = v14;
    *((_OWORD *)v13 + 3) = v15;
    v13[11] = a2;
    uint64_t v16 = g_registration_list;
    void *v13 = g_registration_list;
    if (v16) {
      *(void *)(v16 + 8) = v13;
    }
    g_registration_list = (uint64_t)v13;
    v13[1] = &g_registration_list;
    goto LABEL_37;
  }
  os_log_type_t v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  int v25 = "strict_calloc";
  __int16 v26 = 2048;
  uint64_t v27 = 1;
  __int16 v28 = 2048;
  uint64_t v29 = 120;
  BOOL v21 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    goto LABEL_22;
  }
  __break(1u);
  return result;
}

void __nw_settings_get_l4s_enabled_internal_block_invoke()
{
  CFStringRef v0 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)"network_enable_l4s", 18, 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  Boolean keyExistsAndHasValidFormat = 0;
  int AppBooleanValue = CFPreferencesGetAppBooleanValue(v0, @"Apple Global Domain", &keyExistsAndHasValidFormat);
  int v2 = keyExistsAndHasValidFormat;
  if (v0) {
    CFRelease(v0);
  }
  if (v2) {
    BOOL v3 = AppBooleanValue == 0;
  }
  else {
    BOOL v3 = 1;
  }
  char v4 = !v3;
  nw_settings_get_l4s_enabled_internal::l4s_enabled = v4;
}

uint64_t __nw_protocol_instance_report_ready_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t extra = nw_hash_node_get_extra(a2);
  __int16 v5 = *(_WORD *)(extra + 52);
  if ((v5 & 0x10) == 0)
  {
    uint64_t v6 = extra;
    if ((v5 & 4) != 0)
    {
      object = (nw_protocol *)nw_hash_node_get_object(a2);
      uint64_t v9 = (void **)*(id *)(a1 + 32);
      if (nw_protocol_definition_get_message_is_stream(v9[1]) && *(v9 - 6) == object)
      {

        unint64_t v10 = -2;
      }
      else
      {

        unint64_t v10 = (unint64_t)object;
        if (*(void *)(a1 + 40) != -1 && object != (nw_protocol *)-2) {
          return 1;
        }
      }
      *(_WORD *)(v6 + 52) |= 0x10u;
      os_log_type_t v11 = *(NWConcrete_nw_protocol_instance **)(a1 + 32);
      if (v11) {
        p_paths_log_id_num = (nw_protocol *)&v11[-1].paths_log_id_num;
      }
      else {
        p_paths_log_id_num = 0;
      }
      nw_protocol_implementation_report_connected(v11, p_paths_log_id_num, object, v10);
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 32);
      if ((!v7 || (*(char *)(v7 + 405) & 0x80000000) == 0) && gLogDatapath)
      {
        long long v14 = __nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v15 = *(void *)(a1 + 32);
          uint64_t v16 = *(void *)(a1 + 40);
          BOOL v17 = v15 == 0;
          if (v15) {
            BOOL v18 = (const char *)(v15 + 407);
          }
          else {
            BOOL v18 = "";
          }
          BOOL v21 = "nw_protocol_instance_report_ready_block_invoke";
          __int16 v22 = 2082;
          os_log_type_t v19 = " ";
          int v20 = 136446978;
          if (v17) {
            os_log_type_t v19 = "";
          }
          os_log_type_t v23 = v18;
          __int16 v24 = 2080;
          int v25 = v19;
          __int16 v26 = 2048;
          uint64_t v27 = v16;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDelaying the delivery of connected() on flow %llx", (uint8_t *)&v20, 0x2Au);
        }

        __int16 v5 = *(_WORD *)(v6 + 52);
      }
      *(_WORD *)(v6 + 52) = v5 | 0x30;
    }
  }
  return 1;
}

uint64_t nw_protocol_implementation_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    __int16 v5 = p_output_handler;
    uint64_t v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 80);
        if (v8)
        {
          if (*(void *)(v8 + 64))
          {
            v5[403] |= 0x20u;
            *(void *)buf = 0;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000;
            uint64_t v57 = -1;
            v48[0] = MEMORY[0x1E4F143A8];
            v48[1] = 3221225472;
            int v49 = (uint64_t (*)(void *))___ZL49nw_protocol_implementation_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
            uint64_t v50 = &unk_1E523BFD8;
            uint64_t v9 = v5;
            os_log_type_t v51 = v9;
            BOOL v52 = buf;
            uint64_t v53 = a2;
            tqh_first = a2->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              os_log_type_t v11 = (nw_frame *)*((void *)tqh_first + 4);
              char v12 = v49(v48);
              tqh_first = v11;
            }
            while ((v12 & 1) != 0);
            uint64_t v13 = *(OS_nw_endpoint **)(*(void *)&buf[8] + 24);
            if (v13 != (OS_nw_endpoint *)-1 && v13 != v9->preferred_ipv6_address)
            {
              long long v14 = *(void (**)(NWConcrete_nw_protocol_instance *))(*(void *)(*((void *)v6 + 1) + 80)
                                                                             + 104);
              if (v14) {
                v14(v9);
              }
            }
            v6[403] &= ~0x20u;
            nw_protocol_implementation_deliver_output_available(v9);
            uint64_t v15 = nw_protocol_implementation_finalize_pending_frames(v9);

            _Block_object_dispose(buf, 8);
LABEL_16:

            return v15;
          }
          uint64_t v29 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          __int16 v22 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v54 = 0;
          if (__nwlog_fault(v22, &type, &v54))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v23 = __nwlog_obj();
              os_log_type_t v30 = type;
              if (os_log_type_enabled(v23, type))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
                _os_log_impl(&dword_1830D4000, v23, v30, "%{public}s called with null instance->parent_definition->extended_state->handle_outbound", buf, 0xCu);
              }
LABEL_103:

              goto LABEL_68;
            }
            if (!v54)
            {
              os_log_type_t v23 = __nwlog_obj();
              os_log_type_t v47 = type;
              if (os_log_type_enabled(v23, type))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
                _os_log_impl(&dword_1830D4000, v23, v47, "%{public}s called with null instance->parent_definition->extended_state->handle_outbound, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_103;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            os_log_type_t v23 = __nwlog_obj();
            os_log_type_t v41 = type;
            BOOL v42 = os_log_type_enabled(v23, type);
            if (!backtrace_string)
            {
              if (v42)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
                _os_log_impl(&dword_1830D4000, v23, v41, "%{public}s called with null instance->parent_definition->extended_state->handle_outbound, no backtrace", buf, 0xCu);
              }
              goto LABEL_103;
            }
            if (v42)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v23, v41, "%{public}s called with null instance->parent_definition->extended_state->handle_outbound, dumping backtrace:%{public}s", buf, 0x16u);
            }
            goto LABEL_67;
          }
LABEL_68:
          if (v22) {
            free(v22);
          }
          uint64_t v15 = 0;
          goto LABEL_16;
        }
        uint64_t v27 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
        __int16 v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (!__nwlog_fault(v22, &type, &v54)) {
          goto LABEL_68;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v28 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
          goto LABEL_103;
        }
        if (!v54)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v46 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v23, v46, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_103;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v39 = type;
        BOOL v40 = os_log_type_enabled(v23, type);
        if (!backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v23, v39, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_103;
        }
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v39, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        int v25 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
        __int16 v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (!__nwlog_fault(v22, &type, &v54)) {
          goto LABEL_68;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v26 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_103;
        }
        if (!v54)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v45 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v23, v45, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_103;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v23, type);
        if (!backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v23, v37, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_103;
        }
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v37, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
    }
    else
    {
      BOOL v21 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
      __int16 v22 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v54 = 0;
      if (!__nwlog_fault(v22, &type, &v54)) {
        goto LABEL_68;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_103;
      }
      if (!v54)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v23, v44, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_103;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v35 = type;
      BOOL v36 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_103;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
LABEL_67:

    free(backtrace_string);
    goto LABEL_68;
  }
  BOOL v17 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
  BOOL v18 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v54 = 0;
  if (__nwlog_fault(v18, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v54)
    {
      os_log_type_t v31 = (char *)__nw_create_backtrace_string();
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v19, type);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v31;
          _os_log_impl(&dword_1830D4000, v19, v32, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v31);
        goto LABEL_89;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
        _os_log_impl(&dword_1830D4000, v19, v32, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
        _os_log_impl(&dword_1830D4000, v19, v43, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_89:
  if (v18) {
    free(v18);
  }
  return 0;
}

void sub_1833389C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_report_connected(NWConcrete_nw_protocol_instance *a1, nw_protocol *a2, nw_protocol *a3, unint64_t a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  uint64_t v8 = v7;
  if (!v7)
  {
    uint64_t v27 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "nw_protocol_implementation_report_connected";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    v57[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v55) = 0;
    if (!__nwlog_fault(v28, v57, &v55)) {
      goto LABEL_111;
    }
    if (v57[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if ((_BYTE)v55)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v39 = v57[0];
      BOOL v40 = os_log_type_enabled(v29, v57[0]);
      if (backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v60 = "nw_protocol_implementation_report_connected";
          __int16 v61 = 2082;
          int v62 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v29, v39, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_111:
        if (!v28) {
          goto LABEL_31;
        }
LABEL_112:
        free(v28);
        goto LABEL_31;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v39, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v49 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v49, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_110:

    goto LABEL_111;
  }
  if (!a2)
  {
    os_log_type_t v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "nw_protocol_implementation_report_connected";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    v57[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v55) = 0;
    if (!__nwlog_fault(v28, v57, &v55)) {
      goto LABEL_111;
    }
    if (v57[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v32 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null protocol", buf, 0xCu);
      }
      goto LABEL_110;
    }
    if (!(_BYTE)v55)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v50 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v50, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_110;
    }
    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    uint64_t v29 = __nwlog_obj();
    os_log_type_t v42 = v57[0];
    BOOL v43 = os_log_type_enabled(v29, v57[0]);
    if (!v41)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v42, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
      goto LABEL_110;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v60 = "nw_protocol_implementation_report_connected";
      __int16 v61 = 2082;
      int v62 = (nw_protocol_identifier *)v41;
      _os_log_impl(&dword_1830D4000, v29, v42, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
  if (!a3)
  {
    BOOL v33 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "nw_protocol_implementation_report_connected";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    v57[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v55) = 0;
    if (!__nwlog_fault(v28, v57, &v55)) {
      goto LABEL_111;
    }
    if (v57[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v34 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v34, "%{public}s called with null input_protocol", buf, 0xCu);
      }
      goto LABEL_110;
    }
    if (!(_BYTE)v55)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v51 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v51, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_110;
    }
    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    uint64_t v29 = __nwlog_obj();
    os_log_type_t v44 = v57[0];
    BOOL v45 = os_log_type_enabled(v29, v57[0]);
    if (!v41)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_1830D4000, v29, v44, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
      }
      goto LABEL_110;
    }
    if (v45)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v60 = "nw_protocol_implementation_report_connected";
      __int16 v61 = 2082;
      int v62 = (nw_protocol_identifier *)v41;
      _os_log_impl(&dword_1830D4000, v29, v44, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_79:

    free(v41);
    if (!v28) {
      goto LABEL_31;
    }
    goto LABEL_112;
  }
  v7->preferred_ipv6_address = (OS_nw_endpoint *)a4;
  handle = a3->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = a3[1].callbacks;
    if (callbacks) {
      a3[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
    char v10 = -1;
  }
  else
  {
    char v10 = 0;
  }
  *(void *)uint64_t v57 = a3;
  char v58 = v10;
  char v12 = a2->handle;
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    long long v14 = a2[1].callbacks;
    if (v14) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v14->add_input_handler + 1);
    }
    char v13 = -1;
  }
  else
  {
    char v13 = 0;
  }
  uint64_t v55 = a2;
  char v56 = v13;
  uint64_t v15 = a3->callbacks;
  if (v15)
  {
    connected = (void (*)(nw_protocol *, nw_protocol *))v15->connected;
    if (connected)
    {
      connected(a3, a2);
      goto LABEL_17;
    }
  }
  BOOL v21 = __nwlog_obj();
  identifier = a3->identifier;
  *(_DWORD *)buf = 136446722;
  os_log_type_t v60 = "__nw_protocol_connected";
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  __int16 v61 = 2082;
  int v62 = identifier;
  __int16 v63 = 2048;
  os_log_type_t v64 = a3;
  os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v53 = 0;
  if (__nwlog_fault(v23, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        os_log_type_t v26 = a3->identifier;
        if (!v26) {
          os_log_type_t v26 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v60 = "__nw_protocol_connected";
        __int16 v61 = 2082;
        int v62 = v26;
        __int16 v63 = 2048;
        os_log_type_t v64 = a3;
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s protocol %{public}s (%p) has invalid connected callback", buf, 0x20u);
      }
    }
    else if (v53)
    {
      os_log_type_t v35 = (char *)__nw_create_backtrace_string();
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v52 = type;
      BOOL v36 = os_log_type_enabled(v24, type);
      if (v35)
      {
        if (v36)
        {
          os_log_type_t v37 = a3->identifier;
          if (!v37) {
            os_log_type_t v37 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446978;
          os_log_type_t v60 = "__nw_protocol_connected";
          __int16 v61 = 2082;
          int v62 = v37;
          __int16 v63 = 2048;
          os_log_type_t v64 = a3;
          __int16 v65 = 2082;
          uint64_t v66 = (nw_protocol *)v35;
          _os_log_impl(&dword_1830D4000, v24, v52, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v35);
        goto LABEL_91;
      }
      if (v36)
      {
        BOOL v48 = a3->identifier;
        if (!v48) {
          BOOL v48 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v60 = "__nw_protocol_connected";
        __int16 v61 = 2082;
        int v62 = v48;
        __int16 v63 = 2048;
        os_log_type_t v64 = a3;
        _os_log_impl(&dword_1830D4000, v24, v52, "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v24, type))
      {
        os_log_type_t v47 = a3->identifier;
        if (!v47) {
          os_log_type_t v47 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v60 = "__nw_protocol_connected";
        __int16 v61 = 2082;
        int v62 = v47;
        __int16 v63 = 2048;
        os_log_type_t v64 = a3;
        _os_log_impl(&dword_1830D4000, v24, v46, "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
LABEL_91:
  if (v23) {
    free(v23);
  }
LABEL_17:
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v55);
    if (handle != &nw_protocol_ref_counted_handle) {
      goto LABEL_19;
    }
  }
  else if (handle != &nw_protocol_ref_counted_handle)
  {
    goto LABEL_19;
  }
  nw::release_if_needed<nw_protocol *>((uint64_t *)v57);
LABEL_19:
  v8->preferred_ipv6_address = 0;
  if (a4 >= 0xFFFFFFFFFFFFFFFELL && (SBYTE5(v8->flow_in_connected) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136447234;
      os_log_type_t v60 = "nw_protocol_implementation_report_connected";
      __int16 v61 = 2082;
      int v62 = (nw_protocol_identifier *)((char *)&v8->flow_in_connected + 7);
      __int16 v63 = 2080;
      os_log_type_t v64 = (nw_protocol *)" ";
      __int16 v65 = 2048;
      uint64_t v66 = a2;
      __int16 v67 = 2048;
      unint64_t v68 = a4;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sReporting connected with protocol: %p, flow: %llx", buf, 0x34u);
    }
  }
  if (a4 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    var13 = (void (*)(NWConcrete_nw_protocol_instance *, unint64_t))v8->parent_definition->extended_state->var13;
    if (var13) {
      var13(v8, a4);
    }
  }
  int v19 = SBYTE3(v8->flow_in_connected);
  if (v19 < 0)
  {
    BYTE3(v8->flow_in_connected) = v19 & 0x7F;
    var14 = (void (*)(NWConcrete_nw_protocol_instance *, void))v8->parent_definition->extended_state->var14;
    if (var14) {
      var14(v8, 0);
    }
  }
  nw_protocol_implementation_finalize_pending_frames(v8);
LABEL_31:
}

uint64_t nw_protocol_implementation_finalize_pending_frames(void *a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  BOOL v3 = v1 + 208;
  if (!*((void *)v1 + 26))
  {
    uint64_t v7 = 1;
    goto LABEL_15;
  }
  if ((v1[405] & 0x80000000) == 0 && gLogDatapath)
  {
    int v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v42 = "nw_protocol_implementation_finalize_pending_frames";
      __int16 v43 = 2082;
      os_log_type_t v44 = v2 + 407;
      __int16 v45 = 2080;
      os_log_type_t v46 = " ";
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFinalizing outbound frames (batched)", buf, 0x20u);
    }
  }
  char v4 = (const char *)*((void *)v2 - 8);
  if (!v4)
  {
    uint64_t v27 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    v38[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v28, v38, &type))
    {
      if (v38[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v30 = v38[0];
        if (os_log_type_enabled(v29, v38[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v32 = v38[0];
        BOOL v33 = os_log_type_enabled(v29, v38[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
            __int16 v43 = 2082;
            os_log_type_t v44 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_69;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v34 = v38[0];
        if (os_log_type_enabled(v29, v38[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v29, v34, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_69:
    if (v28) {
      free(v28);
    }
    uint64_t v7 = 0;
    goto LABEL_15;
  }
  __int16 v5 = (void *)*((void *)v4 + 5);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v8 = *((void *)v4 + 11);
    if (v8) {
      *((void *)v4 + 11) = v8 + 1;
    }
    char v6 = -1;
  }
  else
  {
    char v6 = 0;
  }
  *(void *)BOOL v38 = v4;
  char v39 = v6;
  uint64_t v9 = *((void *)v4 + 3);
  if (v9)
  {
    char v10 = *(uint64_t (**)(const char *, char *))(v9 + 96);
    if (v10)
    {
      uint64_t v7 = v10(v4, v3);
      if (v5 != &nw_protocol_ref_counted_handle) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  char v13 = __nwlog_obj();
  long long v14 = (const char *)*((void *)v4 + 2);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
  if (!v14) {
    long long v14 = "invalid";
  }
  __int16 v43 = 2082;
  os_log_type_t v44 = (char *)v14;
  __int16 v45 = 2048;
  os_log_type_t v46 = v4;
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (!__nwlog_fault(v15, &type, &v37)) {
    goto LABEL_49;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v16, type))
    {
      BOOL v18 = (const char *)*((void *)v4 + 2);
      if (!v18) {
        BOOL v18 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
      __int16 v43 = 2082;
      os_log_type_t v44 = (char *)v18;
      __int16 v45 = 2048;
      os_log_type_t v46 = v4;
      _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback", buf, 0x20u);
    }
LABEL_48:

    goto LABEL_49;
  }
  if (!v37)
  {
    uint64_t v16 = __nwlog_obj();
    os_log_type_t v24 = type;
    if (os_log_type_enabled(v16, type))
    {
      os_log_type_t v25 = (const char *)*((void *)v4 + 2);
      if (!v25) {
        os_log_type_t v25 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
      __int16 v43 = 2082;
      os_log_type_t v44 = (char *)v25;
      __int16 v45 = 2048;
      os_log_type_t v46 = v4;
      _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_48;
  }
  os_log_type_t v20 = (char *)__nw_create_backtrace_string();
  uint64_t v16 = __nwlog_obj();
  os_log_type_t v21 = type;
  BOOL v22 = os_log_type_enabled(v16, type);
  if (!v20)
  {
    if (v22)
    {
      if (*((void *)v4 + 2)) {
        os_log_type_t v26 = (const char *)*((void *)v4 + 2);
      }
      else {
        os_log_type_t v26 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
      __int16 v43 = 2082;
      os_log_type_t v44 = (char *)v26;
      __int16 v45 = 2048;
      os_log_type_t v46 = v4;
      _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace", buf, 0x20u);
    }
    goto LABEL_48;
  }
  if (v22)
  {
    if (*((void *)v4 + 2)) {
      os_log_type_t v23 = (const char *)*((void *)v4 + 2);
    }
    else {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    os_log_type_t v42 = "__nw_protocol_finalize_output_frames";
    __int16 v43 = 2082;
    os_log_type_t v44 = (char *)v23;
    __int16 v45 = 2048;
    os_log_type_t v46 = v4;
    __int16 v47 = 2082;
    BOOL v48 = v20;
    _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v20);
LABEL_49:
  if (v15) {
    free(v15);
  }
  uint64_t v7 = 0;
  if (v5 == &nw_protocol_ref_counted_handle) {
LABEL_14:
  }
    nw::release_if_needed<nw_protocol *>((uint64_t *)v38);
LABEL_15:
  os_log_type_t v11 = (char *)*((void *)v2 + 37);
  if (v11)
  {
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    v35[2] = __nw_protocol_implementation_finalize_pending_frames_block_invoke;
    v35[3] = &unk_1E524AF58;
    BOOL v36 = v2;
    nw_hash_table_apply(v11, (uint64_t)v35);
  }
  return v7;
}

uint64_t ___ZL49nw_protocol_implementation_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = (uint64_t)v3;
  if (*(_DWORD *)(*(void *)(a1[4] + 8) + 64) == 3)
  {
    metadata = (uint64_t *)nw_frame_get_metadata((uint64_t)v3);
    char v6 = metadata;
    if (metadata)
    {
      uint64_t v7 = *metadata;
      goto LABEL_6;
    }
  }
  else
  {
    char v6 = 0;
  }
  uint64_t v7 = -1;
LABEL_6:
  uint64_t v8 = *(void *)(a1[5] + 8);
  uint64_t v9 = *(void *)(v8 + 24);
  if (v9 != v7)
  {
    if (v9 != -1)
    {
      char v10 = *(void (**)(void))(*(void *)(*(void *)(a1[4] + 8) + 80) + 104);
      if (v10)
      {
        v10();
        uint64_t v8 = *(void *)(a1[5] + 8);
      }
    }
    *(void *)(v8 + 24) = v7;
    os_log_type_t v11 = *(void (**)(void))(*(void *)(*(void *)(a1[4] + 8) + 80) + 96);
    if (v11) {
      v11();
    }
  }
  if (gLogDatapath)
  {
    os_log_type_t v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      uint64_t size = nw_protocol_data_get_size((void *)v4);
      int is_metadata_complete = nw_frame_is_metadata_complete(v4);
      int v24 = *(unsigned __int8 *)(v4 + 186) >> 7;
      int v25 = 136447490;
      os_log_type_t v26 = "nw_protocol_implementation_finalize_output_frames_block_invoke";
      __int16 v27 = 2048;
      uint64_t v28 = v4;
      __int16 v29 = 2048;
      uint64_t v30 = size;
      __int16 v31 = 2048;
      os_log_type_t v32 = v6;
      __int16 v33 = 1024;
      int v34 = is_metadata_complete;
      __int16 v35 = 1024;
      int v36 = v24;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s calling handle outbound with frame %p (length %zu bytes), metadata %p complete: %u, connection complete: %u", (uint8_t *)&v25, 0x36u);
    }
  }
  uint64_t v12 = *(void *)(v4 + 32);
  char v13 = *(void **)(v4 + 40);
  long long v14 = (void *)(v4 + 32);
  if (v12)
  {
    *(void *)(v12 + 40) = v13;
    char v13 = *(void **)(v4 + 40);
  }
  else
  {
    *(void *)(a1[6] + 8) = v13;
  }
  void *v13 = v12;
  *long long v14 = 0;
  *(void *)(v4 + 40) = 0;
  uint64_t v15 = a1[4];
  uint64_t v16 = *(void *)(v15 + 8);
  os_log_type_t v17 = *(void (**)(uint64_t, uint64_t, uint64_t, void *, uint64_t, void))(*(void *)(v16 + 80) + 64);
  BOOL v18 = nw_frame_copy_metadata_for_protocol(v4, v16);
  uint64_t v19 = nw_frame_is_metadata_complete(v4);
  v17(v15, v7, v4, v18, v19, *(unsigned __int8 *)(v4 + 186) >> 7);

  if (!*v14 && !*(void *)(v4 + 40) && (*(void *)(v4 + 16) || *(void *)(v4 + 24)))
  {
    if (nw_frame_get_finalizer_context(v4)) {
      nw_frame_finalize(v4);
    }
  }

  return 1;
}

void sub_183339F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_frame_is_metadata_complete(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v12 = "__nw_frame_is_metadata_complete";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v3, &type, &v9)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "__nw_frame_is_metadata_complete";
      char v6 = "%{public}s called with null frame";
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v12 = "__nw_frame_is_metadata_complete";
          __int16 v13 = 2082;
          long long v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (!v8)
      {
LABEL_18:
        if (v3) {
          free(v3);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "__nw_frame_is_metadata_complete";
      char v6 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "__nw_frame_is_metadata_complete";
      char v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_18;
  }
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1) {
    return (*(unsigned __int8 *)(v1 + 66) >> 6) & 1;
  }
  return 0;
}

id *nw_protocol_instance_copy_association(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    id v3 = v1[5];
    if (v3)
    {
      uint64_t v4 = nw_endpoint_copy_association_with_evaluator(v3, v2[6], 0);
      goto LABEL_4;
    }
    char v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_instance_copy_association";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null instance->endpoint", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null instance->endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null instance->endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v22 = "nw_protocol_instance_copy_association";
        __int16 v23 = 2082;
        int v24 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null instance->endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    char v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_instance_copy_association";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v22 = "nw_protocol_instance_copy_association";
        __int16 v23 = 2082;
        int v24 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0;
LABEL_4:

  return v4;
}

void sub_18333A618(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL32nw_path_can_use_channel_syscallsv_block_invoke()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  getpid();
  if (sandbox_check())
  {
    nw_path_can_use_channel_syscalls(void)::can_use_channel_syscalls = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFStringRef v0 = (id)gLogObj;
    if (!os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
LABEL_5:

      return;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v5 = "nw_path_can_use_channel_syscalls_block_invoke";
    uint64_t v1 = "%{public}s Sandbox does not allow access to channel system calls";
    int v2 = v0;
    os_log_type_t v3 = OS_LOG_TYPE_ERROR;
LABEL_4:
    _os_log_impl(&dword_1830D4000, v2, v3, v1, buf, 0xCu);
    goto LABEL_5;
  }
  nw_path_can_use_channel_syscalls(void)::can_use_channel_syscalls = 1;
  if (gLogDatapath)
  {
    CFStringRef v0 = __nwlog_obj();
    if (!os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v5 = "nw_path_can_use_channel_syscalls_block_invoke";
    uint64_t v1 = "%{public}s Sandbox allows access to channel system calls";
    int v2 = v0;
    os_log_type_t v3 = OS_LOG_TYPE_DEBUG;
    goto LABEL_4;
  }
}

BOOL nw_path_get_vpn_config_id(NWConcrete_nw_path *a1, unsigned __int8 (*a2)[16])
{
  return nw_path_get_vpn_config_uuid(a1, a2, 0, 1, 0);
}

void *nw_protocol_set_default_one_to_one_callbacks(void *result)
{
  *BOOL result = nw_protocol_default_add_input_handler;
  result[2] = nw_protocol_default_replace_input_handler;
  result[1] = nw_protocol_default_remove_input_handler;
  result[8] = nw_protocol_default_input_available;
  result[9] = nw_protocol_default_output_available;
  result[23] = nw_protocol_default_input_finished;
  result[24] = nw_protocol_default_output_finished;
  result[33] = nw_protocol_default_input_flush;
  result[10] = nw_protocol_default_get_input_frames;
  result[11] = nw_protocol_default_get_output_frames;
  result[12] = nw_protocol_default_finalize_output_frames;
  result[31] = nw_protocol_default_get_message_properties;
  result[13] = nw_protocol_default_link_state;
  result[14] = nw_protocol_default_get_parameters;
  result[16] = nw_protocol_default_get_local;
  result[17] = nw_protocol_default_get_remote;
  result[15] = nw_protocol_default_get_path;
  result[21] = nw_protocol_default_updated_path;
  result[25] = nw_protocol_default_get_output_local;
  result[26] = nw_protocol_default_get_output_interface;
  result[3] = nw_protocol_default_connect;
  result[4] = nw_protocol_default_disconnect;
  result[5] = nw_protocol_default_connected;
  result[6] = nw_protocol_default_disconnected;
  result[7] = nw_protocol_default_error;
  result[32] = nw_protocol_default_reset;
  result[22] = nw_protocol_default_supports_external_data;
  result[27] = nw_protocol_default_waiting_for_output;
  result[28] = nw_protocol_default_copy_info;
  result[18] = nw_protocol_default_register_notification;
  result[19] = nw_protocol_default_unregister_notification;
  result[20] = nw_protocol_default_notify;
  result[29] = nw_protocol_default_add_listen_handler;
  result[30] = nw_protocol_default_remove_listen_handler;
  return result;
}

BOOL nw_protocol_register(void *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v4 = &g_registration_list;
  while (1)
  {
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v18 = "nw_protocol_register";
        __int16 v19 = 2082;
        uint64_t v20 = (uint64_t)a1;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s Protocol %{public}s is already registered", buf, 0x16u);
      }
LABEL_23:
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      return v4 == 0;
    }
  }
  char v10 = malloc_type_calloc(1uLL, 0x78uLL, 0xEAFB8F1AuLL);
  if (v10)
  {
LABEL_20:
    long long v11 = *(_OWORD *)a1;
    long long v12 = *((_OWORD *)a1 + 1);
    v10[8] = a1[4];
    *((_OWORD *)v10 + 2) = v11;
    *((_OWORD *)v10 + 3) = v12;
    v10[10] = a2;
    uint64_t v13 = g_registration_list;
    *char v10 = g_registration_list;
    if (v13) {
      *(void *)(v13 + 8) = v10;
    }
    g_registration_list = (uint64_t)v10;
    v10[1] = &g_registration_list;
    goto LABEL_23;
  }
  os_log_type_t v15 = __nwlog_obj();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v18 = "strict_calloc";
  __int16 v19 = 2048;
  uint64_t v20 = 1;
  __int16 v21 = 2048;
  uint64_t v22 = 120;
  BOOL v16 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    goto LABEL_20;
  }
  __break(1u);
  return result;
}

BOOL __nw_path_evaluator_trigger_agents_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  os_log_type_t v5 = v4;
  *(void *)int v24 = 0;
  if (!v4) {
    goto LABEL_14;
  }
  data = (unsigned int *)xpc_dictionary_get_data(v4, "data", (size_t *)v24);
  if (!data) {
    goto LABEL_14;
  }
  if (*(void *)v24 < 0xD8uLL) {
    goto LABEL_14;
  }
  uint64_t v7 = data;
  if (*(void *)v24 != data[53] + 216) {
    goto LABEL_14;
  }
  BOOL is_required = nw_path_netagent_is_required(*(void **)(a1 + 32), v5);
  uint64_t v9 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v9 + 376) == 3 && !*(_DWORD *)(v9 + 320))
  {
    long long v11 = v7 + 52;
    unsigned int v10 = v7[52];
    if ((is_required | ((v10 & 0x40) >> 6))) {
      goto LABEL_8;
    }
LABEL_10:
    BOOL v12 = *(unsigned char *)(a1 + 72) != 0;
    goto LABEL_11;
  }
  long long v11 = v7 + 52;
  unsigned int v10 = v7[52];
  if (!is_required) {
    goto LABEL_10;
  }
LABEL_8:
  BOOL v12 = 1;
LABEL_11:
  if ((v10 & 3) != 1 || (v10 & 0x40) == 0 && *(unsigned char *)(a1 + 73))
  {
LABEL_14:
    BOOL v13 = 1;
    goto LABEL_15;
  }
  BOOL v13 = 1;
  if ((!v12 & (v10 >> 4) & 1) == 0)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    if ((v10 & 1) != 0 && (v10 & 0xC) != 0)
    {
      *(_OWORD *)uu = *(_OWORD *)v7;
      if (!uuid_is_null(uu))
      {
        os_log_type_t v15 = *(NWConcrete_nw_path **)(a1 + 32);
        if ((*((unsigned char *)v11 + 1) & 2) != 0)
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = nw_path_agent_action(v15, uu, 131);
          int v16 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          os_log_type_t v17 = "assert";
          os_log_type_t v18 = "assert failed";
        }
        else
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = nw_path_agent_action(v15, uu, 130);
          int v16 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          os_log_type_t v17 = "triggered";
          os_log_type_t v18 = "trigger failed";
        }
        if (v16) {
          __int16 v19 = v17;
        }
        else {
          __int16 v19 = v18;
        }
        if (__nwlog_path_log::onceToken != -1) {
          dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_48_44893);
        }
        uint64_t v20 = (id)gpathLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = *(void *)(a1 + 40) + 80;
          unsigned int v22 = v7[52];
          *(_DWORD *)int v24 = 136447746;
          *(void *)&v24[4] = "nw_path_evaluator_trigger_agents_block_invoke";
          __int16 v25 = 1042;
          int v26 = 16;
          __int16 v27 = 2098;
          uint64_t v28 = v21;
          __int16 v29 = 2082;
          uint64_t v30 = v19;
          __int16 v31 = 2082;
          os_log_type_t v32 = v7 + 4;
          __int16 v33 = 2082;
          int v34 = v7 + 12;
          __int16 v35 = 1024;
          unsigned int v36 = v22;
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P] agent %{public}s %{public}s:%{public}s flags: 0x%x", v24, 0x40u);
        }

        uint64_t v23 = *(void **)(a1 + 48);
        if (v23 && object_getClass(v23) == (Class)MEMORY[0x1E4F14568]) {
          xpc_array_set_uuid(*(xpc_object_t *)(a1 + 48), 0xFFFFFFFFFFFFFFFFLL, uu);
        }
      }
      BOOL v13 = *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) != 0;
    }
  }
LABEL_15:

  return v13;
}

void sub_18333AF14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_evaluator_cancel_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZL30nw_listener_set_state_on_queueP22NWConcrete_nw_listener19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_202(uint64_t a1)
{
  return nw_utilities_execute_block_as_persona_from_parameters(*(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(void **)(a1 + 32));
}

BOOL nw_parameters_create_from_dictionary(void *a1)
{
  uint64_t v280 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (!v1)
  {
    nw_parameters_t v2 = 0;
LABEL_160:
    v144 = v2;

    return (BOOL)v144;
  }
  nw_parameters_t v2 = nw_parameters_create();
  Class Class = object_getClass(v1);
  id v4 = (objc_class *)MEMORY[0x1E4F14590];
  if (Class == (Class)MEMORY[0x1E4F14590] && (xpc_object_t value = xpc_dictionary_get_value(v1, "required_interface")) != 0)
  {
    xpc_object_t v7 = value;
    if (object_getClass(value) == v4) {
      os_log_type_t v5 = v7;
    }
    else {
      os_log_type_t v5 = 0;
    }
  }
  else
  {
    os_log_type_t v5 = 0;
  }
  id v8 = v5;
  uint64_t v9 = nw_interface_create_from_dictionary(v8);
  Class isa = v2[13].isa;
  long long v11 = (void *)*((void *)isa + 21);
  *((void *)isa + 21) = v9;

  *((_DWORD *)v2[13].isa + 19) = xpc_dictionary_get_uint64(v1, "required_interface_type");
  if (xpc_dictionary_get_BOOL(v1, "only_primary_requires_type")) {
    __int16 v12 = 32;
  }
  else {
    __int16 v12 = 0;
  }
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFDF | v12;
  *((_DWORD *)v2[13].isa + 20) = xpc_dictionary_get_uint64(v1, "required_interface_subtype");
  *((_DWORD *)v2[13].isa + 23) = xpc_dictionary_get_uint64(v1, "next_hop_required_interface_type");
  *((_DWORD *)v2[13].isa + 24) = xpc_dictionary_get_uint64(v1, "next_hop_required_interface_subtype");
  string = xpc_dictionary_get_string(v1, "effective_bundle_id");
  if (string) {
    nw_parameters_set_effective_bundle_id(v2, string);
  }
  BOOL v14 = xpc_dictionary_get_string(v1, "account_id");
  if (v14) {
    nw_parameters_set_account_id(v2, v14);
  }
  os_log_type_t v15 = xpc_dictionary_get_string(v1, "attribution_context");
  if (v15) {
    nw_parameters_set_attribution_context(v2, v15);
  }
  int v16 = xpc_dictionary_get_string(v1, "url");
  if (v16)
  {
    nw_endpoint_t url = nw_endpoint_create_url(v16);
    Class v18 = v2[25].isa;
    v2[25].Class isa = (Class)url;
  }
  __int16 v19 = xpc_dictionary_get_string(v1, "main_document_url");
  if (v19)
  {
    nw_endpoint_t v20 = nw_endpoint_create_url(v19);
    Class v21 = v2[26].isa;
    v2[26].Class isa = (Class)v20;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v146 = xpc_dictionary_get_value(v1, "effective_audit_token")) != 0
    && (v147 = v146, object_getClass(v146) == (Class)MEMORY[0x1E4F14580]))
  {
    id v260 = v147;
    xpc_data_get_bytes(v260, &v2[5], 0, 0x20uLL);
  }
  else
  {
    id v260 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v148 = xpc_dictionary_get_value(v1, "local_address")) != 0
    && (v149 = v148, object_getClass(v148) == v4))
  {
    id v261 = v149;
    v150 = nw_endpoint_create_from_dictionary(v261);
    Class v151 = v2[13].isa;
    v152 = (void *)*((void *)v151 + 20);
    *((void *)v151 + 20) = v150;
  }
  else
  {
    id v261 = 0;
  }
  BOOL v22 = xpc_dictionary_get_BOOL(v1, "reuse_local_address");
  uint64_t v23 = 256;
  if (!v22) {
    uint64_t v23 = 0;
  }
  v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFEFFLL | v23);
  Class v24 = object_getClass(v1);
  xpc_object_t v25 = 0;
  if (v24 == v4)
  {
    xpc_object_t v25 = xpc_dictionary_get_value(v1, "tls_session_id");
    if (v25)
    {
      v153 = v25;
      if (object_getClass(v25) == (Class)MEMORY[0x1E4F14580]) {
        xpc_object_t v25 = xpc_retain(v153);
      }
      else {
        xpc_object_t v25 = 0;
      }
    }
  }
  Class v26 = v2[16].isa;
  v2[16].Class isa = (Class)v25;

  *((_DWORD *)v2[13].isa + 18) = xpc_dictionary_get_uint64(v1, "traffic_class");
  *((_DWORD *)v2[13].isa + 16) = xpc_dictionary_get_int64(v1, "pid");
  *((_DWORD *)v2[13].isa + 17) = xpc_dictionary_get_int64(v1, "uid");
  uuid = xpc_dictionary_get_uuid(v1, "proc_uuid");
  if (uuid) {
    *(_OWORD *)((char *)v2[13].isa + 8) = *(_OWORD *)uuid;
  }
  uint64_t v28 = xpc_dictionary_get_uuid(v1, "e_proc_uuid");
  if (v28) {
    *(_OWORD *)((char *)v2[13].isa + 24) = *(_OWORD *)v28;
  }
  __int16 v29 = xpc_dictionary_get_uuid(v1, "persona_id");
  if (v29) {
    *(_OWORD *)((char *)v2[13].isa + 40) = *(_OWORD *)v29;
  }
  uint64_t v30 = xpc_dictionary_get_uuid(v1, "parent_id");
  if (v30) {
    *(_OWORD *)&v2[1].Class isa = *(_OWORD *)v30;
  }
  v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFFFELL | xpc_dictionary_get_BOOL(v1, "dry_run"));
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFFE | xpc_dictionary_get_BOOL(v1, "prohibit_expensive");
  if (xpc_dictionary_get_BOOL(v1, "prohibit_constrained")) {
    __int16 v31 = 2;
  }
  else {
    __int16 v31 = 0;
  }
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFFD | v31;
  if (xpc_dictionary_get_BOOL(v1, "allow_ultra_constrained")) {
    __int16 v32 = 4;
  }
  else {
    __int16 v32 = 0;
  }
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFFB | v32;
  if (xpc_dictionary_get_BOOL(v1, "prohibit_roaming")) {
    __int16 v33 = 8;
  }
  else {
    __int16 v33 = 0;
  }
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFF7 | v33;
  if (object_getClass(v1) == v4
    && (xpc_object_t v154 = xpc_dictionary_get_value(v1, "prohibited_interface_types")) != 0
    && (v155 = v154, object_getClass(v154) == (Class)MEMORY[0x1E4F14568])
    && (id obj = xpc_retain(v155)) != 0)
  {
    v156 = (id *)*((void *)v2[13].isa + 22);
    if (!v156)
    {
      v157 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v157)
      {
        v223 = __nwlog_obj();
        os_log_type_enabled(v223, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v224 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v224);
        if (result) {
          goto LABEL_341;
        }
        free(v224);
      }
      *((void *)v2[13].isa + 22) = v157;
      v156 = (id *)*((void *)v2[13].isa + 22);
    }
    objc_storeStrong(v156, obj);
  }
  else
  {
    id obj = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v158 = xpc_dictionary_get_value(v1, "prohibited_interface_subtypes")) != 0
    && (v159 = v158, object_getClass(v158) == (Class)MEMORY[0x1E4F14568])
    && (id v263 = xpc_retain(v159)) != 0)
  {
    uint64_t v160 = *((void *)v2[13].isa + 22);
    if (!v160)
    {
      v161 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v161)
      {
        v225 = __nwlog_obj();
        os_log_type_enabled(v225, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v226 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v226);
        if (result) {
          goto LABEL_341;
        }
        free(v226);
      }
      *((void *)v2[13].isa + 22) = v161;
      uint64_t v160 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v160 + 8), v263);
  }
  else
  {
    id v263 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v162 = xpc_dictionary_get_value(v1, "preferred_interface_subtypes")) != 0
    && (v163 = v162, object_getClass(v162) == (Class)MEMORY[0x1E4F14568])
    && (id v264 = xpc_retain(v163)) != 0)
  {
    uint64_t v164 = *((void *)v2[13].isa + 22);
    if (!v164)
    {
      v165 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v165)
      {
        v227 = __nwlog_obj();
        os_log_type_enabled(v227, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v228 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v228);
        if (result) {
          goto LABEL_341;
        }
        free(v228);
      }
      *((void *)v2[13].isa + 22) = v165;
      uint64_t v164 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v164 + 16), v264);
  }
  else
  {
    id v264 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v166 = xpc_dictionary_get_value(v1, "prohibited_interfaces")) != 0
    && (v167 = v166, object_getClass(v166) == (Class)MEMORY[0x1E4F14568])
    && (id v265 = xpc_retain(v167)) != 0)
  {
    uint64_t v168 = *((void *)v2[13].isa + 22);
    if (!v168)
    {
      v169 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v169)
      {
        v229 = __nwlog_obj();
        os_log_type_enabled(v229, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v230 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v230);
        if (result) {
          goto LABEL_341;
        }
        free(v230);
      }
      *((void *)v2[13].isa + 22) = v169;
      uint64_t v168 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v168 + 24), v265);
  }
  else
  {
    id v265 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v170 = xpc_dictionary_get_value(v1, "prohibited_netagent_domains")) != 0
    && (v171 = v170, object_getClass(v170) == (Class)MEMORY[0x1E4F14568])
    && (id v266 = xpc_retain(v171)) != 0)
  {
    uint64_t v172 = *((void *)v2[13].isa + 22);
    if (!v172)
    {
      v173 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v173)
      {
        v231 = __nwlog_obj();
        os_log_type_enabled(v231, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v232 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v232);
        if (result) {
          goto LABEL_341;
        }
        free(v232);
      }
      *((void *)v2[13].isa + 22) = v173;
      uint64_t v172 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v172 + 32), v266);
  }
  else
  {
    id v266 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v174 = xpc_dictionary_get_value(v1, "prohibited_netagent_types")) != 0
    && (v175 = v174, object_getClass(v174) == (Class)MEMORY[0x1E4F14568])
    && (id v267 = xpc_retain(v175)) != 0)
  {
    uint64_t v176 = *((void *)v2[13].isa + 22);
    if (!v176)
    {
      v177 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v177)
      {
        v233 = __nwlog_obj();
        os_log_type_enabled(v233, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v234 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v234);
        if (result) {
          goto LABEL_341;
        }
        free(v234);
      }
      *((void *)v2[13].isa + 22) = v177;
      uint64_t v176 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v176 + 40), v267);
  }
  else
  {
    id v267 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v178 = xpc_dictionary_get_value(v1, "prohibited_netagent_uuids")) != 0
    && (v179 = v178, object_getClass(v178) == (Class)MEMORY[0x1E4F14568])
    && (id v268 = xpc_retain(v179)) != 0)
  {
    uint64_t v180 = *((void *)v2[13].isa + 22);
    if (!v180)
    {
      v181 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v181)
      {
        v235 = __nwlog_obj();
        os_log_type_enabled(v235, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v236 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v236);
        if (result) {
          goto LABEL_341;
        }
        free(v236);
      }
      *((void *)v2[13].isa + 22) = v181;
      uint64_t v180 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v180 + 48), v268);
  }
  else
  {
    id v268 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v182 = xpc_dictionary_get_value(v1, "required_netagent_domains")) != 0
    && (v183 = v182, object_getClass(v182) == (Class)MEMORY[0x1E4F14568])
    && (id v269 = xpc_retain(v183)) != 0)
  {
    uint64_t v184 = *((void *)v2[13].isa + 22);
    if (!v184)
    {
      v185 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v185)
      {
        v237 = __nwlog_obj();
        os_log_type_enabled(v237, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v238 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v238);
        if (result) {
          goto LABEL_341;
        }
        free(v238);
      }
      *((void *)v2[13].isa + 22) = v185;
      uint64_t v184 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v184 + 56), v269);
  }
  else
  {
    id v269 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v186 = xpc_dictionary_get_value(v1, "required_netagent_types")) != 0
    && (v187 = v186, object_getClass(v186) == (Class)MEMORY[0x1E4F14568])
    && (id v270 = xpc_retain(v187)) != 0)
  {
    uint64_t v188 = *((void *)v2[13].isa + 22);
    if (!v188)
    {
      v189 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v189)
      {
        v239 = __nwlog_obj();
        os_log_type_enabled(v239, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v240 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v240);
        if (result) {
          goto LABEL_341;
        }
        free(v240);
      }
      *((void *)v2[13].isa + 22) = v189;
      uint64_t v188 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v188 + 64), v270);
  }
  else
  {
    id v270 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v190 = xpc_dictionary_get_value(v1, "required_netagent_uuids")) != 0
    && (v191 = v190, object_getClass(v190) == (Class)MEMORY[0x1E4F14568])
    && (id v271 = xpc_retain(v191)) != 0)
  {
    uint64_t v192 = *((void *)v2[13].isa + 22);
    if (!v192)
    {
      v193 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v193)
      {
        v241 = __nwlog_obj();
        os_log_type_enabled(v241, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v242 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v242);
        if (result) {
          goto LABEL_341;
        }
        free(v242);
      }
      *((void *)v2[13].isa + 22) = v193;
      uint64_t v192 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v192 + 72), v271);
  }
  else
  {
    id v271 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v194 = xpc_dictionary_get_value(v1, "preferred_netagent_domains")) != 0
    && (v195 = v194, object_getClass(v194) == (Class)MEMORY[0x1E4F14568])
    && (xpc_object_t v272 = xpc_retain(v195)) != 0)
  {
    uint64_t v196 = *((void *)v2[13].isa + 22);
    if (!v196)
    {
      v197 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v197)
      {
        v243 = __nwlog_obj();
        os_log_type_enabled(v243, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(void *)&length[4] = "strict_calloc";
        __int16 v276 = 2048;
        uint64_t v277 = 1;
        __int16 v278 = 2048;
        uint64_t v279 = 144;
        v244 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v244);
        if (result) {
          goto LABEL_341;
        }
        free(v244);
      }
      *((void *)v2[13].isa + 22) = v197;
      uint64_t v196 = *((void *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v196 + 80), v272);
  }
  else
  {
    xpc_object_t v272 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v198 = xpc_dictionary_get_value(v1, "preferred_netagent_types")) != 0
    && (v199 = v198, object_getClass(v198) == (Class)MEMORY[0x1E4F14568]))
  {
    xpc_object_t v34 = xpc_retain(v199);
    if (v34)
    {
      uint64_t v200 = *((void *)v2[13].isa + 22);
      if (!v200)
      {
        v201 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
        if (!v201)
        {
          v245 = __nwlog_obj();
          os_log_type_enabled(v245, OS_LOG_TYPE_ERROR);
          *(_DWORD *)length = 136446722;
          *(void *)&length[4] = "strict_calloc";
          __int16 v276 = 2048;
          uint64_t v277 = 1;
          __int16 v278 = 2048;
          uint64_t v279 = 144;
          v246 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v246);
          if (result) {
            goto LABEL_341;
          }
          free(v246);
        }
        *((void *)v2[13].isa + 22) = v201;
        uint64_t v200 = *((void *)v2[13].isa + 22);
      }
      objc_storeStrong((id *)(v200 + 88), v34);
    }
  }
  else
  {
    xpc_object_t v34 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v202 = xpc_dictionary_get_value(v1, "preferred_netagent_uuids")) != 0
    && (v203 = v202, object_getClass(v202) == (Class)MEMORY[0x1E4F14568]))
  {
    xpc_object_t v35 = xpc_retain(v203);
    if (v35)
    {
      uint64_t v204 = *((void *)v2[13].isa + 22);
      if (!v204)
      {
        v205 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
        if (!v205)
        {
          v247 = __nwlog_obj();
          os_log_type_enabled(v247, OS_LOG_TYPE_ERROR);
          *(_DWORD *)length = 136446722;
          *(void *)&length[4] = "strict_calloc";
          __int16 v276 = 2048;
          uint64_t v277 = 1;
          __int16 v278 = 2048;
          uint64_t v279 = 144;
          v248 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v248);
          if (result) {
            goto LABEL_341;
          }
          free(v248);
        }
        *((void *)v2[13].isa + 22) = v205;
        uint64_t v204 = *((void *)v2[13].isa + 22);
      }
      objc_storeStrong((id *)(v204 + 96), v35);
    }
  }
  else
  {
    xpc_object_t v35 = 0;
  }
  if (object_getClass(v1) == v4
    && (xpc_object_t v206 = xpc_dictionary_get_value(v1, "avoided_netagent_domains")) != 0
    && (v207 = v206, object_getClass(v206) == (Class)MEMORY[0x1E4F14568]))
  {
    xpc_object_t v36 = xpc_retain(v207);
    if (v36)
    {
      uint64_t v208 = *((void *)v2[13].isa + 22);
      if (!v208)
      {
        v209 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
        if (!v209)
        {
          v249 = __nwlog_obj();
          os_log_type_enabled(v249, OS_LOG_TYPE_ERROR);
          *(_DWORD *)length = 136446722;
          *(void *)&length[4] = "strict_calloc";
          __int16 v276 = 2048;
          uint64_t v277 = 1;
          __int16 v278 = 2048;
          uint64_t v279 = 144;
          v250 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v250);
          if (result) {
            goto LABEL_341;
          }
          free(v250);
        }
        *((void *)v2[13].isa + 22) = v209;
        uint64_t v208 = *((void *)v2[13].isa + 22);
      }
      objc_storeStrong((id *)(v208 + 104), v36);
    }
  }
  else
  {
    xpc_object_t v36 = 0;
  }
  if (object_getClass(v1) == v4)
  {
    xpc_object_t v210 = xpc_dictionary_get_value(v1, "avoided_netagent_types");
    xpc_object_t v37 = v210;
    if (!v210) {
      goto LABEL_76;
    }
    if (object_getClass(v210) == (Class)MEMORY[0x1E4F14568])
    {
      xpc_object_t v37 = xpc_retain(v37);
      if (v37)
      {
        uint64_t v211 = *((void *)v2[13].isa + 22);
        if (!v211)
        {
          v212 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
          if (!v212)
          {
            v251 = __nwlog_obj();
            os_log_type_enabled(v251, OS_LOG_TYPE_ERROR);
            *(_DWORD *)length = 136446722;
            *(void *)&length[4] = "strict_calloc";
            __int16 v276 = 2048;
            uint64_t v277 = 1;
            __int16 v278 = 2048;
            uint64_t v279 = 144;
            v252 = (void *)_os_log_send_and_compose_impl();

            BOOL result = __nwlog_abort((uint64_t)v252);
            if (result) {
              goto LABEL_341;
            }
            free(v252);
          }
          *((void *)v2[13].isa + 22) = v212;
          uint64_t v211 = *((void *)v2[13].isa + 22);
        }
        objc_storeStrong((id *)(v211 + 112), v37);
      }
      goto LABEL_76;
    }
  }
  xpc_object_t v37 = 0;
LABEL_76:
  if (object_getClass(v1) != v4)
  {
LABEL_77:
    xpc_object_t v38 = 0;
    goto LABEL_78;
  }
  xpc_object_t v213 = xpc_dictionary_get_value(v1, "avoided_netagent_uuids");
  xpc_object_t v38 = v213;
  if (!v213) {
    goto LABEL_78;
  }
  if (object_getClass(v213) != (Class)MEMORY[0x1E4F14568]) {
    goto LABEL_77;
  }
  xpc_object_t v38 = xpc_retain(v38);
  if (!v38)
  {
LABEL_78:
    if (object_getClass(v1) != v4)
    {
LABEL_79:
      xpc_object_t v39 = 0;
      goto LABEL_80;
    }
    xpc_object_t v39 = xpc_dictionary_get_value(v1, "extra_parent_ids");
    if (v39)
    {
      v216 = v39;
      if (object_getClass(v39) != (Class)MEMORY[0x1E4F14568]) {
        goto LABEL_79;
      }
      xpc_object_t v39 = xpc_retain(v216);
    }
LABEL_80:
    Class v40 = v2[17].isa;
    v2[17].Class isa = (Class)v39;

    BOOL v41 = xpc_dictionary_get_BOOL(v1, "trust_invalid_certs");
    uint64_t v42 = 0x200000000000;
    if (!v41) {
      uint64_t v42 = 0;
    }
    v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFDFFFFFFFFFFFLL | v42);
    BOOL v43 = xpc_dictionary_get_BOOL(v1, "should_skip_probe_sampling");
    uint64_t v44 = 0x400000000000;
    if (!v43) {
      uint64_t v44 = 0;
    }
    v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFBFFFFFFFFFFFLL | v44);
    if (xpc_dictionary_get_BOOL(v1, "use_long_outstanding_queries")) {
      uint64_t v45 = 8;
    }
    else {
      uint64_t v45 = 0;
    }
    v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFFF7 | v45);
    BOOL v46 = xpc_dictionary_get_BOOL(v1, "use_awdl");
    Class v47 = v2[13].isa;
    int v49 = *((unsigned __int16 *)v47 + 54);
    BOOL v48 = (char *)v47 + 108;
    int v50 = v49 | (v48[2] << 16);
    if (v46) {
      __int16 v51 = 8;
    }
    else {
      __int16 v51 = 0;
    }
    unsigned int v52 = v50 & 0xFFFFFFF7;
    *(_WORD *)BOOL v48 = v52 | v51;
    void v48[2] = BYTE2(v52);
    BOOL v53 = xpc_dictionary_get_BOOL(v1, "use_p2p");
    Class v54 = v2[13].isa;
    int v56 = *((unsigned __int16 *)v54 + 54);
    uint64_t v55 = (char *)v54 + 108;
    int v57 = v56 | (v55[2] << 16);
    if (v53) {
      __int16 v58 = 16;
    }
    else {
      __int16 v58 = 0;
    }
    unsigned int v59 = v57 & 0xFFFFFFEF;
    *(_WORD *)uint64_t v55 = v59 | v58;
    v55[2] = BYTE2(v59);
    BOOL v60 = xpc_dictionary_get_BOOL(v1, "resolve_ptr");
    uint64_t v61 = 32;
    if (!v60) {
      uint64_t v61 = 0;
    }
    v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFFDFLL | v61);
    int v62 = xpc_dictionary_get_value(v1, "indefinite");
    BOOL v63 = v62 == 0;

    if (v63)
    {
LABEL_101:
      BOOL v67 = xpc_dictionary_get_BOOL(v1, "no_fallback");
      Class v68 = v2[13].isa;
      int v70 = *((unsigned __int16 *)v68 + 54);
      uint64_t v69 = (char *)v68 + 108;
      int v71 = v70 | (v69[2] << 16);
      if (v67) {
        __int16 v72 = 32;
      }
      else {
        __int16 v72 = 0;
      }
      unsigned int v73 = v71 & 0xFFFFFFDF;
      *(_WORD *)uint64_t v69 = v73 | v72;
      v69[2] = BYTE2(v73);
      BOOL v74 = xpc_dictionary_get_BOOL(v1, "no_proxy");
      Class v75 = v2[13].isa;
      int v77 = *((unsigned __int16 *)v75 + 54);
      char v76 = (char *)v75 + 108;
      int v78 = v77 | (v76[2] << 16);
      if (v74) {
        __int16 v79 = 2;
      }
      else {
        __int16 v79 = 0;
      }
      unsigned int v80 = v78 & 0xFFFFFFFD;
      *(_WORD *)char v76 = v80 | v79;
      v76[2] = BYTE2(v80);
      BOOL v81 = xpc_dictionary_get_BOOL(v1, "no_transform");
      Class v82 = v2[13].isa;
      int v84 = *((unsigned __int16 *)v82 + 54);
      uint64_t v83 = (char *)v82 + 108;
      int v85 = v84 | (v83[2] << 16);
      if (v81) {
        __int16 v86 = 4;
      }
      else {
        __int16 v86 = 0;
      }
      unsigned int v87 = v85 & 0xFFFFFFFB;
      *(_WORD *)uint64_t v83 = v87 | v86;
      v83[2] = BYTE2(v87);
      BOOL v88 = xpc_dictionary_get_BOOL(v1, "server");
      uint64_t v89 = 0x8000;
      if (!v88) {
        uint64_t v89 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFF7FFFLL | v89);
      *(_DWORD *)((char *)v2[13].isa + 103) = xpc_dictionary_get_uint64(v1, "multipath_service");
      BYTE4(v2[11].isa) = xpc_dictionary_get_uint64(v1, "data_mode");
      LODWORD(v2[11].isa) = xpc_dictionary_get_uint64(v1, "sleep_keepalive_interval");
      BOOL v90 = xpc_dictionary_get_BOOL(v1, "custom_protocols_only");
      uint64_t v91 = 2048;
      if (!v90) {
        uint64_t v91 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFF7FFLL | v91);
      *((_WORD *)v2[13].isa + 54) = *((_WORD *)v2[13].isa + 54) & 0xFFFE | xpc_dictionary_get_BOOL(v1, "discretionary");
      BOOL v92 = xpc_dictionary_get_BOOL(v1, "local_only");
      uint64_t v93 = 0x4000;
      if (!v92) {
        uint64_t v93 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFBFFFLL | v93);
      BOOL v94 = xpc_dictionary_get_BOOL(v1, "receive_any_interface");
      uint64_t v95 = 512;
      if (!v94) {
        uint64_t v95 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFDFFLL | v95);
      BYTE5(v2[11].isa) = xpc_dictionary_get_uint64(v1, "ecn_mode");
      *((_DWORD *)v2[13].isa + 21) = xpc_dictionary_get_uint64(v1, "companion_preference");
      *(void *)length = 0;
      data = xpc_dictionary_get_data(v1, "initial_data_payload", (size_t *)length);
      if (*(void *)length && data)
      {
        dispatch_data_t v97 = dispatch_data_create(data, *(size_t *)length, 0, 0);
        Class v98 = v2[18].isa;
        v2[18].Class isa = (Class)v97;
      }
      if (object_getClass(v1) == v4)
      {
        xpc_object_t v217 = xpc_dictionary_get_value(v1, "metadata");
        xpc_object_t v99 = v217;
        if (!v217) {
          goto LABEL_123;
        }
        if (object_getClass(v217) == (Class)MEMORY[0x1E4F14580])
        {
          xpc_object_t v99 = xpc_retain(v99);
          if (v99) {
            objc_storeStrong((id *)&v2[27].isa, v99);
          }
          goto LABEL_123;
        }
      }
      xpc_object_t v99 = 0;
LABEL_123:
      BOOL v100 = xpc_dictionary_get_BOOL(v1, "allow_unusable_addresses");
      uint64_t v101 = 0x80000;
      if (!v100) {
        uint64_t v101 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFF7FFFFLL | v101);
      BOOL v102 = xpc_dictionary_get_BOOL(v1, "prefer_no_proxy");
      Class v103 = v2[13].isa;
      int v105 = *((unsigned __int16 *)v103 + 54);
      v104 = (char *)v103 + 108;
      int v106 = v105 | (v104[2] << 16);
      if (v102) {
        __int16 v107 = 256;
      }
      else {
        __int16 v107 = 0;
      }
      unsigned int v108 = v106 & 0xFFFFFEFF;
      *(_WORD *)v104 = v108 | v107;
      v104[2] = BYTE2(v108);
      BOOL v109 = xpc_dictionary_get_BOOL(v1, "https_proxy_is_opaque");
      uint64_t v110 = 0x100000;
      if (!v109) {
        uint64_t v110 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFEFFFFFLL | v110);
      BOOL v111 = xpc_dictionary_get_BOOL(v1, "https_proxy_over_tls");
      uint64_t v112 = 0x200000;
      if (!v111) {
        uint64_t v112 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFDFFFFFLL | v112);
      BOOL v113 = xpc_dictionary_get_BOOL(v1, "attach_protocol_listener");
      uint64_t v114 = 0x400000;
      if (!v113) {
        uint64_t v114 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFBFFFFFLL | v114);
      BOOL v115 = xpc_dictionary_get_BOOL(v1, "prohibit_joining_protocols");
      uint64_t v116 = 0x800000;
      if (!v115) {
        uint64_t v116 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFF7FFFFFLL | v116);
      BOOL v117 = xpc_dictionary_get_BOOL(v1, "allow_joining_connected_fd");
      uint64_t v118 = 0x1000000;
      if (!v117) {
        uint64_t v118 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFEFFFFFFLL | v118);
      BOOL v119 = xpc_dictionary_get_BOOL(v1, "allow_duplicate_state_updates");
      uint64_t v120 = 0x4000000;
      if (!v119) {
        uint64_t v120 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFBFFFFFFLL | v120);
      BOOL v121 = xpc_dictionary_get_BOOL(v1, "always_open_listener_socket");
      uint64_t v122 = 0x8000000;
      if (!v121) {
        uint64_t v122 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFF7FFFFFFLL | v122);
      BOOL v123 = xpc_dictionary_get_BOOL(v1, "never_open_listener_socket");
      uint64_t v124 = 0x10000000;
      if (!v123) {
        uint64_t v124 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFEFFFFFFFLL | v124);
      BOOL v125 = xpc_dictionary_get_BOOL(v1, "disable_listener_datapath");
      uint64_t v126 = 0x20000000;
      if (!v125) {
        uint64_t v126 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFDFFFFFFFLL | v126);
      BOOL v127 = xpc_dictionary_get_BOOL(v1, "requires_dnssec_validation");
      uint64_t v128 = 0x40000000;
      if (!v127) {
        uint64_t v128 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFBFFFFFFFLL | v128);
      BOOL v129 = xpc_dictionary_get_BOOL(v1, "known_tracker");
      Class v130 = v2[13].isa;
      int v132 = *((unsigned __int16 *)v130 + 54);
      v131 = (char *)v130 + 108;
      int v133 = v132 | (v131[2] << 16);
      if (v129) {
        __int16 v134 = 0x4000;
      }
      else {
        __int16 v134 = 0;
      }
      unsigned int v135 = v133 & 0xFFFFBFFF;
      *(_WORD *)v131 = v135 | v134;
      v131[2] = BYTE2(v135);
      *((unsigned char *)v2[13].isa + 102) = xpc_dictionary_get_uint64(v1, "attribution");
      BOOL v136 = xpc_dictionary_get_BOOL(v1, "include_ble");
      uint64_t v137 = 0x800000000;
      if (!v136) {
        uint64_t v137 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFF7FFFFFFFFLL | v137);
      BOOL v138 = xpc_dictionary_get_BOOL(v1, "screen_off");
      uint64_t v139 = 0x1000000000;
      if (!v138) {
        uint64_t v139 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFEFFFFFFFFFLL | v139);
      BOOL v140 = xpc_dictionary_get_BOOL(v1, "internet_fallback");
      uint64_t v141 = 0x2000000000;
      if (!v140) {
        uint64_t v141 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFDFFFFFFFFFLL | v141);
      BOOL v142 = xpc_dictionary_get_BOOL(v1, "minimize_logging");
      uint64_t v143 = 0x4000000000;
      if (!v142) {
        uint64_t v143 = 0;
      }
      v2[12].Class isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFBFFFFFFFFFLL | v143);

      goto LABEL_160;
    }
    BOOL v64 = xpc_dictionary_get_BOOL(v1, "indefinite");
    __int16 v65 = v2;
    if (v65)
    {
      uint64_t v66 = 128;
      if (v64) {
        uint64_t v66 = 192;
      }
      v2[12].Class isa = (Class)(v66 | (unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFF3FLL);
LABEL_100:

      goto LABEL_101;
    }
    v218 = __nwlog_obj();
    *(_DWORD *)length = 136446210;
    *(void *)&length[4] = "nw_parameters_set_indefinite";
    v258 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t v274 = OS_LOG_TYPE_ERROR;
    char v273 = 0;
    v219 = (char *)v258;
    if (!__nwlog_fault(v258, &v274, &v273))
    {
LABEL_307:
      if (v219) {
        free(v219);
      }
      goto LABEL_100;
    }
    if (v274 == OS_LOG_TYPE_FAULT)
    {
      v220 = __nwlog_obj();
      os_log_type_t type = v274;
      if (os_log_type_enabled(v220, v274))
      {
        *(_DWORD *)length = 136446210;
        *(void *)&length[4] = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_1830D4000, v220, type, "%{public}s called with null parameters", length, 0xCu);
      }
    }
    else
    {
      if (v273)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        typea = __nwlog_obj();
        os_log_type_t v254 = v274;
        BOOL v222 = os_log_type_enabled(typea, v274);
        if (backtrace_string)
        {
          if (v222)
          {
            *(_DWORD *)length = 136446466;
            *(void *)&length[4] = "nw_parameters_set_indefinite";
            __int16 v276 = 2082;
            uint64_t v277 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, typea, v254, "%{public}s called with null parameters, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
        }
        else
        {
          if (v222)
          {
            *(_DWORD *)length = 136446210;
            *(void *)&length[4] = "nw_parameters_set_indefinite";
            _os_log_impl(&dword_1830D4000, typea, v254, "%{public}s called with null parameters, no backtrace", length, 0xCu);
          }
        }
        goto LABEL_306;
      }
      v220 = __nwlog_obj();
      os_log_type_t typeb = v274;
      if (os_log_type_enabled(v220, v274))
      {
        *(_DWORD *)length = 136446210;
        *(void *)&length[4] = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_1830D4000, v220, typeb, "%{public}s called with null parameters, backtrace limit exceeded", length, 0xCu);
      }
    }

LABEL_306:
    v219 = (char *)v258;
    goto LABEL_307;
  }
  uint64_t v214 = *((void *)v2[13].isa + 22);
  if (v214)
  {
LABEL_281:
    objc_storeStrong((id *)(v214 + 120), v38);
    goto LABEL_78;
  }
  v215 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
  if (v215)
  {
LABEL_280:
    *((void *)v2[13].isa + 22) = v215;
    uint64_t v214 = *((void *)v2[13].isa + 22);
    goto LABEL_281;
  }
  v253 = __nwlog_obj();
  os_log_type_enabled(v253, OS_LOG_TYPE_ERROR);
  *(_DWORD *)length = 136446722;
  *(void *)&length[4] = "strict_calloc";
  __int16 v276 = 2048;
  uint64_t v277 = 1;
  __int16 v278 = 2048;
  uint64_t v279 = 144;
  v259 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v259);
  if (!result)
  {
    free(v259);
    goto LABEL_280;
  }
LABEL_341:
  __break(1u);
  return result;
}

void sub_18333DDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28)
{
  _Unwind_Resume(a1);
}

void nw_parameters_set_url(void *a1, const char *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  os_log_type_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2 && *a2)
    {
      nw_endpoint_t url = nw_endpoint_create_url(a2);
      uint64_t v6 = (void *)v4[25];
      v4[25] = url;
    }
    else
    {
      uint64_t v6 = (void *)v3[25];
      v3[25] = 0;
    }

    goto LABEL_7;
  }
  xpc_object_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  Class v18 = "nw_parameters_set_url";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        Class v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          Class v18 = "nw_parameters_set_url";
          __int16 v19 = 2082;
          nw_endpoint_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        Class v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        Class v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v8) {
    free(v8);
  }
LABEL_7:
}

void sub_18333E200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_url(const char *url)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (url)
  {
    CFIndex v2 = strlen(url);
    CFURLRef v3 = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)url, v2, 0x600u, 0, 0);
    BOOL v4 = -[NWConcrete_nw_url_endpoint initWithURL:]([NWConcrete_nw_url_endpoint alloc], v3);
    if (v3) {
      CFRelease(v3);
    }
    return (nw_endpoint_t)v4;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_endpoint_create_url";
  xpc_object_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null url", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_endpoint_create_url";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null url, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null url, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null url, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
  return 0;
}

void sub_18333E4E8(_Unwind_Exception *exception_object)
{
}

void sub_18333E4F4(_Unwind_Exception *exception_object)
{
  if (!v1) {
    _Unwind_Resume(exception_object);
  }
  CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void nw_parameters_set_source_application_by_bundle_id_internal(void *a1, const char *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFURLRef v3 = a1;
  BOOL v4 = v3;
  if (v3)
  {
    nw_parameters_set_effective_bundle_id(v3, a2);
    os_log_type_t v5 = (void *)NEHelperCacheCopyAppUUIDMappingExtended();
    uint64_t v6 = v5;
    if (v5 && object_getClass(v5) == (Class)MEMORY[0x1E4F14568] && xpc_array_get_count(v6))
    {
      v4[12] &= ~0x1000uLL;
      *(_OWORD *)(v4[13] + 24) = *(_OWORD *)xpc_array_get_uuid(v6, 0);
    }
    else
    {
      v4[12] |= 0x1000uLL;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      xpc_object_t v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        __int16 v20 = 2082;
        uint64_t v21 = (void *)a2;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s Failed to convert from bundle ID (%{public}s) to UUID. This could lead to incorrect policies and accounting.", buf, 0x16u);
      }
    }
    goto LABEL_8;
  }
  id v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v9) {
    free(v9);
  }
LABEL_8:
}

void sub_18333E8AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_parameters_set_effective_bundle_id(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFURLRef v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    xpc_object_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_parameters_set_effective_bundle_id";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_parameters_set_effective_bundle_id";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v20 = "nw_parameters_set_effective_bundle_id";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_parameters_set_effective_bundle_id";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_parameters_set_effective_bundle_id";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v8) {
      free(v8);
    }
    goto LABEL_8;
  }
  os_log_type_t v5 = (void *)v3[14];
  if (v5)
  {
    free(v5);
    v4[14] = 0;
  }
  if (!a2 || strlen(a2) - 1 > 0x3FE) {
    goto LABEL_8;
  }
  uint64_t v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    v4[14] = v6;
LABEL_8:

    return;
  }
  BOOL v14 = __nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "strict_strdup";
  os_log_type_t v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }
  __break(1u);
}

uint64_t nw_protocol_updated_path_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 168) != 0;
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0;
  }
}

BOOL nw_channel_set_path_flow_registration(uint64_t a1, void *a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v6, type, &v29)) {
      goto LABEL_24;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled(v7, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null channel";
      goto LABEL_22;
    }
    if (!v29)
    {
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled(v7, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    xpc_object_t v7 = __nwlog_obj();
    os_log_type_t v8 = type[0];
    BOOL v25 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (!v25) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null channel, no backtrace";
      goto LABEL_22;
    }
    if (!v25) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    __int16 v32 = 2082;
    v33[0] = backtrace_string;
    Class v26 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_54;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v6, type, &v29)) {
      goto LABEL_24;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled(v7, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null path";
      goto LABEL_22;
    }
    if (!v29)
    {
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled(v7, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null path, backtrace limit exceeded";
      goto LABEL_22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    xpc_object_t v7 = __nwlog_obj();
    os_log_type_t v8 = type[0];
    BOOL v27 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (!v27) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null path, no backtrace";
      goto LABEL_22;
    }
    if (!v27) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    __int16 v32 = 2082;
    v33[0] = backtrace_string;
    Class v26 = "%{public}s called with null path, dumping backtrace:%{public}s";
LABEL_54:
    _os_log_impl(&dword_1830D4000, v7, v8, v26, buf, 0x16u);
    goto LABEL_55;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v6, type, &v29)) {
      goto LABEL_24;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled(v7, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null flow_registration";
      goto LABEL_22;
    }
    if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      BOOL v28 = os_log_type_enabled(v7, type[0]);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v31 = "nw_channel_set_path_flow_registration";
          __int16 v32 = 2082;
          v33[0] = backtrace_string;
          Class v26 = "%{public}s called with null flow_registration, dumping backtrace:%{public}s";
          goto LABEL_54;
        }
LABEL_55:
        free(backtrace_string);
        goto LABEL_24;
      }
      if (!v28) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null flow_registration, no backtrace";
    }
    else
    {
      xpc_object_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled(v7, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s called with null flow_registration, backtrace limit exceeded";
    }
LABEL_22:
    uint64_t v22 = v7;
    os_log_type_t v23 = v8;
LABEL_23:
    _os_log_impl(&dword_1830D4000, v22, v23, v9, buf, 0xCu);
    goto LABEL_24;
  }
  os_log_type_t v5 = a3;
  if (uuid_is_null(v5 + 32))
  {

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v6, type, &v29)) {
      goto LABEL_24;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      xpc_object_t v7 = gLogObj;
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s nw_path_flow_registration_get_id failed";
      goto LABEL_22;
    }
    if (!v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      xpc_object_t v7 = gLogObj;
      os_log_type_t v8 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s nw_path_flow_registration_get_id failed, backtrace limit exceeded";
      goto LABEL_22;
    }
    char v17 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v18 = gLogObj;
    os_log_type_t v19 = type[0];
    BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v17)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v31 = "nw_channel_set_path_flow_registration";
        __int16 v32 = 2082;
        v33[0] = v17;
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s nw_path_flow_registration_get_id failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v17);
      goto LABEL_24;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v31 = "nw_channel_set_path_flow_registration";
      os_log_type_t v9 = "%{public}s nw_path_flow_registration_get_id failed, no backtrace";
      uint64_t v22 = v18;
      os_log_type_t v23 = v19;
      goto LABEL_23;
    }
LABEL_24:
    if (v6) {
      free(v6);
    }
    return 0;
  }
  *(_OWORD *)os_log_type_t type = *((_OWORD *)v5 + 2);

  uint64_t node = nw_hash_table_get_node(*(void *)(a1 + 280), (uint64_t)type, 16);
  if (!node)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v21 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v31 = "nw_channel_set_path_flow_registration";
    __int16 v32 = 1042;
    LODWORD(v33[0]) = 16;
    WORD2(v33[0]) = 2098;
    *(void *)((char *)v33 + 6) = type;
    _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s Node not found for flow id %{public,uuid_t}.16P", buf, 0x1Cu);
    return 0;
  }
  uint64_t v11 = node;
  os_log_type_t v12 = *(void **)(node + 48);
  *(void *)(node + 48) = os_retain(v5);
  nw_path_flow_registration_get_nexus_flow_index(a2, v5, (_DWORD *)(v11 + 112));
  LODWORD(v11) = *(unsigned __int16 *)(a1 + 444);
  BOOL v13 = v5;
  v13[148] = v13[148] & 0xFD | (v11 >> 10) & 2;

  uint64_t advisory_region = nw_channel_get_advisory_region(a1);
  os_log_type_t v15 = v13;
  *((void *)v15 + 10) = advisory_region;

  if (v12) {
    os_release(v12);
  }
  return 1;
}

void sub_18333F4F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_flow_registration_get_nexus_flow_index(void *a1, void *a2, _DWORD *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  os_log_type_t v5 = a1;
  uint64_t v6 = a2;
  if (a3)
  {
    xpc_object_t v7 = nw_path_copy_flow_for_registration(v5, v6);
    BOOL v8 = v7 != 0;
    if (v7) {
      *a3 = v7[41];
    }

    goto LABEL_5;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v21 = "nw_path_flow_registration_get_nexus_flow_index";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_path_flow_registration_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null nexus_flow_index", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v21 = "nw_path_flow_registration_get_nexus_flow_index";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null nexus_flow_index, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_path_flow_registration_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null nexus_flow_index, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_path_flow_registration_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null nexus_flow_index, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v11) {
    free(v11);
  }
  BOOL v8 = 0;
LABEL_5:

  return v8;
}

uint64_t nw_channel_get_advisory_region(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)os_log_type_t v9 = 0;
    if (*(void *)(a1 + 144))
    {
      os_channel_attr_get();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v1 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v12 = "nw_channel_get_advisory_region";
        _os_log_impl(&dword_1830D4000, v1, OS_LOG_TYPE_DEFAULT, "%{public}s advisory region not supported by this channel", buf, 0xCu);
      }
    }
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v12 = "nw_channel_get_advisory_region";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  v9[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v3, v9, &type)) {
    goto LABEL_5;
  }
  if (v9[0] == OS_LOG_TYPE_FAULT)
  {
    BOOL v4 = __nwlog_obj();
    os_log_type_t v5 = v9[0];
    if (!os_log_type_enabled(v4, v9[0])) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v12 = "nw_channel_get_advisory_region";
    uint64_t v6 = "%{public}s called with null channel";
    goto LABEL_22;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    BOOL v4 = __nwlog_obj();
    os_log_type_t v5 = v9[0];
    if (!os_log_type_enabled(v4, v9[0])) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v12 = "nw_channel_get_advisory_region";
    uint64_t v6 = "%{public}s called with null channel, backtrace limit exceeded";
    goto LABEL_22;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  BOOL v4 = __nwlog_obj();
  os_log_type_t v5 = v9[0];
  BOOL v8 = os_log_type_enabled(v4, v9[0]);
  if (!backtrace_string)
  {
    if (!v8) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v12 = "nw_channel_get_advisory_region";
    uint64_t v6 = "%{public}s called with null channel, no backtrace";
LABEL_22:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
LABEL_5:
    if (!v3) {
      return 0;
    }
LABEL_6:
    free(v3);
    return 0;
  }
  if (v8)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v12 = "nw_channel_get_advisory_region";
    __int16 v13 = 2082;
    BOOL v14 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(backtrace_string);
  if (v3) {
    goto LABEL_6;
  }
  return 0;
}

BOOL __nwlog_abort(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0;
  os_log_type_t v9 = &v8;
  uint64_t v10 = 0x3002000000;
  uint64_t v11 = __Block_byref_object_copy__2;
  os_log_type_t v12 = __Block_byref_object_dispose__3;
  uint64_t v13 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  v7[2] = ____nwlog_abort_block_invoke;
  v7[3] = &unk_1E52420E8;
  v7[4] = &v8;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_abort_block_invoke((uint64_t)v7);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  uint64_t v2 = v9[5];
  if (v2)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v9[5], a1) & 1) == 0)
    {
      uint64_t v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v3);
      BOOL v4 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v15 = "__nwlog_abort";
        __int16 v16 = 2080;
        uint64_t v17 = a1;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s Abort not handled: %s", buf, 0x16u);
      }
    }
    os_log_type_t v5 = (const void *)v9[5];
    if (v5)
    {
      _Block_release(v5);
      v9[5] = 0;
    }
  }
  else
  {
    qword_1E8F68060 = a1;
  }
  _Block_object_dispose(&v8, 8);
  return v2 == 0;
}

uint64_t nw_path_get_ipv4_network_signature(void *a1, void *a2, unsigned char *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  os_log_type_t v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_path_get_ipv4_network_signature";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v31 = "nw_path_get_ipv4_network_signature";
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_36;
  }
  if (!a2)
  {
    uint64_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_path_get_ipv4_network_signature";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null signature", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null signature, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v31 = "nw_path_get_ipv4_network_signature";
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null signature, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_36;
  }
  if (!a3)
  {
    uint64_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_path_get_ipv4_network_signature";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null signature_len", buf, 0xCu);
      }
LABEL_54:

LABEL_55:
      if (v10) {
        free(v10);
      }
      goto LABEL_57;
    }
    if (!v28)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s called with null signature_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v31 = "nw_path_get_ipv4_network_signature";
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null signature_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_36:

    free(backtrace_string);
    goto LABEL_55;
  }
  if (!nw_path_network_is_satisfied_update_reason(v5, 0) || (direct = v6->direct) == 0)
  {
LABEL_57:
    uint64_t ipv4_network_signature = 0;
    goto LABEL_58;
  }
  uint64_t ipv4_network_signature = nw_interface_get_ipv4_network_signature(direct, a2, a3);
LABEL_58:

  return ipv4_network_signature;
}

void sub_1833406B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_register_context_internal(void *a1, void *a2, void *a3)
{
  uint64_t v230 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v209 = a2;
  uint64_t v208 = a3;
  uint64_t v6 = (id *)malloc_type_calloc(1uLL, 0x150uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_2:
    objc_storeStrong(v6 + 31, a3);
    nw_endpoint_flow_initialize_protocol(v5, (uint64_t)v6, 1);
    uint64_t v7 = *((void *)v209 + 97);
    uint64_t v206 = v7;
    if (v7)
    {
      uint64_t v8 = *(uint64_t **)(v7 + 24);
      if (atomic_load_explicit((atomic_ullong *volatile)&nw_protocol_get_zombie_callbacks(void)::once_flag, memory_order_acquire) != -1)
      {
        *(void *)buf = &v211;
        *(void *)os_log_type_t type = buf;
        std::__call_once(&nw_protocol_get_zombie_callbacks(void)::once_flag, type, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<nw_protocol_get_zombie_callbacks(void)::$_0 &&>>);
      }
      if (v8 != &nw_protocol_get_zombie_callbacks(void)::callbacks) {
        goto LABEL_6;
      }
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v17 = (id)gconnectionLogObj;
        id_string = nw_endpoint_handler_get_id_string(v5);
        BOOL v19 = nw_endpoint_handler_dry_run_string(v5);
        nw_endpoint_t v20 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v20);
        os_log_type_t v22 = nw_endpoint_handler_state_string(v5);
        BOOL v23 = nw_endpoint_handler_mode_string(v5);
        id v24 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
        __int16 v214 = 2082;
        uint64_t v215 = (uint64_t)id_string;
        __int16 v216 = 2082;
        uint64_t v217 = (uint64_t)v19;
        __int16 v218 = 2082;
        v219 = logging_description;
        __int16 v220 = 2082;
        v221 = v22;
        __int16 v222 = 2082;
        v223 = v23;
        __int16 v224 = 2114;
        id v225 = v24;
        __int16 v226 = 2048;
        v227 = (char *)v206;
        os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v211 = 0;
        if (__nwlog_fault(v25, type, &v211))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v26 = (id)gconnectionLogObj;
            os_log_type_t v27 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              char v28 = nw_endpoint_handler_get_id_string(v5);
              char v29 = nw_endpoint_handler_dry_run_string(v5);
              log = v26;
              nw_endpoint_t v30 = nw_endpoint_handler_copy_endpoint(v5);
              v187 = v25;
              __int16 v31 = nw_endpoint_get_logging_description(v30);
              __int16 v32 = nw_endpoint_handler_state_string(v5);
              __int16 v33 = nw_endpoint_handler_mode_string(v5);
              id v34 = nw_endpoint_handler_copy_current_path(v5);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
              __int16 v214 = 2082;
              uint64_t v215 = (uint64_t)v28;
              __int16 v216 = 2082;
              uint64_t v217 = (uint64_t)v29;
              __int16 v218 = 2082;
              v219 = v31;
              __int16 v220 = 2082;
              v221 = v32;
              __int16 v222 = 2082;
              v223 = v33;
              __int16 v224 = 2114;
              id v225 = v34;
              __int16 v226 = 2048;
              v227 = (char *)v206;
              os_log_type_t v26 = log;
              _os_log_impl(&dword_1830D4000, log, v27, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p", buf, 0x52u);

              os_log_type_t v25 = v187;
            }
          }
          else
          {
            if (v211)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                xpc_object_t v36 = (char *)backtrace_string;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                xpc_object_t v37 = (id)gconnectionLogObj;
                os_log_type_t v38 = type[0];
                if (os_log_type_enabled(v37, type[0]))
                {
                  xpc_object_t v39 = nw_endpoint_handler_get_id_string(v5);
                  Class v40 = nw_endpoint_handler_dry_run_string(v5);
                  loga = v37;
                  uint64_t v188 = v25;
                  nw_endpoint_t v205 = nw_endpoint_handler_copy_endpoint(v5);
                  BOOL v41 = nw_endpoint_get_logging_description(v205);
                  uint64_t v42 = nw_endpoint_handler_state_string(v5);
                  BOOL v43 = nw_endpoint_handler_mode_string(v5);
                  id v44 = nw_endpoint_handler_copy_current_path(v5);
                  *(_DWORD *)buf = 136448258;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                  __int16 v214 = 2082;
                  uint64_t v215 = (uint64_t)v39;
                  __int16 v216 = 2082;
                  uint64_t v217 = (uint64_t)v40;
                  __int16 v218 = 2082;
                  v219 = v41;
                  __int16 v220 = 2082;
                  v221 = v42;
                  __int16 v222 = 2082;
                  v223 = v43;
                  __int16 v224 = 2114;
                  id v225 = v44;
                  __int16 v226 = 2048;
                  v227 = (char *)v206;
                  __int16 v228 = 2082;
                  v229 = v36;
                  xpc_object_t v37 = loga;
                  _os_log_impl(&dword_1830D4000, loga, v38, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p, dumping backtrace:%{public}s", buf, 0x5Cu);

                  os_log_type_t v25 = v188;
                }

                free(v36);
                if (!v25) {
                  goto LABEL_97;
                }
                goto LABEL_96;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              BOOL v94 = (id)gconnectionLogObj;
              os_log_type_t v115 = type[0];
              if (os_log_type_enabled(v94, type[0]))
              {
                uint64_t v116 = nw_endpoint_handler_get_id_string(v5);
                BOOL v117 = nw_endpoint_handler_dry_run_string(v5);
                logf = v94;
                nw_endpoint_t v118 = nw_endpoint_handler_copy_endpoint(v5);
                v193 = v25;
                BOOL v119 = nw_endpoint_get_logging_description(v118);
                uint64_t v120 = nw_endpoint_handler_state_string(v5);
                BOOL v121 = nw_endpoint_handler_mode_string(v5);
                id v122 = nw_endpoint_handler_copy_current_path(v5);
                *(_DWORD *)buf = 136448002;
                *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                __int16 v214 = 2082;
                uint64_t v215 = (uint64_t)v116;
                __int16 v216 = 2082;
                uint64_t v217 = (uint64_t)v117;
                __int16 v218 = 2082;
                v219 = v119;
                __int16 v220 = 2082;
                v221 = v120;
                __int16 v222 = 2082;
                v223 = v121;
                __int16 v224 = 2114;
                id v225 = v122;
                __int16 v226 = 2048;
                v227 = (char *)v206;
                BOOL v94 = logf;
                _os_log_impl(&dword_1830D4000, logf, v115, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p, no backtrace", buf, 0x52u);

                os_log_type_t v25 = v193;
              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              BOOL v94 = (id)gconnectionLogObj;
              os_log_type_t v95 = type[0];
              if (os_log_type_enabled(v94, type[0]))
              {
                v96 = nw_endpoint_handler_get_id_string(v5);
                dispatch_data_t v97 = nw_endpoint_handler_dry_run_string(v5);
                logd = v94;
                nw_endpoint_t v98 = nw_endpoint_handler_copy_endpoint(v5);
                v191 = v25;
                xpc_object_t v99 = nw_endpoint_get_logging_description(v98);
                BOOL v100 = nw_endpoint_handler_state_string(v5);
                uint64_t v101 = nw_endpoint_handler_mode_string(v5);
                id v102 = nw_endpoint_handler_copy_current_path(v5);
                *(_DWORD *)buf = 136448002;
                *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                __int16 v214 = 2082;
                uint64_t v215 = (uint64_t)v96;
                __int16 v216 = 2082;
                uint64_t v217 = (uint64_t)v97;
                __int16 v218 = 2082;
                v219 = v99;
                __int16 v220 = 2082;
                v221 = v100;
                __int16 v222 = 2082;
                v223 = v101;
                __int16 v224 = 2114;
                id v225 = v102;
                __int16 v226 = 2048;
                v227 = (char *)v206;
                BOOL v94 = logd;
                _os_log_impl(&dword_1830D4000, logd, v95, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p, backtrace limit exceeded", buf, 0x52u);

                os_log_type_t v25 = v191;
              }
            }
          }
        }
        if (v25) {
LABEL_96:
        }
          free(v25);
      }
LABEL_97:
      nw_endpoint_flow_cleanup_protocol(v5, (uint64_t)v6, 1);
      id v123 = v6[23];
      v6[23] = 0;

      free(v6);
      uint64_t v6 = 0;
LABEL_123:

      return (BOOL)v6;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
    v147 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v211 = 0;
    if (__nwlog_fault(v147, type, &v211))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        xpc_object_t v148 = __nwlog_obj();
        os_log_type_t v149 = type[0];
        if (!os_log_type_enabled(v148, type[0])) {
          goto LABEL_144;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
        v150 = "%{public}s called with null protocol";
LABEL_142:
        v157 = v148;
        os_log_type_t v158 = v149;
LABEL_143:
        _os_log_impl(&dword_1830D4000, v157, v158, v150, buf, 0xCu);
        goto LABEL_144;
      }
      if (!v211)
      {
        xpc_object_t v148 = __nwlog_obj();
        os_log_type_t v149 = type[0];
        if (!os_log_type_enabled(v148, type[0])) {
          goto LABEL_144;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
        v150 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_142;
      }
      Class v151 = (char *)__nw_create_backtrace_string();
      v152 = __nwlog_obj();
      os_log_type_t v153 = type[0];
      BOOL v154 = os_log_type_enabled(v152, type[0]);
      if (v151)
      {
        if (v154)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
          __int16 v214 = 2082;
          uint64_t v215 = (uint64_t)v151;
          _os_log_impl(&dword_1830D4000, v152, v153, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v151);
        goto LABEL_144;
      }
      if (v154)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
        v150 = "%{public}s called with null protocol, no backtrace";
        v157 = v152;
        os_log_type_t v158 = v153;
        goto LABEL_143;
      }
    }
LABEL_144:
    if (v147) {
      free(v147);
    }
LABEL_6:
    nw_protocol_metadata_t v9 = nw_content_context_copy_protocol_metadata(v208, *((nw_protocol_definition_t *)v209 + 96));
    nw_protocol_metadata_t v204 = v9;
    if (v9)
    {
      objc_storeStrong(v6 + 29, v9);
      uint64_t v10 = (void *)nw_protocol_metadata_copy_message_options(v204);
      uint64_t v11 = v10;
      if (v10)
      {
        os_log_type_t v12 = nw_protocol_options_copy(v10);

        nw_parameters_set_protocol_instance(v12, v13, v206);
        id v14 = v6[22];
        if (v14)
        {
          uint64_t v15 = (id *)v14;
          id v16 = v15[19];

          nw_protocol_stack_replace_protocol(v16, *((void **)v209 + 96), v12);
        }
      }
      else
      {
        os_log_type_t v12 = 0;
      }
    }
    char v210 = 0;
    BOOL v45 = nw_hash_table_add_object(*((void *)v209 + 108), (uint64_t)v6, &v210);
    if (v45 && v210)
    {
      uint64_t v46 = v45;
      if (v206)
      {
        if ((id *)v206 != v6)
        {
          Class v47 = *(void **)(v206 + 24);
          if (v47 && v6 && *v47)
          {
            if (nw_protocol_add_input_handler(v206, (uint64_t)v6))
            {
              BOOL v48 = v6[4];
              if (v48)
              {
                uint64_t v49 = v48[3];
                if (v49)
                {
                  int v50 = *(void (**)(void *, id *))(v49 + 24);
                  if (v50)
                  {
                    v50(v48, v6);
LABEL_42:
                    if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      __int16 v51 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v52 = nw_endpoint_handler_get_id_string(v5);
                        BOOL v53 = nw_endpoint_handler_dry_run_string(v5);
                        nw_endpoint_t v54 = nw_endpoint_handler_copy_endpoint(v5);
                        uint64_t v55 = nw_endpoint_get_logging_description(v54);
                        int v56 = nw_endpoint_handler_state_string(v5);
                        int v57 = nw_endpoint_handler_mode_string(v5);
                        id v58 = nw_endpoint_handler_copy_current_path(v5);
                        unsigned int v59 = *(char **)(v206 + 16);
                        *(_DWORD *)buf = 136448258;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                        __int16 v214 = 2082;
                        uint64_t v215 = (uint64_t)v52;
                        __int16 v216 = 2082;
                        uint64_t v217 = (uint64_t)v53;
                        __int16 v218 = 2082;
                        v219 = v55;
                        __int16 v220 = 2082;
                        v221 = v56;
                        __int16 v222 = 2082;
                        v223 = v57;
                        __int16 v224 = 2114;
                        id v225 = v58;
                        __int16 v226 = 2048;
                        v227 = (char *)v6;
                        __int16 v228 = 2080;
                        v229 = v59;
                        _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added per-message protocol %p to %s", buf, 0x5Cu);
                      }
                    }
                    goto LABEL_122;
                  }
                }
              }
              xpc_object_t v162 = __nwlog_obj();
              id v163 = v6[4];
              uint64_t v164 = "invalid";
              if (v163)
              {
                v165 = (const char *)*((void *)v163 + 2);
                if (v165) {
                  uint64_t v164 = v165;
                }
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
              __int16 v214 = 2082;
              uint64_t v215 = (uint64_t)v164;
              xpc_object_t v166 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              char v211 = 0;
              if (__nwlog_fault(v166, type, &v211))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v167 = __nwlog_obj();
                  os_log_type_t v168 = type[0];
                  if (os_log_type_enabled(v167, type[0]))
                  {
                    id v169 = v6[4];
                    xpc_object_t v170 = "invalid";
                    if (v169)
                    {
                      v171 = (const char *)*((void *)v169 + 2);
                      if (v171) {
                        xpc_object_t v170 = v171;
                      }
                    }
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                    __int16 v214 = 2082;
                    uint64_t v215 = (uint64_t)v170;
                    _os_log_impl(&dword_1830D4000, v167, v168, "%{public}s protocol %{public}s has invalid connect callback", buf, 0x16u);
                  }
                }
                else
                {
                  if (v211)
                  {
                    uint64_t v172 = (char *)__nw_create_backtrace_string();
                    v173 = __nwlog_obj();
                    os_log_type_t v174 = type[0];
                    BOOL v175 = os_log_type_enabled(v173, type[0]);
                    if (v172)
                    {
                      if (v175)
                      {
                        id v176 = v6[4];
                        v177 = "invalid";
                        if (v176)
                        {
                          xpc_object_t v178 = (const char *)*((void *)v176 + 2);
                          if (v178) {
                            v177 = v178;
                          }
                        }
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                        __int16 v214 = 2082;
                        uint64_t v215 = (uint64_t)v177;
                        __int16 v216 = 2082;
                        uint64_t v217 = (uint64_t)v172;
                        _os_log_impl(&dword_1830D4000, v173, v174, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
                      }

                      free(v172);
                    }
                    else
                    {
                      if (v175)
                      {
                        id v184 = v6[4];
                        v185 = "invalid";
                        if (v184)
                        {
                          xpc_object_t v186 = (const char *)*((void *)v184 + 2);
                          if (v186) {
                            v185 = v186;
                          }
                        }
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                        __int16 v214 = 2082;
                        uint64_t v215 = (uint64_t)v185;
                        _os_log_impl(&dword_1830D4000, v173, v174, "%{public}s protocol %{public}s has invalid connect callback, no backtrace", buf, 0x16u);
                      }
                    }
                    goto LABEL_190;
                  }
                  v167 = __nwlog_obj();
                  os_log_type_t v180 = type[0];
                  if (os_log_type_enabled(v167, type[0]))
                  {
                    id v181 = v6[4];
                    xpc_object_t v182 = "invalid";
                    if (v181)
                    {
                      v183 = (const char *)*((void *)v181 + 2);
                      if (v183) {
                        xpc_object_t v182 = v183;
                      }
                    }
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
                    __int16 v214 = 2082;
                    uint64_t v215 = (uint64_t)v182;
                    _os_log_impl(&dword_1830D4000, v167, v180, "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded", buf, 0x16u);
                  }
                }
              }
LABEL_190:
              if (v166) {
                free(v166);
              }
              goto LABEL_42;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v93 = (id)gLogObj;
            if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
              __int16 v214 = 2048;
              uint64_t v215 = v206;
              _os_log_impl(&dword_1830D4000, v93, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
            }
          }
          goto LABEL_114;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v89 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        __int16 v214 = 2048;
        uint64_t v215 = (uint64_t)v6;
        BOOL v90 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v211 = 0;
        if (__nwlog_fault(v90, type, &v211))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v91 = (id)gLogObj;
            os_log_type_t v92 = type[0];
            if (os_log_type_enabled(v91, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
              __int16 v214 = 2048;
              uint64_t v215 = (uint64_t)v6;
              _os_log_impl(&dword_1830D4000, v91, v92, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
LABEL_174:

            goto LABEL_112;
          }
          if (!v211)
          {
            uint64_t v91 = __nwlog_obj();
            os_log_type_t v133 = type[0];
            if (os_log_type_enabled(v91, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
              __int16 v214 = 2048;
              uint64_t v215 = (uint64_t)v6;
              _os_log_impl(&dword_1830D4000, v91, v133, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_174;
          }
          Class v103 = (char *)__nw_create_backtrace_string();
          v104 = __nwlog_obj();
          os_log_type_t v105 = type[0];
          BOOL v106 = os_log_type_enabled(v104, type[0]);
          if (v103)
          {
            if (v106)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
              __int16 v214 = 2048;
              uint64_t v215 = (uint64_t)v6;
              __int16 v216 = 2082;
              uint64_t v217 = (uint64_t)v103;
              _os_log_impl(&dword_1830D4000, v104, v105, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v103);
            if (!v90) {
              goto LABEL_114;
            }
            goto LABEL_113;
          }
          if (v106)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
            __int16 v214 = 2048;
            uint64_t v215 = (uint64_t)v6;
            _os_log_impl(&dword_1830D4000, v104, v105, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
          }
LABEL_111:
        }
      }
      else
      {
        v155 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        BOOL v90 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v211 = 0;
        if (!__nwlog_fault(v90, type, &v211)) {
          goto LABEL_112;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v91 = __nwlog_obj();
          os_log_type_t v156 = type[0];
          if (os_log_type_enabled(v91, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_1830D4000, v91, v156, "%{public}s called with null protocol", buf, 0xCu);
          }
          goto LABEL_174;
        }
        if (!v211)
        {
          uint64_t v91 = __nwlog_obj();
          os_log_type_t v179 = type[0];
          if (os_log_type_enabled(v91, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_1830D4000, v91, v179, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_174;
        }
        v159 = (char *)__nw_create_backtrace_string();
        v104 = __nwlog_obj();
        os_log_type_t v160 = type[0];
        BOOL v161 = os_log_type_enabled(v104, type[0]);
        if (!v159)
        {
          if (v161)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_1830D4000, v104, v160, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }
          goto LABEL_111;
        }
        if (v161)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
          __int16 v214 = 2082;
          uint64_t v215 = (uint64_t)v159;
          _os_log_impl(&dword_1830D4000, v104, v160, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v159);
      }
LABEL_112:
      if (!v90)
      {
LABEL_114:
        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v134 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
          {
            unsigned int v135 = nw_endpoint_handler_get_id_string(v5);
            BOOL v136 = nw_endpoint_handler_dry_run_string(v5);
            nw_endpoint_t v137 = nw_endpoint_handler_copy_endpoint(v5);
            uint64_t logh = v46;
            BOOL v138 = nw_endpoint_get_logging_description(v137);
            uint64_t v139 = nw_endpoint_handler_state_string(v5);
            BOOL v140 = nw_endpoint_handler_mode_string(v5);
            id v141 = nw_endpoint_handler_copy_current_path(v5);
            BOOL v142 = (char *)v6[2];
            uint64_t v143 = *(char **)(v206 + 16);
            *(_DWORD *)buf = 136448258;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
            __int16 v214 = 2082;
            uint64_t v215 = (uint64_t)v135;
            __int16 v216 = 2082;
            uint64_t v217 = (uint64_t)v136;
            __int16 v218 = 2082;
            v219 = v138;
            __int16 v220 = 2082;
            v221 = v139;
            __int16 v222 = 2082;
            v223 = v140;
            __int16 v224 = 2114;
            id v225 = v141;
            __int16 v226 = 2082;
            v227 = v142;
            __int16 v228 = 2082;
            v229 = v143;
            _os_log_impl(&dword_1830D4000, v134, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s to %{public}s", buf, 0x5Cu);

            uint64_t v46 = logh;
          }
        }
        nw_hash_table_remove_node(*((void *)v209 + 108), v46);
        goto LABEL_121;
      }
LABEL_113:
      free(v90);
      goto LABEL_114;
    }
    if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v60 = (id)gconnectionLogObj;
      uint64_t v61 = nw_endpoint_handler_get_id_string(v5);
      int v62 = nw_endpoint_handler_dry_run_string(v5);
      nw_endpoint_t v63 = nw_endpoint_handler_copy_endpoint(v5);
      BOOL v64 = nw_endpoint_get_logging_description(v63);
      __int16 v65 = nw_endpoint_handler_state_string(v5);
      uint64_t v66 = nw_endpoint_handler_mode_string(v5);
      id v67 = nw_endpoint_handler_copy_current_path(v5);
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
      __int16 v214 = 2082;
      uint64_t v215 = (uint64_t)v61;
      __int16 v216 = 2082;
      uint64_t v217 = (uint64_t)v62;
      __int16 v218 = 2082;
      v219 = v64;
      __int16 v220 = 2082;
      v221 = v65;
      __int16 v222 = 2082;
      v223 = v66;
      __int16 v224 = 2114;
      id v225 = v67;
      Class v68 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v211 = 0;
      if (__nwlog_fault(v68, type, &v211))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v69 = (id)gconnectionLogObj;
          os_log_type_t v70 = type[0];
          if (os_log_type_enabled(v69, type[0]))
          {
            int v71 = nw_endpoint_handler_get_id_string(v5);
            __int16 v72 = nw_endpoint_handler_dry_run_string(v5);
            logb = v69;
            nw_endpoint_t v73 = nw_endpoint_handler_copy_endpoint(v5);
            v189 = v68;
            BOOL v74 = nw_endpoint_get_logging_description(v73);
            Class v75 = nw_endpoint_handler_state_string(v5);
            char v76 = nw_endpoint_handler_mode_string(v5);
            id v77 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
            __int16 v214 = 2082;
            uint64_t v215 = (uint64_t)v71;
            __int16 v216 = 2082;
            uint64_t v217 = (uint64_t)v72;
            __int16 v218 = 2082;
            v219 = v74;
            __int16 v220 = 2082;
            v221 = v75;
            __int16 v222 = 2082;
            v223 = v76;
            __int16 v224 = 2114;
            id v225 = v77;
            uint64_t v69 = logb;
            _os_log_impl(&dword_1830D4000, logb, v70, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table", buf, 0x48u);

            Class v68 = v189;
          }
        }
        else if (v211)
        {
          int v78 = __nw_create_backtrace_string();
          if (v78)
          {
            __int16 v79 = (char *)v78;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            unsigned int v80 = (id)gconnectionLogObj;
            os_log_type_t v81 = type[0];
            if (os_log_type_enabled(v80, type[0]))
            {
              Class v82 = nw_endpoint_handler_get_id_string(v5);
              uint64_t v83 = nw_endpoint_handler_dry_run_string(v5);
              logc = v80;
              int v84 = v82;
              xpc_object_t v190 = v68;
              nw_endpoint_t v207 = nw_endpoint_handler_copy_endpoint(v5);
              int v85 = nw_endpoint_get_logging_description(v207);
              __int16 v86 = nw_endpoint_handler_state_string(v5);
              unsigned int v87 = nw_endpoint_handler_mode_string(v5);
              id v88 = nw_endpoint_handler_copy_current_path(v5);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
              __int16 v214 = 2082;
              uint64_t v215 = (uint64_t)v84;
              __int16 v216 = 2082;
              uint64_t v217 = (uint64_t)v83;
              __int16 v218 = 2082;
              v219 = v85;
              __int16 v220 = 2082;
              v221 = v86;
              __int16 v222 = 2082;
              v223 = v87;
              __int16 v224 = 2114;
              id v225 = v88;
              __int16 v226 = 2082;
              v227 = v79;
              unsigned int v80 = logc;
              _os_log_impl(&dword_1830D4000, logc, v81, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table, dumping backtrace:%{public}s", buf, 0x52u);

              Class v68 = v190;
            }

            free(v79);
            if (!v68) {
              goto LABEL_105;
            }
            goto LABEL_104;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v69 = (id)gconnectionLogObj;
          os_log_type_t v124 = type[0];
          if (os_log_type_enabled(v69, type[0]))
          {
            BOOL v125 = nw_endpoint_handler_get_id_string(v5);
            uint64_t v126 = nw_endpoint_handler_dry_run_string(v5);
            logg = v69;
            nw_endpoint_t v127 = nw_endpoint_handler_copy_endpoint(v5);
            xpc_object_t v194 = v68;
            uint64_t v128 = nw_endpoint_get_logging_description(v127);
            BOOL v129 = nw_endpoint_handler_state_string(v5);
            Class v130 = nw_endpoint_handler_mode_string(v5);
            id v131 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
            __int16 v214 = 2082;
            uint64_t v215 = (uint64_t)v125;
            __int16 v216 = 2082;
            uint64_t v217 = (uint64_t)v126;
            __int16 v218 = 2082;
            v219 = v128;
            __int16 v220 = 2082;
            v221 = v129;
            __int16 v222 = 2082;
            v223 = v130;
            __int16 v224 = 2114;
            id v225 = v131;
            uint64_t v69 = logg;
            _os_log_impl(&dword_1830D4000, logg, v124, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table, no backtrace", buf, 0x48u);

            Class v68 = v194;
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v69 = (id)gconnectionLogObj;
          os_log_type_t v107 = type[0];
          if (os_log_type_enabled(v69, type[0]))
          {
            unsigned int v108 = nw_endpoint_handler_get_id_string(v5);
            BOOL v109 = nw_endpoint_handler_dry_run_string(v5);
            loge = v69;
            nw_endpoint_t v110 = nw_endpoint_handler_copy_endpoint(v5);
            uint64_t v192 = v68;
            BOOL v111 = nw_endpoint_get_logging_description(v110);
            uint64_t v112 = nw_endpoint_handler_state_string(v5);
            BOOL v113 = nw_endpoint_handler_mode_string(v5);
            id v114 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
            __int16 v214 = 2082;
            uint64_t v215 = (uint64_t)v108;
            __int16 v216 = 2082;
            uint64_t v217 = (uint64_t)v109;
            __int16 v218 = 2082;
            v219 = v111;
            __int16 v220 = 2082;
            v221 = v112;
            __int16 v222 = 2082;
            v223 = v113;
            __int16 v224 = 2114;
            id v225 = v114;
            uint64_t v69 = loge;
            _os_log_impl(&dword_1830D4000, loge, v107, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table, backtrace limit exceeded", buf, 0x48u);

            Class v68 = v192;
          }
        }
      }
      if (v68) {
LABEL_104:
      }
        free(v68);
    }
LABEL_105:
    nw_endpoint_flow_cleanup_protocol(v5, (uint64_t)v6, 1);
    id v132 = v6[23];
    v6[23] = 0;

    free(v6);
LABEL_121:
    uint64_t v6 = 0;
LABEL_122:

    goto LABEL_123;
  }
  v145 = __nwlog_obj();
  os_log_type_enabled(v145, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  __int16 v214 = 2048;
  uint64_t v215 = 1;
  __int16 v216 = 2048;
  uint64_t v217 = 336;
  xpc_object_t v146 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v146);
  if (!result)
  {
    free(v146);
    goto LABEL_2;
  }
  __break(1u);
  return result;
}

void sub_1833422F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_ipv4_network_signature(void *a1, void *a2, unsigned char *a3)
{
  *(void *)&v45[13] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    BOOL v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_interface_get_ipv4_network_signature";
    nw_protocol_metadata_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null interface", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v40)
    {
      id v24 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v37, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v24 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v32 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v31, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_interface_get_ipv4_network_signature";
      __int16 v44 = 2082;
      *(void *)BOOL v45 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v24, v31, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (!a2)
  {
    os_log_type_t v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_interface_get_ipv4_network_signature";
    nw_protocol_metadata_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v24 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null signature", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v40)
    {
      id v24 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v38, "%{public}s called with null signature, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v24 = __nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v34 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v33, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_interface_get_ipv4_network_signature";
      __int16 v44 = 2082;
      *(void *)BOOL v45 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v24, v33, "%{public}s called with null signature, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (!a3)
  {
    char v28 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_interface_get_ipv4_network_signature";
    nw_protocol_metadata_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v24 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null signature_len", buf, 0xCu);
      }
LABEL_74:

      goto LABEL_23;
    }
    if (!v40)
    {
      id v24 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v39, "%{public}s called with null signature_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v24 = __nwlog_obj();
    os_log_type_t v35 = type;
    BOOL v36 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_1830D4000, v24, v35, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_interface_get_ipv4_network_signature";
      __int16 v44 = 2082;
      *(void *)BOOL v45 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v24, v35, "%{public}s called with null signature_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_56:

    free(backtrace_string);
    goto LABEL_23;
  }
  if (*a3 <= 0x13u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    int v8 = *a3;
    *(_DWORD *)buf = 136446466;
    BOOL v43 = "nw_interface_get_ipv4_network_signature";
    __int16 v44 = 1024;
    *(_DWORD *)BOOL v45 = v8;
    nw_protocol_metadata_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (__nwlog_fault(v9, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v12 = *a3;
          *(_DWORD *)buf = 136446466;
          BOOL v43 = "nw_interface_get_ipv4_network_signature";
          __int16 v44 = 1024;
          *(_DWORD *)BOOL v45 = v12;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s signature length %u is less than IFNET_SIGNATURELEN", buf, 0x12u);
        }
      }
      else if (v40)
      {
        uint64_t v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (id)gLogObj;
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v10, type);
        if (v15)
        {
          if (v17)
          {
            int v18 = *a3;
            *(_DWORD *)buf = 136446722;
            BOOL v43 = "nw_interface_get_ipv4_network_signature";
            __int16 v44 = 1024;
            *(_DWORD *)BOOL v45 = v18;
            v45[2] = 2082;
            *(void *)&v45[3] = v15;
            _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v15);
          if (!v9) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
        if (v17)
        {
          int v21 = *a3;
          *(_DWORD *)buf = 136446466;
          BOOL v43 = "nw_interface_get_ipv4_network_signature";
          __int16 v44 = 1024;
          *(_DWORD *)BOOL v45 = v21;
          _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v20 = *a3;
          *(_DWORD *)buf = 136446466;
          BOOL v43 = "nw_interface_get_ipv4_network_signature";
          __int16 v44 = 1024;
          *(_DWORD *)BOOL v45 = v20;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
LABEL_23:
    if (!v9)
    {
LABEL_25:
      uint64_t v14 = 0;
      goto LABEL_26;
    }
LABEL_24:
    free(v9);
    goto LABEL_25;
  }
  size_t v13 = v5[32];
  *a3 = v13;
  memcpy(a2, v5 + 12, v13);
  uint64_t v14 = 1;
LABEL_26:

  return v14;
}

nw_protocol_metadata_t nw_content_context_copy_protocol_metadata(nw_content_context_t context, nw_protocol_definition_t protocol)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  BOOL v4 = protocol;
  if (v3)
  {
    id v5 = 0;
    if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
      && v3 != (nw_content_context_t)&__block_literal_global_8_42267
      && v3 != (nw_content_context_t)&__block_literal_global_6_42258
      && v3 != (nw_content_context_t)&__block_literal_global_42249)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v3[14]);
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      char v28 = __Block_byref_object_copy__42473;
      os_log_type_t v29 = __Block_byref_object_dispose__42474;
      id v30 = 0;
      Class isa = (atomic_uchar *)v3[11].isa;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_content_context_copy_protocol_metadata_block_invoke;
      v22[3] = &unk_1E524A2E8;
      id v7 = v4;
      BOOL v23 = v7;
      id v24 = buf;
      nw_array_apply(isa, (uint64_t)v22);
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
      int v8 = *(void **)(*(void *)&buf[8] + 40);
      if (!v8)
      {
        nw_protocol_metadata_t v9 = nw_content_context_copy_connection(v3);
        uint64_t v10 = v9;
        if (v9)
        {
          nw_protocol_metadata_t v11 = nw_connection_copy_protocol_metadata(v9, v7);
          int v12 = *(void **)(*(void *)&buf[8] + 40);
          *(void *)(*(void *)&buf[8] + 40) = v11;
        }
        int v8 = *(void **)(*(void *)&buf[8] + 40);
      }
      id v5 = v8;

      _Block_object_dispose(buf, 8);
    }
    goto LABEL_11;
  }
  uint64_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_content_context_copy_protocol_metadata";
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v15, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_content_context_copy_protocol_metadata";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_28:
  if (v15) {
    free(v15);
  }
  id v5 = 0;
LABEL_11:

  return v5;
}

void sub_1833431D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{
  _Block_object_dispose(&a21, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_content_context_copy_connection(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = 0;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_10_42276
      && v1 != (os_unfair_lock_s *)&__block_literal_global_8_42267
      && v1 != (os_unfair_lock_s *)&__block_literal_global_6_42258
      && v1 != (os_unfair_lock_s *)&__block_literal_global_42249)
    {
      os_unfair_lock_lock(v1 + 28);
      if ((v2[29]._os_unfair_lock_opaque & 0x100000) != 0
        && (uint64_t v4 = *(void *)&v2[26]._os_unfair_lock_opaque) != 0
        && *(void *)(v4 + 24) != *(void *)(v4 + 16))
      {
        uint64_t v3 = nw_array_get_object_at_index(v4, 0);
      }
      else
      {
        uint64_t v3 = 0;
      }
      os_unfair_lock_unlock(v2 + 28);
    }
    goto LABEL_12;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_content_context_copy_connection";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_content_context_copy_connection";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_content_context_copy_connection";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_content_context_copy_connection";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_content_context_copy_connection";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_29:
  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0;
LABEL_12:

  return v3;
}

void nw_protocol_stack_replace_protocol(void *a1, void *a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (!v5)
  {
    char v25 = v7;
    os_log_type_t v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v59 = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (!__nwlog_fault(v27, &v59, &v58)) {
      goto LABEL_71;
    }
    if (v59 == OS_LOG_TYPE_FAULT)
    {
      char v28 = __nwlog_obj();
      os_log_type_t v29 = v59;
      if (os_log_type_enabled(v28, v59))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v58)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v28 = __nwlog_obj();
      os_log_type_t v37 = v59;
      BOOL v38 = os_log_type_enabled(v28, v59);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v28, v37, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_71:
        if (!v27) {
          goto LABEL_28;
        }
        goto LABEL_80;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v28, v37, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v28 = __nwlog_obj();
      os_log_type_t v44 = v59;
      if (os_log_type_enabled(v28, v59))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v28, v44, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_71;
  }
  if (!v6)
  {
    id v30 = v7;
    uint64_t v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v59 = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (!__nwlog_fault(v27, &v59, &v58)) {
      goto LABEL_79;
    }
    if (v59 == OS_LOG_TYPE_FAULT)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = v59;
      if (os_log_type_enabled(v32, v59))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null old_protocol", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (!v58)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v45 = v59;
      if (os_log_type_enabled(v32, v59))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v32, v45, "%{public}s called with null old_protocol, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    os_log_type_t v39 = (char *)__nw_create_backtrace_string();
    BOOL v32 = __nwlog_obj();
    os_log_type_t v40 = v59;
    BOOL v41 = os_log_type_enabled(v32, v59);
    if (!v39)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null old_protocol, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v39;
      _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null old_protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_58;
  }
  if (!v7)
  {
    id v30 = 0;
    BOOL v34 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v59 = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (!__nwlog_fault(v27, &v59, &v58)) {
      goto LABEL_79;
    }
    if (v59 == OS_LOG_TYPE_FAULT)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v35 = v59;
      if (os_log_type_enabled(v32, v59))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v32, v35, "%{public}s called with null new_options", buf, 0xCu);
      }
LABEL_78:

LABEL_79:
      char v25 = v30;
      if (!v27) {
        goto LABEL_28;
      }
LABEL_80:
      free(v27);
      goto LABEL_28;
    }
    if (!v58)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v46 = v59;
      if (os_log_type_enabled(v32, v59))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v32, v46, "%{public}s called with null new_options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    os_log_type_t v39 = (char *)__nw_create_backtrace_string();
    BOOL v32 = __nwlog_obj();
    os_log_type_t v42 = v59;
    BOOL v43 = os_log_type_enabled(v32, v59);
    if (!v39)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_1830D4000, v32, v42, "%{public}s called with null new_options, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v39;
      _os_log_impl(&dword_1830D4000, v32, v42, "%{public}s called with null new_options, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_58:

    free(v39);
    goto LABEL_79;
  }
  id v47 = v7;
  int v8 = (id *)v7;
  id v9 = v8[1];

  id v10 = v5[1];
  if (v10)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v61 = __Block_byref_object_copy__19403;
    int v62 = __Block_byref_object_dispose__19404;
    id v63 = v10;
    os_log_type_t v11 = (atomic_uchar *)v5[1];
    v53[0] = MEMORY[0x1E4F143A8];
    v53[1] = 3221225472;
    v53[2] = __nw_protocol_stack_replace_protocol_block_invoke;
    v53[3] = &unk_1E523D1B0;
    v53[4] = v9;
    id v54 = v6;
    int v57 = buf;
    uint64_t v55 = v5;
    int v56 = v8;
    nw_array_apply(v11, (uint64_t)v53);
    BOOL v12 = *(void **)(*(void *)&buf[8] + 40);
    if (v12) {
      objc_storeStrong(v5 + 1, v12);
    }

    _Block_object_dispose(buf, 8);
  }
  id v13 = v5[2];
  if (v13)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v61 = __Block_byref_object_copy__19403;
    int v62 = __Block_byref_object_dispose__19404;
    id v63 = v13;
    char v14 = (atomic_uchar *)v5[2];
    v48[0] = MEMORY[0x1E4F143A8];
    v48[1] = 3221225472;
    void v48[2] = __nw_protocol_stack_replace_protocol_block_invoke_3;
    v48[3] = &unk_1E523D1B0;
    v48[4] = v9;
    id v49 = v6;
    unsigned int v52 = buf;
    int v50 = v5;
    __int16 v51 = v8;
    nw_array_apply(v14, (uint64_t)v48);
    uint64_t v15 = *(void **)(*(void *)&buf[8] + 40);
    if (v15) {
      objc_storeStrong(v5 + 2, v15);
    }

    _Block_object_dispose(buf, 8);
  }
  id v16 = v5[3];
  if (v16)
  {
    os_log_type_t v17 = (id *)v16;
    id v18 = v17[1];

    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v9, (uint64_t)v18)
      || nw_protocol_definition_is_equal_unsafe((uint64_t)v6, (uint64_t)v18))
    {
      objc_storeStrong(v5 + 3, a3);
    }
  }
  id v19 = v5[4];
  if (v19)
  {
    uint64_t v20 = (id *)v19;
    id v21 = v20[1];

    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v9, (uint64_t)v21)
      || nw_protocol_definition_is_equal_unsafe((uint64_t)v6, (uint64_t)v21))
    {
      objc_storeStrong(v5 + 4, a3);
    }
  }
  id v22 = v5[6];
  if (v22)
  {
    BOOL v23 = (id *)v22;
    id v24 = v23[1];

    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v9, (uint64_t)v24)
      || nw_protocol_definition_is_equal_unsafe((uint64_t)v6, (uint64_t)v24))
    {
      objc_storeStrong(v5 + 6, a3);
    }
  }
  char v25 = v47;
LABEL_28:
}

void sub_183343EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_parameters_set_protocol_instance(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = v4;
  if (v4)
  {
    id v6 = v4;
    v6[2] = a3;

    goto LABEL_3;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v18 = "nw_parameters_set_protocol_instance";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_parameters_set_protocol_instance";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null protocol_parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v18 = "nw_parameters_set_protocol_instance";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_parameters_set_protocol_instance";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_parameters_set_protocol_instance";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
LABEL_3:
}

nw_endpoint_t nw_endpoint_create_with_sock_name(int a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a1 < 0)
  {
    id v24 = __nwlog_obj();
    *(_DWORD *)&address[0].sa_len = 136446210;
    *(void *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
    id v5 = (void *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v30) = 0;
    if (!__nwlog_fault((const char *)v5, buf, &v30))
    {
LABEL_40:
      if (v5) {
        free(v5);
      }
      return 0;
    }
    if (buf[0] == 17)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v25 = buf[0];
      if (!os_log_type_enabled(v6, (os_log_type_t)buf[0])) {
        goto LABEL_39;
      }
      *(_DWORD *)&address[0].sa_len = 136446210;
      *(void *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
      int v8 = "%{public}s called with null (sockfd >= 0)";
    }
    else if ((_BYTE)v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v25 = buf[0];
      BOOL v27 = os_log_type_enabled(v6, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)&address[0].sa_len = 136446466;
          *(void *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
          *(_WORD *)&address[0].sa_data[10] = 2082;
          *(void *)&address[0].sa_data[12] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v25, "%{public}s called with null (sockfd >= 0), dumping backtrace:%{public}s", &address[0].sa_len, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_40;
      }
      if (!v27) {
        goto LABEL_39;
      }
      *(_DWORD *)&address[0].sa_len = 136446210;
      *(void *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
      int v8 = "%{public}s called with null (sockfd >= 0), no backtrace";
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v25 = buf[0];
      if (!os_log_type_enabled(v6, (os_log_type_t)buf[0])) {
        goto LABEL_39;
      }
      *(_DWORD *)&address[0].sa_len = 136446210;
      *(void *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
      int v8 = "%{public}s called with null (sockfd >= 0), backtrace limit exceeded";
    }
    uint64_t v20 = address;
    uint64_t v21 = v6;
    os_log_type_t v22 = v25;
    uint32_t v23 = 12;
    goto LABEL_38;
  }
  memset(address, 0, sizeof(address));
  socklen_t v30 = 128;
  if (!getsockname(a1, address, &v30))
  {
    if (v30 && v30 >= address[0].sa_len) {
      return nw_endpoint_create_address(address);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    BOOL v32 = "nw_endpoint_create_with_sock_name";
    __int16 v33 = 1024;
    socklen_t v34 = v30;
    __int16 v35 = 1024;
    LODWORD(v36[0]) = address[0].sa_len;
    id v5 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault((const char *)v5, &type, &v28)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v32 = "nw_endpoint_create_with_sock_name";
      __int16 v33 = 1024;
      socklen_t v34 = v30;
      __int16 v35 = 1024;
      LODWORD(v36[0]) = address[0].sa_len;
      int v8 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u";
    }
    else
    {
      if (v28)
      {
        os_log_type_t v11 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v6, type);
        if (v11)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446978;
            BOOL v32 = "nw_endpoint_create_with_sock_name";
            __int16 v33 = 1024;
            socklen_t v34 = v30;
            __int16 v35 = 1024;
            LODWORD(v36[0]) = address[0].sa_len;
            WORD2(v36[0]) = 2082;
            *(void *)((char *)v36 + 6) = v11;
            os_log_type_t v14 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u, dumping backtrace:%{public}s";
            char v15 = v6;
            os_log_type_t v16 = v12;
            uint32_t v17 = 34;
LABEL_28:
            _os_log_impl(&dword_1830D4000, v15, v16, v14, buf, v17);
          }
LABEL_29:

          free(v11);
          goto LABEL_40;
        }
        if (!v13) {
          goto LABEL_39;
        }
        *(_DWORD *)buf = 136446722;
        BOOL v32 = "nw_endpoint_create_with_sock_name";
        __int16 v33 = 1024;
        socklen_t v34 = v30;
        __int16 v35 = 1024;
        LODWORD(v36[0]) = address[0].sa_len;
        int v8 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u, no backtrace";
        uint64_t v20 = (sockaddr *)buf;
        uint64_t v21 = v6;
        os_log_type_t v22 = v12;
LABEL_33:
        uint32_t v23 = 24;
LABEL_38:
        _os_log_impl(&dword_1830D4000, v21, v22, v8, &v20->sa_len, v23);
        goto LABEL_39;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v32 = "nw_endpoint_create_with_sock_name";
      __int16 v33 = 1024;
      socklen_t v34 = v30;
      __int16 v35 = 1024;
      LODWORD(v36[0]) = address[0].sa_len;
      int v8 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u, backtrace limit exceeded";
    }
    uint64_t v20 = (sockaddr *)buf;
    uint64_t v21 = v6;
    os_log_type_t v22 = v7;
    goto LABEL_33;
  }
  socklen_t v1 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v1 != 22 && v1 != 57 && v1 != 102)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    BOOL v32 = "nw_endpoint_create_with_sock_name";
    __int16 v33 = 1024;
    socklen_t v34 = v1;
    id v5 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if ((__nwlog_fault((const char *)v5, &type, &v28) & 1) == 0) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        BOOL v32 = "nw_endpoint_create_with_sock_name";
        __int16 v33 = 1024;
        socklen_t v34 = v1;
        int v8 = "%{public}s getsockname failed %{darwin.errno}d";
LABEL_36:
        uint64_t v20 = (sockaddr *)buf;
        uint64_t v21 = v6;
        os_log_type_t v22 = v10;
LABEL_37:
        uint32_t v23 = 18;
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        BOOL v32 = "nw_endpoint_create_with_sock_name";
        __int16 v33 = 1024;
        socklen_t v34 = v1;
        int v8 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_36;
      }
LABEL_39:

      goto LABEL_40;
    }
    os_log_type_t v11 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v19) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v32 = "nw_endpoint_create_with_sock_name";
      __int16 v33 = 1024;
      socklen_t v34 = v1;
      int v8 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
      uint64_t v20 = (sockaddr *)buf;
      uint64_t v21 = v6;
      os_log_type_t v22 = v18;
      goto LABEL_37;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446722;
      BOOL v32 = "nw_endpoint_create_with_sock_name";
      __int16 v33 = 1024;
      socklen_t v34 = v1;
      __int16 v35 = 2082;
      v36[0] = v11;
      os_log_type_t v14 = "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s";
      char v15 = v6;
      os_log_type_t v16 = v18;
      uint32_t v17 = 28;
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    BOOL v32 = "nw_endpoint_create_with_sock_name";
    __int16 v33 = 1024;
    socklen_t v34 = v1;
    _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s getsockname failed %{darwin.errno}d", buf, 0x12u);
  }

  return 0;
}

unint64_t nw_http_get_indeterminate_binary_message_chunk_length(unint64_t result, int a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    unint64_t v5 = result;
    if (result >= 0x40)
    {
      if (result >= 0x4000)
      {
        if (result >> 30)
        {
          if (result >> 62)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
            *(_DWORD *)os_log_type_t v12 = 136446466;
            *(void *)&v12[4] = "_http_vle_length";
            *(_WORD *)&v12[12] = 2048;
            *(void *)&v12[14] = v5;
            os_log_type_t v7 = (void *)_os_log_send_and_compose_impl();
            BOOL result = __nwlog_abort((uint64_t)v7);
            if (result)
            {
              __break(1u);
              return result;
            }
            free(v7);
            uint64_t v6 = 0;
          }
          else
          {
            uint64_t v6 = 8;
          }
        }
        else
        {
          uint64_t v6 = 4;
        }
      }
      else
      {
        uint64_t v6 = 2;
      }
    }
    else
    {
      uint64_t v6 = 1;
    }
    BOOL result = v6 + v5;
  }
  if (a2)
  {
    unint64_t v8 = result + 1;
    if (a3)
    {
      *(void *)os_log_type_t v12 = 0;
      *(void *)&v12[8] = v12;
      *(void *)&v12[16] = 0x2000000000;
      uint64_t v13 = 0;
      v11[0] = MEMORY[0x1E4F143A8];
      v11[1] = 0x40000000;
      v11[2] = __nw_http_get_indeterminate_binary_message_chunk_length_block_invoke;
      v11[3] = &unk_1E5242CB0;
      v11[4] = v12;
      id v9 = a3;
      os_log_type_t v10 = v11;
      _nw_http_fields_enumerate((uint64_t)v9, v10);

      v8 += *(void *)(*(void *)&v12[8] + 24);
      _Block_object_dispose(v12, 8);
    }
    return v8 + 1;
  }
  return result;
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_16(uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!__s)
  {
    size_t v5 = 0;
    goto LABEL_6;
  }
  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1;
    goto LABEL_7;
  }
  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2;
    goto LABEL_7;
  }
  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4;
    goto LABEL_7;
  }
  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000);
    size_t v6 = 8;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    os_log_type_t v7 = (void *)(a1 + 32);
    id v9 = *(char **)(*(void *)(v8 + 8) + 24);
    os_log_type_t v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            uint64_t v38 = __nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "_http_safe_append";
              __int16 v52 = 2082;
              BOOL v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v11 + 24) = 0;
        }
        uint64_t v13 = &v9[v6];
        goto LABEL_13;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      uint32_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          os_log_type_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (!v48)
      {
        id v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          os_log_type_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          os_log_type_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = backtrace_string;
        os_log_type_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      uint32_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          os_log_type_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
        }
LABEL_112:
        if (v23) {
          free(v23);
        }
        uint64_t v13 = 0;
        goto LABEL_13;
      }
      if (!v48)
      {
        id v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          os_log_type_t v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          os_log_type_t v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = backtrace_string;
        os_log_type_t v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_1830D4000, v24, v25, v37, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_112;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  __int16 v51 = "_http_vle_encode";
  __int16 v52 = 2048;
  BOOL v53 = (const char *)v5;
  uint32_t v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }
  free(v17);
  uint64_t v18 = *(void *)(a1 + 32);
  os_log_type_t v7 = (void *)(a1 + 32);
  uint64_t v13 = *(char **)(*(void *)(v18 + 8) + 24);
  os_log_type_t v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8) + 24) = v13;
  uint64_t v14 = *(char **)(*(void *)(*v7 + 8) + 24);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v19, &type, &v48)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      os_log_type_t v22 = "%{public}s called with null cursor";
    }
    else
    {
      if (!v48)
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        os_log_type_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }
      uint64_t v31 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          __int16 v52 = 2082;
          BOOL v53 = v31;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }
      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      os_log_type_t v22 = "%{public}s called with null cursor, no backtrace";
    }
LABEL_100:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }
  if (v5)
  {
    if (__s)
    {
      uint64_t v15 = *(void *)(*v10 + 8);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        unint64_t v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = __nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v45 = *(void *)(v15 + 24);
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "_http_safe_append";
              __int16 v52 = 2082;
              BOOL v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v5;
              __int16 v56 = 2048;
              uint64_t v57 = v45;
              _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v15 + 24) = 0;
        }
        v14 += v5;
        goto LABEL_21;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      BOOL v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        char v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          socklen_t v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        char v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          socklen_t v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      BOOL v41 = (char *)__nw_create_backtrace_string();
      char v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          socklen_t v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = v41;
        BOOL v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      BOOL v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        char v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          socklen_t v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
        }
LABEL_120:
        if (v27) {
          free(v27);
        }
        uint64_t v14 = 0;
        goto LABEL_21;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        char v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          socklen_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      BOOL v41 = (char *)__nw_create_backtrace_string();
      char v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          socklen_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = v41;
        BOOL v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_1830D4000, v28, v29, v43, buf, 0x16u);
      }
    }
    free(v41);
    goto LABEL_120;
  }
LABEL_21:
  *(void *)(*(void *)(*v7 + 8) + 24) = v14;
  if (*(void *)(*(void *)(*v7 + 8) + 24)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  BOOL v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      os_log_type_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      os_log_type_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }
    __int16 v33 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = __src;
    BOOL v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      os_log_type_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      __int16 v52 = 2082;
      BOOL v53 = v33;
      _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v33);
  }
LABEL_101:
  if (v19) {
LABEL_102:
  }
    free(v19);
}

void nw_content_context_foreach_protocol_metadata(nw_content_context_t context, void *foreach_block)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  size_t v4 = foreach_block;
  size_t v5 = v4;
  if (!v3)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v8) {
          goto LABEL_8;
        }
LABEL_43:
        free(v8);
        goto LABEL_8;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v9 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (v4)
  {
    if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
      && v3 != (nw_content_context_t)&__block_literal_global_8_42267
      && v3 != (nw_content_context_t)&__block_literal_global_6_42258
      && v3 != (nw_content_context_t)&__block_literal_global_42249)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v3[14]);
      size_t v6 = v3[11].isa;
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_content_context_foreach_protocol_metadata_block_invoke;
      v21[3] = &unk_1E524AE90;
      id v22 = v5;
      nw_array_apply(v6, (uint64_t)v21);
    }
    goto LABEL_8;
  }
  uint64_t v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v9 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null foreach_block", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v23)
  {
    id v9 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null foreach_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  unint64_t v16 = (char *)__nw_create_backtrace_string();
  id v9 = __nwlog_obj();
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null foreach_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v26 = "nw_content_context_foreach_protocol_metadata";
    __int16 v27 = 2082;
    char v28 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null foreach_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_43;
  }
LABEL_8:
}

void ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_40(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (nw_protocol_plugin_retry_end_async(*(void *)(a1 + 40) + 344))
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v2();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if ((*(unsigned char *)(v3 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        size_t v4 = __nwlog_obj();
        BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
        uint64_t v3 = *(void *)(a1 + 40);
        if (v5)
        {
          int v6 = 136446722;
          os_log_type_t v7 = "nw_http_authentication_handle_challenge_block_invoke";
          __int16 v8 = 2082;
          uint64_t v9 = v3 + 114;
          __int16 v10 = 2080;
          uint64_t v11 = " ";
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalling destroy because defer_destroy was true", (uint8_t *)&v6, 0x20u);
          uint64_t v3 = *(void *)(a1 + 40);
        }
      }
    }
    nw_http_authentication_destroy(v3);
  }
}

uint64_t nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = report;
  size_t v4 = v3;
  if (!v3)
  {
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v31)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_1830D4000, v19, v29, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_1830D4000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
      __int16 v35 = 2082;
      BOOL v36 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v19, v25, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_44;
  }
  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    os_log_type_t v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

    goto LABEL_59;
  }
  if (path_index == -1)
  {
    uint64_t isa = (uint64_t)v4[16].isa;
    uint64_t isa_high = HIDWORD(v4[5].isa);
    if (isa_high < 2) {
      goto LABEL_14;
    }
    if (isa_high == 2)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = isa_high - 1;
      Class v13 = v4[52].isa;
      unint64_t v14 = (isa_high - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        isa += *((void *)v13 + 9);
        v11 += *((void *)v13 + 54);
        Class v13 = (Class)((char *)v13 + 720);
        v14 -= 2;
      }
      while (v14);
      isa += v11;
      if (v12 == ((isa_high - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }
    uint64_t v15 = isa_high - v9;
    unint64_t v16 = (void *)((char *)v4[52].isa + 360 * v9 - 288);
    do
    {
      isa += *v16;
      v16 += 45;
      --v15;
    }
    while (v15);
    goto LABEL_14;
  }
  if (HIDWORD(v4[5].isa) <= path_index)
  {
    id v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_1830D4000, v19, v23, "%{public}s called with null (path_index < report->path_count)", buf, 0xCu);
      }
LABEL_56:

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      uint64_t isa = 0;
      goto LABEL_14;
    }
    if (!v31)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_1830D4000, v19, v30, "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_1830D4000, v19, v27, "%{public}s called with null (path_index < report->path_count), no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
      __int16 v35 = 2082;
      BOOL v36 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v19, v27, "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_44:

    free(backtrace_string);
    goto LABEL_57;
  }
  BOOL v5 = v4;
  if (HIDWORD(v4[5].isa) <= path_index)
  {
    uint64_t v6 = 0;
  }
  else if (path_index)
  {
    uint64_t v6 = (uint64_t)v5[52].isa + 360 * path_index - 360;
  }
  else
  {
    uint64_t v6 = (uint64_t)&v5[7];
  }

  uint64_t isa = *(void *)(v6 + 72);
LABEL_14:

  return isa;
}

void sub_18334670C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_request_outbound_data(void *a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  os_log_type_t v7 = a1;
  id v8 = a4;
  uint64_t v9 = v8;
  if (!v7)
  {
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_request_outbound_data";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v41 = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v18, &v41, &v40)) {
      goto LABEL_61;
    }
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v26 = v41;
      BOOL v27 = os_log_type_enabled(v19, v41);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v43 = "nw_protocol_request_outbound_data";
          __int16 v44 = 2082;
          uint64_t v45 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v26, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v18)
        {
LABEL_10:
          uint64_t v10 = 0;
          goto LABEL_11;
        }
LABEL_62:
        free(v18);
        goto LABEL_10;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v26, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v33 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v33, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_60:

    goto LABEL_61;
  }
  if (!a3)
  {
    os_log_type_t v21 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_request_outbound_data";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v41 = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v18, &v41, &v40)) {
      goto LABEL_61;
    }
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v22 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s called with null data_size", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (!v40)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v34 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v34, "%{public}s called with null data_size, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_60;
    }
    BOOL v28 = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v29 = v41;
    BOOL v30 = os_log_type_enabled(v19, v41);
    if (!v28)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v29, "%{public}s called with null data_size, no backtrace", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_protocol_request_outbound_data";
      __int16 v44 = 2082;
      uint64_t v45 = v28;
      _os_log_impl(&dword_1830D4000, v19, v29, "%{public}s called with null data_size, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_41;
  }
  if (!v8)
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_request_outbound_data";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v41 = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v18, &v41, &v40)) {
      goto LABEL_61;
    }
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v24 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s called with null available_outbound_data", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (!v40)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v35 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v35, "%{public}s called with null available_outbound_data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_60;
    }
    BOOL v28 = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v31 = v41;
    BOOL v32 = os_log_type_enabled(v19, v41);
    if (!v28)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_1830D4000, v19, v31, "%{public}s called with null available_outbound_data, no backtrace", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_protocol_request_outbound_data";
      __int16 v44 = 2082;
      uint64_t v45 = v28;
      _os_log_impl(&dword_1830D4000, v19, v31, "%{public}s called with null available_outbound_data, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_41:

    free(v28);
    if (!v18) {
      goto LABEL_10;
    }
    goto LABEL_62;
  }
  if (!nw_protocol_service_outbound_requests(v7)
    || (nw_protocol_service_requested_outbound_data(v7, a2, a3, v9) & 1) == 0)
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_request_outbound_data_block_invoke;
    aBlock[3] = &unk_1E523BDB0;
    id v37 = v9;
    unint64_t v38 = a2;
    uint64_t v39 = a3;
    uint64_t v11 = _Block_copy(aBlock);
    uint64_t tqh_first = (uint64_t)v7->pending_outbound_frames.tqh_first;
    if (!tqh_first)
    {
      BOOL v13 = nw_array_create();
      unint64_t v14 = v7->pending_outbound_frames.tqh_first;
      v7->pending_outbound_frames.uint64_t tqh_first = (nw_frame *)v13;

      uint64_t tqh_first = (uint64_t)v7->pending_outbound_frames.tqh_first;
    }
    uint64_t v15 = _Block_copy(v11);
    nw_array_append(tqh_first, v15);

    goto LABEL_10;
  }
  uint64_t v10 = 1;
LABEL_11:

  return v10;
}

void sub_183346EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_service_requested_outbound_data(void *a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  os_log_type_t v7 = a1;
  unint64_t v78 = a2;
  id v8 = a4;
  uint64_t v9 = (void (**)(void, void))v8;
  if (!v7)
  {
    BOOL v36 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
    id v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (!__nwlog_fault(v37, type, &v81)) {
      goto LABEL_127;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v38 = __nwlog_obj();
      os_log_type_t v39 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_126;
    }
    if (!(_BYTE)v81)
    {
      unint64_t v38 = __nwlog_obj();
      os_log_type_t v57 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v57, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_126;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v38 = __nwlog_obj();
    os_log_type_t v45 = type[0];
    BOOL v46 = os_log_type_enabled(v38, type[0]);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v45, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_126;
    }
    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
      __int16 v86 = 2082;
      unsigned int v87 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v38, v45, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_87;
  }
  if (!a3)
  {
    char v40 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
    id v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (!__nwlog_fault(v37, type, &v81)) {
      goto LABEL_127;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v38 = __nwlog_obj();
      os_log_type_t v41 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v41, "%{public}s called with null data_size", buf, 0xCu);
      }
      goto LABEL_126;
    }
    if (!(_BYTE)v81)
    {
      unint64_t v38 = __nwlog_obj();
      os_log_type_t v58 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v58, "%{public}s called with null data_size, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_126;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v38 = __nwlog_obj();
    os_log_type_t v47 = type[0];
    BOOL v48 = os_log_type_enabled(v38, type[0]);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v47, "%{public}s called with null data_size, no backtrace", buf, 0xCu);
      }
      goto LABEL_126;
    }
    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
      __int16 v86 = 2082;
      unsigned int v87 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v38, v47, "%{public}s called with null data_size, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_87;
  }
  if (!v8)
  {
    BOOL v42 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
    id v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (!__nwlog_fault(v37, type, &v81)) {
      goto LABEL_127;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v38 = __nwlog_obj();
      os_log_type_t v43 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v43, "%{public}s called with null available_outbound_data", buf, 0xCu);
      }
LABEL_126:

LABEL_127:
      if (v37) {
        free(v37);
      }
      goto LABEL_28;
    }
    if (!(_BYTE)v81)
    {
      unint64_t v38 = __nwlog_obj();
      os_log_type_t v63 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v63, "%{public}s called with null available_outbound_data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_126;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v38 = __nwlog_obj();
    os_log_type_t v49 = type[0];
    BOOL v50 = os_log_type_enabled(v38, type[0]);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_1830D4000, v38, v49, "%{public}s called with null available_outbound_data, no backtrace", buf, 0xCu);
      }
      goto LABEL_126;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
      __int16 v86 = 2082;
      unsigned int v87 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v38, v49, "%{public}s called with null available_outbound_data, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_87:

    free(backtrace_string);
    goto LABEL_127;
  }
  if (!*((void *)v7 + 37))
  {
    if ((v7[403] & 4) != 0)
    {
      uint64_t v21 = 0;
      v7[403] |= 8u;
LABEL_160:
      v7[405] |= 2u;
      goto LABEL_161;
    }
    v77[0] = 0;
    v77[1] = v77;
    os_log_type_t v17 = (const char *)*((void *)v7 - 8);
    if (v17)
    {
      BOOL v18 = (void *)*((void *)v17 + 5);
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v24 = *((void *)v17 + 11);
        if (v24) {
          *((void *)v17 + 11) = v24 + 1;
        }
        char v19 = -1;
      }
      else
      {
        char v19 = 0;
      }
      *(void *)os_log_type_t type = v17;
      char v84 = v19;
      os_log_type_t v25 = (void *)*((void *)v7 - 7);
      if (v25 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v27 = *((void *)v7 - 1);
        if (v27) {
          *((void *)v7 - 1) = v27 + 1;
        }
        char v26 = -1;
      }
      else
      {
        char v26 = 0;
      }
      os_log_type_t v81 = v7 - 96;
      LOBYTE(v82) = v26;
      uint64_t v28 = *((void *)v17 + 3);
      if (v28)
      {
        os_log_type_t v29 = *(uint64_t (**)(const char *, unsigned char *, uint64_t, uint64_t, uint64_t, id *))(v28 + 88);
        if (v29)
        {
          int v30 = v29(v17, v7 - 96, a3, a3, 1, v77);
          if (v25 != &nw_protocol_ref_counted_handle) {
            goto LABEL_40;
          }
          goto LABEL_147;
        }
      }
      __int16 v51 = __nwlog_obj();
      __int16 v52 = (const char *)*((void *)v17 + 2);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
      if (!v52) {
        __int16 v52 = "invalid";
      }
      __int16 v86 = 2082;
      unsigned int v87 = (char *)v52;
      __int16 v88 = 2048;
      id v89 = v17;
      BOOL v53 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v80 = OS_LOG_TYPE_ERROR;
      char v79 = 0;
      if (__nwlog_fault(v53, &v80, &v79))
      {
        if (v80 == OS_LOG_TYPE_FAULT)
        {
          __int16 v54 = __nwlog_obj();
          os_log_type_t v55 = v80;
          if (os_log_type_enabled(v54, v80))
          {
            __int16 v56 = (const char *)*((void *)v17 + 2);
            if (!v56) {
              __int16 v56 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
            __int16 v86 = 2082;
            unsigned int v87 = (char *)v56;
            __int16 v88 = 2048;
            id v89 = v17;
            _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback", buf, 0x20u);
          }
LABEL_143:

          goto LABEL_144;
        }
        if (!v79)
        {
          __int16 v54 = __nwlog_obj();
          os_log_type_t v71 = v80;
          if (os_log_type_enabled(v54, v80))
          {
            __int16 v72 = (const char *)*((void *)v17 + 2);
            if (!v72) {
              __int16 v72 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
            __int16 v86 = 2082;
            unsigned int v87 = (char *)v72;
            __int16 v88 = 2048;
            id v89 = v17;
            _os_log_impl(&dword_1830D4000, v54, v71, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded", buf, 0x20u);
          }
          goto LABEL_143;
        }
        uint64_t v64 = (char *)__nw_create_backtrace_string();
        __int16 v54 = __nwlog_obj();
        os_log_type_t v65 = v80;
        BOOL v66 = os_log_type_enabled(v54, v80);
        if (!v64)
        {
          if (v66)
          {
            nw_endpoint_t v73 = (const char *)*((void *)v17 + 2);
            if (!v73) {
              nw_endpoint_t v73 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
            __int16 v86 = 2082;
            unsigned int v87 = (char *)v73;
            __int16 v88 = 2048;
            id v89 = v17;
            _os_log_impl(&dword_1830D4000, v54, v65, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace", buf, 0x20u);
          }
          goto LABEL_143;
        }
        if (v66)
        {
          id v67 = (const char *)*((void *)v17 + 2);
          if (!v67) {
            id v67 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
          __int16 v86 = 2082;
          unsigned int v87 = (char *)v67;
          __int16 v88 = 2048;
          id v89 = v17;
          __int16 v90 = 2082;
          unint64_t v91 = (unint64_t)v64;
          _os_log_impl(&dword_1830D4000, v54, v65, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v64);
      }
LABEL_144:
      if (v53) {
        free(v53);
      }
      int v30 = 0;
      if (v25 != &nw_protocol_ref_counted_handle)
      {
LABEL_40:
        if (v18 != &nw_protocol_ref_counted_handle) {
          goto LABEL_41;
        }
        goto LABEL_148;
      }
LABEL_147:
      nw::release_if_needed<nw_protocol *>((uint64_t *)&v81);
      if (v18 != &nw_protocol_ref_counted_handle)
      {
LABEL_41:
        if (!v30) {
          goto LABEL_159;
        }
        goto LABEL_149;
      }
LABEL_148:
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (!v30)
      {
LABEL_159:
        uint64_t v21 = 0;
        goto LABEL_160;
      }
LABEL_149:
      id v74 = v77[0];
      ((void (**)(void, id))v9)[2](v9, v74);

      goto LABEL_150;
    }
    os_log_type_t v59 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
    id v60 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (__nwlog_fault(v60, type, &v81))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v61 = __nwlog_obj();
        os_log_type_t v62 = type[0];
        if (os_log_type_enabled(v61, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
          _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if ((_BYTE)v81)
      {
        Class v68 = (char *)__nw_create_backtrace_string();
        uint64_t v61 = __nwlog_obj();
        os_log_type_t v69 = type[0];
        BOOL v70 = os_log_type_enabled(v61, type[0]);
        if (v68)
        {
          if (v70)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
            __int16 v86 = 2082;
            unsigned int v87 = v68;
            _os_log_impl(&dword_1830D4000, v61, v69, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v68);
          goto LABEL_157;
        }
        if (v70)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
          _os_log_impl(&dword_1830D4000, v61, v69, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v61 = __nwlog_obj();
        os_log_type_t v75 = type[0];
        if (os_log_type_enabled(v61, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
          _os_log_impl(&dword_1830D4000, v61, v75, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_157:
    if (v60) {
      free(v60);
    }
    goto LABEL_159;
  }
  uint64_t v10 = nw_protocol_implementation_lookup_path((NWConcrete_nw_protocol_instance *)v7, a2, &v78);
  if (!v10)
  {
    if (((char)v7[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v20 = (id)gLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        __int16 v86 = 2082;
        unsigned int v87 = v7 + 407;
        __int16 v88 = 2080;
        id v89 = " ";
        __int16 v90 = 2048;
        unint64_t v91 = v78;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo path found for %lx", buf, 0x2Au);
      }
    }
    v9[2](v9, 0);
    goto LABEL_150;
  }
  uint64_t v11 = v10;
  if ((*(unsigned char *)(v10 + 137) & 2) == 0)
  {
    os_log_type_t v81 = 0;
    Class v82 = (id *)&v81;
    uint64_t v12 = *(void **)(v10 + 32);
    if (v12)
    {
      uint64_t v13 = v12[3];
      if (v13)
      {
        unint64_t v14 = *(uint64_t (**)(void))(v13 + 88);
        if (v14)
        {
          uint64_t v15 = (void *)v12[5];
          if (v15 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v31 = v12[11];
            if (v31) {
              v12[11] = v31 + 1;
            }
            char v16 = -1;
          }
          else
          {
            char v16 = 0;
          }
          *(void *)buf = v12;
          buf[8] = v16;
          BOOL v32 = (void *)*((void *)v7 - 7);
          if (v32 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v34 = *((void *)v7 - 1);
            if (v34) {
              *((void *)v7 - 1) = v34 + 1;
            }
            char v33 = -1;
          }
          else
          {
            char v33 = 0;
          }
          *(void *)os_log_type_t type = v7 - 96;
          char v84 = v33;
          uint64_t v21 = v14();
          if (v32 == &nw_protocol_ref_counted_handle)
          {
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            if (v15 != &nw_protocol_ref_counted_handle)
            {
LABEL_53:
              if (v21)
              {
LABEL_54:
                os_log_type_t v35 = v81;
                *(void *)(v11 + 56) = nw_frame_get_finalizer_context((uint64_t)v35);
                ((void (**)(void, char *))v9)[2](v9, v35);

LABEL_150:
                uint64_t v21 = 1;
                goto LABEL_161;
              }
              goto LABEL_57;
            }
          }
          else if (v15 != &nw_protocol_ref_counted_handle)
          {
            goto LABEL_53;
          }
          nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
          if (v21) {
            goto LABEL_54;
          }
LABEL_57:
          char v22 = *(unsigned char *)(v11 + 137) | 1;
          goto LABEL_22;
        }
      }
    }
    if (((char)v7[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        __int16 v86 = 2082;
        unsigned int v87 = v7 + 407;
        __int16 v88 = 2080;
        id v89 = " ";
        __int16 v90 = 2048;
        unint64_t v91 = v78;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sOutput handler is torn down for path %lx", buf, 0x2Au);
      }
    }
LABEL_28:
    uint64_t v21 = 0;
    goto LABEL_161;
  }
  uint64_t v21 = 0;
  char v22 = *(unsigned char *)(v10 + 137) | 5;
LABEL_22:
  *(unsigned char *)(v11 + 137) = v22;
LABEL_161:

  return v21;
}

void sub_183347E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_service_outbound_requests(NWConcrete_nw_protocol_instance *a1)
{
  socklen_t v1 = a1;
  uint64_t v2 = v1;
  p_uint64_t tqh_first = (id *)&v1->pending_outbound_frames.tqh_first;
  uint64_t tqh_first = (atomic_uchar *)v1->pending_outbound_frames.tqh_first;
  if (tqh_first)
  {
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x3032000000;
    uint64_t v13 = __Block_byref_object_copy__11790;
    unint64_t v14 = __Block_byref_object_dispose__11791;
    id v15 = 0;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = ___ZL37nw_protocol_service_outbound_requestsP31NWConcrete_nw_protocol_instance_block_invoke;
    v7[3] = &unk_1E524A2E8;
    uint64_t v9 = &v10;
    id v8 = v1;
    nw_array_apply(tqh_first, (uint64_t)v7);
    objc_storeStrong(p_tqh_first, (id)v11[5]);
    BOOL v5 = v11[5] == 0;

    _Block_object_dispose(&v10, 8);
  }
  else
  {
    BOOL v5 = 1;
  }

  return v5;
}

uint64_t ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4F143A8];
  uint64_t v3 = 0x40000000;
  size_t v4 = ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2;
  BOOL v5 = &unk_1E523C378;
  long long v7 = *(_OWORD *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  return (*(uint64_t (**)(void))(*(void *)(v7 + 752) + 16))();
}

char *nw_path_flow_copy_description(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  socklen_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[2];
    if (v3) {
      snprintf(__str, 0x28uLL, ", interface: %s", (const char *)(v3 + 104));
    }
    else {
      __str[0] = 0;
    }
    char v4 = *((unsigned char *)v2 + 185);
    memset(out, 0, 37);
    uuid_unparse((const unsigned __int8 *)v2 + 144, (char *)out);
    BOOL v5 = ", assigned";
    uint64_t v6 = "";
    if ((v4 & 2) == 0) {
      BOOL v5 = "";
    }
    if (v4) {
      uint64_t v6 = ", viable";
    }
    os_log_type_t v17 = 0;
    asprintf(&v17, "%s%s%s%s", (const char *)out, __str, v6, v5);
    long long v7 = v17;
    goto LABEL_10;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)__str = 136446210;
  os_log_type_t v20 = "nw_path_flow_copy_description";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();

  out[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v17) = 0;
  if (__nwlog_fault(v10, out, &v17))
  {
    if (out[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = out[0];
      if (os_log_type_enabled(v11, out[0]))
      {
        *(_DWORD *)__str = 136446210;
        os_log_type_t v20 = "nw_path_flow_copy_description";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null flow", (uint8_t *)__str, 0xCu);
      }
    }
    else if ((_BYTE)v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v14 = out[0];
      BOOL v15 = os_log_type_enabled(v11, out[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__str = 136446466;
          os_log_type_t v20 = "nw_path_flow_copy_description";
          __int16 v21 = 2082;
          char v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null flow, dumping backtrace:%{public}s", (uint8_t *)__str, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v15)
      {
        *(_DWORD *)__str = 136446210;
        os_log_type_t v20 = "nw_path_flow_copy_description";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null flow, no backtrace", (uint8_t *)__str, 0xCu);
      }
    }
    else
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v16 = out[0];
      if (os_log_type_enabled(v11, out[0]))
      {
        *(_DWORD *)__str = 136446210;
        os_log_type_t v20 = "nw_path_flow_copy_description";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null flow, backtrace limit exceeded", (uint8_t *)__str, 0xCu);
      }
    }
  }
LABEL_27:
  if (v10) {
    free(v10);
  }
  long long v7 = 0;
LABEL_10:

  return v7;
}

void sub_183348424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_parameters_get_prohibit_cellular_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E4F145F8])
  {
    uint64_t v5 = 1;
    if (xpc_uint64_get_value(v4) == 2)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 1;
  }

  return v5;
}

void sub_1833484B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_parameters_t nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t configure_dtls, nw_parameters_configure_protocol_block_t configure_udp)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = configure_dtls;
  id v4 = configure_udp;
  uint64_t v5 = v4;
  if (!v3)
  {
    char v40 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_udp";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s called with null configure_dtls", buf, 0xCu);
      }
      goto LABEL_129;
    }
    if (!v59)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v56 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v56, "%{public}s called with null configure_dtls, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_129;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v50 = os_log_type_enabled(v42, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v49, "%{public}s called with null configure_dtls, no backtrace", buf, 0xCu);
      }
      goto LABEL_129;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v62 = "nw_parameters_create_secure_udp";
      __int16 v63 = 2082;
      uint64_t v64 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v42, v49, "%{public}s called with null configure_dtls, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_105;
  }
  if (!v4)
  {
    __int16 v44 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_udp";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v45, "%{public}s called with null configure_udp", buf, 0xCu);
      }
      goto LABEL_129;
    }
    if (!v59)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v57, "%{public}s called with null configure_udp, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_129;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v51 = type;
    BOOL v52 = os_log_type_enabled(v42, type);
    if (!backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v51, "%{public}s called with null configure_udp, no backtrace", buf, 0xCu);
      }
      goto LABEL_129;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v62 = "nw_parameters_create_secure_udp";
      __int16 v63 = 2082;
      uint64_t v64 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v42, v51, "%{public}s called with null configure_udp, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_105:

    free(backtrace_string);
    if (!v41) {
      goto LABEL_132;
    }
    goto LABEL_131;
  }
  if (v4 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_19196)
  {
    BOOL v46 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_udp";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v47, "%{public}s called with null (configure_udp != (_nw_parameters_configure_protocol_disable))", buf, 0xCu);
      }
    }
    else if (v59)
    {
      BOOL v53 = (char *)__nw_create_backtrace_string();
      BOOL v42 = __nwlog_obj();
      os_log_type_t v54 = type;
      BOOL v55 = os_log_type_enabled(v42, type);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v62 = "nw_parameters_create_secure_udp";
          __int16 v63 = 2082;
          uint64_t v64 = v53;
          _os_log_impl(&dword_1830D4000, v42, v54, "%{public}s called with null (configure_udp != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v53);
LABEL_130:
        if (!v41)
        {
LABEL_132:
          uint64_t v10 = 0;
          goto LABEL_80;
        }
LABEL_131:
        free(v41);
        goto LABEL_132;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v54, "%{public}s called with null (configure_udp != (_nw_parameters_configure_protocol_disable)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v42, v58, "%{public}s called with null (configure_udp != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_129:

    goto LABEL_130;
  }
  nw_parameters_t v6 = nw_parameters_create();
  if (v6)
  {
    if (v3 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_19196) {
      goto LABEL_11;
    }
    long long v7 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v7);

    if (options)
    {
      if (nw_parameters_add_protocol_stack_member(v6, 4, 0, options))
      {
        if (v3 != (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
          v3[2](v3, options);
        }

LABEL_11:
        if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
          dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
        }
        uint64_t v9 = nw_protocol_create_options((void *)g_udp_definition);
        if (v9)
        {
          if (nw_parameters_add_protocol_stack_member(v6, 3, 0, v9))
          {
            if (v5 != (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
              v5[2](v5, v9);
            }
            BYTE4(v6[11].isa) = 1;
            uint64_t v10 = v6;
            goto LABEL_78;
          }
LABEL_77:
          uint64_t v10 = 0;
LABEL_78:

          goto LABEL_79;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_udp";
              _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_udp_create_options failed", buf, 0xCu);
            }
          }
          else if (v59)
          {
            uint64_t v31 = __nw_create_backtrace_string();
            if (v31)
            {
              BOOL v32 = (char *)v31;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v33 = (id)gLogObj;
              os_log_type_t v34 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v62 = "nw_parameters_create_secure_udp";
                __int16 v63 = 2082;
                uint64_t v64 = v32;
                _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s nw_udp_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v32);
              if (!v23) {
                goto LABEL_77;
              }
              goto LABEL_76;
            }
            uint64_t v24 = __nwlog_obj();
            os_log_type_t v38 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_udp";
              _os_log_impl(&dword_1830D4000, v24, v38, "%{public}s nw_udp_create_options failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (id)gLogObj;
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_udp";
              _os_log_impl(&dword_1830D4000, v24, v36, "%{public}s nw_udp_create_options failed, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        if (!v23) {
          goto LABEL_77;
        }
LABEL_76:
        free(v23);
        goto LABEL_77;
      }
      goto LABEL_70;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_udp";
    char v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v19, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_udp";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s nw_tls_create_options failed", buf, 0xCu);
        }
      }
      else if (v59)
      {
        char v26 = __nw_create_backtrace_string();
        if (v26)
        {
          uint64_t v27 = (char *)v26;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v28 = (id)gLogObj;
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v62 = "nw_parameters_create_secure_udp";
            __int16 v63 = 2082;
            uint64_t v64 = v27;
            _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s nw_tls_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v27);
          if (!v19) {
            goto LABEL_70;
          }
          goto LABEL_69;
        }
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_udp";
          _os_log_impl(&dword_1830D4000, v20, v37, "%{public}s nw_tls_create_options failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_udp";
          _os_log_impl(&dword_1830D4000, v20, v35, "%{public}s nw_tls_create_options failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v19)
    {
LABEL_70:

      goto LABEL_71;
    }
LABEL_69:
    free(v19);
    goto LABEL_70;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v62 = "nw_parameters_create_secure_udp";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v59 = 0;
  if (__nwlog_fault(v12, &type, &v59))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }
    else if (v59)
    {
      BOOL v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v62 = "nw_parameters_create_secure_udp";
          __int16 v63 = 2082;
          uint64_t v64 = v15;
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        if (!v12) {
          goto LABEL_71;
        }
        goto LABEL_58;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl(&dword_1830D4000, v13, v30, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
  if (v12) {
LABEL_58:
  }
    free(v12);
LABEL_71:
  uint64_t v10 = 0;
LABEL_79:

LABEL_80:
  return v10;
}

void sub_183349458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_parameters_t nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t configure_tls, nw_parameters_configure_protocol_block_t configure_tcp)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = configure_tls;
  id v4 = configure_tcp;
  uint64_t v5 = v4;
  if (!v3)
  {
    char v40 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_tcp";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59)) {
      goto LABEL_132;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s called with null configure_tls", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (!v59)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v56 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v56, "%{public}s called with null configure_tls, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_131;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v50 = os_log_type_enabled(v42, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v49, "%{public}s called with null configure_tls, no backtrace", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v62 = "nw_parameters_create_secure_tcp";
      __int16 v63 = 2082;
      uint64_t v64 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v42, v49, "%{public}s called with null configure_tls, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_107;
  }
  if (!v4)
  {
    __int16 v44 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_tcp";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59)) {
      goto LABEL_132;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v45, "%{public}s called with null configure_tcp", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (!v59)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v57, "%{public}s called with null configure_tcp, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_131;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v51 = type;
    BOOL v52 = os_log_type_enabled(v42, type);
    if (!backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v51, "%{public}s called with null configure_tcp, no backtrace", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v62 = "nw_parameters_create_secure_tcp";
      __int16 v63 = 2082;
      uint64_t v64 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v42, v51, "%{public}s called with null configure_tcp, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_107:

    free(backtrace_string);
    if (!v41) {
      goto LABEL_134;
    }
    goto LABEL_133;
  }
  if (v4 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_19196)
  {
    BOOL v46 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_tcp";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59)) {
      goto LABEL_132;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v47, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable))", buf, 0xCu);
      }
    }
    else if (v59)
    {
      BOOL v53 = (char *)__nw_create_backtrace_string();
      BOOL v42 = __nwlog_obj();
      os_log_type_t v54 = type;
      BOOL v55 = os_log_type_enabled(v42, type);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          __int16 v63 = 2082;
          uint64_t v64 = v53;
          _os_log_impl(&dword_1830D4000, v42, v54, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v53);
LABEL_132:
        if (!v41)
        {
LABEL_134:
          uint64_t v10 = 0;
          goto LABEL_82;
        }
LABEL_133:
        free(v41);
        goto LABEL_134;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v54, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v42, v58, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_131:

    goto LABEL_132;
  }
  nw_parameters_t v6 = nw_parameters_create();
  if (v6)
  {
    if (v3 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_19196) {
      goto LABEL_11;
    }
    long long v7 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v7);

    if (options)
    {
      if (nw_parameters_add_protocol_stack_member(v6, 4, 0, options))
      {
        if (v3 != (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
          v3[2](v3, options);
        }

LABEL_11:
        if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
          dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
        }
        uint64_t v9 = nw_protocol_create_options((void *)g_tcp_definition);
        if (v9)
        {
          if (nw_parameters_add_protocol_stack_member(v6, 3, 0, v9))
          {
            if (networkd_settings_get_BOOL((const char *)nw_setting_tcp_enable_auto_tfo)) {
              nw_parameters_set_tfo(v6, 1);
            }
            if (v5 != (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
              v5[2](v5, v9);
            }
            BYTE4(v6[11].isa) = 2;
            uint64_t v10 = v6;
            goto LABEL_80;
          }
LABEL_79:
          uint64_t v10 = 0;
LABEL_80:

          goto LABEL_81;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_tcp_create_options failed", buf, 0xCu);
            }
          }
          else if (v59)
          {
            uint64_t v31 = __nw_create_backtrace_string();
            if (v31)
            {
              BOOL v32 = (char *)v31;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v33 = (id)gLogObj;
              os_log_type_t v34 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v62 = "nw_parameters_create_secure_tcp";
                __int16 v63 = 2082;
                uint64_t v64 = v32;
                _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s nw_tcp_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v32);
              if (!v23) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }
            uint64_t v24 = __nwlog_obj();
            os_log_type_t v38 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_1830D4000, v24, v38, "%{public}s nw_tcp_create_options failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (id)gLogObj;
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_1830D4000, v24, v36, "%{public}s nw_tcp_create_options failed, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        if (!v23) {
          goto LABEL_79;
        }
LABEL_78:
        free(v23);
        goto LABEL_79;
      }
      goto LABEL_72;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_tcp";
    char v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v19, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s nw_tls_create_options failed", buf, 0xCu);
        }
      }
      else if (v59)
      {
        char v26 = __nw_create_backtrace_string();
        if (v26)
        {
          uint64_t v27 = (char *)v26;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v28 = (id)gLogObj;
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v62 = "nw_parameters_create_secure_tcp";
            __int16 v63 = 2082;
            uint64_t v64 = v27;
            _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s nw_tls_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v27);
          if (!v19) {
            goto LABEL_72;
          }
          goto LABEL_71;
        }
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_1830D4000, v20, v37, "%{public}s nw_tls_create_options failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_1830D4000, v20, v35, "%{public}s nw_tls_create_options failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v19)
    {
LABEL_72:

      goto LABEL_73;
    }
LABEL_71:
    free(v19);
    goto LABEL_72;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v62 = "nw_parameters_create_secure_tcp";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v59 = 0;
  if (__nwlog_fault(v12, &type, &v59))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }
    else if (v59)
    {
      BOOL v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          __int16 v63 = 2082;
          uint64_t v64 = v15;
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        if (!v12) {
          goto LABEL_73;
        }
        goto LABEL_60;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_1830D4000, v13, v30, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
  if (v12) {
LABEL_60:
  }
    free(v12);
LABEL_73:
  uint64_t v10 = 0;
LABEL_81:

LABEL_82:
  return v10;
}

void sub_18334A450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_add_protocol_stack_member(void *a1, int a2, unsigned int a3, void *a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  long long v7 = a1;
  id v8 = a4;
  uint64_t v9 = v8;
  if (v7)
  {
    if (v8)
    {
      id v10 = v7[19];
      id v11 = v10;
      if (v10)
      {
        switch(a2)
        {
          case 2:
            objc_storeStrong((id *)v10 + 6, a4);
            goto LABEL_25;
          case 3:
            objc_storeStrong((id *)v10 + 3, a4);
            goto LABEL_25;
          case 4:
            uint64_t v14 = *((void *)v10 + 2);
            if (a3 == -1)
            {
              if (v14) {
                goto LABEL_24;
              }
            }
            else if (v14)
            {
              if (a3 >= (unint64_t)((uint64_t)(*(void *)(v14 + 24) - *(void *)(v14 + 16)) >> 3)) {
                goto LABEL_24;
              }
              BOOL v15 = nw_array_create();
              os_log_type_t v16 = (atomic_uchar *)v11[2];
              v50[0] = MEMORY[0x1E4F143A8];
              v50[1] = 3221225472;
              v50[2] = __nw_parameters_add_protocol_stack_member_block_invoke_2;
              v50[3] = &unk_1E523D2F0;
              unsigned int v53 = a3;
              id v17 = (id)v15;
              id v51 = v17;
              id v52 = v9;
              nw_array_apply(v16, (uint64_t)v50);
              id v18 = (void *)v11[2];
              v11[2] = v17;
              id v19 = v17;

LABEL_25:
              uint64_t v13 = 1;
LABEL_26:

              goto LABEL_27;
            }
            uint64_t v25 = 2;
            goto LABEL_23;
          case 5:
            uint64_t v14 = *((void *)v10 + 1);
            if (a3 == -1)
            {
              if (v14) {
                goto LABEL_24;
              }
            }
            else if (v14)
            {
              if (a3 < (unint64_t)((uint64_t)(*(void *)(v14 + 24) - *(void *)(v14 + 16)) >> 3))
              {
                BOOL v20 = nw_array_create();
                os_log_type_t v21 = (atomic_uchar *)v11[1];
                v54[0] = MEMORY[0x1E4F143A8];
                v54[1] = 3221225472;
                v54[2] = __nw_parameters_add_protocol_stack_member_block_invoke;
                v54[3] = &unk_1E523D2F0;
                unsigned int v57 = a3;
                id v22 = (id)v20;
                id v55 = v22;
                id v56 = v9;
                nw_array_apply(v21, (uint64_t)v54);
                uint64_t v23 = (void *)v11[1];
                v11[1] = v22;
                id v24 = v22;

                goto LABEL_25;
              }
LABEL_24:
              nw_array_append(v14, v9);
              goto LABEL_25;
            }
            uint64_t v25 = 1;
LABEL_23:
            BOOL v26 = nw_array_create();
            uint64_t v27 = (void *)v11[v25];
            v11[v25] = v26;

            uint64_t v14 = v11[v25];
            goto LABEL_24;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v12 = (id)gLogObj;
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v61 = "nw_parameters_add_protocol_stack_member";
              __int16 v62 = 1024;
              LODWORD(v63) = a2;
              _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s Unsupported protocol level %u", buf, 0x12u);
            }

            goto LABEL_9;
        }
      }
      os_log_type_t v35 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v61 = "nw_parameters_add_protocol_stack_member";
      os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v59 = OS_LOG_TYPE_ERROR;
      char v58 = 0;
      if (__nwlog_fault(v36, &v59, &v58))
      {
        if (v59 == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v37 = __nwlog_obj();
          os_log_type_t v38 = v59;
          if (os_log_type_enabled(v37, v59))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s called with null stack", buf, 0xCu);
          }
        }
        else if (v58)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v37 = __nwlog_obj();
          os_log_type_t v45 = v59;
          BOOL v46 = os_log_type_enabled(v37, v59);
          if (backtrace_string)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v61 = "nw_parameters_add_protocol_stack_member";
              __int16 v62 = 2082;
              __int16 v63 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v37, v45, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_79;
          }
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_1830D4000, v37, v45, "%{public}s called with null stack, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          os_log_type_t v37 = __nwlog_obj();
          os_log_type_t v49 = v59;
          if (os_log_type_enabled(v37, v59))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_1830D4000, v37, v49, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_79:
      if (v36) {
        free(v36);
      }
LABEL_9:
      uint64_t v13 = 0;
      goto LABEL_26;
    }
    char v33 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v61 = "nw_parameters_add_protocol_stack_member";
    os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v59 = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (__nwlog_fault(v30, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v34 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null protocol_parameters", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (!v58)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v48 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_1830D4000, v31, v48, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      os_log_type_t v39 = (char *)__nw_create_backtrace_string();
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v42 = v59;
      BOOL v43 = os_log_type_enabled(v31, v59);
      if (!v39)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_1830D4000, v31, v42, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v61 = "nw_parameters_add_protocol_stack_member";
        __int16 v62 = 2082;
        __int16 v63 = v39;
        _os_log_impl(&dword_1830D4000, v31, v42, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_52;
    }
  }
  else
  {
    os_log_type_t v29 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v61 = "nw_parameters_add_protocol_stack_member";
    os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v59 = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (__nwlog_fault(v30, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v32 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (!v58)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v47 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_1830D4000, v31, v47, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      os_log_type_t v39 = (char *)__nw_create_backtrace_string();
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v40 = v59;
      BOOL v41 = os_log_type_enabled(v31, v59);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_1830D4000, v31, v40, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v61 = "nw_parameters_add_protocol_stack_member";
        __int16 v62 = 2082;
        __int16 v63 = v39;
        _os_log_impl(&dword_1830D4000, v31, v40, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_52:

      free(v39);
    }
  }
LABEL_73:
  if (v30) {
    free(v30);
  }
  uint64_t v13 = 0;
LABEL_27:

  return v13;
}

uint64_t nw_protocol_get_path(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_get_path";
    id v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_path";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_get_path";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_60;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_path";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }
      else
      {
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_path";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }
LABEL_60:
    if (v18) {
      free(v18);
    }
    return 0;
  }
  id v2 = *(void **)(a1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      *(void *)(a1 + 88) = v3 + 1;
    }
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t))(v4 + 120);
    if (v5)
    {
      uint64_t v6 = v5(a1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_8;
    }
  }
  __nwlog_obj();
  os_log_type_t v12 = *(const char **)(a1 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v32 = "__nw_protocol_get_path";
  if (!v12) {
    os_log_type_t v12 = "invalid";
  }
  __int16 v33 = 2082;
  os_log_type_t v34 = (void *)v12;
  __int16 v35 = 2048;
  uint64_t v36 = a1;
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (!__nwlog_fault(v13, &type, &v29)) {
    goto LABEL_51;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_51;
    }
    os_log_type_t v16 = *(const char **)(a1 + 16);
    if (!v16) {
      os_log_type_t v16 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v32 = "__nw_protocol_get_path";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v16;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    id v17 = "%{public}s protocol %{public}s (%p) has invalid get_path callback";
LABEL_50:
    _os_log_impl(&dword_1830D4000, v14, v15, v17, buf, 0x20u);
    goto LABEL_51;
  }
  if (!v29)
  {
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_51;
    }
    uint64_t v27 = *(const char **)(a1 + 16);
    if (!v27) {
      uint64_t v27 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v32 = "__nw_protocol_get_path";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v27;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    id v17 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded";
    goto LABEL_50;
  }
  id v22 = (char *)__nw_create_backtrace_string();
  uint64_t v14 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v23 = os_log_type_enabled(v14, type);
  if (!v22)
  {
    if (!v23) {
      goto LABEL_51;
    }
    uint64_t v28 = *(const char **)(a1 + 16);
    if (!v28) {
      uint64_t v28 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v32 = "__nw_protocol_get_path";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v28;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    id v17 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace";
    goto LABEL_50;
  }
  if (v23)
  {
    id v24 = *(const char **)(a1 + 16);
    if (!v24) {
      id v24 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    os_log_type_t v32 = "__nw_protocol_get_path";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v24;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    __int16 v37 = 2082;
    os_log_type_t v38 = v22;
    _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v22);
LABEL_51:
  if (v13) {
    free(v13);
  }
  uint64_t v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_8:
    if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *(void *)(a1 + 88);
      if (v8)
      {
        uint64_t v9 = v8 - 1;
        *(void *)(a1 + 88) = v9;
        if (!v9)
        {
          id v10 = *(void (***)(void))(a1 + 64);
          if (v10)
          {
            *(void *)(a1 + 64) = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if (*(unsigned char *)(a1 + 72))
          {
            id v11 = *(const void **)(a1 + 64);
            if (v11) {
              _Block_release(v11);
            }
          }
          free((void *)a1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_get_local_endpoint(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
    id v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_60;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }
      else
      {
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }
LABEL_60:
    if (v18) {
      free(v18);
    }
    return 0;
  }
  id v2 = *(void **)(a1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      *(void *)(a1 + 88) = v3 + 1;
    }
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t))(v4 + 128);
    if (v5)
    {
      uint64_t v6 = v5(a1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_8;
    }
  }
  __nwlog_obj();
  os_log_type_t v12 = *(const char **)(a1 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
  if (!v12) {
    os_log_type_t v12 = "invalid";
  }
  __int16 v33 = 2082;
  os_log_type_t v34 = (void *)v12;
  __int16 v35 = 2048;
  uint64_t v36 = a1;
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (!__nwlog_fault(v13, &type, &v29)) {
    goto LABEL_51;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_51;
    }
    os_log_type_t v16 = *(const char **)(a1 + 16);
    if (!v16) {
      os_log_type_t v16 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v16;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    id v17 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_50:
    _os_log_impl(&dword_1830D4000, v14, v15, v17, buf, 0x20u);
    goto LABEL_51;
  }
  if (!v29)
  {
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_51;
    }
    uint64_t v27 = *(const char **)(a1 + 16);
    if (!v27) {
      uint64_t v27 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v27;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    id v17 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
    goto LABEL_50;
  }
  id v22 = (char *)__nw_create_backtrace_string();
  uint64_t v14 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v23 = os_log_type_enabled(v14, type);
  if (!v22)
  {
    if (!v23) {
      goto LABEL_51;
    }
    uint64_t v28 = *(const char **)(a1 + 16);
    if (!v28) {
      uint64_t v28 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v28;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    id v17 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
    goto LABEL_50;
  }
  if (v23)
  {
    id v24 = *(const char **)(a1 + 16);
    if (!v24) {
      id v24 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v24;
    __int16 v35 = 2048;
    uint64_t v36 = a1;
    __int16 v37 = 2082;
    os_log_type_t v38 = v22;
    _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v22);
LABEL_51:
  if (v13) {
    free(v13);
  }
  uint64_t v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_8:
    if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *(void *)(a1 + 88);
      if (v8)
      {
        uint64_t v9 = v8 - 1;
        *(void *)(a1 + 88) = v9;
        if (!v9)
        {
          id v10 = *(void (***)(void))(a1 + 64);
          if (v10)
          {
            *(void *)(a1 + 64) = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if (*(unsigned char *)(a1 + 72))
          {
            id v11 = *(const void **)(a1 + 64);
            if (v11) {
              _Block_release(v11);
            }
          }
          free((void *)a1);
        }
      }
    }
  }
  return v6;
}

uint64_t __nw_channel_purge_idle_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (unsigned __int16 *)(a3 + 444);
  int v4 = *(unsigned __int16 *)(a3 + 444) | (*(unsigned __int8 *)(a3 + 446) << 16);
  if ((v4 & 0x60000) == 0 && *(void *)(a3 + 136))
  {
    unsigned __int16 *v3 = *(_WORD *)(a3 + 444);
    *(unsigned char *)(a3 + 446) = BYTE2(v4) | 4;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 136446210;
      os_log_type_t v12 = "nw_channel_purge_idle_block_invoke";
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s Purging channel packet pool after going idle", (uint8_t *)&v11, 0xCu);
    }
    if (os_channel_packet_pool_purge())
    {
      uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (!v10)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = nw_array_create();
        uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      }
      nw_array_append(v10, (void *)a3);
    }
  }
  unsigned int v8 = (*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0xFFFDFFFF;
  unsigned __int16 *v3 = *v3;
  *((unsigned char *)v3 + 2) = BYTE2(v8);
  return 1;
}

void nw_protocol_definition_set_initialize(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_definition_set_initialize";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v22 = "nw_protocol_definition_set_initialize";
          __int16 v23 = 2082;
          id v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var5 = a2;
    goto LABEL_4;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_protocol_definition_set_initialize";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_initialize";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_initialize";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v14 = (char *)__nw_create_backtrace_string();
  long long v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_initialize";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_protocol_definition_set_initialize";
    __int16 v23 = 2082;
    id v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_18334BF34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_outbound(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_definition_set_handle_outbound";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v22 = "nw_protocol_definition_set_handle_outbound";
          __int16 v23 = 2082;
          id v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var8 = a2;
    goto LABEL_4;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_protocol_definition_set_handle_outbound";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_handle_outbound";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_handle_outbound";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v14 = (char *)__nw_create_backtrace_string();
  long long v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_handle_outbound";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_protocol_definition_set_handle_outbound";
    __int16 v23 = 2082;
    id v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_18334C3F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_error(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_definition_set_handle_error";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v22 = "nw_protocol_definition_set_handle_error";
          __int16 v23 = 2082;
          id v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var9 = a2;
    goto LABEL_4;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_protocol_definition_set_handle_error";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_handle_error";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_handle_error";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v14 = (char *)__nw_create_backtrace_string();
  long long v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_handle_error";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_protocol_definition_set_handle_error";
    __int16 v23 = 2082;
    id v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_18334C8BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_destroy(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_definition_set_destroy";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v22 = "nw_protocol_definition_set_destroy";
          __int16 v23 = 2082;
          id v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var6 = a2;
    goto LABEL_4;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_protocol_definition_set_destroy";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_destroy";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_destroy";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v14 = (char *)__nw_create_backtrace_string();
  long long v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_definition_set_destroy";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_protocol_definition_set_destroy";
    __int16 v23 = 2082;
    id v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_18334CD80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_2(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v44 = 0;
  os_log_type_t v45 = &v44;
  uint64_t v46 = 0x2020000000;
  char v47 = 1;
  id v2 = *(os_unfair_lock_s **)(a1 + 32);
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_3;
  aBlock[3] = &unk_1E524B978;
  os_log_type_t v42 = v2;
  BOOL v43 = &v44;
  uint64_t v3 = (void (**)(void))_Block_copy(aBlock);
  v2 += 10;
  os_unfair_lock_lock(v2);
  v3[2](v3);
  os_unfair_lock_unlock(v2);

  if (*((unsigned char *)v45 + 24))
  {
    uint64_t v4 = mach_continuous_time();
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    if (gLogDatapath)
    {
      char v19 = __nwlog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v20 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner_block_invoke_2";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v20;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s report %p adding collecting snapshot", buf, 0x16u);
      }
    }
    nw_data_transfer_report_add_snapshot_on_nw_queue(*(void **)(a1 + 32));
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v7 = v6[1];
    if (v7)
    {
      unint64_t v8 = nw_delta_nanos(v7, v5);
      uint64_t v9 = (v8 / 0xF4240);
      if (v8 > 0xF423FFFFFFFFFLL) {
        uint64_t v9 = 0xFFFFFFFFLL;
      }
      *(void *)(*(void *)(a1 + 32) + 16) = v9;
      uint64_t v6 = *(void **)(a1 + 32);
    }
    id v10 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    int v11 = v6;
    os_log_type_t v12 = v11;
    if (v10)
    {
      if (v11)
      {
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_connection_remove_data_transfer_report_block_invoke;
        id v51 = &unk_1E524B9A0;
        id v13 = v10;
        id v52 = v13;
        id v53 = v12;
        nw_connection_async_if_needed(v13, buf);

LABEL_13:
        uint64_t v14 = *(os_unfair_lock_s **)(a1 + 32);
        v39[0] = MEMORY[0x1E4F143A8];
        v39[1] = 3221225472;
        v39[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_238;
        v39[3] = &unk_1E524BAA8;
        os_log_type_t v40 = v14;
        os_log_type_t v15 = (void (**)(void))_Block_copy(v39);
        v14 += 10;
        os_unfair_lock_lock(v14);
        v15[2](v15);
        os_unfair_lock_unlock(v14);

        BOOL v16 = v40;
LABEL_14:

        goto LABEL_16;
      }
      uint64_t v25 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
      id v22 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v49 = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v22, &v49, &v48)) {
        goto LABEL_59;
      }
      if (v49 == OS_LOG_TYPE_FAULT)
      {
        __int16 v23 = __nwlog_obj();
        os_log_type_t v26 = v49;
        if (os_log_type_enabled(v23, v49))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if (v48)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v23 = __nwlog_obj();
        os_log_type_t v32 = v49;
        BOOL v33 = os_log_type_enabled(v23, v49);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v22) {
            goto LABEL_13;
          }
          goto LABEL_60;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v23 = __nwlog_obj();
        os_log_type_t v35 = v49;
        if (os_log_type_enabled(v23, v49))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    else
    {
      os_log_type_t v21 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
      id v22 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v49 = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v22, &v49, &v48)) {
        goto LABEL_59;
      }
      if (v49 == OS_LOG_TYPE_FAULT)
      {
        __int16 v23 = __nwlog_obj();
        os_log_type_t v24 = v49;
        if (os_log_type_enabled(v23, v49))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v48)
      {
        uint64_t v28 = (char *)__nw_create_backtrace_string();
        __int16 v23 = __nwlog_obj();
        os_log_type_t v29 = v49;
        BOOL v30 = os_log_type_enabled(v23, v49);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v28;
            _os_log_impl(&dword_1830D4000, v23, v29, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v28);
LABEL_59:
          if (!v22) {
            goto LABEL_13;
          }
LABEL_60:
          free(v22);
          goto LABEL_13;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_1830D4000, v23, v29, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v23 = __nwlog_obj();
        os_log_type_t v34 = v49;
        if (os_log_type_enabled(v23, v49))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_59;
  }
  if (gLogDatapath)
  {
    BOOL v16 = __nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner_block_invoke_2";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v27;
      _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s report %p already collected, delivering", buf, 0x16u);
    }
    goto LABEL_14;
  }
LABEL_16:
  os_log_type_t v17 = *(void (***)(void, void))(a1 + 48);
  if (v17)
  {
    if (*(unsigned char *)(a1 + 64))
    {
      v17[2](v17, *(void *)(a1 + 32));
    }
    else
    {
      os_log_type_t v18 = *(NSObject **)(a1 + 40);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_239;
      block[3] = &unk_1E524B950;
      os_log_type_t v38 = v17;
      id v37 = *(id *)(a1 + 32);
      dispatch_async(v18, block);
    }
  }

  _Block_object_dispose(&v44, 8);
}

void sub_18334D60C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a30, 8);
  _Unwind_Resume(a1);
}

void nw_data_transfer_report_add_snapshot_on_nw_queue(void *a1)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  socklen_t v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    os_log_type_t v38 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v39, type, &v63)) {
      goto LABEL_103;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v41 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if ((_BYTE)v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v47 = type[0];
      BOOL v48 = os_log_type_enabled(v40, type[0]);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
          __int16 v73 = 2082;
          id v74 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v40, v47, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_103:
        if (!v39) {
          goto LABEL_16;
        }
LABEL_104:
        free(v39);
        goto LABEL_16;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v47, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v54 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v54, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_102:

    goto LABEL_103;
  }
  uint64_t v3 = v1[3];
  if (!v3)
  {
    os_log_type_t v42 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v39, type, &v63)) {
      goto LABEL_103;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v43 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v43, "%{public}s called with null report->connection", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (!(_BYTE)v63)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v55 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v55, "%{public}s called with null report->connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_102;
    }
    os_log_type_t v49 = (char *)__nw_create_backtrace_string();
    os_log_type_t v40 = __nwlog_obj();
    os_log_type_t v50 = type[0];
    BOOL v51 = os_log_type_enabled(v40, type[0]);
    if (!v49)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v50, "%{public}s called with null report->connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (v51)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      __int16 v73 = 2082;
      id v74 = v49;
      _os_log_impl(&dword_1830D4000, v40, v50, "%{public}s called with null report->connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_83;
  }
  uint64_t v4 = *(void **)(v3 + 24);
  if (!v4)
  {
    uint64_t v44 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v39, type, &v63)) {
      goto LABEL_103;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v45 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v45, "%{public}s called with null report->connection->context", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (!(_BYTE)v63)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v56 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v56, "%{public}s called with null report->connection->context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_102;
    }
    os_log_type_t v49 = (char *)__nw_create_backtrace_string();
    os_log_type_t v40 = __nwlog_obj();
    os_log_type_t v52 = type[0];
    BOOL v53 = os_log_type_enabled(v40, type[0]);
    if (!v49)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v40, v52, "%{public}s called with null report->connection->context, no backtrace", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (v53)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      __int16 v73 = 2082;
      id v74 = v49;
      _os_log_impl(&dword_1830D4000, v40, v52, "%{public}s called with null report->connection->context, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_83:

    free(v49);
    if (!v39) {
      goto LABEL_16;
    }
    goto LABEL_104;
  }
  uint64_t v5 = v4;
  uint64_t v6 = v5;
  if (((_BYTE)v5[17] & 8) == 0) {
    dispatch_assert_queue_V2(v5[1]);
  }

  *(void *)os_log_type_t type = 0;
  Class v68 = type;
  uint64_t v69 = 0x2020000000;
  char v70 = 0;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke;
  aBlock[3] = &unk_1E524B978;
  BOOL v66 = type;
  uint64_t v7 = (char *)v2;
  id v65 = v7;
  unint64_t v8 = (void (**)(void))_Block_copy(aBlock);
  os_unfair_lock_lock((os_unfair_lock_t)v2 + 10);
  v8[2](v8);
  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 10);

  if (!*((unsigned char *)v68 + 24))
  {
    __int16 v63 = 0;
    char v62 = 0;
    unint64_t v61 = 0;
    nw_connection_fillout_data_transfer_snapshot_on_nw_queue(*((void **)v2 + 3), (uint64_t *)&v63, &v61, &v62, 0);
    if (!v63 || __ROR8__(0xD37A6F4DE9BD37A7 * v61, 3) > 0x1642C8590B21642uLL) {
      goto LABEL_12;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      __int16 v73 = 2048;
      id v74 = v7;
      __int16 v75 = 2048;
      char v76 = v63;
      __int16 v77 = 2048;
      unint64_t v78 = v61 / 0xB8;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s report %p adding snapshot %p with snapshot path count %lu", buf, 0x2Au);
    }

    unint64_t v11 = v61;
    if (v61 - 184 <= 0xB7)
    {
      uint64_t v12 = *((void *)v2 + 3);
      if ((*(unsigned char *)(v12 + 109) & 0x40) != 0)
      {
        uint64_t v27 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(v12 + 144));
        id v28 = nw_endpoint_handler_copy_current_path(v27);
        id v29 = nw_path_copy_interface(v28);

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v30 = (id)gLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          if (v29)
          {
            radio_os_log_type_t type = nw_interface_get_radio_type(v29);
            os_log_type_t v32 = nw_interface_radio_type_to_string(radio_type);
          }
          else
          {
            os_log_type_t v32 = "none";
          }
          uint64_t v33 = *((void *)v7 + 4);
          if (v33)
          {
            int v34 = nw_interface_get_radio_type(*((void **)v7 + 4));
            os_log_type_t v35 = nw_interface_radio_type_to_string(v34);
          }
          else
          {
            os_log_type_t v35 = "none";
          }
          *(_DWORD *)buf = 136447490;
          __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
          __int16 v73 = 2048;
          id v74 = v7;
          __int16 v75 = 2112;
          char v76 = v29;
          __int16 v77 = 2080;
          unint64_t v78 = (unint64_t)v32;
          __int16 v79 = 2112;
          uint64_t v80 = v33;
          __int16 v81 = 2080;
          Class v82 = v35;
          _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s report %p got snapshot for interface %@[%s] (currently collecting interface: %@[%s])", buf, 0x3Eu);
        }

        v57[0] = MEMORY[0x1E4F143A8];
        v57[1] = 3221225472;
        v57[2] = __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke_191;
        v57[3] = &unk_1E5249FB0;
        char v58 = v7;
        id v60 = v63;
        id v36 = v29;
        id v59 = v36;
        id v37 = (void (**)(void))_Block_copy(v57);
        os_unfair_lock_lock((os_unfair_lock_t)v2 + 10);
        v37[2](v37);
        os_unfair_lock_unlock((os_unfair_lock_t)v2 + 10);

        goto LABEL_12;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      __int16 v73 = 2048;
      id v74 = v7;
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s report %p adding multipath snapshot", buf, 0x16u);
    }

    if (v11 < 0xB8)
    {
LABEL_12:
      if (v62 && v63) {
        free(v63);
      }
      goto LABEL_15;
    }
    uint64_t v14 = 0;
    if (v11 / 0xB8 <= 1) {
      unint64_t v15 = 1;
    }
    else {
      unint64_t v15 = v11 / 0xB8;
    }
    while (1)
    {
      os_log_type_t v17 = (nw_data_transfer_snapshot *)((char *)v63 + 184 * v14);
      unint64_t var0 = v17->var0;
      BOOL v16 = (nw_data_transfer_path_report *)(v7 + 56);
      if (v17->var0)
      {
        char v19 = (unsigned int *)*((void *)v7 + 51);
        uint64_t v20 = v19 ? v19[2] : 0;
        BOOL v16 = (nw_data_transfer_path_report *)(v7 + 56);
        if (var0 != v20)
        {
          unsigned int v21 = *((_DWORD *)v7 + 11);
          if (v21 < 2)
          {
LABEL_44:
            nw_data_transfer_add_initial_snapshot(v7, v19, (NWConcrete_nw_interface **)v63 + 23 * v14);
            goto LABEL_29;
          }
          uint64_t v22 = 0;
          uint64_t v23 = *((void *)v7 + 52);
          LODWORD(v24) = v21 - 1;
          if (v24 <= 1) {
            uint64_t v24 = 1;
          }
          else {
            uint64_t v24 = v24;
          }
          uint64_t v25 = (uint64_t *)(v23 + 352);
          while (1)
          {
            uint64_t v26 = *v25;
            if (*v25) {
              uint64_t v26 = *(unsigned int *)(v26 + 8);
            }
            if (var0 == v26) {
              break;
            }
            ++v22;
            v25 += 45;
            if (v24 == v22) {
              goto LABEL_44;
            }
          }
          BOOL v16 = (nw_data_transfer_path_report *)(v23 + 360 * v22);
        }
      }
      nw_data_transfer_update_path_report_end(v16, (nw_data_transfer_snapshot *)v63 + v14);
      nw_data_transfer_update_path_report_begin(v16, v17);
LABEL_29:
      if (++v14 == v15) {
        goto LABEL_12;
      }
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v9 = (id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v72 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    __int16 v73 = 2048;
    id v74 = v7;
    _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s skipping snapshot for collected report %p", buf, 0x16u);
  }

LABEL_15:
  _Block_object_dispose(type, 8);
LABEL_16:
}

void sub_18334E2E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void nw_connection_fillout_data_transfer_snapshot_on_nw_queue(void *a1, uint64_t *a2, void *a3, unsigned char *a4, int a5)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  id v10 = v9;
  if (!v9)
  {
    BOOL v51 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
    os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v93 = 0;
    if (!__nwlog_fault(v52, &type, &v93)) {
      goto LABEL_165;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v53 = __nwlog_obj();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v93)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v53 = __nwlog_obj();
      os_log_type_t v58 = type;
      BOOL v59 = os_log_type_enabled(v53, type);
      if (backtrace_string)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
          __int16 v97 = 2082;
          uint64_t v98 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v53, v58, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_165:
        if (!v52) {
          goto LABEL_88;
        }
LABEL_166:
        free(v52);
        goto LABEL_88;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v53, v58, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v53 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v53, v73, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_164:

    goto LABEL_165;
  }
  if (!a2)
  {
    os_log_type_t v55 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
    os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v93 = 0;
    if (!__nwlog_fault(v52, &type, &v93)) {
      goto LABEL_165;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v53 = __nwlog_obj();
      os_log_type_t v56 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v53, v56, "%{public}s called with null snapshot", buf, 0xCu);
      }
    }
    else if (v93)
    {
      id v60 = (char *)__nw_create_backtrace_string();
      BOOL v53 = __nwlog_obj();
      os_log_type_t v61 = type;
      BOOL v62 = os_log_type_enabled(v53, type);
      if (v60)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446466;
          v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
          __int16 v97 = 2082;
          uint64_t v98 = (uint64_t)v60;
          _os_log_impl(&dword_1830D4000, v53, v61, "%{public}s called with null snapshot, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v60);
        if (!v52) {
          goto LABEL_88;
        }
        goto LABEL_166;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v53, v61, "%{public}s called with null snapshot, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v53 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v53, v74, "%{public}s called with null snapshot, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_164;
  }
  nw_context_assert_queue(v9[3]);
  if ((*((unsigned char *)v10 + 109) & 0x40) == 0 || !v10[18]) {
    goto LABEL_88;
  }
  unint64_t v11 = v10;
  if (!a3)
  {
    __int16 v63 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
    uint64_t v64 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v93 = 0;
    if (!__nwlog_fault(v64, &type, &v93)) {
      goto LABEL_193;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v65 = __nwlog_obj();
      os_log_type_t v66 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s called with null snapshot_length", buf, 0xCu);
      }
      goto LABEL_192;
    }
    if (!v93)
    {
      id v65 = __nwlog_obj();
      os_log_type_t v89 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v65, v89, "%{public}s called with null snapshot_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_192;
    }
    __int16 v75 = (char *)__nw_create_backtrace_string();
    id v65 = __nwlog_obj();
    os_log_type_t v76 = type;
    BOOL v77 = os_log_type_enabled(v65, type);
    if (!v75)
    {
      if (v77)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v65, v76, "%{public}s called with null snapshot_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_192;
    }
    if (v77)
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      __int16 v97 = 2082;
      uint64_t v98 = (uint64_t)v75;
      _os_log_impl(&dword_1830D4000, v65, v76, "%{public}s called with null snapshot_length, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v75);
LABEL_193:
    if (!v64) {
      goto LABEL_8;
    }
    goto LABEL_194;
  }
  if (a4)
  {
    nw_context_assert_queue(v10[3]);
    nw_endpoint_handler_fillout_data_transfer_snapshot(v10[18], a2, a3, a4, a5 ^ 1);
    goto LABEL_8;
  }
  os_log_type_t v71 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
  uint64_t v64 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v93 = 0;
  if (!__nwlog_fault(v64, &type, &v93)) {
    goto LABEL_193;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v65 = __nwlog_obj();
    os_log_type_t v72 = type;
    if (os_log_type_enabled(v65, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_1830D4000, v65, v72, "%{public}s called with null should_release_snapshot", buf, 0xCu);
    }
LABEL_192:

    goto LABEL_193;
  }
  if (!v93)
  {
    id v65 = __nwlog_obj();
    os_log_type_t v92 = type;
    if (os_log_type_enabled(v65, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_1830D4000, v65, v92, "%{public}s called with null should_release_snapshot, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_192;
  }
  char v84 = (char *)__nw_create_backtrace_string();
  id v65 = __nwlog_obj();
  os_log_type_t v85 = type;
  BOOL v86 = os_log_type_enabled(v65, type);
  if (!v84)
  {
    if (v86)
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_1830D4000, v65, v85, "%{public}s called with null should_release_snapshot, no backtrace", buf, 0xCu);
    }
    goto LABEL_192;
  }
  if (v86)
  {
    *(_DWORD *)buf = 136446466;
    v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
    __int16 v97 = 2082;
    uint64_t v98 = (uint64_t)v84;
    _os_log_impl(&dword_1830D4000, v65, v85, "%{public}s called with null should_release_snapshot, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v84);
  if (v64) {
LABEL_194:
  }
    free(v64);
LABEL_8:

  if (*a2) {
    goto LABEL_11;
  }
  uint64_t v12 = malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
  if (v12)
  {
LABEL_10:
    *a2 = (uint64_t)v12;
    *a3 = 184;
    *a4 = 1;
LABEL_11:
    id v13 = v10[18];
    uint64_t v14 = v13;
    if (v13)
    {
      unint64_t v15 = (NWConcrete_nw_endpoint_handler *)v13;
      uint64_t mode = v15->mode;

      if (mode == 2)
      {
        os_log_type_t v17 = nw_endpoint_handler_copy_flow(v15);
        uint64_t v18 = *((void *)v17 + 133);

        goto LABEL_49;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      if (mode > 5) {
        uint64_t v20 = "unknown-mode";
      }
      else {
        uint64_t v20 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      v96 = "nw_endpoint_handler_get_sent_application_byte_count";
      __int16 v97 = 2082;
      uint64_t v98 = (uint64_t)v20;
      __int16 v99 = 2082;
      uint64_t v100 = (uint64_t)"flow";
      unsigned int v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v93 = 0;
      if (__nwlog_fault(v21, &type, &v93))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v22 = (id)gLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            if (mode > 5) {
              uint64_t v24 = "unknown-mode";
            }
            else {
              uint64_t v24 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446722;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            __int16 v97 = 2082;
            uint64_t v98 = (uint64_t)v24;
            __int16 v99 = 2082;
            uint64_t v100 = (uint64_t)"flow";
            _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
          }
        }
        else if (v93)
        {
          uint64_t v25 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v22 = (id)gLogObj;
          os_log_type_t v26 = type;
          BOOL v27 = os_log_type_enabled(v22, type);
          if (v25)
          {
            if (v27)
            {
              if (mode > 5) {
                id v28 = "unknown-mode";
              }
              else {
                id v28 = off_1E523FB08[mode];
              }
              *(_DWORD *)buf = 136446978;
              v96 = "nw_endpoint_handler_get_sent_application_byte_count";
              __int16 v97 = 2082;
              uint64_t v98 = (uint64_t)v28;
              __int16 v99 = 2082;
              uint64_t v100 = (uint64_t)"flow";
              __int16 v101 = 2082;
              id v102 = v25;
              _os_log_impl(&dword_1830D4000, v22, v26, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v25);
            if (!v21) {
              goto LABEL_48;
            }
            goto LABEL_47;
          }
          if (v27)
          {
            if (mode > 5) {
              uint64_t v31 = "unknown-mode";
            }
            else {
              uint64_t v31 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446722;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            __int16 v97 = 2082;
            uint64_t v98 = (uint64_t)v31;
            __int16 v99 = 2082;
            uint64_t v100 = (uint64_t)"flow";
            _os_log_impl(&dword_1830D4000, v22, v26, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v22 = (id)gLogObj;
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v22, type))
          {
            if (mode > 5) {
              BOOL v30 = "unknown-mode";
            }
            else {
              BOOL v30 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446722;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            __int16 v97 = 2082;
            uint64_t v98 = (uint64_t)v30;
            __int16 v99 = 2082;
            uint64_t v100 = (uint64_t)"flow";
            _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
          }
        }
LABEL_45:
      }
    }
    else
    {
      id v67 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v96 = "nw_endpoint_handler_get_sent_application_byte_count";
      unsigned int v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v93 = 0;
      if (__nwlog_fault(v21, &type, &v93))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v68 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_1830D4000, v22, v68, "%{public}s called with null handler", buf, 0xCu);
          }
        }
        else if (v93)
        {
          unint64_t v78 = (char *)__nw_create_backtrace_string();
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v79 = type;
          BOOL v80 = os_log_type_enabled(v22, type);
          if (v78)
          {
            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              v96 = "nw_endpoint_handler_get_sent_application_byte_count";
              __int16 v97 = 2082;
              uint64_t v98 = (uint64_t)v78;
              _os_log_impl(&dword_1830D4000, v22, v79, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v78);
            if (!v21) {
              goto LABEL_48;
            }
            goto LABEL_47;
          }
          if (v80)
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_1830D4000, v22, v79, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v90 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_1830D4000, v22, v90, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_45;
      }
    }
    if (!v21)
    {
LABEL_48:
      uint64_t v18 = 0;
LABEL_49:

      *(void *)(*a2 + 176) = v18;
      id v32 = v10[18];
      uint64_t v33 = v32;
      if (v32)
      {
        int v34 = (NWConcrete_nw_endpoint_handler *)v32;
        uint64_t v35 = v34->mode;

        if (v35 == 2)
        {
          id v36 = nw_endpoint_handler_copy_flow(v34);
          uint64_t v37 = *((void *)v36 + 134);

LABEL_87:
          *(void *)(*a2 + 168) = v37;
LABEL_88:

          return;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v38 = (id)gLogObj;
        if (v35 > 5) {
          uint64_t v39 = "unknown-mode";
        }
        else {
          uint64_t v39 = off_1E523FB08[v35];
        }
        *(_DWORD *)buf = 136446722;
        v96 = "nw_endpoint_handler_get_received_application_byte_count";
        __int16 v97 = 2082;
        uint64_t v98 = (uint64_t)v39;
        __int16 v99 = 2082;
        uint64_t v100 = (uint64_t)"flow";
        os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v93 = 0;
        if (__nwlog_fault(v40, &type, &v93))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v41 = (id)gLogObj;
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              if (v35 > 5) {
                os_log_type_t v43 = "unknown-mode";
              }
              else {
                os_log_type_t v43 = off_1E523FB08[v35];
              }
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              __int16 v97 = 2082;
              uint64_t v98 = (uint64_t)v43;
              __int16 v99 = 2082;
              uint64_t v100 = (uint64_t)"flow";
              _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
            }
          }
          else if (v93)
          {
            uint64_t v44 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v41 = (id)gLogObj;
            os_log_type_t v45 = type;
            BOOL v46 = os_log_type_enabled(v41, type);
            if (v44)
            {
              if (v46)
              {
                if (v35 > 5) {
                  os_log_type_t v47 = "unknown-mode";
                }
                else {
                  os_log_type_t v47 = off_1E523FB08[v35];
                }
                *(_DWORD *)buf = 136446978;
                v96 = "nw_endpoint_handler_get_received_application_byte_count";
                __int16 v97 = 2082;
                uint64_t v98 = (uint64_t)v47;
                __int16 v99 = 2082;
                uint64_t v100 = (uint64_t)"flow";
                __int16 v101 = 2082;
                id v102 = v44;
                _os_log_impl(&dword_1830D4000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
              }

              free(v44);
              if (!v40) {
                goto LABEL_86;
              }
              goto LABEL_85;
            }
            if (v46)
            {
              if (v35 > 5) {
                os_log_type_t v50 = "unknown-mode";
              }
              else {
                os_log_type_t v50 = off_1E523FB08[v35];
              }
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              __int16 v97 = 2082;
              uint64_t v98 = (uint64_t)v50;
              __int16 v99 = 2082;
              uint64_t v100 = (uint64_t)"flow";
              _os_log_impl(&dword_1830D4000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v41 = (id)gLogObj;
            os_log_type_t v48 = type;
            if (os_log_type_enabled(v41, type))
            {
              if (v35 > 5) {
                os_log_type_t v49 = "unknown-mode";
              }
              else {
                os_log_type_t v49 = off_1E523FB08[v35];
              }
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              __int16 v97 = 2082;
              uint64_t v98 = (uint64_t)v49;
              __int16 v99 = 2082;
              uint64_t v100 = (uint64_t)"flow";
              _os_log_impl(&dword_1830D4000, v41, v48, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
            }
          }
LABEL_83:
        }
      }
      else
      {
        uint64_t v69 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v96 = "nw_endpoint_handler_get_received_application_byte_count";
        os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v93 = 0;
        if (__nwlog_fault(v40, &type, &v93))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v41 = __nwlog_obj();
            os_log_type_t v70 = type;
            if (os_log_type_enabled(v41, type))
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              _os_log_impl(&dword_1830D4000, v41, v70, "%{public}s called with null handler", buf, 0xCu);
            }
          }
          else if (v93)
          {
            __int16 v81 = (char *)__nw_create_backtrace_string();
            os_log_type_t v41 = __nwlog_obj();
            os_log_type_t v82 = type;
            BOOL v83 = os_log_type_enabled(v41, type);
            if (v81)
            {
              if (v83)
              {
                *(_DWORD *)buf = 136446466;
                v96 = "nw_endpoint_handler_get_received_application_byte_count";
                __int16 v97 = 2082;
                uint64_t v98 = (uint64_t)v81;
                _os_log_impl(&dword_1830D4000, v41, v82, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v81);
              if (!v40) {
                goto LABEL_86;
              }
              goto LABEL_85;
            }
            if (v83)
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              _os_log_impl(&dword_1830D4000, v41, v82, "%{public}s called with null handler, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            os_log_type_t v41 = __nwlog_obj();
            os_log_type_t v91 = type;
            if (os_log_type_enabled(v41, type))
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              _os_log_impl(&dword_1830D4000, v41, v91, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
            }
          }
          goto LABEL_83;
        }
      }
      if (!v40)
      {
LABEL_86:
        uint64_t v37 = 0;
        goto LABEL_87;
      }
LABEL_85:
      free(v40);
      goto LABEL_86;
    }
LABEL_47:
    free(v21);
    goto LABEL_48;
  }
  unsigned int v87 = __nwlog_obj();
  os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v96 = "strict_calloc";
  __int16 v97 = 2048;
  uint64_t v98 = 1;
  __int16 v99 = 2048;
  uint64_t v100 = 184;
  __int16 v88 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v88))
  {
    free(v88);
    goto LABEL_10;
  }
  __break(1u);
}

void sub_18334F8F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_fillout_data_transfer_snapshot(void *a1, uint64_t *a2, void *a3, unsigned char *a4, int a5)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  id v10 = v9;
  if (v9)
  {
    *(void *)__int16 v63 = 0;
    *(void *)&v63[8] = v63;
    *(void *)&v63[16] = 0x2020000000;
    char v64 = 0;
    os_unfair_lock_lock(v9 + 28);
    unint64_t v11 = *(void **)&v10[62]._os_unfair_lock_opaque;
    if (v10[29]._os_unfair_lock_opaque != 2)
    {
      v59[0] = MEMORY[0x1E4F143A8];
      v59[1] = 3221225472;
      v59[2] = __nw_endpoint_handler_fillout_data_transfer_snapshot_block_invoke;
      v59[3] = &unk_1E523F9A0;
      v59[6] = a3;
      v59[7] = a4;
      int v60 = a5;
      v59[4] = v63;
      v59[5] = a2;
      [v11 applyWithHandler:v10 toChildren:v59];
LABEL_33:
      os_unfair_lock_unlock(v10 + 28);
      BOOL v26 = *(unsigned char *)(*(void *)&v63[8] + 24) != 0;
      _Block_object_dispose(v63, 8);
      goto LABEL_34;
    }
    uint64_t v12 = v11;
    id v13 = v12;
    if (v12)
    {
      if (a2)
      {
        if (a3)
        {
          if (a4)
          {
            *a4 = 0;
            uint64_t v14 = v12[101];
            if (v14)
            {
              *a2 = v14;
              *a3 = v12[102];
              if (a5 != 1) {
                goto LABEL_9;
              }
              goto LABEL_24;
            }
            BOOL v16 = (void *)v12[51];
            if (v16)
            {
              uint64_t v17 = v16[3];
              if (v17)
              {
                uint64_t v18 = *(uint64_t (**)(void))(v17 + 224);
                if (v18)
                {
                  id v19 = (void *)v16[5];
                  if (v19 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v21 = v16[11];
                    if (v21) {
                      v16[11] = v21 + 1;
                    }
                    char v20 = -1;
                  }
                  else
                  {
                    char v20 = 0;
                  }
                  *(void *)buf = v16;
                  buf[8] = v20;
                  uint64_t v22 = v18();
                  if (v19 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                  }
                  *a2 = v22;
                  if (v22)
                  {
                    *a4 = 1;
                    if (a5 != 1)
                    {
LABEL_9:
                      if (!a5)
                      {
                        int v15 = v13[206] + 1;
LABEL_26:
                        v13[206] = v15;
                        goto LABEL_27;
                      }
                      goto LABEL_27;
                    }
LABEL_24:
                    int v23 = v13[206];
                    if (v23)
                    {
                      int v15 = v23 - 1;
                      goto LABEL_26;
                    }
LABEL_27:
                    char v24 = 1;
LABEL_32:

                    *(unsigned char *)(*(void *)&v63[8] + 24) = v24;
                    goto LABEL_33;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v25 = (id)gLogObj;
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
                    _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s copy_info() returned NULL", buf, 0xCu);
                  }
                }
              }
            }
LABEL_31:
            char v24 = 0;
            goto LABEL_32;
          }
          os_log_type_t v43 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          uint64_t v33 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v61 = 0;
          if (!__nwlog_fault((const char *)v33, &type, &v61))
          {
LABEL_85:
            if (v33) {
              free(v33);
            }
            goto LABEL_31;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v34 = __nwlog_obj();
            os_log_type_t v44 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_1830D4000, v34, v44, "%{public}s called with null should_release_snapshot", buf, 0xCu);
            }
LABEL_119:

            goto LABEL_85;
          }
          if (!v61)
          {
            int v34 = __nwlog_obj();
            os_log_type_t v58 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_1830D4000, v34, v58, "%{public}s called with null should_release_snapshot, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_119;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          int v34 = __nwlog_obj();
          os_log_type_t v52 = type;
          BOOL v53 = os_log_type_enabled(v34, type);
          if (!backtrace_string)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_1830D4000, v34, v52, "%{public}s called with null should_release_snapshot, no backtrace", buf, 0xCu);
            }
            goto LABEL_119;
          }
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            __int16 v66 = 2082;
            id v67 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v34, v52, "%{public}s called with null should_release_snapshot, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
        else
        {
          os_log_type_t v41 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          uint64_t v33 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v61 = 0;
          if (!__nwlog_fault((const char *)v33, &type, &v61)) {
            goto LABEL_85;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v34 = __nwlog_obj();
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_1830D4000, v34, v42, "%{public}s called with null snapshot_length", buf, 0xCu);
            }
            goto LABEL_119;
          }
          if (!v61)
          {
            int v34 = __nwlog_obj();
            os_log_type_t v57 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_1830D4000, v34, v57, "%{public}s called with null snapshot_length, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_119;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          int v34 = __nwlog_obj();
          os_log_type_t v50 = type;
          BOOL v51 = os_log_type_enabled(v34, type);
          if (!backtrace_string)
          {
            if (v51)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_1830D4000, v34, v50, "%{public}s called with null snapshot_length, no backtrace", buf, 0xCu);
            }
            goto LABEL_119;
          }
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            __int16 v66 = 2082;
            id v67 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v34, v50, "%{public}s called with null snapshot_length, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
      }
      else
      {
        uint64_t v39 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
        uint64_t v33 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v61 = 0;
        if (!__nwlog_fault((const char *)v33, &type, &v61)) {
          goto LABEL_85;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v34 = __nwlog_obj();
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v34, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            _os_log_impl(&dword_1830D4000, v34, v40, "%{public}s called with null snapshot", buf, 0xCu);
          }
          goto LABEL_119;
        }
        if (!v61)
        {
          int v34 = __nwlog_obj();
          os_log_type_t v56 = type;
          if (os_log_type_enabled(v34, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            _os_log_impl(&dword_1830D4000, v34, v56, "%{public}s called with null snapshot, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_119;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v34 = __nwlog_obj();
        os_log_type_t v48 = type;
        BOOL v49 = os_log_type_enabled(v34, type);
        if (!backtrace_string)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            _os_log_impl(&dword_1830D4000, v34, v48, "%{public}s called with null snapshot, no backtrace", buf, 0xCu);
          }
          goto LABEL_119;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          __int16 v66 = 2082;
          id v67 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v34, v48, "%{public}s called with null snapshot, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
    }
    else
    {
      id v32 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
      uint64_t v33 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v61 = 0;
      if (!__nwlog_fault((const char *)v33, &type, &v61)) {
        goto LABEL_85;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v34 = __nwlog_obj();
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (!v61)
      {
        int v34 = __nwlog_obj();
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          _os_log_impl(&dword_1830D4000, v34, v55, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_119;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v34 = __nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v47 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          _os_log_impl(&dword_1830D4000, v34, v46, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (v47)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
        __int16 v66 = 2082;
        id v67 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v34, v46, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_85;
  }
  id v28 = __nwlog_obj();
  *(_DWORD *)__int16 v63 = 136446210;
  *(void *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
  os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v29, buf, &type))
  {
    if (buf[0] == 17)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = buf[0];
      if (os_log_type_enabled(v30, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v63 = 136446210;
        *(void *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s called with null handler", v63, 0xCu);
      }
    }
    else if (type)
    {
      id v36 = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v37 = buf[0];
      BOOL v38 = os_log_type_enabled(v30, (os_log_type_t)buf[0]);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)__int16 v63 = 136446466;
          *(void *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
          *(_WORD *)&v63[12] = 2082;
          *(void *)&v63[14] = v36;
          _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s called with null handler, dumping backtrace:%{public}s", v63, 0x16u);
        }

        free(v36);
        goto LABEL_93;
      }
      if (v38)
      {
        *(_DWORD *)__int16 v63 = 136446210;
        *(void *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
        _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s called with null handler, no backtrace", v63, 0xCu);
      }
    }
    else
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v54 = buf[0];
      if (os_log_type_enabled(v30, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v63 = 136446210;
        *(void *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
        _os_log_impl(&dword_1830D4000, v30, v54, "%{public}s called with null handler, backtrace limit exceeded", v63, 0xCu);
      }
    }
  }
LABEL_93:
  if (v29) {
    free(v29);
  }
  BOOL v26 = 0;
LABEL_34:

  return v26;
}

void nw_data_transfer_update_path_report_begin(nw_data_transfer_path_report *a1, nw_data_transfer_snapshot *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_data_transfer_update_path_report_begin";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v5, &type, &v15)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_data_transfer_update_path_report_begin";
        unint64_t v8 = "%{public}s called with null path_report";
LABEL_36:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_data_transfer_update_path_report_begin";
          __int16 v19 = 2082;
          char v20 = (nw_data_transfer_path_report *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null path_report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5) {
          return;
        }
LABEL_39:
        free(v5);
        return;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_data_transfer_update_path_report_begin";
        unint64_t v8 = "%{public}s called with null path_report, no backtrace";
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_data_transfer_update_path_report_begin";
        unint64_t v8 = "%{public}s called with null path_report, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    if (gLogDatapath)
    {
      id v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v18 = "nw_data_transfer_update_path_report_begin";
        __int16 v19 = 2048;
        char v20 = a1;
        __int16 v21 = 2048;
        uint64_t v22 = a2;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s updating path report %p with beginning snapshot %p", buf, 0x20u);
      }
    }
    *(_OWORD *)&a1->incremental.received_ip_packet_count = *(_OWORD *)&a2->var1;
    *(_OWORD *)&a1->incremental.received_ip_ect0_packet_count = *(_OWORD *)&a2->var3;
    *(_OWORD *)&a1->incremental.sent_ip_packet_count = *(_OWORD *)&a2->var5;
    *(_OWORD *)&a1->incremental.received_transport_duplicate_byte_count = *(_OWORD *)&a2->var7;
    *(_OWORD *)&a1->incremental.sent_transport_byte_count = *(_OWORD *)&a2->var9;
    *(_OWORD *)&a1->incremental.sent_transport_ecn_capable_packet_count = *(_OWORD *)&a2->var11;
    *(_OWORD *)&a1->incremental.sent_transport_ecn_capable_marked_packet_count = *(_OWORD *)&a2->var13;
    *(_OWORD *)&a1->incremental.received_application_byte_count = *(_OWORD *)&a2->var21;
    *(_OWORD *)&a1->total.transport_smoothed_rtt_milliseconds = *(_OWORD *)&a2->var15;
    *(_OWORD *)&a1->total.transport_current_rtt_milliseconds = *(_OWORD *)&a2->var17;
    *(_OWORD *)&a1->total.transport_congestion_window = *(_OWORD *)&a2->var19;
    return;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v18 = "nw_data_transfer_update_path_report_begin";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v5, &type, &v15)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_data_transfer_update_path_report_begin";
      unint64_t v8 = "%{public}s called with null snapshot";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if (!v15)
  {
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_data_transfer_update_path_report_begin";
      unint64_t v8 = "%{public}s called with null snapshot, backtrace limit exceeded";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  id v13 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v14 = os_log_type_enabled(v6, type);
  if (!v13)
  {
    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_data_transfer_update_path_report_begin";
      unint64_t v8 = "%{public}s called with null snapshot, no backtrace";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v18 = "nw_data_transfer_update_path_report_begin";
    __int16 v19 = 2082;
    char v20 = (nw_data_transfer_path_report *)v13;
    _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null snapshot, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v5) {
    goto LABEL_39;
  }
}

uint64_t __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(_DWORD *)(*(void *)(result + 32) + 52) == 2;
  return result;
}

uint64_t ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_3(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(_DWORD *)(v1 + 52) == 2 && (*(unsigned char *)(v1 + 424) & 1) == 0) {
    *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = 0;
  }
  return result;
}

void ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_238(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 24);
  *(void *)(v2 + 24) = 0;

  *(_DWORD *)(*(void *)(a1 + 32) + 52) = 2;
  *(unsigned char *)(*(void *)(a1 + 32) + 424) &= ~1u;
}

uint64_t *nw_frame_array_prepend(uint64_t *result, int a2, uint64_t a3)
{
  uint64_t v3 = result + 1;
  uint64_t v4 = *result;
  if (a2)
  {
    *(void *)(a3 + 32) = v4;
    uint64_t v5 = a3 + 32;
    uint64_t v6 = (void *)(v4 + 40);
  }
  else
  {
    *(void *)(a3 + 16) = v4;
    uint64_t v5 = a3 + 16;
    uint64_t v6 = (void *)(v4 + 24);
  }
  if (v4) {
    uint64_t v3 = v6;
  }
  void *v3 = v5;
  *BOOL result = a3;
  *(void *)(v5 + 8) = result;
  return result;
}

void nw_protocol_implementation_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v148 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    uint64_t v5 = p_output_handler;
    uint64_t v6 = (void **)v5;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      __int16 v75 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v141 = "nw_protocol_implementation_disconnect";
      os_log_type_t v76 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (!__nwlog_fault(v76, type, &v136)) {
        goto LABEL_307;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v78 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v78, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if ((_BYTE)v136)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v77 = __nwlog_obj();
        os_log_type_t v94 = type[0];
        BOOL v95 = os_log_type_enabled(v77, type[0]);
        if (backtrace_string)
        {
          if (v95)
          {
            *(_DWORD *)buf = 136446466;
            id v141 = "nw_protocol_implementation_disconnect";
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)backtrace_string;
            _os_log_impl(&dword_1830D4000, v77, v94, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_307:
          if (!v76) {
            goto LABEL_129;
          }
          goto LABEL_308;
        }
        if (v95)
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v94, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v115 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v115, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }
LABEL_306:

      goto LABEL_307;
    }
    os_log_type_t v7 = (void *)*((void *)v5 + 1);
    if (!v7)
    {
      os_log_type_t v79 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v141 = "nw_protocol_implementation_disconnect";
      os_log_type_t v76 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (!__nwlog_fault(v76, type, &v136)) {
        goto LABEL_307;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v80 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v80, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }
        goto LABEL_306;
      }
      if (!(_BYTE)v136)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v116 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v116, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_306;
      }
      v96 = (char *)__nw_create_backtrace_string();
      BOOL v77 = __nwlog_obj();
      os_log_type_t v97 = type[0];
      BOOL v98 = os_log_type_enabled(v77, type[0]);
      if (!v96)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v97, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_306;
      }
      if (v98)
      {
        *(_DWORD *)buf = 136446466;
        id v141 = "nw_protocol_implementation_disconnect";
        __int16 v142 = 2082;
        uint64_t v143 = (nw_protocol *)v96;
        _os_log_impl(&dword_1830D4000, v77, v97, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_274;
    }
    if (!v7[10])
    {
      __int16 v81 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v141 = "nw_protocol_implementation_disconnect";
      os_log_type_t v76 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (!__nwlog_fault(v76, type, &v136)) {
        goto LABEL_307;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v82 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v82, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
        }
        goto LABEL_306;
      }
      if (!(_BYTE)v136)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v117 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v117, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_306;
      }
      v96 = (char *)__nw_create_backtrace_string();
      BOOL v77 = __nwlog_obj();
      os_log_type_t v99 = type[0];
      BOOL v100 = os_log_type_enabled(v77, type[0]);
      if (!v96)
      {
        if (v100)
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v77, v99, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
        }
        goto LABEL_306;
      }
      if (v100)
      {
        *(_DWORD *)buf = 136446466;
        id v141 = "nw_protocol_implementation_disconnect";
        __int16 v142 = 2082;
        uint64_t v143 = (nw_protocol *)v96;
        _os_log_impl(&dword_1830D4000, v77, v99, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_274;
    }
    if ((v5[405] & 0x80000000) == 0 && gLogDatapath)
    {
      BOOL v83 = __nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        id v141 = "nw_protocol_implementation_disconnect";
        __int16 v142 = 2082;
        uint64_t v143 = (nw_protocol *)((char *)v6 + 407);
        __int16 v144 = 2080;
        v145 = (nw_protocol *)" ";
        _os_log_impl(&dword_1830D4000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDisconnect from input handler", buf, 0x20u);
      }

      os_log_type_t v7 = v6[1];
    }
    int v8 = *((_DWORD *)v7 + 16);
    if (v8 != 2)
    {
      if (v8 == 3)
      {
        uint64_t v9 = *(uint64_t (**)(void **, uint64_t, uint64_t))(v7[10] + 128);
        if (v9)
        {
          id v10 = v6;
          if (nw_protocol_definition_get_message_is_stream(v6[1]) && *(v10 - 6) == a2) {
            uint64_t v11 = -2;
          }
          else {
            uint64_t v11 = (uint64_t)a2;
          }

          if ((v9(v10, v11, 3) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v12 = (id)gLogObj;
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
            {
              id v13 = v10;
              if (nw_protocol_definition_get_message_is_stream(v6[1]) && *(v13 - 6) == a2) {
                uint64_t v14 = -2;
              }
              else {
                uint64_t v14 = (uint64_t)a2;
              }

              *(_DWORD *)buf = 136446466;
              id v141 = "nw_protocol_implementation_disconnect";
              __int16 v142 = 2048;
              uint64_t v143 = (nw_protocol *)v14;
              _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Flow %llx deferred stop, holding disconnected", buf, 0x16u);
            }

            if (a2)
            {
              if (a2->output_handler_context) {
                goto LABEL_129;
              }
LABEL_23:
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v15 = (id)gLogObj;
              *(_DWORD *)buf = 136446466;
              id v141 = "nw_protocol_implementation_disconnect";
              __int16 v142 = 2048;
              uint64_t v143 = a2;
              BOOL v16 = (const char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v136) = 0;
              if (!__nwlog_fault(v16, type, &v136)) {
                goto LABEL_138;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                uint64_t v17 = __nwlog_obj();
                os_log_type_t v18 = type[0];
                if (os_log_type_enabled(v17, type[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  id v141 = "nw_protocol_implementation_disconnect";
                  __int16 v142 = 2048;
                  uint64_t v143 = a2;
                  _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Output handler context doesn't exist on protocol %p", buf, 0x16u);
                }
              }
              else if ((_BYTE)v136)
              {
                os_log_type_t v42 = (char *)__nw_create_backtrace_string();
                uint64_t v17 = __nwlog_obj();
                os_log_type_t v43 = type[0];
                BOOL v44 = os_log_type_enabled(v17, type[0]);
                if (v42)
                {
                  if (v44)
                  {
                    *(_DWORD *)buf = 136446722;
                    id v141 = "nw_protocol_implementation_disconnect";
                    __int16 v142 = 2048;
                    uint64_t v143 = a2;
                    __int16 v144 = 2082;
                    v145 = (nw_protocol *)v42;
                    _os_log_impl(&dword_1830D4000, v17, v43, "%{public}s Output handler context doesn't exist on protocol %p, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(v42);
LABEL_138:
                  if (v16)
                  {
                    char v64 = (char *)v16;
LABEL_140:
                    free(v64);
                  }
LABEL_129:

                  return;
                }
                if (v44)
                {
                  *(_DWORD *)buf = 136446466;
                  id v141 = "nw_protocol_implementation_disconnect";
                  __int16 v142 = 2048;
                  uint64_t v143 = a2;
                  _os_log_impl(&dword_1830D4000, v17, v43, "%{public}s Output handler context doesn't exist on protocol %p, no backtrace", buf, 0x16u);
                }
              }
              else
              {
                uint64_t v17 = __nwlog_obj();
                os_log_type_t v63 = type[0];
                if (os_log_type_enabled(v17, type[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  id v141 = "nw_protocol_implementation_disconnect";
                  __int16 v142 = 2048;
                  uint64_t v143 = a2;
                  _os_log_impl(&dword_1830D4000, v17, v63, "%{public}s Output handler context doesn't exist on protocol %p, backtrace limit exceeded", buf, 0x16u);
                }
              }

              goto LABEL_138;
            }
            id v122 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            id v141 = "__nw_protocol_get_output_handler_context";
            id v123 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v136) = 0;
            if (__nwlog_fault(v123, type, &v136))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v124 = __nwlog_obj();
                os_log_type_t v125 = type[0];
                if (os_log_type_enabled(v124, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  id v141 = "__nw_protocol_get_output_handler_context";
                  _os_log_impl(&dword_1830D4000, v124, v125, "%{public}s called with null protocol", buf, 0xCu);
                }
              }
              else if ((_BYTE)v136)
              {
                BOOL v129 = (char *)__nw_create_backtrace_string();
                os_log_type_t v124 = __nwlog_obj();
                os_log_type_t v130 = type[0];
                BOOL v131 = os_log_type_enabled(v124, type[0]);
                if (v129)
                {
                  if (v131)
                  {
                    *(_DWORD *)buf = 136446466;
                    id v141 = "__nw_protocol_get_output_handler_context";
                    __int16 v142 = 2082;
                    uint64_t v143 = (nw_protocol *)v129;
                    _os_log_impl(&dword_1830D4000, v124, v130, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v129);
                  goto LABEL_315;
                }
                if (v131)
                {
                  *(_DWORD *)buf = 136446210;
                  id v141 = "__nw_protocol_get_output_handler_context";
                  _os_log_impl(&dword_1830D4000, v124, v130, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                os_log_type_t v124 = __nwlog_obj();
                os_log_type_t v133 = type[0];
                if (os_log_type_enabled(v124, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  id v141 = "__nw_protocol_get_output_handler_context";
                  _os_log_impl(&dword_1830D4000, v124, v133, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_315:
            if (v123) {
              free(v123);
            }
            goto LABEL_23;
          }
          goto LABEL_82;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v24 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        id v141 = "nw_protocol_implementation_disconnect";
        uint64_t v25 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v136) = 0;
        if (__nwlog_fault(v25, type, &v136))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v26 = (id)gLogObj;
            os_log_type_t v27 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v141 = "nw_protocol_implementation_disconnect";
              _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null instance->parent_definition->stop", buf, 0xCu);
            }
          }
          else if ((_BYTE)v136)
          {
            BOOL v30 = __nw_create_backtrace_string();
            if (v30)
            {
              os_log_type_t v31 = (nw_protocol *)v30;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v32 = (id)gLogObj;
              os_log_type_t v33 = type[0];
              if (os_log_type_enabled(v32, type[0]))
              {
                *(_DWORD *)buf = 136446466;
                id v141 = "nw_protocol_implementation_disconnect";
                __int16 v142 = 2082;
                uint64_t v143 = v31;
                _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v31);
              if (!v25) {
                goto LABEL_82;
              }
              goto LABEL_81;
            }
            BOOL v26 = __nwlog_obj();
            os_log_type_t v46 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v141 = "nw_protocol_implementation_disconnect";
              _os_log_impl(&dword_1830D4000, v26, v46, "%{public}s called with null instance->parent_definition->stop, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v26 = (id)gLogObj;
            os_log_type_t v40 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v141 = "nw_protocol_implementation_disconnect";
              _os_log_impl(&dword_1830D4000, v26, v40, "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        if (!v25)
        {
LABEL_82:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v47 = (id)gLogObj;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v48 = v6;
            if (nw_protocol_definition_get_message_is_stream(v6[1]) && *(v48 - 6) == a2) {
              uint64_t v49 = -2;
            }
            else {
              uint64_t v49 = (uint64_t)a2;
            }

            *(_DWORD *)buf = 136446466;
            id v141 = "nw_protocol_implementation_disconnect";
            __int16 v142 = 2048;
            uint64_t v143 = (nw_protocol *)v49;
            _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_DEBUG, "%{public}s Flow %llx stopping immediately, sending disconnected", buf, 0x16u);
          }

          if (a2)
          {
            if (a2->handle == &nw_protocol_ref_counted_handle)
            {
              callbacks = a2[1].callbacks;
              if (callbacks) {
                a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
              }
              *(void *)os_log_type_t type = a2;
              char v50 = v139 | 1;
            }
            else
            {
              *(void *)os_log_type_t type = a2;
              char v50 = v139 & 0xFE;
            }
            char v139 = v50;
            if (*(v6 - 7) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v53 = (uint64_t)*(v6 - 1);
              if (v53) {
                *(v6 - 1) = (void *)(v53 + 1);
              }
              char v52 = -1;
            }
            else
            {
              char v52 = 0;
            }
            BOOL v136 = v6 - 12;
            char v137 = v52;
            os_log_type_t v54 = a2->callbacks;
            if (v54)
            {
              disconnected = (void (*)(nw_protocol *, void **))v54->disconnected;
              if (disconnected)
              {
                disconnected(a2, v6 - 12);
                char v52 = v137;
                goto LABEL_101;
              }
            }
            __int16 v101 = __nwlog_obj();
            identifier = a2->identifier;
            *(_DWORD *)buf = 136446722;
            id v141 = "__nw_protocol_disconnected";
            if (!identifier) {
              identifier = (nw_protocol_identifier *)"invalid";
            }
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)identifier;
            __int16 v144 = 2048;
            v145 = a2;
            id v67 = (void *)_os_log_send_and_compose_impl();

            os_log_type_t v135 = OS_LOG_TYPE_ERROR;
            char v134 = 0;
            if (!__nwlog_fault((const char *)v67, &v135, &v134))
            {
LABEL_294:
              if (v67) {
                free(v67);
              }
LABEL_101:
              if ((v52 & 1) == 0)
              {
LABEL_127:
                if (v139) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                }
                goto LABEL_129;
              }
LABEL_126:
              nw::release_if_needed<nw_protocol *>((uint64_t *)&v136);
              goto LABEL_127;
            }
            if (v135 == OS_LOG_TYPE_FAULT)
            {
              uint64_t v68 = __nwlog_obj();
              os_log_type_t v103 = v135;
              if (os_log_type_enabled(v68, v135))
              {
                v104 = a2->identifier;
                if (!v104) {
                  v104 = (nw_protocol_identifier *)"invalid";
                }
                *(_DWORD *)buf = 136446722;
                id v141 = "__nw_protocol_disconnected";
                __int16 v142 = 2082;
                uint64_t v143 = (nw_protocol *)v104;
                __int16 v144 = 2048;
                v145 = a2;
                _os_log_impl(&dword_1830D4000, v68, v103, "%{public}s protocol %{public}s (%p) has invalid disconnected callback", buf, 0x20u);
              }
LABEL_293:

              goto LABEL_294;
            }
            if (!v134)
            {
              uint64_t v68 = __nwlog_obj();
              os_log_type_t v126 = v135;
              if (os_log_type_enabled(v68, v135))
              {
                nw_endpoint_t v127 = a2->identifier;
                if (!v127) {
                  nw_endpoint_t v127 = (nw_protocol_identifier *)"invalid";
                }
                *(_DWORD *)buf = 136446722;
                id v141 = "__nw_protocol_disconnected";
                __int16 v142 = 2082;
                uint64_t v143 = (nw_protocol *)v127;
                __int16 v144 = 2048;
                v145 = a2;
                _os_log_impl(&dword_1830D4000, v68, v126, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded", buf, 0x20u);
              }
              goto LABEL_293;
            }
            BOOL v86 = (char *)__nw_create_backtrace_string();
            uint64_t v68 = __nwlog_obj();
            os_log_type_t v111 = v135;
            BOOL v112 = os_log_type_enabled(v68, v135);
            if (!v86)
            {
              if (v112)
              {
                uint64_t v128 = a2->identifier;
                if (!v128) {
                  uint64_t v128 = (nw_protocol_identifier *)"invalid";
                }
                *(_DWORD *)buf = 136446722;
                id v141 = "__nw_protocol_disconnected";
                __int16 v142 = 2082;
                uint64_t v143 = (nw_protocol *)v128;
                __int16 v144 = 2048;
                v145 = a2;
                _os_log_impl(&dword_1830D4000, v68, v111, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace", buf, 0x20u);
              }
              goto LABEL_293;
            }
            if (v112)
            {
              BOOL v113 = a2->identifier;
              if (!v113) {
                BOOL v113 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446978;
              id v141 = "__nw_protocol_disconnected";
              __int16 v142 = 2082;
              uint64_t v143 = (nw_protocol *)v113;
              __int16 v144 = 2048;
              v145 = a2;
              __int16 v146 = 2082;
              v147 = v86;
              _os_log_impl(&dword_1830D4000, v68, v111, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
LABEL_235:

            free(v86);
            goto LABEL_294;
          }
          BOOL v109 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          id v141 = "__nw_protocol_disconnected";
          os_log_type_t v76 = (const char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v136) = 0;
          if (!__nwlog_fault(v76, type, &v136)) {
            goto LABEL_307;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            BOOL v77 = __nwlog_obj();
            os_log_type_t v110 = type[0];
            if (os_log_type_enabled(v77, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v141 = "__nw_protocol_disconnected";
              _os_log_impl(&dword_1830D4000, v77, v110, "%{public}s called with null protocol", buf, 0xCu);
            }
            goto LABEL_306;
          }
          if (!(_BYTE)v136)
          {
            BOOL v77 = __nwlog_obj();
            os_log_type_t v132 = type[0];
            if (os_log_type_enabled(v77, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v141 = "__nw_protocol_disconnected";
              _os_log_impl(&dword_1830D4000, v77, v132, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_306;
          }
          v96 = (char *)__nw_create_backtrace_string();
          BOOL v77 = __nwlog_obj();
          os_log_type_t v120 = type[0];
          BOOL v121 = os_log_type_enabled(v77, type[0]);
          if (!v96)
          {
            if (v121)
            {
              *(_DWORD *)buf = 136446210;
              id v141 = "__nw_protocol_disconnected";
              _os_log_impl(&dword_1830D4000, v77, v120, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
            }
            goto LABEL_306;
          }
          if (v121)
          {
            *(_DWORD *)buf = 136446466;
            id v141 = "__nw_protocol_disconnected";
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)v96;
            _os_log_impl(&dword_1830D4000, v77, v120, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
LABEL_274:

          free(v96);
          if (!v76) {
            goto LABEL_129;
          }
LABEL_308:
          char v64 = (char *)v76;
          goto LABEL_140;
        }
LABEL_81:
        free(v25);
        goto LABEL_82;
      }
LABEL_112:
      if (a2)
      {
        if (a2->handle == &nw_protocol_ref_counted_handle)
        {
          BOOL v59 = a2[1].callbacks;
          if (v59) {
            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v59->add_input_handler + 1);
          }
          char v58 = -1;
        }
        else
        {
          char v58 = 0;
        }
        *(void *)os_log_type_t type = a2;
        char v139 = v58;
        if (*(v6 - 7) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v60 = (uint64_t)*(v6 - 1);
          if (v60) {
            *(v6 - 1) = (void *)(v60 + 1);
          }
          char v52 = -1;
        }
        else
        {
          char v52 = 0;
        }
        BOOL v136 = v6 - 12;
        char v137 = v52;
        char v61 = a2->callbacks;
        if (v61)
        {
          BOOL v62 = (void (*)(nw_protocol *, void **))v61->disconnected;
          if (v62)
          {
            v62(a2, v6 - 12);
            if ((v137 & 1) == 0) {
              goto LABEL_127;
            }
            goto LABEL_126;
          }
        }
        id v65 = __nwlog_obj();
        __int16 v66 = a2->identifier;
        *(_DWORD *)buf = 136446722;
        id v141 = "__nw_protocol_disconnected";
        if (!v66) {
          __int16 v66 = (nw_protocol_identifier *)"invalid";
        }
        __int16 v142 = 2082;
        uint64_t v143 = (nw_protocol *)v66;
        __int16 v144 = 2048;
        v145 = a2;
        id v67 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t v135 = OS_LOG_TYPE_ERROR;
        char v134 = 0;
        if (!__nwlog_fault((const char *)v67, &v135, &v134)) {
          goto LABEL_294;
        }
        if (v135 == OS_LOG_TYPE_FAULT)
        {
          uint64_t v68 = __nwlog_obj();
          os_log_type_t v69 = v135;
          if (os_log_type_enabled(v68, v135))
          {
            os_log_type_t v70 = a2->identifier;
            if (!v70) {
              os_log_type_t v70 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446722;
            id v141 = "__nw_protocol_disconnected";
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)v70;
            __int16 v144 = 2048;
            v145 = a2;
            _os_log_impl(&dword_1830D4000, v68, v69, "%{public}s protocol %{public}s (%p) has invalid disconnected callback", buf, 0x20u);
          }
          goto LABEL_293;
        }
        if (!v134)
        {
          uint64_t v68 = __nwlog_obj();
          os_log_type_t v107 = v135;
          if (os_log_type_enabled(v68, v135))
          {
            unsigned int v108 = a2->identifier;
            if (!v108) {
              unsigned int v108 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446722;
            id v141 = "__nw_protocol_disconnected";
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)v108;
            __int16 v144 = 2048;
            v145 = a2;
            _os_log_impl(&dword_1830D4000, v68, v107, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded", buf, 0x20u);
          }
          goto LABEL_293;
        }
        BOOL v86 = (char *)__nw_create_backtrace_string();
        uint64_t v68 = __nwlog_obj();
        os_log_type_t v87 = v135;
        BOOL v88 = os_log_type_enabled(v68, v135);
        if (!v86)
        {
          if (v88)
          {
            nw_endpoint_t v118 = a2->identifier;
            if (!v118) {
              nw_endpoint_t v118 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446722;
            id v141 = "__nw_protocol_disconnected";
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)v118;
            __int16 v144 = 2048;
            v145 = a2;
            _os_log_impl(&dword_1830D4000, v68, v87, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace", buf, 0x20u);
          }
          goto LABEL_293;
        }
        if (v88)
        {
          os_log_type_t v89 = a2->identifier;
          if (!v89) {
            os_log_type_t v89 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446978;
          id v141 = "__nw_protocol_disconnected";
          __int16 v142 = 2082;
          uint64_t v143 = (nw_protocol *)v89;
          __int16 v144 = 2048;
          v145 = a2;
          __int16 v146 = 2082;
          v147 = v86;
          _os_log_impl(&dword_1830D4000, v68, v87, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        goto LABEL_235;
      }
      char v84 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v141 = "__nw_protocol_disconnected";
      os_log_type_t v76 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (!__nwlog_fault(v76, type, &v136)) {
        goto LABEL_307;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v85 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "__nw_protocol_disconnected";
          _os_log_impl(&dword_1830D4000, v77, v85, "%{public}s called with null protocol", buf, 0xCu);
        }
        goto LABEL_306;
      }
      if (!(_BYTE)v136)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v119 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "__nw_protocol_disconnected";
          _os_log_impl(&dword_1830D4000, v77, v119, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_306;
      }
      v96 = (char *)__nw_create_backtrace_string();
      BOOL v77 = __nwlog_obj();
      os_log_type_t v105 = type[0];
      BOOL v106 = os_log_type_enabled(v77, type[0]);
      if (!v96)
      {
        if (v106)
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "__nw_protocol_disconnected";
          _os_log_impl(&dword_1830D4000, v77, v105, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
        goto LABEL_306;
      }
      if (v106)
      {
        *(_DWORD *)buf = 136446466;
        id v141 = "__nw_protocol_disconnected";
        __int16 v142 = 2082;
        uint64_t v143 = (nw_protocol *)v96;
        _os_log_impl(&dword_1830D4000, v77, v105, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_274;
    }
    __int16 v19 = *(uint64_t (**)(void **, uint64_t, uint64_t))(v7[10] + 128);
    if (v19)
    {
      if (v19(v6, -1, 3)) {
        goto LABEL_112;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      id v141 = "nw_protocol_implementation_disconnect";
      __int16 v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (!__nwlog_fault(v21, type, &v136)) {
        goto LABEL_110;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW", buf, 0xCu);
        }
LABEL_109:

LABEL_110:
        if (!v21) {
          goto LABEL_112;
        }
LABEL_111:
        free(v21);
        goto LABEL_112;
      }
      if (!(_BYTE)v136)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v45 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v22, v45, "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_109;
      }
      BOOL v38 = __nw_create_backtrace_string();
      if (!v38)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v57 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v22, v57, "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, no backtrace", buf, 0xCu);
        }
        goto LABEL_109;
      }
      os_log_type_t v35 = (nw_protocol *)v38;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v36 = (id)gLogObj;
      os_log_type_t v39 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        id v141 = "nw_protocol_implementation_disconnect";
        __int16 v142 = 2082;
        uint64_t v143 = v35;
        _os_log_impl(&dword_1830D4000, v36, v39, "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      id v141 = "nw_protocol_implementation_disconnect";
      __int16 v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (!__nwlog_fault(v21, type, &v136)) {
        goto LABEL_110;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (id)gLogObj;
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s called with null instance->parent_definition->stop", buf, 0xCu);
        }
        goto LABEL_109;
      }
      if (!(_BYTE)v136)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (id)gLogObj;
        os_log_type_t v41 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v22, v41, "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_109;
      }
      int v34 = __nw_create_backtrace_string();
      if (!v34)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v56 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_1830D4000, v22, v56, "%{public}s called with null instance->parent_definition->stop, no backtrace", buf, 0xCu);
        }
        goto LABEL_109;
      }
      os_log_type_t v35 = (nw_protocol *)v34;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v36 = (id)gLogObj;
      os_log_type_t v37 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        id v141 = "nw_protocol_implementation_disconnect";
        __int16 v142 = 2082;
        uint64_t v143 = v35;
        _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v35);
    if (!v21) {
      goto LABEL_112;
    }
    goto LABEL_111;
  }
  os_log_type_t v71 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v141 = "nw_protocol_implementation_disconnect";
  os_log_type_t v72 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v136) = 0;
  if (__nwlog_fault(v72, type, &v136))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v73 = __nwlog_obj();
      os_log_type_t v74 = type[0];
      if (os_log_type_enabled(v73, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v141 = "nw_protocol_implementation_disconnect";
        _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if ((_BYTE)v136)
    {
      os_log_type_t v90 = (char *)__nw_create_backtrace_string();
      os_log_type_t v73 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v92 = os_log_type_enabled(v73, type[0]);
      if (v90)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          id v141 = "nw_protocol_implementation_disconnect";
          __int16 v142 = 2082;
          uint64_t v143 = (nw_protocol *)v90;
          _os_log_impl(&dword_1830D4000, v73, v91, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v90);
        goto LABEL_259;
      }
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        id v141 = "nw_protocol_implementation_disconnect";
        _os_log_impl(&dword_1830D4000, v73, v91, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v73 = __nwlog_obj();
      os_log_type_t v114 = type[0];
      if (os_log_type_enabled(v73, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v141 = "nw_protocol_implementation_disconnect";
        _os_log_impl(&dword_1830D4000, v73, v114, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_259:
  if (v72) {
    free(v72);
  }
}

void sub_183352E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
  if (a16) {
    nw::release_if_needed<nw_protocol *>(&a15);
  }
  if (a18) {
    nw::release_if_needed<nw_protocol *>(&a17);
  }

  _Unwind_Resume(a1);
}

void nw_flow_passthrough_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = (id *)a1->handle;
    id v4 = handle[20];
    uint64_t v5 = v4;
    if (v4)
    {
      uint64_t v6 = (NWConcrete_nw_endpoint_handler *)v4;
      uint64_t mode = v6->mode;

      if (mode != 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v28 = (id)gLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          if (mode > 5) {
            os_log_type_t v29 = "unknown-mode";
          }
          else {
            os_log_type_t v29 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          BOOL v113 = "nw_flow_passthrough_disconnected";
          __int16 v114 = 2082;
          id_str = (void *)v29;
          __int16 v116 = 2082;
          os_log_type_t v117 = "flow";
          _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }

        goto LABEL_55;
      }
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        callbacks = default_input_handler->callbacks;
        if (callbacks)
        {
          disconnected = (void (*)(void))callbacks->disconnected;
          if (disconnected) {
            disconnected();
          }
        }
      }
      *((_WORD *)handle + 166) |= 0x210u;
      uint64_t v11 = nw_endpoint_handler_copy_flow(v6);
      v104 = v11;
      if (handle == (id *)((char *)v11 + 376))
      {
        id v30 = handle[40];
        if (v30)
        {
          os_log_type_t v31 = v30;
          int v32 = v31[3];

          if (v32 == 35)
          {
            os_log_type_t v33 = a1->default_input_handler;
            if (v33)
            {
              name = v33->identifier->name;
              if (name)
              {
                if (!strcmp(name, "flow_replay"))
                {
                  uint64_t v35 = (uint64_t)v33->default_input_handler;
                  if (v35)
                  {
                    if (!nw_protocol_input_handler_is_connection_flow(v35))
                    {
                      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                      char logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                      if (minimize_logging)
                      {
                        if (logging_disabled) {
                          goto LABEL_37;
                        }
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        BOOL v38 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                        {
                          id_string = nw_endpoint_handler_get_id_string(v6);
                          logb = nw_endpoint_handler_dry_run_string(v6);
                          nw_endpoint_t v96 = nw_endpoint_handler_copy_endpoint(v6);
                          logging_description = nw_endpoint_get_logging_description(v96);
                          BOOL v98 = nw_endpoint_handler_state_string(v6);
                          os_log_type_t v99 = nw_endpoint_handler_mode_string(v6);
                          id v100 = nw_endpoint_handler_copy_current_path(v6);
                          *(_DWORD *)buf = 136447746;
                          BOOL v113 = "nw_flow_passthrough_disconnected";
                          __int16 v114 = 2082;
                          id_str = (void *)id_string;
                          __int16 v116 = 2082;
                          os_log_type_t v117 = logb;
                          __int16 v118 = 2082;
                          os_log_type_t v119 = logging_description;
                          __int16 v120 = 2082;
                          BOOL v121 = v98;
                          __int16 v122 = 2082;
                          id v123 = v99;
                          __int16 v124 = 2114;
                          id v125 = v100;
                          _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received EAGAIN, rebuilding stack", buf, 0x48u);
                        }
                      }
                      else
                      {
                        if (logging_disabled)
                        {
LABEL_37:
                          os_log_type_t v46 = v104;
                          nw_endpoint_flow_rebuild_stack(v6, a1);
                          v6->event = (nw_endpoint_handler_event_s)262147;
                          nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
LABEL_54:

LABEL_55:
                          return;
                        }
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        BOOL v38 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
                        {
                          log = v38;
                          os_log_type_t v39 = nw_endpoint_handler_get_id_string(v6);
                          os_log_type_t v40 = nw_endpoint_handler_dry_run_string(v6);
                          nw_endpoint_t v41 = nw_endpoint_handler_copy_endpoint(v6);
                          os_log_type_t v42 = nw_endpoint_get_logging_description(v41);
                          os_log_type_t v43 = nw_endpoint_handler_state_string(v6);
                          BOOL v44 = nw_endpoint_handler_mode_string(v6);
                          id v45 = nw_endpoint_handler_copy_current_path(v6);
                          *(_DWORD *)buf = 136447746;
                          BOOL v113 = "nw_flow_passthrough_disconnected";
                          __int16 v114 = 2082;
                          id_str = (void *)v39;
                          __int16 v116 = 2082;
                          os_log_type_t v117 = v40;
                          __int16 v118 = 2082;
                          os_log_type_t v119 = v42;
                          __int16 v120 = 2082;
                          BOOL v121 = v43;
                          __int16 v122 = 2082;
                          id v123 = v44;
                          __int16 v124 = 2114;
                          id v125 = v45;
                          BOOL v38 = log;
                          _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received EAGAIN, rebuilding stack", buf, 0x48u);
                        }
                      }

                      goto LABEL_37;
                    }
                  }
                }
              }
            }
          }
        }
      }
      BOOL v12 = v11;
      id v13 = v12;
      if (v12)
      {
        uint64_t v14 = *((void *)v12 + 53);

        if (!v14)
        {
          id v47 = handle[40];
          id v48 = handle[23];
          v105[0] = MEMORY[0x1E4F143A8];
          v105[1] = 3221225472;
          v105[2] = ___ZL32nw_flow_passthrough_disconnectedP11nw_protocolS0__block_invoke;
          v105[3] = &unk_1E523CC00;
          BOOL v106 = v6;
          BOOL v109 = handle;
          os_log_type_t v107 = v13;
          id v108 = v47;
          id v49 = v47;
          nw_queue_context_async(v48, v105);

LABEL_53:
          os_log_type_t v46 = v104;
          goto LABEL_54;
        }
LABEL_11:
        id v15 = v6;
        BOOL v16 = (*((unsigned char *)v15 + 268) & 0x20) == 0;

        if (v16)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v17 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v18 = v15;

            __int16 v19 = v18;
            BOOL v20 = (*((unsigned char *)v15 + 268) & 1) == 0;

            if (v20) {
              __int16 v21 = "";
            }
            else {
              __int16 v21 = "dry-run ";
            }
            nw_endpoint_t v22 = nw_endpoint_handler_copy_endpoint(v19);
            os_log_type_t v23 = nw_endpoint_get_logging_description(v22);
            id v24 = v19;
            uint64_t v25 = v24;
            uint64_t v26 = v24[30];
            if (v26 > 5) {
              os_log_type_t v27 = "unknown-state";
            }
            else {
              os_log_type_t v27 = off_1E523FB38[v26];
            }

            char v50 = v25;
            BOOL v51 = "path";
            switch(v6->mode)
            {
              case 0:
                break;
              case 1:
                BOOL v51 = "resolver";
                break;
              case 2:
                BOOL v51 = nw_endpoint_flow_mode_string(v50[31]);
                break;
              case 3:
                BOOL v51 = "proxy";
                break;
              case 4:
                BOOL v51 = "fallback";
                break;
              case 5:
                BOOL v51 = "transform";
                break;
              default:
                BOOL v51 = "unknown-mode";
                break;
            }
            loga = v51;

            char v52 = v50;
            uint64_t v53 = v13;
            os_log_type_t v54 = v27;
            os_log_type_t v55 = (id *)v52;
            os_log_type_t v56 = v17;
            os_log_type_t v57 = v18;
            char v58 = v5;
            nw_endpoint_t v59 = v22;
            uint64_t v60 = v23;
            char v61 = v21;
            BOOL v62 = v52 + 28;
            os_unfair_lock_lock(v52 + 28);
            id v63 = v55[8];
            char v64 = v62;
            id v65 = v61;
            __int16 v66 = v60;
            nw_endpoint_t v67 = v59;
            uint64_t v5 = v58;
            uint64_t v68 = v57;
            uint64_t v17 = v56;
            os_log_type_t v69 = v63;
            os_unfair_lock_unlock(v64);

            os_log_type_t v70 = v54;
            id v13 = v53;
            *(_DWORD *)buf = 136447746;
            BOOL v113 = "nw_flow_passthrough_disconnected";
            __int16 v114 = 2082;
            id_str = v68->id_str;
            __int16 v116 = 2082;
            os_log_type_t v117 = v65;
            __int16 v118 = 2082;
            os_log_type_t v119 = v66;
            __int16 v120 = 2082;
            BOOL v121 = v70;
            __int16 v122 = 2082;
            id v123 = loga;
            __int16 v124 = 2114;
            id v125 = v69;
            _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] deferring fail on disconnected", buf, 0x48u);
          }
        }
        *((unsigned char *)v13 + 35) |= 0x80u;
        goto LABEL_53;
      }
      os_log_type_t v85 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      BOOL v113 = "nw_flow_passthrough_should_fail_on_disconnected";
      BOOL v86 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v110 = 0;
      if (__nwlog_fault(v86, &type, &v110))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v87 = __nwlog_obj();
          os_log_type_t v88 = type;
          if (os_log_type_enabled(v87, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v113 = "nw_flow_passthrough_should_fail_on_disconnected";
            _os_log_impl(&dword_1830D4000, v87, v88, "%{public}s called with null endpoint_flow", buf, 0xCu);
          }
        }
        else if (v110)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v87 = __nwlog_obj();
          os_log_type_t v90 = type;
          BOOL v91 = os_log_type_enabled(v87, type);
          if (backtrace_string)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v113 = "nw_flow_passthrough_should_fail_on_disconnected";
              __int16 v114 = 2082;
              id_str = backtrace_string;
              _os_log_impl(&dword_1830D4000, v87, v90, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_109;
          }
          if (v91)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v113 = "nw_flow_passthrough_should_fail_on_disconnected";
            _os_log_impl(&dword_1830D4000, v87, v90, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          os_log_type_t v87 = __nwlog_obj();
          os_log_type_t v94 = type;
          if (os_log_type_enabled(v87, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v113 = "nw_flow_passthrough_should_fail_on_disconnected";
            _os_log_impl(&dword_1830D4000, v87, v94, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_109:
      if (v86) {
        free(v86);
      }
      goto LABEL_11;
    }
    __int16 v75 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v113 = "nw_flow_passthrough_disconnected";
    os_log_type_t v76 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v110 = 0;
    if (__nwlog_fault(v76, &type, &v110))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v78 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_1830D4000, v77, v78, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v110)
      {
        os_log_type_t v82 = (char *)__nw_create_backtrace_string();
        BOOL v77 = __nwlog_obj();
        os_log_type_t v83 = type;
        BOOL v84 = os_log_type_enabled(v77, type);
        if (v82)
        {
          if (v84)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v113 = "nw_flow_passthrough_disconnected";
            __int16 v114 = 2082;
            id_str = v82;
            _os_log_impl(&dword_1830D4000, v77, v83, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v82);
          goto LABEL_101;
        }
        if (v84)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_1830D4000, v77, v83, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v77 = __nwlog_obj();
        os_log_type_t v93 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_1830D4000, v77, v93, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_101:
    if (v76) {
      free(v76);
    }
    goto LABEL_55;
  }
  os_log_type_t v71 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v113 = "nw_flow_passthrough_disconnected";
  os_log_type_t v72 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v110 = 0;
  if (__nwlog_fault(v72, &type, &v110))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v110)
    {
      os_log_type_t v79 = (char *)__nw_create_backtrace_string();
      os_log_type_t v73 = __nwlog_obj();
      os_log_type_t v80 = type;
      BOOL v81 = os_log_type_enabled(v73, type);
      if (v79)
      {
        if (v81)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v113 = "nw_flow_passthrough_disconnected";
          __int16 v114 = 2082;
          id_str = v79;
          _os_log_impl(&dword_1830D4000, v73, v80, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v79);
        goto LABEL_96;
      }
      if (v81)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_1830D4000, v73, v80, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v73 = __nwlog_obj();
      os_log_type_t v92 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_1830D4000, v73, v92, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_96:
  if (v72) {
    free(v72);
  }
}

void sub_183353C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void nw_flow_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  handle = (nw_flow_protocol *)a1->handle;
  uint64_t v3 = handle->handler;
  id v4 = v3;
  if (!v3)
  {
    char v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v90 = "nw_flow_disconnected";
    nw_endpoint_t v59 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v87 = 0;
    if (__nwlog_fault(v59, &type, &v87))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v60 = __nwlog_obj();
        os_log_type_t v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v90 = "nw_flow_disconnected";
          _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v87)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v60 = __nwlog_obj();
        os_log_type_t v63 = type;
        BOOL v64 = os_log_type_enabled(v60, type);
        if (backtrace_string)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v90 = "nw_flow_disconnected";
            __int16 v91 = 2082;
            os_log_type_t v92 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v60, v63, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_70;
        }
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v90 = "nw_flow_disconnected";
          _os_log_impl(&dword_1830D4000, v60, v63, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v60 = __nwlog_obj();
        os_log_type_t v65 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v90 = "nw_flow_disconnected";
          _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_70:
    if (v59) {
      free(v59);
    }
    goto LABEL_53;
  }
  uint64_t v5 = v3;
  uint64_t mode = v5->mode;

  if (mode == 2)
  {
    if ((*((_WORD *)handle + 166) & 0x100) != 0)
    {
      uint64_t v25 = v5;
      char v26 = *((unsigned char *)v25 + 268);

      if ((v26 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v27 = v25;

          id v28 = v27;
          char v29 = *((unsigned char *)v25 + 268);

          if (v29) {
            id v30 = "dry-run ";
          }
          else {
            id v30 = "";
          }
          nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v28);
          logging_description = nw_endpoint_get_logging_description(v31);
          BOOL v77 = v30;
          id_str = v27->id_str;
          os_log_type_t v33 = v28;
          int v34 = v33;
          uint64_t v35 = v33[30];
          if (v35 > 5) {
            id v36 = "unknown-state";
          }
          else {
            id v36 = off_1E523FB38[v35];
          }
          loga = v12;

          os_log_type_t v37 = v34;
          BOOL v38 = v37;
          os_log_type_t v39 = logging_description;
          os_log_type_t v40 = "path";
          switch(v5->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v40 = "resolver";
              break;
            case 2:
              os_log_type_t v40 = nw_endpoint_flow_mode_string(v37[31]);
              break;
            case 3:
              os_log_type_t v40 = "proxy";
              break;
            case 4:
              os_log_type_t v40 = "fallback";
              break;
            case 5:
              os_log_type_t v40 = "transform";
              break;
            default:
              os_log_type_t v40 = "unknown-mode";
              break;
          }

          id v45 = v38;
          os_unfair_lock_lock((os_unfair_lock_t)v45 + 28);
          id v46 = v45[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v45 + 28);

          *(_DWORD *)buf = 136447746;
          os_log_type_t v90 = "nw_flow_disconnected";
          __int16 v91 = 2082;
          os_log_type_t v92 = id_str;
          __int16 v93 = 2082;
          os_log_type_t v94 = v77;
          __int16 v95 = 2082;
          nw_endpoint_t v96 = v39;
          __int16 v97 = 2082;
          BOOL v98 = v36;
          __int16 v99 = 2082;
          id v100 = v40;
          __int16 v101 = 2114;
          id v102 = v46;
          BOOL v12 = loga;
          _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected for unregistered flow", buf, 0x48u);
        }
        goto LABEL_49;
      }
    }
    else
    {
      parameters = handle->parameters;
      if (!parameters) {
        goto LABEL_50;
      }
      int v8 = parameters;
      uint64_t v9 = *((void *)v8 + 12);

      if ((v9 & 0x4000000000) != 0) {
        goto LABEL_50;
      }
      if (nw_endpoint_handler_get_minimize_logging(v5))
      {
        if (nw_endpoint_handler_get_logging_disabled(v5)) {
          goto LABEL_50;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v5);
          __int16 v66 = nw_endpoint_handler_dry_run_string(v5);
          nw_endpoint_t v67 = nw_endpoint_handler_copy_endpoint(v5);
          uint64_t v68 = nw_endpoint_get_logging_description(v67);
          os_log_type_t v69 = nw_endpoint_handler_state_string(v5);
          os_log_type_t v70 = nw_endpoint_handler_mode_string(v5);
          id v71 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          os_log_type_t v90 = "nw_flow_disconnected";
          __int16 v91 = 2082;
          os_log_type_t v92 = (void *)id_string;
          __int16 v93 = 2082;
          os_log_type_t v94 = v66;
          __int16 v95 = 2082;
          nw_endpoint_t v96 = v68;
          __int16 v97 = 2082;
          BOOL v98 = v69;
          __int16 v99 = 2082;
          id v100 = v70;
          __int16 v101 = 2114;
          id v102 = v71;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected", buf, 0x48u);
        }
        goto LABEL_49;
      }
      id v10 = v5;
      char v11 = *((unsigned char *)v10 + 268);

      if ((v11 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          id v13 = v10;

          uint64_t v14 = v13;
          char v15 = *((unsigned char *)v10 + 268);

          if (v15) {
            BOOL v16 = "dry-run ";
          }
          else {
            BOOL v16 = "";
          }
          nw_endpoint_t v17 = nw_endpoint_handler_copy_endpoint(v14);
          os_log_type_t v18 = nw_endpoint_get_logging_description(v17);
          os_log_t log = (os_log_t)v13->id_str;
          os_log_type_t v76 = v16;
          __int16 v19 = v14;
          BOOL v20 = v19;
          uint64_t v21 = v19[30];
          if (v21 > 5) {
            nw_endpoint_t v22 = "unknown-state";
          }
          else {
            nw_endpoint_t v22 = off_1E523FB38[v21];
          }
          os_log_type_t v73 = v22;

          nw_endpoint_t v41 = v20;
          os_log_type_t v42 = v41;
          os_log_type_t v43 = v18;
          BOOL v44 = "path";
          switch(v5->mode)
          {
            case 0:
              break;
            case 1:
              BOOL v44 = "resolver";
              break;
            case 2:
              BOOL v44 = nw_endpoint_flow_mode_string(v41[31]);
              break;
            case 3:
              BOOL v44 = "proxy";
              break;
            case 4:
              BOOL v44 = "fallback";
              break;
            case 5:
              BOOL v44 = "transform";
              break;
            default:
              BOOL v44 = "unknown-mode";
              break;
          }

          id v47 = v42;
          os_unfair_lock_lock((os_unfair_lock_t)v47 + 28);
          id v48 = v47[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v47 + 28);

          *(_DWORD *)buf = 136447746;
          os_log_type_t v90 = "nw_flow_disconnected";
          __int16 v91 = 2082;
          os_log_type_t v92 = log;
          __int16 v93 = 2082;
          os_log_type_t v94 = v76;
          __int16 v95 = 2082;
          nw_endpoint_t v96 = v43;
          __int16 v97 = 2082;
          BOOL v98 = v73;
          __int16 v99 = 2082;
          id v100 = v44;
          __int16 v101 = 2114;
          id v102 = v48;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected", buf, 0x48u);
        }
LABEL_49:
      }
    }
LABEL_50:
    *((_WORD *)handle + 166) |= 0x210u;
    id v49 = nw_endpoint_handler_copy_flow(v5);
    unsigned int v50 = *((unsigned __int16 *)handle + 166);
    BOOL v51 = handle->output_context;
    if ((v50 & 0x100) == 0) {
      nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v49, handle, 1);
    }
    int v52 = (v50 >> 8) & 1;
    uint64_t v53 = handle->last_error;
    context = handle->context;
    v79[0] = MEMORY[0x1E4F143A8];
    v79[1] = 3221225472;
    v79[2] = ___ZL20nw_flow_disconnectedP11nw_protocolS0__block_invoke;
    v79[3] = &unk_1E523CBB0;
    os_log_type_t v80 = v5;
    BOOL v84 = handle;
    os_log_type_t v55 = v49;
    BOOL v81 = v55;
    os_log_type_t v82 = v53;
    char v86 = v52;
    os_log_type_t v56 = v51;
    os_log_type_t v83 = v56;
    os_log_type_t v85 = handle;
    os_log_type_t v57 = v53;
    nw_queue_context_async(context, v79);

    goto LABEL_53;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v23 = (id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      id v24 = "unknown-mode";
    }
    else {
      id v24 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v90 = "nw_flow_disconnected";
    __int16 v91 = 2082;
    os_log_type_t v92 = (void *)v24;
    __int16 v93 = 2082;
    os_log_type_t v94 = "flow";
    _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_53:
}

void sub_1833546EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t data_source_read_callback(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, _DWORD *a5, void *a6, uint64_t a7)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    if (gLogDatapath)
    {
      os_log_type_t v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        id v30 = "data_source_read_callback";
        __int16 v31 = 2082;
        int v32 = (char *)(a7 + 205);
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }
    char v11 = (_DWORD *)*a6;
    if (*a6)
    {
      int v12 = v11[13];
      if (v12) {
        unsigned int v13 = v12 - (v11[14] + v11[15]);
      }
      else {
        unsigned int v13 = 0;
      }
      if (v13 >= a4) {
        unsigned int v16 = a4;
      }
      else {
        unsigned int v16 = v13;
      }
      if (v16 >= 0x3FF6) {
        uint64_t v15 = 16374;
      }
      else {
        uint64_t v15 = v16;
      }
      if (v15 == v13) {
        int v17 = 7;
      }
      else {
        int v17 = 6;
      }
      *a5 |= v17;
      if (gLogDatapath)
      {
        id v24 = __nwlog_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          id v30 = "data_source_read_callback";
          __int16 v31 = 2082;
          int v32 = (char *)(a7 + 205);
          __int16 v33 = 1024;
          int v34 = v15;
          _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipped copying %u bytes in data_source_read_callback", buf, 0x1Cu);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        id v30 = "data_source_read_callback";
        __int16 v31 = 2082;
        int v32 = (char *)(a7 + 205);
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received unexpected NULL frame in data source", buf, 0x16u);
      }
      uint64_t v15 = 0;
      *a5 |= 1u;
    }
    return v15;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v30 = "data_source_read_callback";
  __int16 v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v19, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        id v30 = "data_source_read_callback";
        nw_endpoint_t v22 = "%{public}s nghttp2 user data is NULL, not http2_transport";
LABEL_38:
        _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          id v30 = "data_source_read_callback";
          __int16 v31 = 2082;
          int v32 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_39;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        id v30 = "data_source_read_callback";
        nw_endpoint_t v22 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
        goto LABEL_38;
      }
    }
    else
    {
      BOOL v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        id v30 = "data_source_read_callback";
        nw_endpoint_t v22 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
  }
LABEL_39:
  if (v19) {
    free(v19);
  }
  return -902;
}

uint64_t __nw_connection_get_symptom_reporter_handle_block_invoke()
{
  uint64_t result = symptom_framework_init();
  nw_connection_get_symptom_reporter_handle::symptom_reporter = result;
  return result;
}

uint64_t nw_protocol_instance_get_level(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void *)*((void *)v1 + 15);
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = v4;
      if (((_BYTE)v4[17] & 8) == 0) {
        dispatch_assert_queue_V2(v4[1]);
      }
    }
    uint64_t v6 = v2[94];
    goto LABEL_7;
  }
  int v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "nw_protocol_instance_get_level";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v19 = "nw_protocol_instance_get_level";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0;
LABEL_7:

  return v6;
}

void sub_183354E50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_ip_identifier_block_invoke()
{
  unk_1EB267643 = 0;
  unk_1EB26763B = 0;
  qword_1EB267650 = 0;
  unk_1EB26764B = 0;
  strcpy((char *)&nw_protocol_ip_identifier::identifier, "ip");
  qword_1EB267658 = 0x100000002;
  flowhash_seed = arc4random();

  return nw_protocol_register_extended(&nw_protocol_ip_identifier::identifier, (uint64_t)nw_protocol_ip_create);
}

void ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_198(uint64_t a1, int a2, int a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  switch(a2)
  {
    case 3:
      uint64_t v21 = *(void *)(a1 + 32);
      uint64_t v22 = *(NWConcrete_nw_resolver_service **)(a1 + 40);
      if (v22)
      {
        if (v21)
        {
          if ((*(unsigned char *)(v21 + 346) & 0x20) != 0)
          {
LABEL_53:
            nw_resolver_service_cancel_query(v22);
            break;
          }
          if (*(unsigned char *)(v21 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v23 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v23, OS_LOG_TYPE_INFO)) {
              goto LABEL_52;
            }
            uint64_t v24 = *(void *)(a1 + 40);
            uint64_t v25 = *(void *)(a1 + 32) + 256;
            int v52 = 136446722;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 2082;
            *(void *)os_log_type_t v55 = v25;
            *(_WORD *)&v55[8] = 2114;
            *(void *)&v55[10] = v24;
            BOOL v26 = "%{public}s [C%{public}s] Invalidating getaddrinfo DNS object for %{public}@";
            char v27 = v23;
            uint32_t v28 = 32;
            goto LABEL_51;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v23 = (id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            uint64_t v39 = *(void *)(a1 + 40);
            int v40 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
            int v52 = 136446722;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v40;
            *(_WORD *)&v55[4] = 2114;
            *(void *)&v55[6] = v39;
            BOOL v26 = "%{public}s [R%u] Invalidating getaddrinfo DNS object for %{public}@";
            char v27 = v23;
            uint32_t v28 = 28;
            goto LABEL_51;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v23 = (id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = *(void *)(a1 + 40);
            int v52 = 136446466;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 2114;
            *(void *)os_log_type_t v55 = v36;
            BOOL v26 = "%{public}s Invalidating getaddrinfo DNS object for %{public}@";
            char v27 = v23;
            uint32_t v28 = 22;
LABEL_51:
            _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_INFO, v26, (uint8_t *)&v52, v28);
          }
        }
LABEL_52:

        uint64_t v22 = *(NWConcrete_nw_resolver_service **)(a1 + 40);
        goto LABEL_53;
      }
      if (v21)
      {
        if ((*(unsigned char *)(v21 + 346) & 0x20) != 0) {
          goto LABEL_88;
        }
        if (*(unsigned char *)(v21 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v30 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_INFO)) {
            goto LABEL_87;
          }
          uint64_t v31 = *(void *)(a1 + 32) + 256;
          int v52 = 136446466;
          uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          __int16 v54 = 2082;
          *(void *)os_log_type_t v55 = v31;
          int v32 = "%{public}s [C%{public}s] Invalidating getaddrinfo DNS object";
          __int16 v33 = v30;
          uint32_t v34 = 22;
          goto LABEL_86;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v30 = (id)gLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
        {
          int v51 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
          int v52 = 136446466;
          uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          __int16 v54 = 1024;
          *(_DWORD *)os_log_type_t v55 = v51;
          int v32 = "%{public}s [R%u] Invalidating getaddrinfo DNS object";
          __int16 v33 = v30;
          uint32_t v34 = 18;
          goto LABEL_86;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v30 = (id)gLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
        {
          int v52 = 136446210;
          uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          int v32 = "%{public}s Invalidating getaddrinfo DNS object";
          __int16 v33 = v30;
          uint32_t v34 = 12;
LABEL_86:
          _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_INFO, v32, (uint8_t *)&v52, v34);
        }
      }
LABEL_87:

      uint64_t v21 = *(void *)(a1 + 32);
LABEL_88:
      if (*(void *)(v21 + 48) == *(void *)(a1 + 48)) {
        nw_resolver_cancel_query_locked((NWConcrete_nw_resolver *)v21, 0);
      }
      break;
    case 2:
      if (*(void *)(a1 + 40)) {
        break;
      }
      uint64_t v15 = *(void *)(a1 + 32);
      if (v15)
      {
        if ((*(unsigned char *)(v15 + 346) & 0x20) != 0)
        {
LABEL_64:
          BOOL v42 = nw_array_create();
          uint64_t v43 = *(void *)(a1 + 32);
          BOOL v44 = *(void **)(v43 + 144);
          *(void *)(v43 + 144) = v42;

          nw_resolver_update_status_locked(*(void **)(a1 + 32), 0);
          break;
        }
        if (*(unsigned char *)(v15 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v16 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_INFO)) {
            goto LABEL_63;
          }
          uint64_t v17 = *(void *)(a1 + 32) + 256;
          int v52 = 136446466;
          uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          __int16 v54 = 2082;
          *(void *)os_log_type_t v55 = v17;
          os_log_type_t v18 = "%{public}s [C%{public}s] Removing all results for DNS";
          __int16 v19 = v16;
          uint32_t v20 = 22;
          goto LABEL_62;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          int v41 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
          int v52 = 136446466;
          uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          __int16 v54 = 1024;
          *(_DWORD *)os_log_type_t v55 = v41;
          os_log_type_t v18 = "%{public}s [R%u] Removing all results for DNS";
          __int16 v19 = v16;
          uint32_t v20 = 18;
          goto LABEL_62;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          int v52 = 136446210;
          uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          os_log_type_t v18 = "%{public}s Removing all results for DNS";
          __int16 v19 = v16;
          uint32_t v20 = 12;
LABEL_62:
          _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_INFO, v18, (uint8_t *)&v52, v20);
        }
      }
LABEL_63:

      goto LABEL_64;
    case 1:
      dns_error = nw_error_create_dns_error(a3);
      uint64_t v8 = *(void *)(a1 + 32);
      os_log_type_t v7 = *(void **)(a1 + 40);
      if (v7)
      {
        if (v8)
        {
          if ((*(unsigned char *)(v8 + 346) & 0x20) != 0) {
            goto LABEL_69;
          }
          if (*(unsigned char *)(v8 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v9 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
              goto LABEL_68;
            }
            uint64_t v10 = *(void *)(a1 + 40);
            uint64_t v11 = *(void *)(a1 + 32) + 256;
            int v52 = 136446978;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 2082;
            *(void *)os_log_type_t v55 = v11;
            *(_WORD *)&v55[8] = 2112;
            *(void *)&v55[10] = dns_error;
            *(_WORD *)&v55[18] = 2114;
            *(void *)&v55[20] = v10;
            int v12 = "%{public}s [C%{public}s] Got DNS error %@ for %{public}@";
            os_log_type_t v13 = v9;
            uint32_t v14 = 42;
            goto LABEL_67;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = *(void *)(a1 + 40);
            int v38 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
            int v52 = 136446978;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v38;
            *(_WORD *)&v55[4] = 2112;
            *(void *)&v55[6] = dns_error;
            *(_WORD *)&v55[14] = 2114;
            *(void *)&v55[16] = v37;
            int v12 = "%{public}s [R%u] Got DNS error %@ for %{public}@";
            os_log_type_t v13 = v9;
            uint32_t v14 = 38;
            goto LABEL_67;
          }
LABEL_68:

          uint64_t v8 = *(void *)(a1 + 32);
          os_log_type_t v7 = *(void **)(a1 + 40);
          goto LABEL_69;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (id)gLogObj;
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_68;
        }
        uint64_t v35 = *(void *)(a1 + 40);
        int v52 = 136446722;
        uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        __int16 v54 = 2112;
        *(void *)os_log_type_t v55 = dns_error;
        *(_WORD *)&v55[8] = 2114;
        *(void *)&v55[10] = v35;
        int v12 = "%{public}s Got DNS error %@ for %{public}@";
      }
      else
      {
        if (!v8)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            int v52 = 136446466;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 2112;
            *(void *)os_log_type_t v55 = dns_error;
            int v12 = "%{public}s Got DNS error %@";
            os_log_type_t v13 = v9;
            uint32_t v14 = 22;
            goto LABEL_67;
          }
          goto LABEL_68;
        }
        if ((*(unsigned char *)(v8 + 346) & 0x20) != 0)
        {
          os_log_type_t v7 = 0;
LABEL_69:
          id v46 = v7;
          __int16 v47 = *(_WORD *)(v8 + 88) & 0xFFEF;
          *(_WORD *)(v8 + 88) = v47;
          if ((*(unsigned char *)(v8 + 347) & 2) == 0)
          {
            v47 |= 0x80u;
            *(_WORD *)(v8 + 88) = v47;
          }
          int v48 = *(_DWORD *)(v8 + 80);
          if (v48 == 1)
          {
            __int16 v49 = 2056;
          }
          else
          {
            if (v48 != 2) {
              goto LABEL_76;
            }
            __int16 v49 = 1028;
          }
          v47 |= v49;
          *(_WORD *)(v8 + 88) = v47;
LABEL_76:
          if (a3)
          {
            if (!v46)
            {
              __int16 v50 = v47 | 3;
              *(_WORD *)(v8 + 88) = v50;
              if ((v50 & 0xC) != 0) {
                goto LABEL_80;
              }
              goto LABEL_79;
            }
            v46[18] |= 3u;
            if ((*(_WORD *)(v8 + 88) & 0xC) == 0) {
LABEL_79:
            }
              *(_DWORD *)(v8 + 84) = a3;
          }
LABEL_80:

          nw_resolver_update_status_locked(*(void **)(a1 + 32), 0);
          break;
        }
        if (!*(unsigned char *)(v8 + 256))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            int v45 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
            int v52 = 136446722;
            uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v45;
            *(_WORD *)&v55[4] = 2112;
            *(void *)&v55[6] = dns_error;
            int v12 = "%{public}s [R%u] Got DNS error %@";
            os_log_type_t v13 = v9;
            uint32_t v14 = 28;
            goto LABEL_67;
          }
          goto LABEL_68;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v9 = (id)gconnectionLogObj;
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_68;
        }
        uint64_t v29 = *(void *)(a1 + 32) + 256;
        int v52 = 136446722;
        uint64_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        __int16 v54 = 2082;
        *(void *)os_log_type_t v55 = v29;
        *(_WORD *)&v55[8] = 2112;
        *(void *)&v55[10] = dns_error;
        int v12 = "%{public}s [C%{public}s] Got DNS error %@";
      }
      os_log_type_t v13 = v9;
      uint32_t v14 = 32;
LABEL_67:
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v52, v14);
      goto LABEL_68;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
}

void sub_18335598C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_protocol_copy_resolver_definitionv_block_invoke()
{
  named = nw_protocol_definition_create_named(1, 0);
  uint64_t v1 = (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition;
  nw_protocol_copy_resolver_definition(void)::resolver_definition = (uint64_t)named;

  nw_protocol_definition_set_cache_entry_deallocator((void *)nw_protocol_copy_resolver_definition(void)::resolver_definition, nw_resolver_deallocate_cache_entry);
  uint64_t v2 = (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition;

  nw_protocol_definition_set_should_flush_cache_entry(v2, nw_resolver_should_flush_cache_entry);
}

void __nw_protocol_copy_quic_connection_definition_block_invoke()
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  named = nw_protocol_definition_create_named(3, "quic-connection");
  uint64_t v1 = (void *)nw_protocol_copy_quic_connection_definition::quic_definition;
  nw_protocol_copy_quic_connection_definition::quic_definition = (uint64_t)named;

  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_quic_connection_definition::quic_definition, (uint64_t)nw_quic_connection_allocate_options, (uint64_t)nw_quic_connection_copy_options, (uint64_t)nw_quic_connection_deallocate_options);
  nw_protocol_definition_set_options_comparator((void *)nw_protocol_copy_quic_connection_definition::quic_definition, (uint64_t)nw_quic_connection_option_compare);
  nw_protocol_definition_set_metadata_initializer((void *)nw_protocol_copy_quic_connection_definition::quic_definition, 0xE0u, nw_quic_connection_initialize_metadata, nw_quic_connection_finalize_metadata);
  nw_protocol_definition_set_metadata_copy_reply((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_metadata_create_reply, nw_quic_metadata_copy_original, nw_quic_metadata_set_original);
  nw_protocol_definition_set_metadata_copy_message_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_metadata_copy_stream_options);
  id v2 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  uint64_t v3 = v2;
  if (v2)
  {
    *((unsigned char *)v2 + 184) |= 6u;
    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_protocol_definition_set_message_is_stream";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_definition_set_message_is_stream";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_protocol_definition_set_message_is_stream";
          __int16 v19 = 2082;
          uint32_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_definition_set_message_is_stream";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_definition_set_message_is_stream";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_29:
  if (v7) {
    free(v7);
  }
LABEL_3:

  nw_protocol_definition_set_cache_entry_deallocator((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_deallocate_cache_entry);
  nw_protocol_definition_set_should_flush_cache_entry((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_should_flush_cache_entry);
  id v4 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (quic_fillout_definition_callbacks_override)
  {
    uint32_t v14 = v4;
    quic_fillout_definition_callbacks_override(v4);
LABEL_7:

    uint64_t v5 = (void *)nw_protocol_copy_quic_connection_definition::quic_definition;
    nw_protocol_definition_register(v5);
    return;
  }
  if (MEMORY[0x1E4FBA960])
  {
    uint32_t v14 = v4;
    quic_fillout_definition_callbacks();
    goto LABEL_7;
  }
}

void sub_183355E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_should_flush_cache_entry(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_common_state(v3);
    v4->common_state->var8 = a2;
    goto LABEL_4;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null should_flush_cache_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null should_flush_cache_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint32_t v14 = (char *)__nw_create_backtrace_string();
  os_log_type_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null should_flush_cache_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_protocol_definition_set_should_flush_cache_entry";
    __int16 v23 = 2082;
    uint64_t v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null should_flush_cache_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183356328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_protocol_copy_custom_ip_definitionv_block_invoke()
{
  named = nw_protocol_definition_create_named(1, 0);
  uint64_t v1 = (void *)nw_protocol_copy_custom_ip_definition(void)::definition;
  nw_protocol_copy_custom_ip_definition(void)::definition = (uint64_t)named;

  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_custom_ip_definition(void)::definition, (uint64_t)nw_custom_ip_allocate_options, (uint64_t)nw_custom_ip_copy_options, (uint64_t)nw_custom_ip_deallocate_options);
  id v2 = (void *)nw_protocol_copy_custom_ip_definition(void)::definition;

  nw_protocol_definition_set_options_equality_check(v2, (uint64_t)nw_custom_ip_option_is_equal);
}

NWConcrete_nw_protocol_definition *nw_protocol_definition_create_named(int a1, unsigned __int8 *a2)
{
  *(void *)&v62[13] = *MEMORY[0x1E4F143B8];
  if ((a1 - 4) > 0xFFFFFFFC)
  {
    os_log_type_t v9 = objc_alloc_init(NWConcrete_nw_protocol_definition);
    os_log_type_t v7 = v9;
    if (v9)
    {
      uuid_generate_random(v9->unique_identifier);
      name = v7->identifier.name;
      if (a2)
      {
        int v11 = *a2;
        char *name = v11;
        if (v11)
        {
          int v12 = a2[1];
          v7->identifier.name[1] = v12;
          if (v12)
          {
            int v13 = a2[2];
            v7->identifier.name[2] = v13;
            if (v13)
            {
              int v14 = a2[3];
              v7->identifier.name[3] = v14;
              if (v14)
              {
                int v15 = a2[4];
                v7->identifier.name[4] = v15;
                if (v15)
                {
                  int v16 = a2[5];
                  v7->identifier.name[5] = v16;
                  if (v16)
                  {
                    int v17 = a2[6];
                    v7->identifier.name[6] = v17;
                    if (v17)
                    {
                      int v18 = a2[7];
                      v7->identifier.name[7] = v18;
                      if (v18)
                      {
                        int v19 = a2[8];
                        v7->identifier.name[8] = v19;
                        if (v19)
                        {
                          int v20 = a2[9];
                          v7->identifier.name[9] = v20;
                          if (v20)
                          {
                            int v21 = a2[10];
                            v7->identifier.name[10] = v21;
                            if (v21)
                            {
                              int v22 = a2[11];
                              v7->identifier.name[11] = v22;
                              if (v22)
                              {
                                int v23 = a2[12];
                                v7->identifier.name[12] = v23;
                                if (v23)
                                {
                                  int v24 = a2[13];
                                  v7->identifier.name[13] = v24;
                                  if (v24)
                                  {
                                    int v25 = a2[14];
                                    v7->identifier.name[14] = v25;
                                    if (v25)
                                    {
                                      int v26 = a2[15];
                                      v7->identifier.name[15] = v26;
                                      if (v26)
                                      {
                                        int v27 = a2[16];
                                        v7->identifier.name[16] = v27;
                                        if (v27)
                                        {
                                          int v28 = a2[17];
                                          v7->identifier.name[17] = v28;
                                          if (v28)
                                          {
                                            int v29 = a2[18];
                                            v7->identifier.name[18] = v29;
                                            if (v29)
                                            {
                                              int v30 = a2[19];
                                              v7->identifier.name[19] = v30;
                                              if (v30)
                                              {
                                                int v31 = a2[20];
                                                v7->identifier.name[20] = v31;
                                                if (v31)
                                                {
                                                  int v32 = a2[21];
                                                  v7->identifier.name[21] = v32;
                                                  if (v32)
                                                  {
                                                    int v33 = a2[22];
                                                    v7->identifier.name[22] = v33;
                                                    if (v33)
                                                    {
                                                      int v34 = a2[23];
                                                      v7->identifier.name[23] = v34;
                                                      if (v34)
                                                      {
                                                        int v35 = a2[24];
                                                        v7->identifier.name[24] = v35;
                                                        if (v35)
                                                        {
                                                          int v36 = a2[25];
                                                          v7->identifier.name[25] = v36;
                                                          if (v36)
                                                          {
                                                            int v37 = a2[26];
                                                            v7->identifier.name[26] = v37;
                                                            if (v37)
                                                            {
                                                              int v38 = a2[27];
                                                              v7->identifier.name[27] = v38;
                                                              if (v38)
                                                              {
                                                                int v39 = a2[28];
                                                                v7->identifier.name[28] = v39;
                                                                if (v39)
                                                                {
                                                                  int v40 = a2[29];
                                                                  v7->identifier.name[29] = v40;
                                                                  if (v40)
                                                                  {
                                                                    int v41 = a2[30];
                                                                    v7->identifier.name[30] = v41;
                                                                    if (v41) {
                                                                      v7->identifier.name[31] = 0;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        uuid_unparse(v7->unique_identifier, name);
      }
      if (a1 == 3) {
        int v49 = 2;
      }
      else {
        int v49 = 1;
      }
      v7->identifier.level = 0;
      v7->identifier.mapping = v49;
      v7->variant = a1;
      __int16 v50 = v7;
      goto LABEL_62;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v45 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v60 = "nw_protocol_definition_create_named";
    id v46 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (__nwlog_fault(v46, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v47 = (id)gLogObj;
        os_log_type_t v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s [nw_protocol_definition init] failed", buf, 0xCu);
        }
      }
      else if (v57)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v47 = (id)gLogObj;
        os_log_type_t v54 = type;
        BOOL v55 = os_log_type_enabled(v47, type);
        if (backtrace_string)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v60 = "nw_protocol_definition_create_named";
            __int16 v61 = 2082;
            *(void *)BOOL v62 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v47, v54, "%{public}s [nw_protocol_definition init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v46) {
            goto LABEL_62;
          }
          goto LABEL_56;
        }
        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_1830D4000, v47, v54, "%{public}s [nw_protocol_definition init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v47 = (id)gLogObj;
        os_log_type_t v56 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_1830D4000, v47, v56, "%{public}s [nw_protocol_definition init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v46)
    {
LABEL_62:

      return v7;
    }
LABEL_56:
    free(v46);
    goto LABEL_62;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  uint64_t v60 = "nw_protocol_definition_create_named";
  __int16 v61 = 1024;
  *(_DWORD *)BOOL v62 = a1;
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v57 = 0;
  if (__nwlog_fault(v4, &type, &v57))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v60 = "nw_protocol_definition_create_named";
        __int16 v61 = 1024;
        *(_DWORD *)BOOL v62 = a1;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s Invalid protocol variant %u", buf, 0x12u);
      }
    }
    else if (v57)
    {
      BOOL v42 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (id)gLogObj;
      os_log_type_t v43 = type;
      BOOL v44 = os_log_type_enabled(v5, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v60 = "nw_protocol_definition_create_named";
          __int16 v61 = 1024;
          *(_DWORD *)BOOL v62 = a1;
          v62[2] = 2082;
          *(void *)&v62[3] = v42;
          _os_log_impl(&dword_1830D4000, v5, v43, "%{public}s Invalid protocol variant %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v42);
        if (!v4) {
          return 0;
        }
        goto LABEL_8;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v60 = "nw_protocol_definition_create_named";
        __int16 v61 = 1024;
        *(_DWORD *)BOOL v62 = a1;
        _os_log_impl(&dword_1830D4000, v5, v43, "%{public}s Invalid protocol variant %u, no backtrace", buf, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (id)gLogObj;
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v60 = "nw_protocol_definition_create_named";
        __int16 v61 = 1024;
        *(_DWORD *)BOOL v62 = a1;
        _os_log_impl(&dword_1830D4000, v5, v52, "%{public}s Invalid protocol variant %u, backtrace limit exceeded", buf, 0x12u);
      }
    }
  }
  if (v4) {
LABEL_8:
  }
    free(v4);
  return 0;
}

void sub_183356B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_copy_reply(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  os_log_type_t v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v31 = "nw_protocol_definition_set_metadata_copy_reply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          int v31 = "nw_protocol_definition_set_metadata_copy_reply";
          __int16 v32 = 2082;
          int v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10) {
          goto LABEL_5;
        }
LABEL_56:
        free(v10);
        goto LABEL_5;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    int v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v31 = "nw_protocol_definition_set_metadata_copy_reply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null create_reply_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s called with null create_reply_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    int v20 = (char *)__nw_create_backtrace_string();
    int v11 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null create_reply_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      int v31 = "nw_protocol_definition_set_metadata_copy_reply";
      __int16 v32 = 2082;
      int v33 = v20;
      _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null create_reply_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    int v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v31 = "nw_protocol_definition_set_metadata_copy_reply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null copy_original_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null copy_original_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    int v20 = (char *)__nw_create_backtrace_string();
    int v11 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        int v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null copy_original_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      int v31 = "nw_protocol_definition_set_metadata_copy_reply";
      __int16 v32 = 2082;
      int v33 = v20;
      _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null copy_original_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v20);
    if (!v10) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_common_state(v7);
  v8->common_state->var3 = a2;
  v8->common_state->var4 = a3;
  v8->common_state->var5 = a4;
LABEL_5:
}

void sub_183357250(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_copy_message_options(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_common_state(v3);
    v4->common_state->var6 = a2;
    goto LABEL_4;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null copy_message_options", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null copy_message_options, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v14 = (char *)__nw_create_backtrace_string();
  os_log_type_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null copy_message_options, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
    __int16 v23 = 2082;
    BOOL v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null copy_message_options, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183357718(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_globals_allocator(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_protocol_definition_set_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          int v29 = "nw_protocol_definition_set_globals_allocator";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    int v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_protocol_definition_set_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      int v29 = "nw_protocol_definition_set_globals_allocator";
      __int16 v30 = 2082;
      int v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_protocol_definition_set_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      int v29 = "nw_protocol_definition_set_globals_allocator";
      __int16 v30 = 2082;
      int v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_common_state(v5);
  v6->common_state->unint64_t var0 = a2;
  v6->common_state->var2 = a3;
LABEL_5:
}

void sub_183357DEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_cache_entry_deallocator(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_common_state(v3);
    v4->common_state->var7 = a2;
    goto LABEL_4;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null deallocate_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v14 = (char *)__nw_create_backtrace_string();
  os_log_type_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
    __int16 v23 = 2082;
    os_log_type_t v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_1833582B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_initialize_common_state(NWConcrete_nw_protocol_definition *a1)
{
  uint64_t v1 = a1;
  if (v1->common_state) {
    goto LABEL_4;
  }
  id v2 = (nw_protocol_definition_common_state *)malloc_type_calloc(1uLL, 0x58uLL, 0xEAFB8F1AuLL);
  if (v2)
  {
LABEL_3:
    v1->common_state = v2;
LABEL_4:

    return;
  }
  id v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  id v4 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v4))
  {
    free(v4);
    goto LABEL_3;
  }
  __break(1u);
}

void sub_183358400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183358D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_transform_add_children(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    __int16 v30 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    int v31 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v67) = 0;
    if (__nwlog_fault(v31, type, &v67))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v32 = __nwlog_obj();
        os_log_type_t v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v67)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v32 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        BOOL v36 = os_log_type_enabled(v32, type[0]);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v32, v35, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v32, v35, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v32 = __nwlog_obj();
        os_log_type_t v37 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v32, v37, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_32:
    if (v31) {
      free(v31);
    }
    unsigned int mode = 0;
    goto LABEL_35;
  }
  unsigned int mode = v1->mode;

  if (mode == 5)
  {
    id v4 = nw_endpoint_handler_copy_transform(v2);
    uint64_t v5 = v2;
    os_unfair_lock_lock(&v5->lock);
    os_log_type_t v6 = v5->current_path;
    os_unfair_lock_unlock(&v5->lock);

    uint64_t v67 = 0;
    uint64_t v68 = &v67;
    uint64_t v69 = 0x2020000000;
    char v70 = 1;
    os_log_type_t v7 = v5;
    id v8 = v7[4];

    os_log_type_t v9 = (atomic_uchar *)nw_parameters_copy_transform_array(v8);
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    os_log_type_t v73 = __Block_byref_object_copy__79114;
    *(void *)&long long v74 = __Block_byref_object_dispose__79115;
    *((void *)&v74 + 1) = 0;
    *(void *)os_log_type_t type = 0;
    BOOL v62 = type;
    uint64_t v63 = 0x3032000000;
    BOOL v64 = __Block_byref_object_copy__79114;
    os_log_type_t v65 = __Block_byref_object_dispose__79115;
    id v66 = 0;
    v53[0] = MEMORY[0x1E4F143A8];
    v53[1] = 3221225472;
    v53[2] = ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke;
    v53[3] = &unk_1E5249768;
    id v10 = v8;
    id v54 = v10;
    int v11 = v4;
    BOOL v55 = v11;
    os_log_type_t v12 = v7;
    os_log_type_t v56 = v12;
    char v58 = &v67;
    BOOL v13 = v6;
    char v57 = v13;
    nw_endpoint_t v59 = buf;
    uint64_t v60 = type;
    nw_array_apply(v9, (uint64_t)v53);
    if (*((unsigned char *)v68 + 24))
    {
      id v14 = *((id *)v11 + 7);
      id v15 = v10;
      BOOL v16 = (NWConcrete_nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v15, 0, 0);

      nw_parameters_set_no_transform(v16, 1);
      long long v71 = 0uLL;
      if (nw_path_get_client_id(v13, &v71)) {
        nw_parameters_set_parent_id_inner(v16, (const unsigned __int8 *)&v71, 0);
      }
      inner = nw_endpoint_handler_create_inner(v14, v16, nw_endpoint_transform_receive_report, v12, v12, 0, 0);
      uint64_t v18 = *((void *)v11 + 1);
      if (!v18)
      {
        BOOL v19 = nw_array_create();
        BOOL v20 = (void *)*((void *)v11 + 1);
        *((void *)v11 + 1) = v19;

        uint64_t v18 = *((void *)v11 + 1);
      }
      nw_array_append(v18, inner);
    }
    uint64_t v21 = *(void *)(*(void *)&buf[8] + 40);
    if (v21)
    {
      BOOL v22 = (void *)*((void *)v62 + 5);
      if (v22)
      {
        uint64_t v24 = *(void *)(v21 + 16);
        uint64_t v23 = *(void *)(v21 + 24);
        if (xpc_array_get_count(v22) == (v23 - v24) >> 3)
        {
          combined_array = nw_array_create_combined_array(*((void **)v11 + 1), *(void **)(*(void *)&buf[8] + 40));
          char v26 = (void *)*((void *)v11 + 1);
          *((void *)v11 + 1) = combined_array;

          if (!*((void *)v11 + 3))
          {
            xpc_object_t v27 = xpc_array_create(0, 0);
            char v28 = (void *)*((void *)v11 + 3);
            *((void *)v11 + 3) = v27;
          }
          int v29 = (void *)*((void *)v62 + 5);
          applier[0] = MEMORY[0x1E4F143A8];
          applier[1] = 3221225472;
          applier[2] = ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke_101;
          applier[3] = &unk_1E524B4A0;
          os_log_type_t v52 = v11;
          xpc_array_apply(v29, applier);
        }
      }
    }

    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);

    _Block_object_dispose(&v67, 8);
    goto LABEL_56;
  }
LABEL_35:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v38 = (id)gLogObj;
  if (mode > 5) {
    int v39 = "unknown-mode";
  }
  else {
    int v39 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
  *(_WORD *)&unsigned char buf[12] = 2082;
  *(void *)&buf[14] = v39;
  *(_WORD *)&buf[22] = 2082;
  os_log_type_t v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
  int v40 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v67) = 0;
  if (!__nwlog_fault((const char *)v40, type, &v67))
  {
LABEL_54:
    if (!v40) {
      goto LABEL_56;
    }
LABEL_55:
    free(v40);
    goto LABEL_56;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v41 = (id)gLogObj;
    os_log_type_t v42 = type[0];
    if (os_log_type_enabled(v41, type[0]))
    {
      if (mode > 5) {
        os_log_type_t v43 = "unknown-mode";
      }
      else {
        os_log_type_t v43 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v43;
      *(_WORD *)&buf[22] = 2082;
      os_log_type_t v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_53:

    goto LABEL_54;
  }
  if (!(_BYTE)v67)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v41 = (id)gLogObj;
    os_log_type_t v48 = type[0];
    if (os_log_type_enabled(v41, type[0]))
    {
      if (mode > 5) {
        int v49 = "unknown-mode";
      }
      else {
        int v49 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v49;
      *(_WORD *)&buf[22] = 2082;
      os_log_type_t v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl(&dword_1830D4000, v41, v48, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_53;
  }
  BOOL v44 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v41 = (id)gLogObj;
  os_log_type_t v45 = type[0];
  BOOL v46 = os_log_type_enabled(v41, type[0]);
  if (!v44)
  {
    if (v46)
    {
      if (mode > 5) {
        __int16 v50 = "unknown-mode";
      }
      else {
        __int16 v50 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v50;
      *(_WORD *)&buf[22] = 2082;
      os_log_type_t v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl(&dword_1830D4000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_53;
  }
  if (v46)
  {
    if (mode > 5) {
      __int16 v47 = "unknown-mode";
    }
    else {
      __int16 v47 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v47;
    *(_WORD *)&buf[22] = 2082;
    os_log_type_t v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
    LOWORD(v74) = 2082;
    *(void *)((char *)&v74 + 2) = v44;
    _os_log_impl(&dword_1830D4000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v44);
  if (v40) {
    goto LABEL_55;
  }
LABEL_56:
}

void sub_183359784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,char a35)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v40 - 176), 8);

  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

id nw_parameters_copy_transform_array(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[20];
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_copy_transform_array";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_copy_transform_array";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_copy_transform_array";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_copy_transform_array";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_copy_transform_array";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nwlog_get_private_redacted_block_invoke()
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  strcpy(__s2, "not redacted");
  char __s1 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v25 = 136380675;
  char v26 = __s2;
  CFStringRef v0 = (char *)_os_log_send_and_compose_impl();
  if (v0 == &__s1)
  {
LABEL_14:
    uint64_t result = strncmp(&__s1, __s2, 0xDuLL);
    nwlog_get_private_redacted::privateRedacted = result != 0;
    return result;
  }
  uint64_t v1 = v0;
  if (v0)
  {
LABEL_3:
    int v2 = __s1;
    char *v1 = __s1;
    if (v2)
    {
      int v3 = v15;
      v1[1] = v15;
      if (v3)
      {
        int v4 = v16;
        v1[2] = v16;
        if (v4)
        {
          int v5 = v17;
          v1[3] = v17;
          if (v5)
          {
            int v6 = v18;
            v1[4] = v18;
            if (v6)
            {
              int v7 = v19;
              v1[5] = v19;
              if (v7)
              {
                int v8 = v20;
                v1[6] = v20;
                if (v8)
                {
                  int v9 = v21;
                  v1[7] = v21;
                  if (v9)
                  {
                    int v10 = v22;
                    v1[8] = v22;
                    if (v10) {
                      v1[9] = v23;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    free(v1);
    goto LABEL_14;
  }
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  int v25 = 136446210;
  char v26 = "_strict_strlcpy";
  char v13 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void nw_connection_register_context(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    int v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_connection_register_context";
    int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23)) {
      goto LABEL_38;
    }
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_connection_register_context";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_connection_register_context";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_connection_register_context";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_connection_register_context";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __nw_connection_register_context_block_invoke;
    v20[3] = &unk_1E524B9A0;
    id v21 = v3;
    id v22 = v5;
    nw_connection_async_if_needed(v21, v20);

    goto LABEL_4;
  }
  int v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_connection_register_context";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23)) {
    goto LABEL_38;
  }
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    int v8 = __nwlog_obj();
    os_log_type_t v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_connection_register_context";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null content_context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    int v8 = __nwlog_obj();
    os_log_type_t v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_connection_register_context";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null content_context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  unsigned __int8 v15 = (char *)__nw_create_backtrace_string();
  int v8 = __nwlog_obj();
  os_log_type_t v16 = v24;
  BOOL v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_connection_register_context";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null content_context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_connection_register_context";
    __int16 v27 = 2082;
    char v28 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null content_context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_18335A214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t nw_activity_is_complete(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[140] >> 3) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_activity_is_complete";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_is_complete";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_activity_is_complete";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_is_complete";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_is_complete";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_activity_is_activated(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[140] >> 2) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_activity_is_activated";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_is_activated";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_activity_is_activated";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_is_activated";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_is_activated";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t on_data_chunk_recv_callback(uint64_t a1, uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v69 = "on_data_chunk_recv_callback";
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();
    v66[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v45, v66, &type)) {
      goto LABEL_103;
    }
    if (v66[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v46 = __nwlog_obj();
      os_log_type_t v47 = v66[0];
      if (!os_log_type_enabled(v46, v66[0])) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v69 = "on_data_chunk_recv_callback";
      os_log_type_t v48 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v46 = __nwlog_obj();
      os_log_type_t v47 = v66[0];
      BOOL v51 = os_log_type_enabled(v46, v66[0]);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_103;
      }
      if (!v51)
      {
LABEL_103:
        if (v45) {
          free(v45);
        }
        return 4294966394;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v69 = "on_data_chunk_recv_callback";
      os_log_type_t v48 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }
    else
    {
      BOOL v46 = __nwlog_obj();
      os_log_type_t v47 = v66[0];
      if (!os_log_type_enabled(v46, v66[0])) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v69 = "on_data_chunk_recv_callback";
      os_log_type_t v48 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v46, v47, v48, buf, 0xCu);
    goto LABEL_103;
  }
  if (gLogDatapath)
  {
    int v49 = __nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = a6 + 205;
      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  *(void *)id v66 = 0;
  uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a6, a3, v66);
  if (!stream_from_id) {
    return 4294966775;
  }
  uint64_t v11 = stream_from_id;
  uint64_t input_frame = http2_transport_create_input_frame(a6, stream_from_id, a5);
  if (!input_frame)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = a6 + 205;
    int v19 = *(_DWORD *)(v11 + 32);
    *(_DWORD *)buf = 136446978;
    uint64_t v69 = "on_data_chunk_recv_callback";
    __int16 v70 = 2082;
    uint64_t v71 = a6 + 205;
    __int16 v72 = 2048;
    *(void *)os_log_type_t v73 = a5;
    *(_WORD *)&v73[8] = 1024;
    *(_DWORD *)&v73[10] = v19;
    unsigned __int8 v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (!__nwlog_fault(v20, &type, &v65)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v21 = gLogObj;
      os_log_type_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      int v23 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      uint64_t v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = v18;
      __int16 v72 = 2048;
      *(void *)os_log_type_t v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v23;
      os_log_type_t v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d";
    }
    else if (v65)
    {
      char v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v21 = gLogObj;
      os_log_type_t v22 = type;
      BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v27)
        {
          int v28 = *(_DWORD *)(v11 + 32);
          *(_DWORD *)buf = 136447234;
          uint64_t v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v18;
          __int16 v72 = 2048;
          *(void *)os_log_type_t v73 = a5;
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v28;
          __int16 v74 = 2082;
          uint64_t v75 = v26;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v26);
        goto LABEL_54;
      }
      if (!v27)
      {
LABEL_54:
        if (v20) {
          free(v20);
        }
        return 4294966394;
      }
      int v43 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      uint64_t v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = v18;
      __int16 v72 = 2048;
      *(void *)os_log_type_t v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v43;
      os_log_type_t v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v21 = gLogObj;
      os_log_type_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      int v42 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      uint64_t v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = v18;
      __int16 v72 = 2048;
      *(void *)os_log_type_t v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v42;
      os_log_type_t v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v21, v22, v24, buf, 0x26u);
    goto LABEL_54;
  }
  uint64_t v13 = input_frame;
  if (!*(void *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(void *)(input_frame + 88)))
  {
    int v16 = 0;
    int v25 = 0;
  }
  else
  {
    int v15 = *(_DWORD *)(v13 + 52);
    uint64_t v14 = *(unsigned int *)(v13 + 56);
    if (v15) {
      int v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    }
    else {
      int v16 = 0;
    }
    int v25 = (void *)(*(void *)(v13 + 112) + v14);
  }
  if (v16 != a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v33 = a6 + 205;
    *(_DWORD *)buf = 136446978;
    uint64_t v69 = "on_data_chunk_recv_callback";
    __int16 v70 = 2082;
    uint64_t v71 = a6 + 205;
    __int16 v72 = 1024;
    *(_DWORD *)os_log_type_t v73 = v16;
    *(_WORD *)&v73[4] = 2048;
    *(void *)&v73[6] = a5;
    uint64_t v34 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v34, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v35 = gLogObj;
        os_log_type_t v36 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 1024;
          *(_DWORD *)os_log_type_t v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(void *)&v73[6] = a5;
          os_log_type_t v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame";
LABEL_58:
          _os_log_impl(&dword_1830D4000, v35, v36, v37, buf, 0x26u);
        }
      }
      else if (v65)
      {
        uint64_t v40 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v35 = gLogObj;
        os_log_type_t v36 = type;
        BOOL v41 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v40)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136447234;
            uint64_t v69 = "on_data_chunk_recv_callback";
            __int16 v70 = 2082;
            uint64_t v71 = v33;
            __int16 v72 = 1024;
            *(_DWORD *)os_log_type_t v73 = v16;
            *(_WORD *)&v73[4] = 2048;
            *(void *)&v73[6] = a5;
            __int16 v74 = 2082;
            uint64_t v75 = v40;
            _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_create_input_frame, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v40);
          goto LABEL_59;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 1024;
          *(_DWORD *)os_log_type_t v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(void *)&v73[6] = a5;
          os_log_type_t v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame, no backtrace";
          goto LABEL_58;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v35 = gLogObj;
        os_log_type_t v36 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 1024;
          *(_DWORD *)os_log_type_t v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(void *)&v73[6] = a5;
          os_log_type_t v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame, backtrace limit exceeded";
          goto LABEL_58;
        }
      }
    }
LABEL_59:
    if (v34) {
      free(v34);
    }
    if ((*(_WORD *)(v13 + 204) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(v13, *(void *)(v13 + 88)))
    {
      BOOL v44 = *(void **)(v13 + 112);
      if (v44) {
        free(v44);
      }
    }
    nw_frame_reset(v13, 0, 0, 0, 0);
    os_release((void *)v13);
    return 4294966394;
  }
  memcpy(v25, a4, a5);
  *(void *)(v13 + 16) = 0;
  uint64_t v29 = *(uint64_t **)(v11 + 8);
  *(void *)(v13 + 24) = v29;
  *uint64_t v29 = v13;
  *(void *)(v11 + 8) = v13 + 16;
  if (!*(void *)v66)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v30 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = a6 + 205;
      __int16 v72 = 2048;
      *(void *)os_log_type_t v73 = v11;
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s stream (%p) did not have protocol extra", buf, 0x20u);
    }
  }
  if (*(unsigned char *)(v11 + 36))
  {
    if (gLogDatapath)
    {
      __int16 v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
      {
        int v62 = *(_DWORD *)(v11 + 32);
        *(_DWORD *)buf = 136446978;
        uint64_t v69 = "on_data_chunk_recv_callback";
        __int16 v70 = 2082;
        uint64_t v71 = a6 + 205;
        __int16 v72 = 2048;
        *(void *)os_log_type_t v73 = *(void *)v66;
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v62;
        _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s calling input_available on protocol %p for stream %d", buf, 0x26u);
      }
    }
    if (*(void *)v66)
    {
      uint64_t v38 = *(void *)(*(void *)v66 + 24);
      if (v38)
      {
        int v39 = *(void (**)(void))(v38 + 64);
        if (v39)
        {
          v39();
          return 0;
        }
      }
    }
    __nwlog_obj();
    os_log_type_t v52 = "invalid";
    if (*(void *)v66 && *(void *)(*(void *)v66 + 16)) {
      os_log_type_t v52 = *(const char **)(*(void *)v66 + 16);
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v69 = "on_data_chunk_recv_callback";
    __int16 v70 = 2082;
    uint64_t v71 = (uint64_t)v52;
    uint64_t v53 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v53, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v54 = __nwlog_obj();
        os_log_type_t v55 = type;
        if (!os_log_type_enabled(v54, type)) {
          goto LABEL_118;
        }
        os_log_type_t v56 = "invalid";
        if (*(void *)v66 && *(void *)(*(void *)v66 + 16)) {
          os_log_type_t v56 = *(const char **)(*(void *)v66 + 16);
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v69 = "on_data_chunk_recv_callback";
        __int16 v70 = 2082;
        uint64_t v71 = (uint64_t)v56;
        char v57 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_117;
      }
      if (!v65)
      {
        id v54 = __nwlog_obj();
        os_log_type_t v55 = type;
        if (!os_log_type_enabled(v54, type)) {
          goto LABEL_118;
        }
        uint64_t v63 = "invalid";
        if (*(void *)v66 && *(void *)(*(void *)v66 + 16)) {
          uint64_t v63 = *(const char **)(*(void *)v66 + 16);
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v69 = "on_data_chunk_recv_callback";
        __int16 v70 = 2082;
        uint64_t v71 = (uint64_t)v63;
        char v57 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_117;
      }
      char v58 = (char *)__nw_create_backtrace_string();
      id v54 = __nwlog_obj();
      os_log_type_t v55 = type;
      BOOL v59 = os_log_type_enabled(v54, type);
      if (v58)
      {
        if (v59)
        {
          uint64_t v60 = "invalid";
          if (*(void *)v66 && *(void *)(*(void *)v66 + 16)) {
            uint64_t v60 = *(const char **)(*(void *)v66 + 16);
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = (uint64_t)v60;
          __int16 v72 = 2082;
          *(void *)os_log_type_t v73 = v58;
          _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v58);
        goto LABEL_118;
      }
      if (v59)
      {
        BOOL v64 = "invalid";
        if (*(void *)v66 && *(void *)(*(void *)v66 + 16)) {
          BOOL v64 = *(const char **)(*(void *)v66 + 16);
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v69 = "on_data_chunk_recv_callback";
        __int16 v70 = 2082;
        uint64_t v71 = (uint64_t)v64;
        char v57 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_117:
        _os_log_impl(&dword_1830D4000, v54, v55, v57, buf, 0x16u);
      }
    }
LABEL_118:
    if (v53) {
      free(v53);
    }
    return 0;
  }
  if (!gLogDatapath) {
    return 0;
  }
  int v31 = __nwlog_obj();
  uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    int v32 = *(_DWORD *)(v11 + 32);
    *(_DWORD *)buf = 136446978;
    uint64_t v69 = "on_data_chunk_recv_callback";
    __int16 v70 = 2082;
    uint64_t v71 = a6 + 205;
    __int16 v72 = 2048;
    *(void *)os_log_type_t v73 = *(void *)v66;
    *(_WORD *)&v73[8] = 1024;
    *(_DWORD *)&v73[10] = v32;
    _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s suppressing input_available on protocol %p for stream %d that is not yet open", buf, 0x26u);
    return 0;
  }
  return result;
}

{
  uint64_t stream_from_id;
  uint64_t v11;
  uint64_t input_frame;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  int v21;
  const char *v22;
  int v23;
  int v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  int v28;
  int v29;
  const char *v30;
  char *v31;
  BOOL v32;
  int v33;
  void *v34;
  char *v35;
  BOOL v36;
  int v37;
  int v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  uint64_t result;
  int v44;
  int v45;
  int v46;
  int v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  int v51;
  int v52;
  const char *v53;
  uint64_t v54;
  void (*v55)(void);
  char *v56;
  BOOL v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  NSObject *v74;
  int v75;
  char *backtrace_string;
  BOOL v77;
  const char *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  const char *v82;
  const char *v83;
  char *v84;
  BOOL v85;
  const char *v86;
  NSObject *v87;
  uint64_t v88;
  NSObject *v89;
  int v90;
  int v91;
  const char *v92;
  const char *v93;
  char v94;
  os_log_type_t v95[15];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  unsigned char v104[10];
  __int16 v105;
  unsigned char v106[14];
  __int16 v107;
  char *v108;
  uint64_t v109;

  BOOL v109 = *MEMORY[0x1E4F143B8];
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v98 = "on_data_chunk_recv_callback";
    __int16 v70 = (char *)_os_log_send_and_compose_impl();
    v95[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v70, v95, &type)) {
      goto LABEL_149;
    }
    if (v95[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = __nwlog_obj();
      __int16 v72 = v95[0];
      if (!os_log_type_enabled(v71, v95[0])) {
        goto LABEL_149;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v98 = "on_data_chunk_recv_callback";
      os_log_type_t v73 = "%{public}s nghttp2 user data is NULL, not http2";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v71 = __nwlog_obj();
      __int16 v72 = v95[0];
      BOOL v77 = os_log_type_enabled(v71, v95[0]);
      if (backtrace_string)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v98 = "on_data_chunk_recv_callback";
          __int16 v99 = 2082;
          id v100 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v71, v72, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_149;
      }
      if (!v77)
      {
LABEL_149:
        if (v70) {
          free(v70);
        }
        return 4294966394;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v98 = "on_data_chunk_recv_callback";
      os_log_type_t v73 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }
    else
    {
      uint64_t v71 = __nwlog_obj();
      __int16 v72 = v95[0];
      if (!os_log_type_enabled(v71, v95[0])) {
        goto LABEL_149;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v98 = "on_data_chunk_recv_callback";
      os_log_type_t v73 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v71, v72, v73, buf, 0xCu);
    goto LABEL_149;
  }
  if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v74 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v75 = *(_DWORD *)(a6 + 368);
      *(_DWORD *)buf = 136446978;
      BOOL v98 = "on_data_chunk_recv_callback";
      __int16 v99 = 2082;
      id v100 = (const char *)(a6 + 390);
      __int16 v101 = 2080;
      id v102 = " ";
      uint64_t v103 = 1024;
      *(_DWORD *)v104 = v75;
      _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  *(void *)__int16 v95 = 0;
  uint64_t stream_from_id = nw_http2_get_stream_from_id(a6, a3, v95);
  if (!stream_from_id)
  {
    if (*(__int16 *)(a6 + 388) < 0) {
      return 4294966775;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v17 = *(_DWORD *)(a6 + 368);
    *(_DWORD *)buf = 136447234;
    BOOL v98 = "on_data_chunk_recv_callback";
    __int16 v99 = 2082;
    id v100 = (const char *)(a6 + 390);
    __int16 v101 = 2080;
    id v102 = " ";
    uint64_t v103 = 1024;
    *(_DWORD *)v104 = v17;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = a3;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v18, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v19 = gconnectionLogObj;
        unsigned __int8 v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_89;
        }
        id v21 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(a6 + 390);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v21;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        os_log_type_t v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
        goto LABEL_88;
      }
      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v19 = gconnectionLogObj;
        unsigned __int8 v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_89;
        }
        uint64_t v60 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(a6 + 390);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v60;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        os_log_type_t v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d, backtrace limit exceeded";
        goto LABEL_88;
      }
      int v31 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v19 = gconnectionLogObj;
      unsigned __int8 v20 = type;
      int v32 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v31)
      {
        if (v32)
        {
          uint64_t v33 = *(_DWORD *)(a6 + 368);
          *(_DWORD *)buf = 136447490;
          BOOL v98 = "on_data_chunk_recv_callback";
          __int16 v99 = 2082;
          id v100 = (const char *)(a6 + 390);
          __int16 v101 = 2080;
          id v102 = " ";
          uint64_t v103 = 1024;
          *(_DWORD *)v104 = v33;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = a3;
          os_log_type_t v105 = 2082;
          *(void *)BOOL v106 = v31;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s %{public}s%s<i%u> failed to find stream %d, dumping backtrace:%{public}s", buf, 0x36u);
        }
        free(v31);
        goto LABEL_89;
      }
      if (v32)
      {
        __int16 v61 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(a6 + 390);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v61;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        os_log_type_t v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d, no backtrace";
LABEL_88:
        _os_log_impl(&dword_1830D4000, v19, v20, v22, buf, 0x2Cu);
      }
    }
LABEL_89:
    if (v18) {
      free(v18);
    }
    return 4294966775;
  }
  uint64_t v11 = stream_from_id;
  uint64_t input_frame = http2_create_input_frame(a6, stream_from_id, a5);
  if (!input_frame)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0) {
      return 4294966394;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v24 = *(_DWORD *)(v11 + 176);
    int v23 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    BOOL v98 = "on_data_chunk_recv_callback";
    __int16 v99 = 2082;
    id v100 = (const char *)(v11 + 191);
    __int16 v101 = 2080;
    id v102 = " ";
    uint64_t v103 = 1024;
    *(_DWORD *)v104 = v23;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v24;
    os_log_type_t v105 = 2048;
    *(void *)BOOL v106 = a5;
    *(_WORD *)&v106[8] = 1024;
    *(_DWORD *)&v106[10] = v24;
    int v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v25, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v26 = gconnectionLogObj;
        BOOL v27 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_103;
        }
        uint64_t v29 = *(_DWORD *)(v11 + 176);
        int v28 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v28;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v29;
        os_log_type_t v105 = 2048;
        *(void *)BOOL v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v29;
        __int16 v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d";
        goto LABEL_102;
      }
      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v26 = gconnectionLogObj;
        BOOL v27 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_103;
        }
        uint64_t v63 = *(_DWORD *)(v11 + 176);
        int v62 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v62;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v63;
        os_log_type_t v105 = 2048;
        *(void *)BOOL v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v63;
        __int16 v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, backtrace limit exceeded";
        goto LABEL_102;
      }
      os_log_type_t v35 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v26 = gconnectionLogObj;
      BOOL v27 = type;
      os_log_type_t v36 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v35)
      {
        if (v36)
        {
          uint64_t v38 = *(_DWORD *)(v11 + 176);
          os_log_type_t v37 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136448002;
          BOOL v98 = "on_data_chunk_recv_callback";
          __int16 v99 = 2082;
          id v100 = (const char *)(v11 + 191);
          __int16 v101 = 2080;
          id v102 = " ";
          uint64_t v103 = 1024;
          *(_DWORD *)v104 = v37;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = v38;
          os_log_type_t v105 = 2048;
          *(void *)BOOL v106 = a5;
          *(_WORD *)&v106[8] = 1024;
          *(_DWORD *)&v106[10] = v38;
          os_log_type_t v107 = 2082;
          id v108 = v35;
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, dumping backtrace:%{public}s", buf, 0x46u);
        }
        free(v35);
        goto LABEL_103;
      }
      if (v36)
      {
        uint64_t v67 = *(_DWORD *)(v11 + 176);
        id v66 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v66;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v67;
        os_log_type_t v105 = 2048;
        *(void *)BOOL v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v67;
        __int16 v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, no backtrace";
LABEL_102:
        _os_log_impl(&dword_1830D4000, v26, v27, v30, buf, 0x3Cu);
      }
    }
LABEL_103:
    if (v25) {
      free(v25);
    }
    return 4294966394;
  }
  uint64_t v13 = input_frame;
  if (!*(void *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(void *)(input_frame + 88)))
  {
    int v16 = 0;
    uint64_t v34 = 0;
  }
  else
  {
    int v15 = *(_DWORD *)(v13 + 52);
    uint64_t v14 = *(unsigned int *)(v13 + 56);
    if (v15) {
      int v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    }
    else {
      int v16 = 0;
    }
    uint64_t v34 = (void *)(*(void *)(v13 + 112) + v14);
  }
  if (v16 != a5)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0)
    {
LABEL_110:
      nw_frame_finalize(v13);
      return 4294966394;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v47 = *(_DWORD *)(v11 + 176);
    BOOL v46 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    BOOL v98 = "on_data_chunk_recv_callback";
    __int16 v99 = 2082;
    id v100 = (const char *)(v11 + 191);
    __int16 v101 = 2080;
    id v102 = " ";
    uint64_t v103 = 1024;
    *(_DWORD *)v104 = v46;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v47;
    os_log_type_t v105 = 1024;
    *(_DWORD *)BOOL v106 = v16;
    *(_WORD *)&v106[4] = 2048;
    *(void *)&v106[6] = a5;
    os_log_type_t v48 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v48, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v49 = gconnectionLogObj;
        __int16 v50 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_108;
        }
        os_log_type_t v52 = *(_DWORD *)(v11 + 176);
        BOOL v51 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v51;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v52;
        os_log_type_t v105 = 1024;
        *(_DWORD *)BOOL v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(void *)&v106[6] = a5;
        uint64_t v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame";
        goto LABEL_107;
      }
      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v49 = gconnectionLogObj;
        __int16 v50 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_108;
        }
        char v65 = *(_DWORD *)(v11 + 176);
        BOOL v64 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v64;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v65;
        os_log_type_t v105 = 1024;
        *(_DWORD *)BOOL v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(void *)&v106[6] = a5;
        uint64_t v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame, backtrace limit exceeded";
        goto LABEL_107;
      }
      os_log_type_t v56 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v49 = gconnectionLogObj;
      __int16 v50 = type;
      char v57 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v56)
      {
        if (v57)
        {
          BOOL v59 = *(_DWORD *)(v11 + 176);
          char v58 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136448002;
          BOOL v98 = "on_data_chunk_recv_callback";
          __int16 v99 = 2082;
          id v100 = (const char *)(v11 + 191);
          __int16 v101 = 2080;
          id v102 = " ";
          uint64_t v103 = 1024;
          *(_DWORD *)v104 = v58;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = v59;
          os_log_type_t v105 = 1024;
          *(_DWORD *)BOOL v106 = v16;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          os_log_type_t v107 = 2082;
          id v108 = v56;
          _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_create_input_frame, dumping backtrace:%{public}s", buf, 0x46u);
        }
        free(v56);
        goto LABEL_108;
      }
      if (v57)
      {
        uint64_t v69 = *(_DWORD *)(v11 + 176);
        uint64_t v68 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v68;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v69;
        os_log_type_t v105 = 1024;
        *(_DWORD *)BOOL v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(void *)&v106[6] = a5;
        uint64_t v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame, no backtrace";
LABEL_107:
        _os_log_impl(&dword_1830D4000, v49, v50, v53, buf, 0x3Cu);
      }
    }
LABEL_108:
    if (v48) {
      free(v48);
    }
    goto LABEL_110;
  }
  memcpy(v34, a4, a5);
  *(void *)(v13 + 32) = 0;
  int v39 = *(uint64_t **)(v11 + 8);
  *(void *)(v13 + 40) = v39;
  *int v39 = v13;
  *(void *)(v11 + 8) = v13 + 32;
  uint64_t v40 = *(void *)(v11 + 80);
  *(void *)(v11 + 80) = v40 + a5;
  if (__CFADD__(v40, a5))
  {
    if (gLogDatapath)
    {
      char v87 = __nwlog_obj();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v88 = *(void *)(v11 + 80);
        *(_DWORD *)buf = 136446978;
        BOOL v98 = "increment_inbound_body_size";
        __int16 v99 = 2082;
        id v100 = "inbound_body_size";
        __int16 v101 = 2048;
        id v102 = (const char *)a5;
        uint64_t v103 = 2048;
        *(void *)v104 = v88;
        _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }
    }
    *(void *)(v11 + 80) = -1;
  }
  BOOL v41 = (*(unsigned __int8 *)(v11 + 190) >> 3) & 1;
  if (!gLogDatapath) {
    LOBYTE(v41) = 1;
  }
  if (*(_WORD *)(v11 + 188))
  {
    if ((v41 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v89 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        __int16 v91 = *(_DWORD *)(v11 + 176);
        os_log_type_t v90 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = (const char *)(v11 + 191);
        __int16 v101 = 2080;
        id v102 = " ";
        uint64_t v103 = 1024;
        *(_DWORD *)v104 = v90;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v91;
        os_log_type_t v105 = 2048;
        *(void *)BOOL v106 = *(void *)v95;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v91;
        _os_log_impl(&dword_1830D4000, v89, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling input_available on protocol %p for stream %d", buf, 0x3Cu);
      }
    }
    if (*(void *)v95)
    {
      id v54 = *(void *)(*(void *)v95 + 24);
      if (v54)
      {
        os_log_type_t v55 = *(void (**)(void))(v54 + 64);
        if (v55)
        {
          v55();
          return 0;
        }
      }
    }
    __nwlog_obj();
    os_log_type_t v78 = "invalid";
    if (*(void *)v95 && *(void *)(*(void *)v95 + 16)) {
      os_log_type_t v78 = *(const char **)(*(void *)v95 + 16);
    }
    *(_DWORD *)buf = 136446466;
    BOOL v98 = "on_data_chunk_recv_callback";
    __int16 v99 = 2082;
    id v100 = v78;
    os_log_type_t v79 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v79, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v80 = __nwlog_obj();
        BOOL v81 = type;
        if (!os_log_type_enabled(v80, type)) {
          goto LABEL_168;
        }
        os_log_type_t v82 = "invalid";
        if (*(void *)v95 && *(void *)(*(void *)v95 + 16)) {
          os_log_type_t v82 = *(const char **)(*(void *)v95 + 16);
        }
        *(_DWORD *)buf = 136446466;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = v82;
        os_log_type_t v83 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_167;
      }
      if (!v94)
      {
        os_log_type_t v80 = __nwlog_obj();
        BOOL v81 = type;
        if (!os_log_type_enabled(v80, type)) {
          goto LABEL_168;
        }
        os_log_type_t v92 = "invalid";
        if (*(void *)v95 && *(void *)(*(void *)v95 + 16)) {
          os_log_type_t v92 = *(const char **)(*(void *)v95 + 16);
        }
        *(_DWORD *)buf = 136446466;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = v92;
        os_log_type_t v83 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_167;
      }
      BOOL v84 = (char *)__nw_create_backtrace_string();
      os_log_type_t v80 = __nwlog_obj();
      BOOL v81 = type;
      os_log_type_t v85 = os_log_type_enabled(v80, type);
      if (v84)
      {
        if (v85)
        {
          char v86 = "invalid";
          if (*(void *)v95 && *(void *)(*(void *)v95 + 16)) {
            char v86 = *(const char **)(*(void *)v95 + 16);
          }
          *(_DWORD *)buf = 136446722;
          BOOL v98 = "on_data_chunk_recv_callback";
          __int16 v99 = 2082;
          id v100 = v86;
          __int16 v101 = 2082;
          id v102 = v84;
          _os_log_impl(&dword_1830D4000, v80, v81, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v84);
        goto LABEL_168;
      }
      if (v85)
      {
        __int16 v93 = "invalid";
        if (*(void *)v95 && *(void *)(*(void *)v95 + 16)) {
          __int16 v93 = *(const char **)(*(void *)v95 + 16);
        }
        *(_DWORD *)buf = 136446466;
        BOOL v98 = "on_data_chunk_recv_callback";
        __int16 v99 = 2082;
        id v100 = v93;
        os_log_type_t v83 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_167:
        _os_log_impl(&dword_1830D4000, v80, v81, v83, buf, 0x16u);
      }
    }
LABEL_168:
    if (v79) {
      free(v79);
    }
    return 0;
  }
  if (v41) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  int v42 = gconnectionLogObj;
  uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    os_log_type_t v45 = *(_DWORD *)(v11 + 176);
    BOOL v44 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    BOOL v98 = "on_data_chunk_recv_callback";
    __int16 v99 = 2082;
    id v100 = (const char *)(v11 + 191);
    __int16 v101 = 2080;
    id v102 = " ";
    uint64_t v103 = 1024;
    *(_DWORD *)v104 = v44;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v45;
    os_log_type_t v105 = 2048;
    *(void *)BOOL v106 = *(void *)v95;
    *(_WORD *)&v106[8] = 1024;
    *(_DWORD *)&v106[10] = v45;
    _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> suppressing input_available on protocol %p for stream %d that is not yet open", buf, 0x3Cu);
    return 0;
  }
  return result;
}

BOOL http2_transport_create_input_frame(uint64_t a1, uint64_t a2, size_t size)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v57 = "http2_transport_create_input_frame";
    int v28 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v28, type, &v55)) {
      goto LABEL_94;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (!os_log_type_enabled(v29, type[0])) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      char v57 = "http2_transport_create_input_frame";
      int v31 = "%{public}s called with null http2_transport";
LABEL_93:
      _os_log_impl(&dword_1830D4000, v29, v30, v31, buf, 0xCu);
      goto LABEL_94;
    }
    if (v55 == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v29, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v29 = __nwlog_obj();
    os_log_type_t v30 = type[0];
    BOOL v36 = os_log_type_enabled(v29, type[0]);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    if (!v36) {
      goto LABEL_76;
    }
    *(_DWORD *)buf = 136446466;
    char v57 = "http2_transport_create_input_frame";
    __int16 v58 = 2082;
    uint64_t v59 = (uint64_t)backtrace_string;
    os_log_type_t v37 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_1830D4000, v29, v30, v37, buf, 0x16u);
    goto LABEL_76;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v57 = "http2_transport_create_input_frame";
    int v28 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v28, type, &v55)) {
      goto LABEL_94;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (!os_log_type_enabled(v29, type[0])) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      char v57 = "http2_transport_create_input_frame";
      int v31 = "%{public}s called with null stream";
      goto LABEL_93;
    }
    if (v55 == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v29, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v29 = __nwlog_obj();
    os_log_type_t v30 = type[0];
    BOOL v38 = os_log_type_enabled(v29, type[0]);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null stream, no backtrace";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    if (!v38) {
      goto LABEL_76;
    }
    *(_DWORD *)buf = 136446466;
    char v57 = "http2_transport_create_input_frame";
    __int16 v58 = 2082;
    uint64_t v59 = (uint64_t)backtrace_string;
    os_log_type_t v37 = "%{public}s called with null stream, dumping backtrace:%{public}s";
    goto LABEL_75;
  }
  unsigned int v4 = size;
  if (!size)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v57 = "http2_transport_create_input_frame";
    int v28 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v28, type, &v55)) {
      goto LABEL_94;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v29, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null length";
        goto LABEL_93;
      }
LABEL_94:
      if (v28) {
        free(v28);
      }
      return 0;
    }
    if (v55 == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v29, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null length, backtrace limit exceeded";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v29 = __nwlog_obj();
    os_log_type_t v30 = type[0];
    BOOL v39 = os_log_type_enabled(v29, type[0]);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        char v57 = "http2_transport_create_input_frame";
        int v31 = "%{public}s called with null length, no backtrace";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      char v57 = "http2_transport_create_input_frame";
      __int16 v58 = 2082;
      uint64_t v59 = (uint64_t)backtrace_string;
      os_log_type_t v37 = "%{public}s called with null length, dumping backtrace:%{public}s";
      goto LABEL_75;
    }
LABEL_76:
    free(backtrace_string);
    goto LABEL_94;
  }
  *(void *)os_log_type_t type = 0;
  os_log_type_t v52 = type;
  uint64_t v53 = 0x2000000000;
  uint64_t v54 = 0;
  if (gLogDatapath)
  {
    int v32 = __nwlog_obj();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      char v57 = "http2_transport_create_input_frame";
      __int16 v58 = 2082;
      uint64_t v59 = a1 + 205;
      __int16 v60 = 1024;
      LODWORD(v61) = v4;
      _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s requested input frame of length %u", buf, 0x1Cu);
    }
  }
  v44[0] = MEMORY[0x1E4F143A8];
  v44[1] = 0x40000000;
  os_log_type_t v45 = ___ZL34http2_transport_create_input_frameP27nw_protocol_http2_transportP22http2_transport_streamj_block_invoke;
  BOOL v46 = &unk_1E5240B80;
  unsigned int v50 = v4;
  uint64_t v48 = a1;
  uint64_t v49 = a2;
  os_log_type_t v47 = type;
  uint64_t v6 = *(void *)(a1 + 160);
  do
  {
    if (!v6) {
      break;
    }
    uint64_t v7 = *(void *)(v6 + 16);
    char v8 = ((uint64_t (*)(void *))v45)(v44);
    uint64_t v6 = v7;
  }
  while ((v8 & 1) != 0);
  if (*((void *)v52 + 3)) {
    goto LABEL_9;
  }
  if (gLogDatapath)
  {
    uint64_t v40 = __nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      char v57 = "http2_transport_create_input_frame";
      __int16 v58 = 2082;
      uint64_t v59 = a1 + 205;
      __int16 v60 = 1024;
      LODWORD(v61) = v4;
      _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s no input frame to reuse for length %u", buf, 0x1Cu);
    }
  }
  uint64_t v11 = malloc_type_calloc(1uLL, v4, 0xEAFB8F1AuLL);
  if (v11)
  {
    uint64_t v12 = (uint64_t)v11;
    goto LABEL_16;
  }
  BOOL v41 = __nwlog_obj();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  char v57 = "strict_calloc";
  __int16 v58 = 2048;
  uint64_t v59 = 1;
  __int16 v60 = 2048;
  uint64_t v61 = v4;
  int v42 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v42);
  if (!result)
  {
    free(v42);
    uint64_t v12 = 0;
LABEL_16:
    uint64_t v13 = nw_frame_create(16, v12, v4, (uint64_t)nw_protocol_http2_transport_frame_input_finalizer, 0);
    *((void *)v52 + 3) = v13;
    if (v13)
    {
      if (http2_transport_input_frame_context_reset(v13, a1, a2))
      {
        if (!gLogDatapath)
        {
LABEL_10:
          uint64_t v9 = *((void *)v52 + 3);
LABEL_11:
          _Block_object_dispose(type, 8);
          return v9;
        }
        uint64_t v14 = __nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          char v57 = "http2_transport_create_input_frame";
          __int16 v58 = 2082;
          uint64_t v59 = a1 + 205;
          __int16 v60 = 1024;
          LODWORD(v61) = v4;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s allocated new input frame of length %u", buf, 0x1Cu);
        }
LABEL_9:
        if (gLogDatapath)
        {
          uint64_t v33 = __nwlog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v34 = *((void *)v52 + 3);
            *(_DWORD *)buf = 136446978;
            char v57 = "http2_transport_create_input_frame";
            __int16 v58 = 2082;
            uint64_t v59 = a1 + 205;
            __int16 v60 = 2048;
            uint64_t v61 = v34;
            __int16 v62 = 1024;
            unsigned int v63 = v4;
            _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s input_frame_create returning frame %p for requested length %u", buf, 0x26u);
          }
        }
        goto LABEL_10;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        char v57 = "http2_transport_create_input_frame";
        __int16 v58 = 2082;
        uint64_t v59 = a1 + 205;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s input frame has no metadata", buf, 0x16u);
      }
      buffer = (void *)nw_frame_get_buffer(*((void *)v52 + 3), 0);
      if (buffer) {
        free(buffer);
      }
      nw_frame_reset(*((void *)v52 + 3), 0, 0, 0, 0);
      id v21 = (void *)*((void *)v52 + 3);
      if (v21)
      {
        os_release(v21);
        uint64_t v9 = 0;
        *((void *)v52 + 3) = 0;
        goto LABEL_11;
      }
LABEL_44:
      uint64_t v9 = 0;
      goto LABEL_11;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    char v57 = "http2_transport_create_input_frame";
    int v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v55 = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v15, &v55, &v43))
    {
      if (v55 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v16 = gLogObj;
        os_log_type_t v17 = v55;
        if (os_log_type_enabled((os_log_t)gLogObj, v55))
        {
          *(_DWORD *)buf = 136446210;
          char v57 = "http2_transport_create_input_frame";
          uint64_t v18 = "%{public}s nw_frame_create new input frame failed";
LABEL_38:
          char v26 = v16;
          os_log_type_t v27 = v17;
LABEL_39:
          _os_log_impl(&dword_1830D4000, v26, v27, v18, buf, 0xCu);
        }
      }
      else if (v43)
      {
        os_log_type_t v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v23 = gLogObj;
        os_log_type_t v24 = v55;
        BOOL v25 = os_log_type_enabled((os_log_t)gLogObj, v55);
        if (v22)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            char v57 = "http2_transport_create_input_frame";
            __int16 v58 = 2082;
            uint64_t v59 = (uint64_t)v22;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s nw_frame_create new input frame failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v22);
          goto LABEL_40;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          char v57 = "http2_transport_create_input_frame";
          uint64_t v18 = "%{public}s nw_frame_create new input frame failed, no backtrace";
          char v26 = v23;
          os_log_type_t v27 = v24;
          goto LABEL_39;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v16 = gLogObj;
        os_log_type_t v17 = v55;
        if (os_log_type_enabled((os_log_t)gLogObj, v55))
        {
          *(_DWORD *)buf = 136446210;
          char v57 = "http2_transport_create_input_frame";
          uint64_t v18 = "%{public}s nw_frame_create new input frame failed, backtrace limit exceeded";
          goto LABEL_38;
        }
      }
    }
LABEL_40:
    if (v15) {
      free(v15);
    }
    if (v11) {
      free(v11);
    }
    goto LABEL_44;
  }
  __break(1u);
  return result;
}

uint64_t ___ZL34http2_transport_create_input_frameP27nw_protocol_http2_transportP22http2_transport_streamj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
    {
      unsigned int v4 = 0;
      uint64_t v5 = 0;
    }
    else
    {
      unsigned int v4 = *(_DWORD *)(a2 + 48);
      uint64_t v5 = *(void *)(a2 + 112);
    }
    if (gLogDatapath)
    {
      char v87 = __nwlog_obj();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v88 = *(void *)(a1 + 40);
        BOOL v89 = v88 == 0;
        *(_DWORD *)buf = 136446978;
        os_log_type_t v90 = (const char *)(v88 + 205);
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        if (v89) {
          os_log_type_t v90 = "";
        }
        __int16 v106 = 2082;
        os_log_type_t v107 = (void *)v90;
        __int16 v108 = 2048;
        *(void *)BOOL v109 = v5;
        *(_WORD *)&v109[8] = 1024;
        unsigned int v110 = v4;
        _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s existing frame found, buffer %p, length %u", buf, 0x26u);
      }
    }
    int v6 = *(_DWORD *)(a2 + 52);
    if (v6) {
      v6 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    }
    if (v6 == v4)
    {
      if (v5 && v4)
      {
        if (http2_transport_candidate_frame_length_is_match(v4, *(_DWORD *)(a1 + 56)))
        {
          uint64_t v8 = *(void *)(a2 + 16);
          uint64_t v9 = *(void **)(a2 + 24);
          if (v8)
          {
            *(void *)(v8 + 24) = v9;
            uint64_t v9 = *(void **)(a2 + 24);
          }
          else
          {
            *(void *)(*(void *)(a1 + 40) + 168) = v9;
          }
          void *v9 = v8;
          *(void *)(a2 + 16) = 0;
          *(void *)(a2 + 24) = 0;
          uint64_t v67 = *(void *)(a1 + 40);
          int v68 = *(_DWORD *)(v67 + 192);
          if (v68)
          {
            *(_DWORD *)(v67 + 192) = v68 - 1;
            goto LABEL_175;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          uint64_t v69 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v102 = 0;
          if (__nwlog_fault(v69, &type, &v102))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __int16 v70 = __nwlog_obj();
              os_log_type_t v71 = type;
              if (!os_log_type_enabled(v70, type)) {
                goto LABEL_173;
              }
              *(_DWORD *)buf = 136446210;
              os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
              __int16 v72 = "%{public}s http2_transport count attempted to decrement below zero";
              goto LABEL_172;
            }
            if (!v102)
            {
              __int16 v70 = __nwlog_obj();
              os_log_type_t v71 = type;
              if (!os_log_type_enabled(v70, type)) {
                goto LABEL_173;
              }
              *(_DWORD *)buf = 136446210;
              os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
              __int16 v72 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
              goto LABEL_172;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            __int16 v70 = __nwlog_obj();
            os_log_type_t v71 = type;
            BOOL v82 = os_log_type_enabled(v70, type);
            if (backtrace_string)
            {
              if (v82)
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
                __int16 v106 = 2082;
                os_log_type_t v107 = backtrace_string;
                _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(backtrace_string);
              goto LABEL_173;
            }
            if (v82)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
              __int16 v72 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_172:
              _os_log_impl(&dword_1830D4000, v70, v71, v72, buf, 0xCu);
            }
          }
LABEL_173:
          if (v69) {
            free(v69);
          }
LABEL_175:
          if (gLogDatapath)
          {
            __int16 v91 = __nwlog_obj();
            if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v92 = *(void *)(a1 + 40);
              __int16 v93 = "";
              os_log_type_t v94 = (const char *)(v92 + 205);
              BOOL v89 = v92 == 0;
              int v95 = *(_DWORD *)(a1 + 56);
              if (!v89) {
                __int16 v93 = v94;
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
              __int16 v106 = 2082;
              os_log_type_t v107 = (void *)v93;
              __int16 v108 = 1024;
              *(_DWORD *)BOOL v109 = v4;
              *(_WORD *)&v109[4] = 1024;
              *(_DWORD *)&v109[6] = v95;
              _os_log_impl(&dword_1830D4000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reusing input frame of length %u, adjusting to %u", buf, 0x22u);
            }
            int v86 = v4 - *(_DWORD *)(a1 + 56);
            if (!v86)
            {
              if (gLogDatapath)
              {
                nw_endpoint_t v96 = __nwlog_obj();
                if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v97 = *(void *)(a1 + 40);
                  if (v97) {
                    BOOL v98 = (const char *)(v97 + 205);
                  }
                  else {
                    BOOL v98 = "";
                  }
                  *(_DWORD *)buf = 136446466;
                  os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
                  __int16 v106 = 2082;
                  os_log_type_t v107 = (void *)v98;
                  _os_log_impl(&dword_1830D4000, v96, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s frame was exact match, not modifying", buf, 0x16u);
                }
              }
              goto LABEL_178;
            }
            if (gLogDatapath)
            {
              __int16 v99 = __nwlog_obj();
              if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v100 = *(void *)(a1 + 40);
                *(_DWORD *)buf = 136446722;
                os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
                if (v100) {
                  __int16 v101 = (const char *)(v100 + 205);
                }
                else {
                  __int16 v101 = "";
                }
                __int16 v106 = 2082;
                os_log_type_t v107 = (void *)v101;
                __int16 v108 = 1024;
                *(_DWORD *)BOOL v109 = v86;
                _os_log_impl(&dword_1830D4000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s claiming %u bytes off end of frame", buf, 0x1Cu);
              }
            }
          }
          else
          {
            int v86 = v4 - *(_DWORD *)(a1 + 56);
            if (!v86)
            {
LABEL_178:
              http2_transport_input_frame_context_reset(a2, *(void *)(a1 + 40), *(void *)(a1 + 48));
              uint64_t result = 0;
              *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
              return result;
            }
          }
          nw_frame_claim(a2, v7, 0, v86);
          goto LABEL_178;
        }
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = *(void *)(a1 + 40);
      if (v30) {
        int v31 = (const char *)(v30 + 205);
      }
      else {
        int v31 = "";
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
      __int16 v106 = 2082;
      os_log_type_t v107 = (void *)v31;
      int v32 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v102 = 0;
      if (__nwlog_fault(v32, &type, &v102))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = gLogObj;
          os_log_type_t v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_129;
          }
          uint64_t v35 = *(void *)(a1 + 40);
          if (v35) {
            BOOL v36 = (const char *)(v35 + 205);
          }
          else {
            BOOL v36 = "";
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v36;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer";
LABEL_128:
          _os_log_impl(&dword_1830D4000, v33, v34, v37, buf, 0x16u);
          goto LABEL_129;
        }
        if (!v102)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = gLogObj;
          os_log_type_t v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_129;
          }
          uint64_t v73 = *(void *)(a1 + 40);
          if (v73) {
            __int16 v74 = (const char *)(v73 + 205);
          }
          else {
            __int16 v74 = "";
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v74;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer, backtrace limit exceeded";
          goto LABEL_128;
        }
        int v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = gLogObj;
        os_log_type_t v34 = type;
        BOOL v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v42)
        {
          if (!v43) {
            goto LABEL_129;
          }
          uint64_t v75 = *(void *)(a1 + 40);
          if (v75) {
            uint64_t v76 = (const char *)(v75 + 205);
          }
          else {
            uint64_t v76 = "";
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v76;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer, no backtrace";
          goto LABEL_128;
        }
        if (v43)
        {
          uint64_t v44 = *(void *)(a1 + 40);
          if (v44) {
            os_log_type_t v45 = (const char *)(v44 + 205);
          }
          else {
            os_log_type_t v45 = "";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v45;
          __int16 v108 = 2082;
          *(void *)BOOL v109 = v42;
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s %{public}s destroying frame with NULL buffer, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v42);
      }
LABEL_129:
      if (v32) {
        free(v32);
      }
      uint64_t v77 = *(void *)(a2 + 16);
      os_log_type_t v78 = *(void **)(a2 + 24);
      if (v77)
      {
        *(void *)(v77 + 24) = v78;
        os_log_type_t v78 = *(void **)(a2 + 24);
      }
      else
      {
        *(void *)(*(void *)(a1 + 40) + 168) = v78;
      }
      *os_log_type_t v78 = v77;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      uint64_t v57 = *(void *)(a1 + 40);
      int v58 = *(_DWORD *)(v57 + 192);
      if (v58)
      {
LABEL_135:
        *(_DWORD *)(v57 + 192) = v58 - 1;
LABEL_161:
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(a2, *(void *)(a2 + 88)))
        {
          os_log_type_t v85 = *(void **)(a2 + 112);
          if (v85) {
            free(v85);
          }
        }
        nw_frame_reset(a2, 0, 0, 0, 0);
        os_release((void *)a2);
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
      uint64_t v59 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v102 = 0;
      if (!__nwlog_fault(v59, &type, &v102)) {
        goto LABEL_159;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v60 = gLogObj;
        os_log_type_t v61 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_159;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        __int16 v62 = "%{public}s http2_transport count attempted to decrement below zero";
        goto LABEL_157;
      }
      if (!v102)
      {
        __int16 v60 = __nwlog_obj();
        os_log_type_t v61 = type;
        if (!os_log_type_enabled(v60, type)) {
          goto LABEL_159;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        __int16 v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
        goto LABEL_157;
      }
      os_log_type_t v79 = (char *)__nw_create_backtrace_string();
      __int16 v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      BOOL v80 = os_log_type_enabled(v60, type);
      if (v79)
      {
        if (v80)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = v79;
          _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v79);
        if (!v59) {
          goto LABEL_161;
        }
        goto LABEL_160;
      }
      if (v80)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        __int16 v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_157:
        os_log_type_t v83 = v60;
        os_log_type_t v84 = v61;
LABEL_158:
        _os_log_impl(&dword_1830D4000, v83, v84, v62, buf, 0xCu);
        goto LABEL_159;
      }
      goto LABEL_159;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = *(void *)(a1 + 40);
    if (v18) {
      int v19 = (const char *)(v18 + 205);
    }
    else {
      int v19 = "";
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
    __int16 v106 = 2082;
    os_log_type_t v107 = (void *)v19;
    unsigned __int8 v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (__nwlog_fault(v20, &type, &v102))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v23 = *(void *)(a1 + 40);
          if (v23) {
            os_log_type_t v24 = (const char *)(v23 + 205);
          }
          else {
            os_log_type_t v24 = "";
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v24;
          BOOL v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying";
LABEL_93:
          _os_log_impl(&dword_1830D4000, v21, v22, v25, buf, 0x16u);
        }
      }
      else if (v102)
      {
        BOOL v38 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = gLogObj;
        os_log_type_t v22 = type;
        BOOL v39 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v38)
        {
          if (v39)
          {
            uint64_t v40 = *(void *)(a1 + 40);
            if (v40) {
              BOOL v41 = (const char *)(v40 + 205);
            }
            else {
              BOOL v41 = "";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
            __int16 v106 = 2082;
            os_log_type_t v107 = (void *)v41;
            __int16 v108 = 2082;
            *(void *)BOOL v109 = v38;
            _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v38);
          goto LABEL_94;
        }
        if (v39)
        {
          uint64_t v53 = *(void *)(a1 + 40);
          if (v53) {
            uint64_t v54 = (const char *)(v53 + 205);
          }
          else {
            uint64_t v54 = "";
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v54;
          BOOL v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, no backtrace";
          goto LABEL_93;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v48 = *(void *)(a1 + 40);
          if (v48) {
            uint64_t v49 = (const char *)(v48 + 205);
          }
          else {
            uint64_t v49 = "";
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v49;
          BOOL v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, backtrace limit exceeded";
          goto LABEL_93;
        }
      }
    }
LABEL_94:
    if (v20) {
      free(v20);
    }
    uint64_t v55 = *(void *)(a2 + 16);
    os_log_type_t v56 = *(void **)(a2 + 24);
    if (v55)
    {
      *(void *)(v55 + 24) = v56;
      os_log_type_t v56 = *(void **)(a2 + 24);
    }
    else
    {
      *(void *)(*(void *)(a1 + 40) + 168) = v56;
    }
    void *v56 = v55;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    uint64_t v57 = *(void *)(a1 + 40);
    int v58 = *(_DWORD *)(v57 + 192);
    if (v58) {
      goto LABEL_135;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
    uint64_t v59 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (!__nwlog_fault(v59, &type, &v102)) {
      goto LABEL_159;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v60 = gLogObj;
      os_log_type_t v61 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_159;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
      __int16 v62 = "%{public}s http2_transport count attempted to decrement below zero";
      goto LABEL_157;
    }
    if (!v102)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v60 = gLogObj;
      os_log_type_t v61 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_159;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
      __int16 v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
      goto LABEL_157;
    }
    unsigned int v63 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v64 = gLogObj;
    os_log_type_t v65 = type;
    BOOL v66 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v63)
    {
      if (!v66) {
        goto LABEL_159;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
      __int16 v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
      os_log_type_t v83 = v64;
      os_log_type_t v84 = v65;
      goto LABEL_158;
    }
    if (v66)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
      __int16 v106 = 2082;
      os_log_type_t v107 = v63;
      _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v63);
LABEL_159:
    if (!v59) {
      goto LABEL_161;
    }
LABEL_160:
    free(v59);
    goto LABEL_161;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10) {
    uint64_t v11 = (const char *)(v10 + 205);
  }
  else {
    uint64_t v11 = "";
  }
  *(_DWORD *)buf = 136446466;
  os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
  __int16 v106 = 2082;
  os_log_type_t v107 = (void *)v11;
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v102 = 0;
  if (__nwlog_fault(v12, &type, &v102))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        uint64_t v15 = *(void *)(a1 + 40);
        if (v15) {
          uint64_t v16 = (const char *)(v15 + 205);
        }
        else {
          uint64_t v16 = "";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        __int16 v106 = 2082;
        os_log_type_t v107 = (void *)v16;
        os_log_type_t v17 = "%{public}s %{public}s foreach gave null candidate_frame";
LABEL_84:
        _os_log_impl(&dword_1830D4000, v13, v14, v17, buf, 0x16u);
      }
    }
    else if (v102)
    {
      char v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = gLogObj;
      os_log_type_t v14 = type;
      BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v27)
        {
          uint64_t v28 = *(void *)(a1 + 40);
          if (v28) {
            uint64_t v29 = (const char *)(v28 + 205);
          }
          else {
            uint64_t v29 = "";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
          __int16 v106 = 2082;
          os_log_type_t v107 = (void *)v29;
          __int16 v108 = 2082;
          *(void *)BOOL v109 = v26;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s %{public}s foreach gave null candidate_frame, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v26);
        goto LABEL_85;
      }
      if (v27)
      {
        uint64_t v50 = *(void *)(a1 + 40);
        if (v50) {
          BOOL v51 = (const char *)(v50 + 205);
        }
        else {
          BOOL v51 = "";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        __int16 v106 = 2082;
        os_log_type_t v107 = (void *)v51;
        os_log_type_t v17 = "%{public}s %{public}s foreach gave null candidate_frame, no backtrace";
        goto LABEL_84;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        uint64_t v46 = *(void *)(a1 + 40);
        if (v46) {
          os_log_type_t v47 = (const char *)(v46 + 205);
        }
        else {
          os_log_type_t v47 = "";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v105 = "http2_transport_create_input_frame_block_invoke";
        __int16 v106 = 2082;
        os_log_type_t v107 = (void *)v47;
        os_log_type_t v17 = "%{public}s %{public}s foreach gave null candidate_frame, backtrace limit exceeded";
        goto LABEL_84;
      }
    }
  }
LABEL_85:
  if (v12) {
    free(v12);
  }
  return 0;
}

BOOL http2_transport_candidate_frame_length_is_match(unsigned int a1, unsigned int a2)
{
  *(void *)&v17[5] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v5, &type, &v12)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
      uint64_t v8 = "%{public}s called with null length";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
          __int16 v16 = 2082;
          *(void *)os_log_type_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null length, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_23;
      }
      if (!v11)
      {
LABEL_23:
        if (v5) {
          free(v5);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
      uint64_t v8 = "%{public}s called with null length, no backtrace";
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
      uint64_t v8 = "%{public}s called with null length, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_23;
  }
  if (*MEMORY[0x1E4F14B00] + (unint64_t)a2 >= a1) {
    return a1 >= a2;
  }
  if (!gLogDatapath) {
    return 0;
  }
  uint64_t v9 = __nwlog_obj();
  BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446722;
    uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
    __int16 v16 = 1024;
    *(_DWORD *)os_log_type_t v17 = a1;
    v17[2] = 1024;
    *(_DWORD *)&v17[3] = a2;
    _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s candidate frame (%u bytes) is too much larger than requested (%u bytes), skipping", buf, 0x18u);
    return 0;
  }
  return result;
}

uint64_t nw_http2_transport_get_stream_from_id(uint64_t a1, int a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v28 = "nw_http2_transport_get_stream_from_id";
    __int16 v29 = 2082;
    uint64_t v30 = a1 + 205;
    __int16 v31 = 1024;
    LODWORD(v32) = a2;
    BOOL v11 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL stream";
    char v12 = v10;
    os_log_type_t v13 = OS_LOG_TYPE_ERROR;
LABEL_9:
    _os_log_impl(&dword_1830D4000, v12, v13, v11, buf, 0x1Cu);
    return 0;
  }
  uint64_t stream_node_from_id = nw_http2_transport_get_stream_node_from_id(a1, a2);
  if (!stream_node_from_id)
  {
    if (!gLogDatapath) {
      return 0;
    }
    os_log_type_t v14 = __nwlog_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
      return 0;
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v28 = "nw_http2_transport_get_stream_from_id";
    __int16 v29 = 2082;
    uint64_t v30 = a1 + 205;
    __int16 v31 = 1024;
    LODWORD(v32) = a2;
    BOOL v11 = "%{public}s %{public}s stream %d not found in id based hash table";
    char v12 = v14;
    os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
    goto LABEL_9;
  }
  uint64_t v7 = stream_node_from_id;
  uint64_t result = *(void *)(stream_node_from_id + 16);
  if (!result)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = a1 + 205;
    *(_DWORD *)buf = 136446722;
    uint64_t v28 = "nw_http2_transport_get_stream_from_id";
    __int16 v29 = 2082;
    uint64_t v30 = a1 + 205;
    __int16 v31 = 2048;
    uint64_t v32 = v7;
    __int16 v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v16, &type, &v25)) {
      goto LABEL_31;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v28 = "nw_http2_transport_get_stream_from_id";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      uint64_t v32 = v7;
      int v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra";
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = gLogObj;
      os_log_type_t v18 = type;
      BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v28 = "nw_http2_transport_get_stream_from_id";
          __int16 v29 = 2082;
          uint64_t v30 = v15;
          __int16 v31 = 2048;
          uint64_t v32 = v7;
          __int16 v33 = 2082;
          os_log_type_t v34 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s %{public}s hash node %p didn't have a stream as extra, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(backtrace_string);
        goto LABEL_31;
      }
      if (!v21)
      {
LABEL_31:
        if (v16) {
          free(v16);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v28 = "nw_http2_transport_get_stream_from_id";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      uint64_t v32 = v7;
      int v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v28 = "nw_http2_transport_get_stream_from_id";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      uint64_t v32 = v7;
      int v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0x20u);
    goto LABEL_31;
  }
  if (a3)
  {
    uint64_t v9 = *(void *)(v7 + 32);
    if (v9)
    {
      *a3 = v9;
    }
    else if (gLogDatapath)
    {
      uint64_t v22 = result;
      uint64_t v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        int v24 = *(_DWORD *)(v22 + 32);
        *(_DWORD *)buf = 136446722;
        uint64_t v28 = "nw_http2_transport_get_stream_from_id";
        __int16 v29 = 2082;
        uint64_t v30 = a1 + 205;
        __int16 v31 = 1024;
        LODWORD(v32) = v24;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s no input handler attached to stream %d, ignoring", buf, 0x1Cu);
      }
      return v22;
    }
  }
  return result;
}

BOOL nw_http2_transport_get_stream_node_from_id(uint64_t a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v19 = a2;
  uint64_t v3 = *(void *)(a1 + 120);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v11, &type, &v17)) {
      goto LABEL_25;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_id";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null http2_transport->http2_transport_streams_id, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_25;
      }
      if (!v16)
      {
LABEL_25:
        if (v11) {
          free(v11);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_id, no backtrace";
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_id, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
    goto LABEL_25;
  }
  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
      __int16 v22 = 2082;
      uint64_t v23 = (char *)(a1 + 205);
      __int16 v24 = 1024;
      int v25 = a2;
      uint64_t v7 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL hash node";
      uint64_t v8 = v10;
      os_log_type_t v9 = OS_LOG_TYPE_ERROR;
      goto LABEL_8;
    }
  }
  else
  {
    BOOL result = nw_hash_table_get_node(v3, (uint64_t)&v19, 4);
    if (result) {
      return result;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      BOOL v21 = "nw_http2_transport_get_stream_node_from_id";
      __int16 v22 = 2082;
      uint64_t v23 = (char *)(a1 + 205);
      __int16 v24 = 1024;
      int v25 = v19;
      uint64_t v7 = "%{public}s %{public}s requested stream id (%d) not found, returning NULL";
      uint64_t v8 = v6;
      os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
LABEL_8:
      _os_log_impl(&dword_1830D4000, v8, v9, v7, buf, 0x1Cu);
    }
  }
  return 0;
}

BOOL ___ZL32nw_protocol_setup_udp_definitionv_block_invoke()
{
  if (nw_protocol_udp_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_udp_identifier::onceToken, &__block_literal_global_23);
  }
  CFStringRef v0 = nw_protocol_definition_create_with_identifier((long long *)&nw_protocol_udp_identifier::identifier);
  uint64_t v1 = (void *)g_udp_definition;
  g_udp_definition = (uint64_t)v0;

  nw_protocol_definition_set_options_allocator((void *)g_udp_definition, (uint64_t)nw_udp_allocate_options, (uint64_t)nw_udp_copy_options, (uint64_t)nw_udp_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)g_udp_definition, (uint64_t)nw_udp_option_is_equal);
  nw_protocol_definition_set_options_serializer((void *)g_udp_definition, 0, (uint64_t)nw_udp_serialize_options, (uint64_t)nw_udp_deserialize_options);
  nw_protocol_definition_set_metadata_allocator((void *)g_udp_definition, (uint64_t)nw_udp_allocate_metadata, (uint64_t)nw_udp_deallocate_metadata);
  nw_protocol_definition_set_has_global_definition((void *)g_udp_definition);
  int v2 = (void *)g_udp_definition;

  return nw_protocol_register_handle((uint64_t)&nw_protocol_udp_identifier::identifier, v2, (uint64_t)nw_protocol_udp_create, 0);
}

void nw_protocol_definition_set_has_global_definition(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    *((unsigned char *)v1 + 184) |= 0x40u;
    goto LABEL_3;
  }
  uint64_t v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
  unsigned int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

void ___ZL32nw_protocol_setup_tcp_definitionv_block_invoke()
{
  CFStringRef v0 = (long long *)nw_protocol_tcp_identifier();
  id v1 = nw_protocol_definition_create_with_identifier(v0);
  int v2 = (void *)g_tcp_definition;
  g_tcp_definition = (uint64_t)v1;

  nw_protocol_definition_set_options_allocator((void *)g_tcp_definition, (uint64_t)nw_tcp_allocate_options, (uint64_t)nw_tcp_copy_options, (uint64_t)nw_tcp_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)g_tcp_definition, (uint64_t)nw_tcp_option_is_equal);
  nw_protocol_definition_set_metadata_allocator((void *)g_tcp_definition, (uint64_t)nw_tcp_allocate_metadata, (uint64_t)nw_tcp_deallocate_metadata);
  nw_protocol_definition_set_context_globals_allocator((void *)g_tcp_definition, nw_tcp_allocate_globals, nw_tcp_deallocate_globals);
  uint64_t v3 = (void *)g_tcp_definition;

  nw_protocol_definition_set_has_global_definition(v3);
}

void nw_protocol_definition_set_options_allocator(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    BOOL v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v36 = "nw_protocol_definition_set_options_allocator";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v36 = "nw_protocol_definition_set_options_allocator";
          __int16 v37 = 2082;
          BOOL v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v10) {
          goto LABEL_6;
        }
LABEL_73:
        free(v10);
        goto LABEL_6;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v11 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v29, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_71:

    goto LABEL_72;
  }
  if (!a2)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v36 = "nw_protocol_definition_set_options_allocator";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v30, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    __int16 v22 = (char *)__nw_create_backtrace_string();
    char v11 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v36 = "nw_protocol_definition_set_options_allocator";
      __int16 v37 = 2082;
      BOOL v38 = v22;
      _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a3)
  {
    __int16 v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v36 = "nw_protocol_definition_set_options_allocator";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null copy_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v31, "%{public}s called with null copy_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    __int16 v22 = (char *)__nw_create_backtrace_string();
    char v11 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null copy_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v36 = "nw_protocol_definition_set_options_allocator";
      __int16 v37 = 2082;
      BOOL v38 = v22;
      _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null copy_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a4)
  {
    uint64_t v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v36 = "nw_protocol_definition_set_options_allocator";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v32, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    __int16 v22 = (char *)__nw_create_backtrace_string();
    char v11 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v28 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v36 = "nw_protocol_definition_set_options_allocator";
      __int16 v37 = 2082;
      BOOL v38 = v22;
      _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v22);
    if (!v10) {
      goto LABEL_6;
    }
    goto LABEL_73;
  }
  v7[11] = a2;
  v7[12] = a3;
  v7[13] = a4;
LABEL_6:
}

void nw_protocol_definition_set_options_equality_check(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  unsigned int v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_definition_set_options_equality_check";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v22 = "nw_protocol_definition_set_options_equality_check";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *((void *)v3 + 14) = a2;
    goto LABEL_4;
  }
  BOOL v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v22 = "nw_protocol_definition_set_options_equality_check";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_definition_set_options_equality_check";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null check_equality_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_definition_set_options_equality_check";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null check_equality_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v14 = (char *)__nw_create_backtrace_string();
  uint64_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_definition_set_options_equality_check";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null check_equality_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v22 = "nw_protocol_definition_set_options_equality_check";
    __int16 v23 = 2082;
    BOOL v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null check_equality_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void nw_protocol_definition_set_metadata_allocator(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
          __int16 v30 = 2082;
          os_log_type_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    char v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    BOOL v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
      __int16 v30 = 2082;
      os_log_type_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    BOOL v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
      __int16 v30 = 2082;
      os_log_type_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  *((void *)v5 + 18) = a2;
  *((void *)v5 + 19) = a3;
LABEL_5:
}

void nw_protocol_definition_set_context_globals_allocator(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
          __int16 v30 = 2082;
          os_log_type_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    char v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    BOOL v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
      __int16 v30 = 2082;
      os_log_type_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    BOOL v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_definition_set_context_globals_allocator";
      __int16 v30 = 2082;
      os_log_type_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_common_state(v5);
  v6->common_state->var1 = a2;
  v6->common_state->var2 = a3;
LABEL_5:
}

void sub_18335FEE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_enable_l4s(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_enable_l4s_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_quic_connection_get_enable_l4s";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_get_enable_l4s";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_connection_get_enable_l4s";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_get_enable_l4s";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_get_enable_l4s";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_18336020C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_protocol_instance_async_if_needed(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    os_log_type_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_protocol_instance_async_if_needed";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v28 = "nw_protocol_instance_async_if_needed";
          __int16 v29 = 2082;
          __int16 v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_56:
        free(v7);
        goto LABEL_5;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v22, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  id v5 = (void *)v3[15];
  if (!v5)
  {
    BOOL v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_protocol_instance_async_if_needed";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null instance->context", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v25)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v23, "%{public}s called with null instance->context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v17 = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null instance->context, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v28 = "nw_protocol_instance_async_if_needed";
      __int16 v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null instance->context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v4)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_protocol_instance_async_if_needed";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null block", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v25)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v24, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v17 = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v28 = "nw_protocol_instance_async_if_needed";
      __int16 v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v17);
    if (!v7) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_queue_context_async_if_needed(v5, v4);
LABEL_5:
}

void sub_1833608F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_monitor_set_queue(nw_path_monitor_t monitor, dispatch_queue_t queue)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = monitor;
  id v4 = queue;
  id v5 = v4;
  if (!v3)
  {
    os_log_type_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_path_monitor_set_queue";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_path_monitor_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v23 = "nw_path_monitor_set_queue";
          __int16 v24 = 2082;
          char v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_path_monitor_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_path_monitor_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    nw_path_evaluator_set_queue(v3, v4);
    goto LABEL_4;
  }
  BOOL v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_path_monitor_set_queue";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_path_monitor_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_path_monitor_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_path_monitor_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v23 = "nw_path_monitor_set_queue";
    __int16 v24 = 2082;
    char v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

void nw_path_evaluator_set_queue(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    BOOL v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_path_evaluator_set_queue";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_evaluator_set_queue";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v31 = "nw_path_evaluator_set_queue";
          __int16 v32 = 2082;
          char v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v15) {
          goto LABEL_24;
        }
LABEL_59:
        free(v15);
        goto LABEL_24;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_evaluator_set_queue";
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_evaluator_set_queue";
        _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_57:

    goto LABEL_58;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 24);
    if ((*((unsigned char *)v3 + 107) & 0x10) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      uint64_t v31 = "nw_path_evaluator_set_queue";
      os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v28 = 0;
      if (__nwlog_fault(v7, &type, &v28))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v8 = (id)gLogObj;
          os_log_type_t v9 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v31 = "nw_path_evaluator_set_queue";
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Client error: set queue after starting", buf, 0xCu);
          }
        }
        else if (v28)
        {
          BOOL v10 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v8 = (id)gLogObj;
          os_log_type_t v11 = type;
          BOOL v12 = os_log_type_enabled(v8, type);
          if (v10)
          {
            if (v12)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v31 = "nw_path_evaluator_set_queue";
              __int16 v32 = 2082;
              char v33 = v10;
              _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s Client error: set queue after starting, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v10);
            if (!v7) {
              goto LABEL_23;
            }
            goto LABEL_22;
          }
          if (v12)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v31 = "nw_path_evaluator_set_queue";
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s Client error: set queue after starting, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v8 = (id)gLogObj;
          os_log_type_t v13 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v31 = "nw_path_evaluator_set_queue";
            _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s Client error: set queue after starting, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (v7) {
LABEL_22:
      }
        free(v7);
    }
LABEL_23:
    objc_storeStrong((id *)v3 + 7, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 24);
    goto LABEL_24;
  }
  os_log_type_t v18 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v31 = "nw_path_evaluator_set_queue";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (!__nwlog_fault(v15, &type, &v28)) {
    goto LABEL_58;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v16 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_57;
  }
  if (!v28)
  {
    os_log_type_t v16 = __nwlog_obj();
    os_log_type_t v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_57;
  }
  os_log_type_t v23 = (char *)__nw_create_backtrace_string();
  os_log_type_t v16 = __nwlog_obj();
  os_log_type_t v24 = type;
  BOOL v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_57;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v31 = "nw_path_evaluator_set_queue";
    __int16 v32 = 2082;
    char v33 = v23;
    _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15) {
    goto LABEL_59;
  }
LABEL_24:
}

BOOL nw_path_has_dns(nw_path_t path)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = path;
  uint64_t v2 = v1;
  if (!v1)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_path_has_dns";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_path_has_dns";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v17 = "nw_path_has_dns";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_path_has_dns";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_path_has_dns";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  nw_path_update_dns(v1);
  resolver_configs = v2->resolver_configs;
  if (!resolver_configs)
  {
LABEL_22:
    BOOL v4 = 0;
    goto LABEL_23;
  }
  BOOL v4 = resolver_configs[3].super.super.isa != resolver_configs[2].super.super.isa;
LABEL_23:

  return v4;
}

void sub_1833617CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_has_signature(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((void *)v1 + 24) != 0;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_has_signature";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_has_signature";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_has_signature";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_has_signature";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_has_signature";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

void nw_activity_set_global_parent(void *a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if ((v1[140] & 8) == 0)
    {
      *(void *)__int16 v37 = 0;
      *(void *)&v37[8] = v37;
      *(void *)&v37[16] = 0x2020000000;
      char v38 = 0;
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3221225472;
      aBlock[2] = __nw_activity_set_global_parent_block_invoke_61;
      aBlock[3] = &unk_1E524B978;
      BOOL v3 = v1;
      id v26 = v3;
      os_log_type_t v27 = v37;
      BOOL v4 = _Block_copy(aBlock);
      char v28 = v4;
      nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>((os_unfair_lock_s *)&global_parent_lock, (uint64_t)&v28);

      if (!*(unsigned char *)(*(void *)&v37[8] + 24))
      {
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        id v5 = (id)gactivityLogObj;
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          __int16 v32 = v3;
          _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEFAULT, "Set activity %{public}@ as the global parent", buf, 0xCu);
        }

LABEL_9:
        _Block_object_dispose(v37, 8);
        goto LABEL_19;
      }
      os_log_type_t v12 = __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      __int16 v32 = "nw_activity_set_global_parent";
      __int16 v33 = 2082;
      uint64_t v34 = "Global parent activity is immutable and cannot be set to a different activity";
      char v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v24 = 0;
      if (__nwlog_fault(v13, &type, &v24))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v14 = __nwlog_obj();
          os_log_type_t v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v32 = "nw_activity_set_global_parent";
            __int16 v33 = 2082;
            uint64_t v34 = "Global parent activity is immutable and cannot be set to a different activity";
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
          }
        }
        else if (v24)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          char v14 = __nwlog_obj();
          os_log_type_t v20 = type;
          BOOL v21 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v21)
            {
              *(_DWORD *)buf = 136446722;
              __int16 v32 = "nw_activity_set_global_parent";
              __int16 v33 = 2082;
              uint64_t v34 = "Global parent activity is immutable and cannot be set to a different activity";
              __int16 v35 = 2082;
              BOOL v36 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v14, v20, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(backtrace_string);
            goto LABEL_54;
          }
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v32 = "nw_activity_set_global_parent";
            __int16 v33 = 2082;
            uint64_t v34 = "Global parent activity is immutable and cannot be set to a different activity";
            _os_log_impl(&dword_1830D4000, v14, v20, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
          }
        }
        else
        {
          char v14 = __nwlog_obj();
          os_log_type_t v23 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v32 = "nw_activity_set_global_parent";
            __int16 v33 = 2082;
            uint64_t v34 = "Global parent activity is immutable and cannot be set to a different activity";
            _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
        }
      }
LABEL_54:
      if (v13) {
        free(v13);
      }
      goto LABEL_9;
    }
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)__int16 v37 = 136446210;
    *(void *)&v37[4] = "nw_activity_set_global_parent";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v9, buf, &type)) {
      goto LABEL_49;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = buf[0];
      if (os_log_type_enabled(v10, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v37 = 136446210;
        *(void *)&v37[4] = "nw_activity_set_global_parent";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", v37, 0xCu);
      }
    }
    else if (type)
    {
      os_log_type_t v16 = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v17 = buf[0];
      BOOL v18 = os_log_type_enabled(v10, (os_log_type_t)buf[0]);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)__int16 v37 = 136446466;
          *(void *)&v37[4] = "nw_activity_set_global_parent";
          *(_WORD *)&v37[12] = 2082;
          *(void *)&v37[14] = v16;
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", v37, 0x16u);
        }

        free(v16);
        goto LABEL_49;
      }
      if (v18)
      {
        *(_DWORD *)__int16 v37 = 136446210;
        *(void *)&v37[4] = "nw_activity_set_global_parent";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", v37, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v10, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v37 = 136446210;
        *(void *)&v37[4] = "nw_activity_set_global_parent";
        _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", v37, 0xCu);
      }
    }

LABEL_49:
    if (v9) {
      free(v9);
    }
    goto LABEL_19;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  id v6 = (id)gactivityLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int16 v37 = 138543362;
    *(void *)&v37[4] = global_parent;
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, "Unsetting the global parent activity %{public}@", v37, 0xCu);
  }

  __int16 v30 = &__block_literal_global_60_58745;
  nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>((os_unfair_lock_s *)&global_parent_lock, (uint64_t)&v30);

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  os_log_type_t v7 = (id)gactivityLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v37 = 0;
    _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "Unset the global parent activity", v37, 2u);
  }

LABEL_19:
}

void sub_1833621D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_216(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  BOOL v4 = a3;
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16);
  if (v5 && !nw_path_parameters_get_logging_disabled(*(void *)(v5 + 104)))
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
    }
    id v6 = (id)glistenerLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
      int v30 = 136446722;
      uint64_t v31 = "nw_listener_reconcile_inboxes_on_queue_block_invoke";
      __int16 v32 = 2082;
      __int16 v33 = id_string;
      __int16 v34 = 2114;
      __int16 v35 = v4;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s [%{public}s] creating new flow for %{public}@", (uint8_t *)&v30, 0x20u);
    }
  }
  os_log_type_t v8 = -[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]((id *)[nw_ip_channel_inbox alloc], *(void **)(*(void *)(a1 + 32) + 176), v4, *(void **)(*(void *)(a1 + 32) + 208), *(void **)(a1 + 32));
  os_log_type_t v9 = v8;
  if (v8)
  {
    uint64_t v10 = [v8 start];
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    os_log_type_t v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 16);
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
    {
      if (v13 && !nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        char v14 = (id)glistenerLogObj;
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        os_log_type_t v15 = nw_listener_get_id_string(*(void **)(a1 + 32));
        os_log_type_t v16 = *(id **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
        uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 208);
        int v30 = 136447234;
        uint64_t v31 = "nw_listener_reconcile_inboxes_on_queue_block_invoke";
        __int16 v32 = 2082;
        __int16 v33 = v15;
        __int16 v34 = 2114;
        __int16 v35 = v16;
        __int16 v36 = 2114;
        __int16 v37 = v9;
        __int16 v38 = 2114;
        uint64_t v39 = v17;
        BOOL v18 = "%{public}s [%{public}s] Error %{public}@ starting inbox %{public}@. Parameters: %{public}@";
        uint64_t v19 = v14;
        os_log_type_t v20 = OS_LOG_TYPE_ERROR;
        uint32_t v21 = 52;
LABEL_22:
        _os_log_impl(&dword_1830D4000, v19, v20, v18, (uint8_t *)&v30, v21);
LABEL_23:
      }
    }
    else
    {
      if (v13 && !nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        BOOL v25 = (id)glistenerLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          id v26 = nw_listener_get_id_string(*(void **)(a1 + 32));
          os_log_type_t v27 = *(id **)(*(void *)(a1 + 32) + 208);
          int v30 = 136446978;
          uint64_t v31 = "nw_listener_reconcile_inboxes_on_queue_block_invoke";
          __int16 v32 = 2082;
          __int16 v33 = v26;
          __int16 v34 = 2114;
          __int16 v35 = v9;
          __int16 v36 = 2114;
          __int16 v37 = v27;
          _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public}s] Started inbox %{public}@ with parameters %{public}@", (uint8_t *)&v30, 0x2Au);
        }
      }
      nw_array_append(*(void *)(*(void *)(a1 + 32) + 144), v9);
    }
  }
  else
  {
    uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 16);
    if (v22 && !nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      char v14 = (id)glistenerLogObj;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      os_log_type_t v23 = nw_listener_get_id_string(*(void **)(a1 + 32));
      char v24 = *(id **)(*(void *)(a1 + 32) + 208);
      int v30 = 136446722;
      uint64_t v31 = "nw_listener_reconcile_inboxes_on_queue_block_invoke";
      __int16 v32 = 2082;
      __int16 v33 = v23;
      __int16 v34 = 2114;
      __int16 v35 = v24;
      BOOL v18 = "%{public}s [%{public}s] Failed to create IP channel flow for %{public}@";
      uint64_t v19 = v14;
      os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
      uint32_t v21 = 32;
      goto LABEL_22;
    }
  }
  BOOL v28 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;

  return v28;
}

void sub_18336261C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1833641F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_channel_add_input_handler(nw_protocol *a1, nw_protocol *uu)
{
  *(void *)&v59[13] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_channel_add_input_handler";
    id v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v6, &type, &v54)) {
      goto LABEL_98;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null channel_protocol";
    }
    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v52 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v52) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v57 = "nw_channel_add_input_handler";
        __int16 v58 = 2082;
        *(void *)uint64_t v59 = backtrace_string;
        uint64_t v46 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
        goto LABEL_82;
      }
      if (!v52) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null channel_protocol, no backtrace";
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
    }
    goto LABEL_96;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_channel_add_input_handler";
    id v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v6, &type, &v54)) {
      goto LABEL_98;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null channel";
    }
    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v53 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v53) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v57 = "nw_channel_add_input_handler";
        __int16 v58 = 2082;
        *(void *)uint64_t v59 = backtrace_string;
        uint64_t v46 = "%{public}s called with null channel, dumping backtrace:%{public}s";
        goto LABEL_82;
      }
      if (!v53)
      {
LABEL_98:
        if (v6) {
          free(v6);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null channel, backtrace limit exceeded";
    }
LABEL_96:
    __int16 v38 = v7;
    os_log_type_t v39 = v8;
    goto LABEL_97;
  }
  if (!uu)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_channel_add_input_handler";
    id v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v6, &type, &v54)) {
      goto LABEL_98;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null input_protocol";
    }
    else
    {
      if (v54)
      {
        uint64_t v11 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = gLogObj;
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v11)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v57 = "nw_channel_add_input_handler";
            __int16 v58 = 2082;
            *(void *)uint64_t v59 = v11;
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v11);
          goto LABEL_98;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "nw_channel_add_input_handler";
          os_log_type_t v9 = "%{public}s called with null input_protocol, no backtrace";
          __int16 v38 = v12;
          os_log_type_t v39 = v13;
LABEL_97:
          _os_log_impl(&dword_1830D4000, v38, v39, v9, buf, 0xCu);
          goto LABEL_98;
        }
        goto LABEL_98;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      os_log_type_t v9 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    }
    goto LABEL_96;
  }
  if (!uuid_is_null(uu->flow_id))
  {
    *((_WORD *)handle + 222) |= 0x100u;
    uint64_t internal = *((void *)handle + 35);
    if (internal) {
      goto LABEL_22;
    }
LABEL_20:
    uint64_t internal = nw_hash_table_create_internal(0x11u, 128, (const void *(*)(const void *, unsigned int *))nw_protocol_get_key, (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key, 0);
    if (internal)
    {
      *(_DWORD *)(internal + 48) &= ~2u;
      *((void *)handle + 35) = internal;
      goto LABEL_22;
    }
    *((void *)handle + 35) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_channel_add_input_handler";
    id v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (__nwlog_fault(v6, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "nw_channel_add_input_handler";
        os_log_type_t v9 = "%{public}s nw_protocol_hash_table_create failed";
        goto LABEL_96;
      }
      if (!v54)
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "nw_channel_add_input_handler";
        os_log_type_t v9 = "%{public}s nw_protocol_hash_table_create failed, backtrace limit exceeded";
        goto LABEL_96;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v45 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v45) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "nw_channel_add_input_handler";
        os_log_type_t v9 = "%{public}s nw_protocol_hash_table_create failed, no backtrace";
        goto LABEL_96;
      }
      if (!v45)
      {
LABEL_83:
        free(backtrace_string);
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v57 = "nw_channel_add_input_handler";
      __int16 v58 = 2082;
      *(void *)uint64_t v59 = backtrace_string;
      uint64_t v46 = "%{public}s nw_protocol_hash_table_create failed, dumping backtrace:%{public}s";
LABEL_82:
      _os_log_impl(&dword_1830D4000, v7, v8, v46, buf, 0x16u);
      goto LABEL_83;
    }
    goto LABEL_98;
  }
  if (*((void *)handle + 34))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_channel_add_input_handler";
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s Channel already has input handler registered as default", buf, 0xCu);
    }
    return 0;
  }
  *((void *)handle + 34) = uu;
  uint64_t internal = *((void *)handle + 35);
  if (!internal) {
    goto LABEL_20;
  }
LABEL_22:
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  BOOL v15 = nw_hash_table_add_object(internal, (uint64_t)uu, (char *)&type);
  BOOL v16 = type != OS_LOG_TYPE_DEFAULT;
  if (type)
  {
    uint64_t v17 = (void *)v15;
    uint64_t extra = nw_hash_node_get_extra(v15);
    *(_OWORD *)uint64_t extra = 0u;
    *(_OWORD *)(extra + 16) = 0u;
    *(_OWORD *)(extra + 32) = 0u;
    *(_OWORD *)(extra + 48) = 0u;
    *(_OWORD *)(extra + 64) = 0u;
    *(_OWORD *)(extra + 80) = 0u;
    *(_OWORD *)(extra + 96) = 0u;
    *(_OWORD *)(extra + 112) = 0u;
    *(void *)(extra + 8) = extra;
    if (!uuid_is_null((const unsigned __int8 *)handle + 352)
      && !uuid_compare((const unsigned __int8 *)handle + 352, uu->flow_id))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v57 = "nw_channel_add_input_handler";
        __int16 v58 = 1042;
        *(_DWORD *)uint64_t v59 = 16;
        v59[2] = 2098;
        *(void *)&v59[3] = uu;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s Adding pending input frames for %{public,uuid_t}.16P", buf, 0x1Cu);
      }
      uint64_t v20 = *((void *)handle + 42);
      if (v20)
      {
        **(void **)(extra + 8) = v20;
        *(void *)(*((void *)handle + 42) + 40) = *(void *)(extra + 8);
        *(void *)(extra + 8) = *((void *)handle + 43);
        *((void *)handle + 42) = 0;
        *((void *)handle + 43) = handle + 336;
      }
      uuid_clear((unsigned __int8 *)handle + 352);
      uint64_t v21 = *((void *)handle + 24);
      if (v21)
      {
        nw_queue_cancel_source(v21);
        *((void *)handle + 24) = 0;
      }
    }
    uint64_t v22 = *(void **)(extra + 16);
    if (v22)
    {
      os_release(v22);
      *(void *)(extra + 16) = 0;
    }
    os_log_type_t v23 = *(void **)(extra + 72);
    if (v23)
    {
      os_release(v23);
      *(void *)(extra + 72) = 0;
    }
    char v24 = 0;
    *(void *)(extra + 72) = nw_link_info_create(0);
    if (uu->handle == &nw_protocol_ref_counted_handle)
    {
      callbacks = uu[1].callbacks;
      if (callbacks) {
        uu[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      char v24 = 1;
    }
    char v26 = *(unsigned char *)(extra + 32);
    if (v26)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)(extra + 24));
      char v26 = *(unsigned char *)(extra + 32);
    }
    *(void *)(extra + 24) = uu;
    *(unsigned char *)(extra + 32) = v26 & 0xFE | v24;
    uuid_unparse(uu->flow_id, (char *)(extra + 84));
    uu->output_handler_context = v17;
    output_handler = uu->output_handler;
    if (output_handler != a1)
    {
      if (output_handler)
      {
        if (output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          uint64_t v40 = output_handler[1].callbacks;
          if (v40)
          {
            BOOL v41 = (nw_protocol_callbacks *)((char *)v40 - 1);
            output_handler[1].callbacks = v41;
            if (!v41)
            {
              int v42 = *(void (***)(void))output_handler[1].flow_id;
              if (v42)
              {
                *(void *)output_handler[1].flow_id = 0;
                v42[2](v42);
                _Block_release(v42);
              }
              if (output_handler[1].flow_id[8])
              {
                BOOL v43 = *(const void **)output_handler[1].flow_id;
                if (v43) {
                  _Block_release(v43);
                }
              }
              free(output_handler);
            }
          }
        }
      }
      uu->output_handler = a1;
      if (a1->handle == &nw_protocol_ref_counted_handle)
      {
        BOOL v28 = a1[1].callbacks;
        if (v28) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
        }
      }
    }
    __int16 v29 = uu->callbacks;
    if (v29)
    {
      get_parameters = (uint64_t (*)(nw_protocol *))v29->get_parameters;
      if (get_parameters)
      {
        if (uu->handle == &nw_protocol_ref_counted_handle)
        {
          __int16 v33 = uu[1].callbacks;
          if (v33) {
            uu[1].callbacks = (nw_protocol_callbacks *)((char *)&v33->add_input_handler + 1);
          }
          uint64_t v31 = (void *)get_parameters(uu);
          if (uu->handle == &nw_protocol_ref_counted_handle)
          {
            os_log_type_t v47 = uu[1].callbacks;
            if (v47)
            {
              uint64_t v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
              uu[1].callbacks = v48;
              if (!v48)
              {
                uint64_t v49 = *(void (***)(void))uu[1].flow_id;
                if (v49)
                {
                  *(void *)uu[1].flow_id = 0;
                  v49[2](v49);
                  _Block_release(v49);
                }
                if (uu[1].flow_id[8])
                {
                  uint64_t v50 = *(const void **)uu[1].flow_id;
                  if (v50) {
                    _Block_release(v50);
                  }
                }
                free(uu);
              }
            }
          }
        }
        else
        {
          uint64_t v31 = (void *)get_parameters(uu);
        }
        if (v31)
        {
          __int16 v34 = v31;
          BOOL v35 = v34[92] == 1;

          *(unsigned char *)(extra + 121) = *(unsigned char *)(extra + 121) & 0xFB | (4 * v35);
        }
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v36 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v57 = "nw_channel_add_input_handler";
      __int16 v58 = 1042;
      *(_DWORD *)uint64_t v59 = 16;
      v59[2] = 2098;
      *(void *)&v59[3] = uu;
      _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s Added channel input handler for %{public,uuid_t}.16P", buf, 0x1Cu);
    }
    uint64_t v37 = *((void *)handle + 25);
    if (v37)
    {
      nw_queue_cancel_source(v37);
      *((void *)handle + 25) = 0;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v32 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v57 = "nw_channel_add_input_handler";
      __int16 v58 = 1042;
      *(_DWORD *)uint64_t v59 = 16;
      v59[2] = 2098;
      *(void *)&v59[3] = uu;
      _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s Channel already has input handler registered for %{public,uuid_t}.16P", buf, 0x1Cu);
    }
  }
  return v16;
}

NWConcrete_nw_link_info *nw_link_info_create(int a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = objc_alloc_init(NWConcrete_nw_link_info);
  BOOL v3 = v2;
  if (v2)
  {
    v2->flow_control_status = a1;
    v2->link_quality = 0;
    BOOL v4 = v2;
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_link_info_create";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14)) {
    goto LABEL_8;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (id)gLogObj;
    os_log_type_t v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_link_info_create";
      _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s [nw_link_info init] failed", buf, 0xCu);
    }
LABEL_7:

LABEL_8:
    if (!v6) {
      goto LABEL_10;
    }
LABEL_9:
    free(v6);
    goto LABEL_10;
  }
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (id)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_link_info_create";
      _os_log_impl(&dword_1830D4000, v7, v13, "%{public}s [nw_link_info init] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_7;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v7 = (id)gLogObj;
  os_log_type_t v11 = type;
  BOOL v12 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_link_info_create";
      _os_log_impl(&dword_1830D4000, v7, v11, "%{public}s [nw_link_info init] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_7;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_link_info_create";
    __int16 v18 = 2082;
    uint64_t v19 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v7, v11, "%{public}s [nw_link_info init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v6) {
    goto LABEL_9;
  }
LABEL_10:

  return v3;
}

uint64_t nw_path_flow_registration_can_support_user_packet_pool(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  BOOL v3 = a1;
  BOOL v4 = a2;
  if (v3)
  {
    id v5 = nw_path_copy_flow_for_registration(v3, v4);
    id v6 = v5;
    if (v5) {
      uint64_t can_support_user_packet_pool = nw_path_flow_nexus_can_support_user_packet_pool(v5);
    }
    else {
      uint64_t can_support_user_packet_pool = 0;
    }

    goto LABEL_6;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v10) {
    free(v10);
  }
  uint64_t can_support_user_packet_pool = 0;
LABEL_6:

  return can_support_user_packet_pool;
}

uint64_t nw_path_flow_nexus_can_support_user_packet_pool(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)length = 136446210;
    *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null flow", length, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)length = 136446466;
            *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null flow, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v16)
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }
      else
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null flow, backtrace limit exceeded", length, 0xCu);
        }
      }
    }
LABEL_32:
    if (v11) {
      free(v11);
    }
    goto LABEL_12;
  }
  BOOL v3 = v1;
  BOOL v4 = (void *)v3[3];
  if (v4
    && (*(void *)length = 0, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) != 0)
    && *(void *)length >= 0xD8uLL
    && (id v6 = data, *(void *)length == data[53] + 216)
    && ((data[52] & 0xE080) != 0 ? (BOOL v7 = (data[52] & 0x13) == 1) : (BOOL v7 = 1), !v7))
  {

    if (v6[53] >= 0xCCu)
    {
      uint64_t v8 = v6[104] & 1;
      goto LABEL_13;
    }
  }
  else
  {
  }
LABEL_12:
  uint64_t v8 = 0;
LABEL_13:

  return v8;
}

const char *nw_listener_get_id_string(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = (char *)v1;
  if (v1)
  {
    BOOL v3 = v1 + 42;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_listener_get_id_string";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_listener_get_id_string";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_listener_get_id_string";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_listener_get_id_string";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_listener_get_id_string";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = "";
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_get_id(void *a1, _OWORD *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  BOOL v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_path_flow_get_id";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_path_flow_get_id";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null flow", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v19 = "nw_path_flow_get_id";
            __int16 v20 = 2082;
            __int16 v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_path_flow_get_id";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_path_flow_get_id";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (v9) {
      free(v9);
    }
    goto LABEL_3;
  }
  id v5 = v3 + 9;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 144))
  {
    *a2 = *v5;
    uint64_t v6 = 1;
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v6 = 0;
LABEL_5:

  return v6;
}

void sub_183366034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_ip_channel_inbox_get_parameters(nw_protocol *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    id v1 = a1->handle;
    uint64_t v2 = v1;
    if (v1)
    {
      id v3 = v1[6];
LABEL_4:

      goto LABEL_5;
    }
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v24 = "nw_ip_channel_inbox_get_parameters";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v10, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_ip_channel_inbox_get_parameters";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null inbox", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            char v24 = "nw_ip_channel_inbox_get_parameters";
            __int16 v25 = 2082;
            char v26 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v17, "%{public}s called with null inbox, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_ip_channel_inbox_get_parameters";
          _os_log_impl(&dword_1830D4000, v11, v17, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_ip_channel_inbox_get_parameters";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null inbox, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_43:
    if (v10) {
      free(v10);
    }
    id v3 = 0;
    goto LABEL_4;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v24 = "nw_ip_channel_inbox_get_parameters";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v6, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v24 = "nw_ip_channel_inbox_get_parameters";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v21)
    {
      os_log_type_t v13 = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v7, type);
      if (v13)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          char v24 = "nw_ip_channel_inbox_get_parameters";
          __int16 v25 = 2082;
          char v26 = v13;
          _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v13);
        goto LABEL_37;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        char v24 = "nw_ip_channel_inbox_get_parameters";
        _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v24 = "nw_ip_channel_inbox_get_parameters";
        _os_log_impl(&dword_1830D4000, v7, v19, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_37:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_5:

  return v3;
}

void ___ZL15nw_channel_initv_block_invoke()
{
  g_channel_check_validity = (uint64_t (*)(void, void))nw_channel_frame_check_validity;
  g_channel_reclassifier = nw_channel_reclassify_input;
  g_channel_set_flow_handler = nw_channel_set_flow_handler;
  g_channel_get_flow_handler = nw_channel_get_flow_handler;
  g_channel_set_internet_checksum_handler = nw_channel_set_internet_checksum_handler;
  g_channel_get_internet_checksum_handler = (uint64_t (*)(void, void, void, void))nw_channel_get_internet_checksum_handler;
  g_channel_protocol_callbacks = (uint64_t)nw_channel_add_input_handler;
  qword_1EB267490 = (uint64_t)nw_channel_replace_input_handler;
  qword_1EB267488 = (uint64_t)nw_channel_remove_input_handler;
  qword_1EB2674D0 = (uint64_t)nw_channel_get_input_frames;
  qword_1EB2674D8 = (uint64_t)nw_channel_get_output_frames;
  qword_1EB2674E0 = (uint64_t)nw_channel_finalize_output_frames;
  qword_1EB267498 = (uint64_t)nw_channel_connect;
  qword_1EB2674A0 = (uint64_t)nw_channel_disconnect;
  qword_1EB267528 = (uint64_t)nw_channel_updated_path;
  qword_1EB267540 = (uint64_t)nw_channel_output_finished;
  qword_1EB267578 = (uint64_t)nw_channel_get_message_properties;
}

void __nw_connection_register_context_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    if ((nw_endpoint_handler_register_context(*(void **)(v2 + 144), *(void **)(a1 + 40)) & 1) == 0)
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 16);
      if (v9)
      {
        if (!nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v4 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
            goto LABEL_16;
          }
          uint64_t v10 = *(void *)(a1 + 40);
          int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
          int v12 = 136446722;
          os_log_type_t v13 = "nw_connection_register_context_block_invoke";
          __int16 v14 = 1024;
          int v15 = v11;
          __int16 v16 = 2112;
          uint64_t v17 = v10;
          uint64_t v6 = "%{public}s [C%u] Failed to register context %@";
          BOOL v7 = v4;
          uint32_t v8 = 28;
          goto LABEL_15;
        }
      }
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v4 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v12 = 136446466;
      os_log_type_t v13 = "nw_connection_register_context_block_invoke";
      __int16 v14 = 1024;
      int v15 = v5;
      uint64_t v6 = "%{public}s [C%u] Cannot register a context on a connection that is not ready";
      BOOL v7 = v4;
      uint32_t v8 = 18;
LABEL_15:
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v12, v8);
LABEL_16:
    }
  }
}

uint64_t nw_endpoint_handler_register_context(void *a1, void *a2)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  BOOL v4 = a2;
  if (!v4)
  {
    int v86 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
    char v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v108 = 0;
    if (!__nwlog_fault(v26, &type, &v108)) {
      goto LABEL_76;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v27 = __nwlog_obj();
      os_log_type_t v87 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_1830D4000, v27, v87, "%{public}s called with null content_context", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (!v108)
    {
      uint64_t v27 = __nwlog_obj();
      os_log_type_t v95 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_1830D4000, v27, v95, "%{public}s called with null content_context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v27 = __nwlog_obj();
    os_log_type_t v91 = type;
    BOOL v92 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_1830D4000, v27, v91, "%{public}s called with null content_context, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v92)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v27, v91, "%{public}s called with null content_context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_132;
  }
  if (!v3)
  {
    uint64_t v88 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
    char v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v108 = 0;
    if (!__nwlog_fault(v26, &type, &v108)) {
      goto LABEL_76;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v27 = __nwlog_obj();
      os_log_type_t v89 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_1830D4000, v27, v89, "%{public}s called with null handler", buf, 0xCu);
      }
LABEL_75:

      goto LABEL_76;
    }
    if (!v108)
    {
      uint64_t v27 = __nwlog_obj();
      os_log_type_t v96 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_1830D4000, v27, v96, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v27 = __nwlog_obj();
    os_log_type_t v93 = type;
    BOOL v94 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v94)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_1830D4000, v27, v93, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v94)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v27, v93, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_132:

    free(backtrace_string);
    if (!v26) {
      goto LABEL_78;
    }
    goto LABEL_77;
  }
  int v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if (mode == 2)
  {
    BOOL v7 = nw_endpoint_handler_copy_flow(v5);
    uint32_t v8 = v7;
    if ((*((unsigned char *)v7 + 35) & 2) != 0)
    {
      uint64_t v30 = *((void *)v7 + 117);
      if (v30)
      {
        uint64_t v31 = nw_endpoint_handler_register_context(v30, v4);
LABEL_111:

        goto LABEL_112;
      }
      __int16 v36 = v5;
      char v37 = *((unsigned char *)v36 + 268);

      if ((v37 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v38 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v39 = v36;

          uint64_t v40 = v39;
          char v41 = *((unsigned char *)v36 + 268);

          if (v41) {
            int v42 = "dry-run ";
          }
          else {
            int v42 = "";
          }
          nw_endpoint_t v43 = nw_endpoint_handler_copy_endpoint(v40);
          logging_description = nw_endpoint_get_logging_description(v43);
          id_str = v39->id_str;
          BOOL v45 = v40;
          uint64_t v46 = v45;
          uint64_t v47 = v45[30];
          if (v47 > 5) {
            uint64_t v48 = "unknown-state";
          }
          else {
            uint64_t v48 = off_1E523FB38[v47];
          }
          __int16 v99 = v48;

          uint64_t v64 = v46;
          os_log_type_t v65 = v64;
          int v66 = v5->mode;
          uint64_t v67 = "path";
          switch(v66)
          {
            case 0:
              break;
            case 1:
              uint64_t v67 = "resolver";
              break;
            case 2:
              uint64_t v67 = nw_endpoint_flow_mode_string(v64[31]);
              break;
            case 3:
              uint64_t v67 = "proxy";
              break;
            case 4:
              uint64_t v67 = "fallback";
              break;
            case 5:
              uint64_t v67 = "transform";
              break;
            default:
              uint64_t v67 = "unknown-mode";
              break;
          }

          uint64_t v75 = v65;
          os_unfair_lock_lock((os_unfair_lock_t)v75 + 28);
          id v76 = v75[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v75 + 28);

          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = id_str;
          *(_WORD *)&buf[22] = 2082;
          uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))v42;
          *(_WORD *)BOOL v112 = 2082;
          *(void *)&v112[2] = logging_description;
          *(_WORD *)&v112[10] = 2082;
          *(void *)&v112[12] = v99;
          __int16 v113 = 2082;
          __int16 v114 = v67;
          __int16 v115 = 2114;
          id v116 = v76;
          _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot register, no connected handler", buf, 0x48u);
        }
        goto LABEL_109;
      }
    }
    else if (*((void *)v7 + 96))
    {
      uint64_t v9 = *((void *)v7 + 108);
      if (v9)
      {
        uint64_t node = nw_hash_table_get_node(v9, (uint64_t)v4, 0);
        if (node)
        {
          uint64_t v11 = *(void *)(node + 16);
          if (v11) {
            goto LABEL_96;
          }
        }
        uint64_t v11 = nw_endpoint_handler_register_context_internal(v5, v8, v4);
        int v12 = v5;
        char v13 = *((unsigned char *)v12 + 268);

        if ((v13 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v14 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            int v15 = v12;

            __int16 v16 = v15;
            char v17 = *((unsigned char *)v12 + 268);

            if (v17) {
              uint64_t v18 = "dry-run ";
            }
            else {
              uint64_t v18 = "";
            }
            nw_endpoint_t v19 = nw_endpoint_handler_copy_endpoint(v16);
            v104 = nw_endpoint_get_logging_description(v19);
            BOOL v98 = v15->id_str;
            os_log_type_t v20 = v16;
            char v21 = v20;
            uint64_t v22 = v20[30];
            if (v22 > 5) {
              uint64_t v23 = "unknown-state";
            }
            else {
              uint64_t v23 = off_1E523FB38[v22];
            }
            uint64_t v97 = v23;

            int v68 = v21;
            uint64_t v69 = v68;
            uint64_t v100 = (uint64_t (*)(uint64_t, uint64_t))v18;
            __int16 v70 = "path";
            switch(v5->mode)
            {
              case 0:
                break;
              case 1:
                __int16 v70 = "resolver";
                break;
              case 2:
                __int16 v70 = nw_endpoint_flow_mode_string(v68[31]);
                break;
              case 3:
                __int16 v70 = "proxy";
                break;
              case 4:
                __int16 v70 = "fallback";
                break;
              case 5:
                __int16 v70 = "transform";
                break;
              default:
                __int16 v70 = "unknown-mode";
                break;
            }

            uint64_t v77 = v69;
            os_unfair_lock_lock((os_unfair_lock_t)v77 + 28);
            id v78 = v77[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v77 + 28);

            *(_DWORD *)buf = 136448002;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v98;
            *(_WORD *)&buf[22] = 2082;
            uint64_t v111 = v100;
            *(_WORD *)BOOL v112 = 2082;
            *(void *)&v112[2] = v104;
            *(_WORD *)&v112[10] = 2082;
            *(void *)&v112[12] = v97;
            __int16 v113 = 2082;
            __int16 v114 = v70;
            __int16 v115 = 2114;
            id v116 = v78;
            __int16 v117 = 2048;
            uint64_t v118 = v11;
            _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Registered protocol %p", buf, 0x52u);
          }
        }
        if (v11)
        {
LABEL_96:
          uint64_t v79 = *(void *)(v11 + 32);
          if (!v79 || (uint64_t v80 = *(void *)(v79 + 24)) == 0 || (v81 = *(uint64_t (**)(void))(v80 + 224)) == 0)
          {
            uint64_t v31 = 1;
            goto LABEL_111;
          }
          __int16 v38 = v81();
          *(void *)buf = 0;
          *(void *)&buf[8] = buf;
          *(void *)&buf[16] = 0x3032000000;
          uint64_t v111 = __Block_byref_object_copy__16663;
          *(void *)BOOL v112 = __Block_byref_object_dispose__16664;
          *(void *)&v112[8] = 0;
          v105[0] = MEMORY[0x1E4F143A8];
          v105[1] = 3221225472;
          v105[2] = __nw_endpoint_handler_register_context_block_invoke;
          v105[3] = &unk_1E524A2E8;
          __int16 v106 = v8;
          os_log_type_t v107 = buf;
          nw_array_apply((atomic_uchar *)v38, (uint64_t)v105);
          BOOL v82 = *(NSObject **)(*(void *)&buf[8] + 40);
          if (v82) {
            nw_content_context_set_metadata_for_protocol(v4, v82);
          }

          _Block_object_dispose(buf, 8);
          uint64_t v31 = 1;
          goto LABEL_110;
        }
        goto LABEL_102;
      }
      BOOL v51 = v5;
      char v52 = *((unsigned char *)v51 + 268);

      if ((v52 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v38 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          BOOL v53 = v51;

          char v54 = v53;
          char v55 = *((unsigned char *)v51 + 268);

          if (v55) {
            os_log_type_t v56 = "dry-run ";
          }
          else {
            os_log_type_t v56 = "";
          }
          nw_endpoint_t v57 = nw_endpoint_handler_copy_endpoint(v54);
          __int16 v58 = nw_endpoint_get_logging_description(v57);
          uint64_t v103 = v53->id_str;
          uint64_t v59 = v54;
          __int16 v60 = v59;
          uint64_t v61 = v59[30];
          if (v61 > 5) {
            __int16 v62 = "unknown-state";
          }
          else {
            __int16 v62 = off_1E523FB38[v61];
          }
          __int16 v101 = v62;

          os_log_type_t v71 = v60;
          __int16 v72 = v71;
          int v73 = v5->mode;
          __int16 v74 = "path";
          switch(v73)
          {
            case 0:
              break;
            case 1:
              __int16 v74 = "resolver";
              break;
            case 2:
              __int16 v74 = nw_endpoint_flow_mode_string(v71[31]);
              break;
            case 3:
              __int16 v74 = "proxy";
              break;
            case 4:
              __int16 v74 = "fallback";
              break;
            case 5:
              __int16 v74 = "transform";
              break;
            default:
              __int16 v74 = "unknown-mode";
              break;
          }

          os_log_type_t v83 = v72;
          os_unfair_lock_lock((os_unfair_lock_t)v83 + 28);
          id v84 = v83[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v83 + 28);

          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v103;
          *(_WORD *)&buf[22] = 2082;
          uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))v56;
          *(_WORD *)BOOL v112 = 2082;
          *(void *)&v112[2] = v58;
          *(_WORD *)&v112[10] = 2082;
          *(void *)&v112[12] = v101;
          __int16 v113 = 2082;
          __int16 v114 = v74;
          __int16 v115 = 2114;
          id v116 = v84;
          _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot register after flow table is released", buf, 0x48u);
        }
LABEL_109:
        uint64_t v31 = 0;
LABEL_110:

        goto LABEL_111;
      }
    }
LABEL_102:
    uint64_t v31 = 0;
    goto LABEL_111;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v24 = (id)gLogObj;
  if (mode > 5) {
    __int16 v25 = "unknown-mode";
  }
  else {
    __int16 v25 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
  *(_WORD *)&unsigned char buf[12] = 2082;
  *(void *)&buf[14] = v25;
  *(_WORD *)&buf[22] = 2082;
  uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
  char v26 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v108 = 0;
  if (__nwlog_fault(v26, &type, &v108))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (id)gLogObj;
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        if (mode > 5) {
          __int16 v29 = "unknown-mode";
        }
        else {
          __int16 v29 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v29;
        *(_WORD *)&buf[22] = 2082;
        uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
        _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if (v108)
    {
      __int16 v32 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (id)gLogObj;
      os_log_type_t v33 = type;
      BOOL v34 = os_log_type_enabled(v27, type);
      if (v32)
      {
        if (v34)
        {
          if (mode > 5) {
            BOOL v35 = "unknown-mode";
          }
          else {
            BOOL v35 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v35;
          *(_WORD *)&buf[22] = 2082;
          uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
          *(_WORD *)BOOL v112 = 2082;
          *(void *)&v112[2] = v32;
          _os_log_impl(&dword_1830D4000, v27, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v32);
        if (!v26) {
          goto LABEL_78;
        }
        goto LABEL_77;
      }
      if (v34)
      {
        if (mode > 5) {
          unsigned int v63 = "unknown-mode";
        }
        else {
          unsigned int v63 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v63;
        *(_WORD *)&buf[22] = 2082;
        uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
        _os_log_impl(&dword_1830D4000, v27, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (id)gLogObj;
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v27, type))
      {
        if (mode > 5) {
          uint64_t v50 = "unknown-mode";
        }
        else {
          uint64_t v50 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v50;
        *(_WORD *)&buf[22] = 2082;
        uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
        _os_log_impl(&dword_1830D4000, v27, v49, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_75;
  }
LABEL_76:
  if (v26) {
LABEL_77:
  }
    free(v26);
LABEL_78:
  uint64_t v31 = 0;
LABEL_112:

  return v31;
}

void sub_18336784C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_stream_data_bidirectional_local_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_stream_data_bidirectional_local_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_183367BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_bidirectional_local_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  int v5 = _Block_copy(*(const void **)(a1 + 32));
  uint64_t v6 = *(void **)(a2 + 56);
  *(void *)(a2 + 56) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_protocol_definition_set_instance_state_allocator(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    BOOL v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v18 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v18 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v29 = "nw_protocol_definition_set_instance_state_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_extended_state(v5);
  v6->extended_state->unint64_t var0 = a2;
  v6->extended_state->var1 = a3;
LABEL_5:
}

void sub_18336832C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_inbound_events(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    BOOL v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_protocol_definition_set_inbound_events";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v29 = "nw_protocol_definition_set_inbound_events";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_protocol_definition_set_inbound_events";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null inbound_starting", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null inbound_starting, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v18 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null inbound_starting, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v29 = "nw_protocol_definition_set_inbound_events";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null inbound_starting, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_protocol_definition_set_inbound_events";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null inbound_stopping", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null inbound_stopping, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v18 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null inbound_stopping, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v29 = "nw_protocol_definition_set_inbound_events";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null inbound_stopping, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_extended_state(v5);
  v6->extended_state->var10 = a2;
  v6->extended_state->var11 = a3;
LABEL_5:
}

void sub_183368A04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_clear_flow_for_key(void *a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = (char *)v3;
  if (!v3)
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v37 = "nw_protocol_instance_clear_flow_for_key";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v11, &type, &v34)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        char v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          char v37 = "nw_protocol_instance_clear_flow_for_key";
          __int16 v38 = 2082;
          os_log_type_t v39 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v11) {
          goto LABEL_14;
        }
LABEL_67:
        free(v11);
        goto LABEL_14;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        char v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        char v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_1830D4000, v12, v28, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_65:

    goto LABEL_66;
  }
  if (a2)
  {
    uint64_t v5 = v3[30];
    if (v5 && *(_DWORD *)(v5 + 40))
    {
      uint64_t node = nw_hash_table_get_node(v5, a2, *(unsigned int *)(*(void *)(*((void *)v4 + 1) + 80) + 256));
      if (node)
      {
        uint64_t v7 = node;
        int v8 = v4[405];
        if (*(void *)(node + 16))
        {
          if ((v8 & 0x80000000) == 0 && gLogDatapath)
          {
            char v26 = __nwlog_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v27 = *(char **)(v7 + 32);
              *(_DWORD *)buf = 136447234;
              char v37 = "nw_protocol_instance_clear_flow_for_key";
              __int16 v38 = 2082;
              os_log_type_t v39 = v4 + 407;
              __int16 v40 = 2080;
              char v41 = " ";
              __int16 v42 = 2048;
              uint64_t v43 = a2;
              __int16 v44 = 2048;
              BOOL v45 = v27;
              _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRemoving custom flow mapping for key %p, flow %llx", buf, 0x34u);
            }
          }
          nw_hash_table_remove_node(*((void *)v4 + 30), v7);
          goto LABEL_14;
        }
        if (v8 < 0) {
          goto LABEL_14;
        }
        BOOL v22 = __nwlog_obj();
        *(_DWORD *)buf = 136446978;
        char v37 = "nw_protocol_instance_clear_flow_for_key";
        __int16 v38 = 2082;
        os_log_type_t v39 = v4 + 407;
        __int16 v40 = 2080;
        char v41 = " ";
        __int16 v42 = 2048;
        uint64_t v43 = v7;
        os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v34 = 0;
        if (!__nwlog_fault(v23, &type, &v34)) {
          goto LABEL_74;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v24 = __nwlog_obj();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446978;
            char v37 = "nw_protocol_instance_clear_flow_for_key";
            __int16 v38 = 2082;
            os_log_type_t v39 = v4 + 407;
            __int16 v40 = 2080;
            char v41 = " ";
            __int16 v42 = 2048;
            uint64_t v43 = v7;
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s %{public}s%sobject not present from node %p", buf, 0x2Au);
          }
        }
        else if (v34)
        {
          __int16 v30 = (char *)__nw_create_backtrace_string();
          os_log_type_t v24 = __nwlog_obj();
          os_log_type_t v31 = type;
          BOOL v32 = os_log_type_enabled(v24, type);
          if (v30)
          {
            if (v32)
            {
              *(_DWORD *)buf = 136447234;
              char v37 = "nw_protocol_instance_clear_flow_for_key";
              __int16 v38 = 2082;
              os_log_type_t v39 = v4 + 407;
              __int16 v40 = 2080;
              char v41 = " ";
              __int16 v42 = 2048;
              uint64_t v43 = v7;
              __int16 v44 = 2082;
              BOOL v45 = v30;
              _os_log_impl(&dword_1830D4000, v24, v31, "%{public}s %{public}s%sobject not present from node %p, dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v30);
            goto LABEL_74;
          }
          if (v32)
          {
            *(_DWORD *)buf = 136446978;
            char v37 = "nw_protocol_instance_clear_flow_for_key";
            __int16 v38 = 2082;
            os_log_type_t v39 = v4 + 407;
            __int16 v40 = 2080;
            char v41 = " ";
            __int16 v42 = 2048;
            uint64_t v43 = v7;
            _os_log_impl(&dword_1830D4000, v24, v31, "%{public}s %{public}s%sobject not present from node %p, no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          os_log_type_t v24 = __nwlog_obj();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446978;
            char v37 = "nw_protocol_instance_clear_flow_for_key";
            __int16 v38 = 2082;
            os_log_type_t v39 = v4 + 407;
            __int16 v40 = 2080;
            char v41 = " ";
            __int16 v42 = 2048;
            uint64_t v43 = v7;
            _os_log_impl(&dword_1830D4000, v24, v33, "%{public}s %{public}s%sobject not present from node %p, backtrace limit exceeded", buf, 0x2Au);
          }
        }

LABEL_74:
        if (v23) {
          free(v23);
        }
        goto LABEL_14;
      }
      if (v4[405] < 0) {
        goto LABEL_14;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        char v37 = "nw_protocol_instance_clear_flow_for_key";
        __int16 v38 = 2082;
        os_log_type_t v39 = v4 + 407;
        __int16 v40 = 2080;
        char v41 = " ";
        __int16 v42 = 2048;
        uint64_t v43 = a2;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNo flow found in custom flow mapping table for key %p", buf, 0x2Au);
      }
    }
    else
    {
      if (v4[405] < 0) {
        goto LABEL_14;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        char v37 = "nw_protocol_instance_clear_flow_for_key";
        __int16 v38 = 2082;
        os_log_type_t v39 = v4 + 407;
        __int16 v40 = 2080;
        char v41 = " ";
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFlow mapping table is empty", buf, 0x20u);
      }
    }

    goto LABEL_14;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v37 = "nw_protocol_instance_clear_flow_for_key";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (!__nwlog_fault(v11, &type, &v34)) {
    goto LABEL_66;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      char v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null key", buf, 0xCu);
    }
    goto LABEL_65;
  }
  if (!v34)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v29 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      char v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_1830D4000, v12, v29, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_65;
  }
  os_log_type_t v19 = (char *)__nw_create_backtrace_string();
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      char v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s called with null key, no backtrace", buf, 0xCu);
    }
    goto LABEL_65;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    char v37 = "nw_protocol_instance_clear_flow_for_key";
    __int16 v38 = 2082;
    os_log_type_t v39 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s called with null key, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_67;
  }
LABEL_14:
}

NSObject *nw_listener_socket_inbox_create_socket(void *a1, const unsigned __int8 *a2, int *a3)
{
  uint64_t v288 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    __int16 v114 = __nwlog_obj();
    *(_DWORD *)address = 136446210;
    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
    __int16 v115 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v282) = 0;
    if (!__nwlog_fault(v115, type, &v282)) {
      goto LABEL_375;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v116 = __nwlog_obj();
      os_log_type_t v117 = type[0];
      if (os_log_type_enabled(v116, type[0]))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v116, v117, "%{public}s called with null parameters", (uint8_t *)address, 0xCu);
      }
    }
    else if ((_BYTE)v282)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v116 = __nwlog_obj();
      os_log_type_t v125 = type[0];
      BOOL v126 = os_log_type_enabled(v116, type[0]);
      if (backtrace_string)
      {
        if (v126)
        {
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 2082;
          *(void *)&address[7] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v116, v125, "%{public}s called with null parameters, dumping backtrace:%{public}s", (uint8_t *)address, 0x16u);
        }

        free(backtrace_string);
        if (!v115) {
          goto LABEL_377;
        }
        goto LABEL_376;
      }
      if (v126)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v116, v125, "%{public}s called with null parameters, no backtrace", (uint8_t *)address, 0xCu);
      }
    }
    else
    {
      id v116 = __nwlog_obj();
      os_log_type_t v131 = type[0];
      if (os_log_type_enabled(v116, type[0]))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v116, v131, "%{public}s called with null parameters, backtrace limit exceeded", (uint8_t *)address, 0xCu);
      }
    }
    goto LABEL_374;
  }
  if (!a3)
  {
    uint64_t v118 = __nwlog_obj();
    *(_DWORD *)address = 136446210;
    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
    __int16 v115 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v282) = 0;
    if (!__nwlog_fault(v115, type, &v282)) {
      goto LABEL_375;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v116 = __nwlog_obj();
      os_log_type_t v119 = type[0];
      if (os_log_type_enabled(v116, type[0]))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v116, v119, "%{public}s called with null outFD", (uint8_t *)address, 0xCu);
      }
    }
    else if ((_BYTE)v282)
    {
      nw_endpoint_t v127 = (char *)__nw_create_backtrace_string();
      id v116 = __nwlog_obj();
      os_log_type_t v128 = type[0];
      BOOL v129 = os_log_type_enabled(v116, type[0]);
      if (v127)
      {
        if (v129)
        {
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 2082;
          *(void *)&address[7] = v127;
          _os_log_impl(&dword_1830D4000, v116, v128, "%{public}s called with null outFD, dumping backtrace:%{public}s", (uint8_t *)address, 0x16u);
        }

        free(v127);
LABEL_375:
        if (!v115)
        {
LABEL_377:
          os_log_type_t v24 = 0;
          goto LABEL_111;
        }
LABEL_376:
        free(v115);
        goto LABEL_377;
      }
      if (v129)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v116, v128, "%{public}s called with null outFD, no backtrace", (uint8_t *)address, 0xCu);
      }
    }
    else
    {
      id v116 = __nwlog_obj();
      os_log_type_t v132 = type[0];
      if (os_log_type_enabled(v116, type[0]))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v116, v132, "%{public}s called with null outFD, backtrace limit exceeded", (uint8_t *)address, 0xCu);
      }
    }
LABEL_374:

    goto LABEL_375;
  }
  *a3 = -1;
  uint64_t v7 = v5;
  int v8 = *(id *)(v7[13] + 160);

  int required_address_family = nw_parameters_get_required_address_family(v7);
  if (!v8)
  {
    endpoint = 0;
    __int16 v14 = 0;
    goto LABEL_21;
  }
  os_log_type_t v10 = nw_endpoint_get_address(v8);
  if (nw_endpoint_is_multicast(v8))
  {
    endpoint = v8;
    int sa_family = v10->sa_family;
    int required_address_family = sa_family;
    if (sa_family != 30)
    {
LABEL_6:
      if (sa_family != 2) {
        goto LABEL_29;
      }
      int v12 = *(_DWORD *)&v10->sa_data[2];
LABEL_8:
      if (v12) {
        BOOL v13 = endpoint == 0;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        goto LABEL_20;
      }
LABEL_13:
      endpoint = 0;
      goto LABEL_29;
    }
  }
  else
  {
    endpoint = 0;
    int sa_family = v10->sa_family;
    if (sa_family != 30) {
      goto LABEL_6;
    }
  }
  if (!*(_DWORD *)&v10->sa_data[6] && !*(_DWORD *)&v10->sa_data[10] && !*(_DWORD *)&v10[1].sa_len)
  {
    int v12 = *(_DWORD *)&v10[1].sa_data[2];
    goto LABEL_8;
  }
  if (!endpoint) {
    goto LABEL_13;
  }
LABEL_20:
  __int16 v14 = *(_WORD *)v10->sa_data;

LABEL_21:
  if (required_address_family) {
    int v15 = required_address_family;
  }
  else {
    int v15 = 30;
  }
  if (v15 == 30)
  {
    memset(&address[2], 0, 24);
    address[0] = 7708;
    address[1] = v14;
    nw_endpoint_t v16 = nw_endpoint_create_address((const sockaddr *)address);
  }
  else
  {
    if (v15 != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s listener created without a local address specified", (uint8_t *)address, 0xCu);
      }

      os_log_type_t v24 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
      int v8 = 0;
      goto LABEL_110;
    }
    address[0] = 528;
    address[1] = v14;
    *(_DWORD *)&address[2] = 0;
    *(void *)&address[4] = 0;
    nw_endpoint_t v16 = nw_endpoint_create_address((const sockaddr *)address);
  }
  int v8 = v16;
  if (!v16) {
    goto LABEL_34;
  }
LABEL_29:
  os_log_type_t v17 = nw_endpoint_get_address(v8);
  BOOL v18 = v17;
  if (!v17)
  {
LABEL_34:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v22 = (id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)address = 136446210;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s listener created without a local address specified", (uint8_t *)address, 0xCu);
    }
    goto LABEL_59;
  }
  if (required_address_family && v17->sa_family != required_address_family)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v22 = (id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)address = 136446210;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s Required address family doesn't match local address", (uint8_t *)address, 0xCu);
    }
  }
  else
  {
    int ip_protocol = nw_parameters_get_ip_protocol(v7);
    int v20 = ip_protocol;
    if (ip_protocol == 6)
    {
      int v21 = 1;
      goto LABEL_42;
    }
    if (ip_protocol == 17)
    {
      int v21 = 2;
LABEL_42:
      int v25 = socket(v18->sa_family, v21, 0);
      int v26 = v25;
      if ((v25 & 0x80000000) == 0)
      {
        int v282 = 1;
        int v281 = 0;
        int v274 = v25;
        char v273 = a3;
        if (setsockopt(v25, 0xFFFF, 4, &v282, 4u))
        {
          posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                            + 8));
          int error_code = nw_error_get_error_code(posix_error);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v29 = (id)gLogObj;
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 1024;
          *(_DWORD *)&address[7] = error_code;
          __int16 v30 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v280) = 0;
          if (!__nwlog_fault(v30, type, &v280)) {
            goto LABEL_142;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v31 = (id)gLogObj;
            os_log_type_t v32 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = error_code;
              _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s SO_REUSEADDR failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
            }
LABEL_132:

            goto LABEL_142;
          }
          if (!(_BYTE)v280)
          {
            os_log_type_t v31 = __nwlog_obj();
            os_log_type_t v61 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = error_code;
              _os_log_impl(&dword_1830D4000, v31, v61, "%{public}s SO_REUSEADDR failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
            }
            goto LABEL_132;
          }
          __int16 v42 = (char *)__nw_create_backtrace_string();
          uint64_t v43 = __nwlog_obj();
          os_log_type_t v44 = type[0];
          BOOL v45 = os_log_type_enabled(v43, type[0]);
          if (v42)
          {
            if (v45)
            {
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = error_code;
              address[9] = 2082;
              *(void *)&address[10] = v42;
              _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s SO_REUSEADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
            }
            goto LABEL_71;
          }
          if (v45)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = error_code;
            _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s SO_REUSEADDR failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
          }
LABEL_141:

LABEL_142:
          if (!v30) {
            goto LABEL_144;
          }
          goto LABEL_143;
        }
        if (v20 != 6 && setsockopt(v26, 0xFFFF, 512, &v282, 4u))
        {
          posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                            + 8));
          int v39 = nw_error_get_error_code(posix_error);
          __int16 v40 = __nwlog_obj();
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 1024;
          *(_DWORD *)&address[7] = v39;
          __int16 v30 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v280) = 0;
          if (!__nwlog_fault(v30, type, &v280)) {
            goto LABEL_142;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v31 = __nwlog_obj();
            os_log_type_t v41 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v39;
              _os_log_impl(&dword_1830D4000, v31, v41, "%{public}s SO_REUSEPORT failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
            }
            goto LABEL_132;
          }
          if (!(_BYTE)v280)
          {
            os_log_type_t v31 = __nwlog_obj();
            os_log_type_t v71 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v39;
              _os_log_impl(&dword_1830D4000, v31, v71, "%{public}s SO_REUSEPORT failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
            }
            goto LABEL_132;
          }
          __int16 v42 = (char *)__nw_create_backtrace_string();
          uint64_t v43 = __nwlog_obj();
          os_log_type_t v64 = type[0];
          BOOL v65 = os_log_type_enabled(v43, type[0]);
          if (!v42)
          {
            if (v65)
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v39;
              _os_log_impl(&dword_1830D4000, v43, v64, "%{public}s SO_REUSEPORT failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
            }
            goto LABEL_141;
          }
          if (v65)
          {
            *(_DWORD *)address = 136446722;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v39;
            address[9] = 2082;
            *(void *)&address[10] = v42;
            _os_log_impl(&dword_1830D4000, v43, v64, "%{public}s SO_REUSEPORT failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
          }
LABEL_71:

          free(v42);
          if (!v30)
          {
LABEL_144:
            int v74 = v274;
            if (posix_error)
            {
LABEL_145:
              close(v74);
LABEL_434:
              os_log_type_t v24 = posix_error;

              goto LABEL_110;
            }
LABEL_433:
            *char v273 = v74;
            goto LABEL_434;
          }
LABEL_143:
          free(v30);
          goto LABEL_144;
        }
        os_log_type_t v49 = v7;
        BOOL v50 = (*(_WORD *)(v7[13] + 108) & 8) == 0;

        if (!v50 && setsockopt(v274, 0xFFFF, 4356, &v282, 4u))
        {
          posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                            + 8));
          int v51 = nw_error_get_error_code(posix_error);
          char v52 = __nwlog_obj();
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 1024;
          *(_DWORD *)&address[7] = v51;
          __int16 v30 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v280) = 0;
          if (!__nwlog_fault(v30, type, &v280)) {
            goto LABEL_142;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v31 = __nwlog_obj();
            os_log_type_t v53 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v51;
              _os_log_impl(&dword_1830D4000, v31, v53, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
            }
            goto LABEL_132;
          }
          if (!(_BYTE)v280)
          {
            os_log_type_t v31 = __nwlog_obj();
            os_log_type_t v72 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v51;
              _os_log_impl(&dword_1830D4000, v31, v72, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
            }
            goto LABEL_132;
          }
          __int16 v42 = (char *)__nw_create_backtrace_string();
          uint64_t v43 = __nwlog_obj();
          os_log_type_t v66 = type[0];
          BOOL v67 = os_log_type_enabled(v43, type[0]);
          if (!v42)
          {
            if (v67)
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v51;
              _os_log_impl(&dword_1830D4000, v43, v66, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
            }
            goto LABEL_141;
          }
          if (v67)
          {
            *(_DWORD *)address = 136446722;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v51;
            address[9] = 2082;
            *(void *)&address[10] = v42;
            _os_log_impl(&dword_1830D4000, v43, v66, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
          }
          goto LABEL_71;
        }
        char v54 = v49;
        BOOL v55 = (*(_WORD *)(v7[13] + 108) & 0x80) == 0;

        if (v55 || !setsockopt(v274, 0xFFFF, 0x10000, &v282, 4u))
        {
LABEL_152:
          uint64_t v75 = v54;
          id v272 = *(id *)(v7[13] + 168);

          id v76 = v272;
          if (v272) {
            int v77 = *((_DWORD *)v272 + 2);
          }
          else {
            int v77 = 0;
          }
          int v78 = v274;
          int v280 = v77;
          int v79 = v18->sa_family;
          if (v79 == 30)
          {
            *(_DWORD *)os_log_type_t type = required_address_family == 30;
            if (setsockopt(v274, 41, 27, type, 4u))
            {
              id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                         + 8));
              int v80 = nw_error_get_error_code(v270);
              BOOL v81 = __nwlog_obj();
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              if (*(_DWORD *)type) {
                BOOL v82 = "on";
              }
              else {
                BOOL v82 = "off";
              }
              address[6] = 2082;
              *(void *)&address[7] = v82;
              address[11] = 1024;
              *(_DWORD *)&address[12] = v80;
              os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v279 = OS_LOG_TYPE_ERROR;
              char v278 = 0;
              if (__nwlog_fault(v83, &v279, &v278))
              {
                if (v279 == OS_LOG_TYPE_FAULT)
                {
                  id v84 = __nwlog_obj();
                  os_log_type_t v85 = v279;
                  if (os_log_type_enabled(v84, v279))
                  {
                    int v86 = "on";
                    if (!*(_DWORD *)type) {
                      int v86 = "off";
                    }
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2082;
                    *(void *)&address[7] = v86;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = v80;
                    _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s IPV6_V6ONLY %{public}s failed %{darwin.errno}d", (uint8_t *)address, 0x1Cu);
                  }
LABEL_400:

                  goto LABEL_429;
                }
                if (!v278)
                {
                  id v84 = __nwlog_obj();
                  os_log_type_t v103 = v279;
                  if (os_log_type_enabled(v84, v279))
                  {
                    v104 = "on";
                    if (!*(_DWORD *)type) {
                      v104 = "off";
                    }
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2082;
                    *(void *)&address[7] = v104;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = v80;
                    _os_log_impl(&dword_1830D4000, v84, v103, "%{public}s IPV6_V6ONLY %{public}s failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x1Cu);
                  }
                  goto LABEL_400;
                }
                os_log_type_t v95 = (char *)__nw_create_backtrace_string();
                os_log_type_t v96 = __nwlog_obj();
                os_log_type_t v97 = v279;
                BOOL v98 = os_log_type_enabled(v96, v279);
                if (v95)
                {
                  if (v98)
                  {
                    __int16 v99 = "on";
                    if (!*(_DWORD *)type) {
                      __int16 v99 = "off";
                    }
                    *(_DWORD *)address = 136446978;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2082;
                    *(void *)&address[7] = v99;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = v80;
                    address[14] = 2082;
                    *(void *)&address[15] = v95;
                    _os_log_impl(&dword_1830D4000, v96, v97, "%{public}s IPV6_V6ONLY %{public}s failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x26u);
                  }
                  goto LABEL_195;
                }
                if (v98)
                {
                  os_log_type_t v105 = "on";
                  if (!*(_DWORD *)type) {
                    os_log_type_t v105 = "off";
                  }
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 2082;
                  *(void *)&address[7] = v105;
                  address[11] = 1024;
                  *(_DWORD *)&address[12] = v80;
                  _os_log_impl(&dword_1830D4000, v96, v97, "%{public}s IPV6_V6ONLY %{public}s failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x1Cu);
                }
                goto LABEL_428;
              }
LABEL_429:
              if (!v83)
              {
LABEL_431:
                id v76 = v272;
                goto LABEL_432;
              }
LABEL_430:
              free(v83);
              goto LABEL_431;
            }
            if (v280 && setsockopt(v274, 41, 125, &v280, 4u))
            {
              id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                         + 8));
              int v90 = nw_error_get_error_code(v270);
              os_log_type_t v91 = __nwlog_obj();
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v280;
              address[9] = 1024;
              *(_DWORD *)&address[10] = v90;
              os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v279 = OS_LOG_TYPE_ERROR;
              char v278 = 0;
              if (!__nwlog_fault(v83, &v279, &v278)) {
                goto LABEL_429;
              }
              if (v279 == OS_LOG_TYPE_FAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v92 = v279;
                if (os_log_type_enabled(v84, v279))
                {
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v280;
                  address[9] = 1024;
                  *(_DWORD *)&address[10] = v90;
                  _os_log_impl(&dword_1830D4000, v84, v92, "%{public}s IPV6_BOUND_IF %d failed %{darwin.errno}d", (uint8_t *)address, 0x18u);
                }
                goto LABEL_400;
              }
              if (!v278)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v120 = v279;
                if (os_log_type_enabled(v84, v279))
                {
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v280;
                  address[9] = 1024;
                  *(_DWORD *)&address[10] = v90;
                  _os_log_impl(&dword_1830D4000, v84, v120, "%{public}s IPV6_BOUND_IF %d failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x18u);
                }
                goto LABEL_400;
              }
              os_log_type_t v95 = (char *)__nw_create_backtrace_string();
              os_log_type_t v96 = __nwlog_obj();
              os_log_type_t v106 = v279;
              BOOL v107 = os_log_type_enabled(v96, v279);
              if (v95)
              {
                if (v107)
                {
                  *(_DWORD *)address = 136446978;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v280;
                  address[9] = 1024;
                  *(_DWORD *)&address[10] = v90;
                  address[12] = 2082;
                  *(void *)&address[13] = v95;
                  _os_log_impl(&dword_1830D4000, v96, v106, "%{public}s IPV6_BOUND_IF %d failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x22u);
                }
                goto LABEL_195;
              }
              if (v107)
              {
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v280;
                address[9] = 1024;
                *(_DWORD *)&address[10] = v90;
                _os_log_impl(&dword_1830D4000, v96, v106, "%{public}s IPV6_BOUND_IF %d failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x18u);
              }
              goto LABEL_428;
            }
          }
          else if (v79 == 2 && v77 && setsockopt(v274, 0, 25, &v280, 4u))
          {
            id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
            int v87 = nw_error_get_error_code(v270);
            uint64_t v88 = __nwlog_obj();
            *(_DWORD *)address = 136446722;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v280;
            address[9] = 1024;
            *(_DWORD *)&address[10] = v87;
            os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v83, type, &v279)) {
              goto LABEL_429;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              id v84 = __nwlog_obj();
              os_log_type_t v89 = type[0];
              if (os_log_type_enabled(v84, type[0]))
              {
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v280;
                address[9] = 1024;
                *(_DWORD *)&address[10] = v87;
                _os_log_impl(&dword_1830D4000, v84, v89, "%{public}s IP_BOUND_IF %d failed %{darwin.errno}d", (uint8_t *)address, 0x18u);
              }
              goto LABEL_400;
            }
            if (v279 == OS_LOG_TYPE_DEFAULT)
            {
              id v84 = __nwlog_obj();
              os_log_type_t v108 = type[0];
              if (os_log_type_enabled(v84, type[0]))
              {
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v280;
                address[9] = 1024;
                *(_DWORD *)&address[10] = v87;
                _os_log_impl(&dword_1830D4000, v84, v108, "%{public}s IP_BOUND_IF %d failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x18u);
              }
              goto LABEL_400;
            }
            uint64_t v100 = (char *)__nw_create_backtrace_string();
            os_log_type_t v96 = __nwlog_obj();
            os_log_type_t v101 = type[0];
            BOOL v102 = os_log_type_enabled(v96, type[0]);
            if (v100)
            {
              if (v102)
              {
                *(_DWORD *)address = 136446978;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v280;
                address[9] = 1024;
                *(_DWORD *)&address[10] = v87;
                address[12] = 2082;
                *(void *)&address[13] = v100;
                _os_log_impl(&dword_1830D4000, v96, v101, "%{public}s IP_BOUND_IF %d failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x22u);
              }

              free(v100);
              goto LABEL_429;
            }
            if (v102)
            {
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v280;
              address[9] = 1024;
              *(_DWORD *)&address[10] = v87;
              _os_log_impl(&dword_1830D4000, v96, v101, "%{public}s IP_BOUND_IF %d failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x18u);
            }
            goto LABEL_428;
          }
          if (uuid_is_null(a2) || !setsockopt(v274, 0xFFFF, 4384, a2, 0x10u))
          {
LABEL_276:
            if (bind(v78, v18, v18->sa_len))
            {
              os_log_type_t v133 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                         + 8));
              unsigned int v134 = nw_error_get_error_code(v133);
              unsigned int v135 = v134;
              id v270 = v133;
              if (v134 <= 0x31 && ((1 << v134) & 0x3000000002006) != 0)
              {
                BOOL v136 = __nwlog_obj();
                if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)address = 136447235;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v78;
                  address[9] = 2113;
                  *(void *)&address[10] = v8;
                  address[14] = 2114;
                  *(void *)&address[15] = v75;
                  __int16 v284 = 1024;
                  unsigned int v285 = v135;
                  _os_log_impl(&dword_1830D4000, v136, OS_LOG_TYPE_ERROR, "%{public}s bind(%d, %{private}@) %{public}@ failed %{darwin.errno}d", (uint8_t *)address, 0x2Cu);
                }

                goto LABEL_431;
              }
              __int16 v146 = __nwlog_obj();
              *(_DWORD *)address = 136447235;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v78;
              address[9] = 2113;
              *(void *)&address[10] = v8;
              address[14] = 2114;
              *(void *)&address[15] = v75;
              __int16 v284 = 1024;
              unsigned int v285 = v135;
              os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v83, type, &v279)) {
                goto LABEL_429;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v147 = type[0];
                if (os_log_type_enabled(v84, type[0]))
                {
                  *(_DWORD *)address = 136447235;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v274;
                  address[9] = 2113;
                  *(void *)&address[10] = v8;
                  address[14] = 2114;
                  *(void *)&address[15] = v75;
                  __int16 v284 = 1024;
                  unsigned int v285 = v135;
                  _os_log_impl(&dword_1830D4000, v84, v147, "%{public}s bind(%d, %{private}@) %{public}@ failed %{darwin.errno}d", (uint8_t *)address, 0x2Cu);
                }
                goto LABEL_400;
              }
              if (v279 == OS_LOG_TYPE_DEFAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v165 = type[0];
                if (os_log_type_enabled(v84, type[0]))
                {
                  *(_DWORD *)address = 136447235;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v274;
                  address[9] = 2113;
                  *(void *)&address[10] = v8;
                  address[14] = 2114;
                  *(void *)&address[15] = v75;
                  __int16 v284 = 1024;
                  unsigned int v285 = v135;
                  _os_log_impl(&dword_1830D4000, v84, v165, "%{public}s bind(%d, %{private}@) %{public}@ failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x2Cu);
                }
                goto LABEL_400;
              }
              os_log_type_t v95 = (char *)__nw_create_backtrace_string();
              os_log_type_t v96 = __nwlog_obj();
              os_log_type_t v156 = type[0];
              BOOL v157 = os_log_type_enabled(v96, type[0]);
              if (v95)
              {
                if (v157)
                {
                  *(_DWORD *)address = 136447491;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v274;
                  address[9] = 2113;
                  *(void *)&address[10] = v8;
                  address[14] = 2114;
                  *(void *)&address[15] = v75;
                  __int16 v284 = 1024;
                  unsigned int v285 = v135;
                  __int16 v286 = 2082;
                  v287 = v95;
                  _os_log_impl(&dword_1830D4000, v96, v156, "%{public}s bind(%d, %{private}@) %{public}@ failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x36u);
                }
LABEL_195:

                free(v95);
                if (!v83) {
                  goto LABEL_431;
                }
                goto LABEL_430;
              }
              if (v157)
              {
                *(_DWORD *)address = 136447235;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v274;
                address[9] = 2113;
                *(void *)&address[10] = v8;
                address[14] = 2114;
                *(void *)&address[15] = v75;
                __int16 v284 = 1024;
                unsigned int v285 = v135;
                _os_log_impl(&dword_1830D4000, v96, v156, "%{public}s bind(%d, %{private}@) %{public}@ failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x2Cu);
              }
LABEL_428:

              goto LABEL_429;
            }
            if (v20 == 6)
            {
              if (listen(v78, 1024))
              {
                id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                           + 8));
                int v137 = nw_error_get_error_code(v270);
                BOOL v138 = __nwlog_obj();
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v137;
                os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
                if (!__nwlog_fault(v83, type, &v279)) {
                  goto LABEL_429;
                }
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  id v84 = __nwlog_obj();
                  os_log_type_t v139 = type[0];
                  if (os_log_type_enabled(v84, type[0]))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v137;
                    _os_log_impl(&dword_1830D4000, v84, v139, "%{public}s listen failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                  }
                  goto LABEL_400;
                }
                if (v279 == OS_LOG_TYPE_DEFAULT)
                {
                  id v84 = __nwlog_obj();
                  os_log_type_t v164 = type[0];
                  if (os_log_type_enabled(v84, type[0]))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v137;
                    _os_log_impl(&dword_1830D4000, v84, v164, "%{public}s listen failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                  }
                  goto LABEL_400;
                }
                os_log_type_t v153 = (char *)__nw_create_backtrace_string();
                os_log_type_t v96 = __nwlog_obj();
                os_log_type_t v154 = type[0];
                BOOL v155 = os_log_type_enabled(v96, type[0]);
                if (!v153)
                {
                  if (v155)
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v137;
                    _os_log_impl(&dword_1830D4000, v96, v154, "%{public}s listen failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                  }
                  goto LABEL_428;
                }
                if (v155)
                {
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v137;
                  address[9] = 2082;
                  *(void *)&address[10] = v153;
                  _os_log_impl(&dword_1830D4000, v96, v154, "%{public}s listen failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                }
LABEL_315:

                free(v153);
                if (!v83) {
                  goto LABEL_431;
                }
                goto LABEL_430;
              }
LABEL_463:
              id v270 = 0;
LABEL_432:

              int v74 = v274;
              posix_error = v270;
              if (v270) {
                goto LABEL_145;
              }
              goto LABEL_433;
            }
            int v140 = v18->sa_family;
            if (v140 != 2)
            {
              if (v140 != 30) {
                goto LABEL_463;
              }
              if (setsockopt(v78, 41, 61, &v282, 4u) < 0)
              {
                id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                           + 8));
                int v158 = nw_error_get_error_code(v270);
                v159 = __nwlog_obj();
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v158;
                os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
                if (!__nwlog_fault(v83, type, &v279)) {
                  goto LABEL_429;
                }
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  id v84 = __nwlog_obj();
                  os_log_type_t v160 = type[0];
                  if (os_log_type_enabled(v84, type[0]))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v158;
                    _os_log_impl(&dword_1830D4000, v84, v160, "%{public}s IPV6_RECVPKTINFO failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                  }
                  goto LABEL_400;
                }
                if (v279 == OS_LOG_TYPE_DEFAULT)
                {
                  id v84 = __nwlog_obj();
                  os_log_type_t v180 = type[0];
                  if (os_log_type_enabled(v84, type[0]))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v158;
                    _os_log_impl(&dword_1830D4000, v84, v180, "%{public}s IPV6_RECVPKTINFO failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                  }
                  goto LABEL_400;
                }
                os_log_type_t v153 = (char *)__nw_create_backtrace_string();
                os_log_type_t v96 = __nwlog_obj();
                os_log_type_t v169 = type[0];
                BOOL v170 = os_log_type_enabled(v96, type[0]);
                if (!v153)
                {
                  if (v170)
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v158;
                    _os_log_impl(&dword_1830D4000, v96, v169, "%{public}s IPV6_RECVPKTINFO failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                  }
                  goto LABEL_428;
                }
                if (v170)
                {
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v158;
                  address[9] = 2082;
                  *(void *)&address[10] = v153;
                  _os_log_impl(&dword_1830D4000, v96, v169, "%{public}s IPV6_RECVPKTINFO failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                }
                goto LABEL_315;
              }
              if ((setsockopt(v78, 41, 35, &v282, 4u) & 0x80000000) == 0) {
                goto LABEL_407;
              }
              int v141 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
              __int16 v142 = __nwlog_obj();
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v141;
              uint64_t v143 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v143, type, &v279))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __int16 v144 = __nwlog_obj();
                  os_log_type_t v145 = type[0];
                  if (os_log_type_enabled(v144, type[0]))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v141;
                    _os_log_impl(&dword_1830D4000, v144, v145, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                  }
                }
                else if (v279)
                {
                  v173 = (char *)__nw_create_backtrace_string();
                  __int16 v144 = __nwlog_obj();
                  os_log_type_t v174 = type[0];
                  BOOL v175 = os_log_type_enabled(v144, type[0]);
                  if (v173)
                  {
                    if (v175)
                    {
                      *(_DWORD *)address = 136446722;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v141;
                      address[9] = 2082;
                      *(void *)&address[10] = v173;
                      _os_log_impl(&dword_1830D4000, v144, v174, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                    }

                    free(v173);
                    goto LABEL_404;
                  }
                  if (v175)
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v141;
                    _os_log_impl(&dword_1830D4000, v144, v174, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                  }
                }
                else
                {
                  __int16 v144 = __nwlog_obj();
                  os_log_type_t v182 = type[0];
                  if (os_log_type_enabled(v144, type[0]))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v141;
                    _os_log_impl(&dword_1830D4000, v144, v182, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                  }
                }
              }
LABEL_404:
              if (v143) {
                free(v143);
              }
              id v76 = v272;
LABEL_407:
              if (!endpoint) {
                goto LABEL_463;
              }
              id v184 = __nwlog_obj();
              if (os_log_type_enabled(v184, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 2112;
                *(void *)&address[7] = endpoint;
                _os_log_impl(&dword_1830D4000, v184, OS_LOG_TYPE_DEBUG, "%{public}s Joining multicast group %@", (uint8_t *)address, 0x16u);
              }

              memset(type, 0, sizeof(type));
              int v277 = 0;
              *(sockaddr *)os_log_type_t type = *(sockaddr *)&nw_endpoint_get_address(endpoint)->sa_data[6];
              nw_interface_t v185 = nw_parameters_copy_required_interface(v75);
              xpc_object_t v186 = v185;
              if (!v185)
              {
LABEL_413:
                if ((setsockopt(v274, 41, 13, type, 0x14u) & 0x80000000) == 0) {
                  goto LABEL_488;
                }
                int v187 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                uint64_t v188 = __nwlog_obj();
                v189 = v188;
                if (v187 == 49)
                {
                  if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2112;
                    *(void *)&address[7] = endpoint;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = 49;
                    _os_log_impl(&dword_1830D4000, v189, OS_LOG_TYPE_ERROR, "%{public}s IPV6_LEAVE_GROUP %@ failed %{darwin.errno}d", (uint8_t *)address, 0x1Cu);
                  }

                  goto LABEL_488;
                }
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 2112;
                *(void *)&address[7] = endpoint;
                address[11] = 1024;
                *(_DWORD *)&address[12] = v187;
                v191 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v279 = OS_LOG_TYPE_ERROR;
                char v278 = 0;
                if (__nwlog_fault(v191, &v279, &v278))
                {
                  if (v279 == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v192 = __nwlog_obj();
                    os_log_type_t v193 = v279;
                    if (os_log_type_enabled(v192, v279))
                    {
                      *(_DWORD *)address = 136446722;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 2112;
                      *(void *)&address[7] = endpoint;
                      address[11] = 1024;
                      *(_DWORD *)&address[12] = v187;
                      _os_log_impl(&dword_1830D4000, v192, v193, "%{public}s IPV6_LEAVE_GROUP %@ failed %{darwin.errno}d", (uint8_t *)address, 0x1Cu);
                    }
                  }
                  else if (v278)
                  {
                    v195 = (char *)__nw_create_backtrace_string();
                    uint64_t v192 = __nwlog_obj();
                    os_log_type_t v265 = v279;
                    BOOL v196 = os_log_type_enabled(v192, v279);
                    if (v195)
                    {
                      if (v196)
                      {
                        *(_DWORD *)address = 136446978;
                        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                        address[6] = 2112;
                        *(void *)&address[7] = endpoint;
                        address[11] = 1024;
                        *(_DWORD *)&address[12] = v187;
                        address[14] = 2082;
                        *(void *)&address[15] = v195;
                        _os_log_impl(&dword_1830D4000, v192, v265, "%{public}s IPV6_LEAVE_GROUP %@ failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x26u);
                      }

                      free(v195);
                      goto LABEL_486;
                    }
                    if (v196)
                    {
                      *(_DWORD *)address = 136446722;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 2112;
                      *(void *)&address[7] = endpoint;
                      address[11] = 1024;
                      *(_DWORD *)&address[12] = v187;
                      _os_log_impl(&dword_1830D4000, v192, v265, "%{public}s IPV6_LEAVE_GROUP %@ failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x1Cu);
                    }
                  }
                  else
                  {
                    uint64_t v192 = __nwlog_obj();
                    os_log_type_t v211 = v279;
                    if (os_log_type_enabled(v192, v279))
                    {
                      *(_DWORD *)address = 136446722;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 2112;
                      *(void *)&address[7] = endpoint;
                      address[11] = 1024;
                      *(_DWORD *)&address[12] = v187;
                      _os_log_impl(&dword_1830D4000, v192, v211, "%{public}s IPV6_LEAVE_GROUP %@ failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x1Cu);
                    }
                  }
                }
LABEL_486:
                if (v191) {
                  free(v191);
                }
LABEL_488:
                if ((setsockopt(v274, 41, 12, type, 0x14u) & 0x80000000) == 0)
                {
                  v212 = nw_parameters_copy_default_protocol_stack(v75);
                  xpc_object_t v213 = v212;
                  if (v212)
                  {
                    nw_protocol_options_t v214 = nw_protocol_stack_copy_internet_protocol(v212);
                    nw_protocol_options_t v215 = v214;
                    if (v214)
                    {
                      __int16 v216 = nw_ip_options_get_disable_multicast_loopback(v214) ? &v281 : &v282;
                      if (setsockopt(v274, 41, 11, v216, 4u))
                      {
                        int v217 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                        __int16 v218 = __nwlog_obj();
                        *(_DWORD *)address = 136446466;
                        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                        address[6] = 1024;
                        int v219 = v217;
                        *(_DWORD *)&address[7] = v217;
                        __int16 v220 = (char *)_os_log_send_and_compose_impl();

                        os_log_type_t v279 = OS_LOG_TYPE_ERROR;
                        char v278 = 0;
                        if (__nwlog_fault(v220, &v279, &v278))
                        {
                          if (v279 == OS_LOG_TYPE_FAULT)
                          {
                            v221 = __nwlog_obj();
                            os_log_type_t v222 = v279;
                            if (os_log_type_enabled(v221, v279))
                            {
                              *(_DWORD *)address = 136446466;
                              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                              address[6] = 1024;
                              *(_DWORD *)&address[7] = v219;
                              _os_log_impl(&dword_1830D4000, v221, v222, "%{public}s IPV6_MULTICAST_LOOP failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                            }
                          }
                          else
                          {
                            if (v278)
                            {
                              v232 = (char *)__nw_create_backtrace_string();
                              v233 = __nwlog_obj();
                              os_log_type_t v267 = v279;
                              BOOL v234 = os_log_type_enabled(v233, v279);
                              if (v232)
                              {
                                if (v234)
                                {
                                  *(_DWORD *)address = 136446722;
                                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                                  address[6] = 1024;
                                  *(_DWORD *)&address[7] = v219;
                                  address[9] = 2082;
                                  *(void *)&address[10] = v232;
                                  _os_log_impl(&dword_1830D4000, v233, v267, "%{public}s IPV6_MULTICAST_LOOP failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                                }

                                free(v232);
                              }
                              else
                              {
                                if (v234)
                                {
                                  *(_DWORD *)address = 136446466;
                                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                                  address[6] = 1024;
                                  *(_DWORD *)&address[7] = v219;
                                  _os_log_impl(&dword_1830D4000, v233, v267, "%{public}s IPV6_MULTICAST_LOOP failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                                }
                              }
                              goto LABEL_533;
                            }
                            v221 = __nwlog_obj();
                            os_log_type_t v236 = v279;
                            if (os_log_type_enabled(v221, v279))
                            {
                              *(_DWORD *)address = 136446466;
                              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                              address[6] = 1024;
                              *(_DWORD *)&address[7] = v219;
                              _os_log_impl(&dword_1830D4000, v221, v236, "%{public}s IPV6_MULTICAST_LOOP failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                            }
                          }
                        }
LABEL_533:
                        if (v220) {
                          free(v220);
                        }
                      }
                    }
                  }
                  else
                  {
                    nw_protocol_options_t v215 = 0;
                  }

                  id v270 = 0;
                  goto LABEL_536;
                }
                unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                id v270 = nw_error_create_posix_error(**(_DWORD **)(StatusReg + 8));
                int v224 = **(_DWORD **)(StatusReg + 8);
                id v225 = __nwlog_obj();
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v224;
                __int16 v226 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v279 = OS_LOG_TYPE_ERROR;
                char v278 = 0;
                if (__nwlog_fault(v226, &v279, &v278))
                {
                  if (v279 == OS_LOG_TYPE_FAULT)
                  {
                    v227 = __nwlog_obj();
                    os_log_type_t v228 = v279;
                    if (os_log_type_enabled(v227, v279))
                    {
                      *(_DWORD *)address = 136446466;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v224;
                      _os_log_impl(&dword_1830D4000, v227, v228, "%{public}s IPV6_JOIN_GROUP failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                    }
LABEL_521:

                    goto LABEL_522;
                  }
                  if (!v278)
                  {
                    v227 = __nwlog_obj();
                    os_log_type_t v235 = v279;
                    if (os_log_type_enabled(v227, v279))
                    {
                      *(_DWORD *)address = 136446466;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v224;
                      _os_log_impl(&dword_1830D4000, v227, v235, "%{public}s IPV6_JOIN_GROUP failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                    }
                    goto LABEL_521;
                  }
                  v229 = (char *)__nw_create_backtrace_string();
                  v227 = __nwlog_obj();
                  os_log_type_t v230 = v279;
                  BOOL v231 = os_log_type_enabled(v227, v279);
                  if (!v229)
                  {
                    if (v231)
                    {
                      *(_DWORD *)address = 136446466;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v224;
                      _os_log_impl(&dword_1830D4000, v227, v230, "%{public}s IPV6_JOIN_GROUP failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                    }
                    goto LABEL_521;
                  }
                  if (v231)
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v224;
                    address[9] = 2082;
                    *(void *)&address[10] = v229;
                    _os_log_impl(&dword_1830D4000, v227, v230, "%{public}s IPV6_JOIN_GROUP failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                  }

                  free(v229);
                }
LABEL_522:
                if (v226) {
LABEL_523:
                }
                  free(v226);
LABEL_536:

                goto LABEL_431;
              }
              if (nw_interface_supports_multicast(v185))
              {
                int v277 = v186[2];
                goto LABEL_413;
              }
              xpc_object_t v190 = __nwlog_obj();
              if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 2112;
                *(void *)&address[7] = v186;
                _os_log_impl(&dword_1830D4000, v190, OS_LOG_TYPE_ERROR, "%{public}s Interface %@ doesn't support multicast", (uint8_t *)address, 0x16u);
              }
LABEL_420:

              id v270 = nw_error_create_posix_error(22);
              goto LABEL_536;
            }
            if (setsockopt(v78, 0, 20, &v282, 4u) < 0)
            {
              id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                         + 8));
              int v161 = nw_error_get_error_code(v270);
              xpc_object_t v162 = __nwlog_obj();
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v161;
              os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v83, type, &v279)) {
                goto LABEL_429;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v163 = type[0];
                if (os_log_type_enabled(v84, type[0]))
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v161;
                  _os_log_impl(&dword_1830D4000, v84, v163, "%{public}s IP_RECVIF failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                }
                goto LABEL_400;
              }
              if (v279 == OS_LOG_TYPE_DEFAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v181 = type[0];
                if (os_log_type_enabled(v84, type[0]))
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v161;
                  _os_log_impl(&dword_1830D4000, v84, v181, "%{public}s IP_RECVIF failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                }
                goto LABEL_400;
              }
              os_log_type_t v153 = (char *)__nw_create_backtrace_string();
              os_log_type_t v96 = __nwlog_obj();
              os_log_type_t v171 = type[0];
              BOOL v172 = os_log_type_enabled(v96, type[0]);
              if (!v153)
              {
                if (v172)
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v161;
                  _os_log_impl(&dword_1830D4000, v96, v171, "%{public}s IP_RECVIF failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                }
                goto LABEL_428;
              }
              if (v172)
              {
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v161;
                address[9] = 2082;
                *(void *)&address[10] = v153;
                _os_log_impl(&dword_1830D4000, v96, v171, "%{public}s IP_RECVIF failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
              }
              goto LABEL_315;
            }
            if (setsockopt(v78, 0, 7, &v282, 4u) < 0)
            {
              id v270 = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                         + 8));
              int v166 = nw_error_get_error_code(v270);
              v167 = __nwlog_obj();
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v166;
              os_log_type_t v83 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v83, type, &v279)) {
                goto LABEL_429;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v168 = type[0];
                if (os_log_type_enabled(v84, type[0]))
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v166;
                  _os_log_impl(&dword_1830D4000, v84, v168, "%{public}s IP_RECVDSTADDR failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                }
                goto LABEL_400;
              }
              if (v279 == OS_LOG_TYPE_DEFAULT)
              {
                id v84 = __nwlog_obj();
                os_log_type_t v183 = type[0];
                if (os_log_type_enabled(v84, type[0]))
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v166;
                  _os_log_impl(&dword_1830D4000, v84, v183, "%{public}s IP_RECVDSTADDR failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                }
                goto LABEL_400;
              }
              os_log_type_t v153 = (char *)__nw_create_backtrace_string();
              os_log_type_t v96 = __nwlog_obj();
              os_log_type_t v176 = type[0];
              BOOL v177 = os_log_type_enabled(v96, type[0]);
              if (!v153)
              {
                if (v177)
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v166;
                  _os_log_impl(&dword_1830D4000, v96, v176, "%{public}s IP_RECVDSTADDR failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                }
                goto LABEL_428;
              }
              if (v177)
              {
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v166;
                address[9] = 2082;
                *(void *)&address[10] = v153;
                _os_log_impl(&dword_1830D4000, v96, v176, "%{public}s IP_RECVDSTADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
              }
              goto LABEL_315;
            }
            if ((setsockopt(v78, 0, 27, &v282, 4u) & 0x80000000) == 0)
            {
LABEL_449:
              if (!endpoint) {
                goto LABEL_463;
              }
              v197 = __nwlog_obj();
              if (os_log_type_enabled(v197, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 2112;
                *(void *)&address[7] = endpoint;
                _os_log_impl(&dword_1830D4000, v197, OS_LOG_TYPE_DEBUG, "%{public}s Joining multicast group %@", (uint8_t *)address, 0x16u);
              }

              *(void *)os_log_type_t type = 0;
              *(_DWORD *)os_log_type_t type = *(_DWORD *)&nw_endpoint_get_address(endpoint)->sa_data[2];
              *(_DWORD *)&type[4] = 0;
              nw_interface_t v198 = nw_parameters_copy_required_interface(v75);
              xpc_object_t v186 = v198;
              if (v198)
              {
                if (!nw_interface_supports_multicast(v198))
                {
                  xpc_object_t v190 = __nwlog_obj();
                  if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2112;
                    *(void *)&address[7] = v186;
                    _os_log_impl(&dword_1830D4000, v190, OS_LOG_TYPE_ERROR, "%{public}s Interface %@ doesn't support multicast", (uint8_t *)address, 0x16u);
                  }
                  goto LABEL_420;
                }
                nw_endpoint_t host = nw_endpoint_create_host("0.0.0.0", "0");
                uint64_t v200 = nw_interface_copy_local_address_for_remote_address(v186, host);
                v201 = v200;
                if (!v200)
                {
                  nw_endpoint_t v205 = __nwlog_obj();
                  if (os_log_type_enabled(v205, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)address = 136446466;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2112;
                    *(void *)&address[7] = v186;
                    _os_log_impl(&dword_1830D4000, v205, OS_LOG_TYPE_ERROR, "%{public}s Did not find interface address for %@", (uint8_t *)address, 0x16u);
                  }

                  id v270 = nw_error_create_posix_error(2);
                  goto LABEL_536;
                }
                if (nw_endpoint_get_address(v200)) {
                  *(_DWORD *)&type[4] = *(_DWORD *)&v18->sa_data[2];
                }
              }
              if ((setsockopt(v274, 0, 13, type, 8u) & 0x80000000) == 0)
              {
LABEL_542:
                if ((setsockopt(v274, 0, 12, type, 8u) & 0x80000000) == 0)
                {
                  v238 = nw_parameters_copy_default_protocol_stack(v75);
                  v239 = v238;
                  if (v238)
                  {
                    nw_protocol_options_t v240 = nw_protocol_stack_copy_internet_protocol(v238);
                    nw_protocol_options_t v241 = v240;
                    if (v240)
                    {
                      v242 = nw_ip_options_get_disable_multicast_loopback(v240) ? &v281 : &v282;
                      if (setsockopt(v274, 0, 11, v242, 4u))
                      {
                        int v243 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                        v244 = __nwlog_obj();
                        *(_DWORD *)address = 136446466;
                        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                        address[6] = 1024;
                        int v245 = v243;
                        *(_DWORD *)&address[7] = v243;
                        v246 = (char *)_os_log_send_and_compose_impl();

                        os_log_type_t v279 = OS_LOG_TYPE_ERROR;
                        char v278 = 0;
                        if (__nwlog_fault(v246, &v279, &v278))
                        {
                          if (v279 == OS_LOG_TYPE_FAULT)
                          {
                            v247 = __nwlog_obj();
                            os_log_type_t v248 = v279;
                            if (os_log_type_enabled(v247, v279))
                            {
                              *(_DWORD *)address = 136446466;
                              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                              address[6] = 1024;
                              *(_DWORD *)&address[7] = v245;
                              _os_log_impl(&dword_1830D4000, v247, v248, "%{public}s IP_MULTICAST_LOOP failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                            }
                          }
                          else
                          {
                            if (v278)
                            {
                              v257 = (char *)__nw_create_backtrace_string();
                              v258 = __nwlog_obj();
                              os_log_type_t v268 = v279;
                              BOOL v259 = os_log_type_enabled(v258, v279);
                              if (v257)
                              {
                                if (v259)
                                {
                                  *(_DWORD *)address = 136446722;
                                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                                  address[6] = 1024;
                                  *(_DWORD *)&address[7] = v245;
                                  address[9] = 2082;
                                  *(void *)&address[10] = v257;
                                  _os_log_impl(&dword_1830D4000, v258, v268, "%{public}s IP_MULTICAST_LOOP failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                                }

                                free(v257);
                              }
                              else
                              {
                                if (v259)
                                {
                                  *(_DWORD *)address = 136446466;
                                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                                  address[6] = 1024;
                                  *(_DWORD *)&address[7] = v245;
                                  _os_log_impl(&dword_1830D4000, v258, v268, "%{public}s IP_MULTICAST_LOOP failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                                }
                              }
                              goto LABEL_584;
                            }
                            v247 = __nwlog_obj();
                            os_log_type_t v261 = v279;
                            if (os_log_type_enabled(v247, v279))
                            {
                              *(_DWORD *)address = 136446466;
                              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                              address[6] = 1024;
                              *(_DWORD *)&address[7] = v245;
                              _os_log_impl(&dword_1830D4000, v247, v261, "%{public}s IP_MULTICAST_LOOP failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                            }
                          }
                        }
LABEL_584:
                        if (v246) {
                          free(v246);
                        }
                      }
                    }
                  }
                  else
                  {
                    nw_protocol_options_t v241 = 0;
                  }

                  id v270 = 0;
                  goto LABEL_536;
                }
                unint64_t v249 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                id v270 = nw_error_create_posix_error(**(_DWORD **)(v249 + 8));
                int v250 = **(_DWORD **)(v249 + 8);
                v251 = __nwlog_obj();
                *(_DWORD *)address = 136446466;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v250;
                __int16 v226 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v279 = OS_LOG_TYPE_ERROR;
                char v278 = 0;
                if (__nwlog_fault(v226, &v279, &v278))
                {
                  if (v279 == OS_LOG_TYPE_FAULT)
                  {
                    v252 = __nwlog_obj();
                    os_log_type_t v253 = v279;
                    if (os_log_type_enabled(v252, v279))
                    {
                      *(_DWORD *)address = 136446466;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v250;
                      _os_log_impl(&dword_1830D4000, v252, v253, "%{public}s IP_ADD_MEMBERSHIP failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                    }
LABEL_575:

                    goto LABEL_576;
                  }
                  if (!v278)
                  {
                    v252 = __nwlog_obj();
                    os_log_type_t v260 = v279;
                    if (os_log_type_enabled(v252, v279))
                    {
                      *(_DWORD *)address = 136446466;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v250;
                      _os_log_impl(&dword_1830D4000, v252, v260, "%{public}s IP_ADD_MEMBERSHIP failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                    }
                    goto LABEL_575;
                  }
                  os_log_type_t v254 = (char *)__nw_create_backtrace_string();
                  v252 = __nwlog_obj();
                  os_log_type_t v255 = v279;
                  BOOL v256 = os_log_type_enabled(v252, v279);
                  if (!v254)
                  {
                    if (v256)
                    {
                      *(_DWORD *)address = 136446466;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 1024;
                      *(_DWORD *)&address[7] = v250;
                      _os_log_impl(&dword_1830D4000, v252, v255, "%{public}s IP_ADD_MEMBERSHIP failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                    }
                    goto LABEL_575;
                  }
                  if (v256)
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v250;
                    address[9] = 2082;
                    *(void *)&address[10] = v254;
                    _os_log_impl(&dword_1830D4000, v252, v255, "%{public}s IP_ADD_MEMBERSHIP failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                  }

                  free(v254);
                }
LABEL_576:
                if (!v226) {
                  goto LABEL_536;
                }
                goto LABEL_523;
              }
              int v202 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
              v203 = __nwlog_obj();
              nw_protocol_metadata_t v204 = v203;
              if (v202 == 49)
              {
                if (os_log_type_enabled(v203, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 2112;
                  *(void *)&address[7] = endpoint;
                  address[11] = 1024;
                  *(_DWORD *)&address[12] = 49;
                  _os_log_impl(&dword_1830D4000, v204, OS_LOG_TYPE_ERROR, "%{public}s IP_DROP_MEMBERSHIP %@ failed %{darwin.errno}d", (uint8_t *)address, 0x1Cu);
                }

                goto LABEL_542;
              }
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 2112;
              *(void *)&address[7] = endpoint;
              address[11] = 1024;
              *(_DWORD *)&address[12] = v202;
              uint64_t v206 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v279 = OS_LOG_TYPE_ERROR;
              char v278 = 0;
              if (__nwlog_fault(v206, &v279, &v278))
              {
                if (v279 == OS_LOG_TYPE_FAULT)
                {
                  nw_endpoint_t v207 = __nwlog_obj();
                  os_log_type_t v208 = v279;
                  if (os_log_type_enabled(v207, v279))
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2112;
                    *(void *)&address[7] = endpoint;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = v202;
                    _os_log_impl(&dword_1830D4000, v207, v208, "%{public}s IP_DROP_MEMBERSHIP %@ failed %{darwin.errno}d", (uint8_t *)address, 0x1Cu);
                  }
                }
                else if (v278)
                {
                  id v209 = (char *)__nw_create_backtrace_string();
                  nw_endpoint_t v207 = __nwlog_obj();
                  os_log_type_t v266 = v279;
                  BOOL v210 = os_log_type_enabled(v207, v279);
                  if (v209)
                  {
                    if (v210)
                    {
                      *(_DWORD *)address = 136446978;
                      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                      address[6] = 2112;
                      *(void *)&address[7] = endpoint;
                      address[11] = 1024;
                      *(_DWORD *)&address[12] = v202;
                      address[14] = 2082;
                      *(void *)&address[15] = v209;
                      _os_log_impl(&dword_1830D4000, v207, v266, "%{public}s IP_DROP_MEMBERSHIP %@ failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x26u);
                    }

                    free(v209);
                    goto LABEL_540;
                  }
                  if (v210)
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2112;
                    *(void *)&address[7] = endpoint;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = v202;
                    _os_log_impl(&dword_1830D4000, v207, v266, "%{public}s IP_DROP_MEMBERSHIP %@ failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x1Cu);
                  }
                }
                else
                {
                  nw_endpoint_t v207 = __nwlog_obj();
                  os_log_type_t v237 = v279;
                  if (os_log_type_enabled(v207, v279))
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 2112;
                    *(void *)&address[7] = endpoint;
                    address[11] = 1024;
                    *(_DWORD *)&address[12] = v202;
                    _os_log_impl(&dword_1830D4000, v207, v237, "%{public}s IP_DROP_MEMBERSHIP %@ failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x1Cu);
                  }
                }
              }
LABEL_540:
              if (v206) {
                free(v206);
              }
              goto LABEL_542;
            }
            int v148 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            os_log_type_t v149 = __nwlog_obj();
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v148;
            v150 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v150, type, &v279))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                Class v151 = __nwlog_obj();
                os_log_type_t v152 = type[0];
                if (os_log_type_enabled(v151, type[0]))
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v148;
                  _os_log_impl(&dword_1830D4000, v151, v152, "%{public}s IP_RECVTOS failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
                }
              }
              else if (v279)
              {
                xpc_object_t v178 = (char *)__nw_create_backtrace_string();
                Class v151 = __nwlog_obj();
                os_log_type_t v264 = type[0];
                BOOL v179 = os_log_type_enabled(v151, type[0]);
                if (v178)
                {
                  if (v179)
                  {
                    *(_DWORD *)address = 136446722;
                    *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                    address[6] = 1024;
                    *(_DWORD *)&address[7] = v148;
                    address[9] = 2082;
                    *(void *)&address[10] = v178;
                    _os_log_impl(&dword_1830D4000, v151, v264, "%{public}s IP_RECVTOS failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                  }

                  free(v178);
                  goto LABEL_446;
                }
                if (v179)
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v148;
                  _os_log_impl(&dword_1830D4000, v151, v264, "%{public}s IP_RECVTOS failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                }
              }
              else
              {
                Class v151 = __nwlog_obj();
                os_log_type_t v194 = type[0];
                if (os_log_type_enabled(v151, type[0]))
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v148;
                  _os_log_impl(&dword_1830D4000, v151, v194, "%{public}s IP_RECVTOS failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
                }
              }
            }
LABEL_446:
            if (v150) {
              free(v150);
            }
            id v76 = v272;
            goto LABEL_449;
          }
          unsigned int v93 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (v93 <= 0x2A && ((1 << v93) & 0x40000400004) != 0)
          {
            BOOL v94 = __nwlog_obj();
            if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v93;
              _os_log_impl(&dword_1830D4000, v94, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
            }

            int v78 = v274;
            id v76 = v272;
            goto LABEL_276;
          }
          BOOL v109 = __nwlog_obj();
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 1024;
          *(_DWORD *)&address[7] = v93;
          unsigned int v110 = (const char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v279 = OS_LOG_TYPE_DEFAULT;
          uint64_t v111 = (char *)v110;
          if (!__nwlog_fault(v110, type, &v279))
          {
LABEL_273:
            id v76 = v272;
            if (v111) {
              free(v111);
            }
            int v78 = v274;
            goto LABEL_276;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            BOOL v112 = __nwlog_obj();
            os_log_type_t v113 = type[0];
            if (os_log_type_enabled(v112, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v93;
              _os_log_impl(&dword_1830D4000, v112, v113, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
            }
          }
          else
          {
            if (v279)
            {
              BOOL v121 = (char *)__nw_create_backtrace_string();
              __int16 v122 = __nwlog_obj();
              os_log_type_t v263 = type[0];
              BOOL v123 = os_log_type_enabled(v122, type[0]);
              if (v121)
              {
                if (v123)
                {
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v93;
                  address[9] = 2082;
                  *(void *)&address[10] = v121;
                  _os_log_impl(&dword_1830D4000, v122, v263, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
                }

                free(v121);
              }
              else
              {
                if (v123)
                {
                  *(_DWORD *)address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v93;
                  _os_log_impl(&dword_1830D4000, v122, v263, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
                }
              }
              goto LABEL_272;
            }
            BOOL v112 = __nwlog_obj();
            os_log_type_t v130 = type[0];
            if (os_log_type_enabled(v112, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v93;
              _os_log_impl(&dword_1830D4000, v112, v130, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
            }
          }

LABEL_272:
          uint64_t v111 = (char *)v110;
          goto LABEL_273;
        }
        int v56 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        nw_endpoint_t v57 = __nwlog_obj();
        *(_DWORD *)address = 136446466;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        address[6] = 1024;
        int v269 = v56;
        *(_DWORD *)&address[7] = v56;
        id v271 = (const char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v280) = 0;
        __int16 v58 = (char *)v271;
        if (!__nwlog_fault(v271, type, &v280))
        {
LABEL_150:
          if (v58) {
            free(v58);
          }
          goto LABEL_152;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v59 = __nwlog_obj();
          os_log_type_t v60 = type[0];
          if (os_log_type_enabled(v59, type[0]))
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v269;
            _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
          }
        }
        else
        {
          if ((_BYTE)v280)
          {
            int v68 = (char *)__nw_create_backtrace_string();
            uint64_t v69 = __nwlog_obj();
            os_log_type_t v262 = type[0];
            BOOL v70 = os_log_type_enabled(v69, type[0]);
            if (v68)
            {
              if (v70)
              {
                *(_DWORD *)address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v269;
                address[9] = 2082;
                *(void *)&address[10] = v68;
                _os_log_impl(&dword_1830D4000, v69, v262, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
              }

              free(v68);
              goto LABEL_149;
            }
            if (v70)
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v269;
              _os_log_impl(&dword_1830D4000, v69, v262, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
            }
          }
          else
          {
            uint64_t v69 = __nwlog_obj();
            os_log_type_t v73 = type[0];
            if (os_log_type_enabled(v69, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v269;
              _os_log_impl(&dword_1830D4000, v69, v73, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
            }
          }
        }
LABEL_149:
        __int16 v58 = (char *)v271;
        goto LABEL_150;
      }
      int v33 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v34 = (id)gLogObj;
      *(_DWORD *)address = 136446466;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      address[6] = 1024;
      *(_DWORD *)&address[7] = v33;
      BOOL v35 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v282) = 0;
      if (__nwlog_fault(v35, type, &v282))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v36 = (id)gLogObj;
          os_log_type_t v37 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v33;
            _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s socket failed %{darwin.errno}d", (uint8_t *)address, 0x12u);
          }
        }
        else if ((_BYTE)v282)
        {
          uint64_t v46 = (char *)__nw_create_backtrace_string();
          __int16 v36 = __nwlog_obj();
          os_log_type_t v47 = type[0];
          BOOL v48 = os_log_type_enabled(v36, type[0]);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v33;
              address[9] = 2082;
              *(void *)&address[10] = v46;
              _os_log_impl(&dword_1830D4000, v36, v47, "%{public}s socket failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)address, 0x1Cu);
            }

            free(v46);
            if (!v35) {
              goto LABEL_108;
            }
            goto LABEL_107;
          }
          if (v48)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v33;
            _os_log_impl(&dword_1830D4000, v36, v47, "%{public}s socket failed %{darwin.errno}d, no backtrace", (uint8_t *)address, 0x12u);
          }
        }
        else
        {
          __int16 v36 = __nwlog_obj();
          os_log_type_t v62 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v33;
            _os_log_impl(&dword_1830D4000, v36, v62, "%{public}s socket failed %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)address, 0x12u);
          }
        }
      }
      if (!v35)
      {
LABEL_108:
        __int16 v38 = nw_error_create_posix_error(v33);
        goto LABEL_109;
      }
LABEL_107:
      free(v35);
      goto LABEL_108;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v22 = (id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)address = 136446466;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      address[6] = 1024;
      *(_DWORD *)&address[7] = v20;
      _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s IP Protocol %u unrecognized", (uint8_t *)address, 0x12u);
    }
  }
LABEL_59:

  __int16 v38 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
LABEL_109:
  os_log_type_t v24 = v38;
LABEL_110:

LABEL_111:
  return v24;
}

void sub_18336DC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

BOOL nw_create_browser_key_for (const char *a1, void *a2)
{
  id v3 = a2;
  id v4 = (char *)v3;
  if (v3) {
    id v5 = v3 + 104;
  }
  else {
    id v5 = 0;
  }
  size_t v6 = strlen(a1);
  if (v4) {
    size_t v7 = strlen(v5);
  }
  else {
    size_t v7 = 0;
  }
  if (v6 + v7 == -1)
  {
    int v21 = __nwlog_obj();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    BOOL v22 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v22);
    if (result) {
      goto LABEL_32;
    }
    free(v22);
  }
  int v8 = malloc_type_malloc(v6 + v7 + 1, 0xF2B69DE5uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    unsigned char *v8 = 0;
    if (v6 + v7 != -1)
    {
LABEL_10:
      os_log_type_t v10 = v9;
      if (v6 + v7)
      {
        uint64_t v11 = v6 + v7 + 1;
        os_log_type_t v10 = v9;
        while (1)
        {
          int v12 = *(unsigned __int8 *)a1;
          *os_log_type_t v10 = v12;
          if (!v12) {
            break;
          }
          ++v10;
          ++a1;
          if ((unint64_t)--v11 <= 1) {
            goto LABEL_14;
          }
        }
      }
      else
      {
LABEL_14:
        *os_log_type_t v10 = 0;
      }
      if (v4)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 1;
        while (1)
        {
          int v15 = &v9[v13];
          if (!v9[v13]) {
            break;
          }
          ++v13;
          --v14;
          if (v6 + v7 + 1 == v13) {
            goto LABEL_26;
          }
        }
        if (v6 + v7 + v14 < 2)
        {
LABEL_25:
          *int v15 = 0;
        }
        else
        {
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          while (1)
          {
            int v18 = v5[v16];
            v9[v16 + v13] = v18;
            if (!v18) {
              break;
            }
            unint64_t v19 = v6 + v7 - v13 + v17--;
            ++v16;
            if (v19 <= 1)
            {
              int v15 = &v9[v13 + v16];
              goto LABEL_25;
            }
          }
        }
      }
    }
LABEL_26:

    return (BOOL)v9;
  }
  os_log_type_t v23 = __nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  os_log_type_t v24 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
    MEMORY[0] = 0;
    if (v6 + v7 != -1) {
      goto LABEL_10;
    }
    goto LABEL_26;
  }
LABEL_32:
  __break(1u);
  return result;
}

void sub_18336E05C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_browser_remove_result_locked(void *a1, const char *a2, void *a3)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a3;
  uint64_t uint64 = xpc_dictionary_get_uint64(*((xpc_object_t *)v5 + 20), a2);
  int v8 = nw_browser_copy_result_to_modify_locked((NWConcrete_nw_browser *)v5, a2, uint64);
  BOOL v107 = v8;
  if (!uint64)
  {
    BOOL logging_disabled = nw_parameters_get_logging_disabled(*((void *)v5 + 5));
    if (!v8)
    {
      if (!logging_disabled)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        int v25 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          int v26 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v26;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = a2;
          _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s [B%u] Trying to remove %s with invalid changes", buf, 0x1Cu);
        }

        goto LABEL_181;
      }
      goto LABEL_184;
    }
    if (logging_disabled) {
      goto LABEL_184;
    }
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
    }
    id v19 = (id)gbrowserLogObj;
    int v20 = *((_DWORD *)v5 + 48);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v20;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = a2;
    int v21 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v108 = 0;
    if (__nwlog_fault(v21, &type, &v108))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        BOOL v22 = (id)gbrowserLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          int v24 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v24;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = a2;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s [B%u] Trying to remove %s with invalid changes", buf, 0x1Cu);
        }
      }
      else if (v108)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          __int16 v36 = (char *)backtrace_string;
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          os_log_type_t v37 = (id)gbrowserLogObj;
          os_log_type_t v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            int v39 = *((_DWORD *)v5 + 48);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v39;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = a2;
            *(_WORD *)&buf[28] = 2082;
            *(void *)&buf[30] = v36;
            _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s [B%u] Trying to remove %s with invalid changes, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(v36);
          if (!v21) {
            goto LABEL_181;
          }
          goto LABEL_76;
        }
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        BOOL v22 = (id)gbrowserLogObj;
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v22, type))
        {
          int v48 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v48;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = a2;
          _os_log_impl(&dword_1830D4000, v22, v47, "%{public}s [B%u] Trying to remove %s with invalid changes, no backtrace", buf, 0x1Cu);
        }
      }
      else
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        BOOL v22 = (id)gbrowserLogObj;
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v22, type))
        {
          int v46 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v46;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = a2;
          _os_log_impl(&dword_1830D4000, v22, v45, "%{public}s [B%u] Trying to remove %s with invalid changes, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
    }
    if (!v21) {
      goto LABEL_181;
    }
LABEL_76:
    os_log_type_t v49 = (char *)v21;
LABEL_180:
    free(v49);
    goto LABEL_181;
  }
  if (v6 && *((unsigned char *)v5 + 196))
  {
    id v9 = v5;
    id v10 = v6;
    if (a2)
    {
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        uint64_t v11 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v12;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = a2;
          *(_WORD *)&buf[28] = 2112;
          *(void *)&buf[30] = v10;
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] cancel query record for %s on %@", buf, 0x26u);
        }
      }
      uint64_t browser_key_for = nw_create_browser_key_for (a2, v10);
      uint64_t pointer = xpc_dictionary_get_pointer();
      if (pointer)
      {
        xpc_dictionary_set_pointer();
        if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          int v15 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            int v16 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v16;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = browser_key_for;
            _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns_ref_map: set %s to NULL", buf, 0x1Cu);
          }
        }
        if (browser_key_for) {
          free((void *)browser_key_for);
        }
        id v17 = nw_parameters_copy_context(*((void **)v9 + 5));
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = ___ZL50nw_browser_cancel_query_record_for_endpoint_lockedP21NWConcrete_nw_browserPKcPU26objcproto15OS_nw_interface8NSObject_block_invoke;
        *(void *)&unsigned char buf[24] = &unk_1E52491B0;
        uint64_t v111 = pointer;
        *(void *)&buf[32] = v9;
        nw_queue_context_async(v17, buf);

        goto LABEL_92;
      }
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        id v27 = v10;
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        id v28 = (id)gbrowserLogObj;
        int v29 = *((_DWORD *)v9 + 48);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v29;
        os_log_type_t v106 = (const char *)_os_log_send_and_compose_impl();

        id v10 = v27;
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v108 = 0;
        __int16 v30 = (char *)v106;
        if (!__nwlog_fault(v106, &type, &v108)) {
          goto LABEL_88;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          id v31 = v10;
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          os_log_type_t v32 = (id)gbrowserLogObj;
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            int v34 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v34;
            _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s [B%u] Could not find dns_ref for service", buf, 0x12u);
          }
        }
        else if (v108)
        {
          __int16 v40 = __nw_create_backtrace_string();
          if (v40)
          {
            os_log_type_t v41 = (char *)v40;
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
            }
            __int16 v42 = (id)gbrowserLogObj;
            os_log_type_t v43 = type;
            if (os_log_type_enabled(v42, type))
            {
              int v44 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v44;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v41;
              _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s [B%u] Could not find dns_ref for service, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v41);
            goto LABEL_87;
          }
          id v31 = v10;
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          os_log_type_t v32 = (id)gbrowserLogObj;
          os_log_type_t v52 = type;
          if (os_log_type_enabled(v32, type))
          {
            int v53 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v53;
            _os_log_impl(&dword_1830D4000, v32, v52, "%{public}s [B%u] Could not find dns_ref for service, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          id v31 = v10;
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          os_log_type_t v32 = (id)gbrowserLogObj;
          os_log_type_t v50 = type;
          if (os_log_type_enabled(v32, type))
          {
            int v51 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v51;
            _os_log_impl(&dword_1830D4000, v32, v50, "%{public}s [B%u] Could not find dns_ref for service, backtrace limit exceeded", buf, 0x12u);
          }
        }

        id v10 = v31;
LABEL_87:
        __int16 v30 = (char *)v106;
LABEL_88:
        if (v30) {
          free(v30);
        }
      }
    }
    else
    {
      __nwlog_obj();
      v98 = id v97 = v10;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
      uint64_t browser_key_for = _os_log_send_and_compose_impl();

      id v10 = v97;
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v108 = 0;
      if (__nwlog_fault((const char *)browser_key_for, &type, &v108))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v99 = __nwlog_obj();
          os_log_type_t v100 = type;
          if (os_log_type_enabled(v99, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v99, v100, "%{public}s called with null fullname", buf, 0xCu);
          }
        }
        else if (v108)
        {
          os_log_type_t v101 = __nw_create_backtrace_string();
          __int16 v99 = __nwlog_obj();
          os_log_type_t v105 = type;
          BOOL v102 = os_log_type_enabled(v99, type);
          if (v101)
          {
            os_log_type_t v103 = (char *)v101;
            if (v102)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v101;
              _os_log_impl(&dword_1830D4000, v99, v105, "%{public}s called with null fullname, dumping backtrace:%{public}s", buf, 0x16u);
            }

            id v10 = v97;
            free(v103);
            if (!browser_key_for) {
              goto LABEL_92;
            }
            goto LABEL_91;
          }
          if (v102)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v99, v105, "%{public}s called with null fullname, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __int16 v99 = __nwlog_obj();
          os_log_type_t v104 = type;
          if (os_log_type_enabled(v99, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v99, v104, "%{public}s called with null fullname, backtrace limit exceeded", buf, 0xCu);
          }
        }

        id v10 = v97;
      }
    }
    if (!browser_key_for)
    {
LABEL_92:

      int v8 = v107;
      goto LABEL_93;
    }
LABEL_91:
    free((void *)browser_key_for);
    goto LABEL_92;
  }
  if (v6)
  {
LABEL_93:
    if (nw_browse_result_remove_interface(v8, v6)) {
      goto LABEL_94;
    }
    if (!nw_parameters_get_logging_disabled(*((void *)v5 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      id v57 = (id)gbrowserLogObj;
      int v58 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v58;
      uint64_t v59 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v108 = 0;
      if (!__nwlog_fault(v59, &type, &v108))
      {
LABEL_178:
        if (v59)
        {
LABEL_179:
          os_log_type_t v49 = (char *)v59;
          goto LABEL_180;
        }
LABEL_181:
        uint64_t v56 = 0;
LABEL_182:
        int v8 = v107;
        goto LABEL_183;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        os_log_type_t v60 = (id)gbrowserLogObj;
        os_log_type_t v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          int v62 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v62;
          _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s [B%u] tried to remove non-existent interface", buf, 0x12u);
        }
        goto LABEL_177;
      }
      if (!v108)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        os_log_type_t v60 = (id)gbrowserLogObj;
        os_log_type_t v85 = type;
        if (os_log_type_enabled(v60, type))
        {
          int v86 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v86;
          _os_log_impl(&dword_1830D4000, v60, v85, "%{public}s [B%u] tried to remove non-existent interface, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_177;
      }
      BOOL v65 = __nw_create_backtrace_string();
      if (!v65)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        os_log_type_t v60 = (id)gbrowserLogObj;
        os_log_type_t v90 = type;
        if (os_log_type_enabled(v60, type))
        {
          int v91 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v91;
          _os_log_impl(&dword_1830D4000, v60, v90, "%{public}s [B%u] tried to remove non-existent interface, no backtrace", buf, 0x12u);
        }
        goto LABEL_177;
      }
      os_log_type_t v66 = (char *)v65;
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      BOOL v67 = (id)gbrowserLogObj;
      os_log_type_t v68 = type;
      if (os_log_type_enabled(v67, type))
      {
        int v69 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v66;
        _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s [B%u] tried to remove non-existent interface, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      goto LABEL_161;
    }
LABEL_184:
    uint64_t v56 = 0;
    goto LABEL_183;
  }
LABEL_94:
  if (nw_browse_result_get_interfaces_count(v8))
  {
    xpc_dictionary_set_uint64(*((xpc_object_t *)v5 + 20), a2, uint64 | 0x10);
    if (nw_parameters_get_logging_disabled(*((void *)v5 + 5)))
    {
      uint64_t v56 = 1;
      goto LABEL_183;
    }
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
    }
    char v54 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
    {
      int v55 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v55;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2112;
      *(void *)&buf[30] = v6;
      _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s interface_removed(%@)", buf, 0x26u);
    }

    uint64_t v56 = 1;
    goto LABEL_182;
  }
  uint64_t v63 = *((void *)v5 + 18);
  if (v63) {
    uint64_t v64 = (uint64_t)(*(void *)(v63 + 24) - *(void *)(v63 + 16)) >> 3;
  }
  else {
    uint64_t v64 = 0;
  }
  BOOL v70 = nw_array_duplicate_array_without_object(v63, v8);
  os_log_type_t v71 = (void *)*((void *)v5 + 18);
  *((void *)v5 + 18) = v70;

  uint64_t v72 = *((void *)v5 + 18);
  if (v72) {
    uint64_t v73 = (uint64_t)(*(void *)(v72 + 24) - *(void *)(v72 + 16)) >> 3;
  }
  else {
    uint64_t v73 = 0;
  }
  BOOL v74 = nw_parameters_get_logging_disabled(*((void *)v5 + 5));
  if (v64 - 1 != v73)
  {
    if (v74) {
      goto LABEL_181;
    }
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
    }
    id v81 = (id)gbrowserLogObj;
    int v82 = *((_DWORD *)v5 + 48);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v82;
    uint64_t v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v108 = 0;
    if (!__nwlog_fault(v59, &type, &v108)) {
      goto LABEL_178;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      os_log_type_t v60 = (id)gbrowserLogObj;
      os_log_type_t v83 = type;
      if (os_log_type_enabled(v60, type))
      {
        int v84 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v84;
        _os_log_impl(&dword_1830D4000, v60, v83, "%{public}s [B%u] new: failed to remove from new_results", buf, 0x12u);
      }
LABEL_177:

      goto LABEL_178;
    }
    if (!v108)
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      os_log_type_t v60 = (id)gbrowserLogObj;
      os_log_type_t v92 = type;
      if (os_log_type_enabled(v60, type))
      {
        int v93 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v93;
        _os_log_impl(&dword_1830D4000, v60, v92, "%{public}s [B%u] new: failed to remove from new_results, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_177;
    }
    int v87 = __nw_create_backtrace_string();
    if (!v87)
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      os_log_type_t v60 = (id)gbrowserLogObj;
      os_log_type_t v94 = type;
      if (os_log_type_enabled(v60, type))
      {
        int v95 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v95;
        _os_log_impl(&dword_1830D4000, v60, v94, "%{public}s [B%u] new: failed to remove from new_results, no backtrace", buf, 0x12u);
      }
      goto LABEL_177;
    }
    os_log_type_t v66 = (char *)v87;
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
    }
    BOOL v67 = (id)gbrowserLogObj;
    os_log_type_t v88 = type;
    if (os_log_type_enabled(v67, type))
    {
      int v89 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v89;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v66;
      _os_log_impl(&dword_1830D4000, v67, v88, "%{public}s [B%u] new: failed to remove from new_results, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
LABEL_161:

    free(v66);
    if (!v59) {
      goto LABEL_181;
    }
    goto LABEL_179;
  }
  if (!v74)
  {
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
    }
    uint64_t v75 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      int v76 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v76;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v107;
      _os_log_impl(&dword_1830D4000, v75, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: removed %@ from new_results", buf, 0x1Cu);
    }
  }
  xpc_dictionary_set_uint64(*((xpc_object_t *)v5 + 20), a2, uint64 | 4);
  if (!nw_parameters_get_logging_disabled(*((void *)v5 + 5)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
    }
    int v77 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
    {
      int v78 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v78;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2112;
      *(void *)&buf[30] = v6;
      _os_log_impl(&dword_1830D4000, v77, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s result_removed(%@)", buf, 0x26u);
    }
  }
  id v79 = nw_browser_copy_old_result_locked((NWConcrete_nw_browser *)v5, a2);
  BOOL v80 = v79 == 0;

  int v8 = v107;
  if (v80) {
    xpc_dictionary_set_value(*((xpc_object_t *)v5 + 20), a2, 0);
  }
  nw_dictionary_set_value(*((void *)v5 + 21), a2, 0);
  uint64_t v56 = 1;
LABEL_183:

  return v56;
}

void sub_18336F6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_quic_stream_set_is_unidirectional(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_is_unidirectional_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v17 = "nw_quic_stream_set_is_unidirectional";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v17 = "nw_quic_stream_set_is_unidirectional";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          id v17 = "nw_quic_stream_set_is_unidirectional";
          __int16 v18 = 2082;
          id v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        id v17 = "nw_quic_stream_set_is_unidirectional";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v17 = "nw_quic_stream_set_is_unidirectional";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_18336FA08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFErrorRef nw_error_copy_cf_error(nw_error_t error)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = error;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = [v1 description];
    id v4 = (void *)v3;
    unsigned int v5 = LODWORD(v2[1].isa) - 1;
    if (v5 < 3 && (CFIndex isa_high = SHIDWORD(v2[1].isa), isa_high))
    {
      CFStringRef v7 = off_1E523C690[v5];
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (v3)
      {
        *(void *)values = v3;
        CFDictionaryRef v9 = CFDictionaryCreate(v8, MEMORY[0x1E4F1D140], (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      else
      {
        CFDictionaryRef v9 = 0;
      }
      BOOL v10 = CFErrorCreate(v8, v7, isa_high, v9);
    }
    else
    {
      BOOL v10 = 0;
    }

    goto LABEL_10;
  }
  int v12 = __nwlog_obj();
  *(_DWORD *)values = 136446210;
  *(void *)&values[4] = "nw_error_copy_cf_error";
  char v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)values = 136446210;
        *(void *)&values[4] = "nw_error_copy_cf_error";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null error", values, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)values = 136446466;
          *(void *)&values[4] = "nw_error_copy_cf_error";
          __int16 v23 = 2082;
          int v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null error, dumping backtrace:%{public}s", values, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v18)
      {
        *(_DWORD *)values = 136446210;
        *(void *)&values[4] = "nw_error_copy_cf_error";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null error, no backtrace", values, 0xCu);
      }
    }
    else
    {
      char v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)values = 136446210;
        *(void *)&values[4] = "nw_error_copy_cf_error";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null error, backtrace limit exceeded", values, 0xCu);
      }
    }
  }
LABEL_27:
  if (v13) {
    free(v13);
  }
  BOOL v10 = 0;
LABEL_10:

  return v10;
}

void sub_18336FD44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *nwlog_get_string_for_dns_service_error(int a1)
{
  BOOL result = (const char *)DNSServiceErrorCodeToString();
  if (!result)
  {
    switch(a1)
    {
      case -65570:
        BOOL result = "PolicyDenied";
        break;
      case -65569:
        BOOL result = "DefunctConnection";
        break;
      case -65568:
        BOOL result = "Timeout";
        break;
      case -65567:
        BOOL result = "PollingMode";
        break;
      case -65566:
        BOOL result = "NoRouter";
        break;
      case -65565:
        BOOL result = "NATPortMappingDisabled";
        break;
      case -65564:
        BOOL result = "NATPortMappingUnsupported";
        break;
      case -65563:
        BOOL result = "ServiceNotRunning";
        break;
      case -65562:
        BOOL result = "Transient";
        break;
      case -65561:
        BOOL result = "BadKey";
        break;
      case -65560:
        BOOL result = "BadSig";
        break;
      case -65559:
        BOOL result = "BadTime";
        break;
      case -65558:
        BOOL result = "DoubleNAT";
        break;
      case -65557:
        BOOL result = "NATTraversal";
        break;
      case -65556:
        BOOL result = "NoSuchKey";
        break;
      case -65555:
        BOOL result = "NoAuth";
        break;
      case -65554:
        BOOL result = "NoSuchRecord";
        break;
      case -65553:
        BOOL result = "Refused";
        break;
      case -65552:
        BOOL result = "BadInterfaceIndex";
        break;
      case -65551:
        BOOL result = "Incompatible";
        break;
      case -65550:
        BOOL result = "Firewall";
        break;
      case -65549:
        BOOL result = "Invalid";
        break;
      case -65548:
        BOOL result = "NameConflict";
        break;
      case -65547:
        BOOL result = "AlreadyRegistered";
        break;
      case -65546:
      case -65537:
        goto LABEL_7;
      case -65545:
        BOOL result = "NotInitialized";
        break;
      case -65544:
        BOOL result = "Unsupported";
        break;
      case -65543:
        BOOL result = "BadFlags";
        break;
      case -65542:
        BOOL result = "BadState";
        break;
      case -65541:
        BOOL result = "BadReference";
        break;
      case -65540:
        BOOL result = "BadParam";
        break;
      case -65539:
        BOOL result = "NoMemory";
        break;
      case -65538:
        BOOL result = "NoSuchName";
        break;
      default:
        if (a1) {
LABEL_7:
        }
          BOOL result = "Unknown";
        else {
          BOOL result = "NoError";
        }
        break;
    }
  }
  return result;
}

void nw_data_transfer_report_collect_on_nw_queue(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  unsigned int v5 = v4;
  if (v3)
  {
    if (!v4 && gLogDatapath)
    {
      BOOL v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s called without collect_block", buf, 0xCu);
      }
    }
    nw_data_transfer_report_collect_inner(v3, 0, v5, 1);
    goto LABEL_5;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_data_transfer_report_collect_on_nw_queue";
  CFStringRef v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      CFAllocatorRef v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      CFAllocatorRef v8 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_data_transfer_report_collect_on_nw_queue";
          __int16 v19 = 2082;
          char v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      CFAllocatorRef v8 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v8, v14, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v7) {
    free(v7);
  }
LABEL_5:
}

void sub_183370AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_data_transfer_report_collect(nw_data_transfer_report_t report, dispatch_queue_t queue, nw_data_transfer_report_collect_block_t collect_block)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = report;
  id v6 = queue;
  nw_data_transfer_report_collect_block_t v7 = collect_block;
  CFAllocatorRef v8 = v7;
  if (!v5)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v26 = "nw_data_transfer_report_collect";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_data_transfer_report_collect";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          int v26 = "nw_data_transfer_report_collect";
          __int16 v27 = 2082;
          id v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v10) {
          goto LABEL_5;
        }
LABEL_40:
        free(v10);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_data_transfer_report_collect";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_data_transfer_report_collect";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v6 || !v7)
  {
    nw_data_transfer_report_collect_inner(v5, v6, v7, 0);
    goto LABEL_5;
  }
  BOOL v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v26 = "nw_data_transfer_report_collect";
  BOOL v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23)) {
    goto LABEL_39;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      int v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      int v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  BOOL v18 = (char *)__nw_create_backtrace_string();
  os_log_type_t v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      int v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    int v26 = "nw_data_transfer_report_collect";
    __int16 v27 = 2082;
    id v28 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_40;
  }
LABEL_5:
}

void sub_183370FF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_data_transfer_report_collect_inner(void *a1, void *a2, void *a3, int a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  nw_data_transfer_report_collect_block_t v7 = a1;
  CFAllocatorRef v8 = a2;
  id v9 = a3;
  BOOL v10 = (void (**)(void, void))v9;
  if (!v9 || v8 || (a4 & 1) != 0)
  {
    if (!v9 && gLogDatapath)
    {
      os_log_type_t v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s called without collect_block", buf, 0xCu);
      }
    }
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    int v48 = __Block_byref_object_copy__7806;
    os_log_type_t v49 = __Block_byref_object_dispose__7807;
    id v50 = 0;
    uint64_t v43 = 0;
    int v44 = &v43;
    uint64_t v45 = 0x2020000000;
    char v46 = 0;
    uint64_t v39 = 0;
    __int16 v40 = &v39;
    uint64_t v41 = 0x2020000000;
    char v42 = 0;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke;
    aBlock[3] = &unk_1E523DE78;
    os_log_type_t v11 = v7;
    BOOL v35 = v11;
    __int16 v36 = &v39;
    os_log_type_t v37 = &v43;
    os_log_type_t v38 = buf;
    os_log_type_t v12 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v7 + 10);
    v12[2](v12);
    os_unfair_lock_unlock(v7 + 10);

    if (*((unsigned char *)v40 + 24))
    {
      if (!v10)
      {
LABEL_16:

        _Block_object_dispose(&v39, 8);
        _Block_object_dispose(&v43, 8);
        _Block_object_dispose(buf, 8);

        goto LABEL_17;
      }
      if (a4)
      {
        ((void (**)(void, os_unfair_lock_s *))v10)[2](v10, v11);
        goto LABEL_16;
      }
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_237;
      block[3] = &unk_1E524B950;
      char v15 = (id *)&v33;
      os_log_type_t v33 = v10;
      os_log_type_t v16 = (id *)&v32;
      os_log_type_t v32 = v11;
      dispatch_async(v8, block);
    }
    else
    {
      if (!*((unsigned char *)v44 + 24)) {
        goto LABEL_16;
      }
      uint64_t v13 = *(void *)(*(void *)&buf[8] + 40);
      if (!v13) {
        goto LABEL_16;
      }
      os_log_type_t v14 = *(void **)(v13 + 24);
      if (!v14) {
        goto LABEL_16;
      }
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_2;
      v26[3] = &unk_1E523B808;
      __int16 v27 = v11;
      v29[1] = buf;
      v29[0] = v10;
      char v30 = a4;
      id v28 = v8;
      nw_queue_context_async_if_needed(v14, v26);

      char v15 = (id *)&v27;
      os_log_type_t v16 = (id *)v29;
    }

    goto LABEL_16;
  }
  BOOL v17 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
  BOOL v18 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v43) = 16;
  LOBYTE(v39) = 0;
  if (__nwlog_fault(v18, &v43, &v39))
  {
    if (v43 == 17)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = v43;
      if (os_log_type_enabled(v19, (os_log_type_t)v43))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null queue", buf, 0xCu);
      }
    }
    else if ((_BYTE)v39)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v23 = v43;
      BOOL v24 = os_log_type_enabled(v19, (os_log_type_t)v43);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v23, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_37;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_1830D4000, v19, v23, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v25 = v43;
      if (os_log_type_enabled(v19, (os_log_type_t)v43))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_1830D4000, v19, v25, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_37:
  if (v18) {
    free(v18);
  }
LABEL_17:
}

void sub_1833715A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v40 - 192), 8);
  _Block_object_dispose((const void *)(v40 - 160), 8);

  _Unwind_Resume(a1);
}

void ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[4];
  if (*(_DWORD *)(v2 + 52) == 2)
  {
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
    return;
  }
  *(unsigned char *)(v2 + 424) |= 1u;
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  uint64_t v3 = a1[4];
  if (*(void *)(v3 + 24)) {
    goto LABEL_23;
  }
  char v4 = *(unsigned char *)(v3 + 424);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v5 = (id)gLogObj;
  id v6 = v5;
  if ((v4 & 1) == 0)
  {
    os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
    nw_data_transfer_report_collect_block_t v7 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v7))
    {
LABEL_22:
      free(v7);
      goto LABEL_23;
    }
    __break(1u);
  }
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
  nw_data_transfer_report_collect_block_t v7 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault((const char *)v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFAllocatorRef v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
        BOOL v10 = "%{public}s Report's (not in progress) associated connection unexpectedly nil";
LABEL_18:
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v9;
LABEL_19:
        _os_log_impl(&dword_1830D4000, v14, v15, v10, buf, 0xCu);
        goto LABEL_20;
      }
      goto LABEL_20;
    }
    if (!v16)
    {
      CFAllocatorRef v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
        BOOL v10 = "%{public}s Report's (not in progress) associated connection unexpectedly nil, backtrace limit exceeded";
        goto LABEL_18;
      }
LABEL_20:

      goto LABEL_21;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFAllocatorRef v8 = (id)gLogObj;
    os_log_type_t v12 = type;
    BOOL v13 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
      BOOL v10 = "%{public}s Report's (not in progress) associated connection unexpectedly nil, no backtrace";
      os_log_type_t v14 = v8;
      os_log_type_t v15 = v12;
      goto LABEL_19;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
      __int16 v20 = 2082;
      os_log_type_t v21 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s Report's (not in progress) associated connection unexpectedly nil, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
  }
LABEL_21:
  if (v7) {
    goto LABEL_22;
  }
LABEL_23:
  objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), *(id *)(a1[4] + 24));
}

void sub_183371A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_can_use_dns_xpc_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  nw_resolver_can_use_dns_xpc::can_use_dns_xpc = 1;
  if (!MEMORY[0x1E4FBA5C0])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFStringRef v0 = (id)gLogObj;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v3 = "nw_resolver_can_use_dns_xpc_block_invoke";
      _os_log_impl(&dword_1830D4000, v0, OS_LOG_TYPE_ERROR, "%{public}s libdns_services is not available", buf, 0xCu);
    }
  }
  getpid();
  if (sandbox_check())
  {
    nw_resolver_can_use_dns_xpc::can_use_dns_xpc = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v1 = (id)gLogObj;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v3 = "nw_resolver_can_use_dns_xpc_block_invoke";
      _os_log_impl(&dword_1830D4000, v1, OS_LOG_TYPE_ERROR, "%{public}s Sandbox does not allow access to com.apple.dnssd.service", buf, 0xCu);
    }
  }
}

BOOL nw_path_evaluator_add_endpoint_to_necp_message(void *a1, int a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v312 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = a1;
  os_log_type_t v9 = v8;
  if (!a3)
  {
    __int16 v218 = v8;
    os_log_type_t v228 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
    v229 = (char *)_os_log_send_and_compose_impl();

    v295[0] = OS_LOG_TYPE_ERROR;
    v303[0] = 0;
    if (!__nwlog_fault(v229, v295, v303)) {
      goto LABEL_544;
    }
    if (v295[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v231 = v295[0];
      if (os_log_type_enabled(v230, v295[0]))
      {
        *(_DWORD *)buf = 136446210;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_1830D4000, v230, v231, "%{public}s called with null cursor", buf, 0xCu);
      }
      goto LABEL_543;
    }
    if (!v303[0])
    {
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v252 = v295[0];
      if (os_log_type_enabled(v230, v295[0]))
      {
        *(_DWORD *)buf = 136446210;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_1830D4000, v230, v252, "%{public}s called with null cursor, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_543;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v230 = __nwlog_obj();
    os_log_type_t v237 = v295[0];
    BOOL v238 = os_log_type_enabled(v230, v295[0]);
    if (!backtrace_string)
    {
      if (v238)
      {
        *(_DWORD *)buf = 136446210;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_1830D4000, v230, v237, "%{public}s called with null cursor, no backtrace", buf, 0xCu);
      }
      goto LABEL_543;
    }
    if (v238)
    {
      *(_DWORD *)buf = 136446466;
      v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
      __int16 v306 = 2082;
      *(void *)v307 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v230, v237, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_487;
  }
  if (!a4)
  {
    __int16 v218 = v8;
    v232 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
    v229 = (char *)_os_log_send_and_compose_impl();

    v295[0] = OS_LOG_TYPE_ERROR;
    v303[0] = 0;
    if (!__nwlog_fault(v229, v295, v303)) {
      goto LABEL_544;
    }
    if (v295[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v233 = v295[0];
      if (os_log_type_enabled(v230, v295[0]))
      {
        *(_DWORD *)buf = 136446210;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_1830D4000, v230, v233, "%{public}s called with null beyond", buf, 0xCu);
      }
      goto LABEL_543;
    }
    if (!v303[0])
    {
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v253 = v295[0];
      if (os_log_type_enabled(v230, v295[0]))
      {
        *(_DWORD *)buf = 136446210;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_1830D4000, v230, v253, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_543;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v230 = __nwlog_obj();
    os_log_type_t v239 = v295[0];
    BOOL v240 = os_log_type_enabled(v230, v295[0]);
    if (!backtrace_string)
    {
      if (v240)
      {
        *(_DWORD *)buf = 136446210;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_1830D4000, v230, v239, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
      }
      goto LABEL_543;
    }
    if (v240)
    {
      *(_DWORD *)buf = 136446466;
      v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
      __int16 v306 = 2082;
      *(void *)v307 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v230, v239, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_487:

    free(backtrace_string);
    if (!v229) {
      goto LABEL_546;
    }
    goto LABEL_545;
  }
  unint64_t v288 = a4;
  if (a3 >= a4)
  {
    __int16 v218 = v8;
    BOOL v234 = __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
    __int16 v306 = 2048;
    *(void *)v307 = a3;
    *(_WORD *)&v307[8] = 2048;
    *(void *)&v307[10] = a4;
    v229 = (char *)_os_log_send_and_compose_impl();

    v295[0] = OS_LOG_TYPE_ERROR;
    v303[0] = 0;
    if (!__nwlog_fault(v229, v295, v303)) {
      goto LABEL_544;
    }
    if (v295[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v235 = v295[0];
      if (os_log_type_enabled(v230, v295[0]))
      {
        *(_DWORD *)buf = 136446722;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        __int16 v306 = 2048;
        *(void *)v307 = a3;
        *(_WORD *)&v307[8] = 2048;
        *(void *)&v307[10] = v288;
        _os_log_impl(&dword_1830D4000, v230, v235, "%{public}s Invalid cursor %p >= beyond %p", buf, 0x20u);
      }
    }
    else if (v303[0])
    {
      nw_protocol_options_t v241 = (char *)__nw_create_backtrace_string();
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v242 = v295[0];
      BOOL v243 = os_log_type_enabled(v230, v295[0]);
      if (v241)
      {
        if (v243)
        {
          *(_DWORD *)buf = 136446978;
          v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v288;
          *(_WORD *)&v307[18] = 2082;
          *(void *)v308 = v241;
          _os_log_impl(&dword_1830D4000, v230, v242, "%{public}s Invalid cursor %p >= beyond %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v241);
LABEL_544:
        if (!v229)
        {
LABEL_546:
          a3 = 0;
          goto LABEL_433;
        }
LABEL_545:
        free(v229);
        goto LABEL_546;
      }
      if (v243)
      {
        *(_DWORD *)buf = 136446722;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        __int16 v306 = 2048;
        *(void *)v307 = a3;
        *(_WORD *)&v307[8] = 2048;
        *(void *)&v307[10] = v288;
        _os_log_impl(&dword_1830D4000, v230, v242, "%{public}s Invalid cursor %p >= beyond %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      os_log_type_t v230 = __nwlog_obj();
      os_log_type_t v254 = v295[0];
      if (os_log_type_enabled(v230, v295[0]))
      {
        *(_DWORD *)buf = 136446722;
        v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
        __int16 v306 = 2048;
        *(void *)v307 = a3;
        *(_WORD *)&v307[8] = 2048;
        *(void *)&v307[10] = v288;
        _os_log_impl(&dword_1830D4000, v230, v254, "%{public}s Invalid cursor %p >= beyond %p, backtrace limit exceeded", buf, 0x20u);
      }
    }
LABEL_543:

    goto LABEL_544;
  }
  int v283 = a2;
  *(void *)v295 = 0;
  uint64_t v296 = 0;
  int v298 = 0;
  uint64_t v297 = 0;
  os_log_type_t v279 = v8;
  nw_txt_record_t v280 = nw_endpoint_copy_txt_record(v8);
  nw_endpoint_type_t v10 = nw_endpoint_get_type(v9);
  os_log_type_t v11 = v9;
  unsigned int v285 = v11;
  nw_endpoint_type_t v12 = nw_endpoint_get_type(v11);
  nw_txt_record_t v13 = nw_endpoint_copy_txt_record(v11);
  switch(v12)
  {
    case nw_endpoint_type_address:
      address = nw_endpoint_get_address(v11);
      if (address)
      {
        unint64_t sa_len = address->sa_len;
        if (!v13) {
          goto LABEL_50;
        }
      }
      else
      {
        unint64_t sa_len = 0;
        if (!v13) {
          goto LABEL_50;
        }
      }
      unint64_t sa_len = (unint64_t)v13[2].isa + 28;
      goto LABEL_50;
    case nw_endpoint_type_host:
    case nw_endpoint_type_url|nw_endpoint_type_address:
      BOOL domain_for_policy = nw_endpoint_get_domain_for_policy(v11);
      if (domain_for_policy)
      {
        size_t v15 = strlen((const char *)domain_for_policy) + 9;
        if (v13)
        {
LABEL_7:
          unint64_t sa_len = (unint64_t)v13[2].isa + v15;
          goto LABEL_50;
        }
      }
      else
      {
        size_t v15 = 9;
        if (v13) {
          goto LABEL_7;
        }
      }
      unint64_t sa_len = v15;
      goto LABEL_50;
    case nw_endpoint_type_bonjour_service:
      bonjour_service_name = nw_endpoint_get_bonjour_service_name(v11);
      bonjour_service_os_log_type_t type = nw_endpoint_get_bonjour_service_type(v11);
      bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v11);
      if (bonjour_service_name)
      {
        size_t v20 = strlen(bonjour_service_name) + 9;
        if (bonjour_service_type) {
          goto LABEL_10;
        }
      }
      else
      {
        size_t v20 = 9;
        if (bonjour_service_type)
        {
LABEL_10:
          size_t v21 = strlen(bonjour_service_type) + 1;
          if (bonjour_service_domain)
          {
LABEL_11:
            size_t v22 = strlen(bonjour_service_domain) + 1;
            if (v13)
            {
LABEL_12:
              Class isa = v13[2].isa;
              goto LABEL_42;
            }
LABEL_41:
            Class isa = 0;
LABEL_42:
            unint64_t sa_len = (unint64_t)isa + v22 + v21 + v20;
            goto LABEL_50;
          }
LABEL_40:
          size_t v22 = 1;
          if (v13) {
            goto LABEL_12;
          }
          goto LABEL_41;
        }
      }
      size_t v21 = 1;
      if (bonjour_service_domain) {
        goto LABEL_11;
      }
      goto LABEL_40;
    case nw_endpoint_type_url:
      nw_endpoint_t url = nw_endpoint_get_url(v11);
      if (url) {
        unint64_t sa_len = strlen(url) + 9;
      }
      else {
        unint64_t sa_len = 9;
      }
      goto LABEL_50;
    case nw_endpoint_type_url|nw_endpoint_type_host:
      application_service_alias = (const char *)nw_endpoint_get_application_service_alias(v11);
      application_service_name = (const char *)nw_endpoint_get_application_service_name(v11);
      nw_endpoint_get_service_identifier(v11, buf);
      device_name = (const char *)nw_endpoint_get_device_name(v11);
      device_model = (const char *)nw_endpoint_get_device_model(v11);
      contact_id = (const char *)nw_endpoint_get_contact_id(v11);
      if (application_service_alias)
      {
        size_t v30 = strlen(application_service_alias) + 9;
        if (application_service_name) {
          goto LABEL_18;
        }
      }
      else
      {
        size_t v30 = 9;
        if (application_service_name)
        {
LABEL_18:
          size_t v31 = strlen(application_service_name) + 1;
          if (device_name) {
            goto LABEL_19;
          }
          goto LABEL_45;
        }
      }
      size_t v31 = 1;
      if (device_name)
      {
LABEL_19:
        size_t v32 = strlen(device_name) + 1;
        if (device_model) {
          goto LABEL_20;
        }
        goto LABEL_46;
      }
LABEL_45:
      size_t v32 = 1;
      if (device_model)
      {
LABEL_20:
        size_t v33 = strlen(device_model) + 1;
        if (contact_id) {
          goto LABEL_21;
        }
LABEL_47:
        size_t v34 = 1;
        if (v13) {
          goto LABEL_22;
        }
        goto LABEL_48;
      }
LABEL_46:
      size_t v33 = 1;
      if (!contact_id) {
        goto LABEL_47;
      }
LABEL_21:
      size_t v34 = strlen(contact_id) + 1;
      if (v13)
      {
LABEL_22:
        Class v35 = v13[2].isa;
        goto LABEL_49;
      }
LABEL_48:
      Class v35 = 0;
LABEL_49:
      unint64_t sa_len = (unint64_t)v35 + v34 + v30 + v31 + v32 + v33 + 24;
LABEL_50:
      if (sa_len <= 0x1C) {
        size_t v42 = 28;
      }
      else {
        size_t v42 = sa_len;
      }
LABEL_53:

      if (v42 < 0x1D)
      {
        int v281 = 0;
        int v44 = v295;
        size_t v42 = 28;
      }
      else
      {
        uint64_t v43 = malloc_type_calloc(v42, 1uLL, 0xEAFB8F1AuLL);
        if (v43)
        {
          int v281 = v43;
          int v44 = (os_log_type_t *)v43;
        }
        else
        {
          v244 = __nwlog_obj();
          os_log_type_enabled(v244, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          v305 = "strict_calloc";
          __int16 v306 = 2048;
          *(void *)v307 = v42;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = 1;
          LODWORD(v278) = 32;
          int v277 = buf;
          int v245 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v245);
          if (result)
          {
            __break(1u);
            return result;
          }
          free(v245);
          int v281 = 0;
          int v44 = 0;
        }
      }
LABEL_76:
      char v51 = -1;
      if (v42 >= 0xFF) {
        size_t v52 = 255;
      }
      else {
        size_t v52 = v42;
      }
      if (sa_len < 0xFF) {
        char v51 = sa_len;
      }
      switch(v10)
      {
        case nw_endpoint_type_address:
          int v53 = nw_endpoint_get_address(v11);
          if (!v53) {
            goto LABEL_202;
          }
          memcpy(v44, v53, v53->sa_len);
          if (v280)
          {
            size_t v54 = (size_t)v280[2].isa;
            if (v52 >= v54 + 28) {
              memcpy(v44 + 28, v280[1].isa, v54);
            }
          }
          size_t v55 = v52 + 5;
          if (v288 - a3 < v52 + 5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v56 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v305 = "nw_necp_append_tlv";
            __int16 v306 = 2048;
            *(void *)v307 = a3;
            *(_WORD *)&v307[8] = 2048;
            *(void *)&v307[10] = v52 + 5;
            *(_WORD *)&v307[18] = 2048;
            *(void *)v308 = v288;
            *(_WORD *)&v308[8] = 1024;
            *(_DWORD *)v309 = v283;
            *(_WORD *)&v309[4] = 1024;
            *(_DWORD *)&v309[6] = v52;
            LODWORD(v278) = 54;
            int v277 = buf;
            id v57 = (char *)_os_log_send_and_compose_impl();

            v303[0] = 16;
            uu[0] = 0;
            if (!__nwlog_fault(v57, v303, uu)) {
              goto LABEL_195;
            }
            if (v303[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v58 = (id)gLogObj;
              os_log_type_t v59 = v303[0];
              if (os_log_type_enabled(v58, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                _os_log_impl(&dword_1830D4000, v58, v59, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
              goto LABEL_194;
            }
            if (!uu[0])
            {
              int v58 = __nwlog_obj();
              os_log_type_t v157 = v303[0];
              if (os_log_type_enabled(v58, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                _os_log_impl(&dword_1830D4000, v58, v157, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
              goto LABEL_194;
            }
            uint64_t v143 = (char *)__nw_create_backtrace_string();
            int v58 = __nwlog_obj();
            os_log_type_t v144 = v303[0];
            BOOL v145 = os_log_type_enabled(v58, (os_log_type_t)v303[0]);
            if (!v143)
            {
              if (v145)
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                _os_log_impl(&dword_1830D4000, v58, v144, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
              goto LABEL_194;
            }
            if (v145)
            {
              *(_DWORD *)buf = 136447746;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              __int16 v310 = 2082;
              v311 = v143;
              _os_log_impl(&dword_1830D4000, v58, v144, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

            free(v143);
            if (v57) {
              goto LABEL_196;
            }
            goto LABEL_197;
          }
          *(unsigned char *)a3 = v283;
          *(_DWORD *)(a3 + 1) = v52;
          if (v44) {
            goto LABEL_201;
          }
          os_log_type_t v100 = __nwlog_obj();
          *(_DWORD *)buf = 136446722;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 1024;
          *(_DWORD *)v307 = v283;
          *(_WORD *)&v307[4] = 1024;
          *(_DWORD *)&v307[6] = v52;
          LODWORD(v278) = 24;
          int v277 = buf;
          id v57 = (char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (!__nwlog_fault(v57, v303, uu)) {
            goto LABEL_195;
          }
          if (v303[0] == 17)
          {
            int v58 = __nwlog_obj();
            os_log_type_t v101 = v303[0];
            if (os_log_type_enabled(v58, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136446722;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 1024;
              *(_DWORD *)v307 = v283;
              *(_WORD *)&v307[4] = 1024;
              *(_DWORD *)&v307[6] = v52;
              _os_log_impl(&dword_1830D4000, v58, v101, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
            }
            goto LABEL_194;
          }
          if (uu[0])
          {
            os_log_type_t v130 = (char *)__nw_create_backtrace_string();
            int v58 = __nwlog_obj();
            os_log_type_t v274 = v303[0];
            BOOL v275 = os_log_type_enabled(v58, (os_log_type_t)v303[0]);
            if (v130)
            {
              if (v275)
              {
                *(_DWORD *)buf = 136446978;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 1024;
                *(_DWORD *)v307 = v283;
                *(_WORD *)&v307[4] = 1024;
                *(_DWORD *)&v307[6] = v52;
                *(_WORD *)&v307[10] = 2082;
                *(void *)&v307[12] = v130;
                _os_log_impl(&dword_1830D4000, v58, v274, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
              }
              goto LABEL_237;
            }
            if (v275)
            {
              *(_DWORD *)buf = 136446722;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 1024;
              *(_DWORD *)v307 = v283;
              *(_WORD *)&v307[4] = 1024;
              *(_DWORD *)&v307[6] = v52;
              _os_log_impl(&dword_1830D4000, v58, v274, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
            }
          }
          else
          {
            int v58 = __nwlog_obj();
            os_log_type_t v276 = v303[0];
            if (os_log_type_enabled(v58, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136446722;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 1024;
              *(_DWORD *)v307 = v283;
              *(_WORD *)&v307[4] = 1024;
              *(_DWORD *)&v307[6] = v52;
              _os_log_impl(&dword_1830D4000, v58, v276, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
            }
          }
          goto LABEL_194;
        case nw_endpoint_type_host:
          *((unsigned char *)v44 + 1) = 0;
          os_log_type_t *v44 = v51;
          *((_WORD *)v44 + 1) = __rev16(nw_endpoint_get_port(v11));
          *((_DWORD *)v44 + 1) = 2;
          BOOL v77 = nw_endpoint_get_domain_for_policy(v11);
          int v78 = (const void *)v77;
          if (v77)
          {
            size_t v79 = strlen((const char *)v77) + 1;
            memcpy(v44 + 8, v78, v79);
            nw_txt_record_t v80 = v280;
            if (v280)
            {
LABEL_110:
              memcpy(&v44[v79 + 8], v80[1].isa, (size_t)v80[2].isa);
              goto LABEL_133;
            }
          }
          else
          {
            size_t v79 = 1;
            nw_txt_record_t v80 = v280;
            if (v280) {
              goto LABEL_110;
            }
          }
          v44[v52 - 1] = OS_LOG_TYPE_DEFAULT;
LABEL_133:
          size_t v55 = v52 + 5;
          if (v288 - a3 >= v52 + 5) {
            goto LABEL_200;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v94 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v52 + 5;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = v283;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v52;
          LODWORD(v278) = 54;
          int v277 = buf;
          id v57 = (char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (!__nwlog_fault(v57, v303, uu)) {
            goto LABEL_195;
          }
          if (v303[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v75 = (id)gLogObj;
            os_log_type_t v95 = v303[0];
            if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v75, v95, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
            }
            goto LABEL_291;
          }
          if (uu[0])
          {
            os_log_type_t v130 = (char *)__nw_create_backtrace_string();
            uint64_t v75 = __nwlog_obj();
            os_log_type_t v135 = v303[0];
            BOOL v136 = os_log_type_enabled(v75, (os_log_type_t)v303[0]);
            if (v130)
            {
              if (v136)
              {
                *(_DWORD *)buf = 136447746;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                __int16 v310 = 2082;
                v311 = v130;
                _os_log_impl(&dword_1830D4000, v75, v135, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
              }
              goto LABEL_232;
            }
            if (v136)
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v75, v135, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
            }
          }
          else
          {
            uint64_t v75 = __nwlog_obj();
            os_log_type_t v151 = v303[0];
            if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v75, v151, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
            }
          }
          goto LABEL_291;
        case nw_endpoint_type_bonjour_service:
          *((unsigned char *)v44 + 1) = 0;
          os_log_type_t *v44 = v51;
          *((_WORD *)v44 + 1) = 0;
          *((_DWORD *)v44 + 1) = 3;
          uint64_t v64 = nw_endpoint_get_bonjour_service_name(v11);
          BOOL v65 = nw_endpoint_get_bonjour_service_type(v11);
          os_log_type_t v66 = nw_endpoint_get_bonjour_service_domain(v11);
          if (v64)
          {
            size_t v67 = strlen(v64) + 1;
            if (v65) {
              goto LABEL_97;
            }
          }
          else
          {
            size_t v67 = 1;
            if (v65)
            {
LABEL_97:
              size_t v68 = strlen(v65) + 1;
              size_t v69 = v52;
              if (v66) {
                goto LABEL_98;
              }
              goto LABEL_141;
            }
          }
          size_t v68 = 1;
          size_t v69 = v52;
          if (v66)
          {
LABEL_98:
            size_t v70 = strlen(v66) + 1;
            if (!v64) {
              goto LABEL_144;
            }
            goto LABEL_142;
          }
LABEL_141:
          size_t v70 = 1;
          if (!v64) {
            goto LABEL_144;
          }
LABEL_142:
          if (v67) {
            memcpy(v44 + 8, v64, v67);
          }
LABEL_144:
          if (v65 && v68) {
            memcpy(&v44[v67 + 8], v65, v68);
          }
          if (v66 && v70) {
            memcpy(&v44[v67 + 8 + v68], v66, v70);
          }
          if (v280)
          {
            memcpy(&v44[v67 + 8 + v68 + v70], v280[1].isa, (size_t)v280[2].isa);
            size_t v96 = v69;
          }
          else
          {
            size_t v96 = v69;
            v44[v69 - 1] = OS_LOG_TYPE_DEFAULT;
          }
          size_t v97 = v96 + 5;
          if (v288 - a3 >= v96 + 5)
          {
            *(unsigned char *)a3 = v283;
            *(_DWORD *)(a3 + 1) = v96;
            memcpy((void *)(a3 + 5), v44, v96);
            a3 += v97;
            goto LABEL_198;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v98 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v96 + 5;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = v283;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v96;
          LODWORD(v278) = 54;
          int v277 = buf;
          id v57 = (char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (!__nwlog_fault(v57, v303, uu)) {
            goto LABEL_195;
          }
          if (v303[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v75 = (id)gLogObj;
            os_log_type_t v99 = v303[0];
            if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v96 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v69;
              _os_log_impl(&dword_1830D4000, v75, v99, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
            }
            goto LABEL_291;
          }
          if (uu[0])
          {
            os_log_type_t v130 = (char *)__nw_create_backtrace_string();
            uint64_t v75 = __nwlog_obj();
            os_log_type_t v137 = v303[0];
            BOOL v138 = os_log_type_enabled(v75, (os_log_type_t)v303[0]);
            if (v130)
            {
              if (v138)
              {
                *(_DWORD *)buf = 136447746;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v97;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v69;
                __int16 v310 = 2082;
                v311 = v130;
                _os_log_impl(&dword_1830D4000, v75, v137, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
              }
              goto LABEL_232;
            }
            if (v138)
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v97;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v69;
              _os_log_impl(&dword_1830D4000, v75, v137, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
            }
          }
          else
          {
            uint64_t v75 = __nwlog_obj();
            os_log_type_t v152 = v303[0];
            if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v96 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v69;
              _os_log_impl(&dword_1830D4000, v75, v152, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
            }
          }
          goto LABEL_291;
        case nw_endpoint_type_url:
          *((unsigned char *)v44 + 1) = 0;
          os_log_type_t *v44 = v51;
          *((_WORD *)v44 + 1) = __rev16(nw_endpoint_get_port(v11));
          *((_DWORD *)v44 + 1) = 4;
          os_log_type_t v71 = nw_endpoint_get_url(v11);
          uint64_t v72 = v71;
          if (v71)
          {
            size_t v73 = strlen(v71);
            memcpy(v44 + 8, v72, v73 + 1);
          }
          v44[v52 - 1] = OS_LOG_TYPE_DEFAULT;
          size_t v55 = v52 + 5;
          if (v288 - a3 >= v52 + 5) {
            goto LABEL_200;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v74 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v52 + 5;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = v283;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v52;
          LODWORD(v278) = 54;
          int v277 = buf;
          id v57 = (char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (!__nwlog_fault(v57, v303, uu)) {
            goto LABEL_195;
          }
          if (v303[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v75 = (id)gLogObj;
            os_log_type_t v76 = v303[0];
            if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
            }
            goto LABEL_291;
          }
          if (uu[0])
          {
            os_log_type_t v130 = (char *)__nw_create_backtrace_string();
            uint64_t v75 = __nwlog_obj();
            os_log_type_t v133 = v303[0];
            BOOL v134 = os_log_type_enabled(v75, (os_log_type_t)v303[0]);
            if (v130)
            {
              if (v134)
              {
                *(_DWORD *)buf = 136447746;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                __int16 v310 = 2082;
                v311 = v130;
                _os_log_impl(&dword_1830D4000, v75, v133, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
              }
              goto LABEL_232;
            }
            if (v134)
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v75, v133, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
            }
          }
          else
          {
            uint64_t v75 = __nwlog_obj();
            os_log_type_t v150 = v303[0];
            if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v75, v150, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
            }
          }
          goto LABEL_291;
        case nw_endpoint_type_url|nw_endpoint_type_address:
          *((unsigned char *)v44 + 1) = 0;
          os_log_type_t *v44 = v51;
          *((_WORD *)v44 + 1) = 0;
          *((_DWORD *)v44 + 1) = 5;
          BOOL v60 = nw_endpoint_get_domain_for_policy(v11);
          os_log_type_t v61 = (const void *)v60;
          if (v60)
          {
            size_t v62 = strlen((const char *)v60) + 1;
            memcpy(v44 + 8, v61, v62);
            nw_txt_record_t v63 = v280;
            if (v280)
            {
LABEL_94:
              memcpy(&v44[v62 + 8], v63[1].isa, (size_t)v63[2].isa);
              goto LABEL_124;
            }
          }
          else
          {
            size_t v62 = 1;
            nw_txt_record_t v63 = v280;
            if (v280) {
              goto LABEL_94;
            }
          }
          v44[v52 - 1] = OS_LOG_TYPE_DEFAULT;
LABEL_124:
          size_t v55 = v52 + 5;
          if (v288 - a3 >= v52 + 5)
          {
LABEL_200:
            *(unsigned char *)a3 = v283;
            *(_DWORD *)(a3 + 1) = v52;
LABEL_201:
            memcpy((void *)(a3 + 5), v44, v52);
            a3 += v55;
LABEL_202:
            if ((a5 & 1) == 0) {
              goto LABEL_311;
            }
            goto LABEL_203;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v92 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v52 + 5;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = v283;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v52;
          LODWORD(v278) = 54;
          int v277 = buf;
          id v57 = (char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (__nwlog_fault(v57, v303, uu))
          {
            if (v303[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v75 = (id)gLogObj;
              os_log_type_t v93 = v303[0];
              if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                _os_log_impl(&dword_1830D4000, v75, v93, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
            }
            else if (uu[0])
            {
              os_log_type_t v130 = (char *)__nw_create_backtrace_string();
              uint64_t v75 = __nwlog_obj();
              os_log_type_t v131 = v303[0];
              BOOL v132 = os_log_type_enabled(v75, (os_log_type_t)v303[0]);
              if (v130)
              {
                if (v132)
                {
                  *(_DWORD *)buf = 136447746;
                  v305 = "nw_necp_append_tlv";
                  __int16 v306 = 2048;
                  *(void *)v307 = a3;
                  *(_WORD *)&v307[8] = 2048;
                  *(void *)&v307[10] = v52 + 5;
                  *(_WORD *)&v307[18] = 2048;
                  *(void *)v308 = v288;
                  *(_WORD *)&v308[8] = 1024;
                  *(_DWORD *)v309 = v283;
                  *(_WORD *)&v309[4] = 1024;
                  *(_DWORD *)&v309[6] = v52;
                  __int16 v310 = 2082;
                  v311 = v130;
                  _os_log_impl(&dword_1830D4000, v75, v131, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }
LABEL_232:

                goto LABEL_238;
              }
              if (v132)
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                _os_log_impl(&dword_1830D4000, v75, v131, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
            }
            else
            {
              uint64_t v75 = __nwlog_obj();
              os_log_type_t v149 = v303[0];
              if (os_log_type_enabled(v75, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v52 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = v283;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v52;
                _os_log_impl(&dword_1830D4000, v75, v149, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }
LABEL_291:
          }
LABEL_195:
          if (!v57) {
            goto LABEL_197;
          }
          goto LABEL_196;
        case nw_endpoint_type_url|nw_endpoint_type_host:
          *((unsigned char *)v44 + 1) = 0;
          os_log_type_t *v44 = v51;
          *((_WORD *)v44 + 1) = 0;
          *((_DWORD *)v44 + 1) = 6;
          id v81 = (const char *)nw_endpoint_get_application_service_alias(v11);
          int v82 = v81;
          if (v81)
          {
            size_t v83 = strlen(v81);
            size_t v84 = v83 + 1;
            if (v83 == -1) {
              size_t v84 = 0;
            }
            else {
              memcpy(v44 + 8, v82, v84);
            }
          }
          else
          {
            size_t v84 = 1;
          }
          BOOL v102 = (const char *)nw_endpoint_get_application_service_name(v11);
          os_log_type_t v103 = v102;
          if (v102)
          {
            size_t v104 = strlen(v102);
            size_t v105 = v104 + 1;
            if (v104 == -1) {
              size_t v105 = 0;
            }
            else {
              memcpy(&v44[v84 + 8], v103, v105);
            }
          }
          else
          {
            size_t v105 = 1;
          }
          os_log_type_t v106 = (const char *)nw_endpoint_get_device_name(v11);
          BOOL v107 = v106;
          size_t v108 = v105 + v84;
          if (v106)
          {
            size_t v109 = strlen(v106);
            size_t v110 = v109 + 1;
            if (v109 == -1) {
              size_t v110 = 0;
            }
            else {
              memcpy(&v44[v108 + 8], v107, v110);
            }
          }
          else
          {
            size_t v110 = 1;
          }
          uint64_t v111 = (const char *)nw_endpoint_get_device_model(v11);
          uint64_t v112 = v111;
          size_t v113 = v110 + v108;
          if (v111)
          {
            size_t v114 = strlen(v111);
            size_t v115 = v114 + 1;
            if (v114 == -1) {
              size_t v115 = 0;
            }
            else {
              memcpy(&v44[v113 + 8], v112, v115);
            }
          }
          else
          {
            size_t v115 = 1;
          }
          id v116 = (const char *)nw_endpoint_get_contact_id(v11);
          os_log_type_t v117 = v116;
          size_t v118 = v115 + v113;
          if (v116)
          {
            size_t v119 = strlen(v116);
            size_t v120 = v119 + 1;
            if (v119 == -1) {
              size_t v120 = 0;
            }
            else {
              memcpy(&v44[v118 + 8], v117, v120);
            }
          }
          else
          {
            size_t v120 = 1;
          }
          size_t v121 = v120 + v118;
          __int16 v122 = v44 + 8;
          *(_DWORD *)&v44[v121 + 8] = nw_endpoint_get_device_color(v11);
          *(_DWORD *)&v122[v121 + 4] = nw_endpoint_get_advertised_route(v11);
          memset(v303, 0, sizeof(v303));
          nw_endpoint_get_service_identifier(v11, v303);
          *(_OWORD *)&v122[v121 + 8] = *(_OWORD *)v303;
          if (v280) {
            memcpy(&v122[v121 + 24], v280[1].isa, (size_t)v280[2].isa);
          }
          size_t v55 = v52 + 5;
          if (v288 - a3 >= v52 + 5) {
            goto LABEL_200;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v123 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v52 + 5;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = v283;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v52;
          LODWORD(v278) = 54;
          int v277 = buf;
          id v57 = (char *)_os_log_send_and_compose_impl();

          uu[0] = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v57, uu, &type)) {
            goto LABEL_195;
          }
          if (uu[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v58 = (id)gLogObj;
            os_log_type_t v124 = uu[0];
            if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v58, v124, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
            }
LABEL_194:

            goto LABEL_195;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            int v58 = __nwlog_obj();
            os_log_type_t v153 = uu[0];
            if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v58, v153, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
            }
            goto LABEL_194;
          }
          os_log_type_t v130 = (char *)__nw_create_backtrace_string();
          int v58 = __nwlog_obj();
          os_log_type_t v139 = uu[0];
          BOOL v140 = os_log_type_enabled(v58, (os_log_type_t)uu[0]);
          if (!v130)
          {
            if (v140)
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v58, v139, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
            }
            goto LABEL_194;
          }
          if (v140)
          {
            *(_DWORD *)buf = 136447746;
            v305 = "nw_necp_append_tlv";
            __int16 v306 = 2048;
            *(void *)v307 = a3;
            *(_WORD *)&v307[8] = 2048;
            *(void *)&v307[10] = v52 + 5;
            *(_WORD *)&v307[18] = 2048;
            *(void *)v308 = v288;
            *(_WORD *)&v308[8] = 1024;
            *(_DWORD *)v309 = v283;
            *(_WORD *)&v309[4] = 1024;
            *(_DWORD *)&v309[6] = v52;
            __int16 v310 = 2082;
            v311 = v130;
            _os_log_impl(&dword_1830D4000, v58, v139, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
          }
LABEL_237:

LABEL_238:
          free(v130);
          if (v57) {
LABEL_196:
          }
            free(v57);
LABEL_197:
          a3 = 0;
          goto LABEL_198;
        default:
          if (!nw_endpoint_is_custom_type(v11)) {
            goto LABEL_202;
          }
          os_log_type_t v85 = nw_endpoint_copy_custom_data(v11);
          int v86 = v85;
          if (!v85)
          {
            *(_DWORD *)int v44 = 8;
            *((_DWORD *)v44 + 1) = v10;
            goto LABEL_441;
          }
          size_t size = dispatch_data_get_size(v85);
          if (size > 0x400)
          {
            size_t v282 = v52;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v88 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
            __int16 v306 = 1024;
            *(_DWORD *)v307 = 1024;
            LODWORD(v278) = 18;
            int v277 = buf;
            int v89 = (char *)_os_log_send_and_compose_impl();

            v303[0] = 16;
            uu[0] = 0;
            if (__nwlog_fault(v89, v303, uu))
            {
              if (v303[0] == 17)
              {
                os_log_type_t v90 = __nwlog_obj();
                os_log_type_t v91 = v303[0];
                if (os_log_type_enabled(v90, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
                  __int16 v306 = 1024;
                  *(_DWORD *)v307 = 1024;
                  _os_log_impl(&dword_1830D4000, v90, v91, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
                }
              }
              else if (uu[0])
              {
                os_log_type_t v154 = (char *)__nw_create_backtrace_string();
                os_log_type_t v90 = __nwlog_obj();
                os_log_type_t v155 = v303[0];
                BOOL v156 = os_log_type_enabled(v90, (os_log_type_t)v303[0]);
                if (v154)
                {
                  if (v156)
                  {
                    *(_DWORD *)buf = 136446722;
                    v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
                    __int16 v306 = 1024;
                    *(_DWORD *)v307 = 1024;
                    *(_WORD *)&v307[4] = 2082;
                    *(void *)&v307[6] = v154;
                    _os_log_impl(&dword_1830D4000, v90, v155, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }

                  free(v154);
                  goto LABEL_437;
                }
                if (v156)
                {
                  *(_DWORD *)buf = 136446466;
                  v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
                  __int16 v306 = 1024;
                  *(_DWORD *)v307 = 1024;
                  _os_log_impl(&dword_1830D4000, v90, v155, "%{public}s Custom data size must be no larger than %d, no backtrace", buf, 0x12u);
                }
              }
              else
              {
                os_log_type_t v90 = __nwlog_obj();
                os_log_type_t v159 = v303[0];
                if (os_log_type_enabled(v90, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  v305 = "nw_path_evaluator_add_endpoint_to_necp_message";
                  __int16 v306 = 1024;
                  *(_DWORD *)v307 = 1024;
                  _os_log_impl(&dword_1830D4000, v90, v159, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", buf, 0x12u);
                }
              }
            }
LABEL_437:
            size_t v52 = v282;
            if (v89) {
              free(v89);
            }
            char v142 = 8;
            goto LABEL_440;
          }
          char v141 = -9;
          if (size < 0xF7) {
            char v141 = size;
          }
          char v142 = v141 + 8;
LABEL_440:
          *((unsigned char *)v44 + 1) = 0;
          os_log_type_t *v44 = v142;
          *((_WORD *)v44 + 1) = 0;
          *((_DWORD *)v44 + 1) = v10;
          applier[0] = MEMORY[0x1E4F143A8];
          applier[1] = 3221225472;
          applier[2] = __nw_path_evaluator_add_endpoint_to_necp_message_block_invoke;
          applier[3] = &__block_descriptor_41_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
          char v294 = v142;
          void applier[4] = v44;
          dispatch_data_apply(v86, applier);
LABEL_441:
          if (v288 - a3 >= v52 + 5)
          {
            *(unsigned char *)a3 = v283;
            *(_DWORD *)(a3 + 1) = v52;
            memcpy((void *)(a3 + 5), v44, v52);
            a3 += v52 + 5;
            goto LABEL_462;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v220 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v52 + 5;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = v283;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v52;
          LODWORD(v278) = 54;
          int v277 = buf;
          v221 = (char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (!__nwlog_fault(v221, v303, uu)) {
            goto LABEL_459;
          }
          if (v303[0] == 17)
          {
            os_log_type_t v222 = __nwlog_obj();
            os_log_type_t v223 = v303[0];
            if (os_log_type_enabled(v222, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v222, v223, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
            }
LABEL_458:

            goto LABEL_459;
          }
          if (!uu[0])
          {
            os_log_type_t v222 = __nwlog_obj();
            os_log_type_t v227 = v303[0];
            if (os_log_type_enabled(v222, (os_log_type_t)v303[0]))
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v222, v227, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
            }
            goto LABEL_458;
          }
          int v224 = (char *)__nw_create_backtrace_string();
          os_log_type_t v222 = __nwlog_obj();
          os_log_type_t v225 = v303[0];
          BOOL v226 = os_log_type_enabled(v222, (os_log_type_t)v303[0]);
          if (!v224)
          {
            if (v226)
            {
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v52 + 5;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = v283;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = v52;
              _os_log_impl(&dword_1830D4000, v222, v225, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
            }
            goto LABEL_458;
          }
          if (v226)
          {
            *(_DWORD *)buf = 136447746;
            v305 = "nw_necp_append_tlv";
            __int16 v306 = 2048;
            *(void *)v307 = a3;
            *(_WORD *)&v307[8] = 2048;
            *(void *)&v307[10] = v52 + 5;
            *(_WORD *)&v307[18] = 2048;
            *(void *)v308 = v288;
            *(_WORD *)&v308[8] = 1024;
            *(_DWORD *)v309 = v283;
            *(_WORD *)&v309[4] = 1024;
            *(_DWORD *)&v309[6] = v52;
            __int16 v310 = 2082;
            v311 = v224;
            _os_log_impl(&dword_1830D4000, v222, v225, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
          }

          free(v224);
LABEL_459:
          if (v221) {
            free(v221);
          }
          a3 = 0;
LABEL_462:

LABEL_198:
          os_log_type_t v11 = v285;
          if ((a5 & 1) == 0) {
            goto LABEL_311;
          }
LABEL_203:
          memset(uu, 0, sizeof(uu));
          uuid_clear(uu);
          nw_endpoint_get_agent_identifier(v11, uu);
          if (uuid_is_null(uu)) {
            goto LABEL_311;
          }
          os_log_type_t v125 = v11;
          if (a3)
          {
            if (a3 >= v288)
            {
              v257 = __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = v288;
              LODWORD(v278) = 32;
              int v277 = buf;
              nw_endpoint_t v127 = (char *)_os_log_send_and_compose_impl();

              v303[0] = 16;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v127, v303, &type))
              {
                if (v303[0] == 17)
                {
                  os_log_type_t v128 = __nwlog_obj();
                  os_log_type_t v258 = v303[0];
                  if (os_log_type_enabled(v128, (os_log_type_t)v303[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = v288;
                    _os_log_impl(&dword_1830D4000, v128, v258, "%{public}s Invalid cursor %p >= beyond %p", buf, 0x20u);
                  }
                  goto LABEL_306;
                }
                if (type == OS_LOG_TYPE_DEFAULT)
                {
                  os_log_type_t v128 = __nwlog_obj();
                  os_log_type_t v273 = v303[0];
                  if (os_log_type_enabled(v128, (os_log_type_t)v303[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = v288;
                    _os_log_impl(&dword_1830D4000, v128, v273, "%{public}s Invalid cursor %p >= beyond %p, backtrace limit exceeded", buf, 0x20u);
                  }
                  goto LABEL_306;
                }
                os_log_type_t v267 = (char *)__nw_create_backtrace_string();
                os_log_type_t v128 = __nwlog_obj();
                os_log_type_t v268 = v303[0];
                BOOL v269 = os_log_type_enabled(v128, (os_log_type_t)v303[0]);
                if (!v267)
                {
                  if (v269)
                  {
                    *(_DWORD *)buf = 136446722;
                    v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = v288;
                    _os_log_impl(&dword_1830D4000, v128, v268, "%{public}s Invalid cursor %p >= beyond %p, no backtrace", buf, 0x20u);
                  }
                  goto LABEL_306;
                }
                if (v269)
                {
                  *(_DWORD *)buf = 136446978;
                  v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                  __int16 v306 = 2048;
                  *(void *)v307 = a3;
                  *(_WORD *)&v307[8] = 2048;
                  *(void *)&v307[10] = v288;
                  *(_WORD *)&v307[18] = 2082;
                  *(void *)v308 = v267;
                  _os_log_impl(&dword_1830D4000, v128, v268, "%{public}s Invalid cursor %p >= beyond %p, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                free(v267);
              }
            }
            else
            {
              memset(v303, 0, sizeof(v303));
              uuid_clear(v303);
              nw_endpoint_get_agent_identifier(v125, v303);
              if (uuid_is_null(v303)) {
                goto LABEL_310;
              }
              if (v288 - a3 > 0x14)
              {
                *(unsigned char *)a3 = -100;
                *(_DWORD *)(a3 + 1) = 16;
                *(_OWORD *)(a3 + 5) = *(_OWORD *)v303;
                a3 += 21;
                goto LABEL_310;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v126 = (id)gLogObj;
              *(_DWORD *)buf = 136447490;
              v305 = "nw_necp_append_tlv";
              __int16 v306 = 2048;
              *(void *)v307 = a3;
              *(_WORD *)&v307[8] = 2048;
              *(void *)&v307[10] = 21;
              *(_WORD *)&v307[18] = 2048;
              *(void *)v308 = v288;
              *(_WORD *)&v308[8] = 1024;
              *(_DWORD *)v309 = 156;
              *(_WORD *)&v309[4] = 1024;
              *(_DWORD *)&v309[6] = 16;
              LODWORD(v278) = 54;
              int v277 = buf;
              nw_endpoint_t v127 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v299 = 0;
              if (__nwlog_fault(v127, &type, &v299))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  os_log_type_t v128 = __nwlog_obj();
                  os_log_type_t v129 = type;
                  if (os_log_type_enabled(v128, type))
                  {
                    *(_DWORD *)buf = 136447490;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = 21;
                    *(_WORD *)&v307[18] = 2048;
                    *(void *)v308 = v288;
                    *(_WORD *)&v308[8] = 1024;
                    *(_DWORD *)v309 = 156;
                    *(_WORD *)&v309[4] = 1024;
                    *(_DWORD *)&v309[6] = 16;
                    _os_log_impl(&dword_1830D4000, v128, v129, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                  }
LABEL_306:

                  goto LABEL_307;
                }
                if (!v299)
                {
                  os_log_type_t v128 = __nwlog_obj();
                  os_log_type_t v158 = type;
                  if (os_log_type_enabled(v128, type))
                  {
                    *(_DWORD *)buf = 136447490;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = 21;
                    *(_WORD *)&v307[18] = 2048;
                    *(void *)v308 = v288;
                    *(_WORD *)&v308[8] = 1024;
                    *(_DWORD *)v309 = 156;
                    *(_WORD *)&v309[4] = 1024;
                    *(_DWORD *)&v309[6] = 16;
                    _os_log_impl(&dword_1830D4000, v128, v158, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                  }
                  goto LABEL_306;
                }
                __int16 v146 = (char *)__nw_create_backtrace_string();
                os_log_type_t v128 = __nwlog_obj();
                os_log_type_t v147 = type;
                BOOL v148 = os_log_type_enabled(v128, type);
                if (!v146)
                {
                  if (v148)
                  {
                    *(_DWORD *)buf = 136447490;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = 21;
                    *(_WORD *)&v307[18] = 2048;
                    *(void *)v308 = v288;
                    *(_WORD *)&v308[8] = 1024;
                    *(_DWORD *)v309 = 156;
                    *(_WORD *)&v309[4] = 1024;
                    *(_DWORD *)&v309[6] = 16;
                    _os_log_impl(&dword_1830D4000, v128, v147, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                  }
                  goto LABEL_306;
                }
                if (v148)
                {
                  *(_DWORD *)buf = 136447746;
                  v305 = "nw_necp_append_tlv";
                  __int16 v306 = 2048;
                  *(void *)v307 = a3;
                  *(_WORD *)&v307[8] = 2048;
                  *(void *)&v307[10] = 21;
                  *(_WORD *)&v307[18] = 2048;
                  *(void *)v308 = v288;
                  *(_WORD *)&v308[8] = 1024;
                  *(_DWORD *)v309 = 156;
                  *(_WORD *)&v309[4] = 1024;
                  *(_DWORD *)&v309[6] = 16;
                  __int16 v310 = 2082;
                  v311 = v146;
                  _os_log_impl(&dword_1830D4000, v128, v147, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }
LABEL_255:

                free(v146);
                if (!v127) {
                  goto LABEL_309;
                }
                goto LABEL_308;
              }
            }
          }
          else
          {
            os_log_type_t v255 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
            LODWORD(v278) = 12;
            int v277 = buf;
            nw_endpoint_t v127 = (char *)_os_log_send_and_compose_impl();

            v303[0] = 16;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v127, v303, &type))
            {
              if (v303[0] == 17)
              {
                os_log_type_t v128 = __nwlog_obj();
                os_log_type_t v256 = v303[0];
                if (os_log_type_enabled(v128, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                  _os_log_impl(&dword_1830D4000, v128, v256, "%{public}s called with null cursor", buf, 0xCu);
                }
                goto LABEL_306;
              }
              if (type == OS_LOG_TYPE_DEFAULT)
              {
                os_log_type_t v128 = __nwlog_obj();
                os_log_type_t v272 = v303[0];
                if (os_log_type_enabled(v128, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                  _os_log_impl(&dword_1830D4000, v128, v272, "%{public}s called with null cursor, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_306;
              }
              __int16 v146 = (char *)__nw_create_backtrace_string();
              os_log_type_t v128 = __nwlog_obj();
              os_log_type_t v265 = v303[0];
              BOOL v266 = os_log_type_enabled(v128, (os_log_type_t)v303[0]);
              if (!v146)
              {
                if (v266)
                {
                  *(_DWORD *)buf = 136446210;
                  v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                  _os_log_impl(&dword_1830D4000, v128, v265, "%{public}s called with null cursor, no backtrace", buf, 0xCu);
                }
                goto LABEL_306;
              }
              if (v266)
              {
                *(_DWORD *)buf = 136446466;
                v305 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                __int16 v306 = 2082;
                *(void *)v307 = v146;
                _os_log_impl(&dword_1830D4000, v128, v265, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
              }
              goto LABEL_255;
            }
          }
LABEL_307:
          if (!v127) {
            goto LABEL_309;
          }
LABEL_308:
          free(v127);
LABEL_309:
          a3 = 0;
LABEL_310:

          os_log_type_t v11 = v285;
LABEL_311:
          os_log_type_t v160 = v281;
          if ((a5 & 2) == 0) {
            goto LABEL_341;
          }
          device_id = (const char *)nw_endpoint_get_device_id(v11);
          if (!device_id) {
            goto LABEL_341;
          }
          xpc_object_t v162 = device_id;
          unsigned int v163 = strlen(device_id);
          if (!a3)
          {
            v246 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v305 = "nw_necp_append_tlv";
            LODWORD(v278) = 12;
            int v277 = buf;
            v247 = (const char *)_os_log_send_and_compose_impl();

            v303[0] = 16;
            uu[0] = 0;
            if (__nwlog_fault(v247, v303, uu))
            {
              if (v303[0] == 17)
              {
                os_log_type_t v248 = __nwlog_obj();
                os_log_type_t v249 = v303[0];
                if (os_log_type_enabled(v248, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v305 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_1830D4000, v248, v249, "%{public}s called with null tlv_start", buf, 0xCu);
                }
              }
              else if (uu[0])
              {
                BOOL v259 = (char *)__nw_create_backtrace_string();
                os_log_type_t v248 = __nwlog_obj();
                os_log_type_t v260 = v303[0];
                BOOL v261 = os_log_type_enabled(v248, (os_log_type_t)v303[0]);
                if (v259)
                {
                  if (v261)
                  {
                    *(_DWORD *)buf = 136446466;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2082;
                    *(void *)v307 = v259;
                    _os_log_impl(&dword_1830D4000, v248, v260, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v259);
                  goto LABEL_566;
                }
                if (v261)
                {
                  *(_DWORD *)buf = 136446210;
                  v305 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_1830D4000, v248, v260, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                os_log_type_t v248 = __nwlog_obj();
                os_log_type_t v270 = v303[0];
                if (os_log_type_enabled(v248, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v305 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_1830D4000, v248, v270, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_566:
            if (!v247) {
              goto LABEL_339;
            }
            os_log_type_t v176 = (char *)v247;
            goto LABEL_338;
          }
          unsigned int v164 = v163;
          if (a3 >= v288)
          {
            int v250 = __nwlog_obj();
            *(_DWORD *)buf = 136447234;
            v305 = "nw_necp_append_tlv";
            __int16 v306 = 2048;
            *(void *)v307 = a3;
            *(_WORD *)&v307[8] = 2048;
            *(void *)&v307[10] = v288;
            *(_WORD *)&v307[18] = 1024;
            *(_DWORD *)v308 = 158;
            *(_WORD *)&v308[4] = 1024;
            *(_DWORD *)&v308[6] = v164;
            LODWORD(v278) = 44;
            int v277 = buf;
            v167 = (const char *)_os_log_send_and_compose_impl();

            v303[0] = 16;
            uu[0] = 0;
            if (!__nwlog_fault(v167, v303, uu)) {
              goto LABEL_336;
            }
            if (v303[0] == 17)
            {
              os_log_type_t v168 = __nwlog_obj();
              os_log_type_t v251 = v303[0];
              if (os_log_type_enabled(v168, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447234;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v288;
                *(_WORD *)&v307[18] = 1024;
                *(_DWORD *)v308 = 158;
                *(_WORD *)&v308[4] = 1024;
                *(_DWORD *)&v308[6] = v164;
                _os_log_impl(&dword_1830D4000, v168, v251, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
              }
            }
            else if (uu[0])
            {
              os_log_type_t v262 = (char *)__nw_create_backtrace_string();
              os_log_type_t v168 = __nwlog_obj();
              os_log_type_t v263 = v303[0];
              BOOL v264 = os_log_type_enabled(v168, (os_log_type_t)v303[0]);
              if (v262)
              {
                if (v264)
                {
                  *(_DWORD *)buf = 136447490;
                  v305 = "nw_necp_append_tlv";
                  __int16 v306 = 2048;
                  *(void *)v307 = a3;
                  *(_WORD *)&v307[8] = 2048;
                  *(void *)&v307[10] = v288;
                  *(_WORD *)&v307[18] = 1024;
                  *(_DWORD *)v308 = 158;
                  *(_WORD *)&v308[4] = 1024;
                  *(_DWORD *)&v308[6] = v164;
                  *(_WORD *)v309 = 2082;
                  *(void *)&v309[2] = v262;
                  _os_log_impl(&dword_1830D4000, v168, v263, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                }

                free(v262);
                goto LABEL_336;
              }
              if (v264)
              {
                *(_DWORD *)buf = 136447234;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v288;
                *(_WORD *)&v307[18] = 1024;
                *(_DWORD *)v308 = 158;
                *(_WORD *)&v308[4] = 1024;
                *(_DWORD *)&v308[6] = v164;
                _os_log_impl(&dword_1830D4000, v168, v263, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
              }
            }
            else
            {
              os_log_type_t v168 = __nwlog_obj();
              os_log_type_t v271 = v303[0];
              if (os_log_type_enabled(v168, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447234;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v288;
                *(_WORD *)&v307[18] = 1024;
                *(_DWORD *)v308 = 158;
                *(_WORD *)&v308[4] = 1024;
                *(_DWORD *)&v308[6] = v164;
                _os_log_impl(&dword_1830D4000, v168, v271, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
              }
            }
LABEL_335:

            goto LABEL_336;
          }
          unint64_t v165 = v163 + 5;
          if (v288 - a3 >= v165)
          {
            *(unsigned char *)a3 = -98;
            *(_DWORD *)(a3 + 1) = v163;
            if (v163) {
              memcpy((void *)(a3 + 5), v162, v163);
            }
            a3 += v165;
            goto LABEL_340;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v166 = (id)gLogObj;
          *(_DWORD *)buf = 136447490;
          v305 = "nw_necp_append_tlv";
          __int16 v306 = 2048;
          *(void *)v307 = a3;
          *(_WORD *)&v307[8] = 2048;
          *(void *)&v307[10] = v165;
          *(_WORD *)&v307[18] = 2048;
          *(void *)v308 = v288;
          *(_WORD *)&v308[8] = 1024;
          *(_DWORD *)v309 = 158;
          *(_WORD *)&v309[4] = 1024;
          *(_DWORD *)&v309[6] = v164;
          LODWORD(v278) = 54;
          int v277 = buf;
          v167 = (const char *)_os_log_send_and_compose_impl();

          v303[0] = 16;
          uu[0] = 0;
          if (__nwlog_fault(v167, v303, uu))
          {
            if (v303[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v168 = (id)gLogObj;
              os_log_type_t v169 = v303[0];
              if (os_log_type_enabled(v168, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v165;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = 158;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v164;
                _os_log_impl(&dword_1830D4000, v168, v169, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
            }
            else if (uu[0])
            {
              BOOL v170 = __nw_create_backtrace_string();
              if (v170)
              {
                os_log_type_t v171 = (char *)v170;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v172 = (id)gLogObj;
                os_log_type_t v173 = v303[0];
                if (os_log_type_enabled(v172, (os_log_type_t)v303[0]))
                {
                  *(_DWORD *)buf = 136447746;
                  v305 = "nw_necp_append_tlv";
                  __int16 v306 = 2048;
                  *(void *)v307 = a3;
                  *(_WORD *)&v307[8] = 2048;
                  *(void *)&v307[10] = v165;
                  *(_WORD *)&v307[18] = 2048;
                  *(void *)v308 = v288;
                  *(_WORD *)&v308[8] = 1024;
                  *(_DWORD *)v309 = 158;
                  *(_WORD *)&v309[4] = 1024;
                  *(_DWORD *)&v309[6] = v164;
                  __int16 v310 = 2082;
                  v311 = v171;
                  _os_log_impl(&dword_1830D4000, v172, v173, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }

                free(v171);
                if (!v167) {
                  goto LABEL_339;
                }
                goto LABEL_337;
              }
              os_log_type_t v168 = __nwlog_obj();
              os_log_type_t v175 = v303[0];
              if (os_log_type_enabled(v168, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v165;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = 158;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v164;
                _os_log_impl(&dword_1830D4000, v168, v175, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v168 = (id)gLogObj;
              os_log_type_t v174 = v303[0];
              if (os_log_type_enabled(v168, (os_log_type_t)v303[0]))
              {
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v165;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = 158;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v164;
                _os_log_impl(&dword_1830D4000, v168, v174, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }
            goto LABEL_335;
          }
LABEL_336:
          if (v167)
          {
LABEL_337:
            os_log_type_t v176 = (char *)v167;
LABEL_338:
            free(v176);
          }
LABEL_339:
          a3 = 0;
LABEL_340:
          os_log_type_t v160 = v281;
          os_log_type_t v11 = v285;
LABEL_341:
          if ((a5 & 4) == 0) {
            goto LABEL_430;
          }
          long long v291 = 0u;
          long long v292 = 0u;
          long long v289 = 0u;
          long long v290 = 0u;
          id v177 = nw_endpoint_copy_public_keys(v11);
          uint64_t v178 = [v177 countByEnumeratingWithState:&v289 objects:v301 count:16];
          if (!v178) {
            goto LABEL_429;
          }
          uint64_t v287 = *(void *)v290;
          id v284 = v177;
          do
          {
            for (uint64_t i = 0; i != v178; ++i)
            {
              if (*(void *)v290 != v287) {
                objc_enumerationMutation(v177);
              }
              os_log_type_t v180 = *(void **)(*((void *)&v289 + 1) + 8 * i);
              unsigned int v181 = objc_msgSend(v180, "length", v277, v278);
              os_log_type_t v182 = (const void *)[v180 bytes];
              if (!a3)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v194 = (id)gLogObj;
                *(_DWORD *)buf = 136446210;
                v305 = "nw_necp_append_tlv";
                LODWORD(v278) = 12;
                int v277 = buf;
                nw_interface_t v185 = (const char *)_os_log_send_and_compose_impl();

                v303[0] = 16;
                uu[0] = 0;
                if (__nwlog_fault(v185, v303, uu))
                {
                  if (v303[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    xpc_object_t v186 = (id)gLogObj;
                    os_log_type_t v195 = v303[0];
                    if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v305 = "nw_necp_append_tlv";
                      _os_log_impl(&dword_1830D4000, v186, v195, "%{public}s called with null tlv_start", buf, 0xCu);
                    }
                    goto LABEL_374;
                  }
                  if (uu[0])
                  {
                    uint64_t v200 = __nw_create_backtrace_string();
                    if (v200)
                    {
                      v201 = v200;
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      int v202 = (id)gLogObj;
                      os_log_type_t v203 = v303[0];
                      if (os_log_type_enabled(v202, (os_log_type_t)v303[0]))
                      {
                        *(_DWORD *)buf = 136446466;
                        v305 = "nw_necp_append_tlv";
                        __int16 v306 = 2082;
                        *(void *)v307 = v201;
                        _os_log_impl(&dword_1830D4000, v202, v203, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      v191 = (char *)v201;
                      goto LABEL_367;
                    }
                    xpc_object_t v186 = __nwlog_obj();
                    os_log_type_t v215 = v303[0];
                    if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v305 = "nw_necp_append_tlv";
                      _os_log_impl(&dword_1830D4000, v186, v215, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                    }
                  }
                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    xpc_object_t v186 = (id)gLogObj;
                    os_log_type_t v210 = v303[0];
                    if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v305 = "nw_necp_append_tlv";
                      _os_log_impl(&dword_1830D4000, v186, v210, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                    }
                  }
LABEL_374:
                }
LABEL_375:
                id v177 = v284;
                if (v185)
                {
LABEL_376:
                  os_log_type_t v193 = (char *)v185;
                  goto LABEL_345;
                }
LABEL_346:
                a3 = 0;
                continue;
              }
              if (a3 >= v288)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v196 = (id)gLogObj;
                *(_DWORD *)buf = 136447234;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v288;
                *(_WORD *)&v307[18] = 1024;
                *(_DWORD *)v308 = 159;
                *(_WORD *)&v308[4] = 1024;
                *(_DWORD *)&v308[6] = v181;
                LODWORD(v278) = 44;
                int v277 = buf;
                v197 = (const char *)_os_log_send_and_compose_impl();

                v303[0] = 16;
                uu[0] = 0;
                if (__nwlog_fault(v197, v303, uu))
                {
                  if (v303[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    nw_interface_t v198 = (id)gLogObj;
                    os_log_type_t v199 = v303[0];
                    if (os_log_type_enabled(v198, (os_log_type_t)v303[0]))
                    {
                      *(_DWORD *)buf = 136447234;
                      v305 = "nw_necp_append_tlv";
                      __int16 v306 = 2048;
                      *(void *)v307 = a3;
                      *(_WORD *)&v307[8] = 2048;
                      *(void *)&v307[10] = v288;
                      *(_WORD *)&v307[18] = 1024;
                      *(_DWORD *)v308 = 159;
                      *(_WORD *)&v308[4] = 1024;
                      *(_DWORD *)&v308[6] = v181;
                      _os_log_impl(&dword_1830D4000, v198, v199, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                    }
                    goto LABEL_419;
                  }
                  if (uu[0])
                  {
                    nw_protocol_metadata_t v204 = __nw_create_backtrace_string();
                    if (v204)
                    {
                      nw_endpoint_t v205 = (char *)v204;
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v206 = (id)gLogObj;
                      os_log_type_t v207 = v303[0];
                      if (os_log_type_enabled(v206, (os_log_type_t)v303[0]))
                      {
                        *(_DWORD *)buf = 136447490;
                        v305 = "nw_necp_append_tlv";
                        __int16 v306 = 2048;
                        *(void *)v307 = a3;
                        *(_WORD *)&v307[8] = 2048;
                        *(void *)&v307[10] = v288;
                        *(_WORD *)&v307[18] = 1024;
                        *(_DWORD *)v308 = 159;
                        *(_WORD *)&v308[4] = 1024;
                        *(_DWORD *)&v308[6] = v181;
                        *(_WORD *)v309 = 2082;
                        *(void *)&v309[2] = v205;
                        _os_log_impl(&dword_1830D4000, v206, v207, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                      }

                      free(v205);
                      id v177 = v284;
                      if (!v197) {
                        goto LABEL_346;
                      }
LABEL_421:
                      os_log_type_t v193 = (char *)v197;
LABEL_345:
                      free(v193);
                      goto LABEL_346;
                    }
                    nw_interface_t v198 = __nwlog_obj();
                    os_log_type_t v216 = v303[0];
                    if (os_log_type_enabled(v198, (os_log_type_t)v303[0]))
                    {
                      *(_DWORD *)buf = 136447234;
                      v305 = "nw_necp_append_tlv";
                      __int16 v306 = 2048;
                      *(void *)v307 = a3;
                      *(_WORD *)&v307[8] = 2048;
                      *(void *)&v307[10] = v288;
                      *(_WORD *)&v307[18] = 1024;
                      *(_DWORD *)v308 = 159;
                      *(_WORD *)&v308[4] = 1024;
                      *(_DWORD *)&v308[6] = v181;
                      _os_log_impl(&dword_1830D4000, v198, v216, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                    }
                  }
                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    nw_interface_t v198 = (id)gLogObj;
                    os_log_type_t v211 = v303[0];
                    if (os_log_type_enabled(v198, (os_log_type_t)v303[0]))
                    {
                      *(_DWORD *)buf = 136447234;
                      v305 = "nw_necp_append_tlv";
                      __int16 v306 = 2048;
                      *(void *)v307 = a3;
                      *(_WORD *)&v307[8] = 2048;
                      *(void *)&v307[10] = v288;
                      *(_WORD *)&v307[18] = 1024;
                      *(_DWORD *)v308 = 159;
                      *(_WORD *)&v308[4] = 1024;
                      *(_DWORD *)&v308[6] = v181;
                      _os_log_impl(&dword_1830D4000, v198, v211, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                    }
                  }
LABEL_419:
                }
                id v177 = v284;
                if (!v197) {
                  goto LABEL_346;
                }
                goto LABEL_421;
              }
              unint64_t v183 = v181 + 5;
              if (v288 - a3 < v183)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v184 = (id)gLogObj;
                *(_DWORD *)buf = 136447490;
                v305 = "nw_necp_append_tlv";
                __int16 v306 = 2048;
                *(void *)v307 = a3;
                *(_WORD *)&v307[8] = 2048;
                *(void *)&v307[10] = v181 + 5;
                *(_WORD *)&v307[18] = 2048;
                *(void *)v308 = v288;
                *(_WORD *)&v308[8] = 1024;
                *(_DWORD *)v309 = 159;
                *(_WORD *)&v309[4] = 1024;
                *(_DWORD *)&v309[6] = v181;
                LODWORD(v278) = 54;
                int v277 = buf;
                nw_interface_t v185 = (const char *)_os_log_send_and_compose_impl();

                v303[0] = 16;
                uu[0] = 0;
                if (!__nwlog_fault(v185, v303, uu)) {
                  goto LABEL_375;
                }
                if (v303[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  xpc_object_t v186 = (id)gLogObj;
                  os_log_type_t v187 = v303[0];
                  if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                  {
                    *(_DWORD *)buf = 136447490;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = v181 + 5;
                    *(_WORD *)&v307[18] = 2048;
                    *(void *)v308 = v288;
                    *(_WORD *)&v308[8] = 1024;
                    *(_DWORD *)v309 = 159;
                    *(_WORD *)&v309[4] = 1024;
                    *(_DWORD *)&v309[6] = v181;
                    _os_log_impl(&dword_1830D4000, v186, v187, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                  }
                  goto LABEL_374;
                }
                if (!uu[0])
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  xpc_object_t v186 = (id)gLogObj;
                  os_log_type_t v192 = v303[0];
                  if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                  {
                    *(_DWORD *)buf = 136447490;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = v181 + 5;
                    *(_WORD *)&v307[18] = 2048;
                    *(void *)v308 = v288;
                    *(_WORD *)&v308[8] = 1024;
                    *(_DWORD *)v309 = 159;
                    *(_WORD *)&v309[4] = 1024;
                    *(_DWORD *)&v309[6] = v181;
                    _os_log_impl(&dword_1830D4000, v186, v192, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                  }
                  goto LABEL_374;
                }
                uint64_t v188 = __nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                xpc_object_t v186 = (id)gLogObj;
                os_log_type_t v189 = v303[0];
                BOOL v190 = os_log_type_enabled(v186, (os_log_type_t)v303[0]);
                if (!v188)
                {
                  if (v190)
                  {
                    *(_DWORD *)buf = 136447490;
                    v305 = "nw_necp_append_tlv";
                    __int16 v306 = 2048;
                    *(void *)v307 = a3;
                    *(_WORD *)&v307[8] = 2048;
                    *(void *)&v307[10] = v181 + 5;
                    *(_WORD *)&v307[18] = 2048;
                    *(void *)v308 = v288;
                    *(_WORD *)&v308[8] = 1024;
                    *(_DWORD *)v309 = 159;
                    *(_WORD *)&v309[4] = 1024;
                    *(_DWORD *)&v309[6] = v181;
                    _os_log_impl(&dword_1830D4000, v186, v189, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                  }
                  goto LABEL_374;
                }
                if (v190)
                {
                  *(_DWORD *)buf = 136447746;
                  v305 = "nw_necp_append_tlv";
                  __int16 v306 = 2048;
                  *(void *)v307 = a3;
                  *(_WORD *)&v307[8] = 2048;
                  *(void *)&v307[10] = v181 + 5;
                  *(_WORD *)&v307[18] = 2048;
                  *(void *)v308 = v288;
                  *(_WORD *)&v308[8] = 1024;
                  *(_DWORD *)v309 = 159;
                  *(_WORD *)&v309[4] = 1024;
                  *(_DWORD *)&v309[6] = v181;
                  __int16 v310 = 2082;
                  v311 = (char *)v188;
                  _os_log_impl(&dword_1830D4000, v186, v189, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }

                v191 = (char *)v188;
LABEL_367:
                free(v191);
                id v177 = v284;
                if (v185) {
                  goto LABEL_376;
                }
                goto LABEL_346;
              }
              *(unsigned char *)a3 = -97;
              *(_DWORD *)(a3 + 1) = v181;
              if (v181)
              {
                if (!v182)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v208 = (id)gLogObj;
                  *(_DWORD *)buf = 136446722;
                  v305 = "nw_necp_append_tlv";
                  __int16 v306 = 1024;
                  *(_DWORD *)v307 = 159;
                  *(_WORD *)&v307[4] = 1024;
                  *(_DWORD *)&v307[6] = v181;
                  LODWORD(v278) = 24;
                  int v277 = buf;
                  nw_interface_t v185 = (const char *)_os_log_send_and_compose_impl();

                  v303[0] = 16;
                  uu[0] = 0;
                  if (__nwlog_fault(v185, v303, uu))
                  {
                    if (v303[0] == 17)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      xpc_object_t v186 = (id)gLogObj;
                      os_log_type_t v209 = v303[0];
                      if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                      {
                        *(_DWORD *)buf = 136446722;
                        v305 = "nw_necp_append_tlv";
                        __int16 v306 = 1024;
                        *(_DWORD *)v307 = 159;
                        *(_WORD *)&v307[4] = 1024;
                        *(_DWORD *)&v307[6] = v181;
                        _os_log_impl(&dword_1830D4000, v186, v209, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
                      }
                      goto LABEL_374;
                    }
                    if (!uu[0])
                    {
                      xpc_object_t v186 = __nwlog_obj();
                      os_log_type_t v217 = v303[0];
                      if (os_log_type_enabled(v186, (os_log_type_t)v303[0]))
                      {
                        *(_DWORD *)buf = 136446722;
                        v305 = "nw_necp_append_tlv";
                        __int16 v306 = 1024;
                        *(_DWORD *)v307 = 159;
                        *(_WORD *)&v307[4] = 1024;
                        *(_DWORD *)&v307[6] = v181;
                        _os_log_impl(&dword_1830D4000, v186, v217, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
                      }
                      goto LABEL_374;
                    }
                    v212 = (char *)__nw_create_backtrace_string();
                    xpc_object_t v186 = __nwlog_obj();
                    os_log_type_t v213 = v303[0];
                    BOOL v214 = os_log_type_enabled(v186, (os_log_type_t)v303[0]);
                    if (!v212)
                    {
                      if (v214)
                      {
                        *(_DWORD *)buf = 136446722;
                        v305 = "nw_necp_append_tlv";
                        __int16 v306 = 1024;
                        *(_DWORD *)v307 = 159;
                        *(_WORD *)&v307[4] = 1024;
                        *(_DWORD *)&v307[6] = v181;
                        _os_log_impl(&dword_1830D4000, v186, v213, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
                      }
                      goto LABEL_374;
                    }
                    if (v214)
                    {
                      *(_DWORD *)buf = 136446978;
                      v305 = "nw_necp_append_tlv";
                      __int16 v306 = 1024;
                      *(_DWORD *)v307 = 159;
                      *(_WORD *)&v307[4] = 1024;
                      *(_DWORD *)&v307[6] = v181;
                      *(_WORD *)&v307[10] = 2082;
                      *(void *)&v307[12] = v212;
                      _os_log_impl(&dword_1830D4000, v186, v213, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
                    }

                    free(v212);
                  }
                  goto LABEL_375;
                }
                memcpy((void *)(a3 + 5), v182, v181);
              }
              a3 += v183;
            }
            uint64_t v178 = [v177 countByEnumeratingWithState:&v289 objects:v301 count:16];
          }
          while (v178);
LABEL_429:

          os_log_type_t v160 = v281;
LABEL_430:
          if (v160) {
            free(v160);
          }

          __int16 v218 = v279;
LABEL_433:

          return a3;
      }
    default:
      if (!nw_endpoint_is_custom_type(v11)) {
        goto LABEL_75;
      }
      size_t custom_data_length = nw_endpoint_get_custom_data_length(v11);
      if (!custom_data_length) {
        goto LABEL_75;
      }
      if (custom_data_length <= 0x400)
      {
        char v45 = -9;
        if (custom_data_length < 0xF7) {
          char v45 = custom_data_length;
        }
        unsigned __int8 v46 = v45 + 8;
        unint64_t sa_len = v46;
        if (v46 <= 0x1Cu) {
          size_t v42 = 28;
        }
        else {
          size_t v42 = v46;
        }
        goto LABEL_53;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v37 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v305 = "nw_path_struct_size_for_endpoint";
      __int16 v306 = 1024;
      *(_DWORD *)v307 = 1024;
      LODWORD(v278) = 18;
      int v277 = buf;
      os_log_type_t v38 = (char *)_os_log_send_and_compose_impl();

      v303[0] = 16;
      uu[0] = 0;
      if (!__nwlog_fault(v38, v303, uu)) {
        goto LABEL_73;
      }
      if (v303[0] == 17)
      {
        uint64_t v39 = __nwlog_obj();
        os_log_type_t v40 = v303[0];
        if (os_log_type_enabled(v39, (os_log_type_t)v303[0]))
        {
          *(_DWORD *)buf = 136446466;
          v305 = "nw_path_struct_size_for_endpoint";
          __int16 v306 = 1024;
          *(_DWORD *)v307 = 1024;
          _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
        }
      }
      else if (uu[0])
      {
        os_log_type_t v47 = (char *)__nw_create_backtrace_string();
        uint64_t v39 = __nwlog_obj();
        os_log_type_t v48 = v303[0];
        BOOL v49 = os_log_type_enabled(v39, (os_log_type_t)v303[0]);
        if (v47)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446722;
            v305 = "nw_path_struct_size_for_endpoint";
            __int16 v306 = 1024;
            *(_DWORD *)v307 = 1024;
            *(_WORD *)&v307[4] = 2082;
            *(void *)&v307[6] = v47;
            _os_log_impl(&dword_1830D4000, v39, v48, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v47);
LABEL_73:
          if (v38) {
            free(v38);
          }
LABEL_75:

          unint64_t sa_len = 0;
          int v281 = 0;
          int v44 = v295;
          size_t v42 = 28;
          goto LABEL_76;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v305 = "nw_path_struct_size_for_endpoint";
          __int16 v306 = 1024;
          *(_DWORD *)v307 = 1024;
          _os_log_impl(&dword_1830D4000, v39, v48, "%{public}s Custom data size must be no larger than %d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        uint64_t v39 = __nwlog_obj();
        os_log_type_t v50 = v303[0];
        if (os_log_type_enabled(v39, (os_log_type_t)v303[0]))
        {
          *(_DWORD *)buf = 136446466;
          v305 = "nw_path_struct_size_for_endpoint";
          __int16 v306 = 1024;
          *(_DWORD *)v307 = 1024;
          _os_log_impl(&dword_1830D4000, v39, v50, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", buf, 0x12u);
        }
      }

      goto LABEL_73;
  }
}

void sub_1833771FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_add_inbound(void *a1, uint64_t a2, void *a3, void *a4, int a5, int a6)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  os_log_type_t v11 = a1;
  nw_endpoint_type_t v12 = a3;
  nw_txt_record_t v13 = a4;
  if (!v11)
  {
    os_log_type_t v61 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
    size_t v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (!__nwlog_fault(v62, type, &v80)) {
      goto LABEL_150;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v64 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v64, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v80)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v68 = type[0];
      BOOL v69 = os_log_type_enabled(v63, type[0]);
      if (backtrace_string)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
          __int16 v84 = 2082;
          os_log_type_t v85 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v63, v68, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_150:
        if (!v62) {
          goto LABEL_100;
        }
LABEL_151:
        free(v62);
        goto LABEL_100;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v68, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v77 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v77, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_149:

    goto LABEL_150;
  }
  if (!v12)
  {
    BOOL v65 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
    size_t v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (!__nwlog_fault(v62, type, &v80)) {
      goto LABEL_150;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v66 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v66, "%{public}s called with null data", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (!v80)
    {
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v78 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v78, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_149;
    }
    uint64_t v72 = (char *)__nw_create_backtrace_string();
    nw_txt_record_t v63 = __nwlog_obj();
    os_log_type_t v73 = type[0];
    BOOL v74 = os_log_type_enabled(v63, type[0]);
    if (!v72)
    {
      if (v74)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v73, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (v74)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
      __int16 v84 = 2082;
      os_log_type_t v85 = v72;
      _os_log_impl(&dword_1830D4000, v63, v73, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_130;
  }
  os_log_type_t v14 = (void *)*((void *)v11 + 15);
  if (v14)
  {
    size_t v15 = v14;
    char v16 = v15;
    if (((_BYTE)v15[17] & 8) == 0) {
      dispatch_assert_queue_V2(v15[1]);
    }
  }
  if (v13) {
    nw_frame_set_metadata((uint64_t)v12, v13, 1, a5);
  }
  if (a6) {
    v12[186] |= 0x80u;
  }
  if (*(_DWORD *)(*((void *)v11 + 1) + 64) == 3)
  {
    uint64_t node = nw_hash_table_get_node(*((void *)v11 + 29), a2, 8);
    if (node)
    {
      int v18 = *((_DWORD *)v12 + 13);
      if (v18) {
        v18 -= *((_DWORD *)v12 + 14) + *((_DWORD *)v12 + 15);
      }
      int v19 = *(_DWORD *)(node + 68) + v18;
      ++*(_DWORD *)(node + 64);
      *(_DWORD *)(node + 68) = v19;
      *((void *)v12 + 4) = 0;
      size_t v20 = *(void **)(node + 56);
      *((void *)v12 + 5) = v20;
      *size_t v20 = v12;
      *(void *)(node + 56) = v12 + 32;
      __int16 v21 = *(_WORD *)(node + 84);
      if ((v21 & 0x10) != 0)
      {
        if ((v11[403] & 0x10) != 0)
        {
          if (a6) {
            *(_WORD *)(node + 84) = v21 | 0x40;
          }
        }
        else
        {
          size_t v22 = *(void **)(node + 16);
          if (v22)
          {
            uint64_t v23 = v22[3];
            if (v23)
            {
              BOOL v24 = *(void (**)(void *, char *))(v23 + 64);
              if (v24)
              {
                os_log_type_t v25 = (void *)v22[5];
                if (v25 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v45 = v22[11];
                  if (v45) {
                    v22[11] = v45 + 1;
                  }
                  char v26 = -1;
                }
                else
                {
                  char v26 = 0;
                }
                *(void *)buf = v22;
                buf[8] = v26;
                unsigned __int8 v46 = (void *)*((void *)v11 - 7);
                if (v46 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v48 = *((void *)v11 - 1);
                  if (v48) {
                    *((void *)v11 - 1) = v48 + 1;
                  }
                  char v47 = -1;
                }
                else
                {
                  char v47 = 0;
                }
                *(void *)os_log_type_t type = v11 - 96;
                char v82 = v47;
                v24(v22, v11 - 96);
                if (v46 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                }
                if (v25 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
              }
            }
            if (a6)
            {
              uint64_t v49 = v22[3];
              if (v49)
              {
                os_log_type_t v50 = *(void (**)(void *, char *))(v49 + 184);
                if (v50)
                {
                  char v51 = (void *)v22[5];
                  if (v51 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v57 = v22[11];
                    if (v57) {
                      v22[11] = v57 + 1;
                    }
                    char v52 = -1;
                  }
                  else
                  {
                    char v52 = 0;
                  }
                  *(void *)buf = v22;
                  buf[8] = v52;
                  int v58 = (void *)*((void *)v11 - 7);
                  if (v58 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v60 = *((void *)v11 - 1);
                    if (v60) {
                      *((void *)v11 - 1) = v60 + 1;
                    }
                    char v59 = -1;
                  }
                  else
                  {
                    char v59 = 0;
                  }
                  *(void *)os_log_type_t type = v11 - 96;
                  char v82 = v59;
                  v50(v22, v11 - 96);
                  if (v58 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
                  if (v51 == &nw_protocol_ref_counted_handle)
                  {
LABEL_99:
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    goto LABEL_100;
                  }
                }
              }
            }
          }
        }
      }
    }
    else if ((v11[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      Class v35 = (id)gLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        __int16 v84 = 2082;
        os_log_type_t v85 = v11 + 407;
        __int16 v86 = 2080;
        int v87 = " ";
        __int16 v88 = 2048;
        uint64_t v89 = a2;
        _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot add inbound data, flow %llx does not exist", buf, 0x2Au);
      }
    }
    goto LABEL_100;
  }
  if (a2 != -1)
  {
    size_t v70 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
    size_t v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (!__nwlog_fault(v62, type, &v80)) {
      goto LABEL_150;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v71 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v71, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (!v80)
    {
      nw_txt_record_t v63 = __nwlog_obj();
      os_log_type_t v79 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v79, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_149;
    }
    uint64_t v72 = (char *)__nw_create_backtrace_string();
    nw_txt_record_t v63 = __nwlog_obj();
    os_log_type_t v75 = type[0];
    BOOL v76 = os_log_type_enabled(v63, type[0]);
    if (!v72)
    {
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_1830D4000, v63, v75, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (v76)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
      __int16 v84 = 2082;
      os_log_type_t v85 = v72;
      _os_log_impl(&dword_1830D4000, v63, v75, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_130:

    free(v72);
    if (!v62) {
      goto LABEL_100;
    }
    goto LABEL_151;
  }
  int v27 = *((_DWORD *)v12 + 13);
  if (v27) {
    v27 -= *((_DWORD *)v12 + 14) + *((_DWORD *)v12 + 15);
  }
  int v28 = *((_DWORD *)v11 + 51) + v27;
  ++*((_DWORD *)v11 + 50);
  *((_DWORD *)v11 + 51) = v28;
  *((void *)v12 + 4) = 0;
  uint64_t v29 = (void *)*((void *)v11 + 24);
  *((void *)v12 + 5) = v29;
  *uint64_t v29 = v12;
  *((void *)v11 + 24) = v12 + 32;
  if ((v11[402] & 8) != 0)
  {
    if ((v11[403] & 0x10) != 0)
    {
      if (a6) {
        v11[403] |= 0x40u;
      }
    }
    else
    {
      size_t v30 = (void *)*((void *)v11 - 6);
      if (!v30) {
        goto LABEL_51;
      }
      uint64_t v31 = v30[3];
      if (!v31) {
        goto LABEL_51;
      }
      size_t v32 = *(void (**)(void))(v31 + 64);
      if (!v32) {
        goto LABEL_51;
      }
      size_t v33 = (void *)v30[5];
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v36 = v30[11];
        if (v36) {
          v30[11] = v36 + 1;
        }
        char v34 = -1;
      }
      else
      {
        char v34 = 0;
      }
      *(void *)buf = v30;
      buf[8] = v34;
      id v37 = (void *)*((void *)v11 - 7);
      if (v37 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v39 = *((void *)v11 - 1);
        if (v39) {
          *((void *)v11 - 1) = v39 + 1;
        }
        char v38 = -1;
      }
      else
      {
        char v38 = 0;
      }
      *(void *)os_log_type_t type = v11 - 96;
      char v82 = v38;
      v32();
      if (v37 == &nw_protocol_ref_counted_handle) {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      }
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
        if (!a6) {
          goto LABEL_100;
        }
      }
      else
      {
LABEL_51:
        if (!a6) {
          goto LABEL_100;
        }
      }
      os_log_type_t v40 = (void *)*((void *)v11 - 6);
      if (v40)
      {
        uint64_t v41 = v40[3];
        if (v41)
        {
          size_t v42 = *(void (**)(void))(v41 + 184);
          if (v42)
          {
            uint64_t v43 = (void *)v40[5];
            if (v43 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v53 = v40[11];
              if (v53) {
                v40[11] = v53 + 1;
              }
              char v44 = -1;
            }
            else
            {
              char v44 = 0;
            }
            *(void *)buf = v40;
            buf[8] = v44;
            size_t v54 = (void *)*((void *)v11 - 7);
            if (v54 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v56 = *((void *)v11 - 1);
              if (v56) {
                *((void *)v11 - 1) = v56 + 1;
              }
              char v55 = -1;
            }
            else
            {
              char v55 = 0;
            }
            *(void *)os_log_type_t type = v11 - 96;
            char v82 = v55;
            v42();
            if (v54 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            }
            if (v43 == &nw_protocol_ref_counted_handle) {
              goto LABEL_99;
            }
          }
        }
      }
    }
  }
LABEL_100:
}

void sub_183377E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  if (v12 == v11) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v10 == v11) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

void ___ZL25nw_protocol_udp_callbacksv_block_invoke()
{
  nw_protocol_udp_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler((void *)nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_add_input_handler);
  nw_protocol_callbacks_set_remove_input_handler(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_remove_input_handler);
  nw_protocol_callbacks_set_get_input_frames(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_finalize_output_frames);
  nw_protocol_callbacks_set_connected(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_connected);
  nw_protocol_callbacks_set_disconnected(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_disconnected);
  nw_protocol_callbacks_set_link_state(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_link_state);
  nw_protocol_callbacks_set_updated_path(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_updated_path);
  nw_protocol_callbacks_set_get_message_properties(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_get_message_properties);
  nw_protocol_callbacks_set_copy_info(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_copy_info);
  uint64_t v0 = nw_protocol_udp_callbacks(void)::callbacks;

  nw_protocol_callbacks_set_error(v0, (uint64_t)nw_protocol_udp_error);
}

void ___ZL26nw_protocol_ipv4_callbacksv_block_invoke()
{
  nw_protocol_ipv4_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler((void *)nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_add_input_handler);
  nw_protocol_callbacks_set_replace_input_handler(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_replace_input_handler);
  nw_protocol_callbacks_set_remove_input_handler(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_remove_input_handler);
  nw_protocol_callbacks_set_get_input_frames(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_finalize_output_frames);
  nw_protocol_callbacks_set_connected(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_connected);
  nw_protocol_callbacks_set_disconnected(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_disconnected);
  nw_protocol_callbacks_set_get_message_properties(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_get_message_properties);
  nw_protocol_callbacks_set_copy_info(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_copy_info);
  nw_protocol_callbacks_set_updated_path(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_updated_path);
  nw_protocol_callbacks_set_notify(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_notify);
  uint64_t v0 = nw_protocol_ipv4_callbacks(void)::callbacks;

  nw_protocol_callbacks_set_error(v0, (uint64_t)nw_protocol_ipv4_error);
}

BOOL nw_protocol_one_to_one_callbacks_new()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x110uLL, 0xEAFB8F1AuLL);
  id v1 = v0;
  if (v0)
  {
    *uint64_t v0 = nw_protocol_default_add_input_handler;
    v0[2] = nw_protocol_default_replace_input_handler;
    v0[1] = nw_protocol_default_remove_input_handler;
    v0[8] = nw_protocol_default_input_available;
    v0[9] = nw_protocol_default_output_available;
    v0[23] = nw_protocol_default_input_finished;
    v0[24] = nw_protocol_default_output_finished;
    v0[33] = nw_protocol_default_input_flush;
    v0[10] = nw_protocol_default_get_input_frames;
    v0[11] = nw_protocol_default_get_output_frames;
    v0[12] = nw_protocol_default_finalize_output_frames;
    v0[31] = nw_protocol_default_get_message_properties;
    v0[13] = nw_protocol_default_link_state;
    v0[14] = nw_protocol_default_get_parameters;
    v0[16] = nw_protocol_default_get_local;
    v0[17] = nw_protocol_default_get_remote;
    v0[15] = nw_protocol_default_get_path;
    v0[21] = nw_protocol_default_updated_path;
    v0[25] = nw_protocol_default_get_output_local;
    v0[26] = nw_protocol_default_get_output_interface;
    v0[3] = nw_protocol_default_connect;
    v0[4] = nw_protocol_default_disconnect;
    v0[5] = nw_protocol_default_connected;
    v0[6] = nw_protocol_default_disconnected;
    v0[7] = nw_protocol_default_error;
    v0[32] = nw_protocol_default_reset;
    v0[22] = nw_protocol_default_supports_external_data;
    v0[27] = nw_protocol_default_waiting_for_output;
    v0[28] = nw_protocol_default_copy_info;
    v0[18] = nw_protocol_default_register_notification;
    v0[19] = nw_protocol_default_unregister_notification;
    v0[20] = nw_protocol_default_notify;
    v0[29] = nw_protocol_default_add_listen_handler;
    v0[30] = nw_protocol_default_remove_listen_handler;
    return (BOOL)v1;
  }
  uint64_t v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    MEMORY[0x100] = 0u;
    MEMORY[0xF0] = 0u;
    MEMORY[0xE0] = 0u;
    MEMORY[0xD0] = 0u;
    MEMORY[0xC0] = 0u;
    MEMORY[0xB0] = 0u;
    MEMORY[0xA0] = 0u;
    MEMORY[0x90] = 0u;
    MEMORY[0x80] = 0u;
    MEMORY[0x70] = 0u;
    MEMORY[0x60] = 0u;
    MEMORY[0x50] = 0u;
    MEMORY[0x40] = 0u;
    MEMORY[0x30] = 0u;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    nw_protocol_set_default_one_to_one_callbacks(0);
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

void nw_protocol_callbacks_set_updated_path(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 168) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
        unsigned int v5 = "%{public}s called with null updated_path";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
        unsigned int v5 = "%{public}s called with null updated_path, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null updated_path, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
        unsigned int v5 = "%{public}s called with null updated_path, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_updated_path";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_remove_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 8) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
        unsigned int v5 = "%{public}s called with null remove_input_handler";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
        unsigned int v5 = "%{public}s called with null remove_input_handler, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null remove_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
        unsigned int v5 = "%{public}s called with null remove_input_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_get_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 88) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
        unsigned int v5 = "%{public}s called with null get_output_frames";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
        unsigned int v5 = "%{public}s called with null get_output_frames, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null get_output_frames, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
        unsigned int v5 = "%{public}s called with null get_output_frames, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_get_input_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 80) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
        unsigned int v5 = "%{public}s called with null get_input_frames";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
        unsigned int v5 = "%{public}s called with null get_input_frames, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null get_input_frames, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
        unsigned int v5 = "%{public}s called with null get_input_frames, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 96) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
        unsigned int v5 = "%{public}s called with null finalize_output_frames";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
        unsigned int v5 = "%{public}s called with null finalize_output_frames, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null finalize_output_frames, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
        unsigned int v5 = "%{public}s called with null finalize_output_frames, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_copy_info(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 224) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
        unsigned int v5 = "%{public}s called with null copy_info";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
        unsigned int v5 = "%{public}s called with null copy_info, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null copy_info, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
        unsigned int v5 = "%{public}s called with null copy_info, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_copy_info";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_add_input_handler(void *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *a1 = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
        unsigned int v5 = "%{public}s called with null add_input_handler";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
        unsigned int v5 = "%{public}s called with null add_input_handler, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null add_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
        unsigned int v5 = "%{public}s called with null add_input_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_get_message_properties(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 248) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
        unsigned int v5 = "%{public}s called with null get_message_properties";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
        unsigned int v5 = "%{public}s called with null get_message_properties, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null get_message_properties, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
        unsigned int v5 = "%{public}s called with null get_message_properties, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 48) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
        unsigned int v5 = "%{public}s called with null disconnected";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
        unsigned int v5 = "%{public}s called with null disconnected, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null disconnected, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
        unsigned int v5 = "%{public}s called with null disconnected, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_disconnected";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_connected(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 40) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
        unsigned int v5 = "%{public}s called with null connected";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
        unsigned int v5 = "%{public}s called with null connected, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null connected, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
        unsigned int v5 = "%{public}s called with null connected, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_connected";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_replace_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 16) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
        unsigned int v5 = "%{public}s called with null replace_input_handler";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
        unsigned int v5 = "%{public}s called with null replace_input_handler, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null replace_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
        unsigned int v5 = "%{public}s called with null replace_input_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_protocol_callbacks_set_notify(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 160) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
        unsigned int v5 = "%{public}s called with null notify";
        goto LABEL_32;
      }
      if (!v10)
      {
        uint64_t v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
        unsigned int v5 = "%{public}s called with null notify, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
          __int16 v14 = 2082;
          size_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null notify, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
        unsigned int v5 = "%{public}s called with null notify, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
      unsigned int v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
      unsigned int v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }
    id v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
      unsigned int v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      nw_txt_record_t v13 = "nw_protocol_callbacks_set_notify";
      __int16 v14 = 2082;
      size_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null callbacks, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

void nw_path_monitor_set_cancel_handler(nw_path_monitor_t monitor, nw_path_monitor_cancel_handler_t cancel_handler)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  nw_path_monitor_t v3 = monitor;
  nw_path_monitor_cancel_handler_t v4 = cancel_handler;
  unsigned int v5 = v4;
  if (!v3)
  {
    char v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v27 = "nw_path_monitor_set_cancel_handler";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "nw_path_monitor_set_cancel_handler";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          int v27 = "nw_path_monitor_set_cancel_handler";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v11) {
          goto LABEL_4;
        }
LABEL_39:
        free(v11);
        goto LABEL_4;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "nw_path_monitor_set_cancel_handler";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "nw_path_monitor_set_cancel_handler";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    id v6 = v4;
    BOOL v7 = v3;
    os_unfair_lock_lock((os_unfair_lock_t)&v3[12]);
    CFAllocatorRef v8 = (objc_class *)_Block_copy(v6);

    Class isa = v7[9].isa;
    v7[9].Class isa = v8;

    os_unfair_lock_unlock((os_unfair_lock_t)&v3[12]);
    goto LABEL_4;
  }
  __int16 v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v27 = "nw_path_monitor_set_cancel_handler";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v11, &type, &v24)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      int v27 = "nw_path_monitor_set_cancel_handler";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null cancel_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      int v27 = "nw_path_monitor_set_cancel_handler";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null cancel_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  int v19 = (char *)__nw_create_backtrace_string();
  uint64_t v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      int v27 = "nw_path_monitor_set_cancel_handler";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s called with null cancel_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    int v27 = "nw_path_monitor_set_cancel_handler";
    __int16 v28 = 2082;
    uint64_t v29 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s called with null cancel_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_39;
  }
LABEL_4:
}

BOOL nw_connection_failed_due_to_blocked_tracker(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v19 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_failed_due_to_blocked_tracker_block_invoke;
    v13[3] = &unk_1E524B978;
    os_log_type_t v15 = buf;
    __int16 v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_failed_due_to_blocked_tracker_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_failed_due_to_blocked_tracker";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_failed_due_to_blocked_tracker";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_failed_due_to_blocked_tracker";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_failed_due_to_blocked_tracker";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_failed_due_to_blocked_tracker";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_connection_failed_due_to_blocked_tracker_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(unsigned char *)(*(void *)(result + 32) + 110) & 1;
  return result;
}

void nw_quic_connection_set_max_stream_data_unidirectional_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_stream_data_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337BE88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 72);
  *(void *)(a2 + 72) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_max_stream_data_bidirectional_remote_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_stream_data_bidirectional_remote_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337C20C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_bidirectional_remote_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 64);
  *(void *)(a2 + 64) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_max_data_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_data_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_set_max_data_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_data_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_set_max_data_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_data_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_max_data_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337C590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_data_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 48);
  *(void *)(a2 + 48) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_local_max_streams_unidirectional_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_local_max_streams_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337C914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_max_streams_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 88);
  *(void *)(a2 + 88) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_local_max_streams_bidirectional_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_local_max_streams_bidirectional_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337CC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_max_streams_bidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 80);
  *(void *)(a2 + 80) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_inject_packet_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_inject_packet_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_inject_packet_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_inject_packet_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_inject_packet_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_inject_packet_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_inject_packet_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337D01C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_inject_packet_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 176);
  *(void *)(a2 + 176) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_peer_idle_timeout_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_peer_idle_timeout_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337D3A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_peer_idle_timeout_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 152);
  *(void *)(a2 + 152) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_local_max_streams_unidirectional_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_local_max_streams_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337D724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_local_max_streams_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 104);
  *(void *)(a2 + 104) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_local_max_streams_bidirectional_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_local_max_streams_bidirectional_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337DAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_local_max_streams_bidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 96);
  *(void *)(a2 + 96) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_keepalive_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_keepalive_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_quic_connection_get_keepalive_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_keepalive_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_quic_connection_get_keepalive_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_keepalive_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_quic_connection_get_keepalive_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18337DE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_keepalive_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  unsigned int v5 = _Block_copy(*(const void **)(a1 + 32));
  id v6 = *(void **)(a2 + 168);
  *(void *)(a2 + 168) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nwsc_get_endpoint_identifier(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 368) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 400) = 0u;
  *(_OWORD *)(a2 + 416) = 0u;
  *(_DWORD *)(a2 + 432) = 0;
  id v4 = nw_endpoint_copy_address_string(v3);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v20 = 136446466;
      uint64_t v21 = "nwsc_get_endpoint_identifier";
      __int16 v22 = 2112;
      os_log_type_t v23 = v3;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s Could not get address string from endpoint %@", (uint8_t *)&v20, 0x16u);
    }
    goto LABEL_35;
  }
  unint64_t v5 = 436;
  id v6 = (unsigned char *)a2;
  while (*v6)
  {
    ++v6;
    if (!--v5) {
      goto LABEL_15;
    }
  }
  if (v5 < 2)
  {
LABEL_14:
    *id v6 = 0;
  }
  else
  {
    uint64_t v8 = 0;
    while (1)
    {
      int v9 = v4[v8];
      v6[v8] = v9;
      if (!v9) {
        break;
      }
      --v5;
      ++v8;
      if (v5 <= 1)
      {
        v6 += v8;
        goto LABEL_14;
      }
    }
  }
LABEL_15:
  free(v4);
  int address_family = nw_endpoint_get_address_family(v3);
  unint64_t v11 = 436;
  os_log_type_t v12 = (char *)a2;
  if (address_family == 30)
  {
    while (*v12)
    {
      ++v12;
      if (!--v11) {
        goto LABEL_28;
      }
    }
    if (v11 < 2) {
      goto LABEL_27;
    }
    char v13 = 46;
    goto LABEL_26;
  }
  while (*v12)
  {
    ++v12;
    if (!--v11) {
      goto LABEL_28;
    }
  }
  if (v11 >= 2)
  {
    char v13 = 58;
LABEL_26:
    *v12++ = v13;
  }
LABEL_27:
  char *v12 = 0;
LABEL_28:
  id v14 = nw_endpoint_copy_port_string(v3);
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v20 = 136446466;
      uint64_t v21 = "nwsc_get_endpoint_identifier";
      __int16 v22 = 2112;
      os_log_type_t v23 = v3;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s Could not get port string from endpoint %@", (uint8_t *)&v20, 0x16u);
    }
LABEL_35:

    uint64_t v16 = 0;
    *(_DWORD *)(a2 + 432) = 0;
    *(_OWORD *)(a2 + 400) = 0u;
    *(_OWORD *)(a2 + 416) = 0u;
    *(_OWORD *)(a2 + 368) = 0u;
    *(_OWORD *)(a2 + 384) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 352) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    goto LABEL_43;
  }
  unint64_t v15 = 436;
  while (*(unsigned char *)a2)
  {
    ++a2;
    if (!--v15) {
      goto LABEL_42;
    }
  }
  if (v15 < 2)
  {
LABEL_41:
    *(unsigned char *)a2 = 0;
  }
  else
  {
    uint64_t v17 = 0;
    while (1)
    {
      int v18 = v14[v17];
      *(unsigned char *)(a2 + v17) = v18;
      if (!v18) {
        break;
      }
      --v15;
      ++v17;
      if (v15 <= 1)
      {
        a2 += v17;
        goto LABEL_41;
      }
    }
  }
LABEL_42:
  free(v14);
  uint64_t v16 = 1;
LABEL_43:

  return v16;
}

void sub_18337E1E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_http_capsule_framer_finalize_output_frames_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(a1 + 32);
  if (v4 == 420171067 && (nw_frame_is_metadata_complete(a2) & 1) != 0) {
    unint64_t v4 = 420171068;
  }
  if (!*(void *)(a1 + 48))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v42 = "nw_http_capsule_framer_write_capsule_header";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v7, type, &v40)) {
      goto LABEL_65;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s called with null protocol";
    }
    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type[0];
      BOOL v12 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (!v12) {
          goto LABEL_90;
        }
        *(_DWORD *)buf = 136446466;
        size_t v42 = "nw_http_capsule_framer_write_capsule_header";
        __int16 v43 = 2082;
        unint64_t v44 = (unint64_t)backtrace_string;
        char v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_89;
      }
      if (!v12) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_63:
    uint64_t v29 = v8;
    os_log_type_t v30 = v9;
LABEL_64:
    _os_log_impl(&dword_1830D4000, v29, v30, v10, buf, 0xCu);
    goto LABEL_65;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v42 = "nw_http_capsule_framer_write_capsule_header";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v7, type, &v40)) {
      goto LABEL_65;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s called with null frame";
      goto LABEL_63;
    }
    if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type[0];
      BOOL v38 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (!v38) {
          goto LABEL_90;
        }
        *(_DWORD *)buf = 136446466;
        size_t v42 = "nw_http_capsule_framer_write_capsule_header";
        __int16 v43 = 2082;
        unint64_t v44 = (unint64_t)backtrace_string;
        char v13 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_89:
        _os_log_impl(&dword_1830D4000, v8, v9, v13, buf, 0x16u);
LABEL_90:
        free(backtrace_string);
        if (!v7) {
          return 1;
        }
        goto LABEL_66;
      }
      if (!v38) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    goto LABEL_63;
  }
  if ((*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    unsigned int v5 = 0;
    if (v4 < 0x40) {
      goto LABEL_10;
    }
LABEL_24:
    if (v4 >= 0x4000)
    {
      if (v4 >> 30)
      {
        if (v4 >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          size_t v42 = "_http_vle_length";
          __int16 v43 = 2048;
          unint64_t v44 = v4;
          id v14 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v14);
          if (result) {
            goto LABEL_100;
          }
          free(v14);
          int v6 = 0;
        }
        else
        {
          int v6 = 8;
        }
      }
      else
      {
        int v6 = 4;
      }
    }
    else
    {
      int v6 = 2;
    }
    goto LABEL_32;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 48);
  if (v4 >= 0x40) {
    goto LABEL_24;
  }
LABEL_10:
  int v6 = 1;
LABEL_32:
  if (v5 >> 30) {
    int v16 = 8;
  }
  else {
    int v16 = 4;
  }
  if (v5 >= 0x4000) {
    int v17 = v16;
  }
  else {
    int v17 = 2;
  }
  if (v5 >= 0x40) {
    int v18 = v17;
  }
  else {
    int v18 = 1;
  }
  unsigned int v19 = v18 + v6;
  nw_frame_unclaim(a2, a2, v18 + v6, 0);
  if (!*(void *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    goto LABEL_50;
  }
  int v20 = *(_DWORD *)(a2 + 52);
  uint64_t v21 = *(unsigned int *)(a2 + 56);
  if (!v20)
  {
    int v22 = 0;
    uint64_t v23 = *(void *)(a2 + 112);
    if (v23) {
      goto LABEL_47;
    }
    goto LABEL_50;
  }
  int v22 = v20 - (v21 + *(_DWORD *)(a2 + 60));
  uint64_t v23 = *(void *)(a2 + 112);
  if (!v23)
  {
LABEL_50:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    size_t v42 = "nw_http_capsule_framer_write_capsule_header";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v7, type, &v40)) {
      goto LABEL_65;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s Unable to fillout capsule header because nw_frame_unclaimed_bytes() returned NULL";
      goto LABEL_63;
    }
    if (!v40)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s Unable to fillout capsule header because nw_frame_unclaimed_bytes() returned NULL, backtrace limit exceeded";
      goto LABEL_63;
    }
    os_log_type_t v25 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v26 = gLogObj;
    os_log_type_t v27 = type[0];
    BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v25)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        size_t v42 = "nw_http_capsule_framer_write_capsule_header";
        __int16 v43 = 2082;
        unint64_t v44 = (unint64_t)v25;
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s Unable to fillout capsule header because nw_frame_unclaimed_bytes() returned NULL, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v25);
    }
    else if (v28)
    {
      *(_DWORD *)buf = 136446210;
      size_t v42 = "nw_http_capsule_framer_write_capsule_header";
      os_log_type_t v10 = "%{public}s Unable to fillout capsule header because nw_frame_unclaimed_bytes() returned NULL, no backtrace";
      uint64_t v29 = v26;
      os_log_type_t v30 = v27;
      goto LABEL_64;
    }
LABEL_65:
    if (!v7) {
      return 1;
    }
LABEL_66:
    free(v7);
    return 1;
  }
LABEL_47:
  *(void *)os_log_type_t type = 0;
  if (v4 <= 0x3F)
  {
    *(void *)os_log_type_t type = v4;
    unsigned int v24 = 1;
LABEL_75:
    size_t v32 = (char *)(v23 + v21);
    size_t v33 = v22 - v19;
    uint64_t v34 = v24;
    memcpy(v32, type, v24);
    if (v33 > 0x3F)
    {
      if (v33 >> 14)
      {
        if (v33 >> 30)
        {
          *(void *)os_log_type_t type = bswap64(v33 | 0xC000000000000000);
          unsigned int v35 = 8;
        }
        else
        {
          *(void *)os_log_type_t type = bswap32(v33 | 0x80000000);
          unsigned int v35 = 4;
        }
      }
      else
      {
        *(void *)os_log_type_t type = bswap32(v33 | 0x4000) >> 16;
        unsigned int v35 = 2;
      }
    }
    else
    {
      *(void *)os_log_type_t type = v22 - v19;
      unsigned int v35 = 1;
    }
    memcpy(&v32[v34], type, v35);
    unsigned int v36 = v35 + v34;
    if (v36 < v19)
    {
      memmove(&v32[v36], &v32[v19], v33);
      nw_frame_claim(a2, v37, 0, v19 - v36);
    }
    return 1;
  }
  if (!(v4 >> 14))
  {
    *(void *)os_log_type_t type = bswap32(v4 | 0x4000) >> 16;
    unsigned int v24 = 2;
    goto LABEL_75;
  }
  if (!(v4 >> 30))
  {
    *(void *)os_log_type_t type = bswap32(v4 | 0x80000000);
    unsigned int v24 = 4;
    goto LABEL_75;
  }
  if (!(v4 >> 62))
  {
    *(void *)os_log_type_t type = bswap64(v4 | 0xC000000000000000);
    unsigned int v24 = 8;
    goto LABEL_75;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  size_t v42 = "_http_vle_encode";
  __int16 v43 = 2048;
  unint64_t v44 = v4;
  uint64_t v31 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v31);
  if (!result)
  {
    free(v31);
    unsigned int v24 = 0;
    goto LABEL_75;
  }
LABEL_100:
  __break(1u);
  return result;
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2_30(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (a3 <= 0x3F)
  {
    unint64_t __src = a3;
    size_t v10 = 1;
    goto LABEL_9;
  }
  if (!(a3 >> 14))
  {
    unint64_t __src = bswap32(a3 | 0x4000) >> 16;
    size_t v10 = 2;
    goto LABEL_9;
  }
  if (!(a3 >> 30))
  {
    unint64_t __src = bswap32(a3 | 0x80000000);
    size_t v10 = 4;
    goto LABEL_9;
  }
  if (!(a3 >> 62))
  {
    unint64_t __src = bswap64(a3 | 0xC000000000000000);
    size_t v10 = 8;
LABEL_9:
    uint64_t v11 = a1 + 32;
    BOOL v12 = *(char **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v13 = a1 + 40;
    if (v12)
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
      if (*(void *)(v14 + 24) >= v10)
      {
        memcpy(v12, &__src, v10);
        unint64_t v15 = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = v15 - v10;
        if (v15 < v10)
        {
          if (gLogDatapath)
          {
            uint64_t v60 = __nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v61 = *(void *)(v14 + 24);
              *(_DWORD *)buf = 136446978;
              size_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              os_log_type_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = v10;
              __int16 v88 = 2048;
              uint64_t v89 = v61;
              _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v14 + 24) = 0;
        }
        int v16 = &v12[v10];
        goto LABEL_15;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      unsigned int v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (!__nwlog_fault(v35, &type, &v80)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (!v80)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v62 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = backtrace_string;
        char v59 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_124;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      unsigned int v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (!__nwlog_fault(v35, &type, &v80)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null buffer";
LABEL_194:
          _os_log_impl(&dword_1830D4000, v36, v37, v38, buf, 0xCu);
        }
LABEL_195:
        if (v35) {
          free(v35);
        }
        int v16 = 0;
        goto LABEL_15;
      }
      if (!v80)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v58 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = backtrace_string;
        char v59 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_124:
        _os_log_impl(&dword_1830D4000, v36, v37, v59, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_195;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  size_t v83 = "_http_vle_encode";
  __int16 v84 = 2048;
  os_log_type_t v85 = (const char *)a3;
  BOOL v28 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v28)) {
    goto LABEL_220;
  }
  free(v28);
  uint64_t v29 = *(void *)(a1 + 32);
  uint64_t v11 = a1 + 32;
  int v16 = *(char **)(*(void *)(v29 + 8) + 24);
  uint64_t v13 = v11 + 8;
LABEL_15:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v16;
  int v17 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke_2";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (!__nwlog_fault(v31, &type, &v80)) {
      goto LABEL_184;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
LABEL_183:
      _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0xCu);
      goto LABEL_184;
    }
    if (!v80)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }
    char v51 = (char *)__nw_create_backtrace_string();
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v52 = os_log_type_enabled(v32, type);
    if (!v51)
    {
      if (!v52) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }
    if (!v52) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)buf = 136446466;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    __int16 v84 = 2082;
    os_log_type_t v85 = v51;
    _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    goto LABEL_107;
  }
  if (a3)
  {
    if (a2)
    {
      uint64_t v18 = *(void *)(*(void *)v13 + 8);
      if (*(void *)(v18 + 24) >= a3)
      {
        memcpy(v17, a2, a3);
        unint64_t v19 = *(void *)(v18 + 24);
        *(void *)(v18 + 24) = v19 - a3;
        if (v19 < a3)
        {
          if (gLogDatapath)
          {
            size_t v70 = __nwlog_obj();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v71 = *(void *)(v18 + 24);
              *(_DWORD *)buf = 136446978;
              size_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              os_log_type_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = a3;
              __int16 v88 = 2048;
              uint64_t v89 = v71;
              _os_log_impl(&dword_1830D4000, v70, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v18 + 24) = 0;
        }
        v17 += a3;
        goto LABEL_23;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v43, &__src, &type)) {
        goto LABEL_209;
      }
      if (__src == 17)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      size_t v67 = (char *)__nw_create_backtrace_string();
      unint64_t v44 = __nwlog_obj();
      os_log_type_t v45 = __src;
      BOOL v72 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (v72)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v67;
        BOOL v69 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_143;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v43, &__src, &type)) {
        goto LABEL_209;
      }
      if (__src == 17)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null data";
LABEL_208:
          _os_log_impl(&dword_1830D4000, v44, v45, v46, buf, 0xCu);
        }
LABEL_209:
        if (v43) {
          free(v43);
        }
        int v17 = 0;
        goto LABEL_23;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      size_t v67 = (char *)__nw_create_backtrace_string();
      unint64_t v44 = __nwlog_obj();
      os_log_type_t v45 = __src;
      BOOL v68 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null data, no backtrace";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (v68)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v67;
        BOOL v69 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_143:
        _os_log_impl(&dword_1830D4000, v44, v45, v69, buf, 0x16u);
      }
    }
    free(v67);
    goto LABEL_209;
  }
LABEL_23:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v17;
  int v20 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v31, &__src, &type)) {
      goto LABEL_184;
    }
    if (__src == 17)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
      goto LABEL_183;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }
    char v51 = (char *)__nw_create_backtrace_string();
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = __src;
    BOOL v53 = os_log_type_enabled(v32, (os_log_type_t)__src);
    if (!v51)
    {
      if (!v53) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }
    if (!v53) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }
  if (a5 <= 0x3F)
  {
    unint64_t __src = a5;
    size_t v21 = 1;
    goto LABEL_32;
  }
  if (!(a5 >> 14))
  {
    unint64_t __src = bswap32(a5 | 0x4000) >> 16;
    size_t v21 = 2;
    goto LABEL_32;
  }
  if (!(a5 >> 30))
  {
    unint64_t __src = bswap32(a5 | 0x80000000);
    size_t v21 = 4;
    goto LABEL_32;
  }
  if (a5 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    size_t v83 = "_http_vle_encode";
    __int16 v84 = 2048;
    os_log_type_t v85 = (const char *)a5;
    os_log_type_t v30 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v30))
    {
      free(v30);
      unsigned int v24 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
      goto LABEL_37;
    }
LABEL_220:
    __break(1u);
    return;
  }
  unint64_t __src = bswap64(a5 | 0xC000000000000000);
  size_t v21 = 8;
LABEL_32:
  uint64_t v22 = *(void *)(*(void *)v13 + 8);
  if (*(void *)(v22 + 24) >= v21)
  {
    memcpy(v20, &__src, v21);
    unint64_t v23 = *(void *)(v22 + 24);
    *(void *)(v22 + 24) = v23 - v21;
    if (v23 < v21)
    {
      if (gLogDatapath)
      {
        nw_txt_record_t v63 = __nwlog_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = *(void *)(v22 + 24);
          *(_DWORD *)buf = 136446978;
          size_t v83 = "_http_safe_append";
          __int16 v84 = 2082;
          os_log_type_t v85 = "*remaining";
          __int16 v86 = 2048;
          size_t v87 = v21;
          __int16 v88 = 2048;
          uint64_t v89 = v64;
          _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
        }
      }
      *(void *)(v22 + 24) = 0;
    }
    unsigned int v24 = &v20[v21];
    goto LABEL_37;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  size_t v83 = "_http_safe_append";
  uint64_t v39 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v80 = 0;
  if (__nwlog_fault(v39, &type, &v80))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v83 = "_http_safe_append";
        size_t v42 = "%{public}s called with null (*remaining >= length)";
LABEL_200:
        _os_log_impl(&dword_1830D4000, v40, v41, v42, buf, 0xCu);
      }
    }
    else if (v80)
    {
      BOOL v65 = (char *)__nw_create_backtrace_string();
      char v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      BOOL v66 = os_log_type_enabled(v40, type);
      if (v65)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          size_t v83 = "_http_safe_append";
          __int16 v84 = 2082;
          os_log_type_t v85 = v65;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v65);
        goto LABEL_201;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        size_t v83 = "_http_safe_append";
        size_t v42 = "%{public}s called with null (*remaining >= length), no backtrace";
        goto LABEL_200;
      }
    }
    else
    {
      char v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v83 = "_http_safe_append";
        size_t v42 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
        goto LABEL_200;
      }
    }
  }
LABEL_201:
  if (v39) {
    free(v39);
  }
  unsigned int v24 = 0;
LABEL_37:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v24;
  os_log_type_t v25 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (v25)
  {
    if (!a5) {
      goto LABEL_45;
    }
    if (a4)
    {
      uint64_t v26 = *(void *)(*(void *)v13 + 8);
      if (*(void *)(v26 + 24) >= a5)
      {
        memcpy(v25, a4, a5);
        unint64_t v27 = *(void *)(v26 + 24);
        *(void *)(v26 + 24) = v27 - a5;
        if (v27 < a5)
        {
          if (gLogDatapath)
          {
            BOOL v76 = __nwlog_obj();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v77 = *(void *)(v26 + 24);
              *(_DWORD *)buf = 136446978;
              size_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              os_log_type_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = a5;
              __int16 v88 = 2048;
              uint64_t v89 = v77;
              _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v26 + 24) = 0;
        }
        v25 += a5;
        goto LABEL_45;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      char v47 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v47, &__src, &type)) {
        goto LABEL_217;
      }
      if (__src == 17)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      os_log_type_t v73 = (char *)__nw_create_backtrace_string();
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v49 = __src;
      BOOL v78 = os_log_type_enabled(v48, (os_log_type_t)__src);
      if (!v73)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v73;
        os_log_type_t v75 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_155;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      char v47 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v47, &__src, &type)) {
        goto LABEL_217;
      }
      if (__src == 17)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null data";
LABEL_216:
          _os_log_impl(&dword_1830D4000, v48, v49, v50, buf, 0xCu);
        }
LABEL_217:
        if (v47) {
          free(v47);
        }
        os_log_type_t v25 = 0;
LABEL_45:
        *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v25;
        if (*(void *)(*(void *)(*(void *)v11 + 8) + 24)) {
          return;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
        uint64_t v31 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(__src) = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v31, &__src, &type))
        {
          if (__src == 17)
          {
            size_t v32 = __nwlog_obj();
            os_log_type_t v33 = __src;
            if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
              goto LABEL_184;
            }
            *(_DWORD *)buf = 136446210;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            uint64_t v34 = "%{public}s called with null cursor";
            goto LABEL_183;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            size_t v32 = __nwlog_obj();
            os_log_type_t v33 = __src;
            if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
              goto LABEL_184;
            }
            *(_DWORD *)buf = 136446210;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
            goto LABEL_183;
          }
          char v55 = (char *)__nw_create_backtrace_string();
          size_t v32 = __nwlog_obj();
          os_log_type_t v33 = __src;
          BOOL v56 = os_log_type_enabled(v32, (os_log_type_t)__src);
          if (!v55)
          {
            if (!v56) {
              goto LABEL_184;
            }
            *(_DWORD *)buf = 136446210;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            uint64_t v34 = "%{public}s called with null cursor, no backtrace";
            goto LABEL_183;
          }
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            __int16 v84 = 2082;
            os_log_type_t v85 = v55;
            _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v55);
        }
LABEL_184:
        if (v31) {
          goto LABEL_185;
        }
        return;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      os_log_type_t v73 = (char *)__nw_create_backtrace_string();
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v49 = __src;
      BOOL v74 = os_log_type_enabled(v48, (os_log_type_t)__src);
      if (!v73)
      {
        if (v74)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null data, no backtrace";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (v74)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v73;
        os_log_type_t v75 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_155:
        _os_log_impl(&dword_1830D4000, v48, v49, v75, buf, 0x16u);
      }
    }
    free(v73);
    goto LABEL_217;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
  uint64_t v31 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v80 = 0;
  if (!__nwlog_fault(v31, &type, &v80)) {
    goto LABEL_184;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_184;
    }
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v34 = "%{public}s called with null cursor";
    goto LABEL_183;
  }
  if (!v80)
  {
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_184;
    }
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
    goto LABEL_183;
  }
  char v51 = (char *)__nw_create_backtrace_string();
  size_t v32 = __nwlog_obj();
  os_log_type_t v33 = type;
  BOOL v54 = os_log_type_enabled(v32, type);
  if (!v51)
  {
    if (!v54) {
      goto LABEL_184;
    }
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v34 = "%{public}s called with null cursor, no backtrace";
    goto LABEL_183;
  }
  if (v54) {
    goto LABEL_106;
  }
LABEL_107:
  free(v51);
  if (v31) {
LABEL_185:
  }
    free(v31);
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (a3 <= 0x3F)
  {
    unint64_t __src = a3;
    size_t v10 = 1;
    goto LABEL_9;
  }
  if (!(a3 >> 14))
  {
    unint64_t __src = bswap32(a3 | 0x4000) >> 16;
    size_t v10 = 2;
    goto LABEL_9;
  }
  if (!(a3 >> 30))
  {
    unint64_t __src = bswap32(a3 | 0x80000000);
    size_t v10 = 4;
    goto LABEL_9;
  }
  if (!(a3 >> 62))
  {
    unint64_t __src = bswap64(a3 | 0xC000000000000000);
    size_t v10 = 8;
LABEL_9:
    uint64_t v11 = a1 + 32;
    BOOL v12 = *(char **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v13 = a1 + 40;
    if (v12)
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
      if (*(void *)(v14 + 24) >= v10)
      {
        memcpy(v12, &__src, v10);
        unint64_t v15 = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = v15 - v10;
        if (v15 < v10)
        {
          if (gLogDatapath)
          {
            uint64_t v60 = __nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v61 = *(void *)(v14 + 24);
              *(_DWORD *)buf = 136446978;
              size_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              os_log_type_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = v10;
              __int16 v88 = 2048;
              uint64_t v89 = v61;
              _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v14 + 24) = 0;
        }
        int v16 = &v12[v10];
        goto LABEL_15;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      unsigned int v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (!__nwlog_fault(v35, &type, &v80)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (!v80)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v62 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = backtrace_string;
        char v59 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_124;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      unsigned int v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (!__nwlog_fault(v35, &type, &v80)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null buffer";
LABEL_194:
          _os_log_impl(&dword_1830D4000, v36, v37, v38, buf, 0xCu);
        }
LABEL_195:
        if (v35) {
          free(v35);
        }
        int v16 = 0;
        goto LABEL_15;
      }
      if (!v80)
      {
        unsigned int v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v58 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          BOOL v38 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = backtrace_string;
        char v59 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_124:
        _os_log_impl(&dword_1830D4000, v36, v37, v59, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_195;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  size_t v83 = "_http_vle_encode";
  __int16 v84 = 2048;
  os_log_type_t v85 = (const char *)a3;
  BOOL v28 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v28)) {
    goto LABEL_220;
  }
  free(v28);
  uint64_t v29 = *(void *)(a1 + 32);
  uint64_t v11 = a1 + 32;
  int v16 = *(char **)(*(void *)(v29 + 8) + 24);
  uint64_t v13 = v11 + 8;
LABEL_15:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v16;
  int v17 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke_2";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (!__nwlog_fault(v31, &type, &v80)) {
      goto LABEL_184;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
LABEL_183:
      _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0xCu);
      goto LABEL_184;
    }
    if (!v80)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }
    char v51 = (char *)__nw_create_backtrace_string();
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v52 = os_log_type_enabled(v32, type);
    if (!v51)
    {
      if (!v52) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }
    if (!v52) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)buf = 136446466;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    __int16 v84 = 2082;
    os_log_type_t v85 = v51;
    _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    goto LABEL_107;
  }
  if (a3)
  {
    if (a2)
    {
      uint64_t v18 = *(void *)(*(void *)v13 + 8);
      if (*(void *)(v18 + 24) >= a3)
      {
        memcpy(v17, a2, a3);
        unint64_t v19 = *(void *)(v18 + 24);
        *(void *)(v18 + 24) = v19 - a3;
        if (v19 < a3)
        {
          if (gLogDatapath)
          {
            size_t v70 = __nwlog_obj();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v71 = *(void *)(v18 + 24);
              *(_DWORD *)buf = 136446978;
              size_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              os_log_type_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = a3;
              __int16 v88 = 2048;
              uint64_t v89 = v71;
              _os_log_impl(&dword_1830D4000, v70, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v18 + 24) = 0;
        }
        v17 += a3;
        goto LABEL_23;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v43, &__src, &type)) {
        goto LABEL_209;
      }
      if (__src == 17)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      size_t v67 = (char *)__nw_create_backtrace_string();
      unint64_t v44 = __nwlog_obj();
      os_log_type_t v45 = __src;
      BOOL v72 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (v72)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v67;
        BOOL v69 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_143;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v43, &__src, &type)) {
        goto LABEL_209;
      }
      if (__src == 17)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null data";
LABEL_208:
          _os_log_impl(&dword_1830D4000, v44, v45, v46, buf, 0xCu);
        }
LABEL_209:
        if (v43) {
          free(v43);
        }
        int v17 = 0;
        goto LABEL_23;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        unint64_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      size_t v67 = (char *)__nw_create_backtrace_string();
      unint64_t v44 = __nwlog_obj();
      os_log_type_t v45 = __src;
      BOOL v68 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          unsigned __int8 v46 = "%{public}s called with null data, no backtrace";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (v68)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v67;
        BOOL v69 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_143:
        _os_log_impl(&dword_1830D4000, v44, v45, v69, buf, 0x16u);
      }
    }
    free(v67);
    goto LABEL_209;
  }
LABEL_23:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v17;
  int v20 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v31, &__src, &type)) {
      goto LABEL_184;
    }
    if (__src == 17)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
      goto LABEL_183;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      size_t v32 = __nwlog_obj();
      os_log_type_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }
    char v51 = (char *)__nw_create_backtrace_string();
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = __src;
    BOOL v53 = os_log_type_enabled(v32, (os_log_type_t)__src);
    if (!v51)
    {
      if (!v53) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }
    if (!v53) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }
  if (a5 <= 0x3F)
  {
    unint64_t __src = a5;
    size_t v21 = 1;
    goto LABEL_32;
  }
  if (!(a5 >> 14))
  {
    unint64_t __src = bswap32(a5 | 0x4000) >> 16;
    size_t v21 = 2;
    goto LABEL_32;
  }
  if (!(a5 >> 30))
  {
    unint64_t __src = bswap32(a5 | 0x80000000);
    size_t v21 = 4;
    goto LABEL_32;
  }
  if (a5 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    size_t v83 = "_http_vle_encode";
    __int16 v84 = 2048;
    os_log_type_t v85 = (const char *)a5;
    os_log_type_t v30 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v30))
    {
      free(v30);
      unsigned int v24 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
      goto LABEL_37;
    }
LABEL_220:
    __break(1u);
    return;
  }
  unint64_t __src = bswap64(a5 | 0xC000000000000000);
  size_t v21 = 8;
LABEL_32:
  uint64_t v22 = *(void *)(*(void *)v13 + 8);
  if (*(void *)(v22 + 24) >= v21)
  {
    memcpy(v20, &__src, v21);
    unint64_t v23 = *(void *)(v22 + 24);
    *(void *)(v22 + 24) = v23 - v21;
    if (v23 < v21)
    {
      if (gLogDatapath)
      {
        nw_txt_record_t v63 = __nwlog_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = *(void *)(v22 + 24);
          *(_DWORD *)buf = 136446978;
          size_t v83 = "_http_safe_append";
          __int16 v84 = 2082;
          os_log_type_t v85 = "*remaining";
          __int16 v86 = 2048;
          size_t v87 = v21;
          __int16 v88 = 2048;
          uint64_t v89 = v64;
          _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
        }
      }
      *(void *)(v22 + 24) = 0;
    }
    unsigned int v24 = &v20[v21];
    goto LABEL_37;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  size_t v83 = "_http_safe_append";
  uint64_t v39 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v80 = 0;
  if (__nwlog_fault(v39, &type, &v80))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v83 = "_http_safe_append";
        size_t v42 = "%{public}s called with null (*remaining >= length)";
LABEL_200:
        _os_log_impl(&dword_1830D4000, v40, v41, v42, buf, 0xCu);
      }
    }
    else if (v80)
    {
      BOOL v65 = (char *)__nw_create_backtrace_string();
      char v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      BOOL v66 = os_log_type_enabled(v40, type);
      if (v65)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          size_t v83 = "_http_safe_append";
          __int16 v84 = 2082;
          os_log_type_t v85 = v65;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v65);
        goto LABEL_201;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        size_t v83 = "_http_safe_append";
        size_t v42 = "%{public}s called with null (*remaining >= length), no backtrace";
        goto LABEL_200;
      }
    }
    else
    {
      char v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v83 = "_http_safe_append";
        size_t v42 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
        goto LABEL_200;
      }
    }
  }
LABEL_201:
  if (v39) {
    free(v39);
  }
  unsigned int v24 = 0;
LABEL_37:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v24;
  os_log_type_t v25 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (v25)
  {
    if (!a5) {
      goto LABEL_45;
    }
    if (a4)
    {
      uint64_t v26 = *(void *)(*(void *)v13 + 8);
      if (*(void *)(v26 + 24) >= a5)
      {
        memcpy(v25, a4, a5);
        unint64_t v27 = *(void *)(v26 + 24);
        *(void *)(v26 + 24) = v27 - a5;
        if (v27 < a5)
        {
          if (gLogDatapath)
          {
            BOOL v76 = __nwlog_obj();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v77 = *(void *)(v26 + 24);
              *(_DWORD *)buf = 136446978;
              size_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              os_log_type_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = a5;
              __int16 v88 = 2048;
              uint64_t v89 = v77;
              _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v26 + 24) = 0;
        }
        v25 += a5;
        goto LABEL_45;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      char v47 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v47, &__src, &type)) {
        goto LABEL_217;
      }
      if (__src == 17)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      os_log_type_t v73 = (char *)__nw_create_backtrace_string();
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v49 = __src;
      BOOL v78 = os_log_type_enabled(v48, (os_log_type_t)__src);
      if (!v73)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v73;
        os_log_type_t v75 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_155;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v83 = "_http_safe_append";
      char v47 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v47, &__src, &type)) {
        goto LABEL_217;
      }
      if (__src == 17)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null data";
LABEL_216:
          _os_log_impl(&dword_1830D4000, v48, v49, v50, buf, 0xCu);
        }
LABEL_217:
        if (v47) {
          free(v47);
        }
        os_log_type_t v25 = 0;
LABEL_45:
        *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v25;
        if (*(void *)(*(void *)(*(void *)v11 + 8) + 24)) {
          return;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
        uint64_t v31 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(__src) = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v31, &__src, &type))
        {
          if (__src == 17)
          {
            size_t v32 = __nwlog_obj();
            os_log_type_t v33 = __src;
            if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
              goto LABEL_184;
            }
            *(_DWORD *)buf = 136446210;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            uint64_t v34 = "%{public}s called with null cursor";
            goto LABEL_183;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            size_t v32 = __nwlog_obj();
            os_log_type_t v33 = __src;
            if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
              goto LABEL_184;
            }
            *(_DWORD *)buf = 136446210;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
            goto LABEL_183;
          }
          char v55 = (char *)__nw_create_backtrace_string();
          size_t v32 = __nwlog_obj();
          os_log_type_t v33 = __src;
          BOOL v56 = os_log_type_enabled(v32, (os_log_type_t)__src);
          if (!v55)
          {
            if (!v56) {
              goto LABEL_184;
            }
            *(_DWORD *)buf = 136446210;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            uint64_t v34 = "%{public}s called with null cursor, no backtrace";
            goto LABEL_183;
          }
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
            __int16 v84 = 2082;
            os_log_type_t v85 = v55;
            _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v55);
        }
LABEL_184:
        if (v31) {
          goto LABEL_185;
        }
        return;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      os_log_type_t v73 = (char *)__nw_create_backtrace_string();
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v49 = __src;
      BOOL v74 = os_log_type_enabled(v48, (os_log_type_t)__src);
      if (!v73)
      {
        if (v74)
        {
          *(_DWORD *)buf = 136446210;
          size_t v83 = "_http_safe_append";
          os_log_type_t v50 = "%{public}s called with null data, no backtrace";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (v74)
      {
        *(_DWORD *)buf = 136446466;
        size_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        os_log_type_t v85 = v73;
        os_log_type_t v75 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_155:
        _os_log_impl(&dword_1830D4000, v48, v49, v75, buf, 0x16u);
      }
    }
    free(v73);
    goto LABEL_217;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
  uint64_t v31 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v80 = 0;
  if (!__nwlog_fault(v31, &type, &v80)) {
    goto LABEL_184;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_184;
    }
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v34 = "%{public}s called with null cursor";
    goto LABEL_183;
  }
  if (!v80)
  {
    size_t v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_184;
    }
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
    goto LABEL_183;
  }
  char v51 = (char *)__nw_create_backtrace_string();
  size_t v32 = __nwlog_obj();
  os_log_type_t v33 = type;
  BOOL v54 = os_log_type_enabled(v32, type);
  if (!v51)
  {
    if (!v54) {
      goto LABEL_184;
    }
    *(_DWORD *)buf = 136446210;
    size_t v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v34 = "%{public}s called with null cursor, no backtrace";
    goto LABEL_183;
  }
  if (v54) {
    goto LABEL_106;
  }
LABEL_107:
  free(v51);
  if (v31) {
LABEL_185:
  }
    free(v31);
}

char *__cdecl nw_endpoint_copy_port_string(nw_endpoint_t endpoint)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = endpoint;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    asprintf((char **)buf, "%d", __rev16([v1 port]));
    id v3 = *(char **)buf;
    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
          __int16 v16 = 2082;
          int v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void sub_183381F04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  unsigned int v78 = 0;
  unint64_t v4 = (unsigned char *)nw_frame_unclaimed_bytes(a2, &v78);
  int v6 = v4;
  uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v7 > 8)
  {
    LODWORD(v8) = 0;
  }
  else
  {
    if (!v78)
    {
      LODWORD(v8) = 0;
      goto LABEL_43;
    }
    if (9 - (int)v7 >= v78) {
      size_t v8 = v78;
    }
    else {
      size_t v8 = (9 - v7);
    }
    memcpy(v4, (const void *)(*(void *)(a1 + 56) + v7), v8);
    if (gLogDatapath)
    {
      uint64_t v60 = __nwlog_obj();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v61 = *(void *)(a1 + 64);
        *(_DWORD *)buf = 136446722;
        char v80 = "send_data_callback_block_invoke";
        if (v61) {
          BOOL v62 = (const char *)(v61 + 205);
        }
        else {
          BOOL v62 = "";
        }
        __int16 v81 = 2082;
        char v82 = v62;
        __int16 v83 = 1024;
        LODWORD(v84) = v8;
        _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of frame header", buf, 0x1Cu);
      }
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v8;
    LODWORD(v7) = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  unint64_t v9 = *(void *)(*(void *)(a1 + 72) + 16);
  if (v9)
  {
    if (v7 <= 9)
    {
      if (v78 <= v8) {
        goto LABEL_43;
      }
      v6[v8] = v9 - 1;
      if (gLogDatapath)
      {
        nw_txt_record_t v63 = __nwlog_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = *(void *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          char v80 = "send_data_callback_block_invoke";
          if (v64) {
            BOOL v65 = (const char *)(v64 + 205);
          }
          else {
            BOOL v65 = "";
          }
          __int16 v81 = 2082;
          char v82 = v65;
          __int16 v83 = 1024;
          LODWORD(v84) = 1;
          _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u byte of padding length", buf, 0x1Cu);
        }
      }
      LODWORD(v8) = v8 + 1;
      LODWORD(v7) = ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      unint64_t v9 = *(void *)(*(void *)(a1 + 72) + 16);
    }
    if (v7 >= *(_DWORD *)(a1 + 112) + ~v9) {
      goto LABEL_24;
    }
    unsigned int v10 = v78 - v8;
    if (v78 <= v8) {
      goto LABEL_43;
    }
    int v11 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    unsigned int v77 = 0;
    uint64_t v12 = *(void *)(a1 + 80);
    char v13 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 88), &v77);
    if (v13)
    {
      unsigned int v14 = v12 - v11;
      if ((int)v12 - v11 >= v10) {
        unsigned int v14 = v10;
      }
      if (v14 >= v77) {
        size_t v15 = v77;
      }
      else {
        size_t v15 = v14;
      }
      memcpy(&v6[v8], v13, v15);
      if (gLogDatapath)
      {
        BOOL v69 = __nwlog_obj();
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v70 = *(void *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          char v80 = "send_data_callback_block_invoke";
          if (v70) {
            uint64_t v71 = (const char *)(v70 + 205);
          }
          else {
            uint64_t v71 = "";
          }
          __int16 v81 = 2082;
          char v82 = v71;
          __int16 v83 = 1024;
          LODWORD(v84) = v15;
          _os_log_impl(&dword_1830D4000, v69, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of body data (padding)", buf, 0x1Cu);
        }
      }
      nw_frame_claim(*(void *)(a1 + 88), v16, v15, 0);
      LODWORD(v8) = v15 + v8;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v15;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v15;
      unint64_t v9 = *(void *)(*(void *)(a1 + 72) + 16);
LABEL_24:
      if (v9 >= 2)
      {
        unsigned int v17 = v78 - v8;
        if (v78 > v8)
        {
          unsigned int v18 = ~*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) + v9;
          if (v18 >= v17) {
            size_t v19 = v17;
          }
          else {
            size_t v19 = v18;
          }
          bzero(&v6[v8], v19);
          if (gLogDatapath)
          {
            BOOL v66 = __nwlog_obj();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v67 = *(void *)(a1 + 64);
              *(_DWORD *)buf = 136446722;
              char v80 = "send_data_callback_block_invoke";
              if (v67) {
                BOOL v68 = (const char *)(v67 + 205);
              }
              else {
                BOOL v68 = "";
              }
              __int16 v81 = 2082;
              char v82 = v68;
              __int16 v83 = 1024;
              LODWORD(v84) = v19;
              _os_log_impl(&dword_1830D4000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of padding", buf, 0x1Cu);
            }
          }
          LODWORD(v8) = v19 + v8;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v19;
          uint64_t v20 = *(void *)(a1 + 48);
LABEL_41:
          *(_DWORD *)(*(void *)(v20 + 8) + 24) += v19;
        }
      }
LABEL_43:
      nw_frame_claim(a2, v5, v8, 0);
      nw_frame_collapse(a2);
      nw_frame_unclaim(a2, v27, v8, 0);
      uint64_t v29 = *(void *)(a2 + 32);
      os_log_type_t v30 = *(void **)(a2 + 40);
      BOOL v28 = (void *)(a2 + 32);
      if (v29)
      {
        *(void *)(v29 + 40) = v30;
        os_log_type_t v30 = *(void **)(a2 + 40);
      }
      else
      {
        *(void *)(*(void *)(a1 + 96) + 8) = v30;
      }
      *os_log_type_t v30 = v29;
      void *v28 = 0;
      *(void *)(a2 + 40) = 0;
      uint64_t v31 = *(void *)(a1 + 104);
      size_t v32 = *(uint64_t **)(v31 + 8);
      *(void *)(a2 + 40) = v32;
      *size_t v32 = a2;
      *(void *)(v31 + 8) = v28;
      if (gLogDatapath)
      {
        uint64_t v57 = __nwlog_obj();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v58 = *(void *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          char v80 = "send_data_callback_block_invoke";
          if (v58) {
            char v59 = (const char *)(v58 + 205);
          }
          else {
            char v59 = "";
          }
          __int16 v81 = 2082;
          char v82 = v59;
          __int16 v83 = 1024;
          LODWORD(v84) = v8;
          _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s copied %u bytes into output frame", buf, 0x1Cu);
        }
      }
      return 1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v34 = *(void *)(a1 + 64);
    if (v34) {
      unsigned int v35 = (const char *)(v34 + 205);
    }
    else {
      unsigned int v35 = "";
    }
    *(_DWORD *)buf = 136446466;
    char v80 = "send_data_callback_block_invoke";
    __int16 v81 = 2082;
    char v82 = v35;
    unsigned int v36 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (!__nwlog_fault(v36, &type, &v75)) {
      goto LABEL_100;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v37 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v37, type))
      {
        uint64_t v39 = *(void *)(a1 + 64);
        if (v39) {
          char v40 = (const char *)(v39 + 205);
        }
        else {
          char v40 = "";
        }
LABEL_57:
        *(_DWORD *)buf = 136446466;
        char v80 = "send_data_callback_block_invoke";
        __int16 v81 = 2082;
        char v82 = v40;
        os_log_type_t v41 = "%{public}s %{public}s unexpected NULL in source frame";
LABEL_99:
        _os_log_impl(&dword_1830D4000, v37, v38, v41, buf, 0x16u);
        goto LABEL_100;
      }
      goto LABEL_100;
    }
    if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v37 = __nwlog_obj();
      os_log_type_t v38 = type;
      BOOL v46 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v46)
        {
          uint64_t v47 = *(void *)(a1 + 64);
          if (v47) {
            uint64_t v48 = (const char *)(v47 + 205);
          }
          else {
            uint64_t v48 = "";
          }
LABEL_79:
          *(_DWORD *)buf = 136446722;
          char v80 = "send_data_callback_block_invoke";
          __int16 v81 = 2082;
          char v82 = v48;
          __int16 v83 = 2082;
          __int16 v84 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s %{public}s unexpected NULL in source frame, dumping backtrace:%{public}s", buf, 0x20u);
          goto LABEL_80;
        }
        goto LABEL_80;
      }
      if (!v46) {
        goto LABEL_100;
      }
      uint64_t v54 = *(void *)(a1 + 64);
      if (v54) {
        char v55 = (const char *)(v54 + 205);
      }
      else {
        char v55 = "";
      }
      goto LABEL_98;
    }
    os_log_type_t v37 = __nwlog_obj();
    os_log_type_t v38 = type;
    if (!os_log_type_enabled(v37, type)) {
      goto LABEL_100;
    }
    uint64_t v51 = *(void *)(a1 + 64);
    if (v51) {
      BOOL v52 = (const char *)(v51 + 205);
    }
    else {
      BOOL v52 = "";
    }
    goto LABEL_85;
  }
  if (v7 >= *(_DWORD *)(a1 + 112)) {
    goto LABEL_43;
  }
  unsigned int v21 = v78 - v8;
  if (v78 <= v8) {
    goto LABEL_43;
  }
  int v22 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  unsigned int v77 = 0;
  uint64_t v23 = *(void *)(a1 + 80);
  unsigned int v24 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 88), &v77);
  if (v24)
  {
    unsigned int v25 = v23 - v22;
    if ((int)v23 - v22 >= v21) {
      unsigned int v25 = v21;
    }
    if (v25 >= v77) {
      size_t v19 = v77;
    }
    else {
      size_t v19 = v25;
    }
    memcpy(&v6[v8], v24, v19);
    if (gLogDatapath)
    {
      BOOL v72 = __nwlog_obj();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v73 = *(void *)(a1 + 64);
        *(_DWORD *)buf = 136446722;
        char v80 = "send_data_callback_block_invoke";
        if (v73) {
          BOOL v74 = (const char *)(v73 + 205);
        }
        else {
          BOOL v74 = "";
        }
        __int16 v81 = 2082;
        char v82 = v74;
        __int16 v83 = 1024;
        LODWORD(v84) = v19;
        _os_log_impl(&dword_1830D4000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of body data (no padding)", buf, 0x1Cu);
      }
    }
    nw_frame_claim(*(void *)(a1 + 88), v26, v19, 0);
    LODWORD(v8) = v19 + v8;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v19;
    uint64_t v20 = *(void *)(a1 + 40);
    goto LABEL_41;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v42 = *(void *)(a1 + 64);
  if (v42) {
    __int16 v43 = (const char *)(v42 + 205);
  }
  else {
    __int16 v43 = "";
  }
  *(_DWORD *)buf = 136446466;
  char v80 = "send_data_callback_block_invoke";
  __int16 v81 = 2082;
  char v82 = v43;
  unsigned int v36 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v75 = 0;
  if (!__nwlog_fault(v36, &type, &v75)) {
    goto LABEL_100;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v37 = __nwlog_obj();
      os_log_type_t v38 = type;
      BOOL v49 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v49)
        {
          uint64_t v50 = *(void *)(a1 + 64);
          if (v50) {
            uint64_t v48 = (const char *)(v50 + 205);
          }
          else {
            uint64_t v48 = "";
          }
          goto LABEL_79;
        }
LABEL_80:
        free(backtrace_string);
        goto LABEL_100;
      }
      if (!v49) {
        goto LABEL_100;
      }
      uint64_t v56 = *(void *)(a1 + 64);
      if (v56) {
        char v55 = (const char *)(v56 + 205);
      }
      else {
        char v55 = "";
      }
LABEL_98:
      *(_DWORD *)buf = 136446466;
      char v80 = "send_data_callback_block_invoke";
      __int16 v81 = 2082;
      char v82 = v55;
      os_log_type_t v41 = "%{public}s %{public}s unexpected NULL in source frame, no backtrace";
      goto LABEL_99;
    }
    os_log_type_t v37 = __nwlog_obj();
    os_log_type_t v38 = type;
    if (!os_log_type_enabled(v37, type)) {
      goto LABEL_100;
    }
    uint64_t v53 = *(void *)(a1 + 64);
    if (v53) {
      BOOL v52 = (const char *)(v53 + 205);
    }
    else {
      BOOL v52 = "";
    }
LABEL_85:
    *(_DWORD *)buf = 136446466;
    char v80 = "send_data_callback_block_invoke";
    __int16 v81 = 2082;
    char v82 = v52;
    os_log_type_t v41 = "%{public}s %{public}s unexpected NULL in source frame, backtrace limit exceeded";
    goto LABEL_99;
  }
  os_log_type_t v37 = __nwlog_obj();
  os_log_type_t v38 = type;
  if (os_log_type_enabled(v37, type))
  {
    uint64_t v44 = *(void *)(a1 + 64);
    if (v44) {
      char v40 = (const char *)(v44 + 205);
    }
    else {
      char v40 = "";
    }
    goto LABEL_57;
  }
LABEL_100:
  if (v36) {
    free(v36);
  }
  return 0;
}

void nw_protocol_common_output_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_protocol_common_output_finished";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v42)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v45 = "nw_protocol_common_output_finished";
      uint64_t v16 = "%{public}s called with null protocol";
      goto LABEL_44;
    }
    if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v37 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (!v37) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v45 = "nw_protocol_common_output_finished";
        __int16 v46 = 2082;
        uint64_t v47 = backtrace_string;
        os_log_type_t v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_82;
      }
      if (!v37) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v45 = "nw_protocol_common_output_finished";
      uint64_t v16 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      unsigned int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v45 = "nw_protocol_common_output_finished";
      uint64_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_44:
    unsigned int v25 = v14;
    os_log_type_t v26 = v15;
LABEL_45:
    _os_log_impl(&dword_1830D4000, v25, v26, v16, buf, 0xCu);
    goto LABEL_46;
  }
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      unint64_t v4 = *(void **)(v3 + 40);
      if (v4 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v5 = *(void *)(v3 + 88);
        if (v5) {
          *(void *)(v3 + 88) = v5 + 1;
        }
      }
      int v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 88) = v7 + 1;
        }
      }
      uint64_t v8 = *(void *)(v3 + 24);
      if (v8)
      {
        unint64_t v9 = *(void (**)(uint64_t, uint64_t))(v8 + 192);
        if (v9)
        {
          v9(v3, a2);
          goto LABEL_13;
        }
      }
      __nwlog_obj();
      uint64_t v27 = *(const char **)(v3 + 16);
      *(_DWORD *)buf = 136446722;
      os_log_type_t v45 = "__nw_protocol_output_finished";
      if (!v27) {
        uint64_t v27 = "invalid";
      }
      __int16 v46 = 2082;
      uint64_t v47 = (void *)v27;
      __int16 v48 = 2048;
      uint64_t v49 = v3;
      BOOL v28 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v42 = 0;
      if (__nwlog_fault(v28, &type, &v42))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v29 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (!os_log_type_enabled(v29, type)) {
            goto LABEL_98;
          }
          uint64_t v31 = *(const char **)(v3 + 16);
          if (!v31) {
            uint64_t v31 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v45 = "__nw_protocol_output_finished";
          __int16 v46 = 2082;
          uint64_t v47 = (void *)v31;
          __int16 v48 = 2048;
          uint64_t v49 = v3;
          size_t v32 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
          goto LABEL_97;
        }
        if (!v42)
        {
          uint64_t v29 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (!os_log_type_enabled(v29, type)) {
            goto LABEL_98;
          }
          char v40 = *(const char **)(v3 + 16);
          if (!v40) {
            char v40 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v45 = "__nw_protocol_output_finished";
          __int16 v46 = 2082;
          uint64_t v47 = (void *)v40;
          __int16 v48 = 2048;
          uint64_t v49 = v3;
          size_t v32 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
          goto LABEL_97;
        }
        os_log_type_t v33 = (char *)__nw_create_backtrace_string();
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v30 = type;
        BOOL v34 = os_log_type_enabled(v29, type);
        if (v33)
        {
          if (v34)
          {
            unsigned int v35 = *(const char **)(v3 + 16);
            if (!v35) {
              unsigned int v35 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v45 = "__nw_protocol_output_finished";
            __int16 v46 = 2082;
            uint64_t v47 = (void *)v35;
            __int16 v48 = 2048;
            uint64_t v49 = v3;
            __int16 v50 = 2082;
            uint64_t v51 = v33;
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v33);
          goto LABEL_98;
        }
        if (v34)
        {
          os_log_type_t v41 = *(const char **)(v3 + 16);
          if (!v41) {
            os_log_type_t v41 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v45 = "__nw_protocol_output_finished";
          __int16 v46 = 2082;
          uint64_t v47 = (void *)v41;
          __int16 v48 = 2048;
          uint64_t v49 = v3;
          size_t v32 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
LABEL_97:
          _os_log_impl(&dword_1830D4000, v29, v30, v32, buf, 0x20u);
        }
      }
LABEL_98:
      if (v28) {
        free(v28);
      }
LABEL_13:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v21 = *(void *)(a2 + 88);
        if (v21)
        {
          uint64_t v22 = v21 - 1;
          *(void *)(a2 + 88) = v22;
          if (!v22)
          {
            uint64_t v23 = *(void (***)(void))(a2 + 64);
            if (v23)
            {
              *(void *)(a2 + 64) = 0;
              v23[2](v23);
              _Block_release(v23);
            }
            if (*(unsigned char *)(a2 + 72))
            {
              unsigned int v24 = *(const void **)(a2 + 64);
              if (v24) {
                _Block_release(v24);
              }
            }
            free((void *)a2);
          }
        }
      }
      if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = *(void *)(v3 + 88);
        if (v10)
        {
          uint64_t v11 = v10 - 1;
          *(void *)(v3 + 88) = v11;
          if (!v11)
          {
            uint64_t v12 = *(void (***)(void))(v3 + 64);
            if (v12)
            {
              *(void *)(v3 + 64) = 0;
              v12[2](v12);
              _Block_release(v12);
            }
            if (*(unsigned char *)(v3 + 72))
            {
              char v13 = *(const void **)(v3 + 64);
              if (v13) {
                _Block_release(v13);
              }
            }
            goto LABEL_47;
          }
        }
      }
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_protocol_common_output_finished";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_common_output_finished";
        uint64_t v16 = "%{public}s output_finished requires an output handler";
        goto LABEL_44;
      }
      if (!v42)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_common_output_finished";
        uint64_t v16 = "%{public}s output_finished requires an output handler, backtrace limit exceeded";
        goto LABEL_44;
      }
      unsigned int v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v18 = gLogObj;
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v17)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v45 = "nw_protocol_common_output_finished";
          __int16 v46 = 2082;
          uint64_t v47 = v17;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s output_finished requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v17);
        if (v3) {
          goto LABEL_47;
        }
        return;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_common_output_finished";
        uint64_t v16 = "%{public}s output_finished requires an output handler, no backtrace";
        unsigned int v25 = v18;
        os_log_type_t v26 = v19;
        goto LABEL_45;
      }
    }
LABEL_46:
    if (!v3) {
      return;
    }
    goto LABEL_47;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v45 = "nw_protocol_common_output_finished";
  uint64_t v3 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (!__nwlog_fault((const char *)v3, &type, &v42)) {
    goto LABEL_46;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_protocol_common_output_finished";
    uint64_t v16 = "%{public}s called with null other_protocol";
    goto LABEL_44;
  }
  if (!v42)
  {
    unsigned int v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_protocol_common_output_finished";
    uint64_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_44;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  unsigned int v14 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v39 = os_log_type_enabled(v14, type);
  if (!backtrace_string)
  {
    if (!v39) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_protocol_common_output_finished";
    uint64_t v16 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_44;
  }
  if (!v39) {
    goto LABEL_83;
  }
  *(_DWORD *)buf = 136446466;
  os_log_type_t v45 = "nw_protocol_common_output_finished";
  __int16 v46 = 2082;
  uint64_t v47 = backtrace_string;
  os_log_type_t v38 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_82:
  _os_log_impl(&dword_1830D4000, v14, v15, v38, buf, 0x16u);
LABEL_83:
  free(backtrace_string);
  if (v3) {
LABEL_47:
  }
    free((void *)v3);
}

id nw_connection_copy_failed_resolution_report(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    os_log_type_t v19 = __Block_byref_object_copy__7806;
    BOOL v20 = __Block_byref_object_dispose__7807;
    id v21 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_failed_resolution_report_block_invoke;
    v13[3] = &unk_1E524B978;
    os_log_type_t v15 = buf;
    unsigned int v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_failed_resolution_report_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_failed_resolution_report_block_invoke(uint64_t a1)
{
}

id nw_quic_connection_copy_sec_protocol_options(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    char v16 = __Block_byref_object_copy__55989;
    unsigned int v17 = __Block_byref_object_dispose__55990;
    id v18 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_copy_sec_protocol_options_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    id v2 = *(id *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  unint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_options";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_options";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_options";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_options";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_options";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  id v2 = 0;
LABEL_3:

  return v2;
}

void sub_183383C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_resolve_ptr(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[96] >> 5) & 1;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_resolve_ptr";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_resolve_ptr";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_resolve_ptr";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_resolve_ptr";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_resolve_ptr";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_connection_unregister_context(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    int v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_connection_unregister_context";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23)) {
      goto LABEL_38;
    }
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v26 = "nw_connection_unregister_context";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __nw_connection_unregister_context_block_invoke;
    v20[3] = &unk_1E524B9A0;
    id v21 = v3;
    id v22 = v5;
    nw_connection_async_if_needed(v21, v20);

    goto LABEL_4;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v26 = "nw_connection_unregister_context";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23)) {
    goto LABEL_38;
  }
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_connection_unregister_context";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null content_context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_connection_unregister_context";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null content_context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = v24;
  BOOL v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_connection_unregister_context";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null content_context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v26 = "nw_connection_unregister_context";
    __int16 v27 = 2082;
    BOOL v28 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null content_context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183384494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t _s7Network12NWParametersC3tls3tcpAcA13NWProtocolTLSC7OptionsCSg_AA0E3TCPCAHCtcfC_0(uint64_t a1)
{
  type metadata accessor for NWParameters();
  uint64_t v2 = swift_allocObject();
  nw_parameters_t v3 = nw_parameters_create();
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61EA0);
  uint64_t v4 = swift_allocObject();
  *(void *)(v2 + 16) = v4;
  *(_DWORD *)(v4 + 24) = 0;
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 24);
  *(void *)(v4 + 16) = v3;
  int v6 = (void **)(v4 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 24));
  sub_18338471C(v6);
  os_unfair_lock_unlock(v5);
  os_unfair_lock_lock(v5);
  sub_1834A471C(v6, &v20);
  os_unfair_lock_unlock(v5);
  uint64_t v7 = *(void *)(v20 + 16);
  os_log_type_t v8 = (nw_protocol_stack_t *)(v7 + 16);
  os_log_type_t v9 = (os_unfair_lock_s *)(v7 + 24);
  swift_retain_n();
  os_unfair_lock_lock(v9);
  sub_1834A4914(v8);
  os_unfair_lock_unlock(v9);
  swift_retain();
  uint64_t v10 = swift_release_n();
  if (a1)
  {
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F61E50);
    uint64_t inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_183D569A0;
    *(void *)(inited + 32) = a1;
    uint64_t v20 = inited;
    uint64_t v12 = sub_183D44E6C();
    MEMORY[0x1F4188790](v12);
    BOOL v14 = (nw_protocol_stack_t *)(v13 + 16);
    os_log_type_t v15 = (os_unfair_lock_s *)(v13 + 24);
    swift_retain_n();
    os_unfair_lock_lock(v15);
    sub_1834F2C44(v14);
    os_unfair_lock_unlock(v15);
    swift_release();
    swift_release();
    swift_bridgeObjectRelease();
  }
  else
  {
    MEMORY[0x1F4188790](v10);
    BOOL v17 = (nw_protocol_stack_t *)&v16[4];
    os_log_type_t v18 = v16 + 6;
    os_unfair_lock_lock(v16 + 6);
    sub_1834F2C44(v17);
    os_unfair_lock_unlock(v18);
  }
  swift_release();
  swift_release();
  swift_release();
  return v2;
}

void sub_18338471C(void **a1)
{
}

uint64_t nw_browser_add_result_locked(void *a1, const char *a2, void *a3, void *a4, int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v10 = a3;
  os_log_type_t v11 = a4;
  if (v9)
  {
    uint64_t uint64 = xpc_dictionary_get_uint64(*((xpc_object_t *)v9 + 20), a2);
    BOOL v13 = nw_browser_copy_result_to_modify_locked((NWConcrete_nw_browser *)v9, a2, uint64);
    BOOL v14 = (void *)v13;
    if (uint64)
    {
      if (!v11) {
        goto LABEL_26;
      }
      nw_browse_result_set_discovered_from_path((void *)v13, a5);
      if (nw_browse_result_insert_interface(v14, v11))
      {
        xpc_dictionary_set_uint64(*((xpc_object_t *)v9 + 20), a2, uint64 | 8);
        if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          os_log_type_t v15 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            int v16 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            uint64_t v64 = "nw_browser_add_result_locked";
            __int16 v65 = 1024;
            *(_DWORD *)BOOL v66 = v16;
            *(_WORD *)&v66[4] = 2080;
            *(void *)&v66[6] = a2;
            __int16 v67 = 2112;
            BOOL v68 = v11;
            _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s interface_added(%@)", buf, 0x26u);
          }
LABEL_25:
        }
LABEL_26:
        uint64_t v21 = 1;
LABEL_89:

        goto LABEL_90;
      }
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        id v22 = (id)gbrowserLogObj;
        int v23 = *((_DWORD *)v9 + 48);
        *(_DWORD *)buf = 136446978;
        uint64_t v64 = "nw_browser_add_result_locked";
        __int16 v65 = 1024;
        *(_DWORD *)BOOL v66 = v23;
        *(_WORD *)&v66[4] = 2112;
        *(void *)&v66[6] = v11;
        __int16 v67 = 2080;
        BOOL v68 = a2;
        os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v61 = 0;
        if (__nwlog_fault(v24, &type, &v61))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
            }
            unsigned int v25 = (id)gbrowserLogObj;
            os_log_type_t v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              int v27 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              uint64_t v64 = "nw_browser_add_result_locked";
              __int16 v65 = 1024;
              *(_DWORD *)BOOL v66 = v27;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              __int16 v67 = 2080;
              BOOL v68 = a2;
              _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s [B%u] tried to insert duplicate interface %@ for %s", buf, 0x26u);
            }
          }
          else if (v61)
          {
            backtrace_string = __nw_create_backtrace_string();
            if (backtrace_string)
            {
              unsigned int v35 = (char *)backtrace_string;
              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
              }
              unsigned int v36 = (id)gbrowserLogObj;
              os_log_type_t v37 = type;
              if (os_log_type_enabled(v36, type))
              {
                int v38 = *((_DWORD *)v9 + 48);
                *(_DWORD *)buf = 136447234;
                uint64_t v64 = "nw_browser_add_result_locked";
                __int16 v65 = 1024;
                *(_DWORD *)BOOL v66 = v38;
                *(_WORD *)&v66[4] = 2112;
                *(void *)&v66[6] = v11;
                __int16 v67 = 2080;
                BOOL v68 = a2;
                __int16 v69 = 2082;
                uint64_t v70 = v35;
                _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s", buf, 0x30u);
              }

              free(v35);
              if (!v24) {
                goto LABEL_88;
              }
              goto LABEL_74;
            }
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
            }
            unsigned int v25 = (id)gbrowserLogObj;
            os_log_type_t v46 = type;
            if (os_log_type_enabled(v25, type))
            {
              int v47 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              uint64_t v64 = "nw_browser_add_result_locked";
              __int16 v65 = 1024;
              *(_DWORD *)BOOL v66 = v47;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              __int16 v67 = 2080;
              BOOL v68 = a2;
              _os_log_impl(&dword_1830D4000, v25, v46, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, no backtrace", buf, 0x26u);
            }
          }
          else
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
            }
            unsigned int v25 = (id)gbrowserLogObj;
            os_log_type_t v44 = type;
            if (os_log_type_enabled(v25, type))
            {
              int v45 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              uint64_t v64 = "nw_browser_add_result_locked";
              __int16 v65 = 1024;
              *(_DWORD *)BOOL v66 = v45;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              __int16 v67 = 2080;
              BOOL v68 = a2;
              _os_log_impl(&dword_1830D4000, v25, v44, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, backtrace limit exceeded", buf, 0x26u);
            }
          }
        }
        if (v24) {
LABEL_74:
        }
          free(v24);
      }
LABEL_88:
      uint64_t v21 = 0;
      goto LABEL_89;
    }
    os_log_type_t v15 = nw_browse_result_create(v10);
    nw_browse_result_set_discovered_from_path(v15, a5);
    if (!v11 || nw_browse_result_insert_interface(v15, v11))
    {
      nw_array_append(*((void *)v9 + 18), v15);
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        BOOL v17 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          int v18 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446722;
          uint64_t v64 = "nw_browser_add_result_locked";
          __int16 v65 = 1024;
          *(_DWORD *)BOOL v66 = v18;
          *(_WORD *)&v66[4] = 2112;
          *(void *)&v66[6] = v15;
          _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: added %@ to new_results", buf, 0x1Cu);
        }
      }
      xpc_dictionary_set_uint64(*((xpc_object_t *)v9 + 20), a2, 2uLL);
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
        }
        os_log_type_t v19 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          int v20 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446978;
          uint64_t v64 = "nw_browser_add_result_locked";
          __int16 v65 = 1024;
          *(_DWORD *)BOOL v66 = v20;
          *(_WORD *)&v66[4] = 2080;
          *(void *)&v66[6] = a2;
          __int16 v67 = 1024;
          LODWORD(v68) = 2;
          _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s = result_added(%d)", buf, 0x22u);
        }
      }
      goto LABEL_25;
    }
    if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      id v28 = (id)gbrowserLogObj;
      int v29 = *((_DWORD *)v9 + 48);
      *(_DWORD *)buf = 136446978;
      uint64_t v64 = "nw_browser_add_result_locked";
      __int16 v65 = 1024;
      *(_DWORD *)BOOL v66 = v29;
      *(_WORD *)&v66[4] = 2112;
      *(void *)&v66[6] = v11;
      __int16 v67 = 2080;
      BOOL v68 = a2;
      os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v61 = 0;
      if (__nwlog_fault(v30, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          uint64_t v31 = (id)gbrowserLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            int v33 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            uint64_t v64 = "nw_browser_add_result_locked";
            __int16 v65 = 1024;
            *(_DWORD *)BOOL v66 = v33;
            *(_WORD *)&v66[4] = 2112;
            *(void *)&v66[6] = v11;
            __int16 v67 = 2080;
            BOOL v68 = a2;
            _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s", buf, 0x26u);
          }
        }
        else if (v61)
        {
          BOOL v39 = __nw_create_backtrace_string();
          if (v39)
          {
            char v40 = (char *)v39;
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
            }
            os_log_type_t v41 = (id)gbrowserLogObj;
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              int v43 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136447234;
              uint64_t v64 = "nw_browser_add_result_locked";
              __int16 v65 = 1024;
              *(_DWORD *)BOOL v66 = v43;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              __int16 v67 = 2080;
              BOOL v68 = a2;
              __int16 v69 = 2082;
              uint64_t v70 = v40;
              _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s", buf, 0x30u);
            }

            free(v40);
            if (!v30) {
              goto LABEL_87;
            }
            goto LABEL_86;
          }
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          uint64_t v31 = (id)gbrowserLogObj;
          os_log_type_t v50 = type;
          if (os_log_type_enabled(v31, type))
          {
            int v51 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            uint64_t v64 = "nw_browser_add_result_locked";
            __int16 v65 = 1024;
            *(_DWORD *)BOOL v66 = v51;
            *(_WORD *)&v66[4] = 2112;
            *(void *)&v66[6] = v11;
            __int16 v67 = 2080;
            BOOL v68 = a2;
            _os_log_impl(&dword_1830D4000, v31, v50, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, no backtrace", buf, 0x26u);
          }
        }
        else
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          uint64_t v31 = (id)gbrowserLogObj;
          os_log_type_t v48 = type;
          if (os_log_type_enabled(v31, type))
          {
            int v49 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            uint64_t v64 = "nw_browser_add_result_locked";
            __int16 v65 = 1024;
            *(_DWORD *)BOOL v66 = v49;
            *(_WORD *)&v66[4] = 2112;
            *(void *)&v66[6] = v11;
            __int16 v67 = 2080;
            BOOL v68 = a2;
            _os_log_impl(&dword_1830D4000, v31, v48, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, backtrace limit exceeded", buf, 0x26u);
          }
        }
      }
      if (v30) {
LABEL_86:
      }
        free(v30);
    }
LABEL_87:

    goto LABEL_88;
  }
  uint64_t v53 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v64 = "nw_browser_add_result_locked";
  uint64_t v54 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v61 = 0;
  if (__nwlog_fault(v54, &type, &v61))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v55 = __nwlog_obj();
      os_log_type_t v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v61)
    {
      uint64_t v57 = (char *)__nw_create_backtrace_string();
      char v55 = __nwlog_obj();
      os_log_type_t v58 = type;
      BOOL v59 = os_log_type_enabled(v55, type);
      if (v57)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v64 = "nw_browser_add_result_locked";
          __int16 v65 = 2082;
          *(void *)BOOL v66 = v57;
          _os_log_impl(&dword_1830D4000, v55, v58, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v57);
        goto LABEL_107;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_1830D4000, v55, v58, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v55 = __nwlog_obj();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_1830D4000, v55, v60, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_107:
  if (v54) {
    free(v54);
  }
  uint64_t v21 = 0;
LABEL_90:

  return v21;
}

void sub_183385484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_connection_t nwsc_request_create_and_start_connection_inner(void *a1, void *a2, void *a3)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  unint64_t v6 = a2;
  unint64_t v7 = a3;
  os_log_type_t v8 = (void *)v7;
  if (!(v6 | v7))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
    LOWORD(v126[0]) = 2114;
    *(void *)((char *)v126 + 2) = v5;
    id v10 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (!__nwlog_fault(v10, type, &error)) {
      goto LABEL_97;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (id)gLogObj;
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s %{public}@ tried to start connection on without request nor endpoint", buf, 0x16u);
      }
    }
    else if ((_BYTE)error)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (id)gLogObj;
      os_log_type_t v24 = type[0];
      BOOL v25 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2114;
          *(void *)((char *)v126 + 2) = v5;
          WORD5(v126[0]) = 2082;
          *(void *)((char *)v126 + 12) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s %{public}@ tried to start connection on without request nor endpoint, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
        if (!v10) {
          goto LABEL_99;
        }
        goto LABEL_98;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s %{public}@ tried to start connection on without request nor endpoint, no backtrace", buf, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (id)gLogObj;
      os_log_type_t v32 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        _os_log_impl(&dword_1830D4000, v11, v32, "%{public}s %{public}@ tried to start connection on without request nor endpoint, backtrace limit exceeded", buf, 0x16u);
      }
    }
    goto LABEL_96;
  }
  BOOL v13 = (void *)v7;
  if (v6)
  {
    if (*(unsigned char *)(v6 + 616))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v26 = (id)gLogObj;
      *(_DWORD *)buf = 136446722;
      os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
      LOWORD(v126[0]) = 2114;
      *(void *)((char *)v126 + 2) = v5;
      WORD5(v126[0]) = 2114;
      *(void *)((char *)v126 + 12) = v6;
      id v10 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(error) = 0;
      if (!__nwlog_fault(v10, type, &error)) {
        goto LABEL_97;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (id)gLogObj;
        os_log_type_t v27 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2114;
          *(void *)((char *)v126 + 2) = v5;
          WORD5(v126[0]) = 2114;
          *(void *)((char *)v126 + 12) = v6;
          _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s %{public}@ tried to start connection on incoming request %{public}@", buf, 0x20u);
        }
      }
      else if ((_BYTE)error)
      {
        os_log_type_t v41 = __nw_create_backtrace_string();
        if (v41)
        {
          os_log_type_t v42 = (char *)v41;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v43 = (id)gLogObj;
          os_log_type_t v44 = type[0];
          if (os_log_type_enabled(v43, type[0]))
          {
            *(_DWORD *)buf = 136446978;
            os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
            LOWORD(v126[0]) = 2114;
            *(void *)((char *)v126 + 2) = v5;
            WORD5(v126[0]) = 2114;
            *(void *)((char *)v126 + 12) = v6;
            WORD2(v126[1]) = 2082;
            *(void *)((char *)&v126[1] + 6) = v42;
            _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s %{public}@ tried to start connection on incoming request %{public}@, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v42);
          if (!v10) {
            goto LABEL_99;
          }
          goto LABEL_98;
        }
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v63 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2114;
          *(void *)((char *)v126 + 2) = v5;
          WORD5(v126[0]) = 2114;
          *(void *)((char *)v126 + 12) = v6;
          _os_log_impl(&dword_1830D4000, v11, v63, "%{public}s %{public}@ tried to start connection on incoming request %{public}@, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (id)gLogObj;
        os_log_type_t v59 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2114;
          *(void *)((char *)v126 + 2) = v5;
          WORD5(v126[0]) = 2114;
          *(void *)((char *)v126 + 12) = v6;
          _os_log_impl(&dword_1830D4000, v11, v59, "%{public}s %{public}@ tried to start connection on incoming request %{public}@, backtrace limit exceeded", buf, 0x20u);
        }
      }
LABEL_96:

LABEL_97:
      if (!v10)
      {
LABEL_99:
        nw_connection_t v64 = 0;
        goto LABEL_193;
      }
LABEL_98:
      free(v10);
      goto LABEL_99;
    }
    if (*(void *)(v6 + 576))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        WORD5(v126[0]) = 2114;
        *(void *)((char *)v126 + 12) = v6;
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cancelling previous connection on request %{public}@", buf, 0x20u);
      }

      nw_connection_cancel(*(nw_connection_t *)(v6 + 576));
      os_log_type_t v15 = *(void **)(v6 + 576);
      *(void *)(v6 + 576) = 0;
    }
    BOOL v13 = *(void **)(v6 + 8);
  }
  endpoint = v13;
  int v16 = (unsigned __int16 *)v5;
  BOOL v17 = (NWConcrete_nw_unique_connection_request *)(id)v6;
  if (!v16)
  {
    BOOL v102 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
    int v29 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (!__nwlog_fault(v29, type, &error)) {
      goto LABEL_112;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v103 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl(&dword_1830D4000, v30, v103, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else
    {
      if ((_BYTE)error)
      {
        size_t v104 = (char *)__nw_create_backtrace_string();
        size_t v105 = __nwlog_obj();
        os_log_type_t v106 = type[0];
        BOOL v107 = os_log_type_enabled(v105, type[0]);
        if (v104)
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
            LOWORD(v126[0]) = 2082;
            *(void *)((char *)v126 + 2) = v104;
            _os_log_impl(&dword_1830D4000, v105, v106, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v104);
        }
        else
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
            _os_log_impl(&dword_1830D4000, v105, v106, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
          }
        }
        goto LABEL_112;
      }
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v109 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl(&dword_1830D4000, v30, v109, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_212:

    goto LABEL_112;
  }
  if (!v16[24])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v28 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
    int v29 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (!__nwlog_fault(v29, type, &error)) {
      goto LABEL_112;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v30 = (id)gLogObj;
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s Bad local port", buf, 0xCu);
      }
    }
    else if ((_BYTE)error)
    {
      int v47 = __nw_create_backtrace_string();
      if (v47)
      {
        os_log_type_t v48 = (char *)v47;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v49 = (id)gLogObj;
        os_log_type_t v50 = type[0];
        if (os_log_type_enabled(v49, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
          LOWORD(v126[0]) = 2082;
          *(void *)((char *)v126 + 2) = v48;
          _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s Bad local port, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v48);
        if (!v29) {
          goto LABEL_114;
        }
        goto LABEL_113;
      }
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v65 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl(&dword_1830D4000, v30, v65, "%{public}s Bad local port, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v30 = (id)gLogObj;
      os_log_type_t v62 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl(&dword_1830D4000, v30, v62, "%{public}s Bad local port, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_212;
  }
  if (nw_service_connector_get_new_sequence_number(void)::onceToken != -1) {
    dispatch_once(&nw_service_connector_get_new_sequence_number(void)::onceToken, &__block_literal_global_191);
  }
  for (unint64_t i = atomic_fetch_add(&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber, 1uLL);
        !i;
  if (v6)
  {
    v17->sequenceNumber = i;
    size_t v19 = strnlen(v17->service, 0x100uLL);
    size_t v20 = v19;
    if (v19 < 0x100)
    {
      unsigned int v21 = v19 + 91;
      unsigned __int8 v22 = v19;
      goto LABEL_43;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v45 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
    LOWORD(v126[0]) = 2048;
    *(void *)((char *)v126 + 2) = v20;
    int v29 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (__nwlog_fault(v29, type, &error))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v30 = (id)gLogObj;
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v30, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
          LOWORD(v126[0]) = 2048;
          *(void *)((char *)v126 + 2) = v20;
          _os_log_impl(&dword_1830D4000, v30, v46, "%{public}s Service name too long %zu", buf, 0x16u);
        }
      }
      else
      {
        if ((_BYTE)error)
        {
          char v55 = (char *)__nw_create_backtrace_string();
          os_log_type_t v56 = __nwlog_obj();
          os_log_type_t v57 = type[0];
          BOOL v58 = os_log_type_enabled(v56, type[0]);
          if (v55)
          {
            if (v58)
            {
              *(_DWORD *)buf = 136446722;
              os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
              LOWORD(v126[0]) = 2048;
              *(void *)((char *)v126 + 2) = v20;
              WORD5(v126[0]) = 2082;
              *(void *)((char *)v126 + 12) = v55;
              _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s Service name too long %zu, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v55);
            if (!v29) {
              goto LABEL_114;
            }
            goto LABEL_113;
          }
          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
            LOWORD(v126[0]) = 2048;
            *(void *)((char *)v126 + 2) = v20;
            _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s Service name too long %zu, no backtrace", buf, 0x16u);
          }

          goto LABEL_112;
        }
        os_log_type_t v30 = __nwlog_obj();
        os_log_type_t v66 = type[0];
        if (os_log_type_enabled(v30, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v125 = "nw_service_connector_create_initial_payload_for_request";
          LOWORD(v126[0]) = 2048;
          *(void *)((char *)v126 + 2) = v20;
          _os_log_impl(&dword_1830D4000, v30, v66, "%{public}s Service name too long %zu, backtrace limit exceeded", buf, 0x16u);
        }
      }
      goto LABEL_212;
    }
LABEL_112:
    if (!v29)
    {
LABEL_114:

      goto LABEL_126;
    }
LABEL_113:
    free(v29);
    goto LABEL_114;
  }
  unsigned __int8 v22 = 0;
  unsigned int v21 = 79;
LABEL_43:
  memset(v126, 0, sizeof(v126));
  *(_WORD *)buf = bswap32(v21) >> 16;
  *(_WORD *)&buf[2] = bswap32(v16[24]) >> 16;
  os_log_type_t v125 = (const char *)bswap64(i);
  if (v6)
  {
    v126[0] = *(_OWORD *)v17->uuid;
    LOBYTE(v126[1]) = v22;
    memcpy((char *)&v126[1] + 1, v17->service, v22);
  }
  size_t v33 = (unsigned __int16)v21 + 2;
  CFDataRef v34 = (const __CFData *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:buf length:v33 freeWhenDone:0];
  CFErrorRef error = 0;
  CFDataRef v35 = SecKeyCreateSignature(*((SecKeyRef *)v16 + 14), (SecKeyAlgorithm)*MEMORY[0x1E4F3BAA0], v34, &error);
  CFDataRef v36 = v35;
  if (v35)
  {
    if (v6) {
      os_log_type_t v37 = (char *)&v126[1] + v22 + 1;
    }
    else {
      os_log_type_t v37 = (char *)v126 + 4;
    }
    [(__CFData *)v35 getBytes:v37 length:64];
    dispatch_data_t v38 = dispatch_data_create(buf, v33, 0, 0);
    BOOL v39 = v38;
    if (v38)
    {
      char v40 = v38;
LABEL_121:
      BOOL v68 = v39;

      goto LABEL_122;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v51 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    size_t v121 = "nw_service_connector_create_initial_payload_for_request";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v118 = OS_LOG_TYPE_ERROR;
    char v117 = 0;
    if (__nwlog_fault(v52, &v118, &v117))
    {
      if (v118 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v53 = (id)gLogObj;
        os_log_type_t v54 = v118;
        if (os_log_type_enabled(v53, v118))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          size_t v121 = "nw_service_connector_create_initial_payload_for_request";
          _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s dispatch_data_create failed", (uint8_t *)type, 0xCu);
        }
      }
      else if (v117)
      {
        os_log_type_t v60 = (char *)__nw_create_backtrace_string();
        uint64_t v53 = __nwlog_obj();
        os_log_type_t v110 = v118;
        BOOL v61 = os_log_type_enabled(v53, v118);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            size_t v121 = "nw_service_connector_create_initial_payload_for_request";
            __int16 v122 = 2082;
            CFErrorRef v123 = (CFErrorRef)v60;
            _os_log_impl(&dword_1830D4000, v53, v110, "%{public}s dispatch_data_create failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }

          free(v60);
          if (!v52) {
            goto LABEL_120;
          }
          goto LABEL_119;
        }
        if (v61)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          size_t v121 = "nw_service_connector_create_initial_payload_for_request";
          _os_log_impl(&dword_1830D4000, v53, v110, "%{public}s dispatch_data_create failed, no backtrace", (uint8_t *)type, 0xCu);
        }
      }
      else
      {
        uint64_t v53 = __nwlog_obj();
        os_log_type_t v67 = v118;
        if (os_log_type_enabled(v53, v118))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          size_t v121 = "nw_service_connector_create_initial_payload_for_request";
          _os_log_impl(&dword_1830D4000, v53, v67, "%{public}s dispatch_data_create failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
      }
    }
    if (!v52)
    {
LABEL_120:
      BOOL v39 = 0;
      goto LABEL_121;
    }
LABEL_119:
    free(v52);
    goto LABEL_120;
  }
  size_t v108 = __nwlog_obj();
  if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)os_log_type_t type = 136446466;
    size_t v121 = "nw_service_connector_create_initial_payload_for_request";
    __int16 v122 = 2112;
    CFErrorRef v123 = error;
    _os_log_impl(&dword_1830D4000, v108, OS_LOG_TYPE_ERROR, "%{public}s SecKeyCreateSignature failed with error %@", (uint8_t *)type, 0x16u);
  }

  if (error)
  {
    CFRelease(error);
    BOOL v68 = 0;
    CFErrorRef error = 0;
  }
  else
  {
    BOOL v68 = 0;
  }
LABEL_122:

  if (v68)
  {
    if (v6)
    {
      userParameters = v17->userParameters;
      if (userParameters)
      {
        uint64_t v70 = userParameters;
        legacy_tcp_socket = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v70, 0, 0);

        nw_parameters_set_data_mode(legacy_tcp_socket, 2u);
        nw_parameters_set_allow_socket_access(legacy_tcp_socket, 1);
        nw_parameters_set_tfo(legacy_tcp_socket, 1);
        goto LABEL_138;
      }
    }
    legacy_tcp_socket = nw_parameters_create_legacy_tcp_socket(&__block_literal_global_200);
    if (legacy_tcp_socket)
    {
LABEL_138:
      nw_parameters_set_fast_open_enabled(legacy_tcp_socket, 1);
      nw_parameters_set_fast_open_force_enable(legacy_tcp_socket, 1);
      nw_parameters_set_no_proxy(legacy_tcp_socket, 1);
      nw_connection_t v64 = nw_connection_create(endpoint, legacy_tcp_socket);
      if (v64)
      {
        if (v6)
        {
          nwsc_request_stop_path_watcher(v17);
          objc_storeStrong((id *)&v17->connection, v64);
        }
        nw_connection_set_queue(v64, *((dispatch_queue_t *)v16 + 4));
        nw_connection_send(v64, v68, (nw_content_context_t)&__block_literal_global_42249, 1, &__block_literal_global_24376);
        handler[0] = MEMORY[0x1E4F143A8];
        handler[1] = 3221225472;
        handler[2] = ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_201;
        handler[3] = &unk_1E5243318;
        os_log_type_t v79 = v16;
        size_t v113 = v79;
        char v80 = v64;
        size_t v114 = v80;
        __int16 v81 = v17;
        size_t v115 = v81;
        char v116 = 0;
        nw_connection_set_state_changed_handler(v80, handler);
        nw_connection_start(v80);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v82 = (id)gLogObj;
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2114;
          *(void *)((char *)v126 + 2) = v79;
          WORD5(v126[0]) = 2114;
          *(void *)((char *)v126 + 12) = v81;
          _os_log_impl(&dword_1830D4000, v82, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ sending connection request %{public}@", buf, 0x20u);
        }

        __int16 v83 = v80;
LABEL_184:

LABEL_191:
        goto LABEL_192;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v85 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
      __int16 v86 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(error) = 0;
      if (__nwlog_fault(v86, type, &error))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          size_t v87 = __nwlog_obj();
          os_log_type_t v88 = type[0];
          if (os_log_type_enabled(v87, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
            _os_log_impl(&dword_1830D4000, v87, v88, "%{public}s nw_connection_create failed", buf, 0xCu);
          }
        }
        else if ((_BYTE)error)
        {
          os_log_type_t v93 = (char *)__nw_create_backtrace_string();
          size_t v87 = __nwlog_obj();
          os_log_type_t v94 = type[0];
          BOOL v95 = os_log_type_enabled(v87, type[0]);
          if (v93)
          {
            if (v95)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
              LOWORD(v126[0]) = 2082;
              *(void *)((char *)v126 + 2) = v93;
              _os_log_impl(&dword_1830D4000, v87, v94, "%{public}s nw_connection_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v93);
            goto LABEL_182;
          }
          if (v95)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
            _os_log_impl(&dword_1830D4000, v87, v94, "%{public}s nw_connection_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          size_t v87 = __nwlog_obj();
          os_log_type_t v99 = type[0];
          if (os_log_type_enabled(v87, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
            _os_log_impl(&dword_1830D4000, v87, v99, "%{public}s nw_connection_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_182:
      if (v86) {
        free(v86);
      }
      goto LABEL_184;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v89 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
    uint64_t v90 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (__nwlog_fault(v90, type, &error))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v92 = type[0];
        if (os_log_type_enabled(v91, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          _os_log_impl(&dword_1830D4000, v91, v92, "%{public}s nw_parameters_create failed", buf, 0xCu);
        }
      }
      else if ((_BYTE)error)
      {
        size_t v96 = (char *)__nw_create_backtrace_string();
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v97 = type[0];
        BOOL v98 = os_log_type_enabled(v91, type[0]);
        if (v96)
        {
          if (v98)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
            LOWORD(v126[0]) = 2082;
            *(void *)((char *)v126 + 2) = v96;
            _os_log_impl(&dword_1830D4000, v91, v97, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v96);
          goto LABEL_188;
        }
        if (v98)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          _os_log_impl(&dword_1830D4000, v91, v97, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v100 = type[0];
        if (os_log_type_enabled(v91, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          _os_log_impl(&dword_1830D4000, v91, v100, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_188:
    if (v90) {
      free(v90);
    }
    nw_connection_t v64 = 0;
    goto LABEL_191;
  }
LABEL_126:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v72 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
  uint64_t v73 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(error) = 0;
  if (__nwlog_fault(v73, type, &error))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v74 = (id)gLogObj;
      os_log_type_t v75 = type[0];
      if (os_log_type_enabled(v74, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s nw_service_connector_create_initial_payload_for_request failed", buf, 0xCu);
      }
    }
    else if ((_BYTE)error)
    {
      BOOL v76 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v74 = (id)gLogObj;
      os_log_type_t v77 = type[0];
      BOOL v78 = os_log_type_enabled(v74, type[0]);
      if (v76)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2082;
          *(void *)((char *)v126 + 2) = v76;
          _os_log_impl(&dword_1830D4000, v74, v77, "%{public}s nw_service_connector_create_initial_payload_for_request failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v76);
        if (!v73) {
          goto LABEL_152;
        }
        goto LABEL_151;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        _os_log_impl(&dword_1830D4000, v74, v77, "%{public}s nw_service_connector_create_initial_payload_for_request failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v74 = (id)gLogObj;
      os_log_type_t v84 = type[0];
      if (os_log_type_enabled(v74, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v125 = "nwsc_request_create_and_start_connection_inner";
        _os_log_impl(&dword_1830D4000, v74, v84, "%{public}s nw_service_connector_create_initial_payload_for_request failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
  if (v73) {
LABEL_151:
  }
    free(v73);
LABEL_152:
  nw_connection_t v64 = 0;
LABEL_192:

LABEL_193:

  return v64;
}

void sub_183387194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_add_server_raw_public_key(void *a1, const UInt8 *a2, CFIndex a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  unint64_t v6 = (CFMutableArrayRef *)v5;
  if (!v5)
  {
    id v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
          __int16 v37 = 2082;
          dispatch_data_t v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_75:
        if (!v10) {
          goto LABEL_9;
        }
LABEL_76:
        free(v10);
        goto LABEL_9;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v29, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_74:

    goto LABEL_75;
  }
  if (!nw_protocol_options_is_masque(*((void **)v5 + 5)))
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v33)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v30, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    unsigned __int8 v22 = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
      __int16 v37 = 2082;
      dispatch_data_t v38 = v22;
      _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
  if (!a2)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null key_bytes", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v33)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v31, "%{public}s called with null key_bytes, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    unsigned __int8 v22 = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null key_bytes, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
      __int16 v37 = 2082;
      dispatch_data_t v38 = v22;
      _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null key_bytes, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
  if (!a3)
  {
    BOOL v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null key_length", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v33)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v32, "%{public}s called with null key_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    unsigned __int8 v22 = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v28 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null key_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      CFDataRef v36 = "nw_proxy_hop_add_server_raw_public_key";
      __int16 v37 = 2082;
      dispatch_data_t v38 = v22;
      _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null key_length, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_49:

    free(v22);
    if (!v10) {
      goto LABEL_9;
    }
    goto LABEL_76;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!v6[7]) {
    v6[7] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  }
  CFDataRef v8 = CFDataCreate(v7, a2, a3);
  CFArrayAppendValue(v6[7], v8);
  if (v8) {
    CFRelease(v8);
  }
LABEL_9:
}

void sub_183387B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_parameters_set_data_mode(void *a1, unsigned int a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    id v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_set_data_mode";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_parameters_set_data_mode";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_48:
        if (!v10) {
          goto LABEL_14;
        }
        goto LABEL_49;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  if (a2 >= 0xFF)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_set_data_mode";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX)", buf, 0xCu);
      }
    }
    else if (v23)
    {
      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_parameters_set_data_mode";
          __int16 v27 = 2082;
          BOOL v28 = v18;
          _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v10) {
          goto LABEL_14;
        }
LABEL_49:
        free(v10);
        goto LABEL_14;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_47;
  }
  *((unsigned char *)v3 + 92) = a2;
  uint64_t v5 = v3[19];
  if (v5 && !*(void *)(v5 + 24))
  {
    if (a2 == 1)
    {
      if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
        dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
      }
      options = nw_protocol_create_options((void *)g_udp_definition);
      goto LABEL_13;
    }
    if (a2 == 2)
    {
      if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
      }
      options = nw_protocol_create_options((void *)g_tcp_definition);
LABEL_13:
      uint64_t v7 = v4[19];
      CFDataRef v8 = *(void **)(v7 + 24);
      *(void *)(v7 + 24) = options;
    }
  }
LABEL_14:
}

void sub_1833880CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_201(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a3;
  int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 16);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (id)gLogObj;
  CFDataRef v8 = v7;
  if (v6 == 4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if (a2 > 5) {
        id v9 = "unknown";
      }
      else {
        id v9 = off_1E523DF08[a2];
      }
      uint64_t v12 = *(void *)(a1 + 32);
      os_log_type_t v11 = *(NSObject **)(a1 + 40);
      uint64_t v13 = *(void *)(a1 + 48);
      int v14 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)buf = 136447746;
      int v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
      __int16 v44 = 2114;
      uint64_t v45 = v12;
      __int16 v46 = 2114;
      int v47 = v11;
      __int16 v48 = 2082;
      int v49 = v9;
      __int16 v50 = 2114;
      id v51 = v5;
      __int16 v52 = 2114;
      uint64_t v53 = v13;
      __int16 v54 = 1024;
      int v55 = v14;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring connection %{public}@ received state %{public}s error %{public}@ for request %{public}@ opCode %u", buf, 0x44u);
    }

    goto LABEL_11;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 5) {
      id v10 = "unknown";
    }
    else {
      id v10 = off_1E523DF08[a2];
    }
    uint64_t v16 = *(void *)(a1 + 32);
    os_log_type_t v15 = *(NSObject **)(a1 + 40);
    uint64_t v17 = *(void *)(a1 + 48);
    int v18 = *(unsigned __int8 *)(a1 + 56);
    *(_DWORD *)buf = 136447746;
    int v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
    __int16 v44 = 2114;
    uint64_t v45 = v16;
    __int16 v46 = 2114;
    int v47 = v15;
    __int16 v48 = 2082;
    int v49 = v10;
    __int16 v50 = 2114;
    id v51 = v5;
    __int16 v52 = 2114;
    uint64_t v53 = v17;
    __int16 v54 = 1024;
    int v55 = v18;
    _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ connection %{public}@ received state %{public}s error %{public}@ for request %{public}@ opCode %u", buf, 0x44u);
  }

  if ((a2 & 0xFFFFFFFE) == 2)
  {
    os_log_type_t v19 = *(NWConcrete_nw_unique_connection_request **)(a1 + 48);
    if (v19) {
      nwsc_request_stop_path_watcher(v19);
    }
  }
  if (a2 == 3)
  {
    BOOL v20 = *(NSObject **)(a1 + 40);
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
    }
    os_log_type_t v21 = (id)g_tcp_definition;
    nw_protocol_metadata_t v22 = nw_connection_copy_protocol_metadata(v20, v21);

    if (v22)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
      }
      id v23 = (id)nw_context_copy_implicit_context::implicit_context;
      v38[0] = MEMORY[0x1E4F143A8];
      v38[1] = 3221225472;
      v38[2] = ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_202;
      v38[3] = &unk_1E5249868;
      uint64_t v39 = *(id *)(a1 + 32);
      id v40 = *(id *)(a1 + 48);
      os_log_type_t v41 = v22;
      nw_queue_context_async_if_needed(v23, v38);

      BOOL v24 = v39;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v24 = (id)gLogObj;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a1 + 32);
        BOOL v26 = *(NSObject **)(a1 + 40);
        __int16 v27 = *(const char **)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        int v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v44 = 2114;
        uint64_t v45 = v25;
        __int16 v46 = 2114;
        int v47 = v26;
        __int16 v48 = 2114;
        int v49 = v27;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ metadata for connection %{public}@ is nil -- unable to enable keep alives for request %{public}@", buf, 0x2Au);
      }
    }

    nw_connection_set_state_changed_handler(*(nw_connection_t *)(a1 + 40), 0);
    nw_connection_set_path_changed_handler(*(nw_connection_t *)(a1 + 40), 0);
    nw_service_connector_should_accept_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), *(NWConcrete_nw_connection **)(a1 + 40), 0);
  }
  else if (a2 == 4 || a2 == 1)
  {
    if (!*(void *)(a1 + 48))
    {
LABEL_11:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      goto LABEL_33;
    }
    if (nwsc_is_error_allowlisted(v5, a2 == 1))
    {
      if (a2 == 4)
      {
        nwsc_request_start_path_watcher(*(NWConcrete_nw_service_connector **)(a1 + 32), *(NWConcrete_nw_unique_connection_request **)(a1 + 48), *(NWConcrete_nw_connection **)(a1 + 40), 1);
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFDataRef v34 = (id)gLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v35 = *(void *)(a1 + 32);
          CFDataRef v36 = *(NSObject **)(a1 + 40);
          __int16 v37 = *(const char **)(a1 + 48);
          *(_DWORD *)buf = 136446978;
          int v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
          __int16 v44 = 2114;
          uint64_t v45 = v35;
          __int16 v46 = 2114;
          int v47 = v36;
          __int16 v48 = 2114;
          int v49 = v37;
          _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ connection %{public}@ in waiting state for request %{public}@", buf, 0x2Au);
        }

        *(unsigned char *)(*(void *)(a1 + 48) + 616) |= 0x80u;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v28 = (id)gLogObj;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        uint64_t v29 = *(void *)(a1 + 32);
        os_log_type_t v30 = *(const char **)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        int v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v44 = 2114;
        uint64_t v45 = v29;
        __int16 v46 = 2114;
        int v47 = v5;
        __int16 v48 = 2114;
        int v49 = v30;
        _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ received unrecoverable error %{public}@, cancelling request %{public}@", buf, 0x2Au);
      }

      nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), *(void **)(*(void *)(a1 + 48) + 8), *(void *)(a1 + 48) + 24, *(void **)(a1 + 40), 0);
      os_log_type_t v31 = *(void **)(a1 + 32);
      os_log_type_t v32 = *(void **)(a1 + 48);
      int error_code = nw_error_get_error_code(v5);
      nw_service_connector_trigger_request_complete_block_inner(v31, v32, 0, 0, error_code);
    }
  }
LABEL_33:
}

void sub_1833886DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t nw_socket_set_common_sockopts(nw_protocol *a1)
{
  uint64_t v563 = *MEMORY[0x1E4F143B8];
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    nw_parameters_t v3 = &a1[1].output_handler;
  }
  else {
    nw_parameters_t v3 = 0;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v558 = "nw_socket_set_common_sockopts";
    os_log_type_t v225 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v561) = 0;
    if (!__nwlog_fault(v225, uu, &v561)) {
      goto LABEL_96;
    }
    if (uu[0] == 17)
    {
      id v9 = __nwlog_obj();
      os_log_type_t v10 = uu[0];
      if (os_log_type_enabled(v9, (os_log_type_t)uu[0]))
      {
        *(_DWORD *)buf = 136446210;
        v558 = "nw_socket_set_common_sockopts";
        os_log_type_t v11 = "%{public}s called with null socket_handler";
LABEL_94:
        os_log_type_t v42 = v9;
        os_log_type_t v43 = v10;
LABEL_95:
        _os_log_impl(&dword_1830D4000, v42, v43, v11, buf, 0xCu);
      }
    }
    else if ((_BYTE)v561)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v9 = __nwlog_obj();
      os_log_type_t v10 = uu[0];
      BOOL v228 = os_log_type_enabled(v9, (os_log_type_t)uu[0]);
      if (backtrace_string)
      {
        if (v228)
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 2082;
          *(void *)v560 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_96;
      }
      if (v228)
      {
        *(_DWORD *)buf = 136446210;
        v558 = "nw_socket_set_common_sockopts";
        os_log_type_t v11 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_94;
      }
    }
    else
    {
      id v9 = __nwlog_obj();
      os_log_type_t v10 = uu[0];
      if (os_log_type_enabled(v9, (os_log_type_t)uu[0]))
      {
        *(_DWORD *)buf = 136446210;
        v558 = "nw_socket_set_common_sockopts";
        os_log_type_t v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_94;
      }
    }
LABEL_96:
    if (v225) {
      free(v225);
    }
    return 0;
  }
  if ((*(_DWORD *)&a1[4].flow_id[12] & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v558 = "nw_socket_set_common_sockopts";
    os_log_type_t v225 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v561) = 0;
    if (!__nwlog_fault(v225, uu, &v561)) {
      goto LABEL_96;
    }
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = gLogObj;
      os_log_type_t v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null socket_handler->fd";
      goto LABEL_94;
    }
    if (!(_BYTE)v561)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = gLogObj;
      os_log_type_t v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null socket_handler->fd, backtrace limit exceeded";
      goto LABEL_94;
    }
    uint64_t v17 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v18 = gLogObj;
    os_log_type_t v19 = uu[0];
    BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!v17)
    {
      if (!v20) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null socket_handler->fd, no backtrace";
      goto LABEL_100;
    }
    if (!v20) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2082;
    *(void *)v560 = v17;
    os_log_type_t v21 = "%{public}s called with null socket_handler->fd, dumping backtrace:%{public}s";
LABEL_69:
    _os_log_impl(&dword_1830D4000, v18, v19, v21, buf, 0x16u);
    goto LABEL_70;
  }
  identifier = a1[2].identifier;
  if (!identifier) {
    goto LABEL_25;
  }
  uint64_t v6 = *(void *)&identifier->name[24];
  if (!v6) {
    goto LABEL_25;
  }
  uint64_t v7 = *(uint64_t (**)(void))(v6 + 136);
  if (!v7) {
    goto LABEL_25;
  }
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    uint64_t v12 = *(void *)&identifier[2].name[8];
    if (v12) {
      *(void *)&identifier[2].name[8] = v12 + 1;
    }
    CFDataRef v8 = (void *)v7(identifier);
    if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
    {
      uint64_t v27 = *(void *)&identifier[2].name[8];
      if (v27)
      {
        uint64_t v28 = v27 - 1;
        *(void *)&identifier[2].name[8] = v28;
        if (!v28)
        {
          uint64_t v29 = *(void (***)(void))&identifier[1].name[24];
          if (v29)
          {
            *(void *)&identifier[1].name[24] = 0;
            v29[2](v29);
            _Block_release(v29);
          }
          if (identifier[1].level)
          {
            os_log_type_t v30 = *(const void **)&identifier[1].name[24];
            if (v30) {
              _Block_release(v30);
            }
          }
          free(identifier);
        }
      }
    }
  }
  else
  {
    CFDataRef v8 = (void *)v7(a1[2].identifier);
  }
  if (!v8)
  {
LABEL_25:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v558 = "nw_socket_set_common_sockopts";
    os_log_type_t v225 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v561) = 0;
    if (!__nwlog_fault(v225, uu, &v561)) {
      goto LABEL_96;
    }
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = gLogObj;
      os_log_type_t v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null remote_endpoint";
      goto LABEL_94;
    }
    if (!(_BYTE)v561)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = gLogObj;
      os_log_type_t v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null remote_endpoint, backtrace limit exceeded";
      goto LABEL_94;
    }
    uint64_t v17 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v18 = gLogObj;
    os_log_type_t v19 = uu[0];
    BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!v17)
    {
      if (!v26) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null remote_endpoint, no backtrace";
      goto LABEL_100;
    }
    if (!v26) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2082;
    *(void *)v560 = v17;
    os_log_type_t v21 = "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s";
    goto LABEL_69;
  }
  uint64_t v13 = a1[2].identifier;
  if (!v13) {
    goto LABEL_45;
  }
  uint64_t v14 = *(void *)&v13->name[24];
  if (!v14) {
    goto LABEL_45;
  }
  os_log_type_t v15 = *(uint64_t (**)(void))(v14 + 112);
  if (!v15) {
    goto LABEL_45;
  }
  if (*(_UNKNOWN **)v13[1].name == &nw_protocol_ref_counted_handle)
  {
    uint64_t v22 = *(void *)&v13[2].name[8];
    if (v22) {
      *(void *)&v13[2].name[8] = v22 + 1;
    }
    uint64_t v16 = (void *)v15(v13);
    if (*(_UNKNOWN **)v13[1].name == &nw_protocol_ref_counted_handle)
    {
      uint64_t v36 = *(void *)&v13[2].name[8];
      if (v36)
      {
        uint64_t v37 = v36 - 1;
        *(void *)&v13[2].name[8] = v37;
        if (!v37)
        {
          dispatch_data_t v38 = *(void (***)(void))&v13[1].name[24];
          if (v38)
          {
            *(void *)&v13[1].name[24] = 0;
            v38[2](v38);
            _Block_release(v38);
          }
          if (v13[1].level)
          {
            uint64_t v39 = *(const void **)&v13[1].name[24];
            if (v39) {
              _Block_release(v39);
            }
          }
          free(v13);
        }
      }
    }
  }
  else
  {
    uint64_t v16 = (void *)v15(a1[2].identifier);
  }
  if (!v16)
  {
LABEL_45:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v558 = "nw_socket_set_common_sockopts";
    os_log_type_t v225 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v561) = 0;
    if (!__nwlog_fault(v225, uu, &v561)) {
      goto LABEL_96;
    }
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = gLogObj;
      os_log_type_t v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null parameters";
      goto LABEL_94;
    }
    if (!(_BYTE)v561)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = gLogObj;
      os_log_type_t v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_96;
      }
      *(_DWORD *)buf = 136446210;
      v558 = "nw_socket_set_common_sockopts";
      os_log_type_t v11 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_94;
    }
    uint64_t v17 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v18 = gLogObj;
    os_log_type_t v19 = uu[0];
    BOOL v35 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (v17)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2082;
        *(void *)v560 = v17;
        os_log_type_t v21 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
        goto LABEL_69;
      }
LABEL_70:
      free(v17);
      goto LABEL_96;
    }
    if (!v35) {
      goto LABEL_96;
    }
    *(_DWORD *)buf = 136446210;
    v558 = "nw_socket_set_common_sockopts";
    os_log_type_t v11 = "%{public}s called with null parameters, no backtrace";
LABEL_100:
    os_log_type_t v42 = v18;
    os_log_type_t v43 = v19;
    goto LABEL_95;
  }
  uint64_t v546 = (uint64_t)v3;
  path = (void *)nw_socket_get_path(a1);
  int v555 = 0;
  int v556 = 1;
  int identifier_low = LOBYTE(a1[6].identifier);
  if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4130, &v556, 4u)) {
    goto LABEL_108;
  }
  int v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  BOOL v24 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2080;
    *(void *)v560 = (char *)a1 + 404;
    *(_WORD *)&v560[8] = 1024;
    *(_DWORD *)&v560[10] = v23;
    _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v25 = gLogObj;
  if (v23 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = 22;
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_108;
  }
  *(_DWORD *)buf = 136446466;
  v558 = "nw_socket_set_common_sockopts";
  __int16 v559 = 1024;
  *(_DWORD *)v560 = v23;
  int v537 = 18;
  os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();
  uu[0] = 16;
  LOBYTE(v561) = 0;
  if (__nwlog_fault(v31, uu, &v561))
  {
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v32 = gLogObj;
      os_log_type_t v33 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_106;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v23;
      CFDataRef v34 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d";
      goto LABEL_105;
    }
    if (!(_BYTE)v561)
    {
      os_log_type_t v32 = __nwlog_obj();
      os_log_type_t v33 = uu[0];
      if (!os_log_type_enabled(v32, (os_log_type_t)uu[0])) {
        goto LABEL_106;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v23;
      CFDataRef v34 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_105;
    }
    v543 = p_output_handler;
    id v40 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v32 = gLogObj;
    os_log_type_t v33 = uu[0];
    BOOL v41 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (v40)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v23;
        *(_WORD *)&v560[4] = 2082;
        *(void *)&v560[6] = v40;
        _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v40);
      p_output_handler = v543;
      goto LABEL_106;
    }
    p_output_handler = v543;
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v23;
      CFDataRef v34 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
LABEL_105:
      _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0x12u);
    }
  }
LABEL_106:
  if (v31) {
    free(v31);
  }
LABEL_108:
  if (ioctl(*(_DWORD *)&a1[4].flow_id[12], 0x8004667EuLL, &v556, v537) < 0)
  {
    uint64_t v49 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v50 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v49;
      _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_ERROR, "%{public}s %s FIONBIO failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v51 = gLogObj;
    if (v49 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        __int16 v52 = "%{public}s FIONBIO failed %{darwin.errno}d";
LABEL_289:
        _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_ERROR, v52, buf, 0x12u);
      }
LABEL_329:
      uint64_t v75 = (uint64_t)p_output_handler;
LABEL_330:
      uint64_t v74 = v49;
      goto LABEL_331;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v49;
    int v55 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v561) = 0;
    if (!__nwlog_fault(v55, uu, &v561)) {
      goto LABEL_327;
    }
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v56 = gLogObj;
      os_log_type_t v57 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_327;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      BOOL v58 = "%{public}s FIONBIO failed %{darwin.errno}d";
    }
    else if ((_BYTE)v561)
    {
      os_log_type_t v59 = (char *)__nw_create_backtrace_string();
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = uu[0];
      BOOL v60 = os_log_type_enabled(v56, (os_log_type_t)uu[0]);
      if (v59)
      {
        if (v60)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v49;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v59;
          _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s FIONBIO failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v59);
        if (!v55) {
          goto LABEL_329;
        }
        goto LABEL_328;
      }
      if (!v60) {
        goto LABEL_327;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      BOOL v58 = "%{public}s FIONBIO failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = uu[0];
      if (!os_log_type_enabled(v56, (os_log_type_t)uu[0])) {
        goto LABEL_327;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      BOOL v58 = "%{public}s FIONBIO failed %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_326:
    _os_log_impl(&dword_1830D4000, v56, v57, v58, buf, 0x12u);
    goto LABEL_327;
  }
  memset(uu, 0, sizeof(uu));
  __int16 v44 = v16;
  *(_OWORD *)uuid_t uu = *(_OWORD *)(v44 + 24);

  if (uuid_is_null(uu))
  {
    if (uuid_is_null(a1->flow_id) || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4369, a1, 0x10u)) {
      goto LABEL_181;
    }
    int v45 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v46 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v45;
      _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d", buf, 0x1Cu);
    }
    if (v45 == 2 || v45 == 22)
    {
      int v47 = __nwlog_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v45;
        __int16 v48 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
LABEL_136:
        _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_ERROR, v48, buf, 0x12u);
        goto LABEL_181;
      }
      goto LABEL_181;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v45;
    BOOL v61 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v561) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v61, &v561, type) & 1) == 0) {
      goto LABEL_179;
    }
    if (v561 == 17)
    {
      os_log_type_t v62 = __nwlog_obj();
      os_log_type_t v63 = v561;
      if (!os_log_type_enabled(v62, (os_log_type_t)v561)) {
        goto LABEL_179;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v45;
      nw_connection_t v64 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
      goto LABEL_178;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v62 = __nwlog_obj();
      os_log_type_t v63 = v561;
      if (!os_log_type_enabled(v62, (os_log_type_t)v561)) {
        goto LABEL_179;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v45;
      nw_connection_t v64 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_178;
    }
    BOOL v68 = p_output_handler;
    __int16 v69 = (char *)__nw_create_backtrace_string();
    os_log_type_t v62 = __nwlog_obj();
    os_log_type_t v63 = v561;
    BOOL v70 = os_log_type_enabled(v62, (os_log_type_t)v561);
    if (!v69)
    {
      p_output_handler = v68;
      if (!v70) {
        goto LABEL_179;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v45;
      nw_connection_t v64 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, no backtrace";
      goto LABEL_178;
    }
    if (v70)
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v45;
      *(_WORD *)&v560[4] = 2082;
      *(void *)&v560[6] = v69;
      _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v69);
    p_output_handler = v68;
LABEL_179:
    if (!v61) {
      goto LABEL_181;
    }
    goto LABEL_180;
  }
  if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4384, uu, 0x10u)) {
    goto LABEL_181;
  }
  int v53 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  __int16 v54 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2080;
    *(void *)v560 = (char *)a1 + 404;
    *(_WORD *)&v560[8] = 1024;
    *(_DWORD *)&v560[10] = v53;
    _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d", buf, 0x1Cu);
  }
  if (v53 != 2 && v53 != 22)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v53;
    BOOL v61 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v561) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v61, &v561, type) & 1) == 0) {
      goto LABEL_179;
    }
    if (v561 == 17)
    {
      os_log_type_t v62 = __nwlog_obj();
      os_log_type_t v63 = v561;
      if (!os_log_type_enabled(v62, (os_log_type_t)v561)) {
        goto LABEL_179;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v53;
      nw_connection_t v64 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d";
    }
    else
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v62 = __nwlog_obj();
        os_log_type_t v63 = v561;
        if (!os_log_type_enabled(v62, (os_log_type_t)v561)) {
          goto LABEL_179;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v53;
        nw_connection_t v64 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_178;
      }
      os_log_type_t v65 = p_output_handler;
      os_log_type_t v66 = (char *)__nw_create_backtrace_string();
      os_log_type_t v62 = __nwlog_obj();
      os_log_type_t v63 = v561;
      BOOL v67 = os_log_type_enabled(v62, (os_log_type_t)v561);
      if (v66)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v53;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v66;
          _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v66);
        p_output_handler = v65;
        if (!v61) {
          goto LABEL_181;
        }
LABEL_180:
        free(v61);
        goto LABEL_181;
      }
      p_output_handler = v65;
      if (!v67) {
        goto LABEL_179;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v53;
      nw_connection_t v64 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, no backtrace";
    }
LABEL_178:
    _os_log_impl(&dword_1830D4000, v62, v63, v64, buf, 0x12u);
    goto LABEL_179;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v47 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v53;
    __int16 v48 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d";
    goto LABEL_136;
  }
LABEL_181:
  uint64_t v71 = v44;
  int v72 = *(_DWORD *)(*((void *)v71 + 13) + 72);

  if (v72)
  {
    uint64_t v73 = nw_socket_set_traffic_class((uint64_t)p_output_handler, v72);
    if (v73)
    {
      uint64_t v74 = v73;
      uint64_t v75 = (uint64_t)p_output_handler;
LABEL_331:
      nw_socket_internal_error(v75, v74);
      return 0;
    }
  }
  BOOL v76 = v8;
  int v77 = [v76 type];

  if (v77 == 1 && identifier_low == 2 && setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 0x20000, &v556, 4u))
  {
    int v78 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v79 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v78;
      _os_log_impl(&dword_1830D4000, v79, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v80 = gLogObj;
    if (v78 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        _os_log_impl(&dword_1830D4000, v80, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_210;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v78;
    __int16 v81 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v561) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v81, &v561, type)) {
      goto LABEL_208;
    }
    if (v561 == 17)
    {
      char v82 = __nwlog_obj();
      os_log_type_t v83 = v561;
      if (!os_log_type_enabled(v82, (os_log_type_t)v561)) {
        goto LABEL_208;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v78;
      os_log_type_t v84 = "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d";
    }
    else if (type[0])
    {
      id v85 = p_output_handler;
      __int16 v86 = (char *)__nw_create_backtrace_string();
      char v82 = __nwlog_obj();
      os_log_type_t v83 = v561;
      BOOL v87 = os_log_type_enabled(v82, (os_log_type_t)v561);
      if (v86)
      {
        if (v87)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v78;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v86;
          _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v86);
        p_output_handler = v85;
        goto LABEL_208;
      }
      p_output_handler = v85;
      if (!v87)
      {
LABEL_208:
        if (v81) {
          free(v81);
        }
        goto LABEL_210;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v78;
      os_log_type_t v84 = "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      char v82 = __nwlog_obj();
      os_log_type_t v83 = v561;
      if (!os_log_type_enabled(v82, (os_log_type_t)v561)) {
        goto LABEL_208;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v78;
      os_log_type_t v84 = "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v82, v83, v84, buf, 0x12u);
    goto LABEL_208;
  }
LABEL_210:
  pid_t v88 = getpid();
  id v89 = v71;
  uint64_t v90 = v89;
  int v91 = *(_DWORD *)(*((void *)v71 + 13) + 64);
  BOOL v93 = v91 > 0 && v91 != v88;

  if (v93)
  {
    LODWORD(v561) = 0;
    os_log_type_t v94 = v90;
    int v95 = *(_DWORD *)(*((void *)v71 + 13) + 64);

    LODWORD(v561) = v95;
    if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4359, &v561, 4u))
    {
      if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v117 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 2082;
          *(void *)v560 = (char *)a1 + 404;
          *(_WORD *)&v560[8] = 1024;
          *(_DWORD *)&v560[10] = v561;
          os_log_type_t v109 = "%{public}s %{public}s successfully set source application pid to %d";
          os_log_type_t v110 = v117;
          os_log_type_t v111 = OS_LOG_TYPE_DEBUG;
          uint32_t v112 = 28;
          goto LABEL_261;
        }
      }
      goto LABEL_224;
    }
    int v96 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v97 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v561;
      *(_WORD *)&v560[14] = 1024;
      *(_DWORD *)&v560[16] = v96;
      _os_log_impl(&dword_1830D4000, v97, OS_LOG_TYPE_ERROR, "%{public}s %s set source pid to %d failed %{darwin.errno}d", buf, 0x22u);
    }
  }
  BOOL v98 = v90;
  if (uuid_is_null((const unsigned __int8 *)(*((void *)v71 + 13) + 24)))
  {

    goto LABEL_224;
  }
  BOOL v104 = uuid_compare((const unsigned __int8 *)(*((void *)v71 + 13) + 24), (const unsigned __int8 *)(*((void *)v71 + 13) + 8)) == 0;

  if (v104) {
    goto LABEL_224;
  }
  long long v561 = 0uLL;
  size_t v105 = v98;
  long long v561 = *(_OWORD *)(*((void *)v71 + 13) + 24);

  if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4360, &v561, 0x10u))
  {
    int v106 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v107 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v106;
      _os_log_impl(&dword_1830D4000, v107, OS_LOG_TYPE_ERROR, "%{public}s %s set source app uuid failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v108 = gLogObj;
    if (v106 == 22)
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_224;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = 22;
      os_log_type_t v109 = "%{public}s set source app uuid failed %{darwin.errno}d";
      os_log_type_t v110 = v108;
      os_log_type_t v111 = OS_LOG_TYPE_ERROR;
      uint32_t v112 = 18;
LABEL_261:
      _os_log_impl(&dword_1830D4000, v110, v111, v109, buf, v112);
      goto LABEL_224;
    }
    os_log_type_t v124 = p_output_handler;
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v106;
    os_log_type_t v125 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v553[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v125, type, v553)) {
      goto LABEL_423;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v126 = __nwlog_obj();
      os_log_type_t v127 = type[0];
      if (os_log_type_enabled(v126, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v106;
        os_log_type_t v128 = "%{public}s set source app uuid failed %{darwin.errno}d";
LABEL_422:
        _os_log_impl(&dword_1830D4000, v126, v127, v128, buf, 0x12u);
      }
    }
    else if (v553[0])
    {
      v541 = v76;
      os_log_type_t v151 = (char *)__nw_create_backtrace_string();
      id v126 = __nwlog_obj();
      os_log_type_t v127 = type[0];
      BOOL v152 = os_log_type_enabled(v126, type[0]);
      if (v151)
      {
        if (v152)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v106;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v151;
          _os_log_impl(&dword_1830D4000, v126, v127, "%{public}s set source app uuid failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v151);
        BOOL v76 = v541;
        goto LABEL_423;
      }
      BOOL v76 = v541;
      if (v152)
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v106;
        os_log_type_t v128 = "%{public}s set source app uuid failed %{darwin.errno}d, no backtrace";
        goto LABEL_422;
      }
    }
    else
    {
      id v126 = __nwlog_obj();
      os_log_type_t v127 = type[0];
      if (os_log_type_enabled(v126, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v106;
        os_log_type_t v128 = "%{public}s set source app uuid failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_422;
      }
    }
LABEL_423:
    if (v125) {
      free(v125);
    }
    p_output_handler = v124;
    goto LABEL_224;
  }
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v123 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2082;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1042;
      *(_DWORD *)&v560[10] = 16;
      *(_WORD *)&v560[14] = 2098;
      *(void *)&v560[16] = &v561;
      os_log_type_t v109 = "%{public}s %{public}s successfully set source application uuid to %{public,uuid_t}.16P";
      os_log_type_t v110 = v123;
      os_log_type_t v111 = OS_LOG_TYPE_DEBUG;
      uint32_t v112 = 38;
      goto LABEL_261;
    }
  }
LABEL_224:
  LODWORD(v561) = 0;
  os_log_type_t v99 = v90;
  int v100 = *(unsigned __int8 *)(*((void *)v71 + 13) + 107);

  LODWORD(v561) = v100;
  if (!v100 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4400, &v561, 4u)) {
    goto LABEL_273;
  }
  int v101 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  BOOL v102 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446978;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2080;
    *(void *)v560 = (char *)a1 + 404;
    *(_WORD *)&v560[8] = 1024;
    *(_DWORD *)&v560[10] = v561;
    *(_WORD *)&v560[14] = 1024;
    *(_DWORD *)&v560[16] = v101;
    _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d", buf, 0x22u);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v103 = gLogObj;
  if (v101 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v561;
      *(_WORD *)&v560[4] = 1024;
      *(_DWORD *)&v560[6] = 22;
      _os_log_impl(&dword_1830D4000, v103, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d", buf, 0x18u);
    }
    goto LABEL_273;
  }
  v544 = p_output_handler;
  *(_DWORD *)buf = 136446722;
  v558 = "nw_socket_set_common_sockopts";
  __int16 v559 = 1024;
  *(_DWORD *)v560 = v561;
  *(_WORD *)&v560[4] = 1024;
  *(_DWORD *)&v560[6] = v101;
  size_t v113 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v553[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v113, type, v553))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      size_t v114 = __nwlog_obj();
      os_log_type_t v115 = type[0];
      if (os_log_type_enabled(v114, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v561;
        *(_WORD *)&v560[4] = 1024;
        *(_DWORD *)&v560[6] = v101;
        char v116 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d";
LABEL_268:
        os_log_type_t v129 = v114;
        os_log_type_t v130 = v115;
LABEL_269:
        _os_log_impl(&dword_1830D4000, v129, v130, v116, buf, 0x18u);
      }
    }
    else if (v553[0])
    {
      os_log_type_t v118 = v76;
      size_t v119 = (char *)__nw_create_backtrace_string();
      size_t v120 = __nwlog_obj();
      os_log_type_t v121 = type[0];
      BOOL v122 = os_log_type_enabled(v120, type[0]);
      if (v119)
      {
        if (v122)
        {
          *(_DWORD *)buf = 136446978;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v561;
          *(_WORD *)&v560[4] = 1024;
          *(_DWORD *)&v560[6] = v101;
          *(_WORD *)&v560[10] = 2082;
          *(void *)&v560[12] = v119;
          _os_log_impl(&dword_1830D4000, v120, v121, "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v119);
        BOOL v76 = v118;
        goto LABEL_270;
      }
      BOOL v76 = v118;
      if (v122)
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v561;
        *(_WORD *)&v560[4] = 1024;
        *(_DWORD *)&v560[6] = v101;
        char v116 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, no backtrace";
        os_log_type_t v129 = v120;
        os_log_type_t v130 = v121;
        goto LABEL_269;
      }
    }
    else
    {
      size_t v114 = __nwlog_obj();
      os_log_type_t v115 = type[0];
      if (os_log_type_enabled(v114, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v561;
        *(_WORD *)&v560[4] = 1024;
        *(_DWORD *)&v560[6] = v101;
        char v116 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_268;
      }
    }
  }
LABEL_270:
  if (v113) {
    free(v113);
  }
  p_output_handler = v544;
LABEL_273:
  *(_DWORD *)os_log_type_t type = 0;
  if (nw_parameters_get_prohibit_cellular(v99)) {
    *(_DWORD *)type |= 4u;
  }
  os_log_type_t v131 = v99;
  BOOL v132 = (*(_WORD *)(*((void *)v71 + 13) + 100) & 1) == 0;

  if (!v132) {
    *(_DWORD *)type |= 8u;
  }
  os_log_type_t v133 = v131;
  BOOL v134 = (*(_WORD *)(*((void *)v71 + 13) + 100) & 2) == 0;

  if (v134)
  {
    if (!*(_DWORD *)type) {
      goto LABEL_290;
    }
  }
  else
  {
    *(_DWORD *)type |= 0x10u;
  }
  if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4225, type, 4u))
  {
    uint64_t v49 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v135 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v49;
      _os_log_impl(&dword_1830D4000, v135, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v51 = gLogObj;
    if (v49 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        __int16 v52 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d";
        goto LABEL_289;
      }
      goto LABEL_329;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v49;
    int v55 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v55, v553, v552)) {
      goto LABEL_327;
    }
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = v553[0];
      if (!os_log_type_enabled(v56, v553[0])) {
        goto LABEL_327;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      BOOL v58 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d";
      goto LABEL_326;
    }
    if (v552[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = v553[0];
      if (!os_log_type_enabled(v56, v553[0])) {
        goto LABEL_327;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      BOOL v58 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_326;
    }
    char v142 = (char *)__nw_create_backtrace_string();
    uint64_t v56 = __nwlog_obj();
    os_log_type_t v57 = v553[0];
    BOOL v143 = os_log_type_enabled(v56, v553[0]);
    if (!v142)
    {
      if (!v143) {
        goto LABEL_327;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      BOOL v58 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d, no backtrace";
      goto LABEL_326;
    }
    if (v143)
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      *(_WORD *)&v560[4] = 2082;
      *(void *)&v560[6] = v142;
      _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v142);
LABEL_327:
    if (!v55) {
      goto LABEL_329;
    }
LABEL_328:
    free(v55);
    goto LABEL_329;
  }
LABEL_290:
  BOOL v136 = v133;
  BOOL v137 = (*(_WORD *)(*((void *)v71 + 13) + 108) & 0x80) == 0;

  if (v137 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 0x10000, &v556, 4u)) {
    goto LABEL_345;
  }
  int v138 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v139 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2080;
    *(void *)v560 = (char *)a1 + 404;
    *(_WORD *)&v560[8] = 1024;
    *(_DWORD *)&v560[10] = v138;
    _os_log_impl(&dword_1830D4000, v139, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", buf, 0x1Cu);
  }
  BOOL v140 = __nwlog_obj();
  char v141 = v140;
  if (v138 == 22)
  {
    if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = 22;
      _os_log_impl(&dword_1830D4000, v141, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_345;
  }
  os_log_type_t v144 = p_output_handler;
  *(_DWORD *)buf = 136446466;
  v558 = "nw_socket_set_common_sockopts";
  __int16 v559 = 1024;
  *(_DWORD *)v560 = v138;
  BOOL v145 = (char *)_os_log_send_and_compose_impl();
  v553[0] = OS_LOG_TYPE_ERROR;
  v552[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v145, v553, v552))
  {
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v146 = __nwlog_obj();
      os_log_type_t v147 = v553[0];
      if (os_log_type_enabled(v146, v553[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v138;
        BOOL v148 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d";
LABEL_341:
        _os_log_impl(&dword_1830D4000, v146, v147, v148, buf, 0x12u);
      }
    }
    else if (v552[0])
    {
      v540 = v76;
      os_log_type_t v149 = (char *)__nw_create_backtrace_string();
      __int16 v146 = __nwlog_obj();
      os_log_type_t v147 = v553[0];
      BOOL v150 = os_log_type_enabled(v146, v553[0]);
      if (v149)
      {
        if (v150)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v138;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v149;
          _os_log_impl(&dword_1830D4000, v146, v147, "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v149);
        BOOL v76 = v540;
        goto LABEL_342;
      }
      BOOL v76 = v540;
      if (v150)
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v138;
        BOOL v148 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, no backtrace";
        goto LABEL_341;
      }
    }
    else
    {
      __int16 v146 = __nwlog_obj();
      os_log_type_t v147 = v553[0];
      if (os_log_type_enabled(v146, v553[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v138;
        BOOL v148 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_341;
      }
    }
  }
LABEL_342:
  if (v145) {
    free(v145);
  }
  p_output_handler = v144;
LABEL_345:
  os_log_type_t v154 = v136;
  BOOL v155 = (v154[12] & 0x200) == 0;

  if (v155 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4356, &v556, 4u)) {
    goto LABEL_370;
  }
  int v156 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v157 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2080;
    *(void *)v560 = (char *)a1 + 404;
    *(_WORD *)&v560[8] = 1024;
    *(_DWORD *)&v560[10] = v156;
    _os_log_impl(&dword_1830D4000, v157, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d", buf, 0x1Cu);
  }
  os_log_type_t v158 = __nwlog_obj();
  os_log_type_t v159 = v158;
  if (v156 == 22)
  {
    if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = 22;
      _os_log_impl(&dword_1830D4000, v159, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_370;
  }
  os_log_type_t v160 = v76;
  int v161 = v154;
  xpc_object_t v162 = p_output_handler;
  *(_DWORD *)buf = 136446466;
  v558 = "nw_socket_set_common_sockopts";
  __int16 v559 = 1024;
  *(_DWORD *)v560 = v156;
  unsigned int v163 = (char *)_os_log_send_and_compose_impl();
  v553[0] = OS_LOG_TYPE_ERROR;
  v552[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v163, v553, v552))
  {
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v164 = __nwlog_obj();
      os_log_type_t v165 = v553[0];
      if (os_log_type_enabled(v164, v553[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v156;
        id v166 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d";
LABEL_365:
        os_log_type_t v171 = v164;
        os_log_type_t v172 = v165;
LABEL_366:
        _os_log_impl(&dword_1830D4000, v171, v172, v166, buf, 0x12u);
      }
    }
    else if (v552[0])
    {
      v167 = (char *)__nw_create_backtrace_string();
      os_log_type_t v168 = __nwlog_obj();
      os_log_type_t v169 = v553[0];
      BOOL v170 = os_log_type_enabled(v168, v553[0]);
      if (v167)
      {
        if (v170)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v156;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v167;
          _os_log_impl(&dword_1830D4000, v168, v169, "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v167);
        goto LABEL_367;
      }
      if (v170)
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v156;
        id v166 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace";
        os_log_type_t v171 = v168;
        os_log_type_t v172 = v169;
        goto LABEL_366;
      }
    }
    else
    {
      unsigned int v164 = __nwlog_obj();
      os_log_type_t v165 = v553[0];
      if (os_log_type_enabled(v164, v553[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v156;
        id v166 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_365;
      }
    }
  }
LABEL_367:
  if (v163) {
    free(v163);
  }
  p_output_handler = v162;
  os_log_type_t v154 = v161;
  BOOL v76 = v160;
LABEL_370:
  os_log_type_t v173 = v154;
  BOOL v174 = ((*(unsigned __int16 *)(*((void *)v71 + 13) + 108) | (*(unsigned __int8 *)(*((void *)v71 + 13) + 110) << 16)) & 0x10000) == 0;

  if (v174 || (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4393, &v556, 4u) & 0x80000000) == 0) {
    goto LABEL_397;
  }
  int v175 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v176 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2080;
    *(void *)v560 = (char *)a1 + 404;
    *(_WORD *)&v560[8] = 1024;
    *(_DWORD *)&v560[10] = v175;
    _os_log_impl(&dword_1830D4000, v176, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d", buf, 0x1Cu);
  }
  id v177 = __nwlog_obj();
  uint64_t v178 = v177;
  if (v175 == 22)
  {
    if (os_log_type_enabled(v177, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = 22;
      _os_log_impl(&dword_1830D4000, v178, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_397;
  }
  BOOL v179 = v76;
  os_log_type_t v180 = v154;
  unsigned int v181 = p_output_handler;
  *(_DWORD *)buf = 136446466;
  v558 = "nw_socket_set_common_sockopts";
  __int16 v559 = 1024;
  *(_DWORD *)v560 = v175;
  os_log_type_t v182 = (char *)_os_log_send_and_compose_impl();
  v553[0] = OS_LOG_TYPE_ERROR;
  v552[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v182, v553, v552))
  {
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v183 = __nwlog_obj();
      os_log_type_t v184 = v553[0];
      if (os_log_type_enabled(v183, v553[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v175;
        nw_interface_t v185 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d";
LABEL_392:
        BOOL v190 = v183;
        os_log_type_t v191 = v184;
LABEL_393:
        _os_log_impl(&dword_1830D4000, v190, v191, v185, buf, 0x12u);
      }
    }
    else if (v552[0])
    {
      xpc_object_t v186 = (char *)__nw_create_backtrace_string();
      os_log_type_t v187 = __nwlog_obj();
      os_log_type_t v188 = v553[0];
      BOOL v189 = os_log_type_enabled(v187, v553[0]);
      if (v186)
      {
        if (v189)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v175;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v186;
          _os_log_impl(&dword_1830D4000, v187, v188, "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v186);
        goto LABEL_394;
      }
      if (v189)
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v175;
        nw_interface_t v185 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, no backtrace";
        BOOL v190 = v187;
        os_log_type_t v191 = v188;
        goto LABEL_393;
      }
    }
    else
    {
      unint64_t v183 = __nwlog_obj();
      os_log_type_t v184 = v553[0];
      if (os_log_type_enabled(v183, v553[0]))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v175;
        nw_interface_t v185 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_392;
      }
    }
  }
LABEL_394:
  if (v182) {
    free(v182);
  }
  p_output_handler = v181;
  os_log_type_t v154 = v180;
  BOOL v76 = v179;
LABEL_397:
  os_log_type_t v192 = v173;
  os_log_type_t v193 = v192[19].isa;

  uint64_t v545 = (uint64_t)p_output_handler;
  nw_protocol_options_t v194 = nw_protocol_stack_copy_internet_protocol(v193);
  nw_protocol_options_t v195 = nw_protocol_stack_copy_transport_protocol(v193);
  if (v193) {
    os_release(v193);
  }
  int v196 = identifier_low;
  v539 = v192;
  if (v194)
  {
    v542 = v76;
    if (!nw_ip_options_get_calculate_receive_time(v194)
      || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 0x40000, &v556, 4u))
    {
      goto LABEL_432;
    }
    int v197 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    nw_interface_t v198 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v197;
      _os_log_impl(&dword_1830D4000, v198, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d", buf, 0x1Cu);
    }
    os_log_type_t v199 = __nwlog_obj();
    uint64_t v200 = v199;
    if (v197 == 22)
    {
      if (os_log_type_enabled(v199, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        _os_log_impl(&dword_1830D4000, v200, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_432;
    }
    v201 = v154;
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v197;
    int v202 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v202, v553, v552))
    {
      if (v553[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v203 = __nwlog_obj();
        os_log_type_t v204 = v553[0];
        if (os_log_type_enabled(v203, v553[0]))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v197;
          nw_endpoint_t v205 = "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d";
LABEL_428:
          _os_log_impl(&dword_1830D4000, v203, v204, v205, buf, 0x12u);
        }
      }
      else if (v552[0])
      {
        uint64_t v206 = (char *)__nw_create_backtrace_string();
        os_log_type_t v203 = __nwlog_obj();
        os_log_type_t v204 = v553[0];
        BOOL v207 = os_log_type_enabled(v203, v553[0]);
        if (v206)
        {
          if (v207)
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v197;
            *(_WORD *)&v560[4] = 2082;
            *(void *)&v560[6] = v206;
            _os_log_impl(&dword_1830D4000, v203, v204, "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v206);
          int v196 = identifier_low;
          goto LABEL_429;
        }
        int v196 = identifier_low;
        if (v207)
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v197;
          nw_endpoint_t v205 = "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d, no backtrace";
          goto LABEL_428;
        }
      }
      else
      {
        os_log_type_t v203 = __nwlog_obj();
        os_log_type_t v204 = v553[0];
        if (os_log_type_enabled(v203, v553[0]))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v197;
          nw_endpoint_t v205 = "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_428;
        }
      }
    }
LABEL_429:
    if (v202) {
      free(v202);
    }
    os_log_type_t v154 = v201;
    os_log_type_t v192 = v539;
LABEL_432:
    *(_DWORD *)v553 = 0;
    *(_DWORD *)v553 = nw_ip_options_get_hop_limit(v194);
    if (!*(_DWORD *)v553) {
      goto LABEL_496;
    }
    if (v196 == 2)
    {
      if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0, 4, v553, 4u))
      {
        if (!nw_ip_options_get_receive_hop_limit(v194)) {
          goto LABEL_547;
        }
        goto LABEL_498;
      }
      int v208 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v209 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v208;
        _os_log_impl(&dword_1830D4000, v209, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_TTL failed %{darwin.errno}d", buf, 0x1Cu);
      }
      os_log_type_t v210 = __nwlog_obj();
      os_log_type_t v211 = v210;
      if (v208 == 22)
      {
        if (!os_log_type_enabled(v210, OS_LOG_TYPE_ERROR)) {
          goto LABEL_496;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        v212 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d";
LABEL_451:
        _os_log_impl(&dword_1830D4000, v211, OS_LOG_TYPE_ERROR, v212, buf, 0x12u);
        goto LABEL_496;
      }
      os_log_type_t v216 = v154;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v208;
      os_log_type_t v217 = (char *)_os_log_send_and_compose_impl();
      v552[0] = OS_LOG_TYPE_ERROR;
      v550[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v217, v552, v550))
      {
        if (v552[0] == OS_LOG_TYPE_FAULT)
        {
          __int16 v218 = __nwlog_obj();
          os_log_type_t v219 = v552[0];
          if (!os_log_type_enabled(v218, v552[0])) {
            goto LABEL_493;
          }
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v208;
          id v220 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d";
          goto LABEL_492;
        }
        if (v550[0] == OS_LOG_TYPE_DEFAULT)
        {
          __int16 v218 = __nwlog_obj();
          os_log_type_t v219 = v552[0];
          if (!os_log_type_enabled(v218, v552[0])) {
            goto LABEL_493;
          }
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v208;
          id v220 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_492;
        }
        v221 = (char *)__nw_create_backtrace_string();
        __int16 v218 = __nwlog_obj();
        os_log_type_t v219 = v552[0];
        BOOL v222 = os_log_type_enabled(v218, v552[0]);
        if (v221)
        {
          if (v222)
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v208;
            *(_WORD *)&v560[4] = 2082;
            *(void *)&v560[6] = v221;
            _os_log_impl(&dword_1830D4000, v218, v219, "%{public}s setsockopt IP_TTL failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v221);
          int v196 = identifier_low;
          if (!v217) {
            goto LABEL_495;
          }
          goto LABEL_494;
        }
        int v196 = identifier_low;
        if (v222)
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v208;
          id v220 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d, no backtrace";
LABEL_492:
          _os_log_impl(&dword_1830D4000, v218, v219, v220, buf, 0x12u);
        }
      }
    }
    else
    {
      if (v196 != 30 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 47, v553, 4u))
      {
LABEL_496:
        if (!nw_ip_options_get_receive_hop_limit(v194)) {
          goto LABEL_547;
        }
        if (v196 != 2)
        {
          if (v196 != 30 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 37, &v556, 4u)) {
            goto LABEL_547;
          }
          int v234 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v235 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 2080;
            *(void *)v560 = (char *)a1 + 404;
            *(_WORD *)&v560[8] = 1024;
            *(_DWORD *)&v560[10] = v234;
            _os_log_impl(&dword_1830D4000, v235, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d", buf, 0x1Cu);
          }
          os_log_type_t v236 = __nwlog_obj();
          v232 = v236;
          if (v234 == 22)
          {
            if (os_log_type_enabled(v236, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = 22;
              os_log_type_t v233 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d";
              goto LABEL_515;
            }
LABEL_547:
            if (nw_ip_options_get_fragmentation_value(v194) == 1
              || nw_parameters_get_upper_transport_protocol(v192) == 253)
            {
              if (v196 == 2)
              {
                v246 = v542;
                if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0, 28, &v556, 4u))
                {
LABEL_569:
                  int v251 = 0;
                  goto LABEL_663;
                }
                int v247 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                os_log_type_t v248 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 2080;
                  *(void *)v560 = (char *)a1 + 404;
                  *(_WORD *)&v560[8] = 1024;
                  *(_DWORD *)&v560[10] = v247;
                  _os_log_impl(&dword_1830D4000, v248, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_DONTFRAG failed %{darwin.errno}d", buf, 0x1Cu);
                }
                os_log_type_t v249 = __nwlog_obj();
                int v250 = v249;
                if (v247 == 22)
                {
                  if (os_log_type_enabled(v249, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = 22;
                    _os_log_impl(&dword_1830D4000, v250, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d", buf, 0x12u);
                    int v251 = 0;
                    goto LABEL_663;
                  }
                  goto LABEL_569;
                }
                v538 = v154;
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v247;
                os_log_type_t v256 = (char *)_os_log_send_and_compose_impl();
                v552[0] = OS_LOG_TYPE_ERROR;
                v550[0] = OS_LOG_TYPE_DEFAULT;
                if (!__nwlog_fault(v256, v552, v550)) {
                  goto LABEL_593;
                }
                if (v552[0] == OS_LOG_TYPE_FAULT)
                {
                  v257 = __nwlog_obj();
                  os_log_type_t v258 = v552[0];
                  if (os_log_type_enabled(v257, v552[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = v247;
                    BOOL v259 = "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d";
LABEL_592:
                    _os_log_impl(&dword_1830D4000, v257, v258, v259, buf, 0x12u);
                  }
                }
                else if (v550[0])
                {
                  os_log_type_t v265 = (char *)__nw_create_backtrace_string();
                  v257 = __nwlog_obj();
                  os_log_type_t v258 = v552[0];
                  BOOL v266 = os_log_type_enabled(v257, v552[0]);
                  if (v265)
                  {
                    if (v266)
                    {
                      *(_DWORD *)buf = 136446722;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v247;
                      *(_WORD *)&v560[4] = 2082;
                      *(void *)&v560[6] = v265;
                      _os_log_impl(&dword_1830D4000, v257, v258, "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                    }
                    free(v265);
                    int v196 = identifier_low;
                    goto LABEL_593;
                  }
                  int v196 = identifier_low;
                  if (v266)
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = v247;
                    BOOL v259 = "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d, no backtrace";
                    goto LABEL_592;
                  }
                }
                else
                {
                  v257 = __nwlog_obj();
                  os_log_type_t v258 = v552[0];
                  if (os_log_type_enabled(v257, v552[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = v247;
                    BOOL v259 = "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d, backtrace limit exceeded";
                    goto LABEL_592;
                  }
                }
LABEL_593:
                if (v256) {
                  free(v256);
                }
                int v251 = 0;
                v246 = v542;
                os_log_type_t v154 = v538;
LABEL_663:
                int is_multicast = nw_endpoint_is_multicast(v246);
                os_log_type_t v192 = v539;
                if (!is_multicast) {
                  goto LABEL_733;
                }
                BOOL disable_multicast_loopback = nw_ip_options_get_disable_multicast_loopback(v194);
                if (v196 == 2 && v195 && nw_protocol_options_is_udp(v195))
                {
                  if (disable_multicast_loopback) {
                    char v294 = &v555;
                  }
                  else {
                    char v294 = &v556;
                  }
                  if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0, 11, v294, 4u)) {
                    goto LABEL_733;
                  }
                  int v295 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  uint64_t v296 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446722;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 2080;
                    *(void *)v560 = (char *)a1 + 404;
                    *(_WORD *)&v560[8] = 1024;
                    *(_DWORD *)&v560[10] = v295;
                    _os_log_impl(&dword_1830D4000, v296, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d", buf, 0x1Cu);
                  }
                  uint64_t v297 = __nwlog_obj();
                  int v298 = v297;
                  if (v295 == 22)
                  {
                    if (os_log_type_enabled(v297, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = 22;
                      char v299 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d";
                      v300 = v298;
                      os_log_type_t v301 = OS_LOG_TYPE_ERROR;
                      uint32_t v302 = 18;
LABEL_732:
                      _os_log_impl(&dword_1830D4000, v300, v301, v299, buf, v302);
                      goto LABEL_733;
                    }
                    goto LABEL_733;
                  }
                  v309 = v154;
                  *(_DWORD *)buf = 136446466;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 1024;
                  *(_DWORD *)v560 = v295;
                  __int16 v310 = (char *)_os_log_send_and_compose_impl();
                  v552[0] = OS_LOG_TYPE_ERROR;
                  v550[0] = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v310, v552, v550))
                  {
                    if (v552[0] == OS_LOG_TYPE_FAULT)
                    {
                      v311 = __nwlog_obj();
                      os_log_type_t v312 = v552[0];
                      if (os_log_type_enabled(v311, v552[0]))
                      {
                        *(_DWORD *)buf = 136446466;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v295;
                        v313 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d";
LABEL_718:
                        _os_log_impl(&dword_1830D4000, v311, v312, v313, buf, 0x12u);
                      }
                    }
                    else if (v550[0])
                    {
                      v319 = (char *)__nw_create_backtrace_string();
                      v311 = __nwlog_obj();
                      os_log_type_t v312 = v552[0];
                      BOOL v320 = os_log_type_enabled(v311, v552[0]);
                      if (v319)
                      {
                        if (v320)
                        {
                          *(_DWORD *)buf = 136446722;
                          v558 = "nw_socket_set_common_sockopts";
                          __int16 v559 = 1024;
                          *(_DWORD *)v560 = v295;
                          *(_WORD *)&v560[4] = 2082;
                          *(void *)&v560[6] = v319;
                          _os_log_impl(&dword_1830D4000, v311, v312, "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                        }
                        free(v319);
                        goto LABEL_719;
                      }
                      if (v320)
                      {
                        *(_DWORD *)buf = 136446466;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v295;
                        v313 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d, no backtrace";
                        goto LABEL_718;
                      }
                    }
                    else
                    {
                      v311 = __nwlog_obj();
                      os_log_type_t v312 = v552[0];
                      if (os_log_type_enabled(v311, v552[0]))
                      {
                        *(_DWORD *)buf = 136446466;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v295;
                        v313 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d, backtrace limit exceeded";
                        goto LABEL_718;
                      }
                    }
                  }
LABEL_719:
                  if (v310) {
                    free(v310);
                  }
                  os_log_type_t v154 = v309;
                  os_log_type_t v192 = v539;
                  goto LABEL_733;
                }
                if (v195) {
                  int v303 = v251;
                }
                else {
                  int v303 = 0;
                }
                if (v303 != 1 || !nw_protocol_options_is_udp(v195)) {
                  goto LABEL_733;
                }
                if (disable_multicast_loopback) {
                  v304 = &v555;
                }
                else {
                  v304 = &v556;
                }
                if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 11, v304, 4u))
                {
LABEL_728:
                  v324 = __nwlog_obj();
                  if (os_log_type_enabled(v324, OS_LOG_TYPE_DEBUG))
                  {
                    v325 = "Enabled";
                    if (disable_multicast_loopback) {
                      v325 = "Disabled";
                    }
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 2080;
                    *(void *)v560 = v325;
                    char v299 = "%{public}s %s multicast loopback";
                    v300 = v324;
                    os_log_type_t v301 = OS_LOG_TYPE_DEBUG;
                    uint32_t v302 = 22;
                    goto LABEL_732;
                  }
LABEL_733:
                  os_release(v194);
                  BOOL v76 = v542;
                  goto LABEL_734;
                }
                int v305 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                __int16 v306 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 2080;
                  *(void *)v560 = (char *)a1 + 404;
                  *(_WORD *)&v560[8] = 1024;
                  *(_DWORD *)&v560[10] = v305;
                  _os_log_impl(&dword_1830D4000, v306, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d", buf, 0x1Cu);
                }
                v307 = __nwlog_obj();
                v308 = v307;
                if (v305 == 22)
                {
                  if (os_log_type_enabled(v307, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = 22;
                    _os_log_impl(&dword_1830D4000, v308, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d", buf, 0x12u);
                  }
                  goto LABEL_728;
                }
                v314 = v154;
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v305;
                v315 = (char *)_os_log_send_and_compose_impl();
                v552[0] = OS_LOG_TYPE_ERROR;
                v550[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v315, v552, v550))
                {
                  if (v552[0] == OS_LOG_TYPE_FAULT)
                  {
                    v316 = __nwlog_obj();
                    os_log_type_t v317 = v552[0];
                    if (os_log_type_enabled(v316, v552[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v305;
                      v318 = "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d";
LABEL_724:
                      _os_log_impl(&dword_1830D4000, v316, v317, v318, buf, 0x12u);
                    }
                  }
                  else if (v550[0])
                  {
                    v321 = v315;
                    v322 = (char *)__nw_create_backtrace_string();
                    v316 = __nwlog_obj();
                    os_log_type_t v317 = v552[0];
                    BOOL v323 = os_log_type_enabled(v316, v552[0]);
                    if (v322)
                    {
                      if (v323)
                      {
                        *(_DWORD *)buf = 136446722;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v305;
                        *(_WORD *)&v560[4] = 2082;
                        *(void *)&v560[6] = v322;
                        _os_log_impl(&dword_1830D4000, v316, v317, "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v322);
                      v315 = v321;
                      goto LABEL_725;
                    }
                    v315 = v321;
                    if (v323)
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v305;
                      v318 = "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d, no backtrace";
                      goto LABEL_724;
                    }
                  }
                  else
                  {
                    v316 = __nwlog_obj();
                    os_log_type_t v317 = v552[0];
                    if (os_log_type_enabled(v316, v552[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v305;
                      v318 = "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_724;
                    }
                  }
                }
LABEL_725:
                os_log_type_t v192 = v539;
                if (v315) {
                  free(v315);
                }
                os_log_type_t v154 = v314;
                goto LABEL_728;
              }
              if (v196 == 30)
              {
                if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 62, &v556, 4u)) {
                  goto LABEL_604;
                }
                int v252 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                os_log_type_t v253 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 2080;
                  *(void *)v560 = (char *)a1 + 404;
                  *(_WORD *)&v560[8] = 1024;
                  *(_DWORD *)&v560[10] = v252;
                  _os_log_impl(&dword_1830D4000, v253, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d", buf, 0x1Cu);
                }
                os_log_type_t v254 = __nwlog_obj();
                os_log_type_t v255 = v254;
                if (v252 == 22)
                {
                  if (os_log_type_enabled(v254, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = 22;
                    _os_log_impl(&dword_1830D4000, v255, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d", buf, 0x12u);
                  }
                  goto LABEL_604;
                }
                os_log_type_t v260 = v154;
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v252;
                BOOL v261 = (char *)_os_log_send_and_compose_impl();
                v552[0] = OS_LOG_TYPE_ERROR;
                v550[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v261, v552, v550))
                {
                  if (v552[0] == OS_LOG_TYPE_FAULT)
                  {
                    os_log_type_t v262 = __nwlog_obj();
                    os_log_type_t v263 = v552[0];
                    if (os_log_type_enabled(v262, v552[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v252;
                      BOOL v264 = "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d";
LABEL_600:
                      _os_log_impl(&dword_1830D4000, v262, v263, v264, buf, 0x12u);
                    }
                  }
                  else if (v550[0])
                  {
                    os_log_type_t v267 = (char *)__nw_create_backtrace_string();
                    os_log_type_t v262 = __nwlog_obj();
                    os_log_type_t v263 = v552[0];
                    BOOL v268 = os_log_type_enabled(v262, v552[0]);
                    if (v267)
                    {
                      if (v268)
                      {
                        *(_DWORD *)buf = 136446722;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v252;
                        *(_WORD *)&v560[4] = 2082;
                        *(void *)&v560[6] = v267;
                        _os_log_impl(&dword_1830D4000, v262, v263, "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v267);
                      int v196 = identifier_low;
                      goto LABEL_601;
                    }
                    int v196 = identifier_low;
                    if (v268)
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v252;
                      BOOL v264 = "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d, no backtrace";
                      goto LABEL_600;
                    }
                  }
                  else
                  {
                    os_log_type_t v262 = __nwlog_obj();
                    os_log_type_t v263 = v552[0];
                    if (os_log_type_enabled(v262, v552[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v252;
                      BOOL v264 = "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_600;
                    }
                  }
                }
LABEL_601:
                if (v261) {
                  free(v261);
                }
                os_log_type_t v154 = v260;
LABEL_604:
                if (!nw_ip_options_get_use_minimum_mtu(v194)
                  || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 42, &v556, 4u))
                {
                  goto LABEL_630;
                }
                int v269 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                os_log_type_t v270 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 2080;
                  *(void *)v560 = (char *)a1 + 404;
                  *(_WORD *)&v560[8] = 1024;
                  *(_DWORD *)&v560[10] = v269;
                  _os_log_impl(&dword_1830D4000, v270, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d", buf, 0x1Cu);
                }
                os_log_type_t v271 = __nwlog_obj();
                os_log_type_t v272 = v271;
                if (v269 == 22)
                {
                  if (os_log_type_enabled(v271, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = 22;
                    _os_log_impl(&dword_1830D4000, v272, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d", buf, 0x12u);
                  }
                  goto LABEL_630;
                }
                os_log_type_t v273 = v154;
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v269;
                os_log_type_t v274 = (char *)_os_log_send_and_compose_impl();
                v552[0] = OS_LOG_TYPE_ERROR;
                v550[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v274, v552, v550))
                {
                  if (v552[0] == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v275 = __nwlog_obj();
                    os_log_type_t v276 = v552[0];
                    if (os_log_type_enabled(v275, v552[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v269;
                      int v277 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d";
LABEL_626:
                      _os_log_impl(&dword_1830D4000, v275, v276, v277, buf, 0x12u);
                    }
                  }
                  else if (v550[0])
                  {
                    uint64_t v278 = (char *)__nw_create_backtrace_string();
                    BOOL v275 = __nwlog_obj();
                    os_log_type_t v276 = v552[0];
                    BOOL v279 = os_log_type_enabled(v275, v552[0]);
                    if (v278)
                    {
                      if (v279)
                      {
                        *(_DWORD *)buf = 136446722;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v269;
                        *(_WORD *)&v560[4] = 2082;
                        *(void *)&v560[6] = v278;
                        _os_log_impl(&dword_1830D4000, v275, v276, "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v278);
                      int v196 = identifier_low;
                      goto LABEL_627;
                    }
                    int v196 = identifier_low;
                    if (v279)
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v269;
                      int v277 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, no backtrace";
                      goto LABEL_626;
                    }
                  }
                  else
                  {
                    BOOL v275 = __nwlog_obj();
                    os_log_type_t v276 = v552[0];
                    if (os_log_type_enabled(v275, v552[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v269;
                      int v277 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_626;
                    }
                  }
                }
LABEL_627:
                if (v274) {
                  free(v274);
                }
                os_log_type_t v154 = v273;
LABEL_630:
                int local_address_preference = nw_ip_options_get_local_address_preference(v194);
                v246 = v542;
                if (!local_address_preference)
                {
                  int v251 = 1;
                  goto LABEL_663;
                }
                *(_DWORD *)v552 = -1;
                if (local_address_preference == 2)
                {
                  *(_DWORD *)v552 = 0;
                }
                else if (local_address_preference == 1)
                {
                  *(_DWORD *)v552 = 1;
                }
                if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 63, v552, 4u)) {
                  goto LABEL_661;
                }
                int v281 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                size_t v282 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 2080;
                  *(void *)v560 = (char *)a1 + 404;
                  *(_WORD *)&v560[8] = 1024;
                  *(_DWORD *)&v560[10] = v281;
                  _os_log_impl(&dword_1830D4000, v282, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d", buf, 0x1Cu);
                }
                int v283 = __nwlog_obj();
                id v284 = v283;
                if (v281 == 22)
                {
                  if (os_log_type_enabled(v283, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = 22;
                    _os_log_impl(&dword_1830D4000, v284, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d", buf, 0x12u);
                  }
LABEL_661:
                  int v251 = 1;
                  goto LABEL_662;
                }
                unsigned int v285 = v154;
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v281;
                __int16 v286 = (char *)_os_log_send_and_compose_impl();
                v550[0] = OS_LOG_TYPE_ERROR;
                os_log_type_t v551 = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v286, v550, &v551))
                {
                  if (v550[0] == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v287 = __nwlog_obj();
                    os_log_type_t v288 = v550[0];
                    if (os_log_type_enabled(v287, v550[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v281;
                      long long v289 = "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d";
LABEL_657:
                      _os_log_impl(&dword_1830D4000, v287, v288, v289, buf, 0x12u);
                    }
                  }
                  else if (v551)
                  {
                    long long v290 = (char *)__nw_create_backtrace_string();
                    uint64_t v287 = __nwlog_obj();
                    os_log_type_t v288 = v550[0];
                    BOOL v291 = os_log_type_enabled(v287, v550[0]);
                    if (v290)
                    {
                      if (v291)
                      {
                        *(_DWORD *)buf = 136446722;
                        v558 = "nw_socket_set_common_sockopts";
                        __int16 v559 = 1024;
                        *(_DWORD *)v560 = v281;
                        *(_WORD *)&v560[4] = 2082;
                        *(void *)&v560[6] = v290;
                        _os_log_impl(&dword_1830D4000, v287, v288, "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v290);
                      int v196 = identifier_low;
                      goto LABEL_658;
                    }
                    int v196 = identifier_low;
                    if (v291)
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v281;
                      long long v289 = "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d, no backtrace";
                      goto LABEL_657;
                    }
                  }
                  else
                  {
                    uint64_t v287 = __nwlog_obj();
                    os_log_type_t v288 = v550[0];
                    if (os_log_type_enabled(v287, v550[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v558 = "nw_socket_set_common_sockopts";
                      __int16 v559 = 1024;
                      *(_DWORD *)v560 = v281;
                      long long v289 = "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_657;
                    }
                  }
                }
LABEL_658:
                if (v286) {
                  free(v286);
                }
                os_log_type_t v154 = v285;
                goto LABEL_661;
              }
            }
            else if (v196 == 30)
            {
              goto LABEL_604;
            }
            int v251 = 0;
LABEL_662:
            v246 = v542;
            goto LABEL_663;
          }
          os_log_type_t v237 = v154;
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v234;
          BOOL v238 = (char *)_os_log_send_and_compose_impl();
          v552[0] = OS_LOG_TYPE_ERROR;
          v550[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v238, v552, v550))
          {
            if (v552[0] == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v239 = __nwlog_obj();
              os_log_type_t v240 = v552[0];
              if (!os_log_type_enabled(v239, v552[0])) {
                goto LABEL_544;
              }
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v234;
              nw_protocol_options_t v241 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d";
              goto LABEL_543;
            }
            if (v550[0] == OS_LOG_TYPE_DEFAULT)
            {
              os_log_type_t v239 = __nwlog_obj();
              os_log_type_t v240 = v552[0];
              if (!os_log_type_enabled(v239, v552[0])) {
                goto LABEL_544;
              }
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v234;
              nw_protocol_options_t v241 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_543;
            }
            v244 = (char *)__nw_create_backtrace_string();
            os_log_type_t v239 = __nwlog_obj();
            os_log_type_t v240 = v552[0];
            BOOL v245 = os_log_type_enabled(v239, v552[0]);
            if (!v244)
            {
              int v196 = identifier_low;
              if (!v245) {
                goto LABEL_544;
              }
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v234;
              nw_protocol_options_t v241 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d, no backtrace";
              goto LABEL_543;
            }
            if (v245)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v234;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v244;
              _os_log_impl(&dword_1830D4000, v239, v240, "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v244);
            int v196 = identifier_low;
          }
          goto LABEL_544;
        }
LABEL_498:
        if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0, 24, &v556, 4u)) {
          goto LABEL_547;
        }
        int v229 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v230 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 2080;
          *(void *)v560 = (char *)a1 + 404;
          *(_WORD *)&v560[8] = 1024;
          *(_DWORD *)&v560[10] = v229;
          _os_log_impl(&dword_1830D4000, v230, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_RECVTTL failed %{darwin.errno}d", buf, 0x1Cu);
        }
        os_log_type_t v231 = __nwlog_obj();
        v232 = v231;
        if (v229 == 22)
        {
          if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = 22;
            os_log_type_t v233 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d";
LABEL_515:
            _os_log_impl(&dword_1830D4000, v232, OS_LOG_TYPE_ERROR, v233, buf, 0x12u);
            goto LABEL_547;
          }
          goto LABEL_547;
        }
        os_log_type_t v237 = v154;
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v229;
        BOOL v238 = (char *)_os_log_send_and_compose_impl();
        v552[0] = OS_LOG_TYPE_ERROR;
        v550[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v238, v552, v550))
        {
          if (v552[0] == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v239 = __nwlog_obj();
            os_log_type_t v240 = v552[0];
            if (!os_log_type_enabled(v239, v552[0])) {
              goto LABEL_544;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v229;
            nw_protocol_options_t v241 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d";
            goto LABEL_543;
          }
          if (v550[0] == OS_LOG_TYPE_DEFAULT)
          {
            os_log_type_t v239 = __nwlog_obj();
            os_log_type_t v240 = v552[0];
            if (!os_log_type_enabled(v239, v552[0])) {
              goto LABEL_544;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v229;
            nw_protocol_options_t v241 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_543;
          }
          os_log_type_t v242 = (char *)__nw_create_backtrace_string();
          os_log_type_t v239 = __nwlog_obj();
          os_log_type_t v240 = v552[0];
          BOOL v243 = os_log_type_enabled(v239, v552[0]);
          if (v242)
          {
            if (v243)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v229;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v242;
              _os_log_impl(&dword_1830D4000, v239, v240, "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v242);
            int v196 = identifier_low;
            if (!v238) {
              goto LABEL_546;
            }
            goto LABEL_545;
          }
          int v196 = identifier_low;
          if (v243)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v229;
            nw_protocol_options_t v241 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d, no backtrace";
LABEL_543:
            _os_log_impl(&dword_1830D4000, v239, v240, v241, buf, 0x12u);
          }
        }
LABEL_544:
        if (!v238)
        {
LABEL_546:
          os_log_type_t v154 = v237;
          os_log_type_t v192 = v539;
          goto LABEL_547;
        }
LABEL_545:
        free(v238);
        goto LABEL_546;
      }
      int v213 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v214 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v213;
        _os_log_impl(&dword_1830D4000, v214, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d", buf, 0x1Cu);
      }
      os_log_type_t v215 = __nwlog_obj();
      os_log_type_t v211 = v215;
      if (v213 == 22)
      {
        if (!os_log_type_enabled(v215, OS_LOG_TYPE_ERROR)) {
          goto LABEL_496;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        v212 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d";
        goto LABEL_451;
      }
      os_log_type_t v216 = v154;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v213;
      os_log_type_t v217 = (char *)_os_log_send_and_compose_impl();
      v552[0] = OS_LOG_TYPE_ERROR;
      v550[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v217, v552, v550))
      {
        if (v552[0] == OS_LOG_TYPE_FAULT)
        {
          __int16 v218 = __nwlog_obj();
          os_log_type_t v219 = v552[0];
          if (!os_log_type_enabled(v218, v552[0])) {
            goto LABEL_493;
          }
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v213;
          id v220 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d";
          goto LABEL_492;
        }
        if (v550[0] == OS_LOG_TYPE_DEFAULT)
        {
          __int16 v218 = __nwlog_obj();
          os_log_type_t v219 = v552[0];
          if (!os_log_type_enabled(v218, v552[0])) {
            goto LABEL_493;
          }
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v213;
          id v220 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_492;
        }
        os_log_type_t v223 = (char *)__nw_create_backtrace_string();
        __int16 v218 = __nwlog_obj();
        os_log_type_t v219 = v552[0];
        BOOL v224 = os_log_type_enabled(v218, v552[0]);
        if (!v223)
        {
          int v196 = identifier_low;
          if (!v224) {
            goto LABEL_493;
          }
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v213;
          id v220 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d, no backtrace";
          goto LABEL_492;
        }
        if (v224)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v213;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v223;
          _os_log_impl(&dword_1830D4000, v218, v219, "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v223);
        int v196 = identifier_low;
      }
    }
LABEL_493:
    if (!v217)
    {
LABEL_495:
      os_log_type_t v154 = v216;
      os_log_type_t v192 = v539;
      goto LABEL_496;
    }
LABEL_494:
    free(v217);
    goto LABEL_495;
  }
LABEL_734:
  if (v195)
  {
    v326 = v195;
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
    }
    BOOL v327 = nw_protocol_options_matches_definition(v326, (void *)g_tcp_definition);

    if (v327)
    {
      if ((nw_socket_set_bidirectional_tcp_sockopts(v545, v326) & 1) == 0) {
        goto LABEL_1222;
      }
      ecn_uint64_t mode = nw_parameters_get_ecn_mode(v192);
      if (ecn_mode)
      {
        if (ecn_mode == 1) {
          int v329 = 1;
        }
        else {
          int v329 = 2;
        }
      }
      else
      {
        if (!nw_tcp_options_get_disable_ecn(v326)) {
          goto LABEL_789;
        }
        int v329 = 2;
      }
      *(_DWORD *)v553 = v329;
      if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 528, v553, 4u)) {
        goto LABEL_789;
      }
      int v335 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v336 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v335;
        _os_log_impl(&dword_1830D4000, v336, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_ECN_MODE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v337 = __nwlog_obj();
      v338 = v337;
      if (v335 == 22)
      {
        if (os_log_type_enabled(v337, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          _os_log_impl(&dword_1830D4000, v338, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_789;
      }
      v339 = v76;
      v340 = v154;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v335;
      v341 = (char *)_os_log_send_and_compose_impl();
      v552[0] = OS_LOG_TYPE_ERROR;
      v550[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v341, v552, v550))
      {
        if (v552[0] == OS_LOG_TYPE_FAULT)
        {
          v342 = __nwlog_obj();
          os_log_type_t v343 = v552[0];
          if (os_log_type_enabled(v342, v552[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v335;
            v344 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d";
LABEL_785:
            _os_log_impl(&dword_1830D4000, v342, v343, v344, buf, 0x12u);
          }
        }
        else if (v550[0])
        {
          v351 = (char *)__nw_create_backtrace_string();
          v342 = __nwlog_obj();
          os_log_type_t v343 = v552[0];
          BOOL v352 = os_log_type_enabled(v342, v552[0]);
          if (v351)
          {
            if (v352)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v335;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v351;
              _os_log_impl(&dword_1830D4000, v342, v343, "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v351);
            goto LABEL_786;
          }
          if (v352)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v335;
            v344 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, no backtrace";
            goto LABEL_785;
          }
        }
        else
        {
          v342 = __nwlog_obj();
          os_log_type_t v343 = v552[0];
          if (os_log_type_enabled(v342, v552[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v335;
            v344 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_785;
          }
        }
      }
LABEL_786:
      os_log_type_t v192 = v539;
      if (v341) {
        free(v341);
      }
      os_log_type_t v154 = v340;
      BOOL v76 = v339;
LABEL_789:
      int enable_l4s = nw_tcp_options_get_enable_l4s(v326);
      if (enable_l4s == 2) {
        goto LABEL_853;
      }
      *(_DWORD *)v553 = enable_l4s == 1;
      if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 539, v553, 4u)) {
        goto LABEL_853;
      }
      int v356 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v357 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v356;
        _os_log_impl(&dword_1830D4000, v357, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v358 = __nwlog_obj();
      v359 = v358;
      if (v356 == 22)
      {
        if (os_log_type_enabled(v358, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          _os_log_impl(&dword_1830D4000, v359, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_853;
      }
      v360 = v76;
      v361 = v154;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v356;
      v362 = (char *)_os_log_send_and_compose_impl();
      v552[0] = OS_LOG_TYPE_ERROR;
      v550[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v362, v552, v550))
      {
        if (v552[0] == OS_LOG_TYPE_FAULT)
        {
          v363 = __nwlog_obj();
          os_log_type_t v364 = v552[0];
          if (os_log_type_enabled(v363, v552[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v356;
            v365 = "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d";
LABEL_849:
            _os_log_impl(&dword_1830D4000, v363, v364, v365, buf, 0x12u);
          }
        }
        else if (v550[0])
        {
          v366 = (char *)__nw_create_backtrace_string();
          v363 = __nwlog_obj();
          os_log_type_t v364 = v552[0];
          BOOL v367 = os_log_type_enabled(v363, v552[0]);
          if (v366)
          {
            if (v367)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v356;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v366;
              _os_log_impl(&dword_1830D4000, v363, v364, "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v366);
            goto LABEL_850;
          }
          if (v367)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v356;
            v365 = "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d, no backtrace";
            goto LABEL_849;
          }
        }
        else
        {
          v363 = __nwlog_obj();
          os_log_type_t v364 = v552[0];
          if (os_log_type_enabled(v363, v552[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v356;
            v365 = "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_849;
          }
        }
      }
LABEL_850:
      os_log_type_t v192 = v539;
      if (v362) {
        free(v362);
      }
      os_log_type_t v154 = v361;
      BOOL v76 = v360;
LABEL_853:
      if (!nw_tcp_options_get_fast_open_force_enable(v326)
        || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 536, &v556, 4u))
      {
        goto LABEL_879;
      }
      int v383 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v384 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v383;
        _os_log_impl(&dword_1830D4000, v384, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v385 = __nwlog_obj();
      v386 = v385;
      if (v383 == 22)
      {
        if (os_log_type_enabled(v385, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          _os_log_impl(&dword_1830D4000, v386, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_879;
      }
      v387 = v76;
      v388 = v154;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v383;
      v389 = (char *)_os_log_send_and_compose_impl();
      v553[0] = OS_LOG_TYPE_ERROR;
      v552[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v389, v553, v552))
      {
        if (v553[0] == OS_LOG_TYPE_FAULT)
        {
          v390 = __nwlog_obj();
          os_log_type_t v391 = v553[0];
          if (os_log_type_enabled(v390, v553[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v383;
            v392 = "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d";
LABEL_875:
            _os_log_impl(&dword_1830D4000, v390, v391, v392, buf, 0x12u);
          }
        }
        else if (v552[0])
        {
          v393 = (char *)__nw_create_backtrace_string();
          v390 = __nwlog_obj();
          os_log_type_t v391 = v553[0];
          BOOL v394 = os_log_type_enabled(v390, v553[0]);
          if (v393)
          {
            if (v394)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v383;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v393;
              _os_log_impl(&dword_1830D4000, v390, v391, "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v393);
            goto LABEL_876;
          }
          if (v394)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v383;
            v392 = "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d, no backtrace";
            goto LABEL_875;
          }
        }
        else
        {
          v390 = __nwlog_obj();
          os_log_type_t v391 = v553[0];
          if (os_log_type_enabled(v390, v553[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v383;
            v392 = "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_875;
          }
        }
      }
LABEL_876:
      os_log_type_t v192 = v539;
      if (v389) {
        free(v389);
      }
      os_log_type_t v154 = v388;
      BOOL v76 = v387;
LABEL_879:
      *(_DWORD *)v553 = 0;
      *(_DWORD *)v553 = nw_tcp_options_get_connection_timeout(v326);
      if (!*(_DWORD *)v553 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 32, v553, 4u)) {
        goto LABEL_905;
      }
      int v395 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v396 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v395;
        _os_log_impl(&dword_1830D4000, v396, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v397 = __nwlog_obj();
      v398 = v397;
      if (v395 == 22)
      {
        if (os_log_type_enabled(v397, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          _os_log_impl(&dword_1830D4000, v398, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_905;
      }
      v399 = v76;
      v400 = v154;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v395;
      v401 = (char *)_os_log_send_and_compose_impl();
      v552[0] = OS_LOG_TYPE_ERROR;
      v550[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v401, v552, v550))
      {
        if (v552[0] == OS_LOG_TYPE_FAULT)
        {
          v402 = __nwlog_obj();
          os_log_type_t v403 = v552[0];
          if (os_log_type_enabled(v402, v552[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v395;
            v404 = "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d";
LABEL_901:
            _os_log_impl(&dword_1830D4000, v402, v403, v404, buf, 0x12u);
          }
        }
        else if (v550[0])
        {
          v405 = (char *)__nw_create_backtrace_string();
          v402 = __nwlog_obj();
          os_log_type_t v403 = v552[0];
          BOOL v406 = os_log_type_enabled(v402, v552[0]);
          if (v405)
          {
            if (v406)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v395;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v405;
              _os_log_impl(&dword_1830D4000, v402, v403, "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v405);
            goto LABEL_902;
          }
          if (v406)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v395;
            v404 = "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, no backtrace";
            goto LABEL_901;
          }
        }
        else
        {
          v402 = __nwlog_obj();
          os_log_type_t v403 = v552[0];
          if (os_log_type_enabled(v402, v552[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v395;
            v404 = "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_901;
          }
        }
      }
LABEL_902:
      os_log_type_t v192 = v539;
      if (v401) {
        free(v401);
      }
      os_log_type_t v154 = v400;
      BOOL v76 = v399;
LABEL_905:
      nw_multipath_service_t multipath_service = nw_parameters_get_multipath_service(v192);
      int v408 = *(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16);
      if ((v408 & 0x20000) == 0) {
        goto LABEL_1051;
      }
      nw_multipath_service_t v409 = multipath_service;
      if (multipath_service == nw_multipath_service_disabled) {
        goto LABEL_1051;
      }
      *(_DWORD *)v552 = -1;
      switch(multipath_service)
      {
        case nw_multipath_service_aggregate:
          int v410 = 2;
          break;
        case nw_multipath_service_interactive:
          int v410 = 1;
          break;
        case nw_multipath_service_handover:
          *(_DWORD *)v552 = 0;
          goto LABEL_918;
        default:
          if (multipath_service == 101)
          {
            int v410 = 4;
            break;
          }
          if (multipath_service == 100)
          {
            int v410 = 3;
            break;
          }
          if ((v408 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v424 = (char *)&a1[6].identifier + 4;
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 2082;
            *(void *)v560 = (char *)a1 + 404;
            *(_WORD *)&v560[8] = 1024;
            *(_DWORD *)&v560[10] = v409;
            v425 = (char *)_os_log_send_and_compose_impl();
            v550[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v551 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v425, v550, &v551)) {
              goto LABEL_1267;
            }
            if (v550[0] == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v426 = gconnectionLogObj;
              os_log_type_t v427 = v550[0];
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v550[0])) {
                goto LABEL_1267;
              }
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 2082;
              *(void *)v560 = v424;
              *(_WORD *)&v560[8] = 1024;
              *(_DWORD *)&v560[10] = v409;
              v428 = "%{public}s %{public}s Multipath Service has not been set correctly: %u";
            }
            else
            {
              if (v551)
              {
                v439 = (char *)__nw_create_backtrace_string();
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                v440 = gconnectionLogObj;
                os_log_type_t v441 = v550[0];
                BOOL v442 = os_log_type_enabled((os_log_t)gconnectionLogObj, v550[0]);
                if (v439)
                {
                  if (v442)
                  {
                    *(_DWORD *)buf = 136446978;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 2082;
                    *(void *)v560 = v424;
                    *(_WORD *)&v560[8] = 1024;
                    *(_DWORD *)&v560[10] = v409;
                    *(_WORD *)&v560[14] = 2082;
                    *(void *)&v560[16] = v439;
                    _os_log_impl(&dword_1830D4000, v440, v441, "%{public}s %{public}s Multipath Service has not been set correctly: %u, dumping backtrace:%{public}s", buf, 0x26u);
                  }
                  free(v439);
                  goto LABEL_1267;
                }
                if (!v442)
                {
LABEL_1267:
                  if (v425) {
                    free(v425);
                  }
                  goto LABEL_1222;
                }
                *(_DWORD *)buf = 136446722;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 2082;
                *(void *)v560 = v424;
                *(_WORD *)&v560[8] = 1024;
                *(_DWORD *)&v560[10] = v409;
                v428 = "%{public}s %{public}s Multipath Service has not been set correctly: %u, no backtrace";
                v535 = v440;
                os_log_type_t v536 = v441;
LABEL_1266:
                _os_log_impl(&dword_1830D4000, v535, v536, v428, buf, 0x1Cu);
                goto LABEL_1267;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v426 = gconnectionLogObj;
              os_log_type_t v427 = v550[0];
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v550[0])) {
                goto LABEL_1267;
              }
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 2082;
              *(void *)v560 = v424;
              *(_WORD *)&v560[8] = 1024;
              *(_DWORD *)&v560[10] = v409;
              v428 = "%{public}s %{public}s Multipath Service has not been set correctly: %u, backtrace limit exceeded";
            }
            v535 = v426;
            os_log_type_t v536 = v427;
            goto LABEL_1266;
          }
LABEL_1222:
          os_release(v326);
          return 0;
      }
      *(_DWORD *)v552 = v410;
LABEL_918:
      if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 531, v552, 4u))
      {
        uint64_t v411 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v412 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 2080;
          *(void *)v560 = (char *)a1 + 404;
          *(_WORD *)&v560[8] = 1024;
          *(_DWORD *)&v560[10] = v411;
          _os_log_impl(&dword_1830D4000, v412, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d", buf, 0x1Cu);
        }
        if (v411 == 13 || v411 == 22)
        {
          v413 = __nwlog_obj();
          if (os_log_type_enabled(v413, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v411;
            _os_log_impl(&dword_1830D4000, v413, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d", buf, 0x12u);
          }
LABEL_974:
          uint64_t v438 = v545;
LABEL_1221:
          nw_socket_internal_error(v438, v411);
          goto LABEL_1222;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v411;
        v418 = (char *)_os_log_send_and_compose_impl();
        v550[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v551 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v418, v550, &v551))
        {
          if (v550[0] == OS_LOG_TYPE_FAULT)
          {
            v419 = __nwlog_obj();
            os_log_type_t v420 = v550[0];
            if (!os_log_type_enabled(v419, v550[0])) {
              goto LABEL_972;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v411;
            v421 = "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d";
            goto LABEL_971;
          }
          if (v551 == OS_LOG_TYPE_DEFAULT)
          {
            v419 = __nwlog_obj();
            os_log_type_t v420 = v550[0];
            if (!os_log_type_enabled(v419, v550[0])) {
              goto LABEL_972;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v411;
            v421 = "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_971;
          }
          v422 = (char *)__nw_create_backtrace_string();
          v419 = __nwlog_obj();
          os_log_type_t v420 = v550[0];
          BOOL v423 = os_log_type_enabled(v419, v550[0]);
          if (v422)
          {
            if (v423)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v411;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v422;
              _os_log_impl(&dword_1830D4000, v419, v420, "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v422);
            goto LABEL_972;
          }
          if (v423)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v411;
            v421 = "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d, no backtrace";
LABEL_971:
            _os_log_impl(&dword_1830D4000, v419, v420, v421, buf, 0x12u);
          }
        }
LABEL_972:
        if (v418) {
          free(v418);
        }
        goto LABEL_974;
      }
      if (!nw_parameters_get_multipath_force_enable(v192)
        || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 535, &v556, 4u))
      {
LABEL_1025:
        *(_DWORD *)v550 = 0;
        *(_DWORD *)v550 = nw_tcp_options_get_multipath_force_version(v326);
        if (*(_DWORD *)v550 <= 1u && setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 538, v550, 4u))
        {
          uint64_t v454 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v455 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 2080;
            *(void *)v560 = (char *)a1 + 404;
            *(_WORD *)&v560[8] = 1024;
            *(_DWORD *)&v560[10] = v454;
            _os_log_impl(&dword_1830D4000, v455, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d", buf, 0x1Cu);
          }
          v456 = __nwlog_obj();
          v457 = v456;
          if (v454 == 22)
          {
            if (os_log_type_enabled(v456, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = 22;
              _os_log_impl(&dword_1830D4000, v457, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d", buf, 0x12u);
            }
LABEL_1050:
            nw_socket_internal_error(v545, v454);
            goto LABEL_1051;
          }
          v458 = v154;
          v459 = v76;
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v454;
          v460 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t v551 = OS_LOG_TYPE_ERROR;
          char v549 = 0;
          if (__nwlog_fault(v460, &v551, &v549))
          {
            if (v551 == OS_LOG_TYPE_FAULT)
            {
              v461 = __nwlog_obj();
              os_log_type_t v462 = v551;
              if (os_log_type_enabled(v461, v551))
              {
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v454;
                v463 = "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d";
LABEL_1045:
                v467 = v461;
LABEL_1046:
                _os_log_impl(&dword_1830D4000, v467, v462, v463, buf, 0x12u);
              }
            }
            else if (v549)
            {
              v464 = (char *)__nw_create_backtrace_string();
              v465 = __nwlog_obj();
              os_log_type_t v462 = v551;
              BOOL v466 = os_log_type_enabled(v465, v551);
              if (v464)
              {
                if (v466)
                {
                  *(_DWORD *)buf = 136446722;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 1024;
                  *(_DWORD *)v560 = v454;
                  *(_WORD *)&v560[4] = 2082;
                  *(void *)&v560[6] = v464;
                  _os_log_impl(&dword_1830D4000, v465, v462, "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v464);
                goto LABEL_1047;
              }
              if (v466)
              {
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v454;
                v463 = "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d, no backtrace";
                v467 = v465;
                goto LABEL_1046;
              }
            }
            else
            {
              v461 = __nwlog_obj();
              os_log_type_t v462 = v551;
              if (os_log_type_enabled(v461, v551))
              {
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v454;
                v463 = "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_1045;
              }
            }
          }
LABEL_1047:
          if (v460) {
            free(v460);
          }
          BOOL v76 = v459;
          os_log_type_t v154 = v458;
          os_log_type_t v192 = v539;
          goto LABEL_1050;
        }
LABEL_1051:
        *(_DWORD *)v552 = 0;
        *(_DWORD *)v552 = nw_endpoint_get_alternate_port(v76);
        if (*(_DWORD *)v552
          && ((*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16)) & 0x20000) != 0
          && setsockopt(*(_DWORD *)&a1[4].flow_id[12], 6, 534, v552, 4u))
        {
          uint64_t v411 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v468 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 2080;
            *(void *)v560 = (char *)a1 + 404;
            *(_WORD *)&v560[8] = 1024;
            *(_DWORD *)&v560[10] = v411;
            _os_log_impl(&dword_1830D4000, v468, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d", buf, 0x1Cu);
          }
          v469 = __nwlog_obj();
          v470 = v469;
          if (v411 == 22)
          {
            if (os_log_type_enabled(v469, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = 22;
              _os_log_impl(&dword_1830D4000, v470, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d", buf, 0x12u);
            }
LABEL_1220:
            uint64_t v438 = v545;
            goto LABEL_1221;
          }
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v411;
          v514 = (char *)_os_log_send_and_compose_impl();
          v550[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v551 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v514, v550, &v551))
          {
            if (v550[0] == OS_LOG_TYPE_FAULT)
            {
              v515 = __nwlog_obj();
              os_log_type_t v516 = v550[0];
              if (!os_log_type_enabled(v515, v550[0])) {
                goto LABEL_1218;
              }
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v411;
              v517 = "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d";
              goto LABEL_1217;
            }
            if (v551 == OS_LOG_TYPE_DEFAULT)
            {
              v515 = __nwlog_obj();
              os_log_type_t v516 = v550[0];
              if (!os_log_type_enabled(v515, v550[0])) {
                goto LABEL_1218;
              }
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v411;
              v517 = "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_1217;
            }
            v525 = (char *)__nw_create_backtrace_string();
            v515 = __nwlog_obj();
            os_log_type_t v516 = v550[0];
            BOOL v526 = os_log_type_enabled(v515, v550[0]);
            if (v525)
            {
              if (v526)
              {
                *(_DWORD *)buf = 136446722;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = v411;
                *(_WORD *)&v560[4] = 2082;
                *(void *)&v560[6] = v525;
                _os_log_impl(&dword_1830D4000, v515, v516, "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(v525);
              goto LABEL_1218;
            }
            if (v526)
            {
              *(_DWORD *)buf = 136446466;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v411;
              v517 = "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d, no backtrace";
LABEL_1217:
              _os_log_impl(&dword_1830D4000, v515, v516, v517, buf, 0x12u);
            }
          }
LABEL_1218:
          if (v514) {
            free(v514);
          }
          goto LABEL_1220;
        }
        goto LABEL_1061;
      }
      uint64_t v414 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v415 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v414;
        _os_log_impl(&dword_1830D4000, v415, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v416 = __nwlog_obj();
      v417 = v416;
      if (v414 == 22)
      {
        if (os_log_type_enabled(v416, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          _os_log_impl(&dword_1830D4000, v417, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x12u);
        }
LABEL_1024:
        nw_socket_internal_error(v545, v414);
        goto LABEL_1025;
      }
      v429 = v154;
      v430 = v76;
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v414;
      v431 = (char *)_os_log_send_and_compose_impl();
      v550[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v551 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v431, v550, &v551))
      {
        if (v550[0] == OS_LOG_TYPE_FAULT)
        {
          v432 = __nwlog_obj();
          os_log_type_t v433 = v550[0];
          if (os_log_type_enabled(v432, v550[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v414;
            v434 = "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d";
LABEL_1019:
            v453 = v432;
LABEL_1020:
            _os_log_impl(&dword_1830D4000, v453, v433, v434, buf, 0x12u);
          }
        }
        else if (v551)
        {
          v435 = (char *)__nw_create_backtrace_string();
          v436 = __nwlog_obj();
          os_log_type_t v433 = v550[0];
          BOOL v437 = os_log_type_enabled(v436, v550[0]);
          if (v435)
          {
            if (v437)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v414;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v435;
              _os_log_impl(&dword_1830D4000, v436, v433, "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v435);
            goto LABEL_1021;
          }
          if (v437)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v414;
            v434 = "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d, no backtrace";
            v453 = v436;
            goto LABEL_1020;
          }
        }
        else
        {
          v432 = __nwlog_obj();
          os_log_type_t v433 = v550[0];
          if (os_log_type_enabled(v432, v550[0]))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v414;
            v434 = "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_1019;
          }
        }
      }
LABEL_1021:
      if (v431) {
        free(v431);
      }
      BOOL v76 = v430;
      os_log_type_t v154 = v429;
      os_log_type_t v192 = v539;
      goto LABEL_1024;
    }
    if (!nw_protocol_options_is_udp(v326)) {
      goto LABEL_1061;
    }
    int v330 = identifier_low;
    if (!nw_udp_options_get_prefer_no_checksum(v326) || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 17, 1, &v556, 4u))
    {
LABEL_817:
      if (v330 == 2)
      {
        if ((setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0, 27, &v556, 4u) & 0x80000000) == 0) {
          goto LABEL_994;
        }
        int v368 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v369 = __nwlog_obj();
        v370 = v369;
        if (v368 == 22)
        {
          if (os_log_type_enabled(v369, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = 22;
            v371 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d";
LABEL_827:
            _os_log_impl(&dword_1830D4000, v370, OS_LOG_TYPE_ERROR, v371, buf, 0x12u);
            goto LABEL_994;
          }
          goto LABEL_994;
        }
        v374 = v154;
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v368;
        v375 = (char *)_os_log_send_and_compose_impl();
        v553[0] = OS_LOG_TYPE_ERROR;
        v552[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v375, v553, v552))
        {
          if (v553[0] == OS_LOG_TYPE_FAULT)
          {
            v376 = __nwlog_obj();
            os_log_type_t v377 = v553[0];
            if (!os_log_type_enabled(v376, v553[0])) {
              goto LABEL_991;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v368;
            v378 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d";
            goto LABEL_990;
          }
          if (v552[0] == OS_LOG_TYPE_DEFAULT)
          {
            v376 = __nwlog_obj();
            os_log_type_t v377 = v553[0];
            if (!os_log_type_enabled(v376, v553[0])) {
              goto LABEL_991;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v368;
            v378 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_990;
          }
          v379 = (char *)__nw_create_backtrace_string();
          v376 = __nwlog_obj();
          os_log_type_t v377 = v553[0];
          BOOL v380 = os_log_type_enabled(v376, v553[0]);
          if (v379)
          {
            if (v380)
            {
              *(_DWORD *)buf = 136446722;
              v558 = "nw_socket_set_common_sockopts";
              __int16 v559 = 1024;
              *(_DWORD *)v560 = v368;
              *(_WORD *)&v560[4] = 2082;
              *(void *)&v560[6] = v379;
              _os_log_impl(&dword_1830D4000, v376, v377, "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v379);
            if (!v375) {
              goto LABEL_993;
            }
            goto LABEL_992;
          }
          if (v380)
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v368;
            v378 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d, no backtrace";
LABEL_990:
            _os_log_impl(&dword_1830D4000, v376, v377, v378, buf, 0x12u);
          }
        }
      }
      else
      {
        if (v330 != 30 || (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 35, &v556, 4u) & 0x80000000) == 0) {
          goto LABEL_994;
        }
        int v372 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v373 = __nwlog_obj();
        v370 = v373;
        if (v372 == 22)
        {
          if (os_log_type_enabled(v373, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = 22;
            v371 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d";
            goto LABEL_827;
          }
LABEL_994:
          if (nw_endpoint_get_type(v76) == nw_endpoint_type_address
            && nw_endpoint_is_broadcast(v76, path)
            && setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 32, &v556, 4u) < 0)
          {
            int v443 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            v444 = __nwlog_obj();
            v445 = v444;
            if (v443 == 22)
            {
              if (os_log_type_enabled(v444, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v558 = "nw_socket_set_common_sockopts";
                __int16 v559 = 1024;
                *(_DWORD *)v560 = 22;
                _os_log_impl(&dword_1830D4000, v445, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d", buf, 0x12u);
              }
              goto LABEL_1061;
            }
            v446 = v154;
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v443;
            v447 = (char *)_os_log_send_and_compose_impl();
            v553[0] = OS_LOG_TYPE_ERROR;
            v552[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v447, v553, v552))
            {
              if (v553[0] == OS_LOG_TYPE_FAULT)
              {
                v448 = __nwlog_obj();
                os_log_type_t v449 = v553[0];
                if (os_log_type_enabled(v448, v553[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 1024;
                  *(_DWORD *)v560 = v443;
                  v450 = "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d";
LABEL_1013:
                  _os_log_impl(&dword_1830D4000, v448, v449, v450, buf, 0x12u);
                }
              }
              else if (v552[0])
              {
                v451 = (char *)__nw_create_backtrace_string();
                v448 = __nwlog_obj();
                os_log_type_t v449 = v553[0];
                BOOL v452 = os_log_type_enabled(v448, v553[0]);
                if (v451)
                {
                  if (v452)
                  {
                    *(_DWORD *)buf = 136446722;
                    v558 = "nw_socket_set_common_sockopts";
                    __int16 v559 = 1024;
                    *(_DWORD *)v560 = v443;
                    *(_WORD *)&v560[4] = 2082;
                    *(void *)&v560[6] = v451;
                    _os_log_impl(&dword_1830D4000, v448, v449, "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }
                  free(v451);
                  goto LABEL_1014;
                }
                if (v452)
                {
                  *(_DWORD *)buf = 136446466;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 1024;
                  *(_DWORD *)v560 = v443;
                  v450 = "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d, no backtrace";
                  goto LABEL_1013;
                }
              }
              else
              {
                v448 = __nwlog_obj();
                os_log_type_t v449 = v553[0];
                if (os_log_type_enabled(v448, v553[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  v558 = "nw_socket_set_common_sockopts";
                  __int16 v559 = 1024;
                  *(_DWORD *)v560 = v443;
                  v450 = "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_1013;
                }
              }
            }
LABEL_1014:
            if (v447) {
              free(v447);
            }
            os_log_type_t v154 = v446;
            os_log_type_t v192 = v539;
          }
LABEL_1061:
          os_release(v326);
          goto LABEL_1062;
        }
        v374 = v154;
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v372;
        v375 = (char *)_os_log_send_and_compose_impl();
        v553[0] = OS_LOG_TYPE_ERROR;
        v552[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v375, v553, v552))
        {
          if (v553[0] == OS_LOG_TYPE_FAULT)
          {
            v376 = __nwlog_obj();
            os_log_type_t v377 = v553[0];
            if (!os_log_type_enabled(v376, v553[0])) {
              goto LABEL_991;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v372;
            v378 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d";
            goto LABEL_990;
          }
          if (v552[0] == OS_LOG_TYPE_DEFAULT)
          {
            v376 = __nwlog_obj();
            os_log_type_t v377 = v553[0];
            if (!os_log_type_enabled(v376, v553[0])) {
              goto LABEL_991;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v372;
            v378 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_990;
          }
          v381 = (char *)__nw_create_backtrace_string();
          v376 = __nwlog_obj();
          os_log_type_t v377 = v553[0];
          BOOL v382 = os_log_type_enabled(v376, v553[0]);
          if (!v381)
          {
            if (!v382) {
              goto LABEL_991;
            }
            *(_DWORD *)buf = 136446466;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v372;
            v378 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d, no backtrace";
            goto LABEL_990;
          }
          if (v382)
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v372;
            *(_WORD *)&v560[4] = 2082;
            *(void *)&v560[6] = v381;
            _os_log_impl(&dword_1830D4000, v376, v377, "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v381);
        }
      }
LABEL_991:
      if (!v375)
      {
LABEL_993:
        os_log_type_t v154 = v374;
        os_log_type_t v192 = v539;
        goto LABEL_994;
      }
LABEL_992:
      free(v375);
      goto LABEL_993;
    }
    int v331 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    v332 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v331;
      _os_log_impl(&dword_1830D4000, v332, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt UDP_NOCKSUM failed %{darwin.errno}d", buf, 0x1Cu);
    }
    v333 = __nwlog_obj();
    v334 = v333;
    if (v331 == 22)
    {
      if (os_log_type_enabled(v333, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        _os_log_impl(&dword_1830D4000, v334, OS_LOG_TYPE_ERROR, "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_817;
    }
    v345 = v76;
    v346 = v154;
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v331;
    v347 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v347, v553, v552))
    {
      if (v553[0] == OS_LOG_TYPE_FAULT)
      {
        v348 = __nwlog_obj();
        os_log_type_t v349 = v553[0];
        if (os_log_type_enabled(v348, v553[0]))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v331;
          v350 = "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d";
LABEL_813:
          _os_log_impl(&dword_1830D4000, v348, v349, v350, buf, 0x12u);
        }
      }
      else if (v552[0])
      {
        v353 = (char *)__nw_create_backtrace_string();
        v348 = __nwlog_obj();
        os_log_type_t v349 = v553[0];
        BOOL v354 = os_log_type_enabled(v348, v553[0]);
        if (v353)
        {
          if (v354)
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v331;
            *(_WORD *)&v560[4] = 2082;
            *(void *)&v560[6] = v353;
            _os_log_impl(&dword_1830D4000, v348, v349, "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v353);
          int v330 = identifier_low;
          goto LABEL_814;
        }
        int v330 = identifier_low;
        if (v354)
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v331;
          v350 = "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d, no backtrace";
          goto LABEL_813;
        }
      }
      else
      {
        v348 = __nwlog_obj();
        os_log_type_t v349 = v553[0];
        if (os_log_type_enabled(v348, v553[0]))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v331;
          v350 = "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_813;
        }
      }
    }
LABEL_814:
    os_log_type_t v192 = v539;
    if (v347) {
      free(v347);
    }
    os_log_type_t v154 = v346;
    BOOL v76 = v345;
    goto LABEL_817;
  }
LABEL_1062:
  v471 = v192;
  BOOL v472 = (v154[12] & 0x100) == 0;

  if (!v472)
  {
    if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4, &v556, 4u) < 0)
    {
      uint64_t v49 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v485 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v49;
        _os_log_impl(&dword_1830D4000, v485, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_REUSEADDR failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v486 = __nwlog_obj();
      v479 = v486;
      if (v49 == 22)
      {
        if (os_log_type_enabled(v486, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          v480 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d";
          goto LABEL_1134;
        }
LABEL_1208:
        uint64_t v75 = v545;
        goto LABEL_330;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      v492 = (char *)_os_log_send_and_compose_impl();
      v553[0] = OS_LOG_TYPE_ERROR;
      v552[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v492, v553, v552)) {
        goto LABEL_1206;
      }
      if (v553[0] == OS_LOG_TYPE_FAULT)
      {
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        if (!os_log_type_enabled(v493, v553[0])) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d";
      }
      else if (v552[0])
      {
        v505 = (char *)__nw_create_backtrace_string();
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        BOOL v506 = os_log_type_enabled(v493, v553[0]);
        if (v505)
        {
          if (v506)
          {
            *(_DWORD *)buf = 136446722;
            v558 = "nw_socket_set_common_sockopts";
            __int16 v559 = 1024;
            *(_DWORD *)v560 = v49;
            *(_WORD *)&v560[4] = 2082;
            *(void *)&v560[6] = v505;
            _os_log_impl(&dword_1830D4000, v493, v494, "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v505);
LABEL_1206:
          if (!v492) {
            goto LABEL_1208;
          }
LABEL_1207:
          free(v492);
          goto LABEL_1208;
        }
        if (!v506) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d, no backtrace";
      }
      else
      {
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        if (!os_log_type_enabled(v493, v553[0])) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d, backtrace limit exceeded";
      }
LABEL_1205:
      _os_log_impl(&dword_1830D4000, v493, v494, v495, buf, 0x12u);
      goto LABEL_1206;
    }
    if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 512, &v556, 4u) < 0)
    {
      uint64_t v49 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v496 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v49;
        _os_log_impl(&dword_1830D4000, v496, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_REUSEPORT failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v497 = __nwlog_obj();
      v479 = v497;
      if (v49 == 22)
      {
        if (os_log_type_enabled(v497, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          v480 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d";
          goto LABEL_1134;
        }
        goto LABEL_1208;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      v492 = (char *)_os_log_send_and_compose_impl();
      v553[0] = OS_LOG_TYPE_ERROR;
      v552[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v492, v553, v552)) {
        goto LABEL_1206;
      }
      if (v553[0] == OS_LOG_TYPE_FAULT)
      {
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        if (!os_log_type_enabled(v493, v553[0])) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d";
        goto LABEL_1205;
      }
      if (v552[0] == OS_LOG_TYPE_DEFAULT)
      {
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        if (!os_log_type_enabled(v493, v553[0])) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_1205;
      }
      v500 = (char *)__nw_create_backtrace_string();
      v493 = __nwlog_obj();
      os_log_type_t v494 = v553[0];
      BOOL v509 = os_log_type_enabled(v493, v553[0]);
      if (!v500)
      {
        if (!v509) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d, no backtrace";
        goto LABEL_1205;
      }
      if (v509)
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        *(_WORD *)&v560[4] = 2082;
        *(void *)&v560[6] = v500;
        v502 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_1171;
      }
LABEL_1172:
      free(v500);
      if (!v492) {
        goto LABEL_1208;
      }
      goto LABEL_1207;
    }
  }
  v473 = *(void **)&a1[3].flow_id[8];
  if (v473)
  {
    int v474 = *(_DWORD *)&a1[4].flow_id[12];
    bytes_ptr = xpc_data_get_bytes_ptr(v473);
    socklen_t length = xpc_data_get_length(*(xpc_object_t *)&a1[3].flow_id[8]);
    if (setsockopt(v474, 0xFFFF, 4358, bytes_ptr, length))
    {
      uint64_t v49 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v477 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 2080;
        *(void *)v560 = (char *)a1 + 404;
        *(_WORD *)&v560[8] = 1024;
        *(_DWORD *)&v560[10] = v49;
        _os_log_impl(&dword_1830D4000, v477, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v478 = __nwlog_obj();
      v479 = v478;
      if (v49 == 22)
      {
        if (os_log_type_enabled(v478, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = 22;
          v480 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d";
LABEL_1134:
          _os_log_impl(&dword_1830D4000, v479, OS_LOG_TYPE_ERROR, v480, buf, 0x12u);
          uint64_t v75 = v545;
          goto LABEL_330;
        }
        goto LABEL_1208;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      v492 = (char *)_os_log_send_and_compose_impl();
      v553[0] = OS_LOG_TYPE_ERROR;
      v552[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v492, v553, v552)) {
        goto LABEL_1206;
      }
      if (v553[0] == OS_LOG_TYPE_FAULT)
      {
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        if (!os_log_type_enabled(v493, v553[0])) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d";
        goto LABEL_1205;
      }
      if (v552[0] == OS_LOG_TYPE_DEFAULT)
      {
        v493 = __nwlog_obj();
        os_log_type_t v494 = v553[0];
        if (!os_log_type_enabled(v493, v553[0])) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_1205;
      }
      v500 = (char *)__nw_create_backtrace_string();
      v493 = __nwlog_obj();
      os_log_type_t v494 = v553[0];
      BOOL v501 = os_log_type_enabled(v493, v553[0]);
      if (!v500)
      {
        if (!v501) {
          goto LABEL_1206;
        }
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        v495 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d, no backtrace";
        goto LABEL_1205;
      }
      if (v501)
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v49;
        *(_WORD *)&v560[4] = 2082;
        *(void *)&v560[6] = v500;
        v502 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_1171:
        _os_log_impl(&dword_1830D4000, v493, v494, v502, buf, 0x1Cu);
        goto LABEL_1172;
      }
      goto LABEL_1172;
    }
  }
  if (path
    && nw_path_uses_interface_subtype(path, 4001)
    && setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4376, &v556, 4u) < 0)
  {
    uint64_t v49 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    v503 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2080;
      *(void *)v560 = (char *)a1 + 404;
      *(_WORD *)&v560[8] = 1024;
      *(_DWORD *)&v560[10] = v49;
      _os_log_impl(&dword_1830D4000, v503, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d", buf, 0x1Cu);
    }
    v504 = __nwlog_obj();
    v479 = v504;
    if (v49 == 22)
    {
      if (os_log_type_enabled(v504, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = 22;
        v480 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d";
        goto LABEL_1134;
      }
      goto LABEL_1208;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v49;
    v492 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v492, v553, v552)) {
      goto LABEL_1206;
    }
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      v493 = __nwlog_obj();
      os_log_type_t v494 = v553[0];
      if (!os_log_type_enabled(v493, v553[0])) {
        goto LABEL_1206;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      v495 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d";
      goto LABEL_1205;
    }
    if (v552[0] == OS_LOG_TYPE_DEFAULT)
    {
      v493 = __nwlog_obj();
      os_log_type_t v494 = v553[0];
      if (!os_log_type_enabled(v493, v553[0])) {
        goto LABEL_1206;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      v495 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_1205;
    }
    v500 = (char *)__nw_create_backtrace_string();
    v493 = __nwlog_obj();
    os_log_type_t v494 = v553[0];
    BOOL v518 = os_log_type_enabled(v493, v553[0]);
    if (!v500)
    {
      if (!v518) {
        goto LABEL_1206;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      v495 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d, no backtrace";
      goto LABEL_1205;
    }
    if (v518)
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v49;
      *(_WORD *)&v560[4] = 2082;
      *(void *)&v560[6] = v500;
      v502 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_1171;
    }
    goto LABEL_1172;
  }
  id v481 = nw_parameters_copy_context(v471);
  int do_not_log_trackers = nw_context_get_do_not_log_trackers(v481);
  if (v481) {
    os_release(v481);
  }
  if (do_not_log_trackers)
  {
    if ((setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4405, &v556, 4u) & 0x80000000) == 0)
    {
      if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0) {
        goto LABEL_1243;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v483 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_1243;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2082;
      *(void *)v560 = (char *)a1 + 404;
      v484 = "%{public}s %{public}s set SO_MARK_DOMAIN_INFO_SILENT on";
      goto LABEL_1235;
    }
    int v498 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v498 == 22 || v498 == 42)
    {
      v499 = __nwlog_obj();
      if (os_log_type_enabled(v499, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v498;
        v484 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d";
LABEL_1241:
        v529 = v499;
        os_log_type_t v530 = OS_LOG_TYPE_ERROR;
        uint32_t v531 = 18;
        goto LABEL_1242;
      }
      goto LABEL_1243;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v498;
    v510 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v510, v553, v552) & 1) == 0) {
      goto LABEL_1259;
    }
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      v511 = __nwlog_obj();
      os_log_type_t v512 = v553[0];
      if (!os_log_type_enabled(v511, v553[0])) {
        goto LABEL_1259;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v498;
      v513 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d";
      goto LABEL_1258;
    }
    if (v552[0] == OS_LOG_TYPE_DEFAULT)
    {
      v511 = __nwlog_obj();
      os_log_type_t v512 = v553[0];
      if (!os_log_type_enabled(v511, v553[0])) {
        goto LABEL_1259;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v498;
      v513 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_1258;
    }
    v523 = (char *)__nw_create_backtrace_string();
    v511 = __nwlog_obj();
    os_log_type_t v512 = v553[0];
    BOOL v524 = os_log_type_enabled(v511, v553[0]);
    if (!v523)
    {
      if (!v524) {
        goto LABEL_1259;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v498;
      v513 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d, no backtrace";
      goto LABEL_1258;
    }
    if (v524)
    {
      *(_DWORD *)buf = 136446722;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v498;
      *(_WORD *)&v560[4] = 2082;
      *(void *)&v560[6] = v523;
      _os_log_impl(&dword_1830D4000, v511, v512, "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v523);
    goto LABEL_1259;
  }
  if (!nw_parameters_get_is_known_tracker(v471)) {
    goto LABEL_1228;
  }
  if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4389, &v556, 4u) < 0)
  {
    int v507 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v507 == 22 || v507 == 42)
    {
      v508 = __nwlog_obj();
      if (!os_log_type_enabled(v508, OS_LOG_TYPE_ERROR)) {
        goto LABEL_1228;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v507;
      v488 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d";
      v489 = v508;
      os_log_type_t v490 = OS_LOG_TYPE_ERROR;
      uint32_t v491 = 18;
      goto LABEL_1144;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v507;
    v519 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v519, v553, v552) & 1) == 0) {
      goto LABEL_1226;
    }
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      v520 = __nwlog_obj();
      os_log_type_t v521 = v553[0];
      if (!os_log_type_enabled(v520, v553[0])) {
        goto LABEL_1226;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v507;
      v522 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d";
    }
    else if (v552[0])
    {
      v527 = (char *)__nw_create_backtrace_string();
      v520 = __nwlog_obj();
      os_log_type_t v521 = v553[0];
      BOOL v528 = os_log_type_enabled(v520, v553[0]);
      if (v527)
      {
        if (v528)
        {
          *(_DWORD *)buf = 136446722;
          v558 = "nw_socket_set_common_sockopts";
          __int16 v559 = 1024;
          *(_DWORD *)v560 = v507;
          *(_WORD *)&v560[4] = 2082;
          *(void *)&v560[6] = v527;
          _os_log_impl(&dword_1830D4000, v520, v521, "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v527);
        goto LABEL_1226;
      }
      if (!v528)
      {
LABEL_1226:
        if (v519) {
          free(v519);
        }
        goto LABEL_1228;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v507;
      v522 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v520 = __nwlog_obj();
      os_log_type_t v521 = v553[0];
      if (!os_log_type_enabled(v520, v553[0])) {
        goto LABEL_1226;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v507;
      v522 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v520, v521, v522, buf, 0x12u);
    goto LABEL_1226;
  }
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v487 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 2082;
      *(void *)v560 = v546 + 308;
      v488 = "%{public}s %{public}s set SO_MARK_KNOWN_TRACKER on";
      v489 = v487;
      os_log_type_t v490 = OS_LOG_TYPE_DEBUG;
      uint32_t v491 = 22;
LABEL_1144:
      _os_log_impl(&dword_1830D4000, v489, v490, v488, buf, v491);
    }
  }
LABEL_1228:
  if (nw_parameters_get_attribution(&v471->super) != nw_parameters_attribution_user) {
    goto LABEL_1243;
  }
  if ((setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4390, &v556, 4u) & 0x80000000) == 0)
  {
    if ((*(_WORD *)(v546 + 301) & 0x80) != 0) {
      goto LABEL_1243;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v483 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_1243;
    }
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 2082;
    *(void *)v560 = v546 + 308;
    v484 = "%{public}s %{public}s set SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED on";
LABEL_1235:
    v529 = v483;
    os_log_type_t v530 = OS_LOG_TYPE_DEBUG;
    uint32_t v531 = 22;
LABEL_1242:
    _os_log_impl(&dword_1830D4000, v529, v530, v484, buf, v531);
    goto LABEL_1243;
  }
  int v532 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v532 != 22 && v532 != 42 && v532 != 100)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v532;
    v510 = (char *)_os_log_send_and_compose_impl();
    v553[0] = OS_LOG_TYPE_ERROR;
    v552[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v510, v553, v552) & 1) == 0) {
      goto LABEL_1259;
    }
    if (v553[0] == OS_LOG_TYPE_FAULT)
    {
      v511 = __nwlog_obj();
      os_log_type_t v512 = v553[0];
      if (!os_log_type_enabled(v511, v553[0])) {
        goto LABEL_1259;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v532;
      v513 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d";
      goto LABEL_1258;
    }
    if (v552[0] == OS_LOG_TYPE_DEFAULT)
    {
      v511 = __nwlog_obj();
      os_log_type_t v512 = v553[0];
      if (!os_log_type_enabled(v511, v553[0])) {
        goto LABEL_1259;
      }
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v532;
      v513 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_1258;
    }
    v533 = (char *)__nw_create_backtrace_string();
    v511 = __nwlog_obj();
    os_log_type_t v512 = v553[0];
    BOOL v534 = os_log_type_enabled(v511, v553[0]);
    if (v533)
    {
      if (v534)
      {
        *(_DWORD *)buf = 136446722;
        v558 = "nw_socket_set_common_sockopts";
        __int16 v559 = 1024;
        *(_DWORD *)v560 = v532;
        *(_WORD *)&v560[4] = 2082;
        *(void *)&v560[6] = v533;
        _os_log_impl(&dword_1830D4000, v511, v512, "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v533);
      if (!v510) {
        goto LABEL_1243;
      }
      goto LABEL_1260;
    }
    if (v534)
    {
      *(_DWORD *)buf = 136446466;
      v558 = "nw_socket_set_common_sockopts";
      __int16 v559 = 1024;
      *(_DWORD *)v560 = v532;
      v513 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d, no backtrace";
LABEL_1258:
      _os_log_impl(&dword_1830D4000, v511, v512, v513, buf, 0x12u);
    }
LABEL_1259:
    if (!v510) {
      goto LABEL_1243;
    }
LABEL_1260:
    free(v510);
    goto LABEL_1243;
  }
  v499 = __nwlog_obj();
  if (os_log_type_enabled(v499, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v558 = "nw_socket_set_common_sockopts";
    __int16 v559 = 1024;
    *(_DWORD *)v560 = v532;
    v484 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d";
    goto LABEL_1241;
  }
LABEL_1243:
  nw_protocol_socket_set_necp_attributes(v546, v471, (const char **)v76);
  return 1;
}

void sub_183391DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_fast_open_force_enable(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_fast_open_force_enable_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_1833920EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_connection_timeout(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_connection_timeout_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_18339242C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_disable_ecn(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_disable_ecn_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ecn";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ecn";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ecn";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ecn";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ecn";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183392774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_ip_options_get_use_minimum_mtu(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_use_minimum_mtu_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183392ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_context_get_do_not_log_trackers(void *a1)
{
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      uint64_t v3 = BYTE1(v2[34]._os_unfair_lock_opaque) & 1;
      os_unfair_lock_unlock(v2 + 20);
    }
    else
    {
      uint64_t v3 = BYTE1(v2[34]._os_unfair_lock_opaque) & 1;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

id nw_parameters_copy_tls_session_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    id v3 = v1[16];
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_copy_tls_session_id";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_copy_tls_session_id";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_copy_tls_session_id";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_copy_tls_session_id";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_copy_tls_session_id";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_5(uint64_t a1)
{
  v56[3] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 136))
  {
    if (*(void *)(v1 + 216))
    {
      uint64_t v2 = *(void *)(v1 + 384);
      if (v2)
      {
        while (1)
        {
          if (!*(void *)(v1 + 136) || !*(void *)(v1 + 216)) {
            return;
          }
          uint64_t v3 = v2;
          uint64_t v2 = *(void *)(v2 + 56);
          uint64_t v4 = *(void *)(v3 + 24);
          int v5 = os_channel_flow_admissible();
          if (!v5) {
            break;
          }
          int v12 = v5;
          if (v5 != 55)
          {
            if (v5 == 2)
            {
              if (gLogDatapath)
              {
                char v13 = __nwlog_obj();
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446466;
                  __int16 v52 = "nw_channel_check_flows_allowed";
                  __int16 v53 = 2082;
                  __int16 v54 = (const char *)(v3 + 84);
                  _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Flow(%{public}s) is no longer present", buf, 0x16u);
                }
              }
            }
            else
            {
              if (!*(void *)(v1 + 136))
              {
                if (_nw_signposts_once != -1) {
                  dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
                }
                if (_nw_signposts_enabled && kdebug_is_enabled()) {
                  kdebug_trace();
                }
                goto LABEL_18;
              }
              if (((*(unsigned __int16 *)(v1 + 444) | (*(unsigned __int8 *)(v1 + 446) << 16)) & 0x80000) == 0)
              {
                if (!os_channel_is_defunct())
                {
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446722;
                  uint64_t v28 = (const char *)(v3 + 84);
                  __int16 v52 = "nw_channel_check_flows_allowed";
                  __int16 v53 = 2082;
                  __int16 v54 = v28;
                  __int16 v55 = 1024;
                  LODWORD(v56[0]) = v12;
                  uint64_t v29 = (const char *)_os_log_send_and_compose_impl();
                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v49 = 0;
                  __int16 v48 = (char *)v29;
                  if (!__nwlog_fault(v29, &type, &v49)) {
                    goto LABEL_88;
                  }
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    os_log_type_t v30 = __nwlog_obj();
                    os_log_type_t v31 = type;
                    os_log_t logc = v30;
                    if (os_log_type_enabled(v30, type))
                    {
                      *(_DWORD *)buf = 136446722;
                      __int16 v52 = "nw_channel_check_flows_allowed";
                      __int16 v53 = 2082;
                      __int16 v54 = v28;
                      __int16 v55 = 1024;
                      LODWORD(v56[0]) = v12;
                      os_log_type_t v32 = logc;
                      os_log_type_t v33 = v31;
                      CFDataRef v34 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d";
                      goto LABEL_87;
                    }
                    goto LABEL_88;
                  }
                  if (v49)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    uint64_t v39 = __nwlog_obj();
                    os_log_type_t v41 = type;
                    BOOL v36 = os_log_type_enabled(v39, type);
                    if (backtrace_string)
                    {
                      if (v36)
                      {
                        *(_DWORD *)buf = 136446978;
                        __int16 v52 = "nw_channel_check_flows_allowed";
                        __int16 v53 = 2082;
                        __int16 v54 = v28;
                        __int16 v55 = 1024;
                        LODWORD(v56[0]) = v12;
                        WORD2(v56[0]) = 2082;
                        *(void *)((char *)v56 + 6) = backtrace_string;
                        _os_log_impl(&dword_1830D4000, v39, v41, "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                      }
                      free(backtrace_string);
                      goto LABEL_88;
                    }
                    if (!v36)
                    {
LABEL_88:
                      if (v48) {
                        free(v48);
                      }
                      goto LABEL_18;
                    }
                    *(_DWORD *)buf = 136446722;
                    __int16 v52 = "nw_channel_check_flows_allowed";
                    __int16 v53 = 2082;
                    __int16 v54 = v28;
                    __int16 v55 = 1024;
                    LODWORD(v56[0]) = v12;
                    os_log_type_t v32 = v39;
                    os_log_type_t v33 = v41;
                    CFDataRef v34 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, no backtrace";
                  }
                  else
                  {
                    uint64_t v37 = __nwlog_obj();
                    os_log_type_t v38 = type;
                    os_log_t logd = v37;
                    if (!os_log_type_enabled(v37, type)) {
                      goto LABEL_88;
                    }
                    *(_DWORD *)buf = 136446722;
                    __int16 v52 = "nw_channel_check_flows_allowed";
                    __int16 v53 = 2082;
                    __int16 v54 = v28;
                    __int16 v55 = 1024;
                    LODWORD(v56[0]) = v12;
                    os_log_type_t v32 = logd;
                    os_log_type_t v33 = v38;
                    CFDataRef v34 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, backtrace limit exceeded";
                  }
LABEL_87:
                  _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0x1Cu);
                  goto LABEL_88;
                }
                nw_channel_handle_defunct(v1);
              }
            }
          }
LABEL_18:
          if (!v2) {
            return;
          }
        }
        if (nw_link_set_flow_control_status(*(void **)(v3 + 72), 0))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v6 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v52 = "nw_channel_check_flows_allowed";
            __int16 v53 = 2082;
            __int16 v54 = (const char *)(v3 + 84);
            _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s Flow resumed for flow id %{public}s", buf, 0x16u);
          }
        }
        if (v4)
        {
          uint64_t v7 = *(void *)(v4 + 24);
          if (v7)
          {
            os_log_type_t v8 = *(void (**)(uint64_t, uint64_t, void))(v7 + 104);
            if (v8)
            {
              v8(v4, v1 + 24, *(void *)(v3 + 72));
LABEL_14:
              uint64_t v9 = *(void *)(v3 + 56);
              os_log_type_t v10 = *(void **)(v3 + 64);
              if (v9)
              {
                *(void *)(v9 + 64) = v10;
                os_log_type_t v10 = *(void **)(v3 + 64);
              }
              else
              {
                *(void *)(v1 + 392) = v10;
              }
              *os_log_type_t v10 = v9;
              *(unsigned char *)(v3 + 121) &= ~2u;
              goto LABEL_18;
            }
          }
          __nwlog_obj();
          BOOL v11 = *(const char **)(v4 + 16);
          if (!v11) {
            BOOL v11 = "invalid";
          }
        }
        else
        {
          __nwlog_obj();
          BOOL v11 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        __int16 v52 = "nw_channel_check_flows_allowed";
        __int16 v53 = 2082;
        __int16 v54 = v11;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v49 = 0;
        int v47 = (char *)v14;
        if (__nwlog_fault(v14, &type, &v49))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v15 = __nwlog_obj();
            os_log_type_t v16 = type;
            os_log_t log = v15;
            if (!os_log_type_enabled(v15, type)) {
              goto LABEL_63;
            }
            if (v4)
            {
              __int16 v17 = *(const char **)(v4 + 16);
              if (!v17) {
                __int16 v17 = "invalid";
              }
            }
            else
            {
              __int16 v17 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            __int16 v52 = "nw_channel_check_flows_allowed";
            __int16 v53 = 2082;
            __int16 v54 = v17;
            uint64_t v25 = log;
            os_log_type_t v26 = v16;
            uint64_t v27 = "%{public}s protocol %{public}s has invalid link_state callback";
            goto LABEL_62;
          }
          if (!v49)
          {
            os_log_type_t v21 = __nwlog_obj();
            os_log_type_t v22 = type;
            os_log_t logb = v21;
            if (!os_log_type_enabled(v21, type)) {
              goto LABEL_63;
            }
            if (v4)
            {
              int v23 = *(const char **)(v4 + 16);
              if (!v23) {
                int v23 = "invalid";
              }
            }
            else
            {
              int v23 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            __int16 v52 = "nw_channel_check_flows_allowed";
            __int16 v53 = 2082;
            __int16 v54 = v23;
            uint64_t v25 = logb;
            os_log_type_t v26 = v22;
            uint64_t v27 = "%{public}s protocol %{public}s has invalid link_state callback, backtrace limit exceeded";
            goto LABEL_62;
          }
          int v18 = (char *)__nw_create_backtrace_string();
          loga = __nwlog_obj();
          os_log_type_t v40 = type;
          BOOL v19 = os_log_type_enabled(loga, type);
          if (v18)
          {
            if (v19)
            {
              if (v4)
              {
                BOOL v20 = *(const char **)(v4 + 16);
                if (!v20) {
                  BOOL v20 = "invalid";
                }
              }
              else
              {
                BOOL v20 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              __int16 v52 = "nw_channel_check_flows_allowed";
              __int16 v53 = 2082;
              __int16 v54 = v20;
              __int16 v55 = 2082;
              v56[0] = v18;
              _os_log_impl(&dword_1830D4000, loga, v40, "%{public}s protocol %{public}s has invalid link_state callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v18);
            goto LABEL_63;
          }
          if (v19)
          {
            if (v4)
            {
              BOOL v24 = *(const char **)(v4 + 16);
              if (!v24) {
                BOOL v24 = "invalid";
              }
            }
            else
            {
              BOOL v24 = "invalid";
            }
            uint64_t v25 = loga;
            os_log_type_t v26 = v40;
            *(_DWORD *)buf = 136446466;
            __int16 v52 = "nw_channel_check_flows_allowed";
            __int16 v53 = 2082;
            __int16 v54 = v24;
            uint64_t v27 = "%{public}s protocol %{public}s has invalid link_state callback, no backtrace";
LABEL_62:
            _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0x16u);
          }
        }
LABEL_63:
        if (v47) {
          free(v47);
        }
        goto LABEL_14;
      }
    }
  }
}

uint64_t nw_protocol_instance_copy_path(void *a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  uint64_t v4 = (char *)v3;
  if (!v3)
  {
    uint64_t v28 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
    os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v16, &type, &v33))
    {
LABEL_48:
      if (!v16) {
        goto LABEL_50;
      }
LABEL_49:
      free(v16);
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (!v33)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_1830D4000, v17, v32, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v17 = __nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v31 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_1830D4000, v17, v30, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
      __int16 v36 = 2082;
      uint64_t v37 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v17, v30, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_28;
  }
  int v5 = (void *)v3[15];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = v6;
    if (((_BYTE)v6[17] & 8) == 0) {
      dispatch_assert_queue_V2(v6[1]);
    }
  }
  if (a2 != -1)
  {
    if (*(_DWORD *)(*((void *)v4 + 1) + 64) == 3)
    {
      uint64_t node = nw_hash_table_get_node(*((void *)v4 + 29), a2, 8);
      if (node)
      {
        os_log_type_t v8 = *(void **)(node + 16);
        if (v8)
        {
          uint64_t v14 = v8[3];
          if (v14)
          {
            os_log_type_t v10 = *(void (**)(void))(v14 + 120);
            if (v10)
            {
              BOOL v11 = (void *)v8[5];
              if (v11 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v25 = v8[11];
                if (v25) {
                  v8[11] = v25 + 1;
                }
                char v12 = -1;
              }
              else
              {
                char v12 = 0;
              }
              goto LABEL_43;
            }
          }
        }
      }
      else if ((v4[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v23 = (id)gLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
          __int16 v36 = 2082;
          uint64_t v37 = v4 + 407;
          __int16 v38 = 2080;
          uint64_t v39 = " ";
          __int16 v40 = 2048;
          uint64_t v41 = a2;
          _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot access path, flow %llx does not exist", buf, 0x2Au);
        }
      }
LABEL_50:
      uint64_t v26 = 0;
      goto LABEL_51;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
    os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v16, &type, &v33)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null (flow == (_nw_protocol_default_flow))", buf, 0xCu);
      }
LABEL_47:

      goto LABEL_48;
    }
    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_1830D4000, v17, v24, "%{public}s called with null (flow == (_nw_protocol_default_flow)), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (id)gLogObj;
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null (flow == (_nw_protocol_default_flow)), no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
      __int16 v36 = 2082;
      uint64_t v37 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null (flow == (_nw_protocol_default_flow)), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_28:

    free(backtrace_string);
    if (!v16) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  os_log_type_t v8 = (void *)*((void *)v4 - 6);
  if (!v8) {
    goto LABEL_50;
  }
  uint64_t v9 = v8[3];
  if (!v9) {
    goto LABEL_50;
  }
  os_log_type_t v10 = *(void (**)(void))(v9 + 120);
  if (!v10) {
    goto LABEL_50;
  }
  BOOL v11 = (void *)v8[5];
  if (v11 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v22 = v8[11];
    if (v22) {
      v8[11] = v22 + 1;
    }
    char v12 = -1;
  }
  else
  {
    char v12 = 0;
  }
LABEL_43:
  *(void *)buf = v8;
  buf[8] = v12;
  uint64_t v26 = v10();
  if (v11 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
  }
LABEL_51:

  return v26;
}

void sub_183393F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (v8 == v9) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }

  _Unwind_Resume(a1);
}

void nw_path_monitor_set_update_handler(nw_path_monitor_t monitor, nw_path_monitor_update_handler_t update_handler)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = monitor;
  nw_path_monitor_update_handler_t v4 = update_handler;
  int v5 = v4;
  if (!v3)
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v27 = "nw_path_monitor_set_update_handler";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_path_monitor_set_update_handler";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v27 = "nw_path_monitor_set_update_handler";
          __int16 v28 = 2082;
          os_log_type_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v11) {
          goto LABEL_4;
        }
LABEL_39:
        free(v11);
        goto LABEL_4;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_path_monitor_set_update_handler";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_path_monitor_set_update_handler";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    uint64_t v6 = v3;
    id v7 = v5;
    os_unfair_lock_lock((os_unfair_lock_t)&v6[12]);
    uint64_t v8 = (objc_class *)_Block_copy(v7);
    Class isa = v6[8].isa;
    v6[8].Class isa = v8;

    os_unfair_lock_unlock((os_unfair_lock_t)&v6[12]);
    goto LABEL_4;
  }
  uint64_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v27 = "nw_path_monitor_set_update_handler";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v11, &type, &v24)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    char v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v27 = "nw_path_monitor_set_update_handler";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null update_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    char v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v27 = "nw_path_monitor_set_update_handler";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  BOOL v19 = (char *)__nw_create_backtrace_string();
  char v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v27 = "nw_path_monitor_set_update_handler";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v27 = "nw_path_monitor_set_update_handler";
    __int16 v28 = 2082;
    os_log_type_t v29 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_39;
  }
LABEL_4:
}

void nw_parameters_set_traffic_class(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  nw_path_monitor_update_handler_t v4 = v3;
  if (v3)
  {
    *(_DWORD *)(*((void *)v3 + 13) + 72) = a2;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_set_traffic_class";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_set_traffic_class";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_set_traffic_class";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_set_traffic_class";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_set_traffic_class";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_quic_connection_set_is_early_data_accepted(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_is_early_data_accepted_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  nw_path_monitor_update_handler_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_quic_connection_set_is_early_data_accepted";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_quic_connection_set_is_early_data_accepted";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_quic_connection_set_is_early_data_accepted";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_quic_connection_set_is_early_data_accepted";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_quic_connection_set_is_early_data_accepted";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183394A0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_is_early_data_accepted_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 216) = *(unsigned char *)(a2 + 216) & 0xFE | *(unsigned char *)(a1 + 32);
  return 1;
}

void nw_path_flow_registration_set_ecn_cache(void *a1, void *a2, uint64_t a3)
{
  *(void *)&v43[13] = *MEMORY[0x1E4F143B8];
  int v5 = a1;
  id v6 = a2;
  os_log_type_t v7 = v6;
  if (!v5)
  {
    uint64_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
    char v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type)) {
      goto LABEL_28;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = __nwlog_obj();
      os_log_type_t v22 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v21 = __nwlog_obj();
      os_log_type_t v33 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v33, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v21 = __nwlog_obj();
    os_log_type_t v27 = v37[0];
    BOOL v28 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
      __int16 v42 = 2082;
      *(void *)os_log_type_t v43 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_60;
  }
  if (!v6)
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
    char v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type)) {
      goto LABEL_28;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = __nwlog_obj();
      os_log_type_t v24 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null flow_registration", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v21 = __nwlog_obj();
      os_log_type_t v34 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v21 = __nwlog_obj();
    os_log_type_t v29 = v37[0];
    BOOL v30 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
      __int16 v42 = 2082;
      *(void *)os_log_type_t v43 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_60;
  }
  if (!a3)
  {
    uint64_t v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
    char v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type)) {
      goto LABEL_28;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = __nwlog_obj();
      os_log_type_t v26 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null ecn_cache_buffer", buf, 0xCu);
      }
LABEL_78:

LABEL_28:
      if (!v13) {
        goto LABEL_30;
      }
LABEL_29:
      free(v13);
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v21 = __nwlog_obj();
      os_log_type_t v35 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v35, "%{public}s called with null ecn_cache_buffer, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v21 = __nwlog_obj();
    os_log_type_t v31 = v37[0];
    BOOL v32 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_1830D4000, v21, v31, "%{public}s called with null ecn_cache_buffer, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
      __int16 v42 = 2082;
      *(void *)os_log_type_t v43 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v31, "%{public}s called with null ecn_cache_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_60:

    goto LABEL_20;
  }
  *(void *)uint64_t v37 = 0;
  id v8 = nw_parameters_copy_context(v5[2]);
  int v9 = nw_path_shared_necp_fd(v8);

  if (v9 < 0) {
    goto LABEL_30;
  }
  *(_WORD *)uint64_t v37 = 257;
  uint64_t v38 = a3;
  *(_DWORD *)&v37[4] = 1;
  if (!necp_client_action()) {
    goto LABEL_30;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v11 = (id)gLogObj;
  os_log_type_t v12 = v11;
  if (v10 != 2)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
    __int16 v42 = 1024;
    *(_DWORD *)os_log_type_t v43 = v10;
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36)) {
      goto LABEL_28;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        __int16 v42 = 1024;
        *(_DWORD *)os_log_type_t v43 = v10;
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s necp update cache failed for ecn %{darwin.errno}d", buf, 0x12u);
      }
LABEL_27:

      goto LABEL_28;
    }
    if (!v36)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        __int16 v42 = 1024;
        *(_DWORD *)os_log_type_t v43 = v10;
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s necp update cache failed for ecn %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_27;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v14 = (id)gLogObj;
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
        __int16 v42 = 1024;
        *(_DWORD *)os_log_type_t v43 = v10;
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s necp update cache failed for ecn %{darwin.errno}d, no backtrace", buf, 0x12u);
      }
      goto LABEL_27;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
      __int16 v42 = 1024;
      *(_DWORD *)os_log_type_t v43 = v10;
      v43[2] = 2082;
      *(void *)&v43[3] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s necp update cache failed for ecn %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_20:
    free(backtrace_string);
    if (!v13) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v41 = "nw_path_flow_registration_set_ecn_cache";
    __int16 v42 = 1024;
    *(_DWORD *)os_log_type_t v43 = 2;
    _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s necp update cache failed for ecn %{darwin.errno}d", buf, 0x12u);
  }

LABEL_30:
}

void sub_183395444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_interface_create_with_name(char *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_interface_create_with_name";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12)) {
      goto LABEL_25;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_interface_create_with_name";
        int v9 = "%{public}s called with null interface_name";
LABEL_23:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v15 = "nw_interface_create_with_name";
            __int16 v16 = 2082;
            os_log_type_t v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null interface_name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (!v11) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_interface_create_with_name";
        int v9 = "%{public}s called with null interface_name, no backtrace";
        goto LABEL_23;
      }
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_interface_create_with_name";
        int v9 = "%{public}s called with null interface_name, backtrace limit exceeded";
        goto LABEL_23;
      }
    }
LABEL_24:

LABEL_25:
    if (v6) {
      free(v6);
    }
    return 0;
  }
  unsigned int v2 = if_nametoindex(a1);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_path_monitor_update_handler_t v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v15 = "nw_interface_create_with_name";
      __int16 v16 = 2082;
      os_log_type_t v17 = a1;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s Failed to find interface index for %{public}s", buf, 0x16u);
    }

    return 0;
  }

  return nw_interface_create_with_index_and_name(v2, (unsigned __int8 *)a1);
}

NWConcrete_nw_interface *nw_interface_create_with_index_and_name(unsigned int a1, unsigned __int8 *a2)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    BOOL v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
    os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v72 = 0;
    if (!__nwlog_fault(v59, &type, &v72)) {
      goto LABEL_145;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null interface_index", buf, 0xCu);
      }
    }
    else if (v72)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v60 = __nwlog_obj();
      os_log_type_t v65 = type;
      BOOL v66 = os_log_type_enabled(v60, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null interface_index, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_145;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null interface_index, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v60 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_1830D4000, v60, v70, "%{public}s called with null interface_index, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_144:

    goto LABEL_145;
  }
  if (a2)
  {
    if (a1 >= 0x7FFFFFFF)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_path_monitor_update_handler_t v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = a1;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = 0x7FFFFFFF;
        *(_WORD *)&unsigned char buf[24] = 2082;
        *(void *)&buf[26] = a2;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s refusing to create an interface with index %u too high (>=%u) (name=\"%{public}s\")", buf, 0x22u);
      }

      return 0;
    }
    id v6 = objc_alloc_init(NWConcrete_nw_interface);
    os_log_type_t v7 = v6;
    if (v6)
    {
      v6->index = a1;
      int v8 = *a2;
      v6->name[0] = v8;
      if (v8)
      {
        int v9 = a2[1];
        v6->name[1] = v9;
        if (v9)
        {
          int v10 = a2[2];
          v6->name[2] = v10;
          if (v10)
          {
            int v11 = a2[3];
            v6->name[3] = v11;
            if (v11)
            {
              int v12 = a2[4];
              v6->name[4] = v12;
              if (v12)
              {
                int v13 = a2[5];
                v6->name[5] = v13;
                if (v13)
                {
                  int v14 = a2[6];
                  v6->name[6] = v14;
                  if (v14)
                  {
                    int v15 = a2[7];
                    v6->name[7] = v15;
                    if (v15)
                    {
                      int v16 = a2[8];
                      v6->name[8] = v16;
                      if (v16)
                      {
                        int v17 = a2[9];
                        v6->name[9] = v17;
                        if (v17)
                        {
                          int v18 = a2[10];
                          v6->name[10] = v18;
                          if (v18)
                          {
                            int v19 = a2[11];
                            v6->name[11] = v19;
                            if (v19)
                            {
                              int v20 = a2[12];
                              v6->name[12] = v20;
                              if (v20)
                              {
                                int v21 = a2[13];
                                v6->name[13] = v21;
                                if (v21)
                                {
                                  int v22 = a2[14];
                                  v6->name[14] = v22;
                                  if (v22)
                                  {
                                    int v23 = a2[15];
                                    v6->name[15] = v23;
                                    if (v23)
                                    {
                                      int v24 = a2[16];
                                      v6->name[16] = v24;
                                      if (v24)
                                      {
                                        int v25 = a2[17];
                                        v6->name[17] = v25;
                                        if (v25)
                                        {
                                          int v26 = a2[18];
                                          v6->name[18] = v26;
                                          if (v26)
                                          {
                                            int v27 = a2[19];
                                            v6->name[19] = v27;
                                            if (v27)
                                            {
                                              int v28 = a2[20];
                                              v6->name[20] = v28;
                                              if (v28)
                                              {
                                                int v29 = a2[21];
                                                v6->name[21] = v29;
                                                if (v29)
                                                {
                                                  int v30 = a2[22];
                                                  v6->name[22] = v30;
                                                  if (v30)
                                                  {
                                                    int v31 = a2[23];
                                                    v6->name[23] = v31;
                                                    if (v31) {
                                                      v6->name[24] = 0;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      int v32 = socket(2, 2, 0);
      if ((v32 & 0x80000000) == 0)
      {
        os_log_type_t v33 = v7;
        os_log_type_t v34 = v33;
        memset(buf, 0, 32);
        buf[0] = v7->name[0];
        if (buf[0])
        {
          buf[1] = v33->name[1];
          if (buf[1])
          {
            buf[2] = v33->name[2];
            if (buf[2])
            {
              buf[3] = v33->name[3];
              if (buf[3])
              {
                uint8_t buf[4] = v33->name[4];
                if (buf[4])
                {
                  buf[5] = v33->name[5];
                  if (buf[5])
                  {
                    buf[6] = v33->name[6];
                    if (buf[6])
                    {
                      buf[7] = v33->name[7];
                      if (buf[7])
                      {
                        buf[8] = v33->name[8];
                        if (buf[8])
                        {
                          buf[9] = v33->name[9];
                          if (buf[9])
                          {
                            buf[10] = v33->name[10];
                            if (buf[10])
                            {
                              buf[11] = v33->name[11];
                              if (buf[11])
                              {
                                unsigned char buf[12] = v33->name[12];
                                if (buf[12])
                                {
                                  buf[13] = v33->name[13];
                                  if (buf[13]) {
                                    buf[14] = v33->name[14];
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (ioctl(v32, 0xC0206933uLL, buf) != -1) {
          v34->details.mtu = *(_DWORD *)&buf[16];
        }
        if (ioctl(v32, 0xC02069A0uLL, buf) != -1) {
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFFFE | (*(_DWORD *)&buf[16] != 0);
        }
        if (ioctl(v32, 0xC02069CCuLL, buf) != -1) {
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFFFD | (2 * (*(_DWORD *)&buf[16] != 0));
        }
        if (ioctl(v32, 0xC02069DAuLL, buf) != -1) {
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFFFB | (4 * (*(_DWORD *)&buf[16] != 0));
        }
        if (ioctl(v32, 0xC020699DuLL, buf) != -1) {
          v34->delegate_index = *(_DWORD *)&buf[16];
        }
        if (ioctl(v32, 0xC02069ADuLL, buf) != -1)
        {
          int v35 = *(_DWORD *)&buf[16];
          int v36 = 4;
          int v37 = 2;
          switch(*(_DWORD *)&buf[16])
          {
            case 1:
            case 6:
              goto LABEL_95;
            case 2:
              int v37 = 3;
              goto LABEL_99;
            case 3:
            case 4:
              v34->os_log_type_t type = 1;
              unsigned int v38 = v35 - 3;
              goto LABEL_96;
            case 5:
LABEL_99:
              unsigned int v55 = 0;
              v34->os_log_type_t type = v37;
              break;
            default:
              int v36 = 0;
LABEL_95:
              v34->os_log_type_t type = v36;
              unsigned int v38 = v35 - 3;
              if (v38 > 4) {
                unsigned int v55 = 0;
              }
              else {
LABEL_96:
              }
                unsigned int v55 = dword_183E234B8[v38];
              break;
          }
          v34->subos_log_type_t type = v55;
        }
        if (ioctl(v32, 0xC0206911uLL, buf) != -1) {
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFDFF | (*(_WORD *)&buf[16] >> 6) & 0x200;
        }

        close(v32);
        int v5 = v34;
        goto LABEL_110;
      }
      int v43 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v44 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v43;
      __int16 v40 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v72 = 0;
      if (!__nwlog_fault((const char *)v40, &type, &v72))
      {
LABEL_107:
        if (!v40)
        {
LABEL_109:
          int v5 = 0;
LABEL_110:

          return v5;
        }
LABEL_108:
        free(v40);
        goto LABEL_109;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v41 = (id)gLogObj;
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl(&dword_1830D4000, v41, v45, "%{public}s information socket creation failed %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v72)
      {
        char v49 = __nw_create_backtrace_string();
        if (v49)
        {
          __int16 v50 = (char *)v49;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v51 = (id)gLogObj;
          os_log_type_t v52 = type;
          if (os_log_type_enabled(v51, type))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v43;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v50;
            _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s information socket creation failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v50);
          if (!v40) {
            goto LABEL_109;
          }
          goto LABEL_108;
        }
        uint64_t v41 = __nwlog_obj();
        os_log_type_t v56 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl(&dword_1830D4000, v41, v56, "%{public}s information socket creation failed %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v41 = (id)gLogObj;
        os_log_type_t v54 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl(&dword_1830D4000, v41, v54, "%{public}s information socket creation failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v39 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
      __int16 v40 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v72 = 0;
      if (!__nwlog_fault((const char *)v40, &type, &v72)) {
        goto LABEL_107;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v41 = (id)gLogObj;
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s nw_interface_create failed", buf, 0xCu);
        }
      }
      else if (v72)
      {
        __int16 v46 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v41 = (id)gLogObj;
        os_log_type_t v47 = type;
        BOOL v48 = os_log_type_enabled(v41, type);
        if (v46)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v46;
            _os_log_impl(&dword_1830D4000, v41, v47, "%{public}s nw_interface_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v46);
          if (!v40) {
            goto LABEL_109;
          }
          goto LABEL_108;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_1830D4000, v41, v47, "%{public}s nw_interface_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v41 = (id)gLogObj;
        os_log_type_t v53 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_1830D4000, v41, v53, "%{public}s nw_interface_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_107;
  }
  os_log_type_t v62 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
  os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v72 = 0;
  if (__nwlog_fault(v59, &type, &v72))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v60 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_1830D4000, v60, v63, "%{public}s called with null interface_name", buf, 0xCu);
      }
    }
    else if (v72)
    {
      BOOL v67 = (char *)__nw_create_backtrace_string();
      BOOL v60 = __nwlog_obj();
      os_log_type_t v68 = type;
      BOOL v69 = os_log_type_enabled(v60, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v67;
          _os_log_impl(&dword_1830D4000, v60, v68, "%{public}s called with null interface_name, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v67);
        if (!v59) {
          return 0;
        }
        goto LABEL_146;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_1830D4000, v60, v68, "%{public}s called with null interface_name, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v60 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_1830D4000, v60, v71, "%{public}s called with null interface_name, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_144;
  }
LABEL_145:
  if (v59) {
LABEL_146:
  }
    free(v59);
  return 0;
}

void sub_183396A38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_interface_create_from_necp(uint64_t a1, unsigned int a2)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    BOOL v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_interface_create_from_necp";
    int v36 = (char *)_os_log_send_and_compose_impl();

    v68[0] = 16;
    LOBYTE(v67) = 0;
    if (!__nwlog_fault(v36, v68, &v67)) {
      goto LABEL_69;
    }
    if (v68[0] == 17)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v60 = v68[0];
      if (os_log_type_enabled(v59, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_from_necp";
        _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null interface_index", buf, 0xCu);
      }
    }
    else if ((_BYTE)v67)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v62 = v68[0];
      BOOL v63 = os_log_type_enabled(v59, (os_log_type_t)v68[0]);
      if (backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_from_necp";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null interface_index, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_69;
      }
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_from_necp";
        _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null interface_index, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v64 = v68[0];
      if (os_log_type_enabled(v59, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_from_necp";
        _os_log_impl(&dword_1830D4000, v59, v64, "%{public}s called with null interface_index, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_69;
  }
  if (a2 >= 0x7FFFFFFF)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_interface_create_from_necp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = 0x7FFFFFFF;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s refusing to create an interface with index %u too high (>=%u)", buf, 0x18u);
    }

    return 0;
  }
  unsigned int v67 = a2;
  int v78 = 0;
  long long v77 = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)BOOL v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  memset(buf, 0, sizeof(buf));
  if (!necp_client_action())
  {
    if (!*(_DWORD *)&buf[24])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_log_type_t v68 = 136446466;
        BOOL v69 = "nw_interface_create_from_necp";
        __int16 v70 = 1024;
        LODWORD(v71[0]) = a2;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s Copy interface failed to find valid interface for index %u", v68, 0x12u);
      }
      goto LABEL_10;
    }
    os_log_type_t v7 = objc_alloc_init(NWConcrete_nw_interface);
    int v8 = v7;
    if (v7)
    {
      int v9 = buf[0];
      v7->name[0] = buf[0];
      if (v9)
      {
        int v10 = buf[1];
        v7->name[1] = buf[1];
        if (v10)
        {
          int v11 = buf[2];
          v7->name[2] = buf[2];
          if (v11)
          {
            int v12 = buf[3];
            v7->name[3] = buf[3];
            if (v12)
            {
              int v13 = buf[4];
              v7->name[4] = buf[4];
              if (v13)
              {
                int v14 = buf[5];
                v7->name[5] = buf[5];
                if (v14)
                {
                  int v15 = buf[6];
                  v7->name[6] = buf[6];
                  if (v15)
                  {
                    int v16 = buf[7];
                    v7->name[7] = buf[7];
                    if (v16)
                    {
                      int v17 = buf[8];
                      v7->name[8] = buf[8];
                      if (v17)
                      {
                        int v18 = buf[9];
                        v7->name[9] = buf[9];
                        if (v18)
                        {
                          int v19 = buf[10];
                          v7->name[10] = buf[10];
                          if (v19)
                          {
                            int v20 = buf[11];
                            v7->name[11] = buf[11];
                            if (v20)
                            {
                              int v21 = buf[12];
                              v7->name[12] = buf[12];
                              if (v21)
                              {
                                int v22 = buf[13];
                                v7->name[13] = buf[13];
                                if (v22)
                                {
                                  int v23 = buf[14];
                                  v7->name[14] = buf[14];
                                  if (v23)
                                  {
                                    int v24 = buf[15];
                                    v7->name[15] = buf[15];
                                    if (v24)
                                    {
                                      int v25 = buf[16];
                                      v7->name[16] = buf[16];
                                      if (v25)
                                      {
                                        int v26 = buf[17];
                                        v7->name[17] = buf[17];
                                        if (v26)
                                        {
                                          int v27 = buf[18];
                                          v7->name[18] = buf[18];
                                          if (v27)
                                          {
                                            int v28 = buf[19];
                                            v7->name[19] = buf[19];
                                            if (v28)
                                            {
                                              int v29 = buf[20];
                                              v7->name[20] = buf[20];
                                              if (v29)
                                              {
                                                int v30 = buf[21];
                                                v7->name[21] = buf[21];
                                                if (v30)
                                                {
                                                  int v31 = buf[22];
                                                  v7->name[22] = buf[22];
                                                  if (v31) {
                                                    v7->name[23] = 0;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v7->index = *(_DWORD *)&buf[24];
      int v32 = v73;
      int v33 = 4;
      int v34 = 2;
      switch((int)v73)
      {
        case 1:
        case 6:
          goto LABEL_74;
        case 2:
          int v34 = 3;
          goto LABEL_78;
        case 3:
        case 4:
          v7->os_log_type_t type = 1;
          unsigned int v35 = v32 - 3;
          goto LABEL_75;
        case 5:
LABEL_78:
          unsigned int v51 = 0;
          v7->os_log_type_t type = v34;
          break;
        default:
          int v33 = 0;
LABEL_74:
          v7->os_log_type_t type = v33;
          unsigned int v35 = v32 - 3;
          if (v35 > 4) {
            unsigned int v51 = 0;
          }
          else {
LABEL_75:
          }
            unsigned int v51 = dword_183E234B8[v35];
          break;
      }
      v7->subos_log_type_t type = v51;
      unsigned int v52 = *(_DWORD *)&buf[28];
      v7->delegate_index = DWORD1(v73);
      v7->generation = v52;
      v7->details.mtu = HIDWORD(v73);
      *(void *)&v7->details.tso_max_segment_size_int v4 = *(void *)((char *)&v77 + 4);
      v7->details.hwcsum_flags = HIDWORD(v77);
      *(_WORD *)((char *)&v7->details + 73) = (*(_WORD *)((char *)&v7->details + 73) & 0xFF80 | BYTE8(v73) & 1 | (WORD4(v73) >> 5) & 2 | (WORD4(v73) >> 12) & 4 | (8 * ((WORD4(v73) >> 1) & 7)) & 0xFFBF | (((WORD4(v73) >> 5) & 1) << 6)) ^ 0x10;
      memcpy(&v7->details, &v74, BYTE4(__n[0]));
      v8->details.ipv4_signature.signature_len = BYTE4(__n[0]);
      memcpy(&v8->details.ipv6_signature, (char *)__n + 5, BYTE1(v76[1]));
      v8->details.ipv6_signature.signature_len = BYTE1(v76[1]);
      __int16 v53 = WORD4(v73);
      __int16 v54 = *(_WORD *)((char *)&v8->details + 73) & 0xFF7F | BYTE8(v73) & 0x80;
      *(_WORD *)((char *)&v8->details + 73) = v54;
      if ((v53 & 0x80) != 0) {
        v8->details.ipv4_netmask = HIDWORD(v76[1]);
      }
      __int16 v55 = v54 & 0xFEFF | v53 & 0x100;
      *(_WORD *)((char *)&v8->details + 73) = v55;
      if ((v53 & 0x100) != 0) {
        v8->details.ipv4_broadcast = v77;
      }
      *(_WORD *)((char *)&v8->details + 73) = v55 & 0xC1FF | v53 & 0x3E00;
      v8->details.radio_os_log_type_t type = v78;
      os_log_type_t v56 = v8;
LABEL_92:

      return v8;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v42 = (id)gLogObj;
    *(_DWORD *)os_log_type_t v68 = 136446210;
    BOOL v69 = "nw_interface_create_from_necp";
    int v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v43, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (id)gLogObj;
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)os_log_type_t v68 = 136446210;
          BOOL v69 = "nw_interface_create_from_necp";
          _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s nw_interface_create failed", v68, 0xCu);
        }
      }
      else if (v65)
      {
        os_log_type_t v47 = (char *)__nw_create_backtrace_string();
        id v44 = __nwlog_obj();
        os_log_type_t v48 = type;
        BOOL v49 = os_log_type_enabled(v44, type);
        if (v47)
        {
          if (v49)
          {
            *(_DWORD *)os_log_type_t v68 = 136446466;
            BOOL v69 = "nw_interface_create_from_necp";
            __int16 v70 = 2082;
            v71[0] = v47;
            _os_log_impl(&dword_1830D4000, v44, v48, "%{public}s nw_interface_create failed, dumping backtrace:%{public}s", v68, 0x16u);
          }

          free(v47);
          goto LABEL_90;
        }
        if (v49)
        {
          *(_DWORD *)os_log_type_t v68 = 136446210;
          BOOL v69 = "nw_interface_create_from_necp";
          _os_log_impl(&dword_1830D4000, v44, v48, "%{public}s nw_interface_create failed, no backtrace", v68, 0xCu);
        }
      }
      else
      {
        id v44 = __nwlog_obj();
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)os_log_type_t v68 = 136446210;
          BOOL v69 = "nw_interface_create_from_necp";
          _os_log_impl(&dword_1830D4000, v44, v57, "%{public}s nw_interface_create failed, backtrace limit exceeded", v68, 0xCu);
        }
      }
    }
LABEL_90:
    if (v43) {
      free(v43);
    }
    goto LABEL_92;
  }
  int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v5 = (id)gLogObj;
  id v6 = v5;
  if (v4 != 2)
  {
    *(_DWORD *)os_log_type_t v68 = 136446466;
    BOOL v69 = "nw_interface_create_from_necp";
    __int16 v70 = 1024;
    LODWORD(v71[0]) = v4;
    int v36 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v36, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v37 = (id)gLogObj;
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)os_log_type_t v68 = 136446466;
          BOOL v69 = "nw_interface_create_from_necp";
          __int16 v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d", v68, 0x12u);
        }
      }
      else if (v65)
      {
        id v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v37 = (id)gLogObj;
        os_log_type_t v40 = type;
        BOOL v41 = os_log_type_enabled(v37, type);
        if (v39)
        {
          if (v41)
          {
            *(_DWORD *)os_log_type_t v68 = 136446722;
            BOOL v69 = "nw_interface_create_from_necp";
            __int16 v70 = 1024;
            LODWORD(v71[0]) = v4;
            WORD2(v71[0]) = 2082;
            *(void *)((char *)v71 + 6) = v39;
            _os_log_impl(&dword_1830D4000, v37, v40, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, dumping backtrace:%{public}s", v68, 0x1Cu);
          }

          free(v39);
          if (!v36) {
            return 0;
          }
          goto LABEL_70;
        }
        if (v41)
        {
          *(_DWORD *)os_log_type_t v68 = 136446466;
          BOOL v69 = "nw_interface_create_from_necp";
          __int16 v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl(&dword_1830D4000, v37, v40, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, no backtrace", v68, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v37 = (id)gLogObj;
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)os_log_type_t v68 = 136446466;
          BOOL v69 = "nw_interface_create_from_necp";
          __int16 v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl(&dword_1830D4000, v37, v46, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, backtrace limit exceeded", v68, 0x12u);
        }
      }
    }
LABEL_69:
    if (!v36) {
      return 0;
    }
LABEL_70:
    free(v36);
    return 0;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)os_log_type_t v68 = 136446466;
    BOOL v69 = "nw_interface_create_from_necp";
    __int16 v70 = 1024;
    LODWORD(v71[0]) = 2;
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d", v68, 0x12u);
  }
LABEL_10:

  return 0;
}

uint64_t objectdestroy_104Tm()
{
  uint64_t v1 = type metadata accessor for NWPath(0);
  unint64_t v2 = (*(unsigned __int8 *)(*(void *)(v1 - 8) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v1 - 8) + 80);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  unint64_t v3 = v0 + v2 + *(int *)(v1 + 44);
  uint64_t v4 = type metadata accessor for NWEndpoint();
  int v5 = *(unsigned int (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 48);
  if (!v5(v3, 1, v4))
  {
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        sub_18315E658(*(void *)v3, *(void *)(v3 + 8), *(void *)(v3 + 16), *(unsigned char *)(v3 + 24));
        break;
      case 1u:
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(void *)(v3 + 48) != 1) {
          goto LABEL_14;
        }
        break;
      case 2u:
        swift_bridgeObjectRelease();
        break;
      case 3u:
        uint64_t v8 = sub_183D4447C();
        (*(void (**)(unint64_t, uint64_t))(*(void *)(v8 - 8) + 8))(v3, v8);
        break;
      case 4u:
LABEL_14:
        swift_unknownObjectRelease();
        break;
      default:
        break;
    }
  }
  unint64_t v6 = v0 + v2 + *(int *)(v1 + 48);
  if (!v5(v6, 1, v4))
  {
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        sub_18315E658(*(void *)v6, *(void *)(v6 + 8), *(void *)(v6 + 16), *(unsigned char *)(v6 + 24));
        break;
      case 1u:
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(void *)(v6 + 48) != 1) {
          goto LABEL_19;
        }
        break;
      case 2u:
        swift_bridgeObjectRelease();
        break;
      case 3u:
        uint64_t v9 = sub_183D4447C();
        (*(void (**)(unint64_t, uint64_t))(*(void *)(v9 - 8) + 8))(v6, v9);
        break;
      case 4u:
LABEL_19:
        swift_unknownObjectRelease();
        break;
      default:
        break;
    }
  }
  swift_unknownObjectRelease();

  return swift_deallocObject();
}

uint64_t nw_protocol_http2_transport_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v24 = "nw_protocol_http2_transport_finalize_output_frames";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v8, &v22, &v21)) {
      goto LABEL_39;
    }
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = v22;
      if (!os_log_type_enabled(v9, v22)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      int v24 = "nw_protocol_http2_transport_finalize_output_frames";
      int v11 = "%{public}s called with null protocol";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = v22;
      BOOL v14 = os_log_type_enabled(v9, v22);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          int v24 = "nw_protocol_http2_transport_finalize_output_frames";
          __int16 v25 = 2082;
          int v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_39:
        if (!v8) {
          return 0;
        }
LABEL_40:
        free(v8);
        return 0;
      }
      if (!v14) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      int v24 = "nw_protocol_http2_transport_finalize_output_frames";
      int v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = v22;
      if (!os_log_type_enabled(v9, v22)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      int v24 = "nw_protocol_http2_transport_finalize_output_frames";
      int v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_38:
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
    goto LABEL_39;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if (gLogDatapath)
    {
      int v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        int v24 = "nw_protocol_http2_transport_finalize_output_frames";
        __int16 v25 = 2082;
        int v26 = handle + 205;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 0x40000000;
    int v18 = ___ZL50nw_protocol_http2_transport_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    int v19 = &__block_descriptor_tmp_44_38322;
    int v20 = a2;
    uint64_t tqh_first = a2->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      int v5 = (nw_frame *)*((void *)tqh_first + 4);
      char v6 = ((uint64_t (*)(void *))v18)(v17);
      uint64_t tqh_first = v5;
    }
    while ((v6 & 1) != 0);
    nw_http2_transport_session_send((uint64_t)handle);
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v24 = "nw_protocol_http2_transport_finalize_output_frames";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v22 = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (!__nwlog_fault(v8, &v22, &v21)) {
    goto LABEL_39;
  }
  if (v22 == OS_LOG_TYPE_FAULT)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v10 = v22;
    if (!os_log_type_enabled(v9, v22)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    int v24 = "nw_protocol_http2_transport_finalize_output_frames";
    int v11 = "%{public}s called with null http2_transport";
    goto LABEL_38;
  }
  if (!v21)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v10 = v22;
    if (!os_log_type_enabled(v9, v22)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    int v24 = "nw_protocol_http2_transport_finalize_output_frames";
    int v11 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    goto LABEL_38;
  }
  int v15 = (char *)__nw_create_backtrace_string();
  uint64_t v9 = __nwlog_obj();
  os_log_type_t v10 = v22;
  BOOL v16 = os_log_type_enabled(v9, v22);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    int v24 = "nw_protocol_http2_transport_finalize_output_frames";
    int v11 = "%{public}s called with null http2_transport, no backtrace";
    goto LABEL_38;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    int v24 = "nw_protocol_http2_transport_finalize_output_frames";
    __int16 v25 = 2082;
    int v26 = v15;
    _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v15);
  if (v8) {
    goto LABEL_40;
  }
  return 0;
}

uint64_t ___ZL50nw_protocol_http2_transport_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  unint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    unint64_t v3 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 32) + 8) = v3;
  }
  void *v3 = v2;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void nw_protocol_http2_transport_frame_output_finalizer(nw_frame *a1, int a2, void *a3)
{
  v63[2] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
      unint64_t v3 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v56 = 0;
      if (!__nwlog_fault(v3, &type, &v56)) {
        goto LABEL_36;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
        char v6 = "%{public}s http2_transport output frames should no longer have nonnull context";
      }
      else
      {
        if (v56)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v16 = gLogObj;
          os_log_type_t v17 = type;
          BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = (nw_frame *)backtrace_string;
              _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s http2_transport output frames should no longer have nonnull context, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            if (v3) {
              goto LABEL_37;
            }
            return;
          }
          if (!v18) {
            goto LABEL_36;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          char v6 = "%{public}s http2_transport output frames should no longer have nonnull context, no backtrace";
          __int16 v25 = v16;
          os_log_type_t v26 = v17;
          goto LABEL_35;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
        char v6 = "%{public}s http2_transport output frames should no longer have nonnull context, backtrace limit exceeded";
      }
LABEL_34:
      __int16 v25 = v4;
      os_log_type_t v26 = v5;
LABEL_35:
      _os_log_impl(&dword_1830D4000, v25, v26, v6, buf, 0xCu);
      goto LABEL_36;
    }
    if (gLogDatapath)
    {
      id v44 = __nwlog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
        __int16 v60 = 2048;
        os_log_type_t v61 = a1;
        __int16 v62 = 1024;
        LODWORD(v63[0]) = a2;
        WORD2(v63[0]) = 2048;
        *(void *)((char *)v63 + 6) = 0;
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s called with frame %p success %d context %p", buf, 0x26u);
      }
    }
    __int16 v9 = *((_WORD *)a1 + 102);
    os_log_type_t v10 = (uint64_t *)((char *)a1 + 208);
    if ((v9 & 4) != 0)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        uint64_t v12 = *((void *)a1 + 2);
        int v13 = (void *)*((void *)a1 + 3);
        BOOL v14 = (void *)((char *)a1 + 16);
        if (v12)
        {
          *(void *)(v12 + 24) = v13;
          int v13 = (void *)*((void *)a1 + 3);
        }
        else
        {
          *(void *)(v11 + 136) = v13;
        }
        void *v13 = v12;
        *BOOL v14 = 0;
        *((void *)a1 + 3) = 0;
        if (!a2)
        {
          if (gLogDatapath)
          {
            int v24 = __nwlog_obj();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = (nw_frame *)(v11 + 205);
              _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disposing of output frame, finalizer called with success == false", buf, 0x16u);
            }
          }
          goto LABEL_89;
        }
        uint64_t v19 = *((void *)a1 + 27);
        if (v19)
        {
          uint64_t v20 = *(void *)(v19 + 56);
          if (v20)
          {
            uint64_t v21 = *(void *)(v20 + 32);
            if (v21)
            {
              if ((*(unsigned char *)(v21 + 36) & 1) != 0 || *(int *)(v21 + 32) < 1)
              {
                if (*(void *)(v21 + 16))
                {
                  if (gLogDatapath)
                  {
                    BOOL v49 = __nwlog_obj();
                    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446466;
                      os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                      __int16 v60 = 2082;
                      os_log_type_t v61 = (nw_frame *)(v11 + 205);
                      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream already has pending data, simply pending for future send", buf, 0x16u);
                    }
                    int v50 = gLogDatapath;
                    *((void *)a1 + 2) = 0;
                    unsigned int v51 = *(void **)(v21 + 24);
                    *((void *)a1 + 3) = v51;
                    void *v51 = a1;
                    *(void *)(v21 + 24) = v14;
                    if (v50)
                    {
                      unsigned int v52 = __nwlog_obj();
                      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 0;
                        nw_frame_array_get_frame_count((uint64_t *)(v21 + 16), 0, buf);
                        int v53 = *(_DWORD *)buf;
                        *(_DWORD *)buf = 136446722;
                        os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                        __int16 v60 = 2082;
                        os_log_type_t v61 = (nw_frame *)(v11 + 205);
                        __int16 v62 = 1024;
                        LODWORD(v63[0]) = v53;
                        _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream now has %u bytes pending", buf, 0x1Cu);
                      }
                    }
                  }
                  else
                  {
                    *((void *)a1 + 2) = 0;
                    unsigned int v35 = *(void **)(v21 + 24);
                    *((void *)a1 + 3) = v35;
                    *unsigned int v35 = a1;
                    *(void *)(v21 + 24) = v14;
                  }
                }
                else
                {
                  if (!nw_http2_transport_submit_data(v11, (uint64_t)a1))
                  {
                    *((void *)a1 + 2) = 0;
                    BOOL v41 = *(void **)(v21 + 24);
                    *((void *)a1 + 3) = v41;
                    *BOOL v41 = a1;
                    *(void *)(v21 + 24) = v14;
                    if (gLogDatapath)
                    {
                      __int16 v54 = __nwlog_obj();
                      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 0;
                        nw_frame_array_get_frame_count((uint64_t *)(v21 + 16), 0, buf);
                        int v55 = *(_DWORD *)buf;
                        *(_DWORD *)buf = 136446722;
                        os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                        __int16 v60 = 2082;
                        os_log_type_t v61 = (nw_frame *)(v11 + 205);
                        __int16 v62 = 1024;
                        LODWORD(v63[0]) = v55;
                        _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream now has %u bytes pending", buf, 0x1Cu);
                      }
                    }
                  }
                  nw_http2_transport_session_send(v11);
                }
                return;
              }
              os_log_type_t v22 = __nwlog_obj();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                __int16 v60 = 2082;
                os_log_type_t v61 = (nw_frame *)(v11 + 205);
                _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Cannot send data on a stream that is not open but has a greater than zero stream id", buf, 0x16u);
              }
              buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0);
              if (!buffer)
              {
LABEL_94:
                nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
                os_release(a1);
                return;
              }
LABEL_93:
              free(buffer);
              goto LABEL_94;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v36 = (nw_frame *)(v11 + 205);
            *(_DWORD *)buf = 136446466;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            __int16 v60 = 2082;
            os_log_type_t v61 = (nw_frame *)(v11 + 205);
            int v28 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v56 = 0;
            if (__nwlog_fault(v28, &type, &v56))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                int v29 = __nwlog_obj();
                os_log_type_t v30 = type;
                if (!os_log_type_enabled(v29, type)) {
                  goto LABEL_87;
                }
                *(_DWORD *)buf = 136446466;
                os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                __int16 v60 = 2082;
                os_log_type_t v61 = v36;
                int v31 = "%{public}s %{public}s stream not found";
                goto LABEL_86;
              }
              if (!v56)
              {
                int v29 = __nwlog_obj();
                os_log_type_t v30 = type;
                if (!os_log_type_enabled(v29, type)) {
                  goto LABEL_87;
                }
                *(_DWORD *)buf = 136446466;
                os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                __int16 v60 = 2082;
                os_log_type_t v61 = v36;
                int v31 = "%{public}s %{public}s stream not found, backtrace limit exceeded";
                goto LABEL_86;
              }
              int v37 = (char *)__nw_create_backtrace_string();
              int v29 = __nwlog_obj();
              os_log_type_t v30 = type;
              BOOL v40 = os_log_type_enabled(v29, type);
              if (!v37)
              {
                if (!v40) {
                  goto LABEL_87;
                }
                *(_DWORD *)buf = 136446466;
                os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
                __int16 v60 = 2082;
                os_log_type_t v61 = v36;
                int v31 = "%{public}s %{public}s stream not found, no backtrace";
                goto LABEL_86;
              }
              if (!v40) {
                goto LABEL_69;
              }
              *(_DWORD *)buf = 136446722;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = v36;
              __int16 v62 = 2082;
              v63[0] = v37;
              id v39 = "%{public}s %{public}s stream not found, dumping backtrace:%{public}s";
              goto LABEL_68;
            }
LABEL_87:
            if (!v28) {
              goto LABEL_89;
            }
            goto LABEL_88;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v32 = (nw_frame *)(v11 + 205);
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          __int16 v60 = 2082;
          os_log_type_t v61 = (nw_frame *)(v11 + 205);
          int v28 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v56 = 0;
          if (!__nwlog_fault(v28, &type, &v56)) {
            goto LABEL_87;
          }
          if (type != OS_LOG_TYPE_FAULT)
          {
            if (!v56)
            {
              int v29 = __nwlog_obj();
              os_log_type_t v30 = type;
              if (!os_log_type_enabled(v29, type)) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = v32;
              int v31 = "%{public}s %{public}s node not found, backtrace limit exceeded";
              goto LABEL_86;
            }
            int v37 = (char *)__nw_create_backtrace_string();
            int v29 = __nwlog_obj();
            os_log_type_t v30 = type;
            BOOL v38 = os_log_type_enabled(v29, type);
            if (!v37)
            {
              if (!v38) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = v32;
              int v31 = "%{public}s %{public}s node not found, no backtrace";
              goto LABEL_86;
            }
            if (!v38) {
              goto LABEL_69;
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            __int16 v60 = 2082;
            os_log_type_t v61 = v32;
            __int16 v62 = 2082;
            v63[0] = v37;
            id v39 = "%{public}s %{public}s node not found, dumping backtrace:%{public}s";
LABEL_68:
            _os_log_impl(&dword_1830D4000, v29, v30, v39, buf, 0x20u);
LABEL_69:
            free(v37);
            if (v28) {
LABEL_88:
            }
              free(v28);
LABEL_89:
            if ((*((_WORD *)a1 + 102) & 0x100) != 0
              && g_channel_check_validity
              && !g_channel_check_validity(a1, *((void *)a1 + 11)))
            {
              goto LABEL_94;
            }
            buffer = (void *)*((void *)a1 + 14);
            if (!buffer) {
              goto LABEL_94;
            }
            goto LABEL_93;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v29 = gLogObj;
          os_log_type_t v30 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_87;
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          __int16 v60 = 2082;
          os_log_type_t v61 = v32;
          int v31 = "%{public}s %{public}s node not found";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v27 = (nw_frame *)(v11 + 205);
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          __int16 v60 = 2082;
          os_log_type_t v61 = (nw_frame *)(v11 + 205);
          int v28 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v56 = 0;
          if (!__nwlog_fault(v28, &type, &v56)) {
            goto LABEL_87;
          }
          if (type != OS_LOG_TYPE_FAULT)
          {
            if (!v56)
            {
              int v29 = __nwlog_obj();
              os_log_type_t v30 = type;
              if (!os_log_type_enabled(v29, type)) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = v27;
              int v31 = "%{public}s %{public}s input_protocol not found, backtrace limit exceeded";
              goto LABEL_86;
            }
            int v33 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v29 = gLogObj;
            os_log_type_t v30 = type;
            BOOL v34 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (!v33)
            {
              if (!v34) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = v27;
              int v31 = "%{public}s %{public}s input_protocol not found, no backtrace";
              goto LABEL_86;
            }
            if (v34)
            {
              *(_DWORD *)buf = 136446722;
              os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v60 = 2082;
              os_log_type_t v61 = v27;
              __int16 v62 = 2082;
              v63[0] = v33;
              _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s %{public}s input_protocol not found, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v33);
            goto LABEL_87;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v29 = gLogObj;
          os_log_type_t v30 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_87;
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          __int16 v60 = 2082;
          os_log_type_t v61 = v27;
          int v31 = "%{public}s %{public}s input_protocol not found";
        }
LABEL_86:
        _os_log_impl(&dword_1830D4000, v29, v30, v31, buf, 0x16u);
        goto LABEL_87;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
      unint64_t v3 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v56 = 0;
      if (__nwlog_fault(v3, &type, &v56))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            char v6 = "%{public}s called with null http2_transport";
            goto LABEL_34;
          }
          goto LABEL_36;
        }
        if (!v56)
        {
          uint64_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            char v6 = "%{public}s called with null http2_transport, backtrace limit exceeded";
            goto LABEL_34;
          }
          goto LABEL_36;
        }
        os_log_type_t v45 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v48 = os_log_type_enabled(v4, type);
        if (!v45)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            char v6 = "%{public}s called with null http2_transport, no backtrace";
            goto LABEL_34;
          }
          goto LABEL_36;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          __int16 v60 = 2082;
          os_log_type_t v61 = (nw_frame *)v45;
          os_log_type_t v47 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
          goto LABEL_125;
        }
        goto LABEL_126;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
      unint64_t v3 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v56 = 0;
      if (!__nwlog_fault(v3, &type, &v56)) {
        goto LABEL_36;
      }
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (!v56)
        {
          uint64_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            char v6 = "%{public}s called with null output_context, backtrace limit exceeded";
            goto LABEL_34;
          }
          goto LABEL_36;
        }
        os_log_type_t v45 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v46 = os_log_type_enabled(v4, type);
        if (!v45)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            char v6 = "%{public}s called with null output_context, no backtrace";
            goto LABEL_34;
          }
          goto LABEL_36;
        }
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          __int16 v60 = 2082;
          os_log_type_t v61 = (nw_frame *)v45;
          os_log_type_t v47 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
LABEL_125:
          _os_log_impl(&dword_1830D4000, v4, v5, v47, buf, 0x16u);
        }
LABEL_126:
        free(v45);
        if (v3) {
          goto LABEL_37;
        }
        return;
      }
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
        char v6 = "%{public}s called with null output_context";
        goto LABEL_34;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v56 = 0;
    if (__nwlog_fault(v3, &type, &v56))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          char v6 = "%{public}s called with null frame";
          goto LABEL_34;
        }
      }
      else if (v56)
      {
        id v42 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v43 = os_log_type_enabled(v4, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
            __int16 v60 = 2082;
            os_log_type_t v61 = (nw_frame *)v42;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v42);
        }
        else if (v43)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          char v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v59 = "nw_protocol_http2_transport_frame_output_finalizer";
          char v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_34;
        }
      }
    }
  }
LABEL_36:
  if (v3) {
LABEL_37:
  }
    free(v3);
}

BOOL nw_http2_transport_submit_data(uint64_t a1, uint64_t a2)
{
  v52[2] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v48 = "__nw_frame_get_metadata";
    int v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v32, &type, &v45)) {
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "__nw_frame_get_metadata";
      unsigned int v35 = "%{public}s called with null frame";
    }
    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      BOOL v37 = os_log_type_enabled(v33, type);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v48 = "__nw_frame_get_metadata";
          __int16 v49 = 2082;
          uint64_t v50 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_94;
      }
      if (!v37)
      {
LABEL_94:
        if (v32) {
          free(v32);
        }
        goto LABEL_3;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "__nw_frame_get_metadata";
      unsigned int v35 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      int v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "__nw_frame_get_metadata";
      unsigned int v35 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v33, v34, v35, buf, 0xCu);
    goto LABEL_94;
  }
  if ((*(_WORD *)(a2 + 204) & 4) == 0)
  {
LABEL_3:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v48 = "nw_http2_transport_submit_data";
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null output_context";
      goto LABEL_39;
    }
    if (!v45)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null output_context, backtrace limit exceeded";
      goto LABEL_39;
    }
    os_log_type_t v17 = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v18 = os_log_type_enabled(v4, type);
    if (!v17)
    {
      if (!v18) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null output_context, no backtrace";
      goto LABEL_39;
    }
    if (!v18)
    {
LABEL_23:
      free(v17);
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446466;
    BOOL v48 = "nw_http2_transport_submit_data";
    __int16 v49 = 2082;
    uint64_t v50 = (uint64_t)v17;
    uint64_t v19 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
LABEL_22:
    _os_log_impl(&dword_1830D4000, v4, v5, v19, buf, 0x16u);
    goto LABEL_23;
  }
  uint64_t v7 = *(void *)(a2 + 216);
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v48 = "nw_http2_transport_submit_data";
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null input_protocol";
    }
    else if (v45)
    {
      os_log_type_t v17 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v40 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v40) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v17;
        uint64_t v19 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_22;
      }
      if (!v40) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null input_protocol, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    }
    goto LABEL_39;
  }
  uint64_t v8 = *(void *)(v7 + 56);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v48 = "nw_http2_transport_submit_data";
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null node";
    }
    else if (v45)
    {
      os_log_type_t v17 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v41 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v41) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v17;
        uint64_t v19 = "%{public}s called with null node, dumping backtrace:%{public}s";
        goto LABEL_22;
      }
      if (!v41) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null node, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null node, backtrace limit exceeded";
    }
    goto LABEL_39;
  }
  uint64_t v9 = *(void *)(v8 + 32);
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v48 = "nw_http2_transport_submit_data";
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null stream";
    }
    else if (v45)
    {
      os_log_type_t v17 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v42 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v42) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v17;
        uint64_t v19 = "%{public}s called with null stream, dumping backtrace:%{public}s";
        goto LABEL_22;
      }
      if (!v42) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null stream, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v48 = "nw_http2_transport_submit_data";
      char v6 = "%{public}s called with null stream, backtrace limit exceeded";
    }
LABEL_39:
    uint64_t v27 = v4;
    os_log_type_t v28 = v5;
    uint32_t v29 = 12;
LABEL_45:
    _os_log_impl(&dword_1830D4000, v27, v28, v6, buf, v29);
    goto LABEL_46;
  }
  int v11 = *(_DWORD *)(v9 + 32);
  uint64_t v12 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (!v12)
  {
    BOOL v38 = __nwlog_obj();
    os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    BOOL v48 = "strict_calloc";
    __int16 v49 = 2048;
    uint64_t v50 = 1;
    __int16 v51 = 2048;
    v52[0] = 16;
    id v39 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v39);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v39);
  }
  void *v12 = a2;
  v12[1] = data_source_read_callback;
  int v13 = nghttp2_submit_data();
  free(v12);
  if (v13)
  {
    if (v13 == -529)
    {
      if (gLogDatapath)
      {
        BOOL v14 = __nwlog_obj();
        BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
        if (!result) {
          return result;
        }
        int v16 = *(_DWORD *)(a2 + 52);
        if (v16) {
          v16 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
        }
        *(_DWORD *)buf = 136446978;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = a1 + 205;
        __int16 v51 = 1024;
        LODWORD(v52[0]) = v11;
        WORD2(v52[0]) = 1024;
        *(_DWORD *)((char *)v52 + 6) = v16;
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s already have data outgoing on stream %d, cannot send %u bytes", buf, 0x22u);
      }
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = nghttp2_strerror();
    *(_DWORD *)buf = 136446466;
    BOOL v48 = "nw_http2_transport_submit_data";
    __int16 v49 = 2082;
    uint64_t v50 = v20;
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (__nwlog_fault(v3, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = gLogObj;
        os_log_type_t v22 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_46;
        }
        uint64_t v23 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = v23;
        char v6 = "%{public}s nghttp2_submit_data: %{public}s failed";
        goto LABEL_44;
      }
      if (!v45)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = gLogObj;
        os_log_type_t v22 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_46;
        }
        uint64_t v30 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = v30;
        char v6 = "%{public}s nghttp2_submit_data: %{public}s failed, backtrace limit exceeded";
        goto LABEL_44;
      }
      int v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v21 = gLogObj;
      os_log_type_t v22 = type;
      BOOL v25 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v24)
      {
        if (v25)
        {
          uint64_t v26 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          BOOL v48 = "nw_http2_transport_submit_data";
          __int16 v49 = 2082;
          uint64_t v50 = v26;
          __int16 v51 = 2082;
          v52[0] = v24;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s nghttp2_submit_data: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v24);
        goto LABEL_46;
      }
      if (v25)
      {
        uint64_t v31 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        BOOL v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = v31;
        char v6 = "%{public}s nghttp2_submit_data: %{public}s failed, no backtrace";
LABEL_44:
        uint64_t v27 = v21;
        os_log_type_t v28 = v22;
        uint32_t v29 = 22;
        goto LABEL_45;
      }
    }
LABEL_46:
    if (v3) {
      free(v3);
    }
    return 0;
  }
  if (gLogDatapath)
  {
    BOOL v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      int v44 = *(_DWORD *)(a2 + 52);
      if (v44) {
        v44 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
      }
      *(_DWORD *)buf = 136446978;
      BOOL v48 = "nw_http2_transport_submit_data";
      __int16 v49 = 2082;
      uint64_t v50 = a1 + 205;
      __int16 v51 = 1024;
      LODWORD(v52[0]) = v44;
      WORD2(v52[0]) = 1024;
      *(_DWORD *)((char *)v52 + 6) = v11;
      _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s submitted %u bytes on stream %d", buf, 0x22u);
    }
  }
  return 1;
}

void __cxx_global_var_init_5()
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  {
    return;
  }
  {
    {
      nw::object::_class(void)::instance = (uint64_t)"object";
      *(void *)algn_1EB267848 = 6;
      xmmword_1EB267850 = 0u;
      unk_1EB267860 = 0u;
      xmmword_1EB267870 = 0u;
      *(_OWORD *)&qword_1EB267880 = 0u;
      *(long long *)((char *)&xmmword_1EB267888 + 8) = 0u;
      *(_OWORD *)&qword_1EB2678A0 = 0u;
      xmmword_1EB2678B0 = 0u;
      unk_1EB2678C0 = 0u;
      qword_1EB2678D0 = (uint64_t)&qword_1EB2678D0;
      unk_1EB2678D8 = &qword_1EB2678D0;
      qword_1EB2678E0 = 0;
      dword_1EB2678E8 = 0;
    }
    nw_string::_class(void)::instance = (uint64_t)"OS_nw_string";
    unk_1EB267790 = 12;
    xmmword_1EB267798 = 0u;
    unk_1EB2677A8 = 0u;
    xmmword_1EB2677B8 = 0u;
    xmmword_1EB2677D8 = 0u;
    *(_OWORD *)&qword_1EB2677E8 = 0u;
    qword_1EB2677F8 = (uint64_t)&nw::object::_class(void)::instance;
    unk_1EB267800 = 4096;
    qword_1EB267808 = 0;
    qword_1EB267810 = 0;
    qword_1EB267818 = (uint64_t)&qword_1EB267818;
    qword_1EB267820 = (uint64_t)&qword_1EB267818;
    qword_1EB267828 = 0;
    dword_1EB267830 = 0;
    unk_1EB2677C8 = 0u;
    nw::object::class_def::setup(&nw::object::_class(void)::instance, (int64x2_t *)&unk_1EB2677C8);
  }
  if (!(_BYTE)qword_1EB267920)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v12 = "register_override_method_def";
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v1, &type, &v9)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "register_override_method_def";
      uint64_t v4 = "%{public}s called with null (def.slot())";
      goto LABEL_38;
    }
    if (!v9)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "register_override_method_def";
      uint64_t v4 = "%{public}s called with null (def.slot()), backtrace limit exceeded";
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v2 = __nwlog_obj();
    os_log_type_t v3 = type;
    BOOL v6 = os_log_type_enabled(v2, type);
    if (!backtrace_string)
    {
      if (!v6) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "register_override_method_def";
      uint64_t v4 = "%{public}s called with null (def.slot()), no backtrace";
      goto LABEL_38;
    }
    if (v6)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v12 = "register_override_method_def";
      __int16 v13 = 2082;
      BOOL v14 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v2, v3, "%{public}s called with null (def.slot()), dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_39:
    if (!v1) {
      goto LABEL_7;
    }
LABEL_40:
    free(v1);
    goto LABEL_7;
  }
  if (nw::object::__destroy_def_instance >= (unint64_t)qword_1EB2677F0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v12 = "register_override_method_def";
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v1, &type, &v9)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "register_override_method_def";
      uint64_t v4 = "%{public}s called with null (def.slot().value() < m_method_table.size())";
      goto LABEL_38;
    }
    if (!v9)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "register_override_method_def";
      uint64_t v4 = "%{public}s called with null (def.slot().value() < m_method_table.size()), backtrace limit exceeded";
      goto LABEL_38;
    }
    uint64_t v7 = (char *)__nw_create_backtrace_string();
    uint64_t v2 = __nwlog_obj();
    os_log_type_t v3 = type;
    BOOL v8 = os_log_type_enabled(v2, type);
    if (v7)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v12 = "register_override_method_def";
        __int16 v13 = 2082;
        BOOL v14 = v7;
        _os_log_impl(&dword_1830D4000, v2, v3, "%{public}s called with null (def.slot().value() < m_method_table.size()), dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v7);
      if (!v1) {
        goto LABEL_7;
      }
      goto LABEL_40;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "register_override_method_def";
      uint64_t v4 = "%{public}s called with null (def.slot().value() < m_method_table.size()), no backtrace";
LABEL_38:
      _os_log_impl(&dword_1830D4000, v2, v3, v4, buf, 0xCu);
      goto LABEL_39;
    }
    goto LABEL_39;
  }
  uint64_t v0 = (void (**)(nw_string *))(*(void *)(qword_1EB2677D0
                                                     + (((unint64_t)(qword_1EB2677E8
                                                                          + nw::object::__destroy_def_instance) >> 5) & 0x7FFFFFFFFFFFFF8))
                                         + 16
                                         * (qword_1EB2677E8 + nw::object::__destroy_def_instance));
  *uint64_t v0 = nw_string::_destroy;
  v0[1] = 0;
LABEL_7:
}

void nw::object::class_def::setup(void *a1, int64x2_t *a2)
{
  uint64_t v4 = a1[14];
  if (v4) {
    nw::object::class_def::setup(v4, a2);
  }
  unint64_t v5 = a2[2].u64[0];
  uint64_t v6 = a2[2].i64[1];
  unint64_t v7 = v5 + v6;
  unint64_t v8 = (v5 + v6) >> 8;
  char v9 = (unint64_t *)a2->i64[1];
  os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
  int v11 = (char *)&v9[v8];
  if (v10 == v9) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *(void *)v11 + 16 * v7;
  }
  unint64_t v13 = a1[12];
  uint64_t v14 = a1[9];
  uint64_t v15 = v14 + 8 * (v13 >> 8);
  if (a1[10] == v14)
  {
    int v16 = 0;
    unint64_t v18 = 0;
    v419 = (uint64_t *)(v14 + 8 * ((a1[13] + v13) >> 8));
  }
  else
  {
    int v16 = (char *)(*(void *)v15 + 16 * v13);
    unint64_t v17 = a1[13] + v13;
    v419 = (uint64_t *)(v14 + 8 * (v17 >> 8));
    unint64_t v18 = *v419 + 16 * v17;
    if ((char *)v18 != v16)
    {
      unint64_t j = ((16 * v17) >> 4) + 32 * ((void)v419 - v15) - ((uint64_t)&v16[-*(void *)v15] >> 4);
      goto LABEL_11;
    }
  }
  unint64_t j = 0;
LABEL_11:
  unint64_t v20 = v5 >> 8;
  uint64_t v21 = (char *)&v9[v5 >> 8];
  int64_t v22 = (char *)v10 - (char *)v9;
  if (v10 == v9)
  {
    uint64_t v23 = 0;
    if (v12) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v23 = *(void *)v21 + 16 * v5;
    if (v12 != v23)
    {
LABEL_13:
      unint64_t v24 = ((v12 - *(void *)v11) >> 4) + 32 * (v11 - v21) - ((v23 - *(void *)v21) >> 4);
      goto LABEL_16;
    }
  }
  unint64_t v24 = 0;
LABEL_16:
  if (v24 >= v6 - v24)
  {
    uint64_t v34 = 32 * v22 - 1;
    uint64_t v35 = (char *)v10 - (char *)v9;
    if (v10 == v9) {
      uint64_t v34 = 0;
    }
    unint64_t v36 = v34 - v7;
    BOOL v37 = j >= v36;
    unint64_t v38 = j - v36;
    if (v38 == 0 || !v37) {
      goto LABEL_420;
    }
    uint64_t v408 = v15;
    if (v10 == v9) {
      unint64_t v39 = v38 + 1;
    }
    else {
      unint64_t v39 = v38;
    }
    if ((_BYTE)v39) {
      unint64_t v40 = (v39 >> 8) + 1;
    }
    else {
      unint64_t v40 = v39 >> 8;
    }
    if (v40 >= v20) {
      uint64_t v15 = v5 >> 8;
    }
    else {
      uint64_t v15 = v40;
    }
    unint64_t v411 = j;
    unint64_t v412 = v24;
    if (v40 > v20)
    {
      unint64_t j = v40 - v15;
      uint64_t v41 = a2[1].i64[1] - a2->i64[0];
      uint64_t v42 = v35 >> 3;
      if (v40 - v15 > (v41 >> 3) - (v35 >> 3))
      {
        unint64_t v43 = v41 >> 2;
        if (v43 <= j + v42) {
          size_t v44 = j + v42;
        }
        else {
          size_t v44 = v43;
        }
        unint64_t v409 = v18;
        if (v44)
        {
          char v45 = (unint64_t *)malloc_type_calloc(v44, 8uLL, 0x80040B8603338uLL);
          if (!v45)
          {
LABEL_54:
            __break(1u);
            goto LABEL_55;
          }
        }
        else
        {
          char v45 = 0;
        }
        uint64_t v406 = v15 << 8;
        os_log_type_t v236 = (char *)&v45[v42 - v15];
        os_log_type_t v237 = (char *)&v45[v44];
        os_log_type_t v10 = (unint64_t *)v236;
        while (1)
        {
          os_log_type_t v239 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v239) {
            goto LABEL_54;
          }
          unint64_t v18 = (unint64_t)v239;
          if (v10 != (unint64_t *)v237) {
            goto LABEL_329;
          }
          __srcc = v45;
          if (v236 > (char *)v45)
          {
            uint64_t v240 = (v236 - (char *)v45) >> 3;
            if (v240 >= -1) {
              uint64_t v241 = v240 + 1;
            }
            else {
              uint64_t v241 = v240 + 2;
            }
            uint64_t v242 = v241 >> 1;
            BOOL v243 = &v236[-8 * (v241 >> 1)];
            v244 = v237;
            if (v237 != v236)
            {
              memmove(v243, v236, v237 - v236);
              v244 = v236;
            }
            uint64_t v238 = -v242;
            os_log_type_t v10 = (unint64_t *)&v243[v237 - v236];
            os_log_type_t v236 = &v244[8 * v238];
            char v45 = __srcc;
            goto LABEL_329;
          }
          if (v237 == (char *)v45) {
            size_t v245 = 1;
          }
          else {
            size_t v245 = (v237 - (char *)v45) >> 2;
          }
          v246 = (char *)malloc_type_calloc(v245, 8uLL, 0x80040B8603338uLL);
          if (!v246) {
            goto LABEL_54;
          }
          char v45 = (unint64_t *)v246;
          size_t v247 = v245 >> 2;
          os_log_type_t v248 = (unint64_t *)&v246[8 * (v245 >> 2)];
          os_log_type_t v10 = v248;
          int64_t v249 = v237 - v236;
          if (v237 != v236)
          {
            os_log_type_t v10 = (unint64_t *)((char *)v248 + (v249 & 0xFFFFFFFFFFFFFFF8));
            unint64_t v250 = v249 - 8;
            if (v250 >= 0x38)
            {
              uint64_t v252 = 8 * v247;
              if ((unint64_t)(&v246[8 * v247] - v236) >= 0x20)
              {
                uint64_t v253 = (v250 >> 3) + 1;
                uint64_t v254 = v253 & 0x3FFFFFFFFFFFFFFCLL;
                int v251 = &v248[v254];
                os_log_type_t v255 = (long long *)(v236 + 16);
                os_log_type_t v256 = &v246[v252 + 16];
                uint64_t v257 = v253 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v258 = *v255;
                  *((_OWORD *)v256 - 1) = *(v255 - 1);
                  *(_OWORD *)os_log_type_t v256 = v258;
                  v255 += 2;
                  v256 += 32;
                  v257 -= 4;
                }
                while (v257);
                if (v253 == (v253 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_352;
                }
                v236 += v254 * 8;
              }
              else
              {
                int v251 = (unint64_t *)&v246[8 * (v245 >> 2)];
              }
            }
            else
            {
              int v251 = (unint64_t *)&v246[8 * (v245 >> 2)];
            }
            do
            {
              unint64_t v259 = *(void *)v236;
              v236 += 8;
              *v251++ = v259;
            }
            while (v251 != v10);
          }
LABEL_352:
          os_log_type_t v237 = &v246[8 * v245];
          if (__srcc)
          {
            os_log_type_t v236 = &v246[8 * (v245 >> 2)];
            free(__srcc);
          }
          else
          {
            os_log_type_t v236 = (char *)v248;
          }
LABEL_329:
          *v10++ = v18;
          if (!--j)
          {
            unint64_t j = a2->u64[1];
            if (!v15)
            {
              unint64_t v18 = (unint64_t)v236;
LABEL_357:
              uint64_t v260 = a2[1].i64[0];
              if (v260 == j)
              {
LABEL_358:
                BOOL v261 = (void *)a2->i64[0];
                a2->i64[0] = (uint64_t)v45;
                a2->i64[1] = v18;
                a2[1].i64[0] = (uint64_t)v10;
                a2[1].i64[1] = (uint64_t)v237;
                a2[2].i64[0] -= v406;
                unint64_t v18 = v409;
                if (v261)
                {
                  free(v261);
                  os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
                }
LABEL_419:
                uint64_t v6 = a2[2].i64[1];
                char v9 = (unint64_t *)a2->i64[1];
                unint64_t v7 = a2[2].i64[0] + v6;
                unint64_t v8 = v7 >> 8;
                uint64_t v15 = v408;
                unint64_t j = v411;
                unint64_t v24 = v412;
LABEL_420:
                v307 = &v9[v8];
                if (v10 == v9) {
                  v308 = 0;
                }
                else {
                  v308 = (char *)(*v307 + 16 * v7);
                }
                unint64_t v338 = v6 - v24;
                if (v6 - v24 >= j)
                {
                  v341 = v308;
                  v342 = &v9[v8];
                  if (!j) {
                    return;
                  }
                }
                else
                {
                  if (v338 >= j >> 1)
                  {
                    uint64_t v339 = v6 - v24 - j + ((uint64_t)(v18 - *v419) >> 4);
                    if (v339 < 1)
                    {
                      unint64_t v348 = 255 - v339;
                      unsigned __int8 v349 = ~(_BYTE)v348;
                      v419 -= v348 >> 8;
                      uint64_t v350 = *v419;
                      goto LABEL_467;
                    }
                    v419 += (unint64_t)v339 >> 8;
                    uint64_t v340 = *v419;
LABEL_456:
                    os_log_type_t v343 = (char *)(v340 + 16 * v339);
                    if (v343 != (char *)v18) {
                      goto LABEL_457;
                    }
LABEL_468:
                    v341 = v308;
                    v342 = v307;
                  }
                  else
                  {
                    if (v338)
                    {
                      uint64_t v339 = v338 + ((uint64_t)&v16[-*(void *)v15] >> 4);
                      if (v339 >= 1)
                      {
                        v419 = (uint64_t *)(v15 + 8 * ((unint64_t)v339 >> 8));
                        uint64_t v340 = *v419;
                        goto LABEL_456;
                      }
                      unint64_t v351 = 255 - v339;
                      unsigned __int8 v349 = ~(_BYTE)v351;
                      v419 = (uint64_t *)(v15 - 8 * (v351 >> 8));
                      uint64_t v350 = *v419;
LABEL_467:
                      os_log_type_t v343 = (char *)(v350 + 16 * v349);
                      if (v343 == (char *)v18) {
                        goto LABEL_468;
                      }
                    }
                    else
                    {
                      v419 = (uint64_t *)v15;
                      os_log_type_t v343 = v16;
                      if (v16 == (char *)v18) {
                        goto LABEL_468;
                      }
                    }
LABEL_457:
                    v344 = v419;
                    v345 = v343;
                    v342 = v307;
                    v341 = v308;
                    do
                    {
                      *v341++ = *(_OWORD *)v345;
                      if ((_OWORD *)((char *)v341 - *v342) == (_OWORD *)4096)
                      {
                        v346 = (_OWORD *)v342[1];
                        ++v342;
                        v341 = v346;
                      }
                      v345 += 16;
                      if (&v345[-*v344] == (char *)4096)
                      {
                        v347 = (char *)v344[1];
                        ++v344;
                        v345 = v347;
                      }
                      ++a2[2].i64[1];
                    }
                    while (v345 != (char *)v18);
                  }
                  unint64_t j = v338;
                  unint64_t v18 = (unint64_t)v343;
                  if (!v338) {
                    return;
                  }
                }
                uint64_t v352 = ((uint64_t)&v308[-*v307] >> 4) - j;
                if (v352 < 1)
                {
                  unint64_t v355 = 255 - v352;
                  v353 = &v307[-(v355 >> 8)];
                  BOOL v354 = (char *)(*v353 + 16 * ~(_BYTE)v355);
                  if (v354 == v308) {
                    goto LABEL_480;
                  }
                }
                else
                {
                  v353 = &v307[(unint64_t)v352 >> 8];
                  BOOL v354 = (char *)(*v353 + 16 * v352);
                  if (v354 == v308) {
                    goto LABEL_480;
                  }
                }
                int v356 = v353;
                v357 = v354;
                do
                {
                  *v341++ = *(_OWORD *)v357;
                  if ((_OWORD *)((char *)v341 - *v342) == (_OWORD *)4096)
                  {
                    v358 = (_OWORD *)v342[1];
                    ++v342;
                    v341 = v358;
                  }
                  v357 += 16;
                  if (&v357[-*v356] == (char *)4096)
                  {
                    v359 = (char *)v356[1];
                    ++v356;
                    v357 = v359;
                  }
                  ++a2[2].i64[1];
                }
                while (v357 != v308);
LABEL_480:
                if (j >= v338) {
                  goto LABEL_523;
                }
                v360 = (char *)*v307;
                uint64_t v361 = ((uint64_t)&v308[-*v307] >> 4) - v338;
                if (v361 < 1)
                {
                  unint64_t v378 = 255 - v361;
                  v362 = &v307[-(v378 >> 8)];
                  uint64_t v363 = *v362 + 16 * ~(_BYTE)v378;
                  if (v362 == v353) {
                    goto LABEL_513;
                  }
LABEL_483:
                  os_log_type_t v364 = (unsigned char *)*v353;
                  if ((char *)*v353 != v354)
                  {
                    while (1)
                    {
                      uint64_t v365 = (v308 - v360) >> 4;
                      if ((v354 - v364) >> 4 < v365) {
                        uint64_t v365 = (v354 - v364) >> 4;
                      }
                      v354 -= 16 * v365;
                      v308 -= 16 * v365;
                      if (v365) {
                        memmove(v308, v354, 16 * v365);
                      }
                      if (v354 == v364) {
                        break;
                      }
                      v366 = (char *)*--v307;
                      v360 = v366;
                      v308 = v366 + 4096;
                    }
                    v360 = (char *)*v307;
                    if ((char *)(*v307 + 4096) == v308)
                    {
                      BOOL v367 = (char *)v307[1];
                      ++v307;
                      v360 = v367;
                      v308 = v367;
                    }
                  }
                  for (unint64_t i = v353 - 1; i != v362; --i)
                  {
                    v369 = (unsigned char *)*i;
                    v370 = (char *)(*i + 4096);
                    while (1)
                    {
                      uint64_t v371 = (v308 - v360) >> 4;
                      if ((v370 - v369) >> 4 < v371) {
                        uint64_t v371 = (v370 - v369) >> 4;
                      }
                      v370 -= 16 * v371;
                      v308 -= 16 * v371;
                      if (v371) {
                        memmove(v308, v370, 16 * v371);
                      }
                      if (v370 == v369) {
                        break;
                      }
                      int v372 = (char *)*--v307;
                      v360 = v372;
                      v308 = v372 + 4096;
                    }
                    v360 = (char *)*v307;
                    if ((char *)(*v307 + 4096) == v308)
                    {
                      v373 = (char *)v307[1];
                      ++v307;
                      v360 = v373;
                      v308 = v373;
                    }
                  }
                  v374 = (char *)(*v362 + 4096);
                  if (v374 == (char *)v363)
                  {
LABEL_523:
                    if ((uint64_t *)v15 == v419)
                    {
                      if (v16 != (char *)v18)
                      {
                        v402 = (char *)*v307;
                        v401 = (uint64_t *)(v307 - 1);
                        uint64_t v400 = (uint64_t)v402;
                        while (1)
                        {
                          uint64_t v403 = (uint64_t)&v308[-v400] >> 4;
                          if ((uint64_t)(v18 - (void)v16) >> 4 < v403) {
                            uint64_t v403 = (uint64_t)(v18 - (void)v16) >> 4;
                          }
                          v18 -= 16 * v403;
                          if (v403) {
                            memmove(&v308[-16 * v403], (const void *)v18, 16 * v403);
                          }
                          if ((char *)v18 == v16) {
                            break;
                          }
                          uint64_t v404 = *v401--;
                          uint64_t v400 = v404;
                          v308 = (char *)(v404 + 4096);
                        }
                      }
                    }
                    else
                    {
                      uint64_t v382 = *v419;
                      if (*v419 != v18)
                      {
                        unint64_t v383 = *v307;
                        while (1)
                        {
                          uint64_t v384 = (uint64_t)&v308[-v383] >> 4;
                          if ((uint64_t)(v18 - v382) >> 4 < v384) {
                            uint64_t v384 = (uint64_t)(v18 - v382) >> 4;
                          }
                          v18 -= 16 * v384;
                          v308 -= 16 * v384;
                          if (v384) {
                            memmove(v308, (const void *)v18, 16 * v384);
                          }
                          if (v18 == v382) {
                            break;
                          }
                          unint64_t v385 = *--v307;
                          unint64_t v383 = v385;
                          v308 = (char *)(v385 + 4096);
                        }
                        if ((char *)(*v307 + 4096) == v308)
                        {
                          v386 = (char *)v307[1];
                          ++v307;
                          v308 = v386;
                        }
                      }
                      v387 = v419 - 1;
                      if (v419 - 1 != (uint64_t *)v15)
                      {
                        v388 = (char *)*v307;
                        do
                        {
                          v389 = (unsigned char *)*v387;
                          v390 = (char *)(*v387 + 4096);
                          while (1)
                          {
                            uint64_t v391 = (v308 - v388) >> 4;
                            if ((v390 - v389) >> 4 < v391) {
                              uint64_t v391 = (v390 - v389) >> 4;
                            }
                            v390 -= 16 * v391;
                            v308 -= 16 * v391;
                            if (v391) {
                              memmove(v308, v390, 16 * v391);
                            }
                            if (v390 == v389) {
                              break;
                            }
                            v392 = (char *)*--v307;
                            v388 = v392;
                            v308 = v392 + 4096;
                          }
                          v388 = (char *)*v307;
                          if ((char *)(*v307 + 4096) == v308)
                          {
                            v393 = (char *)v307[1];
                            ++v307;
                            v388 = v393;
                            v308 = v393;
                          }
                          --v387;
                        }
                        while (v387 != (uint64_t *)v15);
                      }
                      BOOL v394 = (unsigned char *)(*(void *)v15 + 4096);
                      if (v394 != v16)
                      {
                        v397 = (char *)*v307;
                        v396 = (uint64_t *)(v307 - 1);
                        uint64_t v395 = (uint64_t)v397;
                        while (1)
                        {
                          uint64_t v398 = (uint64_t)&v308[-v395] >> 4;
                          if ((v394 - v16) >> 4 < v398) {
                            uint64_t v398 = (v394 - v16) >> 4;
                          }
                          v394 -= 16 * v398;
                          if (v398) {
                            memmove(&v308[-16 * v398], v394, 16 * v398);
                          }
                          if (v394 == v16) {
                            break;
                          }
                          uint64_t v399 = *v396--;
                          uint64_t v395 = v399;
                          v308 = (char *)(v399 + 4096);
                        }
                      }
                    }
                    return;
                  }
                  unint64_t v375 = *v307;
                  while (1)
                  {
                    uint64_t v376 = (uint64_t)&v308[-v375] >> 4;
                    if ((uint64_t)&v374[-v363] >> 4 < v376) {
                      uint64_t v376 = (uint64_t)&v374[-v363] >> 4;
                    }
                    v374 -= 16 * v376;
                    v308 -= 16 * v376;
                    if (v376) {
                      memmove(v308, v374, 16 * v376);
                    }
                    if (v374 == (char *)v363) {
                      break;
                    }
                    unint64_t v377 = *--v307;
                    unint64_t v375 = v377;
                    v308 = (char *)(v377 + 4096);
                  }
                }
                else
                {
                  v362 = &v307[(unint64_t)v361 >> 8];
                  uint64_t v363 = *v362 + 16 * v361;
                  if (v362 != v353) {
                    goto LABEL_483;
                  }
LABEL_513:
                  if ((char *)v363 == v354) {
                    goto LABEL_523;
                  }
                  while (1)
                  {
                    uint64_t v380 = (v308 - v360) >> 4;
                    if ((uint64_t)&v354[-v363] >> 4 < v380) {
                      uint64_t v380 = (uint64_t)&v354[-v363] >> 4;
                    }
                    v354 -= 16 * v380;
                    v308 -= 16 * v380;
                    if (v380) {
                      memmove(v308, v354, 16 * v380);
                    }
                    if (v354 == (char *)v363) {
                      break;
                    }
                    v379 = (char *)*--v307;
                    v360 = v379;
                    v308 = v379 + 4096;
                  }
                }
                if ((char *)(*v307 + 4096) == v308)
                {
                  v381 = (char *)v307[1];
                  ++v307;
                  v308 = v381;
                }
                goto LABEL_523;
              }
              while (2)
              {
                if ((unint64_t *)v18 != v45)
                {
LABEL_387:
                  uint64_t v281 = *(void *)(v260 - 8);
                  v260 -= 8;
                  *(void *)(v18 - 8) = v281;
                  v18 -= 8;
                  if (v260 == a2->i64[1]) {
                    goto LABEL_358;
                  }
                  continue;
                }
                break;
              }
              if (v10 < (unint64_t *)v237)
              {
                uint64_t v282 = (v237 - (char *)v10) >> 3;
                if (v282 >= -1) {
                  uint64_t v283 = v282 + 1;
                }
                else {
                  uint64_t v283 = v282 + 2;
                }
                uint64_t v284 = v283 >> 1;
                unint64_t v18 = (unint64_t)&v45[v283 >> 1];
                unsigned int v285 = v45;
                if (v10 != v45)
                {
                  memmove((void *)v18, v45, (char *)v10 - (char *)v45);
                  unsigned int v285 = v10;
                }
                os_log_type_t v10 = &v285[v284];
                goto LABEL_387;
              }
              unint64_t j = (unint64_t)v45;
              if (v237 == (char *)v45) {
                size_t v286 = 1;
              }
              else {
                size_t v286 = (v237 - (char *)v45) >> 2;
              }
              uint64_t v287 = (char *)malloc_type_calloc(v286, 8uLL, 0x80040B8603338uLL);
              if (!v287) {
                goto LABEL_54;
              }
              os_log_type_t v288 = (unint64_t *)v287;
              unint64_t v289 = (v286 + 3) >> 2;
              unint64_t v18 = (unint64_t)&v287[8 * v289];
              os_log_type_t v237 = &v287[8 * v286];
              unint64_t v291 = (unint64_t)v10 - j;
              BOOL v290 = v10 == (unint64_t *)j;
              os_log_type_t v10 = (unint64_t *)v18;
              if (!v290)
              {
                os_log_type_t v10 = (unint64_t *)(v18 + (v291 & 0xFFFFFFFFFFFFFFF8));
                unint64_t v292 = v291 - 8;
                v293 = (unint64_t *)&v287[8 * v289];
                char v294 = (unint64_t *)j;
                if (v292 >= 0x38)
                {
                  uint64_t v295 = 8 * v289;
                  v293 = (unint64_t *)&v287[8 * v289];
                  char v294 = (unint64_t *)j;
                  if ((unint64_t)v293 - j >= 0x20)
                  {
                    uint64_t v296 = (v292 >> 3) + 1;
                    uint64_t v297 = 8 * (v296 & 0x3FFFFFFFFFFFFFFCLL);
                    v293 = (unint64_t *)(v18 + v297);
                    int v298 = (long long *)(j + 16);
                    char v299 = &v287[v295 + 16];
                    uint64_t v300 = v296 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v301 = *v298;
                      *((_OWORD *)v299 - 1) = *(v298 - 1);
                      *(_OWORD *)char v299 = v301;
                      v298 += 2;
                      v299 += 32;
                      v300 -= 4;
                    }
                    while (v300);
                    if (v296 != (v296 & 0x3FFFFFFFFFFFFFFCLL))
                    {
                      char v294 = (unint64_t *)(j + v297);
                      goto LABEL_406;
                    }
LABEL_408:
                    free((void *)j);
LABEL_409:
                    char v45 = v288;
                    goto LABEL_387;
                  }
                }
                do
                {
LABEL_406:
                  unint64_t v302 = *v294++;
                  *v293++ = v302;
                }
                while (v293 != v10);
              }
              if (j) {
                goto LABEL_408;
              }
              goto LABEL_409;
            }
            while (2)
            {
              if (v10 != (unint64_t *)v237)
              {
                unint64_t v18 = (unint64_t)v236;
                goto LABEL_361;
              }
              __srcd = v45;
              if (v236 > (char *)v45)
              {
                uint64_t v262 = (v236 - (char *)v45) >> 3;
                if (v262 >= -1) {
                  uint64_t v263 = v262 + 1;
                }
                else {
                  uint64_t v263 = v262 + 2;
                }
                uint64_t v264 = v263 >> 1;
                os_log_type_t v265 = &v236[-8 * (v263 >> 1)];
                BOOL v266 = v237;
                if (v237 != v236)
                {
                  memmove(v265, v236, v237 - v236);
                  BOOL v266 = v236;
                }
                os_log_type_t v10 = (unint64_t *)&v265[v237 - v236];
                unint64_t v18 = (unint64_t)&v266[-8 * v264];
                goto LABEL_361;
              }
              if (v237 == (char *)v45) {
                size_t v267 = 1;
              }
              else {
                size_t v267 = (v237 - (char *)v45) >> 2;
              }
              BOOL v268 = (char *)malloc_type_calloc(v267, 8uLL, 0x80040B8603338uLL);
              if (!v268) {
                goto LABEL_54;
              }
              char v45 = (unint64_t *)v268;
              size_t v269 = v267 >> 2;
              unint64_t v18 = (unint64_t)&v268[8 * (v267 >> 2)];
              os_log_type_t v10 = (unint64_t *)v18;
              int64_t v270 = v237 - v236;
              if (v237 != v236)
              {
                os_log_type_t v10 = (unint64_t *)(v18 + (v270 & 0xFFFFFFFFFFFFFFF8));
                unint64_t v271 = v270 - 8;
                if (v271 >= 0x38)
                {
                  uint64_t v273 = 8 * v269;
                  if ((unint64_t)(&v268[8 * v269] - v236) < 0x20)
                  {
                    os_log_type_t v272 = (unint64_t *)&v268[8 * (v267 >> 2)];
                    goto LABEL_383;
                  }
                  uint64_t v274 = (v271 >> 3) + 1;
                  uint64_t v275 = 8 * (v274 & 0x3FFFFFFFFFFFFFFCLL);
                  os_log_type_t v272 = (unint64_t *)(v18 + v275);
                  os_log_type_t v276 = (long long *)(v236 + 16);
                  int v277 = &v268[v273 + 16];
                  uint64_t v278 = v274 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v279 = *v276;
                    *((_OWORD *)v277 - 1) = *(v276 - 1);
                    *(_OWORD *)int v277 = v279;
                    v276 += 2;
                    v277 += 32;
                    v278 -= 4;
                  }
                  while (v278);
                  if (v274 != (v274 & 0x3FFFFFFFFFFFFFFCLL))
                  {
                    v236 += v275;
                    goto LABEL_383;
                  }
                }
                else
                {
                  os_log_type_t v272 = (unint64_t *)&v268[8 * (v267 >> 2)];
                  do
                  {
LABEL_383:
                    unint64_t v280 = *(void *)v236;
                    v236 += 8;
                    *v272++ = v280;
                  }
                  while (v272 != v10);
                }
              }
              os_log_type_t v237 = &v268[8 * v267];
              if (__srcd) {
                free(__srcd);
              }
LABEL_361:
              *v10++ = *(void *)j;
              unint64_t j = a2->i64[1] + 8;
              a2->i64[1] = j;
              os_log_type_t v236 = (char *)v18;
              if (!--v15) {
                goto LABEL_357;
              }
              continue;
            }
          }
        }
      }
      if (j)
      {
        while (a2[1].i64[1] != a2[1].i64[0])
        {
          unint64_t v82 = v24;
          os_log_type_t v83 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v83) {
            goto LABEL_54;
          }
          os_log_type_t v420 = v83;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back(a2, &v420);
          --j;
          unint64_t v24 = v82;
          if (!j)
          {
            os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
            goto LABEL_417;
          }
        }
        uint64_t v303 = 0;
        v15 += j;
        while (1)
        {
          v304 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v304) {
            goto LABEL_54;
          }
          os_log_type_t v420 = v304;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
          os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
          if ((unint64_t *)((char *)v10 - a2->i64[1]) == (unint64_t *)8) {
            uint64_t v305 = 255;
          }
          else {
            uint64_t v305 = 256;
          }
          uint64_t v306 = v305 + a2[2].i64[0];
          a2[2].i64[0] = v306;
          if (j == ++v303) {
            goto LABEL_418;
          }
        }
      }
LABEL_417:
      uint64_t v306 = a2[2].i64[0];
LABEL_418:
      a2[2].i64[0] = v306 - (v15 << 8);
      if (!v15) {
        goto LABEL_419;
      }
      while (1)
      {
        __int16 v310 = (unint64_t *)a2->i64[1];
        unint64_t v312 = *v310;
        v311 = v310 + 1;
        unint64_t j = v312;
        a2->i64[1] = (uint64_t)v311;
        if (v10 == (unint64_t *)a2[1].i64[1])
        {
          uint64_t v313 = (uint64_t)v311 - a2->i64[0];
          if ((unint64_t)v311 <= a2->i64[0])
          {
            if (v10 == (unint64_t *)a2->i64[0]) {
              size_t v320 = 1;
            }
            else {
              size_t v320 = ((uint64_t)v10 - a2->i64[0]) >> 2;
            }
            v321 = malloc_type_calloc(v320, 8uLL, 0x80040B8603338uLL);
            if (!v321) {
              goto LABEL_54;
            }
            size_t v322 = v320 >> 2;
            BOOL v323 = (unint64_t *)&v321[8 * (v320 >> 2)];
            v324 = (unint64_t *)a2->i64[1];
            os_log_type_t v10 = v323;
            uint64_t v325 = a2[1].i64[0] - (void)v324;
            if (v325)
            {
              os_log_type_t v10 = (unint64_t *)((char *)v323 + (v325 & 0xFFFFFFFFFFFFFFF8));
              unint64_t v326 = v325 - 8;
              if (v326 >= 0x38)
              {
                uint64_t v328 = 8 * v322;
                unint64_t v329 = &v321[8 * v322] - (unsigned char *)v324;
                BOOL v327 = (unint64_t *)&v321[8 * (v320 >> 2)];
                if (v329 < 0x20) {
                  goto LABEL_443;
                }
                uint64_t v330 = (v326 >> 3) + 1;
                uint64_t v331 = v330 & 0x3FFFFFFFFFFFFFFCLL;
                BOOL v327 = &v323[v331];
                v332 = (long long *)(v324 + 2);
                v333 = &v321[v328 + 16];
                uint64_t v334 = v330 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v335 = *v332;
                  *(v333 - 1) = *(v332 - 1);
                  _OWORD *v333 = v335;
                  v332 += 2;
                  v333 += 2;
                  v334 -= 4;
                }
                while (v334);
                if (v330 != (v330 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  v324 = (unint64_t *)((char *)v324 + v331 * 8);
                  goto LABEL_443;
                }
              }
              else
              {
                BOOL v327 = (unint64_t *)&v321[8 * (v320 >> 2)];
                do
                {
LABEL_443:
                  unint64_t v336 = *v324++;
                  *v327++ = v336;
                }
                while (v327 != v10);
              }
            }
            v337 = (void *)a2->i64[0];
            a2->i64[0] = (uint64_t)v321;
            a2->i64[1] = (uint64_t)v323;
            a2[1].i64[0] = (uint64_t)v10;
            a2[1].i64[1] = (uint64_t)&v321[8 * v320];
            if (v337)
            {
              free(v337);
              os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
            }
            goto LABEL_423;
          }
          uint64_t v314 = v313 >> 3;
          BOOL v53 = v313 >> 3 < -1;
          uint64_t v315 = (v313 >> 3) + 2;
          if (v53) {
            uint64_t v316 = v315;
          }
          else {
            uint64_t v316 = v314 + 1;
          }
          uint64_t v317 = v316 >> 1;
          v318 = &v311[-(v316 >> 1)];
          int64_t v319 = (char *)v10 - (char *)v311;
          if (v10 != v311)
          {
            memmove(&v311[-(v316 >> 1)], v311, (char *)v10 - (char *)v311);
            os_log_type_t v10 = (unint64_t *)a2->i64[1];
          }
          v309 = &v10[-v317];
          os_log_type_t v10 = (unint64_t *)((char *)v318 + v319);
          a2->i64[1] = (uint64_t)v309;
          a2[1].i64[0] = (uint64_t)v318 + v319;
        }
LABEL_423:
        *os_log_type_t v10 = j;
        os_log_type_t v10 = (unint64_t *)(a2[1].i64[0] + 8);
        a2[1].i64[0] = (uint64_t)v10;
        if (!--v15) {
          goto LABEL_419;
        }
      }
    }
    a2[2].i64[0] = v5 - (v15 << 8);
    if (!v15) {
      goto LABEL_419;
    }
    while (1)
    {
      BOOL v48 = (unint64_t *)a2->i64[1];
      unint64_t v50 = *v48;
      __int16 v49 = v48 + 1;
      unint64_t j = v50;
      a2->i64[1] = (uint64_t)v49;
      if (v10 == (unint64_t *)a2[1].i64[1])
      {
        uint64_t v51 = (uint64_t)v49 - a2->i64[0];
        if ((unint64_t)v49 <= a2->i64[0])
        {
          if (v10 == (unint64_t *)a2->i64[0]) {
            size_t v59 = 1;
          }
          else {
            size_t v59 = ((uint64_t)v10 - a2->i64[0]) >> 2;
          }
          __int16 v60 = malloc_type_calloc(v59, 8uLL, 0x80040B8603338uLL);
          if (!v60) {
            goto LABEL_54;
          }
          size_t v61 = v59 >> 2;
          __int16 v62 = (unint64_t *)&v60[8 * (v59 >> 2)];
          BOOL v63 = (unint64_t *)a2->i64[1];
          os_log_type_t v10 = v62;
          uint64_t v64 = a2[1].i64[0] - (void)v63;
          if (v64)
          {
            os_log_type_t v10 = (unint64_t *)((char *)v62 + (v64 & 0xFFFFFFFFFFFFFFF8));
            unint64_t v65 = v64 - 8;
            if (v65 >= 0x38)
            {
              uint64_t v67 = 8 * v61;
              unint64_t v68 = &v60[8 * v61] - (unsigned char *)v63;
              BOOL v66 = (unint64_t *)&v60[8 * (v59 >> 2)];
              if (v68 < 0x20) {
                goto LABEL_81;
              }
              uint64_t v69 = (v65 >> 3) + 1;
              uint64_t v70 = v69 & 0x3FFFFFFFFFFFFFFCLL;
              BOOL v66 = &v62[v70];
              os_log_type_t v71 = (long long *)(v63 + 2);
              char v72 = &v60[v67 + 16];
              uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v74 = *v71;
                *(v72 - 1) = *(v71 - 1);
                _OWORD *v72 = v74;
                v71 += 2;
                v72 += 2;
                v73 -= 4;
              }
              while (v73);
              if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
              {
                BOOL v63 = (unint64_t *)((char *)v63 + v70 * 8);
                goto LABEL_81;
              }
            }
            else
            {
              BOOL v66 = (unint64_t *)&v60[8 * (v59 >> 2)];
              do
              {
LABEL_81:
                unint64_t v75 = *v63++;
                *v66++ = v75;
              }
              while (v66 != v10);
            }
          }
          BOOL v76 = (void *)a2->i64[0];
          a2->i64[0] = (uint64_t)v60;
          a2->i64[1] = (uint64_t)v62;
          a2[1].i64[0] = (uint64_t)v10;
          a2[1].i64[1] = (uint64_t)&v60[8 * v59];
          if (v76)
          {
            free(v76);
            os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
          }
          goto LABEL_61;
        }
        uint64_t v52 = v51 >> 3;
        BOOL v53 = v51 >> 3 < -1;
        uint64_t v54 = (v51 >> 3) + 2;
        if (v53) {
          uint64_t v55 = v54;
        }
        else {
          uint64_t v55 = v52 + 1;
        }
        uint64_t v56 = v55 >> 1;
        os_log_type_t v57 = &v49[-(v55 >> 1)];
        int64_t v58 = (char *)v10 - (char *)v49;
        if (v10 != v49)
        {
          memmove(&v49[-(v55 >> 1)], v49, (char *)v10 - (char *)v49);
          os_log_type_t v10 = (unint64_t *)a2->i64[1];
        }
        os_log_type_t v47 = &v10[-v56];
        os_log_type_t v10 = (unint64_t *)((char *)v57 + v58);
        a2->i64[1] = (uint64_t)v47;
        a2[1].i64[0] = (uint64_t)v57 + v58;
      }
LABEL_61:
      *os_log_type_t v10 = j;
      os_log_type_t v10 = (unint64_t *)(a2[1].i64[0] + 8);
      a2[1].i64[0] = (uint64_t)v10;
      if (!--v15) {
        goto LABEL_419;
      }
    }
  }
  unint64_t v25 = j - v5;
  if (j <= v5) {
    goto LABEL_141;
  }
  unint64_t v409 = v18;
  uint64_t v26 = 32 * v22 - 1;
  if (v10 == v9)
  {
    uint64_t v26 = 0;
    ++v25;
  }
  if ((_BYTE)v25) {
    unint64_t v27 = (v25 >> 8) + 1;
  }
  else {
    unint64_t v27 = v25 >> 8;
  }
  unint64_t v28 = (v26 - v7) >> 8;
  if (v27 >= v28) {
    unint64_t v18 = v28;
  }
  else {
    unint64_t v18 = v27;
  }
  unint64_t v412 = v24;
  if (v27 <= v28)
  {
LABEL_55:
    for (a2[2].i64[0] = v5 + (v18 << 8); v18; --v18)
    {
      uint64_t v46 = a2[1].i64[0];
      os_log_type_t v420 = *(void **)(v46 - 8);
      a2[1].i64[0] = v46 - 8;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
    }
    goto LABEL_140;
  }
  unint64_t v410 = j;
  unint64_t j = v27 - v18;
  uint64_t v29 = a2[1].i64[1] - a2->i64[0];
  uint64_t v30 = v10 - v9;
  if (v27 - v18 <= (v29 >> 3) - v30)
  {
    if (j)
    {
      if (v9 != (unint64_t *)a2->i64[0])
      {
        do
        {
          long long v77 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v77) {
            goto LABEL_54;
          }
          os_log_type_t v420 = v77;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
          uint64_t v78 = a2->i64[1];
          if (a2[1].i64[0] - v78 == 8) {
            uint64_t v79 = 255;
          }
          else {
            uint64_t v79 = 256;
          }
          unint64_t v5 = v79 + a2[2].i64[0];
          a2[2].i64[0] = v5;
          if (!--j) {
            goto LABEL_96;
          }
        }
        while (v78 != a2->i64[0]);
      }
      v18 += j;
      do
      {
        char v80 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
        if (!v80) {
          goto LABEL_54;
        }
        os_log_type_t v420 = v80;
        std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back(a2, &v420);
        --j;
      }
      while (j);
      unint64_t v5 = a2[2].u64[0];
    }
LABEL_96:
    a2[2].i64[0] = v5 + (v18 << 8);
    for (unint64_t j = v410; v18; --v18)
    {
      uint64_t v81 = a2[1].i64[0];
      os_log_type_t v420 = *(void **)(v81 - 8);
      a2[1].i64[0] = v81 - 8;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
    }
    goto LABEL_140;
  }
  BOOL v31 = v10 == v9;
  if (v29 >> 2 <= j + v30) {
    size_t v32 = j + v30;
  }
  else {
    size_t v32 = v29 >> 2;
  }
  uint64_t v407 = v15;
  if (v32)
  {
    int v33 = (uint64_t *)malloc_type_calloc(v32, 8uLL, 0x80040B8603338uLL);
    if (!v33) {
      goto LABEL_54;
    }
  }
  else
  {
    int v33 = 0;
  }
  unint64_t v405 = (v27 << 8) - v31;
  uint64_t v15 = (uint64_t)&v33[v32];
  os_log_type_t v84 = v33;
  id v85 = (char *)v33;
  do
  {
    __int16 v86 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
    if (!v86) {
      goto LABEL_54;
    }
    BOOL v87 = v86;
    if (v85 == (char *)v15)
    {
      unint64_t __src = v33;
      if (v84 <= v33)
      {
        if ((uint64_t *)v15 == v33) {
          size_t v94 = 1;
        }
        else {
          size_t v94 = (v15 - (uint64_t)v33) >> 2;
        }
        int v95 = (uint64_t *)malloc_type_calloc(v94, 8uLL, 0x80040B8603338uLL);
        if (!v95) {
          goto LABEL_54;
        }
        int v96 = v95;
        size_t v97 = v94 >> 2;
        BOOL v98 = (char *)&v95[v94 >> 2];
        id v85 = v98;
        uint64_t v99 = v15 - (void)v84;
        if ((uint64_t *)v15 != v84)
        {
          id v85 = &v98[v99 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v100 = v99 - 8;
          if (v100 >= 0x38)
          {
            uint64_t v102 = v97;
            if ((unint64_t)((char *)&v95[v97] - (char *)v84) < 0x20)
            {
              int v101 = (char *)&v95[v94 >> 2];
              goto LABEL_131;
            }
            uint64_t v103 = (v100 >> 3) + 1;
            uint64_t v104 = 8 * (v103 & 0x3FFFFFFFFFFFFFFCLL);
            int v101 = &v98[v104];
            size_t v105 = (long long *)(v84 + 2);
            int v106 = &v95[v102 + 2];
            uint64_t v107 = v103 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v108 = *v105;
              *((_OWORD *)v106 - 1) = *(v105 - 1);
              *(_OWORD *)int v106 = v108;
              v105 += 2;
              v106 += 4;
              v107 -= 4;
            }
            while (v107);
            if (v103 != (v103 & 0x3FFFFFFFFFFFFFFCLL))
            {
              os_log_type_t v84 = (uint64_t *)((char *)v84 + v104);
              goto LABEL_131;
            }
          }
          else
          {
            int v101 = (char *)&v95[v94 >> 2];
            do
            {
LABEL_131:
              uint64_t v109 = *v84++;
              *(void *)int v101 = v109;
              v101 += 8;
            }
            while (v101 != v85);
          }
        }
        uint64_t v15 = (uint64_t)&v95[v94];
        if (__src)
        {
          os_log_type_t v84 = &v95[v94 >> 2];
          free(__src);
        }
        else
        {
          os_log_type_t v84 = (uint64_t *)v98;
        }
        int v33 = v96;
        goto LABEL_108;
      }
      uint64_t v88 = v84 - v33;
      if (v88 >= -1) {
        uint64_t v89 = v88 + 1;
      }
      else {
        uint64_t v89 = v88 + 2;
      }
      uint64_t v90 = v89 >> 1;
      int v91 = (char *)&v84[-(v89 >> 1)];
      os_log_type_t v92 = (void *)v15;
      if ((uint64_t *)v15 != v84)
      {
        memmove(v91, v84, v15 - (void)v84);
        os_log_type_t v92 = v84;
      }
      uint64_t v93 = -v90;
      id v85 = &v91[v15 - (void)v84];
      os_log_type_t v84 = &v92[v93];
    }
LABEL_108:
    *(void *)id v85 = v87;
    v85 += 8;
    --j;
  }
  while (j);
  unint64_t j = a2[1].u64[0];
  if (v18)
  {
    while (1)
    {
      if (v85 == (char *)v15)
      {
        if (v84 <= v33)
        {
          __srca = v33;
          if ((uint64_t *)v15 == v33) {
            size_t v123 = 1;
          }
          else {
            size_t v123 = (v15 - (uint64_t)v33) >> 2;
          }
          os_log_type_t v124 = (uint64_t *)malloc_type_calloc(v123, 8uLL, 0x80040B8603338uLL);
          if (!v124) {
            goto LABEL_54;
          }
          os_log_type_t v125 = v124;
          size_t v126 = v123 >> 2;
          os_log_type_t v110 = &v124[v123 >> 2];
          id v85 = (char *)v110;
          uint64_t v127 = v15 - (void)v84;
          if ((uint64_t *)v15 != v84)
          {
            id v85 = (char *)v110 + (v127 & 0xFFFFFFFFFFFFFFF8);
            unint64_t v128 = v127 - 8;
            if (v128 >= 0x38)
            {
              uint64_t v130 = v126;
              if ((unint64_t)((char *)&v124[v126] - (char *)v84) < 0x20)
              {
                os_log_type_t v129 = (char *)&v124[v123 >> 2];
                goto LABEL_170;
              }
              uint64_t v131 = (v128 >> 3) + 1;
              uint64_t v132 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              os_log_type_t v129 = (char *)&v110[v132];
              os_log_type_t v133 = (long long *)(v84 + 2);
              BOOL v134 = &v124[v130 + 2];
              uint64_t v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v136 = *v133;
                *((_OWORD *)v134 - 1) = *(v133 - 1);
                *(_OWORD *)BOOL v134 = v136;
                v133 += 2;
                v134 += 4;
                v135 -= 4;
              }
              while (v135);
              if (v131 != (v131 & 0x3FFFFFFFFFFFFFFCLL))
              {
                os_log_type_t v84 = (uint64_t *)((char *)v84 + v132 * 8);
                goto LABEL_170;
              }
            }
            else
            {
              os_log_type_t v129 = (char *)&v124[v123 >> 2];
              do
              {
LABEL_170:
                uint64_t v137 = *v84++;
                *(void *)os_log_type_t v129 = v137;
                v129 += 8;
              }
              while (v129 != v85);
            }
          }
          uint64_t v15 = (uint64_t)&v124[v123];
          if (__srca) {
            free(__srca);
          }
          int v33 = v125;
          goto LABEL_148;
        }
        uint64_t v117 = v84 - v33;
        if (v117 >= -1) {
          uint64_t v118 = v117 + 1;
        }
        else {
          uint64_t v118 = v117 + 2;
        }
        uint64_t v119 = v118 >> 1;
        size_t v120 = (char *)&v84[-(v118 >> 1)];
        os_log_type_t v121 = (void *)v15;
        if ((uint64_t *)v15 != v84)
        {
          memmove(v120, v84, v15 - (void)v84);
          os_log_type_t v121 = v84;
        }
        uint64_t v122 = -v119;
        id v85 = &v120[v15 - (void)v84];
        os_log_type_t v110 = &v121[v122];
      }
      else
      {
        os_log_type_t v110 = v84;
      }
LABEL_148:
      *(void *)id v85 = *(void *)(j - 8);
      v85 += 8;
      unint64_t j = a2[1].i64[0] - 8;
      a2[1].i64[0] = j;
      os_log_type_t v84 = v110;
      if (!--v18) {
        goto LABEL_136;
      }
    }
  }
  os_log_type_t v110 = v84;
LABEL_136:
  unint64_t v18 = (unint64_t)v33;
  os_log_type_t v111 = (uint64_t *)a2->i64[1];
  if (v111 != (uint64_t *)j)
  {
    while (1)
    {
      if (v85 == (char *)v15)
      {
        if ((unint64_t)v110 <= v18)
        {
          if (v15 == v18) {
            size_t v144 = 1;
          }
          else {
            size_t v144 = (uint64_t)(v15 - v18) >> 2;
          }
          BOOL v145 = malloc_type_calloc(v144, 8uLL, 0x80040B8603338uLL);
          if (!v145) {
            goto LABEL_54;
          }
          unint64_t v146 = (unint64_t)v145;
          size_t v147 = v144 >> 2;
          unint64_t j = (unint64_t)&v145[8 * (v144 >> 2)];
          id v85 = (char *)j;
          uint64_t v148 = v15 - (void)v110;
          if ((uint64_t *)v15 != v110)
          {
            id v85 = (char *)(j + (v148 & 0xFFFFFFFFFFFFFFF8));
            unint64_t v149 = v148 - 8;
            if (v149 >= 0x38)
            {
              uint64_t v151 = 8 * v147;
              if ((unint64_t)(&v145[8 * v147] - (unsigned char *)v110) < 0x20)
              {
                BOOL v150 = &v145[8 * (v144 >> 2)];
                goto LABEL_197;
              }
              uint64_t v152 = (v149 >> 3) + 1;
              uint64_t v153 = 8 * (v152 & 0x3FFFFFFFFFFFFFFCLL);
              BOOL v150 = (char *)(j + v153);
              os_log_type_t v154 = (long long *)(v110 + 2);
              BOOL v155 = &v145[v151 + 16];
              uint64_t v156 = v152 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v157 = *v154;
                *(v155 - 1) = *(v154 - 1);
                _OWORD *v155 = v157;
                v154 += 2;
                v155 += 2;
                v156 -= 4;
              }
              while (v156);
              if (v152 != (v152 & 0x3FFFFFFFFFFFFFFCLL))
              {
                os_log_type_t v110 = (uint64_t *)((char *)v110 + v153);
                goto LABEL_197;
              }
            }
            else
            {
              BOOL v150 = &v145[8 * (v144 >> 2)];
              do
              {
LABEL_197:
                uint64_t v158 = *v110++;
                *(void *)BOOL v150 = v158;
                v150 += 8;
              }
              while (v150 != v85);
            }
          }
          uint64_t v15 = (uint64_t)&v145[8 * v144];
          if (v18) {
            free((void *)v18);
          }
          unint64_t v18 = v146;
          goto LABEL_175;
        }
        uint64_t v139 = (uint64_t)((uint64_t)v110 - v18) >> 3;
        if (v139 >= -1) {
          uint64_t v140 = v139 + 1;
        }
        else {
          uint64_t v140 = v139 + 2;
        }
        uint64_t v141 = v140 >> 1;
        char v142 = (char *)&v110[-(v140 >> 1)];
        BOOL v143 = (void *)v15;
        if ((uint64_t *)v15 != v110)
        {
          memmove(v142, v110, v15 - (void)v110);
          BOOL v143 = v110;
        }
        id v85 = &v142[v15 - (void)v110];
        unint64_t j = (unint64_t)&v143[-v141];
      }
      else
      {
        unint64_t j = (unint64_t)v110;
      }
LABEL_175:
      uint64_t v138 = *v111++;
      *(void *)id v85 = v138;
      v85 += 8;
      os_log_type_t v110 = (uint64_t *)j;
      if (v111 == (uint64_t *)a2[1].i64[0]) {
        goto LABEL_138;
      }
    }
  }
  unint64_t j = (unint64_t)v110;
LABEL_138:
  uint32_t v112 = (void *)a2->i64[0];
  a2->i64[0] = v18;
  a2->i64[1] = j;
  a2[1].i64[0] = (uint64_t)v85;
  a2[1].i64[1] = v15;
  uint64_t v15 = v407;
  a2[2].i64[0] += v405;
  unint64_t j = v410;
  if (v112) {
    free(v112);
  }
LABEL_140:
  unint64_t v5 = a2[2].u64[0];
  char v9 = (unint64_t *)a2->i64[1];
  os_log_type_t v10 = (unint64_t *)a2[1].i64[0];
  unint64_t v20 = v5 >> 8;
  unint64_t v18 = v409;
  unint64_t v24 = v412;
LABEL_141:
  size_t v113 = &v9[v20];
  if (v10 == v9)
  {
    size_t v114 = 0;
    unint64_t v115 = j - v24;
    if (j <= v24) {
      goto LABEL_202;
    }
LABEL_143:
    if (v24 >= j >> 1)
    {
      uint64_t v116 = v115 + ((uint64_t)&v16[-*(void *)v15] >> 4);
      if (v116 >= 1)
      {
        v15 += 8 * ((unint64_t)v116 >> 8);
LABEL_206:
        uint64_t v161 = *(void *)v15 + 16 * v116;
        if ((char *)v161 != v16) {
          goto LABEL_207;
        }
LABEL_218:
        os_log_type_t v159 = v114;
        os_log_type_t v160 = (char **)v113;
        goto LABEL_219;
      }
      unint64_t v167 = 255 - v116;
      unsigned __int8 v168 = ~(_BYTE)v167;
      v15 -= 8 * (v167 >> 8);
    }
    else
    {
      if (!v24)
      {
        uint64_t v15 = (uint64_t)v419;
        uint64_t v161 = v18;
        if ((char *)v18 == v16) {
          goto LABEL_218;
        }
        goto LABEL_207;
      }
      uint64_t v116 = ((uint64_t)(v18 - *v419) >> 4) - v24;
      if (v116 >= 1)
      {
        uint64_t v15 = (uint64_t)&v419[(unint64_t)v116 >> 8];
        goto LABEL_206;
      }
      unint64_t v169 = 255 - v116;
      unsigned __int8 v168 = ~(_BYTE)v169;
      uint64_t v15 = (uint64_t)&v419[-(v169 >> 8)];
    }
    uint64_t v161 = *(void *)v15 + 16 * v168;
    if ((char *)v161 == v16) {
      goto LABEL_218;
    }
LABEL_207:
    xpc_object_t v162 = (const void **)v15;
    unsigned int v163 = (char *)v161;
    os_log_type_t v160 = (char **)v113;
    os_log_type_t v159 = v114;
    do
    {
      if (v159 == *v160)
      {
        uint64_t v165 = (uint64_t)*--v160;
        os_log_type_t v159 = (char *)(v165 + 4096);
      }
      if (v163 == *v162)
      {
        uint64_t v166 = (uint64_t)*--v162;
        unsigned int v163 = (char *)(v166 + 4096);
      }
      long long v164 = *((_OWORD *)v163 - 1);
      v163 -= 16;
      *((_OWORD *)v159 - 1) = v164;
      v159 -= 16;
      a2[2] = vaddq_s64(a2[2], (int64x2_t)xmmword_183D5CD40);
    }
    while (v163 != v16);
LABEL_219:
    unint64_t j = v24;
    int v16 = (char *)v161;
    if (!v24) {
      return;
    }
LABEL_220:
    uint64_t v170 = j + ((uint64_t)&v114[-*v113] >> 4);
    if (v170 < 1)
    {
      unint64_t v173 = 255 - v170;
      os_log_type_t v171 = &v113[-(v173 >> 8)];
      os_log_type_t v172 = (char *)(*v171 + 16 * ~(_BYTE)v173);
      if (v172 == v114) {
        goto LABEL_230;
      }
    }
    else
    {
      os_log_type_t v171 = &v113[(unint64_t)v170 >> 8];
      os_log_type_t v172 = (char *)(*v171 + 16 * v170);
      if (v172 == v114) {
        goto LABEL_230;
      }
    }
    BOOL v174 = (void **)v171;
    int v175 = v172;
    do
    {
      if (v159 == *v160)
      {
        uint64_t v177 = (uint64_t)*--v160;
        os_log_type_t v159 = (char *)(v177 + 4096);
      }
      if (v175 == *v174)
      {
        uint64_t v178 = (uint64_t)*--v174;
        int v175 = (char *)(v178 + 4096);
      }
      long long v176 = *((_OWORD *)v175 - 1);
      v175 -= 16;
      *((_OWORD *)v159 - 1) = v176;
      v159 -= 16;
      a2[2] = vaddq_s64(a2[2], (int64x2_t)xmmword_183D5CD40);
    }
    while (v175 != v114);
LABEL_230:
    if (j < v24)
    {
      BOOL v179 = (char *)*v113;
      uint64_t v180 = v24 + ((uint64_t)&v114[-*v113] >> 4);
      if (v180 < 1)
      {
        unint64_t v183 = 255 - v180;
        unsigned int v181 = (char **)&v113[-(v183 >> 8)];
        uint64_t v182 = (uint64_t)&(*v181)[16 * ~(_BYTE)v183];
      }
      else
      {
        unsigned int v181 = (char **)&v113[(unint64_t)v180 >> 8];
        uint64_t v182 = (uint64_t)&(*v181)[16 * v180];
      }
      __srcb = (char *)v182;
      if (v171 != (unint64_t *)v181)
      {
        uint64_t v184 = *v171 + 4096;
        if ((char *)v184 != v172)
        {
          nw_interface_t v185 = v16;
          uint64_t v186 = v15;
          while (1)
          {
            uint64_t v187 = (v179 - v114 + 4096) >> 4;
            if ((v184 - (uint64_t)v172) >> 4 >= v187) {
              uint64_t v188 = v187;
            }
            else {
              uint64_t v188 = (v184 - (uint64_t)v172) >> 4;
            }
            if (v188) {
              memmove(v114, v172, 16 * v188);
            }
            v172 += 16 * v188;
            if (v172 == (char *)v184) {
              break;
            }
            BOOL v189 = (char *)v113[1];
            ++v113;
            BOOL v179 = v189;
            size_t v114 = v189;
          }
          v114 += 16 * v188;
          BOOL v179 = (char *)*v113;
          if ((char *)(*v113 + 4096) == v114)
          {
            BOOL v190 = (char *)v113[1];
            ++v113;
            BOOL v179 = v190;
            size_t v114 = v190;
          }
          uint64_t v15 = v186;
          int v16 = v185;
        }
        os_log_type_t v191 = (char **)(v171 + 1);
        if (v171 + 1 != (unint64_t *)v181)
        {
          v413 = v16;
          do
          {
            uint64_t v192 = v15;
            unint64_t v193 = v18;
            uint64_t v194 = 0;
            nw_protocol_options_t v195 = *v191;
            while (1)
            {
              uint64_t v196 = (v179 - v114 + 4096) >> 4;
              if ((4096 - 16 * v194) >> 4 >= v196) {
                uint64_t v197 = v196;
              }
              else {
                uint64_t v197 = (4096 - 16 * v194) >> 4;
              }
              if (v197) {
                memmove(v114, &v195[16 * v194], 16 * v197);
              }
              v194 += v197;
              if (v194 == 256) {
                break;
              }
              nw_interface_t v198 = (char *)v113[1];
              ++v113;
              BOOL v179 = v198;
              size_t v114 = v198;
            }
            v114 += 16 * v197;
            BOOL v179 = (char *)*v113;
            if ((char *)(*v113 + 4096) == v114)
            {
              os_log_type_t v199 = (char *)v113[1];
              ++v113;
              BOOL v179 = v199;
              size_t v114 = v199;
            }
            unint64_t v18 = v193;
            uint64_t v15 = v192;
            ++v191;
          }
          while (v191 != v181);
          int v16 = v413;
        }
        uint64_t v200 = *v181;
        if (*v181 == __srcb) {
          goto LABEL_283;
        }
        v201 = (char *)*v113;
        while (1)
        {
          uint64_t v202 = (v201 - v114 + 4096) >> 4;
          if ((__srcb - v200) >> 4 >= v202) {
            uint64_t v203 = v202;
          }
          else {
            uint64_t v203 = (__srcb - v200) >> 4;
          }
          if (v203) {
            memmove(v114, v200, 16 * v203);
          }
          v200 += 16 * v203;
          if (v200 == __srcb) {
            break;
          }
          os_log_type_t v204 = (char *)v113[1];
          ++v113;
          v201 = v204;
          size_t v114 = v204;
        }
        v114 += 16 * v203;
        goto LABEL_281;
      }
      if (v172 != (char *)v182)
      {
        while (1)
        {
          uint64_t v206 = (v179 - v114 + 4096) >> 4;
          if ((__srcb - v172) >> 4 >= v206) {
            uint64_t v207 = v206;
          }
          else {
            uint64_t v207 = (__srcb - v172) >> 4;
          }
          if (v207) {
            memmove(v114, v172, 16 * v207);
          }
          v172 += 16 * v207;
          if (v172 == __srcb) {
            break;
          }
          nw_endpoint_t v205 = (char *)v113[1];
          ++v113;
          BOOL v179 = v205;
          size_t v114 = v205;
        }
        v114 += 16 * v207;
LABEL_281:
        if ((char *)(*v113 + 4096) == v114)
        {
          int v208 = (char *)v113[1];
          ++v113;
          size_t v114 = v208;
        }
      }
    }
LABEL_283:
    if (v419 == (uint64_t *)v15)
    {
      if (v16 != (char *)v18)
      {
        v232 = (char *)*v113;
        os_log_type_t v231 = (void **)(v113 + 1);
        os_log_type_t v230 = v232;
        while (1)
        {
          uint64_t v233 = (v230 - v114 + 4096) >> 4;
          if ((uint64_t)(v18 - (void)v16) >> 4 >= v233) {
            uint64_t v234 = v233;
          }
          else {
            uint64_t v234 = (uint64_t)(v18 - (void)v16) >> 4;
          }
          if (v234) {
            memmove(v114, v16, 16 * v234);
          }
          v16 += 16 * v234;
          if (v16 == (char *)v18) {
            break;
          }
          os_log_type_t v235 = (char *)*v231++;
          os_log_type_t v230 = v235;
          size_t v114 = v235;
        }
      }
    }
    else
    {
      uint64_t v209 = *(void *)v15 + 4096;
      if ((char *)v209 != v16)
      {
        os_log_type_t v210 = (char *)*v113;
        while (1)
        {
          uint64_t v211 = (v210 - v114 + 4096) >> 4;
          if ((v209 - (uint64_t)v16) >> 4 >= v211) {
            uint64_t v212 = v211;
          }
          else {
            uint64_t v212 = (v209 - (uint64_t)v16) >> 4;
          }
          if (v212) {
            memmove(v114, v16, 16 * v212);
          }
          v16 += 16 * v212;
          if (v16 == (char *)v209) {
            break;
          }
          int v213 = (char *)v113[1];
          ++v113;
          os_log_type_t v210 = v213;
          size_t v114 = v213;
        }
        v114 += 16 * v212;
        if ((char *)(*v113 + 4096) == v114)
        {
          BOOL v214 = (char *)v113[1];
          ++v113;
          size_t v114 = v214;
        }
      }
      os_log_type_t v215 = (uint64_t *)(v15 + 8);
      if ((uint64_t *)(v15 + 8) != v419)
      {
        os_log_type_t v216 = (char *)*v113;
        do
        {
          uint64_t v217 = 0;
          uint64_t v218 = *v215;
          while (1)
          {
            uint64_t v219 = (v216 - v114 + 4096) >> 4;
            if ((4096 - 16 * v217) >> 4 >= v219) {
              uint64_t v220 = v219;
            }
            else {
              uint64_t v220 = (4096 - 16 * v217) >> 4;
            }
            if (v220) {
              memmove(v114, (const void *)(v218 + 16 * v217), 16 * v220);
            }
            v217 += v220;
            if (v217 == 256) {
              break;
            }
            v221 = (char *)v113[1];
            ++v113;
            os_log_type_t v216 = v221;
            size_t v114 = v221;
          }
          v114 += 16 * v220;
          os_log_type_t v216 = (char *)*v113;
          if ((char *)(*v113 + 4096) == v114)
          {
            BOOL v222 = (char *)v113[1];
            ++v113;
            os_log_type_t v216 = v222;
            size_t v114 = v222;
          }
          ++v215;
        }
        while (v215 != v419);
      }
      os_log_type_t v223 = (char *)*v419;
      if (*v419 != v18)
      {
        BOOL v226 = (char *)*v113;
        os_log_type_t v225 = (void **)(v113 + 1);
        BOOL v224 = v226;
        while (1)
        {
          uint64_t v227 = (v224 - v114 + 4096) >> 4;
          uint64_t v228 = (uint64_t)(v18 - (void)v223) >> 4 >= v227 ? v227 : (uint64_t)(v18 - (void)v223) >> 4;
          if (v228) {
            memmove(v114, v223, 16 * v228);
          }
          v223 += 16 * v228;
          if (v223 == (char *)v18) {
            break;
          }
          int v229 = (char *)*v225++;
          BOOL v224 = v229;
          size_t v114 = v229;
        }
      }
    }
    return;
  }
  size_t v114 = (char *)(*v113 + 16 * v5);
  unint64_t v115 = j - v24;
  if (j > v24) {
    goto LABEL_143;
  }
LABEL_202:
  os_log_type_t v159 = v114;
  os_log_type_t v160 = (char **)v113;
  if (j) {
    goto LABEL_220;
  }
}

uint64_t nw_context_64k_buffer_manager(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = nw_context_copy_globals_context(v1);

    uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 156);
    if (!v4)
    {
      *(void *)(*(void *)(v3 + 32) + 156) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe_3, dword_1E8F651F0, (unsigned __int16)word_1E8F651F4);
      uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 156);
    }
    goto LABEL_4;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v17 = "nw_context_64k_buffer_manager";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v17 = "nw_context_64k_buffer_manager";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v17 = "nw_context_64k_buffer_manager";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v17 = "nw_context_64k_buffer_manager";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v17 = "nw_context_64k_buffer_manager";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
LABEL_4:

  return v4;
}

void sub_18339CA28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_2(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (nw_path_flow_is_assigned(v4) && (nw_path_flow_is_defunct(v4) & 1) == 0)
  {
    unint64_t v5 = (void *)a1[4];
    uint64_t v6 = (void *)v5[26];
    unint64_t v7 = v5;
    id v8 = v4;
    id v9 = v6;
    nw_context_assert_queue((void *)v7[3]);
    uint64_t v20 = 0;
    uint64_t v21 = &v20;
    uint64_t v22 = 0x3032000000;
    uint64_t v23 = __Block_byref_object_copy__18063;
    unint64_t v24 = __Block_byref_object_dispose__18064;
    id v25 = 0;
    os_log_type_t v10 = (atomic_uchar *)v7[18];
    if (v10)
    {
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3221225472;
      v16[2] = ___ZL45nw_listener_find_channel_inbox_match_on_queueP22NWConcrete_nw_listenerPU26objcproto15OS_nw_path_flow8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke;
      v16[3] = &unk_1E5244660;
      id v17 = v8;
      id v18 = v9;
      uint64_t v19 = &v20;
      nw_array_apply(v10, (uint64_t)v16);

      os_log_type_t v11 = (void *)v21[5];
    }
    else
    {
      os_log_type_t v11 = 0;
    }
    id v12 = v11;
    _Block_object_dispose(&v20, 8);

    if (v12)
    {
      uint64_t v13 = a1[5];
      char v14 = v12;
    }
    else
    {
      uint64_t v13 = a1[6];
      char v14 = v8;
    }
    nw_array_append(v13, v14);
  }
  return 1;
}

void sub_18339CBDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_is_defunct(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[186] >> 2) & 1;
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_flow_is_defunct";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_is_defunct";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_flow_is_defunct";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_is_defunct";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_is_defunct";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_is_assigned(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[185] >> 1) & 1;
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_flow_is_assigned";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_is_assigned";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_flow_is_assigned";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_is_assigned";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_is_assigned";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_quic_connection_set_sec_protocol_metadata(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_sec_protocol_metadata_block_invoke;
    v13[3] = &unk_1E5248F68;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v18 = "nw_quic_connection_set_sec_protocol_metadata";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_quic_connection_set_sec_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v18 = "nw_quic_connection_set_sec_protocol_metadata";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_quic_connection_set_sec_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_quic_connection_set_sec_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18339D434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_sec_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

BOOL nw_settings_register_quic_log_debug_updates(void *a1)
{
  nw_allow_use_of_dispatch_internal();
  pthread_mutex_lock(&sSettingsMutex);
  uint64_t v2 = (const void *)sQUICUpdateBlock;
  if ((void *)sQUICUpdateBlock != a1)
  {
    if (a1)
    {
      a1 = _Block_copy(a1);
      uint64_t v2 = (const void *)sQUICUpdateBlock;
    }
    if (v2) {
      _Block_release(v2);
    }
    sQUICUpdateBlock = (uint64_t)a1;
  }
  pthread_mutex_unlock(&sSettingsMutex);
  id v3 = (const char *)nw_setting_libnetcore_datapath_debug;
  networkd_settings_init();
  if (!sCachedSettings) {
    return 0;
  }
  pthread_mutex_lock(&sSettingsMutex);
  id v4 = (void *)sCachedSettings;
  if (!sCachedSettings) {
    goto LABEL_13;
  }
  Class Class = object_getClass((id)sCachedSettings);
  BOOL v6 = 0;
  if (!v3 || Class != (Class)MEMORY[0x1E4F14590]) {
    goto LABEL_14;
  }
  xpc_object_t value = xpc_dictionary_get_value(v4, v3);
  if (value && (os_log_type_t v8 = value, object_getClass(value) == (Class)MEMORY[0x1E4F14570])) {
    BOOL v6 = xpc_BOOL_get_value(v8);
  }
  else {
LABEL_13:
  }
    BOOL v6 = 0;
LABEL_14:
  pthread_mutex_unlock(&sSettingsMutex);
  return v6;
}

void nw_quic_connection_execute_locked(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_execute_locked_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v18 = "nw_quic_connection_execute_locked";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_quic_connection_execute_locked";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v18 = "nw_quic_connection_execute_locked";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_quic_connection_execute_locked";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_quic_connection_execute_locked";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18339D89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_execute_locked_block_invoke(uint64_t a1, os_unfair_lock_s *a2)
{
  id v3 = a2 + 53;
  os_unfair_lock_lock(a2 + 53);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  os_unfair_lock_unlock(v3);
  return 1;
}

void nw_parameters_set_discretionary(void *a1, __int16 a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *(_WORD *)(*((void *)v3 + 13) + 108) = *(_WORD *)(*((void *)v3 + 13) + 108) & 0xFFFE | a2;
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_set_discretionary";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_set_discretionary";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_set_discretionary";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_set_discretionary";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_set_discretionary";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

uint64_t nw_protocol_instance_add_new_flow(void *a1, char a2, int a3, void *a4, void *a5, void *a6)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  BOOL v11 = a1;
  id v12 = a4;
  char v13 = a5;
  id v14 = a6;
  if (!v11)
  {
    size_t v44 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v55 = "nw_protocol_instance_add_new_flow";
    char v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (__nwlog_fault(v45, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v46 = __nwlog_obj();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v52)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v46 = __nwlog_obj();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v46, type);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v55 = "nw_protocol_instance_add_new_flow";
            __int16 v56 = 2082;
            os_log_type_t v57 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v46, v49, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_83;
        }
        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_1830D4000, v46, v49, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v46 = __nwlog_obj();
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_1830D4000, v46, v51, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_83:
    if (v45) {
      free(v45);
    }
    goto LABEL_14;
  }
  char v15 = (void *)*((void *)v11 + 15);
  if (v15)
  {
    int v16 = v15;
    __int16 v17 = v16;
    if (((_BYTE)v16[17] & 8) == 0) {
      dispatch_assert_queue_V2(v16[1]);
    }
  }
  if (nw_protocol_definition_get_variant(*((void **)v11 + 1)) == 3)
  {
    id v18 = *((id *)v11 + 6);
    BOOL v19 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v18, 0, 0);

    if (v19)
    {
      uint64_t v20 = (id)v19;
      uint64_t v21 = v20;
      if (a2)
      {
        *(_DWORD *)(v20[13] + 84) = 0;
        unint64_t v22 = v20[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;
        v20[12] = v22;
        uint64_t v23 = 0x8000;
      }
      else
      {
        uint64_t v23 = 0;
        unint64_t v22 = v20[12];
      }
      v20[12] = v22 & 0xFFFFFFFFFFFF7FFFLL | v23;

      if (v13) {
        v13[2](v13, v21);
      }
      if (a3) {
        char v30 = 3;
      }
      else {
        char v30 = 1;
      }
      v11[404] = v30 | v11[404] & 0xFC;
      *((void *)v11 + 31) = 0;
      objc_storeStrong((id *)v11 + 32, a4);
      if (v14)
      {
        BOOL v31 = nw_connection_create_from_protocol_on_nw_queue(*((void **)v11 + 5), v21, (nw_protocol *)(v11 - 96));
        if (v31)
        {
          (*((void (**)(id, void, void *))v14 + 2))(v14, *((void *)v11 + 31), v31);

LABEL_34:
          v11[404] &= 0xFCu;
          uint64_t v34 = (void *)*((void *)v11 + 32);
          *((void *)v11 + 32) = 0;

          uint64_t v25 = *((void *)v11 + 31);
LABEL_65:

          goto LABEL_66;
        }
        if ((v11[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v38 = (id)gLogObj;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v55 = "nw_protocol_instance_add_new_flow";
            __int16 v56 = 2082;
            os_log_type_t v57 = v11 + 407;
            __int16 v58 = 2080;
            size_t v59 = " ";
            _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%snw_connection_create_from_protocol_on_nw_queue failed", buf, 0x20u);
          }
        }
      }
      else
      {
        size_t v32 = (uint64_t (***)(void))*((void *)v11 + 3);
        if (v32)
        {
          if (*v32)
          {
            int v33 = **v32;
            if (v33)
            {
              if (v33()) {
                goto LABEL_34;
              }
            }
          }
          if ((v11[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            unint64_t v40 = (id)gLogObj;
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              uint64_t v55 = "nw_protocol_instance_add_new_flow";
              __int16 v56 = 2082;
              os_log_type_t v57 = v11 + 407;
              __int16 v58 = 2080;
              size_t v59 = " ";
              _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sListener rejected new flow", buf, 0x20u);
            }
          }
        }
        else if ((v11[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v39 = (id)gLogObj;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v55 = "nw_protocol_instance_add_new_flow";
            __int16 v56 = 2082;
            os_log_type_t v57 = v11 + 407;
            __int16 v58 = 2080;
            size_t v59 = " ";
            _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo listener registered, cannot accept new flow", buf, 0x20u);
          }
        }
      }
      v11[404] &= 0xFCu;
      uint64_t v41 = (void *)*((void *)v11 + 32);
      *((void *)v11 + 32) = 0;

LABEL_64:
      uint64_t v25 = 0;
      goto LABEL_65;
    }
    if (v11[405] < 0) {
      goto LABEL_64;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v26 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    uint64_t v55 = "nw_protocol_instance_add_new_flow";
    __int16 v56 = 2082;
    os_log_type_t v57 = v11 + 407;
    __int16 v58 = 2080;
    size_t v59 = " ";
    unint64_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (__nwlog_fault(v27, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v28 = (id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v55 = "nw_protocol_instance_add_new_flow";
          __int16 v56 = 2082;
          os_log_type_t v57 = v11 + 407;
          __int16 v58 = 2080;
          size_t v59 = " ";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow", buf, 0x20u);
        }
      }
      else if (v52)
      {
        uint64_t v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v28 = (id)gLogObj;
        os_log_type_t v36 = type;
        BOOL v37 = os_log_type_enabled(v28, type);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446978;
            uint64_t v55 = "nw_protocol_instance_add_new_flow";
            __int16 v56 = 2082;
            os_log_type_t v57 = v11 + 407;
            __int16 v58 = 2080;
            size_t v59 = " ";
            __int16 v60 = 2082;
            size_t v61 = v35;
            _os_log_impl(&dword_1830D4000, v28, v36, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v35);
          if (!v27) {
            goto LABEL_64;
          }
          goto LABEL_63;
        }
        if (v37)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v55 = "nw_protocol_instance_add_new_flow";
          __int16 v56 = 2082;
          os_log_type_t v57 = v11 + 407;
          __int16 v58 = 2080;
          size_t v59 = " ";
          _os_log_impl(&dword_1830D4000, v28, v36, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v28 = (id)gLogObj;
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v55 = "nw_protocol_instance_add_new_flow";
          __int16 v56 = 2082;
          os_log_type_t v57 = v11 + 407;
          __int16 v58 = 2080;
          size_t v59 = " ";
          _os_log_impl(&dword_1830D4000, v28, v42, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v27) {
      goto LABEL_64;
    }
LABEL_63:
    free(v27);
    goto LABEL_64;
  }
  if ((v11[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v24 = (id)gLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v55 = "nw_protocol_instance_add_new_flow";
      __int16 v56 = 2082;
      os_log_type_t v57 = v11 + 407;
      __int16 v58 = 2080;
      size_t v59 = " ";
      _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot add new flows to a non-multiplexing protocol", buf, 0x20u);
    }
  }
LABEL_14:
  uint64_t v25 = 0;
LABEL_66:

  return v25;
}

void sub_18339E644(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_instance_set_flow_for_key(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a1;
  BOOL v6 = v5;
  if (!v5)
  {
    os_log_type_t v29 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    unint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v23 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v30, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (!v46)
      {
        uint64_t v23 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v43, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v35 = type;
      BOOL v36 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        __int16 v50 = 2082;
        uint64_t v51 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
    goto LABEL_52;
  }
  if (!a2)
  {
    BOOL v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    unint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v23 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s called with null key", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (!v46)
      {
        uint64_t v23 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v44, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v37, "%{public}s called with null key, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        __int16 v50 = 2082;
        uint64_t v51 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v23, v37, "%{public}s called with null key, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
    goto LABEL_52;
  }
  if (!a3)
  {
    int v33 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    unint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v23 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null flow", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (!v46)
      {
        uint64_t v23 = __nwlog_obj();
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v45, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v40 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_1830D4000, v23, v39, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        __int16 v50 = 2082;
        uint64_t v51 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v23, v39, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
LABEL_52:
    if (v22) {
      free(v22);
    }
    goto LABEL_29;
  }
  if (nw_protocol_definition_get_variant(v5[1]) != 3)
  {
    if (*((char *)v6 + 405) < 0) {
      goto LABEL_29;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
      __int16 v50 = 2082;
      uint64_t v51 = (uint64_t)v6 + 407;
      __int16 v52 = 2080;
      BOOL v53 = " ";
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot use custom flow mapping table on a non-multiplexing protocol", buf, 0x20u);
    }
LABEL_28:

    goto LABEL_29;
  }
  size_t v7 = *(unsigned int *)(*((void *)v6[1] + 10) + 256);
  if (!v7)
  {
    if (*((char *)v6 + 405) < 0) {
      goto LABEL_29;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
      __int16 v50 = 2082;
      uint64_t v51 = (uint64_t)v6 + 407;
      __int16 v52 = 2080;
      BOOL v53 = " ";
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sThe size of the key data in the protocol definition must be specified before using the custom flow map. See nw_protocol_definition_set_custom_flow_map_key_size.", buf, 0x20u);
    }
    goto LABEL_28;
  }
  if (v6[30]) {
    goto LABEL_9;
  }
  uint64_t internal = nw_hash_table_create_internal(0x1Fu, 8, (const void *(*)(const void *, unsigned int *))nw_protocol_custom_mapping_get_key, (unsigned int (*)(const void *, unsigned int))nw_protocol_custom_mapping_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_custom_mapping_matches_key, nw_protocol_custom_mapping_release_object);
  if (!internal)
  {
    v6[30] = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    unint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46)) {
      goto LABEL_52;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v23 = (id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s nw_hash_table_create_no_lock failed", buf, 0xCu);
      }
LABEL_51:

      goto LABEL_52;
    }
    if (!v46)
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v23 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v27 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s nw_hash_table_create_no_lock failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_51;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
      __int16 v50 = 2082;
      uint64_t v51 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_45:

    free(backtrace_string);
    goto LABEL_52;
  }
  *(_DWORD *)(internal + 48) &= ~2u;
  v6[30] = (void *)internal;
LABEL_9:
  id v9 = malloc_type_calloc(1uLL, v7 + 4, 0xEAFB8F1AuLL);
  if (v9)
  {
LABEL_10:
    _DWORD *v9 = v7;
    memcpy(v9 + 1, a2, v7);
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    uint64_t v10 = nw_hash_table_add_object((uint64_t)v6[30], (uint64_t)v9, (char *)&type);
    if (type) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    uint64_t v12 = !v11;
    if (!v11)
    {
      *(void *)(v10 + 32) = a3;
      uint64_t v13 = 1;
      if (*((char *)v6 + 405) < 0 || !gLogDatapath) {
        goto LABEL_30;
      }
      id v14 = __nwlog_obj();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136447234;
      os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
      __int16 v50 = 2082;
      uint64_t v51 = (uint64_t)v6 + 407;
      __int16 v52 = 2080;
      BOOL v53 = " ";
      __int16 v54 = 2048;
      uint64_t v55 = a2;
      __int16 v56 = 2048;
      uint64_t v57 = a3;
      char v15 = "%{public}s %{public}s%sAdded key %p to custom flow mapping table for flow id: %llx";
      int v16 = v14;
      os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
      uint32_t v18 = 52;
      goto LABEL_34;
    }
    if ((*((char *)v6 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v14 = (id)gLogObj;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
LABEL_35:

        uint64_t v13 = v12;
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446978;
      os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
      __int16 v50 = 2082;
      uint64_t v51 = (uint64_t)v6 + 407;
      __int16 v52 = 2080;
      BOOL v53 = " ";
      __int16 v54 = 2048;
      uint64_t v55 = a2;
      char v15 = "%{public}s %{public}s%sFailed to add key %p to custom flow mapping table";
      int v16 = v14;
      os_log_type_t v17 = OS_LOG_TYPE_ERROR;
      uint32_t v18 = 42;
LABEL_34:
      _os_log_impl(&dword_1830D4000, v16, v17, v15, buf, v18);
      goto LABEL_35;
    }
LABEL_29:
    uint64_t v13 = 0;
LABEL_30:

    return v13;
  }
  uint64_t v41 = __nwlog_obj();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v49 = "strict_calloc";
  __int16 v50 = 2048;
  uint64_t v51 = 1;
  __int16 v52 = 2048;
  BOOL v53 = (const char *)(v7 + 4);
  os_log_type_t v42 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v42);
  if (!result)
  {
    free(v42);
    goto LABEL_10;
  }
  __break(1u);
  return result;
}

void sub_18339F388(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_definition_get_variant(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[16];
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_protocol_definition_get_variant";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_protocol_definition_get_variant";
          __int16 v17 = 2082;
          uint32_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_flow_listener_new_flow(uint64_t a1, void *a2, void *a3)
{
  uint64_t v262 = *MEMORY[0x1E4F143B8];
  id v239 = a2;
  id v240 = a3;
  id v5 = *(id *)(*(void *)(a1 + 24) + 160);
  if (!v5)
  {
    os_log_type_t v129 = 0;
    uint64_t v187 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v245 = "nw_flow_listener_new_flow";
    uint64_t v188 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v242 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v188, &type, &v242))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v189 = __nwlog_obj();
        os_log_type_t v190 = type;
        if (os_log_type_enabled(v189, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v245 = "nw_flow_listener_new_flow";
          _os_log_impl(&dword_1830D4000, v189, v190, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v242)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v189 = __nwlog_obj();
        os_log_type_t v192 = type;
        BOOL v193 = os_log_type_enabled(v189, type);
        if (backtrace_string)
        {
          if (v193)
          {
            *(_DWORD *)buf = 136446466;
            size_t v245 = "nw_flow_listener_new_flow";
            __int16 v246 = 2082;
            uint64_t v247 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v189, v192, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_204;
        }
        if (v193)
        {
          *(_DWORD *)buf = 136446210;
          size_t v245 = "nw_flow_listener_new_flow";
          _os_log_impl(&dword_1830D4000, v189, v192, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v189 = __nwlog_obj();
        os_log_type_t v201 = type;
        if (os_log_type_enabled(v189, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v245 = "nw_flow_listener_new_flow";
          _os_log_impl(&dword_1830D4000, v189, v201, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_204:
    if (v188) {
      free(v188);
    }
    uint64_t v22 = 0;
    goto LABEL_124;
  }
  id v238 = v5;
  BOOL v6 = (NWConcrete_nw_endpoint_handler *)v5;
  uint64_t mode = v6->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v35 = (id)gLogObj;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5) {
        BOOL v36 = "unknown-mode";
      }
      else {
        BOOL v36 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      size_t v245 = "nw_flow_listener_new_flow";
      __int16 v246 = 2082;
      uint64_t v247 = (uint64_t)v36;
      __int16 v248 = 2082;
      uint64_t v249 = (uint64_t)"flow";
      _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

    uint64_t v22 = 0;
    goto LABEL_123;
  }
  os_log_type_t v8 = nw_endpoint_handler_copy_flow(v6);
  os_log_type_t v236 = (uint64_t *)v8;
  if (!*((void *)v8 + 96))
  {
    os_log_type_t v37 = v6;
    char v38 = *((unsigned char *)v37 + 268);

    if ((v38 & 0x20) == 0)
    {
      os_log_type_t v39 = v6;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v40 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        uint64_t v41 = v37;

        os_log_type_t v42 = v41;
        char v43 = *((unsigned char *)v37 + 268);

        if (v43) {
          os_log_type_t v44 = "dry-run ";
        }
        else {
          os_log_type_t v44 = "";
        }
        nw_endpoint_t v45 = nw_endpoint_handler_copy_endpoint(v42);
        logging_description = nw_endpoint_get_logging_description(v45);
        id_str = v41->id_str;
        BOOL v48 = v42;
        os_log_type_t v49 = v48;
        uint64_t v50 = v48[30];
        if (v50 > 5) {
          uint64_t v51 = "unknown-state";
        }
        else {
          uint64_t v51 = off_1E523FB38[v50];
        }

        size_t v61 = v49;
        uint64_t v62 = v61;
        BOOL v63 = "path";
        switch(v39->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v63 = "resolver";
            break;
          case 2:
            BOOL v63 = nw_endpoint_flow_mode_string(v61[31]);
            break;
          case 3:
            BOOL v63 = "proxy";
            break;
          case 4:
            BOOL v63 = "fallback";
            break;
          case 5:
            BOOL v63 = "transform";
            break;
          default:
            BOOL v63 = "unknown-mode";
            break;
        }

        uint64_t v127 = v62;
        os_unfair_lock_lock((os_unfair_lock_t)v127 + 28);
        id v128 = v127[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v127 + 28);

        *(_DWORD *)buf = 136447746;
        size_t v245 = "nw_flow_listener_new_flow";
        __int16 v246 = 2082;
        uint64_t v247 = (uint64_t)id_str;
        __int16 v248 = 2082;
        uint64_t v249 = (uint64_t)v44;
        __int16 v250 = 2082;
        int v251 = logging_description;
        __int16 v252 = 2082;
        uint64_t v253 = v51;
        __int16 v254 = 2082;
        os_log_type_t v255 = v63;
        __int16 v256 = 2114;
        id v257 = v128;
        _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive new flows on non-multiplexed protocols", buf, 0x48u);
      }
    }
    goto LABEL_120;
  }
  id v9 = (char *)malloc_type_calloc(1uLL, 0x150uLL, 0xEAFB8F1AuLL);
  os_log_type_t v237 = v9;
  if (v9)
  {
LABEL_5:
    nw_endpoint_flow_initialize_protocol(v6, v9, 1);
    uint64_t v10 = *((void *)v8 + 97);
    uint64_t log = v10;
    if (v10)
    {
      if (v9)
      {
        if ((char *)v10 != v9)
        {
          BOOL v11 = *(void **)(v10 + 24);
          if (v11 && *v11)
          {
            if (nw_protocol_add_input_handler(v10, (uint64_t)v9))
            {
              uint64_t v12 = v10;
              char v13 = *(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)(v10 + 24) + 224);
              if (v13)
              {
                uint64_t v14 = v13(v10, 255, v237);
                char v15 = (void *)v14;
                if (v14)
                {
                  uint64_t v16 = *(void *)(v14 + 24) - *(void *)(v14 + 16);
                  if (v16)
                  {
                    uint64_t v17 = nw_array_get_object_at_index(v14, (v16 >> 3) - 1);
                    uint32_t v18 = (void *)*((void *)v237 + 30);
                    *((void *)v237 + 30) = v17;
                  }
                }

                uint64_t v12 = v10;
              }
              uint64_t v20 = v236;
              uint64_t v19 = (uint64_t)v237;
              if (*((void *)v237 + 30))
              {
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                BOOL v21 = !nw_hash_table_add_object(v236[108], (uint64_t)v237, (char *)&type) || type == OS_LOG_TYPE_DEFAULT;
                uint64_t v22 = !v21;
                if (!v21)
                {
                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                  if (minimize_logging)
                  {
                    if (logging_disabled) {
                      goto LABEL_31;
                    }
                    os_log_type_t v210 = v6;
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v25 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v6);
                      uint64_t v212 = nw_endpoint_handler_dry_run_string(v6);
                      nw_endpoint_t v213 = nw_endpoint_handler_copy_endpoint(v6);
                      BOOL v214 = nw_endpoint_get_logging_description(v213);
                      os_log_type_t v215 = nw_endpoint_handler_state_string(v6);
                      os_log_type_t v216 = nw_endpoint_handler_mode_string(v6);
                      id v217 = nw_endpoint_handler_copy_current_path(v210);
                      uint64_t v218 = *(void *)(log + 16);
                      *(_DWORD *)buf = 136448258;
                      size_t v245 = "nw_flow_listener_new_flow";
                      __int16 v246 = 2082;
                      uint64_t v247 = (uint64_t)id_string;
                      __int16 v248 = 2082;
                      uint64_t v249 = (uint64_t)v212;
                      __int16 v250 = 2082;
                      int v251 = v214;
                      __int16 v252 = 2082;
                      uint64_t v253 = v215;
                      __int16 v254 = 2082;
                      os_log_type_t v255 = v216;
                      __int16 v256 = 2114;
                      id v257 = v217;
                      __int16 v258 = 2048;
                      unint64_t v259 = v237;
                      __int16 v260 = 2080;
                      uint64_t v261 = v218;
                      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added inbound per-message protocol %p to %s", buf, 0x5Cu);
                    }
                  }
                  else
                  {
                    if (logging_disabled)
                    {
LABEL_31:
                      (*(void (**)(uint64_t, char *))(*(void *)(v12 + 24) + 24))(v12, v237);
                      *((_WORD *)v237 + 166) |= 0x400u;
LABEL_122:

LABEL_123:
                      os_log_type_t v129 = v238;
LABEL_124:

                      return v22;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v25 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
                    {
                      os_log_type_t v26 = nw_endpoint_handler_get_id_string(v6);
                      BOOL v27 = nw_endpoint_handler_dry_run_string(v6);
                      nw_endpoint_t v28 = nw_endpoint_handler_copy_endpoint(v6);
                      os_log_type_t v29 = nw_endpoint_get_logging_description(v28);
                      os_log_type_t v30 = nw_endpoint_handler_state_string(v6);
                      BOOL v31 = v6;
                      os_log_type_t v32 = nw_endpoint_handler_mode_string(v6);
                      id v33 = nw_endpoint_handler_copy_current_path(v31);
                      uint64_t v34 = *(void *)(log + 16);
                      *(_DWORD *)buf = 136448258;
                      size_t v245 = "nw_flow_listener_new_flow";
                      __int16 v246 = 2082;
                      uint64_t v247 = (uint64_t)v26;
                      __int16 v248 = 2082;
                      uint64_t v249 = (uint64_t)v27;
                      __int16 v250 = 2082;
                      int v251 = v29;
                      __int16 v252 = 2082;
                      uint64_t v253 = v30;
                      __int16 v254 = 2082;
                      os_log_type_t v255 = v32;
                      __int16 v256 = 2114;
                      id v257 = v33;
                      __int16 v258 = 2048;
                      unint64_t v259 = v237;
                      __int16 v260 = 2080;
                      uint64_t v261 = v34;
                      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added inbound per-message protocol %p to %s", buf, 0x5Cu);
                    }
                  }

                  uint64_t v20 = v236;
                  uint64_t v12 = log;
                  goto LABEL_31;
                }
                if (nw_endpoint_handler_get_logging_disabled(v6)) {
                  goto LABEL_164;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                id v84 = (id)gconnectionLogObj;
                id v85 = nw_endpoint_handler_get_id_string(v6);
                __int16 v86 = nw_endpoint_handler_dry_run_string(v6);
                nw_endpoint_t v87 = nw_endpoint_handler_copy_endpoint(v6);
                uint64_t v88 = nw_endpoint_get_logging_description(v87);
                uint64_t v89 = nw_endpoint_handler_state_string(v6);
                uint64_t v90 = v6;
                int v91 = nw_endpoint_handler_mode_string(v6);
                id v92 = nw_endpoint_handler_copy_current_path(v90);
                *(_DWORD *)buf = 136447746;
                size_t v245 = "nw_flow_listener_new_flow";
                __int16 v246 = 2082;
                uint64_t v247 = (uint64_t)v85;
                __int16 v248 = 2082;
                uint64_t v249 = (uint64_t)v86;
                __int16 v250 = 2082;
                int v251 = v88;
                __int16 v252 = 2082;
                uint64_t v253 = v89;
                __int16 v254 = 2082;
                os_log_type_t v255 = v91;
                BOOL v6 = v90;
                __int16 v256 = 2114;
                id v257 = v92;
                uint64_t v93 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v242 = OS_LOG_TYPE_ERROR;
                char v241 = 0;
                if (__nwlog_fault(v93, &v242, &v241))
                {
                  if (v242 == OS_LOG_TYPE_FAULT)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    size_t v94 = (id)gconnectionLogObj;
                    os_log_type_t v95 = v242;
                    if (os_log_type_enabled(v94, v242))
                    {
                      loga = v94;
                      int v96 = nw_endpoint_handler_get_id_string(v90);
                      size_t v97 = nw_endpoint_handler_dry_run_string(v90);
                      nw_endpoint_t v98 = nw_endpoint_handler_copy_endpoint(v90);
                      uint64_t v219 = v93;
                      uint64_t v99 = nw_endpoint_get_logging_description(v98);
                      unint64_t v100 = nw_endpoint_handler_state_string(v90);
                      int v101 = nw_endpoint_handler_mode_string(v90);
                      id v102 = nw_endpoint_handler_copy_current_path(v90);
                      *(_DWORD *)buf = 136447746;
                      size_t v245 = "nw_flow_listener_new_flow";
                      __int16 v246 = 2082;
                      uint64_t v247 = (uint64_t)v96;
                      __int16 v248 = 2082;
                      uint64_t v249 = (uint64_t)v97;
                      __int16 v250 = 2082;
                      int v251 = v99;
                      __int16 v252 = 2082;
                      uint64_t v253 = v100;
                      __int16 v254 = 2082;
                      os_log_type_t v255 = v101;
                      BOOL v6 = v90;
                      __int16 v256 = 2114;
                      id v257 = v102;
                      _os_log_impl(&dword_1830D4000, loga, v95, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table", buf, 0x48u);

                      uint64_t v93 = v219;
                      size_t v94 = loga;
                    }
                  }
                  else
                  {
                    if (v241)
                    {
                      uint64_t v141 = __nw_create_backtrace_string();
                      if (v141)
                      {
                        char v142 = (char *)v141;
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        BOOL v143 = (id)gconnectionLogObj;
                        os_log_type_t v144 = v242;
                        if (os_log_type_enabled(v143, v242))
                        {
                          os_log_t logc = v143;
                          BOOL v145 = nw_endpoint_handler_get_id_string(v90);
                          unint64_t v146 = nw_endpoint_handler_dry_run_string(v90);
                          size_t v147 = v145;
                          v221 = v93;
                          nw_endpoint_t v227 = nw_endpoint_handler_copy_endpoint(v90);
                          uint64_t v148 = nw_endpoint_get_logging_description(v227);
                          unint64_t v149 = nw_endpoint_handler_state_string(v90);
                          BOOL v150 = nw_endpoint_handler_mode_string(v90);
                          id v151 = nw_endpoint_handler_copy_current_path(v90);
                          *(_DWORD *)buf = 136448002;
                          size_t v245 = "nw_flow_listener_new_flow";
                          __int16 v246 = 2082;
                          uint64_t v247 = (uint64_t)v147;
                          __int16 v248 = 2082;
                          uint64_t v249 = (uint64_t)v146;
                          __int16 v250 = 2082;
                          int v251 = v148;
                          __int16 v252 = 2082;
                          uint64_t v253 = v149;
                          __int16 v254 = 2082;
                          os_log_type_t v255 = v150;
                          BOOL v6 = v90;
                          __int16 v256 = 2114;
                          id v257 = v151;
                          __int16 v258 = 2082;
                          unint64_t v259 = v142;
                          _os_log_impl(&dword_1830D4000, logc, v144, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table, dumping backtrace:%{public}s", buf, 0x52u);

                          uint64_t v93 = v221;
                          BOOL v143 = logc;
                        }

                        free(v142);
                        goto LABEL_162;
                      }
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      os_log_type_t v160 = (id)gconnectionLogObj;
                      os_log_type_t v178 = v242;
                      if (os_log_type_enabled(v160, v242))
                      {
                        os_log_type_t v223 = nw_endpoint_handler_get_id_string(v90);
                        BOOL v179 = nw_endpoint_handler_dry_run_string(v90);
                        loge = v160;
                        nw_endpoint_t v180 = nw_endpoint_handler_copy_endpoint(v90);
                        unsigned int v181 = v93;
                        uint64_t v182 = nw_endpoint_get_logging_description(v180);
                        unint64_t v183 = nw_endpoint_handler_state_string(v90);
                        uint64_t v184 = nw_endpoint_handler_mode_string(v90);
                        id v185 = nw_endpoint_handler_copy_current_path(v90);
                        *(_DWORD *)buf = 136447746;
                        size_t v245 = "nw_flow_listener_new_flow";
                        __int16 v246 = 2082;
                        uint64_t v247 = (uint64_t)v223;
                        __int16 v248 = 2082;
                        uint64_t v249 = (uint64_t)v179;
                        __int16 v250 = 2082;
                        int v251 = v182;
                        __int16 v252 = 2082;
                        uint64_t v253 = v183;
                        __int16 v254 = 2082;
                        os_log_type_t v255 = v184;
                        BOOL v6 = v90;
                        __int16 v256 = 2114;
                        id v257 = v185;
                        _os_log_impl(&dword_1830D4000, loge, v178, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table, no backtrace", buf, 0x48u);

                        uint64_t v93 = v181;
                        os_log_type_t v160 = loge;
                      }
                    }
                    else
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      os_log_type_t v160 = (id)gconnectionLogObj;
                      os_log_type_t v161 = v242;
                      if (os_log_type_enabled(v160, v242))
                      {
                        BOOL v222 = nw_endpoint_handler_get_id_string(v90);
                        xpc_object_t v162 = nw_endpoint_handler_dry_run_string(v90);
                        os_log_t logd = v160;
                        nw_endpoint_t v163 = nw_endpoint_handler_copy_endpoint(v90);
                        long long v164 = v93;
                        uint64_t v165 = nw_endpoint_get_logging_description(v163);
                        uint64_t v166 = nw_endpoint_handler_state_string(v90);
                        unint64_t v167 = nw_endpoint_handler_mode_string(v90);
                        id v168 = nw_endpoint_handler_copy_current_path(v90);
                        *(_DWORD *)buf = 136447746;
                        size_t v245 = "nw_flow_listener_new_flow";
                        __int16 v246 = 2082;
                        uint64_t v247 = (uint64_t)v222;
                        __int16 v248 = 2082;
                        uint64_t v249 = (uint64_t)v162;
                        __int16 v250 = 2082;
                        int v251 = v165;
                        __int16 v252 = 2082;
                        uint64_t v253 = v166;
                        __int16 v254 = 2082;
                        os_log_type_t v255 = v167;
                        BOOL v6 = v90;
                        __int16 v256 = 2114;
                        id v257 = v168;
                        _os_log_impl(&dword_1830D4000, logd, v161, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table, backtrace limit exceeded", buf, 0x48u);

                        uint64_t v93 = v164;
                        os_log_type_t v160 = logd;
                      }
                    }
                  }
                }
LABEL_162:
                if (v93) {
                  free(v93);
                }
LABEL_164:
                nw_endpoint_flow_cleanup_protocol(v6, (uint64_t)v237, 1);
                uint64_t v186 = (void *)*((void *)v237 + 23);
                *((void *)v237 + 23) = 0;

                free(v237);
                goto LABEL_121;
              }
              if (nw_endpoint_handler_get_logging_disabled(v6)) {
                goto LABEL_156;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              id v64 = (id)gconnectionLogObj;
              unint64_t v65 = nw_endpoint_handler_get_id_string(v6);
              BOOL v66 = nw_endpoint_handler_dry_run_string(v6);
              nw_endpoint_t v67 = nw_endpoint_handler_copy_endpoint(v6);
              unint64_t v68 = nw_endpoint_get_logging_description(v67);
              uint64_t v69 = nw_endpoint_handler_state_string(v6);
              uint64_t v70 = v6;
              os_log_type_t v71 = nw_endpoint_handler_mode_string(v6);
              id v72 = nw_endpoint_handler_copy_current_path(v70);
              *(_DWORD *)buf = 136447746;
              size_t v245 = "nw_flow_listener_new_flow";
              __int16 v246 = 2082;
              uint64_t v247 = (uint64_t)v65;
              __int16 v248 = 2082;
              uint64_t v249 = (uint64_t)v66;
              __int16 v250 = 2082;
              int v251 = v68;
              __int16 v252 = 2082;
              uint64_t v253 = v69;
              __int16 v254 = 2082;
              os_log_type_t v255 = v71;
              BOOL v6 = v70;
              __int16 v256 = 2114;
              id v257 = v72;
              uint64_t v73 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              os_log_type_t v242 = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v73, &type, &v242))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  long long v74 = (id)gconnectionLogObj;
                  os_log_type_t v75 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    BOOL v76 = nw_endpoint_handler_get_id_string(v70);
                    long long v77 = nw_endpoint_handler_dry_run_string(v70);
                    nw_endpoint_t v78 = nw_endpoint_handler_copy_endpoint(v70);
                    BOOL v224 = v73;
                    uint64_t v79 = nw_endpoint_get_logging_description(v78);
                    char v80 = nw_endpoint_handler_state_string(v70);
                    uint64_t v81 = nw_endpoint_handler_mode_string(v70);
                    id v82 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    size_t v245 = "nw_flow_listener_new_flow";
                    __int16 v246 = 2082;
                    uint64_t v247 = (uint64_t)v76;
                    __int16 v248 = 2082;
                    uint64_t v249 = (uint64_t)v77;
                    __int16 v250 = 2082;
                    int v251 = v79;
                    __int16 v252 = 2082;
                    uint64_t v253 = v80;
                    __int16 v254 = 2082;
                    os_log_type_t v255 = v81;
                    BOOL v6 = v70;
                    __int16 v256 = 2114;
                    id v257 = v82;
                    _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata", buf, 0x48u);

                    uint64_t v73 = v224;
                  }
                }
                else if (v242)
                {
                  uint64_t v131 = __nw_create_backtrace_string();
                  if (v131)
                  {
                    uint64_t v132 = (char *)v131;
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    os_log_type_t v133 = (id)gconnectionLogObj;
                    os_log_type_t v134 = type;
                    if (os_log_type_enabled(v133, type))
                    {
                      uint64_t v135 = nw_endpoint_handler_get_id_string(v70);
                      long long v136 = nw_endpoint_handler_dry_run_string(v70);
                      BOOL v226 = v73;
                      nw_endpoint_t logb = nw_endpoint_handler_copy_endpoint(v70);
                      uint64_t v137 = nw_endpoint_get_logging_description(logb);
                      uint64_t v138 = nw_endpoint_handler_state_string(v70);
                      uint64_t v139 = nw_endpoint_handler_mode_string(v70);
                      id v140 = nw_endpoint_handler_copy_current_path(v70);
                      *(_DWORD *)buf = 136448002;
                      size_t v245 = "nw_flow_listener_new_flow";
                      __int16 v246 = 2082;
                      uint64_t v247 = (uint64_t)v135;
                      __int16 v248 = 2082;
                      uint64_t v249 = (uint64_t)v136;
                      __int16 v250 = 2082;
                      int v251 = v137;
                      __int16 v252 = 2082;
                      uint64_t v253 = v138;
                      __int16 v254 = 2082;
                      os_log_type_t v255 = v139;
                      BOOL v6 = v70;
                      __int16 v256 = 2114;
                      id v257 = v140;
                      __int16 v258 = 2082;
                      unint64_t v259 = v132;
                      _os_log_impl(&dword_1830D4000, v133, v134, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, dumping backtrace:%{public}s", buf, 0x52u);

                      uint64_t v73 = v226;
                    }

                    free(v132);
                    goto LABEL_154;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  long long v74 = (id)gconnectionLogObj;
                  os_log_type_t v169 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    uint64_t v170 = nw_endpoint_handler_get_id_string(v70);
                    os_log_type_t v171 = nw_endpoint_handler_dry_run_string(v70);
                    nw_endpoint_t v172 = nw_endpoint_handler_copy_endpoint(v70);
                    int v229 = v73;
                    unint64_t v173 = nw_endpoint_get_logging_description(v172);
                    BOOL v174 = nw_endpoint_handler_state_string(v70);
                    int v175 = nw_endpoint_handler_mode_string(v70);
                    id v176 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    size_t v245 = "nw_flow_listener_new_flow";
                    __int16 v246 = 2082;
                    uint64_t v247 = (uint64_t)v170;
                    __int16 v248 = 2082;
                    uint64_t v249 = (uint64_t)v171;
                    __int16 v250 = 2082;
                    int v251 = v173;
                    __int16 v252 = 2082;
                    uint64_t v253 = v174;
                    __int16 v254 = 2082;
                    os_log_type_t v255 = v175;
                    BOOL v6 = v70;
                    __int16 v256 = 2114;
                    id v257 = v176;
                    _os_log_impl(&dword_1830D4000, v74, v169, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, no backtrace", buf, 0x48u);

                    uint64_t v73 = v229;
                  }
                }
                else
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  long long v74 = (id)gconnectionLogObj;
                  os_log_type_t v152 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    uint64_t v153 = nw_endpoint_handler_get_id_string(v70);
                    os_log_type_t v154 = nw_endpoint_handler_dry_run_string(v70);
                    nw_endpoint_t v155 = nw_endpoint_handler_copy_endpoint(v70);
                    uint64_t v228 = v73;
                    uint64_t v156 = nw_endpoint_get_logging_description(v155);
                    long long v157 = nw_endpoint_handler_state_string(v70);
                    uint64_t v158 = nw_endpoint_handler_mode_string(v70);
                    id v159 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    size_t v245 = "nw_flow_listener_new_flow";
                    __int16 v246 = 2082;
                    uint64_t v247 = (uint64_t)v153;
                    __int16 v248 = 2082;
                    uint64_t v249 = (uint64_t)v154;
                    __int16 v250 = 2082;
                    int v251 = v156;
                    __int16 v252 = 2082;
                    uint64_t v253 = v157;
                    __int16 v254 = 2082;
                    os_log_type_t v255 = v158;
                    BOOL v6 = v70;
                    __int16 v256 = 2114;
                    id v257 = v159;
                    _os_log_impl(&dword_1830D4000, v74, v152, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, backtrace limit exceeded", buf, 0x48u);

                    uint64_t v73 = v228;
                  }
                }
              }
LABEL_154:
              uint64_t v19 = (uint64_t)v237;
              if (v73) {
                free(v73);
              }
LABEL_156:
              nw_endpoint_flow_cleanup_protocol(v6, v19, 1);
              uint64_t v177 = *(void **)(v19 + 184);
              *(void *)(v19 + 184) = 0;

LABEL_112:
              free(v237);
LABEL_120:
              uint64_t v22 = 0;
LABEL_121:
              uint64_t v20 = v236;
              goto LABEL_122;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v56 = (id)gLogObj;
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              size_t v245 = "nw_protocol_utilities_add_input_handler";
              __int16 v246 = 2048;
              uint64_t v247 = v10;
              _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
            }
          }
LABEL_92:
          uint64_t v104 = v6;
          BOOL v105 = (*((unsigned char *)v104 + 268) & 0x20) == 0;

          if (v105)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v106 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
            {
              uint64_t v107 = v104;

              long long v108 = v107;
              BOOL v109 = (*((unsigned char *)v104 + 268) & 1) == 0;

              if (v109) {
                os_log_type_t v110 = "";
              }
              else {
                os_log_type_t v110 = "dry-run ";
              }
              nw_endpoint_t v111 = nw_endpoint_handler_copy_endpoint(v108);
              uint32_t v112 = nw_endpoint_get_logging_description(v111);
              size_t v113 = v108;
              size_t v114 = v113;
              uint64_t v115 = v113[30];
              if (v115 > 5) {
                uint64_t v116 = "unknown-state";
              }
              else {
                uint64_t v116 = off_1E523FB38[v115];
              }
              os_log_type_t v225 = v116;

              uint64_t v117 = v114;
              uint64_t v118 = "path";
              switch(v6->mode)
              {
                case 0:
                  break;
                case 1:
                  uint64_t v118 = "resolver";
                  break;
                case 2:
                  uint64_t v118 = nw_endpoint_flow_mode_string(v117[31]);
                  break;
                case 3:
                  uint64_t v118 = "proxy";
                  break;
                case 4:
                  uint64_t v118 = "fallback";
                  break;
                case 5:
                  uint64_t v118 = "transform";
                  break;
                default:
                  uint64_t v118 = "unknown-mode";
                  break;
              }
              uint64_t v220 = v118;

              uint64_t v119 = v106;
              size_t v120 = v112;
              os_log_type_t v121 = v117;
              os_unfair_lock_lock((os_unfair_lock_t)v121 + 28);
              id v122 = v121[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v121 + 28);

              size_t v123 = v120;
              int v106 = v119;
              os_log_type_t v124 = (char *)*((void *)v237 + 2);
              uint64_t v125 = *(void *)(log + 16);
              *(_DWORD *)buf = 136448258;
              size_t v245 = "nw_flow_listener_new_flow";
              __int16 v246 = 2082;
              uint64_t v247 = (uint64_t)v107->id_str;
              __int16 v248 = 2082;
              uint64_t v249 = (uint64_t)v110;
              __int16 v250 = 2082;
              int v251 = v123;
              __int16 v252 = 2082;
              uint64_t v253 = v225;
              __int16 v254 = 2082;
              os_log_type_t v255 = v220;
              __int16 v256 = 2114;
              id v257 = v122;
              __int16 v258 = 2082;
              unint64_t v259 = v124;
              __int16 v260 = 2082;
              uint64_t v261 = v125;
              _os_log_impl(&dword_1830D4000, v119, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound protocol %{public}s to %{public}s", buf, 0x5Cu);
            }
          }
          nw_endpoint_flow_cleanup_protocol(v104, (uint64_t)v237, 1);
          size_t v126 = (void *)*((void *)v237 + 23);
          *((void *)v237 + 23) = 0;

          goto LABEL_112;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v52 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        size_t v245 = "nw_protocol_utilities_add_input_handler";
        __int16 v246 = 2048;
        uint64_t v247 = (uint64_t)v9;
        BOOL v53 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v242 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v53, &type, &v242)) {
          goto LABEL_90;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v54 = (id)gLogObj;
          os_log_type_t v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            size_t v245 = "nw_protocol_utilities_add_input_handler";
            __int16 v246 = 2048;
            uint64_t v247 = (uint64_t)v237;
            _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
          }
        }
        else if (v242)
        {
          uint64_t v57 = __nw_create_backtrace_string();
          if (v57)
          {
            uint64_t v58 = (char *)v57;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            size_t v59 = (id)gLogObj;
            os_log_type_t v60 = type;
            if (os_log_type_enabled(v59, type))
            {
              *(_DWORD *)buf = 136446722;
              size_t v245 = "nw_protocol_utilities_add_input_handler";
              __int16 v246 = 2048;
              uint64_t v247 = (uint64_t)v237;
              __int16 v248 = 2082;
              uint64_t v249 = (uint64_t)v58;
              _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v58);
            if (!v53) {
              goto LABEL_92;
            }
            goto LABEL_91;
          }
          __int16 v54 = __nwlog_obj();
          os_log_type_t v103 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            size_t v245 = "nw_protocol_utilities_add_input_handler";
            __int16 v246 = 2048;
            uint64_t v247 = (uint64_t)v237;
            _os_log_impl(&dword_1830D4000, v54, v103, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v54 = (id)gLogObj;
          os_log_type_t v83 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            size_t v245 = "nw_protocol_utilities_add_input_handler";
            __int16 v246 = 2048;
            uint64_t v247 = (uint64_t)v237;
            _os_log_impl(&dword_1830D4000, v54, v83, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
          }
        }
        goto LABEL_89;
      }
      os_log_type_t v199 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v245 = "nw_protocol_utilities_add_input_handler";
      BOOL v53 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v242 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v53, &type, &v242))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v54 = __nwlog_obj();
          os_log_type_t v200 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            size_t v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_1830D4000, v54, v200, "%{public}s called with null input_protocol", buf, 0xCu);
          }
        }
        else if (v242)
        {
          nw_endpoint_t v205 = (char *)__nw_create_backtrace_string();
          __int16 v54 = __nwlog_obj();
          os_log_type_t v206 = type;
          BOOL v207 = os_log_type_enabled(v54, type);
          if (v205)
          {
            if (v207)
            {
              *(_DWORD *)buf = 136446466;
              size_t v245 = "nw_protocol_utilities_add_input_handler";
              __int16 v246 = 2082;
              uint64_t v247 = (uint64_t)v205;
              _os_log_impl(&dword_1830D4000, v54, v206, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v205);
            if (!v53) {
              goto LABEL_92;
            }
            goto LABEL_91;
          }
          if (v207)
          {
            *(_DWORD *)buf = 136446210;
            size_t v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_1830D4000, v54, v206, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __int16 v54 = __nwlog_obj();
          os_log_type_t v209 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            size_t v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_1830D4000, v54, v209, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_89;
      }
LABEL_90:
      if (!v53) {
        goto LABEL_92;
      }
LABEL_91:
      free(v53);
      goto LABEL_92;
    }
    uint64_t v197 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v245 = "nw_protocol_utilities_add_input_handler";
    BOOL v53 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v242 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v53, &type, &v242)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v54 = __nwlog_obj();
      os_log_type_t v198 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_1830D4000, v54, v198, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v242)
    {
      uint64_t v202 = (char *)__nw_create_backtrace_string();
      __int16 v54 = __nwlog_obj();
      os_log_type_t v203 = type;
      BOOL v204 = os_log_type_enabled(v54, type);
      if (v202)
      {
        if (v204)
        {
          *(_DWORD *)buf = 136446466;
          size_t v245 = "nw_protocol_utilities_add_input_handler";
          __int16 v246 = 2082;
          uint64_t v247 = (uint64_t)v202;
          _os_log_impl(&dword_1830D4000, v54, v203, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v202);
        goto LABEL_90;
      }
      if (v204)
      {
        *(_DWORD *)buf = 136446210;
        size_t v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_1830D4000, v54, v203, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v54 = __nwlog_obj();
      os_log_type_t v208 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_1830D4000, v54, v208, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_89:

    goto LABEL_90;
  }
  uint64_t v194 = v8;
  nw_protocol_options_t v195 = __nwlog_obj();
  os_log_type_enabled(v195, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  size_t v245 = "strict_calloc";
  __int16 v246 = 2048;
  uint64_t v247 = 1;
  __int16 v248 = 2048;
  uint64_t v249 = 336;
  uint64_t v196 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v196);
  if (!result)
  {
    free(v196);
    os_log_type_t v8 = v194;
    id v9 = 0;
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

void sub_1833A1754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23)
{
  _Unwind_Resume(a1);
}

void *nw_connection_create_from_protocol_on_nw_queue(void *a1, void *a2, nw_protocol *a3)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  nw_allow_use_of_dispatch_internal();
  nw_endpoint_t v111 = v5;
  if (v5)
  {
    if (v6)
    {
      size_t v7 = v6;
      id v8 = *(id *)(v7[13] + 136);

      nw_context_assert_queue(v8);
      id v9 = v7;
      BOOL v10 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v9, 0, 0);
      id v110 = v6;

      if (v10)
      {
        BOOL v11 = (id)v10;
        v11[12] = v11[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;

        uint64_t v12 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]((void **)[NWConcrete_nw_connection alloc], v5, v11, 0);
        uint64_t v13 = v12;
        if (v12)
        {
          uint64_t v14 = *(void *)(v12 + 8);
          uint64_t v15 = *(void *)(v12 + 16);
          nw_allow_use_of_dispatch_internal();
          if (has_modifiers == 1)
          {
            os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
            uint64_t v16 = (void *)g_modifier_list;
            if (g_modifier_list)
            {
              while (1)
              {
                uint64_t v17 = (uint64_t (*)(uint64_t, uint64_t))v16[2];
                if (v17)
                {
                  if (v17(v14, v15)) {
                    break;
                  }
                }
                uint64_t v16 = (void *)*v16;
                if (!v16) {
                  goto LABEL_7;
                }
              }
              os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
              uint64_t v18 = *(void *)(v13 + 16);
              if (!v18)
              {
                BOOL v21 = 0;
LABEL_19:
                *(unsigned char *)(v13 + 109) |= 4u;
                unsigned int v22 = *(_DWORD *)(v13 + 448);
                id v23 = *(id *)(v13 + 8);
                id v24 = v21;
                long long v108 = v24;
                BOOL v109 = (id)v13;
                if (!v23)
                {
                  nw_endpoint_t v87 = __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                  uint64_t v88 = (char *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v112 = 0;
                  if (!__nwlog_fault(v88, &type, &v112)) {
                    goto LABEL_193;
                  }
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v89 = __nwlog_obj();
                    os_log_type_t v90 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null endpoint", buf, 0xCu);
                    }
                  }
                  else if (v112)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    uint64_t v89 = __nwlog_obj();
                    os_log_type_t v94 = type;
                    BOOL v95 = os_log_type_enabled(v89, type);
                    if (backtrace_string)
                    {
                      if (v95)
                      {
                        *(_DWORD *)buf = 136446466;
                        uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        __int16 v116 = 2082;
                        *(void *)uint64_t v117 = backtrace_string;
                        _os_log_impl(&dword_1830D4000, v89, v94, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      free(backtrace_string);
                      if (!v88) {
                        goto LABEL_195;
                      }
                      goto LABEL_194;
                    }
                    if (v95)
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_1830D4000, v89, v94, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
                    }
                  }
                  else
                  {
                    uint64_t v89 = __nwlog_obj();
                    os_log_type_t v101 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_1830D4000, v89, v101, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
                    }
                  }
                  goto LABEL_192;
                }
                if (v24)
                {
                  uint64_t v25 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]((id *)[NWConcrete_nw_endpoint_handler alloc], v23, v24, nw_connection_endpoint_report_on_nw_queue, v109, 0, v22);
                  os_log_type_t v26 = v25;
                  if (v25)
                  {
                    *((_DWORD *)v25 + 29) = 2;
                    id v27 = v25[9];
                    nw_endpoint_t v28 = objc_alloc_init(NWConcrete_nw_endpoint_flow);
                    *((unsigned char *)v28 + 32) = *((unsigned char *)v28 + 32) & 0xFC | (v27 == 0) | 2;
                    id v29 = v26[31];
                    v26[31] = v28;

                    if (nw_endpoint_flow_pre_attach_protocols(v26, a3))
                    {
                      os_log_type_t v30 = v26;
LABEL_103:

LABEL_104:
                      nw_endpoint_t v67 = (void *)v109[18];
                      v109[18] = v30;

                      uint64_t v68 = *(void *)(v13 + 16);
                      if (v109[18])
                      {
                        if (v68 && !nw_path_parameters_get_logging_disabled(*(void *)(v68 + 104)))
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          uint64_t v69 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
                          {
                            int v70 = *(_DWORD *)(v13 + 448);
                            logging_description = nw_endpoint_get_logging_description(v111);
                            *(_DWORD *)buf = 136446722;
                            uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
                            __int16 v116 = 1024;
                            *(_DWORD *)uint64_t v117 = v70;
                            *(_WORD *)&v117[4] = 2082;
                            *(void *)&v117[6] = logging_description;
                            _os_log_impl(&dword_1830D4000, v69, OS_LOG_TYPE_INFO, "%{public}s [C%u] create connection to %{public}s", buf, 0x1Cu);
                          }
                        }
                        size_t v59 = v109;
                        goto LABEL_121;
                      }
                      if (v68 && !nw_path_parameters_get_logging_disabled(*(void *)(v68 + 104)))
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        id v72 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                        {
                          int v73 = *(_DWORD *)(v13 + 448);
                          *(_DWORD *)buf = 136446466;
                          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
                          __int16 v116 = 1024;
                          *(_DWORD *)uint64_t v117 = v73;
                          _os_log_impl(&dword_1830D4000, v72, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Failed to create connection from listener", buf, 0x12u);
                        }
                      }
LABEL_120:
                      size_t v59 = 0;
LABEL_121:

                      goto LABEL_122;
                    }
                    if ((*((unsigned char *)v26 + 268) & 0x20) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      char v46 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                      {
                        if (*((unsigned char *)v26 + 268)) {
                          os_log_type_t v47 = "dry-run ";
                        }
                        else {
                          os_log_type_t v47 = "";
                        }
                        nw_endpoint_t v48 = nw_endpoint_handler_copy_endpoint(v26);
                        os_log_type_t v49 = nw_endpoint_get_logging_description(v48);
                        uint64_t v50 = *((unsigned int *)v26 + 30);
                        int v106 = v47;
                        nw_endpoint_t v107 = v48;
                        BOOL v105 = v49;
                        if (v50 > 5) {
                          uint64_t v51 = "unknown-state";
                        }
                        else {
                          uint64_t v51 = off_1E523FB38[v50];
                        }
                        os_log_type_t v103 = v51;
                        size_t v61 = v26;
                        uint64_t v62 = "path";
                        switch(*((_DWORD *)v26 + 29))
                        {
                          case 0:
                            break;
                          case 1:
                            uint64_t v62 = "resolver";
                            break;
                          case 2:
                            uint64_t v62 = nw_endpoint_flow_mode_string(v26[31]);
                            break;
                          case 3:
                            uint64_t v62 = "proxy";
                            break;
                          case 4:
                            uint64_t v62 = "fallback";
                            break;
                          case 5:
                            uint64_t v62 = "transform";
                            break;
                          default:
                            uint64_t v62 = "unknown-mode";
                            break;
                        }
                        uint64_t v104 = v62;

                        id v64 = v61 + 28;
                        unint64_t v65 = v61;
                        os_unfair_lock_lock(v61 + 28);
                        id v66 = v65[8];
                        os_unfair_lock_unlock(v64);

                        *(_DWORD *)buf = 136447746;
                        uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        __int16 v116 = 2082;
                        *(void *)uint64_t v117 = v26 + 21;
                        *(_WORD *)&v117[8] = 2082;
                        *(void *)&v117[10] = v106;
                        __int16 v118 = 2082;
                        uint64_t v119 = v105;
                        __int16 v120 = 2082;
                        os_log_type_t v121 = v103;
                        __int16 v122 = 2082;
                        size_t v123 = v104;
                        __int16 v124 = 2114;
                        id v125 = v66;
                        _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nw_endpoint_flow_pre_attach_protocols", buf, 0x48u);
                      }
                    }
                    nw_endpoint_handler_cancel(v26, 1, 0);
LABEL_102:
                    os_log_type_t v30 = 0;
                    goto LABEL_103;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v42 = (id)gLogObj;
                  *(_DWORD *)buf = 136446210;
                  uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                  char v43 = (char *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v112 = 0;
                  if (__nwlog_fault(v43, &type, &v112))
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v44 = (id)gLogObj;
                      os_log_type_t v45 = type;
                      if (os_log_type_enabled(v44, type))
                      {
                        *(_DWORD *)buf = 136446210;
                        uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed", buf, 0xCu);
                      }
                    }
                    else if (v112)
                    {
                      os_log_type_t v55 = (char *)__nw_create_backtrace_string();
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v44 = (id)gLogObj;
                      os_log_type_t v56 = type;
                      BOOL v57 = os_log_type_enabled(v44, type);
                      if (v55)
                      {
                        if (v57)
                        {
                          *(_DWORD *)buf = 136446466;
                          uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                          __int16 v116 = 2082;
                          *(void *)uint64_t v117 = v55;
                          _os_log_impl(&dword_1830D4000, v44, v56, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
                        }

                        free(v55);
                        if (!v43) {
                          goto LABEL_102;
                        }
                        goto LABEL_93;
                      }
                      if (v57)
                      {
                        *(_DWORD *)buf = 136446210;
                        uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl(&dword_1830D4000, v44, v56, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace", buf, 0xCu);
                      }
                    }
                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v44 = (id)gLogObj;
                      os_log_type_t v63 = type;
                      if (os_log_type_enabled(v44, type))
                      {
                        *(_DWORD *)buf = 136446210;
                        uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl(&dword_1830D4000, v44, v63, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded", buf, 0xCu);
                      }
                    }
                  }
                  if (!v43) {
                    goto LABEL_102;
                  }
LABEL_93:
                  free(v43);
                  goto LABEL_102;
                }
                int v91 = __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                uint64_t v88 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t type = OS_LOG_TYPE_ERROR;
                char v112 = 0;
                if (__nwlog_fault(v88, &type, &v112))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v89 = __nwlog_obj();
                    os_log_type_t v92 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_1830D4000, v89, v92, "%{public}s called with null parameters", buf, 0xCu);
                    }
LABEL_192:

                    goto LABEL_193;
                  }
                  if (!v112)
                  {
                    uint64_t v89 = __nwlog_obj();
                    os_log_type_t v102 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_1830D4000, v89, v102, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
                    }
                    goto LABEL_192;
                  }
                  int v96 = (char *)__nw_create_backtrace_string();
                  uint64_t v89 = __nwlog_obj();
                  os_log_type_t v97 = type;
                  BOOL v98 = os_log_type_enabled(v89, type);
                  if (!v96)
                  {
                    if (v98)
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_1830D4000, v89, v97, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
                    }
                    goto LABEL_192;
                  }
                  if (v98)
                  {
                    *(_DWORD *)buf = 136446466;
                    uint64_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                    __int16 v116 = 2082;
                    *(void *)uint64_t v117 = v96;
                    _os_log_impl(&dword_1830D4000, v89, v97, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v96);
                }
LABEL_193:
                if (!v88)
                {
LABEL_195:
                  os_log_type_t v30 = 0;
                  goto LABEL_104;
                }
LABEL_194:
                free(v88);
                goto LABEL_195;
              }
              if (!nw_path_parameters_get_logging_disabled(*(void *)(v18 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v19 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
                {
                  int v20 = *(_DWORD *)(v13 + 448);
                  *(_DWORD *)buf = 136446466;
                  uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
                  __int16 v116 = 1024;
                  *(_DWORD *)uint64_t v117 = v20;
                  _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Connection parameters were modified", buf, 0x12u);
                }
              }
            }
            else
            {
LABEL_7:
              os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
            }
          }
          BOOL v21 = *(void **)(v13 + 16);
          goto LABEL_19;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v35 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
        BOOL v36 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v112 = 0;
        if (__nwlog_fault(v36, &type, &v112))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v37 = (id)gLogObj;
            os_log_type_t v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s [nw_connection initWithEndpoint:parameters:] failed", buf, 0xCu);
            }
          }
          else if (v112)
          {
            id v52 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v37 = (id)gLogObj;
            os_log_type_t v53 = type;
            BOOL v54 = os_log_type_enabled(v37, type);
            if (v52)
            {
              if (v54)
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
                __int16 v116 = 2082;
                *(void *)uint64_t v117 = v52;
                _os_log_impl(&dword_1830D4000, v37, v53, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v52);
              if (!v36) {
                goto LABEL_120;
              }
              goto LABEL_85;
            }
            if (v54)
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v37, v53, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v37 = (id)gLogObj;
            os_log_type_t v60 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v37, v60, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        if (!v36) {
          goto LABEL_120;
        }
LABEL_85:
        free(v36);
        goto LABEL_120;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
      os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v112 = 0;
      if (__nwlog_fault(v32, &type, &v112))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v33 = (id)gLogObj;
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s nw_parameters_copy failed", buf, 0xCu);
          }
        }
        else if (v112)
        {
          os_log_type_t v39 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v33 = (id)gLogObj;
          os_log_type_t v40 = type;
          BOOL v41 = os_log_type_enabled(v33, type);
          if (v39)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
              __int16 v116 = 2082;
              *(void *)uint64_t v117 = v39;
              _os_log_impl(&dword_1830D4000, v33, v40, "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v39);
            if (!v32) {
              goto LABEL_74;
            }
            goto LABEL_73;
          }
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_1830D4000, v33, v40, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v33 = (id)gLogObj;
          os_log_type_t v58 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_1830D4000, v33, v58, "%{public}s nw_parameters_copy failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v32)
      {
LABEL_74:
        size_t v59 = 0;
LABEL_122:

        long long v74 = v110;
        goto LABEL_123;
      }
LABEL_73:
      free(v32);
      goto LABEL_74;
    }
    long long v74 = 0;
    char v80 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
    long long v77 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v112 = 0;
    if (__nwlog_fault(v77, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v78 = __nwlog_obj();
        os_log_type_t v81 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v78, v81, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_176:

        goto LABEL_177;
      }
      if (!v112)
      {
        nw_endpoint_t v78 = __nwlog_obj();
        os_log_type_t v100 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v78, v100, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_176;
      }
      id v82 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v78 = __nwlog_obj();
      os_log_type_t v85 = type;
      BOOL v86 = os_log_type_enabled(v78, type);
      if (!v82)
      {
        if (v86)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v78, v85, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_176;
      }
      if (v86)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
        __int16 v116 = 2082;
        *(void *)uint64_t v117 = v82;
        _os_log_impl(&dword_1830D4000, v78, v85, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_143;
    }
  }
  else
  {
    long long v74 = v6;
    BOOL v76 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
    long long v77 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v112 = 0;
    if (__nwlog_fault(v77, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v78 = __nwlog_obj();
        os_log_type_t v79 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_176;
      }
      if (!v112)
      {
        nw_endpoint_t v78 = __nwlog_obj();
        os_log_type_t v99 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v78, v99, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_176;
      }
      id v82 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v78 = __nwlog_obj();
      os_log_type_t v83 = type;
      BOOL v84 = os_log_type_enabled(v78, type);
      if (!v82)
      {
        if (v84)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v78, v83, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_176;
      }
      if (v84)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
        __int16 v116 = 2082;
        *(void *)uint64_t v117 = v82;
        _os_log_impl(&dword_1830D4000, v78, v83, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_143:

      free(v82);
    }
  }
LABEL_177:
  if (v77) {
    free(v77);
  }
  size_t v59 = 0;
LABEL_123:

  return v59;
}

void sub_1833A2FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_223(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v148 = *MEMORY[0x1E4F143B8];
  id v7 = a3;
  id v128 = a4;
  identifier = nw_protocol_definition_get_identifier(v7);
  uint64_t registered_endpoint = *(void *)(a1 + 96);
  if (registered_endpoint) {
    goto LABEL_74;
  }
  int v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  BOOL v11 = *(void **)(a1 + 40);
  uint64_t v12 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  uint64_t v13 = *(void **)(a1 + 48);
  id v14 = *(id *)(a1 + 32);
  id v122 = v11;
  id v124 = v12;
  id v126 = v13;
  __int16 v120 = v14;
  if (!v14)
  {
    BOOL v86 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v129 = 0;
    if (!__nwlog_fault(v33, &type, &v129)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v87 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v87, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (!v129)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v103 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v103, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_205;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v34 = __nwlog_obj();
    os_log_type_t v91 = type;
    BOOL v92 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v91, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (v92)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v132 = 2082;
      os_log_type_t v133 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v34, v91, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_172;
  }
  uint64_t v15 = (unsigned int *)v14;
  uint64_t v16 = v15[29];

  if (v16 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    if (v16 > 5) {
      os_log_type_t v26 = "unknown-mode";
    }
    else {
      os_log_type_t v26 = off_1E523FB08[v16];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    __int16 v132 = 2082;
    os_log_type_t v133 = (void *)v26;
    __int16 v134 = 2082;
    uint64_t v135 = "flow";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v129 = 0;
    if (__nwlog_fault(v33, &type, &v129))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v34 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          if (v16 > 5) {
            BOOL v36 = "unknown-mode";
          }
          else {
            BOOL v36 = off_1E523FB08[v16];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v132 = 2082;
          os_log_type_t v133 = (void *)v36;
          __int16 v134 = 2082;
          uint64_t v135 = "flow";
          _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
        goto LABEL_205;
      }
      if (!v129)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v34 = (id)gLogObj;
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v34, type))
        {
          if (v16 > 5) {
            char v43 = "unknown-mode";
          }
          else {
            char v43 = off_1E523FB08[v16];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v132 = 2082;
          os_log_type_t v133 = (void *)v43;
          __int16 v134 = 2082;
          uint64_t v135 = "flow";
          _os_log_impl(&dword_1830D4000, v34, v42, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
        goto LABEL_205;
      }
      os_log_type_t v37 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v38 = (id)gLogObj;
      os_log_type_t v39 = type;
      BOOL v40 = os_log_type_enabled(v38, type);
      if (v37)
      {
        if (v40)
        {
          if (v16 > 5) {
            BOOL v41 = "unknown-mode";
          }
          else {
            BOOL v41 = off_1E523FB08[v16];
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v132 = 2082;
          os_log_type_t v133 = (void *)v41;
          __int16 v134 = 2082;
          uint64_t v135 = "flow";
          __int16 v136 = 2082;
          uint64_t v137 = v37;
          _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v37);
        if (!v33) {
          goto LABEL_72;
        }
        goto LABEL_71;
      }
      if (v40)
      {
        if (v16 > 5) {
          os_log_type_t v44 = "unknown-mode";
        }
        else {
          os_log_type_t v44 = off_1E523FB08[v16];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v132 = 2082;
        os_log_type_t v133 = (void *)v44;
        __int16 v134 = 2082;
        uint64_t v135 = "flow";
        _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
LABEL_70:
    if (!v33)
    {
LABEL_72:
      uint64_t registered_endpoint = 0;
      goto LABEL_73;
    }
LABEL_71:
    free(v33);
    goto LABEL_72;
  }
  if (!identifier)
  {
    uint64_t v88 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v129 = 0;
    if (!__nwlog_fault(v33, &type, &v129)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v89 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v89, "%{public}s called with null identifier", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (!v129)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v104 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v104, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_205;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v34 = __nwlog_obj();
    os_log_type_t v97 = type;
    BOOL v98 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v97, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (v98)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v132 = 2082;
      os_log_type_t v133 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v34, v97, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_172;
  }
  if (!v124)
  {
    uint64_t v93 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v129 = 0;
    if (!__nwlog_fault(v33, &type, &v129)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v94 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v94, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (!v129)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v105 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v105, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_205;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v34 = __nwlog_obj();
    os_log_type_t v99 = type;
    BOOL v100 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v100)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v99, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (v100)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v132 = 2082;
      os_log_type_t v133 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v34, v99, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_172;
  }
  if (!v126)
  {
    BOOL v95 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v129 = 0;
    if (!__nwlog_fault(v33, &type, &v129)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v96 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v96, "%{public}s called with null parameters", buf, 0xCu);
      }
LABEL_205:

      goto LABEL_70;
    }
    if (!v129)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v106 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v106, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_205;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v34 = __nwlog_obj();
    os_log_type_t v101 = type;
    BOOL v102 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v102)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v34, v101, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_205;
    }
    if (v102)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v132 = 2082;
      os_log_type_t v133 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v34, v101, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_172:

    free(backtrace_string);
    if (!v33) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v17 = &g_registration_list;
  do
  {
    uint64_t v17 = (uint64_t *)*v17;
    if (!v17)
    {
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }
  while (*(void *)identifier != v17[4]
       || *((void *)identifier + 1) != v17[5]
       || *((void *)identifier + 2) != v17[6]
       || *((void *)identifier + 3) != v17[7]
       || *((void *)identifier + 4) != v17[8]);
  uint64_t v22 = v17[13];
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  if (!v22)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v15) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v27 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v15);
        __int16 v118 = nw_endpoint_handler_dry_run_string(v15);
        nw_endpoint_t v29 = nw_endpoint_handler_copy_endpoint(v15);
        logging_description = nw_endpoint_get_logging_description(v29);
        os_log_type_t v30 = nw_endpoint_handler_state_string(v15);
        id v31 = nw_endpoint_handler_mode_string(v15);
        id v32 = nw_endpoint_handler_copy_current_path(v15);
        *(_DWORD *)buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v132 = 2082;
        os_log_type_t v133 = (void *)id_string;
        __int16 v134 = 2082;
        uint64_t v135 = v118;
        __int16 v136 = 2082;
        uint64_t v137 = (void *)logging_description;
        __int16 v138 = 2082;
        uint64_t v139 = v30;
        __int16 v140 = 2082;
        uint64_t v141 = v31;
        __int16 v142 = 2114;
        id v143 = v32;
        __int16 v144 = 2080;
        BOOL v145 = identifier;
        __int16 v146 = 2048;
        uint64_t v147 = (uint64_t)identifier;
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x5Cu);
      }
    }
    goto LABEL_72;
  }
  id v23 = v124;
  id v24 = v23;
  while (1)
  {
    uint64_t registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join((uint64_t)identifier, -1, v122, v24, v23, v126, v10 != 0);
    if (registered_endpoint) {
      break;
    }
    uint64_t registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v24, v10 != 0);

    id v24 = (void *)registered_endpoint;
    if (!registered_endpoint) {
      goto LABEL_53;
    }
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v15) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    nw_endpoint_t v107 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v119 = nw_endpoint_handler_get_id_string(v15);
      uint64_t v117 = nw_endpoint_handler_dry_run_string(v15);
      nw_endpoint_t v108 = nw_endpoint_handler_copy_endpoint(v15);
      uint64_t v115 = nw_endpoint_get_logging_description(v108);
      size_t v114 = nw_endpoint_handler_state_string(v15);
      BOOL v109 = nw_endpoint_handler_mode_string(v15);
      id v110 = nw_endpoint_handler_copy_current_path(v15);
      nw_endpoint_t v111 = v110;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      char v112 = "invalid";
      size_t v113 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v113) {
        char v112 = v113;
      }
      __int16 v132 = 2082;
      os_log_type_t v133 = (void *)v119;
      __int16 v134 = 2082;
      uint64_t v135 = v117;
      __int16 v136 = 2082;
      uint64_t v137 = (void *)v115;
      __int16 v138 = 2082;
      uint64_t v139 = v114;
      __int16 v140 = 2082;
      uint64_t v141 = v109;
      __int16 v142 = 2114;
      id v143 = v110;
      __int16 v144 = 2080;
      BOOL v145 = (void *)v112;
      __int16 v146 = 2048;
      uint64_t v147 = registered_endpoint;
      _os_log_impl(&dword_1830D4000, v107, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)", buf, 0x5Cu);
    }
  }
LABEL_53:

LABEL_73:
  if (registered_endpoint)
  {
LABEL_74:
    if (nw_endpoint_flow_join_protocol(*(void **)(a1 + 32), *(void **)(a1 + 48), v128, v7, identifier, -1, registered_endpoint, *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24), *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), (unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)))
    {
      *(void *)(*(void *)(a1 + 56) + 736) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)
                                                            + 32);
      *(unsigned char *)(*(void *)(a1 + 56) + 33) |= 1u;
      os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 880));
      uint64_t v45 = *(void *)(a1 + 56);
      if (!*(void *)(v45 + 720))
      {
        if (*(_UNKNOWN **)(registered_endpoint + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v53 = *(void *)(registered_endpoint + 88);
          if (v53)
          {
            *(void *)(registered_endpoint + 88) = v53 + 1;
            uint64_t v45 = *(void *)(a1 + 56);
          }
          *(void *)buf = registered_endpoint;
          char v46 = buf[8] | 1;
        }
        else
        {
          *(void *)buf = registered_endpoint;
          char v46 = buf[8] & 0xFE;
        }
        buf[8] = v46;
        char v54 = *(unsigned char *)(v45 + 728);
        if (v54)
        {
          nw::release_if_needed<nw_protocol *>((uint64_t *)(v45 + 720));
          char v54 = *(unsigned char *)(v45 + 728);
          uint64_t registered_endpoint = *(void *)buf;
          char v46 = buf[8];
        }
        *(void *)(v45 + 720) = registered_endpoint;
        *(unsigned char *)(v45 + 728) = v54 & 0xFE | v46 & 1;
        uint64_t v45 = *(void *)(a1 + 56);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v45 + 880));
      uint64_t v51 = 0;
      goto LABEL_107;
    }
  }
  uint64_t v47 = nw_endpoint_flow_add_one_protocol(*(void **)(a1 + 32), (long long *)identifier, v128, v7, *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40), *(void **)(a1 + 48), *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24));
  if (v47)
  {
    if (nw_protocol_definition_get_message_is_stream(v7))
    {
      uint64_t v48 = *(void *)(a1 + 56);
      if (!*(void *)(v48 + 768))
      {
        objc_storeStrong((id *)(v48 + 768), a3);
        if (*(_UNKNOWN **)(v47 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v67 = *(void *)(v47 + 88);
          if (v67) {
            *(void *)(v47 + 88) = v67 + 1;
          }
          *(void *)buf = v47;
          buf[8] |= 1u;
          char v52 = 1;
        }
        else
        {
          char v52 = 0;
          *(void *)buf = v47;
          buf[8] &= ~1u;
        }
        uint64_t v68 = *(void *)(a1 + 56);
        char v69 = *(unsigned char *)(v68 + 784);
        if (v69)
        {
          nw::release_if_needed<nw_protocol *>((uint64_t *)(v68 + 776));
          char v69 = *(unsigned char *)(v68 + 784);
        }
        *(void *)(v68 + 776) = v47;
        *(unsigned char *)(v68 + 784) = v52 | v69 & 0xFE;
        uint64_t v70 = *(void *)(v47 + 24);
        if (v70)
        {
          os_log_type_t v71 = *(uint64_t (**)(uint64_t, uint64_t, void))(v70 + 232);
          if (v71)
          {
            uint64_t v72 = *(void *)(a1 + 56) + 440;
            int v73 = *(void **)(v47 + 40);
            if (v73 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v75 = *(void *)(v47 + 88);
              if (v75) {
                *(void *)(v47 + 88) = v75 + 1;
              }
              *(void *)buf = v47;
              char v74 = buf[8] | 1;
            }
            else
            {
              *(void *)buf = v47;
              char v74 = buf[8] & 0xFE;
            }
            buf[8] = v74;
            char v76 = v71(v47, v72, 0);
            if (v73 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
            }
            if ((v76 & 1) == 0 && (nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              long long v77 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
              {
                nw_endpoint_t v78 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                os_log_type_t v79 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                nw_endpoint_t v127 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                size_t v123 = nw_endpoint_get_logging_description(v127);
                id v125 = v79;
                char v80 = v78;
                os_log_type_t v121 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                os_log_type_t v81 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                id v82 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                os_log_type_t v83 = v82;
                BOOL v84 = "invalid";
                os_log_type_t v85 = *(const char **)(*(void *)(a1 + 56) + 392);
                if (!v85) {
                  os_log_type_t v85 = "invalid";
                }
                if (*(void *)(v47 + 16)) {
                  BOOL v84 = *(const char **)(v47 + 16);
                }
                *(_DWORD *)buf = 136448258;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                __int16 v132 = 2082;
                os_log_type_t v133 = (void *)v80;
                __int16 v134 = 2082;
                uint64_t v135 = v125;
                __int16 v136 = 2082;
                uint64_t v137 = (void *)v123;
                __int16 v138 = 2082;
                uint64_t v139 = v121;
                __int16 v140 = 2082;
                uint64_t v141 = v81;
                __int16 v142 = 2114;
                id v143 = v82;
                __int16 v144 = 2082;
                BOOL v145 = (void *)v85;
                __int16 v146 = 2082;
                uint64_t v147 = (uint64_t)v84;
                _os_log_impl(&dword_1830D4000, v77, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s as a listener to %{public}s", buf, 0x5Cu);
              }
            }
          }
        }
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 880));
    uint64_t v49 = *(void *)(a1 + 56);
    if (!*(void *)(v49 + 720))
    {
      if (*(_UNKNOWN **)(v47 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v55 = *(void *)(v47 + 88);
        if (v55)
        {
          *(void *)(v47 + 88) = v55 + 1;
          uint64_t v49 = *(void *)(a1 + 56);
        }
        *(void *)buf = v47;
        char v50 = buf[8] | 1;
      }
      else
      {
        *(void *)buf = v47;
        char v50 = buf[8] & 0xFE;
      }
      buf[8] = v50;
      char v56 = *(unsigned char *)(v49 + 728);
      uint64_t v57 = v47;
      if (v56)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)(v49 + 720));
        char v56 = *(unsigned char *)(v49 + 728);
        uint64_t v57 = *(void *)buf;
        char v50 = buf[8];
      }
      *(void *)(v49 + 720) = v57;
      *(unsigned char *)(v49 + 728) = v56 & 0xFE | v50 & 1;
      uint64_t v49 = *(void *)(a1 + 56);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v49 + 880));
    *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = v47;
    if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v58 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
      {
        size_t v59 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        os_log_type_t v60 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v61 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        uint64_t v62 = nw_endpoint_get_logging_description(v61);
        os_log_type_t v63 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        id v64 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v65 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
        __int16 v132 = 2082;
        os_log_type_t v133 = (void *)v59;
        __int16 v134 = 2082;
        uint64_t v135 = v60;
        __int16 v136 = 2082;
        uint64_t v137 = (void *)v62;
        __int16 v138 = 2082;
        uint64_t v139 = v63;
        __int16 v140 = 2082;
        uint64_t v141 = v64;
        __int16 v142 = 2114;
        id v143 = v65;
        __int16 v144 = 2082;
        BOOL v145 = identifier;
        _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached transport protocol: %{public}s", buf, 0x52u);
      }
    }
    uint64_t v51 = 1;
  }
  else
  {
    uint64_t v51 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;
  }
LABEL_107:

  return v51;
}

void sub_1833A46A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_225(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  identifier = nw_protocol_definition_get_identifier(v6);
  uint64_t registered_endpoint = *(void *)(a1 + 96);
  if (registered_endpoint) {
    goto LABEL_75;
  }
  id v98 = v7;
  int v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  BOOL v11 = *(void **)(a1 + 40);
  uint64_t v12 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  uint64_t v13 = *(void **)(a1 + 48);
  id v14 = *(id *)(a1 + 32);
  id v97 = v11;
  id v15 = v12;
  id v16 = v13;
  BOOL v95 = v14;
  os_log_type_t v96 = v15;
  if (!v14)
  {
    os_log_type_t v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
    size_t v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v100)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v65 = type;
      BOOL v66 = os_log_type_enabled(v60, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_160:
        if (!v59) {
          goto LABEL_73;
        }
        goto LABEL_161;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v78 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v78, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_159:

    goto LABEL_160;
  }
  uint64_t v17 = (unsigned int *)v14;
  uint64_t v18 = v17[29];

  if (v18 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (id)gLogObj;
    if (v18 > 5) {
      nw_endpoint_t v28 = "unknown-mode";
    }
    else {
      nw_endpoint_t v28 = off_1E523FB08[v18];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
    __int16 v104 = 2082;
    os_log_type_t v105 = (void *)v28;
    __int16 v106 = 2082;
    nw_endpoint_t v107 = "flow";
    os_log_type_t v35 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (__nwlog_fault(v35, &type, &v100))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v36 = (id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          if (v18 > 5) {
            os_log_type_t v38 = "unknown-mode";
          }
          else {
            os_log_type_t v38 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = (void *)v38;
          __int16 v106 = 2082;
          nw_endpoint_t v107 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v100)
      {
        os_log_type_t v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v36 = (id)gLogObj;
        os_log_type_t v40 = type;
        BOOL v41 = os_log_type_enabled(v36, type);
        if (v39)
        {
          if (v41)
          {
            if (v18 > 5) {
              os_log_type_t v42 = "unknown-mode";
            }
            else {
              os_log_type_t v42 = off_1E523FB08[v18];
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
            __int16 v104 = 2082;
            os_log_type_t v105 = (void *)v42;
            __int16 v106 = 2082;
            nw_endpoint_t v107 = "flow";
            __int16 v108 = 2082;
            BOOL v109 = v39;
            _os_log_impl(&dword_1830D4000, v36, v40, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          if (!v35) {
            goto LABEL_73;
          }
LABEL_71:
          char v46 = (char *)v35;
LABEL_72:
          free(v46);
          goto LABEL_73;
        }
        if (v41)
        {
          if (v18 > 5) {
            uint64_t v45 = "unknown-mode";
          }
          else {
            uint64_t v45 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = (void *)v45;
          __int16 v106 = 2082;
          nw_endpoint_t v107 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v40, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v36 = (id)gLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v36, type))
        {
          if (v18 > 5) {
            os_log_type_t v44 = "unknown-mode";
          }
          else {
            os_log_type_t v44 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = (void *)v44;
          __int16 v106 = 2082;
          nw_endpoint_t v107 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v43, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v35)
    {
LABEL_73:
      uint64_t registered_endpoint = 0;
      goto LABEL_74;
    }
    goto LABEL_71;
  }
  if (!identifier)
  {
    uint64_t v62 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
    size_t v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v63, "%{public}s called with null identifier", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (!v100)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v79 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v79, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_159;
    }
    os_log_type_t v71 = (char *)__nw_create_backtrace_string();
    os_log_type_t v60 = __nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v73 = os_log_type_enabled(v60, type);
    if (!v71)
    {
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v72, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (v73)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v104 = 2082;
      os_log_type_t v105 = v71;
      _os_log_impl(&dword_1830D4000, v60, v72, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_126;
  }
  if (!v15)
  {
    uint64_t v67 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
    size_t v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v68, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (!v100)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v80, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_159;
    }
    os_log_type_t v71 = (char *)__nw_create_backtrace_string();
    os_log_type_t v60 = __nwlog_obj();
    os_log_type_t v74 = type;
    BOOL v75 = os_log_type_enabled(v60, type);
    if (!v71)
    {
      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v74, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (v75)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v104 = 2082;
      os_log_type_t v105 = v71;
      _os_log_impl(&dword_1830D4000, v60, v74, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_126;
  }
  if (!v16)
  {
    char v69 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
    size_t v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v70, "%{public}s called with null parameters", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (!v100)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v81 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v81, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_159;
    }
    os_log_type_t v71 = (char *)__nw_create_backtrace_string();
    os_log_type_t v60 = __nwlog_obj();
    os_log_type_t v76 = type;
    BOOL v77 = os_log_type_enabled(v60, type);
    if (!v71)
    {
      if (v77)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v76, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (v77)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v104 = 2082;
      os_log_type_t v105 = v71;
      _os_log_impl(&dword_1830D4000, v60, v76, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_126:

    free(v71);
    if (!v59) {
      goto LABEL_73;
    }
LABEL_161:
    char v46 = (char *)v59;
    goto LABEL_72;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v19 = &g_registration_list;
  do
  {
    uint64_t v19 = (uint64_t *)*v19;
    if (!v19)
    {
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }
  while (*(void *)identifier != v19[4]
       || *((void *)identifier + 1) != v19[5]
       || *((void *)identifier + 2) != v19[6]
       || *((void *)identifier + 3) != v19[7]
       || *((void *)identifier + 4) != v19[8]);
  uint64_t v24 = v19[13];
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  if (!v24)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      nw_endpoint_t v29 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v17);
        uint64_t v93 = nw_endpoint_handler_dry_run_string(v17);
        nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v17);
        logging_description = nw_endpoint_get_logging_description(v31);
        id v32 = nw_endpoint_handler_state_string(v17);
        id v33 = nw_endpoint_handler_mode_string(v17);
        id v34 = nw_endpoint_handler_copy_current_path(v17);
        *(_DWORD *)buf = 136448258;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v104 = 2082;
        os_log_type_t v105 = (void *)id_string;
        __int16 v106 = 2082;
        nw_endpoint_t v107 = v93;
        __int16 v108 = 2082;
        BOOL v109 = (void *)logging_description;
        __int16 v110 = 2082;
        nw_endpoint_t v111 = v32;
        __int16 v112 = 2082;
        size_t v113 = v33;
        __int16 v114 = 2114;
        id v115 = v34;
        __int16 v116 = 2080;
        uint64_t v117 = identifier;
        __int16 v118 = 2048;
        uint64_t v119 = (uint64_t)identifier;
        _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x5Cu);
      }
    }
    goto LABEL_73;
  }
  id v25 = v15;
  os_log_type_t v26 = v25;
  while (1)
  {
    uint64_t registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join((uint64_t)identifier, -1, v97, v26, v25, v16, v10 != 0);
    if (registered_endpoint) {
      break;
    }
    uint64_t registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v26, v10 != 0);

    os_log_type_t v26 = (void *)registered_endpoint;
    if (!registered_endpoint) {
      goto LABEL_53;
    }
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v82 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v94 = nw_endpoint_handler_get_id_string(v17);
      BOOL v92 = nw_endpoint_handler_dry_run_string(v17);
      nw_endpoint_t v83 = nw_endpoint_handler_copy_endpoint(v17);
      os_log_type_t v90 = nw_endpoint_get_logging_description(v83);
      os_log_type_t v89 = nw_endpoint_handler_state_string(v17);
      BOOL v84 = nw_endpoint_handler_mode_string(v17);
      id v85 = nw_endpoint_handler_copy_current_path(v17);
      BOOL v86 = v85;
      os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
      os_log_type_t v87 = "invalid";
      uint64_t v88 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v88) {
        os_log_type_t v87 = v88;
      }
      __int16 v104 = 2082;
      os_log_type_t v105 = (void *)v94;
      __int16 v106 = 2082;
      nw_endpoint_t v107 = v92;
      __int16 v108 = 2082;
      BOOL v109 = (void *)v90;
      __int16 v110 = 2082;
      nw_endpoint_t v111 = v89;
      __int16 v112 = 2082;
      size_t v113 = v84;
      __int16 v114 = 2114;
      id v115 = v85;
      __int16 v116 = 2080;
      uint64_t v117 = (void *)v87;
      __int16 v118 = 2048;
      uint64_t v119 = registered_endpoint;
      _os_log_impl(&dword_1830D4000, v82, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)", buf, 0x5Cu);
    }
  }
LABEL_53:

LABEL_74:
  id v7 = v98;
  if (registered_endpoint)
  {
LABEL_75:
    if (nw_endpoint_flow_join_protocol(*(void **)(a1 + 32), *(void **)(a1 + 48), v7, v6, identifier, -1, registered_endpoint, *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24), *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), (unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)))
    {
      uint64_t v47 = 0;
      *(unsigned char *)(*(void *)(a1 + 56) + 33) |= 1u;
      goto LABEL_85;
    }
  }
  uint64_t v48 = nw_endpoint_flow_add_one_protocol(*(void **)(a1 + 32), (long long *)identifier, v7, v6, *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40), *(void **)(a1 + 48), *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24));
  if (v48)
  {
    *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = v48;
    if (nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)))
    {
      uint64_t v47 = 1;
    }
    else
    {
      id v99 = v7;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v49 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        char v50 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        uint64_t v51 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v52 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        uint64_t v53 = nw_endpoint_get_logging_description(v52);
        char v54 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        uint64_t v55 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v56 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136448002;
        os_log_type_t v103 = "nw_endpoint_flow_attach_protocols_block_invoke";
        __int16 v104 = 2082;
        os_log_type_t v105 = (void *)v50;
        __int16 v106 = 2082;
        nw_endpoint_t v107 = v51;
        __int16 v108 = 2082;
        BOOL v109 = (void *)v53;
        __int16 v110 = 2082;
        nw_endpoint_t v111 = v54;
        __int16 v112 = 2082;
        size_t v113 = v55;
        __int16 v114 = 2114;
        id v115 = v56;
        __int16 v116 = 2082;
        uint64_t v117 = identifier;
        _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached internet protocol: %{public}s", buf, 0x52u);
      }
      uint64_t v47 = 1;
      id v7 = v99;
    }
  }
  else
  {
    uint64_t v47 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;
  }
LABEL_85:

  return v47;
}

void sub_1833A59EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_add_one_protocol(void *a1, long long *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  id v13 = a1;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v58 = a6;
  size_t v59 = v15;
  id v56 = v14;
  uint64_t v57 = v16;
  uint64_t protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition((uint64_t)a2, v15, v16, v58);
  if (protocol_for_definition)
  {
    if (v15)
    {
      if (!v14)
      {
LABEL_12:
        uint64_t v55 = a2;
        if (a7)
        {
          if (protocol_for_definition != a7)
          {
            id v27 = *(void **)(protocol_for_definition + 24);
            if (v27 && *v27)
            {
              if (nw_protocol_add_input_handler(protocol_for_definition, a7)) {
                goto LABEL_35;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v32 = (id)gLogObj;
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
                __int16 v64 = 2048;
                uint64_t v65 = protocol_for_definition;
                _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
              }
            }
LABEL_28:
            if ((nw_endpoint_handler_get_logging_disabled(v13) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v18 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              {
                id_string = nw_endpoint_handler_get_id_string(v13);
                id v34 = nw_endpoint_handler_dry_run_string(v13);
                nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v13);
                logging_description = nw_endpoint_get_logging_description(v35);
                os_log_type_t v37 = nw_endpoint_handler_state_string(v13);
                os_log_type_t v38 = nw_endpoint_handler_mode_string(v13);
                id v39 = nw_endpoint_handler_copy_current_path(v13);
                *(_DWORD *)buf = 136448002;
                os_log_type_t v63 = "nw_endpoint_flow_add_one_protocol";
                __int16 v64 = 2082;
                uint64_t v65 = (uint64_t)id_string;
                __int16 v66 = 2082;
                uint64_t v67 = (void *)v34;
                __int16 v68 = 2082;
                char v69 = logging_description;
                __int16 v70 = 2082;
                os_log_type_t v71 = v37;
                __int16 v72 = 2082;
                BOOL v73 = v38;
                __int16 v74 = 2114;
                id v75 = v39;
                __int16 v76 = 2082;
                BOOL v77 = v55;
                _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach protocol %{public}s", buf, 0x52u);
              }
LABEL_33:

              goto LABEL_34;
            }
            goto LABEL_34;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v28 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
          __int16 v64 = 2048;
          uint64_t v65 = a7;
          nw_endpoint_t v29 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v60 = 0;
          if (!__nwlog_fault(v29, &type, &v60)) {
            goto LABEL_23;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v30 = (id)gLogObj;
            os_log_type_t v31 = type;
            if (os_log_type_enabled(v30, type))
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
              __int16 v64 = 2048;
              uint64_t v65 = a7;
              _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
          }
          else
          {
            if (v60)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v42 = (id)gLogObj;
              os_log_type_t v43 = type;
              BOOL v44 = os_log_type_enabled(v42, type);
              if (backtrace_string)
              {
                if (v44)
                {
                  *(_DWORD *)buf = 136446722;
                  os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
                  __int16 v64 = 2048;
                  uint64_t v65 = a7;
                  __int16 v66 = 2082;
                  uint64_t v67 = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                }

                free(backtrace_string);
                if (!v29) {
                  goto LABEL_28;
                }
LABEL_24:
                free(v29);
                goto LABEL_28;
              }
              if (v44)
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
                __int16 v64 = 2048;
                uint64_t v65 = a7;
                _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
              }

LABEL_23:
              if (!v29) {
                goto LABEL_28;
              }
              goto LABEL_24;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v30 = (id)gLogObj;
            os_log_type_t v45 = type;
            if (os_log_type_enabled(v30, type))
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
              __int16 v64 = 2048;
              uint64_t v65 = a7;
              _os_log_impl(&dword_1830D4000, v30, v45, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
            }
          }

          goto LABEL_23;
        }
        char v46 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
        uint64_t v47 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v60 = 0;
        if (__nwlog_fault(v47, &type, &v60))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v48 = __nwlog_obj();
            os_log_type_t v49 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null input_protocol", buf, 0xCu);
            }
          }
          else
          {
            if (v60)
            {
              char v50 = (char *)__nw_create_backtrace_string();
              uint64_t v51 = __nwlog_obj();
              os_log_type_t v52 = type;
              BOOL v53 = os_log_type_enabled(v51, type);
              if (v50)
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446466;
                  os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
                  __int16 v64 = 2082;
                  uint64_t v65 = (uint64_t)v50;
                  _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v50);
              }
              else
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
                }
              }
              goto LABEL_64;
            }
            uint64_t v48 = __nwlog_obj();
            os_log_type_t v54 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v63 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_1830D4000, v48, v54, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_64:
        if (v47) {
          free(v47);
        }
        goto LABEL_28;
      }
    }
    else
    {
      size_t v59 = nw_protocol_definition_create_with_identifier(a2);
      if (!v14) {
        goto LABEL_12;
      }
    }
    nw_endpoint_handler_set_protocol_instance(v13, v14, v59, protocol_for_definition);
    goto LABEL_12;
  }
  if ((nw_endpoint_handler_get_logging_disabled(v13) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v18 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = nw_endpoint_handler_get_id_string(v13);
      int v20 = nw_endpoint_handler_dry_run_string(v13);
      nw_endpoint_t v21 = nw_endpoint_handler_copy_endpoint(v13);
      uint64_t v22 = a2;
      id v23 = nw_endpoint_get_logging_description(v21);
      uint64_t v24 = nw_endpoint_handler_state_string(v13);
      id v25 = nw_endpoint_handler_mode_string(v13);
      id v26 = nw_endpoint_handler_copy_current_path(v13);
      *(_DWORD *)buf = 136448002;
      os_log_type_t v63 = "nw_endpoint_flow_add_one_protocol";
      __int16 v64 = 2082;
      uint64_t v65 = (uint64_t)v19;
      __int16 v66 = 2082;
      uint64_t v67 = (void *)v20;
      __int16 v68 = 2082;
      char v69 = v23;
      __int16 v70 = 2082;
      os_log_type_t v71 = v24;
      __int16 v72 = 2082;
      BOOL v73 = v25;
      __int16 v74 = 2114;
      id v75 = v26;
      __int16 v76 = 2082;
      BOOL v77 = v22;
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create protocol handler: %{public}s", buf, 0x52u);
    }
    goto LABEL_33;
  }
LABEL_34:
  uint64_t protocol_for_definition = 0;
LABEL_35:

  return protocol_for_definition;
}

void sub_1833A6390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

unsigned char *nw_protocol_instance_registrar_copy_next_registered_endpoint(void *a1, int a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_endpoint_is_registered";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v19, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v20 = __nwlog_obj();
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v38 = "nw_endpoint_is_registered";
            __int16 v39 = 2082;
            os_log_type_t v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_37;
        }
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v20 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_37:
    if (v19) {
      free(v19);
    }
LABEL_39:
    id v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
    id v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s finding the next endpoint requires a registered endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        os_log_type_t v30 = (char *)__nw_create_backtrace_string();
        id v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
            __int16 v39 = 2082;
            os_log_type_t v40 = v30;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s finding the next endpoint requires a registered endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v30);
          goto LABEL_55;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s finding the next endpoint requires a registered endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s finding the next endpoint requires a registered endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_55:
    if (v27) {
      free(v27);
    }
LABEL_15:
    uint64_t v12 = 0;
    goto LABEL_16;
  }
  char v5 = v3[231];

  if ((v5 & 4) == 0) {
    goto LABEL_39;
  }
  id v6 = v4;
  int v7 = [v6 type];

  if (v7 != 1 || (v4[231] & 2) != 0) {
    goto LABEL_14;
  }
  id v8 = v6;
  id v9 = v8[14];

  if (!v9 || (id v10 = v9, v11 = [v10 type], v10, v11 != 2))
  {

    goto LABEL_14;
  }
  uint64_t v12 = v10;
  char v13 = v12[231];

  if ((v13 & 4) == 0)
  {
    if (gLogDatapath)
    {
      id v34 = __nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
        __int16 v39 = 2112;
        os_log_type_t v40 = v12;
        _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s next endpoint %@ is not registered, fetching registered copy", buf, 0x16u);
      }
    }
    id v14 = v8[1];
    id v15 = nw_context_copy_registered_endpoint_internal(v14, v12, a2);

    uint64_t v12 = v15;
    if (!v15)
    {
LABEL_14:
      if (gLogDatapath)
      {
        id v16 = __nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          __int16 v39 = 2112;
          os_log_type_t v40 = v6;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s no next endpoint for endpoint %@", buf, 0x16u);
        }
        uint64_t v12 = 0;
        goto LABEL_25;
      }
      goto LABEL_15;
    }
  }
  if (gLogDatapath)
  {
    id v16 = __nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
      __int16 v39 = 2112;
      os_log_type_t v40 = v12;
      __int16 v41 = 2112;
      os_log_type_t v42 = v8;
      _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s found next endpoint %@ for endpoint %@", buf, 0x20u);
    }
LABEL_25:
  }
LABEL_16:

  return v12;
}

void sub_1833A6AA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    int v7 = p_output_handler;
    id v8 = v7;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *((void *)v7 + 1);
      if (v9)
      {
        if (*(void *)(v9 + 80))
        {
          int v10 = v7[405];
          if (!*((void *)v7 + 3))
          {
            if ((v10 & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v13 = (id)gLogObj;
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
                __int16 v46 = 2082;
                uint64_t v47 = v8 + 407;
                __int16 v48 = 2080;
                os_log_type_t v49 = " ";
                _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sAdded protocol listen handler", buf, 0x20u);
              }
            }
            *((void *)v8 + 3) = a2;
            a2->protocol_handler = (nw_protocol *)(v8 - 96);
            if (a3)
            {
              if ((v8[405] & 0x80000000) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v14 = (id)gLogObj;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446722;
                  os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
                  __int16 v46 = 2082;
                  uint64_t v47 = v8 + 407;
                  __int16 v48 = 2080;
                  os_log_type_t v49 = " ";
                  _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sListen handler prohibits joining, removing instance", buf, 0x20u);
                }
              }
              v8[404] |= 4u;
              nw_protocol_remove_instance((uint64_t)(v8 - 96));
            }
            uint64_t v12 = 1;
            goto LABEL_24;
          }
          if ((v10 & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v11 = (id)gLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
              __int16 v46 = 2082;
              uint64_t v47 = v8 + 407;
              __int16 v48 = 2080;
              os_log_type_t v49 = " ";
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sAlready have a listen handler, ignoring add", buf, 0x20u);
            }
          }
LABEL_12:
          uint64_t v12 = 0;
LABEL_24:

          return v12;
        }
        id v26 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
        os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v42 = 0;
        if (!__nwlog_fault((const char *)v21, &type, &v42))
        {
LABEL_93:
          if (v21) {
            free(v21);
          }
          goto LABEL_12;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v27 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
LABEL_92:

          goto LABEL_93;
        }
        if (!v42)
        {
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v41 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl(&dword_1830D4000, v22, v41, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_92;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v36 = type;
        BOOL v37 = os_log_type_enabled(v22, type);
        if (!backtrace_string)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl(&dword_1830D4000, v22, v36, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_92;
        }
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
          __int16 v46 = 2082;
          uint64_t v47 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v36, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        BOOL v24 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
        os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v42 = 0;
        if (!__nwlog_fault((const char *)v21, &type, &v42)) {
          goto LABEL_93;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_92;
        }
        if (!v42)
        {
          uint64_t v22 = __nwlog_obj();
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl(&dword_1830D4000, v22, v40, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_92;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v34 = type;
        BOOL v35 = os_log_type_enabled(v22, type);
        if (!backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl(&dword_1830D4000, v22, v34, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_92;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
          __int16 v46 = 2082;
          uint64_t v47 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v34, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
    }
    else
    {
      int v20 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
      os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v42 = 0;
      if (!__nwlog_fault((const char *)v21, &type, &v42)) {
        goto LABEL_93;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_92;
      }
      if (!v42)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
          _os_log_impl(&dword_1830D4000, v22, v39, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_92;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
          _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_92;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
        __int16 v46 = 2082;
        uint64_t v47 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_93;
  }
  id v16 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
  uint64_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (__nwlog_fault(v17, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v42)
    {
      id v28 = (char *)__nw_create_backtrace_string();
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v18, type);
      if (v28)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
          __int16 v46 = 2082;
          uint64_t v47 = v28;
          _os_log_impl(&dword_1830D4000, v18, v29, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v28);
        goto LABEL_81;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
        _os_log_impl(&dword_1830D4000, v18, v29, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
        _os_log_impl(&dword_1830D4000, v18, v38, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_81:
  if (v17) {
    free(v17);
  }
  return 0;
}

uint64_t __nw_protocol_remove_instance_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(*(void *)(a1 + 32) + 16))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v7, &type, &v18)) {
      goto LABEL_21;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      int v10 = "%{public}s called with null protocol->identifier";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v16)
      {
LABEL_21:
        if (v7) {
          free(v7);
        }
        return 1;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      int v10 = "%{public}s called with null protocol->identifier, no backtrace";
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      int v10 = "%{public}s called with null protocol->identifier, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    goto LABEL_21;
  }
  if (gLogDatapath)
  {
    int v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      logging_description = nw_endpoint_get_logging_description(a2);
      uint64_t v13 = *(void *)(a1 + 32);
      uint64_t v14 = *(void *)(v13 + 16);
      *(_DWORD *)buf = 136447234;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      __int16 v22 = 2080;
      os_log_type_t v23 = (void *)logging_description;
      __int16 v24 = 2048;
      os_log_type_t v25 = a2;
      __int16 v26 = 2048;
      uint64_t v27 = v13;
      __int16 v28 = 2080;
      uint64_t v29 = v14;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s checking registered endpoint %s (%p) to remove instance %p of %s", buf, 0x34u);
    }
  }
  id v4 = nw_endpoint_copy_registrar_for_identifier(a2, *(long long **)(*(void *)(a1 + 32) + 16), 0);
  if (!v4) {
    return 1;
  }
  char v5 = v4;
  nw_protocol_instance_registrar_remove_instance(v4, *(void *)(a1 + 32));
  BOOL v6 = nw_protocol_instance_registrar_get_instance_count(v5) == 0;
  os_release(v5);
  return v6;
}

uint64_t nw_protocol_instance_registrar_search_for_instance_to_join(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, int a7)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  id v75 = a3;
  id v74 = a4;
  id v76 = a5;
  id v77 = a6;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    if (__nwlog_fault(v44, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v47 = "%{public}s called with null identifier";
LABEL_64:
          _os_log_impl(&dword_1830D4000, v45, v46, v47, buf, 0xCu);
        }
      }
      else if (v78)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        BOOL v50 = os_log_type_enabled(v45, type[0]);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v50)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v47 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_64;
        }
      }
      else
      {
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v47 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_64;
        }
      }
    }
    if (v44) {
      free(v44);
    }
LABEL_25:
    if (gLogDatapath)
    {
      __int16 v48 = __nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a1;
        *(_WORD *)&buf[22] = 2048;
        BOOL v84 = (void *)a1;
        _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_DEBUG, "%{public}s protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x20u);
      }
    }
    goto LABEL_26;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v13 = &g_registration_list;
  do
  {
    uint64_t v13 = (uint64_t *)*v13;
    if (!v13)
    {
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      goto LABEL_25;
    }
  }
  while (*(void *)a1 != v13[4]
       || *(void *)(a1 + 8) != v13[5]
       || *(void *)(a1 + 16) != v13[6]
       || *(void *)(a1 + 24) != v13[7]
       || *(void *)(a1 + 32) != v13[8]);
  uint64_t v18 = v13[13];
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  if (!v18) {
    goto LABEL_25;
  }
  os_log_type_t v19 = v74;
  if (!v19)
  {
    uint64_t v51 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
    os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    if (__nwlog_fault(v52, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v53 = __nwlog_obj();
        os_log_type_t v54 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v78)
      {
        id v56 = (char *)__nw_create_backtrace_string();
        BOOL v53 = __nwlog_obj();
        os_log_type_t v57 = type[0];
        BOOL v58 = os_log_type_enabled(v53, type[0]);
        if (v56)
        {
          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v56;
            _os_log_impl(&dword_1830D4000, v53, v57, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v56);
          goto LABEL_79;
        }
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_1830D4000, v53, v57, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v53 = __nwlog_obj();
        os_log_type_t v61 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_1830D4000, v53, v61, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_79:
    if (v52) {
      free(v52);
    }
    goto LABEL_81;
  }
  int v20 = v19;
  char v21 = v19[231];

  if ((v21 & 4) != 0)
  {
    id v22 = nw_endpoint_copy_registrar_for_identifier(v20, (long long *)a1, 0);
    os_log_type_t v71 = v22;
    if (v22)
    {
      uint64_t instance_to_join = nw_protocol_instance_registrar_find_instance_to_join(v22, (void *)a1, a2, a7, 0, 0, v75, v76, v77, v18);
      if (instance_to_join)
      {
LABEL_33:

        goto LABEL_34;
      }
    }
    else if (gLogDatapath)
    {
      size_t v59 = __nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v20;
        *(_WORD *)&buf[22] = 2080;
        BOOL v84 = (void *)a1;
        LOWORD(v85) = 2048;
        *(void *)((char *)&v85 + 2) = a1;
        _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %@ does not have registrar for protocol %s (%p), continuing", buf, 0x2Au);
      }
    }
    id v24 = v75;
    id v25 = v20;
    id v26 = v76;
    id v27 = v77;
    id v28 = v24;
    id v29 = v25;
    id v30 = v26;
    id v31 = v27;
    if (gLogDatapath)
    {
      uint64_t v55 = __nwlog_obj();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "non-";
        *(_WORD *)&buf[22] = 2112;
        BOOL v84 = v29;
        LOWORD(v85) = 2112;
        *(void *)((char *)&v85 + 2) = v30;
        _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_DEBUG, "%{public}s checking %swildcard edges from %@ for destination %@", buf, 0x2Au);
      }
    }
    *(void *)os_log_type_t type = 0;
    os_log_type_t v80 = type;
    uint64_t v81 = 0x2020000000;
    uint64_t v82 = 0;
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke;
    BOOL v84 = &unk_1E523B090;
    char v90 = 0;
    os_log_type_t v87 = type;
    uint64_t v88 = a1;
    uint64_t v89 = a2;
    char v91 = a7;
    id v72 = v28;
    *(void *)&long long v85 = v72;
    id v32 = v30;
    *((void *)&v85 + 1) = v32;
    id v33 = v31;
    id v86 = v33;
    BOOL v73 = v29;
    nw_endpoint_enumerate_edges(v29, a1, buf);
    uint64_t instance_to_join = *((void *)v80 + 3);

    _Block_object_dispose(type, 8);
    if (!instance_to_join)
    {
      id v34 = v72;
      id v35 = v29;
      id v36 = v32;
      id v37 = v33;
      os_log_type_t v38 = v37;
      if (gLogDatapath)
      {
        id v70 = v37;
        char v60 = __nwlog_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&buf[22] = 2112;
          BOOL v84 = v35;
          LOWORD(v85) = 2112;
          *(void *)((char *)&v85 + 2) = v36;
          _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s checking %swildcard edges from %@ for destination %@", buf, 0x2Au);
        }

        os_log_type_t v38 = v70;
      }
      *(void *)os_log_type_t type = 0;
      os_log_type_t v80 = type;
      uint64_t v81 = 0x2020000000;
      uint64_t v82 = 0;
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke;
      BOOL v84 = &unk_1E523B090;
      char v90 = 1;
      os_log_type_t v87 = type;
      uint64_t v88 = a1;
      uint64_t v89 = a2;
      char v91 = a7;
      id v39 = v34;
      *(void *)&long long v85 = v39;
      id v40 = v36;
      *((void *)&v85 + 1) = v40;
      id v41 = v38;
      id v86 = v41;
      char v42 = v35;
      nw_endpoint_enumerate_edges(v35, a1, buf);
      uint64_t instance_to_join = *((void *)v80 + 3);

      _Block_object_dispose(type, 8);
    }

    goto LABEL_33;
  }
LABEL_81:
  uint64_t v62 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
  os_log_type_t v63 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v78 = 0;
  if (__nwlog_fault(v63, type, &v78))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v64 = __nwlog_obj();
      os_log_type_t v65 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s searching for a protocol to join requires a registered endpoint", buf, 0xCu);
      }
    }
    else if (v78)
    {
      __int16 v66 = (char *)__nw_create_backtrace_string();
      __int16 v64 = __nwlog_obj();
      os_log_type_t v67 = type[0];
      BOOL v68 = os_log_type_enabled(v64, type[0]);
      if (v66)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v66;
          _os_log_impl(&dword_1830D4000, v64, v67, "%{public}s searching for a protocol to join requires a registered endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v66);
        goto LABEL_97;
      }
      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl(&dword_1830D4000, v64, v67, "%{public}s searching for a protocol to join requires a registered endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v64 = __nwlog_obj();
      os_log_type_t v69 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl(&dword_1830D4000, v64, v69, "%{public}s searching for a protocol to join requires a registered endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_97:
  if (v63) {
    free(v63);
  }
LABEL_26:
  uint64_t instance_to_join = 0;
LABEL_34:

  return instance_to_join;
}

void sub_1833A84E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31,id a32,id a33)
{
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void nw_endpoint_enumerate_edges(void *a1, uint64_t a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a3;
  if (v6)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    id v27 = __Block_byref_object_copy__6444;
    id v28 = __Block_byref_object_dispose__6445;
    id v29 = 0;
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __nw_endpoint_enumerate_edges_block_invoke;
    v21[3] = &unk_1E524B978;
    os_log_type_t v23 = buf;
    id v7 = v5;
    id v22 = v7;
    nw_endpoint_locked(v7, v21);
    id v8 = *(atomic_uchar **)(*(void *)&buf[8] + 40);
    if (v8)
    {
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3221225472;
      void v17[2] = __nw_endpoint_enumerate_edges_block_invoke_2;
      v17[3] = &unk_1E523B728;
      id v18 = v7;
      uint64_t v20 = a2;
      id v19 = v6;
      nw_array_apply(v8, (uint64_t)v17);
    }
    _Block_object_dispose(buf, 8);

    goto LABEL_5;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
  int v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v10, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null enumerator", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null enumerator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v10) {
    free(v10);
  }
LABEL_5:
}

void sub_1833A897C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_registrar_for_identifier(void *a1, long long *a2, int a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (v5)
  {
    if (a2)
    {
      id v7 = v5[26];
      if (v7) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = a3 == 0;
      }
      if (v8)
      {
        if (v7 || (a3 & 1) != 0 || !gLogDatapath) {
          goto LABEL_17;
        }
        os_log_type_t v9 = a2;
        int v10 = __nwlog_obj();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
        __int16 v46 = 2080;
        uint64_t v47 = (char *)v9;
        __int16 v48 = 2080;
        logging_description = nw_endpoint_get_logging_description(v6);
        __int16 v50 = 2048;
        uint64_t v51 = v6;
        int v11 = "%{public}s no %s registrar for endpoint %s (%p), asked not to create a new one, returning nil";
        goto LABEL_41;
      }
      os_log_type_t v12 = [NWConcrete_nw_protocol_instance_registrar alloc];
      if (!v12) {
        goto LABEL_76;
      }
      v43.os_log_type_t receiver = v12;
      v43.super_class = (Class)NWConcrete_nw_protocol_instance_registrar;
      uint64_t v13 = objc_msgSendSuper2(&v43, sel_init);
      os_log_type_t v14 = v13;
      if (v13)
      {
        v13[2] = 0;
        nw_protocol_identifier_copy((uint64_t)(v13 + 3), a2);
        v14[8] = 0;
LABEL_16:
        id v15 = v6[26];
        v6[26] = v14;

        if (!gLogDatapath)
        {
LABEL_17:
          id v16 = v6[26];
          goto LABEL_18;
        }
        int v10 = __nwlog_obj();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
LABEL_42:

          goto LABEL_17;
        }
        id v29 = (char *)v6[26];
        uint64_t v30 = nw_endpoint_get_logging_description(v6);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
        __int16 v46 = 2112;
        uint64_t v47 = v29;
        __int16 v48 = 2080;
        logging_description = v30;
        __int16 v50 = 2048;
        uint64_t v51 = v6;
        int v11 = "%{public}s created registrar %@ for endpoint %s (%p)";
LABEL_41:
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, v11, buf, 0x2Au);
        goto LABEL_42;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
      id v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v41 = 0;
      if (__nwlog_fault(v32, &type, &v41))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v33 = (id)gLogObj;
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v33 = (id)gLogObj;
          os_log_type_t v36 = type;
          BOOL v37 = os_log_type_enabled(v33, type);
          if (backtrace_string)
          {
            if (v37)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
              __int16 v46 = 2082;
              uint64_t v47 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v33, v36, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_74;
          }
          if (v37)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_1830D4000, v33, v36, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v33 = (id)gLogObj;
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_1830D4000, v33, v40, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_74:
      if (v32) {
        free(v32);
      }
LABEL_76:
      os_log_type_t v14 = 0;
      goto LABEL_16;
    }
    id v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
    id v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v43.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v19, &v43, &type))
    {
      if (LOBYTE(v43.receiver) == 17)
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t receiver = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_1830D4000, v20, receiver, "%{public}s called with null identifier", buf, 0xCu);
        }
LABEL_64:

        goto LABEL_65;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v39 = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_1830D4000, v20, v39, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_64;
      }
      char v24 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v27 = (os_log_type_t)v43.receiver;
      BOOL v28 = os_log_type_enabled(v20, (os_log_type_t)v43.receiver);
      if (!v24)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
        __int16 v46 = 2082;
        uint64_t v47 = v24;
        _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_38;
    }
  }
  else
  {
    id v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
    id v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v43.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v19, &v43, &type))
    {
      if (LOBYTE(v43.receiver) == 17)
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v21 = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v38 = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_1830D4000, v20, v38, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_64;
      }
      char v24 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v25 = (os_log_type_t)v43.receiver;
      BOOL v26 = os_log_type_enabled(v20, (os_log_type_t)v43.receiver);
      if (!v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v45 = "nw_endpoint_copy_registrar_for_identifier";
        __int16 v46 = 2082;
        uint64_t v47 = v24;
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_38:

      free(v24);
    }
  }
LABEL_65:
  if (v19) {
    free(v19);
  }
  id v16 = 0;
LABEL_18:

  return v16;
}

void sub_1833A9290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_registrar_remove_instance(void *a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  if (!a2)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
          __int16 v28 = 2082;
          id v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v6) {
          goto LABEL_5;
        }
LABEL_43:
        free(v6);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_1830D4000, v7, v19, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (*(void *)(a2 + 16))
  {
    if (gLogDatapath)
    {
      int v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a2 + 16);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
        __int16 v28 = 2112;
        id v29 = v3;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        __int16 v32 = 2080;
        uint64_t v33 = v12;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %@ checking to remove instance %p of %s", buf, 0x2Au);
      }
    }
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_instance_registrar_remove_instance_block_invoke;
    aBlock[3] = &unk_1E52491B0;
    id v22 = v3;
    uint64_t v23 = a2;
    id v4 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 2);
    v4[2](v4);
    os_unfair_lock_unlock(v3 + 2);

    goto LABEL_5;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v6, &type, &v24)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null protocol->identifier", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v24)
  {
    id v7 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
      _os_log_impl(&dword_1830D4000, v7, v20, "%{public}s called with null protocol->identifier, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  id v16 = (char *)__nw_create_backtrace_string();
  id v7 = __nwlog_obj();
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v7, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
      _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null protocol->identifier, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v27 = "nw_protocol_instance_registrar_remove_instance";
    __int16 v28 = 2082;
    id v29 = v16;
    _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v6) {
    goto LABEL_43;
  }
LABEL_5:
}

void sub_1833A9880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void nw_protocol_identifier_copy(uint64_t a1, long long *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      long long v2 = *a2;
      long long v3 = a2[1];
      *(void *)(a1 + 32) = *((void *)a2 + 4);
      *(_OWORD *)a1 = v2;
      *(_OWORD *)(a1 + 16) = v3;
      return;
    }
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_identifier_copy";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_identifier_copy";
          os_log_type_t v8 = "%{public}s called with null source";
          goto LABEL_32;
        }
      }
      else
      {
        if (v14)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          id v6 = __nwlog_obj();
          os_log_type_t v7 = type;
          BOOL v13 = os_log_type_enabled(v6, type);
          if (backtrace_string)
          {
            if (v13)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v17 = "nw_protocol_identifier_copy";
              __int16 v18 = 2082;
              os_log_type_t v19 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (v5) {
              goto LABEL_35;
            }
            return;
          }
          if (!v13) {
            goto LABEL_33;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_identifier_copy";
          os_log_type_t v8 = "%{public}s called with null source, no backtrace";
          goto LABEL_32;
        }
        id v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_identifier_copy";
          os_log_type_t v8 = "%{public}s called with null source, backtrace limit exceeded";
          goto LABEL_32;
        }
      }
      goto LABEL_33;
    }
  }
  else
  {
    id v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_identifier_copy";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_protocol_identifier_copy";
        os_log_type_t v8 = "%{public}s called with null destination";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
LABEL_33:

      goto LABEL_34;
    }
    if (!v14)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_protocol_identifier_copy";
        os_log_type_t v8 = "%{public}s called with null destination, backtrace limit exceeded";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    os_log_type_t v10 = (char *)__nw_create_backtrace_string();
    id v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v11 = os_log_type_enabled(v6, type);
    if (!v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_protocol_identifier_copy";
        os_log_type_t v8 = "%{public}s called with null destination, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v17 = "nw_protocol_identifier_copy";
      __int16 v18 = 2082;
      os_log_type_t v19 = v10;
      _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null destination, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v10);
  }
LABEL_34:
  if (v5) {
LABEL_35:
  }
    free(v5);
}

void __nw_protocol_instance_registrar_remove_instance_block_invoke(uint64_t a1)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 16);
  if (v1)
  {
    p_cache = NWConcrete_nw_resolution_report.cache;
    id v4 = &nwlog_legacy_init(void)::init_once;
    id v5 = (id *)&unk_1EB267000;
    while (1)
    {
      id v6 = (void *)*v1;
      if (v1[2] != *(void *)(a1 + 40)) {
        goto LABEL_5;
      }
      if (*((unsigned char *)p_cache + 3665))
      {
        __int16 v30 = __nwlog_obj();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v31 = *(const char **)(a1 + 32);
          uint64_t v32 = *(void *)(a1 + 40);
          uint64_t v33 = *(void *)(v32 + 16);
          *(_DWORD *)buf = 136446978;
          BOOL v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
          __int16 v38 = 2112;
          os_log_type_t v39 = v31;
          __int16 v40 = 2048;
          uint64_t v41 = v32;
          __int16 v42 = 2080;
          uint64_t v43 = v33;
          _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %@ found instance %p of %s, removing", buf, 0x2Au);
        }
      }
      os_log_type_t v7 = (void *)v1[3];
      v1[3] = 0;

      os_log_type_t v8 = (void *)*v1;
      if (*v1) {
        v8[1] = v1[1];
      }
      *(void *)v1[1] = v8;
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)(v9 + 64);
      *(void *)(v9 + 64) = v10 - 1;
      if (!v10) {
        break;
      }
LABEL_4:
      free(v1);
LABEL_5:
      uint64_t v1 = v6;
      if (!v6) {
        return;
      }
    }
    pthread_once(v4, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = v5[237];
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 64);
    *(_DWORD *)buf = 136446978;
    BOOL v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
    __int16 v38 = 2082;
    os_log_type_t v39 = "registrar->instance_count";
    __int16 v40 = 2048;
    uint64_t v41 = 1;
    __int16 v42 = 2048;
    uint64_t v43 = v12;
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v13, &type, &v34))
    {
LABEL_24:
      if (!v13) {
        goto LABEL_3;
      }
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(v4, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = v5[237];
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
LABEL_23:

        goto LABEL_24;
      }
      uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 64);
      *(_DWORD *)buf = 136446978;
      BOOL v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
      __int16 v38 = 2082;
      os_log_type_t v39 = "registrar->instance_count";
      __int16 v40 = 2048;
      uint64_t v41 = 1;
      __int16 v42 = 2048;
      uint64_t v43 = v16;
      os_log_type_t v17 = v14;
      os_log_type_t v18 = v15;
      os_log_type_t v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
    }
    else
    {
      if (v34)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v21 = v4;
        pthread_once(v4, nwlog_legacy_init_once);
        networkd_settings_init();
        id v22 = v5;
        uint64_t v23 = v5[237];
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v23, type);
        if (backtrace_string)
        {
          if (v25)
          {
            uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 64);
            *(_DWORD *)buf = 136447234;
            BOOL v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
            __int16 v38 = 2082;
            os_log_type_t v39 = "registrar->instance_count";
            __int16 v40 = 2048;
            uint64_t v41 = 1;
            __int16 v42 = 2048;
            uint64_t v43 = v26;
            __int16 v44 = 2082;
            os_log_type_t v45 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(backtrace_string);
        }
        else
        {
          if (v25)
          {
            uint64_t v29 = *(void *)(*(void *)(a1 + 32) + 64);
            *(_DWORD *)buf = 136446978;
            BOOL v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
            __int16 v38 = 2082;
            os_log_type_t v39 = "registrar->instance_count";
            __int16 v40 = 2048;
            uint64_t v41 = 1;
            __int16 v42 = 2048;
            uint64_t v43 = v29;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace", buf, 0x2Au);
          }
        }
        id v5 = v22;
        id v4 = v21;
        p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
        if (!v13) {
          goto LABEL_3;
        }
LABEL_30:
        free(v13);
LABEL_3:
        *(void *)(*(void *)(a1 + 32) + 64) = 0;
        goto LABEL_4;
      }
      pthread_once(v4, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = v5[237];
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_23;
      }
      uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 64);
      *(_DWORD *)buf = 136446978;
      BOOL v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
      __int16 v38 = 2082;
      os_log_type_t v39 = "registrar->instance_count";
      __int16 v40 = 2048;
      uint64_t v41 = 1;
      __int16 v42 = 2048;
      uint64_t v43 = v28;
      os_log_type_t v17 = v14;
      os_log_type_t v18 = v27;
      os_log_type_t v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0x2Au);
    goto LABEL_23;
  }
}

BOOL nw_protocol_metadata_is_http_connection(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = a1;
    id v2 = v1[1];

    if (nw_protocol_copy_http_connection_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_89);
    }
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v2, nw_protocol_copy_http_connection_definition_definition);

    return is_equal_unsafe;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_protocol_metadata_is_http_connection";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_metadata_is_http_connection";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_protocol_metadata_is_http_connection";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_metadata_is_http_connection";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_metadata_is_http_connection";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v6) {
    free(v6);
  }
  return 0;
}

id nw_path_evaluator_copy_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 24);
    id v3 = *(id *)&v2[2]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 24);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_path_evaluator_copy_parameters";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_evaluator_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_path_evaluator_copy_parameters";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_evaluator_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_evaluator_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_http_transaction_metadata_get_start_reason(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_transaction_definition_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      int v26 = 0;
      *(void *)&buf[16] = 0x2020000000;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_transaction_metadata_get_start_reason_block_invoke;
      v22[3] = &unk_1E5248E90;
      void v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_transaction_metadata_get_start_reason_block_invoke((uint64_t)v22, isa);
        id v6 = (unsigned int *)(*(void *)&buf[8] + 24);
      }
      else
      {
        id v6 = (unsigned int *)&v26;
      }
      uint64_t v7 = *v6;
      _Block_object_dispose(buf, 8);
      goto LABEL_9;
    }
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http_transaction", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http_transaction, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_start_reason";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0;
LABEL_9:

  return v7;
}

void nw_http_metadata_add_header(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v39 = "nw_http_metadata_add_header";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v12, &v37, &v36)) {
      goto LABEL_75;
    }
    if (v37 == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v22 = v37;
      BOOL v23 = os_log_type_enabled(v13, v37);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v39 = "nw_http_metadata_add_header";
          __int16 v40 = 2082;
          uint64_t v41 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_75:
        if (!v12) {
          goto LABEL_9;
        }
LABEL_76:
        free(v12);
        goto LABEL_9;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v31 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v31, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_74:

    goto LABEL_75;
  }
  id v7 = v5;
  id v8 = *((id *)v7 + 1);

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v8, nw_protocol_copy_http_definition_http_definition);

  if (!is_equal_unsafe)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v39 = "nw_http_metadata_add_header";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v12, &v37, &v36)) {
      goto LABEL_75;
    }
    if (v37 == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v16 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s metadata must be http", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v36)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v32 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v32, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    os_log_type_t v24 = (char *)__nw_create_backtrace_string();
    char v13 = __nwlog_obj();
    os_log_type_t v25 = v37;
    BOOL v26 = os_log_type_enabled(v13, v37);
    if (!v24)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v39 = "nw_http_metadata_add_header";
      __int16 v40 = 2082;
      uint64_t v41 = v24;
      _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
  if (!a2)
  {
    BOOL v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v39 = "nw_http_metadata_add_header";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v12, &v37, &v36)) {
      goto LABEL_75;
    }
    if (v37 == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v18 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null name", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v36)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v33 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v33, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    os_log_type_t v24 = (char *)__nw_create_backtrace_string();
    char v13 = __nwlog_obj();
    os_log_type_t v27 = v37;
    BOOL v28 = os_log_type_enabled(v13, v37);
    if (!v24)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v27, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v39 = "nw_http_metadata_add_header";
      __int16 v40 = 2082;
      uint64_t v41 = v24;
      _os_log_impl(&dword_1830D4000, v13, v27, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
  if (!a3)
  {
    BOOL v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v39 = "nw_http_metadata_add_header";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v12, &v37, &v36)) {
      goto LABEL_75;
    }
    if (v37 == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v20 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null value", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v36)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v34 = v37;
      if (os_log_type_enabled(v13, v37))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v34, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    os_log_type_t v24 = (char *)__nw_create_backtrace_string();
    char v13 = __nwlog_obj();
    os_log_type_t v29 = v37;
    BOOL v30 = os_log_type_enabled(v13, v37);
    if (!v24)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v39 = "nw_http_metadata_add_header";
        _os_log_impl(&dword_1830D4000, v13, v29, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v39 = "nw_http_metadata_add_header";
      __int16 v40 = 2082;
      uint64_t v41 = v24;
      _os_log_impl(&dword_1830D4000, v13, v29, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_49:

    free(v24);
    if (!v12) {
      goto LABEL_9;
    }
    goto LABEL_76;
  }
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 3221225472;
  v35[2] = __nw_http_metadata_add_header_block_invoke;
  v35[3] = &__block_descriptor_48_e9_B16__0_v8l;
  void v35[4] = a2;
  v35[5] = a3;
  uint64_t v10 = *((void *)v7 + 4);
  if (v10) {
    __nw_http_metadata_add_header_block_invoke((uint64_t)v35, v10);
  }
LABEL_9:
}

BOOL nw_application_id_copy_redacted_description(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    id v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_application_id_copy_redacted_description";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v9, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_application_id_copy_redacted_description";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null application_id", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v27 = "nw_application_id_copy_redacted_description";
            __int16 v28 = 2082;
            uint64_t v29 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null application_id, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_application_id_copy_redacted_description";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null application_id, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_application_id_copy_redacted_description";
          _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s called with null application_id, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v9) {
      free(v9);
    }
    id v6 = 0;
    goto LABEL_5;
  }
  id v3 = [v1 redactedDescription];
  uint64_t v4 = [v3 length];
  size_t v5 = v4 + 1;
  if (v4 == -1)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_application_id_copy_redacted_description";
    char v13 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v13);
    if (result) {
      goto LABEL_30;
    }
    free(v13);
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "strict_calloc";
    LODWORD(v23) = 12;
    os_log_type_t v22 = buf;
    os_log_type_t v15 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v15);
    if (result) {
      goto LABEL_30;
    }
    free(v15);
  }
  id v6 = malloc_type_calloc(1uLL, v5, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_4:
    objc_msgSend(v3, "getCString:maxLength:encoding:", v6, v5, 4, v22, v23);

LABEL_5:
    return (BOOL)v6;
  }
  os_log_type_t v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v27 = "strict_calloc";
  __int16 v28 = 2048;
  uint64_t v29 = 1;
  __int16 v30 = 2048;
  size_t v31 = v5;
  LODWORD(v23) = 32;
  os_log_type_t v22 = buf;
  BOOL v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_4;
  }
LABEL_30:
  __break(1u);
  return result;
}

void sub_1833ABD34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_http_client_options_copy_resend_handler_block_invoke(uint64_t a1, const void **a2)
{
  id v3 = _Block_copy(*a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  size_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return 1;
}

uint64_t nw_http_transaction_metadata_get_outbound_message_end_time(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_transaction_definition_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      uint64_t v25 = 0;
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_http_transaction_metadata_get_outbound_message_end_time_block_invoke;
      v21[3] = &unk_1E5248E90;
      void v21[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_transaction_metadata_get_outbound_message_end_time_block_invoke((uint64_t)v21, isa);
        uint64_t v6 = *(void *)(*(void *)&buf[8] + 24);
      }
      else
      {
        uint64_t v6 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_9;
    }
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s metadata must be http_transaction", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v22)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s metadata must be http_transaction, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    id v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v22)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_outbound_message_end_time";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0;
LABEL_9:

  return v6;
}

void nw_http_transaction_metadata_set_connection_metadata(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &type, &v26)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
          __int16 v30 = 2082;
          size_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_8;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_transaction_definition_definition);

  if (is_equal_unsafe)
  {
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __nw_http_transaction_metadata_set_connection_metadata_block_invoke;
    v24[3] = &unk_1E5248F68;
    id v8 = v4;
    id v25 = v8;
    uint64_t v9 = *((void *)v5 + 4);
    if (v9)
    {
      __nw_http_transaction_metadata_set_connection_metadata_block_invoke((uint64_t)v24, v9);
      id v8 = v25;
    }

    goto LABEL_8;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v11, &type, &v26)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s metadata must be http_transaction", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v26)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s metadata must be http_transaction, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  os_log_type_t v19 = (char *)__nw_create_backtrace_string();
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v29 = "nw_http_transaction_metadata_set_connection_metadata";
    __int16 v30 = 2082;
    size_t v31 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_43;
  }
LABEL_8:
}

void __nw_listener_start_block_invoke_56(uint64_t a1)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 128))
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (!v3 || nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104))) {
      return;
    }
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
    }
    id v4 = (id)glistenerLogObj;
    id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
    int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 128);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = id_string;
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&unsigned char buf[24] = 0;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v6;
    id v7 = (void *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v124) = 0;
    if (__nwlog_fault((const char *)v7, type, &v124))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        id v8 = (id)glistenerLogObj;
        os_log_type_t v9 = type[0];
        if (os_log_type_enabled(v8, type[0]))
        {
          uint64_t v10 = nw_listener_get_id_string(*(void **)(a1 + 32));
          int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 128);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v10;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 0;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v11;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s [%{public}s] In wrong state for start. Expected %d, got %d.", buf, 0x22u);
        }
      }
      else if ((_BYTE)v124)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        id v8 = (id)glistenerLogObj;
        os_log_type_t v21 = type[0];
        BOOL v22 = os_log_type_enabled(v8, type[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            os_log_type_t v23 = nw_listener_get_id_string(*(void **)(a1 + 32));
            int v24 = *(_DWORD *)(*(void *)(a1 + 32) + 128);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v23;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 0;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v24;
            *(_WORD *)&buf[34] = 2082;
            *(void *)&buf[36] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v21, "%{public}s [%{public}s] In wrong state for start. Expected %d, got %d., dumping backtrace:%{public}s", buf, 0x2Cu);
          }

          free(backtrace_string);
          if (!v7) {
            return;
          }
LABEL_65:
          free(v7);
          return;
        }
        if (v22)
        {
          uint64_t v47 = nw_listener_get_id_string(*(void **)(a1 + 32));
          int v48 = *(_DWORD *)(*(void *)(a1 + 32) + 128);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v47;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 0;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v48;
          _os_log_impl(&dword_1830D4000, v8, v21, "%{public}s [%{public}s] In wrong state for start. Expected %d, got %d., no backtrace", buf, 0x22u);
        }
      }
      else
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        id v8 = (id)glistenerLogObj;
        os_log_type_t v30 = type[0];
        if (os_log_type_enabled(v8, type[0]))
        {
          size_t v31 = nw_listener_get_id_string(*(void **)(a1 + 32));
          int v32 = *(_DWORD *)(*(void *)(a1 + 32) + 128);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v31;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 0;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v32;
          _os_log_impl(&dword_1830D4000, v8, v30, "%{public}s [%{public}s] In wrong state for start. Expected %d, got %d., backtrace limit exceeded", buf, 0x22u);
        }
      }
    }
    if (!v7) {
      return;
    }
    goto LABEL_65;
  }
  *(void *)os_log_type_t type = 0;
  char v129 = type;
  uint64_t v130 = 0x2020000000;
  char v131 = 0;
  uint64_t v124 = 0;
  id v125 = &v124;
  uint64_t v126 = 0x2020000000;
  char v127 = 0;
  uint64_t v120 = 0;
  os_log_type_t v121 = &v120;
  uint64_t v122 = 0x2020000000;
  char v123 = 0;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_listener_start_block_invoke_57;
  aBlock[3] = &unk_1E523DE78;
  uint64_t v117 = type;
  id v116 = (id)v2;
  __int16 v118 = &v124;
  uint64_t v119 = &v120;
  os_log_type_t v12 = (void (**)(void))_Block_copy(aBlock);
  os_log_type_t v13 = (os_unfair_lock_s *)(v2 + 8);
  os_unfair_lock_lock(v13);
  v12[2](v12);
  os_unfair_lock_unlock(v13);

  if (*((unsigned char *)v129 + 24))
  {
    uint64_t v14 = *(void *)(a1 + 32);
    if (*((unsigned char *)v125 + 24))
    {
      uint64_t v15 = *(void *)(v14 + 16);
      if (v15 && !nw_path_parameters_get_logging_disabled(*(void *)(v15 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        BOOL v16 = (id)glistenerLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v17 = nw_listener_get_id_string(*(void **)(a1 + 32));
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke_2";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v17;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Started with setting both new connection handler and new connection group handler", buf, 0x16u);
        }
      }
LABEL_22:
      BOOL v18 = *(void **)(a1 + 32);
      os_log_type_t v19 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
      nw_listener_set_state_on_queue(v18, 3, v19);

      goto LABEL_196;
    }
    if (!*(void *)(v14 + 32)) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }
  uint64_t v14 = *(void *)(a1 + 32);
  if (*(void *)(v14 + 32))
  {
LABEL_47:
    if (!*((unsigned char *)v121 + 24))
    {
      uint64_t v62 = *(void *)(v14 + 16);
      if (v62 && !nw_path_parameters_get_logging_disabled(*(void *)(v62 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        os_log_type_t v63 = (id)glistenerLogObj;
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          __int16 v64 = nw_listener_get_id_string(*(void **)(a1 + 32));
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v64;
          _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Started without setting new packet handler", buf, 0x16u);
        }
      }
      goto LABEL_22;
    }
    goto LABEL_48;
  }
  if (!*((unsigned char *)v125 + 24))
  {
    uint64_t v25 = *(void *)(v14 + 16);
    if (v25 && !nw_path_parameters_get_logging_disabled(*(void *)(v25 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      char v26 = (id)glistenerLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v27 = nw_listener_get_id_string(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v27;
        _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Started without setting either new connection handler or new connection group handler", buf, 0x16u);
      }
    }
    __int16 v28 = *(void **)(a1 + 32);
    posix_CFErrorRef error = nw_error_create_posix_error(22);
    nw_listener_set_state_on_queue(v28, 3, posix_error);

    goto LABEL_196;
  }
LABEL_48:
  objc_storeStrong((id *)(v14 + 256), (id)v14);
  if (*((unsigned char *)v125 + 24)) {
    nw_parameters_set_attach_protocol_listener(*(void **)(*(void *)(a1 + 32) + 16), 0);
  }
  BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 16));
  *(_DWORD *)(*(void *)(a1 + 32) + 72) = *(_DWORD *)(a1 + 40);
  os_log_type_t v34 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(*(void *)(a1 + 32) + 16), 1);
  id v35 = *(void **)(a1 + 32);
  if (v35[6])
  {
    if (!logging_disabled)
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      char v36 = (id)glistenerLogObj;
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = *(void *)(a1 + 32);
        int v38 = *(unsigned __int16 *)(v37 + 40);
        uint64_t v39 = *(void *)(v37 + 48);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v38;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v34;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v39;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEFAULT, "[L%u %{public}s] start for connection %@", buf, 0x1Cu);
      }

      id v35 = *(void **)(a1 + 32);
    }
    __int16 v40 = v35;
    nw_context_assert_queue((void *)v40[3]);
    uint64_t v41 = (void *)v40[6];
    uint64_t v42 = (uint64_t *)v40[2];
    if (v41)
    {
      uint64_t listener_protocol_on_nw_queue = nw_connection_get_listener_protocol_on_nw_queue(v41, v42, 0);
      if (listener_protocol_on_nw_queue)
      {
        __int16 v44 = -[nw_listener_inbox_protocol initWithProtocol:delegate:]([nw_listener_inbox_protocol alloc], listener_protocol_on_nw_queue, v40);
        if (v44)
        {
          BOOL v45 = nw_array_create();
          uint64_t v46 = (void *)v40[18];
          v40[18] = v45;

          nw_array_append(v40[18], v44);
          nw_listener_set_state_on_queue(v40, 2, 0);
LABEL_193:

          goto LABEL_194;
        }
        uint64_t v78 = v40[2];
        if (v78 && !nw_path_parameters_get_logging_disabled(*(void *)(v78 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
          }
          os_log_type_t v79 = (id)glistenerLogObj;
          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            os_log_type_t v80 = nw_listener_get_id_string(v40);
            uint64_t v81 = *(void *)(listener_protocol_on_nw_queue + 16);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_listener_start_connection_on_queue";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v80;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&unsigned char buf[24] = v81;
            _os_log_impl(&dword_1830D4000, v79, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Failed to create inbox for %{public}s", buf, 0x20u);
          }
        }
        os_log_type_t v67 = v40;
        uint64_t v82 = nw_error_create_posix_error(12);
        nw_listener_set_state_on_queue(v67, 3, v82);
      }
      else
      {
        uint64_t v68 = v40[2];
        if (v68 && !nw_path_parameters_get_logging_disabled(*(void *)(v68 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
          }
          os_log_type_t v69 = (id)glistenerLogObj;
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
            id v70 = nw_listener_get_id_string(v40);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_start_connection_on_queue";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v70;
            _os_log_impl(&dword_1830D4000, v69, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Listener could not find protocol to join in connection", buf, 0x16u);
          }
        }
        __int16 v44 = v40;
        os_log_type_t v67 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
        nw_listener_set_state_on_queue(v44, 3, v67);
      }
    }
    else
    {
      if (v42 && !nw_path_parameters_get_logging_disabled(v42[13]))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        os_log_type_t v65 = (id)glistenerLogObj;
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          __int16 v66 = nw_listener_get_id_string(v40);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_connection_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v66;
          _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Listener no longer has connection to join", buf, 0x16u);
        }
      }
      __int16 v44 = v40;
      os_log_type_t v67 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 57);
      nw_listener_set_state_on_queue(v44, 3, v67);
    }

    goto LABEL_193;
  }
  if (!v35[7])
  {
    if (!logging_disabled)
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      os_log_type_t v71 = (id)glistenerLogObj;
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        int v72 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 40);
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v72;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v34;
        _os_log_impl(&dword_1830D4000, v71, OS_LOG_TYPE_DEFAULT, "[L%u %{public}s] start", buf, 0x12u);
      }

      id v35 = *(void **)(a1 + 32);
    }
    __int16 v40 = v35;
    nw_context_assert_queue((void *)v40[3]);
    nw_listener_set_state_on_queue(v40, 1, 0);
    LODWORD(fds) = 12;
    evaluator_for_listener = nw_path_create_evaluator_for_listener((void *)v40[2], (int *)&fds);
    id v74 = (void *)v40[21];
    v40[21] = evaluator_for_listener;

    id v75 = (void *)v40[21];
    if (v75)
    {
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = ___ZL26nw_listener_start_on_queueP22NWConcrete_nw_listener_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E524AEE0;
      id v76 = v40;
      *(void *)&uint8_t buf[32] = v76;
      nw_path_evaluator_set_update_handler(v75, 0, buf);
      id v77 = nw_path_evaluator_copy_path((os_unfair_lock_s *)v40[21]);
      nw_listener_handle_new_path_on_queue(v76, v77);

      __int16 v44 = *(void **)&buf[32];
    }
    else
    {
      uint64_t v110 = v40[2];
      if (v110 && !nw_path_parameters_get_logging_disabled(*(void *)(v110 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        nw_endpoint_t v111 = (id)glistenerLogObj;
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
        {
          __int16 v112 = nw_listener_get_id_string(v40);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v112;
          _os_log_impl(&dword_1830D4000, v111, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] nw_path_create_evaluator_for_listener failed", buf, 0x16u);
        }
      }
      int v113 = (int)fds;
      __int16 v44 = v40;
      __int16 v114 = nw_error_create_posix_error(v113);
      nw_listener_set_state_on_queue(v44, 3, v114);
    }
    goto LABEL_193;
  }
  if (!logging_disabled)
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
    }
    os_log_type_t v49 = (id)glistenerLogObj;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v50 = *(void *)(a1 + 32);
      int v51 = *(unsigned __int16 *)(v50 + 40);
      uint64_t v52 = *(void *)(v50 + 56);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = v51;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v34;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v52;
      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEFAULT, "[L%u %{public}s] start for launchd key %{public}s", buf, 0x1Cu);
    }

    id v35 = *(void **)(a1 + 32);
  }
  BOOL v53 = v35;
  nw_context_assert_queue(*((void **)v53 + 3));
  BOOL v54 = nw_array_create();
  uint64_t v55 = (void *)*((void *)v53 + 18);
  *((void *)v53 + 18) = v54;

  size_t cnt = 0;
  fds = 0;
  int v56 = launch_activate_socket(*((const char **)v53 + 7), &fds, &cnt);
  if (v56)
  {
    uint64_t v57 = *((void *)v53 + 2);
    if (v57 && !nw_path_parameters_get_logging_disabled(*(void *)(v57 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      BOOL v58 = (id)glistenerLogObj;
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        size_t v59 = nw_listener_get_id_string(v53);
        uint64_t v60 = *((void *)v53 + 7);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v59;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&unsigned char buf[24] = v60;
        *(_WORD *)&uint8_t buf[32] = 1024;
        *(_DWORD *)&buf[34] = v56;
        _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] launch_activate_socket(%{public}s failed: %{darwin.errno}d", buf, 0x26u);
      }
    }
    os_log_type_t v61 = nw_error_create_posix_error(v56);
  }
  else
  {
    os_log_type_t v61 = 0;
  }
  nw_endpoint_t v83 = fds;
  if (!fds) {
    goto LABEL_178;
  }
  if (!cnt) {
    goto LABEL_177;
  }
  for (size_t i = 0; i < cnt; ++i)
  {
    if (v61)
    {
      close(fds[i]);
      continue;
    }
    socklen_t v132 = 4;
    int v133 = 0;
    if (getsockopt(fds[i], 0xFFFF, 4104, &v133, &v132)) {
      BOOL v85 = 0;
    }
    else {
      BOOL v85 = v133 == 1;
    }
    if (v85)
    {
      uint64_t v89 = [nw_listener_inbox_socket alloc];
      int v90 = fds[i];
      id v91 = *((id *)v53 + 2);
      uint64_t v92 = v53;
      if (v89)
      {
        uint64_t v93 = [(nw_listener_inbox_socket *)v89 initWithParameters:v91 delegate:v92];
        os_log_type_t v94 = v93;
        if (!v93 || v90 < 0)
        {
          uint64_t v89 = 0;
        }
        else
        {
          v93->_sockfd_from_client = v90;
          os_log_type_t v94 = v93;
          uint64_t v89 = v94;
        }
      }
      else
      {
        os_log_type_t v94 = 0;
      }

      if (!v89)
      {
        os_log_type_t v61 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 45);
        uint64_t v100 = *((void *)v53 + 2);
        if (v100 && !nw_path_parameters_get_logging_disabled(*(void *)(v100 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
          }
          os_log_type_t v101 = (id)glistenerLogObj;
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
            BOOL v102 = nw_listener_get_id_string(v92);
            uint64_t v103 = *((void *)v53 + 7);
            size_t v104 = *((void *)v53 + 2);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v102;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&unsigned char buf[24] = v103;
            *(_WORD *)&uint8_t buf[32] = 2048;
            *(void *)&buf[34] = i;
            *(_WORD *)&buf[42] = 2114;
            size_t v137 = v104;
            _os_log_impl(&dword_1830D4000, v101, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Failed to create inbox for %{public}s[%zu] with parameters %{public}@", buf, 0x34u);
          }
        }
        close(fds[i]);
        goto LABEL_174;
      }
      os_log_type_t v61 = [(nw_listener_inbox_socket *)v89 start];
      uint64_t v95 = *((void *)v53 + 2);
      if (v61)
      {
        if (!v95 || nw_path_parameters_get_logging_disabled(*(void *)(v95 + 104))) {
          goto LABEL_174;
        }
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        os_log_type_t v96 = (id)glistenerLogObj;
        if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
        {
          id v97 = nw_listener_get_id_string(v92);
          size_t v98 = *((void *)v53 + 7);
          uint64_t v99 = *((void *)v53 + 2);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v97;
          *(_WORD *)&buf[22] = 2114;
          *(void *)&unsigned char buf[24] = v61;
          *(_WORD *)&uint8_t buf[32] = 2114;
          *(void *)&buf[34] = v89;
          *(_WORD *)&buf[42] = 2082;
          size_t v137 = v98;
          __int16 v138 = 2048;
          size_t v139 = i;
          __int16 v140 = 2114;
          uint64_t v141 = v99;
          _os_log_impl(&dword_1830D4000, v96, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Error %{public}@ starting inbox %{public}@ for %{public}s[%zu] with parameters %{public}@", buf, 0x48u);
        }
      }
      else
      {
        if (v95 && !nw_path_parameters_get_logging_disabled(*(void *)(v95 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
          }
          os_log_type_t v105 = (id)glistenerLogObj;
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v106 = nw_listener_get_id_string(v92);
            uint64_t v107 = *((void *)v53 + 7);
            size_t v108 = *((void *)v53 + 2);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v106;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&unsigned char buf[24] = v89;
            *(_WORD *)&uint8_t buf[32] = 2082;
            *(void *)&buf[34] = v107;
            *(_WORD *)&buf[42] = 2048;
            size_t v137 = i;
            __int16 v138 = 2114;
            size_t v139 = v108;
            _os_log_impl(&dword_1830D4000, v105, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public}s] Started inbox %{public}@ for %{public}s[%zu] with parameters %{public}@", buf, 0x3Eu);
          }
        }
        os_log_type_t v96 = [(nw_listener_inbox *)v89 local_endpoint];
        if (v96) {
          nw_listener_set_local_endpoint_on_queue(v92, v96);
        }
        nw_array_append(*((void *)v53 + 18), v89);
      }

LABEL_174:
      continue;
    }
    uint64_t v86 = *((void *)v53 + 2);
    if (v86 && !nw_path_parameters_get_logging_disabled(*(void *)(v86 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      os_log_type_t v87 = (id)glistenerLogObj;
      if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
      {
        uint64_t v88 = *((void *)v53 + 7);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v53 + 42;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&unsigned char buf[24] = v88;
        *(_WORD *)&uint8_t buf[32] = 2048;
        *(void *)&buf[34] = i;
        _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] socket %{public}s[%zu] not SOCK_STREAM - not supported", buf, 0x2Au);
      }
    }
    os_log_type_t v61 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 45);
    close(fds[i]);
  }
  nw_endpoint_t v83 = fds;
  if (fds)
  {
LABEL_177:
    free(v83);
    fds = 0;
  }
LABEL_178:
  if (!v61)
  {
    uint64_t v109 = *((void *)v53 + 18);
    if (v109 && *(void *)(v109 + 24) != *(void *)(v109 + 16))
    {
      os_log_type_t v61 = 0;
      nw_listener_set_state_on_queue(v53, 2, 0);
      goto LABEL_184;
    }
    os_log_type_t v61 = nw_error_create_posix_error(22);
  }
  nw_listener_set_state_on_queue(v53, 3, v61);
LABEL_184:

LABEL_194:
  if (v34) {
    free(v34);
  }
LABEL_196:

  _Block_object_dispose(&v120, 8);
  _Block_object_dispose(&v124, 8);
  _Block_object_dispose(type, 8);
}

void sub_1833ADE68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose(&a38, 8);
  _Unwind_Resume(a1);
}

void sub_1833AE8E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

os_unfair_lock_s *nw_path_evaluator_copy_path(os_unfair_lock_s *result)
{
  if (result)
  {
    id v1 = result + 24;
    uint64_t v2 = result;
    os_unfair_lock_lock(v1);
    id v3 = v2[6];
    os_unfair_lock_unlock(v1);

    return (os_unfair_lock_s *)v3;
  }
  return result;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_listener(void *a1, int *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  if (!v4)
  {
    BOOL v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
    uint64_t v14 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault((const char *)v14, &type, &v27))
    {
LABEL_30:
      if (!v14)
      {
LABEL_32:
        os_log_type_t v12 = 0;
        goto LABEL_33;
      }
LABEL_31:
      free(v14);
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s called with null parameters", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (!v27)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_1830D4000, v15, v26, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v15 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
      __int16 v31 = 2082;
      int v32 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_22;
  }
  id v5 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  int v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v13 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
    uint64_t v14 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault((const char *)v14, &type, &v27)) {
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (id)gLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
LABEL_29:

      goto LABEL_30;
    }
    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (id)gLogObj;
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = (id)gLogObj;
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
      __int16 v31 = 2082;
      int v32 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_22:

    free(backtrace_string);
    if (!v14) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  objc_storeStrong((id *)v5 + 1, a1);
  *((unsigned char *)v6 + 107) |= 2u;
  id v7 = (id *)v4;
  id v8 = v7[19];

  if (v8)
  {
    os_log_type_t v9 = (id *)v8;
    id v10 = v9[3];

    if (v10 && nw_protocol_options_is_custom_ip(v10)) {
      *((unsigned char *)v6 + 106) = nw_custom_ip_options_get_protocol(v10);
    }
  }
  if ((nw_path_evaluator_evaluate(v6, a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v30 = "nw_path_create_evaluator_for_listener";
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    int v6 = 0;
  }
  os_log_type_t v12 = v6;

LABEL_33:
  return v12;
}

void sub_1833AF400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *__nw_listener_start_block_invoke_57(void *result)
{
  *(unsigned char *)(*(void *)(result[5] + 8) + 24) = *(void *)(result[4] + 88) != 0;
  *(unsigned char *)(*(void *)(result[6] + 8) + 24) = *(void *)(result[4] + 96) != 0;
  *(unsigned char *)(*(void *)(result[7] + 8) + 24) = *(void *)(result[4] + 112) != 0;
  return result;
}

uint64_t nw_quic_connection_get_peer_idle_timeout(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    uint64_t v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_peer_idle_timeout_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    uint64_t v2 = *(void *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_quic_connection_get_peer_idle_timeout";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_get_peer_idle_timeout";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_connection_get_peer_idle_timeout";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_get_peer_idle_timeout";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_get_peer_idle_timeout";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_1833AF798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_peer_idle_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  uint64_t v5 = *(void *)(a2 + 152);
  if (v5) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

id nw_quic_connection_copy_sec_protocol_metadata(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v16 = __Block_byref_object_copy__55989;
    uint64_t v17 = __Block_byref_object_dispose__55990;
    id v18 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_copy_sec_protocol_metadata_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    id v2 = *(id *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  id v2 = 0;
LABEL_3:

  return v2;
}

void sub_1833AFB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_copy_sec_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t nw_path_get_reason(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[95];
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_path_get_reason";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_get_reason";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_path_get_reason";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_get_reason";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_get_reason";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_parameters_clear_proxy_options(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void *)*((void *)v1 + 21);
    *((void *)v1 + 21) = 0;

    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_parameters_clear_proxy_options";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_parameters_clear_proxy_options";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v15 = "nw_parameters_clear_proxy_options";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_parameters_clear_proxy_options";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_parameters_clear_proxy_options";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

double __nw_protocol_http_connect_identifier_block_invoke()
{
  unk_1EB2675BD = 0;
  unk_1EB2675B5 = 0;
  dword_1EB2675C4 = 0;
  strcpy((char *)&g_http_connect_protocol_identifier, "http_connect");
  *(void *)&double result = 0x100000004;
  qword_1EB2675C8 = 0x100000004;
  qword_1EB267370 = (uint64_t)nw_protocol_default_replace_input_handler;
  qword_1EB2673A8 = (uint64_t)nw_protocol_default_output_available;
  qword_1EB267420 = (uint64_t)nw_protocol_default_output_finished;
  qword_1EB267468 = (uint64_t)nw_protocol_default_input_flush;
  qword_1EB267458 = (uint64_t)nw_protocol_default_get_message_properties;
  qword_1EB2673C8 = (uint64_t)nw_protocol_default_link_state;
  qword_1EB267408 = (uint64_t)nw_protocol_default_updated_path;
  qword_1EB267428 = (uint64_t)nw_protocol_default_get_output_local;
  qword_1EB267430 = (uint64_t)nw_protocol_default_get_output_interface;
  qword_1EB267378 = (uint64_t)nw_protocol_default_connect;
  qword_1EB267380 = (uint64_t)nw_protocol_default_disconnect;
  qword_1EB267460 = (uint64_t)nw_protocol_default_reset;
  qword_1EB267410 = (uint64_t)nw_protocol_default_supports_external_data;
  qword_1EB267438 = (uint64_t)nw_protocol_default_waiting_for_output;
  qword_1EB2673F0 = (uint64_t)nw_protocol_default_register_notification;
  qword_1EB2673F8 = (uint64_t)nw_protocol_default_unregister_notification;
  qword_1EB267400 = (uint64_t)nw_protocol_default_notify;
  qword_1EB267448 = (uint64_t)nw_protocol_default_add_listen_handler;
  qword_1EB267450 = (uint64_t)nw_protocol_default_remove_listen_handler;
  g_http_connect_protocol_callbacks = (uint64_t)nw_protocol_http_connect_add_input_handler;
  qword_1EB267368 = (uint64_t)nw_protocol_http_connect_remove_input_handler;
  qword_1EB2673A0 = (uint64_t)nw_protocol_http_connect_input_available;
  qword_1EB267418 = (uint64_t)nw_protocol_http_connect_input_finished;
  qword_1EB2673B0 = (uint64_t)nw_protocol_http_connect_get_input_frames;
  qword_1EB2673B8 = (uint64_t)nw_protocol_http_connect_get_output_frames;
  qword_1EB2673C0 = (uint64_t)nw_protocol_http_connect_finalize_output_frames;
  qword_1EB267388 = (uint64_t)nw_protocol_http_connect_connected;
  qword_1EB267390 = (uint64_t)nw_protocol_http_connect_disconnected;
  qword_1EB267398 = (uint64_t)nw_protocol_http_connect_error;
  qword_1EB267440 = (uint64_t)nw_protocol_http_connect_copy_info;
  qword_1EB2673D0 = (uint64_t)nw_protocol_http_connect_get_parameters;
  qword_1EB2673D8 = (uint64_t)nw_protocol_http_connect_get_path;
  qword_1EB2673E0 = (uint64_t)nw_protocol_http_connect_get_local_endpoint;
  qword_1EB2673E8 = (uint64_t)nw_protocol_http_connect_get_remote_endpoint;
  return result;
}

void nw_parameters_inherit_protocol_instances(void *a1, uint64_t a2, void *a3, uint64_t a4, int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  os_log_type_t v9 = a1;
  BOOL v10 = a3;
  os_log_type_t v11 = v10;
  if (!v9)
  {
    int v32 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
    uint64_t v33 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (!__nwlog_fault(v33, type, &v67)) {
      goto LABEL_94;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
        _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s called with null new_parameters", buf, 0xCu);
      }
    }
    else if (v67)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v47 = type[0];
      BOOL v48 = os_log_type_enabled(v34, type[0]);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
          __int16 v69 = 2082;
          id v70 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v34, v47, "%{public}s called with null new_parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_94:
        if (!v33) {
          goto LABEL_34;
        }
LABEL_95:
        free(v33);
        goto LABEL_34;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
        _os_log_impl(&dword_1830D4000, v34, v47, "%{public}s called with null new_parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v34 = __nwlog_obj();
      os_log_type_t v58 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
        _os_log_impl(&dword_1830D4000, v34, v58, "%{public}s called with null new_parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_93:

    goto LABEL_94;
  }
  if (v10)
  {
    char v12 = (void **)v9[19];
    if (v12)
    {
      char v13 = (void **)v11[19];
      if (v13)
      {
        id v14 = v9[23];
        int v15 = 3;
        if (v14)
        {
          __int16 v16 = v14;
          char v17 = v16[170];

          if (v17) {
            int v15 = 4;
          }
          else {
            int v15 = 3;
          }
        }
        if (a4) {
          int v18 = 2;
        }
        else {
          int v18 = 1;
        }
        if (a5) {
          int v19 = v15;
        }
        else {
          int v19 = v18;
        }
        *(void *)buf = 0;
        *(void *)os_log_type_t type = 0;
        if (nw_protocol_stack_application_protocols_are_equal_below(v12, a2, v13, a4, v19, buf, type))
        {
          v62[0] = MEMORY[0x1E4F143A8];
          v62[1] = 3221225472;
          v62[2] = __nw_parameters_inherit_protocol_instances_block_invoke;
          v62[3] = &unk_1E523D2A0;
          uint64_t v64 = *(void *)buf;
          uint64_t v65 = *(void *)type;
          os_log_type_t v63 = v13;
          nw_protocol_stack_iterate_application_protocols_with_index(v12, v62);
        }
        os_log_type_t v20 = v12[3];
        if (v20 && v13[3])
        {
          os_log_type_t v21 = v20;
          id v22 = v21[1];

          if (nw_protocol_options_matches_definition(v13[3], v22))
          {
            nw_protocol_options_inherit_log_id(v13[3], v12[3]);
            uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(v13[3]);
            nw_protocol_options_set_instance(v12[3], protocol_handle);
          }
        }
        os_log_type_t v24 = v12[4];
        if (v24 && v13[4])
        {
          BOOL v25 = v24;
          id v26 = v25[1];

          if (nw_protocol_options_matches_definition(v13[4], v26))
          {
            nw_protocol_options_inherit_log_id(v13[4], v12[4]);
            uint64_t v27 = nw_protocol_options_get_protocol_handle(v13[4]);
            nw_protocol_options_set_instance(v12[4], v27);
          }
        }
        __int16 v28 = v12[6];
        if (v28 && v13[6])
        {
          uint64_t v29 = v28;
          id v30 = v29[1];

          if (nw_protocol_options_matches_definition(v13[6], v30))
          {
            nw_protocol_options_inherit_log_id(v13[6], v12[6]);
            uint64_t v31 = nw_protocol_options_get_protocol_handle(v13[6]);
            nw_protocol_options_set_instance(v12[6], v31);
          }
        }
LABEL_32:

LABEL_33:
        goto LABEL_34;
      }
      uint64_t v42 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
      uint64_t v43 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v67 = 0;
      if (__nwlog_fault(v43, type, &v67))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __int16 v44 = __nwlog_obj();
          os_log_type_t v45 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null join_stack", buf, 0xCu);
          }
        }
        else if (v67)
        {
          uint64_t v55 = (char *)__nw_create_backtrace_string();
          __int16 v44 = __nwlog_obj();
          os_log_type_t v56 = type[0];
          BOOL v57 = os_log_type_enabled(v44, type[0]);
          if (v55)
          {
            if (v57)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
              __int16 v69 = 2082;
              id v70 = v55;
              _os_log_impl(&dword_1830D4000, v44, v56, "%{public}s called with null join_stack, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v55);
            goto LABEL_104;
          }
          if (v57)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_1830D4000, v44, v56, "%{public}s called with null join_stack, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __int16 v44 = __nwlog_obj();
          os_log_type_t v61 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_1830D4000, v44, v61, "%{public}s called with null join_stack, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_104:
      if (v43) {
        free(v43);
      }
      goto LABEL_32;
    }
    int v38 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (__nwlog_fault(v39, type, &v67))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v40 = __nwlog_obj();
        os_log_type_t v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null stack", buf, 0xCu);
        }
      }
      else if (v67)
      {
        uint64_t v52 = (char *)__nw_create_backtrace_string();
        __int16 v40 = __nwlog_obj();
        os_log_type_t v53 = type[0];
        BOOL v54 = os_log_type_enabled(v40, type[0]);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            __int16 v69 = 2082;
            id v70 = v52;
            _os_log_impl(&dword_1830D4000, v40, v53, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v52);
          goto LABEL_99;
        }
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
          _os_log_impl(&dword_1830D4000, v40, v53, "%{public}s called with null stack, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v40 = __nwlog_obj();
        os_log_type_t v60 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
          _os_log_impl(&dword_1830D4000, v40, v60, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_99:
    if (v39) {
      free(v39);
    }
    goto LABEL_33;
  }
  char v36 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
  uint64_t v33 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v67 = 0;
  if (!__nwlog_fault(v33, type, &v67)) {
    goto LABEL_94;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v34 = __nwlog_obj();
    os_log_type_t v37 = type[0];
    if (os_log_type_enabled(v34, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s called with null join_parameters", buf, 0xCu);
    }
    goto LABEL_93;
  }
  if (!v67)
  {
    os_log_type_t v34 = __nwlog_obj();
    os_log_type_t v59 = type[0];
    if (os_log_type_enabled(v34, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_1830D4000, v34, v59, "%{public}s called with null join_parameters, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_93;
  }
  os_log_type_t v49 = (char *)__nw_create_backtrace_string();
  os_log_type_t v34 = __nwlog_obj();
  os_log_type_t v50 = type[0];
  BOOL v51 = os_log_type_enabled(v34, type[0]);
  if (!v49)
  {
    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_1830D4000, v34, v50, "%{public}s called with null join_parameters, no backtrace", buf, 0xCu);
    }
    goto LABEL_93;
  }
  if (v51)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
    __int16 v69 = 2082;
    id v70 = v49;
    _os_log_impl(&dword_1830D4000, v34, v50, "%{public}s called with null join_parameters, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v49);
  if (v33) {
    goto LABEL_95;
  }
LABEL_34:
}

void sub_1833B0F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_options_set_instance(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((void *)v3 + 2) = a2;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_protocol_options_set_instance";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_protocol_options_set_instance";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_protocol_options_inherit_log_id(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    int v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    snprintf((char *)v4 + 48, 0x54uLL, "%s", v3 + 48);
    v5[68] = *((_WORD *)v3 + 68);
    goto LABEL_4;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null new_options", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null new_options, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  int v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null new_options, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v23 = "nw_protocol_options_inherit_log_id";
    __int16 v24 = 2082;
    BOOL v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null new_options, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

BOOL nw_protocol_stack_application_protocols_are_equal_below(void *a1, uint64_t a2, void *a3, uint64_t a4, int a5, void *a6, void *a7)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  os_log_type_t v13 = a1;
  BOOL v14 = a3;
  int v15 = v14;
  if (a4)
  {
    BOOL v16 = 1;
    if (!v13 || !v14 || !v13[2] || !v14[2]) {
      goto LABEL_30;
    }
    uint64_t v17 = *(void *)(a4 + 16);
    if (v17)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      char v64 = 0;
      uint64_t v57 = 0;
      os_log_type_t v58 = &v57;
      uint64_t v59 = 0x2020000000;
      uint64_t v60 = 0;
      v56[0] = MEMORY[0x1E4F143A8];
      v56[1] = 3221225472;
      v56[2] = ___ZL55nw_protocol_stack_application_protocols_are_equal_belowP28NWConcrete_nw_protocol_stackmS0_P11nw_protocol28nw_parameters_compare_mode_tPmS4__block_invoke;
      v56[3] = &unk_1E523D368;
      void v56[5] = buf;
      v56[6] = a4;
      v56[4] = &v57;
      nw_protocol_stack_iterate_application_protocols_with_index(v14, v56);
      if (!*(unsigned char *)(*(void *)&buf[8] + 24))
      {
        if (gLogDatapath)
        {
          uint64_t v39 = __nwlog_obj();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)os_log_type_t v61 = 136446722;
            *(void *)&v61[4] = "nw_protocol_stack_application_protocols_are_equal_below";
            *(_WORD *)&v61[12] = 2048;
            *(void *)&v61[14] = a4;
            *(_WORD *)&v61[22] = 2048;
            uint64_t v62 = v15;
            _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_DEBUG, "%{public}s join protocol %p not in protocol stack %p", v61, 0x20u);
          }
        }
        BOOL v16 = 0;
        goto LABEL_29;
      }
      uint64_t v18 = v13[1];
      if (v18) {
        uint64_t v18 = (uint64_t)(*(void *)(v18 + 24) - *(void *)(v18 + 16)) >> 3;
      }
      uint64_t v19 = v13[2];
      if (v19)
      {
        uint64_t v20 = (uint64_t)(*(void *)(v19 + 24) - *(void *)(v19 + 16)) >> 3;
        uint64_t v21 = v15[1];
        if (!v21)
        {
LABEL_13:
          uint64_t v22 = v20 + v18;
          uint64_t v23 = v15[2];
          if (v23) {
            uint64_t v23 = (uint64_t)(*(void *)(v23 + 24) - *(void *)(v23 + 16)) >> 3;
          }
          *(void *)os_log_type_t v61 = 0;
          *(void *)&v61[8] = v61;
          *(void *)&v61[16] = 0x2020000000;
          LOBYTE(v62) = 0;
          uint64_t v52 = 0;
          os_log_type_t v53 = &v52;
          uint64_t v54 = 0x2020000000;
          uint64_t v55 = 0;
          v51[0] = MEMORY[0x1E4F143A8];
          v51[1] = 3221225472;
          v51[2] = ___ZL55nw_protocol_stack_application_protocols_are_equal_belowP28NWConcrete_nw_protocol_stackmS0_P11nw_protocol28nw_parameters_compare_mode_tPmS4__block_invoke_397;
          v51[3] = &unk_1E523D390;
          v51[8] = v22;
          v51[9] = v23 + v21;
          v51[10] = a2;
          v51[4] = &v57;
          v51[5] = &v52;
          v51[6] = v61;
          v51[7] = v17;
          nw_protocol_stack_iterate_application_protocols_with_index(v13, v51);
          if (*(unsigned char *)(*(void *)&v61[8] + 24) && *(unsigned char *)(*(void *)&buf[8] + 24))
          {
            uint64_t v47 = 0;
            BOOL v48 = &v47;
            uint64_t v49 = 0x2020000000;
            char v50 = 0;
            v41[0] = MEMORY[0x1E4F143A8];
            v41[1] = 3221225472;
            v41[2] = ___ZL55nw_protocol_stack_application_protocols_are_equal_belowP28NWConcrete_nw_protocol_stackmS0_P11nw_protocol28nw_parameters_compare_mode_tPmS4__block_invoke_2;
            v41[3] = &unk_1E523D3B8;
            uint64_t v43 = &v52;
            uint64_t v42 = v15;
            __int16 v44 = &v57;
            os_log_type_t v45 = &v47;
            int v46 = a5;
            nw_protocol_stack_iterate_application_protocols_with_index(v13, v41);
            BOOL v16 = *((unsigned char *)v48 + 24) == 0;

            _Block_object_dispose(&v47, 8);
            if (a6) {
              BOOL v24 = a7 == 0;
            }
            else {
              BOOL v24 = 1;
            }
            if (!v24 && v16)
            {
              *a6 = v53[3];
              *a7 = v58[3];
              BOOL v16 = 1;
            }
          }
          else
          {
            BOOL v16 = 0;
          }
          _Block_object_dispose(&v52, 8);
          _Block_object_dispose(v61, 8);
LABEL_29:
          _Block_object_dispose(&v57, 8);
          _Block_object_dispose(buf, 8);
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v20 = 0;
        uint64_t v21 = v15[1];
        if (!v21) {
          goto LABEL_13;
        }
      }
      uint64_t v21 = (uint64_t)(*(void *)(v21 + 24) - *(void *)(v21 + 16)) >> 3;
      goto LABEL_13;
    }
    os_log_type_t v34 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
    __int16 v28 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v57) = 16;
    v61[0] = 0;
    if (__nwlog_fault(v28, &v57, v61))
    {
      if (v57 == 17)
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v35 = v57;
        if (os_log_type_enabled(v29, (os_log_type_t)v57))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
          _os_log_impl(&dword_1830D4000, v29, v35, "%{public}s called with null join_identifier", buf, 0xCu);
        }
LABEL_67:

        goto LABEL_68;
      }
      if (!v61[0])
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v40 = v57;
        if (os_log_type_enabled(v29, (os_log_type_t)v57))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
          _os_log_impl(&dword_1830D4000, v29, v40, "%{public}s called with null join_identifier, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v37 = v57;
      BOOL v38 = os_log_type_enabled(v29, (os_log_type_t)v57);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
          _os_log_impl(&dword_1830D4000, v29, v37, "%{public}s called with null join_identifier, no backtrace", buf, 0xCu);
        }
        goto LABEL_67;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v29, v37, "%{public}s called with null join_identifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v27 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
    __int16 v28 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v57) = 16;
    v61[0] = 0;
    if (__nwlog_fault(v28, &v57, v61))
    {
      if (v57 == 17)
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v30 = v57;
        if (os_log_type_enabled(v29, (os_log_type_t)v57))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null join_protocol", buf, 0xCu);
        }
        goto LABEL_67;
      }
      if (!v61[0])
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v36 = v57;
        if (os_log_type_enabled(v29, (os_log_type_t)v57))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
          _os_log_impl(&dword_1830D4000, v29, v36, "%{public}s called with null join_protocol, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v32 = v57;
      BOOL v33 = os_log_type_enabled(v29, (os_log_type_t)v57);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
          _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null join_protocol, no backtrace", buf, 0xCu);
        }
        goto LABEL_67;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_application_protocols_are_equal_below";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null join_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_42:

      free(backtrace_string);
    }
  }
LABEL_68:
  if (v28) {
    free(v28);
  }
  BOOL v16 = 0;
LABEL_30:

  return v16;
}

void nw_protocol_stack_iterate_application_protocols_with_index(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x2020000000;
  v19[3] = 0;
  uint64_t v15 = 0;
  BOOL v16 = &v15;
  uint64_t v17 = 0x2020000000;
  char v18 = 0;
  uint64_t v5 = (atomic_uchar *)v3[1];
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZL58nw_protocol_stack_iterate_application_protocols_with_indexP28NWConcrete_nw_protocol_stackU13block_pointerFbmPU33objcproto22OS_nw_protocol_options8NSObjectE_block_invoke;
  v11[3] = &unk_1E523D3E0;
  id v6 = v4;
  id v12 = v6;
  os_log_type_t v13 = v19;
  BOOL v14 = &v15;
  nw_array_apply(v5, (uint64_t)v11);
  if (!*((unsigned char *)v16 + 24))
  {
    os_log_type_t v7 = (atomic_uchar *)v3[2];
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = ___ZL58nw_protocol_stack_iterate_application_protocols_with_indexP28NWConcrete_nw_protocol_stackU13block_pointerFbmPU33objcproto22OS_nw_protocol_options8NSObjectE_block_invoke_2;
    v8[3] = &unk_1E523D408;
    id v9 = v6;
    os_log_type_t v10 = v19;
    nw_array_apply(v7, (uint64_t)v8);
  }
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(v19, 8);
}

void nw_endpoint_handler_unregister_context(void *a1, void *a2)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    uint64_t v81 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v102 = "nw_endpoint_handler_unregister_context";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (!__nwlog_fault(v25, &type, &v99)) {
      goto LABEL_80;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v82 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v102 = "nw_endpoint_handler_unregister_context";
        _os_log_impl(&dword_1830D4000, v26, v82, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v99)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v84 = type;
      BOOL v85 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v85)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v102 = "nw_endpoint_handler_unregister_context";
          __int16 v103 = 2082;
          size_t v104 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v84, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_80;
      }
      if (v85)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v102 = "nw_endpoint_handler_unregister_context";
        _os_log_impl(&dword_1830D4000, v26, v84, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v86 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v102 = "nw_endpoint_handler_unregister_context";
        _os_log_impl(&dword_1830D4000, v26, v86, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_79:

    goto LABEL_80;
  }
  uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if (mode == 2)
  {
    os_log_type_t v7 = nw_endpoint_handler_copy_flow(v5);
    os_log_type_t v8 = (uint64_t *)v7;
    if ((*((unsigned char *)v7 + 35) & 2) != 0)
    {
      uint64_t v29 = *((void *)v7 + 117);
      if (v29)
      {
        nw_endpoint_handler_unregister_context(v29, v4);
      }
      else
      {
        os_log_type_t v34 = v5;
        char v35 = *((unsigned char *)v34 + 268);

        if ((v35 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v36 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            os_log_type_t v37 = v34;

            BOOL v38 = v37;
            char v39 = *((unsigned char *)v34 + 268);

            if (v39) {
              os_log_type_t v40 = "dry-run ";
            }
            else {
              os_log_type_t v40 = "";
            }
            nw_endpoint_t v41 = nw_endpoint_handler_copy_endpoint(v38);
            logging_description = nw_endpoint_get_logging_description(v41);
            id_str = v37->id_str;
            uint64_t v43 = v38;
            __int16 v44 = v43;
            uint64_t v45 = v43[30];
            if (v45 > 5) {
              int v46 = "unknown-state";
            }
            else {
              int v46 = off_1E523FB38[v45];
            }
            id v91 = v46;

            __int16 v69 = v44;
            id v70 = v69;
            int v71 = v5->mode;
            int v72 = "path";
            switch(v71)
            {
              case 0:
                break;
              case 1:
                int v72 = "resolver";
                break;
              case 2:
                int v72 = nw_endpoint_flow_mode_string(v69[31]);
                break;
              case 3:
                int v72 = "proxy";
                break;
              case 4:
                int v72 = "fallback";
                break;
              case 5:
                int v72 = "transform";
                break;
              default:
                int v72 = "unknown-mode";
                break;
            }

            id v77 = v70;
            os_unfair_lock_lock((os_unfair_lock_t)v77 + 28);
            id v78 = v77[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v77 + 28);

            *(_DWORD *)buf = 136447746;
            BOOL v102 = "nw_endpoint_handler_unregister_context";
            __int16 v103 = 2082;
            size_t v104 = id_str;
            __int16 v105 = 2082;
            __int16 v106 = v40;
            __int16 v107 = 2082;
            size_t v108 = (void *)logging_description;
            __int16 v109 = 2082;
            uint64_t v110 = v91;
            __int16 v111 = 2082;
            __int16 v112 = v72;
            __int16 v113 = 2114;
            id v114 = v78;
            _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot unregister, no connected handler", buf, 0x48u);
          }
          goto LABEL_97;
        }
      }
    }
    else if (*((void *)v7 + 96))
    {
      uint64_t v9 = *((void *)v7 + 108);
      if (v9)
      {
        uint64_t node = nw_hash_table_get_node(v9, (uint64_t)v4, 0);
        if (node)
        {
          uint64_t v11 = node;
          uint64_t v12 = *(void *)(node + 16);
          __int16 v13 = *(_WORD *)(v12 + 332);
          *(_WORD *)(v12 + 332) = v13 | 0x100;
          if ((v13 & 0x200) == 0
            && (uint64_t v14 = *(void *)(v12 + 32)) != 0
            && (uint64_t v15 = *(void *)(v14 + 24)) != 0
            && *(void *)(v15 + 32))
          {
            BOOL v16 = v5;
            char v17 = *((unsigned char *)v16 + 268);

            if ((v17 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              char v18 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
              {
                id_string = nw_endpoint_handler_get_id_string(v16);
                uint64_t v89 = nw_endpoint_handler_dry_run_string(v16);
                uint64_t v93 = id_string;
                nw_endpoint_t v97 = nw_endpoint_handler_copy_endpoint(v16);
                os_log_type_t v87 = nw_endpoint_get_logging_description(v97);
                uint64_t v20 = nw_endpoint_handler_state_string(v16);
                uint64_t v21 = nw_endpoint_handler_mode_string(v16);
                id v22 = nw_endpoint_handler_copy_current_path(v16);
                *(_DWORD *)buf = 136448002;
                BOOL v102 = "nw_endpoint_handler_unregister_context";
                __int16 v103 = 2082;
                size_t v104 = (void *)v93;
                __int16 v105 = 2082;
                __int16 v106 = v89;
                __int16 v107 = 2082;
                size_t v108 = (void *)v87;
                __int16 v109 = 2082;
                uint64_t v110 = v20;
                __int16 v111 = 2082;
                __int16 v112 = v21;
                __int16 v113 = 2114;
                id v114 = v22;
                __int16 v115 = 2048;
                uint64_t v116 = v12;
                _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Unregistering protocol %p by disconnecting", buf, 0x52u);
              }
            }
            (*(void (**)(uint64_t, uint64_t))(*(void *)(v14 + 24) + 32))(v14, v12);
          }
          else
          {
            uint64_t v62 = v5;
            char v63 = *((unsigned char *)v62 + 268);

            if ((v63 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              char v64 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v65 = nw_endpoint_handler_get_id_string(v62);
                int v90 = nw_endpoint_handler_dry_run_string(v62);
                os_log_type_t v96 = v65;
                nw_endpoint_t v98 = nw_endpoint_handler_copy_endpoint(v62);
                uint64_t v88 = nw_endpoint_get_logging_description(v98);
                __int16 v66 = nw_endpoint_handler_state_string(v62);
                char v67 = nw_endpoint_handler_mode_string(v62);
                id v68 = nw_endpoint_handler_copy_current_path(v62);
                *(_DWORD *)buf = 136448002;
                BOOL v102 = "nw_endpoint_handler_unregister_context";
                __int16 v103 = 2082;
                size_t v104 = (void *)v96;
                __int16 v105 = 2082;
                __int16 v106 = v90;
                __int16 v107 = 2082;
                size_t v108 = (void *)v88;
                __int16 v109 = 2082;
                uint64_t v110 = v66;
                __int16 v111 = 2082;
                __int16 v112 = v67;
                __int16 v113 = 2114;
                id v114 = v68;
                __int16 v115 = 2048;
                uint64_t v116 = v12;
                _os_log_impl(&dword_1830D4000, v64, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Unregistering protocol %p immediately", buf, 0x52u);
              }
            }
            nw_hash_table_remove_node(v8[108], v11);
          }
        }
        goto LABEL_98;
      }
      uint64_t v49 = v5;
      char v50 = *((unsigned char *)v49 + 268);

      if ((v50 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v36 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          BOOL v51 = v49;

          uint64_t v52 = v51;
          char v53 = *((unsigned char *)v49 + 268);

          if (v53) {
            uint64_t v54 = "dry-run ";
          }
          else {
            uint64_t v54 = "";
          }
          nw_endpoint_t v55 = nw_endpoint_handler_copy_endpoint(v52);
          os_log_type_t v56 = nw_endpoint_get_logging_description(v55);
          uint64_t v95 = v51->id_str;
          uint64_t v57 = v52;
          os_log_type_t v58 = v57;
          uint64_t v59 = v57[30];
          if (v59 > 5) {
            uint64_t v60 = "unknown-state";
          }
          else {
            uint64_t v60 = off_1E523FB38[v59];
          }
          uint64_t v92 = v60;

          BOOL v73 = v58;
          id v74 = v73;
          int v75 = v5->mode;
          id v76 = "path";
          switch(v75)
          {
            case 0:
              break;
            case 1:
              id v76 = "resolver";
              break;
            case 2:
              id v76 = nw_endpoint_flow_mode_string(v73[31]);
              break;
            case 3:
              id v76 = "proxy";
              break;
            case 4:
              id v76 = "fallback";
              break;
            case 5:
              id v76 = "transform";
              break;
            default:
              id v76 = "unknown-mode";
              break;
          }

          os_log_type_t v79 = v74;
          os_unfair_lock_lock((os_unfair_lock_t)v79 + 28);
          id v80 = v79[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v79 + 28);

          *(_DWORD *)buf = 136447746;
          BOOL v102 = "nw_endpoint_handler_unregister_context";
          __int16 v103 = 2082;
          size_t v104 = v95;
          __int16 v105 = 2082;
          __int16 v106 = v54;
          __int16 v107 = 2082;
          size_t v108 = (void *)v56;
          __int16 v109 = 2082;
          uint64_t v110 = v92;
          __int16 v111 = 2082;
          __int16 v112 = v76;
          __int16 v113 = 2114;
          id v114 = v80;
          _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot unregister after flow table is released", buf, 0x48u);
        }
LABEL_97:
      }
    }
LABEL_98:

    goto LABEL_99;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v23 = (id)gLogObj;
  if (mode > 5) {
    BOOL v24 = "unknown-mode";
  }
  else {
    BOOL v24 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  BOOL v102 = "nw_endpoint_handler_unregister_context";
  __int16 v103 = 2082;
  size_t v104 = (void *)v24;
  __int16 v105 = 2082;
  __int16 v106 = "flow";
  BOOL v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v99 = 0;
  if (__nwlog_fault(v25, &type, &v99))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (id)gLogObj;
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        if (mode > 5) {
          __int16 v28 = "unknown-mode";
        }
        else {
          __int16 v28 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        BOOL v102 = "nw_endpoint_handler_unregister_context";
        __int16 v103 = 2082;
        size_t v104 = (void *)v28;
        __int16 v105 = 2082;
        __int16 v106 = "flow";
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if (v99)
    {
      os_log_type_t v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (id)gLogObj;
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v26, type);
      if (v30)
      {
        if (v32)
        {
          if (mode > 5) {
            BOOL v33 = "unknown-mode";
          }
          else {
            BOOL v33 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446978;
          BOOL v102 = "nw_endpoint_handler_unregister_context";
          __int16 v103 = 2082;
          size_t v104 = (void *)v33;
          __int16 v105 = 2082;
          __int16 v106 = "flow";
          __int16 v107 = 2082;
          size_t v108 = v30;
          _os_log_impl(&dword_1830D4000, v26, v31, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v30);
        if (v25) {
          goto LABEL_81;
        }
        goto LABEL_99;
      }
      if (v32)
      {
        if (mode > 5) {
          os_log_type_t v61 = "unknown-mode";
        }
        else {
          os_log_type_t v61 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        BOOL v102 = "nw_endpoint_handler_unregister_context";
        __int16 v103 = 2082;
        size_t v104 = (void *)v61;
        __int16 v105 = 2082;
        __int16 v106 = "flow";
        _os_log_impl(&dword_1830D4000, v26, v31, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (id)gLogObj;
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v26, type))
      {
        if (mode > 5) {
          BOOL v48 = "unknown-mode";
        }
        else {
          BOOL v48 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        BOOL v102 = "nw_endpoint_handler_unregister_context";
        __int16 v103 = 2082;
        size_t v104 = (void *)v48;
        __int16 v105 = 2082;
        __int16 v106 = "flow";
        _os_log_impl(&dword_1830D4000, v26, v47, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_79;
  }
LABEL_80:
  if (v25) {
LABEL_81:
  }
    free(v25);
LABEL_99:
}

void sub_1833B2DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_parameters_set_attribution(nw_parameters_t parameters, nw_parameters_attribution_t attribution)
{
  int v2 = attribution;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v3 = parameters;
  nw_parameters_t v4 = v3;
  if (v3)
  {
    *((unsigned char *)v3[13].isa + 102) = 2 * (v2 == 2);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_set_attribution";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_set_attribution";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_set_attribution";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_set_attribution";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_set_attribution";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

_DWORD *nw_authentication_credential_storage_copy_default_credential(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      id v6 = v3[1];
      ns_protection_space = (void *)nw_authentication_challenge_get_ns_protection_space(v5);
      if (ns_protection_space)
      {
        os_log_type_t v8 = [v6 defaultCredentialForProtectionSpace:ns_protection_space];
        if (v8)
        {
          uint64_t v9 = -[NWConcrete_nw_authentication_credential initWithType:]([NWConcrete_nw_authentication_credential alloc], 1);
          nw_authentication_credential_apply_ns(v9, v8);
        }
        else
        {
          uint64_t v9 = 0;
        }
        os_log_type_t v10 = v9;
      }
      else
      {
        os_log_type_t v10 = 0;
      }

      goto LABEL_10;
    }
    __int16 v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null challenge";
          goto LABEL_37;
        }
        goto LABEL_38;
      }
      if (!v22)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null challenge, backtrace limit exceeded";
          goto LABEL_37;
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v21 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null challenge, no backtrace";
          goto LABEL_37;
        }
        goto LABEL_38;
      }
      if (!v21) {
        goto LABEL_28;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
      __int16 v26 = 2082;
      os_log_type_t v27 = backtrace_string;
      uint64_t v20 = "%{public}s called with null challenge, dumping backtrace:%{public}s";
LABEL_27:
      _os_log_impl(&dword_1830D4000, v14, v15, v20, buf, 0x16u);
LABEL_28:

      free(backtrace_string);
    }
  }
  else
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null storage";
LABEL_37:
          _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
        }
LABEL_38:

        goto LABEL_39;
      }
      if (!v22)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_37;
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v19 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null storage, no backtrace";
          goto LABEL_37;
        }
        goto LABEL_38;
      }
      if (!v19) {
        goto LABEL_28;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
      __int16 v26 = 2082;
      os_log_type_t v27 = backtrace_string;
      uint64_t v20 = "%{public}s called with null storage, dumping backtrace:%{public}s";
      goto LABEL_27;
    }
  }
LABEL_39:
  if (v13) {
    free(v13);
  }
  os_log_type_t v10 = 0;
LABEL_10:

  return v10;
}

void nw_authentication_credential_apply_ns(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    id v6 = [v4 user];
    os_log_type_t v7 = [v5 password];
    nw_authentication_credential_set_username(v3, (const char *)[v6 UTF8String]);
    nw_authentication_credential_set_password(v3, (const char *)[v7 UTF8String]);
    unint64_t v8 = [v5 persistence];
    if (v8 <= 3)
    {
      int v9 = v8;
      os_log_type_t v10 = v3;
      v10[3] = v9;
    }
    goto LABEL_5;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v22 = "nw_authentication_credential_apply_ns";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v22 = "nw_authentication_credential_apply_ns";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          char v22 = "nw_authentication_credential_apply_ns";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        char v22 = "nw_authentication_credential_apply_ns";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v22 = "nw_authentication_credential_apply_ns";
        _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v12) {
    free(v12);
  }
LABEL_5:
}

void nw_path_monitor_cancel(nw_path_monitor_t monitor)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = monitor;
  int v2 = v1;
  if (v1)
  {
    nw_path_evaluator_cancel(v1);
    goto LABEL_3;
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_path_monitor_cancel";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_path_monitor_cancel";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_path_monitor_cancel";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_path_monitor_cancel";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_path_monitor_cancel";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

void sub_1833B3B24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_evaluator_cancel(void *a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (!v1) {
    goto LABEL_8;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v1 + 24);
  if ((v1[107] & 0x20) != 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);
LABEL_8:
    uint64_t v4 = 0;
    goto LABEL_76;
  }
  if ((v1[107] & 0x40) != 0)
  {
    int v2 = nw_parameters_copy_context(*((void **)v1 + 1));
    if (!v2 || (int v3 = v2[31], v2, v3 != 4))
    {
      if (__nwlog_path_log::onceToken != -1) {
        dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_48_44893);
      }
      uint64_t v5 = (id)gpathLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
        *(_WORD *)&unsigned char buf[12] = 1042;
        *(_DWORD *)&buf[14] = 16;
        *(_WORD *)&buf[18] = 2098;
        *(void *)&buf[20] = v1 + 80;
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P] cancel", buf, 0x1Cu);
      }
    }
  }
  v1[107] |= 0x20u;
  os_log_type_t v6 = (void *)*((void *)v1 + 8);
  *((void *)v1 + 8) = 0;

  os_log_type_t v7 = (const void *)*((void *)v1 + 9);
  if (v7)
  {
    os_log_type_t v8 = _Block_copy(v7);
    BOOL v9 = v8;
    os_log_type_t v10 = *((void *)v1 + 7);
    if (v10)
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __nw_path_evaluator_cancel_block_invoke;
      block[3] = &unk_1E524AFA8;
      char v11 = &v46;
      id v46 = v8;
      dispatch_async(v10, block);
    }
    else
    {
      id v13 = nw_parameters_copy_context(*((void **)v1 + 1));
      v43[0] = MEMORY[0x1E4F143A8];
      v43[1] = 3221225472;
      v43[2] = __nw_path_evaluator_cancel_block_invoke_2;
      v43[3] = &unk_1E524AFA8;
      id v44 = v9;
      nw_queue_context_async(v13, v43);

      char v11 = &v44;
    }

    os_log_type_t v12 = (void *)*((void *)v1 + 9);
  }
  else
  {
    os_log_type_t v12 = 0;
  }
  *((void *)v1 + 9) = 0;

  os_log_type_t v14 = (void *)*((void *)v1 + 7);
  *((void *)v1 + 7) = 0;

  id v15 = nw_parameters_copy_context(*((void **)v1 + 1));
  uint64_t globals_for_path = nw_context_get_globals_for_path(v15);

  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
  if ((v1[107] & 1) == 0)
  {
    memset(buf, 0, 37);
    uuid_unparse((const unsigned __int8 *)v1 + 80, (char *)buf);
    uint64_t v17 = *(void *)(globals_for_path + 32);
    if (v17) {
      nw_dictionary_set_value(v17, (const char *)buf, 0);
    }
    goto LABEL_66;
  }
  uuid_clear((unsigned __int8 *)v1 + 80);
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if (sNWDispatchAllowedNow)
    {
LABEL_31:
      if (!*(void *)(globals_for_path + 48)) {
        goto LABEL_66;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v18 = (id)gLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
        _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s Removing client from default path evaluator", buf, 0xCu);
      }

      uint64_t v19 = *(void *)(globals_for_path + 48);
      if (!v19 || *(void *)(v19 + 16) == *(void *)(v19 + 24))
      {
        BOOL v20 = nw_array_create();
      }
      else
      {
        BOOL v20 = nw_array_create();
        std::vector<nw_object_wrapper_t>::reserve(v20 + 16, ((uint64_t)(*(void *)(v19 + 24) - *(void *)(v19 + 16)) >> 3) - 1);
        char v22 = *(void ***)(v19 + 16);
        BOOL v21 = *(void ***)(v19 + 24);
        while (v22 != v21)
        {
          if (*v22 != v1) {
            nw_array_append(v20, *v22);
          }
          ++v22;
        }
      }
      __int16 v23 = *(void **)(globals_for_path + 48);
      *(void *)(globals_for_path + 48) = v20;

      uint64_t v24 = *(void *)(globals_for_path + 48);
      if (v24)
      {
        if (*(void *)(v24 + 24) != *(void *)(v24 + 16)) {
          goto LABEL_66;
        }
      }
      id v25 = nw_parameters_copy_context(*((void **)v1 + 1));
      nw_path_shared_necp_fd(v25);

      if (!necp_client_action()) {
        goto LABEL_63;
      }
      int v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      os_log_type_t v27 = __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v26;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v41 = 0;
      if (__nwlog_fault(v28, &type, &v41))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v29 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v26;
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v29 = __nwlog_obj();
          os_log_type_t v32 = type;
          BOOL v33 = os_log_type_enabled(v29, type);
          if (backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v26;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(backtrace_string);
            goto LABEL_61;
          }
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v26;
            _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          uint64_t v29 = __nwlog_obj();
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v26;
            _os_log_impl(&dword_1830D4000, v29, v34, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }
LABEL_61:
      if (v28) {
        free(v28);
      }
LABEL_63:
      uuid_clear((unsigned __int8 *)globals_for_path);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v35 = (id)gLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
        _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s Removed last default path evaluator client", buf, 0xCu);
      }

      goto LABEL_66;
    }
    if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
      || (getpid(), sandbox_check() == 1))
    {
      sNWDispatchAllowedNow = 1;
      goto LABEL_31;
    }
    if (sNWDispatchAllowedNow == 1) {
      goto LABEL_31;
    }
  }
LABEL_66:
  id v36 = nw_parameters_copy_context(*((void **)v1 + 1));
  if (nw_context_is_inline(v36))
  {
    uint64_t v37 = *(void *)(globals_for_path + 32);
    if (!v37 || !nw_dictionary_get_count(v37))
    {
      uint64_t v38 = *(void *)(globals_for_path + 48);
      if (!v38 || *(void *)(v38 + 16) == *(void *)(v38 + 24))
      {
        if (*(void *)(globals_for_path + 56))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v39 = (id)gLogObj;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_evaluator_cancel";
            _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_DEBUG, "%{public}s Suspending global NECP read source", buf, 0xCu);
          }

          *(unsigned char *)(globals_for_path + 140) |= 1u;
          nw_queue_suspend_source(*(void *)(globals_for_path + 56));
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(globals_for_path + 124));
  os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);

  uint64_t v4 = 1;
LABEL_76:

  return v4;
}

void sub_1833B43E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45nw_activity_should_use_elevated_sampling_ratev_block_invoke()
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (os_variant_has_internal_diagnostics())
  {
    bzero(&v22, 0x500uLL);
    int v0 = uname(&v22);
    if (v0)
    {
      int v1 = v0;
      int v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (id)gLogObj;
      *(_DWORD *)buf = 136446722;
      uint64_t v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
      __int16 v18 = 1024;
      *(_DWORD *)uint64_t v19 = v1;
      *(_WORD *)&void v19[4] = 1024;
      *(_DWORD *)&v19[6] = v2;
      uint64_t v4 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v14 = 0;
      if (__nwlog_fault((const char *)v4, &type, &v14))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v5 = (id)gLogObj;
          os_log_type_t v6 = type;
          if (!os_log_type_enabled(v5, type)) {
            goto LABEL_25;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          __int16 v18 = 1024;
          *(_DWORD *)uint64_t v19 = v1;
          *(_WORD *)&void v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          os_log_type_t v7 = "%{public}s uname failed (%d) %{darwin.errno}d";
LABEL_23:
          os_log_type_t v12 = v5;
          os_log_type_t v13 = v6;
          goto LABEL_24;
        }
        if (!v14)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v5 = (id)gLogObj;
          os_log_type_t v6 = type;
          if (!os_log_type_enabled(v5, type)) {
            goto LABEL_25;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          __int16 v18 = 1024;
          *(_DWORD *)uint64_t v19 = v1;
          *(_WORD *)&void v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          os_log_type_t v7 = "%{public}s uname failed (%d) %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_23;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (id)gLogObj;
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v5, type);
        if (!backtrace_string)
        {
          if (!v11)
          {
LABEL_25:

            if (!v4) {
              return;
            }
LABEL_19:
            free(v4);
            return;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          __int16 v18 = 1024;
          *(_DWORD *)uint64_t v19 = v1;
          *(_WORD *)&void v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          os_log_type_t v7 = "%{public}s uname failed (%d) %{darwin.errno}d, no backtrace";
          os_log_type_t v12 = v5;
          os_log_type_t v13 = v10;
LABEL_24:
          _os_log_impl(&dword_1830D4000, v12, v13, v7, buf, 0x18u);
          goto LABEL_25;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          __int16 v18 = 1024;
          *(_DWORD *)uint64_t v19 = v1;
          *(_WORD *)&void v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s uname failed (%d) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(backtrace_string);
      }
      if (!v4) {
        return;
      }
      goto LABEL_19;
    }
    if (gLogDatapath)
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
      }
      os_log_type_t v8 = (id)gactivityLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
        __int16 v18 = 2080;
        *(void *)uint64_t v19 = v22.machine;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Device: %s", buf, 0x16u);
      }
    }
  }
}

void NWActivity.parentActivity.setter(uint64_t a1)
{
  if (a1)
  {
    nw_activity_set_parent_activity(*(void **)(v1 + 16), *(void **)(a1 + 16));
    swift_release();
  }
  else
  {
    int v2 = *(void **)(v1 + 16);
    nw_activity_set_parent_activity(v2, 0);
  }
}

void nw_activity_set_parent_activity(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    BOOL v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_activity_set_parent_activity";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v31 = "nw_activity_set_parent_activity";
          __int16 v32 = 2082;
          BOOL v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v10) {
          goto LABEL_8;
        }
LABEL_59:
        free(v10);
        goto LABEL_8;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_57:

    goto LABEL_58;
  }
  if ((v3[140] & 4) != 0)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_activity_set_parent_activity";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (!v28)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_57;
    }
    __int16 v20 = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_activity_set_parent_activity";
      __int16 v32 = 2082;
      BOOL v33 = v20;
      _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_38;
  }
  if ((v3[140] & 8) != 0)
  {
    id v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_activity_set_parent_activity";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (!v28)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_57;
    }
    __int16 v20 = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_activity_set_parent_activity";
      __int16 v32 = 2082;
      BOOL v33 = v20;
      _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_38:

    free(v20);
    if (!v10) {
      goto LABEL_8;
    }
    goto LABEL_59;
  }
  id v6 = v4;
  os_log_type_t v7 = (void *)*((void *)v3 + 7);
  if ((v3[64] & 1) != 0 && v7)
  {
    *((void *)v3 + 7) = 0;

    os_log_type_t v7 = (void *)*((void *)v3 + 7);
  }
  *((void *)v3 + 7) = 0;

  os_log_type_t v8 = (void *)*((void *)v3 + 7);
  *((void *)v3 + 7) = v6;

  v3[64] |= 1u;
LABEL_8:
}

void nw_protocol_stack_set_original_proxied_transport_protocol(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 5, a2);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_protocol_instance_set_is_datagram(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 0x80;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 402) = v5 & 0x80 | *((unsigned char *)v3 + 402) & 0x7F;
    goto LABEL_6;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_instance_set_is_datagram";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_protocol_instance_set_is_datagram";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

uint64_t nw_http_copy_trailer_fields_from_indeterminate_binary_message(const char *a1, unint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
    BOOL v33 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v33, &type, &v42)) {
      goto LABEL_104;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v34 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        id v36 = "%{public}s called with null buffer";
LABEL_103:
        _os_log_impl(&dword_1830D4000, v34, v35, v36, buf, 0xCu);
      }
LABEL_104:
      if (v33) {
        free(v33);
      }
      return 0;
    }
    if (!v42)
    {
      uint64_t v34 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        id v36 = "%{public}s called with null buffer, backtrace limit exceeded";
        goto LABEL_103;
      }
      goto LABEL_104;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v34 = __nwlog_obj();
    os_log_type_t v35 = type;
    BOOL v39 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        id v36 = "%{public}s called with null buffer, no backtrace";
        goto LABEL_103;
      }
      goto LABEL_104;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
      __int16 v46 = 2082;
      unint64_t v47 = (unint64_t)backtrace_string;
      os_log_type_t v40 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_93:
      _os_log_impl(&dword_1830D4000, v34, v35, v40, buf, 0x16u);
    }
LABEL_94:
    free(backtrace_string);
    goto LABEL_104;
  }
  unint64_t v2 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
    BOOL v33 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v33, &type, &v42)) {
      goto LABEL_104;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v34 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        id v36 = "%{public}s called with null buffer_length";
        goto LABEL_103;
      }
      goto LABEL_104;
    }
    if (!v42)
    {
      uint64_t v34 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        id v36 = "%{public}s called with null buffer_length, backtrace limit exceeded";
        goto LABEL_103;
      }
      goto LABEL_104;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v34 = __nwlog_obj();
    os_log_type_t v35 = type;
    BOOL v41 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        id v36 = "%{public}s called with null buffer_length, no backtrace";
        goto LABEL_103;
      }
      goto LABEL_104;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
      __int16 v46 = 2082;
      unint64_t v47 = (unint64_t)backtrace_string;
      os_log_type_t v40 = "%{public}s called with null buffer_length, dumping backtrace:%{public}s";
      goto LABEL_93;
    }
    goto LABEL_94;
  }
  id v3 = a1;
  id v4 = 0;
  while (1)
  {
    if (!v2)
    {
LABEL_39:
      if (!v4) {
        return 0;
      }
      id v4 = v4;
      uint64_t v19 = _nw_http_parsed_fields_copy_trailer_fields(v4);

      goto LABEL_83;
    }
    if (!v3)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v45 = "_http_vle_decode";
      os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v42 = 0;
      if (__nwlog_fault(v27, &type, &v42))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v28 = __nwlog_obj();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "_http_vle_decode";
            os_log_type_t v30 = "%{public}s called with null *buffer";
LABEL_75:
            _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
          }
        }
        else if (v42)
        {
          os_log_type_t v31 = (char *)__nw_create_backtrace_string();
          char v28 = __nwlog_obj();
          os_log_type_t v29 = type;
          BOOL v32 = os_log_type_enabled(v28, type);
          if (v31)
          {
            if (v32)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v45 = "_http_vle_decode";
              __int16 v46 = 2082;
              unint64_t v47 = (unint64_t)v31;
              _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v31);
          }
          else if (v32)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "_http_vle_decode";
            os_log_type_t v30 = "%{public}s called with null *buffer, no backtrace";
            goto LABEL_75;
          }
        }
        else
        {
          char v28 = __nwlog_obj();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "_http_vle_decode";
            os_log_type_t v30 = "%{public}s called with null *buffer, backtrace limit exceeded";
            goto LABEL_75;
          }
        }
      }
      if (v27) {
        free(v27);
      }
LABEL_78:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
      os_log_type_t v21 = "%{public}s Failed to decode integer";
LABEL_80:
      BOOL v24 = v20;
      uint32_t v26 = 12;
      goto LABEL_81;
    }
    unint64_t v5 = *(unsigned __int8 *)v3;
    if (v5 > 0x3F)
    {
      if (v5 >> 6 == 2)
      {
        if (v2 < 4) {
          goto LABEL_78;
        }
        unint64_t v5 = bswap32(*(_DWORD *)v3 & 0xFFFFFF7F);
        uint64_t v6 = 4;
        unint64_t v7 = (unint64_t)(v3 + 4);
        if (!v5) {
          goto LABEL_39;
        }
      }
      else if (v5 >> 6 == 1)
      {
        if (v2 < 2) {
          goto LABEL_78;
        }
        unint64_t v5 = bswap32(*(_WORD *)v3 & 0xFFBF) >> 16;
        uint64_t v6 = 2;
        unint64_t v7 = (unint64_t)(v3 + 2);
        if (!v5) {
          goto LABEL_39;
        }
      }
      else
      {
        if (v2 < 8) {
          goto LABEL_78;
        }
        uint64_t v9 = *(void *)v3;
        os_log_type_t v8 = v3 + 8;
        unint64_t v5 = bswap64(v9 & 0xFFFFFFFFFFFFFF3FLL);
        if (HIDWORD(v5))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v22 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_82;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
          __int16 v46 = 2048;
          unint64_t v47 = v5;
          __int16 v48 = 2048;
          uint64_t v49 = 0xFFFFFFFFLL;
          os_log_type_t v21 = "%{public}s _output %llu > _max %llu";
LABEL_45:
          BOOL v24 = v22;
LABEL_49:
          uint32_t v26 = 32;
LABEL_81:
          _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, v21, buf, v26);
          goto LABEL_82;
        }
        uint64_t v6 = 8;
        unint64_t v7 = (unint64_t)v8;
        if (!v5) {
          goto LABEL_39;
        }
      }
    }
    else
    {
      uint64_t v6 = 1;
      unint64_t v7 = (unint64_t)(v3 + 1);
      if (!*v3) {
        goto LABEL_39;
      }
    }
    uint64_t v10 = v2 - v6;
    BOOL v11 = v2 - v6 >= v5;
    unint64_t v12 = v2 - v6 - v5;
    if (!v11) {
      break;
    }
    if (!v12) {
      goto LABEL_41;
    }
    os_log_type_t v13 = (_DWORD *)(v7 + v5);
    unint64_t v14 = *(unsigned __int8 *)(v7 + v5);
    if (v14 <= 0x3F)
    {
      uint64_t v15 = 1;
LABEL_32:
      os_log_type_t v16 = (char *)v13 + v15;
      goto LABEL_33;
    }
    if (v14 >> 6 == 2)
    {
      if (v12 < 4) {
        goto LABEL_41;
      }
      unint64_t v14 = bswap32(*v13 & 0xFFFFFF7F);
      uint64_t v15 = 4;
      goto LABEL_32;
    }
    if (v14 >> 6 == 1)
    {
      if (v12 < 2) {
        goto LABEL_41;
      }
      unint64_t v14 = bswap32(*(_WORD *)v13 & 0xFFBF) >> 16;
      uint64_t v15 = 2;
      goto LABEL_32;
    }
    if (v12 < 8)
    {
LABEL_41:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
      os_log_type_t v21 = "%{public}s Failed to decode integer";
      goto LABEL_80;
    }
    uint64_t v18 = *(void *)v13;
    os_log_type_t v16 = (const char *)(v13 + 2);
    unint64_t v14 = bswap64(v18 & 0xFFFFFFFFFFFFFF3FLL);
    if (HIDWORD(v14))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v25 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
      __int16 v46 = 2048;
      unint64_t v47 = v14;
      __int16 v48 = 2048;
      uint64_t v49 = 0xFFFFFFFFLL;
      os_log_type_t v21 = "%{public}s _output %llu > _max %llu";
      goto LABEL_48;
    }
    uint64_t v15 = 8;
LABEL_33:
    uint64_t v17 = v12 - v15;
    unint64_t v2 = v12 - v15 - v14;
    if (v12 - v15 < v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v25 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
      __int16 v46 = 2048;
      unint64_t v47 = v14;
      __int16 v48 = 2048;
      uint64_t v49 = v17;
      os_log_type_t v21 = "%{public}s _length %llu > remaining %zu";
LABEL_48:
      BOOL v24 = v25;
      goto LABEL_49;
    }
    if (!v4) {
      id v4 = (id)_nw_http_parsed_fields_create();
    }
    id v3 = &v16[v14];
    if (!nw_http_parsed_fields_add(v4, v7, v5, v16, v14, 0)) {
      goto LABEL_82;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v22 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    uint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
    __int16 v46 = 2048;
    unint64_t v47 = v5;
    __int16 v48 = 2048;
    uint64_t v49 = v10;
    os_log_type_t v21 = "%{public}s _length %llu > remaining %zu";
    goto LABEL_45;
  }
LABEL_82:
  uint64_t v19 = 0;
  uint64_t result = 0;
  if (!v4) {
    return result;
  }
LABEL_83:
  os_release(v4);
  return v19;
}

void networkd_settings_update_from_token(int a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t state64 = 0;
  uint32_t state = notify_get_state(a1, &state64);
  if (state)
  {
    uint32_t v2 = state;
    uint64_t v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v3);
    *(_DWORD *)buf = 136446466;
    BOOL v32 = "networkd_settings_update_from_token";
    __int16 v33 = 1024;
    uint32_t v34 = v2;
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v4, &type, &v24)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v5);
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v32 = "networkd_settings_update_from_token";
      __int16 v33 = 1024;
      uint32_t v34 = v2;
      os_log_type_t v8 = "%{public}s notify_get_state(settings) failed: %u";
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v11);
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          BOOL v32 = "networkd_settings_update_from_token";
          __int16 v33 = 1024;
          uint32_t v34 = v2;
          __int16 v35 = 2082;
          id v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s notify_get_state(settings) failed: %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_23;
      }
      if (!v12)
      {
LABEL_23:
        if (v4) {
          free(v4);
        }
        return;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v32 = "networkd_settings_update_from_token";
      __int16 v33 = 1024;
      uint32_t v34 = v2;
      os_log_type_t v8 = "%{public}s notify_get_state(settings) failed: %u, no backtrace";
    }
    else
    {
      uint64_t v14 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v14);
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v32 = "networkd_settings_update_from_token";
      __int16 v33 = 1024;
      uint32_t v34 = v2;
      os_log_type_t v8 = "%{public}s notify_get_state(settings) failed: %u, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x12u);
    goto LABEL_23;
  }
  pthread_mutex_lock(&sSettingsMutex);
  uint64_t v9 = state64;
  if (state64 == sCachedHash)
  {
    if (state64)
    {
      pthread_mutex_unlock(&sSettingsMutex);
      sCachedHash = state64;
      return;
    }
    goto LABEL_19;
  }
  if ((state64 & 0xFFFFFFFFFFFE0000) == (sCachedHash & 0xFFFFFFFFFFFE0000))
  {
    os_log_type_t v13 = (void *)sCachedSettings;
LABEL_28:
    xpc_object_t v15 = nw_settings_add_settings_from_bitmask(v13, v9);
    sCachedSettings = (uint64_t)v15;
    goto LABEL_29;
  }
  if ((state64 & 0xFFFFFFFFFFFE0000) == 0)
  {
    if (sCachedSettings)
    {
      xpc_release((xpc_object_t)sCachedSettings);
      sCachedSettings = 0;
      uint64_t v9 = state64;
    }
    os_log_type_t v13 = 0;
    goto LABEL_28;
  }
LABEL_19:
  networkd_settings_read_from_file();
  xpc_object_t v15 = (xpc_object_t)sCachedSettings;
LABEL_29:
  uint64_t v16 = sBoringSSLUpdateBlock;
  if (sBoringSSLUpdateBlock)
  {
    if (v15)
    {
      BOOL v17 = xpc_dictionary_get_BOOL(v15, (const char *)nw_setting_boringssl_log_debug);
      uint64_t v16 = sBoringSSLUpdateBlock;
    }
    else
    {
      BOOL v17 = 0;
    }
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    id v18 = (id)nw_context_copy_implicit_context::implicit_context;
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 0x40000000;
    v28[2] = ___ZL35networkd_settings_update_from_tokeni_block_invoke;
    v28[3] = &unk_1E524BC58;
    v28[4] = v16;
    BOOL v29 = v17;
    nw_queue_context_async(v18, v28);
    xpc_object_t v15 = (xpc_object_t)sCachedSettings;
  }
  uint64_t v19 = sQUICUpdateBlock;
  if (sQUICUpdateBlock)
  {
    if (v15)
    {
      BOOL v20 = xpc_dictionary_get_BOOL(v15, (const char *)nw_setting_libnetcore_datapath_debug);
      uint64_t v19 = sQUICUpdateBlock;
    }
    else
    {
      BOOL v20 = 0;
    }
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    id v21 = (id)nw_context_copy_implicit_context::implicit_context;
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 0x40000000;
    v26[2] = ___ZL35networkd_settings_update_from_tokeni_block_invoke_2;
    v26[3] = &unk_1E524BC80;
    void v26[4] = v19;
    BOOL v27 = v20;
    nw_queue_context_async(v21, v26);
    xpc_object_t v15 = (xpc_object_t)sCachedSettings;
  }
  if (v15) {
    BOOL v22 = xpc_dictionary_get_BOOL(v15, (const char *)nw_setting_libnetcore_datapath_debug);
  }
  else {
    BOOL v22 = 0;
  }
  pthread_mutex_unlock(&sSettingsMutex);
  sCachedHash = state64;
  uint64_t v23 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v23);
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  if (v22 || !gLogDatapathOverridden) {
    gLogDatapath = v22;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
}

void networkd_settings_read_from_file(void)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (sCachedSettings)
  {
    xpc_release((xpc_object_t)sCachedSettings);
    sCachedSettings = 0;
  }
  int v0 = open((const char *)nw_file_path_settings, 0);
  if (v0 != -1)
  {
    int v1 = v0;
    memset(&v67, 0, sizeof(v67));
    if (fstat(v0, &v67))
    {
      int v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      uint64_t v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v3);
      *(_DWORD *)buf = 136446466;
      char v64 = "networkd_settings_read_from_file";
      __int16 v65 = 1024;
      *(_DWORD *)__int16 v66 = v2;
      id v4 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v61 = 0;
      if (__nwlog_fault(v4, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v5);
          uint64_t v6 = gLogObj;
          os_log_type_t v7 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446466;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 1024;
            *(_DWORD *)__int16 v66 = v2;
            os_log_type_t v8 = "%{public}s networkd settings fstat failed %{darwin.errno}d";
LABEL_40:
            _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x12u);
          }
        }
        else if (v61)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v20 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v20);
          uint64_t v6 = gLogObj;
          os_log_type_t v7 = type;
          BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v21)
            {
              *(_DWORD *)buf = 136446722;
              char v64 = "networkd_settings_read_from_file";
              __int16 v65 = 1024;
              *(_DWORD *)__int16 v66 = v2;
              *(_WORD *)&v66[4] = 2082;
              *(void *)&v66[6] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s networkd settings fstat failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(backtrace_string);
            goto LABEL_41;
          }
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 1024;
            *(_DWORD *)__int16 v66 = v2;
            os_log_type_t v8 = "%{public}s networkd settings fstat failed %{darwin.errno}d, no backtrace";
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v28 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v28);
          uint64_t v6 = gLogObj;
          os_log_type_t v7 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446466;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 1024;
            *(_DWORD *)__int16 v66 = v2;
            os_log_type_t v8 = "%{public}s networkd settings fstat failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_40;
          }
        }
      }
LABEL_41:
      if (v4) {
        free(v4);
      }
      st_size_t size = 0;
      goto LABEL_44;
    }
    st_size_t size = v67.st_size;
    if ((unint64_t)(v67.st_size - 1) > 0xFFFE)
    {
LABEL_44:
      uint64_t v35 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v35);
      id v36 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        char v64 = "networkd_settings_read_from_file";
        __int16 v65 = 2048;
        *(void *)__int16 v66 = st_size;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_ERROR, "%{public}s networkd settings file length %lld is invalid", buf, 0x16u);
      }
      goto LABEL_86;
    }
    os_log_type_t v13 = malloc_type_malloc(v67.st_size, 0xF2B69DE5uLL);
    if (v13)
    {
      uint64_t v14 = v13;
      ssize_t v15 = pread(v1, v13, st_size, 0);
      if (v15 == st_size)
      {
        uint64_t v16 = xpc_create_from_plist();
        sCachedSettings = v16;
        uint64_t v17 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v17);
        id v18 = gLogObj;
        if (v16)
        {
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            char v64 = "networkd_settings_read_from_file";
            _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEFAULT, "%{public}s initialized networkd settings by reading plist directly", buf, 0xCu);
          }
          goto LABEL_85;
        }
        *(_DWORD *)buf = 136446210;
        char v64 = "networkd_settings_read_from_file";
        uint64_t v38 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v61 = 0;
        if (__nwlog_fault(v38, &type, &v61))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            BOOL v39 = __nwlog_obj();
            os_log_type_t v40 = type;
            if (!os_log_type_enabled(v39, type)) {
              goto LABEL_83;
            }
            *(_DWORD *)buf = 136446210;
            char v64 = "networkd_settings_read_from_file";
            BOOL v41 = "%{public}s xpc_create_from_plist failed";
          }
          else if (v61)
          {
            __int16 v46 = (char *)__nw_create_backtrace_string();
            BOOL v39 = __nwlog_obj();
            os_log_type_t v40 = type;
            BOOL v47 = os_log_type_enabled(v39, type);
            if (v46)
            {
              if (v47)
              {
                *(_DWORD *)buf = 136446466;
                char v64 = "networkd_settings_read_from_file";
                __int16 v65 = 2082;
                *(void *)__int16 v66 = v46;
                _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s xpc_create_from_plist failed, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v46);
              if (!v38) {
                goto LABEL_85;
              }
              goto LABEL_84;
            }
            if (!v47) {
              goto LABEL_83;
            }
            *(_DWORD *)buf = 136446210;
            char v64 = "networkd_settings_read_from_file";
            BOOL v41 = "%{public}s xpc_create_from_plist failed, no backtrace";
          }
          else
          {
            BOOL v39 = __nwlog_obj();
            os_log_type_t v40 = type;
            if (!os_log_type_enabled(v39, type)) {
              goto LABEL_83;
            }
            *(_DWORD *)buf = 136446210;
            char v64 = "networkd_settings_read_from_file";
            BOOL v41 = "%{public}s xpc_create_from_plist failed, backtrace limit exceeded";
          }
          uint64_t v50 = v39;
          os_log_type_t v51 = v40;
          uint32_t v52 = 12;
          goto LABEL_82;
        }
      }
      else
      {
        ssize_t v32 = v15;
        if ((v15 & 0x8000000000000000) == 0)
        {
          uint64_t v33 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v33);
          uint32_t v34 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 2048;
            *(void *)__int16 v66 = v32;
            *(_WORD *)&v66[8] = 2048;
            *(void *)&unsigned char v66[10] = st_size;
            _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_ERROR, "%{public}s networkd settings file read invalid length %llu != fstat length %llu", buf, 0x20u);
          }
          goto LABEL_85;
        }
        int v42 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        uint64_t v43 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v43);
        *(_DWORD *)buf = 136446466;
        char v64 = "networkd_settings_read_from_file";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = v42;
        uint64_t v38 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v61 = 0;
        if (__nwlog_fault(v38, &type, &v61))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            id v44 = __nwlog_obj();
            os_log_type_t v45 = type;
            if (!os_log_type_enabled(v44, type)) {
              goto LABEL_83;
            }
            *(_DWORD *)buf = 136446466;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 1024;
            *(_DWORD *)__int16 v66 = v42;
            BOOL v41 = "%{public}s networkd settings file pread failed %{darwin.errno}d";
          }
          else if (v61)
          {
            __int16 v48 = (char *)__nw_create_backtrace_string();
            id v44 = __nwlog_obj();
            os_log_type_t v45 = type;
            BOOL v49 = os_log_type_enabled(v44, type);
            if (v48)
            {
              if (v49)
              {
                *(_DWORD *)buf = 136446722;
                char v64 = "networkd_settings_read_from_file";
                __int16 v65 = 1024;
                *(_DWORD *)__int16 v66 = v42;
                *(_WORD *)&v66[4] = 2082;
                *(void *)&v66[6] = v48;
                _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s networkd settings file pread failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(v48);
              goto LABEL_83;
            }
            if (!v49) {
              goto LABEL_83;
            }
            *(_DWORD *)buf = 136446466;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 1024;
            *(_DWORD *)__int16 v66 = v42;
            BOOL v41 = "%{public}s networkd settings file pread failed %{darwin.errno}d, no backtrace";
          }
          else
          {
            id v44 = __nwlog_obj();
            os_log_type_t v45 = type;
            if (!os_log_type_enabled(v44, type)) {
              goto LABEL_83;
            }
            *(_DWORD *)buf = 136446466;
            char v64 = "networkd_settings_read_from_file";
            __int16 v65 = 1024;
            *(_DWORD *)__int16 v66 = v42;
            BOOL v41 = "%{public}s networkd settings file pread failed %{darwin.errno}d, backtrace limit exceeded";
          }
          uint64_t v50 = v44;
          os_log_type_t v51 = v45;
          uint32_t v52 = 18;
LABEL_82:
          _os_log_impl(&dword_1830D4000, v50, v51, v41, buf, v52);
        }
      }
LABEL_83:
      if (v38) {
LABEL_84:
      }
        free(v38);
LABEL_85:
      free(v14);
      goto LABEL_86;
    }
    uint64_t v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    char v64 = "strict_malloc";
    __int16 v65 = 2048;
    *(void *)__int16 v66 = st_size;
    nw_endpoint_t v55 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v55))
    {
      __break(1u);
      return;
    }
    free(v55);
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    char v64 = "networkd_settings_read_from_file";
    __int16 v65 = 2048;
    *(void *)__int16 v66 = st_size;
    uint64_t v14 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault((const char *)v14, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v56 = __nwlog_obj();
        os_log_type_t v57 = type;
        if (!os_log_type_enabled(v56, type)) {
          goto LABEL_105;
        }
        *(_DWORD *)buf = 136446466;
        char v64 = "networkd_settings_read_from_file";
        __int16 v65 = 2048;
        *(void *)__int16 v66 = st_size;
        os_log_type_t v58 = "%{public}s malloc(%lld) failed";
LABEL_104:
        _os_log_impl(&dword_1830D4000, v56, v57, v58, buf, 0x16u);
        goto LABEL_105;
      }
      if (!v61)
      {
        os_log_type_t v56 = __nwlog_obj();
        os_log_type_t v57 = type;
        if (!os_log_type_enabled(v56, type)) {
          goto LABEL_105;
        }
        *(_DWORD *)buf = 136446466;
        char v64 = "networkd_settings_read_from_file";
        __int16 v65 = 2048;
        *(void *)__int16 v66 = st_size;
        os_log_type_t v58 = "%{public}s malloc(%lld) failed, backtrace limit exceeded";
        goto LABEL_104;
      }
      uint64_t v59 = (char *)__nw_create_backtrace_string();
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      BOOL v60 = os_log_type_enabled(v56, type);
      if (!v59)
      {
        if (!v60) {
          goto LABEL_105;
        }
        *(_DWORD *)buf = 136446466;
        char v64 = "networkd_settings_read_from_file";
        __int16 v65 = 2048;
        *(void *)__int16 v66 = st_size;
        os_log_type_t v58 = "%{public}s malloc(%lld) failed, no backtrace";
        goto LABEL_104;
      }
      if (v60)
      {
        *(_DWORD *)buf = 136446722;
        char v64 = "networkd_settings_read_from_file";
        __int16 v65 = 2048;
        *(void *)__int16 v66 = st_size;
        *(_WORD *)&v66[8] = 2082;
        *(void *)&unsigned char v66[10] = v59;
        _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s malloc(%lld) failed, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v59);
    }
LABEL_105:
    if (!v14)
    {
LABEL_86:
      close(v1);
      if (sCachedSettings)
      {
        xpc_object_t dictionary = xpc_dictionary_get_dictionary((xpc_object_t)sCachedSettings, (const char *)nw_settings_managed_settings);
        if (dictionary) {
          xpc_dictionary_apply(dictionary, &__block_literal_global_15_90075);
        }
      }
      return;
    }
    goto LABEL_85;
  }
  int v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v9 == 2) {
    return;
  }
  if (v9 == 1)
  {
    uint64_t v10 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v10);
    uint64_t v11 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v67.st_dev = 136446466;
      *(void *)&v67.st_uint64_t mode = "networkd_settings_read_from_file";
      WORD2(v67.st_ino) = 2082;
      *(__darwin_ino64_t *)((char *)&v67.st_ino + 6) = nw_file_path_settings;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s Sandbox is preventing this process from reading networkd settings file at \"%{public}s\", please add an exception.", (uint8_t *)&v67, 0x16u);
    }
    return;
  }
  uint64_t v22 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v22);
  v67.st_dev = 136446466;
  *(void *)&v67.st_uint64_t mode = "networkd_settings_read_from_file";
  WORD2(v67.st_ino) = 1024;
  *(_DWORD *)((char *)&v67.st_ino + 6) = v9;
  uint64_t v23 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v23, buf, &type))
  {
    if (buf[0] == 17)
    {
      uint64_t v24 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v24);
      uint64_t v25 = gLogObj;
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0])) {
        goto LABEL_59;
      }
      v67.st_dev = 136446466;
      *(void *)&v67.st_uint64_t mode = "networkd_settings_read_from_file";
      WORD2(v67.st_ino) = 1024;
      *(_DWORD *)((char *)&v67.st_ino + 6) = v9;
      BOOL v27 = "%{public}s networkd settings file open failed %{darwin.errno}d";
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v37 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v37);
      uint64_t v25 = gLogObj;
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0])) {
        goto LABEL_59;
      }
      v67.st_dev = 136446466;
      *(void *)&v67.st_uint64_t mode = "networkd_settings_read_from_file";
      WORD2(v67.st_ino) = 1024;
      *(_DWORD *)((char *)&v67.st_ino + 6) = v9;
      BOOL v27 = "%{public}s networkd settings file open failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_58;
    }
    BOOL v29 = (char *)__nw_create_backtrace_string();
    uint64_t v30 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v30);
    uint64_t v25 = gLogObj;
    os_log_type_t v26 = buf[0];
    BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]);
    if (v29)
    {
      if (v31)
      {
        v67.st_dev = 136446722;
        *(void *)&v67.st_uint64_t mode = "networkd_settings_read_from_file";
        WORD2(v67.st_ino) = 1024;
        *(_DWORD *)((char *)&v67.st_ino + 6) = v9;
        HIWORD(v67.st_uid) = 2082;
        *(void *)&v67.st_gid = v29;
        _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s networkd settings file open failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v67, 0x1Cu);
      }
      free(v29);
      goto LABEL_59;
    }
    if (v31)
    {
      v67.st_dev = 136446466;
      *(void *)&v67.st_uint64_t mode = "networkd_settings_read_from_file";
      WORD2(v67.st_ino) = 1024;
      *(_DWORD *)((char *)&v67.st_ino + 6) = v9;
      BOOL v27 = "%{public}s networkd settings file open failed %{darwin.errno}d, no backtrace";
LABEL_58:
      _os_log_impl(&dword_1830D4000, v25, v26, v27, (uint8_t *)&v67, 0x12u);
    }
  }
LABEL_59:
  if (v23) {
    free(v23);
  }
}

void nw_protocol_instance_set_limit_outbound_data(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 64;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 402) = *((unsigned char *)v3 + 402) & 0xBF | v5;
    goto LABEL_6;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_protocol_instance_set_limit_outbound_data";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_protocol_instance_set_limit_outbound_data";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

double ___ZL34nw_flow_initialize_replay_protocolv_block_invoke()
{
  unk_1EB267254 = 0;
  unk_1EB26724C = 0;
  dword_1EB26725C = 0;
  strcpy((char *)&g_replay_protocol_identifier, "flow_replay");
  *(void *)&double result = 0x300000004;
  qword_1EB267260 = 0x300000004;
  qword_1EB267138 = (uint64_t)nw_protocol_default_replace_input_handler;
  qword_1EB267168 = (uint64_t)nw_protocol_default_input_available;
  qword_1EB2671E0 = (uint64_t)nw_protocol_default_input_finished;
  qword_1EB267230 = (uint64_t)nw_protocol_default_input_flush;
  qword_1EB267190 = (uint64_t)nw_protocol_default_link_state;
  qword_1EB267198 = (uint64_t)nw_protocol_default_get_parameters;
  qword_1EB2671A8 = (uint64_t)nw_protocol_default_get_local;
  qword_1EB2671B0 = (uint64_t)nw_protocol_default_get_remote;
  qword_1EB2671A0 = (uint64_t)nw_protocol_default_get_path;
  qword_1EB2671F0 = (uint64_t)nw_protocol_default_get_output_local;
  qword_1EB2671F8 = (uint64_t)nw_protocol_default_get_output_interface;
  qword_1EB267150 = (uint64_t)nw_protocol_default_connected;
  qword_1EB267160 = (uint64_t)nw_protocol_default_error;
  qword_1EB267228 = (uint64_t)nw_protocol_default_reset;
  qword_1EB267208 = (uint64_t)nw_protocol_default_copy_info;
  qword_1EB2671C8 = (uint64_t)nw_protocol_default_notify;
  qword_1EB267210 = (uint64_t)nw_protocol_default_add_listen_handler;
  qword_1EB267218 = (uint64_t)nw_protocol_default_remove_listen_handler;
  g_replay_protocol_callbacks = (uint64_t)nw_flow_replay_add_input_handler;
  qword_1EB267130 = (uint64_t)nw_flow_replay_remove_input_handler;
  qword_1EB267178 = (uint64_t)nw_flow_replay_get_input_frames;
  qword_1EB267180 = (uint64_t)nw_flow_replay_get_output_frames;
  qword_1EB267188 = (uint64_t)nw_flow_replay_finalize_output_frames;
  qword_1EB2671E8 = (uint64_t)nw_flow_replay_output_finished;
  qword_1EB267170 = (uint64_t)nw_flow_replay_output_available;
  qword_1EB2671D0 = (uint64_t)nw_flow_replay_updated_path;
  qword_1EB267140 = (uint64_t)nw_flow_replay_connect;
  qword_1EB267148 = (uint64_t)nw_flow_replay_disconnect;
  qword_1EB267220 = (uint64_t)nw_flow_replay_get_message_properties;
  qword_1EB267200 = (uint64_t)nw_flow_replay_waiting_for_output;
  qword_1EB2671B8 = (uint64_t)nw_flow_replay_register_notification;
  qword_1EB2671C0 = (uint64_t)nw_flow_replay_unregister_notification;
  qword_1EB2671D8 = (uint64_t)nw_flow_passthrough_supports_external_data;
  qword_1EB267158 = (uint64_t)nw_flow_replay_disconnected;
  return result;
}

uint64_t nw_quic_connection_execute_session_state_update_block(void *a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __nw_quic_connection_execute_session_state_update_block_block_invoke;
    v18[3] = &unk_1E5249138;
    id v19 = v6;
    id v20 = v7;
    uint64_t v8 = nw_protocol_options_access_handle(v5, v18);

    goto LABEL_3;
  }
  uint64_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v24 = "nw_quic_connection_execute_session_state_update_block";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v11, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_quic_connection_execute_session_state_update_block";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "nw_quic_connection_execute_session_state_update_block";
          __int16 v25 = 2082;
          os_log_type_t v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_quic_connection_execute_session_state_update_block";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_quic_connection_execute_session_state_update_block";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v11) {
    free(v11);
  }
  uint64_t v8 = 0;
LABEL_3:

  return v8;
}

void sub_1833B7AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_instance_get_sensitive_redacted(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v1 = *(void **)(a1 + 48);
    return nw_parameters_get_sensitive_redacted(v1);
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_instance_get_sensitive_redacted";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_protocol_instance_get_sensitive_redacted";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v4) {
    free(v4);
  }
  return 1;
}

BOOL nw_protocol_instance_get_logging_disabled(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 48);
    return nw_parameters_get_logging_disabled(v1);
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_instance_get_logging_disabled";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_protocol_instance_get_logging_disabled";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v4) {
    free(v4);
  }
  return 1;
}

void ____nwlog_url_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gurlLogObunint64_t j = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "url");
  }
}

void ____nwlog_listener_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    glistenerLogObunint64_t j = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "listener");
  }
}

NWConcrete_nw_agent_client *nw_agent_client_create(unsigned __int8 *a1, void *a2, void *a3)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = [NWConcrete_nw_agent_client alloc];
  os_log_type_t v8 = (atomic_uint *)v5;
  id v9 = v6;
  if (v7)
  {
    if (a1)
    {
      v63.os_log_type_t receiver = v7;
      v63.super_class = (Class)NWConcrete_nw_agent_client;
      id v7 = (NWConcrete_nw_agent_client *)objc_msgSendSuper2(&v63, sel_init);
      if (v7)
      {
        unsigned int v10 = *a1;
        if (v10 > 0x13) {
          goto LABEL_13;
        }
        if (((1 << v10) & 0xCF400) != 0)
        {
          if (*((_DWORD *)a1 + 3) > 0xFu)
          {
            char v11 = a1 + 16;
            if (!uuid_is_null(v11))
            {
              *(_OWORD *)v7->client_uuid = *(_OWORD *)v11;
              BOOL v12 = nw_path_copy_path_for_client_with_context((uint64_t)v11);
              path = v7->path;
              v7->path = (OS_nw_path *)v12;

              char v14 = v7->path;
              if (v14)
              {
                nw_endpoint_t v15 = nw_path_copy_effective_remote_endpoint(v14);
                endpoint = v7->endpoint;
                v7->endpoint = (OS_nw_endpoint *)v15;

                uint64_t v17 = (OS_nw_parameters *)nw_path_copy_parameters(v7->path);
                parameters = v7->parameters;
                v7->parameters = v17;

                id v19 = (OS_nw_advertise_descriptor *)nw_path_copy_advertise_descriptor(v7->path);
                advertise_descriptor = v7->advertise_descriptor;
                v7->advertise_descriptor = v19;

                char v21 = (OS_nw_browse_descriptor *)nw_path_copy_browse_descriptor(v7->path);
                browse_descriptor = v7->browse_descriptor;
                v7->browse_descriptor = v21;

                uint64_t v23 = (OS_nw_group_descriptor *)nw_path_copy_group_descriptor(v7->path);
                group_descriptor = v7->group_descriptor;
                v7->group_descriptor = v23;
              }
            }
            goto LABEL_13;
          }
          uint64_t v38 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          BOOL v39 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v62 = 0;
          if (!__nwlog_fault(v39, &type, &v62)) {
            goto LABEL_73;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)buf = 136446210;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_client_message))", buf, 0xCu);
            }
          }
          else if (v62)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            os_log_type_t v40 = __nwlog_obj();
            os_log_type_t v49 = type;
            BOOL v50 = os_log_type_enabled(v40, type);
            if (backtrace_string)
            {
              if (v50)
              {
                *(_DWORD *)buf = 136446466;
                __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
                __int16 v67 = 2082;
                uint64_t v68 = backtrace_string;
                _os_log_impl(&dword_1830D4000, v40, v49, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_client_message)), dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(backtrace_string);
              goto LABEL_73;
            }
            if (v50)
            {
              *(_DWORD *)buf = 136446210;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              _os_log_impl(&dword_1830D4000, v40, v49, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_client_message)), no backtrace", buf, 0xCu);
            }
          }
          else
          {
            os_log_type_t v40 = __nwlog_obj();
            os_log_type_t v53 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)buf = 136446210;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              _os_log_impl(&dword_1830D4000, v40, v53, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_client_message)), backtrace limit exceeded", buf, 0xCu);
            }
          }

LABEL_73:
          if (v39) {
            free(v39);
          }
LABEL_75:

LABEL_76:
          id v7 = 0;
          goto LABEL_14;
        }
        if (v10 != 5)
        {
LABEL_13:
          atomic_uint v27 = v8[3];
          unsigned int next_id = nw_agent_client_get_next_id(v8 + 4);
          snprintf(v7->log_string, 8uLL, "%u.%u", v27, next_id);
          goto LABEL_14;
        }
        if (*((_DWORD *)a1 + 3) > 0x17u)
        {
          nw_parameters_t v25 = nw_parameters_create();
          os_log_type_t v26 = v7->parameters;
          v7->parameters = (OS_nw_parameters *)v25;

          nw_parameters_set_pid(v7->parameters, *((_DWORD *)a1 + 5));
          nw_parameters_set_e_proc_uuid(v7->parameters, a1 + 24);
          goto LABEL_13;
        }
        uint64_t v54 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
        nw_endpoint_t v55 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v62 = 0;
        if (__nwlog_fault(v55, &type, &v62))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v56 = __nwlog_obj();
            os_log_type_t v57 = type;
            if (os_log_type_enabled(v56, type))
            {
              *(_DWORD *)buf = 136446210;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_trigger_message))", buf, 0xCu);
            }
          }
          else if (v62)
          {
            os_log_type_t v58 = (char *)__nw_create_backtrace_string();
            os_log_type_t v56 = __nwlog_obj();
            os_log_type_t v59 = type;
            BOOL v60 = os_log_type_enabled(v56, type);
            if (v58)
            {
              if (v60)
              {
                *(_DWORD *)buf = 136446466;
                __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
                __int16 v67 = 2082;
                uint64_t v68 = v58;
                _os_log_impl(&dword_1830D4000, v56, v59, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_trigger_message)), dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v58);
              goto LABEL_88;
            }
            if (v60)
            {
              *(_DWORD *)buf = 136446210;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              _os_log_impl(&dword_1830D4000, v56, v59, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_trigger_message)), no backtrace", buf, 0xCu);
            }
          }
          else
          {
            os_log_type_t v56 = __nwlog_obj();
            os_log_type_t v61 = type;
            if (os_log_type_enabled(v56, type))
            {
              *(_DWORD *)buf = 136446210;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              _os_log_impl(&dword_1830D4000, v56, v61, "%{public}s called with null (header->message_payload_length >= sizeof(struct netagent_trigger_message)), backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_88:
        if (v55) {
          free(v55);
        }
        goto LABEL_75;
      }
      uint32_t v34 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
      uint64_t v35 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v62 = 0;
      if (__nwlog_fault(v35, &type, &v62))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          id v36 = __nwlog_obj();
          os_log_type_t v37 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v62)
        {
          os_log_type_t v45 = (char *)__nw_create_backtrace_string();
          id v36 = __nwlog_obj();
          os_log_type_t v46 = type;
          BOOL v47 = os_log_type_enabled(v36, type);
          if (v45)
          {
            if (v47)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              __int16 v67 = 2082;
              uint64_t v68 = v45;
              _os_log_impl(&dword_1830D4000, v36, v46, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v45);
            goto LABEL_63;
          }
          if (v47)
          {
            *(_DWORD *)buf = 136446210;
            __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            _os_log_impl(&dword_1830D4000, v36, v46, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          id v36 = __nwlog_obj();
          os_log_type_t v52 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            _os_log_impl(&dword_1830D4000, v36, v52, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_63:
      if (v35) {
        free(v35);
      }
      goto LABEL_76;
    }
    uint64_t v30 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v63.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v31, &v63, &type))
    {
      if (LOBYTE(v63.receiver) == 17)
      {
        ssize_t v32 = __nwlog_obj();
        os_log_type_t receiver = (os_log_type_t)v63.receiver;
        if (os_log_type_enabled(v32, (os_log_type_t)v63.receiver))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          _os_log_impl(&dword_1830D4000, v32, receiver, "%{public}s called with null message", buf, 0xCu);
        }
      }
      else if (type)
      {
        int v42 = (char *)__nw_create_backtrace_string();
        ssize_t v32 = __nwlog_obj();
        os_log_type_t v43 = (os_log_type_t)v63.receiver;
        BOOL v44 = os_log_type_enabled(v32, (os_log_type_t)v63.receiver);
        if (v42)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            __int16 v67 = 2082;
            uint64_t v68 = v42;
            _os_log_impl(&dword_1830D4000, v32, v43, "%{public}s called with null message, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v42);
          goto LABEL_57;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          _os_log_impl(&dword_1830D4000, v32, v43, "%{public}s called with null message, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        ssize_t v32 = __nwlog_obj();
        os_log_type_t v51 = (os_log_type_t)v63.receiver;
        if (os_log_type_enabled(v32, (os_log_type_t)v63.receiver))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          _os_log_impl(&dword_1830D4000, v32, v51, "%{public}s called with null message, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_57:
    if (v31) {
      free(v31);
    }

    goto LABEL_76;
  }
LABEL_14:

  return v7;
}

void sub_1833B8B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_copy_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    id v3 = v1[2];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_path_copy_parameters";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_path_copy_parameters";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_copy_path_for_client(uint64_t a1)
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v2 = (id)nw_context_copy_implicit_context::implicit_context;
  BOOL v3 = nw_path_copy_path_for_client_with_context(a1);

  return v3;
}

void sub_1833B8EBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_copy_path_for_client_with_context(uint64_t a1)
{
  uint64_t v1 = (unsigned __int8 *)MEMORY[0x1F4188790](a1);
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v3 = v2;
  if (uuid_is_null(v1))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
    id v5 = (char *)_os_log_send_and_compose_impl();

    v62[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v5, v62, &v63)) {
      goto LABEL_112;
    }
    if (v62[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v7 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null client_id", buf, 0xCu);
      }
    }
    else if ((_BYTE)v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v13 = v62[0];
      BOOL v14 = os_log_type_enabled(v6, v62[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
          __int16 v60 = 2082;
          v61[0] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v13, "%{public}s called with null client_id, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v5) {
          goto LABEL_114;
        }
        goto LABEL_113;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_1830D4000, v6, v13, "%{public}s called with null client_id, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v17 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_1830D4000, v6, v17, "%{public}s called with null client_id, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_70:

    goto LABEL_112;
  }
  if ((nw_path_shared_necp_observer_fd(v3) & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
    id v5 = (char *)_os_log_send_and_compose_impl();

    v62[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v5, v62, &v63)) {
      goto LABEL_112;
    }
    if (v62[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v16 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_1830D4000, v6, v16, "%{public}s nw_path_shared_necp_observer_fd failed", buf, 0xCu);
      }
    }
    else if ((_BYTE)v63)
    {
      char v21 = __nw_create_backtrace_string();
      if (v21)
      {
        uint64_t v22 = (char *)v21;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = (id)gLogObj;
        os_log_type_t v24 = v62[0];
        if (os_log_type_enabled(v23, v62[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
          __int16 v60 = 2082;
          v61[0] = v22;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s nw_path_shared_necp_observer_fd failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        if (!v5) {
          goto LABEL_114;
        }
        goto LABEL_113;
      }
      id v6 = __nwlog_obj();
      os_log_type_t v38 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_1830D4000, v6, v38, "%{public}s nw_path_shared_necp_observer_fd failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      os_log_type_t v30 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_1830D4000, v6, v30, "%{public}s nw_path_shared_necp_observer_fd failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_70;
  }
  bzero(v62, 0x400uLL);
  int v8 = necp_client_action();
  if (v8 <= 0)
  {
    int v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (id)gLogObj;
    id v20 = v19;
    if (v18 == 2)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
        __int16 v60 = 1024;
        LODWORD(v61[0]) = 2;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_114;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
    __int16 v60 = 1024;
    LODWORD(v61[0]) = v18;
    id v5 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v63) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v5, &v63, &type))
    {
      if (v63 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v28 = (id)gLogObj;
        os_log_type_t v29 = v63;
        if (os_log_type_enabled(v28, (os_log_type_t)v63))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
          __int16 v60 = 1024;
          LODWORD(v61[0]) = v18;
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (type)
      {
        BOOL v31 = (char *)__nw_create_backtrace_string();
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v32 = v63;
        BOOL v33 = os_log_type_enabled(v28, (os_log_type_t)v63);
        if (v31)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
            __int16 v60 = 1024;
            LODWORD(v61[0]) = v18;
            WORD2(v61[0]) = 2082;
            *(void *)((char *)v61 + 6) = v31;
            _os_log_impl(&dword_1830D4000, v28, v32, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          goto LABEL_76;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
          __int16 v60 = 1024;
          LODWORD(v61[0]) = v18;
          _os_log_impl(&dword_1830D4000, v28, v32, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v41 = v63;
        if (os_log_type_enabled(v28, (os_log_type_t)v63))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_path_copy_path_for_client_with_context";
          __int16 v60 = 1024;
          LODWORD(v61[0]) = v18;
          _os_log_impl(&dword_1830D4000, v28, v41, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
LABEL_112:
    if (!v5)
    {
LABEL_114:
      BOOL v11 = 0;
LABEL_115:

      return (BOOL)v11;
    }
LABEL_113:
    free(v5);
    goto LABEL_114;
  }
  bzero(buf, 0x1800uLL);
  int v9 = necp_client_action();
  if (v9 > 0)
  {
    id v5 = 0;
    os_log_type_t v10 = buf;
    goto LABEL_11;
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  int v26 = **(_DWORD **)(StatusReg + 8);
  if (v26 != 22)
  {
    if (v26 == 2)
    {
      atomic_uint v27 = __nwlog_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        int v63 = 136446466;
        char v64 = "nw_path_copy_path_for_client_with_context";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = 2;
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
      }

      goto LABEL_114;
    }
    uint64_t v35 = __nwlog_obj();
    int v63 = 136446466;
    char v64 = "nw_path_copy_path_for_client_with_context";
    __int16 v65 = 1024;
    *(_DWORD *)__int16 v66 = v26;
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v56 = 0;
    if (__nwlog_fault(v5, &type, &v56))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          int v63 = 136446466;
          char v64 = "nw_path_copy_path_for_client_with_context";
          __int16 v65 = 1024;
          *(_DWORD *)__int16 v66 = v26;
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
        }
LABEL_98:

        goto LABEL_112;
      }
      if (!v56)
      {
        id v36 = __nwlog_obj();
        os_log_type_t v48 = type;
        if (os_log_type_enabled(v36, type))
        {
          int v63 = 136446466;
          char v64 = "nw_path_copy_path_for_client_with_context";
          __int16 v65 = 1024;
          *(_DWORD *)__int16 v66 = v26;
          _os_log_impl(&dword_1830D4000, v36, v48, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)&v63, 0x12u);
        }
        goto LABEL_98;
      }
      BOOL v31 = (char *)__nw_create_backtrace_string();
      id v36 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v40 = os_log_type_enabled(v36, type);
      if (!v31)
      {
        if (v40)
        {
          int v63 = 136446466;
          char v64 = "nw_path_copy_path_for_client_with_context";
          __int16 v65 = 1024;
          *(_DWORD *)__int16 v66 = v26;
          _os_log_impl(&dword_1830D4000, v36, v39, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, no backtrace", (uint8_t *)&v63, 0x12u);
        }
        goto LABEL_98;
      }
      if (v40)
      {
        int v63 = 136446722;
        char v64 = "nw_path_copy_path_for_client_with_context";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = v26;
        *(_WORD *)&v66[4] = 2082;
        *(void *)&v66[6] = v31;
        _os_log_impl(&dword_1830D4000, v36, v39, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v63, 0x1Cu);
      }

LABEL_76:
      free(v31);
      if (!v5) {
        goto LABEL_114;
      }
      goto LABEL_113;
    }
    goto LABEL_112;
  }
  uint32_t v34 = __nwlog_obj();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    int v63 = 136446466;
    char v64 = "nw_path_copy_path_for_client_with_context";
    __int16 v65 = 1024;
    *(_DWORD *)__int16 v66 = 48;
    _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s Trying to copy result again for %u flows", (uint8_t *)&v63, 0x12u);
  }

  id v5 = (char *)malloc_type_calloc(1uLL, 0x6400uLL, 0xEAFB8F1AuLL);
  if (v5)
  {
LABEL_61:
    int v9 = necp_client_action();
    if (v9 > 0)
    {
      os_log_type_t v10 = (uint8_t *)v5;
LABEL_11:
      BOOL v11 = nw_path_copy_path_for_tlv(v1, v3, (uint64_t)v62, v8, (uint64_t)v10, v9);
      if (v5) {
        free(v5);
      }
      goto LABEL_115;
    }
    int v42 = **(_DWORD **)(StatusReg + 8);
    os_log_type_t v43 = __nwlog_obj();
    BOOL v44 = v43;
    if (v42 == 2)
    {
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        int v63 = 136446466;
        char v64 = "nw_path_copy_path_for_client_with_context";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = 2;
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
      }

      goto LABEL_112;
    }
    int v63 = 136446466;
    char v64 = "nw_path_copy_path_for_client_with_context";
    __int16 v65 = 1024;
    *(_DWORD *)__int16 v66 = v42;
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v56 = 0;
    if (!__nwlog_fault(v45, &type, &v56)) {
      goto LABEL_110;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v46 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        int v63 = 136446466;
        char v64 = "nw_path_copy_path_for_client_with_context";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = v42;
        _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
      }
    }
    else if (v56)
    {
      os_log_type_t v49 = (char *)__nw_create_backtrace_string();
      os_log_type_t v46 = __nwlog_obj();
      os_log_type_t v50 = type;
      BOOL v51 = os_log_type_enabled(v46, type);
      if (v49)
      {
        if (v51)
        {
          int v63 = 136446722;
          char v64 = "nw_path_copy_path_for_client_with_context";
          __int16 v65 = 1024;
          *(_DWORD *)__int16 v66 = v42;
          *(_WORD *)&v66[4] = 2082;
          *(void *)&v66[6] = v49;
          _os_log_impl(&dword_1830D4000, v46, v50, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v63, 0x1Cu);
        }

        free(v49);
        goto LABEL_110;
      }
      if (v51)
      {
        int v63 = 136446466;
        char v64 = "nw_path_copy_path_for_client_with_context";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = v42;
        _os_log_impl(&dword_1830D4000, v46, v50, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, no backtrace", (uint8_t *)&v63, 0x12u);
      }
    }
    else
    {
      os_log_type_t v46 = __nwlog_obj();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v46, type))
      {
        int v63 = 136446466;
        char v64 = "nw_path_copy_path_for_client_with_context";
        __int16 v65 = 1024;
        *(_DWORD *)__int16 v66 = v42;
        _os_log_impl(&dword_1830D4000, v46, v52, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)&v63, 0x12u);
      }
    }

LABEL_110:
    if (v45) {
      free(v45);
    }
    goto LABEL_112;
  }
  uint64_t v54 = __nwlog_obj();
  os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
  int v63 = 136446722;
  char v64 = "strict_calloc";
  __int16 v65 = 2048;
  *(void *)__int16 v66 = 1;
  *(_WORD *)&v66[8] = 2048;
  *(void *)&unsigned char v66[10] = 25600;
  nw_endpoint_t v55 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v55);
  if (!result)
  {
    free(v55);
    goto LABEL_61;
  }
  __break(1u);
  return result;
}

void sub_1833B9F3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path *nw_path_copy_path_for_tlv(_OWORD *a1, void *a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  id v11 = a2;
  if (!v11)
  {
    os_log_type_t v52 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v81 = "nw_path_copy_path_for_tlv";
    os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

    v79[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(obj) = 0;
    if (!__nwlog_fault(v53, v79, &obj)) {
      goto LABEL_157;
    }
    if (v79[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v55 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s called with null context", buf, 0xCu);
      }
      goto LABEL_156;
    }
    if (!(_BYTE)obj)
    {
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v68 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v68, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_156;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v54 = __nwlog_obj();
    os_log_type_t v61 = v79[0];
    BOOL v62 = os_log_type_enabled(v54, v79[0]);
    if (!backtrace_string)
    {
      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v61, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
      goto LABEL_156;
    }
    if (v62)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v81 = "nw_path_copy_path_for_tlv";
      __int16 v82 = 2082;
      nw_endpoint_t v83 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v54, v61, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_132;
  }
  if (!a3)
  {
    char v56 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v81 = "nw_path_copy_path_for_tlv";
    os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

    v79[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(obj) = 0;
    if (!__nwlog_fault(v53, v79, &obj)) {
      goto LABEL_157;
    }
    if (v79[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v57 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v57, "%{public}s called with null parameters_buffer", buf, 0xCu);
      }
      goto LABEL_156;
    }
    if (!(_BYTE)obj)
    {
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v69 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v69, "%{public}s called with null parameters_buffer, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_156;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v54 = __nwlog_obj();
    os_log_type_t v63 = v79[0];
    BOOL v64 = os_log_type_enabled(v54, v79[0]);
    if (!backtrace_string)
    {
      if (v64)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v63, "%{public}s called with null parameters_buffer, no backtrace", buf, 0xCu);
      }
      goto LABEL_156;
    }
    if (v64)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v81 = "nw_path_copy_path_for_tlv";
      __int16 v82 = 2082;
      nw_endpoint_t v83 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v54, v63, "%{public}s called with null parameters_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_132:

    free(backtrace_string);
    if (!v53) {
      goto LABEL_159;
    }
    goto LABEL_158;
  }
  if (!a4)
  {
    os_log_type_t v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v81 = "nw_path_copy_path_for_tlv";
    os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

    v79[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(obj) = 0;
    if (!__nwlog_fault(v53, v79, &obj)) {
      goto LABEL_157;
    }
    if (v79[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v59 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v59, "%{public}s called with null parameters_buffer_size", buf, 0xCu);
      }
    }
    else if ((_BYTE)obj)
    {
      __int16 v65 = (char *)__nw_create_backtrace_string();
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v66 = v79[0];
      BOOL v67 = os_log_type_enabled(v54, v79[0]);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          __int16 v82 = 2082;
          nw_endpoint_t v83 = v65;
          _os_log_impl(&dword_1830D4000, v54, v66, "%{public}s called with null parameters_buffer_size, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v65);
LABEL_157:
        if (!v53)
        {
LABEL_159:
          browse = 0;
          goto LABEL_70;
        }
LABEL_158:
        free(v53);
        goto LABEL_159;
      }
      if (v67)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v66, "%{public}s called with null parameters_buffer_size, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v54 = __nwlog_obj();
      os_log_type_t v70 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v54, v70, "%{public}s called with null parameters_buffer_size, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_156:

    goto LABEL_157;
  }
  nw_parameters_t v12 = nw_parameters_create();
  nw_parameters_t v13 = v12;
  if (v12)
  {
    nw_parameters_set_context(v12, v11);
    id obj = 0;
    *(void *)os_log_type_t v79 = 0;
    id v76 = 0;
    id v77 = 0;
    char v75 = 0;
    unsigned __int16 v74 = 0;
    __int16 v73 = 0;
    if ((nw_path_parse_necp_parameters(v13, (void **)v79, &obj, &v77, &v76, &v75, &v74, (char *)&v73 + 1, &v73, a3, a4) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v23 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      uint64_t v81 = "nw_path_copy_path_for_tlv";
      os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v71 = 0;
      if (!__nwlog_fault(v16, &type, &v71)) {
        goto LABEL_65;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v17 = (id)gLogObj;
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_1830D4000, v17, v24, "%{public}s nw_path_parse_necp_parameters failed", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (!v71)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v17 = (id)gLogObj;
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_1830D4000, v17, v33, "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_64;
      }
      uint64_t v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = (id)gLogObj;
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v17, type);
      if (!v28)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s nw_path_parse_necp_parameters failed, no backtrace", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        __int16 v82 = 2082;
        nw_endpoint_t v83 = v28;
        _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_33;
    }
    if (v77)
    {
      browse = nw_path_create_browse(v77, v13);
      if (!browse)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v71 = 0;
        if (!__nwlog_fault(v16, &type, &v71)) {
          goto LABEL_65;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v17 = (id)gLogObj;
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s nw_path_create_browse failed", buf, 0xCu);
          }
          goto LABEL_64;
        }
        if (!v71)
        {
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v49 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_1830D4000, v17, v49, "%{public}s nw_path_create_browse failed, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_64;
        }
        uint64_t v28 = (char *)__nw_create_backtrace_string();
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v41 = type;
        BOOL v42 = os_log_type_enabled(v17, type);
        if (!v28)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_1830D4000, v17, v41, "%{public}s nw_path_create_browse failed, no backtrace", buf, 0xCu);
          }
          goto LABEL_64;
        }
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          __int16 v82 = 2082;
          nw_endpoint_t v83 = v28;
          _os_log_impl(&dword_1830D4000, v17, v41, "%{public}s nw_path_create_browse failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_33:

        free(v28);
        if (!v16) {
          goto LABEL_67;
        }
        goto LABEL_66;
      }
    }
    else
    {
      browse = nw_path_create(*(void **)v79, v13);
      if (!browse)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v38 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v71 = 0;
        if (!__nwlog_fault(v16, &type, &v71)) {
          goto LABEL_65;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v17 = (id)gLogObj;
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_1830D4000, v17, v39, "%{public}s nw_path_create failed", buf, 0xCu);
          }
        }
        else if (v71)
        {
          os_log_type_t v46 = (char *)__nw_create_backtrace_string();
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v47 = type;
          BOOL v48 = os_log_type_enabled(v17, type);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v81 = "nw_path_copy_path_for_tlv";
              __int16 v82 = 2082;
              nw_endpoint_t v83 = v46;
              _os_log_impl(&dword_1830D4000, v17, v47, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v46);
            if (!v16) {
              goto LABEL_67;
            }
            goto LABEL_66;
          }
          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_1830D4000, v17, v47, "%{public}s nw_path_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v51 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_1830D4000, v17, v51, "%{public}s nw_path_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
LABEL_64:

LABEL_65:
        if (!v16)
        {
LABEL_67:
          browse = 0;
          goto LABEL_68;
        }
LABEL_66:
        free(v16);
        goto LABEL_67;
      }
    }
    objc_storeStrong((id *)&browse->group_descriptor, obj);
    objc_storeStrong((id *)&browse->advertise_descriptor, v76);
    char v31 = *((unsigned char *)browse + 475) & 0xFC | v75;
    browse->custom_etheros_log_type_t type = v74;
    browse->custom_int ip_protocol = HIBYTE(v73);
    *((unsigned char *)browse + 475) = v31 | (2 * v73);
    *(_OWORD *)browse->client_id = *a1;
    if (!a5 || !a6 || nw_path_parse_necp_result(browse, a5, a6))
    {
      nw_path_snapshot_path(browse);
LABEL_68:

      goto LABEL_69;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v34 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v81 = "nw_path_copy_path_for_tlv";
    uint64_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v71 = 0;
    if (__nwlog_fault(v35, &type, &v71))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v36 = (id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s nw_path_parse_necp_result failed", buf, 0xCu);
        }
      }
      else if (v71)
      {
        os_log_type_t v43 = (char *)__nw_create_backtrace_string();
        id v36 = __nwlog_obj();
        os_log_type_t v44 = type;
        BOOL v45 = os_log_type_enabled(v36, type);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v81 = "nw_path_copy_path_for_tlv";
            __int16 v82 = 2082;
            nw_endpoint_t v83 = v43;
            _os_log_impl(&dword_1830D4000, v36, v44, "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v43);
          goto LABEL_102;
        }
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_1830D4000, v36, v44, "%{public}s nw_path_parse_necp_result failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v36 = __nwlog_obj();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_1830D4000, v36, v50, "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_102:
    if (v35) {
      free(v35);
    }

    goto LABEL_67;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v19 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v81 = "nw_path_copy_path_for_tlv";
  id v20 = (char *)_os_log_send_and_compose_impl();

  v79[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(obj) = 0;
  if (__nwlog_fault(v20, v79, &obj))
  {
    if (v79[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v21 = (id)gLogObj;
      os_log_type_t v22 = v79[0];
      if (os_log_type_enabled(v21, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }
    else if ((_BYTE)obj)
    {
      nw_parameters_t v25 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v21 = (id)gLogObj;
      os_log_type_t v26 = v79[0];
      BOOL v27 = os_log_type_enabled(v21, v79[0]);
      if (v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v81 = "nw_path_copy_path_for_tlv";
          __int16 v82 = 2082;
          nw_endpoint_t v83 = v25;
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v25);
        if (!v20) {
          goto LABEL_61;
        }
        goto LABEL_60;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v21 = (id)gLogObj;
      os_log_type_t v32 = v79[0];
      if (os_log_type_enabled(v21, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
  if (v20) {
LABEL_60:
  }
    free(v20);
LABEL_61:
  browse = 0;
LABEL_69:

LABEL_70:
  return browse;
}

void sub_1833BB31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_shared_necp_observer_fd(void *a1)
{
  *(void *)&v40[5] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  uint64_t globals_for_path = nw_context_get_globals_for_path(v1);
  id v3 = (os_unfair_lock_s *)(globals_for_path + 120);
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 120));
  uint64_t v4 = *(unsigned int *)(globals_for_path + 136);
  if ((v4 & 0x80000000) == 0) {
    goto LABEL_2;
  }
  int v5 = necp_open();
  *(_DWORD *)(globals_for_path + 136) = v5;
  if (v5 < 0)
  {
    int v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    os_unfair_lock_unlock(v3);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    id v36 = "nw_path_shared_necp_observer_fd";
    __int16 v37 = 1024;
    int v38 = v13;
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_path_shared_necp_observer_fd";
          __int16 v37 = 1024;
          int v38 = v13;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s necp_open observer failed %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v33)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          id v23 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v24 = (id)gLogObj;
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446722;
            id v36 = "nw_path_shared_necp_observer_fd";
            __int16 v37 = 1024;
            int v38 = v13;
            __int16 v39 = 2082;
            *(void *)BOOL v40 = v23;
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s necp_open observer failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v23);
          if (!v9) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        id v15 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_path_shared_necp_observer_fd";
          __int16 v37 = 1024;
          int v38 = v13;
          _os_log_impl(&dword_1830D4000, v15, v31, "%{public}s necp_open observer failed %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_path_shared_necp_observer_fd";
          __int16 v37 = 1024;
          int v38 = v13;
          _os_log_impl(&dword_1830D4000, v15, v28, "%{public}s necp_open observer failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
LABEL_40:
    if (!v9)
    {
LABEL_42:
      uint64_t v4 = 0xFFFFFFFFLL;
      goto LABEL_43;
    }
LABEL_41:
    free(v9);
    goto LABEL_42;
  }
  arc4random_buf((void *)(globals_for_path + 16), 8uLL);
  if (change_fdguard_np())
  {
    int v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    close(*(_DWORD *)(globals_for_path + 136));
    *(_DWORD *)(globals_for_path + 136) = -1;
    os_unfair_lock_unlock(v3);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    int v8 = *(_DWORD *)(globals_for_path + 136);
    *(_DWORD *)buf = 136446722;
    id v36 = "nw_path_shared_necp_observer_fd";
    __int16 v37 = 1024;
    int v38 = v8;
    __int16 v39 = 1024;
    v40[0] = v6;
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v12 = *(_DWORD *)(globals_for_path + 136);
          *(_DWORD *)buf = 136446722;
          id v36 = "nw_path_shared_necp_observer_fd";
          __int16 v37 = 1024;
          int v38 = v12;
          __int16 v39 = 1024;
          v40[0] = v6;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s Failed to guard necp observer fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }
      else if (v33)
      {
        os_log_type_t v17 = __nw_create_backtrace_string();
        if (v17)
        {
          os_log_type_t v18 = (char *)v17;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v19 = (id)gLogObj;
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v19, type))
          {
            int v21 = *(_DWORD *)(globals_for_path + 136);
            *(_DWORD *)buf = 136446978;
            id v36 = "nw_path_shared_necp_observer_fd";
            __int16 v37 = 1024;
            int v38 = v21;
            __int16 v39 = 1024;
            v40[0] = v6;
            LOWORD(v40[1]) = 2082;
            *(void *)((char *)&v40[1] + 2) = v18;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s Failed to guard necp observer fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(v18);
          if (!v9) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v30 = *(_DWORD *)(globals_for_path + 136);
          *(_DWORD *)buf = 136446722;
          id v36 = "nw_path_shared_necp_observer_fd";
          __int16 v37 = 1024;
          int v38 = v30;
          __int16 v39 = 1024;
          v40[0] = v6;
          _os_log_impl(&dword_1830D4000, v10, v29, "%{public}s Failed to guard necp observer fd %d %{darwin.errno}d, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (id)gLogObj;
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v27 = *(_DWORD *)(globals_for_path + 136);
          *(_DWORD *)buf = 136446722;
          id v36 = "nw_path_shared_necp_observer_fd";
          __int16 v37 = 1024;
          int v38 = v27;
          __int16 v39 = 1024;
          v40[0] = v6;
          _os_log_impl(&dword_1830D4000, v10, v26, "%{public}s Failed to guard necp observer fd %d %{darwin.errno}d, backtrace limit exceeded", buf, 0x18u);
        }
      }
    }
    goto LABEL_40;
  }
  *(unsigned char *)(globals_for_path + 140) |= 4u;
  uint64_t v4 = *(unsigned int *)(globals_for_path + 136);
LABEL_2:
  os_unfair_lock_unlock(v3);
LABEL_43:

  return v4;
}

void sub_1833BBAB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_copy_group_descriptor(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[4];
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_copy_group_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_group_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_copy_group_descriptor";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_group_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_group_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_copy_browse_descriptor(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[5];
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_copy_browse_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_browse_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_copy_browse_descriptor";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_browse_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_browse_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_copy_advertise_descriptor(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[6];
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_copy_advertise_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_advertise_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_copy_advertise_descriptor";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_advertise_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_advertise_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

atomic_uint *nw_agent_client_get_next_id(atomic_uint *result)
{
  id v1 = result;
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  LODWORD(result) = atomic_fetch_add(result, 1u) + 1;
  if (result >= 0x100 && !(_BYTE)result)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446210;
      uint64_t v4 = "nw_agent_client_get_next_id";
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached maximum agent clients, wrapping", (uint8_t *)&v3, 0xCu);
    }

    LOBYTE(result) = nw_agent_client_get_next_id(v1);
  }
  return (atomic_uint *)result;
}

void nw_path_enumerate_gateways(nw_path_t path, nw_path_enumerate_gateways_block_t enumerate_block)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_path_t v3 = path;
  nw_path_enumerate_gateways_block_t v4 = enumerate_block;
  uint64_t v5 = v4;
  if (!v3)
  {
    id v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_path_enumerate_gateways";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_path_enumerate_gateways";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v26 = "nw_path_enumerate_gateways";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_40:
        free(v8);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_path_enumerate_gateways";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v9 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_path_enumerate_gateways";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    uint64_t isa = (atomic_uchar *)v3[26].isa;
    if (isa)
    {
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_path_enumerate_gateways_block_invoke;
      v21[3] = &unk_1E524AE90;
      id v22 = v4;
      nw_array_apply(isa, (uint64_t)v21);
    }
    goto LABEL_5;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v26 = "nw_path_enumerate_gateways";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23)) {
    goto LABEL_39;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v9 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_path_enumerate_gateways";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    int v9 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_path_enumerate_gateways";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  int v9 = __nwlog_obj();
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_path_enumerate_gateways";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v26 = "nw_path_enumerate_gateways";
    __int16 v27 = 2082;
    os_log_type_t v28 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

void __34__nw_ip_channel_inbox_description__block_invoke(uint64_t a1)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  id v2 = *(void **)(*(void *)(a1 + 32) + 24);
  if (v2) {
    goto LABEL_69;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  nw_path_enumerate_gateways_block_t v4 = (unsigned __int8 *)_os_log_send_and_compose_impl();

  if (v4 == &v72)
  {
LABEL_68:
    CFStringRef v67 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"flow: %@, local: %s, scope: %u, protocol: %u", *(void *)(*(void *)(a1 + 32) + 72), &v72, *(unsigned int *)(*(void *)(a1 + 32) + 160), *(unsigned __int8 *)(*(void *)(a1 + 32) + 166));
    uint64_t v68 = *(void *)(a1 + 32);
    os_log_type_t v69 = *(void **)(v68 + 24);
    *(void *)(v68 + 24) = v67;

    id v2 = *(void **)(*(void *)(a1 + 32) + 24);
LABEL_69:
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v2);
    return;
  }
  if (v4)
  {
LABEL_4:
    int v5 = v72;
    *nw_path_enumerate_gateways_block_t v4 = v72;
    if (v5)
    {
      int v6 = v73;
      v4[1] = v73;
      if (v6)
      {
        int v7 = v74;
        v4[2] = v74;
        if (v7)
        {
          int v8 = v75;
          v4[3] = v75;
          if (v8)
          {
            int v9 = v76;
            v4[4] = v76;
            if (v9)
            {
              int v10 = v77;
              v4[5] = v77;
              if (v10)
              {
                int v11 = v78;
                v4[6] = v78;
                if (v11)
                {
                  int v12 = v79;
                  v4[7] = v79;
                  if (v12)
                  {
                    int v13 = v80;
                    v4[8] = v80;
                    if (v13)
                    {
                      int v14 = v81;
                      v4[9] = v81;
                      if (v14)
                      {
                        int v15 = v82;
                        v4[10] = v82;
                        if (v15)
                        {
                          int v16 = v83;
                          v4[11] = v83;
                          if (v16)
                          {
                            int v17 = v84;
                            v4[12] = v84;
                            if (v17)
                            {
                              int v18 = v85;
                              v4[13] = v85;
                              if (v18)
                              {
                                int v19 = v86;
                                v4[14] = v86;
                                if (v19)
                                {
                                  int v20 = v87;
                                  v4[15] = v87;
                                  if (v20)
                                  {
                                    int v21 = v88;
                                    v4[16] = v88;
                                    if (v21)
                                    {
                                      int v22 = v89;
                                      v4[17] = v89;
                                      if (v22)
                                      {
                                        int v23 = v90;
                                        v4[18] = v90;
                                        if (v23)
                                        {
                                          int v24 = v91;
                                          v4[19] = v91;
                                          if (v24)
                                          {
                                            int v25 = v92;
                                            v4[20] = v92;
                                            if (v25)
                                            {
                                              int v26 = v93;
                                              v4[21] = v93;
                                              if (v26)
                                              {
                                                int v27 = v94;
                                                v4[22] = v94;
                                                if (v27)
                                                {
                                                  int v28 = v95;
                                                  v4[23] = v95;
                                                  if (v28)
                                                  {
                                                    int v29 = v96;
                                                    v4[24] = v96;
                                                    if (v29)
                                                    {
                                                      int v30 = v97;
                                                      v4[25] = v97;
                                                      if (v30)
                                                      {
                                                        int v31 = v98;
                                                        v4[26] = v98;
                                                        if (v31)
                                                        {
                                                          int v32 = v99;
                                                          v4[27] = v99;
                                                          if (v32)
                                                          {
                                                            int v33 = v100;
                                                            v4[28] = v100;
                                                            if (v33)
                                                            {
                                                              int v34 = v101;
                                                              v4[29] = v101;
                                                              if (v34)
                                                              {
                                                                int v35 = v102;
                                                                v4[30] = v102;
                                                                if (v35)
                                                                {
                                                                  int v36 = v103;
                                                                  v4[31] = v103;
                                                                  if (v36)
                                                                  {
                                                                    int v37 = v104;
                                                                    v4[32] = v104;
                                                                    if (v37)
                                                                    {
                                                                      int v38 = v105;
                                                                      v4[33] = v105;
                                                                      if (v38)
                                                                      {
                                                                        int v39 = v106;
                                                                        v4[34] = v106;
                                                                        if (v39)
                                                                        {
                                                                          int v40 = v107;
                                                                          v4[35] = v107;
                                                                          if (v40)
                                                                          {
                                                                            int v41 = v108;
                                                                            v4[36] = v108;
                                                                            if (v41)
                                                                            {
                                                                              int v42 = v109;
                                                                              v4[37] = v109;
                                                                              if (v42)
                                                                              {
                                                                                int v43 = v110;
                                                                                v4[38] = v110;
                                                                                if (v43)
                                                                                {
                                                                                  int v44 = v111;
                                                                                  v4[39] = v111;
                                                                                  if (v44)
                                                                                  {
                                                                                    int v45 = v112;
                                                                                    v4[40] = v112;
                                                                                    if (v45)
                                                                                    {
                                                                                      int v46 = v113;
                                                                                      v4[41] = v113;
                                                                                      if (v46)
                                                                                      {
                                                                                        int v47 = v114;
                                                                                        v4[42] = v114;
                                                                                        if (v47)
                                                                                        {
                                                                                          int v48 = v115;
                                                                                          v4[43] = v115;
                                                                                          if (v48)
                                                                                          {
                                                                                            int v49 = v116;
                                                                                            v4[44] = v116;
                                                                                            if (v49)
                                                                                            {
                                                                                              int v50 = v117;
                                                                                              v4[45] = v117;
                                                                                              if (v50)
                                                                                              {
                                                                                                int v51 = v118;
                                                                                                v4[46] = v118;
                                                                                                if (v51)
                                                                                                {
                                                                                                  int v52 = v119;
                                                                                                  v4[47] = v119;
                                                                                                  if (v52)
                                                                                                  {
                                                                                                    int v53 = v120;
                                                                                                    v4[48] = v120;
                                                                                                    if (v53)
                                                                                                    {
                                                                                                      int v54 = v121;
                                                                                                      v4[49] = v121;
                                                                                                      if (v54)
                                                                                                      {
                                                                                                        int v55 = v122;
                                                                                                        v4[50] = v122;
                                                                                                        if (v55)
                                                                                                        {
                                                                                                          int v56 = v123;
                                                                                                          v4[51] = v123;
                                                                                                          if (v56)
                                                                                                          {
                                                                                                            int v57 = v124;
                                                                                                            v4[52] = v124;
                                                                                                            if (v57)
                                                                                                            {
                                                                                                              int v58 = v125;
                                                                                                              v4[53] = v125;
                                                                                                              if (v58)
                                                                                                              {
                                                                                                                int v59 = v126;
                                                                                                                v4[54] = v126;
                                                                                                                if (v59)
                                                                                                                {
                                                                                                                  int v60 = v127;
                                                                                                                  v4[55] = v127;
                                                                                                                  if (v60)
                                                                                                                  {
                                                                                                                    int v61 = v128;
                                                                                                                    v4[56] = v128;
                                                                                                                    if (v61)
                                                                                                                    {
                                                                                                                      int v62 = v129;
                                                                                                                      v4[57] = v129;
                                                                                                                      if (v62)
                                                                                                                      {
                                                                                                                        int v63 = v130;
                                                                                                                        v4[58] = v130;
                                                                                                                        if (v63)
                                                                                                                        {
                                                                                                                          int v64 = v131;
                                                                                                                          v4[59] = v131;
                                                                                                                          if (v64)
                                                                                                                          {
                                                                                                                            int v65 = v132;
                                                                                                                            v4[60] = v132;
                                                                                                                            if (v65)
                                                                                                                            {
                                                                                                                              int v66 = v133;
                                                                                                                              v4[61] = v133;
                                                                                                                              if (v66) {
                                                                                                                                v4[62] = 0;
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    free(v4);
    goto LABEL_68;
  }
  os_log_type_t v70 = __nwlog_obj();
  os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
  char v71 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v71))
  {
    free(v71);
    goto LABEL_4;
  }
  __break(1u);
}

void nw_http_client_metadata_set_initial_request(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    int v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_http_client_metadata_set_initial_request";
    int v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &type, &v26)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_http_client_metadata_set_initial_request";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          int v29 = "nw_http_client_metadata_set_initial_request";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_8;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_http_client_metadata_set_initial_request";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_http_client_metadata_set_initial_request";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_client_definition_definition);

  if (is_equal_unsafe)
  {
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __nw_http_client_metadata_set_initial_request_block_invoke;
    v24[3] = &unk_1E5248F68;
    id v8 = v4;
    id v25 = v8;
    uint64_t v9 = *((void *)v5 + 4);
    if (v9)
    {
      __nw_http_client_metadata_set_initial_request_block_invoke((uint64_t)v24, v9);
      id v8 = v25;
    }

    goto LABEL_8;
  }
  int v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v29 = "nw_http_client_metadata_set_initial_request";
  int v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v11, &type, &v26)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      int v29 = "nw_http_client_metadata_set_initial_request";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s metadata must be http_client", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v26)
  {
    int v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      int v29 = "nw_http_client_metadata_set_initial_request";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s metadata must be http_client, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  int v19 = (char *)__nw_create_backtrace_string();
  int v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      int v29 = "nw_http_client_metadata_set_initial_request";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    int v29 = "nw_http_client_metadata_set_initial_request";
    __int16 v30 = 2082;
    int v31 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_client, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_43;
  }
LABEL_8:
}